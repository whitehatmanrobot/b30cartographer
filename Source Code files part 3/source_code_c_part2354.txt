pdmci, sizeof(*pdmci) );
    AllocSize = sizeof(WCHAR) * sizeof(pdmci->Name);
    pw = (PWSTR)LocalAlloc( LPTR, AllocSize );

    if ( !pw ) {
        return E_OUTOFMEMORY;
    }

    MultiByteToWideChar( CP_ACP, 0, pdmci->Name, -1, pw,
                         sizeof(pdmci->Name) * sizeof(WCHAR) );


    WCHAR SubKey[64 + sizeof(pdmci->Name)];
    CRegSettings regPerf;

    lstrcpy(SubKey, L"Software\\Microsoft\\XboxSDK\\PerfCounter\\");
    lstrcat(SubKey, pw);

    if (ERROR_SUCCESS == regPerf.OpenSubkey(TRUE, HKEY_LOCAL_MACHINE, SubKey)) {
        WCHAR NameSubKey[32], DescSubKey[32], ScaleSubKey[32];
        LANGID LangID = GetSystemDefaultUILanguage();
        DWORD Size;

        wsprintf(NameSubKey,  L"Name%03x", LangID);
        wsprintf(DescSubKey,  L"Description%03x", LangID);
        wsprintf(ScaleSubKey, L"Scale%03x", LangID);

        //
        // Look up name, description and default scale for this counter
        //

        if (regPerf.GetSize(NameSubKey, &Size) == ERROR_SUCCESS && Size != 0) {
            if (Size > AllocSize) {
                AllocSize = Size;
                LocalFree(pw);
                pw = (PWSTR)LocalAlloc(LPTR, Size);
                if (!pw) {
                    return E_OUTOFMEMORY;
                }
            }
            regPerf.GetString(NameSubKey, pw, AllocSize);
            p->pwszName = pw;
        } else {
            p->pwszName = pw;
        }

        if (regPerf.GetSize(DescSubKey, &Size) == ERROR_SUCCESS && Size != 0) {
            pw = (PWSTR)LocalAlloc(LPTR, Size);
            if (!pw) {
                return E_OUTOFMEMORY;
            }
            regPerf.GetString(DescSubKey, pw, Size);
            p->pwszHelp = pw;
        } else if (regPerf.GetSize(L"Description409", &Size) == ERROR_SUCCESS && Size != 0) {
            pw = (PWSTR)LocalAlloc(LPTR, Size);
            if (!pw) {
                return E_OUTOFMEMORY;
            }
            regPerf.GetString(L"Description409", pw, Size);
            p->pwszHelp = pw;
        } else {
            p->pwszHelp = L" ";
        }

        if (regPerf.GetDWORD(ScaleSubKey, &p->dwDefaultScale) != ERROR_SUCCESS && \
            regPerf.GetDWORD(L"Scale409", &p->dwDefaultScale) != ERROR_SUCCESS) {
            p->dwDefaultScale = 0;
        }
    } else {
        if ( pdmci->Type & DMCOUNT_EVENT || pdmci->Type & DMCOUNT_PRATIO ) {
            lstrcatW( pw, L" (/sec average)" );
        }
        p->pwszName = pw;
        p->pwszHelp = L" ";
        p->dwDefaultScale = 0;
    }

    //
    // Internally xbdm use 64-bit counter, so all of ours are 64-bit too
    //

    p->dwCounterType = PERF_COUNTER_LARGE_RAWCOUNT;

    return NOERROR;
}

HRESULT
XbPrfMonConstructPerfItems(
    VOID
    )
{
    HRESULT hr, hr2;
    DM_COUNTINFO dmci;
    CPrfData::PPRFITM pPrfItems;
    SIZE_T NumCounters = 0;
    SIZE_T NumItems = 0;
    SIZE_T MaxItems = 256;
    PDM_WALK_COUNTERS pdmwc = NULL;
    DWORD PrfObjId = 0x1000;

    //
    // Allocate buffer large enough to hold 1 PO and 254 COs (and 1 sentinel)
    //

    pPrfItems = (CPrfData::PPRFITM)LocalAlloc(
        LPTR, sizeof(CPrfData::PRFITM) * (MaxItems) );

    if ( !pPrfItems ) {
        return E_OUTOFMEMORY;
    }

    //
    // Since xbdm has no concept of hierarchy counters, first item here will
    // always be the only one performance object
    //

    InitializePerformanceObject( pPrfItems, PrfObjId, L"Xbox", L"Xbox Performance Object",
                                 PrfObjId+1, PERF_NO_INSTANCES, 0 );
    NumItems++;

    do {
        hr = DmWalkPerformanceCounters( &pdmwc, &dmci );
        if ( SUCCEEDED(hr) ) {

            NumCounters++;

            //
            // Re-allocate buffer if necessary, we have to leave the last
            // item for sentinel as well
            //

            if ( NumItems >= (MaxItems-2) ) {
                MaxItems += 256;
                pPrfItems = (CPrfData::PPRFITM)LocalReAlloc(
                    pPrfItems, sizeof(CPrfData::PPRFITM) * MaxItems, LPTR );
                if ( !pPrfItems ) {
                    hr = E_OUTOFMEMORY;
                    break;
                }
            }

            hr2 = InitializeCounterObject(&pPrfItems[NumItems], PrfObjId+NumCounters, &dmci );

            if ( FAILED(hr2) ) {
                hr = hr2;
                break;
            }

            NumItems++;
        }
    } while ( SUCCEEDED(hr) );

    DmCloseCounters( pdmwc );

    if ( hr == XBDM_ENDOFLIST && NumCounters ) {
        InitializeCounterObject( &pPrfItems[NumItems], (DWORD)-1, 0, TRUE );
        g_PrfData.AssignDynamicPerfItems(pPrfItems);
        g_TotalCounters = NumCounters;
        g_FirstCounterId = PrfObjId+1;
        return NOERROR;
    }

    return E_UNEXPECTED;
}

INT_PTR
WINAPI
GuiDialog(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM /*lParam*/
    )
{
    if ( uMsg == WM_INITDIALOG ) {
        return TRUE;
    } else if ( uMsg == WM_COMMAND && LOWORD(wParam) == IDCANCEL) {
        DestroyWindow( hDlg );
        return TRUE;
    }

    return FALSE;
}

VOID
WINAPI
GuiThread(
    HWND* hDlg
    )
{
    MSG msg;

    *hDlg = CreateDialog( g_hInstance, MAKEINTRESOURCE(IDD_CONNECTING), 0, (DLGPROC)GuiDialog );

    if ( *hDlg ) {
        ShowWindow( *hDlg, SW_SHOW );
        UpdateWindow( *hDlg );
        while (GetMessage(&msg,NULL, 0, 0)) {
            TranslateMessage( &msg );
            DispatchMessage( &msg );
        }
    }
}

INT
WINAPI
_tWinMain(
    HINSTANCE hInstance,
    HINSTANCE /* hInstancePrev */,
    LPTSTR    /* pszCmdLine */,
    int nCmdShow
    )
{
    HRESULT hr;
    DWORD Error;
    int i, argc;
    LPWSTR *argv, arg;
    TCHAR szPath[MAX_PATH];
    LPWSTR pwszXboxName = NULL;
    LPWSTR pwszClientName = NULL;
    BOOL bMachineName = FALSE;
    BOOL bClientName = FALSE;
    HANDLE hMutex, hProcess, hThread;
    HWND hDlg;

    g_hInstance = hInstance;

    //
    // Process and validate command line arguments
    //

    argv = CommandLineToArgvW( GetCommandLineW(), &argc );

    for ( i=1; i<argc; i++ ) {
        arg = argv[i];
        if ( *arg == '/' || *arg == '-' ) {
            arg++;
            if ( *arg == 'x' || *arg == 'X' ) {
                bMachineName = TRUE;
                pwszXboxName = (++i < argc ? argv[i] : NULL);
            } else if ( *arg == 'c' || *arg == 'C' ) {
                bClientName = TRUE;
                pwszClientName = (++i < argc ? argv[i] : NULL);
            } else if ( *arg == 't' || *arg == 'T' ) {
                g_ConnectionTimeout = (++i < argc ? _ttoi(argv[i]) : 2000);
            } else {
                return XbPrfMonDisplayUsage();
            }
        } else {
            return XbPrfMonDisplayUsage();
        }
    }

    if ( (bMachineName && !pwszXboxName) || \
         (bClientName && !pwszClientName) ) {
        return XbPrfMonDisplayUsage();
    }

    if (!g_ConnectionTimeout) {
        g_ConnectionTimeout = 2000;
    }

    //
    // Validate the Xbox machine name (or IP address)
    //

    if ( pwszXboxName ) {

        LPSTR p = (LPSTR)pwszXboxName;
        LPWSTR pw = pwszXboxName;

        while ( *pw ) {
            *p++ = (CHAR)*pw++; // Simple in-place Unicode to ANSI convertion
        }

        *p = 0;
        DmSetXboxName( (LPSTR)pwszXboxName );
    }

    //
    // Check for previous instance of xbprfmon.exe.  There are couple issues
    // that prevent us from launching xbprfmon more than one copy.  The main
    // reason is that xboxdbg will not work for multiple connections at the
    // same time.
    //

    hMutex = CreateMutex( 0, TRUE, XBPRFMON_UUID_STR );

    if ( !hMutex || GetLastError() == ERROR_ALREADY_EXISTS ) {

        //
        // BUGBUG: should we try to bring perfmon's window to top level?
        // or notify user that it's already running
        //

        XbPrfMonReportError( ERROR_SERVICE_EXISTS );
        return 0;
    }

    hThread = CreateThread( 0, 0, (LPTHREAD_START_ROUTINE)GuiThread, (LPVOID)&hDlg, 0, 0 );
    if ( hThread ) {
        CloseHandle( hThread );
    }

    hr = DmUseSharedConnection( TRUE );

    if ( FAILED(hr) ) {
        XbPrfMonTranslateDmError( hr );
        return 0;
    }

    DmSetConnectionTimeout(g_ConnectionTimeout, g_ConnectionTimeout);

    //
    // Enumerate and construct performance counters on the fly
    //

    hr = XbPrfMonConstructPerfItems();

    if ( FAILED(hr) ) {
        XbPrfMonTranslateDmError( hr );
        return 0;
    }

    //
    // Install and add required keys in registry to expose Xbox performance
    // counters to PerfMon
    //

    GetModuleFileName( hInstance, szPath, ARRAYSIZE(szPath) );
    _tcscpy( _tcsrchr(szPath, _T('\\')) + 1, _T("xbprfdll.dll") );

    if ( GetFileAttributes(szPath) == (DWORD)-1 ) {
        XbPrfMonReportError( GetLastError(), szPath );
        return 0;
    }

    g_PrfData.Install( szPath );

    //
    // Activate performance data collector by creating the memory-mapped file
    //

    Error = g_PrfData.Activate();

    if ( Error != ERROR_SUCCESS ) {
        XbPrfMonReportError( Error );
    } else {
        if ( SUCCEEDED(hr) ) {
            hProcess = ExecutePerfMon( nCmdShow, pwszClientName );
            if ( hProcess ) {
                if ( hDlg ) {
                    PostMessage(hDlg, WM_COMMAND, IDCANCEL, 0);
                }
                DmEnableGPUCounter(TRUE);
                WaitForSingleObject(hProcess, INFINITE);
                CloseHandle(hProcess);
            }
        } else {
            XbPrfMonTranslateDmError( hr );
        }
    }

    //
    // Uninstall, remove registry keys and destroy mutex
    //

    g_PrfData.Uninstall();
    CloseHandle(hMutex);
    DmEnableGPUCounter(FALSE);
    DmUseSharedConnection(FALSE);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbupdshl\xbupdshl.cpp ===
#include <precomp.h>

HINSTANCE g_hInstance;

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,  LPSTR lpCmdLine, int nCmdShow)
/*++
  Routine Description:
    Walks through all the steps of setup.
--*/
{
    HRESULT hr;

    g_hInstance = hInstance;

    //Initialize COM
    CoInitialize(NULL);

    // Check the system requirements.
    if(!CheckSystemRequirements()) return -1;
    
    SETUP_PARAMETERS setupParameters;
    setupParameters.dwInstallType = INSTALL_TYPE_CLEAN;
    setupParameters.fRebootRequired = false;
    setupParameters.InstallLocation[0] = TEXT('\0');
    ExtractCabFile(&setupParameters);
    SetDefaultInstallPath(&setupParameters);
    
    // Find the existinf installtion.
    FindExistingInstallation(&setupParameters);

    // Exectue the setup wizard.
    CWizard wizard;
    hr = wizard.Initialize(4);

    // If we couldn't initialize the setup wizard then we are hosed.
    // Rell the user and scram
    if(FAILED(hr))
    {
        TCHAR szErrorBuffer[256];
        FormatErrorCode(szErrorBuffer, hr);
        RMessageBox(GetDesktopWindow(), IDS_ERROR_FORMAT_TEXT, IDS_ERROR_CAPTION, MB_OK|MB_ICONSTOP, szErrorBuffer);
        return -1;
    }

    // Instantiate all the pages and add them to the wizard

    CWelcomePage         welcomePage(&setupParameters);
    CUpgradePage         upgradePage(&setupParameters);
    CInstallLocationPage installLocationPage(&setupParameters);
    CFinishPage          finishPage(&setupParameters);

    wizard.AddPage(&welcomePage);
    wizard.AddPage(&upgradePage);
    wizard.AddPage(&installLocationPage);
    wizard.AddPage(&finishPage);

    // Execute the wizard

    hr = wizard.DoWizard(GetDesktopWindow(), g_hInstance);

    // If the wizard failed to execute, display error
    if(FAILED(hr))
    {
      TCHAR szErrorBuffer[256];
      FormatErrorCode(szErrorBuffer, hr);
      RMessageBox(GetDesktopWindow(), IDS_ERROR_FORMAT_TEXT, IDS_ERROR_CAPTION, MB_OK|MB_ICONSTOP, szErrorBuffer);
      return -1;
    }

    if(setupParameters.pidlInstallFolder)
    {
        IMalloc *pMalloc;
        SHGetMalloc(&pMalloc);
        pMalloc->Free(setupParameters.pidlInstallFolder);
        pMalloc->Release();
        setupParameters.pidlInstallFolder = NULL;
    }
    
    CoUninitialize();

    if(setupParameters.fRebootRequired)
    {
        HandleReboot();
    }
    // We are done, the wizard handled everything.
    return 0;
}

bool CheckSystemRequirements()
/*++
  Routine Description:

    Two requirements:

        1) The shell extension requires Windows 2000 or later.
        2) Installation requires administrator priviledges.

    If the system meets this requirement return true.
    
        Otherwise, pop up a top-level dialog and inform the user
        what is wrong.  Then, return false.
--*/
{
    OSVERSIONINFO versionInfo;
    
    versionInfo.dwOSVersionInfoSize = sizeof(versionInfo);
    
    // If we couldn't get the version inform user and fail
    if(!GetVersionEx(&versionInfo))
    {
        TCHAR szErrorBuffer[256];
        FormatErrorCode(szErrorBuffer, GetLastError());
        RMessageBox(GetDesktopWindow(), IDS_ERROR_FORMAT_TEXT, IDS_ERROR_CAPTION, MB_OK|MB_ICONSTOP, szErrorBuffer);
        return false;
    }

    // Verify Version
    if( (versionInfo.dwPlatformId != VER_PLATFORM_WIN32_NT) || (versionInfo.dwMajorVersion < 5) )
    {
        RMessageBox(GetDesktopWindow(), IDS_ERROR_OLD_OS_VERSION, IDS_ERROR_OLD_OS_VERSION_CAPTION, MB_OK|MB_ICONSTOP);
        return false;
    }

    // TODO: Verify Install Priviledges (for now it will blow up somewhere later if you have insufficient priviledge).
    
    return true;
}

void ExtractCabFile(PSETUP_PARAMETERS pSetupParameters)
{
    HRSRC  hResource = FindResource(g_hInstance, MAKEINTRESOURCE(IDCAB_PRODUCT), TEXT("CABFILES"));
    HGLOBAL hMemory = LoadResource(g_hInstance, hResource);
    PVOID   pData = LockResource(hMemory);
    ULONG   uSize = SizeofResource(g_hInstance, hResource);
    TCHAR   szCabinetName[MAX_PATH];
    DWORD   dwError;

    dwError = GetTempPath(MAX_PATH, pSetupParameters->SourcePath);
    if(!dwError)
    {

    }
    ULONG uLen = _tcslen(pSetupParameters->SourcePath);
    LPTSTR pszParse = pSetupParameters->SourcePath + uLen-1;
    if(*pszParse++!=TEXT('\\')) *pszParse++  = TEXT('\\');
    _tcscpy(pszParse, TEMP_SUBDIR_NAME);
    CreateDirectory(pSetupParameters->SourcePath, NULL);
    wsprintf(szCabinetName, "CABFILE_APPEND_FROMAT", pSetupParameters->SourcePath);

    HANDLE hFile = CreateFile(szCabinetName, GENERIC_WRITE, 0, NULL,CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if(INVALID_HANDLE_VALUE!=hFile)
    {   
        DWORD dwBytesWritten;
        WriteFile(hFile, pData, uSize, &dwBytesWritten, NULL);
        CloseHandle(hFile);
        SetupIterateCabinet(szCabinetName, 0, UnpackFileCB, (PVOID)pSetupParameters->SourcePath);
    }
}

UINT UnpackFileCB( PVOID Context, UINT Notification, UINT_PTR Param1,  UINT_PTR Param2)
{
    if(Notification == SPFILENOTIFY_FILEINCABINET)
    {
        PSETUP_PARAMETERS     pSetupParameters= (LPSTR)Context;
        PFILE_IN_CABINET_INFO pFileCabinetInfo = (PFILE_IN_CABINET_INFO)Param1;
        
        wsprintf(pFileCabinetInfo->FullTargetName, TEXT("%s\\%s"), pszSourceBuffer, pFileCabinetInfo->NameInCabinet);
        return FILEOP_DOIT;
    }
    return NO_ERROR;
}
void PlaceFiles(PSETUP_PARAMETERS pSetupParameters)
{

}


void SetDefaultInstallPath(PSETUP_PARAMETERS pSetupParameters)
{
    SHGetSpecialFolderPath(GetDesktopWindow(), pSetupParameters->InstallLocation, CSIDL_PROGRAM_FILES, FALSE);
    UINT uLen = _tcslen(pSetupParameters->InstallLocation);
    LPTSTR pszParse = pSetupParameters->InstallLocation+uLen;
    *pszParse++ = '\\';
    _tcscpy(pszParse, TEXT("xbnspace"));
    SHGetSpecialFolderLocation(GetDesktopWindow(), CSIDL_PROGRAM_FILES, &pSetupParameters->pidlInstallFolder);
}

void FindExistingInstallation(PSETUP_PARAMETERS pSetupParameters)
{
    //
    //  Look in the registery to find the previous installation
    //
    HKEY hKey;
    if(ERROR_SUCCESS==RegOpenKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{DB15FEDD-96B8-4DA9-97E0-7E5CCA05CC44}\\InProcServer32"), &hKey))
    {
        //
        //  Get the install path
        //
        DWORD dwInstallPath = sizeof(pSetupParameters->InstallLocation);
        RegQueryValueEx(hKey, NULL, NULL, NULL, (PBYTE)pSetupParameters->InstallLocation, &dwInstallPath);
        RegCloseKey(hKey);

        //
        //  TODO: Check and compare versions:
        //
        /*
        HANDLE hFileVersion;
        DWORD  dwVersionInfoSize;
        GetFileVersionInfoSize(pSetupParameters->InstallLocation, &hFileVersion);
        */
        pSetupParameters->dwInstallType = INSTALL_TYPE_UPGRADE_NEWER;
    } else
    {
        pSetupParameters->dwInstallType = INSTALL_TYPE_CLEAN;
        return;
    }

}

void PerformUpgrade(HWND hWnd, PSETUP_PARAMETERS pSetupParameters)
{
    //
    //  Unregister the existing dll
    //
    HRESULT hr = E_FAIL;
    HMODULE hLibrary = LoadLibrary(pSetupParameters->InstallLocation);
    if(hLibrary)
    {
        HRESULT (__stdcall *pfnDllUnregisterServer)(void) = (HRESULT(__stdcall *)(void))GetProcAddress(hLibrary, "DllUnregisterServer");
        if(pfnDllUnregisterServer)
        {
            hr = pfnDllUnregisterServer();
        }
        FreeLibrary(hLibrary);
    }
    
    if(FAILED(hr))
    {
        TCHAR szErrorBuffer[256];
        FormatErrorCode(szErrorBuffer, hr);
        RMessageBox(hWnd, IDS_UPGRADE_FAILURE, IDS_UPGRADE_FAILURE_CAPTION, MB_OK|MB_ICONSTOP, szErrorBuffer);
    }

    //
    //  Try to delete the existing file
    //
    if(DeleteFile(pSetupParameters->InstallLocation))
    {
        // Strip xbshlext.dll from the install location
        LPTSTR pszParse = _tcsrchr(pSetupParameters->InstallLocation, TEXT('\\'));
        *pszParse = TEXT('\0');

        // The delete worked, the file was not in use, so just follow the normal
        // Perform Install path
        
        PerformInstall(hWnd, pSetupParameters);
        return;
    }

    //
    //  The delete file failed, on the old file.
    //  
    TCHAR szTempFileName[MAX_PATH];
    TCHAR szSourceFileName[MAX_PATH];

    // 1) Reboot required.
    pSetupParameters->fRebootRequired = true;

    // 2) Strip xbshlext.dll from the install location
    LPTSTR pszParse = _tcsrchr(pSetupParameters->InstallLocation, TEXT('\\'));
    *pszParse = TEXT('\0');

    // 3) Install xbshlext.dll to a temporary name and set MoveFileEx to install it on reboot
    GetTempFileName(pSetupParameters->InstallLocation, "XBS", 0, szTempFileName);
    wsprintf(szSourceFileName, TEXT("%s\\xbshlext.dll"), pSetupParameters->SourcePath);
    CopyFile(szSourceFileName, szTempFileName, FALSE);
    *pszParse = TEXT('\\');
    MoveFileEx(szTempFileName, pSetupParameters->InstallLocation, MOVEFILE_DELAY_UNTIL_REBOOT|MOVEFILE_REPLACE_EXISTING);

    // 4) Setup RunOnce to call regsvr32.exe on the xbshlext.dll.
    RegisterOnBoot(hWnd, pSetupParameters->InstallLocation);
}

void PerformInstall(HWND hWnd, PSETUP_PARAMETERS pSetupParameters)
{
    bool fDisplayError = false;
    TCHAR szErrorBuffer[256];

    // 1) make sure that the target directory exists
    EnsureDirectoryExists(pSetupParameters->InstallLocation);
    
    // 2) Copy the file 
    TCHAR szSourceFileName[MAX_PATH];
    TCHAR szTargetFileName[MAX_PATH];
    wsprintf(szSourceFileName, TEXT("%s\\xbshlext.dll"), pSetupParameters->SourcePath);
    wsprintf(szTargetFileName, TEXT("%s\\xbshlext.dll"), pSetupParameters->InstallLocation);
    CopyFile(szSourceFileName, szTargetFileName, FALSE);

    // 2) Register the file.
    HMODULE hLibrary = LoadLibrary(szTargetFileName);
    if(hLibrary)
    {
        HRESULT (__stdcall *pfnDllRegisterServer)(void) = (HRESULT(__stdcall *)(void))GetProcAddress(hLibrary, "DllRegisterServer");
        if(pfnDllRegisterServer)
        {
            HRESULT hr = pfnDllRegisterServer();
            if(FAILED(hr))
            {
                fDisplayError = true;
                FormatErrorCode(szErrorBuffer, hr);
            }
        } else
        {
           fDisplayError = true;
           FormatErrorCode(szErrorBuffer, GetLastError());
        }
        FreeLibrary(hLibrary);
    } else
    {
        fDisplayError = true;
        FormatErrorCode(szErrorBuffer, GetLastError());
    }
    if(fDisplayError) RMessageBox(hWnd, IDS_ERROR_FORMAT_TEXT, IDS_ERROR_CAPTION, MB_OK|MB_ICONSTOP, szErrorBuffer);
}

void RegisterOnBoot(HWND hWnd, LPCTSTR szComDll)
{
    TCHAR  szRegisterCommand[512];
    TCHAR  systemPath[MAX_PATH];
    LPTSTR pszParse = szRegisterCommand;
    UINT   uLen;
    HKEY   hRunOnceKey;
    if(GetSystemDirectory(systemPath, MAX_PATH))
    {
        wsprintf(szRegisterCommand, TEXT("\"%s\\regsvr32.exe\" /s \"%s\""), systemPath, szComDll);
        if(ERROR_SUCCESS==RegOpenKey(HKEY_LOCAL_MACHINE, RUN_ONCE_KEY, &hRunOnceKey))
        {
            // Get the length of the command in bytes
            uLen = _tcslen(szRegisterCommand)+1;
            uLen *= sizeof(TCHAR);
            //Get the name of the DLL to use as the unique ID.
            pszParse = _tcsrchr(szComDll, TEXT('\\'));
            pszParse++;
            RegSetValueEx(hRunOnceKey, pszParse, 0, REG_SZ, (LPBYTE)szRegisterCommand, uLen);
            RegCloseKey(hRunOnceKey);
        }
    }
}

int RMessageBox(HWND hWnd, UINT uResourceIdText, UINT uResourceIdCaption, UINT uType,...)
{
    va_list vl;
    TCHAR szFormat[256];
    TCHAR szText[512];
    TCHAR szCaption[512];
    
    // Format the text.
    LoadString(g_hInstance, uResourceIdText, szFormat, sizeof(szFormat)/sizeof(TCHAR));
    va_start(vl, uType); 
    wvsprintfA(szText, szFormat, vl);
    va_end(vl);
    
    // Load the caption
    LoadString(g_hInstance, uResourceIdCaption, szCaption, sizeof(szCaption)/sizeof(TCHAR));
    
    // Call message box
    return MessageBox(hWnd, szText, szCaption, uType);
}

int RSetWindowText(HWND hWnd, UINT uResourceId,...)
{
    va_list vl;
    TCHAR szFormat[256];
    TCHAR szText[512];
    
    // Format the text.
    LoadString(g_hInstance, uResourceId, szFormat, sizeof(szFormat)/sizeof(TCHAR));
    va_start(vl, uResourceId); 
    wvsprintf(szText, szFormat, vl);
    va_end(vl);

    return SetWindowText(hWnd, szText);
}

int FormatErrorCode(LPTSTR pszBuffer, HRESULT hr)
{
    return FormatMessage(
            FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,
            NULL, hr, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), pszBuffer,
            MAX_PATH, NULL);
}

void EnsureDirectoryExists(LPTSTR pszDirectory)
{
    DWORD dwAttributes = GetFileAttributes(pszDirectory);
    if(INVALID_HANDLE_VALUE == (HANDLE)dwAttributes)
    {
        LPTSTR pszParse = _tcsrchr(pszDirectory, TEXT('\\'));
        *pszParse = TEXT('\0');
        EnsureDirectoryExists(pszDirectory);
        *pszParse = TEXT('\\');
        CreateDirectory(pszDirectory, NULL);
    }
}

void HandleReboot()
{
    struct {
        DWORD PrivilegeCount; 
        LUID_AND_ATTRIBUTES RebootPrivilege;
    } tokenPrivilege;

    if(IDYES==RMessageBox(GetDesktopWindow(), IDS_PROMPT_REBOOT, IDS_PROMPT_REBOOT_CAPTION, MB_YESNO|MB_ICONQUESTION))
    {
        HANDLE hProcessToken;
        if(OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY|TOKEN_ADJUST_PRIVILEGES, &hProcessToken))
        {
            tokenPrivilege.PrivilegeCount = 1;
            tokenPrivilege.RebootPrivilege.Attributes = SE_PRIVILEGE_ENABLED;
            if(LookupPrivilegeValue( NULL,SE_SHUTDOWN_NAME, &tokenPrivilege.RebootPrivilege.Luid))
            {
                if(AdjustTokenPrivileges(hProcessToken, FALSE, (PTOKEN_PRIVILEGES)&tokenPrivilege, sizeof(tokenPrivilege), NULL, NULL))
                {
                    ExitWindowsEx(EWX_REBOOT, 0);
                    return;
                }
            }
        }
        RMessageBox(GetDesktopWindow(), IDS_INSUFFICIENT_REBOOT_PRIVILEGE, IDS_PROMPT_REBOOT_CAPTION, MB_OK|MB_ICONERROR);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\common\custom.h ===
//  CUSTOM.H
//
//      This file defines the abstract interfaces for communication between
//      the custom setup dll, and unpacker.exe or uninstall.exe.
//
//      All communication with the custom setup dll, should go through 
//      a method defined in this file.
//
//  Created 30-Mar-2001 [JonT]
//  Separated the custom dll from the exe's.  23-Aug-2001 [MitchD]

#ifndef _CUSTOM_H_
#define _CUSTOM_H_

//---------------------------------------------------------------------
class CCustomSite
{
  public:
    virtual void   SetLastError(DWORD dwStringID, DWORD dwErrorCode)=0;
    virtual void   SetLastErrorString(LPCTSTR lpString,DWORD dwErrorCode)=0;
    virtual LPTSTR GetDefaultDir()=0;
    virtual DWORD  GetFlags()=0;
    virtual void   SetFlags(DWORD dwNewFlags)=0;
    virtual void   AddRegForUninstall(LPCSTR lpRoot, LPCSTR lpSubkey, LPCSTR lpValueName) = 0;
    virtual LPTSTR GetSetting(DWORD dwKey)=0;
};

#define SETUPSITE_FLAGS_FORCEINSTALL         1
#define SETUPSITE_FLAGS_SKIPPRESETUPCHECKS   2
#define SETUPSITE_FLAGS_SETUPHASRUNBEFORE    4

//---------------------------------------------------------------------
class CCustom
{
public:
    virtual BOOL DoPreSetupChecks()=0;
    virtual BOOL ValidateDirectory(
                    LPCSTR lpDefaultDir,    // Default dir: set on upgrade or by the user
                    LPCSTR lpID,            // Target directory ID string. Unique.
                    LPSTR lpCommand,        // Command that was used to fill in the target path
                    LPSTR lpData,           // Data used to fill in the target path (after : in .INI file)
                    LPSTR lpPath            // Path files will be copied to with this ID
                    )=0;
    virtual VOID AfterCopy()=0;
    virtual VOID PostSetup(int nRet)=0;
};

typedef CCustom *(__stdcall *PFNGETCUSTOM)(CCustomSite *pCustomSite);
#define GETCUSTOMPROC "GetCustom"

// Called by uninstall to
typedef BOOL (__stdcall *PFNPREUNINSTALL)(LPCTSTR pszUninstallPath);
#define PREUNINSTALLPROC "PreUninstall"
typedef void (__stdcall *PFNPOSTUNINSTALL)(LPCTSTR pszUninstallPath);
#define POSTUNINSTALLPROC "PostUninstall"

#endif // #ifndef _CUSTOM_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\common\fileinfo.cpp ===
//  FILEINFO.CPP
//
//  Created 30-Mar-2001 [JonT]

#include "common.h"
#include "fileinfo.h"


//  CFileInfo::Get
//      Reads in the important information about a file so it
//      can be saved and reloaded.

BOOL
CFileInfo::Get(
    LPCSTR lpFile
    )
{
    HANDLE hfind;
    WIN32_FIND_DATA find;

    // Find the file
    if ((hfind = FindFirstFile(lpFile, &find)) != INVALID_HANDLE_VALUE)
    {
        m_dwSize = find.nFileSizeLow;
        m_ft = find.ftLastWriteTime;
        FindClose(hfind);
        return TRUE;
    }
    else
        return FALSE;
}


//  CFileInfo::Compare
//      Compares a file in the filesystem to the info currently stored.
//      If the file doesn't exist, returns 1 (same as existing file is older)
//      If the file does exist and matches, returns 0.
//      If the file exists and is older, returns 1.
//      If the file exists and is newer, returns -1

int
CFileInfo::Compare(
    LPCSTR lpFile
    )
{
    HANDLE hfind;
    WIN32_FIND_DATA find;

    // Find the file
    if ((hfind = FindFirstFile(lpFile, &find)) != INVALID_HANDLE_VALUE)
    {
        FindClose(hfind);

        // Strip off the low DWORD and the low bit of the high DWORD.
        // This gives us accuracy that roughly matches the accuracy of FAT
        __int64 i64New = ((LARGE_INTEGER*)&m_ft)->QuadPart;
        __int64 i64Existing = ((LARGE_INTEGER*)&find.ftLastWriteTime)->QuadPart;
        __int64 i64Delta = i64New - i64Existing;
        if (i64Delta < 0)
            i64Delta = -i64Delta;

        // FILETIMEs match (within the resolution of FAT: 2 seconds,
        // size matches, return file is the same.
        // If size doesn't match but time does, assume corruption and force copy.
        if (i64Delta <= 20000001)
            return 0;

        // If existing file is older, return 1
        if (i64Existing < i64New)
            return 1;

        // If existing file is newer, return -1
        return -1;
    }
    return 1;
}


//  CFileInfo::NoLessThan
//      Makes sure a date for the file is no less than a given date.

void
CFileInfo::NoLessThan(
    FILETIME ft
    )
{
    __int64 i64MinTime = ((LARGE_INTEGER*)&ft)->QuadPart;

    // If the date we have is less than the date passed in, set the date
    // to the one passed in
    __int64* pi64Current = &((LARGE_INTEGER*)&m_ft)->QuadPart;
    if (*pi64Current < i64MinTime)
        *pi64Current = i64MinTime;
}


//  CFileInfo::Load
//      Retrieves the text version of the file info and reloads
//      the values into the class.

BOOL
CFileInfo::Load(
    LPSTR lpIn
    )
{
    // Start address
    LPBYTE lp = (LPBYTE)(&m_dwSize);

    // Get address of the next byte after the FILETIME structure
    LPBYTE lpEnd = (LPBYTE)((&m_ft) + 1);

    for (; *lpIn != 0 && lp < lpEnd ; ++lp)
    {
        *lp = (*lpIn++ - 'A') << 4;
        *lp |= (*lpIn++ - 'A');
    }

    if (lp == lpEnd)
        return TRUE;
    else
        return FALSE;
}


//  CFileInfo::Save
//      Saves the info about a file into text format so
//      it can be reloaded later.
//      Assumes the buffer is at least FILEINFO_SAVE_SIZE large.

BOOL
CFileInfo::Save(
    LPSTR lpOut
    )
{
    // Start address
    LPBYTE lp = (LPBYTE)(&m_dwSize);

    // Get address of the next byte after the FILETIME structure
    LPBYTE lpEnd = (LPBYTE)((&m_ft) + 1);

    // Write out one character per nibble
    for (; lp < lpEnd ; ++lp)
    {
        *lpOut++ = (*lp >> 4) + 'A';
        *lpOut++ = (*lp & 0x0f) + 'A';
    }
    *lpOut = 0;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbprfmon\RegSettings.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    PrfData.cpp

Abstract:

    CRegSettings C++ class to help with registry manipulations

Author:

    Jeffrey M. Richter (v-jeffrr) 01-Aug-1998

--*/

#pragma once

class CRegSettings {
public:  // Constructors/destructor
   CRegSettings() : m_hkeySubkey(NULL) { };

   CRegSettings(BOOL fReadOnly, HKEY hkeyRoot, LPCTSTR pszSubkey)
      : m_hkeySubkey(NULL) {
      OpenSubkey(fReadOnly, hkeyRoot, pszSubkey);
   }

   ~CRegSettings() { CloseKey(); }


public:  // Opening/closing registry subkey functions
   operator HKEY() const { return(m_hkeySubkey); }

   LONG OpenSubkey(BOOL fReadOnly, HKEY hkeyRoot, LPCTSTR pszSubkey) {
      CloseKey();
      LONG lErr;
      if (fReadOnly) {
         lErr = ::RegOpenKeyEx(hkeyRoot, pszSubkey, 0,
            KEY_QUERY_VALUE, &m_hkeySubkey);
      } else {
         DWORD dwDisposition;
         lErr = RegCreateKeyEx(hkeyRoot, pszSubkey, 0, NULL,
            REG_OPTION_NON_VOLATILE, KEY_QUERY_VALUE | KEY_SET_VALUE,
            NULL, &m_hkeySubkey, &dwDisposition);
      }
      return(lErr);
   }

   void CloseKey() {
      if (m_hkeySubkey != NULL) {
         ::RegCloseKey(m_hkeySubkey);
         m_hkeySubkey = NULL;
      }
   }


public:  // Reading/writing registry value functions
   LONG GetDWORD(LPCTSTR pszValName, PDWORD pdw) const {
      DWORD cbData = sizeof(pdw);
      return(GetVal(pszValName, (PBYTE) pdw, &cbData));
   }

   LONG SetDWORD(LPCTSTR pszValName, DWORD dw) const {
      return(SetVal(pszValName, REG_DWORD, (BYTE*) &dw, sizeof(dw)));
   }


   LONG GetString(LPCTSTR pszValName, LPTSTR psz, int nMaxSize) const {
      DWORD cbData = nMaxSize;
      return(GetVal(pszValName, (PBYTE) psz, &cbData));
   }

   LONG SetString(LPCTSTR pszValName, LPCTSTR psz) const {
      return(SetVal(pszValName, REG_SZ, (PBYTE) psz,
         sizeof(TCHAR) * (lstrlen(psz) + 1)));
   }


   LONG GetMultiString(LPCTSTR pszValName, LPTSTR psz, int nMaxSize) const {
      return(GetString(pszValName, psz, nMaxSize));
   }

   LONG SetMultiString(LPCTSTR pszValName, LPCTSTR psz) const {
      for (DWORD cch = 0; psz[cch] != 0; cch += 1 + lstrlen(&psz[cch])) ;
      return(SetVal(pszValName, REG_MULTI_SZ, (PBYTE) psz,
         sizeof(TCHAR) * (cch + 1)));
   }


   LONG GetBinary(LPCTSTR pszValName, PBYTE pb, PDWORD pcbData) const {
      return(GetVal(pszValName, pb, pcbData));
   }

   LONG SetBinary(LPCTSTR pszValName, CONST BYTE* pb, int nSize) const {
      return(SetVal(pszValName, REG_BINARY, pb, nSize));
   }

   LONG GetSize(LPCTSTR pszValName, PDWORD pdw) {
      return(GetVal(pszValName, NULL, pdw));
   }

private:
   HKEY  m_hkeySubkey;
private:
   LONG GetVal(LPCTSTR pszValName, PBYTE pbData, PDWORD pcb) const {
      return(::RegQueryValueEx(m_hkeySubkey, pszValName,
         NULL, NULL, pbData, pcb));
   }

   LONG SetVal(LPCTSTR pszValName, DWORD dwType, CONST BYTE *pbData, DWORD cb) const {
      return(::RegSetValueEx(m_hkeySubkey, pszValName,
         0, dwType, pbData, cb));
   }
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\common\fileinfo.h ===
//  FILEINFO.H
//
//  Created 30-Mar-2001 [JonT]

#ifndef _FILEINFO_H_
#define _FILEINFO_H_

//---------------------------------------------------------------------

class CFileInfo
{
private:
    DWORD m_dwSize;
    FILETIME m_ft;

public:
    BOOL Get(LPCSTR lpFile);
    int Compare(LPCSTR lpFile);
    void NoLessThan(FILETIME ft);
    BOOL Load(LPSTR lpIn);
    BOOL Save(LPSTR lpOut);
    DWORD GetSize() { return m_dwSize; }
    FILETIME* GetFiletime() { return &m_ft; }
};

// one byte per nibble + a zero byte
#define FILEINFO_SAVE_SIZE (sizeof (CFileInfo) * 2 + 1)

#endif // #ifndef _FILEINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\common\global.h ===
//  GLOBAL.H
//
//  Created 29-Mar-2001 [JonT]

#ifndef _GLOBAL_H_
#define _GLOBAL_H_

//---------------------------------------------------------------------
//  Global 'settings cab' filenames

#define SCAB_MANIFEST       TEXT("manifest.csv")
#define SCAB_SETTINGS       TEXT("settings.ini")
#define SCAB_LICENSE        TEXT("license.txt")
#define SCAB_CUSTOMDLL      TEXT("custom.dll")
#define SCAB_UNINSTALLDIR   TEXT("uninstall")
#define SCAB_UNINSTALLER    TEXT("xbuninst2.exe")
#define SCAB_UNINSTALLFILE  TEXT("uninstall.csv")

//---------------------------------------------------------------------
// Misc global helpers

inline void
AppendSlash(
    LPSTR lpPath
    )
{
    if (*(lpPath + strlen(lpPath) - 1) != '\\')
        strcat(lpPath, "\\");
}



#endif // #ifndef _GLOBAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\common\helper.h ===
//  HELPER.H
//
//      Header for common miscellaneous helper routines in HELPER.CPP
//
//  Created 9-May-2001 [JonT]

#ifndef _HELPER_H_
#define _HELPER_H_

BOOL GetRegistryString(LPTSTR lpOut, DWORD dwcOut, HKEY hkeyroot, LPCTSTR lpSubkey, LPCTSTR lpValuename);
LPSTR GetRegistryStringAlloc(HKEY hkeyroot, LPCTSTR lpSubkey, LPCTSTR lpValuename);
BOOL WriteRegistryString(HKEY hkeyroot, LPCTSTR lpSubkey, LPCTSTR lpValuename, LPCTSTR lpValue);
BOOL CompareFileVersion(LPTSTR lpPath, DWORD dwVerMS, DWORD dwVerLS, int* lpnResult);
BOOL IsAdministrator(void);
BOOL RegisterDLL(LPCTSTR lpPath, BOOL fUnregister);
BOOL RegisterDLLOnReboot(LPCTSTR lpPath);
int rsprintf(HINSTANCE hInstance, LPSTR pszDest, UINT uFormatResource, ...);
void FormatWindowText(HWND hWnd, ...);
BOOL Reboot();


#endif // #ifndef _HELPER_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\common\langid.h ===
//  LANGID.H
//
//  Created 18-Feb-2002 [JimHelm]

#ifndef _LANGID_H_
#define _LANGID_H_

#include <list>

class CLangID
{
public:
    // Constructors and Destructor
    CLangID();
    CLangID( const CLangID& LangID );
    ~CLangID();

    // Public Methods
    BOOL ParseLangIDs( char* pszLine );     // Takes a NULL terminated string, parses it for lang IDs
                                            // which should be separated by colons ':' (if there is more
                                            // than one), and adds them to the list
    BOOL IsLangIDValid( LANGID lid );       // Will return TRUE if the Lang ID is valid for this machine
    BOOL MoveFirstLangID();                 // Move our pointer to the first item in the list
    BOOL MoveNextLangID();                  // Move our pointer to the next item in the list
    DWORD GetCurrentLangID();               // Retreive the current langID being pointed to
    DWORD GetNumLangIDs()                   // Returns the number of lang IDs in the list
        { return m_LangIDs.size(); };

private:
    // List of LangIDs
    std::list<DWORD> m_LangIDs;             // Linked list of LANGIDs
    unsigned int m_uiListPosition;          // Used to track the position in our list

};

#endif // _LANGID_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\common\parse.h ===
//  PARSE.H
//
//  Created 28-Mar-2001 [JonT]

#ifndef _PARSE_H_
#define _PARSE_H_

//  ParseLine
//      Parses a single line of text by splitting the various 'clauses'
//      (separated by commas) in the line. Modifies the original string
//      by inserting zeros where the commas are. Moves the pointer to
//      the end of line. If desired, call SkipRestOfLine to move to next line.
//      Returns TRUE at EOF (*lp == 0)

BOOL ParseLine(LPSTR& lp, LPSTR* lplpParse, DWORD dwcMaxParse, DWORD* dwcActual);

//  SkipWhitespace
//      Skips the current pointer over any whitespace, including comment lines
//      and blank lines

BOOL SkipWhitespace(LPSTR& lp);

//  ZapComma
//      Replaces a comma with a zero character and skips the pointer past it

BOOL ZapComma(LPSTR& lp);

//  SkipRestOfLine
//      Reduces parsing errors by forcing a skip to the next newline

BOOL SkipRestOfLine(LPSTR& lp);

#endif // #ifndef _PARSE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\common\parse.cpp ===
//  PARSE.CPP
//
//  Created 28-Mar-2001 [JonT]

#include "common.h"
#include "parse.h"

//  ParseLine
//      Parses a single line of text by splitting the various 'clauses'
//      (separated by commas) in the line. Modifies the original string
//      by inserting zeros where the commas are. Returns a pointer past
//      the line and pointing to the first character of the next line.
//      If the pointer points to a zero, it encountered the zero while
//      parsing, generally meaning end of file.
//      Returns TRUE only at EOF.

BOOL ParseLine(
    LPSTR& lp,
    LPSTR* lplpParse,
    DWORD dwcMaxParse,
    DWORD* dwcActualParsed
    )
{
    DWORD i;

    // Clear the incoming buffer
    ZeroMemory(lplpParse, dwcMaxParse * sizeof (LPSTR*));
    if (dwcActualParsed != NULL)
        *dwcActualParsed = 0;

    // Skip any leading whitespace. If at EOF, bail.
    if (SkipWhitespace(lp))
        return TRUE;

    // Zap the proper number of commas.
    // If we reach EOF or EOL mid-loop,
    // we can return, but we need to first
    // point the remaining pointers to 
    // the termination.
    for (i = 0 ; i < dwcMaxParse ; ++i)
    {
        *lplpParse++ = lp;
        if (dwcActualParsed != NULL)
            ++*dwcActualParsed;
        if (ZapComma(lp))
        {
            //EOL then lp points to the beginning of the next
            //we need to terminate with the previous count.
            //EOF we just terminate by pointing to the final NULL.
            LPSTR lpTerminate = *lp ? (lp-1) : lp;
            while(++i < dwcMaxParse) *lplpParse++ = lpTerminate;
            return TRUE;
        }
    }

    // Since we got here, that means that there is still line left, but we've
    // exhausted the available pointers. Now just skip to end of line and zero
    // that
    while (*lp != '\n' && *lp != '\r')
    {
        if (*lp == 0)
            return TRUE;
        else
            ++lp;
    }
    *lp++ = 0;

    // Skip any additional whitespace
    return (*lp == 0);
}


//  ZapComma
//      Moves the passed in pointer to the next comma and zaps it.
//      Returns TRUE at end of line or end of file.
//      At EOF, *lp == 0.

BOOL
ZapComma(
    LPSTR& lp
    )
{
    // Look for the next comma
    while (*lp != ',')
    {
        // If we hit a zero, stop and flag end of file
        if (*lp == 0)
            return TRUE;

        // If we land on CR/LF, zap it and return pointing to that
        if (*lp == '\n' || *lp == '\r')
        {
            *lp++ = 0;
            return TRUE;
        }
        else
            ++lp;
    }

    // Nuke the comma
    *lp++ = 0;
    return FALSE;
}


//  SkipWhitespace
//      Skips past whitespace including comment lines.
//      Returns TRUE at EOF.

BOOL
SkipWhitespace(
    LPSTR& lp
    )
{
    // In case we get called at end of file, bail
    if (*lp == 0)
        return TRUE;

    // Loop until we have a good starting character
    while (TRUE)
    {
        // Skip any amount of whitespace or blank lines
        while (*lp == ' ' || *lp == '\t' || *lp == '\n' || *lp == '\r')
                ++lp;
    
        // Did we find a comment line? If so, skip the entire line
        if (*lp == ';')
        {
            while (*lp != '\n' && *lp != '\r' && *lp != '\0')
                ++lp;
            // Keep looping as there might be additional whitespace/comments
        }

        // Are we at EOF?
        else if (*lp == 0)
            return TRUE;

        // Otherwise, we have a good starting character
        else
            return FALSE;
    }
}

//  SkipRestOfLine
//      Reduces parsing errors by forcing a skip to the next newline.
//      Returns TRUE on EOF.

BOOL
SkipRestOfLine(
    LPSTR& lp
    )
{
    if (*lp == 0)
        return TRUE;

    // Skip to next newline
    while (*lp != '\n' && *lp != '\r')
    {
        if (*lp == 0)
            return TRUE;
        else
            ++lp;
    }

    // Now it's safe to skip whitespace since we know we are at EOL
    return SkipWhitespace(lp);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\common\rsccommon.h ===
/////////////////////////////////////////////////////////////
//  Common Resource IDs.  These ID's


//
//  Standard Error codes
//
#define IDS_ERROR_GENERAL                800
#define IDS_FILE_COPY_PROBLEM            801
#define IDS_SETUP_NOT_COMPLETE           802
#define IDS_CANT_CREATE                  803
#define IDS_MB_COPYPROBLEM               804
#define IDS_COPYING_FILE                 805
#define IDS_UPDATING_REGISTRY            806
#define IDS_MBCANCEL                     807
#define IDS_MB_INVALIDPATH               808


//
//  Standard stuff
//
#define IDC_UNUSED                      -1
#define IDC_STATIC                      -1
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\inf\full\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\common\langid.cpp ===
//  LANGID.CPP
//
//  Created 18-Feb-2002 [JimHelm]

#include "common.h"
#include "langid.h"

// Constructors and Destructor
CLangID::CLangID() :
m_uiListPosition( 0 )
{
}

// Copy constructor
CLangID::CLangID( const CLangID& LangID )
{
    // Copy the list of lang ids
    m_LangIDs = LangID.m_LangIDs;   // Does this work?  Does the list class contain an assignment operator that works?
}

CLangID::~CLangID()
{
    // Empty the linked list
    m_LangIDs.clear();
}

// Takes a NULL terminated string, parses it for lang IDs
// which should be separated by colons ':' (if there is more
// than one), and adds them to the list
BOOL CLangID::ParseLangIDs( char* pszLine )
{
    if( NULL == pszLine )
        return FALSE;

    // Empty the linked list
    m_LangIDs.clear();

    // Check to see if the LangID was left empty.
    // If so, add the global "0000" to our list and exit
    if( ',' == *pszLine )
    {
        m_LangIDs.push_back( 0x0000 );
        return TRUE;
    }

    // If the line wasn't empty, assume we have at least one LangID in the list
    LPSTR lpStopScan = NULL;
    LPSTR lpNextID = pszLine;  // Used to find the next LangID in our string
    DWORD dwLangID = 0;
    do
    {
        dwLangID = strtol( lpNextID, &lpStopScan, 16 );
        m_LangIDs.push_back( dwLangID );
        lpNextID = strstr( lpNextID, ":" );
        
        // Exit if there are no more LangIDs
        if( NULL == lpNextID )
            break;

        // Skip over the ':' and point at the next LangID
        lpNextID++;
    } while( TRUE );

    return TRUE;
}


// Will return TRUE if the Lang ID is valid for this machine
BOOL CLangID::IsLangIDValid( LANGID lid )
{
    BOOL bValidID = FALSE;

    for( std::list<DWORD>::iterator i = m_LangIDs.begin(); i != m_LangIDs.end(); ++i )
    {
        // If our lang ID matches the current machine, or 0000, we should stop looking
        // and return TRUE
        if( ( 0x0000 == *i ) || ( lid == *i ) )
        {
            bValidID = TRUE;
            break;
        }
    }

    return bValidID;
}


// Move our pointer to the first item in the list
BOOL CLangID::MoveFirstLangID()
{
    // Set this to 0 no matter what
    m_uiListPosition = 0;

    // If the list is not empty, return TRUE, otherwise fail
    if( !m_LangIDs.empty() )
        return TRUE;

    return FALSE;
}


// Move our pointer to the next item in the list
BOOL CLangID::MoveNextLangID()
{
    if( ( m_uiListPosition + 1 ) < m_LangIDs.size() )
    {
        m_uiListPosition++;
        return TRUE;
    }

    return FALSE;
}


// Retreive the current langID being pointed to
DWORD CLangID::GetCurrentLangID()
{
    unsigned int uiCount = 0;
    for( std::list<DWORD>::iterator i = m_LangIDs.begin(); i != m_LangIDs.end(); ++i )
    {
        if( uiCount == m_uiListPosition )
            return *i;

        ++uiCount;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\common\settings.cpp ===
//  SETTINGS.CPP
//
//  Created 12-Mar-2001 [JonT]

#include "common.h"
#define SETTINGS
#include "settings.h"

#define MAX_INI_STRING  4096

//---------------------------------------------------------------------

//  CSettingsFile::SetFile
//      Sets an INI file for use with the library
//      fMakeCopy signals if we should work off a copy so that changes can
//      be made without affecting the master

BOOL
CSettingsFile::SetFile(
    LPCTSTR lpIniFile,
    BOOL fMakeCopy
    )
{
    TCHAR szTempPath[MAX_PATH];
    TCHAR szTempFile[MAX_PATH];

    // Free any previous files
    if (m_lpIniFile)
        Close();

    m_fMakeCopy = fMakeCopy;
    if (!fMakeCopy)
    {
        m_lpIniFile = _strdup(lpIniFile);
    }

    // Make a copy. We only keep track of the new name
    else
    {
        GetTempPath(MAX_PATH, szTempPath);
        GetTempFileName(szTempPath, "pak", 0, szTempFile);
        if (!CopyFile(lpIniFile, szTempFile, FALSE))
            return FALSE;
        //BUG 9441, we edit the copy.  The original is usually read-only
        //(as it is checked in).  Copy file preserves the read-only attributes
        //so we must clear or we will not be able to edit it, or delete when we
        //are done.
        if(!SetFileAttributes(szTempFile, FILE_ATTRIBUTE_NORMAL))
            return FALSE;
        m_lpIniFile = _strdup(szTempFile);
    }

    return TRUE;
}


CSettingsFile::~CSettingsFile()
{
    Close();
}


//  CSettingsFile::Close
//      We're done with the INI file or its copy

void
CSettingsFile::Close()
{
    if (m_lpIniFile)
    {
        if (m_fMakeCopy)
        {
            DeleteFile(m_lpIniFile);
        }
        free (m_lpIniFile);
        m_lpIniFile = NULL;
    }
}


//  CSettingsFile::WriteINIString
//      Writes a string to the INI file

BOOL
CSettingsFile::WriteINIString(
    LPCTSTR lpSection,
    LPCTSTR lpKey,
    LPCTSTR lpValue
    )
{
    return WritePrivateProfileString(lpSection, lpKey, lpValue, m_lpIniFile);
}


//  CSettingsFile::NukeINISection
//      Wipes out a full section

VOID
CSettingsFile::NukeINISection(
    LPCTSTR lpSection
    )
{
    WritePrivateProfileSection(lpSection, "", m_lpIniFile);
}


//  CSettingsFile::GetINIString
//      Returns a preprocessed string in a dynamically allocated buffer.
//      Caller's responsibility to free the buffer.

LPTSTR
CSettingsFile::GetINIString(
    LPCTSTR lpSection,
    LPCTSTR lpKey
    )
{
    LPTSTR lpStart;
    LPTSTR lp;
    LPTSTR lpT;
    LPTSTR lpNew;
    LPTSTR lpRead;
    int nLen;

    // Allocate a buffer to initially read into
    lpStart = (LPTSTR)malloc(MAX_INI_STRING);

    // Adjust for the current language
    // First check the language specific section, and then fall back to the default string
    TCHAR szLocedSectionName[MAX_PATH];
    sprintf( szLocedSectionName, "%s_%04X", lpSection, GetUserDefaultUILanguage() );

    // Read the string from the INI file - Trye specific language first, then fall back to the default
    if( 0 == GetPrivateProfileString(szLocedSectionName, lpKey, "", lpStart, MAX_INI_STRING, m_lpIniFile) )
        GetPrivateProfileString(lpSection, lpKey, "", lpStart, MAX_INI_STRING, m_lpIniFile);

    // Walk through the string and substitute any additional keys
    for (lp = lpStart ; *lp ; ++lp)
    {
        // Check for environment var
        if (*lp == '%')
        {
            // Walk until we find the end
            for (lpT = lp + 1 ; *lpT != '%' ; ++lpT)
            {
                // If we hit the end of string beforehand, this means there is an unterminated
                // marker. This means the author messed up or didn't realize this was a reserved
                // char. Save them here by just returning the string without any further substitution
                if (*lpT == 0)
                    goto bail;
            }

            // Make a new copy of the string up to the marker
            *lp = 0;
            lpNew = (LPTSTR)malloc(MAX_INI_STRING);
            strcpy(lpNew, lpStart);
            *lpT = 0;

            // Check for empty string. This means it was a %% which should be replaced with %.
            if (lpT == lp + 1)
            {
                strcat(lpNew, "%");
            }

            // If it is not, go ahead and get the length of the env var, allocate buffer and read into it
            else
            {
                nLen = (int)GetEnvironmentVariable(lp + 1, lpT, 0);
                if (nLen)
                {
                    lpRead = (LPTSTR)malloc(nLen);
                    GetEnvironmentVariable(lp + 1, lpRead, nLen);
                    strcat(lpNew, lpRead);
                    free(lpRead);
                }
            }

            // Attach the rest of the string
            lp = lpNew + strlen(lpNew) - 1; // we'll get incremented shortly
            strcat(lpNew, lpT + 1);
            free(lpStart);
            lpStart = lpNew;
        }

        // Check for string substitution
        else if (*lp == '@')
        {
            // Walk until we find the end
            for (lpT = lp + 1 ; *lpT != '@' ; ++lpT)
            {
                // If we hit the end of string beforehand, this means there is an unterminated
                // marker. This means the author messed up or didn't realize this was a reserved
                // char. Save them here by just returning the string without any further substitution
                if (*lpT == 0)
                    goto bail;
            }

            // Make a new copy of the string up to the marker
            *lp = 0;
            lpNew = (LPTSTR)malloc(MAX_INI_STRING);
            strcpy(lpNew, lpStart);
            *lpT = 0;

            // Check for empty string. This means it was a @@ which should be replaced with @
            if (lpT == lp + 1)
            {
                strcat(lpNew, "@");
            }

            // If it's not, read the substitute string and add it on
            else
            {
                lpRead = (LPTSTR)malloc(MAX_INI_STRING);

                // Adjust for the current language
                // First check the language specific section, and then fall back to the default string
                TCHAR szLocedSubSectionName[MAX_PATH];
                sprintf( szLocedSubSectionName, "%s_%04X", m_strTable[CSTR_STRINGS], GetUserDefaultUILanguage() );

                // Read the string from the INI file - Trye specific language first, then fall back to the default
                if( 0 == GetPrivateProfileString(szLocedSubSectionName, lp + 1, "", lpRead, MAX_INI_STRING, m_lpIniFile) )
                    GetPrivateProfileString(m_strTable[CSTR_STRINGS], lp + 1, "", lpRead, MAX_INI_STRING, m_lpIniFile);

                strcat(lpNew, lpRead);
                free(lpRead);
            }

            // Attach the rest of the string
            lp = lpNew + strlen(lpNew) - 1; // we'll get incremented shortly
            strcat(lpNew, lpT + 1);
            free(lpStart);
            lpStart = lpNew;
        }
    }

    // Return a buffer just the right length
bail:
    lp = _strdup(lpStart);
    free(lpStart);
    return lp;
}


#define MAX_KEYNAMES     4096
                                

//  CSettingsFile::EnumerateINISection
//      Returns a structure with an entire section parsed.

LPSECTIONENUM
CSettingsFile::EnumerateINISection(
    LPCTSTR lpSection
    )
{
    TCHAR KeyNames[MAX_KEYNAMES];
    LPTSTR lp;
    DWORD dwc = 0;
    LPSECTIONENUM lpEnum;
    DWORD i;

    // Get all the key names for this section
    // Adjust for the current language
    // First check the language specific section, and then fall back to the default string
    TCHAR szLocedSectionName[MAX_PATH];
    sprintf( szLocedSectionName, "%s_%04X", lpSection, GetUserDefaultUILanguage() );

    // Read the string from the INI file - Trye specific language first, then fall back to the default
    if( 0 == GetPrivateProfileString(szLocedSectionName, NULL, "", KeyNames, MAX_KEYNAMES, m_lpIniFile) )
        GetPrivateProfileString(lpSection, NULL, "", KeyNames, MAX_KEYNAMES, m_lpIniFile);

    // Count all the sections
    lp = KeyNames;

    // If we have at least one key, count them
    if (*lp != 0 || *(lp + 1) != 0)
    {
        while (TRUE)
        {
            // Skip to a zero
            for (; *lp ; ++lp)
                ;

            ++dwc;

            // Two zeros in a row mean we're done
            if (*++lp == 0)
                break;
        }
    }

    // Allocate the structure to return
    lpEnum = (LPSECTIONENUM)malloc(sizeof (SECTIONENUM) + (dwc - 1) * sizeof (KEYINFO));

    // Fill in the structure
    lpEnum->dwcKeys = dwc;
    for (i = 0, lp = KeyNames ; i < dwc ; ++i, lp += strlen(lp) + 1)
    {
        lpEnum->keys[i].lpKey = _strdup(lp);
        lpEnum->keys[i].lpValue = GetINIString(lpSection, lp);
    }

    return lpEnum;
}


//  CSettingsFile::EnumerateFree
//      Frees memory associated with an enumeration

void
CSettingsFile::EnumerateFree(
        LPSECTIONENUM lpEnum
        )
{
    DWORD i;

    for (i = 0 ; i < lpEnum->dwcKeys ; ++i)
    {
        free(lpEnum->keys[i].lpKey);
        free(lpEnum->keys[i].lpValue);
    }

    free(lpEnum);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\common\helper.cpp ===
//  HELPER.CPP
//
//      Common file and registry helpers to make installation tasks simpler
//
//  Created 19-Apr-2001 [JonT]

#include "common.h"

//  GetRegistryString
//      Reads a registry value into the string passed in. Assumes the string is at
//      least MAX_PATH in length. Returns FALSE if the key/value is not found. Pass
//      in NULL for the string to get the default value.

BOOL
GetRegistryString(
    LPTSTR lpOut,
    DWORD dwcOut,
    HKEY hkeyroot,
    LPCTSTR lpSubkey,
    LPCTSTR lpValuename
    )
{
    HKEY hkey;
    DWORD dwType;
    DWORD dwRet;

    // Open the key and get the value
    if (::RegOpenKeyEx(hkeyroot, lpSubkey, 0, KEY_READ, &hkey) != ERROR_SUCCESS)
        return FALSE;
    dwRet = ::RegQueryValueEx(hkey, lpValuename, NULL, &dwType, (PBYTE)lpOut, &dwcOut);
    ::RegCloseKey(hkey);

    // If we got back a DWORD, convert nicely to a string
    if (dwType == REG_DWORD)
    {
        DWORD dw = *(DWORD*)lpOut;
        sprintf(lpOut, "%d", dw);
        dwType = REG_SZ;
    }

    return (dwRet == ERROR_SUCCESS && dwType == REG_SZ);
}


//  GetRegistryStringAlloc
//      Reads a registry string after allocating a buffer just the right size for it.
//      Returns NULL if the regvalue doesn't exist. Caller's responsibility to free
//      the string.

LPSTR
GetRegistryStringAlloc(
    HKEY hkeyroot,
    LPCTSTR lpSubkey,
    LPCTSTR lpValuename
    )
{
    HKEY hkey;
    DWORD dwType;
    DWORD dwRet;
    LPSTR lpRet;
    DWORD dwcOut;

    // Open the key
    if (::RegOpenKeyEx(hkeyroot, lpSubkey, 0, KEY_READ, &hkey) != ERROR_SUCCESS)
        return NULL;

    // Get the length of the value
    if (::RegQueryValueEx(hkey, lpValuename, NULL, &dwType, NULL, &dwcOut) != ERROR_SUCCESS)
        return NULL;

    // Allocate some memory to read the value into
    lpRet = (LPSTR)malloc(dwcOut);
    if (!lpRet)
        return NULL;

    // Do the read
    dwRet = ::RegQueryValueEx(hkey, lpValuename, NULL, &dwType, (LPBYTE)lpRet, &dwcOut);
    ::RegCloseKey(hkey);

    if (dwRet != ERROR_SUCCESS)
    {
        free(lpRet);
        return NULL;
    }

    // If we got back a DWORD, convert to a string
    if (dwType == REG_DWORD)
    {
        DWORD dw = *(DWORD*)lpRet;
        free(lpRet);
        lpRet = (LPSTR)malloc(12);
        sprintf(lpRet, "%d", dw);
        dwType = REG_SZ;
    }

    return lpRet;
}


//  WriteRegistryString
//      Writes a registry string out

BOOL
WriteRegistryString(
    HKEY hkeyroot,
    LPCTSTR lpSubkey,
    LPCTSTR lpValuename,
    LPCTSTR lpValue
    )
{
    HKEY hkey;
    LONG lRet;

    // Open the key
    if (::RegCreateKeyEx(hkeyroot, lpSubkey, 0, NULL, 0, KEY_ALL_ACCESS, NULL, &hkey, NULL) != ERROR_SUCCESS)
        return FALSE;

    // Set the value
    lRet = ::RegSetValueEx(hkey, lpValuename, 0, REG_SZ, (LPBYTE)lpValue, strlen(lpValue) + 1);
    ::RegCloseKey(hkey);

    return (lRet == ERROR_SUCCESS);
}


//  CompareFileVersion
//      Compares a file's version info with that passed in.
//      Returns FALSE if the file cannot be found or the version information can't be read.
//      Returns TRUE otherwise and places the following values in *lpnResult:
//          -1 if the file is a version less than that passed in,
//          0 if the file is the same version and
//          1 if the file is a greater (later) version.

BOOL
CompareFileVersion(
    LPTSTR lpPath,
    DWORD dwVerMS,
    DWORD dwVerLS,
    int* lpnResult
    )
{
    DWORD dwZero;
    DWORD dwVerSize = ::GetFileVersionInfoSize(lpPath, &dwZero);

    // Make sure the file can be located
    if (dwVerSize == 0)
        return FALSE;

    // Allocate memory for the version block
    PBYTE pbVerInfo = (PBYTE)malloc(dwVerSize);
    if (pbVerInfo == NULL)
        return FALSE;

    // Get the version info for the file in question
    UINT uLen;
    VS_FIXEDFILEINFO* pVer;
    if (::GetFileVersionInfo(lpPath, 0, dwVerSize, pbVerInfo) == FALSE ||
        ::VerQueryValue(pbVerInfo, TEXT("\\"), (LPVOID*)&pVer, &uLen) == FALSE)
    {
        free(pbVerInfo);
        return FALSE;
    }

    // Check most significant DWORD
    if (pVer->dwFileVersionMS > dwVerMS)
        *lpnResult = 1;
    else if (pVer->dwFileVersionMS < dwVerMS)
        *lpnResult = -1;

    // Otherwise, the most significant is equal, so we have to decide based on the least significant
    else 
    {
        if (pVer->dwFileVersionLS > dwVerLS)
            *lpnResult = 1;
        else if (pVer->dwFileVersionLS < dwVerLS)
            *lpnResult = -1;
        else
            *lpnResult = 0;
    }
    free(pbVerInfo);
    return TRUE;
}


//  IsAdministrator
//      Returns TRUE iff the current user belongs to the administrator group

BOOL
IsAdministrator(void)
{
    HANDLE htoken;
    TOKEN_GROUPS* ptg = NULL;
    DWORD  cbTokenGroups;
    DWORD  dwGroup;
    SID_IDENTIFIER_AUTHORITY SystemSidAuthority= SECURITY_NT_AUTHORITY;
    PSID   psidAdmin;
    BOOL fAdmin;

    // First we must open a handle to the access token for this thread.
    if (!OpenThreadToken ( GetCurrentThread(), TOKEN_QUERY, FALSE, &htoken))
    {
        if (GetLastError() == ERROR_NO_TOKEN)
        {
            // If the thread does not have an access token, we'll examine the
            // access token associated with the process.
            if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &htoken))
                return FALSE;
        }
        else 
            return FALSE;
    }

    // Then we must query the size of the group information associated with
    // the token. Note that we expect a FALSE result from GetTokenInformation
    // because we've given it a NULL buffer. On exit cbTokenGroups will tell
    // the size of the group information.
    if (GetTokenInformation(htoken, TokenGroups, NULL, 0, &cbTokenGroups))
        return FALSE;

    // Allocate buffer for token groups
     if (!(ptg = (TOKEN_GROUPS*)_alloca(cbTokenGroups))) 
        return FALSE;

    // Now get the information
    if (!GetTokenInformation(htoken, TokenGroups, ptg, cbTokenGroups, &cbTokenGroups))
        return FALSE;

     // Create a System Identifier for the Admin group.
     if (!AllocateAndInitializeSid(&SystemSidAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, 
        DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &psidAdmin))
        return FALSE;

    // Iterate through the list of groups for this access
    // token looking for a match against the SID we created above.
    fAdmin = FALSE;
    for (dwGroup = 0 ; dwGroup < ptg->GroupCount ; ++dwGroup)
    {
        if (EqualSid(ptg->Groups[dwGroup].Sid, psidAdmin))
        {
            fAdmin = TRUE;
            break;
        }
    }

    // Before we exit we must explicity deallocate the SID we created.
    FreeSid(psidAdmin);
    CloseHandle(htoken);

    return fAdmin;
}


//  RegisterDLL
//      Does OLE registration on a DLL (same as regsvr32, but with less options)

typedef HRESULT (STDAPICALLTYPE *LPREGISTER_ENTRYPOINT)(void);

BOOL
RegisterDLL(
    LPCTSTR lpPath,
    BOOL fUnregister
    )
{
    LPREGISTER_ENTRYPOINT pfnEntrypoint;
    BOOL fRet = FALSE;
    HRESULT hr;

    // Load the library in question. Fail silently on errors
    UINT errMode = SetErrorMode(SEM_FAILCRITICALERRORS);
    HINSTANCE hlib = LoadLibraryEx(lpPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
    if (hlib < (HINSTANCE)HINSTANCE_ERROR)
    {
        goto nocleanup;
    }

    // Get the entrypoint
    if (fUnregister)
        pfnEntrypoint = (LPREGISTER_ENTRYPOINT)GetProcAddress(hlib, "DllUnregisterServer");
    else
        pfnEntrypoint = (LPREGISTER_ENTRYPOINT)GetProcAddress(hlib, "DllRegisterServer");
    if (!pfnEntrypoint)
    {
        goto cleanup;
    }

    // Call the entrypoint
    hr = (*pfnEntrypoint)();
    if (FAILED(hr))
    {
        goto cleanup;
    }

    // Success, we're done
    fRet = TRUE;

cleanup:
    FreeLibrary(hlib);

nocleanup:
    return fRet;
}


const LPTSTR RUN_ONCE_KEY = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce");
BOOL 
RegisterDLLOnReboot(LPCSTR lpPath)
{
    TCHAR  szRegisterCommand[512];
    TCHAR  systemPath[MAX_PATH];
    LPTSTR pszParse = szRegisterCommand;
    UINT   uLen;
    HKEY   hRunOnceKey;
    BOOL   fReturn = FALSE;
    if(GetSystemDirectory(systemPath, MAX_PATH))
    {
        wsprintf(szRegisterCommand, TEXT("\"%s\\regsvr32.exe\" /s \"%s\""), systemPath, lpPath);
        if(ERROR_SUCCESS==RegOpenKey(HKEY_LOCAL_MACHINE, RUN_ONCE_KEY, &hRunOnceKey))
        {
            // Get the length of the command in bytes
            uLen = strlen(szRegisterCommand)+1;
            uLen *= sizeof(TCHAR);
            //Get the name of the DLL to use as the unique ID.
            pszParse = strrchr(lpPath, '\\');
            pszParse++;
            if(ERROR_SUCCESS==RegSetValueEx(hRunOnceKey, pszParse, 0, REG_SZ, (LPBYTE)szRegisterCommand, uLen))
            {
                fReturn = TRUE;
            }
            RegCloseKey(hRunOnceKey);
        }
    }
    return fReturn;
}

int rsprintf(HINSTANCE hInstance, LPSTR pszDest, UINT uFormatResource, ...)
{
    int i=0;
    va_list vl;
    char szFormat[MAX_PATH];
    if(LoadStringA(hInstance, uFormatResource, szFormat, sizeof(szFormat)))
    {
        va_start(vl, uFormatResource); 
        i = vsprintf(pszDest, szFormat, vl);
        va_end(vl);
    }
    return i;
}

void FormatWindowText(HWND hWnd,...)
{
    char szFormat[MAX_PATH];
    char szText[MAX_PATH];
    GetWindowText(hWnd, szFormat, sizeof(szFormat));
    va_list vl;
    va_start(vl, hWnd); 
    vsprintf(szText, szFormat, vl);
    va_end(vl);
    SetWindowText(hWnd, szText);
}

BOOL Reboot()
{
    struct {
        DWORD PrivilegeCount; 
        LUID_AND_ATTRIBUTES RebootPrivilege;
    } tokenPrivilege;

    HANDLE hProcessToken;
    if(OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY|TOKEN_ADJUST_PRIVILEGES, &hProcessToken))
    {
        tokenPrivilege.PrivilegeCount = 1;
        tokenPrivilege.RebootPrivilege.Attributes = SE_PRIVILEGE_ENABLED;
        if(LookupPrivilegeValue( NULL,SE_SHUTDOWN_NAME, &tokenPrivilege.RebootPrivilege.Luid))
        {
            if(AdjustTokenPrivileges(hProcessToken, FALSE, (PTOKEN_PRIVILEGES)&tokenPrivilege, sizeof(tokenPrivilege), NULL, NULL))
            {
                return ExitWindowsEx(EWX_REBOOT, 0);
            }
        }
   }
   return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\inf\tools\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\common\settings.h ===
//  SETTINGS.H
//
//  Created 24-Mar-2001 [JonT]

#ifndef _SETTINGS_H
#define _SETTINGS_H

//---------------------------------------------------------------------
//  CSettingsFile
//      Manages the .INI file associated with the package

typedef struct _KEYINFO
{
    LPTSTR lpKey;
    LPTSTR lpValue;
} KEYINFO, *LPKEYINFO;

typedef struct _SECTIONENUM
{
    DWORD dwcKeys;
    KEYINFO keys[1];
} SECTIONENUM;
typedef SECTIONENUM* LPSECTIONENUM;


class CSettingsFile
{
private:
    LPTSTR m_lpIniFile;
    LPTSTR m_lpEnumAll;
    LPTSTR m_lpEnum;
    BOOL m_fMakeCopy;

public:
    CSettingsFile()
    {
        m_lpIniFile = NULL;
        m_lpEnumAll = NULL;
        m_fMakeCopy = FALSE;
    }
    ~CSettingsFile();

    // Sets the name of INI file to use
    BOOL SetFile(LPCTSTR lpIniFile, BOOL fMakeCopy=FALSE);

    // Return name of ini file or copy
    LPCTSTR GetFile() { return m_lpIniFile; }

    // Done with our copy of the file if any
    void Close();

    // Returns a string from the INI file correctly processed for
    // string and environment variable substitution
    LPTSTR GetString(DWORD dwSection, DWORD dwKey);
    LPTSTR GetString(DWORD dwSection, LPCTSTR lpKey);
    LPTSTR GetSetting(DWORD dwKey);
    LPTSTR GetSetting(LPCSTR lpKey);

    // Writes a string
    BOOL WriteString(DWORD dwSection, DWORD dwKey, LPCTSTR lpValue);
    BOOL WriteString(DWORD dwSection, LPCTSTR lpKey, LPCTSTR lpValue);
    BOOL WriteSetting(DWORD dwKey, LPCTSTR lpValue);

    // Wipes out a section
    VOID NukeSection(DWORD dwSection);
    VOID NukeINISection(LPCTSTR lpSection);

    // Section enumeration: returns a dynamically allocated array of
    // pointers into a static buffer where the section is read in
    LPSECTIONENUM EnumerateSection(DWORD dwSection);
    void EnumerateFree(LPSECTIONENUM lpEnum);

    // Versions of the methods that don't use the stringtable.
    LPTSTR GetINIString(LPCTSTR lpSection, LPCTSTR lpKey);
    BOOL WriteINIString(LPCTSTR lpSection, LPCTSTR lpKey, LPCTSTR lpValue);
    LPSECTIONENUM EnumerateINISection(LPCTSTR lpSection);

    static const LPCTSTR m_strTable[];
};

#define CSTR_PACKERSETTINGS     0
#define CSTR_STRINGS            1
#define CSTR_CABPATH            2
#define CSTR_MANIFEST           3
#define CSTR_TARGETDIRECTORIES  4
#define CSTR_PACKINGLIST        5
#define CSTR_UNPACKERTEMPLATE   6
#define CSTR_UNPACKERNEWEXE     7
#define CSTR_DIRSIZES           8
#define CSTR_UNPACKSETTINGS     9
#define CSTR_UNINSTALLDIR       10
#define CSTR_DIRFLAGS           11
#define CSTR_LICENSEFILE        12
#define CSTR_BUILDFLAVOR        13
#define CSTR_PACKERPATHS        14
#define CSTR_PRODUCTKEY         15
#define CSTR_DEFAULTDIRTEXT     16
#define CSTR_UNINSTALLER        17
#define CSTR_STARTMENUFOLDER    18
#define CSTR_COMPRESSIONTYPE    19
#define CSTR_COMPRESSIONLEVEL   20
#define CSTR_MINVERSIONALLOWED  21
#define CSTR_UPDATEDATESTO      22
#define CSTR_CUSTOMDLL          23
#define CSTR_PRODUCTNAME        24
#define CSTR_WELCOMEMSG         25
#define CSTR_PRODUCTDESC        26
#define CSTR_LICENSE_TITLE      27
#define CSTR_LICENSE_SUBTITLE   28
#define CSTR_LICENSE_INSTRUCT   29
#define CSTR_SKIP_LICENSE_PAGE  30
#define CSTR_TOTALINSTALLSIZE   31
#define CSTR_LANGUAGES          32
#define CSTR_DEFAULTLANGUAGE    33

#define CSTR_LICENSE_MAX_FILES  200

#ifdef UNPACKER
#define CSTR_SETTINGS CSTR_UNPACKSETTINGS
#else
#define CSTR_SETTINGS CSTR_PACKERSETTINGS
#endif

#ifdef SETTINGS
    // Initialize the section and key names
    const LPCTSTR CSettingsFile::m_strTable[] =
    {
        TEXT("PackerSettings"),
        TEXT("Strings"),
        TEXT("CabPath"),
        TEXT("Manifest"),
        TEXT("UnpackerPaths"),
        TEXT("PackingList"),
        TEXT("UnpackerTemplate"),
        TEXT("UnpackerNewExe"),
        TEXT("UnpackerDirSizes"),
        TEXT("UnpackerSettings"),
        TEXT("UninstallDir"),
        TEXT("UnpackerDirFlags"),
        TEXT("LicenseFile"),
        TEXT("BuildFlavor"),
        TEXT("PackerPaths"),
        TEXT("ProductKey"),
        TEXT("DefaultDirText"),
        TEXT("Uninstaller"),
        TEXT("StartMenuFolder"),
        TEXT("CompressionType"),
        TEXT("CompressionLevel"),
        TEXT("MinVersionAllowed"),
        TEXT("UpdateDatesToAtLeast"),
        TEXT("CustomDll"),
        TEXT("ProductName"),
        TEXT("WelcomeMessage"),
        TEXT("ProductDescription"),
        TEXT("LicenseTitle"),
        TEXT("LicenseSubtitle"),
        TEXT("LicenseInstruction"),
        TEXT("SkipLicensePage"),
        TEXT("TotalInstallSize"),
        TEXT("Languages"),
        TEXT("DefaultLanguage")
    };
#endif

inline LPTSTR
CSettingsFile::GetSetting(
    DWORD dwKey
    )
{
    return GetINIString(m_strTable[CSTR_SETTINGS], m_strTable[dwKey]);
}

inline LPTSTR
CSettingsFile::GetSetting(
    LPCSTR lpKey
    )
{
    return GetINIString(m_strTable[CSTR_SETTINGS], lpKey);
}

inline LPTSTR
CSettingsFile::GetString(
    DWORD dwSection,
    DWORD dwKey
    )
{
    return GetINIString(m_strTable[dwSection], m_strTable[dwKey]);
}

inline LPTSTR
CSettingsFile::GetString(
    DWORD dwSection,
    LPCTSTR lpKey
    )
{
    return GetINIString(m_strTable[dwSection], lpKey);
}

inline VOID
CSettingsFile::NukeSection(
    DWORD dwSection
    )
{
    NukeINISection(m_strTable[dwSection]);
}

inline LPSECTIONENUM
CSettingsFile::EnumerateSection(
    DWORD dwSection
    )
{
    return EnumerateINISection(m_strTable[dwSection]);
}


inline BOOL
CSettingsFile::WriteString(
    DWORD dwSection,
    DWORD dwKey,
    LPCTSTR lpValue
    )
{
    return WriteINIString(m_strTable[dwSection], m_strTable[dwKey], lpValue);
}

inline BOOL
CSettingsFile::WriteString(
    DWORD dwSection,
    LPCTSTR lpKey,
    LPCTSTR lpValue
    )
{
    return WriteINIString(m_strTable[dwSection], lpKey, lpValue);
}

inline BOOL
CSettingsFile::WriteSetting(
    DWORD dwKey,
    LPCTSTR lpValue
    )
{
    return WriteINIString(m_strTable[CSTR_SETTINGS], m_strTable[dwKey], lpValue);
}

#endif // #ifndef _SETTINGS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\inf\sources.inc ===
MAJORCOMP=setup
MINORCOMP=inf

TARGETNAME=XDKSetup
TARGETPATH=$(_OBJ_DIR)

TARGETTYPE=LIBRARY

C_DEFINES = $(C_DEFINES) -DSKIP_XBOXVERP_PRAGMA

SOURCES=

NTTARGETFILE0=\
    $(_OBJ_DIR)\$(TARGET_DIRECTORY)\xdk.inf \
    $(_OBJ_DIR)\$(TARGET_DIRECTORY)\xdk.sed \
    $(_OBJ_DIR)\$(TARGET_DIRECTORY)\$(TARGETNAME).exe \
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\inf\makefile.inc ===
#############################################################################
#
#   MAKEFILE.INC
#
#   Common rules for the setup INF files
#
#############################################################################


# Suffixes used by this makefile
.SUFFIXES : .inx .inf


# Definitions
# Base switches for C preprocessor
#
# /EP - Run through the preprocessor only
# /W4 - Warning level 4
# /nologo - Don't display compiler logo
# /c - Don't build an EXE
CFLAGS_BASE=/EP /W4 /nologo /c

TARGETCOPY_CMD = $(TARGETCOPY_CMD:.exe=.inf)

{..\}.inx{$(_OBJ_DIR)\$(TARGET_DIRECTORY)\}.inf:
    $(CC) $(CFLAGS_BASE) $(STD_DEFINES) $(TARGET_DBG_DEFINES) $(C_DEFINES) $(INCPATH0) $< > $*.tmp
    uniq -u $*.tmp > $@
    del $*.tmp
    $(TARGETCOPY_CMD)

{.}.inx{$(_OBJ_DIR)\$(TARGET_DIRECTORY)\}.inf:
    $(CC) $(CFLAGS_BASE) $(STD_DEFINES) $(TARGET_DBG_DEFINES) $(C_DEFINES) $(INCPATH0) $< > $*.tmp
    uniq -u $*.tmp > $@
    del $*.tmp
    $(TARGETCOPY_CMD)

$(_OBJ_DIR)\$(TARGET_DIRECTORY)\$(TARGETNAME).inf: $(PRIVATE_INC_PATH)\xboxverp.h

$(O)\xdk.sed : ..\xdk.sdx
        $(C_PREPROCESSOR_NAME) $(C_PREPROCESSOR_FLAGS:-DNT =) $** > $@

$(O)\$(TARGETNAME).exe : $(O)\xdk.sed $(O)\xdk.inf
        cd $(O)
        iexpressbld.exe /n /M xdk.sed
        cd ..\..
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\packer\CABFILE.CPP ===
//  CABFILE.CPP
//
//  Created 12-Mar-2001 [JonT]

#include "packer.h"

//---------------------------------------------------------------------
// FCI callback prototypes

INT_PTR DIAMONDAPI callback_file_open(char FAR *pszFile, int oflag, int pmode, int FAR *err, void FAR *pv);
unsigned int DIAMONDAPI callback_file_read(INT_PTR hf, void FAR *memory, UINT cb, int FAR *err, void FAR *pv);
unsigned int DIAMONDAPI callback_file_write(INT_PTR hf, void FAR *memory, UINT cb, int FAR *err, void FAR *pv);
int DIAMONDAPI callback_file_close(INT_PTR hf, int FAR *err, void FAR *pv);
long DIAMONDAPI callback_file_seek(INT_PTR hf, long dist, int seektype, int FAR *err, void FAR *pv);
int DIAMONDAPI callback_file_placed(PCCAB pccab, char *pszFile, long  cbFile, BOOL  fContinuation, void FAR *pv);
void HUGE * DIAMONDAPI callback_file_alloc(ULONG cb);
void DIAMONDAPI callback_file_free(void HUGE *memory);
int DIAMONDAPI callback_file_delete(char FAR *pszFile, int FAR *err, void FAR *pv);
BOOL DIAMONDAPI callback_file_template(char *pszTempName, int   cbTempName, void FAR *pv);
BOOL DIAMONDAPI callback_file_next_cab(PCCAB  pccab, ULONG  cbPrevCab, void FAR *pv);
long DIAMONDAPI callback_file_status(UINT   typeStatus, ULONG  cb1, ULONG  cb2, void FAR *pv);
INT_PTR DIAMONDAPI callback_file_openinfo(char   *pszName, USHORT *pdate, USHORT *ptime, USHORT *pattribs, int FAR *err, void FAR *pv);

//---------------------------------------------------------------------
// FCI callback routines

INT_PTR DIAMONDAPI
callback_file_open(
    char FAR *pszFile,
    int oflag,
    int pmode,
    int FAR *err,
    void FAR *pv
        )
{
    int result;

    result = _open(pszFile, oflag, pmode);

    if (result == -1)
        *err = errno;

    return result;
}

unsigned int DIAMONDAPI
callback_file_read(
    INT_PTR hf,
    void FAR *memory,
    UINT cb,
    int FAR *err,
    void FAR *pv
        )
{
    unsigned int result;

    result = (unsigned int) _read((HFILE)hf, memory, cb);

    if (result != cb)
        *err = errno;

    return result;
}

unsigned int DIAMONDAPI
callback_file_write(
    INT_PTR hf,
    void FAR *memory,
    UINT cb,
    int FAR *err,
    void FAR *pv
        )
{
    unsigned int result;

    result = (unsigned int) _write((HFILE)hf, memory, cb);

    if (result != cb)
        *err = errno;

    return result;
}


int DIAMONDAPI
callback_file_close(
    INT_PTR hf,
    int FAR *err,
    void FAR *pv
        )
{
    int result;

    result = _close((HFILE)hf);

    if (result != 0)
        *err = errno;

    return result;
}


long DIAMONDAPI
callback_file_seek(
    INT_PTR hf,
    long dist,
    int seektype,
    int FAR *err,
    void FAR *pv
        )
{
    long result;

    result = _lseek((HFILE)hf, dist, seektype);

    if (result == -1)
        *err = errno;

    return result;
}

int DIAMONDAPI
callback_file_placed(
    PCCAB pccab,
    char *pszFile,
    long  cbFile,
    BOOL  fContinuation,
    void FAR *pv
    )
{
    return 0;
}

void HUGE * DIAMONDAPI
callback_file_alloc(ULONG cb)
{
    return malloc(cb);
}

void DIAMONDAPI
callback_file_free(void HUGE *memory)
{
    free(memory);
}

int DIAMONDAPI
callback_file_delete(
    char FAR *pszFile,
    int FAR *err,
    void FAR *pv
    )
{
    int result;

    result = remove(pszFile);

    if (result != 0)
        *err = errno;

    return result;
}


BOOL DIAMONDAPI
callback_file_template(
    char *pszTempName,
    int   cbTempName,
    void FAR *pv
    )
{
    char    *psz;

    psz = _tempnam("","xx");            // Get a name
    if ((psz != NULL) && (strlen(psz) < (unsigned)cbTempName))
    {
        strcpy(pszTempName,psz);        // Copy to caller's buffer
        free(psz);                      // Free temporary name buffer
        return TRUE;                    // Success
    }
    //** Failed
    if (psz)
    {
        free(psz);
    }

    return FALSE;
}

BOOL DIAMONDAPI
callback_file_next_cab(
    PCCAB pccab,
    ULONG cbPrevCab,
    void FAR *pv
    )
{
    return TRUE;
}

long DIAMONDAPI
callback_file_status(
    UINT typeStatus,
    ULONG cb1,
    ULONG cb2,
    void FAR *pv
    )
{
    return 0;
}

INT_PTR DIAMONDAPI
callback_file_openinfo(
    char *pszName,
    USHORT *pdate,
    USHORT *ptime,
    USHORT *pattribs,
    int FAR *err,
    void FAR *pv
    )
{
    BY_HANDLE_FILE_INFORMATION finfo;
    FILETIME filetime;
    HANDLE handle;
    DWORD attrs;
    int hf;

    // Need a Win32 type handle to get file date/time
    // using the Win32 APIs, even though the handle we
    // will be returning is of the type compatible with
    // _open
    handle = CreateFileA(pszName, GENERIC_READ, FILE_SHARE_READ, NULL,
            OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,NULL);
    if (handle == INVALID_HANDLE_VALUE)
        return -1;

    if (GetFileInformationByHandle(handle, &finfo) == FALSE)
    {
        CloseHandle(handle);
        return -1;
    }

    FileTimeToLocalFileTime(&finfo.ftLastWriteTime, &filetime);
    FileTimeToDosDateTime(&filetime, pdate, ptime);
    attrs = GetFileAttributesA(pszName);
    if (attrs == 0xFFFFFFFF)
    {
        // failure
        *pattribs = 0;
    }
    else
    {
        // Mask out all other bits except these four, since other
        // bits are used by the cabinet format to indicate a
        // special meaning.
        *pattribs = (int) (attrs & (_A_RDONLY | _A_SYSTEM | _A_HIDDEN | _A_ARCH));
    }
    CloseHandle(handle);
    
    
    // Return handle using _open
    hf = _open( pszName, _O_RDONLY | _O_BINARY );
    if (hf == -1)
        return -1; // abort on error
    
    return hf;
}


//---------------------------------------------------------------------
//  CCabFile class

//  CCabFile::SetFile
//      Sets this instance to point to a specific CAB file and prepares the context.

BOOL
CCabFile::SetFile(
    LPCTSTR lpCabName,
    BOOL fTestOnly
    )
{
    TCHAR szDrive[_MAX_DRIVE], szDir[_MAX_DIR], szFname[_MAX_FNAME], szExt[_MAX_EXT];

    // Setup cab
    memset(&m_cab, 0, sizeof (CCAB));
    m_cab.cb = 600 * 1024 * 1024;       // Cabinet has to fit on a CD
    m_cab.cbFolderThresh = m_cab.cb;    // Folder threshold: full size of cab
    m_cab.cbReserveCFHeader = 0;
    m_cab.cbReserveCFFolder = 0;
    m_cab.cbReserveCFData   = 0;
    m_cab.iCab = 1;
    m_cab.iDisk = 0;
    m_cab.setID = 0;

    // Parse the cab name
    _splitpath(lpCabName, szDrive, szDir, szFname, szExt);
    sprintf(m_cab.szCabPath, "%s%s", szDrive, szDir);
    sprintf(m_cab.szCab, "%s%s", szFname, szExt);

    // Make sure we don't have a context open
    if (m_hfci)
        FCIDestroy(m_hfci);

    // Save the testonly flag
    m_fTestOnly = fTestOnly;

    // Test to make sure we could create the file
    if (fTestOnly)
    {
        m_hfci = NULL;
        HANDLE hfile = CreateFile(lpCabName, GENERIC_READ | GENERIC_WRITE, 0, NULL,
            CREATE_ALWAYS, FILE_FLAG_DELETE_ON_CLOSE, NULL);
        if (hfile != INVALID_HANDLE_VALUE)
        {
            CloseHandle(hfile);
            return TRUE;
        }
        else                      
        {
            m_erf.erfOper = FCIERR_OPEN_SRC;
            m_erf.fError = TRUE;
            return FALSE;
        }
    }

    // Create the new context
    m_hfci = FCICreate(
        &m_erf,
        callback_file_placed,
        callback_file_alloc,
        callback_file_free,
        callback_file_open,
        callback_file_read,
        callback_file_write,
        callback_file_close,
        callback_file_seek,
        callback_file_delete,
        callback_file_template,
        &m_cab,
        NULL
        );

    if (!m_hfci)
    {
        fprintf(stderr, "Error: FCICreate failed: error code %08x\n", m_erf.erfOper);
        return FALSE;
    }

    return TRUE;
}


//  CCabFile::SetCompression
//      Sets the compression type and level

BOOL
CCabFile::SetCompression(
    LPCSTR lpType,
    LPCSTR lpLevel
    )
{
    if (_stricmp(lpType, "NONE") == 0)
    {
        m_dwCompression = tcompTYPE_NONE;
    }
    else if (_stricmp(lpType, "MSZIP") == 0)
    {
        m_dwCompression = tcompTYPE_MSZIP;
    }
    else if (_stricmp(lpType, "LZX") == 0)
    {
        DWORD dwLevel = atoi(lpLevel);
        if (dwLevel > 6)
        {
            ::ReportSettingsError(CSTR_COMPRESSIONLEVEL, "compression level for LZX must be in the range of 0-6\n");
            return FALSE;
        }
        m_dwCompression = TCOMPfromLZXWindow(dwLevel + 15);
    }
    else
    {
        ::ReportSettingsError(CSTR_COMPRESSIONTYPE, "Unrecognized compression type. Possible values are NONE, MSZIP, LZX");
        return FALSE;
    }
    return TRUE;
}


//  CCabFile::AddFile
//      Adds a file to the cabinet from the given source path.
//      The pathname stored in the cabinet will be the destination path.
//      Normally, this pathname is a relative pathname.

BOOL
CCabFile::AddFile(
    LPCTSTR lpSourcePath,
    LPCTSTR lpDestPath
    )
{
    // If we're just testing, see if we can find the file
    if (m_fTestOnly)
    {
        HANDLE hfile = CreateFile(lpSourcePath, GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
        if (hfile != INVALID_HANDLE_VALUE)
        {
            CloseHandle(hfile);
            return TRUE;
        }
        else                      
        {
            m_erf.erfOper = FCIERR_OPEN_SRC;
            m_erf.fError = TRUE;
            return FALSE;
        }
    }

    // Add this file to the cabinet
    if(!FCIAddFile(m_hfci, (LPTSTR)lpSourcePath, (LPTSTR)lpDestPath,
        FALSE, // file is not executable
        callback_file_next_cab, callback_file_status, callback_file_openinfo, (USHORT)m_dwCompression))
    {
        // Error reporting handled elsewhere
        return FALSE;
    }

    return TRUE;
}


//  CCabFile::Flush
//      Writes the cab out to disk

BOOL
CCabFile::Flush()
{
    if (m_fTestOnly)
        return TRUE;

    // Flush out the new cab file
    if (!FCIFlushCabinet(m_hfci, FALSE, callback_file_next_cab, callback_file_status))
    {
        fprintf(stderr, "Error: FCIFlushCabinet failed: error code %08x\n", m_erf.erfOper);
        return FALSE;
    }

    return TRUE;
}


//  CCabFile::~CCabFile
//      Destroys the context, we're done with the object

CCabFile::~CCabFile()
{
    if (m_hfci)
        FCIDestroy(m_hfci);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\mkplist\mkplist.cpp ===
//  MKPLIST.CPP
//
//      A test utility to make a packing list from a directory image.
//      To make this more useful, having an exclude list would be a nice feature.
//
//  Created 3-Apr-2001 [JonT]

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include "..\common\global.h"
#include "..\common\settings.h"


    void PrintUsage(void);
    void WalkDirectory(LPSTR lpdir, LPSTR lpdirRelative);
    LPTSTR GetSetting(LPSTR lpSetting);
    BOOL ExcludeFilename(LPSTR lp);

    CSettingsFile g_settings;

    LPSTR g_lpFlavor;
    LPSTR g_lpSourceID;
    LPSTR g_lpDestID;
    LPSTR g_lpPath;
    LPSECTIONENUM g_lpExceptions;

int __cdecl
main(
    int argc,
    char** argv
    )
{
    TCHAR szPath[MAX_PATH];

    if (argc != 2)
    {
        PrintUsage();
        return -1;
    }

    // Point to our ini file. Fully qualify the path. the INI code does very
    // strange things with searches.
    _fullpath(szPath, argv[1], MAX_PATH);
    if (GetFileAttributes(szPath) == 0xffffffff ||
        !g_settings.SetFile(szPath))
    {
        printf("Couldn't find settings file\n");
        return -1;
    }

    g_lpFlavor = GetSetting("Flavor");
    g_lpSourceID = GetSetting("SourceRoot");
    g_lpDestID = GetSetting("DestinationRoot");
    g_lpPath = GetSetting("Path");

    // Get the exclude list
    g_lpExceptions = g_settings.EnumerateINISection("ExcludeList");

    // Walk through all the directories
    WalkDirectory(g_lpPath, "");

    return 0;
}


void
PrintUsage(void)
{
    fprintf(stderr,
        "mkplist: usage: mkplist [settings file]\n\n"
        "Builds a packing list for the setup packer\n\n"
        "Result is sent to stdout. This allows the results of several\n"
        "mkplist commands to be concatenated with >>");
}


void
WalkDirectory(
    LPSTR lpdir,
    LPSTR lpdirRelative
    )
{
    HANDLE hfind;
    WIN32_FIND_DATA find;
    TCHAR szPath[MAX_PATH];     // This is going to chew up some serious stack space--it's recursive!
    TCHAR szPathRelative[MAX_PATH];

    // Create the find path with a \*.* for the search
    strcpy(szPath, lpdir);
    AppendSlash(szPath);
    strcat(szPath, "*.*");

    // Loop through all the files deleting them
    if ((hfind = FindFirstFile(szPath, &find)) != INVALID_HANDLE_VALUE)
    {
        do
        {
            // Skip . and ..
            if (find.cFileName[0] == '.')
                continue;

            // We found a directory, descend into it
            if (find.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                strcpy(szPath, lpdir);
                AppendSlash(szPath);
                strcat(szPath, find.cFileName);
                strcpy(szPathRelative, lpdirRelative);
                if (*lpdirRelative != 0)
                    AppendSlash(szPathRelative);
                strcat(szPathRelative, find.cFileName);
                if (!ExcludeFilename(find.cFileName))
                    WalkDirectory(szPath, szPathRelative);
            }

            // Otherwise, add the file to the list. We descend directories first
            else
            {
                if (!ExcludeFilename(find.cFileName))
                {
                    printf("%s,file,%s,%s,%s,%s,%s,,\n",
                           g_lpFlavor, g_lpSourceID, lpdirRelative, find.cFileName,
                           g_lpDestID, lpdirRelative);
                }
            }
        }
        while (FindNextFile(hfind, &find));
        FindClose(hfind);
    }
}


LPTSTR
GetSetting(
    LPSTR lpSetting
    )
{
    return g_settings.GetINIString("MakePackingList", lpSetting);
}



BOOL
ExcludeFilename(
    LPSTR lp
    )
{
    TCHAR szName[MAX_PATH];
    LPSTR lpT;
    LPSTR lpExt;
    DWORD i;

    // Make sure we have an exclude list
    if (g_lpExceptions == NULL)
        return FALSE;

    // Split filename into name and extension
    strcpy(szName, lp);
    for (lpT = szName ; *lpT != '.' ; ++lpT)
    {
        if (*lpT == 0)
            break;
    }
    if (*lpT != 0)
        *lpT++ = 0;
    lpExt = lpT;

    // Now that we have name and extension, walk through the exclude list
    // looking for matches
    for (i = 0 ; i < g_lpExceptions->dwcKeys ; ++i)
    {
        // Exclude by extension
        if (g_lpExceptions->keys[i].lpKey[0] == '.')
        {
            if (_stricmp(&g_lpExceptions->keys[i].lpKey[1], lpExt) == 0)
                break;
        }

        // Exclude by name (including extension if any)
        else
        {
            if (_stricmp(g_lpExceptions->keys[i].lpKey, lp) == 0)
                break;
        }
    }

    // Return TRUE only if we found the file
    return !(i == g_lpExceptions->dwcKeys);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\packer\filehash.cpp ===
//  FILEHASH.CPP
//
//  Created 3-May-2001 [JonT]

#include "packer.h"

//---------------------------------------------------------------------

                  
CFileHash::CFileHash()
{
    ZeroMemory(m_lhHashTable, TABLE_SIZE * sizeof (LPFILENODE));
}
                  

//  CFileHash::FindDuplicate
//      Searches for a duplicate file from a file that has already been encountered.
//      The files are tracked with a hash table. If a match is found, we return the
//      target of the previous copy. If it's not found, we add it into the data structure.

LPSTR
CFileHash::FindDuplicate(
    LPCSTR lpName,
    LPCSTR lpCopyRoot,
    LPCSTR lpCopyTarget
    )
{
    // Get the information about the file
    WIN32_FIND_DATA fd;
    HANDLE hfind = FindFirstFile(lpName, &fd);
    if (hfind == INVALID_HANDLE_VALUE)
        return NULL;

    // Get the bucket number
    DWORD dwBucket = HashSizeToIndex(fd.nFileSizeLow);

    // Search this bucket for the matching size
    for (LPFILENODE pnode = m_lhHashTable[dwBucket] ; pnode ; pnode = pnode->pnext)
    {
        // The size matching is just a hint. If it matches, we have to compare the
        // file byte-by-byte. Also check to make sure it comes from the correct target root.
        if (pnode->m_dwSize == fd.nFileSizeLow)
        {
            if (_stricmp(lpCopyRoot, pnode->m_lpCopyRoot) == 0 &&
                FileCompare(lpName, pnode->m_lpName))
                break;
        }
    }

    // If we found the file, return that we did
    if (pnode != NULL)
        return pnode->m_lpCopyTarget;

    // Otherwise, add the file
    // Create a new node
    LPFILENODE pfn = new FILENODE;
    pfn->m_lpName = _strdup(lpName);
    pfn->m_lpCopyTarget = _strdup(lpCopyTarget);
    pfn->m_lpCopyRoot = _strdup(lpCopyRoot);
    pfn->m_dwSize = fd.nFileSizeLow;

    // Find the hash bucket to link it into
    DWORD dwHashBucket = HashSizeToIndex(fd.nFileSizeLow);

    // Link the node into the bucket list
    pfn->pnext = m_lhHashTable[dwHashBucket];
    m_lhHashTable[dwHashBucket] = pfn;

    return NULL;
}

//---------------------------------------------------------------------
//  CFileHash - private

DWORD
CFileHash::HashSizeToIndex(
    DWORD dwSize
    )
{
    return (1664525 * dwSize + 1013904223) % TABLE_SIZE;
}


//  CFileHash::FileCompare
//      Compares a file byte-by-byte. Returns TRUE if the files are identical

#define READ_SIZE 4096

BOOL
CFileHash::FileCompare(
    LPCSTR lpFile1,
    LPCSTR lpFile2
    )
{
    // Open the file and add to the end of the target file
    HANDLE fh1 = CreateFile(lpFile1, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
        OPEN_EXISTING, 0, NULL);
    HANDLE fh2 = CreateFile(lpFile2, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
        OPEN_EXISTING, 0, NULL);
    if (fh1 == INVALID_HANDLE_VALUE || fh2 == INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }

    // Allocate an aligned buffers for comparisons
    LPBYTE lpb1 = (LPBYTE)VirtualAlloc(NULL, READ_SIZE, MEM_COMMIT, PAGE_READWRITE);
    LPBYTE lpb2 = (LPBYTE)VirtualAlloc(NULL, READ_SIZE, MEM_COMMIT, PAGE_READWRITE);
    DWORD dwc1;
    DWORD dwc2;
    BOOL fRead1;
    BOOL fRead2;
    BOOL fRet = TRUE;

    // Read chunks of both files. If anything doesn't match: return values, bytes read
    do
    {
        // Read a chunk
        fRead1 = ReadFile(fh1, lpb1, READ_SIZE, &dwc1, NULL);
        fRead2 = ReadFile(fh2, lpb2, READ_SIZE, &dwc2, NULL);

        // Compare the results. Any differences and we're out of here
        if (fRead1 != fRead2 || dwc1 != dwc2 || memcmp(lpb1, lpb2, dwc1) != 0)
        {
            fRet = FALSE;
            break;
        }
    }
    while (fRead1 && dwc1 == READ_SIZE);

    // All done, clean up
    VirtualFree(lpb1, 0, MEM_RELEASE);
    VirtualFree(lpb2, 0, MEM_RELEASE);
    CloseHandle(fh1);
    CloseHandle(fh2);

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\packer\Manifest.cpp ===
//  MANIFEST.CPP
//
//  Created 13-Mar-2001 [JonT]

#include "packer.h"

//---------------------------------------------------------------------

//  CManifest::SetFile
//      Opens a new manifest (overwriting any existing file)

BOOL
CManifest::SetFile(
    LPTSTR lpManifest
    )
{
    Close();

    // Try to open the file
    m_handle = fopen(lpManifest, "w");
    if (m_handle == NULL)
    {
        m_error = errno;
        return FALSE;
    }

    return TRUE;
}


//  CManifest::~CManifest

CManifest::~CManifest()
{
    Close();
}


//  WriteCommand
//      Writes a variable-length command to the manifest
//      You must put a NULL at the end so we know it's complete.

BOOL
CManifest::WriteCommand(
    CLangID* pLangIDs,
    LPCTSTR lpCommand,
    ...
    )
{
    LPSTR lpArg;

    // Write out the list of langIDs
    pLangIDs->MoveFirstLangID();
    fprintf( m_handle, "%04X", pLangIDs->GetCurrentLangID() );
    while( pLangIDs->MoveNextLangID() )
        fprintf( m_handle, ":%04X", pLangIDs->GetCurrentLangID() );

    // Write out the command
    fprintf(m_handle, ",%s", lpCommand);

    va_list vararg;
    va_start(vararg, lpCommand);

    // Loop through all the arguments
    lpArg = va_arg(vararg, LPSTR);
    while (lpArg != NULL)
    {
        // Dump out the argument
        fprintf(m_handle, ",%s", lpArg);

        // Move to the next one
        lpArg = va_arg(vararg, LPSTR);
    }

    va_end(vararg);
    fprintf(m_handle, "\n");
    return TRUE;
}



void
CManifest::Close()
{
    if (m_handle)
        fclose(m_handle);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\packer\dirs.cpp ===
//  DIRS.CPP
//
//  Created 24-Mar-2001 [JonT]

#include "packer.h"

//---------------------------------------------------------------------

//  CDirectories::Init
//      Allocate enough entries for all the directories we'll see

BOOL
CDirectories::Init(
    DWORD dwc
    )
{
    if (m_lpdirs)
        free(m_lpdirs);
    m_lpdirs = (LPDIRINFO)malloc(dwc * sizeof (DIRINFO));

    m_dwcDirsMax = dwc;
    m_dwcDirsNow = 0;

    return (m_lpdirs != NULL);
}


//  CDirectories::Add
//      Adds a new directory to the list

BOOL
CDirectories::Add(
    LPSTR lpID
    )
{
    LPDIRINFO lpdir;
    LPSTR lp;

    // Since we don't want to have duplicate keynames in the INI
    // we allow a single digit after the dirname. Strip it off here.
    lp = lpID + strlen(lpID) - 1;
    if (*lp >= '0' && *lp <= '9')
        *lp = 0;

    // If we already have too many or if this ID is already in there, bail
    if (m_dwcDirsNow == m_dwcDirsMax || Find(lpID))
        return FALSE;
    lpdir = &m_lpdirs[m_dwcDirsNow];
    lstrcpyn(lpdir->szID, lpID, MAX_ID);
    lpdir->dwSize = 0;

    ++m_dwcDirsNow;

    return TRUE;
}

//  CDirectories::AddSize (string overload)
//      Computes the worst-case, uncompressed size for a file
//      and accumulates it into the proper directory

BOOL
CDirectories::AddSize(
    LPCSTR lpID,
    LPCSTR lpFile
    )
{
    LPDIRINFO lp;
    HANDLE hfile;
    DWORD dwc;

    if (!(lp = Find(lpID)))
    {
        SetLastError(0);
        return FALSE;
    }

    // Get the file size
    hfile = CreateFile(lpFile, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                       NULL, OPEN_EXISTING, 0, NULL);
    if (hfile == INVALID_HANDLE_VALUE)
        return FALSE;
    dwc = GetFileSize(hfile, NULL);
    CloseHandle(hfile);

    // Round the size up to a 32K (worst case) cluster size
    dwc |= 32768;
    dwc &= ~32767;

    lp->dwSize += dwc;
    return TRUE;
}


//  CDirectories::AddSize (DWORD overload)
//      Accumulates the size of a file into the directory in
//      cases where we don't want to check the size here

BOOL
CDirectories::AddSize(
    LPCSTR lpID,
    DWORD dwc
    )
{
    LPDIRINFO lp;

    if (!(lp = Find(lpID)))
    {
        SetLastError(0);
        return FALSE;
    }

    // Round the size up to a 32K (worst case) cluster size
    dwc |= 32768;
    dwc &= ~32767;

    lp->dwSize += dwc;
    return TRUE;
}


//  CDirectories::Find
//      Locates a directory entry previously added

LPDIRINFO
CDirectories::Find(
    LPCSTR lpID
    )
{
    LPDIRINFO lp;
    DWORD i;

    for (lp = m_lpdirs, i = 0 ; i < m_dwcDirsNow ; ++i, ++lp)
    {
        if (_stricmp(lp->szID, lpID) == 0)
            break;
    }

    if (i == m_dwcDirsNow)
        return NULL;
    else
        return lp;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\packer\packer.cpp ===
//  PACKER.CPP
//
//  Created 11-Mar-2001 [JonT]

// TODO: add complete .INI file validation: check for all required keys, sections
// TODO: Nuke [PackerSettings] section before copying to .exe

#include "packer.h"

int __cdecl
main(
    int argc,
    char** argv
    )
{
    DWORD dwTickStart = GetTickCount();
    int nRet;

    // Create our application object
    CPacker App;
    
    // Make sure the command line is OK
    if (!App.ParseCommandLine(argc, argv))
    {
        App.PrintUsage();
        return -1;
    }

    // Do all the work
    nRet = App.Process();

    // Print out elapsed time
    if (nRet == 0)
    {
        DWORD dwTickTotal = GetTickCount() - dwTickStart;
        DWORD dwHours = dwTickTotal / (1000 * 60 * 60);
        DWORD dwMinutes = (dwTickTotal % (1000 * 60 * 60)) / (1000 * 60);
        DWORD dwSeconds = ((dwTickTotal % (1000 * 60 * 60)) % (1000 * 60)) / 1000;
    
        printf("Time elapsed: %02d:%02d:%02d\n", dwHours, dwMinutes, dwSeconds);
    }

    return nRet;
}


//---------------------------------------------------------------------
//  CPacker -- our application class

    TCHAR CPacker::m_szIniName[MAX_PATH];

BOOL
CPacker::ParseCommandLine(
    int argc,
    char** argv
    )
{
    int nArg;

    *m_szIniName = 0;

    // Get the executable name
    --argc;
    m_lpLaunchName = argv[0];
    nArg = 1;

    // Process arguments
    for (; argc ; --argc, ++nArg)
    {
        // Is it a switch?
        if (*argv[nArg] == '-' || *argv[nArg] == '/')
        {
            switch (argv[nArg][1] | 32)
            {
            // Test (don't emit anything)
            case 't':
                m_fTestPack = TRUE;
                break;

            // Nologo
            case 'n':
                m_fNoLogo = TRUE;
                break;

            // Usage
            case '?':
            default:
                return FALSE;
            }
        }

        // Must be the ini file name
        else
        {
            // Fully-qualify the INI name
            if (_fullpath(m_szIniName, argv[nArg], _MAX_PATH) == NULL)
                return FALSE;
        }
    }

    // Make sure we got an .INI file
    if (*m_szIniName == 0)
        return FALSE;

    // Display banner if not nologo
    if (!m_fNoLogo)
    {
        printf("Microsoft (R) Self-Extracting Image Packer [%s]\n"
            "Copyright (C) Microsoft Corporation. All rights reserved.\n\n", __DATE__);
    }

    // If we're in test mode, tell them!
    if (m_fTestPack)
        printf("\nTEST MODE: no files will be generated.\n\n");

    return TRUE;
}


//  CPacker::PrintUsage
//      Displays usage message

void
CPacker::PrintUsage()
{
    printf("Usage: xpacker [flags] [filename]\n\n");
    printf("Packer builds a self-extracting executable as part of a simple\n"
           "setup engine.\n\n"
           "\t-? This message\n"
           "\t-t test build (don't emit any files but report errors)\n"
           "\n"
           "It requires a .INI file that describes where to locate the\n"
           "file packing list and the extractor .EXE to bundle in.\n"
           "It builds a .CAB file and a file manifest and attaches these\n"
           "to the extractor executable, which is a setup engine.\n\n");
}


//  CPacker::Process
//      Top-level code for packing the setup files

int
CPacker::Process()
{
    if (!OpenFiles())
        return -1;


    if (!ProcessFiles())
        return -1;

    if (!CreateSettingsCab())
        return -1;


    if (!WriteSelfExtractingExe())
        return -1;

    return 0;
}


//  CPacker::OpenFiles
//      Opens files and prepares for bulk of work in Process()

BOOL
CPacker::OpenFiles()
{
    LPSECTIONENUM lpSection;
    LPTSTR lpPackingList;
    LPSTR lpBuildFlavor;
    DWORD i;

    // Set up the settings file and make a copy so we can modify
    if (!m_settings.SetFile(m_szIniName, TRUE))
    {
        ::ReportError(m_szIniName, 0, "couldn't open settings file");
        return FALSE;
    }

    // Locate the packing list
    lpPackingList = m_settings.GetSetting(CSTR_PACKINGLIST);
    if (!m_plist.SetFile(&m_settings, lpPackingList, m_fTestPack))
    {
        ::ReportSettingsError(CSTR_PACKINGLIST, "couldn't open packing list \"%s\", error=0x%x", lpPackingList, m_plist.GetError());
        return FALSE;
    }
    free(lpPackingList);
    lpPackingList = NULL;

    // Open the manifest
    m_lpManifestName = m_settings.GetSetting(CSTR_MANIFEST);
    if (!m_manifest.SetFile(m_lpManifestName))
    {
        ::ReportSettingsError(CSTR_MANIFEST, "Couldn't open manifest file \"%s\", error=0x%x", m_lpManifestName, m_manifest.GetError());
        return FALSE;
    }

    // Get all the directories so we can sum disk usage for them
    lpSection = m_settings.EnumerateSection(CSTR_TARGETDIRECTORIES);
    m_dirs.Init(lpSection->dwcKeys);
    for (i = 0 ; i < lpSection->dwcKeys ; i++)
        m_dirs.Add(lpSection->keys[i].lpKey);
    m_settings.EnumerateFree(lpSection);

    // Create the cabfile for the files
    m_lpCabPath = m_settings.GetSetting(CSTR_CABPATH);
    strcpy(m_szFileCab, m_lpCabPath);
    if (*(m_lpCabPath + strlen(m_lpCabPath) - 1) != '\\')
        strcat(m_szFileCab, "\\");
    strcpy(m_szSettingsCab, m_szFileCab);
    strcat(m_szFileCab, TEXT("files.cab"));
    strcat(m_szSettingsCab, TEXT("settings.cab"));
    if (!m_cabFiles.SetFile(m_szFileCab, m_fTestPack))
    {
        ::ReportSettingsError(CSTR_CABPATH, "Couldn't create file cab \"%s\", error=0x%x", m_szFileCab, m_cabFiles.GetError()->erfOper);
        return FALSE;
    }

    // Get the build flavor
    lpBuildFlavor = m_settings.GetSetting(CSTR_BUILDFLAVOR);
    if (lpBuildFlavor == NULL || *lpBuildFlavor == 0)
    {
        ::ReportSettingsError(CSTR_BUILDFLAVOR, "no build flavor set");
        return FALSE;
    }
    m_plist.SetBuildFlavor(lpBuildFlavor);
    free(lpBuildFlavor);

    // Set the compression type
    LPSTR lpCompressionType = m_settings.GetSetting(CSTR_COMPRESSIONTYPE);
    LPSTR lpCompressionLevel = m_settings.GetSetting(CSTR_COMPRESSIONLEVEL);
    if (*lpCompressionType == 0)
    {
        free(lpCompressionType);
        lpCompressionType = _strdup("NONE");
    }
    if (!m_cabFiles.SetCompression(lpCompressionType, lpCompressionLevel) ||
        !m_cabSettings.SetCompression(lpCompressionType, lpCompressionLevel))
    {
        return FALSE;
    }
    if (_stricmp(lpCompressionType, "LZX") == 0)
        printf("Compression type set to LZX level %s (of 6)\n", lpCompressionLevel);
    else
        printf("Compression type set to %s\n", lpCompressionType);
    free(lpCompressionType);
    free(lpCompressionLevel);

    return TRUE;
}


//  CPacker::ProcessFiles
//      Walks through all the lines in the packing list and adds files
//      to the cabfile and lines to the manifest.

BOOL
CPacker::ProcessFiles()
{
    return m_plist.ProcessLines(&m_manifest, &m_cabFiles, &m_dirs);
}


//  CPacker::CreateSettingsCab
//      Makes a cabfile that contains the .INI file and the manifest

BOOL
CPacker::CreateSettingsCab()
{
    DWORD i;
    LPDIRINFO lpdi;
    TCHAR szDest[MAX_PATH];
    LPSTR lpCustomDll;
    LPSTR lpLicenseFile;
    LPSTR lpUninstaller;
    

    // Whack the sensitive packer sections from the ini file we're writing out
    m_settings.NukeSection(CSTR_PACKERPATHS);

    // Write out the directory sizes to the INI file
    m_dwTotalSize = 0;
    for (i = 0, lpdi = m_dirs.GetAll() ; i < m_dirs.GetCount() ; ++i, ++lpdi)
    {
        sprintf(szDest, "%d", lpdi->dwSize);
        m_settings.WriteString(CSTR_DIRSIZES, lpdi->szID, szDest);
        m_dwTotalSize += lpdi->dwSize;
    }

    // Write out the total size (in MB) to the ini file.
    // Don't write out 0 though.
    DWORD dwTotalSizeInBigUnits = m_dwTotalSize>>20;
    if(dwTotalSizeInBigUnits)
    {
        sprintf(szDest, "%d MB", dwTotalSizeInBigUnits);
    } else
    {
        dwTotalSizeInBigUnits = m_dwTotalSize>>10;
        if(!dwTotalSizeInBigUnits) dwTotalSizeInBigUnits = 1;
        sprintf(szDest, "%d KB", dwTotalSizeInBigUnits);
    }
    m_settings.WriteString(CSTR_DIRSIZES, CSTR_TOTALINSTALLSIZE, szDest);

    // Get the filenames for the custom dll, the license file and uninstaller exe
    lpCustomDll   = m_settings.GetSetting(CSTR_CUSTOMDLL);
    lpLicenseFile = m_settings.GetSetting(CSTR_LICENSEFILE);
    lpUninstaller = m_settings.GetSetting(CSTR_UNINSTALLER);

    // Create the settings cab and put stuff in it
    if (!m_cabSettings.SetFile(m_szSettingsCab, m_fTestPack))
    {
        ::ReportSettingsError(CSTR_CABPATH, "Couldn't create file cab \"%s\", error=0x%x", m_szSettingsCab, m_cabSettings.GetError()->erfOper);
        return FALSE;
    }
    if (!m_cabSettings.AddFile(m_settings.GetFile(), SCAB_SETTINGS) ||
        !m_cabSettings.AddFile(m_lpManifestName, SCAB_MANIFEST))
    {
        ::ReportSettingsError(CSTR_CABPATH, "Couldn't add files to settings cab, error=0x%x", m_cabSettings.GetError()->erfOper);
        return FALSE;
    }

    // Add the custom dll
    if (*lpCustomDll && !m_cabSettings.AddFile(lpCustomDll, SCAB_CUSTOMDLL))
    {
        ::ReportSettingsError(CSTR_CUSTOMDLL, "Couldn't find the custom dll file \"%s\" and add it to cab, error=0x%x", lpCustomDll, m_cabSettings.GetError()->erfOper);
        return FALSE;
    }

    // Handle multiple license files
    BOOL fLicFileFound = TRUE;
    TCHAR lpLicFilePattern[MAX_PATH+1];
    TCHAR lpPackedLicFilePattern[MAX_PATH+1];
    unsigned int uiCount = 1;
    
    lpLicFilePattern[MAX_PATH] = '\0';
    lpPackedLicFilePattern[MAX_PATH] = '\0';

    strcpy( lpPackedLicFilePattern, SCAB_LICENSE );
    do
    {
        // Add the license file
        if (!m_cabSettings.AddFile(lpLicenseFile, lpPackedLicFilePattern))
        {
            ::ReportSettingsError(CSTR_LICENSEFILE, "Couldn't find license file \"%s\" and add it to cab, error=0x%x", lpLicenseFile, m_cabSettings.GetError()->erfOper);
            return FALSE;
        }

        // Update our file name patterns for the license files
        sprintf( lpLicFilePattern, "%s%u", m_settings.m_strTable[CSTR_LICENSEFILE], uiCount );
        sprintf( lpPackedLicFilePattern, "%s%u", SCAB_LICENSE, uiCount );

        // Get the next license file name (if any) from the INI
        free( lpLicenseFile );
        lpLicenseFile = m_settings.GetSetting( lpLicFilePattern );
        
        if( ( NULL == lpLicenseFile ) || ( '\0' == *lpLicenseFile ) )
            fLicFileFound = FALSE;

        if( uiCount >= CSTR_LICENSE_MAX_FILES )
            fLicFileFound = FALSE;

        ++uiCount;
    } while( fLicFileFound );

    // Add the uninstaller
    if (!m_cabSettings.AddFile(lpUninstaller, SCAB_UNINSTALLER))
    {
        ::ReportSettingsError(CSTR_UNINSTALLER, "Couldn't find uninstall executable \"%s\" and add it to cab, error=0x%x", lpUninstaller, m_cabSettings.GetError()->erfOper);
        return FALSE;
    }
    m_cabSettings.Flush();

    return TRUE;
}


//  CPacker::WriteSelfExtractingExe
//      Modifies the template EXE file (the unpacker) and adds the both cabfiles as
//      resources.

BOOL
CPacker::WriteSelfExtractingExe()
{
    LPTSTR lpTemplate;
    LPTSTR lpExe;
    CExeResource res;

    // Build the extractor by inserting the cab and manifest into the extractor
    lpTemplate = m_settings.GetSetting(CSTR_UNPACKERTEMPLATE);
    lpExe = m_settings.GetSetting(CSTR_UNPACKERNEWEXE);

    // Prepare the EXE then insert the resources
    if (!res.SetFile(lpTemplate, lpExe))
    {
        ::ReportSettingsError(CSTR_UNPACKERTEMPLATE, "Couldn't update %s as template and make %s target .EXE file and add it to cab, error=0x%x", lpTemplate, lpExe, res.GetError());
        return FALSE;
    }

    // If this is just a test, all we do is delete the file and bail, we've validated sufficiently
    if (m_fTestPack)
    {
        res.Close();
        DeleteFile(lpExe);
        return TRUE;
    }

    // Get the total file sizes and tell the resource stuff about it
    HANDLE fh;
    DWORD dwSizeTotal = 0;
    DWORD dwFileCabSize = 0;
    if ((fh = CreateFile(m_szFileCab, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
            OPEN_EXISTING, 0, NULL)) != INVALID_HANDLE_VALUE)
    {
        dwFileCabSize = GetFileSize(fh, NULL);
        dwSizeTotal += dwFileCabSize;
        CloseHandle(fh);
    }
    if ((fh = CreateFile(m_szSettingsCab, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
            OPEN_EXISTING, 0, NULL)) != INVALID_HANDLE_VALUE)
    {
        dwSizeTotal += GetFileSize(fh, NULL);
        CloseHandle(fh);
    }
    res.SetTotalSize(dwSizeTotal);

    // Add the cabs to the file, first the file cab, then the settings cab
    if (!res.AddResourceFromFile(m_szFileCab) ||
        !res.AddResourceFromFile(m_szSettingsCab))
    {
        ::ReportSettingsError(CSTR_UNPACKERNEWEXE, "Couldn't add files to exe: %s, error=0x%x", lpExe, res.GetError());
        res.Close();
        DeleteFile(lpExe);
    }

    // Write the exe out
    else
        res.Close();

    // Clean up status
    fprintf(stderr, "Complete: %d of %d bytes             \n", dwSizeTotal, dwSizeTotal);

    // Get final statistics
    DWORD dwFinalSize = 0;
    if ((fh = CreateFile(lpExe, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
            OPEN_EXISTING, 0, NULL)) != INVALID_HANDLE_VALUE)
    {
        dwFinalSize = GetFileSize(fh, NULL);
        CloseHandle(fh);
    }
    printf("\nFile cab size: %s bytes\n", AddCommas(dwFileCabSize));
    printf("Worst-case uncompressed file size: %s bytes\n", AddCommas(m_dwTotalSize));
    printf("Compression ratio: %.2f%%\n", ((float)dwFileCabSize / (float)m_dwTotalSize) * 100.0);
    printf("Unpacking overhead: %s bytes\n", AddCommas(dwFinalSize - dwFileCabSize));
    printf("Final installer size: %s bytes\n", AddCommas(dwFinalSize));

    return TRUE;
}


//  CPacker::AddCommas
//      Adds commas in the disk size numbers

LPCTSTR
CPacker::AddCommas(
    __int64 li
    )
{
    static TCHAR sz[32];
    LPTSTR lp;
    DWORD i = 0;

    // Initialize and check for special case of zero
    sz[31] = 0;
    lp = &sz[30];
    if (li == 0)
    {
        *lp = '0';
        return lp;
    }

    // Loop until there are no more digits, adding digits and commas
    while (li)
    {
        *lp-- = (TCHAR)(UCHAR)(li % 10) + '0';
        li /= 10;
        if (++i == 3 && li != 0)
        {
            *lp-- = ',';
            i = 0;
        }
    }

    return lp + 1;
}



//---------------------------------------------------------------------
//  Error reporting

//  _ReportError
//      Since processing a packing list is akin to compiling a file,
//      make a compiler-style error message when we find an error

void
_ReportError(
    LPCTSTR lpFile,
    DWORD dwLine,
    LPCTSTR lpszFormat,
    va_list vararg
    )
{
    char szOutput[4096];

    // Get the full error message
    vsprintf(szOutput, lpszFormat, vararg);

    // Display the message
    if (dwLine != 0)
        printf("%s(%d) : error: %s\n", lpFile, dwLine, szOutput);
    else
        printf("%s : error: %s\n", lpFile, szOutput);
}


//  _ReportSettingsError
//      Report an error in settings in a different format since we don't
//      know the line number.

void
_ReportSettingsError(
    DWORD dwSetting,
    LPCTSTR lpszFormat,
    va_list vararg
    )
{
    char szOutput[4096];

    // Get the full error message
    vsprintf(szOutput, lpszFormat, vararg);

    // Display the message
    printf("%s : [%s]%s : error: %s\n", CPacker::m_szIniName,
           CSettingsFile::m_strTable[CSTR_SETTINGS],
           CSettingsFile::m_strTable[dwSetting], szOutput);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\packer\resource.cpp ===
//  RESOURCE.CPP
//
//  Created 13-Mar-2001 [JonT]

#include "packer.h"

//---------------------------------------------------------------------

//  CExeResource::SetFile
//      Sets an EXE for adding resources to

BOOL CExeResource::SetFile(
    LPCTSTR lpTemplateExe,
    LPCTSTR lpNewExe
    )
{
    Close();

    // Copy the template .EXE to the new .EXE name
    if (!CopyFile(lpTemplateExe, lpNewExe, FALSE))
    {
        m_error = GetLastError();
        return FALSE;
    }

    // Open the file and prepare to append to it
    m_handle = CreateFile(lpNewExe, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
    if (m_handle == INVALID_HANDLE_VALUE)
    {
        m_error = GetLastError();
        return FALSE;
    }
    SetFilePointer(m_handle, 0, NULL, FILE_END);

    return TRUE;
}


//  CExeResource::Close
//      Finishes the resource update and either writes or doesn't write the changes

typedef struct _EOFSTRUCT
{
    DWORD dwcFiles;
    DWORD dwSignature;
} EOFSTRUCT;

void
CExeResource::Close()
{
    EOFSTRUCT es;
    DWORD dwc;

    // Make sure we have something actually open
    if (m_handle == INVALID_HANDLE_VALUE)
        return;

    // Write out the variable-sized array of file sizes
    WriteFile(m_handle, m_dwSizes, m_dwcFiles * sizeof (DWORD), &dwc, NULL);

    // Write the end of file structure out
    es.dwcFiles = m_dwcFiles;
    es.dwSignature = 'XOBX';
    WriteFile(m_handle, &es, sizeof (EOFSTRUCT), &dwc, NULL);

    // Make sure the EXE size is set correctly so signing tools don't tromp us
    DWORD dwSeekPosition = SetFilePointer(m_handle, 0, NULL, FILE_CURRENT);

    // Seek back to the start of the file and read the dos EXE header.
    // Write it back out with our seek position tucked away in it.
    IMAGE_DOS_HEADER dos;
    SetFilePointer(m_handle, 0, NULL, FILE_BEGIN);
    ReadFile(m_handle, &dos, sizeof (dos), &dwc, NULL);
    *(DWORD*)(&dos.e_res[0]) = dwSeekPosition;
    SetFilePointer(m_handle, 0, NULL, FILE_BEGIN);
    WriteFile(m_handle, &dos, sizeof (dos), &dwc, NULL);

    CloseHandle(m_handle);
    m_handle = INVALID_HANDLE_VALUE;
}


//  CExeResource::AddResourceFromFile
//      Reads in an entire file and inserts it as a resource into the executable.

#define MAX_COPY_SIZE 65536

BOOL
CExeResource::AddResourceFromFile(
    LPCTSTR lpFile
    )
{
    HANDLE fh;
    DWORD dwc;
    DWORD dwcWritten;
    DWORD dwcTotal = 0;

    // Open the file and add to the end of the target file
    fh = CreateFile(lpFile, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
                    FILE_FLAG_NO_BUFFERING, NULL);
    if (fh == INVALID_HANDLE_VALUE)
    {
        m_error = GetLastError();
        return FALSE;
    }

    // Allocate an aligned buffer for unbuffered copies
    LPBYTE lpb = (LPBYTE)VirtualAlloc(NULL, MAX_COPY_SIZE, MEM_COMMIT, PAGE_READWRITE);

    // Read chunks of the input file and write to the output file
    do
    {
        // Read a chunk
        if (!ReadFile(fh, lpb, MAX_COPY_SIZE, &dwc, NULL))
            break;

        // Keep track of the number of bytes written
        dwcTotal += dwc;
        m_dwCurrent += dwc;

        // Display progress as we go
        fprintf(stderr, "progress: %d of %d bytes           \r", m_dwCurrent, m_dwTotal);

        // Write out the number of bytes read
        if (!WriteFile(m_handle, lpb, dwc, &dwcWritten, NULL))
            break;
    }
    while (dwc == MAX_COPY_SIZE);
    CloseHandle(fh);
    VirtualFree(lpb, 0, MEM_RELEASE);

    // Return error if we couldn't read anything
    if (dwcTotal == 0)
    {
        m_error = GetLastError();
        return FALSE;
    }

    // Record the number of bytes written in this file
    m_dwSizes[m_dwcFiles++] = dwcTotal;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\packer\PLIST.CPP ===
//  PLIST.CPP
//
//  Created 12-Mar-2001 [JonT]

#include "packer.h"

//---------------------------------------------------------------------
//  CPackingList class


//  CPackingList::SetFile
//      Opens the packing list file, returns error if it cannot be located

BOOL
CPackingList::SetFile(
    CSettingsFile* psettings,
    LPCTSTR lpPackingList,
    BOOL fTestOnly
    )
{
    DWORD dwLen;
    DWORD dwActuallyRead;
    HANDLE hfile;

    // Save the test-only flag
    m_fTestOnly = fTestOnly;

    // Save the settings object
    m_psettings = psettings;

    // Keep the name of the packing list around
    lstrcpyn(m_szPackingList, lpPackingList, MAX_PATH);

    // Free any memory before allocating a new buffer
    if (m_lpEntireFile)
        free(m_lpEntireFile);

    // Try to open the file
    hfile = CreateFile(lpPackingList, GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
        FILE_FLAG_SEQUENTIAL_SCAN, NULL);
    if (hfile == INVALID_HANDLE_VALUE)
    {
        m_error = GetLastError();
        return FALSE;
    }

    // Read the entire file
    dwLen = GetFileSize(hfile, NULL);
    if (dwLen == 0xffffffff)
    {
        m_error = GetLastError();
        return FALSE;
    }

    // Allocate a buffer big enough for the whole file
    m_lpEntireFile = (LPSTR)malloc(dwLen + 1);
    if (!m_lpEntireFile)
    {
        m_error = ERROR_OUTOFMEMORY;
        return FALSE;
    }

    // Read it completely and zero-terminate
    if (!ReadFile(hfile, m_lpEntireFile, dwLen, &dwActuallyRead, NULL) ||
        dwActuallyRead != dwLen)
    {
        m_error = GetLastError();
        return FALSE;
    }
    *(m_lpEntireFile + dwLen) = 0;

    // Close file, we're done with it
    CloseHandle(hfile);

    // Point to the first content
    m_lpLine = m_lpEntireFile;

    // Get the time to update all the files to
    LPSTR lpDateUpdate = m_psettings->GetSetting(CSTR_UPDATEDATESTO);
    if (lpDateUpdate && *lpDateUpdate)
    {
        // Parse the month, day, year from the settings string
        LPSTR lpMonth = lpDateUpdate;
        LPSTR lpDay;
        LPSTR lpYear;
        for (lpDay = lpMonth ; *lpDay ; ++lpDay)
        {
            if (*lpDay == '/' || *lpDay == '-')
            {
                *lpDay++ = 0;
                break;
            }
        }
        for (lpYear = lpDay ; *lpYear ; ++lpYear)
        {
            if (*lpYear == '/' || *lpYear == '-')
            {
                *lpYear++ = 0;
                break;
            }
        }

        // Get the parsed string date components into a SYSTEMTIME
        SYSTEMTIME st = { 0 };
        st.wYear = (WORD)atoi(lpYear);
        if (st.wYear < 80)
            st.wYear += 2000;
        else if (st.wYear < 100)
            st.wYear += 1900;
        st.wMonth = (WORD)atoi(lpMonth);
        st.wDay = (WORD)atoi(lpDay);

        // Save the time as a FILETIME for later use, plus a flag if we have a valid date
        FILETIME ftLocal;
        m_fDateUpdate = SystemTimeToFileTime(&st, &ftLocal);
        LocalFileTimeToFileTime(&ftLocal, &m_ftUpdateTo);
    }

    return TRUE;
}


//  CPackingList::SetBuildFlavor
//      Sets the 'build flavor.' This allows a single packing list
//      to serve for multiple installs. Only files matching one or
//      more of the build flavor flags will be emitted into the manifest
//      and cabfile.

void
CPackingList::SetBuildFlavor(
    LPCSTR lp
    )
{
    m_dwBuildFlavor = AccumulateFlavor(lp);
}


//  CPackingList::ProcessLines
//      Drives the loop through all lines in the manifest

BOOL
CPackingList::ProcessLines(
    CManifest* pmanifest,
    CCabFile* pcabfile,
    CDirectories* pdirs
    )
{
    DWORD dwcLines = 0;
    DWORD dwcCurrent = 0;

    // Keep these objects around so the command handlers can see them
    m_pmanifest = pmanifest;
    m_pcabfile = pcabfile;
    m_pdirs = pdirs;

    // Count lines for progress indicator
    m_lpLine = m_lpEntireFile;
    do
    {
        ++dwcLines;
    }
    while (!::SkipRestOfLine(m_lpLine));

    // Loop through all the files in our packing list
    m_lpLine = m_lpEntireFile;
    do
    {
        // Skip over any leading whitespace
        ::SkipWhitespace(m_lpLine);

        // See if we need to process this line. If the build flavor
        // flags don't match, we skip...
        if (!(GetBuildFlavor() & m_dwBuildFlavor))
            continue;

        // Get the Lang IDs for the current line
        LPSTR lpLangIDs = m_lpLine;
        ::ZapComma(m_lpLine);
        m_LangIDs.ParseLangIDs( lpLangIDs );

        // Get the command type for this line
        m_lpCommand = GetCommand();

        // Dispatch the various types of commands
        if (!DispatchCommand())
        {
            ReportError("packing list command '%s' not supported", m_lpCommand);
        }

        // Display progress
        fprintf(stderr, "progress: %d of %d lines     \r", ++dwcCurrent, dwcLines);
    }
    while (!::SkipRestOfLine(m_lpLine));

    // If there are errors, bail
    if (m_dwcErrors > 0)
    {
        printf("%d error%s, stopping.                                              \n",
            m_dwcErrors, m_dwcErrors > 1 ? "s" : "");
        return FALSE;
    }

    fprintf(stderr, "Complete: %d of %d lines             \n", ++dwcCurrent, dwcLines);

    // Write out the manifest and the cab
    pmanifest->Close();

    fprintf(stderr, "Writing out cab file...\n");

    pcabfile->Flush();
    return TRUE;
}


//  CPackingList::~CPackingList

CPackingList::~CPackingList()
{
    // Free the buffer
    if (m_lpEntireFile)
    {
        free(m_lpEntireFile);
        m_lpEntireFile = NULL;
        m_lpLine = NULL;
    }
}

//---------------------------------------------------------------------
//  Private methods

//  _ReportError
//      Since processing a packing list is akin to compiling a file,
//      make a compiler-style error message when we find an error

void
CPackingList::_ReportError(
    LPCTSTR lpszFormat,
    va_list vararg
    )
{
    DWORD dwLine = 1;
    LPCSTR lp;

    // Increment the number of errors
    ++m_dwcErrors;

    // Count the number of LF characters up to the error line
    for (lp = m_lpEntireFile ; lp != m_lpCommand ; ++lp)
    {
        if (*lp == '\n')
            ++dwLine;
    }

    // Display the message
    ::_ReportError(m_szPackingList, dwLine, lpszFormat, vararg);
}

//  GetCommand
//      Returns a pointer to the command portion of the packing list line
//      and moves the pointer past it

LPCSTR
CPackingList::GetCommand()
{
    LPSTR lpCommand = m_lpLine;

    // Aap the comma and move the pointer past it
    ::ZapComma(m_lpLine);

    return lpCommand;
}


//  DispatchCommand
//      Calls the appropriate command handler for the given command

BOOL
CPackingList::DispatchCommand()
{
    int i;

    // Loop through all commands until we find a match
    for (i = 0 ; m_CommandList[i].lpText != NULL ; i++)
    {
        if (_stricmp(m_lpCommand, m_CommandList[i].lpText) == 0)
        {
            (this->*m_CommandList[i].lpHandler)();
            return TRUE;
        }
    }

    return FALSE;
}


//  GetBuildFlavor
//      Returns the DWORD build flavor flags retrieved on the packing list line
//      and moves the pointer past it

DWORD
CPackingList::GetBuildFlavor()
{
    LPSTR lpFlavor = m_lpLine;

    // Aap the comma and move the pointer past it
    ::ZapComma(m_lpLine);

    return AccumulateFlavor(lpFlavor);
}


//  CPackingList::AccumulateFlavor
//      ORs bits into the build flavor. Note that each letter has a unique
//      value by doing 1 << (letter value 1-26). This way, we can have a single
//      packing list line be marked for one or more build flavors.

DWORD
CPackingList::AccumulateFlavor(
    LPCSTR lp
    )
{
    UCHAR ch;
    DWORD dwAccum;

    // Add flag values for each letter in the list
    for (dwAccum = 0 ; *lp != 0 ; ++lp)
    {
        ch = (*lp | 32) - 'a';
        if (ch < 26)
            dwAccum |= 1 << ch;
    }

    return dwAccum;
}

//---------------------------------------------------------------------
//  Packing List commands
//      To add a new packing list command, you must add it to this table, add a new
//      function here with the correct signature, and add this member function
//      to CPackingList in packer.h.

    const COMMAND CPackingList::m_CommandList[] =
    {
        { "file", ProcessFile },
        { "source", ProcessCopySource },
        { "remove", ProcessRemove },
        { "removedir", ProcessRemove },
        { "addreg", ProcessRegCommands },
        { "delreg", ProcessRegCommands },
        { "copy", ProcessCopy },
        { "shortcut", ProcessShortcut },
        { NULL, NULL }
    };


//  ProcessFile
//      Handles a file entry from the packing list
//      The format of a file line is:
//      flavor, command, source root, source path, source file, target root, target path,
//          target file, flags

#define LINE_FILE_SRCROOT 0
#define LINE_FILE_SRCPATH 1
#define LINE_FILE_SRCFILE 2
#define LINE_FILE_TRGROOT 3
#define LINE_FILE_TRGPATH 4
#define LINE_FILE_TRGFILE 5
#define LINE_FILE_FLAGS   6
#define MAX_FILE_LINE 7
#define MIN_FILE_LINE 4

BOOL
CPackingList::ProcessFile()
{
    TCHAR szSource[MAX_PATH];
    TCHAR szDest[MAX_PATH];
    DWORD dwc;
    LPCSTR lpRoot;
    char bFileInfo[FILEINFO_SAVE_SIZE];

    // Parse the rest of the line.
    LPSTR lp[MAX_FILE_LINE];
    ::ParseLine(m_lpLine, lp, MAX_FILE_LINE, &dwc);
    if (dwc < MIN_FILE_LINE || dwc > MAX_FILE_LINE)
    {
        // Report number of entries including command
        ReportError("expected %d entries, received %d", MAX_FILE_LINE + 1, dwc + 1);
        return FALSE;
    }

    // Source name
    lpRoot = m_psettings->GetString(CSTR_PACKERPATHS, lp[LINE_FILE_SRCROOT]);
    szSource[0] = 0;
    if (*lpRoot != 0)
    {
        strcpy(szSource, lpRoot);
        ::AppendSlash(szSource);
    }
    strcat(szSource, lp[LINE_FILE_SRCPATH]);
    ::AppendSlash(szSource);
    strcat(szSource, lp[LINE_FILE_SRCFILE]);

    // Target name. Prepend the root name to make sure it's unique
    // If the target name is blank, use the source name
    strcpy(szDest, lp[LINE_FILE_TRGROOT]);
    ::AppendSlash(szDest);
    strcat(szDest, lp[LINE_FILE_TRGPATH]);
    ::AppendSlash(szDest);
    if (*lp[LINE_FILE_TRGFILE] != 0)
        strcat(szDest, lp[LINE_FILE_TRGFILE]);
    else
        strcat(szDest, lp[LINE_FILE_SRCFILE]);

    // Get the information about the source file. Note that since this is the
    // first time we have touched the file, we report the errors when we can't find
    // the file here.
    CFileInfo fi;
    if (!fi.Get(szSource))
    {
        DWORD dw = GetLastError();
        if (dw == ERROR_FILE_NOT_FOUND || dw == ERROR_PATH_NOT_FOUND)
            ReportError("file '%s' not found", szSource);
        else
            ReportError("couldn't open %s (error is %08x)", szSource, GetLastError());
        return FALSE;
    }

    // If we need to update the date, do so
    if (m_fDateUpdate)
        fi.NoLessThan(m_ftUpdateTo);

    // Account for this file's size in the directory size
    fi.Save(bFileInfo);
    m_pdirs->AddSize(lp[LINE_FILE_TRGROOT], fi.GetSize());

    // See if we've detected a duplicate file
    LPSTR lpCopyTarget = NULL;
    lpCopyTarget = m_filehash.FindDuplicate(szSource, lp[LINE_FILE_TRGROOT], szDest);

    // Did we find a duplicate?
    if (lpCopyTarget != NULL)
    {
        // See if the file is COMPLETELY duplicate: same source, dest name
        if (_stricmp(lpCopyTarget, szDest) == 0)
        {
            ReportError("Duplicate file (%s) encountered!", szDest);
            return FALSE;
        }

        // This file is a copy so just write a copy line to the manifest
        m_pmanifest->WriteCommand(&m_LangIDs, "copy", lp[LINE_FILE_TRGROOT], lpCopyTarget,
                             szDest, lp[LINE_FILE_FLAGS], bFileInfo, NULL);
    }

    // Otherwise, process the normal file command
    else
    {
        // Write a line to the manifest
        m_pmanifest->WriteCommand(&m_LangIDs, m_lpCommand, lp[LINE_FILE_TRGROOT], szDest, lp[LINE_FILE_FLAGS], bFileInfo, NULL);
    
        // Add to cab
        if (!m_pcabfile->AddFile(szSource, szDest))
        {
            ReportError("couldn't add %s to cab (error is %08x)", szSource, m_pcabfile->GetError()->erfOper);
            return FALSE;
        }
    }

    return TRUE;
}

//  ProcesssCopySource
//      Handles a 'source' entry from the packing list.
//      A source entry is the source of a copy command. This line doesn't
//      emit anything to the manifest but allows future copy entries to
//      reference this one.
//      The format of a file line is:
//      flavor, command, source id, source root, source path, source file, target root

#define LINE_SOURCE_SRCID   0
#define LINE_SOURCE_SRCROOT 1
#define LINE_SOURCE_SRCPATH 2
#define LINE_SOURCE_SRCFILE 3
#define LINE_SOURCE_TRGROOT 4
#define MAX_SOURCE_LINE 5
#define MIN_SOURCE_LINE 5

BOOL
CPackingList::ProcessCopySource()
{
    TCHAR szSource[MAX_PATH];
    DWORD dwc;
    LPCSTR lpRoot;
    LPSOURCENODE pnode;

    // Parse the rest of the line.
    LPSTR lp[MAX_SOURCE_LINE];
    ::ParseLine(m_lpLine, lp, MAX_SOURCE_LINE, &dwc);
    if (dwc < MIN_SOURCE_LINE || dwc > MAX_SOURCE_LINE)
    {
        // Report number of entries including command
        ReportError("expected %d entries, received %d", MAX_SOURCE_LINE + 1, dwc + 1);
        return FALSE;
    }

    // Source name
    lpRoot = m_psettings->GetString(CSTR_PACKERPATHS, lp[LINE_SOURCE_SRCROOT]);
    szSource[0] = 0;
    if (*lpRoot != 0)
    {
        strcpy(szSource, lpRoot);
        ::AppendSlash(szSource);
    }
    strcat(szSource, lp[LINE_SOURCE_SRCPATH]);
    ::AppendSlash(szSource);
    strcat(szSource, lp[LINE_SOURCE_SRCFILE]);

    // Create a new source node entry
    pnode = (LPSOURCENODE)malloc(sizeof (SOURCENODE));
    if (pnode == NULL)
    {
        ReportError("out of memory");
        return FALSE;
    }
    pnode->pNext = m_psources;
    m_psources = pnode;
    pnode->lpID = _strdup(lp[LINE_SOURCE_SRCID]);
    pnode->lpRoot = _strdup(lp[LINE_SOURCE_TRGROOT]);
    pnode->lpSource = _strdup(szSource);
    pnode->lpName = _strdup(lp[LINE_SOURCE_SRCFILE]);

    // Find the file and get its time/date and size. Note that this is the first time
    // we have tried to locate the file, so report error here.
    CFileInfo fi;
    if (!fi.Get(szSource))
    {
        DWORD dw = GetLastError();
        if (dw == ERROR_FILE_NOT_FOUND || dw == ERROR_PATH_NOT_FOUND)
            ReportError("file '%s' not found", szSource);
        else
            ReportError("couldn't open %s (error is %08x)", szSource, GetLastError());
        return FALSE;
    }

    // If we need to update the date, do so
    if (m_fDateUpdate)
        fi.NoLessThan(m_ftUpdateTo);

    // Save the information in the structure to pull out later...
    fi.Save(pnode->bFileInfo);
    pnode->nSize = -(int)fi.GetSize();

    return TRUE;
}



//  ProcessCopy
//      Handles a file entry from the packing list
//      The format of a file line is:
//      flavor, command, id, target path, target file, flags

#define LINE_COPY_ID      0
#define LINE_COPY_TRGPATH 1
#define LINE_COPY_TRGFILE 2
#define LINE_COPY_FLAGS   3
#define MAX_COPY_LINE 4
#define MIN_COPY_LINE 2

BOOL
CPackingList::ProcessCopy()
{
    TCHAR szDest[MAX_PATH];
    DWORD dwc;
    LPSOURCENODE pnode;

    // Parse the rest of the line.
    LPSTR lp[MAX_COPY_LINE];
    ::ParseLine(m_lpLine, lp, MAX_COPY_LINE, &dwc);
    if (dwc < MIN_COPY_LINE || dwc > MAX_COPY_LINE)
    {
        // Report number of entries including command
        ReportError("expected %d entries, received %d", MAX_COPY_LINE + 1, dwc + 1);
        return FALSE;
    }

    // Find the SOURCENODE entry
    for (pnode = m_psources ; pnode != NULL ; pnode = pnode->pNext)
    {
        if (_stricmp(pnode->lpID, lp[LINE_COPY_ID]) == 0)
            break;
    }
    if (pnode == NULL)
    {
        // Report number of entries including command
        ReportError("source ID '%s' not found", lp[LINE_COPY_ID]);
        return FALSE;
    }

    // Dest name
    strcpy(szDest, pnode->lpRoot);
    ::AppendSlash(szDest);
    strcat(szDest, lp[LINE_COPY_TRGPATH]);
    ::AppendSlash(szDest);
    if (*lp[LINE_COPY_TRGFILE] == 0)
        strcat(szDest, pnode->lpName);
    else
        strcat(szDest, lp[LINE_COPY_TRGFILE]);

    // The first time we encounter a copy entry, we need to actually
    // create the file on the target, so we emit a file to the manifest.
    // Every time we encounter it after this, we emit a copy to copy that file
    // to the target location. Saves a lot of space in the cabfile...
    if (pnode->nSize < 0)
    {
        // Write the manifest line
        m_pmanifest->WriteCommand(&m_LangIDs, "file", pnode->lpRoot, szDest, lp[LINE_COPY_FLAGS], pnode->bFileInfo, NULL);

        // Add to cab
        if (!m_pcabfile->AddFile(pnode->lpSource, szDest))
        {
            ReportError("couldn't add %s to cab (error is %08x)",
                        pnode->lpSource, m_pcabfile->GetError()->erfOper);
            return FALSE;
        }

        // We're done with the source location now, so save the dest location.
        // This dest location next time will be the source of the copy
        free(pnode->lpSource);
        pnode->lpSource = _strdup(szDest);
        pnode->nSize = -pnode->nSize;
    }
    else
    {
        // Write the copy line to the manifest
        m_pmanifest->WriteCommand(&m_LangIDs, m_lpCommand, pnode->lpRoot, pnode->lpSource,
                             szDest, lp[LINE_COPY_FLAGS], pnode->bFileInfo, NULL);
    }

    // Add the size for this entry
    m_pdirs->AddSize(pnode->lpRoot, pnode->nSize);

    return TRUE;
}


//  ProcessRemove
//      Handles a 'remove' entry from the packing list
//      The format of a file line is:
//      flavor, command, target root, target path, target file, flags

#define LINE_REMOVE_TRGROOT 0
#define LINE_REMOVE_TRGPATH 1
#define LINE_REMOVE_TRGFILE 2
#define LINE_REMOVE_FLAGS   3
#define MAX_REMOVE_LINE 4
#define MIN_REMOVE_LINE 3

BOOL
CPackingList::ProcessRemove()
{
    TCHAR szFile[MAX_PATH];
    DWORD dwc;

    // Parse the rest of the line.
    LPSTR lp[MAX_REMOVE_LINE];
    ::ParseLine(m_lpLine, lp, MAX_REMOVE_LINE, &dwc);
    if (dwc < MIN_REMOVE_LINE || dwc > MAX_REMOVE_LINE)
    {
        // Report number of entries including command
        ReportError("expected %d entries, received %d", MAX_REMOVE_LINE + 1, dwc + 1);
        return FALSE;
    }

    strcpy(szFile, lp[LINE_REMOVE_TRGPATH]);
    if (szFile[0] != 0 && lp[LINE_REMOVE_TRGFILE][0] != 0)
        ::AppendSlash(szFile);
    strcat(szFile, lp[LINE_REMOVE_TRGFILE]);

    // Write a line to the manifest
    m_pmanifest->WriteCommand(&m_LangIDs, m_lpCommand, lp[LINE_REMOVE_TRGROOT], szFile, lp[LINE_REMOVE_FLAGS], NULL);

    return TRUE;
}


//  ProcessRegCommands
//      Handles 'addreg' 'delreg' entries from the packing list
//      The format of a file line is:
//      flavor, command, root key, subkey, value name, value, flags

#define LINE_REG_ROOTKEY   0
#define LINE_REG_SUBKEY    1
#define LINE_REG_VALUENAME 2
#define LINE_REG_VALUE     3
#define LINE_REG_FLAGS     4
#define MAX_REG_LINE 5
#define MIN_REG_LINE 3

BOOL
CPackingList::ProcessRegCommands()
{
    DWORD dwc;

    // Parse the rest of the line.
    LPSTR lp[MAX_REG_LINE];
    ::ParseLine(m_lpLine, lp, MAX_REG_LINE, &dwc);
    if (dwc < MIN_REG_LINE || dwc > MAX_REG_LINE)
    {
        // Report number of entries including command
        ReportError("expected %d entries, received %d", MAX_REG_LINE + 1, dwc + 1);
        return FALSE;
    }

    // Write a line to the manifest
    m_pmanifest->WriteCommand(
        &m_LangIDs,
        m_lpCommand,
        lp[LINE_REG_ROOTKEY],
        lp[LINE_REG_SUBKEY],
        lp[LINE_REG_VALUENAME],
        lp[LINE_REG_VALUE],
        lp[LINE_REG_FLAGS],
        NULL);

    return TRUE;
}


//  CPackingList::ProcessShortcut
//      Processes start menu shortcuts.
//      Format of packing list file line is:
//      flavor, command, target root, target path, target file, shortcut path, shortcut file

#define LINE_SHORTCUT_TRGROOT   0
#define LINE_SHORTCUT_TRGPATH   1
#define LINE_SHORTCUT_TRGFILE   2
#define LINE_SHORTCUT_SHPATH    3
#define LINE_SHORTCUT_SHFILE    4
#define LINE_SHORTCUT_DESCRIPTION 5
#define MAX_SHORTCUT_LINE 6
#define MIN_SHORTCUT_LINE 6

BOOL
CPackingList::ProcessShortcut()
{
    DWORD dwc;
    TCHAR szFile[MAX_PATH];
    TCHAR szShortcut[MAX_PATH];

    // Parse the rest of the line.
    LPSTR lp[MAX_SHORTCUT_LINE];
    ::ParseLine(m_lpLine, lp, MAX_SHORTCUT_LINE, &dwc);
    if (dwc < MIN_SHORTCUT_LINE || dwc > MAX_SHORTCUT_LINE)
    {
        // Report number of entries including command
        ReportError("expected %d entries, received %d", MAX_SHORTCUT_LINE + 1, dwc + 1);
        return FALSE;
    }

    // Build the target path and shortcut path
    strcpy(szFile, lp[LINE_SHORTCUT_TRGPATH]);
    if (szFile[0] != 0)
        ::AppendSlash(szFile);
    strcat(szFile, lp[LINE_SHORTCUT_TRGFILE]);
    strcpy(szShortcut, lp[LINE_SHORTCUT_SHPATH]);
    if (szShortcut[0] != 0)
        ::AppendSlash(szShortcut);
    strcat(szShortcut, lp[LINE_SHORTCUT_SHFILE]);

    // Write out the manifest line
    m_pmanifest->WriteCommand(&m_LangIDs, m_lpCommand, lp[LINE_SHORTCUT_TRGROOT], szFile, szShortcut,
        lp[LINE_SHORTCUT_DESCRIPTION], NULL);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\packer\packer.h ===
//  PACKER.H
//
//  Created 12-Mar-2001 [JonT]

#ifndef _PACKER_H
#define _PACKER_H

#include <stdio.h>
#include <windows.h>
#include <string.h>
#include <stdlib.h>
#include <io.h>
#include <fcntl.h>
#include <fci.h>

#define PACKER
// stuff from common.lib (private\setup\common)
#include "..\common\global.h"
#include "..\common\settings.h"
#include "..\common\parse.h"
#include "..\common\fileinfo.h"
#include "..\common\langid.h"


//---------------------------------------------------------------------
//  Error reporting

    void _ReportError(LPCTSTR lpFile, DWORD dwLine, LPCTSTR lpszFormat, va_list vararg);
    void _ReportSettingsError(DWORD dwSetting, LPCTSTR lpszFormat, va_list vararg);

inline void
ReportError(
    LPCTSTR lpFile,
    DWORD dwLine,
    LPCTSTR lpszFormat,
    ...
    )
{
    va_list vararg;
    va_start(vararg, lpszFormat);
    _ReportError(lpFile, dwLine, lpszFormat, vararg);
    va_end(vararg);
}


inline void
ReportSettingsError(
    DWORD dwSetting,
    LPCTSTR lpszFormat,
    ...
    )
{
    va_list vararg;
    va_start(vararg, lpszFormat);
    _ReportSettingsError(dwSetting, lpszFormat, vararg);
    va_end(vararg);
}

//---------------------------------------------------------------------
//  CFileHash

typedef struct _FILENODE
{
    struct _FILENODE* pnext;
    DWORD m_dwSize;
    LPSTR m_lpName;
    LPSTR m_lpCopyTarget;
    LPSTR m_lpCopyRoot;
} FILENODE, *LPFILENODE;

#define TABLE_SIZE 4001     // prime number

class CFileHash
{
private:
    LPFILENODE m_lhHashTable[TABLE_SIZE];
    DWORD HashSizeToIndex(DWORD dwSize);
    BOOL FileCompare(LPCSTR lpFile1, LPCSTR lpFile2);

public:
    CFileHash();
    LPSTR FindDuplicate(LPCTSTR lpName, LPCTSTR lpCopyRoot, LPCTSTR lpCopyTarget);
};


//---------------------------------------------------------------------
//  CCabFile
//      Manages the FCI (File Compression Interface) and provides an interface
//      to add files to the cabinet.

class CCabFile
{
private:
    HFCI m_hfci;
    ERF m_erf;
    CCAB m_cab;
    BOOL m_fTestOnly;
    DWORD m_dwCompression;

public:
    CCabFile();
    ~CCabFile();

    // Point instance at a particular cab file
    BOOL SetFile(LPCTSTR lpCabFile, BOOL fTestOnly);

    // Sets the type and level of compression to be used
    BOOL SetCompression(LPCSTR lpType, LPCSTR lpLevel);

    // Add a file to the cabinet
    BOOL AddFile(LPCTSTR lpSource, LPCTSTR lpDest);

    // Write the cabinet out to disk
    BOOL Flush();

    // Check error status after failed call
    PERF GetError() { return &m_erf; }

    // Sets the mode to test-only so that nothing is really done but validates
    // all files anyway.
    void SetTestOnly();
};

inline
CCabFile::CCabFile()
{
    m_hfci = NULL;
    memset(&m_erf, sizeof (ERF), 1);
    m_fTestOnly = FALSE;
}

inline void
CCabFile::SetTestOnly()
{
    m_fTestOnly = TRUE;
}

//---------------------------------------------------------------------
//  CManifest
//      Handles the manifest file.
//      The manifest is the output file from the packer that describes
//      all files in the cabinet.

class CManifest
{
private:
    FILE* m_handle;
    DWORD m_error;

public:
    CManifest()
    {
        m_handle = NULL;
    }
    ~CManifest();

    BOOL SetFile(LPTSTR lpManifest);
    BOOL WriteCommand(CLangID* pLangIDs, LPCTSTR lpCommand, ...);
    void Close();
    DWORD GetError() { return m_error; }
};


//---------------------------------------------------------------------
//  CExeResource

#define RES_MAX_FILES 5

class CExeResource
{
private:
    HANDLE m_handle;
    DWORD m_error;
    DWORD m_dwSizes[RES_MAX_FILES];
    DWORD m_dwcFiles;
    DWORD m_dwTotal;
    DWORD m_dwCurrent;

public:
    CExeResource() { m_handle = INVALID_HANDLE_VALUE; m_dwcFiles = 0; }
    ~CExeResource() { Close(); }

    BOOL SetFile(LPCTSTR lpTemplateExe, LPCTSTR lpNewExe);
    void Close();
    VOID SetTotalSize(DWORD dwTotal) { m_dwCurrent = 0; m_dwTotal = dwTotal; }
    BOOL AddResourceFromFile(LPCTSTR lpFile);
    DWORD GetError() { return m_error; }
};


//---------------------------------------------------------------------
//  CDirectories
//      Manages a list of directories encountered in the settings file

#define MAX_ID 64

typedef struct _DIRINFO
{
    char szID[MAX_ID];
    DWORD dwSize;
} DIRINFO, *LPDIRINFO;

class CDirectories
{
private:
    DWORD m_dwcDirsMax;
    DWORD m_dwcDirsNow;
    LPDIRINFO m_lpdirs;

public:
    CDirectories() { m_dwcDirsMax = m_dwcDirsNow = 0; m_lpdirs = NULL; }
    ~CDirectories() { if (m_lpdirs) free(m_lpdirs); }

    BOOL Init(DWORD dwc);
    BOOL Add(LPSTR lpID);
    BOOL AddSize(LPCSTR lpID, LPCSTR lpFile);
    BOOL AddSize(LPCSTR lpID, DWORD dwc);
    LPDIRINFO Find(LPCSTR lpID);
    DWORD GetCount() { return m_dwcDirsNow; }
    LPDIRINFO GetAll() { return m_lpdirs; }
};


//---------------------------------------------------------------------
//  CPackingList
//      Manages the packing list file and allows the program to walk through
//      the list.

typedef struct _SOURCENODE
{
    struct _SOURCENODE* pNext;
    LPSTR lpID;
    int nSize;
    LPSTR lpRoot;
    LPSTR lpSource;
    LPSTR lpName;
    char bFileInfo[FILEINFO_SAVE_SIZE];
} SOURCENODE, *LPSOURCENODE;

class CPackingList;

typedef BOOL (CPackingList::*CMDPFN)();

typedef struct _COMMAND
{
    LPSTR lpText;
    CMDPFN lpHandler;
} COMMAND;

class CPackingList
{
private:
    DWORD m_error;
    LPSTR m_lpEntireFile;
    LPSTR m_lpLine;
    LPCSTR m_lpCommand;
    CLangID m_LangIDs;
    TCHAR m_szPackingList[MAX_PATH];
    DWORD m_dwBuildFlavor;
    LPSOURCENODE m_psources;
    DWORD m_dwcErrors;
    CFileHash m_filehash;
    BOOL m_fTestOnly;
    FILETIME m_ftUpdateTo;
    BOOL m_fDateUpdate;
    CSettingsFile* m_psettings;
    CManifest* m_pmanifest;
    CCabFile* m_pcabfile;
    CDirectories* m_pdirs;

    void ReportError(LPCTSTR lpError, ...);
    void _ReportError(LPCTSTR lpszFormat, va_list vararg);
    LPCSTR GetCommand();
    BOOL DispatchCommand();
    DWORD GetCommandLangID();
    DWORD GetBuildFlavor();
    DWORD AccumulateFlavor(LPCSTR lp);

    // Packing list command handlers
    BOOL ProcessFile();
    BOOL ProcessCopySource();
    BOOL ProcessCopy();
    BOOL ProcessShortcut();
    BOOL ProcessRemove();
    BOOL ProcessRegCommands();
    static const COMMAND m_CommandList[];

public:
    CPackingList()
    {
        m_lpEntireFile = m_lpLine = NULL;
        m_dwBuildFlavor = 0;
        m_psources = NULL;
        m_dwcErrors = 0;
        m_fDateUpdate = FALSE;
    }
    ~CPackingList();

    BOOL SetFile(CSettingsFile* psettings, LPCTSTR lpPackingList, BOOL fTestOnly);
    void SetBuildFlavor(LPCSTR lpFlavor);
    BOOL ProcessLines(CManifest* pmanifest, CCabFile* pcabfiles, CDirectories* pdirs);
    DWORD GetError() { return m_error; }
};


inline void
CPackingList::ReportError(
    LPCTSTR lpszFormat,
    ...
    )
{
    va_list vararg;
    va_start(vararg, lpszFormat);
    _ReportError(lpszFormat, vararg);
    va_end(vararg);
}


//---------------------------------------------------------------------
//  CPacker
//      Application class

class CPacker
{
private:
    LPSTR m_lpLaunchName;
    LPTSTR m_lpCabPath;
    LPTSTR m_lpManifestName;
    TCHAR m_szFileCab[MAX_PATH];
    TCHAR m_szSettingsCab[MAX_PATH];
    BOOL m_fTestPack;
    BOOL m_fNoLogo;
    DWORD m_dwTotalSize;

    CSettingsFile m_settings;
    CCabFile m_cabFiles;
    CCabFile m_cabSettings;
    CPackingList m_plist;
    CManifest m_manifest;
    CDirectories m_dirs;

    BOOL WriteSelfExtractingExe();
    BOOL CreateSettingsCab();
    BOOL ProcessFiles();
    BOOL OpenFiles();
    LPCTSTR CPacker::AddCommas(__int64 li);

    static TCHAR m_szIniName[MAX_PATH];

public:
    CPacker();

    BOOL ParseCommandLine(int argc, char** argv);
    void PrintUsage();
    int Process();
    friend void _ReportSettingsError(DWORD dwSetting, LPCTSTR lpszFormat, va_list vararg);
};


inline
CPacker::CPacker()
{
    m_lpLaunchName = NULL;
    m_fTestPack = FALSE;
    m_fNoLogo = FALSE;
}

#endif // #ifndef _PACKER_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\test\foo.cpp ===
// FOO.CPP
//
//      A sample source file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\uninstall\uninstall.h ===
//  UNINSTALL.H
//
//  Created 2-Apr-2001 [JonT]

#ifndef _UNINSTALL_H
#define _UNINSTALL_H

#include <stdio.h>
#include <windows.h>
#include <commctrl.h>
#include <string.h>
#include <stdlib.h>
#include <shlwapi.h>
#include <global.h>
#include <parse.h>
#include <fileinfo.h>
#include <helper.h>
#include <custom.h>
#include "resource.h"

#endif // #ifndef _UNINSTALL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\unpacker\debug.cpp ===
//  DEBUG.CPP
//
//  Created 13-Mar-2001 [JonT]

#include "unpacker.h"

void
_DebugPrint(
    LPCSTR lpszFormat,
    va_list vararg
    )
{
    char szOutput[4096];

    vsprintf(szOutput, lpszFormat, vararg);
    OutputDebugString(szOutput);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\uninstall\uninstall.cpp ===
//  UNINSTALL.CPP
//
//  Created 2-Apr-2001 [JonT]

#include "uninstall.h"

//---------------------------------------------------------------------

    HINSTANCE g_hinst;
    HINSTANCE g_hinstCustom = NULL;
    LPSTR g_lpUninstallDir = NULL;
    LPSTR g_lpFile;
    DWORD g_fStopUninstall = FALSE;
    LPSTR g_lpProductName = NULL;
    BOOL ParseCommandLine(LPSTR lpCmdLine);
    BOOL ReadUninstallFile();
    BOOL UninstallPrecheck();
    DWORD WINAPI UninstallThread(HWND hwnd);
    VOID UninstallFile(LPSTR& lp, HWND hwndText, BOOL fUnregister);
    VOID UninstallReg(LPSTR& lp, HWND hwndText);
    VOID UninstallDir(LPSTR& lp, HWND hwnd);
    BOOL CALLBACK DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    VOID DeleteDirectory(LPCTSTR lpDir);
    VOID DeleteEmptyDirectory(LPCTSTR lpDir);
    int  rsprintf(LPSTR pszDest, UINT uFormatResource, ...);

#define WMP_FINISHED (WM_USER + 100)

//---------------------------------------------------------------------

int WINAPI
WinMain(
    HINSTANCE hInst,
    HINSTANCE hPrevInst,
    LPSTR lpCmdLine,
    int nCmdShow
    )
{
    TCHAR szText[MAX_PATH];
    TCHAR szTitle[MAX_PATH];

    g_hinst = hInst;
    
    //Parse the command line.
    if(!ParseCommandLine(lpCmdLine))
    {    
        // Get the generic title, since we don't know the product name
        LoadString(g_hinst, IDS_GENERIC_TITLE, szTitle, MAX_PATH);
        LoadString(g_hinst, IDS_MB_RUNFROMCONTROLPANEL, szText, sizeof (szText));
        MessageBox(NULL, szText, szTitle, MB_OK);
        return -1;
    }

    // Load and format our fancy title that has the product name in it.
    rsprintf(g_hinst, szTitle, IDS_TITLE, g_lpProductName);

    static HANDLE s_hevNamespace = CreateEvent(NULL, TRUE, TRUE, TEXT("Local\\X_SETUP_ENGINE"));
    if (GetLastError() == ERROR_ALREADY_EXISTS)
    {
        LoadString(g_hinst, IDS_MB_SINGLEINSTANCEONLY, szText, sizeof (szText));
        MessageBox(NULL, szText, szTitle, MB_OK);
        return -1;
    }

    // Make sure the user is an administrator. If not, no dice
    if (!IsAdministrator())
    {
        rsprintf(g_hinst, szText, IDS_MB_NOTADMIN, g_lpProductName);
        MessageBox(NULL, szText, szTitle, MB_OK);
        return -1;
    }

    // Bogus call to make sure comctl32 is linked in. This call is never made.
    if (hInst == NULL)
        PropertySheet(NULL);

    // Read the entire uninstall file
    if (!ReadUninstallFile())
    {
        LoadString(g_hinst, IDS_CANTFINDFILE, szText, sizeof (szText));
        MessageBox(NULL, szText, szTitle, MB_OK);
        return -1;
    }

    // Load the custom dll, if present
    strcpy(szText, g_lpUninstallDir);
    ::AppendSlash(szText);
    strcat(szText, SCAB_UNINSTALLDIR);
    ::AppendSlash(szText);
    strcat(szText, SCAB_CUSTOMDLL);
    g_hinstCustom = LoadLibrary(szText);

    // Make sure that they can do this.
    if(!UninstallPrecheck())
    {
        if(g_hinstCustom) FreeLibrary(g_hinstCustom);
        return -1;
    }
    
    // Make sure they really want to do this
    rsprintf(g_hinst, szText, IDS_MB_CONFIRM, g_lpProductName);
    if (MessageBox(NULL, szText, szTitle, MB_YESNO) != IDYES)
    {
        if(g_hinstCustom) FreeLibrary(g_hinstCustom);
        return -1;
    }
    
    // Create the UI and drive the rest from there
    int nRet = DialogBox(g_hinst, MAKEINTRESOURCE(IDD_PROGRESS), NULL, DlgProc);

    // If we were successful our done message is already in szText
    // otherwise load the "not successful message."
    if (nRet == 0)
    {
        rsprintf(g_hinst, szText, IDS_MB_FINISHED, g_lpProductName);
    }
    else
        LoadString(g_hinst, IDS_MB_NOTSUCCESSFUL, szText, sizeof (szText));
    MessageBox(NULL, szText, szTitle, MB_OK);

    CloseHandle(s_hevNamespace);
    return 0;
}


//  DlgProc
//      Dialog proc for uninstall progess UI

BOOL CALLBACK
DlgProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    DWORD dw;
    HANDLE hthread;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        hthread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)UninstallThread, hwnd, 0, &dw);
        CloseHandle(hthread);
        return TRUE;

    case WM_COMMAND:
        if (LOWORD(wParam) == IDCANCEL)
        {
            g_fStopUninstall = TRUE;
            return TRUE;
        }
        return FALSE;

    case WMP_FINISHED:
        EndDialog(hwnd, 0);
        return TRUE;
    }

    return FALSE;
}



//  ParseCommandLine
//      Parses command line to get uninstall path, and the product name

BOOL
ParseCommandLine(
    LPSTR lpCmdLine
    )
{
    LPSTR lpRet;

    // Scan for first "
    for (; *lpCmdLine != '\"' ; ++lpCmdLine)
    {
        if (*lpCmdLine == 0)
            return FALSE;
    }

    g_lpUninstallDir = ++lpCmdLine;

    // Scan for second "
    for (; *lpCmdLine != '\"' ; ++lpCmdLine)
    {
        if (*lpCmdLine == 0)
            return FALSE;
    }
    *lpCmdLine++ = 0;

    // Scan for the next "
    for (; *lpCmdLine != '\"' ; ++lpCmdLine)
    {
        if (*lpCmdLine == 0)
            return FALSE;
    }

    g_lpProductName = ++lpCmdLine;

    // Scan for the f "
    for (; *lpCmdLine != '\"' ; ++lpCmdLine)
    {
        if (*lpCmdLine == 0)
            return FALSE;
    }

    *lpCmdLine = 0;
    
    return TRUE;
}


//  ReadUninstallFile
//      Reads the uninstall file into memory

BOOL
ReadUninstallFile()
{
    TCHAR szPath[MAX_PATH];
    HANDLE hfile;
    DWORD dwLen;
    DWORD dwActuallyRead;

    // Get the uninstall filename
    strcpy(szPath, g_lpUninstallDir);
    ::AppendSlash(szPath);
    strcat(szPath, SCAB_UNINSTALLDIR);
    ::AppendSlash(szPath);
    strcat(szPath, SCAB_UNINSTALLFILE);

    // Try to open the file
    hfile = CreateFile(szPath, GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
        FILE_FLAG_SEQUENTIAL_SCAN, NULL);
    if (hfile == INVALID_HANDLE_VALUE)
        return FALSE;

    // Read the entire file
    dwLen = GetFileSize(hfile, NULL);
    if (dwLen == 0xffffffff)
        return FALSE;

    // Allocate a buffer big enough for the whole file
    g_lpFile = (LPSTR)malloc(dwLen + 1);
    if (!g_lpFile)
        return FALSE;

    // Read it completely and zero-terminate
    if (!ReadFile(hfile, g_lpFile, dwLen, &dwActuallyRead, NULL) ||
        dwActuallyRead != dwLen)
        return FALSE;
    *(g_lpFile + dwLen) = 0;

    // Close file, we're done with it
    CloseHandle(hfile);

    return TRUE;
}

// Uninstall pre-check
//  Allows the custom.dll if present to do an uninstall precheck.
BOOL
UninstallPrecheck()
{
    BOOL fRetValue = TRUE;
    // If the custom.dll exports a PREUNINSTALLPROC, call it now
    if(g_hinstCustom)
    {
        PFNPREUNINSTALL pfnPreUninstall;
        pfnPreUninstall = (PFNPREUNINSTALL) GetProcAddress(g_hinstCustom, PREUNINSTALLPROC);
        if(pfnPreUninstall)
        {
            fRetValue = pfnPreUninstall(g_lpUninstallDir);
        }
    }
    return fRetValue;
}


//  UninstallThread
//      A thread to run the uninstall process on so that UI can be displayed smoothly

DWORD WINAPI
UninstallThread(
    HWND hwnd
    )
{
    LPSTR lpCommand;
    LPSTR lp;
    TCHAR szPath[MAX_PATH];
    HWND hwndProgress = GetDlgItem(hwnd, IDC_PROGRESS);
    HWND hwndText = GetDlgItem(hwnd, IDC_STATUS);
    PFNPOSTUNINSTALL pfnPostUninstall;

    // Set up the progress bar by walking the file to find how many lines there are
    lp = g_lpFile;
    DWORD dwcLines = 0;
    do
    {
        ++dwcLines;
    }
    while (!::SkipRestOfLine(lp));
    SendMessage(hwndProgress, PBM_SETRANGE32, 0, dwcLines);
    SendMessage(hwndProgress, PBM_SETSTEP, 1, 0);
    SendMessage(hwndProgress, PBM_SETPOS, 0, 0);

    // Loop through all the lines in the uninstall file processing them
    lp = g_lpFile;
    do
    {
        // If told to cancel, do so
        if (g_fStopUninstall)
            return 0;

        // Update progress bar
        SendMessage(hwndProgress, PBM_STEPIT, 0, 0);

        // Parse the file and handle
        lpCommand = lp;
        ::ZapComma(lp);
        if (*lpCommand == 'f')
            UninstallFile(lp, hwndText, FALSE);
        else if (*lpCommand == 'o')
            UninstallFile(lp, hwndText, TRUE);
        else if (*lpCommand == 'r')
            UninstallReg(lp, hwndText);
        else if (*lpCommand == 'd')
            UninstallDir(lp, hwndText);
    }
    while (!::SkipRestOfLine(lp));

    
    // If the custom.dll exports a POSTUNINSTALLPROC, call it now
    if(g_hinstCustom)
    {
        pfnPostUninstall = (PFNPOSTUNINSTALL) GetProcAddress(g_hinstCustom, POSTUNINSTALLPROC);
        if(pfnPostUninstall)
            pfnPostUninstall(g_lpUninstallDir);
    
    
        // We are done with the custom dll, so free it.
        FreeLibrary(g_hinstCustom);
        g_hinstCustom = NULL;
    }
    
    // Cleanup directories and uninstall stuff files
    LoadString(g_hinst, IDS_DELETINGDIRECTORIES, szPath, MAX_PATH);
    SetWindowText(hwnd, szPath);
    // Nuke the uninstall subdirectory
    strcpy(szPath, g_lpUninstallDir);
    ::AppendSlash(szPath);
    strcat(szPath, SCAB_UNINSTALLDIR);
    DeleteDirectory(szPath);
    // Nuke any empty directories.
    strcpy(szPath, g_lpUninstallDir);
    DeleteEmptyDirectory(szPath);

    // Tell UI we're done
    PostMessage(hwnd, WMP_FINISHED, 0, 0);

    return 0;
}

typedef struct _UPARSEFILE
{
    LPSTR lpPath;
    LPSTR lpFileInfo;
} UPARSEFILE;

//  UninstallFile
//      Handles the uninstalling of a file

VOID
UninstallFile(
    LPSTR& lp,
    HWND hwnd,
    BOOL fUnregister
    )
{
    UPARSEFILE pf;
    CFileInfo fi;

    // Parse the information
    ::ParseLine(lp, (LPSTR*)&pf, sizeof (UPARSEFILE) / sizeof (LPSTR), NULL);
    fi.Load(pf.lpFileInfo);

    // Display the info
    // Display status
    TCHAR sz[MAX_PATH];
    LoadString(g_hinst, IDS_DELETEFILEENTRY, sz, MAX_PATH);
    TCHAR szStatus[MAX_PATH];
    sprintf(szStatus, sz, pf.lpPath);
    SetWindowText(hwnd, szStatus);

    // See if the file matches the one we want (or is older)
    if (fi.Compare(pf.lpPath) != -1)
    {
        // OLE Unregister (regsvr32 /u) the file?
        if (fUnregister)
            RegisterDLL(pf.lpPath, TRUE);

        // Delete it
        if(!DeleteFile(pf.lpPath))
        {
            // It should not even be necessary to tell the user to reboot.
            MoveFileEx(pf.lpPath, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
        }
    }
}

typedef struct _UPARSEREG
{
    LPSTR lpRootKey;
    LPSTR lpSubKey;
    LPSTR lpValueName;
} UPARSEREG;

//  UninstallReg
//      Handles the uninstalling of a regkey

VOID
UninstallReg(
    LPSTR& lp,
    HWND hwnd
    )
{
    UPARSEREG pr;
    HKEY hkeyRoot;
    HKEY hkey;

    // Parse the line
    ::ParseLine(lp, (LPSTR*)&pr, sizeof (UPARSEREG) / sizeof (DWORD), NULL);

    // Display status
    TCHAR sz[MAX_PATH];
    LoadString(g_hinst, IDS_DELETEREGENTRY, sz, MAX_PATH);
    TCHAR szStatus[MAX_PATH];
    sprintf(szStatus, sz, pr.lpRootKey, pr.lpSubKey, pr.lpValueName);
    SetWindowText(hwnd, szStatus);

    // Delete the key if it's there
    // Translate the key values
    if (_stricmp(pr.lpRootKey, "HKLM") == 0)
        hkeyRoot = HKEY_LOCAL_MACHINE;
    else if (_stricmp(pr.lpRootKey, "HKCU") == 0)
        hkeyRoot = HKEY_CURRENT_USER;
    else
        return;

    // Remove the key or value if it's a delreg
    if (*pr.lpValueName == 0)
        SHDeleteKey(hkeyRoot, pr.lpSubKey);
    else
    {
        if (RegOpenKeyEx(hkeyRoot, pr.lpSubKey, 0, KEY_ALL_ACCESS, &hkey) == ERROR_SUCCESS)
        {
            RegDeleteValue(hkey, pr.lpValueName);

            // Check and see if there are any values left in this key
            DWORD dwSubkeys = 1;
            DWORD dwValues = 1;
            if (RegQueryInfoKey(hkey, NULL, NULL, NULL, &dwSubkeys, NULL, NULL,
                &dwValues, NULL, NULL, NULL, NULL) != ERROR_SUCCESS)
            {
                // Make sure we don't delete key if the query fails
                dwSubkeys = 1;
            }
            RegCloseKey(hkey);

            // If there were no more keys or values under the key, nuke it
            if (dwSubkeys == 0 && dwValues == 0)
                SHDeleteKey(hkeyRoot, pr.lpSubKey);
        }
    }
}


typedef struct _UPARSEDIR
{
    LPSTR lpPath;
} UPARSEDIR;


//  UninstallDir
//      Deletes an entire directory.

VOID
UninstallDir(
    LPSTR& lp,
    HWND hwnd
    )
{
    UPARSEDIR pd;

    // Parse the information
    ::ParseLine(lp, (LPSTR*)&pd, sizeof (UPARSEDIR) / sizeof (LPSTR), NULL);

    // Display the info
    // Display status
    TCHAR sz[MAX_PATH];
    LoadString(g_hinst, IDS_DELETEFILEENTRY, sz, MAX_PATH);
    TCHAR szStatus[MAX_PATH];
    sprintf(szStatus, sz, pd.lpPath);
    SetWindowText(hwnd, szStatus);

    // See if the file matches the one we want (or is older)
    DeleteDirectory(pd.lpPath);
}


//  DeleteEmptyDirectory
//      Recursively deletes subdirectories. Never deletes files, only
//      empty subdirectories

VOID
DeleteEmptyDirectory(
    LPCTSTR lpDir
    )
{
    HANDLE hfind;
    WIN32_FIND_DATA find;
    TCHAR szPath[MAX_PATH];

    // Create the find path with a \*.* for the search
    strcpy(szPath, lpDir);
    ::AppendSlash(szPath);
    strcat(szPath, "*.*");

    // Loop through all the files deleting them
    if ((hfind = FindFirstFile(szPath, &find)) != INVALID_HANDLE_VALUE)
    {
        do
        {
            // Skip . and ..
            if (find.cFileName[0] == '.')
                continue;

            // We found a directory, descend into it
            if (find.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                strcpy(szPath, lpDir);
                ::AppendSlash(szPath);
                strcat(szPath, find.cFileName);
                DeleteEmptyDirectory(szPath);
            }
        }
        while (FindNextFile(hfind, &find));
        FindClose(hfind);
    }

    // Nuke the directory
    RemoveDirectory(lpDir);
}


//  DeleteDirectory
//      Deletes a single directory and all files in it.

VOID
DeleteDirectory(
    LPCTSTR lpDir
    )
{
    HANDLE hfind;
    WIN32_FIND_DATA find;
    TCHAR szPath[MAX_PATH];

    // Create the find path with a \*.* for the search
    strcpy(szPath, lpDir);
    ::AppendSlash(szPath);
    strcat(szPath, "*.*");

    // Loop through all the files deleting them
    if ((hfind = FindFirstFile(szPath, &find)) != INVALID_HANDLE_VALUE)
    {
        do
        {
            // Skip . and ..
            if (find.cFileName[0] == '.')
                continue;

            // Skip any directories we might find
            if (find.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                continue;
            }

            strcpy(szPath, lpDir);
            ::AppendSlash(szPath);
            strcat(szPath, find.cFileName);
            DeleteFile(szPath);
        }
        while (FindNextFile(hfind, &find));
        FindClose(hfind);
    }

    // Nuke the directory
    RemoveDirectory(lpDir);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\unpacker\cab.cpp ===
//  CAB.CPP
//
//  Created 13-Mar-2001 [JonT]

#include "unpacker.h"

//---------------------------------------------------------------------
//  Prototypes for FDI callbacks

INT_PTR DIAMONDAPI openfunc(LPSTR pszFile, int oflag, int pmode);
UINT DIAMONDAPI readfunc(INT_PTR hf, LPVOID pv, UINT cb);
UINT DIAMONDAPI writefunc(INT_PTR hf, LPVOID pv, UINT cb);
int DIAMONDAPI closefunc(INT_PTR hf);
long DIAMONDAPI seekfunc(INT_PTR hf, long dist, int seektype);
LPVOID DIAMONDAPI allocfunc(ULONG cb);
void DIAMONDAPI freefunc(LPVOID pv);
INT_PTR DIAMONDAPI notifyfunc(FDINOTIFICATIONTYPE fdint, PFDINOTIFICATION pfdin);


//---------------------------------------------------------------------
// Global definitions for making a resource look like a file.
// Since we don't want to have to copy the resource out to a file, then
// just read it in again, we pretend the resource is a file.
// This makes us do evil hackery because FDI wants to treat these as files
// and doesn't provide any way for us to pass context to the callback functions
// openfunc, readfunc, etc.
// These ugly macros make a illegal file handles starting at -2 that we can
// pass like file handles.
// This evil hackery is necessary because FDI wants to 'open' the file multiple times.
// Of course, each open instance needs a unique file position. This hack gives us
// a way to cheaply map a file position for each open instance.
#define MAX_FILES_OPEN  5
#define IS_RESOURCE_HANDLE(x) ((int)(x) < 0)
#define H_TO_I(x) ((-(int)(x)) - 2)
#define I_TO_H(x) ((INT_PTR)(-(x) - 2))

// We can only have one CCab object at a time due to these unfortunate globals
// (we have to use thse because of communication with te C functions required by FDI)
    HANDLE g_fhTable[MAX_FILES_OPEN];
    DWORD g_posTable[MAX_FILES_OPEN];
    DWORD g_lenTable[MAX_FILES_OPEN];
    TCHAR g_szProcessPath[MAX_PATH];
    LPDWORD g_lpdwSeek;
    LPDWORD g_lpdwLen;

    BOOL CCab::m_fStopCopying = FALSE;
    CFileInfo CCab::m_fi;

//---------------------------------------------------------------------
//  CCab methods

//  CCab::Init
//      Prepares to read the cab files from the end of the executable

BOOL
CCab::Init()
{
    EOFSTRUCT es;
    DWORD dwc;
    int i;

    // Create the FDI context
    m_hfdi = FDICreate(allocfunc, freefunc, openfunc, readfunc, writefunc, closefunc, seekfunc,
        cpu80386, &m_erf);
    if (!m_hfdi)
        return FALSE;

    // Did we get passed in a cab source name as a command line switch?
    lstrcpyn(g_szProcessPath, GetUnpacker()->GetCabSource(), sizeof (g_szProcessPath));

    // If we didn't (the normal case), just use the current EXE to get the cabs out of
    if (g_szProcessPath[0] == 0)
        GetModuleFileName(NULL, g_szProcessPath, MAX_PATH);

    // Open the filename and seek to the end
    m_handle = CreateFile(g_szProcessPath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
    if (m_handle == INVALID_HANDLE_VALUE)
        return FALSE;

    // We put a pointer to the packed stuff in the old exe header
    // Use it to seek and find the structure identifying our packed in data
    IMAGE_DOS_HEADER dos;
    ReadFile(m_handle, &dos, sizeof (dos), &dwc, NULL);
    DWORD dwEndPosition = *(DWORD*)(&dos.e_res[0]);
    SetFilePointer(m_handle, dwEndPosition - sizeof (EOFSTRUCT), NULL, FILE_BEGIN);

    // Read the structure identifying the number of files appended
    if (!ReadFile(m_handle, &es, sizeof (EOFSTRUCT), &dwc, NULL) ||
        dwc != sizeof (EOFSTRUCT) ||
        es.dwSignature != EXE_SIGNATURE)
    {
        CloseHandle(m_handle);
        m_handle = INVALID_HANDLE_VALUE;
        return FALSE;
    }
    m_dwcFiles = es.dwcFiles;

    // Initialize the handle table
    for (i = 0 ; i < MAX_FILES_OPEN ; ++i)
        g_fhTable[i] = INVALID_HANDLE_VALUE;

    // Read the file lengths in
    DWORD dwcb = m_dwcFiles * sizeof (DWORD);
    g_lpdwSeek = (LPDWORD)malloc(dwcb);
    g_lpdwLen = (LPDWORD)malloc(dwcb);
    SetFilePointer(m_handle, dwEndPosition - sizeof (EOFSTRUCT) - dwcb, NULL, FILE_BEGIN);
    if (!ReadFile(m_handle, g_lpdwSeek, dwcb, &dwc, NULL) || dwc != dwcb)
    {
        CloseHandle(m_handle);
        m_handle = INVALID_HANDLE_VALUE;
        return FALSE;
    }

    // Walk through the file list in reverse, computing the seek positions.
    // The file contains the sizes of each sub file. We subtract to compute the seek position
    DWORD dwPosition = SetFilePointer(m_handle, dwEndPosition - sizeof (EOFSTRUCT) - dwcb, NULL, FILE_BEGIN);
    DWORD dwLastPosition = dwPosition;
    for (i = (int)m_dwcFiles - 1 ; i > -1 ; --i)
    {
        g_lpdwSeek[i] = dwPosition - g_lpdwSeek[i];
        dwPosition = g_lpdwSeek[i];
        g_lpdwLen[i] = dwLastPosition - dwPosition;
        dwLastPosition = dwPosition;
    }
    return TRUE;
}


//  CCab::Close
//      Cleans up after the object so we can reuse it

void
CCab::Close()
{
    if (m_hfdi)
        FDIDestroy(m_hfdi);
    m_hfdi = NULL;

    if (m_handle != INVALID_HANDLE_VALUE)
        CloseHandle(m_handle);
    m_handle = INVALID_HANDLE_VALUE;
}


//  CCab::~CCab

CCab::~CCab()
{
    Close();
}


//  CCab::ProcessWithManifest
//      Drives the file copy process.
//      This routine returns when all files in the cab have been processed.
//      Uses the manifest to decide where the files should land.
//      The dwFile parameter is a zero-based index into the file list appended onto the EXE

BOOL
CCab::ProcessWithManifest(
    CManifest* pmanifest,
    DWORD dwFile
    )
{
    BOOL fRet;
    TCHAR szShortcut[MAX_PATH];
    LPSTR lpShortcutRoot;

    // Make a special filename by doing * and a file number. This is the sequence number
    // of the file appended to the executable.
    char lpName[3];
    lpName[0] = '*';
    lpName[1] = '0' + ((UCHAR)dwFile % 10);
    lpName[2] = 0;

    // Save the manifest instance so we can retrieve in the callback
    m_pmanifest = pmanifest;

    // Reset manifest EOF flag
    m_fEOF = FALSE;
    m_fStopCopying = FALSE;

    // Write out uninstall info so that uninstall will delete all our
    // start menu shortcuts
    SHGetFolderPath(NULL, CSIDL_PROGRAMS, NULL, SHGFP_TYPE_CURRENT, szShortcut);
    ::AppendSlash(szShortcut);
    lpShortcutRoot = m_psettings->GetSetting(CSTR_STARTMENUFOLDER);
    strcat(szShortcut, lpShortcutRoot);
    free(lpShortcutRoot);
    m_puninstall->AddDir(szShortcut);


    // Reset the manifest. We assume it's already been initialized here.
    // If this returns TRUE, we're already at EOF and must have a corrupt
    // installer.
    if (pmanifest->ResetPointer())
    {
        GetUnpacker()->PostCopyError(IDS_CORRUPT_INSTALLER, 1009);
        return FALSE;
    }

    // Use '*' as the name of the file. This tells us to use the file appended to the EXE
    // instead of a separate file. Saves copying the cabfile out to a temp file
    // Pass in a this pointer so we can call back to the object

    fRet = FDICopy(m_hfdi, lpName, "", 0, notifyfunc, NULL, (LPVOID)this);
    if( !fRet )
    {
        GetUnpacker()->PostCopyError(IDS_SETUP_NOT_COMPLETE, 1010);
        return FALSE;
    }

    // Make sure the progress bar has been updated
    GetUnpacker()->UpdateProgressBar(0, 0, NULL);

    // Handle remaining manifest items
    if (!m_fEOF)
    {
        LPSTR lpLine;
        LPSTR lpCommand;

        do
        {
            // Get the current manifest line
            lpLine = m_pmanifest->GetLine();

            // Get the Lang IDs for the current line
            CLangID langID;
            LPSTR lpLangIDs = lpLine;
            ::ZapComma(lpLine);
            langID.ParseLangIDs( lpLangIDs );

            // If the langID is not valid, skip this line
            if( !langID.IsLangIDValid( GetUserDefaultUILanguageWithDefault() ) )
                continue;

            // Get the command
            lpCommand = lpLine;
            ::ZapComma(lpLine);
    
            // If it's a copy command, handle it
            if (_stricmp(lpCommand, "file") == 0)
            {
                DebugPrint("Got file command after cab exhausted\n");
                GetUnpacker()->PostCopyError(IDS_CORRUPT_INSTALLER, 1011);
                return FALSE;
            }
    
            // Process other commands. Bail out if something bad happens
            // Assume it's already set the error
            if (!ProcessManifestLine(lpCommand, lpLine))
                return FALSE;
        }
        while (!m_pmanifest->SkipToNextLine());
    }

    // Make sure the progress bar has been updated
    GetUnpacker()->UpdateProgressBar(0, 0, NULL);

    return fRet;
}


//  CCab::ProcessWithoutManifest
//      Drives file copying in the no manifest case.
//      Without a manifest, all files are extracted to relative paths below
//      the passed-in path.
//      The dwFile parameter is a zero-based index into the file list appended onto the EXE

CCab::ProcessNoManifest(
    LPCSTR lpRoot,
    DWORD dwFile
    )
{
    // Make a special filename by doing * and a file number. This is the sequence number
    // of the file appended to the executable.
    char lpName[3];
    lpName[0] = '*';
    lpName[1] = '0' + ((UCHAR)dwFile % 10);
    lpName[2] = 0;

    // Make sure there's no manifest marked
    m_pmanifest = NULL;
    m_fStopCopying = FALSE;

    // Save the root directory. Make sure there's a trailing '\'
    strcpy(m_szNoManifestRoot, lpRoot);
    ::AppendSlash(m_szNoManifestRoot);

    // Use '*' as the name of the file. This tells us to use the resource
    // instead of a file. Saves copying the cabfile out to a temp file
    // Pass in a this pointer so we can call back to the object
    return FDICopy(m_hfdi, lpName, "", 0, notifyfunc, NULL, (LPVOID)this);
}


INT_PTR
CCab::Callback(
    FDINOTIFICATIONTYPE fdint,
    PFDINOTIFICATION pfdin
    )
{
    switch (fdint)
    {
    case fdintCOPY_FILE:
        {
            if( NULL != m_pmanifest )
            {
                // Check to see if we really want to copy this file
                LPSTR lpLine = m_pmanifest->GetLine();

                // Get the Lang IDs for the current line
                CLangID langID;
                LPSTR lpLangIDs = lpLine;
                ::ZapComma(lpLine);
                langID.ParseLangIDs( lpLangIDs );

                if( !langID.IsLangIDValid( GetUserDefaultUILanguageWithDefault() ) )
                {
                    // Move our manifest to the next line
                    m_fEOF = m_pmanifest->SkipToNextLine();

                    // Return NULL to skip the current file in the CAB
                    return NULL;
                }
            }

            return FileCopyOpen(pfdin);
        }

    case fdintCLOSE_FILE_INFO:
        {
            return FileCopyClose(pfdin);
        }

    // We don't support multiple cabinet files. We should never get this.
    case fdintNEXT_CABINET:
        return -1;

    default:
        return 0;
    }
}


//  CCab::FileCopyOpen
//      Called just before each file is extracted from the cab.
//      This gives us the chance to find it in the manifest and
//      do any special processing.

INT_PTR
CCab::FileCopyOpen(
    PFDINOTIFICATION pfdin
    )
{
    LPSTR lpLine;
    LPSTR lpCommand;
    LPTARGETDIR lpTarget;
    PARSEFILE pf;
    int nRet;
    DWORD dwFlags;

    // Check to see if a stop was requested
    if (m_fStopCopying)
        return -1;

    // Use the manifest to determine where the file should be copied
    if (m_pmanifest)
    {
        // Handle as many lines as possible until we encounter a 'file' command.
        while (TRUE)
        {
            // Get the current manifest line
            lpLine = m_pmanifest->GetLine();

            // Get the Lang IDs for the current line
            CLangID langID;
            LPSTR lpLangIDs = lpLine;
            ::ZapComma(lpLine);
            langID.ParseLangIDs( lpLangIDs );

            // Get the command
            lpCommand = lpLine;
            ::ZapComma(lpLine);

            // If it's a copy command, handle it
            if (_stricmp(lpCommand, "file") == 0)
                break;

            // Only process the line if our LangID is correct
            if( langID.IsLangIDValid( GetUserDefaultUILanguageWithDefault() ) )
            {
                // Process other commands. Bail out if something bad happens
                // Assume it's already set the error
                if (!ProcessManifestLine(lpCommand, lpLine))
                    return -1;
            }

            // Skip to next line. Save EOF status away for later
            m_fEOF = m_pmanifest->SkipToNextLine();
        }

        // Parse the manifest line
        ::ParseLine(lpLine, (LPSTR*)&pf, PARSEFILE_DWORDS, NULL);

        // Make sure the file is the one we expected
        if (_stricmp(pf.lpDest, pfdin->psz1) != 0)
        {
            DebugPrint("File %s encountered, %s expected\n", pfdin->psz1, pf.lpDest);
            GetUnpacker()->PostCopyError(IDS_CORRUPT_INSTALLER, 1012);
            return -1;
        }

        // Find the target root the file is relative to
        // This was validated during the disk space check
        lpTarget = m_pdirs->FindTarget(pf.lpRoot);

        // Strip off the extra target root we prepended in the packer
        LPSTR lpSkip = pf.lpDest;
        for (; *lpSkip != '\\' ; ++lpSkip)
        {
            if (*lpSkip == 0)
                break;
        }
        if (*lpSkip != 0)
            ++lpSkip;

        // Now we have the file entry that matches the file we're about to copy.
        // Prepend the correct path onto the file
        strcpy(m_szPath, lpTarget->szPath);
        ::AppendSlash(m_szPath);
        strcat(m_szPath, lpSkip);

        // Save away the fileinfo stuff, we'll need it later to set the accurate file time of the file
        m_fi.Load(pf.lpFileInfo);

        // Get flags
        dwFlags = GetUnpacker()->AccumulateFlags(pf.lpFlags);

        // Check and see if we want to OLE register this file
        if (dwFlags & FILEFLAGS_OLEREGISTER)
            m_fRegister = TRUE;
        else
            m_fRegister = FALSE;

        // Decide if we want to write uninstall info for this file
        dwFlags |= lpTarget->dwFlags;

        // Put the file in the uninstall info if the user didn't say not to
        if (!(dwFlags & FILEFLAGS_NOUNINSTALL))
            m_puninstall->AddFile(m_szPath, pf.lpFileInfo, m_fRegister);

        // Skip the manifest to the next entry, we're ready regardless
        m_fEOF = m_pmanifest->SkipToNextLine();

        // Handle file overwriting
        nRet = PrepareFileOverwrite(lpTarget, pf.lpRoot, m_szPath, pf.lpFlags, pf.lpFileInfo);

        if (nRet == 0 || nRet == -1)
            return nRet;
    }

    // Otherwise, with no manifest, just overwrite all files in the specified directory
    else
    {
        strcpy(m_szPath, m_szNoManifestRoot);
        strcat(m_szPath, pfdin->psz1);
    }

    // Finally call the wrapper that opens the file
    return openfunc(m_szPath, _O_BINARY | _O_TRUNC | _O_RDWR | _O_CREAT, _S_IREAD | _S_IWRITE);
}


//  CCab::FileCopyClose
//      Called just after the file is copied. This allows us to mark the date
//      and attributes as stored in the cab file.

INT_PTR
CCab::FileCopyClose(
    PFDINOTIFICATION pfdin
    )
{
    if (!AdjustFileTime(pfdin->hf))
        return -1;

    closefunc(pfdin->hf);

    if (!SetFileAttributes(m_szPath, Attr32FromAttrFAT(pfdin->attribs)))
        return -1 ;

    // If this is a delay until reboot we need to setup everything
    // for the reboot case.
    if (m_fDelayUntilReboot)
    {   
        // 1. Call MoveFileEx
        MoveFileEx(m_szPath, m_szFinalPath, MOVEFILE_DELAY_UNTIL_REBOOT|MOVEFILE_REPLACE_EXISTING);
        // 2. If the m_fRegister Flag is set, add an entry to run once
        //    to have Regsvr32 register the file on reboot.
        if(m_fRegister)
        {
            RegisterDLLOnReboot(m_szFinalPath);
            m_fRegister = FALSE;
        }
        // 3. Set the reboot required flag.
        GetUnpacker()->SetFlags(UNPACKER_FLAGS_REBOOT_REQUIRED);
        m_fDelayUntilReboot = FALSE;
    } else

    // OLE Register the file if necessary
    if (m_fRegister)
    {
        RegisterDLL(m_szPath, FALSE);
        m_fRegister = FALSE;
    }

    return TRUE;
}


//  CCab::ProcessManifestLine
//      Processes a single line in the manifest.
//      Returns TRUE of the line was handled.

BOOL
CCab::ProcessManifestLine(
    LPSTR lpCommand,
    LPSTR lpLine
    )
{
    // 'copy' command. Copies a file to elsewhere on the disk saving space in the cab
    if (_stricmp(lpCommand, "copy") == 0)
    {
        return ProcessManifestCopyCommand(lpLine);
    }
    else if (_stricmp(lpCommand, "remove") == 0 ||
             _stricmp(lpCommand, "removedir") == 0)
    {
        return ProcessManifestRemoveCommand(lpCommand, lpLine);
    }
    else if (_stricmp(lpCommand, "addreg") == 0 ||
             _stricmp(lpCommand, "delreg") == 0)
    {
        return ProcessManifestRegCommand(lpCommand, lpLine);
    }
    else if (_stricmp(lpCommand, "shortcut") == 0)
    {
        return ProcessManifestShortcut(lpLine);
    }

    // Any other command isn't handled here
    else
    {
        DebugPrint("Unhandled command in ProcessManifestLine (%s)\n", lpCommand);
        GetUnpacker()->PostCopyError(IDS_CORRUPT_INSTALLER, 1013);
        return FALSE;
    }

    return TRUE;
}


//  CCab::ProcessManifestCopyCommand
//      Handles the 'copy' command from the manifest

BOOL CCab::ProcessManifestCopyCommand(
    LPSTR lpLine
    )
{

    PARSECOPY pc;
    LPTARGETDIR lpTarget;
    TCHAR szSource[MAX_PATH];
    TCHAR szDest[MAX_PATH];
    int nRet;
    DWORD dwFlags;

    // Parse the line
    ::ParseLine(lpLine, (LPSTR*)&pc, PARSECOPY_DWORDS, NULL);

    // Find the target root the file is relative to
    // This was validated during the disk space check
    lpTarget = m_pdirs->FindTarget(pc.lpRoot);

    // Strip off the extra target root we prepended
    LPSTR lpSkipDest = pc.lpDest;
    for (; *lpSkipDest != '\\' ; ++lpSkipDest)
    {
        if (*lpSkipDest == 0)
            break;
    }
    if (*lpSkipDest != 0)
        ++lpSkipDest;
    LPSTR lpSkipSrc = pc.lpSource;
    for (; *lpSkipSrc != '\\' ; ++lpSkipSrc)
    {
        if (*lpSkipSrc == 0)
            break;
    }
    if (*lpSkipSrc != 0)
        ++lpSkipSrc;

    // Now we have the file entry that matches the file we're about to copy.
    // Prepend the correct path onto source and dest
    strcpy(szSource, lpTarget->szPath);
    ::AppendSlash(szSource);
    strcat(szSource, lpSkipSrc);
    strcpy(szDest, lpTarget->szPath);
    ::AppendSlash(szDest);
    strcat(szDest, lpSkipDest);

    // Get flags so we can decide if we want to write uninstall info for this file
    dwFlags = GetUnpacker()->AccumulateFlags(pc.lpFlags) | lpTarget->dwFlags;

    // Put the file in the uninstall info if the user didn't say not to
    if (!(dwFlags & FILEFLAGS_NOUNINSTALL))
        m_puninstall->AddFile(szDest, pc.lpFileInfo, FALSE);

    // Make sure the file's ready to be overwritten
    nRet = PrepareFileOverwrite(lpTarget, pc.lpRoot, szDest, pc.lpFlags, pc.lpFileInfo);
    if (nRet == -1)
        return FALSE;
    if (nRet != 0)
    {
        MakeDirectory(szDest);
        if (!CopyFile(szSource, szDest, FALSE))
        {
            // BUGBUG: this should be an abort retry ignore
            DebugPrint("CopyFile(%s, %s) failed, error=%d\n", szSource, szDest, GetLastError());
            GetUnpacker()->PostCopyError(IDS_FILE_COPY_PROBLEM, 1014);
            return FALSE;
        }

        // Set the correct time for the file
        CFileInfo fi;
        fi.Load(pc.lpFileInfo);
        HANDLE fh = CreateFile(szDest, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL, OPEN_EXISTING, 0, NULL);
        if (fh != INVALID_HANDLE_VALUE)
        {
            SetFileTime(fh, fi.GetFiletime(), fi.GetFiletime(), fi.GetFiletime());
            CloseHandle(fh);
        }

    }
    return TRUE;
}


//  CCab::ProcessManifestRemoveCommand
//      Handles the 'remove' command from the manifest
BOOL
CCab::ProcessManifestRemoveCommand(
    LPSTR lpCommand,
    LPSTR lpLine
    )
{
    PARSEDELETE pd;
    LPTARGETDIR lpTarget;
    TCHAR szDest[MAX_PATH];

    // Parse the line
    ::ParseLine(lpLine, (LPSTR*)&pd, PARSEDELETE_DWORDS, NULL);

    // Get the flags from this command
    DWORD dwFlags = GetUnpacker()->AccumulateFlags(pd.lpFlags);

    // Check to see if this command is a 'first-run-only' command.
    // If it is, and this isn't a first run of this setup engine, we skip the command
    if ((dwFlags & REMOVELINE_FLAGS_ONLYONFIRSTRUN) &&
        (GetUnpacker()->GetFlags() & UNPACKER_FLAGS_SETUPHASRUNBEFORE))
    {
        return TRUE;
    }

    // Find the target root the file is relative to
    // This was validated during the disk space check
    lpTarget = m_pdirs->FindTarget(pd.lpRoot);
    
    //If the target directory doesn't exist then we fail.  This is a problem with the CSV file,
    //it has a remove command, but the target path is not defined.  Ideally, the packer would check
    //for this and never build the setup, but it doesn't yet.
    if(!lpTarget)
    {
        GetUnpacker()->PostCopyError(IDS_CORRUPT_INSTALLER, 5000);
        return FALSE;
    }

    // Prepend the correct path.
    strcpy(szDest, lpTarget->szPath);
    ::AppendSlash(szDest);
    strcat(szDest, pd.lpDest);

    // Check for directory or file deletes
    if (_stricmp(lpCommand, "removedir") == 0)
    {
        // Delete the file. We don't check error because it's ok if the files are not there.
        NukeDirectory(szDest);
    }

    else // remove
    {
        // Check first to see if the file is readonly. If it is, set it to not be
        DWORD dwAttr = GetFileAttributes(szDest);
        if (dwAttr != 0xffffffff && (dwAttr & FILE_ATTRIBUTE_READONLY))
            SetFileAttributes(szDest, dwAttr & ~FILE_ATTRIBUTE_READONLY);

        // Delete the file. We don't check error because it's ok if the file's not there.
        DeleteFile(szDest);
    }

    return TRUE;
}


//  CCab::NukeDirectory
//      Does a tree delete of a directory and everything below it. Use carefully!

VOID
CCab::NukeDirectory(
    LPSTR lpdir
    )
{
    HANDLE hfind;
    WIN32_FIND_DATA find;
    TCHAR szPath[MAX_PATH];

    // Create the find path with a \*.* for the search
    strcpy(szPath, lpdir);
    ::AppendSlash(szPath);
    strcat(szPath, "*.*");

    // Loop through all the files deleting them
    if ((hfind = FindFirstFile(szPath, &find)) != INVALID_HANDLE_VALUE)
    {
        do
        {
            // Skip . and ..
            if (find.cFileName[0] == '.')
                continue;

            // We found a directory, descend into it
            if (find.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                strcpy(szPath, lpdir);
                ::AppendSlash(szPath);
                strcat(szPath, find.cFileName);
                NukeDirectory(szPath);
            }

            // Otherwise, delete the file
            else
            {
                strcpy(szPath, lpdir);
                ::AppendSlash(szPath);
                strcat(szPath, find.cFileName);

                // Check first to see if the file is readonly. If it is, set it to not be
                DWORD dwAttr = GetFileAttributes(szPath);
                if (dwAttr & FILE_ATTRIBUTE_READONLY)
                    SetFileAttributes(szPath, dwAttr & ~FILE_ATTRIBUTE_READONLY);

                DeleteFile(szPath);
            }
        }
        while (FindNextFile(hfind, &find));
        FindClose(hfind);
    }

    // Nuke the directory
    RemoveDirectory(lpdir);
}


//  CCab::ProcessManifestRegCommand
//      Handles registry commands from the manifest

BOOL
CCab::ProcessManifestRegCommand(
    LPSTR lpCommand,
    LPSTR lpLine
    )
{
    PARSEREG pr;
    HKEY hkeyRoot;
    HKEY hkey;
    DWORD dw;
    LONG lRet;

    // Update status
    GetUnpacker()->UpdateProgressBar(0, IDS_UPDATING_REGISTRY, "");

    // Parse the line
    ::ParseLine(lpLine, (LPSTR*)&pr, PARSEREG_DWORDS, NULL);

    // Translate the key values
    if (_stricmp(pr.lpRootKey, "HKLM") == 0)
        hkeyRoot = HKEY_LOCAL_MACHINE;
    else if (_stricmp(pr.lpRootKey, "HKCU") == 0)
        hkeyRoot = HKEY_CURRENT_USER;
    else
    {
        DebugPrint("Reg root key value wasn't HKLM or HKCU\n");
        GetUnpacker()->PostCopyError(IDS_CORRUPT_INSTALLER, 1015);
        return FALSE;
    }

    // Remove the key or value if it's a delreg
    if (*lpCommand == 'd')
    {
        if (*pr.lpValueName == 0)
            RegDeleteKey(hkeyRoot, pr.lpSubKey);
        else
        {
            if (RegOpenKeyEx(hkeyRoot, pr.lpSubKey, 0, KEY_ALL_ACCESS, &hkey) == ERROR_SUCCESS)
            {
                RegDeleteValue(hkey, pr.lpValueName);
                RegCloseKey(hkey);
            }
        }
    }

    // Otherwise add the key
    else
    {
        // Read the key
        if (RegCreateKeyEx(hkeyRoot, pr.lpSubKey, 0, NULL, 0, KEY_ALL_ACCESS,
                           NULL, &hkey, &dw) != ERROR_SUCCESS)
        {
            DebugPrint("Couldn't create reg key\n");
            GetUnpacker()->PostCopyError(IDS_CORRUPT_INSTALLER, 1016);
            return FALSE;
        }

        // Add the uninstall information for the key
        m_puninstall->AddReg(pr.lpRootKey, pr.lpSubKey, pr.lpValueName);

        // Get the flags from this manifest item
        DWORD dwFlags = GetUnpacker()->AccumulateFlags(pr.lpFlags);

        // Is it a DWORD regkey?
        if (dwFlags & REGLINE_FLAGS_DWORD)
        {
            DWORD dw = atoi(pr.lpValue);
            lRet = RegSetValueEx(hkey, pr.lpValueName, 0, REG_DWORD, (BYTE*)&dw, sizeof (DWORD));
        }

        // default is REG_SZ
        else
        {
            //Substitute target paths in string values
            char szValue[4096];
            SubstitutePathsInString(pr.lpValue, szValue);
            // Set the value
            lRet = RegSetValueEx(hkey, pr.lpValueName, 0, REG_SZ, (BYTE *)szValue,
                                 strlen(szValue) + 1);
        }

        RegCloseKey(hkey);
        if (lRet != ERROR_SUCCESS)
        {
            DebugPrint("Couldn't create reg value\n");
            GetUnpacker()->PostCopyError(IDS_CORRUPT_INSTALLER, 1017);
            return FALSE;
        }
    }
    return TRUE;
}


//  CCab::PrepareFileOverwrite
//      Prepares a file for overwriting. Depending on flags this may mean
//      prompting or just blasting the file. This routine is used for
//      both 'copy' and 'file' commands.
//      Returns: 
//               1 to continue decompressing the current file
//               0 to skip this file
//              -1 to bail out of the copy on error (PostCopyError has been called)
//      Comment: this function is pretty expensive: an open and a findfirst for
//      each file located. It might be possible to optimize this.

int
CCab::PrepareFileOverwrite(
    LPTARGETDIR lpTarget,
    LPSTR lpRoot,
    LPSTR lpDest,
    LPSTR lpFlags,
    LPSTR lpFileInfo
    )
{
    HANDLE hfile;
    DWORD dwErrorOpen;
    CFileInfo fi;

    // Update the progress indicator
    fi.Load(lpFileInfo);
    GetUnpacker()->UpdateProgressBar(fi.GetSize(), IDS_COPYING_FILE, lpDest);

tryagain:
    dwErrorOpen = ERROR_SUCCESS;

    // Try to open the file
    hfile = CreateFile(lpDest, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
                       NULL, OPEN_EXISTING, 0, NULL);
    if (hfile == INVALID_HANDLE_VALUE)
        dwErrorOpen = GetLastError();
    else
        CloseHandle(hfile);

    // If the file or path wasn't found, this is good, return OK
    if (dwErrorOpen == ERROR_FILE_NOT_FOUND || dwErrorOpen == ERROR_PATH_NOT_FOUND)
        return 1;

    //
    //  Most likely, the flags are needed to resolve this.
    //

    // Flags from the user are always highest priority
    DWORD dwFlags = m_dwOverwriteFlags;

    // Manifest flags always supercede directory flags if they exist
    if (dwFlags == 0)
    dwFlags = GetUnpacker()->AccumulateFlags(lpFlags);

    // Finally, if no other flags, get from the targetdir
    if (dwFlags == 0)
            dwFlags = lpTarget->dwFlags;


    // If the file was found and opened successfully, the file exists. See if
    // it's the same as the file we're trying to copy down. If so, we can skip the
    // file since there's no need to copy it.
    if (dwErrorOpen == ERROR_SUCCESS)
    {
        // Dates may or may not be valid. Depending on how flags are set in the installer,
        // possibly ignore dates altogether
        if (!(GetUnpacker()->GetFlags() & UNPACKER_FLAGS_SETUPHASRUNBEFORE))
            return 1;

        int nRet;
        nRet = fi.Compare(lpDest);

        // If files match, we can skip the file
        if (nRet == 0)
            return 0;

        // If the file is older, we allow the copy
        if (nRet == 1)
            return 1;

        // Default is to prompt
        if (dwFlags & FILEFLAGS_CLOBBER)
            return 1;
        else if (dwFlags & FILEFLAGS_NEVERCLOBBER)
            return 0;

        // Returns -1 on cancel, 0 on skip file, 1 on clobber file
        strcpy(m_szPath, lpDest);
        return DialogBoxParam(::GetInstanceHandle(), MAKEINTRESOURCE(IDD_OVERWRITE),
            GetUnpacker()->GetHWNDDlg(), (DLGPROC)OverwriteDlgProc, (LPARAM)this);
    }

    // If file is busy or other error situation, give the user a chance to resolve
    else
    {
        // Check first to see if the file is readonly. If it is, make it not then try again
        DWORD dwAttr = GetFileAttributes(lpDest);
        if (dwAttr & FILE_ATTRIBUTE_READONLY)
        {
            SetFileAttributes(lpDest, dwAttr & ~FILE_ATTRIBUTE_READONLY);
            goto tryagain;
        }

        // This file may require a reboot to replace.  This is only supported
        // by a file command (not by a copy command).  HACK ALERT: we distinguish
        // the caller based on whether m_szPath is passed as lpDest.
        if ((dwFlags & FILEFLAGS_SYSTEMREBOOT)&&(m_szPath == lpDest))
        {
            // Copy the m_szPath path to the m_szFinalPath
            strcpy(m_szFinalPath, m_szPath);
            
            // Change m_szPath to be a temporary path
            LPSTR lpParse = strrchr(m_szFinalPath, '\\');   // Borrow the path in m_szFinalPath,
            *lpParse='\0';                                  //  by temporarily terminating before the filename.
            BOOL fResult = GetTempFileName(m_szFinalPath, "unp", 0, m_szPath);
            *lpParse='\\';                                  // Done borrow m_szFinalPath, restore it.

            // If for some reason we couldn't create the temporary file,
            // return failure.
            if(!fResult)                    
            {
                GetUnpacker()->PostCopyError(IDS_FILE_COPY_PROBLEM, 6000);
                strcpy(m_szPath, m_szFinalPath);  //Copy the path back in case GetTempFile clobbered it.
                return -1; //
            }
            
            // Set the delay until reboot flag, this will be processed after 
            // the copy to the temporary file.
            m_fDelayUntilReboot = TRUE;

            return 1; //proceed with copy
        }

        // Lots of stack depth, yuck.
        TCHAR sz[512];
        TCHAR szOutput[512];
        int nRet;

        LoadString(::GetInstanceHandle(), IDS_MB_COPYPROBLEM, sz, 512);
        sprintf(szOutput, sz, lpDest);
        nRet = MessageBox(GetUnpacker()->GetHWNDDlg(), szOutput, CUnpacker::GetProductName(), MB_YESNOCANCEL);

        // If they told us to retry, do so
        if (nRet == IDYES)
            goto tryagain;

        // If no retry, skip the file
        if (nRet == IDNO)
            return 0;

        // If cancel, tell the caller to bail
        if (nRet == IDCANCEL)
            return -1;
    }
    return 1;
}


//  CCab::ProcessManifestShortcut
//      Creates a windows shell program group icon

BOOL
CCab::ProcessManifestShortcut(
    LPSTR lpLine
    )
{
    PARSESHORTCUT ps;
    LPTARGETDIR lpTarget;
    TCHAR szDest[MAX_PATH];
    TCHAR szShortcut[MAX_PATH];
    LPSTR lpShortcutRoot;

    // Parse the line
    ::ParseLine(lpLine, (LPSTR*)&ps, PARSESHORTCUT_DWORDS, NULL);

    // Find the target root the file is relative to
    // This was validated during the disk space check
    lpTarget = m_pdirs->FindTarget(ps.lpRoot);

    // Prepend the correct path.
    strcpy(szDest, lpTarget->szPath);
    ::AppendSlash(szDest);
    strcat(szDest, ps.lpDest);

    // Get the path into the program group folder
    SHGetFolderPath(NULL, CSIDL_PROGRAMS, NULL, SHGFP_TYPE_CURRENT, szShortcut);
    ::AppendSlash(szShortcut);
    lpShortcutRoot = m_psettings->GetSetting(CSTR_STARTMENUFOLDER);
    strcat(szShortcut, lpShortcutRoot);
    free(lpShortcutRoot);
    ::AppendSlash(szShortcut);
    strcat(szShortcut, ps.lpShortcutPath);

    // Create the shortcut. Note that if it fails, we don't fail setup. What
    // good would this do?
    MakeDirectory(szShortcut);
    if (FAILED(CreateLink(szDest, szShortcut, ps.lpDescription)))
    {
        DebugPrint("Failed creating shortcut to %s (%s), continuing setup\n",
                   szDest, szShortcut);
    }

    return TRUE;
}


//  CCab::CreateLink
//      Uses the Shell's IShellLink and IPersistFile interfaces 
//      to create and store a shortcut to the specified object. 
//      Returns the result of calling the member functions of the interfaces. 
//      lpszPathObj - address of a buffer containing the path of the object. 
//      lpszPathLink - address of a buffer containing the path where the 
//          Shell link is to be stored. 
//      lpszDesc - address of a buffer containing the description of the 
//          Shell link. 
 
HRESULT
CCab::CreateLink(
    LPCSTR lpszPathObj, 
    LPCSTR lpszPathLink,
    LPCSTR lpszDesc
    ) 
{ 
    HRESULT hres; 
    IShellLink* psl; 
 
    // Get a pointer to the IShellLink interface. 
    hres = CoCreateInstance(CLSID_ShellLink, NULL, 
        CLSCTX_INPROC_SERVER, IID_IShellLink, (LPVOID *) &psl); 
    if (SUCCEEDED(hres))
    { 
        IPersistFile* ppf; 
 
        // Set the path to the shortcut target and add the 
        // description. 
        psl->SetPath(lpszPathObj); 
        psl->SetDescription(lpszDesc); 
 
       // Query IShellLink for the IPersistFile interface for saving the 
       // shortcut in persistent storage. 
        hres = psl->QueryInterface(IID_IPersistFile, (LPVOID*)&ppf); 
 
        if (SUCCEEDED(hres))
        { 
            WCHAR wsz[MAX_PATH]; 
 
            // Ensure that the string is Unicode. 
            MultiByteToWideChar(CP_ACP, 0, lpszPathLink, -1, wsz, MAX_PATH);
 
            // Save the link by calling IPersistFile::Save. 
            hres = ppf->Save(wsz, TRUE); 
            ppf->Release(); 
        } 
        psl->Release(); 
    } 
    return hres; 
}


//---------------------------------------------------------------------
//  FDI Callback functions

//  openfunc
//      FDI callback function
//      Maps _open semantics to CreateFile

INT_PTR DIAMONDAPI
openfunc(
    LPSTR pszFile,
    int oflag,
    int pmode
    )
{
    HANDLE  FileHandle;
    BOOL    fExists     = FALSE;
    DWORD   fAccess;
    DWORD   fCreate;
    DWORD   dwShareMode = 0;

    // The special filename '*' means that we are using a resource as a file.
    // Allocate a special illegal handle to identify it. We have to be able to
    // keep track of multiple simultaneous opens because FDI will call open
    // multiple times and expect the seek pointer to be instanced.
    if (pszFile[0] == '*')
    {
        int i;

        // Find an unused slot
        for (i = 0 ; i < MAX_FILES_OPEN ; ++i)
        {
            if (g_fhTable[i] == INVALID_HANDLE_VALUE)
                break;
        }

        // No slots left, bail out
        if (i == MAX_FILES_OPEN)
            return -1;

        // Create a duplicate handle to the file
        g_fhTable[i] = CreateFile(g_szProcessPath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL, OPEN_EXISTING, 0, NULL);
        g_posTable[i] = g_lpdwSeek[pszFile[1] - '0'];
        g_lenTable[i] = g_lpdwLen[pszFile[1] - '0'];
        SetFilePointer(g_fhTable[i], g_posTable[i], NULL, FILE_BEGIN);
        return I_TO_H(i);
    }

    // BUGBUG: No Append Mode Support
    if (oflag & _O_APPEND)
        return -1;

    // Set Read-Write Access
    if ((oflag & _O_RDWR) || (oflag & _O_WRONLY))
        fAccess = GENERIC_WRITE;
    else
        fAccess = GENERIC_READ;

     // Set Create Flags
    if (oflag & _O_CREAT)
    {
        if (oflag & _O_EXCL)
            fCreate = CREATE_NEW;
        else if (oflag & _O_TRUNC)
            fCreate = CREATE_ALWAYS;
        else
            fCreate = OPEN_ALWAYS;
    }
    else
    {
        if (oflag & _O_TRUNC)
            fCreate = TRUNCATE_EXISTING;
        else
            fCreate = OPEN_EXISTING;
    }

    // Set sharing flags
    if (pmode & _S_IREAD)
        dwShareMode |= FILE_SHARE_READ;
    if (pmode & _S_IWRITE)
        dwShareMode |= FILE_SHARE_WRITE;

    FileHandle = CreateFile(pszFile, fAccess, dwShareMode, NULL, fCreate,
                            FILE_ATTRIBUTE_NORMAL, NULL);

    if ((FileHandle == INVALID_HANDLE_VALUE) && (fCreate != OPEN_EXISTING))
    {
        CCab::MakeDirectory(pszFile);
        FileHandle = CreateFile(pszFile, fAccess, 0, NULL, fCreate,
                                FILE_ATTRIBUTE_NORMAL, NULL);
    }
    return (INT_PTR)FileHandle;
}

UINT DIAMONDAPI
readfunc(
    INT_PTR hf,
    LPVOID pv,
    UINT cb
    )
{
    // Special read from EXE: get the EXE file handle and do the read from
    // the current position
    if (IS_RESOURCE_HANDLE(hf))
        hf = (INT_PTR)g_fhTable[H_TO_I(hf)];

    // Do the read
    if (!ReadFile((HANDLE)hf, pv, cb, (DWORD *)&cb, NULL))
        return -1;
    else
        return cb;
}

UINT DIAMONDAPI
writefunc(
    INT_PTR hf,
    LPVOID pv,
    UINT cb
    )
{
    // Check for resource read
    if (IS_RESOURCE_HANDLE(hf))
    {
        DebugPrint("Error: trying to write to resource!!\n");
        return -1;
    }

    // Normal write
    if (!WriteFile((HANDLE)hf, pv, cb, (DWORD *) &cb, NULL))
        return -1;
    else
        return cb;
}

int DIAMONDAPI
closefunc(
    INT_PTR hf
    )
{
    if (IS_RESOURCE_HANDLE(hf))
    {
        CloseHandle(g_fhTable[H_TO_I(hf)]);
        g_fhTable[H_TO_I(hf)] = INVALID_HANDLE_VALUE;
    }
    else
    {
        CloseHandle((HANDLE)hf);
    }

    return 0;
}

long DIAMONDAPI
seekfunc(
    INT_PTR hf,
    long dist,
    int seektype
    )
{
    DWORD W32seektype;

    // Check for resource seek
    if (IS_RESOURCE_HANDLE(hf))
    {
        DWORD i = H_TO_I(hf);
        HANDLE fh = g_fhTable[i];
        DWORD dwPosition = g_posTable[i];

        switch (seektype)
        {
        case SEEK_SET:
            W32seektype = FILE_BEGIN;
            dist += dwPosition;
            break;
        case SEEK_CUR:
            W32seektype = FILE_CURRENT;
            break;
        case SEEK_END:
            W32seektype = FILE_BEGIN;
            dist += dwPosition + g_lenTable[i];
            break;
        }

        return SetFilePointer(fh, dist, NULL, W32seektype) - dwPosition;
    }

    // Normal seek
    else
    {
        int W32seektype;

        switch (seektype)
        {
        case SEEK_SET:
            W32seektype = FILE_BEGIN;
            break;
        case SEEK_CUR:
            W32seektype = FILE_CURRENT;
            break;
        case SEEK_END:
            W32seektype = FILE_END;
            break;
        }
        return SetFilePointer((HANDLE)hf, dist, NULL, W32seektype);
    }
}

LPVOID DIAMONDAPI
allocfunc(
    ULONG cb
    )
{
    return (LPVOID)GlobalAlloc(GMEM_FIXED, cb);
}


void DIAMONDAPI
freefunc(
    LPVOID pv
    )
{
    GlobalFree(pv);
}

//  notifyfunc
//      This function is a bit different from the others in that it
//      is the only way we get control of the file copying process.
//      It's much more convenient to get this inside a member function
//      so this routine just turns around and calls the CCab object from
//      instance data passed through FDICopy.

INT_PTR DIAMONDAPI
notifyfunc(
    FDINOTIFICATIONTYPE fdint,
    PFDINOTIFICATION pfdin
    )
{
    // Call the member function
    return ((CCab*)pfdin->pv)->Callback(fdint, pfdin);
}


//---------------------------------------------------------------------
//  Static helper functions
//  (called from _cdecl callback functions)

//  MakeDirectory
//      Creates all directories along a path

VOID
CCab::MakeDirectory(
    LPCTSTR pszPath
    )
{
    LPTSTR pchChopper;
    int cExempt;

    if (pszPath[0] != '\0')
    {
        cExempt = 0;

        if ((pszPath[1] == ':') && (pszPath[2] == '\\'))
            pchChopper = (LPTSTR) (pszPath + 3);   // skip past "C:\"
        else if ((pszPath[0] == '\\') && (pszPath[1] == '\\'))
        {
            pchChopper = (LPTSTR) (pszPath + 2);   // skip past "\\"
            cExempt = 2;                // machine & share names exempt
        }
        else
            pchChopper = (LPTSTR) (pszPath + 1);   // skip past potential "\"

        while (*pchChopper != '\0')
        {
            if ((*pchChopper == '\\') && (*(pchChopper - 1) != ':'))
            {
                if (cExempt != 0)
                    cExempt--;
                else
                {
                    *pchChopper = '\0';
                    CreateDirectory(pszPath,NULL);
                    *pchChopper = '\\';
                }
            }
            pchChopper = CharNext(pchChopper);
        }
    }
}

//  CCab::AdjustFileTime
//      Make the file time match the time saved in the cab.
//      Note that the cab saves the date and time in DOS format (two WORDS)

BOOL
CCab::AdjustFileTime(
    INT_PTR hf
    )
{
    SetFileTime((HANDLE)hf, m_fi.GetFiletime(), m_fi.GetFiletime(), m_fi.GetFiletime());

    return TRUE;
}


//  CCab::Attr32FromAttrFAT
//      Converts from FAT attributes (cabfile) to Win32

DWORD
CCab::Attr32FromAttrFAT(
    WORD attrMSDOS
    )
{
#if 0   // 4/4/2001 [JonT] unifdef this if you want to propagate attributes.
        // Here, we always want files set as normal: not hidden, readonly, or system.
    if (attrMSDOS == _A_NORMAL)
        return FILE_ATTRIBUTE_NORMAL;

    // Mask off read-only, hidden, system, and archive bits
    // NOTE: These bits are in the same places in MS-DOS and Win32!
    return attrMSDOS & ( _A_RDONLY | _A_HIDDEN | _A_SYSTEM | _A_ARCH);
#else
    return FILE_ATTRIBUTE_NORMAL;
#endif
}


//  OverwriteDlgProc
//      Handle the yes, yes to all, no, no to all file overwrite dialog
//      Returns -1 on cancel, 0 on skip file, 1 on clobber file.

BOOL CALLBACK
OverwriteDlgProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static CCab* s_pcab;    // Only one dialog up at once...

    // Check for init message where we get the 'this' pointer
    if (uMsg == WM_INITDIALOG)
        s_pcab = (CCab*)lParam;

    // Call the member function where the real processing happens
    return s_pcab->OnOverwriteMessage(hwnd, uMsg, wParam, lParam);
}

BOOL
CCab::OnOverwriteMessage(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        SetWindowText(GetDlgItem(hwnd, IDC_TEXT_FILENAME), m_szPath);
        FormatWindowText(GetDlgItem(hwnd, IDC_OVERWRITE_TEXT), CUnpacker::GetProductName());
        return TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_YESTOALL:
            m_dwOverwriteFlags |= FILEFLAGS_CLOBBER;
            // fall through
        case IDYES:
            EndDialog(hwnd, 1);
            return TRUE;

        case IDC_NOTOALL:
            m_dwOverwriteFlags |= FILEFLAGS_NEVERCLOBBER;
            // fall through
        case IDNO:
            EndDialog(hwnd, 0);
            return TRUE;

        case IDCANCEL:
            EndDialog(hwnd, -1);
            return TRUE;
        }
    }

    return FALSE;
}

//  SubstituePathsInString
//      Walks a string with %foo% escape sequences.  It
//      looks for a directory name foo and if found replaces
//      %foo% with that directory name.  Otherwise, it leaves it
//      leaves %foo% alone.
void CCab::SubstitutePathsInString(LPSTR lpszInput, LPSTR lpszOutput)
{
    LPSTR  pszInputPos = lpszInput;
    LPSTR  pszOutputPos = lpszOutput;

    // Walk until the end of the input string.
    while(*pszInputPos)
    {
        // Check for % escape sequence
        if (*pszInputPos == '%')
        {   
            LPSTR pszPathEnd = ++pszInputPos;
            LPTARGETDIR pszTargetDir = NULL;

            // Find the end of the escape sequence
            while(*pszPathEnd && ('%'!=*pszPathEnd)) pszPathEnd++;

            // If we found the end, try to substitute
            if('%'==*pszPathEnd)
            {
                //%% =? %
                if(pszInputPos != pszPathEnd)
                {
                  //Look up the escape sequence.
                  *pszPathEnd = '\0';
                  pszTargetDir = m_pdirs->FindTarget(pszInputPos);
                  *pszPathEnd = '%';
                  //If we found a path, substitute it.
                  if(pszTargetDir)
                  {
                    pszInputPos = pszTargetDir->szPath;
                    while(*pszInputPos) *lpszOutput++ = *pszInputPos++;
                    pszInputPos = ++pszPathEnd;
                    continue;
                  } else
                  //Otherwise, just copy it
                  {
                    *lpszOutput++ = '%';
                    while(*pszInputPos) *lpszOutput++ = *pszInputPos++;
                  }
                }
            } else
            {
                //If we didn't find the end, then just leave the %.
                //It would be preferable to use %% to specify %, but if there
                //is a single unmatched %, we will allow it.
                pszInputPos--;
            }
        }
        // Copy the character and continue
        *lpszOutput++ = *pszInputPos++;
    }
    //Null terminate the output.
    *lpszOutput = '\0';
}


//  GetUserDefaultUILanguageWithDefault()
//      Will check the current machine language against the list of
//      all supported languages.  If it doesn't match, it will return
//      the default language that is also specified in the INI file.
LANGID
CCab::GetUserDefaultUILanguageWithDefault()
{
    BOOL bLanguageSupported = FALSE;
    m_punpacker->m_SupportedLangs.MoveFirstLangID();
    do
    {
        if( m_punpacker->m_SupportedLangs.GetCurrentLangID() == GetUserDefaultUILanguage() )
        {
            bLanguageSupported = TRUE;
            break;
        }
    } while( m_punpacker->m_SupportedLangs.MoveNextLangID() );

    if( bLanguageSupported )
        return GetUserDefaultUILanguage();
    else
        return (LANGID)m_punpacker->m_dwDefaultLang;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\uninstall\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by uninstall.rc
//
#define IDS_GENERIC_TITLE               900
#define IDS_TITLE                       901
#define IDS_MB_CONFIRM                  902
#define IDS_MB_FINISHED                 903
#define IDD_PROGRESS                    904
#define IDC_PROGRESS                    905
#define IDC_STATUS                      1000
#define IDS_MB_NOTADMIN                 1001
#define IDS_MB_SINGLEINSTANCEONLY       1002
#define IDS_MB_RUNFROMCONTROLPANEL      1003
#define IDS_CANTFINDFILE                1004
#define IDS_MB_NOTSUCCESSFUL            1005
#define IDS_DELETINGDIRECTORIES         1006
#define IDS_DELETEFILEENTRY             1007
#define IDS_DELETEREGENTRY              1008

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\unpacker\dirs.cpp ===
//  DIRS.CPP
//
//  Created 13-Mar-2001 [JonT]

#include "unpacker.h"

//---------------------------------------------------------------------

//  CDirectories::Init
//      Called once we know how many target directories are supported.
//      This allows a buffer for the directories to be allocated.

BOOL
CDirectories::Init(
    DWORD dwcTargets
    )
{
    // Allocate a buffer sufficient for all target directories
    m_Targets = (LPTARGETDIR)malloc(dwcTargets * sizeof (TARGETDIR));
    if (!m_Targets)
        return FALSE;
    ZeroMemory(m_Targets, dwcTargets * sizeof (TARGETDIR));

    m_dwcTargets = 0;
    return TRUE;
}


//  CDirectories::AllTargets
//      Returns a pointer to all the targets.
//      This allows the caller to enumerate all targets.
//      Returns the count of valid targets in *pdwc

LPTARGETDIR
CDirectories::AllTargets(
    LPDWORD pdwc
    )
{
    if (pdwc)
        *pdwc = m_dwcTargets;

    return m_Targets;
}


//  CDirectories::ParseTargetDirs
//      Walk through all the target directories and prepare them
//      to copy files to.

VOID
CDirectories::ParseTargetDirs()
{
    LPSECTIONENUM lpSection;
    DWORD i;
    LPKEYINFO lpkey;

    // Read the section in the settings file
    lpSection = m_psettings->EnumerateSection(CSTR_TARGETDIRECTORIES);
    if (lpSection == NULL)
        return; // the errors will be caught later

    // Allocate our directory buffer with the total number of directories
    if (!Init(lpSection->dwcKeys))
        return; // errors will be caught later

    // Loop through and add each directory as a target directory.
    // Note that this call might do UI or otherwise not return for
    // a long time!
    // Note that we ignore the return value. It is legal to have a
    // target fail. For example, a REGKEY might not be found.
    for (i = 0, lpkey = lpSection->keys ; i < lpSection->dwcKeys ; ++i, ++lpkey)
    {
        AddTarget(lpkey->lpKey, lpkey->lpValue);
    }

    // Free up the memory allocated by the enumeration
    m_psettings->EnumerateFree(lpSection);
}


//  CDirectories::AddTarget
//      Adds a new directory target. This might mean enabling UI to
//      prompt for a target directory or a registry search.
//      Note that it is NOT an error to have a failure here.
//      The order of targets is important: you might have a regkey and
//      if the regkey isn't found, a prompt target later.
//      Once there is a successful add, we won't add any further targets
//      with that ID.

BOOL
CDirectories::AddTarget(
    LPSTR lpID,
    LPSTR lpCommand
    )
{
    LPSTR lpData;
    LPSTR lp;
    LPSTR lpFlags;
    LPTARGETDIR lpTarget;

    // Zap any trailing digits. We do this so that we don't have duplicate INI keys.
    // We just handle one digit.
    lp = lpID + strlen(lpID) - 1;
    if (*lp >= '0' && *lp <= '9')
        *lp = 0;

    // Check and see if we already have a target with that name
    // If we do and it already has a registered path, then we don't
    // need to add the new target. Otherwise add a new target
    lpTarget = FindTarget(lpID);
    if (lpTarget == NULL)
    {
        // New target
        lpTarget = &m_Targets[m_dwcTargets];
        m_dwcTargets++;
        lpTarget->lpID = _strdup(lpID);
        lpTarget->dwDiskSpaceUsed = 0;
        lpTarget->dwDiskSpaceNeeded = 0;
        lpTarget->szPath[0] = 0;
        lpFlags = m_psettings->GetString(CSTR_DIRFLAGS, lpID);
        lpTarget->dwFlags = GetUnpacker()->AccumulateFlags(lpFlags);
        free(lpFlags);
    }
    else
    {
        // Existing target. Path already filled in successfully?
        if (lpTarget->szPath[0] != 0)
            return FALSE;
    }

    // Parse the command
    // All commands are in the form verb:data
    for (lpData = lpCommand ; *lpData != ':' ; lpData++)
    {
        // No data if there's no :
        if (*lpData == 0)
            break;
    }
    if (*lpData != 0)
    {
        // Zap the ':' so we have a split between command and data and save the pointer
        *lpData++ = 0;
    }

    // Get strings that are ok to keep around
    lpTarget->lpCommand = _strdup(lpCommand);
    lpTarget->lpData = _strdup(lpData);

    // Process the commands
    return ProcessCommands(lpTarget);
}


//  CDirectories::FindTarget
//      Returns a pointer to info about the target or NULL

LPTARGETDIR
CDirectories::FindTarget(
    LPCSTR lpID
    )
{
    DWORD i;

    for (i = 0 ; i < m_dwcTargets ; i++)
    {
        if (_stricmp(lpID, m_Targets[i].lpID) == 0)
            return &m_Targets[i];
    }

    return NULL;
}


//  CDirectories::ProcessCommands
//      Knows how to handle the various commands passed in with each
//      directory target.

BOOL
CDirectories::ProcessCommands(
    LPTARGETDIR lpTarget
    )
{
    // Target directory found from looking up a regkey
    if (_stricmp(lpTarget->lpCommand, "REGKEY") == 0)
    {
        return FindRegKey(lpTarget);
    }

    // This points the directory to the default path entered by the user.
    else if (_stricmp(lpTarget->lpCommand, "DEFAULT") == 0)
    {
        return TRUE;
    }

    // These commands point to predefined system directories
    else if (_stricmp(lpTarget->lpCommand, "SYSTEM") == 0)
    {
        GetSystemDirectory(lpTarget->szPath, MAX_PATH);
        return TRUE;
    }
    else if (_stricmp(lpTarget->lpCommand, "WINDOWS") == 0)
    {
        GetWindowsDirectory(lpTarget->szPath, MAX_PATH);
        return TRUE;
    }

    // This command just means that we need to enumerate later and
    // set it in code as opposed to finding it some other templatized way
    else if (_stricmp(lpTarget->lpCommand, "SET_BY_UNPACKER") == 0)
    {
        return TRUE;
    }

    // Not a known command
    else
    {
        DebugPrint("Failed (unimplemented): ID: %s Command: PROMPT\n", lpTarget->lpID);
        return FALSE;
    }

    // Add future commands here
}


//  CDirectories::FindRegKey
//      Processes the "REGKEY" command by looking up a regkey and filling
//      the directory from a specific value in the regkey.
//      Returns FALSE if the regkey doesn't exist. Doesn't create the path.

#define CMD_REG_ROOTKEY   0
#define CMD_REG_SUBKEY    1
#define CMD_REG_VALUE     2
#define CMD_REG_SUBDIR    3
#define MAX_REG_CMD 4

BOOL
CDirectories::FindRegKey(
    LPTARGETDIR lpTarget
    )
{
    HKEY hkey;
    HKEY hkeyRoot;
    LONG lRet;
    DWORD dwSize = MAX_PATH;

    // Parse the rest of the line.
    LPSTR lp[MAX_REG_CMD];
    DWORD dwc;
    ::ParseLine(lpTarget->lpData, lp, MAX_REG_CMD, &dwc);

    // Translate the key values
    if (_stricmp(lp[CMD_REG_ROOTKEY], "HKLM") == 0)
        hkeyRoot = HKEY_LOCAL_MACHINE;
    else if (_stricmp(lp[CMD_REG_ROOTKEY], "HKCU") == 0)
        hkeyRoot = HKEY_CURRENT_USER;
    else
        return FALSE;

    // Read the key
    if (RegOpenKeyEx(hkeyRoot, lp[CMD_REG_SUBKEY], 0, KEY_READ, &hkey) != ERROR_SUCCESS)
        return FALSE;
    lRet = RegQueryValueEx(hkey, lp[CMD_REG_VALUE], NULL, NULL, (LPBYTE)lpTarget->szPath, &dwSize);
    RegCloseKey(hkey);

    if (lRet == ERROR_SUCCESS)
    {
        // If there's an additional dir to add, do it
        if (lp[CMD_REG_SUBDIR] != NULL)
        {
            ::AppendSlash(lpTarget->szPath);
            strcat(lpTarget->szPath, lp[CMD_REG_SUBDIR]);
        }
    }

    return (lRet == ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\unpacker\manifest.cpp ===
//  MANIFEST.CPP
//
//  Created 13-Mar-2001 [JonT]

#include "unpacker.h"


//---------------------------------------------------------------------

 
CManifest::CManifest(
    CSettingsFile* psettings
    )
: m_lpData(NULL),
  m_fEOF(FALSE)
{
}

                                    
//  CManifest::SetFile
//      Initializes the manifest object by reading in the entire manifest and preparing
//      to parse each line.
                                    
BOOL
CManifest::SetFile(
    LPCTSTR lpFile
    )
{
    HANDLE handle;
    DWORD dwLen;
    DWORD dwActuallyRead;

    // Make sure we don't already have a manifest loaded
    if (m_lpData)
        free(m_lpData);

    // Try to open the file
    handle = CreateFile(lpFile, GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
        FILE_FLAG_SEQUENTIAL_SCAN, NULL);
    if (handle == INVALID_HANDLE_VALUE)
        return FALSE;

    // Read the entire file
    dwLen = GetFileSize(handle, NULL);
    if (dwLen == 0xffffffff)
        return FALSE;

    // Allocate a buffer big enough for the whole file
    m_lpData = (LPSTR)malloc(dwLen + 1);
    if (!m_lpData)
        return FALSE;

    // Read it completely and zero-terminate
    if (!ReadFile(handle, m_lpData, dwLen, &dwActuallyRead, NULL) ||
        dwActuallyRead != dwLen)
        return FALSE;
    *(m_lpData + dwLen) = 0;

    // Close file, we're done with it
    CloseHandle(handle);

    // Point the line pointer to the start of the data
    m_lpLine = m_lpData;

    return TRUE;
}


//  CManifest::ResetPointer
//      Sets the pointer to the start of the manifest
//      As with other parsing functions, returns TRUE on EOF.

BOOL
CManifest::ResetPointer()
{
    m_lpLine = m_lpData;

    // Skip whitespace including comment lines, etc.
    // Note that if we return TRUE here, the manifest is empty
    // and the installer is corrupt.
    return SkipWhitespace(m_lpLine);
}


//  CManifest::GetLine
//      Copies the current line of the manifest into the internal buffer.
//      This function does not move to the next line.
//      The buffer can be modified in place. GetLine can be called again
//      to copy in a fresh copy of the line.

LPSTR
CManifest::GetLine()
{
    LPSTR lpIn = m_lpLine;
    LPSTR lpOut = m_szLine;
    DWORD i;

    // Read from the buffer until we hit end of line or file
    for (i = 0 ; *lpIn != '\n' && *lpIn != '\r' && i < MAX_MANIFEST_LINE ; ++lpIn, ++i)
    {
        if (*lpIn == 0)
            break;
        else
            *lpOut++ = *lpIn;
    }
    *lpOut = 0;

    return m_szLine;
}


//  CManifest::SkipToNextLine
//      Moves the pointer to the start of the next line.
//      Returns TRUE at EOF.

BOOL
CManifest::SkipToNextLine()
{
    for (; *m_lpLine != '\n' && *m_lpLine != '\r' ; ++m_lpLine)
    {
        if (*m_lpLine == 0)
            return TRUE;
    }

    // Skip whitespace including comment lines, etc.
    return SkipWhitespace(m_lpLine);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\unpacker\unpacker.cpp ===
//  UNPACKER.CPP
//
//  Created 13-Mar-2001 [JonT]

#include "unpacker.h"

//---------------------------------------------------------------------

int WINAPI
WinMain(
    HINSTANCE hInst,
    HINSTANCE hPrevInst,
    LPSTR lpCmdLine,
    int nCmdShow
    )
{
    CUnpacker app(hInst, lpCmdLine);
    CWizard wiz;
    int nRet;


#ifdef TEST_JPN
    SetThreadLocale(MAKELCID(MAKELANGID(LANG_JAPANESE, SUBLANG_NEUTRAL), SORT_DEFAULT));
#endif
    
    // Make sure we just have one installer running at a time
    static HANDLE s_hevNamespace = CreateEvent(NULL, TRUE, TRUE, _TEXT("Local\\X_SETUP_ENGINE"));
    if (GetLastError() == ERROR_ALREADY_EXISTS)
    {
        TCHAR szTitle[MAX_PATH];
        TCHAR szError[MAX_PATH];
        LoadString(hInst, IDS_WIZARD_TITLE, szTitle, MAX_PATH);
        LoadString(hInst, IDS_ERRORTWOINSTALLERS, szError, MAX_PATH);
        MessageBox(NULL, szError, szTitle, MB_OK);

        return -1;
    }

    // Initialize COM
    CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);

    // Process command line
    if (!app.CommandLine(lpCmdLine))
        return -1;

    // Unpack the settings cab
    if(!app.UnpackSettingsCab())
        return -1;
    
    // We are about to run the wizard
    SetWizRunningState(TRUE);

    // Drive everything through the wizard
    nRet = wiz.DoModal(NULL);

    // The wizard has returned
    SetWizRunningState(FALSE);

    // If we were successful, call the custom postsetup stuff
    if (nRet != -1)
        app.PostSetup(nRet);

    CloseHandle(s_hevNamespace);

    // Reboot if the wizard told us to.
    if(1==nRet)
        Reboot();

    return 0;
}


//---------------------------------------------------------------------
//  CUnpacker class


// Static member variables and contained classes
    HINSTANCE CUnpacker::m_shinst = NULL;
    HINSTANCE CUnpacker::m_scustomhinst = NULL;
    CUnpacker* CUnpacker::m_spThis = NULL;
    CCustom*   CUnpacker::m_spCustom = NULL;
    CSettingsFile CUnpacker::m_settings;
    BOOL          CUnpacker::m_sfWizardRunning=FALSE;
    
    CUninstall CUnpacker::m_uninstall;
    CManifest CUnpacker::m_manifest(&CUnpacker::m_settings);
    CDirectories CUnpacker::m_dirs(&CUnpacker::m_settings);

//  CUnpacker::CUnpacker
//      Singleton application class

CUnpacker::CUnpacker(
    HINSTANCE hinst,
    LPSTR lpCommandline
    )
{
    m_shinst = hinst;
    m_spThis = this;
    m_fTempDir = FALSE;
    m_lpCommandline = lpCommandline;
    m_ProductRegKey.hRootKey = NULL;
    m_ProductRegKey.lpKey = NULL;
    m_ProductRegKey.lpSubkey = NULL;
    m_lpszProductName = NULL;
    m_dwDefaultLang = 0;


    m_szUninstallDir[0] = 0;
    m_szDefaultDir[0] = 0;
    m_dwFlags = 0;
    m_szCabSource[0] = 0;
}


CUnpacker::~CUnpacker()
{
    if(m_scustomhinst)
        FreeLibrary(m_scustomhinst);
    if (m_fTempDir)
        DeleteDirectory(m_szUninstallDir);
    if(m_lpszProductName)
        free(m_lpszProductName);
    if(m_ProductRegKey.lpKey)
        free(m_ProductRegKey.lpKey);
}


//  CUnpacker::CommandLine
//      Processes the command line and sets flags on the CUnpacker object

BOOL
CUnpacker::CommandLine(
    LPSTR lpCmdLine
    )
{
    LPSTR lp;
    LPSTR lpNew;
    TCHAR szTitle[MAX_PATH];
    TCHAR szUsage[2048];
    BOOL fQuote;

    // Scan through looking for slash or -
    for (lp = lpCmdLine ; *lp ; ++lp)
    {
        if (*lp == '-' || *lp == '/')
        {
            if (*++lp == 0)
                break;
            switch (*lp)
            {
            case '?':
                LoadString(::GetInstanceHandle(), IDS_WIZARD_TITLE, szTitle, MAX_PATH);
                LoadString(::GetInstanceHandle(), IDS_MB_USAGE, szUsage, 2048);
                MessageBox(NULL, szUsage, szTitle, MB_OK);
                return FALSE;
            
            case 'f':
            case 'F':
                m_dwFlags |= UNPACKER_FLAGS_FORCEINSTALL;
                break;

            case 's':
            case 'S':
                m_dwFlags |= UNPACKER_FLAGS_SKIPPRESETUPCHECKS;
                break;

            case 'e':
            case 'E':
                ++lp; // skip 'e' character

                // skip whitespace
                while (*lp == ' ' || *lp == '\t')
                    ++lp;
                fQuote = (*lp == '"');
                if (fQuote)
                    ++lp;

                // Loop through the string copying it into our exe name buffer
                lpNew = m_szCabSource;
                while (*lp != 0)
                {
                    if (fQuote)
                    {
                        if (*lp == '"')
                        {
                            ++lp;
                            break;
                        }
                    }
                    else
                    {
                        if (*lp == ' ' || *lp == '\t')
                            break;
                    }
                    *lpNew++ = *lp++;
                }
                *lpNew = 0;
                break;
            }
        }
    }

    return TRUE;
}

//  CUnpacker::UnpackSettingsCab
//      Unpacks the first cab. This one has the manifest, the settings file,
//      and the custom dll.
//      Leaves the files in a temporary directory.

BOOL
CUnpacker::UnpackSettingsCab()
{
    PFNGETCUSTOM pfnGetCustom;
    LPSTR        lpProductKeyName;
    TCHAR szPath[MAX_PATH];
    CCab cabSettings(&m_settings, &m_dirs, &m_uninstall, this);

    // Initialize the settings cabfile
    if (!cabSettings.Init())
    {
        DebugPrint("No cab resources: this executable hasn't been packed\n");
        SetLastError(IDS_UNPACKERNOTPACKED, 1001);
        return FALSE;
    }

    // Create the directory we're going to write the settings cabfile to
    GetTempPath(MAX_PATH, m_szUninstallDir);
    GetTempFileName(m_szUninstallDir, "unp", 0, m_szUninstallDir);
    DeleteFile(m_szUninstallDir);
    ::AppendSlash(m_szUninstallDir);
    if (!CreateDirectory(m_szUninstallDir, NULL))
    {
        DebugPrint("CreateDirectory of %s failed (error=%08x)\n", m_szUninstallDir, GetLastError());
        SetLastError(IDS_CORRUPT_INSTALLER, 1002);
        return FALSE;
    }
    m_fTempDir = TRUE;

    // Unpack the settings cabfile into the temporary directory. Note that the settings cabfile
    // is the second file in the list, and in the zero-based parameter, this is one.
    cabSettings.ProcessNoManifest(m_szUninstallDir, 1);
    cabSettings.Close();

    // Now try to point to the settings file
    strcpy(szPath, m_szUninstallDir);
    ::AppendSlash(szPath);
    strcat(szPath, SCAB_SETTINGS);
    if (!m_settings.SetFile(szPath, FALSE))
    {
        DebugPrint("Couldn't locate settings file\n");
        SetLastError(IDS_UNPACKERNOTPACKED, 1003);
        return FALSE;
    }

    // Read the supported languages
    LPSTR lpLangs = m_settings.GetSetting(CSTR_LANGUAGES);
    if(!*lpLangs)
    {
        SetLastError(IDS_UNPACKERNOTPACKED, 1091);
        return FALSE;
    }
    m_SupportedLangs.ParseLangIDs( lpLangs );

    // Read the default language
    LPSTR lpDefaultLang = m_settings.GetSetting(CSTR_DEFAULTLANGUAGE);
    if(!*lpDefaultLang)
    {
        SetLastError(IDS_UNPACKERNOTPACKED, 1091);
        return FALSE;
    }
    LPSTR lpStopScan = NULL;
    m_dwDefaultLang = strtol( lpDefaultLang, &lpStopScan, 16 );

    // Read the product name
    m_lpszProductName = m_settings.GetSetting(CSTR_PRODUCTNAME);
    if(!*m_lpszProductName)
    {
        SetLastError(IDS_UNPACKERNOTPACKED, 1091);
        return FALSE;
    }
    
    //  Read the product key
    lpProductKeyName= m_settings.GetSetting(CSTR_PRODUCTKEY);
    if(!*lpProductKeyName)
    {
        free(lpProductKeyName);
        SetLastError(IDS_UNPACKERNOTPACKED, 1089);
        return FALSE;
    }
    ParseLine(lpProductKeyName, (LPSTR*)&m_ProductRegKey, INIREGKEY_DWORDS, NULL);

    // Get the root key, from the equivalent strings
    if (_stricmp(m_ProductRegKey.lpKey, "HKLM") == 0)
        m_ProductRegKey.hRootKey = HKEY_LOCAL_MACHINE;
    else if (_stricmp(m_ProductRegKey.lpKey, "HKCU") == 0)
        m_ProductRegKey.hRootKey = HKEY_CURRENT_USER;
    else
    {
       SetLastError(IDS_UNPACKERNOTPACKED, 1090);
       return FALSE;
    }

    // Try to load library the custom dll.
    strcpy(szPath, m_szUninstallDir);
    ::AppendSlash(szPath);
    strcat(szPath, SCAB_CUSTOMDLL);
    m_scustomhinst = LoadLibrary(szPath);
    if(!m_scustomhinst)
    {
        DebugPrint("No custom dll\n");
        return TRUE;
    }

    //  Get a pointer to CCustom
    pfnGetCustom = (PFNGETCUSTOM) GetProcAddress(m_scustomhinst, GETCUSTOMPROC);
    if(pfnGetCustom)
    {
        m_spCustom = pfnGetCustom(this);
    }

    return TRUE;
}


//  CUnpacker::ProcessDirectories
//      Walks the target directories and fills them in the best way possible.
//      If we return TRUE, this is an upgrade, FALSE if it's a new install.

BOOL
CUnpacker::ProcessDirectories()
{
    // walk through the directories, setting everything possible
    m_dirs.ParseTargetDirs();

    // Read the the install path. If we find it, we're good and this is an upgrade, return TRUE;
    // If not, this is not an upgrade.  The UI will set the directory instead, return FALSE;
    return GetRegistryString(m_szDefaultDir, MAX_PATH, m_ProductRegKey.hRootKey, m_ProductRegKey.lpSubkey, XSETUP_INSTALL_REGVALUE);
}

//  CreateVersionString
//      Creates a version string from four WORD values
//      Parameter string must be long enough to accept it (MAX_PATH is plenty safe)

void
CreateVersionString(
    LPSTR lp,
    WORD w1,
    WORD w2,
    WORD w3,
    WORD w4
    )
{
    sprintf(lp, "%d,%d,%d,%d", (DWORD)w1, (DWORD)w2, (DWORD)w3, (DWORD)w4);
}

VOID
CUnpacker::WriteInstallInfo()
{
    HKEY hKey;
    SYSTEMTIME st;
    FILETIME   ft;
    char  szBuild[MAX_PATH];
    
    // Write the registry key out
    if (ERROR_SUCCESS==::RegCreateKeyEx(m_ProductRegKey.hRootKey, m_ProductRegKey.lpSubkey, 0, NULL, 0, KEY_ALL_ACCESS, NULL, &hKey, NULL))
    {
        // Write the product key values (product name, product version, install path and install time
        RegSetValueEx(hKey, XSETUP_PRODUCT_NAME_REGVALUE, 0, REG_SZ, (LPBYTE)m_lpszProductName, strlen(m_lpszProductName) + 1);
        CreateVersionString(szBuild, VER_PRODUCTVERSION); // VER_PRODUCTVERSION contains 4 parameters
        RegSetValueEx(hKey, XSETUP_FULL_BUILD_REGVALUE, 0, REG_SZ, (LPBYTE)szBuild, strlen(szBuild) + 1);
        RegSetValueEx(hKey, XSETUP_INSTALL_REGVALUE, 0, REG_SZ, (LPBYTE)m_szDefaultDir, strlen(m_szDefaultDir) + 1);
        GetLocalTime(&st);
        SystemTimeToFileTime(&st, &ft);
        RegSetValueEx(hKey, XSETUP_INSTALLTIME_REGVALUE, 0, REG_QWORD, (LPBYTE)&(((LARGE_INTEGER*)&ft)->QuadPart), sizeof (__int64));
        RegCloseKey(hKey);
    }

    // BUGBUG: This shouldn't be necessary. Uninstall should be reading and erasing these automatically.
    m_uninstall.AddReg(m_ProductRegKey.lpKey, m_ProductRegKey.lpSubkey, XSETUP_PRODUCT_NAME_REGVALUE);
    m_uninstall.AddReg(m_ProductRegKey.lpKey, m_ProductRegKey.lpSubkey, XSETUP_FULL_BUILD_REGVALUE);
    m_uninstall.AddReg(m_ProductRegKey.lpKey, m_ProductRegKey.lpSubkey, XSETUP_INSTALL_REGVALUE);
    m_uninstall.AddReg(m_ProductRegKey.lpKey, m_ProductRegKey.lpSubkey, XSETUP_INSTALLTIME_REGVALUE);
}

//
//  This handles legacy installs of the XDK, before moving to
//  this setup engine.  Instead of an InstallPath there was an
//  SDK Doc Path.  So we read this, munge it to produce the proper
//  install path and write it back out.
//
VOID CUnpacker::ProcessLegacySetup()
{
    HKEY hKey;
    // open the product key.
    if (RegOpenKey(m_ProductRegKey.hRootKey, m_ProductRegKey.lpSubkey, &hKey) == ERROR_SUCCESS)
    {
        // Try to read the install time.  If the install time is there than this is not a legacy setup.
        FILETIME ft;
        DWORD dwType;
        DWORD dwLen = sizeof (ft);
        if (RegQueryValueEx(hKey, XSETUP_INSTALLTIME_REGVALUE, NULL, &dwType,
                            (LPBYTE)&ft, &dwLen) == ERROR_SUCCESS && dwType == REG_QWORD)
        {
            // Also set this flag UNPACKER_FLAGS_SETUPHASRUNBEFORE.
            // This tells us to skip a bunch of commands in .csv file
            SetFlags(UNPACKER_FLAGS_SETUPHASRUNBEFORE);
        } else
        {
            // Check for the key that old installshield setup put in for the XDK. If we find it,
            // rewrite it as the new key so we still upgrade to the same directory as before
            TCHAR szOldPath[MAX_PATH];
            dwLen = sizeof (szOldPath);
            if (RegQueryValueEx(hKey, XDK_OLD_INSTALL_REGVALUE, NULL, &dwType,
                                (LPBYTE)szOldPath, &dwLen) == ERROR_SUCCESS && dwType == REG_SZ)
            {
                // We have the old string. Strip the last path component off (since this was
                // the 'doc path'
                LPTSTR lp = szOldPath + strlen(szOldPath) - 1;
                for (; lp > szOldPath && *lp != '\\' && *lp != ':' ; --lp)
                    ;
                if (*lp == '\\')
                    *lp = 0;
                else if (*lp == ':')
                    *(lp + 1) = 0;
                ::AppendSlash(szOldPath);

                // Write the string back out in the new way
                RegSetValueEx(hKey, XSETUP_INSTALL_REGVALUE, 0, REG_SZ, (LPBYTE)szOldPath, strlen(szOldPath) + 1);
            }
        }
        RegCloseKey(hKey);
    }
    return;
}

//  CUnpacker::DoPreSetupChecks
//     Called to verify that setup may proceed on the current system.
//     The following checks are performed:
//        Disk Space, User Privileges, Previous Version (for QFE
//        packages).
//
//

BOOL 
CUnpacker::DoPreSetupChecks()
{
    // Skip all presetup checks if the flag was passed in to tell us so...
    // This is an "udocumented, at your own risk" feature.
    if (GetFlags() & UNPACKER_FLAGS_SKIPPRESETUPCHECKS)
        return TRUE;
    
    // Check for administrator
    if (!IsAdministrator())
    {
        SetLastError(IDS_ERRORNOTADMINISTRATOR, 2007);
        return FALSE;
    }

    // Check Windows Version
    if (!CheckWindows())
        return FALSE;

    // Check Upgrade Version
    if (!CheckUpgradeVersion())
        return FALSE;

    //Perform Custom PreSetup checks if any.
    if(m_spCustom && !m_spCustom->DoPreSetupChecks())
        return FALSE;

    // The Japanese build should not be run on a machine without the locale ID set to
    // Japanese or the fonts won't work correctly.
#ifdef UNPACKER_JPN
    LCID lcid = GetThreadLocale();
    LCID lcidCompare = MAKELCID(MAKELANGID(LANG_JAPANESE, SUBLANG_NEUTRAL), SORT_DEFAULT);
    lcidCompare = ConvertDefaultLocale(lcidCompare);
    if (lcid != lcidCompare)
    {
        SetLastError(IDS_JAPANESENOTAVAILABLE, 2015);
        return FALSE;
    }
#endif
    return TRUE;
}


//  CUnpacker::CheckForOtherProduct
//      Due to the way uninstall works only one Xbox Install Technology product
//      can be installed to a single directory.  A product is different if it 
//      should be separately uninstallable.  This routine works by opening the
//      settings.ini file in the uninstall directory and checking the product's
//      default install directory.  If it is the same as this products default
//      install directory the routine turn false.  Additionally, lpOtherProduct
//      is filled in with the product name of the product that occupies lpTarget.
//
BOOL 
CUnpacker::CheckForOtherProduct(LPSTR lpTarget, LPSTR lpOtherProduct, DWORD cbOtherProduct)
{
    BOOL  fAllowInstall = TRUE;
    LPSTR lpOtherProductDefaultInstallDir;
    LPSTR lpDefaultInstallDir;
    
    //Until we find another product, there isn't one.
    *lpOtherProduct = '\0';

    // Get the path to where the settings file would be if there is another
    // product installed at lpTarget.
    TCHAR szOtherProductsSettingsPath[MAX_PATH];
    strcpy(szOtherProductsSettingsPath, lpTarget);
    ::AppendSlash(szOtherProductsSettingsPath);
    strcat(szOtherProductsSettingsPath, SCAB_UNINSTALLDIR);
    ::AppendSlash(szOtherProductsSettingsPath);
    strcat(szOtherProductsSettingsPath, SCAB_SETTINGS);
    
    // Create a CSettingsFile and set the name.  Note that
    // this does not actually open the file, so that this
    // cannot fail with the args we are using.
    CSettingsFile otherProductSettings;
    otherProductSettings.SetFile(szOtherProductsSettingsPath);
    lpOtherProductDefaultInstallDir = otherProductSettings.GetSetting(CSTR_DEFAULTDIRTEXT);
    if(lpOtherProductDefaultInstallDir)
    {
        // If the other product string exists (is not an empty string)
        // Compare it to this product's default install dir.
        if(*lpOtherProductDefaultInstallDir)
        {
            // Get this products default install dir.
            lpDefaultInstallDir = m_settings.GetSetting(CSTR_DEFAULTDIRTEXT);
            if(lpDefaultInstallDir)
            {
                //If the default install directories are not identical, these are
                //different products, don't allow installation to the same directory.
                if(strcmp(lpOtherProductDefaultInstallDir, lpDefaultInstallDir))
                {
                    fAllowInstall = FALSE;
                    //Fill out the other product's name so that the wizard may
                    //Display it in the UI.
                    LPSTR lpOtherProductTemp = otherProductSettings.GetSetting(CSTR_PRODUCTNAME);
                    if(lpOtherProductTemp)
                    {
                        if(*lpOtherProductTemp)
                        {
                            strncpy(lpOtherProduct, lpOtherProductTemp, cbOtherProduct);
                        } else
                        {
                            strncpy(lpOtherProduct, lpOtherProductDefaultInstallDir, cbOtherProduct);
                        }
                        free(lpOtherProductTemp);
                    }
                }
                free(lpDefaultInstallDir);
            }
        }
        free(lpOtherProductDefaultInstallDir);
    }
    return fAllowInstall;
}

//  CUnpacker::ValidateDirectories
//      Called to let us validate all the directories we've parsed out
//      of the settings file. If things aren't good, we need to be able to
//      put up a descriptive error message before going on.
//      If we return FALSE, things aren't good. We've set an error string
//      with WizSetLastError before returning.

BOOL
CUnpacker::ValidateDirectories()
{
    LPTARGETDIR lpTarget;
    DWORD dwc;
    DWORD i;

    // Get the pointer to the first target and count
    lpTarget = m_dirs.AllTargets(&dwc);

    // Walk through all the targets validating them
    for (i = 0 ; i < dwc ; ++i, ++lpTarget)
    {
        // Fill in the DEFAULT command paths. We couldn't do this earlier
        // because we didn't have it from the user yet.
        if (_stricmp(lpTarget->lpCommand, "DEFAULT") == 0)
            strcpy(lpTarget->szPath, m_szDefaultDir);

        // Call the custom directory routine to give it a chance to
        // either fill in the path or return an error (and set the error ID)
        if (m_spCustom && !m_spCustom->ValidateDirectory(m_szDefaultDir, lpTarget->lpID,
                           lpTarget->lpCommand, lpTarget->lpData, lpTarget->szPath))
        {
            SetLastError(IDS_CORRUPT_INSTALLER, 1018);
            return FALSE;
        }

        // As a sanity check, make sure there's something in the path or
        // do the general error ourselves
        if (lpTarget->szPath[0] == 0)
        {
            SetLastError(IDS_CORRUPT_INSTALLER, 1004);
            return FALSE;
        }
    }

    return TRUE;
}


//  CUnpacker::MoveSettingsCab
//      The settings cab was originally expanded into a temp directory
//      because we didn't know where to put it. Now that we know where
//      it's supposed to go, move it there

BOOL
CUnpacker::MoveSettingsCab()
{
    TCHAR szPath[MAX_PATH];

    // Build uninstall directory
    strcpy(szPath, m_szDefaultDir);
    ::AppendSlash(szPath);
    strcat(szPath, SCAB_UNINSTALLDIR);
    ::AppendSlash(szPath);

    // Move all settings to the new uninstall directory, deleting the tempdir
    if (!MoveDirectory(m_szUninstallDir, szPath))
    {
        SetLastError(IDS_CORRUPT_INSTALLER, 1007);
        return FALSE;
    }

    // We're done with the tempdir now. Make our 'uninstall' directory the new dir
    m_fTempDir = FALSE;
    strcpy(m_szUninstallDir, szPath);

    // Reset the settings file
    strcat(szPath, SCAB_SETTINGS);
    m_settings.SetFile(szPath);

    return TRUE;
}

//  CUnpacker::CheckDiskSpace
//      Checks disk space on all drives.
//      Displays UI (MessageBox) if there is inadequate space.
//      Returns 0 if the disk check was successful and there's adequate disk space.
//      Returns 1 if the disk check found that the disk space was exceeded by the
//          default directory. The user can change drives to remedy.
//      Returns -1 if the disk check finds that the disk space was exceeded by the
//          directories other than the default directory. They're screwed.

int
CUnpacker::CheckDiskSpace()
{
    if (!AccumulateFileSizes())
        return -1;

    return CheckAvailableSpace();
}


//  CUnpacker::StartCopy
//      Kicks off the background thread copy routine.
//      We communicate with the progress bar through globals since
//      the FDI routines call us with C functions.

DWORD WINAPI ThreadStart(CUnpacker* punpacker);

VOID
CUnpacker::StartCopy(
    HWND hwndDlg,
    HWND hwndProgress,
    HWND hwndActionText,
    HWND hwndInProgressText
    )
{
    LPTARGETDIR lpTarget;
    DWORD dwc;
    DWORD dwTotalSize;
    DWORD i;

    // Compute the total number of bytes to be copied
    lpTarget = m_dirs.AllTargets(&dwc);
    dwTotalSize = 0;
    for (i = 0 ; i < dwc ; ++i, ++lpTarget)
        dwTotalSize += lpTarget->dwDiskSpaceNeeded;

    // Set up the progress indicator
    SendMessage(hwndProgress, PBM_SETRANGE32, 0, dwTotalSize);
    SendMessage(hwndProgress, PBM_SETSTEP, 1, 0);
    SendMessage(hwndProgress, PBM_SETPOS, 0, 0);

    // Keep the hwnds around for use during the copy process
    m_dwBytesCopiedSoFar = 0;
    m_hwndProgress = hwndProgress;
    m_hwndDlg = hwndDlg;
    m_hwndActionText = hwndActionText;
    m_hwndInProgressText = hwndInProgressText;

    // Get a table of widths for each character so we don't have to do it per-file
    HDC hdc = GetDC(m_hwndInProgressText);
    HFONT hfont = (HFONT)SendMessage(m_hwndInProgressText, WM_GETFONT, 0, 0);
    HFONT hfontOld = (HFONT)SelectObject(hdc, hfont);
    GetCharABCWidths(hdc, 0, 255, m_abc);
    SelectObject(hdc, hfontOld);
    ReleaseDC(m_hwndInProgressText, hdc);

    // Initialize the uninstall info
    m_uninstall.Init(m_dwcManifestLines, m_szUninstallDir);

    // Kick off a thread to do the copying
    m_hthread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)ThreadStart, (LPVOID)this, 0, &dwc);
}


//  CUnpacker::UpdateProgressBar
//      Updates the progress bar by adding the current number of bytes in

VOID
CUnpacker::UpdateProgressBar(
    DWORD dwSize,
    DWORD dwID,
    LPCTSTR lpText
    )
{
    if (m_hwndProgress)
    {
        PostMessage(m_hwndProgress, PBM_SETPOS, m_dwBytesCopiedSoFar, 0);
        if (dwSize > 0)
            m_dwBytesCopiedSoFar += ::DWORDtoDiskSpace(dwSize);
    }

    if (m_hwndActionText && dwID != 0)
    {
        TCHAR sz[MAX_PATH];
        LoadString(::GetInstanceHandle(), dwID, sz, MAX_PATH);
        SetWindowText(m_hwndActionText, sz);
    }

    if (m_hwndInProgressText && lpText != NULL)
    {
        TCHAR szEllipses[MAX_PATH];
        ConvertToEllipses(m_hwndInProgressText, szEllipses, lpText);
        SetWindowText(m_hwndInProgressText, szEllipses);
    }
}


//  CUnpacker::ConvertToEllipses
//      Makes a string fit in the edit control by whacking out the middle of the
//      string and replacing with ellipses

VOID
CUnpacker::ConvertToEllipses(
    HWND hwnd,
    LPSTR lpOut,
    LPCTSTR lpIn
    )
{
    HDC hdc = GetDC(hwnd);
    HFONT hfont = (HFONT)SendMessage(hwnd, WM_GETFONT, 0, 0);
    HFONT hfontOld = (HFONT)SelectObject(hdc, hfont);

    // Figure out how much space the current text would take
    SIZE size;
    DWORD dwcLen = strlen(lpIn);
    GetTextExtentPoint(hdc, lpIn, dwcLen, &size);

    // Get the size of the control. Fudge it by one char because the control probably isn't
    // an incremental char width wide.
    RECT rect;
    GetClientRect(hwnd, &rect);
    rect.right -= 8;

    // If the text will fit, copy it and go
    if (size.cx <= rect.right - rect.left)
    {
        strcpy(lpOut, lpIn);
    }

    // Otherwise, create the ellipses
    else
    {
        // Build the first part of the string
        strncpy(lpOut, lpIn, 5);
        lpOut[5] = 0;
        strcat(lpOut, "...");
        SIZE sizeFirst;
        GetTextExtentPoint(hdc, lpOut, 8, &sizeFirst);

        // Loop through all characters in the name assigning widths
        int nTotalWidth = rect.right - rect.left - sizeFirst.cx;
        LPCSTR lp = lpIn + strlen(lpIn) - 1;
        while (TRUE)
        {
            // Check for bail out case: we don't need ellipses after all!
            if (lp < lpIn + 5)
            {
                lp = NULL;
                break;
            }

            // See if we have made it big enough
            if (nTotalWidth <= 0)
                break;

            // Otherwise, subtract off this character's contribution and move to the next
            nTotalWidth -= m_abc[*lp].abcA + m_abc[*lp].abcB + m_abc[*lp].abcC;
            --lp;
        }

        // We're done: copy the bytes, clean up and get out
        if (lp == NULL)
            strcpy(lpOut, lpIn);
        else
            strcat(lpOut, lp + 1);
    }

    // Clean up
    SelectObject(hdc, hfontOld);
    ReleaseDC(hwnd, hdc);
}


//  CUnpacker::AccumulateFlags
//      Accumulate flags into a DWORD from a flag string.
//      Flag strings are strings composed of letters. Every letter (A-Z)
//      is mapped to a bit by doing 1 << (ch - 'A')

DWORD
CUnpacker::AccumulateFlags(
    LPCSTR lp
    )
{
    UCHAR ch;
    DWORD dwAccum;

    // Add flag values for each letter in the list
    for (dwAccum = 0 ; *lp != 0 ; ++lp)
    {
        ch = (*lp | 32) - 'a';
        if (ch < 26)
            dwAccum |= 1 << ch;
    }

    return dwAccum;
}

void CUnpacker::SetLastError(DWORD dwStringID, DWORD dwErrorCode)
{
    if(m_sfWizardRunning)
    {
        WizSetLastError(dwStringID, dwErrorCode);
        return;
    }

    // If the wizard is not running, just pop a MessageBox
    TCHAR szErrorText[4096];
    TCHAR szErrorCaption[MAX_PATH];
    TCHAR szErrorCodeText[10];

    // If there's is not set, display the general one
    if (dwStringID == 0) dwStringID = IDS_ERROR_GENERAL;
    if(m_lpszProductName)
    {
        strcpy(szErrorCaption, m_lpszProductName);
    } else
    {
        LoadString(GetInstanceHandle(), IDS_WIZARD_TITLE, szErrorCaption, MAX_PATH);
    }
    LoadString(GetInstanceHandle(), dwStringID , szErrorText, 4096);
    sprintf(szErrorCodeText, TEXT(": %d"), dwErrorCode);
    strcat(szErrorText, szErrorCodeText);
    MessageBox(NULL, szErrorText, szErrorCaption, MB_OK|MB_ICONSTOP);
}

void CUnpacker::SetLastErrorString(LPCTSTR lpString, DWORD dwErrorCode)
{
    if(m_sfWizardRunning)
    {
        WizSetLastErrorString(lpString, dwErrorCode);
        return;
    }
    
    // If the wizard is not running, just pop a MessageBox
    TCHAR szErrorCaption[MAX_PATH];
    if(m_lpszProductName)
    {
        strcpy(szErrorCaption, m_lpszProductName);
    } else
    {
        LoadString(GetInstanceHandle(), IDS_WIZARD_TITLE, szErrorCaption, MAX_PATH);
    }

    TCHAR szErrorText[4096];
    sprintf(szErrorText, TEXT("%s: %d"), lpString, dwErrorCode);
    MessageBox(NULL, szErrorText, szErrorCaption, MB_OK|MB_ICONSTOP);
}

//---------------------------------------------------------------------
//  Private routines


//  CUnpacker::MoveDirectory
//      Moves all the files in a directory to another and deletes the old directory

BOOL
CUnpacker::MoveDirectory(
    LPCTSTR lpSource,
    LPCTSTR lpDest
    )
{
    WIN32_FIND_DATA find;
    TCHAR szSourcePath[MAX_PATH];
    TCHAR szDestPath[MAX_PATH];
    TCHAR szFindPath[MAX_PATH];
    LPTSTR lpDestFile;
    LPTSTR lpSourceFile;
    HANDLE hfind;

    // Create the find path with a \*.* for the search
    strcpy(szFindPath, lpSource);
    ::AppendSlash(szFindPath);
    strcat(szFindPath, "*.*");

    // Create the source and dest dirs such that we can add the target filenames on
    strcpy(szSourcePath, lpSource);
    ::AppendSlash(szSourcePath);
    lpSourceFile = szSourcePath + strlen(szSourcePath);
    strcpy(szDestPath, lpDest);
    ::AppendSlash(szDestPath);
    lpDestFile = szDestPath + strlen(szDestPath);

    // Make sure the dest dir exists
    CCab::MakeDirectory(szDestPath);

    // Loop through all the files in source
    if ((hfind = FindFirstFile(szFindPath, &find)) != INVALID_HANDLE_VALUE)
    {
        do
        {
            // Skip . and ..
            if (find.cFileName[0] == '.')
                continue;

            // Skip any directories we might find
            if (find.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                DebugPrint("Directory found in uninstall dir! temp directory won't get deleted...\n");
                continue;
            }

            // For any other file, move it to the right spot
            *lpSourceFile = 0;
            strcat(lpSourceFile, find.cFileName);
            *lpDestFile = 0;
            strcat(lpDestFile, find.cFileName);
            if (!MoveFileEx(szSourcePath, szDestPath,
                MOVEFILE_COPY_ALLOWED | MOVEFILE_REPLACE_EXISTING))
            {
                DebugPrint("Error moving file from temp directory (error=%08x)\n", GetLastError());
            }
        }
        while (FindNextFile(hfind, &find));
    }
    FindClose(hfind);

    // Nuke the directory, don't worry if it fails, in at least
    // one case, we expect it to.
    RemoveDirectory(lpSource);

    return TRUE;
}


//  CUnpacker::DeleteDirectory
//      Called in case we need to nuke the temp directory before
//      we've had a chance to move it to the real place

void
CUnpacker::DeleteDirectory(
    LPCTSTR lpDir
    )
{
    HANDLE hfind;
    WIN32_FIND_DATA find;
    TCHAR szPath[MAX_PATH];

    // Create the find path with a \*.* for the search
    strcpy(szPath, lpDir);
    ::AppendSlash(szPath);
    strcat(szPath, "*.*");

    // Loop through all the files deleting them
    if ((hfind = FindFirstFile(szPath, &find)) != INVALID_HANDLE_VALUE)
    {
        do
        {
            // Skip . and ..
            if (find.cFileName[0] == '.')
                continue;

            // Skip any directories we might find
            if (find.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                DebugPrint("Directory found in uninstall dir! temp directory won't get deleted...\n");
                continue;
            }

            strcpy(szPath, lpDir);
            ::AppendSlash(szPath);
            strcat(szPath, find.cFileName);
            DeleteFile(szPath);
        }
        while (FindNextFile(hfind, &find));
        FindClose(hfind);
    }

    // Nuke the directory
    if (!RemoveDirectory(lpDir))
    {
        DebugPrint("Error removing temp directory (error=%08x)\n", GetLastError());
    }
}


//  CUnpacker::AddCommas
//      Adds commas in the disk size numbers

LPCTSTR
CUnpacker::AddCommas(
    __int64 li
    )
{
    static TCHAR sz[32];
    LPTSTR lp;
    DWORD i = 0;

    // Initialize and check for special case of zero
    sz[31] = 0;
    lp = &sz[30];
    if (li == 0)
    {
        *lp = '0';
        return lp;
    }

    // Loop until there are no more digits, adding digits and commas
    while (li)
    {
        *lp-- = (TCHAR)(UCHAR)(li % 10) + '0';
        li /= 10;
        if (++i == 3 && li != 0)
        {
            *lp-- = ',';
            i = 0;
        }
    }

    return lp + 1;
}


//  CUnpacker::CopyFiles
//      Called on a separate thread and copies all the files.

DWORD WINAPI
ThreadStart(
    CUnpacker* punpacker
    )
{
    // Initialize COM
    CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);

    DWORD dwRet = punpacker->CopyFiles();;
    CoUninitialize();
    return dwRet;
}

DWORD
CUnpacker::CopyFiles()
{
    CCab cabFiles(&m_settings, &m_dirs, &m_uninstall, this);

    // Initialize the file cab
    if (!cabFiles.Init())
    {
        PostCopyError(IDS_CORRUPT_INSTALLER, 1018);
        return -1;
    }

    // Copy all the files from the cab and other manifest-driven work
    // It's odd to be driving this through the cab object, but is done
    // because how FDI works: it makes you get called back once for each
    // file in the cab.
    // Note that the zero parameter is the zero-based index into the list
    // of files appended to the EXE. The file cab is the first file
    if (!cabFiles.ProcessWithManifest(&m_manifest, 0))
        return -1;      // We've already told the UI to skip to the error page

    // Update Version info in the registry
    WriteInstallInfo();

    // Do the custom stuff that's to be done after the copying is complete
    if(m_spCustom)
        m_spCustom->AfterCopy();

    // Write the uninstall information
    m_uninstall.Flush();

    // Since we're done and the thread is going to exit, tell the UI
    PostMessage(m_hwndDlg, WMP_COPYCOMPLETE, 0, 0);

    return 0;
}



//  CUnpacker::PostError
//      Tells the copying wizard page about a fatal error.

VOID
CUnpacker::PostCopyError(
    DWORD dwID,
    DWORD dwErrorCode
    )
{
    PostMessage(m_hwndDlg, WMP_ERROR, dwID, dwErrorCode);
}


//  CUnpacker::AccumulateFileSizes
//      Walks the manifest and adds in the size for each file already on the
//      disk into the manifest. Also accumulates the total size needed for
//      all files into the directory structure.

BOOL
CUnpacker::AccumulateFileSizes()
{
    LPSTR lp;
    LPSTR lpCommand;
    DWORD dwc;
    HANDLE hfile;
    LPTARGETDIR lpTarget;
    CFileInfo fi;
    LPSTR lpDest;
    LPSTR lpRoot;
    DWORD i;

    // Initialize the manifest
    TCHAR szPath[MAX_PATH];
    strcpy(szPath, m_szUninstallDir);
    strcat(szPath, SCAB_MANIFEST);
    if (!m_manifest.SetFile(szPath))
    {
        DebugPrint("Manifest.SetFile() failed.\n");
        GetUnpacker()->PostCopyError(IDS_CORRUPT_INSTALLER, 1019);
        return FALSE;
    }
    m_manifest.ResetPointer();
    m_dwcManifestLines = 0;

    // Make sure all the targets are initially zeroed
    lpTarget = m_dirs.AllTargets(&dwc);
    for (i = 0 ; i < dwc ; ++i, ++lpTarget)
    {
        lpTarget->dwDiskSpaceUsed = 0;
        lpTarget->dwDiskSpaceNeeded = 0;
    }

    // Walk through all lines in the manifest accumulating sizes
    do
    {
        // Get the line
        lp = m_manifest.GetLine();
        ++m_dwcManifestLines;

        // Skip the langIDs
        ::ZapComma(lp);

        // Get the command. We're only interested in 'file' or 'copy' commands
        lpCommand = lp;
        ::ZapComma(lp);
        if (_stricmp(lpCommand, "file") == 0)
        {
            // Parse the line
            PARSEFILE pf;
            ::ParseLine(lp, (LPSTR*)&pf, PARSEFILE_DWORDS, NULL);
            lpDest = pf.lpDest;
            lpRoot = pf.lpRoot;

            // Compute the size needed by the uncompressed file from the
            // file info in the manifest
            fi.Load(pf.lpFileInfo);
        }
        else if (_stricmp(lpCommand, "copy") == 0)
        {
            PARSECOPY pc;
            ::ParseLine(lp, (LPSTR*)&pc, PARSECOPY_DWORDS, NULL);
            lpDest = pc.lpDest;
            lpRoot = pc.lpRoot;

            // Compute the size needed by the uncompressed file from the
            // file info in the manifest
            fi.Load(pc.lpFileInfo);
        }

        // Not 'file' or 'copy,' skip
        else
            continue;

        // If we didn't find a target, the file is bogus
        lpTarget = m_dirs.FindTarget(lpRoot);
        if (lpTarget == NULL)
        {
            SetLastError(IDS_CORRUPT_INSTALLER, 1021);
            return FALSE;
        }

        strcpy(szPath, lpTarget->szPath);
        ::AppendSlash(szPath);
        strcat(szPath, lpDest);

        // Get the file size if it exists
        hfile = CreateFile(szPath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL, OPEN_EXISTING, 0, NULL);
        if (hfile != INVALID_HANDLE_VALUE)
        {
            dwc = GetFileSize(hfile, NULL);
            CloseHandle(hfile);

            lpTarget->dwDiskSpaceUsed += ::DWORDtoDiskSpace(dwc);
        }
        lpTarget->dwDiskSpaceNeeded += ::DWORDtoDiskSpace(fi.GetSize());
    }
    while (!m_manifest.SkipToNextLine());

    return TRUE;
}


//  CUnpacker::CheckAvailableSpace
//      Checks all drives we're going to copy onto to see if they have
//      enough space.

int
CUnpacker::CheckAvailableSpace()
{
    DWORD i;
    DWORD j;
    int nDrives[26] = { 0 };
    static char szDrivePath[] = "x:";
    ULARGE_INTEGER liFree;
    ULARGE_INTEGER liTotal;
    ULARGE_INTEGER liNeeded;
    LPTARGETDIR lpTarget;
    DWORD dwc;

    // Walk through each dir and add into a drive map
    lpTarget = m_dirs.AllTargets(&dwc);
    for (i = 0 ; i < dwc ; ++i, ++lpTarget)
    {
        j = lpTarget->szPath[0] | 32;
        if (j >= 'a' && j <= 'z')
        {
            nDrives[j - 'a'] += (int)lpTarget->dwDiskSpaceNeeded -
                (int)lpTarget->dwDiskSpaceUsed;
        }
    }

    // Get the drive letter for the default directory
    DWORD dwDefault;
    dwDefault = m_szDefaultDir[0] | 32;
    if (dwDefault >= 'a' && dwDefault <= 'z')
        dwDefault -= 'a';
    else
        dwDefault = 0xffffffff;

    // Now walk through all the drives to see if there is enough space
    for (i = 0 ; i < 26 ; ++i)
    {
        if (nDrives[i] > 0)
        {
            szDrivePath[0] = (char)(i + 'A');
            GetDiskFreeSpaceEx(szDrivePath, &liFree, &liTotal, NULL);
            liNeeded.QuadPart = ((__int64)nDrives[i]) << 15;
            if (liNeeded.QuadPart > liFree.QuadPart)
            {
                char szMessage1[MAX_PATH];
                char szMessage2[MAX_PATH];
                char szMessage3[MAX_PATH];
                char szMessage[3 * MAX_PATH];

                // Get the localized part
                LoadString(GetInstanceHandle(), IDS_NOT_ENOUGH_SPACE_ON, szMessage1, MAX_PATH);
                sprintf(szMessage2, szMessage1, szDrivePath);
                LoadString(GetInstanceHandle(), IDS_SPACE_REQUIRED, szMessage1, MAX_PATH);
                sprintf(szMessage3, szMessage1, AddCommas(liNeeded.QuadPart));
                LoadString(GetInstanceHandle(), IDS_SPACE_AVAILABLE, szMessage, MAX_PATH);
                sprintf(szMessage1, szMessage, AddCommas(liFree.QuadPart));

                // Merge the numbers in
                sprintf(szMessage, "%s\n\n%s\n\n%s", szMessage2, szMessage3, szMessage1);
                SetLastErrorString(szMessage, 1008);

                // Return 1 (try again with default dir) if it's on the default drive.
                // Otherwise, return -1 which means they can't correct it.
                if (i == dwDefault)
                    return 1;
                else
                    return -1;
            }
        }
    }

    return 0;
}

typedef BOOL (*LPGETVERSIONEX)(OSVERSIONINFOEX*);
//
//  Check for a compatible version of Windows.  Currently,
//  this checks for Windows 2000.  This really should read
//  the required Windows version from the settings file.
//
BOOL
CUnpacker::CheckWindows()
{
    OSVERSIONINFOEX ver;
    LPGETVERSIONEX lpGetVersionEx;
    HMODULE hlib;

    // Get the extended version info function
    hlib = LoadLibrary("kernel32.dll");
    lpGetVersionEx = (LPGETVERSIONEX)GetProcAddress(hlib, _TEXT("GetVersionExA"));
    FreeLibrary(hlib);
    if (lpGetVersionEx == NULL)
    {
        SetLastError(IDS_ERRORNOTWINDOWS2000, 2008);
        return FALSE;
    }

    // Get the version information
    ver.dwOSVersionInfoSize = sizeof (OSVERSIONINFOEX);
    if (!(*lpGetVersionEx)(&ver))
    {
        SetLastError(IDS_ERRORNOTWINDOWS2000, 2009);
        return FALSE;
    }

    // Compare the version information to what we require (Windows 2000 SP1)
    if (ver.dwMajorVersion < 5)
    {
        SetLastError(IDS_ERRORNOTWINDOWS2000, 2010);
        return FALSE;
    }

#if 0 // No service pack check
    if (ver.wServicePackMajor < 1)
    {
        SetLastError(IDS_ERRORNOTSP1, 2011);
        return FALSE;
    }
#endif

    return TRUE;
}


//  VersionWORDsToQWORD
//      Converts version values as WORD components into a single QWORD

__int64
VersionWORDsToQWORD(
    WORD w1,
    WORD w2,
    WORD w3,
    WORD w4
    )
{
    return (__int64)w4 +
           (__int64)w3 * 65536 +
           (__int64)w2 * 65536 * 65536 +
           (__int64)w1 * 65536 * 65536 * 65536;
}


//  VersionStringToQWORD
//      Converts a version written out as a string as a QWORD for comparisons

__int64
VersionStringToQWORD(
    LPSTR lpVersion
    )
{
    LPSTR lp[4];
    __int64 i64Out;

    // Split the line into components
    LPSTR lpCopy = _strdup(lpVersion);
    LPSTR lpT = lpCopy;
    if (!ParseLine(lpT, lp, 4, NULL))
        return 0;

    i64Out = VersionWORDsToQWORD((WORD)atoi(lp[0]), (WORD)atoi(lp[1]), (WORD)atoi(lp[2]), (WORD)atoi(lp[3]));
    free(lpCopy);
    return i64Out;
}


//  CheckUpgradeVersion
//      Routine to check the existing version in upgrade scenarious.
//      This feature is designed for QFE's.  QFE's perform an upgrade
//      by replacing only select files (and perhaps registry keys), it
//      important to ensure that a compatible version of the product is
//      already installed.  Set MinVersionAllowed in the settings file
//      to invoke this feature.
BOOL
CUnpacker::CheckUpgradeVersion()
{

    LPSTR lpMinInstallVersion;

    // Get the registry path for the upgrade key for product

    //  Legacy:  Make sure the new full build version is written if not
    //           read the old format and write back out in the new format.
    TCHAR szBuild[MAX_PATH];
    szBuild[0] = 0;
    if (!GetRegistryString(szBuild, MAX_PATH, m_ProductRegKey.hRootKey, m_ProductRegKey.lpSubkey, XSETUP_FULL_BUILD_REGVALUE))
    {
        // Get the old one (just the build number)
        if (GetRegistryString(szBuild, MAX_PATH, m_ProductRegKey.hRootKey, m_ProductRegKey.lpSubkey, XSETUP_BUILD_REGVALUE))
        {
            // Write out the new string
            TCHAR szNewBuild[MAX_PATH];
            CreateVersionString(szNewBuild, 1, 0, (WORD)atoi(szBuild), 1);
            WriteRegistryString(m_ProductRegKey.hRootKey, m_ProductRegKey.lpSubkey, XSETUP_FULL_BUILD_REGVALUE, szNewBuild);
        }
    }

    // Make sure we aren't overwriting a newer build. Note that this flag
    // allows the end user to override the build check and overwrite the version with
    // an older version. Bad stuff could happen...
    if (!(GetFlags() & UNPACKER_FLAGS_FORCEINSTALL))
    {
        __int64 i64Installed = 0;
        __int64 i64TryingToInstall = VersionWORDsToQWORD(VER_PRODUCTVERSION); // Note that this contains 4 parameters

        // Get the current version number installed
        if (GetRegistryString(szBuild, MAX_PATH, m_ProductRegKey.hRootKey, m_ProductRegKey.lpSubkey, XSETUP_FULL_BUILD_REGVALUE))
        {
            i64Installed = VersionStringToQWORD(szBuild);
            if (i64Installed > i64TryingToInstall)
            {
                SetLastError(IDS_ERRORINSTALLOVERNEWER, 2012);
                return FALSE;
            }
        }

        // If the setup package has a setting that specifies a lower bound to install over,
        // check it here

        // Read the MinVersionAllowed setting.
        lpMinInstallVersion = GetSetting(CSTR_MINVERSIONALLOWED);
        if (*lpMinInstallVersion)
        {
            // Less than the min bound?
            __int64 i64MinBound = VersionStringToQWORD(lpMinInstallVersion);
            if (i64Installed < i64MinBound)
            {
                TCHAR szBuildWarning[MAX_PATH];
                TCHAR szCurrent[MAX_PATH];
                TCHAR szCurrentOutput[MAX_PATH];
                TCHAR szErrorOutput[MAX_PATH * 2];

                // Get the first part of the string warning them
                LoadString(::GetInstanceHandle(), IDS_ERRORINCORRECTBUILD, szBuildWarning, sizeof (szBuildWarning));
                sprintf(szErrorOutput, szBuildWarning, lpMinInstallVersion);

                // Build the second part of the string: depends on the version they have installed already
                if (i64Installed == 0)
                {
                    LoadString(::GetInstanceHandle(), IDS_ERRORNOBUILDINSTALLED, szCurrentOutput, sizeof (szCurrentOutput));
                }
                else
                {
                    LoadString(::GetInstanceHandle(), IDS_ERRORCURRENTBUILD, szCurrent, sizeof (szCurrent));
                    sprintf(szCurrentOutput, szCurrent, szBuild);
                }

                // Finally, concatenate the two and display the error message
                strcat(szErrorOutput, szCurrentOutput);
                SetLastErrorString(szErrorOutput, 2014);
                free(lpMinInstallVersion);
                return FALSE;
            }
        }
        free(lpMinInstallVersion);
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\unpacker\resource.h ===
// Microsoft Visual C++ generated include file.
// Used by unpacker.rc
//
#include <rsccommon.h>

#define IDI_XBOX                        101
#define IDB_XHEADER                     201
#define IDB_XWATERMARK                  202
#define IDD_WELCOME                     300
#define IDD_LICENSE                     301
#define IDD_SELECTDIR                   302
#define IDD_COPYING                     303
#define IDD_FINISH                      304
#define IDD_WIZERROR                    305
#define IDS_ERRORTITLE                  401
#define IDS_ERRORSUBTITLE               402
#define IDS_LICENSETITLE                403
#define IDS_LICENSESUBTITLE             404
#define IDS_SELDIRTITLE                 405
#define IDS_SELDIRSUBTITLE              406
#define IDS_FOLDERTEXT                  407
#define IDS_COPYINGTITLE                408
#define IDS_COPYINGSUBTITLE             409
#define IDC_TITLE_STATIC                501
#define IDC_PRODUCT_DESC_TEXT           502
#define IDC_INSTALL_SIZE_TEXT           503
#define IDC_STATIC_TEXT                 504
#define IDC_LICENSEEDIT                 505
#define IDC_LICENSE_INSTRUCT            506
#define IDC_INSTALL_TEXT                507
#define IDC_DIRBROWSE                   508
#define IDC_DIREDIT                     509
#define IDC_PROGRESS_BAR                510
#define IDC_INPROGRESSTEXT              511
#define IDC_ACTIONTEXT                  512
#define IDC_ERROR_CODE                  513
#define IDC_PROGRESS                    514
#define IDC_FINISH_TEXT                 515
#define IDD_OVERWRITE                   601
#define IDC_TEXT_FILENAME               602
#define IDC_YESTOALL                    603
#define IDC_NOTOALL                     604
#define IDC_OVERWRITE_TEXT              605
#define IDS_WIZARD_TITLE                651
#define IDS_SPACE_REQUIRED              652
#define IDS_SPACE_AVAILABLE             653
#define IDS_REBOOT_NOW                  654
#define IDS_REBOOT_LATER                655
#define IDS_REBOOT_REQUIRED             656
#define IDS_MB_USAGE                    701
#define IDS_ERRORTWOINSTALLERS          702
#define IDS_ERRORNOTADMINISTRATOR       703
#define IDS_ERRORNOTWINDOWS2000         704
#define IDS_ERRORINSTALLOVERNEWER       705
#define IDS_ERRORINCORRECTBUILD         706
#define IDS_ERRORNOBUILDINSTALLED       707
#define IDS_ERRORCURRENTBUILD           708
#define IDS_JAPANESENOTAVAILABLE        709
#define IDS_UNPACKERNOTPACKED           710
#define IDS_CORRUPT_INSTALLER           711
#define IDS_NOT_ENOUGH_SPACE_ON         712
#define IDS_CANT_SHARE_DIRECTORY        713

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\unpacker\wiz.h ===
//  WIZ.H
//
//  Created 27-Mar-2001 [JonT]

#ifndef _WIZ_H_
#define _WIZ_H_

//---------------------------------------------------------------------

class CWizard
{
private:
    static CWizard* m_spThis;

    HWND m_hwndPropSheet;
    BOOL m_fCentered;
	int m_nReturn;

public:
    CWizard();
    ~CWizard();

    static CWizard* GetWizard();
    static BOOL ActivateCurrentDlg();

    int DoModal(HWND hwndParent);
    VOID SetPropSheetHwnd(HWND hwnd);
    HWND GetPropSheetHwnd();
    BOOL TestAndSetCentered();
	VOID SetReturnValue(int nRet) { m_nReturn = nRet; }
};

inline 
CWizard::CWizard() :
    m_hwndPropSheet(NULL),
    m_fCentered(FALSE)
{
    ASSERT(m_spThis == NULL);
    m_spThis = this;
}

inline
CWizard::~CWizard()
{
    m_spThis = NULL;
}

inline CWizard*
CWizard::GetWizard()
{
    return m_spThis;
}

inline BOOL CWizard::ActivateCurrentDlg()
{
    BOOL bRet = FALSE;
    if (NULL != m_spThis)
    {
        ASSERT(::IsWindow(m_spThis->m_hwndPropSheet));
        ::SetForegroundWindow(m_spThis->m_hwndPropSheet);
        bRet = TRUE;
    }
    return bRet;
}

// The OnInit() of the first wizard page should call this method.
inline VOID 
CWizard::SetPropSheetHwnd(HWND hwnd)
{
    m_hwndPropSheet = hwnd;
}


inline HWND
CWizard::GetPropSheetHwnd()
{
    return (m_hwndPropSheet);
}

inline BOOL
CWizard::TestAndSetCentered()
{
    BOOL fRet = m_fCentered;

    m_fCentered = TRUE;

    return fRet;
}


#endif // #ifndef _WIZ_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\unpacker\wiz.cpp ===
//  WIZ.CPP
//
//  Created 16-Mar-2001 [JonT]

#include "unpacker.h"

// The CWizard singleton instance.
    CWizard* CWizard::m_spThis = NULL; 

//---------------------------------------------------------------------
//  CWizard methods

int
CWizard::DoModal(
    HWND hwndParent
    )
{
    HRESULT hr;
    PROPSHEETPAGE psp[MAX_WIZARD_PAGES];
    PROPSHEETHEADER psh;

    CWizardWelcome AddPageWelcome(this, &psp[0]);
    CWizardError AddPageError(this, &psp[1]);
    CWizardLicense AddPageLicense(this, &psp[2]);
    CWizardSelectDir AddPageSelectDir(this, &psp[3]);
    CWizardCopying AddPageCopying(this, &psp[4]);
    CWizardFinish AddPageFinish(this, &psp[5]);

    ZeroMemory(&psh, sizeof (psh));
    psh.dwSize = sizeof (PROPSHEETHEADER);
    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_WIZARD97 | PSH_NOAPPLYNOW |
        PSH_WATERMARK | PSH_HEADER | PSH_USEICONID;
    psh.hwndParent = hwndParent;
    psh.hInstance = ::GetInstanceHandle();
    psh.pszIcon = MAKEINTRESOURCE(IDI_XBOX);
    psh.pszCaption = MAKEINTRESOURCE(IDS_WIZARD_TITLE);
    psh.nPages = MAX_WIZARD_PAGES;
    psh.pszbmWatermark = MAKEINTRESOURCE(IDB_XWATERMARK);
    psh.pszbmHeader = MAKEINTRESOURCE(IDB_XHEADER);
    psh.nStartPage = 0;
    psh.ppsp = psp;

    m_fCentered = FALSE;

	// Assume not finished yet
	m_nReturn = -1;

    ::PropertySheet(&psh);

	return m_nReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\unpacker\uninstall.cpp ===
//  UNINSTALL.CPP
//
//  Created 1-Apr-2001 [JonT]

#include "unpacker.h"
#include <stdlib.h>
#include <stdio.h>
#include <io.h>
#include <fcntl.h>
#include <search.h>

// Prototype for compare function used in qsort and bsearch
    int __cdecl CompareFunc(const void* e1, const void* e2);

//---------------------------------------------------------------------

BOOL
CUninstall::Init(
    DWORD dwcManifest,
    LPSTR lpUninstallDir
    )
{
    // One shot object: we can create just one uninstall object
    if (m_lpFile)
        return FALSE;

    m_dwcOldLines = ReadOldUninstallFile(lpUninstallDir);
    m_dwcMaxLines = dwcManifest + m_dwcOldLines + 10; // Leave room for some extra commands
    m_dwcTotalLines = 0;

    // Allocate the line table
    m_ptrtable = (LPSTR*)malloc(m_dwcMaxLines * sizeof (LPSTR*));
    ZeroMemory(m_ptrtable, m_dwcMaxLines * sizeof (LPSTR*));

    // If there were no old lines, we're done
    if (m_dwcOldLines == 0)
        return TRUE;

    // Walk through all the old lines pointing the line table at them
    // File line format is:
    // f,fully-qualified filename,ascii-encoded CFileInfo
    // Registry line format is:
    // r,root key,subkey,valuename
    // The part we search on is the filename for files and the root,subkey,vname for regkeys
    LPSTR lp = m_lpFile;
    LPSTR lpValues[3];
    do
    {
        // File lines
        if (*lp == 'f' || *lp == 'o')
        {
            ::ParseLine(lp, lpValues, 3, NULL);
            m_ptrtable[m_dwcTotalLines++] = lpValues[1];
        }
        
        // Registry lines or directory lines
        else if (*lp == 'r' || *lp == 'd')
        {
            // Zap the first comma and the end of the line
            ::ParseLine(lp, lpValues, 1, NULL);

            // Depend on the fact that the command is just one char long
            m_ptrtable[m_dwcTotalLines++] = lpValues[0] + 2;
        }
    }
    while (!::SkipRestOfLine(lp));

    // Sort the file
    m_dwcOldLines = m_dwcTotalLines;
    qsort(m_ptrtable, m_dwcOldLines, sizeof (LPSTR*), CompareFunc);

    return TRUE;
}


//  CUninstall::AddFile
//      Adds uninstall information for a file

VOID
CUninstall::AddFile(
    LPCSTR lpPath,
    LPCSTR lpFileInfo,
    BOOL fRegister
    )
{
    DWORD dwcLen;
    DWORD dwcLenPath = strlen(lpPath);
    LPSTR lp;
    LPSTR* lpTable;

    // Search for the string in the old lines first
    lpTable = (LPSTR*)bsearch((void*)&lpPath, m_ptrtable, m_dwcOldLines, sizeof  (m_ptrtable),
          (int (__cdecl*)(const void*, const void*))CompareFunc);

    // Get the length of the new entry:
    // one byte for command, zero, length of path, zero, length of fileinfo, zero
    dwcLen = strlen(lpFileInfo) + dwcLenPath + 4;

    // Allocate the string
    lp = (LPSTR)malloc(dwcLen);

    // Copy the information in
    if (fRegister)
        lp[0] = 'o';
    else
        lp[0] = 'f';
    lp[1] = 0;
    strcpy(&lp[2], lpPath);
    strcpy(&lp[2 + dwcLenPath + 1], lpFileInfo);

    // If we found an entry, use its place in the table rather than
    // creating a new one
    if (lpTable)
        *lpTable = &lp[2];
    else
        m_ptrtable[m_dwcTotalLines++] = &lp[2];
}


//  CUninstall::AddReg
//      Adds uninstall information for a regkey

VOID
CUninstall::AddReg(
    LPCSTR lpRoot,
    LPCSTR lpSubkey,
    LPCSTR lpValueName
    )
{
    DWORD dwcLenPath;
    LPSTR lp;
    LPSTR* lpTable;

    // Put the reg elements into a string so we can search and save them
    char sz[MAX_PATH];
    dwcLenPath = sprintf(sz, "%s,%s,%s", lpRoot, lpSubkey, lpValueName);
    lp = sz;

    // Search for the string in the old lines first
    lpTable = (LPSTR*)bsearch((void*)&lp, m_ptrtable, m_dwcOldLines, sizeof  (m_ptrtable),
          (int (__cdecl*)(const void*, const void*))CompareFunc);

    // Allocate the new string
    // one byte for command, zero, length of path, zero
    lp = (LPSTR)malloc(dwcLenPath + 3);

    // Copy the information in
    lp[0] = 'r';
    lp[1] = 0;
    strcpy(&lp[2], sz);

    // If we found an entry, use its place in the table rather than
    // creating a new one
    if (lpTable)
        *lpTable = &lp[2];
    else
        m_ptrtable[m_dwcTotalLines++] = &lp[2];
}


//  CUninstall::AddDir
//      Adds uninstall information for an entire directory

VOID
CUninstall::AddDir(
    LPCSTR lpPath
    )
{
    DWORD dwcLenPath = strlen(lpPath);
    LPSTR lp;
    LPSTR* lpTable;

    // Search for the string in the old lines first
    lpTable = (LPSTR*)bsearch((void*)&lpPath, m_ptrtable, m_dwcOldLines, sizeof  (m_ptrtable), CompareFunc);

    // Allocate the string, save room for the command
    lp = (LPSTR)malloc(dwcLenPath + 3);

    // Copy the information in
    lp[0] = 'd';
    lp[1] = 0;
    strcpy(&lp[2], lpPath);

    // If we found an entry, use its place in the table rather than
    // creating a new one
    if (lpTable)
        *lpTable = &lp[2];
    else
        m_ptrtable[m_dwcTotalLines++] = &lp[2];
}


//  CUninstall::Flush
//      Writes out all the uninstall information

VOID
CUninstall::Flush()
{
    FILE* handle;
    DWORD i;
    LPSTR lpCommand;
    LPSTR lpName;
    LPSTR lpFileInfo;
    HKEY hkey;
    TCHAR szName[MAX_PATH];
    DWORD dw;
    TCHAR s_szUninstallKey[] = "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\";

    // Write the regkey so the uninstaller gets launched
    // Create the key
    lpName = GetSettings()->GetSetting(CSTR_DEFAULTDIRTEXT);
    strcpy(szName, s_szUninstallKey);
    strcat(szName, lpName);
    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, szName, 0, NULL, 0, KEY_ALL_ACCESS,
                       NULL, &hkey, &dw) != ERROR_SUCCESS)
    {
        DebugPrint("Couldn't create reg key\n");
        return;
    }

    // Write an uninstall entry so it goes away when we're done
    AddReg("HKLM", szName, "");

    // Write the display name
    RegSetValueEx(hkey, "DisplayName", 0, REG_SZ, (BYTE*)lpName, strlen(lpName) + 1);
    free(lpName);

    // Move the uninstaller EXE to somewhere it can run while we can still
    // delete everything. Use the Windows directory (everyone else does...)
    TCHAR szDest[MAX_PATH];
    GetWindowsDirectory(szDest, MAX_PATH);
    ::AppendSlash(szDest);
    strcat(szDest, SCAB_UNINSTALLER);
    strcpy(szName, GetUnpacker()->GetUninstallDir());
    ::AppendSlash(szName);
    strcat(szName, SCAB_UNINSTALLER);
    if (!MoveFileEx(szName, szDest, MOVEFILE_COPY_ALLOWED | MOVEFILE_REPLACE_EXISTING))
    {
        DebugPrint("uninstaller move failing. Error=%d\n", GetLastError());
    }

    // Write the regkey pointing to the uninstaller and icon
    RegSetValueEx(hkey, "DisplayIcon", 0, REG_SZ, (BYTE*)szDest, strlen(szDest) + 1);
    strcat(szDest, " \"");
    strcat(szDest, GetUnpacker()->GetDefaultDir());
    strcat(szDest, "\" \"");
    strcat(szDest, CUnpacker::GetProductName());
    strcat(szDest, "\"");
    RegSetValueEx(hkey, "UninstallString", 0, REG_SZ, (BYTE*)szDest, strlen(szDest) + 1);

    // Create the new uninstall file
    handle = fopen(m_szUninstallFile, "w");
    if (handle == NULL)
    {
        DebugPrint("Couldn't create uninstall file %s\n", m_szUninstallFile);
        return;
    }

    // Loop through all items in the table
    for (i = 0 ; i < m_dwcTotalLines ; ++i)
    {
        lpName = m_ptrtable[i];
        lpCommand = lpName - 2;
        if (*lpCommand == 'f' || *lpCommand == 'o')
        {
            lpFileInfo = lpName + strlen(lpName) + 1;
            fprintf(handle, "%s,%s,%s\n", lpCommand, lpName, lpFileInfo);
        }
        else if (*lpCommand == 'r' || *lpCommand == 'd')
        {
            fprintf(handle, "%s,%s\n", lpCommand, lpName);
        }
    }

    // We're done with the file
    fclose(handle);
}


//---------------------------------------------------------------------
// Private routines

//  CUninstall::ReadOldUninstallFile
//      Reads the uninstall file left by the previous install if any.
//      Returns the number of lines in the uninstall file read.

DWORD
CUninstall::ReadOldUninstallFile(
    LPSTR lpUninstallDir
    )
{
    HANDLE hfile;
    DWORD dwLen;
    DWORD dwActuallyRead;

    // Get the uninstall filename
    strcpy(m_szUninstallFile, lpUninstallDir);
    ::AppendSlash(m_szUninstallFile);
    strcat(m_szUninstallFile, SCAB_UNINSTALLFILE);

    // Try to open the file
    hfile = CreateFile(m_szUninstallFile, GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
        FILE_FLAG_SEQUENTIAL_SCAN, NULL);
    if (hfile == INVALID_HANDLE_VALUE)
        return 0;

    // Read the entire file
    dwLen = GetFileSize(hfile, NULL);
    if (dwLen == 0xffffffff)
        return 0;

    // Allocate a buffer big enough for the whole file
    m_lpFile = (LPSTR)malloc(dwLen + 1);
    if (!m_lpFile)
        return 0;

    // Read it completely and zero-terminate
    if (!ReadFile(hfile, m_lpFile, dwLen, &dwActuallyRead, NULL) ||
        dwActuallyRead != dwLen)
        return FALSE;
    *(m_lpFile + dwLen) = 0;

    // Close file, we're done with it
    CloseHandle(hfile);

    // Count the number of lines in it
    LPSTR lp = m_lpFile;
    DWORD dwcLines = 0;
    
    // Loop through all the lines in the file couting the lines
    do
    {
        ++dwcLines;
    }
    while (!::SkipRestOfLine(lp));

    return dwcLines;
}


//  CompareFunc
//      Compare function for qsort and bsearch.
//      Looks up the compare string given the string table pointer

int __cdecl
CompareFunc(
    const void* e1,
    const void* e2
    )
{
    return _stricmp(*(LPSTR*)e1, *(LPSTR*)e2);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\unpacker\wizpage.cpp ===
//  WIZPAGE.CPP
//
//  Created 18-Mar-2001 [JonT]

#include "unpacker.h"

//---------------------------------------------------------------------
//  CWizardPage methods

CWizardPage::CWizardPage(
    CWizard* pWizard,
    PROPSHEETPAGE* pPSP,
    UINT uPageID,
    DLGPROC pfnDlgProc,
    PUINT puResult
    )
: m_hwnd(NULL), 
  m_pWizard(pWizard)
{
    GetPageByID(pPSP, uPageID, pfnDlgProc);

    // Set up the font for the titles on the intro and ending pages
    NONCLIENTMETRICS ncm = {0};
    ncm.cbSize = sizeof (ncm);
    SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);

    // Create the intro/end title font
    LOGFONT TitleLogFont = ncm.lfMessageFont;
    TitleLogFont.lfWeight = FW_BOLD;
    lstrcpy(TitleLogFont.lfFaceName, TEXT("Verdana Bold"));

    HDC hdc = GetDC(NULL); // gets the screen DC
    INT FontSize = 12;
    TitleLogFont.lfHeight = 0 - GetDeviceCaps(hdc, LOGPIXELSY) * FontSize / 72;
    m_hTitleFont = CreateFontIndirect(&TitleLogFont);
    ReleaseDC(NULL, hdc);
}


BOOL CALLBACK 
CWizardPage::DlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    BOOL bMsgHandled = FALSE;

    // WM_INITDIALOG: initialize some stuff then call the OnInit routine
    if (uMsg == WM_INITDIALOG)
    {
        CWizardPage* pDlg = (CWizardPage*) ((PROPSHEETPAGE*)lParam)->lParam;
        ::SetWindowLongA(hDlg, DWL_USER, (LONG)pDlg);
        pDlg->m_hwnd = hDlg;

        // Set the title font.
        if (pDlg->m_hTitleFont)
            ::SendMessage(::GetDlgItem(pDlg->m_hwnd, IDC_TITLE_STATIC), WM_SETFONT,
                          (WPARAM)pDlg->m_hTitleFont, 0);

        pDlg->OnInit();
        return TRUE;
    }

    // Any other message pass on to the OnMessage method
    CWizardPage* pDlg = (CWizardPage*) ::GetWindowLongA(hDlg, DWL_USER);
    if (pDlg != NULL)
        return pDlg->OnMessage(uMsg, wParam, lParam);
    else
        return FALSE;
}


BOOL
CWizardPage::OnMessage(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    RECT rect;
    int x;
    int y;
    HDC hdc;
    HWND hwndParent;

    
    switch (uMsg)
    {
    case WM_SIZE:
        // Only do the centering once. This method ensures that
        if (!m_pWizard->TestAndSetCentered())
        {
            hwndParent = GetParent(m_hwnd);
            GetWindowRect(hwndParent, &rect);
            rect.right -= rect.left;
            rect.bottom -= rect.top;
            hdc = CreateCompatibleDC(NULL);
            x = GetDeviceCaps(hdc, HORZRES) / 2 - rect.right / 2;
            y = GetDeviceCaps(hdc, VERTRES) / 2 - rect.bottom / 2;
            DeleteDC(hdc);
            SetWindowPos(hwndParent, NULL, x, y, 0, 0, SWP_NOSIZE);
        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR*)lParam)->code)
        {
        case PSN_SETACTIVE:
            OnSetActive();
            return TRUE;

        case PSN_QUERYCANCEL:
            return OnQueryCancel();
        
        case PSN_WIZNEXT:
            return OnNext();
        
        case PSN_WIZBACK:
            OnBack();
            return TRUE;

        case PSN_WIZFINISH:
            OnFinish();
            return TRUE;
        }
        break;
    }
    
    return FALSE;
}

BOOL
CWizardPage::OnQueryCancel()
{
    // Check first to see if the cancel button is disabled. If it is, this must be
    // from the close button and we want to ignore it too
    if (!IsWindowEnabled(GetDlgItem(GetParent(m_hwnd), IDCANCEL)))
    {
        SetWindowLong(m_hwnd, DWL_MSGRESULT, TRUE);
        return TRUE;
    }

    // Confirmation messagebox. If yes is returned, allow the cancel.
    // On no, cancel the cancel
    TCHAR szConfirmation[MAX_PATH];
    LoadString(::GetInstanceHandle(), IDS_MBCANCEL, szConfirmation, MAX_PATH);
    if (MessageBox(GetParent(m_hwnd), szConfirmation, CUnpacker::GetProductName(), MB_YESNO) == IDYES)
        SetWindowLong(m_hwnd, DWL_MSGRESULT, FALSE);
    else
        SetWindowLong(m_hwnd, DWL_MSGRESULT, TRUE);
        return TRUE;
}

//  CWizardPage::SetNextPage
//      Sets page to go to next. Note that this works to go back to the same
//      page as well as on back.

VOID
CWizardPage::SetNextPage(
    UINT uPageID
    )
{
    SetWindowLong(m_hwnd, DWL_MSGRESULT, uPageID);
}


// Note: GetPageByID() needs to be virtual since "this" is used.
VOID 
CWizardPage::GetPageByID(
    PROPSHEETPAGE* pPSP,
    UINT uPageID,
    DLGPROC pfnDlgProc
    )
{
    pPSP->dwSize = sizeof (PROPSHEETPAGE);
    pPSP->dwFlags = PSP_DEFAULT;
    pPSP->hInstance = ::GetInstanceHandle();
    pPSP->pszTemplate = MAKEINTRESOURCE(uPageID);
    pPSP->pszIcon = NULL;
    pPSP->pfnDlgProc = pfnDlgProc;
    pPSP->pszTitle = NULL;
    pPSP->lParam = (LPARAM) this;
    pPSP->pfnCallback = NULL;
    pPSP->pcRefParent = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\unpacker\unpackui.h ===
//  UNPACKUI.H
//
//  Created 16-Mar-2001

#ifndef _UNPACKUI_H_
#define _UNPACKUI_H_

#include <commctrl.h>
#include <windowsx.h>
#include <tchar.h>
#include <olectl.h>
#include <prsht.h>
#include <shlobj.h>
#include "resource.h"
#include "wiz.h"
#include "wizpage.h"

//---------------------------------------------------------------------
//  Steps to adding a new wizard page
//  1. Draw the new dialog template
//  2. Add strings for Title and Subtitle if necessary
//  3. Bump up MAX_WIZARD_PAGES
//  4. Create the new wizard page class derived from CWizardPage
//      (don't forget to use the new IDD_ value in calling the CWizardPage constructor)
//  5. Instantiate the page in wiz.cpp in DoModal()

#define MAX_WIZARD_PAGES 6

//---------------------------------------------------------------------

class CWizardWelcome : public CWizardPage
{
private:
    virtual VOID OnInit();
    virtual VOID OnSetActive();
    virtual int OnNext();

public:
    CWizardWelcome(CWizard* pWizard, PROPSHEETPAGE* pPSP);
};


//---------------------------------------------------------------------

class CWizardError : public CWizardPage
{
private:
    virtual VOID OnSetActive();
    virtual VOID OnFinish();

    static DWORD m_idLastError;
    static DWORD m_dwErrorCode;
    static TCHAR m_szLastError[];

public:
    CWizardError(CWizard* pWizard, PROPSHEETPAGE* pPSP);

    friend void WizSetLastError(DWORD dwStringID, DWORD dwErrorCode);
    friend void WizSetLastErrorString(LPCTSTR lpString, DWORD dwErrorCode);
    friend LPCTSTR WizGetLastErrorString();
};


inline void
WizSetLastError(
    DWORD dwStringID,
    DWORD dwErrorCode
    )
{
    CWizardError::m_szLastError[0] = 0;
    CWizardError::m_idLastError = dwStringID;
    CWizardError::m_dwErrorCode = dwErrorCode;
}

inline void
WizSetLastErrorString(
    LPCTSTR lpString,
    DWORD dwErrorCode
    )
{
    strcpy(CWizardError::m_szLastError, lpString);
    CWizardError::m_idLastError = 0;
    CWizardError::m_dwErrorCode = dwErrorCode;
}

inline LPCTSTR
WizGetLastErrorString()
{
    return CWizardError::m_szLastError;
}

//---------------------------------------------------------------------

class CWizardLicense : public CWizardPage
{
private:
    virtual VOID OnSetActive();
    virtual int OnNext();
    virtual VOID OnBack();

    LPSTR m_pszTitle;
    LPSTR m_pszSubtitle;
public:
    CWizardLicense(CWizard* pWizard, PROPSHEETPAGE* pPSP);
    ~CWizardLicense()
    {
        if(m_pszTitle) free(m_pszTitle);
        if(m_pszSubtitle) free(m_pszSubtitle);
    }
};


//---------------------------------------------------------------------

class CWizardSelectDir : public CWizardPage
{
private:
    virtual BOOL OnMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual VOID OnSetActive();
    virtual int OnNext();
    virtual VOID OnBack();

public:
    CWizardSelectDir(CWizard* pWizard, PROPSHEETPAGE* pPSP);
};


//---------------------------------------------------------------------

class CWizardCopying : public CWizardPage
{
private:
    virtual VOID OnSetActive();
    virtual BOOL OnMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);

public:
    CWizardCopying(CWizard* pWizard, PROPSHEETPAGE* pPSP);
};


//---------------------------------------------------------------------

class CWizardFinish : public CWizardPage
{
private:
    virtual VOID OnSetActive();
    virtual VOID OnFinish();
    virtual BOOL OnQueryCancel();

public:
    CWizardFinish(CWizard* pWizard, PROPSHEETPAGE* pPSP);
};


#endif // #ifndef _UNPACKUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\unpacker\unpacker.h ===
//  UNPACKER.H
//
//  Created 13-Mar-2001 [JonT]

#ifndef _UNPACKER_H
#define _UNPACKER_H

#include <stdio.h>
#include <windows.h>
#include <string.h>
#include <stdlib.h>
#include <io.h>
#include <fcntl.h>
#include <sys\stat.h>
#include <malloc.h>
#include <fdi.h>
#include <shellapi.h>
#include <xboxverp.h>

#define UNPACKER
// stuff from common.lib (private\setup\common)
#include "global.h"
#include "settings.h"
#include "parse.h"
#include "fileinfo.h"
#include "helper.h"
#include "langid.h"

//---------------------------------------------------------------------
//  Custom setup routines
//      To ease maintenance, the engine is designed to put all code that
//      might need to be updated per setup instance in custom.h and custom.cpp.
//      The CCustom class is called in a few occasions where intervention would
//      be useful and where things aren't data-driven. Please make every
//      attempt to make specific changes in this file and in the resources.

#include "custom.h"


//---------------------------------------------------------------------
//  Constants for the registr
//
#define XSETUP_BUILD_REGVALUE        _TEXT("Build")
#define XSETUP_FULL_BUILD_REGVALUE   _TEXT("InstalledVersion")
#define XSETUP_INSTALLTIME_REGVALUE  _TEXT("LastInstallDate")
#define XSETUP_INSTALL_REGVALUE      _TEXT("InstallPath")
#define XSETUP_PRODUCT_NAME_REGVALUE _TEXT("ProductName")
#define XDK_OLD_INSTALL_REGVALUE     _TEXT("SDK Doc Path")  //Legacy hack for old InstallShield XDK

//---------------------------------------------------------------------
//  Debug routines

void _DebugPrint(LPCSTR lpszFormat, va_list vararg);

#if DBG == 1
inline void
DebugPrint(
    LPCSTR lpszFormat,
    ...
    )
{
    va_list vararg;
    va_start(vararg, lpszFormat);
    _DebugPrint(lpszFormat, vararg);
    va_end(vararg);
}
#else
inline void
DebugPrint(LPCSTR lpszFormat, ...) { }
#endif

#if DBG == 1
#define ASSERT(f) _ASSERT((f) == 0, __FILE__, __LINE__)
#else
#define ASSERT(f)
#endif

inline void
_ASSERT(
    BOOL f,
    LPCSTR lpFile,
    int nLine
    )
{
    if (f)
    {
        DebugPrint("ASSERT! %s (%d)\n", lpFile, nLine);
        DebugBreak();
    }
}

#define FLAG_FROM_LETTER(x) (1 << ((x) - 'A'))

#define ARRAYSIZE(x) (sizeof(x) / sizeof(x[0]))


//---------------------------------------------------------------------


#include "unpackui.h"

//---------------------------------------------------------------------
//  CManifest class

#define MAX_MANIFEST_LINE       2048

// Standard manifest parsing structures
typedef struct _PARSEFILE
{
    LPSTR lpRoot;
    LPSTR lpDest;
    LPSTR lpFlags;
    LPSTR lpFileInfo;
} PARSEFILE, *LPPARSEFILE;
#define PARSEFILE_DWORDS (sizeof (PARSEFILE) / sizeof (LPSTR))

typedef struct _PARSECOPY
{
    LPSTR lpRoot;
    LPSTR lpSource;
    LPSTR lpDest;
    LPSTR lpFlags;
    LPSTR lpFileInfo;
} PARSECOPY, *LPPARSECOPY;
#define PARSECOPY_DWORDS (sizeof (PARSECOPY) / sizeof (LPSTR))

typedef struct _PARSEDELETE
{
    LPSTR lpRoot;
    LPSTR lpDest;
    LPSTR lpFlags;
} PARSEDELETE, *LPPARSEDELETE;
#define PARSEDELETE_DWORDS (sizeof (PARSEDELETE) / sizeof (LPSTR))

typedef struct _PARSEREG
{
    LPSTR lpRootKey;
    LPSTR lpSubKey;
    LPSTR lpValueName;
    LPSTR lpValue;
    LPSTR lpFlags;
} PARSEREG, *LPPARSEREG;
#define PARSEREG_DWORDS (sizeof (PARSEREG) / sizeof (LPSTR))

typedef struct _PARSESHORTCUT
{
    LPSTR lpRoot;
    LPSTR lpDest;
    LPSTR lpShortcutPath;
    LPSTR lpDescription;
} PARSESHORTCUT, *LPPARSESHORTCUT;
#define PARSESHORTCUT_DWORDS (sizeof (PARSESHORTCUT) / sizeof (LPSTR))

#define MANIFEST_TYPE_FILE          1
#define MANIFEST_TYPE_REMOVE        2
#define MANIFEST_TYPE_REGKEY        3

#define MANIFEST_FLAG_PLACEHOLDER   1

typedef struct _FILEMANIFEST
{
    DWORD dwType;
    LPSTR lpID;
    LPSTR lpFile;
    LPSTR lpFlags;
} FILEMANIFEST, *LPFILEMANIFEST;

class CManifest
{
private:
    LPSTR m_lpData;
    LPSTR m_lpLine;
    DWORD m_cData;
    BOOL m_fEOF;
    char m_szLine[MAX_MANIFEST_LINE + 1];

public:
    CManifest(CSettingsFile* psettings);

    BOOL SetFile(LPCTSTR lpFile);
    BOOL ResetPointer();
    LPSTR GetLine();
    BOOL SkipToNextLine();

    // The rest are obsolete
    // Return the information from a file line in the structure
    void ParseLine(LPFILEMANIFEST lpEntry);

    // Returns TRUE if we're at the end of the manifest
    BOOL IsEOF() { return m_fEOF; }

    // Processes non-file type manifest items like REMOVE and REGKEY
    BOOL ProcessNonFileEntries(LPFILEMANIFEST lpEntry);
};


//---------------------------------------------------------------------
//  CDirectories class

typedef struct _TARGETDIR
{
    LPSTR lpID;
    LPSTR lpCommand;
    LPSTR lpData;
    DWORD dwFlags;
    DWORD dwDiskSpaceUsed;
    DWORD dwDiskSpaceNeeded;
    CHAR szPath[MAX_PATH];
} TARGETDIR, *LPTARGETDIR;

class CDirectories
{
private:
    DWORD m_dwcTargets;
    LPTARGETDIR m_Targets;
    CSettingsFile* m_psettings;

    BOOL Init(DWORD dwcTargets);
    BOOL AddTarget(LPSTR lpID, LPSTR lpCommand);
    BOOL ProcessCommands(LPTARGETDIR lpTarget);
    BOOL FindRegKey(LPTARGETDIR lpTarget);

public:
    CDirectories(CSettingsFile* psettings) { m_psettings = psettings; m_Targets = NULL; }
    ~CDirectories() { if (m_Targets) free(m_Targets); }

    VOID ParseTargetDirs();
    LPTARGETDIR FindTarget(LPCSTR lpID);
    LPTARGETDIR AllTargets(LPDWORD pdwc);
};

inline DWORD
DWORDtoDiskSpace(
    DWORD dw
    )
{
    return (dw >> 15) + 1;
}


//---------------------------------------------------------------------
//  CUninstall

class CUninstall
{
private:
    TCHAR m_szUninstallFile[MAX_PATH];
    LPSTR m_lpFile;
    LPSTR* m_ptrtable;
    DWORD m_dwcOldLines;
    DWORD m_dwcTotalLines;
    DWORD m_dwcMaxLines;
    DWORD ReadOldUninstallFile(LPSTR lpUninstallDir);

public:
    CUninstall();
    BOOL Init(DWORD dwcManifest, LPSTR lpUninstallDir);
    VOID AddFile(LPCSTR lpPath, LPCSTR lpFileInfo, BOOL fRegister);
    VOID AddReg(LPCSTR lpRoot, LPCSTR lpSubkey, LPCSTR lpValueName);
    VOID AddDir(LPCSTR lpPath);
    VOID Flush();
};

inline
CUninstall::CUninstall()
{
    m_lpFile = NULL;
    m_ptrtable = NULL;
}


//---------------------------------------------------------------------
//  CCab class

class CUnpacker;

#define FILEFLAGS_PROMPT        0       // default is to always prompt
#define FILEFLAGS_CLOBBER       FLAG_FROM_LETTER('R') // for Replace Always
#define FILEFLAGS_NEVERCLOBBER  FLAG_FROM_LETTER('K') // for Keep Always
#define FILEFLAGS_NOUNINSTALL   FLAG_FROM_LETTER('U') // for no Uninstall
#define FILEFLAGS_SYSTEMREBOOT  FLAG_FROM_LETTER('S') // for System Reboot required. Needs to be replaced using MoveFileEx with the MOVEFILE_DELAY_UNTIL_REBOOT
                                                      // should be used on codec's and shell extensions.
#define FILEFLAGS_OLEREGISTER   FLAG_FROM_LETTER('O') // for OLE Register (this is REGSVR32)


#define REGLINE_FLAGS_REGSZ     0       // default is REG_SZ
#define REGLINE_FLAGS_DWORD     FLAG_FROM_LETTER('D') // for DWORD

#define REMOVELINE_FLAGS_ONLYONFIRSTRUN FLAG_FROM_LETTER('F') // First run only

typedef struct _EOFSTRUCT
{
    DWORD dwcFiles;
    DWORD dwSignature;
} EOFSTRUCT, *LPEOFSTRUCT;

#define EXE_SIGNATURE 'XOBX'

#define MAX_SETUP_PATH_LENGTH   64

class CCab
{
private:
    HFDI m_hfdi;
    ERF m_erf;
    CDirectories* m_pdirs;
    CManifest* m_pmanifest;
    CUninstall* m_puninstall;
    CSettingsFile* m_psettings;
    CUnpacker* m_punpacker;
    CHAR m_szNoManifestRoot[MAX_PATH];
    CHAR m_szPath[MAX_PATH];
    BOOL m_fEOF;
    DWORD m_dwOverwriteFlags;
    DWORD m_dwcFiles;
    HANDLE m_handle;
    BOOL m_fRegister;
    BOOL m_fDelayUntilReboot;
    CHAR m_szFinalPath[MAX_PATH];

    static BOOL m_fStopCopying;
    static CFileInfo m_fi;

    BOOL ProcessManifestLine(LPSTR lpCommand, LPSTR lpLine);
    BOOL ProcessManifestCopyCommand(LPSTR lpLine);
    BOOL ProcessManifestRemoveCommand(LPSTR lpCommand, LPSTR lpLine);
    BOOL ProcessManifestRegCommand(LPSTR lpCommand, LPSTR lpLine);
    BOOL ProcessManifestShortcut(LPSTR lpLine);
    HRESULT CreateLink(LPCSTR lpszPathObj, LPCSTR lpszPathLink, LPCSTR lpszDesc) ;
    int PrepareFileOverwrite(LPTARGETDIR lpTarget, LPSTR lpRoot, LPSTR lpDest, LPSTR lpFlags, LPSTR lpFileInfo);
    BOOL OnOverwriteMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    VOID NukeDirectory(LPSTR lpdir);
    void SubstitutePathsInString(LPSTR lpszInput, LPSTR lpszOutput);
    LANGID GetUserDefaultUILanguageWithDefault();

public:
    CCab(CSettingsFile* psettings, CDirectories* pdirs, CUninstall* puninstall, CUnpacker* punpacker);
    ~CCab();

    // Prepares for cabfile reading from EXE
    BOOL Init();

    // Closes session so we can reuse object
    void Close();

    // Drive the file copy process. Returns only when entire cabfile has
    // been processed.
    // With manifest means that the callback processes files per the
    // manifest instructions.
    // Without manifest means that the callback just copies files directly as
    // specified in the cabfile
    BOOL ProcessWithManifest(CManifest* pmanifest, DWORD dwFile);
    BOOL ProcessNoManifest(LPCSTR lpRootDirectory, DWORD dwFile);

    // Callback called from FDICopy (called within Process()) for several types
    // of notifications during file copies. This is where the bulk of the
    // file copy work is done.
    // FDINOTIFICATIONTYPE is an int, FDINOTIFICATION is an overloaded structure
    // of items returned on notifications. Contents vary per notification type.
    // definitions of these types is in FDI.H
    INT_PTR Callback(FDINOTIFICATIONTYPE fdint, PFDINOTIFICATION pfdin);

    // Called just before a file is copied, allows us to adjust things
    // and process the manifest per-file
    INT_PTR FileCopyOpen(PFDINOTIFICATION pfdin);

    // Called to close the file. This is the point where we set the dates
    // and match attributes of the original file.
    INT_PTR FileCopyClose(PFDINOTIFICATION pfdin);

    static VOID MakeDirectory(LPCTSTR pszPath);
    static DWORD Attr32FromAttrFAT(WORD attrMSDOS);
    static BOOL AdjustFileTime(INT_PTR hf);

    friend BOOL CALLBACK OverwriteDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    friend VOID StopCopying();
};

inline CCab::CCab(
    CSettingsFile* psettings,
    CDirectories* pdirs,
    CUninstall* puninstall,
    CUnpacker* punpacker
    )
:  m_hfdi(NULL),
   m_pdirs(pdirs),
   m_fEOF(FALSE),
   m_dwOverwriteFlags(0),
   m_puninstall(puninstall),
   m_psettings(psettings),
   m_punpacker(punpacker),
   m_handle(INVALID_HANDLE_VALUE),
   m_fRegister(FALSE),
   m_fDelayUntilReboot(FALSE)

{
//    m_szCabName[0] = 0;
    m_szPath[0] = 0;
}

inline VOID
StopCopying()
{
    CCab::m_fStopCopying = TRUE;
}

BOOL CALLBACK OverwriteDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

//---------------------------------------------------------------------
//  CUnpacker (application) class

#define WMP_ERROR           (WM_USER + 100)
#define WMP_COPYCOMPLETE    (WM_USER + 101)

#define UNPACKER_FLAGS_FORCEINSTALL         1
#define UNPACKER_FLAGS_SKIPPRESETUPCHECKS   2
#define UNPACKER_FLAGS_SETUPHASRUNBEFORE    4
#define UNPACKER_FLAGS_SKIPLICENSEPAGE      8
#define UNPACKER_FLAGS_REBOOT_REQUIRED      0x10

typedef struct _INIREGKEY
{
    LPSTR lpKey;
    LPSTR lpSubkey;
    HKEY  hRootKey;
} INIREGKEY, *LPINIREGKEY;
#define INIREGKEY_DWORDS 2  //The hRootKey is not part of ParseLine

class CUnpacker : public CCustomSite
{
private:
    static CSettingsFile m_settings;
    static CManifest m_manifest;
    static CCustom *m_spCustom;
    static CDirectories m_dirs;
    static CUninstall m_uninstall;
    static BOOL m_sfWizardRunning;
    static CUnpacker* m_spThis;
    static HINSTANCE m_shinst;
    static HINSTANCE m_scustomhinst;

    LPSTR m_lpCommandline;
    TCHAR m_szUninstallDir[MAX_PATH];
    TCHAR m_szDefaultDir[MAX_PATH];
    BOOL m_fTempDir;
    HANDLE m_hthread;
    HWND m_hwndDlg;
    HWND m_hwndProgress;
    HWND m_hwndActionText;
    HWND m_hwndInProgressText;
    DWORD m_dwBytesCopiedSoFar;
    DWORD m_dwcManifestLines;
    DWORD m_dwFlags;
    TCHAR m_szCabSource[MAX_PATH];
    ABC m_abc[256];
    INIREGKEY m_ProductRegKey;
    LPSTR m_lpszProductName;

    BOOL MoveDirectory(LPCTSTR lpSource, LPCTSTR lpDest);
    void DeleteDirectory(LPCTSTR lpDir);
    LPCTSTR AddCommas(__int64 li);
    DWORD CopyFiles();
    BOOL AccumulateFileSizes();
    int CheckAvailableSpace();
    VOID ConvertToEllipses(HWND hwnd, LPSTR lpOut, LPCTSTR lpIn);
    BOOL CheckWindows();
    BOOL CheckUpgradeVersion();
    
public:
    CUnpacker(HINSTANCE hinst, LPSTR lpCommandline);
    ~CUnpacker();

    // Properies that need to be accessed by our 'CAB' file
    CLangID m_SupportedLangs;
    DWORD m_dwDefaultLang;

    BOOL CommandLine(LPSTR lpCmdLine);
    BOOL UnpackSettingsCab();
    BOOL DoPreSetupChecks();
    BOOL CustomDirectory(LPTARGETDIR lpTarget);
    BOOL ProcessDirectories();
    BOOL CheckForOtherProduct(LPSTR lpTarget, LPSTR lpOtherProduct, DWORD cbOtherProduct);
    BOOL ValidateDirectories();
    BOOL MoveSettingsCab();
    int CheckDiskSpace();   // returns -1, 0, 1: see header comment
    VOID StartCopy(HWND hwndDlg, HWND hwndProgress, HWND hwndActionText, HWND hwndInProgressText);
    VOID PostCopyError(DWORD dwMsgID, DWORD dwErrorCode);
    VOID UpdateProgressBar(DWORD dwSize, DWORD dwID, LPCTSTR lpText);
    DWORD AccumulateFlags(LPCSTR lp);
    VOID ProcessLegacySetup();
    VOID WriteInstallInfo();
    VOID PostSetup(int nRet) {if(m_spCustom) m_spCustom->PostSetup(nRet);}

    LPCTSTR GetUninstallDir() { return m_szUninstallDir; }
    HWND GetHWNDDlg() { return m_hwndDlg; }
    CUninstall* GetUninstall() { return &m_uninstall; }
    LPCSTR CUnpacker::GetCabSource() { return CUnpacker::m_szCabSource; }

    friend HINSTANCE GetInstanceHandle();
    friend CSettingsFile* GetSettings();
    friend CUnpacker* GetUnpacker();
    friend DWORD WINAPI ThreadStart(CUnpacker* punpacker);
    friend void SetWizRunningState(BOOL fRunning);

    static LPCSTR GetProductName() { return m_spThis->m_lpszProductName; }

   /* CCustomSite Methods */
    void   SetLastError(DWORD dwStringID, DWORD dwErrorCode);
    void   SetLastErrorString(LPCTSTR lpString,DWORD dwErrorCode);
    LPTSTR GetDefaultDir() { return m_szDefaultDir; }
    DWORD  GetFlags() { return m_dwFlags; }
    VOID   SetFlags(DWORD dwNewFlags) { m_dwFlags |= dwNewFlags; }
    void   AddRegForUninstall(LPCSTR lpRoot, LPCSTR lpSubkey, LPCSTR lpValueName){m_uninstall.AddReg(lpRoot, lpSubkey, lpValueName);}
    LPTSTR GetSetting(DWORD dwKey){return m_settings.GetSetting(dwKey);}
};

inline HINSTANCE
GetInstanceHandle()
{
    return CUnpacker::m_shinst;
}

inline CSettingsFile*
GetSettings()
{
    return &CUnpacker::m_settings;
}

inline CUnpacker*
GetUnpacker()
{
    return CUnpacker::m_spThis;
}

inline void SetWizRunningState(BOOL fRunning)
{
    CUnpacker::m_sfWizardRunning = fRunning;
}


//---------------------------------------------------------------------

#endif // #ifndef _UNPACKER_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\unpacker\wzfinish.cpp ===
//  WZFINISH.CPP
//
//  Created 28-Mar-2001 [JonT]

#include "unpacker.h"

CWizardFinish::CWizardFinish(
    CWizard* pWizard,
    PROPSHEETPAGE* pPSP
    ) : CWizardPage(pWizard, pPSP, IDD_FINISH)
{
    // Override any propsheet settings made by the parent for this specific page
    pPSP->dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_HIDEHEADER;
    pPSP->pszTitle = CUnpacker::GetProductName();
}


VOID
CWizardFinish::OnSetActive()
{
    char szTextBuffer[1024];
    PropSheet_SetWizButtons(::GetParent(m_hwnd), PSWIZB_FINISH);

    //Format the title
    FormatWindowText(GetDlgItem(m_hwnd, IDC_TITLE_STATIC), CUnpacker::GetProductName());

    if(GetUnpacker()->GetFlags()&UNPACKER_FLAGS_REBOOT_REQUIRED)
    {
        //Replace the now complete text, with the reboot required message.    
        FormatWindowText(GetDlgItem(m_hwnd, IDC_FINISH_TEXT), CUnpacker::GetProductName());
        rsprintf(GetInstanceHandle(), szTextBuffer, IDS_REBOOT_REQUIRED, CUnpacker::GetProductName());
        SetWindowText(GetDlgItem(m_hwnd, IDC_FINISH_TEXT), szTextBuffer);
        
        //Change the names on the buttons
        LoadString(GetInstanceHandle(), IDS_REBOOT_NOW, szTextBuffer, sizeof(szTextBuffer));
        PropSheet_SetFinishText(::GetParent(m_hwnd), szTextBuffer);
        LoadString(GetInstanceHandle(), IDS_REBOOT_LATER, szTextBuffer, sizeof(szTextBuffer));
        SetWindowText(GetDlgItem(GetParent(m_hwnd), IDCANCEL), szTextBuffer);
        EnableWindow(GetDlgItem(GetParent(m_hwnd), IDCANCEL), TRUE);
    } else
    {
        // Format the finish text with the product name.
        FormatWindowText(GetDlgItem(m_hwnd, IDC_FINISH_TEXT), CUnpacker::GetProductName());

        // Disable the cancel button
        EnableWindow(GetDlgItem(GetParent(m_hwnd), IDCANCEL), FALSE);
    }
}


VOID
CWizardFinish::OnFinish()
{
    if(GetUnpacker()->GetFlags()&UNPACKER_FLAGS_REBOOT_REQUIRED)
    {
        //Indicate that the user wants to reboot.
        m_pWizard->SetReturnValue(1);
    } else
    {
	    // We're done, set the return value
	    m_pWizard->SetReturnValue(0);
    }
}

BOOL
CWizardFinish::OnQueryCancel()
{
    if(GetUnpacker()->GetFlags()&UNPACKER_FLAGS_REBOOT_REQUIRED)
    {
        m_pWizard->SetReturnValue(0);
        SetWindowLong(m_hwnd, DWL_MSGRESULT, FALSE);
        return TRUE;
    } else
    {
        SetWindowLong(m_hwnd, DWL_MSGRESULT, TRUE);
        return TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\unpacker\wzerror.cpp ===
//  WZERROR.CPP
//
//  Created 27-Mar-2001 [JonT]

#include "unpacker.h"

    TCHAR CWizardError::m_szLastError[1024];
    DWORD CWizardError::m_idLastError;
    DWORD CWizardError::m_dwErrorCode;

CWizardError::CWizardError(
    CWizard* pWizard,
    PROPSHEETPAGE* pPSP
    ) : CWizardPage(pWizard, pPSP, IDD_WIZERROR)
{
    // Override any propsheet settings made by the parent for this specific page
    pPSP->dwFlags =           PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    pPSP->pszHeaderTitle =    MAKEINTRESOURCE(IDS_ERRORTITLE);
    pPSP->pszHeaderSubTitle = MAKEINTRESOURCE(IDS_ERRORSUBTITLE);

    if(pPSP->pszTitle)
    {
        pPSP->dwFlags |= PSP_USETITLE;
        pPSP->pszTitle = CUnpacker::GetProductName();
    }

    // Make sure we don't have any strings
    m_idLastError = 0;
    m_szLastError[0] = 0;
    m_dwErrorCode = 0;
}

VOID
CWizardError::OnSetActive()
{
    TCHAR szErrorText[4096];

    // If there's no error set, display the general one
    if (m_idLastError == 0 && m_szLastError[0] == 0)
        m_idLastError = IDS_ERROR_GENERAL;

    // Display the error message
    if (m_idLastError)
    {
        if(
            (IDS_ERRORNOTWINDOWS2000 == m_idLastError) ||
            (IDS_SETUP_NOT_COMPLETE == m_idLastError) ||
            (IDS_ERRORINSTALLOVERNEWER == m_idLastError)
        ) {
            rsprintf(GetInstanceHandle(), szErrorText, m_idLastError, CUnpacker::GetProductName());
        } else
            LoadString(GetInstanceHandle(), m_idLastError, szErrorText, 4096);
        SetWindowText(GetDlgItem(m_hwnd, IDC_STATIC_TEXT), szErrorText);
    }
    else
        SetWindowText(GetDlgItem(m_hwnd, IDC_STATIC_TEXT), m_szLastError);

    // Set the error code in place
    sprintf(szErrorText, "S%d", m_dwErrorCode);
    SetWindowText(GetDlgItem(m_hwnd, IDC_ERROR_CODE), szErrorText);

    // Enable just the finish button
    PropSheet_SetWizButtons(::GetParent(m_hwnd), PSWIZB_FINISH);

    // Disable the cancel button
    EnableWindow(GetDlgItem(GetParent(m_hwnd), IDCANCEL), FALSE);
}

VOID
CWizardError::OnFinish()
{
    PostQuitMessage(-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\unpacker\wzlicense.cpp ===
//  WZLICENSE.CPP
//
//  Created 27-Mar-2001 [JonT]

#include "unpacker.h"

CWizardLicense::CWizardLicense(
    CWizard* pWizard,
    PROPSHEETPAGE* pPSP
    ) : CWizardPage(pWizard, pPSP, IDD_LICENSE), m_pszTitle(NULL), m_pszSubtitle(NULL)
{
    // Override any propsheet settings made by the parent for this specific page
    pPSP->dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    pPSP->pszTitle = CUnpacker::GetProductName();

    // Read the title and subtitle from the ini file.
    m_pszTitle = GetSettings()->GetString(CSTR_STRINGS, CSTR_LICENSE_TITLE);
    if(*m_pszTitle)
    {
      pPSP->pszHeaderTitle = m_pszTitle;
      m_pszSubtitle = GetSettings()->GetString(CSTR_STRINGS, CSTR_LICENSE_SUBTITLE);
      if(*m_pszSubtitle)
        pPSP->pszHeaderSubTitle = m_pszSubtitle;
    }
    else
    {
      pPSP->pszHeaderTitle = MAKEINTRESOURCE(IDS_LICENSETITLE);
      pPSP->pszHeaderSubTitle = MAKEINTRESOURCE(IDS_LICENSESUBTITLE);
    }
}


VOID
CWizardLicense::OnSetActive()
{
    HANDLE hfile;
    LPVOID lp;
    TCHAR szLicenseFile[MAX_PATH];
    DWORD dwc;
    DWORD dwcActual;
    LPSTR lpLicenseFile = NULL;

    // Get the License File Name (in the CAB) from the INI
    lpLicenseFile = GetSettings()->GetSetting(CSTR_LICENSEFILE);

    // Read the license file
    strcpy(szLicenseFile, ::GetUnpacker()->GetUninstallDir());
    ::AppendSlash(szLicenseFile);
    strcat(szLicenseFile, lpLicenseFile);
    hfile = CreateFile(szLicenseFile, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                       NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
    if (hfile == INVALID_HANDLE_VALUE)
    {
        WizSetLastError(IDS_CORRUPT_INSTALLER, 1019);
        SetNextPage(IDD_WIZERROR);
        return;
    }

    dwc = GetFileSize(hfile, NULL);
    lp = malloc(dwc + 1);
    if (!ReadFile(hfile, lp, dwc, &dwcActual, NULL) || dwc != dwcActual)
    {
        WizSetLastError(IDS_CORRUPT_INSTALLER, 1020);
        SetNextPage(IDD_WIZERROR);
        return;
    }
    *((LPBYTE)lp + dwc) = 0;

    // Put the license text in the edit control
    SetWindowText(GetDlgItem(m_hwnd, IDC_LICENSEEDIT), (LPSTR)lp);

    // Update IDC_LICENSE_INSTRUCT with the string from the ini file.
    LPSTR lpInstructText = GetSettings()->GetString(CSTR_STRINGS, CSTR_LICENSE_INSTRUCT);
    SetWindowText(GetDlgItem(m_hwnd, IDC_LICENSE_INSTRUCT), lpInstructText);
    free(lpInstructText);

    // Clean up
    CloseHandle(hfile);
    free(lp);

    // Set default buttons
    PropSheet_SetWizButtons(::GetParent(m_hwnd), PSWIZB_BACK | PSWIZB_NEXT);
}

BOOL
CWizardLicense::OnNext()
{
    static BOOL s_fBeenHereBefore = FALSE;
    CUnpacker* punpacker = ::GetUnpacker();

    // This is a wizard, we can get moved back into
    if (!s_fBeenHereBefore)
    {
        // Load up all the target directories. If this returns TRUE, we're doing
        // an upgrade and can skip the select directory page
        if (punpacker->ProcessDirectories())
        {
            // Start the upgrade
            //
            // Do a sanity check of directories. If no good, skip to the error page.
            // Note that on the clean install case, this is done at the end of
            // the directory selection page.
            // Any disk space failure is fatal, unlike the clean install case where
            // we can let the user pick a new directory.
            // Once the directories are good, move the tempdir to the uninstall dir.
            if (!punpacker->ValidateDirectories() ||
                punpacker->CheckDiskSpace() != 0 ||
                !punpacker->MoveSettingsCab())
            {
                SetNextPage(IDD_WIZERROR);
            }
            else
            {
                SetNextPage(IDD_COPYING);
            }
        }

        // Don't do it again
        s_fBeenHereBefore = TRUE;
    }
    return TRUE;
}

VOID 
CWizardLicense::OnBack()
{
    SetNextPage(IDD_WELCOME);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\unpacker\wizpage.h ===
//  WIZPAGE.H
//
//  Created 27-Mar-2001 [JonT]

#ifndef _WIZPAGE_H_
#define _WIZPAGE_H_

//---------------------------------------------------------------------

class CWizardPage
{
protected:
    static BOOL CALLBACK DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

    virtual BOOL OnMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual VOID GetPageByID(PROPSHEETPAGE* pPSP, UINT uPageID, DLGPROC pfnDlgProc);
    virtual VOID OnInit() {};
    virtual BOOL OnNext() { return TRUE; };
    virtual BOOL OnQueryCancel();
    virtual VOID OnSetActive() = 0;
    virtual VOID OnBack() {};
    virtual VOID OnFinish() {};
    

    VOID SetNextPage(UINT uPageID);

    CWizard* m_pWizard;
    HWND m_hwnd;
    DWORD m_dwDlgID;
    HFONT m_hTitleFont;
    PUINT m_puResult;

public:
    CWizardPage(CWizard* pWizard, PROPSHEETPAGE* pPSP, UINT uPageID, DLGPROC pfnDlgProc = DlgProc, PUINT puResult = NULL);
    ~CWizardPage();
};



inline
CWizardPage::~CWizardPage()
{
    if (m_hTitleFont)
    {
        DeleteObject(m_hTitleFont);
        m_hTitleFont = NULL;
    }
}

#endif // #ifndef _WIZPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\unpacker\wzcopy.cpp ===
//  WZCOPY.CPP
//
//  Created 28-Mar-2001 [JonT]

#include "unpacker.h"

CWizardCopying::CWizardCopying(
    CWizard* pWizard,
    PROPSHEETPAGE* pPSP
    ) : CWizardPage(pWizard, pPSP, IDD_COPYING)
{
    // Override any propsheet settings made by the parent for this specific page
    pPSP->dwFlags =           PSP_DEFAULT | PSP_USETITLE | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    pPSP->pszHeaderTitle =    MAKEINTRESOURCE(IDS_COPYINGTITLE);
    pPSP->pszHeaderSubTitle = MAKEINTRESOURCE(IDS_COPYINGSUBTITLE);
    pPSP->pszTitle =          CUnpacker::GetProductName();
}

BOOL
CWizardCopying::OnMessage(
    UINT dwMessage,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static DWORD dwProgress = 0;

    switch (dwMessage)
    {
    // Fatal error. Jump to error page
    case WMP_ERROR:
        WizSetLastError(wParam, lParam);
        PropSheet_SetCurSelByID(::GetParent(m_hwnd), IDD_WIZERROR);
        return TRUE;

    case WMP_COPYCOMPLETE:
        PropSheet_PressButton(::GetParent(m_hwnd), PSBTN_NEXT);
        return TRUE;

    case WM_COMMAND:
        if (LOWORD(wParam) == IDCANCEL)
        {
            StopCopying();
        }
        return FALSE;
    }

    return CWizardPage::OnMessage(dwMessage, wParam, lParam);
}

VOID
CWizardCopying::OnSetActive()
{
    //Update the install text to have product name
    FormatWindowText(GetDlgItem(m_hwnd, IDC_INSTALL_TEXT), CUnpacker::GetProductName());

    // No buttons active until we're done
    PropSheet_SetWizButtons(::GetParent(m_hwnd), 0);

    // Including no cancel button
    EnableWindow(GetDlgItem(GetParent(m_hwnd), IDCANCEL), FALSE);

    // Kick off the file copy
    GetUnpacker()->StartCopy(m_hwnd, GetDlgItem(m_hwnd, IDC_PROGRESS_BAR),
        GetDlgItem(m_hwnd, IDC_ACTIONTEXT), GetDlgItem(m_hwnd, IDC_INPROGRESSTEXT));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\unpacker\wzwelc.cpp ===
//  WZWELC.CPP
//
//  Created 16-Mar-2001 [JonT]

#include "unpacker.h"

CWizardWelcome::CWizardWelcome(
    CWizard* pWizard,
    PROPSHEETPAGE* pPSP
    ) : CWizardPage(pWizard, pPSP, IDD_WELCOME)
{
    // Override any propsheet settings made by the parent for this specific page
    pPSP->dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_HIDEHEADER;
    pPSP->pszTitle = CUnpacker::GetProductName();
}


VOID
CWizardWelcome::OnInit()
{
    LPSTR lp;
    
    // This is the first page, and thus responsible for setting the PropSheetHwnd
    m_pWizard->SetPropSheetHwnd(::GetParent(m_hwnd));

    SendMessage(::GetParent(m_hwnd), WM_SETICON, (WPARAM)ICON_BIG,
                (LPARAM)LoadIcon(::GetInstanceHandle(), MAKEINTRESOURCE(IDI_XBOX)));

    // Update the welcome message
    lp = GetSettings()->GetString(CSTR_STRINGS, CSTR_WELCOMEMSG);
    if(lp)
    {
        if(*lp)
            SetWindowText(GetDlgItem(m_hwnd, IDC_TITLE_STATIC), lp);
        free(lp);
    }
    lp = GetSettings()->GetString(CSTR_STRINGS, CSTR_PRODUCTDESC);
    if(lp)
    {
        if(*lp)
            SetWindowText(GetDlgItem(m_hwnd, IDC_PRODUCT_DESC_TEXT), lp);
        free(lp);
    }

    // Update the install size.
    lp = GetSettings()->GetString(CSTR_DIRSIZES, CSTR_TOTALINSTALLSIZE);
    FormatWindowText(GetDlgItem(m_hwnd, IDC_INSTALL_SIZE_TEXT), lp);
    free(lp);

    // Make sure to call the base class init function as well
    CWizardPage::OnInit();
}


VOID
CWizardWelcome::OnSetActive()
{
    PropSheet_SetWizButtons(::GetParent(m_hwnd), PSWIZB_NEXT);
}

BOOL
CWizardWelcome::OnNext()
{
    CUnpacker* punpacker;
    static BOOL s_fBeenHereBefore = FALSE;

    punpacker = ::GetUnpacker();
    
    // This is a wizard so we can get called multiple times. Do this only on the
    // first try!
    if (!s_fBeenHereBefore)
    {
        // Don't do this again
        s_fBeenHereBefore = TRUE;

        // Sort of a hack to handle legacy issues revolving around the
        // old install shield based setup used by the XDK.
        punpacker->ProcessLegacySetup();

        // Do the presetup checks. Note that if these fail, the
        // temp directory is always nuked by the CUnpacker destructor.
        if (!punpacker->DoPreSetupChecks())
        {
            // In either failure case, assume that a string error message
            // was passed to WizSetLastError. Note that we default to the
            // error wizard page
            return TRUE;
        }

        //
        //  Check if we should skip the license page.  If so then we
        //  have to duplicate the things that would be done by the license page's
        //  OnNext.
        //
        LPSTR lpSkipLicensePage = GetSettings()->GetSetting(CSTR_SKIP_LICENSE_PAGE);
        if(lpSkipLicensePage)
        {
            if(toupper(*lpSkipLicensePage)=='Y')
            {
                punpacker->SetFlags(UNPACKER_FLAGS_SKIPLICENSEPAGE);
                // Load up all the target directories. If this returns TRUE, we're doing
                // an upgrade and can skip the select directory page
                if (punpacker->ProcessDirectories())
                {
                    // Start the upgrade
                    //
                    // Do a sanity check of directories. If no good, skip to the error page.
                    // Note that on the clean install case, this is done at the end of
                    // the directory selection page.
                    // Any disk space failure is fatal, unlike the clean install case where
                    // we can let the user pick a new directory.
                    // Once the directories are good, move the tempdir to the uninstall dir.
                    if (!punpacker->ValidateDirectories() ||
                        punpacker->CheckDiskSpace() != 0 ||
                        !punpacker->MoveSettingsCab())
                    {
                        SetNextPage(IDD_WIZERROR);
                    }
                    else
                    {
                        SetNextPage(IDD_COPYING);
                    }
                } else
                {
                    SetNextPage(IDD_SELECTDIR);
                }
                free(lpSkipLicensePage);
                return TRUE;
            }
            free(lpSkipLicensePage);
        }
    }

    // Check for the skip licence page flag.  We could
    // hit this if we have been to the select dir page and back.
    if(UNPACKER_FLAGS_SKIPLICENSEPAGE&punpacker->GetFlags())
    {
        SetNextPage(IDD_SELECTDIR);
    } else
    {
        SetNextPage(IDD_LICENSE);
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\unpacker\wzseldir.cpp ===
//  WZSELDIR.CPP
//
//  Created 28-Mar-2001 [JonT]

#include "unpacker.h"

CWizardSelectDir::CWizardSelectDir(
    CWizard* pWizard,
    PROPSHEETPAGE* pPSP
    ) : CWizardPage(pWizard, pPSP, IDD_SELECTDIR)
{
    // Override any propsheet settings made by the parent for this specific page
    pPSP->dwFlags = PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE | PSP_USETITLE;
    pPSP->pszHeaderTitle = MAKEINTRESOURCE(IDS_SELDIRTITLE);
    pPSP->pszHeaderSubTitle = MAKEINTRESOURCE(IDS_SELDIRSUBTITLE);
    pPSP->pszTitle = CUnpacker::GetProductName();
}


//  BrowseCallbackProc
//      Called from SHBrowseForFolder to validate the paths clicked on there

int CALLBACK
BrowseCallbackProc(
    HWND hwnd, 
    UINT uMsg, 
    LPARAM lParam, 
    LPARAM lpData
    )
{
    // If the selection changes, we have a new item to validate
    if (uMsg == BFFM_SELCHANGED)
    {
        TCHAR szPath[MAX_PATH];

        // Get the new item
        SHGetPathFromIDList((LPITEMIDLIST)lParam, szPath);

        // If it's too long, disable the OK button. If it's not, enable it.
        if (strlen(szPath) >= MAX_SETUP_PATH_LENGTH)
            SendMessage(hwnd, BFFM_ENABLEOK, 0, FALSE); // Disable OK button
        else
            SendMessage(hwnd, BFFM_ENABLEOK, 0, TRUE); // Enable OK button
    }
    return 0;
}


BOOL
CWizardSelectDir::OnMessage(
    UINT dwMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    if (dwMsg == WM_COMMAND && LOWORD(wParam) == IDC_DIRBROWSE)
    {
        BROWSEINFO bi = { 0 };
        LPITEMIDLIST pidl;
        TCHAR szText[MAX_PATH];
        LPMALLOC lpmem;

        LoadString(::GetInstanceHandle(), IDS_FOLDERTEXT, szText, sizeof (szText));

        // Bring up the shell browse for folder dialog
        bi.hwndOwner = m_hwnd;
        bi.lpszTitle = szText;
        bi.ulFlags = BIF_RETURNONLYFSDIRS;
        bi.lpfn = BrowseCallbackProc;
        pidl = SHBrowseForFolder(&bi);
        if (pidl)
        {
            SHGetPathFromIDList(pidl, szText);
            SetWindowText(GetDlgItem(m_hwnd, IDC_DIREDIT), szText);
            SHGetMalloc(&lpmem);
            lpmem->Free(pidl);
            lpmem->Release();
        }
    }

    return CWizardPage::OnMessage(dwMsg, wParam, lParam);
}


VOID
CWizardSelectDir::OnSetActive()
{
    TCHAR szPath[MAX_PATH];
    HWND hwndEdit = GetDlgItem(m_hwnd, IDC_DIREDIT);
    CUnpacker* punpacker = GetUnpacker();

    FormatWindowText(GetDlgItem(m_hwnd, IDC_INSTALL_TEXT), CUnpacker::GetProductName());

    if (*punpacker->GetDefaultDir() == 0)
    {
        SHGetFolderPath(NULL, CSIDL_PROGRAM_FILES, NULL, 0, szPath);
        ::AppendSlash(szPath);
        LPSTR lpDefaultDir = GetSettings()->GetSetting(CSTR_DEFAULTDIRTEXT);
        strcat(szPath, lpDefaultDir);
        free(lpDefaultDir);
    }
    else
        strcpy(szPath, punpacker->GetDefaultDir());

    SendMessage(hwndEdit, EM_LIMITTEXT, (WPARAM)MAX_SETUP_PATH_LENGTH, 0);
    SetWindowText(hwndEdit, szPath);
    PropSheet_SetWizButtons(::GetParent(m_hwnd), PSWIZB_BACK | PSWIZB_NEXT);
}


BOOL 
CWizardSelectDir::OnNext()
{
    CUnpacker* punpacker = ::GetUnpacker();
    int nRet;
    TCHAR szPath[MAX_PATH];
    HANDLE hfile;


    // Get the text from the edit control and make it our default directory
    GetWindowText(GetDlgItem(m_hwnd, IDC_DIREDIT), punpacker->GetDefaultDir(), MAX_PATH);

    // Make sure it's not the c: root
    strcpy(szPath, punpacker->GetDefaultDir());
    ::AppendSlash(szPath);
    if (_stricmp(szPath, _TEXT("c:\\")) == 0)
    {
        LoadString(::GetInstanceHandle(), IDS_MB_INVALIDPATH, szPath, sizeof (szPath));
        MessageBox(GetParent(m_hwnd), szPath, CUnpacker::GetProductName(), MB_OK);
        SetNextPage(IDD_SELECTDIR);
        return -1;
    }

    // Make sure that there is not a different product installed to that directory
    // that uses the Xbox Install Technology.
    TCHAR szOtherProductName[MAX_PATH];
    if(!punpacker->CheckForOtherProduct(szPath, szOtherProductName, sizeof(szOtherProductName)))
    {
        TCHAR szMessage[MAX_PATH];
        rsprintf(::GetInstanceHandle(), szMessage, IDS_CANT_SHARE_DIRECTORY, CUnpacker::GetProductName(), szPath, szOtherProductName);
        MessageBox(GetParent(m_hwnd), szMessage, CUnpacker::GetProductName(), MB_OK);
        SetNextPage(IDD_SELECTDIR);
        return -1;
    }

    // See if we can create the directory
    strcat(szPath, "test.tst"); // Depends on szPath from above
    CCab::MakeDirectory(szPath);
    hfile = CreateFile(szPath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL, OPEN_ALWAYS, 0, NULL);
    if (hfile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hfile);
        DeleteFile(szPath);
    }
    else
    {
        LoadString(::GetInstanceHandle(), IDS_CANT_CREATE, szPath, MAX_PATH);
        MessageBox(GetParent(m_hwnd), szPath, CUnpacker::GetProductName(), MB_OK);
        SetNextPage(IDD_SELECTDIR);
        return -1;
    }

    

    // Now that we have a good directory, do a sanity check of directories
    // If no good, skip to the error page.
    if (!punpacker->ValidateDirectories())
    {
        SetNextPage(IDD_WIZERROR);
        return TRUE;
    }

    // Check disk space. This is complicated by the fact that if there are two
    // types of out of disk space: a return of 1 means that the default directory
    // (that they just chose) is the one that is out of space. If it's this, we
    // just show a MessageBox and let them choose a new directory. A return of -1
    // means that it wasn't the default directory that caused it. If not, they can't
    // do anything about it, so we go to the error page.
    // BUGBUG: set hourglass here
    nRet = punpacker->CheckDiskSpace();
    if (nRet == 1)
    {
        MessageBox(GetParent(m_hwnd), WizGetLastErrorString(), CUnpacker::GetProductName(), MB_OK);
        SetNextPage(IDD_SELECTDIR);
        return -1;
    }
    else if (nRet == -1)
    {
        SetNextPage(IDD_WIZERROR);
        return TRUE;
    }

    // Move the tempdir to the uninstall dir. This also sets the
    // default directory for anyone else that needs it
    if (!punpacker->MoveSettingsCab())
        SetNextPage(IDD_WIZERROR);
    else
        SetNextPage(IDD_COPYING);
    return TRUE;
}

VOID
CWizardSelectDir::OnBack()
{
    if(UNPACKER_FLAGS_SKIPLICENSEPAGE&GetUnpacker()->GetFlags())
    {
        SetNextPage(IDD_WELCOME);
    } else
    {
        SetNextPage(IDD_LICENSE);
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\xdk\resource.h ===
//
//  Include all the common resource definitions for unpacker and uninstall
//
#include <rsccommon.h>

// Resources for the Custom DLL
// Some of these seem global, but they are not and are directly used by the Custom DLL
#define IDS_XDK_TITLE                   1000
#define IDS_ERRORNOMSDEV                1001
#define IDS_ERRORMSDEVINUSE             1002
#define IDS_MB_MSDEVINUSE               1003
#define IDS_ERRORNOPROCPACK             1004
#define IDS_ERRORNOTVCSP4               1009
#define IDS_ERRORAPPINUSE               1014
#define IDS_MB_APPINUSE                 1015
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\xdk\custom.cpp ===
//  CUSTOM.CPP
//
//      This file is the only file that normally needs to be modified to make
//      modifications for a particular setup instance. Any changes outside
//      this file should be made to keep the rest of the code a general-purpose
//      engine.
//
//  Created 30-Mar-2001 [JonT]
//  Separated into its own DLL 23-Aug-2001 [MitchdD]


#include <windows.h>
#include <shellapi.h>
#include <shlwapi.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <custom.h>
#include <settings.h>
#include <resource.h>
#include <helper.h>
#include <global.h>
#include <parse.h>
#include <xboxverp.h>

#define XDK_BUILD_REGKEY _TEXT("SOFTWARE\\Microsoft\\XboxSDK")
#define XDK_BUILD_REGVALUE _TEXT("Build")
#define XDK_FULL_BUILD_REGVALUE _TEXT("InstalledVersion")
#define XDK_BUILDTIME_REGVALUE _TEXT("LastInstallDate")
#define XDK_OLD_INSTALL_REGVALUE _TEXT("SDK Doc Path")
#define XDK_NEW_INSTALL_REGVALUE _TEXT("InstallPath")

#define VC_SP_REGKEY _TEXT("SOFTWARE\\Microsoft\\VisualStudio\\6.0\\ServicePacks")

typedef BOOL (*LPGETVERSIONEX)(OSVERSIONINFOEX*);

#define ARRAYSIZE(x) (sizeof(x) / sizeof(x[0]))

//---------------------------------------------------------------------
//  Declare CXdkCustom implementing CCustom

class CXdkCustom : public CCustom
{
public:
    BOOL DoPreSetupChecks();
    BOOL ValidateDirectory(
            LPCSTR lpDefaultDir,    // Default dir: set on upgrade or by the user
            LPCSTR lpID,            // Target directory ID string. Unique.
            LPSTR lpCommand,        // Command that was used to fill in the target path
            LPSTR lpData,           // Data used to fill in the target path (after : in .INI file)
            LPSTR lpPath            // Path files will be copied to with this ID
            );
    VOID AfterCopy();
    VOID PostSetup(int nRet);
};


//---------------------------------------------------------------------
//  Globals
CXdkCustom   g_XdkCustom;
CCustomSite *g_pCustomSite = NULL;
HINSTANCE    g_hInstance = NULL;

CCustom * __stdcall GetCustom(CCustomSite *pSetupSite)
{
    g_pCustomSite = pSetupSite;
    return dynamic_cast<CCustom *>(&g_XdkCustom);
}

//---------------------------------------------------------------------
//  DllMain
BOOL DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID)
{
    if(dwReason==DLL_PROCESS_ATTACH)
    {
        g_hInstance = hInstance;
    }

    return TRUE;
}

inline static HINSTANCE GetInstanceHandle() {return g_hInstance;}

//---------------------------------------------------------------------
//  Helper functions


void XdkLastError(UINT uResourceId, DWORD dwErrorCode, ...)
{
    if(g_pCustomSite)
    {
        char szFormat[MAX_PATH];
        char szText[MAX_PATH];
        LoadString(GetInstanceHandle(), uResourceId, szFormat, sizeof(szFormat));
        va_list vl;
        va_start(vl, dwErrorCode);
        vsprintf(szText, szFormat, vl);
        va_end(vl);
        g_pCustomSite->SetLastErrorString(szText, dwErrorCode);
    }
}

BOOL
CheckForMSDev()
{
    TCHAR szPath[MAX_PATH];
    TCHAR szTitle[MAX_PATH];
    TCHAR szText[MAX_PATH];

    // Get the path from the registry
    if (GetRegistryString(szPath, MAX_PATH, HKEY_LOCAL_MACHINE,
        _TEXT("SOFTWARE\\Microsoft\\VisualStudio\\6.0\\Setup"), _TEXT("VsCommonDir")) == FALSE)
    {
        XdkLastError(IDS_ERRORNOMSDEV, 2001);
        return FALSE;
    }

    // Add the rest of the path to msdev.exe
    int nLen = lstrlen(szPath);
    lstrcpyn(&(szPath[nLen]), _TEXT("\\MSDev98\\Bin\\msdev.exe"), ARRAYSIZE(szPath) - nLen);

    // Loop until the file is not busy anymore or the user tell us to stop trying
    while (TRUE)
    {
        // Open the file. This checks for existence and for the file being in use
        HANDLE hfile = CreateFile(szPath, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
    
        // If this succeeded, we're good to go
        if (hfile != INVALID_HANDLE_VALUE)
        {
            CloseHandle(hfile);
            return TRUE;
        }

        // Any error besides file busy means msdev isn't installed
        if (GetLastError() != ERROR_SHARING_VIOLATION)
        {
            XdkLastError(IDS_ERRORNOMSDEV, 2002);
            return FALSE;
        }
    
        // Give the user a chance to exit MSDEV before bailing on setup
        LoadString(GetInstanceHandle(), IDS_XDK_TITLE, szTitle, MAX_PATH);
        LoadString(GetInstanceHandle(), IDS_MB_MSDEVINUSE, szText, MAX_PATH);
        if (MessageBox(NULL, szText, szTitle, MB_YESNO) == IDNO)
        {
            XdkLastError(IDS_ERRORMSDEVINUSE, 2003);
            return FALSE;
        }
    }
}


BOOL
CheckForProgramInUse(
    LPCTSTR lpExeName
    )
{
    TCHAR szSearch[MAX_PATH];
    TCHAR szTitle[MAX_PATH];
    TCHAR szText[MAX_PATH];
    TCHAR szOutput[MAX_PATH];
    LPTSTR lp;

    // Search the path for the tool. If we don't find it, we're good.
    if (!SearchPath(NULL, lpExeName, NULL, MAX_PATH, szSearch, &lp))
        return TRUE;

    // Loop until the file is not busy anymore or the user tell us to stop trying
    while (TRUE)
    {
        // Open the file. This checks for existence and for the file being in use
        HANDLE hfile = CreateFile(szSearch, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
    
        // If this succeeded, we're good to go
        if (hfile != INVALID_HANDLE_VALUE || GetLastError() != ERROR_SHARING_VIOLATION)
        {
            CloseHandle(hfile);
            return TRUE;
        }

        // Give the user a chance to exit the application before bailing on setup
        LoadString(GetInstanceHandle(), IDS_XDK_TITLE, szTitle, MAX_PATH);
        LoadString(GetInstanceHandle(), IDS_MB_APPINUSE, szText, MAX_PATH);
        sprintf(szOutput, szText, lpExeName);
        if (MessageBox(NULL, szOutput, szTitle, MB_YESNO) == IDNO)
        {
            XdkLastError(IDS_ERRORAPPINUSE, 2016, lpExeName);
            return FALSE;
        }
    }
}


BOOL
CheckForSPAndProcPack()
{
    TCHAR szPath[MAX_PATH];

    // See if the service pack is installed
    if (!GetRegistryString(szPath, MAX_PATH, HKEY_LOCAL_MACHINE, VC_SP_REGKEY, _TEXT("SP4")) &&
        !GetRegistryString(szPath, MAX_PATH, HKEY_LOCAL_MACHINE, VC_SP_REGKEY, _TEXT("SP5")) &&
        !GetRegistryString(szPath, MAX_PATH, HKEY_LOCAL_MACHINE, VC_SP_REGKEY, _TEXT("SP6"))) // doesn't exist yet
    {
        XdkLastError(IDS_ERRORNOTVCSP4, 2013);
        return FALSE;
    }

    // Get the path to the VC Product directory
    if (GetRegistryString(szPath, MAX_PATH, HKEY_LOCAL_MACHINE,
        _TEXT("SOFTWARE\\Microsoft\\DevStudio\\6.0\\Products\\Microsoft Visual C++"),
        _TEXT("ProductDir")) == FALSE)
    {
        XdkLastError(IDS_ERRORNOMSDEV, 2004);
        return FALSE;
    }

    // Get the path to C2.DLL and compare version information against the processor pack version
    int nLen = lstrlen(szPath);
    lstrcpyn(&(szPath[nLen]), _TEXT("\\Bin\\c2.dll"), ARRAYSIZE(szPath) - nLen);
    int nRet;
    if (!CompareFileVersion(szPath, (13 << 16), (8942 << 16), &nRet))
    {
        XdkLastError(IDS_ERRORNOMSDEV, 2005);
        return FALSE;
    }

    // If the version is < what we expect, we have to bail
    if (nRet < 0)
    {
        XdkLastError(IDS_ERRORNOPROCPACK, 2006);
        return FALSE;
    }

    return TRUE;
}


//  PrependPathElement
//      Returns a new path with the element in question added in.
//      The new path is malloc'ed, caller's responsibility to free it.

LPSTR
PrependPathElement(
    LPSTR lpPath,
    LPSTR lpComponent
    )
{
    TCHAR szFullComponent[MAX_PATH];
    LPSTR lp;

    // Get the full path of the component passed in
    strcpy(szFullComponent, g_pCustomSite->GetDefaultDir());
    ::AppendSlash(szFullComponent);
    strcat(szFullComponent, lpComponent);
    DWORD dwcComponent = strlen(szFullComponent);

    // Search for this component
    for (lp = lpPath ; *lp ;)
    {
        // Did we find the component?
        if (_strnicmp(lp, szFullComponent, dwcComponent) == 0)
        {
            // We found it, return an unchanged copy of the string
            return _strdup(lpPath);
        }

        // Scan to the next component
        for (; *lp && *lp != ';' ; ++lp)
            ;
        if (*lp == ';')
            ++lp;
    }

    // Allocate some memory for the new path
    lp = (LPSTR)malloc(strlen(lpPath) + strlen(szFullComponent) + 2);

    // Make the new path
    strcpy(lp, szFullComponent);
    strcat(lp, ";");
    strcat(lp, lpPath);

    return lp;
}

//  MungeMSDEVPaths
//      This is yucky stuff we have to do to support the Xbox Target type. Add the
//      correct directories to their 'path' registry values
//      WARNING!! If you change this code, make sure you change the uninstaller, too!!
//      The uninstaller reverses the effect of this code.

VOID
MungeMSDEVPaths()
{
    LPCSTR lpWin32Directories = _TEXT("Software\\Microsoft\\Devstudio\\6.0\\Build System\\Components\\Platforms\\Win32 (x86)\\Directories");
    LPCSTR lpXboxDirectories = _TEXT("Software\\Microsoft\\Devstudio\\6.0\\Build System\\Components\\Platforms\\Xbox\\Directories");
    LPCSTR lpPathDirs = _TEXT("Path Dirs");
    LPSTR lpDefaultDir = g_pCustomSite->GetDefaultDir();
    HKEY hkey;

    // Does a Xbox target platform "Path Dirs" exist?
    LPSTR lpXboxPlatformPath = GetRegistryStringAlloc(HKEY_CURRENT_USER, lpXboxDirectories, lpPathDirs);
    LPSTR lpWin32PlatformPath = GetRegistryStringAlloc(HKEY_CURRENT_USER, lpWin32Directories, lpPathDirs);
    if (lpXboxPlatformPath)
    {
        // Yes, so add %xdk%\bin\vc7 and %xdk%\bin
        LPSTR lpPath1 = PrependPathElement(lpXboxPlatformPath, _TEXT("Xbox\\Bin"));
        LPSTR lpPath2 = PrependPathElement(lpPath1, _TEXT("Xbox\\Bin\\VC7"));
        WriteRegistryString(HKEY_CURRENT_USER, lpXboxDirectories, lpPathDirs, lpPath2);
        free(lpPath1);
        free(lpPath2);
    }

    // Does the Win32 target platform path exist instead?
    else if (lpWin32PlatformPath)
    {
        // Yes, so add %xdk%\bin\vc7 and %xdk%\bin
        LPSTR lpPath1 = PrependPathElement(lpWin32PlatformPath, _TEXT("Xbox\\Bin"));
        LPSTR lpPath2 = PrependPathElement(lpPath1, _TEXT("Xbox\\Bin\\VC7"));
        WriteRegistryString(HKEY_CURRENT_USER, lpXboxDirectories, lpPathDirs, lpPath2);
        free(lpPath1);
        free(lpPath2);
    }

    // No, create from scratch
    else
    {
        // Get the path to some VC components
        LPSTR lpMSDEVPath = GetRegistryStringAlloc(HKEY_LOCAL_MACHINE,
            _TEXT("Software\\Microsoft\\DevStudio\\6.0\\Products\\Microsoft Visual C++"),
            _TEXT("ProductDir"));

        // Get the path environment variable
        LPCSTR szPathStr = _TEXT("PATH");
        DWORD dwEnvSize = GetEnvironmentVariable(szPathStr, "", 0);
        LPSTR lpPathEnvVar = (LPSTR)malloc(dwEnvSize);
        GetEnvironmentVariable(szPathStr, lpPathEnvVar, dwEnvSize);

        // Build the new VC Win32 target platform path
        LPSTR lpNewPath = (LPSTR)malloc(dwEnvSize + 5 * MAX_PATH);
        *lpNewPath = 0;

        // Add in the Xbox parts of the path
        strcat(lpNewPath, lpDefaultDir);
        ::AppendSlash(lpNewPath);
        strcat(lpNewPath, "Xbox\\Bin\\VC7;");
        strcat(lpNewPath, lpDefaultDir);
        ::AppendSlash(lpNewPath);
        strcat(lpNewPath, "Xbox\\Bin;");

        // Add in the VC parts
        if (lpMSDEVPath)
        {
            strcat(lpNewPath, lpMSDEVPath);
            ::AppendSlash(lpNewPath);
            strcat(lpNewPath, "..\\Common\\MSDev98\\Bin;");
            strcat(lpNewPath, lpMSDEVPath);
            ::AppendSlash(lpNewPath);
            strcat(lpNewPath, "Bin;");
            strcat(lpNewPath, lpMSDEVPath);
            ::AppendSlash(lpNewPath);
            strcat(lpNewPath, "..\\Common\\Tools;");
            free(lpMSDEVPath);
        }

        // Add in the path from the environment variable
        strcat(lpNewPath, lpPathEnvVar);
        free(lpPathEnvVar);

        // All done, write out the registry string
        WriteRegistryString(HKEY_CURRENT_USER, lpXboxDirectories, lpPathDirs, lpNewPath);
        free(lpNewPath);
    }
    if (lpXboxPlatformPath)
        free(lpXboxPlatformPath);
    if (lpWin32PlatformPath)
        free(lpWin32PlatformPath);

    // Just like we did for the "Path Dirs," do for the "Include Dirs"
    LPCSTR lpIncludeDirs = _TEXT("Include Dirs");
    LPSTR lpXboxPlatformInclude = GetRegistryStringAlloc(HKEY_CURRENT_USER, lpXboxDirectories, lpIncludeDirs);
    if (lpXboxPlatformInclude)
    {
        // Path exists, include the Xbox directories
        LPSTR lpPath = PrependPathElement(lpXboxPlatformInclude, _TEXT("Xbox\\Include"));
        WriteRegistryString(HKEY_CURRENT_USER, lpXboxDirectories, lpIncludeDirs, lpPath);
        free(lpPath);
        free(lpXboxPlatformInclude);
    }

    // Otherwise build a new one from scratch
    else
    {
        TCHAR szIncludePath[MAX_PATH];
        strcpy(szIncludePath, lpDefaultDir);
        ::AppendSlash(szIncludePath);
        strcat(szIncludePath, _TEXT("Xbox\\Include"));
        WriteRegistryString(HKEY_CURRENT_USER, lpXboxDirectories, lpIncludeDirs, szIncludePath);
    }

    // And for the "Lib dirs"
    LPCSTR lpLibDirs = _TEXT("Library Dirs");
    LPSTR lpXboxPlatformLib = GetRegistryStringAlloc(HKEY_CURRENT_USER, lpXboxDirectories, lpLibDirs);
    if (lpXboxPlatformLib)
    {
        // Path exists, include the Xbox directories
        LPSTR lpPath = PrependPathElement(lpXboxPlatformLib, _TEXT("Xbox\\Lib"));
        WriteRegistryString(HKEY_CURRENT_USER, lpXboxDirectories, lpLibDirs, lpPath);
        free(lpPath);
        free(lpXboxPlatformLib);
    }

    // Otherwise, build a new one from scratch
    else
    {
        TCHAR szLibPath[MAX_PATH];
        strcpy(szLibPath, lpDefaultDir);
        ::AppendSlash(szLibPath);
        strcat(szLibPath, _TEXT("Xbox\\Lib"));
        WriteRegistryString(HKEY_CURRENT_USER, lpXboxDirectories, lpLibDirs, szLibPath);
    }

    // And for the "source dirs"
    LPCSTR lpSourceDirs = _TEXT("Source Dirs");
    LPSTR lpXboxPlatformSource = GetRegistryStringAlloc(HKEY_CURRENT_USER, lpXboxDirectories, lpSourceDirs);
    if (lpXboxPlatformSource)
    {
        // Path exists, include the Xbox directories
        LPSTR lpPath = PrependPathElement(lpXboxPlatformSource, _TEXT("Source"));
        WriteRegistryString(HKEY_CURRENT_USER, lpXboxDirectories, lpSourceDirs, lpPath);
        free(lpPath);
        free(lpXboxPlatformSource);
    }

    // Otherwise, build a new one from scratch
    else
    {
        TCHAR szSourcePath[MAX_PATH];
        strcpy(szSourcePath, lpDefaultDir);
        ::AppendSlash(szSourcePath);
        strcat(szSourcePath, _TEXT("Source"));
        WriteRegistryString(HKEY_CURRENT_USER, lpXboxDirectories, lpSourceDirs, szSourcePath);
    }

    // Add our directories to the Win32 platform as well
    LPSTR lpWin32PlatformInclude = GetRegistryStringAlloc(HKEY_CURRENT_USER, lpWin32Directories, lpIncludeDirs);
    if (lpWin32PlatformInclude)
    {
        // Path exists, include the Xbox directories
        LPSTR lpPath = PrependPathElement(lpWin32PlatformInclude, _TEXT("Include"));
        WriteRegistryString(HKEY_CURRENT_USER, lpWin32Directories, lpIncludeDirs, lpPath);
        free(lpPath);
        free(lpWin32PlatformInclude);
    }

    // And for the "Lib dirs" (Win32)
    LPSTR lpWin32PlatformLib = GetRegistryStringAlloc(HKEY_CURRENT_USER, lpWin32Directories, lpLibDirs);
    if (lpWin32PlatformLib)
    {
        // Path exists, include the Xbox directories
        LPSTR lpPath = PrependPathElement(lpWin32PlatformLib, _TEXT("Lib"));
        WriteRegistryString(HKEY_CURRENT_USER, lpWin32Directories, lpLibDirs, lpPath);
        free(lpPath);
        free(lpWin32PlatformLib);
    }

    // Update the system path
    LPCSTR lpRegEnvironmentKey = _TEXT("SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment");
    LPCSTR lpRegEnvironmentValue = _TEXT("PATH");
    LPSTR lpEnvironmentPath = GetRegistryStringAlloc(HKEY_LOCAL_MACHINE, lpRegEnvironmentKey, lpRegEnvironmentValue);
    if (lpEnvironmentPath == NULL)
        lpEnvironmentPath = _strdup("");
    LPSTR lpNewPath = PrependPathElement(lpEnvironmentPath, _TEXT("Xbox\\Bin"));
    free(lpEnvironmentPath);
    if (RegOpenKey(HKEY_LOCAL_MACHINE, lpRegEnvironmentKey, &hkey) == ERROR_SUCCESS)
    {
        RegSetValueEx(hkey, lpRegEnvironmentValue, 0, REG_EXPAND_SZ, (LPBYTE)lpNewPath, strlen(lpNewPath) + 1);

        // Make an XDK env. variable with the path to the XDK in it
        RegSetValueEx(hkey, _TEXT("XDK"), 0, REG_EXPAND_SZ, (LPBYTE)lpDefaultDir, strlen(lpDefaultDir) + 1);
        RegCloseKey(hkey);
    }
    free(lpNewPath);

    // Send the message so the new environment variables are picked up
    LPCSTR lpEnvFlag = _TEXT("Environment");
    SendMessage(HWND_BROADCAST, WM_WININICHANGE, 0, (LPARAM)lpEnvFlag);
}

//---------------------------------------------------------------------
//  CXdkCustom methods

//  CXdkCustom::DoPreSetupChecks
//      Here is where we have a chance in code to stop setup because
//      something isn't right. We need to test that we're not installing
//      an older build over a newer one, make sure that the SPs we
//      insist on are already installed, and that nothing we depend on is running.
//      It's important to call XdkLastError with an appropriate error message
//      before returning FALSE.

BOOL
CXdkCustom::DoPreSetupChecks()
{
    // Check to make sure MSDEV is installed
    if (!CheckForMSDev() || !CheckForSPAndProcPack())
        return FALSE;

    // Check to make sure any XDK tools aren't running
    if (!CheckForProgramInUse("xbExplorer.exe") ||
        !CheckForProgramInUse("xbWatson.exe"))
        return FALSE;

    return TRUE;
}


//  CXdkCustom::CustomDirectory
//      Here is where we're given a chance to see and/or update target directories
//      as they get set. Normally, the target directory roots are set by
//      looking up regkeys or by prompting the user for one default directory.
//      This callback is called for each directory target. If any are still empty
//      (and any files are in the manifest pointing to it), the engine will fail,
//      so some error should be displayed here or the empty directory should
//      be resolved somehow. This function will be called once for each target
//      directory.
//      If you take the (radical) step of returning FALSE here, this means that
//      we jump to the error wizard page and terminate setup. As with DoPreSetupChecks,
//      make sure that you've called WizSetLastError with a descriptive error message.

BOOL
CXdkCustom::ValidateDirectory(
    LPCSTR lpDefaultDir,    // Default dir: set on upgrade or by the user
    LPCSTR lpID,            // Target directory ID string. Unique.
    LPSTR lpCommand,        // Command that was used to fill in the target path
    LPSTR lpData,           // Data used to fill in the target path (after : in .INI file)
    LPSTR lpPath            // Path files will be copied to with this ID
    )
{
    return TRUE;
}


//  CXdkCustom::AfterCopy
//      Called just after copying files are complete. Gives a chance to write regkeys
//      and still add things to the uninstall information.

VOID
CXdkCustom::AfterCopy()
{
    // Make sure that MSDEV has the right paths set for the Xbox target type
    MungeMSDEVPaths();
}


//  CXdkCustom::PostSetup
//      Called when setup is complete and the UI has been dismissed.
//      Gives a chance to do any last actions before exiting.

VOID
CXdkCustom::PostSetup(int /*nRet*/)
{
    // Start up the release notes. These will appear after setup goes away
    // This is hardcoded and pretty yucky.
    TCHAR szPath[MAX_PATH];
    strcpy(szPath, g_pCustomSite->GetDefaultDir());
    AppendSlash(szPath);
    strcat(szPath, _TEXT("relnotes.htm"));
    ShellExecute(NULL, NULL, szPath, NULL, NULL, SW_SHOWNORMAL); 
}

VOID
StripPathComponent(
    LPCTSTR pszUninstallPath,
    HKEY hkeyroot,
    LPCTSTR lpSubkey,
    LPCTSTR lpValuename
    );

void __stdcall PostUninstall(LPCTSTR pszUninstallPath)
{
    // Whack the msdev xbox platform key
    LPCSTR lpXboxPlatform = TEXT("Software\\Microsoft\\Devstudio\\6.0\\Build System\\Components\\Platforms\\Xbox");
    SHDeleteKey(HKEY_CURRENT_USER, lpXboxPlatform);

    // Whack out msdev and environment path information
    LPCSTR lpWin32Directories = TEXT("Software\\Microsoft\\Devstudio\\6.0\\Build System\\Components\\Platforms\\Win32 (x86)\\Directories");
    LPCSTR lpPathDirs = TEXT("Path Dirs");
    LPCSTR lpIncludeDirs = TEXT("Include Dirs");
    LPCSTR lpLibDirs = TEXT("Library Dirs");
    LPCSTR lpRegEnvironmentKey = TEXT("SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment");
    LPCSTR lpRegEnvironmentValue = TEXT("PATH");
    StripPathComponent(pszUninstallPath, HKEY_CURRENT_USER, lpWin32Directories, lpIncludeDirs);
    StripPathComponent(pszUninstallPath, HKEY_CURRENT_USER, lpWin32Directories, lpLibDirs);
    StripPathComponent(pszUninstallPath, HKEY_LOCAL_MACHINE, lpRegEnvironmentKey, lpRegEnvironmentValue);
    StripPathComponent(pszUninstallPath, HKEY_CURRENT_USER, lpRegEnvironmentKey, lpRegEnvironmentValue);

    // Nuke the XDK key in the environment
    HKEY hkey;
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpRegEnvironmentKey, 0, KEY_ALL_ACCESS, &hkey) == ERROR_SUCCESS)
    {
        RegDeleteValue(hkey, "XDK");
        RegCloseKey(hkey);
    }

    // Send the message to say that the environment has changed
    LPCSTR lpEnvFlag = TEXT("Environment");
    SendMessage(HWND_BROADCAST, WM_WININICHANGE, 0, (LPARAM)lpEnvFlag);
}

BOOL __stdcall PreUninstall(LPCTSTR pszUninstallPath)
{
    // If MSDev, xbExplorer.exe, xbWatson.exe, 
    //
    if (!CheckForMSDev()||
        !CheckForProgramInUse("xbExplorer.exe") ||
        !CheckForProgramInUse("xbWatson.exe"))
        return FALSE;

    return TRUE;
}

//  StripPathComponent
//      Removes a path component that matches the default directory being uninstalled

VOID
StripPathComponent(
    LPCTSTR pszUninstallPath,
    HKEY hkeyroot,
    LPCTSTR lpSubkey,
    LPCTSTR lpValuename
    )
{
    HKEY hkey;
    DWORD dwType;
    DWORD dwcOut;
    LPSTR lpPath;
    DWORD dwcDir = strlen(pszUninstallPath);
    DWORD dwRet;

    // Open the key
    if (::RegOpenKeyEx(hkeyroot, lpSubkey, 0, KEY_ALL_ACCESS, &hkey) != ERROR_SUCCESS)
        return;

    // Get the length of the value
    if (::RegQueryValueEx(hkey, lpValuename, NULL, &dwType, NULL, &dwcOut) != ERROR_SUCCESS)
        return;

    // Allocate some memory to read the value into
    lpPath = (LPSTR)malloc(dwcOut);
    if (!lpPath)
        return;

    // Do the read
    dwRet = ::RegQueryValueEx(hkey, lpValuename, NULL, &dwType, (LPBYTE)lpPath, &dwcOut);
    if (dwRet != ERROR_SUCCESS || (dwType != REG_SZ && dwType != REG_EXPAND_SZ))
    {
        ::RegCloseKey(hkey);
        free(lpPath);
        return;
    }

    LPSTR lpNewPath = (LPSTR)malloc(dwcOut);
    LPSTR lpNew = lpNewPath;
    LPSTR lp = lpPath;

    // Walk through the path components, finding any piece that matches the install directory
    // Search for this component
    while (*lp)
    {
        // Did we find the component?
        if (_strnicmp(lp, pszUninstallPath, dwcDir) == 0)
        {
            // Scan to the next component, skipping it
            for (; *lp && *lp != ';' ; ++lp)
                ;
            if (*lp == ';')
                ++lp;
        }

        // Otherwise, copy this component
        else
        {
            while (*lp && *lp != ';')
                *lpNew++ = *lp++;
            if (*lp == ';')
                *lpNew++ = *lp++;
        }
    }
    *lpNew = 0;

    // Write the key back out
    ::RegSetValueEx(hkey, lpValuename, 0, REG_EXPAND_SZ, (LPBYTE)lpNewPath, strlen(lpNewPath) + 1);
    ::RegCloseKey(hkey);
    free(lpPath);
    free(lpNewPath);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\buildxbe\crttests\crttestp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    crttestp.h

Abstract:

    Pre-compiled header file for CRT test harness

--*/

#include <ntos.h>
#include <xtl.h>

#ifdef __cplusplus
extern "C" {
#endif

void __cdecl PlumHallStartTest( void );
void __cdecl SlConfrmStartTest( void );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\buildxbe\crttests\main.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    main.cpp

Abstract:

    Entry point and initialization routines for CRT test harness

--*/

#include "crttestp.h"

void __cdecl main()
{
    KdPrint(( "CRTTEST: starting...\n" ));
    PlumHallStartTest();
    SlConfrmStartTest();
    Sleep( INFINITE );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\buildxbe\AudHarn\modules.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    modules.cpp

Abstract:

    List of all test modules

Environment:

    Xbox

Revision History:

--*/


//
// Tell the linker to include the following symbols so that "export table"
// of each test module will be placed and sorted in "export directory" inside
// the test harness
//

#pragma comment( linker, "/include:_dsAPI_ExportTableDirectory" )
#pragma comment( linker, "/include:_dsBVT_ExportTableDirectory" )
#pragma comment( linker, "/include:_ds3D_ExportTableDirectory"  )
#pragma comment( linker, "/include:_ds3DStrs_ExportTableDirectory"  )
#pragma comment( linker, "/include:_mixer_ExportTableDirectory" )
#pragma comment( linker, "/include:_dsReg_ExportTableDirectory" )
#pragma comment( linker, "/include:_DMTest1_ExportTableDirectory" )
#pragma comment( linker, "/include:_xmoBVT_ExportTableDirectory" )
#pragma comment( linker, "/include:_xmoReg_ExportTableDirectory" )
#pragma comment( linker, "/include:_WMABVT_ExportTableDirectory" )
#pragma comment( linker, "/include:_WMAReg_ExportTableDirectory" )
#pragma comment( linker, "/include:_DirectSoundCreate_ExportTableDirectory" )
#pragma comment( linker, "/include:_DirectSoundCreateBuffer_ExportTableDirectory" )
#pragma comment( linker, "/include:_DirectSoundCreateStream_ExportTableDirectory" )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\buildxbe\AudHarn\main.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    main.cpp

Abstract:

    Entry point and initialization routines for test harness

Environment:

    Xbox

Revision History:

--*/

#include <xtl.h>

HANDLE g_hLog;

extern "C"
DWORD
WINAPI
HarnessEntryPoint(
    VOID
    );

int __cdecl main()
{
    //
    // Call main routine of the tets harness library in harnesslib.lib
    //

    return HarnessEntryPoint();
}

//
// Tell the linker to include the following symbols so that XIU and XTU
// sections inside CRT will get built and startup/cleanup routines in
// xtestlib will get executed
//

#pragma comment( linker, "/include:_xtestlib_startup" )
#pragma comment( linker, "/include:_xtestlib_cleanup" )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\buildxbe\dmharn\modules.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    modules.cpp

Abstract:

    List of all test modules

Environment:

    Xbox

Revision History:

--*/


//
// Tell the linker to include the following symbols so that "export table"
// of each test module will be placed and sorted in "export directory" inside
// the test harness
//

#pragma comment( linker, "/include:_DMTest1_ExportTableDirectory" )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\buildxbe\harness\main.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    main.cpp

Abstract:

    Entry point and initialization routines for test harness

Environment:

    Xbox

Revision History:

--*/


#include <xtl.h>


extern "C"
DWORD
WINAPI
HarnessEntryPoint(
    VOID
    );


void __cdecl main()
{
    //
    // Call main routine of the tets harness library in harnesslib.lib
    //
    HarnessEntryPoint();
}


//
// Tell the linker to include the following symbols so that XIU and XTU
// sections inside CRT will get built and startup/cleanup routines in
// xtestlib will get executed
//

#pragma comment( linker, "/include:_xtestlib_startup" )
#pragma comment( linker, "/include:_xtestlib_cleanup" )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\buildxbe\dmharn\main.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    main.cpp

Abstract:

    Entry point and initialization routines for test harness

Environment:

    Xbox

Revision History:

--*/

#include <xtl.h>

HANDLE g_hLog;

extern "C"
DWORD
WINAPI
HarnessEntryPoint(
    VOID
    );

int __cdecl main()
{
    //
    // Call main routine of the tets harness library in harnesslib.lib
    //

    return HarnessEntryPoint();
}

//
// Tell the linker to include the following symbols so that XIU and XTU
// sections inside CRT will get built and startup/cleanup routines in
// xtestlib will get executed
//

#pragma comment( linker, "/include:_xtestlib_startup" )
#pragma comment( linker, "/include:_xtestlib_cleanup" )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\buildxbe\harness\modules.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    modules.cpp

Abstract:

    List of all test modules

Environment:

    Xbox

Revision History:

--*/


//
// Tell the linker to include the following symbols so that "export table"
// of each test module will be placed and sorted in "export directory" inside
// the test harness
//

#ifndef NO_KERNEL_TEST
#pragma comment( linker, "/include:_stressmon_ExportTableDirectory" )
#pragma comment( linker, "/include:_mmtimer_ExportTableDirectory" )
#pragma comment( linker, "/include:_idelog_ExportTableDirectory" )
#pragma comment( linker, "/include:_sdstress_ExportTableDirectory" )
#pragma comment( linker, "/include:_diskperf_ExportTableDirectory" )
#pragma comment( linker, "/include:_fpexcept_ExportTableDirectory" )
//#pragma comment( linker, "/include:_devctl_ExportTableDirectory" )
#pragma comment( linker, "/include:_obstress_ExportTableDirectory" )
#pragma comment( linker, "/include:_abuseval_ExportTableDirectory" )
#pragma comment( linker, "/include:_memperf_ExportTableDirectory" )
#pragma comment( linker, "/include:_vmstress_ExportTableDirectory" )
#pragma comment( linker, "/include:_xmmapi_ExportTableDirectory" )
#pragma comment( linker, "/include:_threading_ExportTableDirectory" )
#pragma comment( linker, "/include:_timetest_ExportTableDirectory" )
#pragma comment( linker, "/include:_fileio_ExportTableDirectory" )
#pragma comment( linker, "/include:_sections_ExportTableDirectory" )
#pragma comment( linker, "/include:_savegame_ExportTableDirectory" )
#pragma comment( linker, "/include:_launcher_ExportTableDirectory" )
#pragma comment( linker, "/include:_usbinput_ExportTableDirectory" )
#pragma comment( linker, "/include:_nickname_ExportTableDirectory" )
#pragma comment( linker, "/include:_smcstress_ExportTableDirectory" )
#pragma comment( linker, "/include:_soundtrack_ExportTableDirectory" )
#pragma comment( linker, "/include:_mutests_ExportTableDirectory" )
#pragma comment( linker, "/include:_cryptotest_ExportTableDirectory" )
#pragma comment( linker, "/include:_dvdperftest_ExportTableDirectory" )
#pragma comment( linker, "/include:_cpuusage_ExportTableDirectory" )
#pragma comment( linker, "/include:_media_ExportTableDirectory" )
#pragma comment( linker, "/include:_WFVO_ExportTableDirectory" )
#pragma comment( linker, "/include:_makeini_ExportTableDirectory" )
#endif //NO_KERNEL_TEST

#ifndef NO_GRAPHICS_TEST
#pragma comment( linker, "/include:_address_ExportTableDirectory" )
#pragma comment( linker, "/include:_D3DAPI_ExportTableDirectory" )
#pragma comment( linker, "/include:_SATEST_ExportTableDirectory" )
#pragma comment( linker, "/include:_alphabld_ExportTableDirectory" )
#pragma comment( linker, "/include:_alphacmp_ExportTableDirectory" )
#pragma comment( linker, "/include:_basicrst_ExportTableDirectory" )
#pragma comment( linker, "/include:_blend_ExportTableDirectory" )
#pragma comment( linker, "/include:_bump_ExportTableDirectory" )
#pragma comment( linker, "/include:_clear_test_ExportTableDirectory" )
#pragma comment( linker, "/include:_compress_ExportTableDirectory" )
#pragma comment( linker, "/include:_cubemap_ExportTableDirectory" )
#pragma comment( linker, "/include:_emboss_ExportTableDirectory" )
#pragma comment( linker, "/include:_fog_ExportTableDirectory" )
#pragma comment( linker, "/include:_gradient_ExportTableDirectory" )
#pragma comment( linker, "/include:_lightmap_ExportTableDirectory" )
#pragma comment( linker, "/include:_linetex_ExportTableDirectory" )
#pragma comment( linker, "/include:_luminanc_ExportTableDirectory" )
#pragma comment( linker, "/include:_mapping_ExportTableDirectory" )
#pragma comment( linker, "/include:_mipfilter_ExportTableDirectory" )
#pragma comment( linker, "/include:_overdraw_ExportTableDirectory" )
#pragma comment( linker, "/include:_perspective_ExportTableDirectory" )
#pragma comment( linker, "/include:_pointsprite_ExportTableDirectory" )
#pragma comment( linker, "/include:_pointtex_ExportTableDirectory" )
#pragma comment( linker, "/include:_pshader_ExportTableDirectory" )
#pragma comment( linker, "/include:_srt_ExportTableDirectory" )
#pragma comment( linker, "/include:_stateblocks_ExportTableDirectory" )
#pragma comment( linker, "/include:_stencil_ExportTableDirectory" )
#pragma comment( linker, "/include:_texturestage_ExportTableDirectory" )
#pragma comment( linker, "/include:_tlvertexclip_ExportTableDirectory" )
#pragma comment( linker, "/include:_volume_ExportTableDirectory" )
#pragma comment( linker, "/include:_wbuffer_ExportTableDirectory" )
#pragma comment( linker, "/include:_wcmp_ExportTableDirectory" )
#pragma comment( linker, "/include:_zbuffer_ExportTableDirectory" )
#pragma comment( linker, "/include:_zcmp_ExportTableDirectory" )
#pragma comment( linker, "/include:_alphabnt_ExportTableDirectory" )
#pragma comment( linker, "/include:_ball_ExportTableDirectory" )
#pragma comment( linker, "/include:_basic_ExportTableDirectory" )
#pragma comment( linker, "/include:_bees_ExportTableDirectory" )
#pragma comment( linker, "/include:_bumpduv1_ExportTableDirectory" )
#pragma comment( linker, "/include:_bumpduv2_ExportTableDirectory" )
#pragma comment( linker, "/include:_clipping_ExportTableDirectory" )
#pragma comment( linker, "/include:_depthbuf_ExportTableDirectory" )
#pragma comment( linker, "/include:_dlight_ExportTableDirectory" )
#pragma comment( linker, "/include:_dxtnoise_ExportTableDirectory" )
#pragma comment( linker, "/include:_fsaa_ExportTableDirectory" )
#pragma comment( linker, "/include:_fvertex1_ExportTableDirectory" )
#pragma comment( linker, "/include:_gammarmp_ExportTableDirectory" )
#pragma comment( linker, "/include:_getrstat_ExportTableDirectory" )
#pragma comment( linker, "/include:_hightide_ExportTableDirectory" )
#pragma comment( linker, "/include:_ibuffer_ExportTableDirectory" )
#pragma comment( linker, "/include:_innrloop_ExportTableDirectory" )
#pragma comment( linker, "/include:_lighting_ExportTableDirectory" )
#pragma comment( linker, "/include:_lightball_ExportTableDirectory" )
#pragma comment( linker, "/include:_litetype_ExportTableDirectory" )
#pragma comment( linker, "/include:_lockdepth_ExportTableDirectory" )
#pragma comment( linker, "/include:_matsrc_ExportTableDirectory" )
#pragma comment( linker, "/include:_mstage1_ExportTableDirectory" )
#pragma comment( linker, "/include:_mstage2_ExportTableDirectory" )
#pragma comment( linker, "/include:_mstage4_ExportTableDirectory" )
#pragma comment( linker, "/include:_mstage5_ExportTableDirectory" )
#pragma comment( linker, "/include:_multilight_ExportTableDirectory" )
#pragma comment( linker, "/include:_mxpalskin_ExportTableDirectory" )
#pragma comment( linker, "/include:_obelisk_ExportTableDirectory" )
#pragma comment( linker, "/include:_palette0_ExportTableDirectory" )
#pragma comment( linker, "/include:_pslights_ExportTableDirectory" )
#pragma comment( linker, "/include:_psverify_ExportTableDirectory" )
#pragma comment( linker, "/include:_reflect0_ExportTableDirectory" )
#pragma comment( linker, "/include:_stencil0_ExportTableDirectory" )
#pragma comment( linker, "/include:_terrain_ExportTableDirectory" )
#pragma comment( linker, "/include:_texform_ExportTableDirectory" )
#pragma comment( linker, "/include:_texgen_ExportTableDirectory" )
#pragma comment( linker, "/include:_texgenxt_ExportTableDirectory" )
#pragma comment( linker, "/include:_textr1_ExportTableDirectory" )
#pragma comment( linker, "/include:_textr2_ExportTableDirectory" )
#pragma comment( linker, "/include:_textr3_ExportTableDirectory" )
#pragma comment( linker, "/include:_textr4_ExportTableDirectory" )
#pragma comment( linker, "/include:_textr5_ExportTableDirectory" )
#pragma comment( linker, "/include:_tunnel_ExportTableDirectory" )
#pragma comment( linker, "/include:_vbbatch_ExportTableDirectory" )
#pragma comment( linker, "/include:_vbib_ExportTableDirectory" )
#pragma comment( linker, "/include:_vpshadr1_ExportTableDirectory" )
#pragma comment( linker, "/include:_vshader_ExportTableDirectory" )
#pragma comment( linker, "/include:_wireframe_ExportTableDirectory" )
#pragma comment( linker, "/include:_misorbit_ExportTableDirectory" )
#pragma comment( linker, "/include:_d3dbvt_ExportTableDirectory" )
#pragma comment( linker, "/include:_chessbrd_ExportTableDirectory" )
#pragma comment( linker, "/include:_clockwrk_ExportTableDirectory" )
#pragma comment( linker, "/include:_rteapot_ExportTableDirectory" )
#pragma comment( linker, "/include:_skulls_ExportTableDirectory" )
#pragma comment( linker, "/include:_snowfall_ExportTableDirectory" )
#pragma comment( linker, "/include:_event_ExportTableDirectory" )
#pragma comment( linker, "/include:_fsaaperf_ExportTableDirectory" )
#pragma comment( linker, "/include:_vistest_ExportTableDirectory" )
#pragma comment( linker, "/include:_Ani_ExportTableDirectory" )
#pragma comment( linker, "/include:_xbox11113_ExportTableDirectory" )
#endif //NO_GRAPHICS_TEST

#ifndef NO_AUDIO_TEST
#pragma comment( linker, "/include:_dsBVT_ExportTableDirectory" )
#pragma comment( linker, "/include:_dsAPI_ExportTableDirectory" )
#pragma comment( linker, "/include:_dsReg_ExportTableDirectory" )
#pragma comment( linker, "/include:_ds3D_ExportTableDirectory" )
#pragma comment( linker, "/include:_ds3DStrs_ExportTableDirectory" )
#pragma comment( linker, "/include:_mixer_ExportTableDirectory" )
#pragma comment( linker, "/include:_xmoReg_ExportTableDirectory" )
#pragma comment( linker, "/include:_xmoBVT_ExportTableDirectory" )
#pragma comment( linker, "/include:_mmStress_ExportTableDirectory" )
#pragma comment( linker, "/include:_wmaStress_ExportTableDirectory" )
#pragma comment( linker, "/include:_WMABVT_ExportTableDirectory" )
#pragma comment( linker, "/include:_WMAReg_ExportTableDirectory" )
#pragma comment( linker, "/include:_DMTest1_ExportTableDirectory" )
#pragma comment( linker, "/include:_DirectSoundCreate_ExportTableDirectory" )
#pragma comment( linker, "/include:_DirectSoundCreateBuffer_ExportTableDirectory" )
#pragma comment( linker, "/include:_DirectSoundCreateStream_ExportTableDirectory" )
#pragma comment( linker, "/include:_playcd_ExportTableDirectory" )
#pragma comment( linker, "/include:_DsoundDRT_ExportTableDirectory" )
#endif // NO_AUDIO_TEST

#ifndef NO_ONLINE_TEST
#pragma comment( linker, "/include:_xnetbvt_ExportTableDirectory" )
#pragma comment( linker, "/include:_xnetapi_ExportTableDirectory" )
#pragma comment( linker, "/include:_xnetstress_ExportTableDirectory" )
#pragma comment( linker, "/include:_xnetstream_ExportTableDirectory" )
#pragma comment( linker, "/include:_XAuthBVT_ExportTableDirectory" )
#pragma comment( linker, "/include:_XMatchBVT_ExportTableDirectory" )
#pragma comment( linker, "/include:_XOnlinePINStartInput_ExportTableDirectory" )
#pragma comment( linker, "/include:_XOnlinePINEndInput_ExportTableDirectory" )
#pragma comment( linker, "/include:_XOnlinePINDecodeInput_ExportTableDirectory" )
#pragma comment( linker, "/include:_XOnlineGetUsers_ExportTableDirectory" )
#pragma comment( linker, "/include:_XOnlineAddCachedUser_ExportTableDirectory" )
#pragma comment( linker, "/include:_XOnlineRemoveCachedUser_ExportTableDirectory" )
#pragma comment( linker, "/include:_XOnlineLogon_ExportTableDirectory" )
#pragma comment( linker, "/include:_XOnlineGetServiceInfo_ExportTableDirectory" )
#pragma comment( linker, "/include:_XOnlineGetLogonUsers_ExportTableDirectory" )
#pragma comment( linker, "/include:_stats_ExportTableDirectory" )
#pragma comment( linker, "/include:_feedback_ExportTableDirectory" )
#pragma comment( linker, "/include:_XOnlineStartup_ExportTableDirectory" )
#pragma comment( linker, "/include:_XBudBVT_ExportTableDirectory" )
#endif // NO_ONLINE_TEST
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\buildxbe\crttests\sources.inc ===
!IF 0

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    sources

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETPATH=obj
TARGETTYPE=PROGRAM

UMTYPE=xboxapp

USE_MAPSYM=1

SOURCES=..\main.cpp

INCLUDES=$(SDK_INC_PATH); \
         $(PRIVATE_INC_PATH); \
         $(BASEDIR)\private\ntos\inc; \
         ..

CRTBASE=$(BASEDIR)\private\test\crttests\test

XE_FLAGS=/TESTID:0xA7049956 /INITFLAGS:3

PRECOMPILED_INCLUDE=..\crttestp.h
PRECOMPILED_CXX=1

SOURCES_USED=..\sources.inc

USE_STL=1
USE_IOSTREAM=1
USE_RTTI=1

# ignore multiply defined symbols warning
LINKER_FLAGS=/IGNORE:4006

TARGETLIBS=$(CRTBASE)\conformance\lib\*\plumhall$(MTLIB).lib \
           $(CRTBASE)\conformance\lib\*\slconfrm$(MTLIB).lib
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\buildxbe\netharness\main.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    main.cpp

Abstract:

    Entry point and initialization routines for test harness

Environment:

    Xbox

Revision History:

--*/


#include <xtl.h>


extern "C"
DWORD
WINAPI
HarnessEntryPoint(
    VOID
    );


void __cdecl main()
{
    //
    // Call main routine of the tets harness library in harnesslib.lib
    //
    HarnessEntryPoint();
}


//
// Tell the linker to include the following symbols so that XIU and XTU
// sections inside CRT will get built and startup/cleanup routines in
// xtestlib will get executed
//

#pragma comment( linker, "/include:_xtestlib_startup" )
#pragma comment( linker, "/include:_xtestlib_cleanup" )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\buildxbe\onlineharness\main.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    main.cpp

Abstract:

    Entry point and initialization routines for test harness

Environment:

    Xbox

Revision History:

--*/


#include <xtl.h>


extern "C"
DWORD
WINAPI
HarnessEntryPoint(
    VOID
    );


void __cdecl main()
{
    //
    // Call main routine of the tets harness library in harnesslib.lib
    //
    HarnessEntryPoint();
}


//
// Tell the linker to include the following symbols so that XIU and XTU
// sections inside CRT will get built and startup/cleanup routines in
// xtestlib will get executed
//

#pragma comment( linker, "/include:_xtestlib_startup" )
#pragma comment( linker, "/include:_xtestlib_cleanup" )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\buildxbe\hwtest\main.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    main.cpp

Abstract:

    Entry point and initialization routines for test harness

--*/

#include <xtl.h>

extern "C"
DWORD
WINAPI
HarnessEntryPoint(
    VOID
    );

void __cdecl main()
{
    //
    // Call main routine of the tets harness library in harnesslib.lib
    //

    HarnessEntryPoint();
}

//
// Tell the linker to include the following symbols so that XIU and XTU
// sections inside CRT will get built and startup/cleanup routines in
// xtestlib will get executed
//

#pragma comment( linker, "/include:_xtestlib_startup" )
#pragma comment( linker, "/include:_xtestlib_cleanup" )

//
// Tell the linker to include the following symbols so that "export table"
// of each test module will be placed and sorted in "export directory" inside
// the test harness
//

#pragma comment( linker, "/include:_memsize_ExportTableDirectory" )
#pragma comment( linker, "/include:_speedtest_ExportTableDirectory" )
#pragma comment( linker, "/include:_memtest_ExportTableDirectory" )
#pragma comment( linker, "/include:_disktest_ExportTableDirectory" )
#pragma comment( linker, "/include:_floatpt_ExportTableDirectory" )
#pragma comment( linker, "/include:_cpuid_ExportTableDirectory" )
#pragma comment( linker, "/include:_msr_ExportTableDirectory" )
#pragma comment( linker, "/include:_launcher_ExportTableDirectory" )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\buildxbe\netharness\modules.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    modules.cpp

Abstract:

    List of all test modules

Environment:

    Xbox

Revision History:

--*/


//
// Tell the linker to include the following symbols so that "export table"
// of each test module will be placed and sorted in "export directory" inside
// the test harness
//

#pragma comment( linker, "/include:_xnetbvt_ExportTableDirectory" )
#pragma comment( linker, "/include:_xnetapi_ExportTableDirectory" )
#pragma comment( linker, "/include:_xnetstress_ExportTableDirectory" )
#pragma comment( linker, "/include:_xnetstream_ExportTableDirectory" )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\buildxbe\onlineharness\modules.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    modules.cpp

Abstract:

    List of all test modules

--*/


//
// Tell the linker to include the following symbols so that "export table"
// of each test module will be placed and sorted in "export directory" inside
// the test harness
//

#pragma comment( linker, "/include:_xnetbvt_ExportTableDirectory" )
#pragma comment( linker, "/include:_xnetapi_ExportTableDirectory" )
#pragma comment( linker, "/include:_xnetstress_ExportTableDirectory" )
#pragma comment( linker, "/include:_xnetstream_ExportTableDirectory" )
#pragma comment( linker, "/include:_XAuthBVT_ExportTableDirectory" )
#pragma comment( linker, "/include:_XMatchBVT_ExportTableDirectory" )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\buildxbe\hwharness\main.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    main.cpp

Abstract:

    Entry point and initialization routines for test harness

Environment:

    Xbox

Revision History:

--*/
#include <xtl.h>
#include <xtestlib.h>
#include <xlog.h>
#include <xlogconio.h>


extern "C"
DWORD
WINAPI
HarnessEntryPoint(VOID);


void __cdecl main() {
	WIN32_FIND_DATA FileData; 
	HANDLE hSearch; 
	char SourceFile[MAX_PATH]; 
	char DestFile[MAX_PATH];
	BOOL bRet;

	char OutStr[256];
	
	// copy testini.ini - will not copy if t:\testini.ini exists
	CopyFile("d:\\testini.ini", "t:\\testini.ini", TRUE);


	// check for mmstress media in t:
	hSearch = FindFirstFile("t:\\media\\audio", &FileData);
	if(hSearch == INVALID_HANDLE_VALUE) {
		// media not found, copy from d:
		FindClose(hSearch);
		hSearch = FindFirstFile("d:\\mmstress\\media\\audio\\pcm\\*.wav", &FileData);
		if(hSearch == INVALID_HANDLE_VALUE) {
			xDebugStringA("No mmstress media files, mmstress will not run\n");
		} else {
			xDebugStringA("Copying mmstress media files...");

			// Create Directories
			bRet = CreateDirectory("t:\\media", NULL);
			if(!bRet) {
				wsprintfA(OutStr, "CreateDirectory(t:\\media) FAILED LastError = %d\n", GetLastError());
				xDebugStringA(OutStr);
				Sleep(INFINITE);
			}

			bRet = CreateDirectory("t:\\media\\audio", NULL);
			if(!bRet) {
				wsprintfA(OutStr, "CreateDirectory(t:\\media\\audio) FAILED LastError = %d\n", GetLastError());
				xDebugStringA(OutStr);
				Sleep(INFINITE);
			}

			bRet = CreateDirectory("t:\\media\\audio\\pcm", NULL);
			if(!bRet) {
				wsprintfA(OutStr, "CreateDirectory(t:\\media\\audio\\pcm) FAILED LastError = %d\n", GetLastError());
				xDebugStringA(OutStr);
				Sleep(INFINITE);
			}

			bRet = CreateDirectory("t:\\media\\audio\\wma", NULL);
			if(!bRet) {
				wsprintfA(OutStr, "CreateDirectory(t:\\media\\audio\\wma) FAILED LastError = %d\n", GetLastError());
				xDebugStringA(OutStr);
				Sleep(INFINITE);
			}


			// Copy pcm files
			do {
				// Source file name
				lstrcpyA(SourceFile, "d:\\mmstress\\media\\audio\\pcm\\");
				lstrcatA(SourceFile, FileData.cFileName);

				//lstrcpyA(OutStr, "Source: ");
				//lstrcatA(OutStr, SourceFile);
				//lstrcatA(OutStr, "\n");
				//xDebugStringA(OutStr);

				// Destination File
				lstrcpyA(DestFile, "t:\\media\\audio\\pcm\\");
				lstrcatA(DestFile, FileData.cFileName);

				//lstrcpyA(OutStr, "Destination: ");
				//lstrcatA(OutStr, DestFile);
				//lstrcatA(OutStr, "\n");
				//xDebugStringA(OutStr);

				bRet = CopyFile(SourceFile, DestFile, FALSE);
				if(!bRet) {
					wsprintfA(OutStr, "CopyFileFAILED: LastError = %d\n", GetLastError());
					OutputDebugStringA(OutStr);
					Sleep(INFINITE);
				}

			} while(FindNextFile(hSearch, &FileData));
			FindClose(hSearch);

			// Copy wma files
			hSearch = FindFirstFile("d:\\mmstress\\media\\audio\\wma\\*.wma", &FileData);
			do {
				// Source file name
				lstrcpyA(SourceFile, "d:\\mmstress\\media\\audio\\wma\\");
				lstrcatA(SourceFile, FileData.cFileName);

				//lstrcpyA(OutStr, "Source: ");
				//lstrcatA(OutStr, SourceFile);
				//lstrcatA(OutStr, "\n");
				//xDebugStringA(OutStr);

				// Destination File
				lstrcpyA(DestFile, "t:\\media\\audio\\wma\\");
				lstrcatA(DestFile, FileData.cFileName);
				
				//lstrcpyA(OutStr, "Destination: ");
				//lstrcatA(OutStr, DestFile);
				//lstrcatA(OutStr, "\n");
				//xDebugStringA(OutStr);

				bRet = CopyFile(SourceFile, DestFile, FALSE);
				if(!bRet) {
					wsprintfA(OutStr, "CopyFileFAILED: LastError = %d\n", GetLastError());
					OutputDebugStringA(OutStr);
					Sleep(INFINITE);
				}
			} while(FindNextFile(hSearch, &FileData));
			FindClose(hSearch);
			xDebugStringA("Done\n");
		}
	} else {
		FindClose(hSearch);
		xDebugStringA("mmstress media files present\n");
	}

   	// Determine console output from ini file
	gbConsoleOut = FALSE;

    // Call main routine of the tets harness library in harnesslib.lib
    HarnessEntryPoint();
}


//
// Tell the linker to include the following symbols so that XIU and XTU
// sections inside CRT will get built and startup/cleanup routines in
// xtestlib will get executed
//
#pragma comment( linker, "/include:_chessbrd_ExportTableDirectory" )
#pragma comment( linker, "/include:_clockwrk_ExportTableDirectory" )
#pragma comment( linker, "/include:_cpuid_ExportTableDirectory" )

#pragma comment( linker, "/include:_DolphinClassic_ExportTableDirectory" )
// #pragma comment( linker, "/include:_Dolphin_ExportTableDirectory" )
#pragma comment( linker, "/include:_dvdauth_ExportTableDirectory" )
#pragma comment( linker, "/include:_dvdecc_ExportTableDirectory" )
#pragma comment( linker, "/include:_dvdperf_ExportTableDirectory" )
#pragma comment( linker, "/include:_dvdservopage_ExportTableDirectory" )

#pragma comment( linker, "/include:_hawk_ExportTableDirectory" )
#pragma comment( linker, "/include:_hdperf_ExportTableDirectory" )
// #pragma comment( linker, "/include:_hdperf_ll_ExportTableDirectory" )
// #pragma comment( linker, "/include:_hdperf_sw_ExportTableDirectory" )

#pragma comment( linker, "/include:_idelog_ExportTableDirectory" )

// #pragma comment( linker, "/include:_floatpt_ExportTableDirectory" )

#pragma comment( linker, "/include:_launcher_ExportTableDirectory" )

#pragma comment( linker, "/include:_mempat_ExportTableDirectory" )
#pragma comment( linker, "/include:_memsize_ExportTableDirectory" )
#pragma comment( linker, "/include:_memtest_ExportTableDirectory" )
#pragma comment( linker, "/include:_memval_ExportTableDirectory" )
#pragma comment( linker, "/include:_misorbit_ExportTableDirectory" )
#pragma comment( linker, "/include:_mmStress_ExportTableDirectory" )
#pragma comment( linker, "/include:_msr_ExportTableDirectory" )
#pragma comment( linker, "/include:_mu_ExportTableDirectory" )

#pragma comment( linker, "/include:_netdata_ExportTableDirectory" )

#pragma comment( linker, "/include:_rumble_ExportTableDirectory" )

#pragma comment( linker, "/include:_sdstress_ExportTableDirectory" )
#pragma comment( linker, "/include:_speedtest_ExportTableDirectory" )

#pragma comment( linker, "/include:_xtestlib_startup" )
#pragma comment( linker, "/include:_xtestlib_cleanup" )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\include\xbfont.h ===
//-----------------------------------------------------------------------------
// File: XBFont.h
//
// Desc: Texture-based font class. This class reads .abc font files that are
//       generated by the FontMaker tool. These .abc files are used to create
//       a texture with all the font's glyph, and also extract information on
//       the dimensions of each glyph.
//
//       Once created, this class is used to render text in a 3D scene with the
//       following function:
//          DrawText( fScreenY, fScreenSpaceY, dwTextColor, strText,
//                    dwJustificationFlags );
//
//       For performance, you can batch mulitple DrawText calls together
//       between Begin() and End() calls, as in the following example:
//          pFont->Begin();
//          pFont->DrawText( ... );
//          pFont->DrawText( ... );
//          pFont->DrawText( ... );
//          pFont->End();
//
//       The size (extent) of the text can be computed without rendering with
//       the following function:
//          GetTextExtent( strText, pfReturnedWidth, pfReturnedHeight,
//                         bComputeExtentUsingFirstLineOnly );
//
//       Finally, the font class can create a texture to hold rendered text,
//       which is useful for static text that must be rendered for many
//       frames, or can even be used within a 3D scene. (For instance, for a
//       player's name on a jersey.) Use the following function for this:
//          CreateTexture( strText, d3dTextureFormat );
//
//       See the XDK docs for more information.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       02.18.01 - Changes for March XDK release
//       04.15.01 - Using packed resources for May XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBFONT_H
#define XBFONT_H
#include "XBResource.h"
#include "XBUtil.h"




//-----------------------------------------------------------------------------
// Number of vertex buffers for rendering text. Having this number be greater
// than 1 can reduce potential stalling of the GPU.
//-----------------------------------------------------------------------------
#define NUM_FONT_BUFFERS 2



//-----------------------------------------------------------------------------
// Flags for the CXBFont::DrawText() function
//-----------------------------------------------------------------------------
#define XBFONT_LEFT     0x00000000
#define XBFONT_RIGHT    0x00000001
#define XBFONT_CENTER_X 0x00000002
#define XBFONT_CENTER_Y 0x00000004




//-----------------------------------------------------------------------------
// Custom vertex type for rendering text
//-----------------------------------------------------------------------------
struct XBFONTVERTEX 
{ 
    D3DXVECTOR4 p;
    DWORD       color;
    FLOAT       tu, tv; 
};

#define D3DFVF_XBFONTVERTEX (D3DFVF_XYZRHW|D3DFVF_DIFFUSE|D3DFVF_TEX1)




//-----------------------------------------------------------------------------
// Name: struct GLYPH_ATTR
// Desc: Structure to hold information about one glyph (font character image)
//-----------------------------------------------------------------------------
struct GLYPH_ATTR
{
    FLOAT left, top, right, bottom; // Texture coordinates for the image
    SHORT wOffset;                  // Pixel offset for glyph start
    SHORT wWidth;                   // Pixel width of the glyph
    SHORT wAdvance;                 // Pixels to advance after the glyph
};




//-----------------------------------------------------------------------------
// Name: class CXBFont
// Desc: Class to implement texture-based font rendering. A .tga image file of 
//       the pre-rendered font is used to create the texture. A .abc file
//       contains information for spacing the font characters (aka glyphs).
//-----------------------------------------------------------------------------
class CXBFont
{
public:
    // Font and texture dimensions
    DWORD         m_dwFontHeight;
    DWORD         m_dwTexWidth;
    DWORD         m_dwTexHeight;

    // Unicode ranges
    WCHAR         m_cLowChar;
    WCHAR         m_cHighChar;

    // Glyph data for the font
    DWORD         m_dwNumGlyphs;
    GLYPH_ATTR*   m_Glyphs;

    // D3D rendering objects
    CXBPackedResource       m_xprResource;
    LPDIRECT3DDEVICE8       m_pd3dDevice;
    LPDIRECT3DTEXTURE8      m_pTexture;
    LPDIRECT3DVERTEXBUFFER8 m_pVBs[NUM_FONT_BUFFERS];
    LPDIRECT3DVERTEXBUFFER8 m_pVB;
    DWORD                   m_dwCurrentBuffer;
    XBFONTVERTEX*           m_pVertices;
    DWORD                   m_dwNumQuads;
    DWORD                   m_dwNestedBeginCount;
    BOOL                    m_bTextureFromFile;

    // Internal call to trigger rendering of the vertex buffer
    HRESULT Render();

    // Access functions for debugging purposes
    LPDIRECT3DTEXTURE8 GetTexture() const    { return m_pTexture; }
    DWORD              GetFontHeight() const { return m_dwFontHeight; }

public:
    // Constructor/destructor
    CXBFont();
    ~CXBFont();

    // Functions to create and destroy the internal objects
    HRESULT Create( LPDIRECT3DDEVICE8 pd3dDevice, 
                    const CHAR* strFontResourceFileName );
    HRESULT Destroy();

    // Replaces invalid (outside the valid glyph range) characters in a string
    VOID    ReplaceInvalidChars( WCHAR* strUpdate, WCHAR cReplacement ) const;

    // Returns the dimensions of a text string
    HRESULT GetTextExtent( const WCHAR* strText, FLOAT* pWidth, 
                           FLOAT* pHeight, BOOL bFirstLineOnly=FALSE ) const;

    // Function to create a texture containing rendered text
    LPDIRECT3DTEXTURE8 CreateTexture( const WCHAR* strText, 
                                      D3DCOLOR dwBackgroundColor = 0x00000000,
                                      D3DCOLOR dwTextColor = 0xffffffff,
                                      D3DFORMAT d3dFormat = D3DFMT_LIN_A8R8G8B8 );

    // Public calls to render text. Callers can simply call DrawText(), but for
    // performance, they should batch multople calls together, bracketed by 
    // calls to Begin() and End().
    HRESULT Begin();
    HRESULT DrawText( FLOAT sx, FLOAT sy, DWORD dwColor, 
                      const WCHAR* strText, DWORD dwFlags=0L );
    HRESULT End();
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\include\xbhelp.h ===
//-----------------------------------------------------------------------------
// File: XBHelp.h
//
// Desc: Support class for rendering a help image, which is an image of an Xbox
//       gamepad, with labelled callouts to each of the gamepad's controls.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       03.06.01 - Changes for April XDK release
//       04.15.01 - Using packed resources for May XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBHELP_H
#define XBHELP_H
#include "XBFont.h"
#include "XBResource.h"
#include "XBUtil.h"




//-----------------------------------------------------------------------------
// Name: struct XBHELP_CALLOUT
// Desc: Structure for callout information, used to label controls when
//       rendering an image of an Xbox gamepad. An app will define an array of
//       of these, one for each gamepad control used.
//-----------------------------------------------------------------------------
struct XBHELP_CALLOUT
{
    WORD     wControl;    // An index to identify a control, as enum'ed below
    WORD     wPlacement;  // An offset to pick from one of the possible placements
    WCHAR*   strText;     // Text to draw when rendering this callout
};




//-----------------------------------------------------------------------------
// Name: class CXBHelp
// Desc: Class for rendering a help image of a gamepad with labelled callouts.
//-----------------------------------------------------------------------------
class CXBHelp
{
    CXBPackedResource       m_xprResource;
    LPDIRECT3DDEVICE8       m_pd3dDevice;
    LPDIRECT3DTEXTURE8      m_pGamepadTexture;
    LPDIRECT3DVERTEXBUFFER8 m_pVB;

public:
    // Constructor/destructor
    CXBHelp();
    ~CXBHelp();

    // Functions to create and destroy the internal objects
    HRESULT Create( LPDIRECT3DDEVICE8 pd3dDevice, CHAR* pResource );
    HRESULT Destroy();

    // Renders the help screen
    HRESULT Render( CXBFont* pFont, XBHELP_CALLOUT* tags, DWORD dwNumCallouts );
};




//-----------------------------------------------------------------------------
// A bunch of constants used to identify callout positions
//-----------------------------------------------------------------------------
enum
{   
    XBHELP_LEFTSTICK,
    XBHELP_LEFTSTICK_LINEEND_1, XBHELP_LEFTSTICK_TEXTPOS_1,
    XBHELP_LEFTSTICK_LINEEND_2, XBHELP_LEFTSTICK_TEXTPOS_2,

    XBHELP_RIGHTSTICK,
    XBHELP_RIGHTSTICK_LINEEND_1, XBHELP_RIGHTSTICK_TEXTPOS_1,
    XBHELP_RIGHTSTICK_LINEEND_2, XBHELP_RIGHTSTICK_TEXTPOS_2,

    XBHELP_DPAD,
    XBHELP_DPAD_LINEEND_1, XBHELP_DPAD_TEXTPOS_1,
    XBHELP_DPAD_LINEEND_2, XBHELP_DPAD_TEXTPOS_2,

    XBHELP_BACK_BUTTON,
    XBHELP_BACK_BUTTON_LINEEND_1, XBHELP_BACK_BUTTON_TEXTPOS_1,
    XBHELP_BACK_BUTTON_LINEEND_2, XBHELP_BACK_BUTTON_TEXTPOS_2,

    XBHELP_START_BUTTON,
    XBHELP_START_BUTTON_LINEEND_1, XBHELP_START_BUTTON_TEXTPOS_1,
    XBHELP_START_BUTTON_LINEEND_2, XBHELP_START_BUTTON_TEXTPOS_2,

    XBHELP_X_BUTTON,
    XBHELP_X_BUTTON_LINEEND_1, XBHELP_X_BUTTON_TEXTPOS_1,
    XBHELP_X_BUTTON_LINEEND_2, XBHELP_X_BUTTON_TEXTPOS_2,

    XBHELP_Y_BUTTON,
    XBHELP_Y_BUTTON_LINEEND_1, XBHELP_Y_BUTTON_TEXTPOS_1,
    XBHELP_Y_BUTTON_LINEEND_2, XBHELP_Y_BUTTON_TEXTPOS_2,

    XBHELP_A_BUTTON,
    XBHELP_A_BUTTON_LINEEND_1, XBHELP_A_BUTTON_TEXTPOS_1,
    XBHELP_A_BUTTON_LINEEND_2, XBHELP_A_BUTTON_TEXTPOS_2,

    XBHELP_B_BUTTON,
    XBHELP_B_BUTTON_LINEEND_1, XBHELP_B_BUTTON_TEXTPOS_1,
    XBHELP_B_BUTTON_LINEEND_2, XBHELP_B_BUTTON_TEXTPOS_2,

    XBHELP_WHITE_BUTTON,
    XBHELP_WHITE_BUTTON_LINEEND_1, XBHELP_WHITE_BUTTON_TEXTPOS_1,
    XBHELP_WHITE_BUTTON_LINEEND_2, XBHELP_WHITE_BUTTON_TEXTPOS_2,

    XBHELP_BLACK_BUTTON,
    XBHELP_BLACK_BUTTON_LINEEND_1, XBHELP_BLACK_BUTTON_TEXTPOS_1,
    XBHELP_BLACK_BUTTON_LINEEND_2, XBHELP_BLACK_BUTTON_TEXTPOS_2,

    XBHELP_LEFT_BUTTON,
    XBHELP_LEFT_BUTTON_LINEEND_1, XBHELP_LEFT_BUTTON_TEXTPOS_1,
    XBHELP_LEFT_BUTTON_LINEEND_2, XBHELP_LEFT_BUTTON_TEXTPOS_2,

    XBHELP_RIGHT_BUTTON,
    XBHELP_RIGHT_BUTTON_LINEEND_1, XBHELP_RIGHT_BUTTON_TEXTPOS_1,
    XBHELP_RIGHT_BUTTON_LINEEND_2, XBHELP_RIGHT_BUTTON_TEXTPOS_2,

    XBHELP_MISC_CALLOUT,
    XBHELP_MISC_CALLOUT_LINEEND_1, XBHELP_MISC_CALLOUT_TEXTPOS_1,
    XBHELP_MISC_CALLOUT_LINEEND_2, XBHELP_MISC_CALLOUT_TEXTPOS_2,
};




//-----------------------------------------------------------------------------
// Placement options for each callout, used as an offset into the enumerated
// list above.
//-----------------------------------------------------------------------------
#define XBHELP_PLACEMENT_CUSTOM 0   // For future implementation
#define XBHELP_PLACEMENT_1      1   // Callout has one line of text
#define XBHELP_PLACEMENT_2      2   // Callout has two lines of text




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\buildxbe\syncsrv\main.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 2000 Microsoft Corporation

Module Name:

  main.c

Abstract:

  This module synchronizes test machines

Author:

  Steven Kehrli (steveke) 17-Jul-2000

Environment:

  XBox

Revision History:

------------------------------------------------------------------------------*/

#include <xtl.h>



int WINAPI NetsyncMain (HINSTANCE, HINSTANCE, LPWSTR, int);

void __cdecl main()
{
    NetsyncMain(NULL, NULL, NULL, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\include\XBPerf.h ===
//-----------------------------------------------------------------------------
// File: XBPerf.h
//
// Desc: Sample to show off tri-stripping performance results
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>




//-----------------------------------------------------------------------------
// Name: XBPerf_CalcCacheHits()
// Desc: Calculate the number of cache hits and degenerate triangles
//-----------------------------------------------------------------------------
HRESULT XBPerf_CalcCacheHits( D3DPRIMITIVETYPE dwPrimType, DWORD dwVertexSize,
						      WORD* pIndices, DWORD dwNumIndices,
						      DWORD* pdwNumDegenerateTris,
						      DWORD* pdwNumCacheHits,
						      DWORD* pdwNumPagesCrossed );




//-----------------------------------------------------------------------------
// Name: XBPerf_GetCpuSpeed()
// Desc: Returns a calculation of the CPU speed.
//-----------------------------------------------------------------------------
double XBPerf_GetCpuSpeed();
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\buildxbe\syncsrv\modules.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  modules.c

Abstract:

  Includes all netsync modules

Author:

  Steven Kehrli (steveke) 13-Nov-2000

------------------------------------------------------------------------------*/

// Have the linker include the following symbols so the export table of each module will be included in the export directory

#pragma comment( linker, "/include:_xnetbvt_xbox_NetsyncExportTableDirectory" )
#pragma comment( linker, "/include:_xnetapi_xbox_NetsyncExportTableDirectory" )
#pragma comment( linker, "/include:_xnetstress_xbox_NetsyncExportTableDirectory" )
#pragma comment( linker, "/include:_xboxkeys_xbox_NetsyncExportTableDirectory" )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\include\XBResource.h ===
//-----------------------------------------------------------------------------
// File: XBResource.h
//
// Desc: Loads resources from an XPR (Xbox Packed Resource) file.  
//
// Hist: 03.12.01 - New for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBRESOURCE_H
#define XBRESOURCE_H



//-----------------------------------------------------------------------------
// Name: XBResource_SizeOf()
// Desc: Determines the byte size of a D3DResource
//-----------------------------------------------------------------------------
DWORD XBResource_SizeOf( LPDIRECT3DRESOURCE8 pResource );





//-----------------------------------------------------------------------------
// Name: struct XBRESOURCE
// Desc: Name tag for resources. An app may initialize this structure, and pass
//       it to the resource's Create() function. From then on, the app may call
//       GetResource() to retrieve a resource using an ascii name.
//-----------------------------------------------------------------------------
struct XBRESOURCE
{
    CHAR* strName;
    DWORD dwOffset;
};





//-----------------------------------------------------------------------------
// Name: class CXBPackedResource
// Desc: 
//-----------------------------------------------------------------------------
class CXBPackedResource
{
protected:
    BYTE*       m_pSysMemData;    // Alloc'ed mem for resource headers etc.
    BYTE*       m_pVidMemData;    // Alloc'ed mem for resource data, etc.

    DWORD       m_dwNumResources; // Number of loaded resources
 
    XBRESOURCE* m_pResourceTags;  // Tags to associate names with the resources

public:
    // Loads the resources out of the specified bundle
    HRESULT Create( LPDIRECT3DDEVICE8 pd3dDevice, const CHAR* strFilename, 
                    DWORD dwNumResources, XBRESOURCE* pResourceTags = NULL );

    VOID Destroy();

    // Functions to retrieve resources by their offset
    VOID* GetData( DWORD dwOffset ) const
    { return &m_pSysMemData[dwOffset]; }

    LPDIRECT3DRESOURCE8 GetResource( DWORD dwOffset ) const
    { return (LPDIRECT3DRESOURCE8)GetData(dwOffset); }

    LPDIRECT3DTEXTURE8 GetTexture( DWORD dwOffset ) const
    { return (LPDIRECT3DTEXTURE8)GetData( dwOffset ); }

    LPDIRECT3DCUBETEXTURE8 GetCubemap( DWORD dwOffset ) const
    { return (LPDIRECT3DCUBETEXTURE8)GetData( dwOffset ); }

    LPDIRECT3DVOLUMETEXTURE8 GetVolumeTexture( DWORD dwOffset ) const
    { return (LPDIRECT3DVOLUMETEXTURE8)GetData( dwOffset ); }

    LPDIRECT3DVERTEXBUFFER8 GetVertexBuffer( DWORD dwOffset ) const
    { return (LPDIRECT3DVERTEXBUFFER8)GetData( dwOffset ); }

    // Functions to retrieve resources by their name
    VOID* GetData( const CHAR* strName ) const;

    LPDIRECT3DRESOURCE8 GetResource( const CHAR* strName ) const
    { return (LPDIRECT3DRESOURCE8)GetData( strName ); }

    LPDIRECT3DTEXTURE8 GetTexture( const CHAR* strName ) const
    { return (LPDIRECT3DTEXTURE8)GetResource( strName ); }

    LPDIRECT3DCUBETEXTURE8 GetCubemap( const CHAR* strName ) const
    { return (LPDIRECT3DCUBETEXTURE8)GetResource( strName ); }

    LPDIRECT3DVOLUMETEXTURE8 GetVolumeTexture( const CHAR* strName ) const
    { return (LPDIRECT3DVOLUMETEXTURE8)GetResource( strName ); }

    LPDIRECT3DVERTEXBUFFER8 GetVertexBuffer( const CHAR* strName ) const
    { return (LPDIRECT3DVERTEXBUFFER8)GetResource( strName ); }

    // Constructor/destructor
    CXBPackedResource();
    ~CXBPackedResource();
};




#endif XBRESOURCE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\include\XbStopWatch.h ===
//-----------------------------------------------------------------------------
// File: XbStopWatch.h
//
// Desc: StopWatch object using QueryPerformanceCounter
//
// Hist: 01.19.01 - New for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBSTOPWATCH_H
#define XBSTOPWATCH_H

#include <xtl.h>




//-----------------------------------------------------------------------------
// Name: class CXBStopWatch
// Desc: Simple timing object using stopwatch metaphor
//-----------------------------------------------------------------------------
class CXBStopWatch
{
    FLOAT    m_fTimerPeriod;        // seconds per tick (1/Hz)
    LONGLONG m_nStartTick;          // time watch last started/reset
    LONGLONG m_nPrevElapsedTicks;   // time watch was previously running
    BOOL     m_bIsRunning;          // TRUE if watch is running

public:

    explicit CXBStopWatch( BOOL bStartWatch = TRUE );

    VOID  Start();
    VOID  StartZero();
    VOID  Stop();
    VOID  Reset();

    BOOL  IsRunning() const;
    FLOAT GetElapsedSeconds() const;
    FLOAT GetElapsedMilliseconds() const;

private:

    LONGLONG GetTicks() const;

};

#endif // XBSTOPWATCH_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\include\xbapp.h ===
//-----------------------------------------------------------------------------
// File: XBApp.h
//
// Desc: Application class for the XBox samples.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       02.19.01 - Changes for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBAPP_H
#define XBAPP_H

#include <xtl.h>
#include <xgraphics.h>
#include <stdio.h>
#include "XBInput.h"
#include "XBUtil.h"




//-----------------------------------------------------------------------------
// Global access to common members
//-----------------------------------------------------------------------------
extern LPDIRECT3DDEVICE8 g_pd3dDevice;




//-----------------------------------------------------------------------------
// Error codes
//-----------------------------------------------------------------------------
#define XBAPPERR_MEDIANOTFOUND       0x82000003




//-----------------------------------------------------------------------------
// Name: class CXBApplication
// Desc: A base class for creating sample Xbox applications. To create a simple
//       Xbox application, simply derive this class and override the following
//       functions:
//          Initialize()          - To initialize the device-dependant objects
//          FrameMove()           - To animate the scene
//          Render()              - To render the scene
//-----------------------------------------------------------------------------
class CXBApplication
{
protected:
    // Main objects used for creating and rendering the 3D scene
    D3DPRESENT_PARAMETERS m_d3dpp;
    LPDIRECT3D8           m_pD3D;              // The D3D enumerator object
    LPDIRECT3DDEVICE8     m_pd3dDevice;        // The D3D rendering device
    LPDIRECT3DSURFACE8    m_pBackBuffer;       // The backbuffer
    LPDIRECT3DSURFACE8    m_pDepthBuffer;      // The depthbuffer

    // Variables for timing
    FLOAT      m_fTime;             // Current absolute time in seconds
    FLOAT      m_fElapsedTime;      // Elapsed absolute time since last frame
    FLOAT      m_fAppTime;          // Current app time in seconds
    FLOAT      m_fElapsedAppTime;   // Elapsed app time since last frame
    BOOL       m_bPaused;           // Whether app time is paused by user
    FLOAT      m_fFPS;              // Instanteous frame rate
    WCHAR      m_strFrameRate[20];  // Frame rate written to a string
    HANDLE     m_hFrameCounter;     // Handle to framerate perf counter

    // Members to init the XINPUT devices.
    XDEVICE_PREALLOC_TYPE* m_InputDeviceTypes;
    DWORD                  m_dwNumInputDeviceTypes;
    XBGAMEPAD*             m_Gamepad;
    XBGAMEPAD              m_DefaultGamepad;

    // Helper functions
    HRESULT RenderGradientBackground( DWORD dwTopColor, DWORD dwBottomColor );

    // Overridable functions for the 3D scene created by the app
    virtual HRESULT Initialize()            { return S_OK; }
    virtual HRESULT FrameMove()             { return S_OK; }
    virtual HRESULT Render()                { return S_OK; }
    virtual HRESULT Cleanup()               { return S_OK; }

public:
    // Functions to create, run, and clean up the application
    HRESULT Create();
    INT     Run();
    VOID    Destroy();

    // Internal constructor
    CXBApplication();
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\include\XbConfig.h ===
//-----------------------------------------------------------------------------
// File: XbConfig.h
//
// Desc: Config object wraps XQueryValue
//
// Hist: 03.02.01 - New for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBCONFIG_H
#define XBCONFIG_H

#include <xtl.h>




//-----------------------------------------------------------------------------
// Name: class CXBConfig
// Desc: Xbox configuration parameters
//-----------------------------------------------------------------------------
class CXBConfig
{
    static DWORD mLanguage; // cached for speed

public:

    static DWORD GetLanguage();

    // Localized dates, times and numbers
    static VOID FormatDateTime( const FILETIME&, CHAR* strDate, CHAR* strTime,
                                BOOL bIncludeSeconds = FALSE );
    static VOID FormatInt( INT, CHAR* strNumber );
    static VOID FormatFloat( DOUBLE, CHAR* strNumber, INT nCount = 2,
                             BOOL bThousandsSep = TRUE );

    // Symbols based on current language
    static CHAR GetDecimalSymbol();
    static CHAR GetThousandsSeparator();
};




#endif // XBCONFIG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\include\XbMemUnit.h ===
//-----------------------------------------------------------------------------
// File: XbMemUnit.h
//
// Desc: Memory unit object wraps XGetDeviceChanges( XDEVICE_TYPE_MEMORY_UNIT )
//       and XMount/UnmountMU
//
// Hist: 01.29.01 - New for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBMEMUNIT_H
#define XBMEMUNIT_H

#include <xtl.h>




//-----------------------------------------------------------------------------
// Name: class CXBMemUnit
// Desc: Xbox memory unit
//-----------------------------------------------------------------------------
class CXBMemUnit
{
    DWORD   m_dwPort;           // XDEVICE_PORT0-3
    DWORD   m_dwSlot;           // XDEVICE_TOP_SLOT or XDEVICE_BOTTOM_SLOT
    CHAR    m_chLogicalDrive;   // MU drive letter alias

public:

    CXBMemUnit();
    explicit CXBMemUnit( DWORD dwPort, DWORD dwSlot, DWORD& dwError );
    CXBMemUnit( const CXBMemUnit& );
    CXBMemUnit& operator=( const CXBMemUnit& );
    virtual ~CXBMemUnit();

    BOOL  Mount( DWORD dwPort, DWORD dwSlot, DWORD& dwError );
    VOID  Unmount();

    BOOL  IsMounted() const;
    CHAR  GetDrive() const;
    DWORD GetPort() const;
    DWORD GetSlot() const;

    static DWORD GetMemUnitSnapshot();
    static BOOL  GetMemUnitChanges( DWORD& dwInsertions, DWORD& dwRemovals );

    static DWORD GetMemUnitMask( DWORD dwMuIndex );
    static DWORD GetMemUnitPort( DWORD dwMuIndex );
    static DWORD GetMemUnitSlot( DWORD dwMuIndex );
};

#endif // XBMEMUNIT_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\include\XbSavedGame.h ===
//-----------------------------------------------------------------------------
// File: XbSavedGame.h
//
// Desc: Saved game container
//
// Hist: 02.05.01 - New for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBSAVED_GAME_H
#define XBSAVED_GAME_H

#include <xtl.h>




//-----------------------------------------------------------------------------
// Name: class CXBSavedGame
// Desc: Xbox saved game container
//-----------------------------------------------------------------------------
class CXBSavedGame
{

    WCHAR         m_strName[ MAX_GAMENAME ]; // name from container
    CHAR          m_strDir[ MAX_PATH ];      // folder
    mutable DWORD m_dwSize;                  // size in bytes
    mutable LPDIRECT3DTEXTURE8 m_pImage;     // game image
    mutable BOOL  m_bIsValidImage;           // TRUE if SaveImage.xbx is valid format

    union
    {
        mutable FILETIME  m_ftCreationTime;  // save date/time
        mutable ULONGLONG m_qwCreationTime;
    };

public:

    CXBSavedGame();
    CXBSavedGame( const CXBSavedGame& );
    CXBSavedGame& operator =( const CXBSavedGame& );
    ~CXBSavedGame();
    explicit CXBSavedGame( const _XGAME_FIND_DATA& );
    CXBSavedGame( const WCHAR* strName, const CHAR* strDir );

    BOOL  CreateGame( CHAR chDestDrive, const WCHAR* strName );
    BOOL  OpenGame( CHAR chDestDrive, const WCHAR* strName,
                    DWORD dwOpenDisposition );
    BOOL  DeleteGame();
    BOOL  IsEmpty() const;
    CHAR  GetDrive() const;
    DWORD GetSize() const;

    FILETIME     GetCreationTime() const;
    ULONGLONG    GetCreationQword() const;
    BOOL         GetImage( LPDIRECT3DTEXTURE8* ) const;
    BOOL         SaveImage( const LPDIRECT3DTEXTURE8 );
    const WCHAR* GetName() const;
    const CHAR*  GetDirectory() const;

private:

    VOID Init();
    static DWORD GetDirSize( const CHAR* strDir, DWORD dwClusterSize );

};

#endif // XBSAVED_GAME_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\include\xbsound.h ===
//-----------------------------------------------------------------------------
// File: XBSound.h
//
// Desc: Helper class for reading a .wav file and playing it in a DirectSound
//       buffer.
//
// Hist: 12.15.00 - New for December XDK release
//       02.15.01 - Updated for March XDK release
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBSOUND_H
#define XBSOUND_H

#include <xtl.h>




//-----------------------------------------------------------------------------
// Name: RIFFHEADER
// Desc: For parsing WAV files
//-----------------------------------------------------------------------------
struct RIFFHEADER
{
    FOURCC  fccChunkId;
    DWORD   dwDataSize;
};

#define RIFFCHUNK_FLAGS_VALID   0x00000001




//-----------------------------------------------------------------------------
// Name: class CRiffChunk
// Desc: RIFF chunk utility class
//-----------------------------------------------------------------------------
class CRiffChunk
{
    FOURCC            m_fccChunkId;       // Chunk identifier
    const CRiffChunk* m_pParentChunk;     // Parent chunk
    HANDLE            m_hFile;
    DWORD             m_dwDataOffset;     // Chunk data offset
    DWORD             m_dwDataSize;       // Chunk data size
    DWORD             m_dwFlags;          // Chunk flags

public:
    CRiffChunk();

    // Initialization
    VOID    Initialize( FOURCC fccChunkId, const CRiffChunk* pParentChunk,
                        HANDLE hFile );
    HRESULT Open();
    BOOL    IsValid()     { return !!(m_dwFlags & RIFFCHUNK_FLAGS_VALID); }

    // Data
    HRESULT ReadData( LONG lOffset, VOID* pData, DWORD dwDataSize );

    // Chunk information
    FOURCC  GetChunkId()  { return m_fccChunkId; }
    DWORD   GetDataSize() { return m_dwDataSize; }
};




//-----------------------------------------------------------------------------
// Name: class CWaveFile
// Desc: Wave file utility class
//-----------------------------------------------------------------------------
class CWaveFile
{
    HANDLE      m_hFile;            // File handle
    CRiffChunk  m_RiffChunk;        // RIFF chunk
    CRiffChunk  m_FormatChunk;      // Format chunk
    CRiffChunk  m_DataChunk;        // Data chunk
    
public:
    CWaveFile();
    ~CWaveFile();

    // Initialization
    HRESULT Open( const CHAR* strFileName );
    VOID    Close();

    // File format
    HRESULT GetFormat( WAVEFORMATEX* pwfxFormat, DWORD dwFormatSize );

    // File data
    HRESULT ReadSample( DWORD dwPosition, VOID* pBuffer, DWORD dwBufferSize, 
                        DWORD* pdwRead );

    // File properties
    VOID    GetDuration( DWORD* pdwDuration ) { *pdwDuration = m_DataChunk.GetDataSize(); }
};




//-----------------------------------------------------------------------------
// Name: class CSound
// Desc: Encapsulates functionality of a DirectSound buffer.
//-----------------------------------------------------------------------------
class CXBSound
{
protected:
    LPDIRECTSOUNDBUFFER  m_pDSoundBuffer;
    WAVEFORMATEX         m_WaveFormat;
    DSBUFFERDESC         m_dsbd;
    DWORD                m_dwBufferSize;

public:
    HRESULT Create( const CHAR* strFileName, DWORD dwFlags = 0L );
    HRESULT Create( const WAVEFORMATEX* pwfxFormat, DWORD dwFlags,
                    const VOID* pBuffer, DWORD dwBytes );
    VOID    Destroy();

    HRESULT Play( DWORD dwFlags = 0L ) const;
    HRESULT Stop() const;
	HRESULT SetMixBins(LPCDSMIXBINS pMixBins) const;
    HRESULT SetPosition( const D3DXVECTOR3& vPosition ) const;
    HRESULT SetVelocity( const D3DXVECTOR3& vVelocity ) const;

    CXBSound();
    ~CXBSound();
};



//-----------------------------------------------------------------------------
// Name: class CDSPImage
// Desc: Encapsulates DSP image for loading from file, downloading to DSP, etc.
//-----------------------------------------------------------------------------
class CDSPImage
{
protected:
    DWORD           m_dwImageSize;
    BYTE *          m_pbImageData;

public:
    CDSPImage();
    ~CDSPImage();

    HRESULT LoadFromFile( char * szFilename );
    HRESULT DownloadImage( LPDIRECTSOUND8 pDSound );
};
#endif // XBSOUND_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\include\XBStrip.h ===
//-----------------------------------------------------------------------------
// File: XBStrip.h
//
// Desc: Tristrip routines (which convert a mesh into a list of optimized
//       triangle strips).
//
// Hist: 02.01.01 - New for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------




//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
#define OPTIMIZE_FOR_CACHE      0x00
#define OPTIMIZE_FOR_INDICES    0x01
#define OUTPUT_TRISTRIP         0x00
#define OUTPUT_TRILIST          0x02




//-----------------------------------------------------------------------------
// Name: Stripify()
// Desc: Main stripify routine. Stripifies a mesh and returns the number of 
//       strip indices contained in ppStripIndices.
// Note: Caller must make sure to call delete[] on the ppStripIndices array
//       when finished with it.
//-----------------------------------------------------------------------------
DWORD Stripify( DWORD  dwNumTriangles,   // Number of triangles
                WORD*  pTriangles,       // Ptr to triangle indices
                DWORD* pdwNumIndices,    // Number of output indices
                WORD** ppStripIndices,   // Output indices
                DWORD  dwFlags = 0 );    // Flags controlling optimizer.



//-----------------------------------------------------------------------------
// Name: ComputeVertexPermutation()
// Desc: Re-arrange vertices so that they occur in the order that they are
//       first used. Instead of actually moving vertex data around, this
//       function returns an array that specifies where (in the new vertex
//       array) each old vertex should go. It also re-maps the strip indices
//       to use the new vertex locations.
// Note: Caller must make sure to call delete[] on the pVertexPermutation array
//       when finished with it.
//-----------------------------------------------------------------------------
VOID ComputeVertexPermutation( DWORD  dwNumStripIndices,     // Number of strip indices
                               WORD*  pStripIndices,         // Ptr to strip indices
                               DWORD  dwNumVertices,         // Number of verticess in
                               WORD** ppVertexPermutation ); // Map from orignal index to remapped index
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\include\XbStorageDevice.h ===
//-----------------------------------------------------------------------------
// File: XbStorageDevice.h
//
// Desc: Hard disk and memory unit devices. Provides save and load game
//       functionality.
//
// Hist: 01.30.01 - New for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBSTORAGE_DEVICE_H
#define XBSTORAGE_DEVICE_H

#include <xtl.h>




//-----------------------------------------------------------------------------
// Name: class CXBStorageDevice
// Desc: Xbox storage device (hard drive, MU)
//-----------------------------------------------------------------------------
class CXBStorageDevice
{

    mutable HANDLE m_hSaveGame;         // For iterating through saved games
    CHAR           m_strRootPath[4];    // "@:\" where @ is the logical drive
                                        // letter of the storage device

public:

    explicit CXBStorageDevice( CHAR chDriveLetter = 0 );
    CXBStorageDevice( const CXBStorageDevice& );
    CXBStorageDevice& operator=( const CXBStorageDevice& );
    virtual ~CXBStorageDevice();

    static CXBStorageDevice GetUserRegion();
    static CXBStorageDevice GetTitleRegion();
    static CXBStorageDevice GetUtilityRegion( BOOL fFormatClean );
    static DWORD GetBlockSize();

    CHAR  GetDrive() const;
    VOID  SetDrive( CHAR chDriveLetter );
    BOOL  IsValid() const;
    BOOL  IsUserRegion() const;
    BOOL  IsMemoryUnit() const;
    BOOL  IsTitleRegion() const;
    BOOL  IsUtilityRegion() const;
    VOID  GetName( WCHAR* strPathBuffer ) const;
    BOOL  GetSize( ULONGLONG& qwTotalBlocks, ULONGLONG& qwUsedBlocks, 
                   ULONGLONG& qwFreeBlocks ) const;
    DWORD GetSavedGameCount() const;
    DWORD GetSectorSize() const;
    DWORD GetClusterSize() const;
    DWORD GetSaveGameOverhead() const;
    DWORD GetFileBytes( DWORD ) const;
    BOOL  FindFirstSaveGame( XGAME_FIND_DATA& ) const;
    BOOL  FindNextSaveGame( XGAME_FIND_DATA& ) const;

private:

    VOID Cleanup() const;

};

#endif // XBSTORAGE_DEVICE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\include\xdppeer.h ===
#ifndef __XDPPEER_H
#define __XDPPEER_H

#include <xtl.h>
#include <dplay8.h>

extern LPDIRECTPLAY8PEER g_pDP;					// DirectPlay peer object

extern LPDIRECTPLAY8ADDRESS g_pDeviceAddress;	// device address of SP
extern LPDIRECTPLAY8ADDRESS g_pHostAddress ;	// host address of SP

extern DWORD g_dwNumPlayers;					// # of players in game
extern DWORD g_dpnidLocalPlayer;				// DPNID of local player
extern DWORD g_dpnidHost;						// DPNID of host

extern WCHAR g_wszXDPPlayerName[32];			// players name
extern WCHAR g_wszXDPSessionName[32];			// session name

// connect stuff
enum
{
	GAME_NOTCONNECTED=0,						// no network connection
	GAME_ENUMERATING,							// searching for hosts
	GAME_CONNECTING,							// connecting to a host
	GAME_CONNECTED,								// connected to a host
	GAME_HOSTING,								// hosting a game
	GAME_DISCONNECTING							// disconecting from a game
};

extern DWORD g_dwConnectStatus;

// active game list stuff
#define MAX_ACTIVEGAMES 32
typedef struct _ActiveGame
{
	DPN_APPLICATION_DESC AppDesc;
	IDirectPlay8Address	*pHostAddr;				// address of host who responded
	IDirectPlay8Address	*pDevAddr;				// device response was received on
	DWORD dwPing;								// ping time
	DWORD dwReportTime;							// last time this server reported
} ActiveGame;

// this message tells the app to delete a game from
// the game menu. hopefully it will never collide with
// any dplay message id's.
#define DPPEER_MSGID_DELETE_GAME (DPN_MSGID_OFFSET|0x0110)

#ifdef __cplusplus
extern "C" {
#endif

HRESULT XDPInit(HRESULT (WINAPI *DPMsgHandler)(void *, DWORD, void *));
void XDPShutdown();
HRESULT XDPDoWork(DWORD param);

HRESULT XDPEnumHosts(DWORD port, GUID *pGuid);
ActiveGame *XDPAddGame(DPNMSG_ENUM_HOSTS_RESPONSE *pHost);
void XDPCancelEnumHosts();
void XDPExpireGames();

HRESULT XDPCreate(DWORD port, GUID *pGuid, DWORD dwMaxPlayers, DWORD flags);
HRESULT XDPConnect(DPN_APPLICATION_DESC *pAppDesc, IDirectPlay8Address *pHostAddr, IDirectPlay8Address *pDevAddr);
HRESULT XDPDisconnect();
HRESULT XDPTerminate();

#define XDPIsConnected() (g_dwConnectStatus==GAME_CONNECTED||g_dwConnectStatus==GAME_HOSTING)

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\include\xbmesh.h ===
//-----------------------------------------------------------------------------
// File: XBMesh.h
//
// Desc: Support code for loading geometry stored in .xbg files. These files
//       typically converted from .x geometry files using the MakeXBG tool. See
//       that tool for more information.
//
//       XBG files were designed to minimalize overhead in the loading and
//       rendering process on the Xbox. The data in a .xbg file is basically
//       stored in one system memory chunk, and one video memory chunk.
//       Therefore, loading a .xbg file is simply two fread() calls followed
//       by some patchup (which turns file offsets into real pointers).
//
//       Geometry files are loaded into arrays of the following structures.
//       XBMESH_FRAME structures contain data to make a frame hierarchy (such
//       as "next" and "child" pointers, plus a transformation matrix). The
//       XMMESH_DATA structure contains data for rendering a mesh (such as
//       the vertex buffer, num of indices, etc.). Finally, the XBMESH_SUBSET
//       structure contains subset properties (materials and textures) and
//       primitive ranges (start index, index count, etc.) for each subset of
//       the data in the XBMESH_DATA structure.
//
//       To use this class, simply instantiate the class, and call Create().
//       Thereafter, the mesh can be rendered with the Render() call. Some
//       render flags are available (see below) to limit what gets rendered.
//       For instance, an app might want to render opaque subsets only, or
//       use a custom vertex shader. For truely custom control, override the
//       CXBMesh class with a new RenderCallback() function, and put any
//       custom pre-rendering code in the callback. The typical use for this
//       is to pass data to a custom vertex shader.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       03.15.01 - Mass changes (removed D3DX and .x support) for April XDK
//       04.15.01 - Using packed resources for May XDK
//       04.17.01 - 16-byte aligning matrices in the file format
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBMESH_H
#define XBMESH_H
#include "XBResource.h"
#include "XBUtil.h"




// Rendering flags. Default is no flags (0x00000000)
#define XBMESH_OPAQUEONLY      0x00000001 // Only render opaque subsets
#define XBMESH_ALPHAONLY       0x00000002 // Only render alpha subsets

#define XBMESH_NOMATERIALS     0x00000010 // Do not use mesh materials
#define XBMESH_NOTEXTURES      0x00000020 // Do not use mesh textures
#define XBMESH_NOFVF           0x00000040 // Do not use mesh FVF code


// The magic number to identify .xbg files
#define XBG_FILE_ID (((DWORD)'X'<<0)|(((DWORD)'B'<<8))|(((DWORD)'G'<<16))|(2<<24))




//-----------------------------------------------------------------------------
// Name: struct XBMESH_SUBSET
// Desc: Struct to hold data for rendering a mesh
//-----------------------------------------------------------------------------
struct XBMESH_SUBSET
{
    D3DMATERIAL8       mtrl;            // Material for this subset
    LPDIRECT3DTEXTURE8 pTexture;        // Texture
    CHAR               strTexture[64];
    DWORD              dwVertexStart;   // Range of vertices to render
    DWORD              dwVertexCount;
    DWORD              dwIndexStart;    // Range of vertex indices to render
    DWORD              dwIndexCount;
};




//-----------------------------------------------------------------------------
// Name: struct XBMESH_DATA
// Desc: Struct for mesh data
//-----------------------------------------------------------------------------
struct XBMESH_DATA
{
    D3DVertexBuffer   m_VB;            // Mesh geometry
    DWORD             m_dwNumVertices;
    D3DIndexBuffer    m_IB;
    DWORD             m_dwNumIndices;
    
    DWORD             m_dwFVF;         // Mesh vertex info
    DWORD             m_dwVertexSize;
    D3DPRIMITIVETYPE  m_dwPrimType;

    DWORD             m_dwNumSubsets;  // Subset info for rendering calls
    XBMESH_SUBSET*    m_pSubsets;
};




//-----------------------------------------------------------------------------
// Name: struct XBMESHFRAME
// Desc: Struct for building a hierarchy of meshes.
//-----------------------------------------------------------------------------
__declspec(align(16)) struct XBMESH_FRAME
{
    D3DXMATRIX        m_matTransform; // The transformation matrix for this frame
    
    XBMESH_DATA       m_MeshData;     // The mesh data belonging to this frame

    CHAR              m_strName[64];
    
    XBMESH_FRAME*     m_pChild;       // Child and sibling ptrs for the hierarchy
    XBMESH_FRAME*     m_pNext;
};




//-----------------------------------------------------------------------------
// Name: class CXBMesh
// Desc: Wrapper class for loading geoemtry files, and rendering the resulting
//       hierachy of meshes and frames.
//-----------------------------------------------------------------------------
class CXBMesh
{
    // Memory allocated during file loading. Ptrs are retained for cleanup.
    VOID* m_pAllocatedSysMem;
    VOID* m_pAllocatedVidMem;

public:
    // Hierarchy (frames and meshes) of loaded geometry
    XBMESH_FRAME* m_pMeshFrames;
    DWORD         m_dwNumFrames;

    // Internal rendering functions
    virtual HRESULT RenderFrame( LPDIRECT3DDEVICE8 pd3dDevice, XBMESH_FRAME* pMesh, 
                                 DWORD dwFlags );
    virtual HRESULT RenderMesh( LPDIRECT3DDEVICE8 pd3dDevice, XBMESH_DATA* pMesh, 
                                DWORD dwFlags );

    // Internal functions to find the radius of sphere centered at zero enclosing mesh.
    float ComputeFrameRadius(XBMESH_FRAME* pFrame, D3DXMATRIX* pParentMat);
    float ComputeMeshRadius(XBMESH_DATA* pMesh, D3DXMATRIX* pMat);
	
    // Internal functions to find the bounding box of the mesh.
    HRESULT ComputeFrameBoundingBox(XBMESH_FRAME* pFrame, D3DXMATRIX* pParentMat, D3DXVECTOR3 *pvMin, D3DXVECTOR3 *pvMax);
	HRESULT ComputeMeshBoundingBox(XBMESH_DATA* pMesh, D3DXMATRIX* pMat, D3DXVECTOR3 *pvMin, D3DXVECTOR3 *pvMax);

public:
    // Reference counting
    DWORD   m_dwRefCount;
    DWORD   AddRef()  { return ++m_dwRefCount; }
    DWORD   Release() { if( --m_dwRefCount ) return m_dwRefCount;
                        delete this; return 0L; }

public:
    // Constructor/destructor
    CXBMesh();
    virtual ~CXBMesh();

    // Creation function. Call this function to create the hierarchy of frames
    // and meshes from a geometry file.
    HRESULT Create( LPDIRECT3DDEVICE8 pd3dDevice, CHAR* strFilename,
                    CXBPackedResource* pResource = NULL );

    // Access functions
    XBMESH_FRAME* GetFrame( DWORD i ) { return &m_pMeshFrames[i]; }
    XBMESH_DATA*  GetMesh( DWORD i )  { return &m_pMeshFrames[i].m_MeshData; }

    // Overridable callback function (called before anything is rendered). 
    // This is useful for setting vertex shader constants, etc., before
    // rendering.
    virtual BOOL RenderCallback( LPDIRECT3DDEVICE8 pd3dDevice, DWORD dwSubset,
                                 XBMESH_SUBSET* pSubset, DWORD dwFlags ) { return TRUE; }
    
    // Render function. Call this function to render the hierarchy of frames
    // and meshes.
    HRESULT Render( LPDIRECT3DDEVICE8 pd3dDevice, DWORD dwFlags = 0x00000000 );

    // Function to find the radius of sphere centered at zero enclosing mesh.
    float ComputeRadius();
    // find the bounding box of all the subsets
	HRESULT ComputeBoundingBox(D3DXVECTOR3 *pvMin, D3DXVECTOR3 *pvMax);
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\include\xbinput.h ===
//-----------------------------------------------------------------------------
// File: XBInput.h
//
// Desc: Input helper functions for the XBox samples
//
// Hist: 12.15.00 - Separated from XBUtil.h for December XDK release
//       01.03.00 - Made changes for real Xbox controller
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBINPUT_H
#define XBINPUT_H




//-----------------------------------------------------------------------------
// Name: struct XBGAMEPAD
// Desc: structure for holding Gamepad data
//-----------------------------------------------------------------------------
struct XBGAMEPAD : public XINPUT_GAMEPAD
{
    // The following members are inherited from XINPUT_GAMEPAD:
    //    WORD    wButtons;
    //    BYTE    bAnalogButtons[8];
    //    SHORT   sThumbLX;
    //    SHORT   sThumbLY;
    //    SHORT   sThumbRX;
    //    SHORT   sThumbRY;

    // Thumb stick values converted to range [-1,+1]
    FLOAT      fX1;
    FLOAT      fY1;
    FLOAT      fX2;
    FLOAT      fY2;
    
    // State of buttons tracked since last poll
    WORD       wLastButtons;
    BOOL       bLastAnalogButtons[8];
    WORD       wPressedButtons;
    BOOL       bPressedAnalogButtons[8];

    // Rumble properties
    XINPUT_RUMBLE   Rumble;
    XINPUT_FEEDBACK Feedback;

    // Device properties
    XINPUT_CAPABILITIES caps;
    HANDLE     hDevice;

    // Flags for whether gamepad was just inserted or removed
    BOOL       bInserted;
    BOOL       bRemoved;
};




//-----------------------------------------------------------------------------
// Global access to gamepad devices
//-----------------------------------------------------------------------------
extern XBGAMEPAD g_Gamepads[4];




//-----------------------------------------------------------------------------
// Name: XBInput_CreateGamepads()
// Desc: Creates the gamepad devices
//-----------------------------------------------------------------------------
HRESULT XBInput_CreateGamepads( XBGAMEPAD** ppGamepads = NULL );




//-----------------------------------------------------------------------------
// Name: XBInput_GetInput()
// Desc: Processes input from the gamepads
//-----------------------------------------------------------------------------
VOID XBInput_GetInput( XBGAMEPAD* pGamepads = NULL );




#endif // XBINPUT_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\include\xdpvoice.h ===
#ifndef __XDPVOICE_H
#define __XDPVOICE_H

#include <xtl.h>
#include <dsound.h>
#include <dplay8.h>
#include <dvoice.h>

#ifdef __cplusplus
extern "C" {
#endif

#define MAX_TARGETS 64
extern DVID g_dvidTargets[MAX_TARGETS];
extern DWORD g_dwNumTargets;

HRESULT XDVInit(HRESULT (WINAPI *DVMsgHandler)(void *, DWORD, void *));

HRESULT XDVCreate(DWORD dwSessionType, GUID guidCT);
HRESULT XDVConnect(DWORD dwFlags);
HRESULT XDVDisconnect();
HRESULT XDVStopSession();
HRESULT XDVDoWork();

HRESULT XDVSetTransmitTargets();
HRESULT XDVClearTransmitTargets();
HRESULT XDVRemoveTransmitTarget(DVID dvidTarget);
HRESULT XDVAddTransmitTarget(DVID dvidTarget);

extern IDirectPlayVoiceServer *g_pDVServer;				// server object
extern IDirectPlayVoiceClient *g_pDVClient;				// client object

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\include\xfvf.h ===
//-----------------------------------------------------------------------------
// File: xfvf.h
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef __FVF_H
#define __FVF_H

#ifdef _XBOX
#include <xtl.h>
#else
#include <d3d8.h>
#endif

#define FVF_XYZDIFF (D3DFVF_XYZ|D3DFVF_DIFFUSE)
#define FVF_XYZNORM (D3DFVF_XYZ|D3DFVF_NORMAL)
#define FVF_XYZTEX1 (D3DFVF_XYZ|D3DFVF_TEX1)
#define FVF_XYZRHWTEX1 (D3DFVF_XYZRHW|D3DFVF_TEX1)
#define FVF_XYZRHWDIFF (D3DFVF_XYZRHW|D3DFVF_DIFFUSE)
#define FVF_XYZDIFFTEX1 (D3DFVF_XYZ|D3DFVF_DIFFUSE|D3DFVF_TEX1)

#define FVF_XYZNORMTEX1 (D3DFVF_XYZ|D3DFVF_NORMAL|D3DFVF_TEX1)
#define FVF_XYZNORMDIFF (D3DFVF_XYZ|D3DFVF_NORMAL|D3DFVF_DIFFUSE)
#define FVF_XYZNORMDIFFTEX1 (D3DFVF_XYZ|D3DFVF_NORMAL|D3DFVF_DIFFUSE|D3DFVF_TEX1)

#ifdef __cplusplus
extern "C" {
#endif

// predefined flexible vertex formats

// D3DFVF_XYZ|D3DFVF_DIFFUSE
typedef struct sFVFT_XYZDIFF
{
	D3DVECTOR v;
	DWORD diff;
} FVFT_XYZDIFF;

// D3DFVF_XYZ|D3DFVF_NORMAL
typedef struct sFVFT_XYZNORM
{
	D3DVECTOR v;
	D3DVECTOR norm;
} FVFT_XYZNORM;

// D3DFVF_XYZ|D3DFVF_TEX1
typedef struct sFVFT_XYZTEX1
{
	D3DVECTOR v;
	float tu;
	float tv;
} FVFT_XYZTEX1;

// D3DFVF_XYZRHW|D3DFVF_TEX1
typedef struct sFVFT_XYZRHWTEX1
{
	D3DVECTOR v;
	float w;
	float tu;
	float tv;
} FVFT_XYZRHWTEX1;

// D3DFVF_XYZRHW|D3DFVF_TEX1
typedef struct sFVFT_XYZRHWDIFF
{
	D3DVECTOR v;
	float w;
	DWORD diff;
} FVFT_XYZRHWDIFF;

// D3DFVF_XYZ|D3DFV_DIFFUSE|D3DFVF_TEX1
typedef struct sFVFT_XYZDIFFTEX1
{
	D3DVECTOR v;
	DWORD diff;
	float tu;
	float tv;
} FVFT_XYZDIFFTEX1;

// D3DFVF_XYZ|D3DFVF_NORMAL|D3DFVF_TEX1
typedef struct sFVFT_XYZNORMTEX1
{
	D3DVECTOR v;
	D3DVECTOR norm;
	float tu;
	float tv;
} FVFT_XYZNORMTEX1;

// D3DFVF_XYZ|D3DFVF_NORMAL|D3DFVF_DIFFUSE
typedef struct sFVFT_XYZNORMDIFF
{
	D3DVECTOR v;
	D3DVECTOR norm;
	DWORD diff;
} FVFT_XYZNORMDIFF;

// D3DFVF_XYZ|D3DFVF_NORMAL|D3DFVF_DIFFUSE|D3DFVF_TEX1
typedef struct sFVFT_XYZNORMDIFFTEX1
{
	D3DVECTOR v;
	D3DVECTOR norm;
	DWORD diff;
	float tu;
	float tv;
} FVFT_XYZNORMDIFFTEX1;

DWORD FVF_VSize(DWORD fvf);

void FVF_GetVert(void *verts, D3DVECTOR *vout, DWORD first, DWORD cnt, DWORD fvf);
void FVF_GetNorm(void *verts, D3DVECTOR *nout, DWORD first, DWORD cnt, DWORD fvf);
void FVF_GetDiff(void *verts, DWORD *dout, DWORD first, DWORD cnt, DWORD fvf);
void FVF_GetUV(void *verts, float *uvout, DWORD first, DWORD cnt, DWORD fvf);

void FVF_SetVert(void *verts, D3DVECTOR *vin, DWORD first, DWORD cnt, DWORD fvf);
void FVF_SetNorm(void *verts, D3DVECTOR *nin, DWORD first, DWORD cnt, DWORD fvf);
void FVF_SetDiff(void *verts, DWORD *din, DWORD first, DWORD cnt, DWORD fvf);
void FVF_SetAllDiff(void *verts, DWORD din, DWORD first, DWORD cnt, DWORD fvf);
void FVF_SetUV(void *verts, float *uvin, DWORD first, DWORD cnt, DWORD fvf);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\include\xmodel.h ===
//-----------------------------------------------------------------------------
// File: xmodel.h
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef __XMODEL_H
#define __XMODEL_H

#ifdef _XBOX
#include <xtl.h>
#else
#include <d3d8.h>
#endif
#include <xbresource.h>
#include "xfvf.h"

extern CXBPackedResource *g_pModelResource;

#define XMF_STRIP	0x0001				// xmodel flag - generate tri strips
#define MFP_EYEWT	0x0001				// vfunc eye weight parameter

//-----------------------------------------------------------------------------
// Model class
//-----------------------------------------------------------------------------
class CXModel
{
	public:
	DWORD		m_dwFlags;
	DWORD		m_dwRefCount;
	DWORD		m_dwNumTriangles;		// # of triangles
	DWORD		m_dwNumVertices;		// # of vertices
	DWORD		m_dwVShader;			// vertex shader
	float		m_fRadius;				// radius
	float		m_fRadius2;				// radius squared

    LPDIRECT3DTEXTURE8 m_pTexture;		// texture

	DWORD		m_dwFVF;				// fvf type
	DWORD		m_dwVBSize;				// size of vbuf
	DWORD		m_dwVBStride;			// vbuf stride
    LPDIRECT3DVERTEXBUFFER8 m_pVB;		// vertex buffer

	D3DPRIMITIVETYPE m_PrimType;		// primitive type
	DWORD		m_dwIBSize;				// index buffer size
    LPDIRECT3DINDEXBUFFER8 m_pIB;		// index buffer
	DWORD		m_dwNumIndices;			// # of indices

	CXModel();
	~CXModel();

	DWORD Render();
	DWORD CXModel::Build(DWORD nvert, D3DVECTOR *vert, 
						 DWORD ntri, DWORD nidx, WORD *trilist, 
						 float *tc, D3DVECTOR *norm, DWORD *diff, 
						 DWORD fvf, DWORD flags);
	D3DVECTOR *GenNormals(DWORD nvert, D3DVECTOR *vert, DWORD ntri, WORD *trilist);
	void DrawNormals();
	DWORD Read_M(char *fname, char *imgname, DWORD fvf, DWORD flags, void (*vfunc)(int, int, float));
	void LoadTexture(char *imgname);

	// primitives
	DWORD Sphere(float radius, DWORD tessx, DWORD tessy, DWORD fvf, char *imgname, float txscale);
	DWORD GridXZ(DWORD tessx, DWORD tessz, float xsize, float zsize, DWORD fvf, char *imgname, float texx, float texz);
	DWORD Cylinder(float rad0, DWORD diff0, float rad1, DWORD diff1, float len, DWORD tess, DWORD fvf, char *imgname, float txscale);

	void LockVB(BYTE **bptr, DWORD flags)
	{
		m_pVB->Lock(0, m_dwVBSize, bptr, flags);
	}
	void UnlockVB()
	{
		m_pVB->Unlock();
	}
	void LockIB(BYTE **bptr, DWORD flags)
	{
		m_pIB->Lock(0, m_dwIBSize, bptr, flags);
	}
	void UnlockIB()
	{
		m_pIB->Unlock();
	}
	void SetVertexShader(DWORD vshader)
	{
		if(vshader==0)
			m_dwVShader = m_dwFVF;
		else
			m_dwVShader = vshader;
	}

	int AddRef() { return ++m_dwRefCount; }
	int Release();
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\include\xparse.h ===
//-----------------------------------------------------------------------------
// File: xparse.h
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef __PARSE_H
#define __PARSE_H

#ifdef __cplusplus
extern "C" {
#endif

#define MAX_TOKENS 32
#define MAX_TOKENSIZE 40
#define TOK_ERR -1

typedef struct sParseBlk
{
	char str[32];
	int val;
} ParseBlock;

typedef struct sToken
{
	char str[MAX_TOKENSIZE];	// token string
	int val;					// token value
} Token;

extern Token tokens[MAX_TOKENS];

int	Parse(char *string, struct sParseBlk *pb);
int ParseTok(char *string, struct sParseBlk *pb);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\include\xshadow.h ===
#ifndef __XSHADOW_H
#define __XSHADOW_H

#include "xobj.h"
#include "xfvf.h"

class CXShadowVolume
{
	float m_fWidth;
	float m_fHeight;

	DWORD m_dwNumTriangles;
	DWORD m_dwNumVertices;
	DWORD m_dwNumEdges;

	D3DMATRIX m_Matrix;
	FVFT_XYZDIFF *m_Vert;
	WORD *m_Tris;

	void AddEdge(DWORD *edgelist, WORD v0, WORD v1);

public:
	CXShadowVolume(float w, float h);
	~CXShadowVolume();

	void AddObj(CXObject *obj, D3DXVECTOR3 *lightpos);
	void Render();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\include\xobj.h ===
//-----------------------------------------------------------------------------
// File: xobj.h
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef __XOBJ_H
#define __XOBJ_H

#ifdef _XBOX
#include <xtl.h>
#include <XBMesh.h>
#else
#include <d3dx8.h>
#endif
#include "xmodel.h"

// object flags
#define OBJ_SYSFLAGSM	0xffff0000			// system flags mask
#define OBJ_USRFLAGSM	0x0000ffff			// user flags mask

#define OBJ_NOMCALCS	0x00010000			// dont do matrix calcs in render

//-----------------------------------------------------------------------------
// Object class
//-----------------------------------------------------------------------------
class CXObject
{
public:

	CXModel				*m_Model;			// model to render
#ifdef _XBOX
	CXBMesh				*m_pXBMesh;			// xbg mesh
#endif

	D3DXVECTOR3			m_vPosition;		// position
	D3DXVECTOR3			m_vRotation;		// rotation
	D3DXMATRIX			m_matOrientation;	// orientation matrix
	D3DMATERIAL8		*m_Material;		// lighting material

	DWORD				m_dwFlags;			// object flags
	DWORD				m_dwType;			// object type
	VOID				*m_pvInfo;			// info pointer

    CXObject();
    ~CXObject();

	void SetModel(CXModel *model);
	void SetXBMesh(CXBMesh *xbm);

	void SetPosition(float x, float y, float z)
	{
		m_vPosition.x = x;
		m_vPosition.y = y;
		m_vPosition.z = z;
	};

	void SetRotation(float x, float y, float z)
	{
		m_vRotation.x = x;
		m_vRotation.y = y;
		m_vRotation.z = z;
	};

	float GetRadius2();
	float GetRadius();

	void CrunchMatrix();
	void Render(int flags);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\include\xtextbox.h ===
#ifndef __XTEXTBOX_H
#define __XTEXTBOX_H

#include "XBFont.h"

// max textbox string length
#define TBOX_STRINGLEN 80

// textbox flags
#define TBOX_POPUP		0x01		// only active when text in box

typedef struct _XTextBoxItem
{
	DWORD val1, val2;				// user values
	WCHAR string[TBOX_STRINGLEN];
	DWORD expiretime;
	DWORD color;
} XTextBoxItem;

typedef struct _XTextBox
{
	float x, y, w, h;				// screen position & size
	DWORD flags;					// textbox flags
	DWORD textcolor;				// text color
	DWORD topcolor, bottomcolor;	// background color

	DWORD head, tail;
	DWORD maxshow;					// max lines to show
	DWORD maxitems;					// max lines to hold
	DWORD nitems;					// current number of items
	DWORD expiretime;				// time each line lives

	XTextBoxItem *items;			// text items
} XTextBox;

#ifdef __cplusplus
extern "C" {
#endif

void XTextBox_SetFont(CXBFont *font);
XTextBox *XTextBox_Init(float x, float y, float w, DWORD maxitems, DWORD flags);
void XTextBox_Shutdown();
XTextBoxItem *XTextBox_AddItem(XTextBox *xbox, WCHAR *string);
void XTextBox_Display(XTextBox *xbox);
void XTextBox_Expire(XTextBox *xbox);

#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\include\xbutil.h ===
//-----------------------------------------------------------------------------
// File: XBUtil.h
//
// Desc: Shortcut macros and helper functions for the XBox samples
//
// Hist: 11.01.00 - New for November XDK release
//       12.01.00 - Moved input code to XBInput.cpp
//       12.15.00 - Changes for December XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBUTIL_H
#define XBUTIL_H

#include <tchar.h>




//-----------------------------------------------------------------------------
// Miscellaneous helper functions
//-----------------------------------------------------------------------------

// For deleting and releasing objects
#define SAFE_DELETE(p)       { delete (p);     (p)=NULL; }
#define SAFE_DELETE_ARRAY(p) { delete[] (p);   (p)=NULL; }
#define SAFE_RELEASE(p)      { if(p) { (p)->Release(); (p)=NULL; } }

// For converting a FLOAT to a DWORD (useful for SetRenderState() calls)
inline DWORD FtoDW( FLOAT f ) { return *((DWORD*)&f); }




//-----------------------------------------------------------------------------
// Name: XBUtil_SetMediaPath() and XBUtil_FindMediaFile()
// Desc: Functions for setting a media path and returning a valid path to a
//       media file.
//-----------------------------------------------------------------------------
VOID    XBUtil_SetMediaPath( const CHAR* strPath );
HRESULT XBUtil_FindMediaFile( CHAR* strPath, const CHAR* strFilename );




//-----------------------------------------------------------------------------
// Name: XBUtil_Timer()
// Desc: Performs timer operations. Use the following commands:
//          TIMER_RESET           - to reset the timer
//          TIMER_START           - to start the timer
//          TIMER_STOP            - to stop (or pause) the timer
//          TIMER_ADVANCE         - to advance the timer by 0.1 seconds
//          TIMER_RETRACT         - to retract the timer by 0.1 seconds
//          TIMER_GETABSOLUTETIME - to get the absolute system time
//          TIMER_GETAPPTIME      - to get the current time
//-----------------------------------------------------------------------------
enum TIMER_COMMAND { TIMER_RESET, TIMER_START, TIMER_STOP, 
                     TIMER_ADVANCE, TIMER_RETRACT, 
                     TIMER_GETABSOLUTETIME, TIMER_GETAPPTIME };
FLOAT XBUtil_Timer( TIMER_COMMAND command );




//-----------------------------------------------------------------------------
// Name: XBUtil_InitMaterial()
// Desc: Initializes a D3DMATERIAL8 structure, setting the diffuse and ambient
//       colors. It does not set emissive or specular colors.
//-----------------------------------------------------------------------------
VOID XBUtil_InitMaterial( D3DMATERIAL8& mtrl, FLOAT r=0.0f, FLOAT g=0.0f,
                                              FLOAT b=0.0f, FLOAT a=1.0f );




//-----------------------------------------------------------------------------
// Name: XBUtil_InitLight()
// Desc: Initializes a D3DLIGHT structure, setting the light position. The
//       diffuse color is set to white, specular and ambient left as black.
//-----------------------------------------------------------------------------
VOID XBUtil_InitLight( D3DLIGHT8& light, D3DLIGHTTYPE ltType,
                       FLOAT x=0.0f, FLOAT y=0.0f, FLOAT z=0.0f );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateTexture()
// Desc: Helper function to create a texture.
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateTexture( LPDIRECT3DDEVICE8 pd3dDevice, const CHAR* strTexture,
                              LPDIRECT3DTEXTURE8* ppTexture,
                              D3DFORMAT d3dFormat = D3DFMT_UNKNOWN );




//-----------------------------------------------------------------------------
// Name: XBUtil_UnswizzleTexture() / XBUtil_SwizzleTexture()
// Desc: Unswizzles / swizzles a texture before it gets unlocked. Note: this
//       operation is typically very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_UnswizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc );
VOID XBUtil_UnswizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc );
VOID XBUtil_SwizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc );
VOID XBUtil_SwizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateVertexShader()
// Desc: Creates a file-based vertex shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateVertexShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                   const CHAR* strFilename, 
                                   const DWORD* pdwVertexDecl,
                                   DWORD* pdwVertexShader );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreatePixelShader()
// Desc: Creates a file-based pixel shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreatePixelShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                  const CHAR* strFilename, DWORD* pdwPixelShader );

                                    
                                    
                                    
//-----------------------------------------------------------------------------
// Name: XBUtil_VectorToRGBA()
// Desc: Converts a normal into an RGBA vector.
//-----------------------------------------------------------------------------
inline D3DCOLOR XBUtil_VectorToRGBA( const D3DXVECTOR3* v, FLOAT fHeight = 1.0f )
{
    D3DCOLOR r = (D3DCOLOR)( ( v->x + 1.0f ) * 127.5f );
    D3DCOLOR g = (D3DCOLOR)( ( v->y + 1.0f ) * 127.5f );
    D3DCOLOR b = (D3DCOLOR)( ( v->z + 1.0f ) * 127.5f );
    D3DCOLOR a = (D3DCOLOR)( 255.0f * fHeight );
    return( (a<<24L) + (r<<16L) + (g<<8L) + (b<<0L) );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_GetCubeMapViewMatrix()
// Desc: Returns a view matrix for rendering to a face of a cubemap.
//-----------------------------------------------------------------------------
D3DXMATRIX XBUtil_GetCubeMapViewMatrix( DWORD dwFace );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateNormalizationCubeMap()
// Desc: Creates a cubemap and fills it with normalized RGBA vectors.
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateNormalizationCubeMap( LPDIRECT3DDEVICE8 pd3dDevice, 
                                           DWORD dwSize, 
                                           LPDIRECT3DCUBETEXTURE8* ppCubeMap );




//-----------------------------------------------------------------------------
// Name: XBUtil_DumpSurface()
// Desc: Writes the contents of a surface (32-bit only) to a .tga file. This
//       could be a backbuffer, texture, or any other 32-bit surface.
//-----------------------------------------------------------------------------
HRESULT XBUtil_DumpSurface( LPDIRECT3DSURFACE8 pSurface, const CHAR* strFileName );




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateHermite()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Hermite curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateHermite( const D3DXVECTOR3& p0, const D3DXVECTOR3& p1, 
                                    const D3DXVECTOR3& v0, const D3DXVECTOR3& v1,
                                    FLOAT u );




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateCatmullRom()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Catmull-Rom curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateCatmullRom( const D3DXVECTOR3& p1, const D3DXVECTOR3& p2, 
                                       const D3DXVECTOR3& p3, const D3DXVECTOR3& p4,
                                       FLOAT u );




//-----------------------------------------------------------------------------
// Name: XBUtil_GetSplinePoint()
// Desc: Returns a point on a spline. The spline is defined by an array of
//       points, and the point and tangent returned are located at position t
//       on the spline, where 0 < t < dwNumSpinePts.
//-----------------------------------------------------------------------------
VOID XBUtil_GetSplinePoint( const D3DXVECTOR3* pSpline, DWORD dwNumSpinePts, FLOAT t, 
                            D3DXVECTOR3* pvPoint, D3DXVECTOR3* pvTangent );




//-----------------------------------------------------------------------------
// Name: XBUtil_RenderSpline()
// Desc: For debugging purposes, visually renders a spline.
//-----------------------------------------------------------------------------
VOID XBUtil_RenderSpline( LPDIRECT3DDEVICE8 pd3dDevice, const D3DXVECTOR3* pSpline, 
                          DWORD dwNumSplinePts, DWORD dwColor, BOOL bRenderAxes );




//-----------------------------------------------------------------------------
// Name: XBUtil_DeclaratorFromFVF()
// Desc: Create a vertex declaration from an FVF. Registers are assigned as
//       follows:
//          v0    = Vertex position
//          v1    = Vertex blend weights
//          v2    = Vertex normal
//          v3    = Vertex pointsize
//          v4    = Vertex diffuse color
//          v5    = Vertex specular color
//          v6-v9 = Vertex texture coords
//-----------------------------------------------------------------------------
HRESULT XBUtil_DeclaratorFromFVF( DWORD dwFVF, 
								  DWORD Declaration[MAX_FVF_DECL_SIZE] );

#endif // XBUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\include\xmenu.h ===
#ifndef __XMENU_H
#define __XMENU_H

#include "XBFont.h"
#include "XBInput.h"

// menu item flags
#define MITEM_SEPARATOR		0x0001			// this item is a separator
#define MITEM_ROUTINE		0x0002			// this item calls a routine
#define MITEM_DISABLED		0x0004			// this item is greyed out

// menu routine commands
#define MROUTINE_INIT		0xffff			// first call to routine
#define MROUTINE_ABORT		0xfffe			// abort routine triggered

// menu routine return values
#define MROUTINE_RETURN		0x0001			// return to menu
#define MROUTINE_DIE		0x0002			// kill routine
#define MROUTINE_SLEEP		0x0003			// routine sleeps

// menu item definition
#define MITEM_STRINGLEN 48
typedef struct _xmenuitem
{
	DWORD flags;
	WCHAR string[MITEM_STRINGLEN];			// text to display
	DWORD val1;								// user defined values
	DWORD val2;
	void *action;							// link to menu or routine
	struct _xmenu *menu;					// menu that owns this item
	DWORD color;							// item color
} XMenuItem;

// menu commands
#define MENU_NEXTITEM		0x0001			// next menu item
#define MENU_PREVITEM		0x0002			// previous menu item
#define MENU_SELECTITEM		0x0003			// select this menu item
#define MENU_BACK			0x0004			// go back one level
#define MENU_ACTIVATE		0x0005			// activate menu

// menu flags
#define MENU_LEFT			0x0001			// left justify menu text
#define MENU_RIGHT			0x0002			// right justify menu text
#define MENU_WRAP			0x0004			// wrap menu selection
#define MENU_NOBACK			0x0008			// cannot use back button

typedef struct _xmenu
{
	float x, y;								// screen position
	float w, h;								// menu size
	DWORD flags;							// menu flags
	DWORD topcolor, bottomcolor;			// menu background gradient color
	DWORD seltopcolor, selbotcolor;			// menu selection bar gradient color
	DWORD itemcolor;						// menu item default color
	struct _xmenu *parent;					// parent menu

	WCHAR title[MITEM_STRINGLEN];			// menu title
	DWORD titlecolor;						// memu title color
	DWORD maxshow;							// max # of items to show at one time
	DWORD maxitems;							// max # of items
	DWORD nitems;							// # of items
	DWORD curitem;							// current selected item
	XMenuItem *items;						// items

	DWORD (*abortroutine)(DWORD, XMenuItem *);	// called when menu aborted
} XMenu;

#ifdef __cplusplus
extern "C" {
#endif

extern XMenu *XMenu_CurMenu;
extern int (*XMenu_CurRoutine)(DWORD cmd, XMenuItem *mi);

void XMenu_SetFont(CXBFont *font);
XMenu *XMenu_Init(float x, float y, DWORD maxitems, DWORD flags, DWORD (*abortroutine)(DWORD, XMenuItem *));
void XMenu_Shutdown();
void XMenu_Delete(XMenu *m);
XMenuItem *XMenu_AddItem(XMenu *m, DWORD flags, WCHAR *string, void *action);
void XMenu_DeleteItem(XMenuItem *mi);
void XMenu_SetMaxShow(XMenu *m, DWORD maxshow);
void XMenu_SetTitle(XMenu *m, WCHAR *string, DWORD color);
void XMenu_SetItemText(XMenuItem *mi, WCHAR *string);
#define XMenu_IsActive() (XMenu_CurMenu||XMenu_CurRoutine)

DWORD XMenu_GetCommand(XBGAMEPAD *gamepad);	// gets command based on joypad
DWORD XMenu_Activate(XMenu *m);				// activates a menu
DWORD XMenu_Routine(DWORD command);			// called each frame to update menu

#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\include\xpath.h ===
//-----------------------------------------------------------------------------
// File: xpath.h
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef __XPATH_H
#define __XPATH_H

#include <tchar.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifdef UNICODE
#define _FN(a) XPath_GetFileNameT(a, NULL)
#else
#define _FN(a) XPath_GetFileNameA(a, NULL)
#endif

#define _FNA(a) XPath_GetFileNameA(a, NULL)

void XPath_SetBasePath(TCHAR *path);
TCHAR *XPath_GetFileNameT(TCHAR *in, TCHAR *out=NULL);
char *XPath_GetFileNameA(char *in, char *out=NULL);

#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\src\xbhelp.cpp ===
//-----------------------------------------------------------------------------
// File: XBHelp.cpp
//
// Desc: Support class for rendering a help image, which is an image of an Xbox
//       gamepad, with labelled callouts to each of the gamepad's controls.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       03.06.01 - Changes for April XDK release
//       04.15.01 - Using packed resources for May XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xgraphics.h>
#include "XBHelp.h"
#include "XBResource.h"




//-----------------------------------------------------------------------------
// Constants for rendering callouts on the help screen. The order of these
// callouts is in agreement with the enum structure in XBHelp.h
//-----------------------------------------------------------------------------
static D3DXVECTOR2 g_vHelpCallouts[] = 
{
    // Order:
    // Button position (start of line),
    // End of line for placement one, Start of text for placement one
    // End of line for placement two, Start of text for placement two

    // Left thumbstick
    D3DXVECTOR2( 255.0f, 149.0f ),
    D3DXVECTOR2( 141.0f,  99.0f ), D3DXVECTOR2( 108.0f,  77.0f ),
    D3DXVECTOR2( 145.0f, 124.0f ), D3DXVECTOR2( 108.0f,  77.0f ),
    
    // Right thumbstick 
    D3DXVECTOR2( 370.0f, 191.0f ),
    D3DXVECTOR2( 370.0f, 363.0f ), D3DXVECTOR2( 352.0f, 364.0f ),
    D3DXVECTOR2( 370.0f, 363.0f ), D3DXVECTOR2( 352.0f, 364.0f ),

    // D-pad
    D3DXVECTOR2( 254.0f, 194.0f ),
    D3DXVECTOR2( 117.0f, 223.0f ), D3DXVECTOR2(  78.0f, 222.0f ),
    D3DXVECTOR2( 117.0f, 223.0f ), D3DXVECTOR2(  78.0f, 222.0f ),
    
    // Back button
    D3DXVECTOR2( 288.0f, 221.0f ),
    D3DXVECTOR2( 185.0f, 284.0f ), D3DXVECTOR2( 145.0f, 282.0f ),
    D3DXVECTOR2( 185.0f, 284.0f ), D3DXVECTOR2( 145.0f, 282.0f ),

    // Start button
    D3DXVECTOR2( 322.0f, 223.0f ),
    D3DXVECTOR2( 262.0f, 343.0f ), D3DXVECTOR2( 217.0f, 340.0f ),
    D3DXVECTOR2( 262.0f, 343.0f ), D3DXVECTOR2( 217.0f, 340.0f ),

    // X button
    D3DXVECTOR2( 394.0f, 176.0f ),
    D3DXVECTOR2( 295.0f, 124.0f ), D3DXVECTOR2( 268.0f, 101.0f ),
    D3DXVECTOR2( 300.0f, 149.0f ), D3DXVECTOR2( 268.0f, 101.0f ),

    // Y button
    D3DXVECTOR2( 405.0f, 164.0f ),
    D3DXVECTOR2( 416.0f,  99.0f ), D3DXVECTOR2( 404.0f, 76.0f ),
    D3DXVECTOR2( 416.0f,  99.0f ), D3DXVECTOR2( 404.0f, 51.0f ),

    // A button
    D3DXVECTOR2( 411.0f, 189.0f ),
    D3DXVECTOR2( 431.0f, 298.0f ), D3DXVECTOR2( 424.0f, 298.0f ),
    D3DXVECTOR2( 431.0f, 298.0f ), D3DXVECTOR2( 424.0f, 298.0f ),

    // B button
    D3DXVECTOR2( 422.0f, 175.0f ),
    D3DXVECTOR2( 443.0f, 244.0f ), D3DXVECTOR2( 435.0f, 243.0f ),
    D3DXVECTOR2( 443.0f, 244.0f ), D3DXVECTOR2( 435.0f, 243.0f ),

    // White button
    D3DXVECTOR2( 424.0f, 158.0f ),
    D3DXVECTOR2( 458.0f, 124.0f ), D3DXVECTOR2( 444.0f, 102.0f ),
    D3DXVECTOR2( 448.0f, 148.0f ), D3DXVECTOR2( 444.0f, 102.0f ),
    
    // Black button
    D3DXVECTOR2( 443.0f, 170.0f ),
    D3DXVECTOR2( 456.0f, 183.0f ), D3DXVECTOR2( 442.0f, 182.0f ),
    D3DXVECTOR2( 456.0f, 183.0f ), D3DXVECTOR2( 442.0f, 182.0f ),

    // Left trigger button
    D3DXVECTOR2( 230.0f, 173.0f ),
    D3DXVECTOR2( 164.0f, 160.0f ), D3DXVECTOR2( 66.0f, 150.0f ),
    D3DXVECTOR2( 164.0f, 160.0f ), D3DXVECTOR2( 66.0f, 150.0f ),

    // Right trigger button
    D3DXVECTOR2( 462.0f, 172.0f ),
    D3DXVECTOR2( 480.0f, 170.0f ), D3DXVECTOR2( 482.0f, 158.0f ),
    D3DXVECTOR2( 480.0f, 170.0f ), D3DXVECTOR2( 482.0f, 158.0f ),

    // Misc callout
    D3DXVECTOR2(  64.0f, 380.0f ),
    D3DXVECTOR2(  64.0f, 380.0f ), D3DXVECTOR2( 64.0f, 405.0f ),
    D3DXVECTOR2(  64.0f, 380.0f ), D3DXVECTOR2( 64.0f, 380.0f ),
};




//-----------------------------------------------------------------------------
// Name: CXBHelp()
// Desc: Help class constructor
//-----------------------------------------------------------------------------
CXBHelp::CXBHelp()
{
    m_pd3dDevice      = NULL;
    m_pGamepadTexture = NULL;
    m_pVB             = NULL;
}




//-----------------------------------------------------------------------------
// Name: ~CXBHelp()
// Desc: Help class destructor
//-----------------------------------------------------------------------------
CXBHelp::~CXBHelp()
{
    Destroy();
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Creates the help class' internal objects
//-----------------------------------------------------------------------------
HRESULT CXBHelp::Create( LPDIRECT3DDEVICE8 pd3dDevice, CHAR* strResource )
{
    // Keep track of the device
    m_pd3dDevice = pd3dDevice;

    // Create the gamepad resource
    if( FAILED( m_xprResource.Create( pd3dDevice, strResource, 1 ) ) )
        return E_FAIL;

    // Store access to the 640x480, linear gamepad texture
    m_pGamepadTexture = m_xprResource.GetTexture( 0UL );

    // Create a vertex buffer for rendering the help screen
    m_pd3dDevice->CreateVertexBuffer( 4*6*sizeof(FLOAT), D3DUSAGE_WRITEONLY, 
                                      0L, D3DPOOL_DEFAULT, &m_pVB );
    struct VERTEX { D3DXVECTOR4 p; FLOAT tu, tv; };
    VERTEX* v;
    m_pVB->Lock( 0, 0, (BYTE**)&v, 0L );
    v[0].p = D3DXVECTOR4(   0,   0, 0, 0 ); v[0].tu =   0; v[0].tv =   0;
    v[1].p = D3DXVECTOR4( 640,   0, 0, 0 ); v[1].tu = 639; v[1].tv =   0;
    v[2].p = D3DXVECTOR4( 640, 480, 0, 0 ); v[2].tu = 639; v[2].tv = 479;
    v[3].p = D3DXVECTOR4(   0, 480, 0, 0 ); v[3].tu =   0; v[3].tv = 479;
    m_pVB->Unlock();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Destroys the help class' internal objects/
//-----------------------------------------------------------------------------
HRESULT CXBHelp::Destroy()
{
    SAFE_RELEASE( m_pVB );
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Renders the gamepad help image, and it's labelled callouts.
//-----------------------------------------------------------------------------
HRESULT CXBHelp::Render( CXBFont* pFont, XBHELP_CALLOUT* tags, 
                         DWORD dwNumCallouts )
{
    // Set state to render the gamepad image
    m_pd3dDevice->SetTexture( 0, m_pGamepadTexture );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,      FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGENABLE,    FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGTABLEMODE, D3DFOG_NONE );
    m_pd3dDevice->SetRenderState( D3DRS_FILLMODE,     D3DFILL_SOLID );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,     D3DCULL_CCW );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_SRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_TEX1 );

    // Render the gamepad image
    m_pd3dDevice->SetStreamSource( 0, m_pVB, 6*sizeof(FLOAT) );
    m_pd3dDevice->DrawPrimitive( D3DPT_QUADLIST, 0, 1 );

    // Set state to draw the lines
    m_pd3dDevice->SetTexture( 0, NULL );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW );

    for( DWORD i=0; i<dwNumCallouts; i++ )
    {
        // Determine the line start and end positions
        WORD wLineStartIndex = tags[i].wControl;
        WORD wLineEndIndex   = tags[i].wControl + 2*(tags[i].wPlacement-1)+1;
        FLOAT line1x = g_vHelpCallouts[wLineStartIndex].x;
        FLOAT line1y = g_vHelpCallouts[wLineStartIndex].y;
        FLOAT line2x = g_vHelpCallouts[wLineEndIndex].x;
        FLOAT line2y = g_vHelpCallouts[wLineEndIndex].y;

        // Draw the callout line
        D3DXVECTOR4 v[2];
        v[0] = D3DXVECTOR4( line1x, line1y, 0.0f, 0.0f );
        v[1] = D3DXVECTOR4( line2x, line2y, 0.0f, 0.0f );
        
        m_pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, v, sizeof(D3DXVECTOR4) );
    }

    // Prepare font for rendering
    pFont->Begin();

    // Render the callouts
    for( i=0; i<dwNumCallouts; i++ )
    {
        // Determine the text position
        WORD wTextPosIndex = tags[i].wControl + 2*(tags[i].wPlacement-1)+2;
        FLOAT textx = g_vHelpCallouts[wTextPosIndex].x;
        FLOAT texty = g_vHelpCallouts[wTextPosIndex].y;

        // Draw the callout text
        pFont->DrawText( textx, texty, 0xffffffff, tags[i].strText );
    }

    // Flush the text drawing
    pFont->End();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\src\xbapp.cpp ===
//-----------------------------------------------------------------------------
// File: XBApp.cpp
//
// Desc: Application class for the XBox samples.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       12.19.01 - Changes for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "XBApp.h"




//-----------------------------------------------------------------------------
// Global access to common members
//-----------------------------------------------------------------------------
CXBApplication*    g_pXBApp     = NULL;
LPDIRECT3DDEVICE8  g_pd3dDevice = NULL;




//-----------------------------------------------------------------------------
// Name: CXBApplication()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBApplication::CXBApplication()
{
    // Initialize member variables
    g_pXBApp          = this;

    // Direct3D variables
    m_pD3D            = NULL;
    m_pd3dDevice      = NULL;
    m_pDepthBuffer    = NULL;
    m_pBackBuffer     = NULL;

    // Variables to perform app timing
    m_bPaused         = FALSE;
    m_fTime           = 0.0f;
    m_fElapsedTime    = 0.0f;
    m_fAppTime        = 0.0f;
    m_fElapsedAppTime = 0.0f;
    m_fFPS            = 0.0f;
    m_strFrameRate[0] = L'\0';

    // Set up the presentation parameters for a double-bufferd, 640x480,
    // 32-bit display using depth-stencil. Override these parameters in
    // your derived class as your app requires.
    ZeroMemory( &m_d3dpp, sizeof(m_d3dpp) );
    m_d3dpp.BackBufferWidth        = 640;
    m_d3dpp.BackBufferHeight       = 480;
    m_d3dpp.BackBufferFormat       = D3DFMT_A8R8G8B8;
    m_d3dpp.BackBufferCount        = 1;
    m_d3dpp.EnableAutoDepthStencil = TRUE;
    m_d3dpp.AutoDepthStencilFormat = D3DFMT_D24S8;
    m_d3dpp.SwapEffect             = D3DSWAPEFFECT_DISCARD;

    // Specify number and type of input devices this app will be using. By
    // default, you can use 0 and NULL, which triggers XInputDevices() to
    // prealloc the default number and types of devices. To use chat or
    // other devices, override these variables in your derived class.
    m_dwNumInputDeviceTypes = 0;
    m_InputDeviceTypes      = NULL;
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Create the app
//-----------------------------------------------------------------------------
HRESULT CXBApplication::Create()
{
    HRESULT hr;

    // Create the Direct3D object
    OutputDebugString( _T("XBApp: Creating Direct3D...\n") );
    if( NULL == ( m_pD3D = Direct3DCreate8(D3D_SDK_VERSION) ) )
    {
        OutputDebugString( _T("XBApp: Unable to create Direct3D!\n") );
        return E_FAIL;
    }

    // Create the device
    OutputDebugString( _T("XBApp: Creating the D3D device...\n") );
    if( FAILED( hr = m_pD3D->CreateDevice( 0, D3DDEVTYPE_HAL, NULL, 
                                           D3DCREATE_HARDWARE_VERTEXPROCESSING, 
                                           &m_d3dpp, &m_pd3dDevice ) ) )
    {
        OutputDebugString( _T("XBApp: Could not create D3D device!\n") );
        return hr;
    }

    // Allow global access to the device
    g_pd3dDevice = m_pd3dDevice;

    // Store pointers to the depth and back buffers
    m_pd3dDevice->GetDepthStencilSurface( &m_pDepthBuffer );
    m_pd3dDevice->GetBackBuffer( 0, 0, &m_pBackBuffer );

    // Clear the backbuffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x00000000, 1.0f, 0L );
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    // Initialize core peripheral port support. Note: If these parameters
    // are 0 and NULL, respectively, then the default number and types of 
    // controllers will be initialized.
    XInitDevices( m_dwNumInputDeviceTypes, m_InputDeviceTypes );
    // Create the gamepad devices
    OutputDebugString( _T("XBApp: Creating gamepad devices...\n") );
    if( FAILED( hr = XBInput_CreateGamepads( &m_Gamepad ) ) )
    {
        OutputDebugString( _T("XBApp: Call to CreateGamepads() failed!\n") );
        return hr;
    }

    // Initialize the app's device-dependent objects
    OutputDebugString( _T("XBApp: Initializing the app...\n") );
    if( FAILED( hr = Initialize() ) )
    {
        OutputDebugString( _T("XBApp: Call to Initialize() failed!\n") );
        return hr;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Cleanup objects
//-----------------------------------------------------------------------------
VOID CXBApplication::Destroy()
{
    // Perform app-specific cleanup
    Cleanup();

    // Release display objects
    SAFE_RELEASE( m_pd3dDevice );
    SAFE_RELEASE( m_pD3D );
}




//-----------------------------------------------------------------------------
// Name: Run()
// Desc: 
//-----------------------------------------------------------------------------
INT CXBApplication::Run()
{
    OutputDebugString( _T("XBApp: Running the application...\n") );

    // Get the frequency of the timer
    LARGE_INTEGER qwTicksPerSec;
    QueryPerformanceFrequency( &qwTicksPerSec );
    FLOAT fSecsPerTick = 1.0f / (FLOAT)qwTicksPerSec.QuadPart;

    // Save the start time
    LARGE_INTEGER qwTime, qwLastTime, qwElapsedTime;
    QueryPerformanceCounter( &qwTime );
    qwLastTime.QuadPart = qwTime.QuadPart;

    LARGE_INTEGER qwAppTime, qwElapsedAppTime;
    qwAppTime.QuadPart        = 0;
    qwElapsedTime.QuadPart    = 0;
    qwElapsedAppTime.QuadPart = 0;

    // Run the game loop, animating and rendering frames
    while( TRUE )
    {
        //-----------------------------------------
        // Handle input
        //-----------------------------------------

        // Read the input for all connected gampads
        XBInput_GetInput( m_Gamepad );

        // Lump inputs of all connected gamepads into one common structure.
        // This is done so apps that need only one gamepad can function with
        // any gamepad.
        ZeroMemory( &m_DefaultGamepad, sizeof(m_DefaultGamepad) );
        for( DWORD i=0; i<4; i++ )
        {
            if( m_Gamepad[i].hDevice )
            {
                m_DefaultGamepad.sThumbLX += m_Gamepad[i].sThumbLX;
                m_DefaultGamepad.sThumbLY += m_Gamepad[i].sThumbLY;
                m_DefaultGamepad.sThumbRX += m_Gamepad[i].sThumbRX;
                m_DefaultGamepad.sThumbRY += m_Gamepad[i].sThumbRY;
                m_DefaultGamepad.fX1      += m_Gamepad[i].fX1;
                m_DefaultGamepad.fY1      += m_Gamepad[i].fY1;
                m_DefaultGamepad.fX2      += m_Gamepad[i].fX2;
                m_DefaultGamepad.fY2      += m_Gamepad[i].fY2;
                m_DefaultGamepad.wButtons        |= m_Gamepad[i].wButtons;
                m_DefaultGamepad.wPressedButtons |= m_Gamepad[i].wPressedButtons;
                m_DefaultGamepad.wLastButtons    |= m_Gamepad[i].wLastButtons;

                for( DWORD b=0; b<8; b++ )
                {
                    m_DefaultGamepad.bAnalogButtons[b]        |= m_Gamepad[i].bAnalogButtons[b];
                    m_DefaultGamepad.bPressedAnalogButtons[b] |= m_Gamepad[i].bPressedAnalogButtons[b];
                    m_DefaultGamepad.bLastAnalogButtons[b]    |= m_Gamepad[i].bLastAnalogButtons[b];
                }
            }
        }

        // Handle special input functions:
        // -  Both triggers and white button triggers a screen dump
        // -  Both triggers and black button triggers a reboot
        if( m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] > 0 )
        {
            if( m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] > 0 )
            {
                // With white button, dump the backbuffer contents
                if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_WHITE] )
                    XGWriteSurfaceToFile( m_pBackBuffer, "D:\\BackBuffer.bmp" );

                // With black button, reboot to the Xbox Dashboard
                if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_BLACK] )
                    XLaunchNewImage( NULL, NULL );
            }
        }

        //-----------------------------------------
        // Perform app timing
        //-----------------------------------------

        // Check Start button
        if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_START )
            m_bPaused = !m_bPaused;

        // Get the current time (keep in LARGE_INTEGER format for precision)
        QueryPerformanceCounter( &qwTime );
        qwElapsedTime.QuadPart = qwTime.QuadPart - qwLastTime.QuadPart;
        qwLastTime.QuadPart    = qwTime.QuadPart;
        if( m_bPaused )
            qwElapsedAppTime.QuadPart = 0;
        else
            qwElapsedAppTime.QuadPart = qwElapsedTime.QuadPart;
        qwAppTime.QuadPart    += qwElapsedAppTime.QuadPart;

        // Store the current time values as floating point
        m_fTime           = fSecsPerTick * ((FLOAT)(qwTime.QuadPart));
        m_fElapsedTime    = fSecsPerTick * ((FLOAT)(qwElapsedTime.QuadPart));
        m_fAppTime        = fSecsPerTick * ((FLOAT)(qwAppTime.QuadPart));
        m_fElapsedAppTime = fSecsPerTick * ((FLOAT)(qwElapsedAppTime.QuadPart));

        // Compute the FPS (frames per second) once per second
        static FLOAT fLastTime = 0.0f;
        static DWORD dwFrames  = 0L;
        dwFrames++;

        if( m_fTime - fLastTime > 1.0f )
        {
            m_fFPS    = dwFrames / ( m_fTime - fLastTime );
            fLastTime = m_fTime;
            dwFrames  = 0L;
            swprintf( m_strFrameRate, L"%0.02f fps", m_fFPS );
        }

        //-----------------------------------------
        // Animate and render a frame
        //-----------------------------------------

        // Frame move the scene
        FrameMove();

        // Render the scene
        Render();

        // Finally, show the frame (swaps the backbuffer to the front)
        m_pd3dDevice->Present( NULL, NULL, NULL, NULL );
    }

    return 0;
}




//-----------------------------------------------------------------------------
// Name: RenderGradientBackground()
// Desc: Draws a gradient filled background
//-----------------------------------------------------------------------------
HRESULT CXBApplication::RenderGradientBackground( DWORD dwTopColor, 
                                                  DWORD dwBottomColor )
{
    // First time around, allocate a vertex buffer
    static LPDIRECT3DVERTEXBUFFER8 g_pVB  = NULL;
    if( g_pVB == NULL )
    {
        m_pd3dDevice->CreateVertexBuffer( 4*5*sizeof(FLOAT), D3DUSAGE_WRITEONLY, 
                                          0L, D3DPOOL_DEFAULT, &g_pVB );
        struct BACKGROUNDVERTEX { D3DXVECTOR4 p; D3DCOLOR color; };
        BACKGROUNDVERTEX* v;
        g_pVB->Lock( 0, 0, (BYTE**)&v, 0L );
        v[0].p = D3DXVECTOR4(   0,   0, 1.0f, 1.0f ); v[0].color = dwTopColor;
        v[1].p = D3DXVECTOR4( 640,   0, 1.0f, 1.0f ); v[1].color = dwTopColor;
        v[2].p = D3DXVECTOR4(   0, 480, 1.0f, 1.0f ); v[2].color = dwBottomColor;
        v[3].p = D3DXVECTOR4( 640, 480, 1.0f, 1.0f ); v[3].color = dwBottomColor;
        g_pVB->Unlock();
    }

    // Set states
    m_pd3dDevice->SetTexture( 0, NULL );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_DISABLE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE ); 
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE ); 
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_DIFFUSE );
    m_pd3dDevice->SetStreamSource( 0, g_pVB, 5*sizeof(FLOAT) );

    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

    // Clear the zbuffer
    m_pd3dDevice->Clear( 0, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 0x00000000, 1.0f, 0L );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\src\xbfont.cpp ===
//-----------------------------------------------------------------------------
// File: XBFont.cpp
//
// Desc: Texture-based font class. This class reads .abc font files that are
//       generated by the FontMaker tool. These .abc files are used to create
//       a texture with all the font's glyph, and also extract information on
//       the dimensions of each glyph.
//
//       Once created, this class is used to render text in a 3D scene with the
//       following function:
//          DrawText( fScreenY, fScreenSpaceY, dwTextColor, strText,
//                    dwJustificationFlags );
//
//       For performance, you can batch mulitple DrawText calls together
//       between Begin() and End() calls, as in the following example:
//          pFont->Begin();
//          pFont->DrawText( ... );
//          pFont->DrawText( ... );
//          pFont->DrawText( ... );
//          pFont->End();
//
//       The size (extent) of the text can be computed without rendering with
//       the following function:
//          GetTextExtent( strText, pfReturnedWidth, pfReturnedHeight,
//                         bComputeExtentUsingFirstLineOnly );
//
//       Finally, the font class can create a texture to hold rendered text,
//       which is useful for static text that must be rendered for many
//       frames, or can even be used within a 3D scene. (For instance, for a
//       player's name on a jersey.) Use the following function for this:
//          CreateTexture( strText, d3dTextureFormat );
//
//       See the XDK docs for more information.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       02.18.01 - Changes for March XDK release
//       04.15.01 - Using packed resources for May XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <stdio.h>
#include "XBFont.h"




// Max size for the font class' vertex buffer
const DWORD XBFONT_MAX_VERTICES = 1024 * 4;

// Helper function to init a vertex
inline XBFONTVERTEX InitFontVertex( const D3DXVECTOR4& p, D3DCOLOR color,
                                    FLOAT tu, FLOAT tv )
{
    XBFONTVERTEX v;   
    v.p     = p;   
    v.color = color;   
    v.tu    = tu;   
    v.tv    = tv;
    return v;
}




//-----------------------------------------------------------------------------
// Name: CXBFont()
// Desc: Font class constructor.
//-----------------------------------------------------------------------------
CXBFont::CXBFont()
{
    m_pd3dDevice         = NULL;
    m_pTexture           = NULL;

    for( DWORD i=0; i<NUM_FONT_BUFFERS; i++ )
        m_pVBs[i] = NULL;
    m_pVB                = NULL;
    m_dwCurrentBuffer    = 0L;
    m_bTextureFromFile   = FALSE;

    m_pVertices          = NULL;
    m_dwNumQuads         = 0L;
    m_dwNestedBeginCount = 0L;

    m_dwFontHeight       = 36;
    m_dwTexWidth         = 64;
    m_dwTexHeight        = 64;

    m_cLowChar           = 0;
    m_cHighChar          = 0;

    m_dwNumGlyphs        = 0L;
    m_Glyphs             = NULL;
}




//-----------------------------------------------------------------------------
// Name: ~CXBFont()
// Desc: Font class destructor.
//-----------------------------------------------------------------------------
CXBFont::~CXBFont()
{
    Destroy();
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Create the font's internal objects (texture and array of glyph info)
//       using the image and information from two files.
//-----------------------------------------------------------------------------
HRESULT CXBFont::Create( LPDIRECT3DDEVICE8 pd3dDevice, 
                         const CHAR* strFontResourceFileName )
{
    HRESULT hr;

    // Store the device for use in member functions
    m_pd3dDevice = pd3dDevice;

    if( FAILED( m_xprResource.Create( m_pd3dDevice, strFontResourceFileName, 
                                      2 ) ) )
        return E_FAIL;

    m_pTexture = m_xprResource.GetTexture( 0UL );

    BYTE* pData = (BYTE*)m_xprResource.GetData( XBResource_SizeOf(m_pTexture) );
    DWORD dwResourceType = ((DWORD*)pData)[0];
    DWORD dwResourceSize = ((DWORD*)pData)[1];
    pData += 2*sizeof(DWORD);

    DWORD dwVersion = ((DWORD*)pData)[0];
    m_dwFontHeight  = ((DWORD*)pData)[1];
    m_dwTexWidth    = ((DWORD*)pData)[2];
    m_dwTexHeight   = ((DWORD*)pData)[3];
    DWORD dwBPP     = ((DWORD*)pData)[4];
    pData += 5*sizeof(DWORD);

    // Check version of file (to make sure it matches up with the FontMaker tool)
    if( dwVersion != 0x00000004 )
    {
        OutputDebugStringA( "XBFont: Incorrect version number on font file!\n" );
        return E_FAIL;
    }

    // Read the low and high char
    m_cLowChar  = ((WCHAR*)pData)[0];
    m_cHighChar = ((WCHAR*)pData)[1];
    pData += 2*sizeof(WCHAR);

    // Read the glyph attributes from the file
    m_Glyphs = (GLYPH_ATTR*)(pData+4);

    // Create vertex buffer for rendering text strings
    for( DWORD i=0; i<NUM_FONT_BUFFERS; i++ )
    {
        hr = pd3dDevice->CreateVertexBuffer( XBFONT_MAX_VERTICES*sizeof(XBFONTVERTEX),
                                             D3DUSAGE_WRITEONLY, 0L,
                                             D3DPOOL_DEFAULT, &m_pVBs[i] );
        if( FAILED(hr) )
            return hr;
    }

    // Assign a current vertex buffer
    m_dwCurrentBuffer = 0L;
    m_pVB = m_pVBs[m_dwCurrentBuffer];

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Destroys the font object
//-----------------------------------------------------------------------------
HRESULT CXBFont::Destroy()
{
    m_xprResource.Destroy();

    // Delete vertex buffers
    for( DWORD i=0; i<NUM_FONT_BUFFERS; i++ )
        SAFE_RELEASE( m_pVBs[i] );

    if( m_bTextureFromFile )
    {
        SAFE_RELEASE( m_pTexture );
        delete [] m_Glyphs;
    }

    m_pd3dDevice         = NULL;
    m_pTexture           = NULL;
    m_pVB                = NULL;
    m_dwCurrentBuffer    = 0L;
    m_bTextureFromFile   = FALSE;

    m_pVertices          = NULL;
    m_dwNumQuads         = 0L;
    m_dwNestedBeginCount = 0L;

    m_dwFontHeight       = 36;
    m_dwTexWidth         = 64;
    m_dwTexHeight        = 64;

    m_cLowChar           = 0;
    m_cHighChar          = 0;

    m_dwNumGlyphs        = 0L;
    m_Glyphs             = NULL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: GetTextExtent()
// Desc: Get the dimensions of a text string
//-----------------------------------------------------------------------------
HRESULT CXBFont::GetTextExtent( const WCHAR* strText, FLOAT* pWidth, 
                                FLOAT* pHeight, BOOL bFirstLineOnly ) const
{
    // Check parameters
    if( NULL==strText || NULL==pWidth || NULL==pHeight )
        return E_INVALIDARG;

    // Set default text extent in output parameters
    (*pWidth)   = 0.0f;
    (*pHeight)  = 0.0f;

    // Initialize counters that keep track of text extent
    FLOAT sx = 0.0f;
    FLOAT sy = (FLOAT)(m_dwFontHeight + 1);

    // Loop through each character and update text extent
    while( *strText )
    {
        WCHAR letter = *strText++;
        
        // Handle newline character
        if( letter == L'\n' )
        {
            if( bFirstLineOnly )
                return S_OK;
            sx  = 0.0f;
            sy += (FLOAT)(m_dwFontHeight + 1);
        }

        // Ignore unprintable characters
        if( letter<m_cLowChar || letter>m_cHighChar )
            continue;

        // Get text extent for this character's glyph
        GLYPH_ATTR* pGlyph = &m_Glyphs[letter - m_cLowChar];
        sx += pGlyph->wOffset;
        sx += pGlyph->wAdvance;

        // Store text extent of string in output parameters
        if( sx > (*pWidth) )   (*pWidth)  = sx;
        if( sy > (*pHeight) )  (*pHeight) = sy;
     }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Begin()
// Desc: Prepares the font vertex buffers for rendering.
//-----------------------------------------------------------------------------
HRESULT CXBFont::Begin()
{
    // Lock vertex buffer on the first call (allow nesting of begin/end calls)
    if( 0 == m_dwNestedBeginCount )
    {
        // Assign a current vertex buffer
        if( m_pVB->IsBusy() )
        {
            if( ++m_dwCurrentBuffer >= NUM_FONT_BUFFERS )
                m_dwCurrentBuffer = 0L;
            m_pVB = m_pVBs[m_dwCurrentBuffer];
        }

        // Lock the vertex buffer
        m_pVB->Lock( 0, 0, (BYTE**)&m_pVertices, 0L );
        m_dwNumQuads = 0;
    }

    // Keep track of the nested begin/end calls.
    m_dwNestedBeginCount++;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DrawText()
// Desc: Draws text as textured polygons
//-----------------------------------------------------------------------------
HRESULT CXBFont::DrawText( FLOAT fOriginX, FLOAT fOriginY, DWORD dwColor,
                           const WCHAR* strText, DWORD dwFlags )
{
    // Set up stuff (i.e. lock the vertex buffer) to prepare for drawing text
    Begin();

    // Set the starting screen position
    FLOAT sx = fOriginX;
    FLOAT sy = fOriginY;

    // If vertically centered, offset the starting sy value
    if( dwFlags & XBFONT_CENTER_Y )
    {
        FLOAT w, h;
        GetTextExtent( strText, &w, &h );
        sy = floorf( sy - h/2 );
    }

    // Set a flag so we can determine initial justification effects
    BOOL bStartingNewLine = TRUE;

    while( *strText )
    {
        // If starting text on a new line, determine justification effects
        if( bStartingNewLine )
        {
            if( dwFlags & (XBFONT_RIGHT|XBFONT_CENTER_X) )
            {
                // Get the extent of this line
                FLOAT w, h;
                GetTextExtent( strText, &w, &h, TRUE );

                // Offset this line's starting sx value
                if( dwFlags & XBFONT_RIGHT )
                    sx = floorf( fOriginX - w );
                if( dwFlags & XBFONT_CENTER_X )
                    sx = floorf( fOriginX - w/2 );
            }
            bStartingNewLine = FALSE;
        }

        // Get the current letter in the string
        WCHAR letter = *strText++;

        // Handle the newline character
        if( letter == L'\n' )
        {
            sx  = fOriginX;
            sy += m_dwFontHeight;
            bStartingNewLine = TRUE;
        }

        // Skip invalid characters
        if( letter<m_cLowChar || letter>m_cHighChar )
            continue;

        // Get the glyph for this character
        GLYPH_ATTR* pGlyph = &m_Glyphs[letter-m_cLowChar];

        // Setup the screen coordinates (note the 0.5f shift value which is to
        // align texel centers with pixel centers)
        sx += pGlyph->wOffset;
        FLOAT sx1 = sx - 0.5f;
        FLOAT sx2 = sx - 0.5f + ((FLOAT)pGlyph->wWidth + 1);
        FLOAT sy1 = sy - 0.5f;
        FLOAT sy2 = sy - 0.5f + ((FLOAT)m_dwFontHeight + 1);
        sx += pGlyph->wAdvance;

        // Setup the texture coordinates (note the fudge factor for converting
        // from integer texel values to floating point texture coords).
        FLOAT tx1 = ( pGlyph->left   * ( m_dwTexWidth-1) ) / m_dwTexWidth;
        FLOAT ty1 = ( pGlyph->top    * (m_dwTexHeight-1) ) / m_dwTexHeight;
        FLOAT tx2 = ( pGlyph->right  * ( m_dwTexWidth-1) ) / m_dwTexWidth;
        FLOAT ty2 = ( pGlyph->bottom * (m_dwTexHeight-1) ) / m_dwTexHeight;

        // Set up the vertices (1 quad = 2 triangles = 6 vertices)
        *m_pVertices++ = InitFontVertex( D3DXVECTOR4(sx1,sy2,0.0f,0.0f), dwColor, tx1, ty2 );
        *m_pVertices++ = InitFontVertex( D3DXVECTOR4(sx1,sy1,0.0f,0.0f), dwColor, tx1, ty1 );
        *m_pVertices++ = InitFontVertex( D3DXVECTOR4(sx2,sy1,0.0f,0.0f), dwColor, tx2, ty1 );
        *m_pVertices++ = InitFontVertex( D3DXVECTOR4(sx2,sy2,0.0f,0.0f), dwColor, tx2, ty2 );
        m_dwNumQuads++;

        // If the vertex buffer is full, render it. This will stall the GPU, so
        // we should sure that XBFONT_MAX_VERTICES is big enough.
        if( (m_dwNumQuads+1)*4 > XBFONT_MAX_VERTICES )
        {
            // Unlock, render, and relock the vertex buffer
            m_pVB->Unlock();
            Render();
            m_pVB->Lock( 0, 0, (BYTE**)&m_pVertices, 0L );
            m_dwNumQuads = 0L;
        }
    }

    // Call End() to complete the begin/end pair for drawing text
    End();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: End()
// Desc: Called after Begin(), this function triggers the rendering of the
//       vertex buffer contents filled during calls to DrawText().
//-----------------------------------------------------------------------------
HRESULT CXBFont::End()
{
    // Keep track of nested calls to begin/end.
    if( 0L == m_dwNestedBeginCount )
        return E_FAIL;
    if( --m_dwNestedBeginCount > 0 )
        return S_OK;
    
    // Unlock the vertex buffer
    m_pVB->Unlock();

    // Render the contents of the vertex buffer
    if( m_dwNumQuads > 0 )
        Render();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: The internal call to actually render the vertices.
//-----------------------------------------------------------------------------
HRESULT CXBFont::Render()
{
    // Set the necessary renderstates
    m_pd3dDevice->SetTexture( 0, m_pTexture );
    m_pd3dDevice->SetStreamSource( 0, m_pVB, sizeof(XBFONTVERTEX) );
    m_pd3dDevice->SetVertexShader( D3DFVF_XBFONTVERTEX );
    m_pd3dDevice->SetPixelShader( NULL );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,         D3DBLEND_SRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND,        D3DBLEND_INVSRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHAREF,         0x08 );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHAFUNC,        D3DCMP_GREATEREQUAL );
    m_pd3dDevice->SetRenderState( D3DRS_FILLMODE,         D3DFILL_SOLID );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,         D3DCULL_CCW );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGENABLE,        FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGTABLEMODE,     D3DFOG_NONE );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILENABLE,    FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_EDGEANTIALIAS,    FALSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXCOORDINDEX, 0 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_NONE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );

    // Render the vertex buffer
    m_pd3dDevice->DrawPrimitive( D3DPT_QUADLIST, 0, m_dwNumQuads );

    // We can restore state here, if we like. Unfortunately, for generic use,
    // it's hard to guess what state the app will want everything restored to.

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RenderToTexture()
// Desc: Creates a texture and renders a text string into it. The texture
//       format defaults to a 32-bit linear texture
//-----------------------------------------------------------------------------
LPDIRECT3DTEXTURE8 CXBFont::CreateTexture( const WCHAR* strText, 
                                           D3DCOLOR dwBackgroundColor, 
                                           D3DCOLOR dwTextColor, 
                                           D3DFORMAT d3dFormat )
{
    // Calculate texture dimensions
    FLOAT fTexWidth;
    FLOAT fTexHeight;
    GetTextExtent( strText, &fTexWidth, &fTexHeight );
    DWORD dwWidth  = (DWORD)fTexWidth;
    DWORD dwHeight = (DWORD)fTexHeight;

    switch( d3dFormat )
    {
        case D3DFMT_A8R8G8B8:
        case D3DFMT_X8R8G8B8:
        case D3DFMT_R5G6B5:
        case D3DFMT_X1R5G5B5:
            // For swizzled textures, make sure the dimensions are a power of two
            for( DWORD wmask=1; dwWidth&(dwWidth-1); wmask = (wmask<<1)+1 )
                dwWidth  = ( dwWidth + wmask ) & ~wmask;
            for( DWORD hmask=1; dwHeight&(dwHeight-1); hmask = (hmask<<1)+1 )
                dwHeight = ( dwHeight + hmask ) & ~hmask;
            break;

        case D3DFMT_LIN_A8R8G8B8:
        case D3DFMT_LIN_X8R8G8B8:
        case D3DFMT_LIN_R5G6B5:
        case D3DFMT_LIN_X1R5G5B5:
            // For linear textures, make sure the stride is a multiple of 64 bytes
            dwWidth  = ( dwWidth + 0x1f ) & ~0x1f;
            break;

        default:
            // All other formats are unsupported as render targets
            return NULL;
    }

    // Create the texture
    LPDIRECT3DTEXTURE8 pTexture;
    if( FAILED( m_pd3dDevice->CreateTexture( dwWidth, dwHeight, 1, 0L, d3dFormat, 
                                             D3DPOOL_DEFAULT, &pTexture ) ) )
        return NULL;
    
    // Get the current backbuffer and zbuffer
    LPDIRECT3DSURFACE8 pBackBuffer, pZBuffer;
    m_pd3dDevice->GetRenderTarget( &pBackBuffer );
    m_pd3dDevice->GetDepthStencilSurface( &pZBuffer );

    // Set the new texture as the render target
    LPDIRECT3DSURFACE8 pTextureSurface;
    pTexture->GetSurfaceLevel( 0, &pTextureSurface );
    D3DVIEWPORT8 vp = { 0, 0, dwWidth, dwHeight, 0.0f, 1.0f };
    m_pd3dDevice->SetRenderTarget( pTextureSurface, NULL );
    m_pd3dDevice->SetViewport( &vp );
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET, dwBackgroundColor, 1.0f, 0L );

    // Render the text
    DrawText( 0, 0, dwTextColor, strText, 0L );

    // Restore the rendertarget
    D3DVIEWPORT8 vpBackBuffer = { 0, 0, 640, 480, 0.0f, 1.0f };
    m_pd3dDevice->SetRenderTarget( pBackBuffer, pZBuffer );
    m_pd3dDevice->SetViewport( &vpBackBuffer );
    SAFE_RELEASE( pBackBuffer );
    SAFE_RELEASE( pZBuffer );
    SAFE_RELEASE( pTextureSurface );

    // Return the new texture
    return pTexture;
}




//-----------------------------------------------------------------------------
// Name: ReplaceInvalidChars()
// Desc: Replaces any character that does not have a glyph in the font with
//       the specified character value. Function is useful for replacing
//       invalid characters with the null "box" character.
//-----------------------------------------------------------------------------
VOID CXBFont::ReplaceInvalidChars( WCHAR* strUpdate, WCHAR cReplacement ) const
{
    // TCR 3-26 Unsupported Characters
    for( ; *strUpdate; ++strUpdate )
    {
        WCHAR cLetter = *strUpdate;
        if( cLetter == L'\n' )
            continue;
        if( cLetter < m_cLowChar || cLetter > m_cHighChar )
            *strUpdate = cReplacement;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\src\XbMemUnit.cpp ===
//-----------------------------------------------------------------------------
// File: XbMemUnit.cpp
//
// Desc: Memory unit object wraps XGetDeviceChanges( XDEVICE_TYPE_MEMORY_UNIT )
//       and XMount/UnmountMU
//
// Hist: 01.29.01 - New for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "XbMemUnit.h"
#include <cassert>




//-----------------------------------------------------------------------------
// Name: CXBMemUnit()
// Desc: Creates an unmounted memory unit
//-----------------------------------------------------------------------------
CXBMemUnit::CXBMemUnit()
:
    m_dwPort( 0 ),
    m_dwSlot( 0 ),
    m_chLogicalDrive( 0 )
{
}




//-----------------------------------------------------------------------------
// Name: CXBMemUnit()
// Desc: Creates and mounts the given memory unit
//-----------------------------------------------------------------------------
CXBMemUnit::CXBMemUnit( DWORD dwPort, DWORD dwSlot, DWORD& dwError )
:
    m_dwPort( 0 ),
    m_dwSlot( 0 ),
    m_chLogicalDrive( 0 )
{
    Mount( dwPort, dwSlot, dwError );
}




//-----------------------------------------------------------------------------
// Name: CXBMemUnit()
// Desc: Copies the given memory unit. Note: You cannot mount a device more 
//       than once. CXBMemUnit is a lightweight wrapper that doesn't
//       implement reference counting. Therefore, the only safe copy is a 
//       copy of an unmounted MU. This function asserts if the source
//       MU is already mounted.
//-----------------------------------------------------------------------------
CXBMemUnit::CXBMemUnit( const CXBMemUnit& rhs )
:
    m_dwPort( 0 ),
    m_dwSlot( 0 ),
    m_chLogicalDrive( 0 )
{
    assert( !rhs.IsMounted() );
    (VOID)rhs;
}



//-----------------------------------------------------------------------------
// Name: CXBMemUnit()
// Desc: Copies the given memory unit. Note: You cannot mount a device more 
//       than once. CXBMemUnit is a lightweight wrapper that doesn't
//       implement reference counting. Therefore, the only safe copy is a 
//       copy of an unmounted MU. This function asserts if the source
//       MU is already mounted.
//-----------------------------------------------------------------------------
CXBMemUnit& CXBMemUnit::operator=( const CXBMemUnit& rhs )
{
    assert( !rhs.IsMounted() );
    (VOID)rhs;
    Unmount();
    return *this;
}




//-----------------------------------------------------------------------------
// Name: ~CXBMemUnit()
// Desc: Unmounts the memory unit
//-----------------------------------------------------------------------------
CXBMemUnit::~CXBMemUnit()
{
    Unmount();
}




//-----------------------------------------------------------------------------
// Name: Mount()
// Desc: Mounts the memory unit in preparation for saving/loading. If
//       successful, GetDrive() will contain the drive mapping for the MU.
//-----------------------------------------------------------------------------
BOOL CXBMemUnit::Mount( DWORD dwPort, DWORD dwSlot, DWORD& dwError )
{
    Unmount();
    CHAR chDrive;
    dwError = XMountMU( dwPort, dwSlot, &chDrive );
    if( dwError != ERROR_SUCCESS )
        return FALSE;

    m_dwPort = dwPort;
    m_dwSlot = dwSlot;
    m_chLogicalDrive = chDrive;
    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: Unmount()
// Desc: Unmounts the memory unit when it is no longer used. If successful,
//       calls to IsMounted() will return FALSE.
//-----------------------------------------------------------------------------
VOID CXBMemUnit::Unmount()
{
    if( IsMounted() )
    {
        DWORD dwSuccess = XUnmountMU( m_dwPort, m_dwSlot );
        assert( dwSuccess == ERROR_SUCCESS );
        (VOID)dwSuccess;
        m_dwPort = 0;
        m_dwSlot = 0;
        m_chLogicalDrive = 0;
    }
}




//-----------------------------------------------------------------------------
// Name: IsMounted()
// Desc: Returns TRUE if the MU has been successfully mounted via the default
//       ctor or Mount().
//-----------------------------------------------------------------------------
BOOL CXBMemUnit::IsMounted() const
{
    return( m_chLogicalDrive != 0 );
}




//-----------------------------------------------------------------------------
// Name: GetDrive()
// Desc: Returns the logical drive mapping for the MU. Returns 0 if the MU 
//       is not mounted.
//-----------------------------------------------------------------------------
CHAR CXBMemUnit::GetDrive() const
{
    return m_chLogicalDrive;
}




//-----------------------------------------------------------------------------
// Name: GetPort()
// Desc: Returns the MU port (XDEVICE_PORT0-3)
//-----------------------------------------------------------------------------
DWORD CXBMemUnit::GetPort() const
{
    return m_dwPort;
}




//-----------------------------------------------------------------------------
// Name: GetSlot()
// Desc: Returns the MU slot (XDEVICE_TOP_SLOT or XDEVICE_BOTTOM_SLOT)
//-----------------------------------------------------------------------------
DWORD CXBMemUnit::GetSlot() const
{
    return m_dwSlot;
}




//-----------------------------------------------------------------------------
// Name: GetMemUnitSnapshot()
// Desc: Calls XGetDevices( XDEVICE_TYPE_MEMORY_UNIT ) to determine
//       what MUs are available. Returns a bitmask corresponding to the
//       installed MUs. May take on the order of 1 second.
//-----------------------------------------------------------------------------
DWORD CXBMemUnit::GetMemUnitSnapshot() // static
{
    return XGetDevices( XDEVICE_TYPE_MEMORY_UNIT );
}




//-----------------------------------------------------------------------------
// Name: GetMemUnitChanges()
// Desc: Calls XGetDeviceChanges( XDEVICE_TYPE_MEMORY_UNIT ) to determine
//       which MUs have been added or removed since the last call to
//       GetMemUnitChanges() or GetMemUnitShapshot(). Returns TRUE if there 
//       were any dynamic insertions or removals since the last call to
//       GetMemUnitChanges() or GetMemUnitSnapshot(). Parameters return
//       bitmasks indicating what devices have changed.
//-----------------------------------------------------------------------------
BOOL CXBMemUnit::GetMemUnitChanges( DWORD& dwInsertions, DWORD& dwRemovals ) // static
{
    return XGetDeviceChanges( XDEVICE_TYPE_MEMORY_UNIT, &dwInsertions, &dwRemovals );
}




//-----------------------------------------------------------------------------
// Name: GetMemUnitMask()
// Desc: Given an MU index, returns the matching bitmask used by 
//       XGetDevices( XDEVICE_TYPE_MEMORY_UNIT )
//-----------------------------------------------------------------------------
DWORD CXBMemUnit::GetMemUnitMask( DWORD i ) // static
{
    // The XGetDevices bitmask is formatted as follows:
    //
    //      0x00000001      port 0 top slot         i = 0
    //      0x00010000      port 0 bottom slot          1
    //      0x00000002      port 1 top slot             2
    //      0x00020000      port 1 bottom slot          3
    //      0x00000004      port 2 top slot             4
    //      0x00040000      port 2 bottom slot          5
    //      0x00000008      port 3 top slot             6
    //      0x00080000      port 3 bottom slot          7

    DWORD dwMask = 1 << GetMemUnitPort( i );
    if( GetMemUnitSlot( i ) == XDEVICE_BOTTOM_SLOT )
        dwMask <<= 16;

    return( dwMask );
}




//-----------------------------------------------------------------------------
// Name: GetMemUnitPort()
// Desc: Given an MU index, returns the port number for the MU
//-----------------------------------------------------------------------------
DWORD CXBMemUnit::GetMemUnitPort( DWORD i ) // static
{
    return( i / 2 );
}




//-----------------------------------------------------------------------------
// Name: GetMemUnitSlot()
// Desc: Given an MU index, returns the slot identifier for the MU
//-----------------------------------------------------------------------------
DWORD CXBMemUnit::GetMemUnitSlot( DWORD i ) // static
{
    return( ( i % 2 ) ? XDEVICE_BOTTOM_SLOT : XDEVICE_TOP_SLOT );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\src\XbConfig.cpp ===
//-----------------------------------------------------------------------------
// File: XbConfig.cpp
//
// Desc: Config object wraps XQueryValue
//
// Hist: 03.02.01 - New for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "XbConfig.h"
#include <cassert>




//-----------------------------------------------------------------------------
// Globals (cached for speed)
//-----------------------------------------------------------------------------
DWORD CXBConfig::mLanguage = 0xFFFFFFFF;




//-----------------------------------------------------------------------------
// Name: GetLanguage()
// Desc: The current language setting
//-----------------------------------------------------------------------------
DWORD CXBConfig::GetLanguage()
{
    // TCR 3-14 Global Language Setting
    if( mLanguage == 0xFFFFFFFF )
        mLanguage = XGetLanguage();
    return mLanguage;
}



//-----------------------------------------------------------------------------
// Name: FormatDateTime()
// Desc: Formats the incoming date/time value in the proper format for
//       the current language setting.
//
//       ftZulu must be the time in UTC format, e.g. result from FindFirstFile
//       strDate is the formatted date result. NULL allowed. Minimum 11 bytes.
//       strTime is the formatted time result. NULL allowed. Minimum 12 bytes.
//-----------------------------------------------------------------------------
VOID CXBConfig::FormatDateTime( const FILETIME& ftZulu, CHAR* strDate, 
                                CHAR* strTime, BOOL bIncludeSeconds )
{
    // TCR 1-13 Display Time
    // TCR 3-15 Global Time Zone Setting

    // Convert to local time
    FILETIME ftTimeLocal;
    FileTimeToLocalFileTime( &ftZulu, &ftTimeLocal );

    // Extract date/time data
    SYSTEMTIME SystemTime;
    FileTimeToSystemTime( &ftTimeLocal, &SystemTime );

    // Format the date
    if( strDate != NULL )
    {
        const CHAR* strDateFormat = "%d/%d/%d";
        switch( GetLanguage() )
        {
            case XC_LANGUAGE_ENGLISH:  // mm/dd/yyyy
                wsprintfA( strDate, strDateFormat, SystemTime.wMonth,
                           SystemTime.wDay, SystemTime.wYear );
                break;

            case XC_LANGUAGE_JAPANESE: // yyyy/mm/dd
                wsprintfA( strDate, strDateFormat, SystemTime.wYear,
                           SystemTime.wMonth, SystemTime.wDay  );
                break;

            case XC_LANGUAGE_GERMAN:   // dd.mm.yyyy
                wsprintfA( strDate, "%d.%d.%d", SystemTime.wDay, 
                           SystemTime.wMonth, SystemTime.wYear );
                break;

            case XC_LANGUAGE_FRENCH:   // dd/mm/yyyy
            case XC_LANGUAGE_SPANISH:  // dd/mm/yyyy
            case XC_LANGUAGE_ITALIAN:  // dd/mm/yyyy
            default:
                wsprintfA( strDate, strDateFormat, SystemTime.wDay,
                           SystemTime.wMonth, SystemTime.wYear );
                break;
        }
    }

    // Format the time
    if( strTime != NULL )
    {
        const WORD wHalfDay = 12;
        WORD wHour12 = 0;
        BOOL bUse24Hour = ( GetLanguage() != XC_LANGUAGE_ENGLISH );
        if( !bUse24Hour )
        {
            // Convert base 24 hours to base 12 hours
            wHour12 = SystemTime.wHour;
            if( wHour12 >= wHalfDay )
                wHour12 -= wHalfDay;
            if( wHour12 == 0 )
                wHour12 = wHalfDay;
        }

        // hh:mm
        wsprintfA( strTime, "%d:%2.2d", bUse24Hour ? SystemTime.wHour : wHour12,
                   SystemTime.wMinute );

        // append :ss if desired
        if( bIncludeSeconds )
        {
            CHAR strSeconds[3];
            wsprintfA( strSeconds, ":%2.2d", SystemTime.wSecond );
            lstrcatA( strTime, strSeconds );
        }

        // append AM/PM if not 24-hour clock
        if( !bUse24Hour )
            lstrcatA( strTime, ( SystemTime.wHour < wHalfDay ) ? " AM" : " PM" );
    }
}




//-----------------------------------------------------------------------------
// Name: FormatInt()
// Desc: Formats the incoming integer into the proper format for the current
//       language setting, including thousands separators. Minimum size for
//       strNumber is 15 bytes.
//-----------------------------------------------------------------------------
VOID CXBConfig::FormatInt( INT nValue, CHAR* strNumber )
{
    const INT RADIX = 10;       // Base 10

    // Format normally; no separtors here
    _itoa( nValue, strNumber, RADIX );

    // Determine number of separators to insert, if any
    INT nLen = lstrlenA( strNumber );
    INT nSeparators = ( nLen - 1 ) / 3;
    if( nSeparators <= 0 )
        return;

    // Separator character is based on language
    CHAR cSeparator = GetThousandsSeparator();

    // Insert separators in place via backward walk
    CHAR* pDest = strNumber + nLen + nSeparators;
    const CHAR* pSrc = strNumber + nLen;
    for( INT i = 0; i < nLen; ++i, --pDest, --pSrc )
    {
        *pDest = *pSrc;
        if( i && ( i % 3 == 0 ) )
        {
            --pDest;
            *pDest = cSeparator;
        }
    }
}




//-----------------------------------------------------------------------------
// Name: FormatFloat()
// Desc: Formats the incoming float into the proper format for the current
//       language setting. Includes thousands separators if desired.
//       nCount indicates number of chars after the decimal point. If
//       nCount is 0, the decimal point is not included. If nCount is less
//       than 0, the decimal point is not included if fValue > 1.0.
//       strNumber minimum size depends on fValue and nCount.
//-----------------------------------------------------------------------------
VOID CXBConfig::FormatFloat( DOUBLE fValue, CHAR* strNumber, INT nCount,
                             BOOL bThousandsSep )
{
    // Format normally; no decimal point or separators here
    INT nDecimalPtPos;
    INT nSign;
    CHAR* strDigits = _fcvt( fValue, (nCount < 0) ? 0 : nCount, 
                             &nDecimalPtPos, &nSign );

    CHAR cDecimal = GetDecimalSymbol();
    CHAR cSeparator = GetThousandsSeparator();

    // Sign
    if( nSign != 0 )
        *strNumber++ = '-';

    // If fValue < 1.0, include the zero before the decimal point
    if( nDecimalPtPos <= 0 )
    {
        *strNumber++ = '0';
        if( nCount > 0 )
        {
            *strNumber++ = cDecimal;
            for( INT i = nDecimalPtPos; i < 0; ++i )
                *strNumber++ = '0';
        }
    }

    // Copy the floating point digits, adding separators and the decimal symbol
    INT nOffset = 2 - ( ( nDecimalPtPos + 1 ) % 3 );
    for( INT i = 0; *strDigits ; ++i, ++strDigits )
    {
        *strNumber++ = *strDigits;

        // Thousands separator
        if( ( bThousandsSep ) && 
            ( nDecimalPtPos > 3 ) && 
            ( i < nDecimalPtPos - 1 ) && 
            ( ( ( i + nOffset ) % 3 ) == 0 ) )
        {
            *strNumber++ = cSeparator;
        }

        // Decimal point
        if( i + 1 == nDecimalPtPos && nCount > 0 )
            *strNumber++ = cDecimal;
    }

    // Slam in the null char
    *strNumber = 0;
}




//-----------------------------------------------------------------------------
// Name: GetDecimalSymbol()
// Desc: Returns the character for the decimal symbol based on the current
//       language.
//-----------------------------------------------------------------------------
CHAR CXBConfig::GetDecimalSymbol()
{
    switch( GetLanguage() )
    {
        default:
        case XC_LANGUAGE_ENGLISH:
        case XC_LANGUAGE_JAPANESE: return( '.' );
        case XC_LANGUAGE_GERMAN:
        case XC_LANGUAGE_FRENCH:
        case XC_LANGUAGE_SPANISH:
        case XC_LANGUAGE_ITALIAN:  return( ',' );
    }
}




//-----------------------------------------------------------------------------
// Name: GetThousandsSeparator()
// Desc: Returns the character for the separator symbol based on the current
//       language.
//-----------------------------------------------------------------------------
CHAR CXBConfig::GetThousandsSeparator()
{
    switch( GetLanguage() )
    {
        default:
        case XC_LANGUAGE_ENGLISH:
        case XC_LANGUAGE_JAPANESE: return( ',' );
        case XC_LANGUAGE_FRENCH:   return( ' ' );
        case XC_LANGUAGE_GERMAN:
        case XC_LANGUAGE_SPANISH:
        case XC_LANGUAGE_ITALIAN:  return( '.' );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\src\xbmesh.cpp ===
//-----------------------------------------------------------------------------
// File: XBMesh.cpp
//
// Desc: Support code for loading geometry stored in .xbg files. See the
//       <XBMesh.h> header file for information on using this class.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       03.15.01 - Mass changes (removed D3DX and .x support) for April XDK
//       04.15.01 - Using packed resources for May XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xgmath.h>
#include <stdio.h>
#include "XBMesh.h"
#include "XBUtil.h"




//-----------------------------------------------------------------------------
// Name: CXBMesh()
// Desc: 
//-----------------------------------------------------------------------------
CXBMesh::CXBMesh()
{
    m_pAllocatedSysMem = NULL;
    m_pAllocatedVidMem = NULL;
    m_pMeshFrames      = NULL;
    m_dwNumFrames      = 0;
    m_dwRefCount       = 1L;
}




//-----------------------------------------------------------------------------
// Name: ~CXBMesh()
// Desc: 
//-----------------------------------------------------------------------------
CXBMesh::~CXBMesh()
{
    // Free textures
    for( DWORD i=0; i<m_dwNumFrames; i++ )
    {
        for( DWORD j = 0; j < m_pMeshFrames[i].m_MeshData.m_dwNumSubsets; j++ )
        {
            SAFE_RELEASE( m_pMeshFrames[i].m_MeshData.m_pSubsets[j].pTexture );
        }
    }

    // Free alloacted memory
    if( m_pAllocatedSysMem )
        delete[] m_pAllocatedSysMem;

    if( m_pAllocatedVidMem )
        D3D_FreeContiguousMemory( m_pAllocatedVidMem );
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBMesh::Create( LPDIRECT3DDEVICE8 pd3dDevice, CHAR* strFilename,
                         CXBPackedResource* pResource )
{
    // Find the media file
    CHAR strMeshPath[512];
    if( FAILED( XBUtil_FindMediaFile( strMeshPath, strFilename ) ) )
        return E_FAIL;

    // Open the file
    FILE* file = fopen( strMeshPath, "rb" );
    if( file == NULL )
    {
        OutputDebugString( _T("CXBFile::Create(): ERROR: File not found!\n") );
        return E_FAIL;
    }

    // Read the magic number
    DWORD dwFileID;
    fread( &dwFileID, 1, sizeof(DWORD), file ); 

    if( dwFileID != XBG_FILE_ID )
    {
        OutputDebugString( _T("CXBFile::Create(): ERROR: Invalid XBG file type!\n") );
        fclose( file );
        return E_FAIL;
    }

    // Read in header
    DWORD dwNumFrames;  // Number of mesh frames in the file
    DWORD dwSysMemSize; // Num bytes needed for system memory objects
    DWORD dwVidMemSize; // Num bytes needed for video memory objects

    fread( &dwNumFrames,  1, sizeof(DWORD), file );
    fread( &dwSysMemSize, 1, sizeof(DWORD), file );
    fread( &dwVidMemSize, 1, sizeof(DWORD), file );

    // Read in system memory objects
    m_pAllocatedSysMem = (VOID*)new BYTE[dwSysMemSize];
    fread( m_pAllocatedSysMem, dwSysMemSize, 1, file );

    // Read in video memory objects
    m_pAllocatedVidMem = D3D_AllocContiguousMemory( dwVidMemSize, D3DVERTEXBUFFER_ALIGNMENT );
    fread( m_pAllocatedVidMem, dwVidMemSize, 1, file ); 
    
    // Done with the file
    fclose( file );

    // Now we need to patch the mesh data. Any pointers read from the file were
    // stored as file offsets. So, we simply need to add a base address to patch
    // things up.
    m_pMeshFrames = (XBMESH_FRAME*)m_pAllocatedSysMem;
    m_dwNumFrames = dwNumFrames;

    for( DWORD i=0; i<m_dwNumFrames; i++ )
    {
        XBMESH_FRAME* pFrame = &m_pMeshFrames[i];
        XBMESH_DATA*  pMesh  = &m_pMeshFrames[i].m_MeshData;

        if( pFrame->m_pChild )
            pFrame->m_pChild  = (XBMESH_FRAME*)( (DWORD)pFrame->m_pChild - 16 + (DWORD)m_pMeshFrames );
        if( pFrame->m_pNext )
            pFrame->m_pNext   = (XBMESH_FRAME*)( (DWORD)pFrame->m_pNext  - 16 + (DWORD)m_pMeshFrames );
        if( pMesh->m_pSubsets )
            pMesh->m_pSubsets = (XBMESH_SUBSET*)( (DWORD)pMesh->m_pSubsets - 16 + (DWORD)m_pMeshFrames);
        
        if( pMesh->m_dwNumIndices )
            pMesh->m_IB.Data  = pMesh->m_IB.Data - 16 + (DWORD)m_pMeshFrames;
        if( pMesh->m_dwNumVertices )
            pMesh->m_VB.Register( m_pAllocatedVidMem );
    }

    // Finally, create any textures used by the meshes' subsets. In this 
    // implementation, we are pulling textures out of the passed in resource.
    if( pResource )
    {
        for( DWORD i=0; i<m_dwNumFrames; i++ )
        {
            XBMESH_DATA* pMesh = &m_pMeshFrames[i].m_MeshData;

            for( DWORD j = 0; j < pMesh->m_dwNumSubsets; j++ )
            {
                XBMESH_SUBSET* pSubset = &pMesh->m_pSubsets[j];

                pSubset->pTexture = pResource->GetTexture( pSubset->strTexture );
            }
        }
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Renders the hierarchy of frames and meshes.
//-----------------------------------------------------------------------------
HRESULT CXBMesh::Render( LPDIRECT3DDEVICE8 pd3dDevice, DWORD dwFlags )
{
    if( m_pMeshFrames )
        RenderFrame( pd3dDevice, m_pMeshFrames, dwFlags );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RenderFrame()
// Desc: Renders a frame (save state, apply matrix, render children, restore).
//-----------------------------------------------------------------------------
HRESULT CXBMesh::RenderFrame( LPDIRECT3DDEVICE8 pd3dDevice, XBMESH_FRAME* pFrame, 
                              DWORD dwFlags )
{
    // Apply the frame's local transform
    D3DXMATRIX matSavedWorld, matWorld;
    pd3dDevice->GetTransform( D3DTS_WORLD, &matSavedWorld );
    D3DXMatrixMultiply( &matWorld, &pFrame->m_matTransform, &matSavedWorld );
    pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

    // Render the mesh data
    if( pFrame->m_MeshData.m_dwNumSubsets ) 
        RenderMesh( pd3dDevice, &pFrame->m_MeshData, dwFlags );

    // Render any child frames
    if( pFrame->m_pChild ) 
        RenderFrame( pd3dDevice, pFrame->m_pChild, dwFlags );

    // Restore the transformation matrix
    pd3dDevice->SetTransform( D3DTS_WORLD, &matSavedWorld );
    
    // Render any sibling frames
    if( pFrame->m_pNext )  
        RenderFrame( pd3dDevice, pFrame->m_pNext, dwFlags );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RenderMesh()
// Desc: Renders the mesh geometry.
//-----------------------------------------------------------------------------
HRESULT CXBMesh::RenderMesh( LPDIRECT3DDEVICE8 pd3dDevice, XBMESH_DATA* pMesh, 
                             DWORD dwFlags )
{
    D3DVertexBuffer* pVB           = &pMesh->m_VB;
    DWORD            dwNumVertices =  pMesh->m_dwNumVertices;
    D3DIndexBuffer*  pIB           = &pMesh->m_IB;
    DWORD            dwNumIndices  =  pMesh->m_dwNumIndices;
    DWORD            dwFVF         =  pMesh->m_dwFVF;
    DWORD            dwVertexSize  =  pMesh->m_dwVertexSize;
    D3DPRIMITIVETYPE dwPrimType    =  pMesh->m_dwPrimType;
    DWORD            dwNumSubsets  =  pMesh->m_dwNumSubsets;
    XBMESH_SUBSET*   pSubsets      = &pMesh->m_pSubsets[0];

    if( dwNumVertices == 0 )
        return S_OK;

    // Set the vertex stream
    pd3dDevice->SetStreamSource( 0, pVB, dwVertexSize );
    pd3dDevice->SetIndices( pIB, 0 );

    // Set the FVF code, unless the user asked us not to
    if( 0 == ( dwFlags & XBMESH_NOFVF ) )
        pd3dDevice->SetVertexShader( dwFVF );

    // Render the subsets
    for( DWORD i = 0; i < dwNumSubsets; i++ )
    {
        BOOL bRender = FALSE;

        // Render the opaque subsets, unless the user asked us not to
        if( 0 == ( dwFlags & XBMESH_ALPHAONLY ) )
        {
            if( 0 == ( dwFlags & XBMESH_NOMATERIALS ) )
            {
                if( pSubsets[i].mtrl.Diffuse.a >= 1.0f )
                    bRender = TRUE;
            }
            else
                bRender = TRUE;
        }

        // Render the transparent subsets, unless the user asked us not to
        if( 0 == ( dwFlags & XBMESH_OPAQUEONLY ) )
        {
            if( 0 == ( dwFlags & XBMESH_NOMATERIALS ) )
            {
                if( pSubsets[i].mtrl.Diffuse.a < 1.0f )
                    bRender = TRUE;
            }
        }

        if( bRender )
        {
            // Set the material, unless the user asked us not to
            if( 0 == ( dwFlags & XBMESH_NOMATERIALS ) )
                pd3dDevice->SetMaterial( &pSubsets[i].mtrl );

            // Set the texture, unless the user asked us not to
            if( 0 == ( dwFlags & XBMESH_NOTEXTURES ) )
                pd3dDevice->SetTexture( 0, pSubsets[i].pTexture );

            // Call the callback, so the app can tweak state before rendering
            // each subset
            BOOL bRenderSubset = RenderCallback( pd3dDevice, i, &pSubsets[i], dwFlags );

            // Draw the mesh subset
            if( bRenderSubset )
            {
                DWORD dwNumPrimitives = ( D3DPT_TRIANGLESTRIP == dwPrimType ) ? pSubsets[i].dwIndexCount-2 : pSubsets[i].dwIndexCount/3;
                pd3dDevice->DrawIndexedPrimitive( dwPrimType, 0, pSubsets[i].dwIndexCount,
                                                  pSubsets[i].dwIndexStart, dwNumPrimitives );
            }
        }
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: ComputeRadius()
// Desc: Finds the farthest point from zero on the mesh.
//-----------------------------------------------------------------------------
FLOAT CXBMesh::ComputeRadius()
{
    D3DXMATRIX matIdentity;
    D3DXMatrixIdentity( &matIdentity );

    return ComputeFrameRadius( m_pMeshFrames, &matIdentity );
}




//-----------------------------------------------------------------------------
// Name: ComputeFrameRadius()
// Desc: Calls ComputeMeshRadius for each frame with the correct transform.
//-----------------------------------------------------------------------------
FLOAT CXBMesh::ComputeFrameRadius( XBMESH_FRAME* pFrame, D3DXMATRIX* pmatParent )
{
    // Apply the frame's local transform
    D3DXMATRIX matWorld;
    D3DXMatrixMultiply( &matWorld, &pFrame->m_matTransform, pmatParent );

    FLOAT fRadius = 0.0f;

    // Compute bounds for the mesh data
    if( pFrame->m_MeshData.m_dwNumSubsets ) 
        fRadius = ComputeMeshRadius( &pFrame->m_MeshData, &matWorld );

    // Compute bounds for any child frames
    if( pFrame->m_pChild ) 
    {
        FLOAT fChildRadius = ComputeFrameRadius( pFrame->m_pChild, &matWorld  );

        if( fChildRadius > fRadius )
            fRadius = fChildRadius;
    }

    // Compute bounds for any sibling frames
    if( pFrame->m_pNext )  
    {
        FLOAT fSiblingRadius = ComputeFrameRadius( pFrame->m_pNext, pmatParent );

        if( fSiblingRadius > fRadius )
            fRadius = fSiblingRadius;
    }

    return fRadius;
}




//-----------------------------------------------------------------------------
// Name: ComputeMeshRadius()
// Desc: Finds the farthest point from zero on the mesh.
//-----------------------------------------------------------------------------
FLOAT CXBMesh::ComputeMeshRadius( XBMESH_DATA* pMesh, D3DXMATRIX* pmat )
{
    DWORD       dwNumVertices = pMesh->m_dwNumVertices;
    DWORD       dwVertexSize  = pMesh->m_dwVertexSize;
    BYTE*       pVertices;
    D3DXVECTOR3 vPos;
    FLOAT       fMaxDist2 = 0.0f;

    pMesh->m_VB.Lock( 0, 0, &pVertices, 0 );

    while( dwNumVertices-- )
    {
        D3DXVec3TransformCoord( &vPos, (D3DXVECTOR3*)pVertices, pmat );

        FLOAT fDist2 = vPos.x*vPos.x + vPos.y*vPos.y + vPos.z*vPos.z;

        if( fDist2 > fMaxDist2 )
            fMaxDist2 = fDist2;

        pVertices += dwVertexSize;
    }

    pMesh->m_VB.Unlock();

    return sqrtf( fMaxDist2 );
}

//-----------------------------------------------------------------------------
//  Take the union of two boxes
//-----------------------------------------------------------------------------
inline float MAX(float a, float b) { return a > b ? a : b; }
inline float MIN(float a, float b) { return a < b ? a : b; }
static void UnionBox(D3DXVECTOR3 *pvMin, D3DXVECTOR3 *pvMax, const D3DXVECTOR3 &vMin, const D3DXVECTOR3 &vMax)
{
	pvMin->x = MIN(pvMin->x, vMin.x);
	pvMin->y = MIN(pvMin->y, vMin.y);
	pvMin->z = MIN(pvMin->z, vMin.z);
	pvMax->x = MAX(pvMax->x, vMax.x);
	pvMax->y = MAX(pvMax->y, vMax.y);
	pvMax->z = MAX(pvMax->z, vMax.z);
}

//-----------------------------------------------------------------------------
// Name: ComputeBoundingBox()
// Desc: Calculates the bounding box of the entire hierarchy.
//-----------------------------------------------------------------------------
HRESULT CXBMesh::ComputeBoundingBox(D3DXVECTOR3 *pvMin, D3DXVECTOR3 *pvMax)
{
    D3DXMATRIX matIdentity;
    D3DXMatrixIdentity( &matIdentity );
    return ComputeFrameBoundingBox( m_pMeshFrames, &matIdentity, pvMin, pvMax );
}

//-----------------------------------------------------------------------------
// Name: ComputeFrameBoundingBox()
// Desc: Calls ComputeMeshBoundingBox for each frame with the correct transform.
//-----------------------------------------------------------------------------
HRESULT CXBMesh::ComputeFrameBoundingBox( XBMESH_FRAME* pFrame, D3DXMATRIX* pmatParent, D3DXVECTOR3 *pvMin, D3DXVECTOR3 *pvMax)
{
	HRESULT hr;
	
	// initialize bounds to be reset on the first UnionBox
	pvMin->x = pvMin->y = pvMin->z = FLT_MAX;
	pvMax->x = pvMax->y = pvMax->z = -FLT_MAX;
	
    // Apply the frame's local transform
    D3DXMATRIX matWorld;
    D3DXMatrixMultiply( &matWorld, &pFrame->m_matTransform, pmatParent );

    // Compute bounds for the mesh data
    if( pFrame->m_MeshData.m_dwNumSubsets )
	{
		D3DXVECTOR3 vMin, vMax;
        hr = ComputeMeshBoundingBox( &pFrame->m_MeshData, &matWorld, &vMin, &vMax );
		if (FAILED(hr))
			return hr;
		UnionBox(pvMin, pvMax, vMin, vMax);
	}

    // Compute bounds for any child frames
    if( pFrame->m_pChild ) 
    {
		D3DXVECTOR3 vMin, vMax;
        hr = ComputeFrameBoundingBox( pFrame->m_pChild, &matWorld, &vMin, &vMax );
		if (FAILED(hr))
			return hr;
		UnionBox(pvMin, pvMax, vMin, vMax);
    }

    // Compute bounds for any sibling frames
    if( pFrame->m_pNext )  
    {
		D3DXVECTOR3 vMin, vMax;
        hr = ComputeFrameBoundingBox( pFrame->m_pNext, pmatParent, &vMin, &vMax );
		if (FAILED(hr))
			return hr;
		UnionBox(pvMin, pvMax, vMin, vMax);
    }
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: ComputeMeshBoundingBox()
// Desc: Calculate the bounding box of the transformed mesh.
//-----------------------------------------------------------------------------
HRESULT CXBMesh::ComputeMeshBoundingBox( XBMESH_DATA* pMesh, D3DXMATRIX* pmat, D3DXVECTOR3 *pvMin, D3DXVECTOR3 *pvMax)
{
	// initialize bounds to be reset on the first point
	pvMin->x = pvMin->y = pvMin->z = FLT_MAX;
	pvMax->x = pvMax->y = pvMax->z = -FLT_MAX;
    DWORD       dwNumVertices = pMesh->m_dwNumVertices;
    DWORD       dwVertexSize  = pMesh->m_dwVertexSize;
    BYTE*       pVertices;
    D3DXVECTOR3 vPos;
    pMesh->m_VB.Lock( 0, 0, &pVertices, 0 );
    while( dwNumVertices-- )
    {
        D3DXVec3TransformCoord( &vPos, (D3DXVECTOR3*)pVertices, pmat );
		UnionBox(pvMin, pvMax, vPos, vPos);	// expand the bounding box to include the point
        pVertices += dwVertexSize;
    }
    pMesh->m_VB.Unlock();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\src\XbStopWatch.cpp ===
//-----------------------------------------------------------------------------
// File: XbStopWatch.cpp
//
// Desc: StopWatch object using QueryPerformanceCounter
//
// Hist: 01.19.01 - New for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "XbStopWatch.h"




//-----------------------------------------------------------------------------
// Name: CXBStopWatch()
// Desc: Creates the stopwatch. By default, stopwatch starts running immediately
//-----------------------------------------------------------------------------
CXBStopWatch::CXBStopWatch( BOOL bStartWatch )
:
    m_fTimerPeriod      ( 0.0f ),
    m_nStartTick        ( 0 ),
    m_nPrevElapsedTicks ( 0 ),
    m_bIsRunning        ( FALSE )   // set in Start()
{
    // Get the timer frequency (ticks per second)
    LARGE_INTEGER qwTimerFreq;
    QueryPerformanceFrequency( &qwTimerFreq );

    // Store as period to avoid division in GetElapsed()
    m_fTimerPeriod = 1.0f / (FLOAT)( qwTimerFreq.QuadPart );

    if( bStartWatch )
        Start();
}




//-----------------------------------------------------------------------------
// Name: Start()
// Desc: Starts the stopwatch running. Does not clear any previous time held
//       by the watch.
//-----------------------------------------------------------------------------
VOID CXBStopWatch::Start()
{
    m_nStartTick = GetTicks();
    m_bIsRunning = TRUE;
}




//-----------------------------------------------------------------------------
// Name: StartZero()
// Desc: Starts the stopwatch running at time zero. Same as calling Reset() and
//       then Start();
//-----------------------------------------------------------------------------
VOID CXBStopWatch::StartZero()
{
    m_nPrevElapsedTicks = 0;
    m_nStartTick = GetTicks();
    m_bIsRunning = TRUE;
}




//-----------------------------------------------------------------------------
// Name: Stop()
// Desc: Stops the stopwatch. After stopping the watch, GetElapsed() will 
//       return the same value until the watch is started or reset.
//-----------------------------------------------------------------------------
VOID CXBStopWatch::Stop()
{
    if( m_bIsRunning )
    {
        // Store the elapsed time
        m_nPrevElapsedTicks += GetTicks() - m_nStartTick;
        m_nStartTick = 0;

        // Stop running
        m_bIsRunning = FALSE;
    }
}




//-----------------------------------------------------------------------------
// Name: Reset()
// Desc: Resets the stopwatch to zero. If the watch was running, it continues
//       to run.
//-----------------------------------------------------------------------------
VOID CXBStopWatch::Reset()
{
    m_nPrevElapsedTicks = 0;
    if( m_bIsRunning )
        m_nStartTick = GetTicks();
}




//-----------------------------------------------------------------------------
// Name: IsRunning()
// Desc: TRUE if the stopwatch is running, else FALSE
//-----------------------------------------------------------------------------
BOOL CXBStopWatch::IsRunning() const
{
    return( m_bIsRunning );
}




//-----------------------------------------------------------------------------
// Name: GetElapsedSeconds()
// Desc: The amount of time the watch has been running since it was last
//       reset, in seconds
//-----------------------------------------------------------------------------
FLOAT CXBStopWatch::GetElapsedSeconds() const
{
    // Start with any previous time
    LONGLONG nTotalTicks( m_nPrevElapsedTicks );

    // If the watch is running, add the time since the last start
    if( m_bIsRunning )
        nTotalTicks += GetTicks() - m_nStartTick;

    // Convert to floating pt
    FLOAT fSeconds = (FLOAT)( nTotalTicks ) * m_fTimerPeriod;
    return( fSeconds );
}




//-----------------------------------------------------------------------------
// Name: GetElapsedMilliseconds()
// Desc: The amount of time the watch has been running since it was last
//       reset, in mS
//-----------------------------------------------------------------------------
FLOAT CXBStopWatch::GetElapsedMilliseconds() const
{
    return( GetElapsedSeconds() * 1000.0f );
}




//-----------------------------------------------------------------------------
// Name: GetTicks()
// Desc: Private function wraps QueryPerformanceCounter()
//-----------------------------------------------------------------------------
LONGLONG CXBStopWatch::GetTicks() const
{
    // Grab the current tick count
    LARGE_INTEGER qwCurrTicks;
    QueryPerformanceCounter( &qwCurrTicks );
    return( qwCurrTicks.QuadPart );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\src\xbinput.cpp ===
//-----------------------------------------------------------------------------
// File: XBInput.cpp
//
// Desc: Input helper functions for the XBox samples
//
// Hist: 12.15.00 - Separated from XBUtil.cpp for December XDK release
//       01.03.01 - Made changes for real Xbox controller
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include "XBInput.h"




//-----------------------------------------------------------------------------
// Globals
//-----------------------------------------------------------------------------

// Deadzone for thumbsticks
#define XBINPUT_DEADZONE 0.24f

// Global instance of gamepad devices
XBGAMEPAD g_Gamepads[4];




//-----------------------------------------------------------------------------
// Name: XBInput_CreateGamepads()
// Desc: Creates the gamepad devices
//-----------------------------------------------------------------------------
HRESULT XBInput_CreateGamepads( XBGAMEPAD** ppGamepads )
{
    // Get a mask of all currently available devices
    DWORD dwDeviceMask = XGetDevices( XDEVICE_TYPE_GAMEPAD );

    // Open the devices
    for( DWORD i=0; i < XGetPortCount(); i++ )
    {
        ZeroMemory( &g_Gamepads[i], sizeof(XBGAMEPAD) );
        if( dwDeviceMask & (1<<i) ) 
        {
            // Get a handle to the device
            g_Gamepads[i].hDevice = XInputOpen( XDEVICE_TYPE_GAMEPAD, i, 
                                                XDEVICE_NO_SLOT, NULL );

            // Store capabilites of the device
            XInputGetCapabilities( g_Gamepads[i].hDevice, &g_Gamepads[i].caps );
        }
    }

    // Created devices are kept global, but for those who prefer member
    // variables, they can get a pointer to the gamepads returned.
    if( ppGamepads )
        (*ppGamepads) = g_Gamepads;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBInput_GetInput()
// Desc: Processes input from the gamepads
//-----------------------------------------------------------------------------
VOID XBInput_GetInput( XBGAMEPAD* pGamepads )
{
    if( NULL == pGamepads )
        pGamepads = g_Gamepads;

    // TCR 3-21 Controller Discovery
    // Get status about gamepad insertions and removals. Note that, in order to
    // not miss devices, we will check for removed device BEFORE checking for
    // insertions
    DWORD dwInsertions, dwRemovals;
    XGetDeviceChanges( XDEVICE_TYPE_GAMEPAD, &dwInsertions, &dwRemovals );

    // Loop through all gamepads
    for( DWORD i=0; i < XGetPortCount(); i++ )
    {
        // Handle removed devices.
        pGamepads[i].bRemoved = ( dwRemovals & (1<<i) ) ? TRUE : FALSE;
        if( pGamepads[i].bRemoved )
        {
            XInputClose( pGamepads[i].hDevice );
            pGamepads[i].hDevice = NULL;
            pGamepads[i].Feedback.Rumble.wLeftMotorSpeed  = 0;
            pGamepads[i].Feedback.Rumble.wRightMotorSpeed = 0;
        }

        // Handle inserted devices
        pGamepads[i].bInserted = ( dwInsertions & (1<<i) ) ? TRUE : FALSE;
        if( pGamepads[i].bInserted ) 
        {
            // TCR 1-14 Device Types
            pGamepads[i].hDevice = XInputOpen( XDEVICE_TYPE_GAMEPAD, i, 
                                               XDEVICE_NO_SLOT, NULL );
            XInputGetCapabilities( pGamepads[i].hDevice, &pGamepads[i].caps );
        }

        // If we have a valid device, poll it's state and track button changes
        if( pGamepads[i].hDevice )
        {
            // Read the input state
            XINPUT_STATE xiState;
            XInputGetState( pGamepads[i].hDevice, &xiState );

            // Copy gamepad to local structure
            memcpy( &pGamepads[i], &xiState.Gamepad, sizeof(XINPUT_STATE) );

            // Put Xbox device input for the gamepad into our custom format
            FLOAT fX1 = (pGamepads[i].sThumbLX+0.5f)/32767.5f;
            pGamepads[i].fX1 = ( fX1 >= 0.0f ? 1.0f : -1.0f ) *
                               max( 0.0f, (fabsf(fX1)-XBINPUT_DEADZONE)/(1.0f-XBINPUT_DEADZONE) );

            FLOAT fY1 = (pGamepads[i].sThumbLY+0.5f)/32767.5f;
            pGamepads[i].fY1 = ( fY1 >= 0.0f ? 1.0f : -1.0f ) *
                               max( 0.0f, (fabsf(fY1)-XBINPUT_DEADZONE)/(1.0f-XBINPUT_DEADZONE) );

            FLOAT fX2 = (pGamepads[i].sThumbRX+0.5f)/32767.5f;
            pGamepads[i].fX2 = ( fX2 >= 0.0f ? 1.0f : -1.0f ) *
                               max( 0.0f, (fabsf(fX2)-XBINPUT_DEADZONE)/(1.0f-XBINPUT_DEADZONE) );

            FLOAT fY2 = (pGamepads[i].sThumbRY+0.5f)/32767.5f;
            pGamepads[i].fY2 = ( fY2 >= 0.0f ? 1.0f : -1.0f ) *
                               max( 0.0f, (fabsf(fY2)-XBINPUT_DEADZONE)/(1.0f-XBINPUT_DEADZONE) );

            // Get the boolean buttons that have been pressed since the last
            // call. Each button is represented by one bit.
            pGamepads[i].wPressedButtons = ( pGamepads[i].wLastButtons ^ pGamepads[i].wButtons ) & pGamepads[i].wButtons;
            pGamepads[i].wLastButtons    = pGamepads[i].wButtons;

            // Get the analog buttons that have been pressed or released since
            // the last call.
            for( DWORD b=0; b<8; b++ )
            {
                // Turn the 8-bit polled value into a boolean value
                BOOL bPressed = ( pGamepads[i].bAnalogButtons[b] > 0 );

                if( bPressed )
                    pGamepads[i].bPressedAnalogButtons[b] = !pGamepads[i].bLastAnalogButtons[b];
                else
                    pGamepads[i].bPressedAnalogButtons[b] = FALSE;
                
                // Store the current state for the next time
                pGamepads[i].bLastAnalogButtons[b] = bPressed;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\src\XBPerf.cpp ===
//-----------------------------------------------------------------------------
// File: XBPerf.cpp
//
// Desc: Sample to show off tri-stripping performance results
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>




//-----------------------------------------------------------------------------
// Name: XBPerf_CalcCacheHits()
// Desc: Calculate the number of cache hits and degenerate triangles
//-----------------------------------------------------------------------------
HRESULT XBPerf_CalcCacheHits( D3DPRIMITIVETYPE dwPrimType, DWORD dwVertexSize,
						      WORD* pIndices, DWORD dwNumIndices,
						      DWORD* pdwNumDegenerateTris,
						      DWORD* pdwNumCacheHits,
 						      DWORD* pdwNumPagesCrossed )
{
	// Check arguments
	if( NULL == pdwNumDegenerateTris || NULL == pdwNumCacheHits || 
		NULL == pdwNumPagesCrossed )
		return E_INVALIDARG;

	// Initialize results
    (*pdwNumDegenerateTris) = 0;
    (*pdwNumCacheHits)      = 0;
    (*pdwNumPagesCrossed)   = 1;

	// Simulate a vertex cache
    static const int CACHE_SIZE = 12;
	static const int PAGE_SIZE  = 4096;
    DWORD rgdwCache[CACHE_SIZE];
    INT   iCachePtr      = 0;
    BOOL  bIsTriStrip    = (dwPrimType == D3DPT_TRIANGLESTRIP);
    DWORD dwLastPageAddr = 0;
    memset( rgdwCache, 0xff, sizeof(rgdwCache) );

	// Run all vertices through the sumilated vertex cache, tallying cache hits,
	// degenerate triangles, and pages crossed.
    for( DWORD i = 0; i < dwNumIndices; i++ )
    {
        // This makes all kinds of assumptions such as page size is 4k,
        // page across then back is ok, etc etc. Seems to be an ok
        // estimate on data locality though.
        DWORD dwPage = dwVertexSize * pIndices[i] / PAGE_SIZE;

        if( ( dwPage > dwLastPageAddr ) || ( dwPage+1 < dwLastPageAddr ) )
        {
            (*pdwNumPagesCrossed)++;
            dwLastPageAddr = dwVertexSize * pIndices[i] / PAGE_SIZE;
        }

        // Update our count of degenerate tris
        if( bIsTriStrip && (i > 1) )
			if( ( pIndices[i-0] == pIndices[i-1] ) ||
			    ( pIndices[i-0] == pIndices[i-2] ) ||
			    ( pIndices[i-1] == pIndices[i-2] ) )
				(*pdwNumDegenerateTris)++;

		// Check to see if the vertex would be in the cache
		BOOL bVertexInCache = FALSE;
        for( int cache_index = 0; cache_index < CACHE_SIZE; cache_index++ )
        {
            if( pIndices[i] == rgdwCache[cache_index] )
            {
				bVertexInCache = TRUE;
                break;
            }
        }

        if( bVertexInCache )
        {
			// Keep track of cache hits
            (*pdwNumCacheHits)++;
		}
        else 
        {
            // Add vertex to simulated cache
            rgdwCache[iCachePtr] = pIndices[i];
            iCachePtr = (iCachePtr + 1) % CACHE_SIZE;
        }
    }

	return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBPerf_GetCpuSpeed()
// Desc: Returns a calculation of the CPU speed.
//-----------------------------------------------------------------------------
#pragma optimize("g", on)
double XBPerf_GetCpuSpeed()
{
    __int64 start, end, freq;
    int     clocks;
	HANDLE  hThread;
    int     iOldThreadPriority;

    hThread = GetCurrentThread();

    // save the current so it can be set back later
    iOldThreadPriority = GetThreadPriority(hThread);

    // boost this thread to do the calculations, making sure no other
    // thread interrupts the calculations
    SetThreadPriority(hThread, THREAD_PRIORITY_TIME_CRITICAL);

    Sleep(10);

    QueryPerformanceFrequency((LARGE_INTEGER*)&freq);
    QueryPerformanceCounter((LARGE_INTEGER*)&start);
    _asm
    {
        rdtsc
        mov     ecx, 100000
x:      dec     ecx
        jnz     x
        mov     ebx,eax
        rdtsc
        sub     eax,ebx
        mov     dword ptr clocks[0],eax
    }
    QueryPerformanceCounter((LARGE_INTEGER*)&end);

    // restore the thread priority
    SetThreadPriority(hThread, iOldThreadPriority);
    CloseHandle(hThread);

    int time = MulDiv((int)(end - start), 1000000, (int)freq);

    return ((clocks + time / 2) / time);
}
#pragma optimize("g", off)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\src\XbSavedGame.cpp ===
//-----------------------------------------------------------------------------
// File: XbSavedGame.cpp
//
// Desc: Saved game container
//
// Hist: 02.05.01 - New for March XDK release
//       03.14.01 - Access image.xbx for game image (April XDK)
//       04.13.01 - GetSize() accounts for directory and cluster overhead
//       05.01.01 - Image.xbx changed to SaveImage.xbx to match specs/docs
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "XbSavedGame.h"
#include "Xbapp.h"
#include "Xbutil.h"
#include <xgraphics.h>
#include <cassert>




//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------
const CHAR* const strUSER_REGION_HD = "U:\\";
const CHAR* const strGAME_IMAGE = "SaveImage.xbx";
const DWORD IMAGE_HDR_SIZE = 2048;             // 2K
const DWORD IMAGE_WH = 64;                     // width and height
const DWORD IMAGE_DATA_SIZE = (IMAGE_WH * IMAGE_WH) / 2; // DXT1 is 4 bits per pixel
                                    




//-----------------------------------------------------------------------------
// Layout of SaveImage.xbx saved game image file
//-----------------------------------------------------------------------------
//
// File is XPR0 format. Since the XPR will always contain only a single
// 256x256 DXT1 image, we know exactly what the header portion will look like

struct XprImageHeader
{
    XPR_HEADER        xpr;           // Standard XPR struct
    IDirect3DTexture8 txt;           // Standard D3D texture struct
    DWORD             dwEndOfHeader; // 0xFFFFFFFF
};

struct XprImage
{
    XprImageHeader hdr;
    CHAR           strPad[ IMAGE_HDR_SIZE - sizeof( XprImageHeader ) ];
    BYTE           pBits[ IMAGE_DATA_SIZE ];     // data bits
};




//-----------------------------------------------------------------------------
// Helper class to wrap FindFirstFile HANDLE
//-----------------------------------------------------------------------------
class FindHandle
{

    HANDLE m_hFind;

public:

    explicit FindHandle( HANDLE h = NULL )
    : 
        m_hFind( h )
    {
    }

    ~FindHandle()
    {
        if( m_hFind != INVALID_HANDLE_VALUE )
            FindClose( m_hFind );
    }

    operator HANDLE() const
    {
        return m_hFind;
    }

};




//-----------------------------------------------------------------------------
// Name: CXBSavedGame()
// Desc: Construct empty saved game
//-----------------------------------------------------------------------------
CXBSavedGame::CXBSavedGame()
:
    m_strName(),
    m_strDir(),
    m_dwSize( DWORD(-1) ),
    m_pImage( NULL ),
    m_bIsValidImage( TRUE ),
    m_qwCreationTime( ULONGLONG(0) )
{
    Init();
}




//-----------------------------------------------------------------------------
// Name: CXBSavedGame()
// Desc: Construct from other save
//-----------------------------------------------------------------------------
CXBSavedGame::CXBSavedGame( const CXBSavedGame& rhs )
:
    m_strName       (),
    m_strDir        (),
    m_dwSize        ( rhs.m_dwSize ),
    m_pImage        ( NULL ),
    m_bIsValidImage ( rhs.m_bIsValidImage ),
    m_qwCreationTime( rhs.m_qwCreationTime )
{
    lstrcpyW( m_strName, rhs.m_strName );
    lstrcpyA( m_strDir,  rhs.m_strDir );
    if( rhs.m_pImage != NULL )
    {
        m_pImage = rhs.m_pImage;
        m_pImage->AddRef();
    }
}




//-----------------------------------------------------------------------------
// Name: operator =()
// Desc: Copy from other save
//-----------------------------------------------------------------------------
CXBSavedGame& CXBSavedGame::operator =( const CXBSavedGame& rhs )
{
    lstrcpyW( m_strName, rhs.m_strName );
    lstrcpyA( m_strDir,  rhs.m_strDir );

    m_dwSize         = rhs.m_dwSize;
    m_bIsValidImage  = rhs.m_bIsValidImage;
    m_qwCreationTime = rhs.m_qwCreationTime;

    SAFE_RELEASE( m_pImage );

    if( rhs.m_pImage != NULL )
    {
        m_pImage = rhs.m_pImage;
        m_pImage->AddRef();
    }
    return *this;
}




//-----------------------------------------------------------------------------
// Name: ~CXBSavedGame()
// Desc: Tear down save game
//-----------------------------------------------------------------------------
CXBSavedGame::~CXBSavedGame()
{
    SAFE_RELEASE( m_pImage );
}




//-----------------------------------------------------------------------------
// Name: CXBSavedGame()
// Desc: Construct saved game from XGAME_FIND_DATA (see XFindFirstSaveGame())
//-----------------------------------------------------------------------------
CXBSavedGame::CXBSavedGame( const XGAME_FIND_DATA& XFindData )
:
    m_strName(),
    m_strDir(),
    m_dwSize( DWORD(-1) ),
    m_pImage( NULL ),
    m_bIsValidImage( TRUE ),
    m_ftCreationTime( XFindData.wfd.ftCreationTime )
{
    lstrcpynW( m_strName, XFindData.szSaveGameName, MAX_GAMENAME );
    lstrcpynA( m_strDir, XFindData.szSaveGameDirectory, MAX_PATH );
}




//-----------------------------------------------------------------------------
// Name: CXBSavedGame()
// Desc: Construct saved game
//-----------------------------------------------------------------------------
CXBSavedGame::CXBSavedGame( const WCHAR* strSaveGameName, 
                            const CHAR* strSaveGameDir )
:
    m_strName(),
    m_strDir(),
    m_dwSize( DWORD(-1) ),
    m_pImage( NULL ),
    m_bIsValidImage( TRUE ),
    m_qwCreationTime( ULONGLONG(0) )
{
    assert( strSaveGameName != NULL );
    assert( strSaveGameDir != NULL );
    lstrcpynW( m_strName, strSaveGameName, MAX_GAMENAME );
    lstrcpynA( m_strDir, strSaveGameDir, MAX_PATH );
}




//-----------------------------------------------------------------------------
// Name: CreateGame()
// Desc: TRUE if game container successfully created on the device
//-----------------------------------------------------------------------------
BOOL CXBSavedGame::CreateGame( CHAR chDestDrive, const WCHAR* strSaveGameName )
{
    return OpenGame( chDestDrive, strSaveGameName, CREATE_NEW );
}




//-----------------------------------------------------------------------------
// Name: OpenGame()
// Desc: TRUE if game container exists on the device
//-----------------------------------------------------------------------------
BOOL CXBSavedGame::OpenGame( CHAR chDestDrive, const WCHAR* strSaveGameName,
                             DWORD dwOpenDisposition )
{
    assert( strSaveGameName != NULL );
    Init();

    CHAR strRootPath[4] = "x:\\";
    *strRootPath = chDestDrive;

    // TCR 3-7 Saved Game Management
    DWORD dwSuccess = XCreateSaveGame( strRootPath, strSaveGameName, 
                                       dwOpenDisposition, 0, m_strDir, 
                                       MAX_PATH );
    if( dwSuccess != ERROR_SUCCESS )
        return FALSE;

    lstrcpynW( m_strName, strSaveGameName, MAX_GAMENAME );
    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: DeleteGame()
// Desc: TRUE if game container exists and successfully deleted
//-----------------------------------------------------------------------------
BOOL CXBSavedGame::DeleteGame()
{
    assert( !IsEmpty() );
    CHAR strRootPath[4] = "x:\\";
    *strRootPath = GetDrive();

    // TCR 3-7 Saved Game Management
    DWORD dwSuccess = XDeleteSaveGame( strRootPath, m_strName );
    Init();
    return( dwSuccess == ERROR_SUCCESS );
}




//-----------------------------------------------------------------------------
// Name: IsEmpty()
// Desc: TRUE if object doesn't represent an actual saved game
//-----------------------------------------------------------------------------
BOOL CXBSavedGame::IsEmpty() const
{
    return( *m_strName == 0 );
}




//-----------------------------------------------------------------------------
// Name: GetDrive()
// Desc: Saved game drive
//-----------------------------------------------------------------------------
CHAR CXBSavedGame::GetDrive() const
{
    return *m_strDir;
}




//-----------------------------------------------------------------------------
// Name: GetSize()
// Desc: Number of bytes used by save game container and data.
//       The value returned is cluster based, so it includes the total number
//       of bytes allocated by the device, and is always evenly divisible by
//       the cluster size of the device.
//-----------------------------------------------------------------------------
DWORD CXBSavedGame::GetSize() const
{
    if( IsEmpty() )
        return 0;

    // Cache the save game container size if we don't have it already
    if( m_dwSize == DWORD(-1) )
    {
        CHAR strRootPath[4] = "x:\\";
        *strRootPath = GetDrive();

        m_dwSize = GetDirSize( m_strDir, XGetDiskClusterSize( strRootPath ) );
    }

    return m_dwSize;
}




//-----------------------------------------------------------------------------
// Name: GetCreationTime()
// Desc: Time/date when saved game container folder was created
//-----------------------------------------------------------------------------
FILETIME CXBSavedGame::GetCreationTime() const
{
    if( IsEmpty() )
        return FILETIME();

    // Cache the creation time if we don't have it already
    if( m_qwCreationTime == ULONGLONG(0) )
    {
        // FindFirstFile() doesn't want trailing backslash
        CHAR strSaveGameDir[ MAX_PATH ];
        lstrcpynA( strSaveGameDir, m_strDir, lstrlenA( m_strDir ) );

        // Get folder creation time
        WIN32_FIND_DATA FolderData;
        FindHandle hFolder( FindFirstFile( strSaveGameDir, &FolderData ) );
        if( hFolder != INVALID_HANDLE_VALUE )
        {
            m_ftCreationTime.dwHighDateTime = FolderData.ftCreationTime.dwHighDateTime;
            m_ftCreationTime.dwLowDateTime = FolderData.ftCreationTime.dwLowDateTime;
        }
    }
    return m_ftCreationTime;
}




//-----------------------------------------------------------------------------
// Name: GetCreationQword()
// Desc: Creation info as ULONGLONG
//-----------------------------------------------------------------------------
ULONGLONG CXBSavedGame::GetCreationQword() const
{
    FILETIME ftCreationTime = GetCreationTime();
    return( *(ULONGLONG*)( &ftCreationTime ) );
}




//-----------------------------------------------------------------------------
// Name: GetName()
// Desc: Saved game name
//-----------------------------------------------------------------------------
const WCHAR* CXBSavedGame::GetName() const
{
    return m_strName;
}




//-----------------------------------------------------------------------------
// Name: GetDirectory()
// Desc: Saved game container folder
//-----------------------------------------------------------------------------
const CHAR* CXBSavedGame::GetDirectory() const
{
    return m_strDir;
}




//-----------------------------------------------------------------------------
// Name: GetImage()
// Desc: Returns pointer to texture for game image. Caller is responsible for
//       calling Release() on the pointer.
//-----------------------------------------------------------------------------
BOOL CXBSavedGame::GetImage( LPDIRECT3DTEXTURE8* ppImage ) const
{
    if( IsEmpty() )
        return FALSE;

    // If we already have the image cached, just update the ref count
    if( m_pImage != NULL )
    {
        m_pImage->AddRef();
        *ppImage = m_pImage;
        return TRUE;
    }

    // If we already failed to load the image, bail out
    if( !m_bIsValidImage )
        return FALSE;

    // We don't have the image yet

    // See if the image file for this saved game exists
    CHAR strFile[ MAX_PATH ];
    lstrcpyA( strFile, m_strDir );
    lstrcatA( strFile, strGAME_IMAGE );
    HANDLE hFile = CreateFile( strFile, GENERIC_READ, 0, NULL, OPEN_EXISTING,
                               0, NULL );
    if( hFile == INVALID_HANDLE_VALUE )
    {
        // TCR 2-14a Saved Game Representative Image
        // No specific image found; see if the default save image exists
        // (always on root of user data region on hard disk)
        lstrcpyA( strFile, strUSER_REGION_HD );
        lstrcatA( strFile, strGAME_IMAGE );
        hFile = CreateFile( strFile, GENERIC_READ, 0, NULL, OPEN_EXISTING,
                            0, NULL );
        if( hFile == INVALID_HANDLE_VALUE )
        {
            m_bIsValidImage = FALSE;
            return FALSE;
        }
    }

    // Read the image header from disk
    XprImageHeader XprHeader;
    DWORD dwBytesRead;
    BOOL bSuccess = ReadFile( hFile, &XprHeader, sizeof( XprImageHeader ),
                              &dwBytesRead, NULL );

    // Validate the image
    bSuccess &= dwBytesRead == sizeof( XprImageHeader ) &&
                XprHeader.xpr.dwMagic == XPR_MAGIC_VALUE &&
                XprHeader.xpr.dwTotalSize == IMAGE_HDR_SIZE + IMAGE_DATA_SIZE &&
                XprHeader.xpr.dwHeaderSize == IMAGE_HDR_SIZE &&
                XprHeader.dwEndOfHeader == 0xFFFFFFFF;

    // If image looks good, store the bits in a texture
    if( bSuccess )
    {
        HRESULT hr = g_pd3dDevice->CreateTexture( IMAGE_WH, IMAGE_WH, 
                                                  1, 0, D3DFMT_DXT1,
                                                  D3DPOOL(), &m_pImage );
        bSuccess = SUCCEEDED(hr);
        if( bSuccess )
        {
            D3DLOCKED_RECT lr;
            m_pImage->LockRect( 0, &lr, NULL, D3DLOCK_READONLY );

            // Copy the bits from the file to the texture
            SetFilePointer( hFile, IMAGE_HDR_SIZE, NULL, FILE_BEGIN );
            bSuccess = ReadFile( hFile, lr.pBits, IMAGE_DATA_SIZE, 
                                 &dwBytesRead, NULL );
            bSuccess &= ( dwBytesRead == IMAGE_DATA_SIZE );
            m_pImage->UnlockRect( 0 );

            if( bSuccess )
            {
                m_pImage->AddRef();
                *ppImage = m_pImage;
            }
        }
    }
    else
    {
        m_bIsValidImage = FALSE;
    }

    CloseHandle( hFile );
    return( bSuccess );
}




//-----------------------------------------------------------------------------
// Name: SaveImage()
// Desc: Generates a meta data image file for the save game. Overwrites
//       any existing image. Automatically converts the incoming texture
//       to the proper meta data image format.
//-----------------------------------------------------------------------------
BOOL CXBSavedGame::SaveImage( const LPDIRECT3DTEXTURE8 pSrcImage )
{
    if( IsEmpty() || pSrcImage == NULL )
        return FALSE;

    // Determine size of incoming texture
    D3DSURFACE_DESC SrcDesc;
    HRESULT hr = pSrcImage->GetLevelDesc( 0, &SrcDesc );
    if( FAILED(hr) )
        return FALSE;

    LPDIRECT3DTEXTURE8* ppSrcImage = NULL;

    // If the incoming texture is not the correct size, scale it
    LPDIRECT3DTEXTURE8 pScaledSrc = NULL;
    if( SrcDesc.Width != IMAGE_WH || SrcDesc.Height != IMAGE_WH )
    {
        // Generate texture with correct size
        hr = g_pd3dDevice->CreateTexture( IMAGE_WH, IMAGE_WH, 1, 0,
                                          SrcDesc.Format, D3DPOOL(), 
                                          &pScaledSrc );
        if( FAILED(hr) )
            return FALSE;

        // Scale source
        LPDIRECT3DSURFACE8 pSrcSurf = NULL;
        LPDIRECT3DSURFACE8 pScaledSurf = NULL;
        hr = pSrcImage->GetSurfaceLevel( 0, &pSrcSurf );
        hr = pScaledSrc->GetSurfaceLevel( 0, &pScaledSurf );
        hr = D3DXLoadSurfaceFromSurface( pScaledSurf, NULL, NULL, 
                                         pSrcSurf, NULL, NULL,
                                         D3DX_DEFAULT, D3DCOLOR( 0 ) );
        SAFE_RELEASE( pSrcSurf );
        SAFE_RELEASE( pScaledSurf );
        if( FAILED(hr) )
            return FALSE;

        // Use the scaled image as the source
        ppSrcImage = &pScaledSrc;
    }
    else
    {
        // The incoming texture is the correct size, so use it as the source
        pSrcImage->AddRef();
        ppSrcImage = &(LPDIRECT3DTEXTURE8)(pSrcImage);
    }

    // Create the 64x64 DXT1 texture that will be stored
    LPDIRECT3DTEXTURE8 pDxt1GameImage = NULL;
    hr = g_pd3dDevice->CreateTexture( IMAGE_WH, IMAGE_WH, 1, 0,
                                      D3DFMT_DXT1, D3DPOOL(), 
                                      &pDxt1GameImage );
    if( FAILED(hr) )
    {
        SAFE_RELEASE( *ppSrcImage );
        return FALSE;
    }

    D3DLOCKED_RECT SrcRect;
    D3DLOCKED_RECT DstRect;
    hr = (*ppSrcImage)->LockRect( 0, &SrcRect, NULL, D3DLOCK_READONLY );
    hr = pDxt1GameImage->LockRect( 0, &DstRect, NULL, 0 );

    // Compress the game save texture using DXT1 compression
    DWORD dwDestPitch = IMAGE_WH * 2;
    hr = XGCompressRect( DstRect.pBits, D3DFMT_DXT1, dwDestPitch,
                         IMAGE_WH, IMAGE_WH, SrcRect.pBits, SrcDesc.Format,
                         SrcRect.Pitch, 0.5f, 0 );

    pDxt1GameImage->UnlockRect( 0 );
    (*ppSrcImage)->UnlockRect( 0 );

    if( SUCCEEDED(hr) )
    {
        // Generate the save game image name
        CHAR strMetaDataFile[ MAX_PATH ];
        lstrcpyA( strMetaDataFile, m_strDir );
        lstrcatA( strMetaDataFile, strGAME_IMAGE );
    
        // Write the compressed texture out to an .XPR file
        LPDIRECT3DSURFACE8 pDxt1Surf = NULL;
        hr = pDxt1GameImage->GetSurfaceLevel( 0, &pDxt1Surf );
        hr = XGWriteSurfaceOrTextureToXPR( pDxt1Surf, strMetaDataFile, TRUE );
        SAFE_RELEASE( pDxt1Surf );
    }

    SAFE_RELEASE( pDxt1GameImage );
    SAFE_RELEASE( *ppSrcImage );

    if( SUCCEEDED(hr) )
        m_bIsValidImage = TRUE;

    return( SUCCEEDED(hr) );

/*

    // Create a 64x64 texture
    LPDIRECT3DTEXTURE8 pScaledImage = NULL;
    HRESULT hr = g_pd3dDevice->CreateTexture( IMAGE_WH, IMAGE_WH, 
                                              1, 0, D3DFMT_DXT1,
                                              D3DPOOL(), &pDxt1GameImage );
    if( FAILED(hr) )
        return FALSE;

    // Copy the game texture to the DXT1 texture
    LPDIRECT3DSURFACE8 pSrcSurf = NULL;
    LPDIRECT3DSURFACE8 pDxt1Surf = NULL;
    hr = pSrcImage->GetSurfaceLevel( 0, &pSrcSurf );
    hr = pDxt1GameImage->GetSurfaceLevel( 0, &pDxt1Surf );
    hr = D3DXLoadSurfaceFromSurface( pDxt1Surf, NULL, NULL, pSrcSurf, NULL, NULL,
                                     D3DX_DEFAULT, D3DCOLOR( 0 ) );
    SAFE_RELEASE( pSrcSurf );

    // Write the DXT1 surface
    CHAR strMetaDataFile[ MAX_PATH ];
    lstrcpyA( strMetaDataFile, m_strDir );
    lstrcatA( strMetaDataFile, strGAME_IMAGE );
    
    // Write the surface out to an .xpr file as a texture
    hr = XGWriteSurfaceOrTextureToXPR(pDxt1Surf, strMetaDataFile, TRUE);
    SAFE_RELEASE( pDxt1Surf );
    SAFE_RELEASE( pDxt1GameImage );

    if( SUCCEEDED(hr) )
        m_bIsValidImage = TRUE;

    return SUCCEEDED(hr);
*/
}




//-----------------------------------------------------------------------------
// Name: Init()
// Desc: Clear saved game data
//-----------------------------------------------------------------------------
VOID CXBSavedGame::Init()
{
    *m_strName = 0;
    *m_strDir = 0;
    m_qwCreationTime = ULONGLONG(0);
    m_dwSize = DWORD(-1);
    SAFE_RELEASE( m_pImage );
    m_bIsValidImage = TRUE;
}




//-----------------------------------------------------------------------------
// Name: GetDirSize()
// Desc: Recursively determines the number of bytes used by the given folder.
//       The value returned is cluster based, so it includes the total number
//       of bytes allocated by the device, and is always evenly divisible by
//       the cluster size of the device.
//-----------------------------------------------------------------------------
DWORD CXBSavedGame::GetDirSize( const CHAR* strDir, DWORD dwClusterSize ) // static
{
    assert( strDir != NULL );

    // Append wildcard specifier to folder
    CHAR strWild[ MAX_PATH ];
    lstrcpyA( strWild, strDir );
    lstrcatA( strWild, "*" );

    // A directory requires a cluster of data
    DWORD dwBytes = dwClusterSize;

    // Enumerate files in strDir
    WIN32_FIND_DATA FileData;
    FindHandle hFile( FindFirstFile( strWild, &FileData ) );
    BOOL bIsValid = ( hFile != INVALID_HANDLE_VALUE );

    while( bIsValid )
    {
        // If we have a subdirectory, recurse into that folder
        if( FileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
        {
            // subdir = strDir + FileData.cFileName + '\'
            CHAR strSubDir[ MAX_PATH ];
            lstrcpyA( strSubDir, strDir );
            lstrcatA( strSubDir, FileData.cFileName );
            lstrcatA( strSubDir, "\\" );
            dwBytes += GetDirSize( strSubDir, dwClusterSize );
        }
        // otherwise we have a regular file; include its size, padded out
        // to the nearest cluster
        else
        {
            assert( FileData.nFileSizeHigh == 0 );

            // Determine clusters required for this file
            DWORD dwClusters = ( FileData.nFileSizeLow + ( dwClusterSize-1 ) ) / 
                                 dwClusterSize;

            // Update total bytes
            dwBytes += dwClusters * dwClusterSize;
        }

        // Grab the next file
        bIsValid = FindNextFile( hFile, &FileData );
    }

    return dwBytes;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\src\XBResource.cpp ===
//-----------------------------------------------------------------------------
// File: XBResource.cpp
//
// Desc: Loads resources from an XPR (Xbox Packed Resource) file.  
//
// Hist: 03.12.01 - New for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xgraphics.h>
#include <stdio.h>
#include "XBUtil.h"
#include "XBResource.h"




//-----------------------------------------------------------------------------
// Name: XBResource_SizeOf()
// Desc: Determines the byte size of a D3DResource
//-----------------------------------------------------------------------------
DWORD XBResource_SizeOf( LPDIRECT3DRESOURCE8 pResource )
{
    switch( pResource->GetType() )
    {
        case D3DRTYPE_TEXTURE:       return sizeof(D3DTexture);
        case D3DRTYPE_VOLUMETEXTURE: return sizeof(D3DVolumeTexture);
        case D3DRTYPE_CUBETEXTURE:   return sizeof(D3DCubeTexture);
        case D3DRTYPE_VERTEXBUFFER:  return sizeof(D3DVertexBuffer);
        case D3DRTYPE_INDEXBUFFER:   return sizeof(D3DIndexBuffer);
        case D3DRTYPE_PALETTE:       return sizeof(D3DPalette);
    }
    return 0;
}




//-----------------------------------------------------------------------------
// Name: CXBPackedResource()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBPackedResource::CXBPackedResource()
{
    m_pSysMemData    = NULL;
    m_pVidMemData    = NULL;
    m_dwNumResources = 0L;
    m_pResourceTags  = NULL;
}




//-----------------------------------------------------------------------------
// Name: ~CXBPackedResource()
// Desc: Destructor
//-----------------------------------------------------------------------------
CXBPackedResource::~CXBPackedResource()
{
    Destroy();
}




//-----------------------------------------------------------------------------
// Name: GetData()
// Desc: Loads all the texture resources from the given XPR.
//-----------------------------------------------------------------------------
VOID* CXBPackedResource::GetData( const CHAR* strName ) const
{
    if( NULL==m_pResourceTags || NULL==strName )
        return NULL;

    for( DWORD i=0; i<m_dwNumResources; i++ )
    {
        if( !_stricmp( strName, m_pResourceTags[i].strName ) )
            return &m_pSysMemData[m_pResourceTags[i].dwOffset];
    }

    return NULL;
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Loads all the texture resources from the given XPR.
//-----------------------------------------------------------------------------
HRESULT CXBPackedResource::Create( LPDIRECT3DDEVICE8 pd3dDevice, 
                                   const CHAR* strFilename, DWORD dwNumResources,
                                   XBRESOURCE* pResourceTags )
{
    // Find the media file
    CHAR strResourcePath[512];
    if( FAILED( XBUtil_FindMediaFile( strResourcePath, strFilename ) ) )
        return E_FAIL;

    // Open the fileto read the XPR headers
    FILE* file = fopen( strResourcePath, "rb" );
    if( NULL == file )
        return E_FAIL;

    // Read in and verify the XPR magic header
    XPR_HEADER xprh;
    fread( &xprh, sizeof(XPR_HEADER), 1, file );
    if( xprh.dwMagic != XPR_MAGIC_VALUE )
    {
        OutputDebugString( _T("Invalid Xbox Packed Resource (.xpr) file") );
        fclose( file );
        return E_INVALIDARG;
    }

    // Compute memory requirements
    DWORD dwSysMemDataSize = xprh.dwHeaderSize - sizeof(XPR_HEADER);
    DWORD dwVidMemDataSize = xprh.dwTotalSize - xprh.dwHeaderSize;

    // Allocate memory
    m_pSysMemData = new BYTE[dwSysMemDataSize];
    m_pVidMemData = (BYTE*)D3D_AllocContiguousMemory( dwVidMemDataSize, D3DTEXTURE_ALIGNMENT );

    // Read in the data from the file
    fread( m_pSysMemData, dwSysMemDataSize, 1, file );
    fread( m_pVidMemData, dwVidMemDataSize, 1, file );

    // Done with the file
    fclose( file );
    
    // Loop over resources, calling Register()
    BYTE* pData = m_pSysMemData;

    for( DWORD i = 0; i < dwNumResources; i++ )
    {
		// Check for userdata
		if( *((DWORD*)pData) & 0x80000000 )
		{
			DWORD dwType = ((DWORD*)pData)[0];
			DWORD dwSize = ((DWORD*)pData)[1];
			pData += 8;

			pData += dwSize;
		}
		else
		{
			// Get the resource
			LPDIRECT3DRESOURCE8 pResource = (LPDIRECT3DRESOURCE8)pData;
    
	        // Register the resource
		    pResource->Register( m_pVidMemData );
        
			// Advance the pointer
			pData += XBResource_SizeOf( pResource );
		}
    }

    // Finally, store number of resources and the resource tags
    m_dwNumResources = dwNumResources;
    m_pResourceTags  = pResourceTags;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Tears down the packed resource data
//-----------------------------------------------------------------------------
VOID CXBPackedResource::Destroy() 
{
    if( m_pSysMemData != NULL )
    {
        delete[] m_pSysMemData;
        m_pSysMemData = NULL;
    }
    if( m_pVidMemData != NULL )
    {
        D3D_FreeContiguousMemory( m_pVidMemData );
        m_pVidMemData = NULL;
    }
    m_dwNumResources = 0L;
    m_pResourceTags  = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\src\xbsound.cpp ===
//-----------------------------------------------------------------------------
// File: XBSound.cpp
//
// Desc: Helper class for reading a .wav file and playing it in a DirectSound
//       buffer.
//
// Hist: 12.15.00 - New for December XDK release
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include <xtl.h>
#include <stdio.h>
#include "XBSound.h"
#include "XBUtil.h"




//-----------------------------------------------------------------------------
// FourCC definitions
//-----------------------------------------------------------------------------
const DWORD FOURCC_RIFF   = 'FFIR';
const DWORD FOURCC_WAVE   = 'EVAW';
const DWORD FOURCC_FORMAT = ' tmf';
const DWORD FOURCC_DATA   = 'atad';




//-----------------------------------------------------------------------------
// Name: CRiffChunk()
// Desc: Object constructor.
//-----------------------------------------------------------------------------
CRiffChunk::CRiffChunk()
{
    // Initialize defaults
    m_fccChunkId   = 0;
    m_pParentChunk = NULL;
    m_hFile        = INVALID_HANDLE_VALUE;
    m_dwDataOffset = 0;
    m_dwDataSize   = 0;
    m_dwFlags      = 0;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initializes the object
//-----------------------------------------------------------------------------
VOID CRiffChunk::Initialize( FOURCC fccChunkId, const CRiffChunk* pParentChunk, 
                             HANDLE hFile )
{
    m_fccChunkId   = fccChunkId;
    m_pParentChunk = pParentChunk;
    m_hFile        = hFile;
}




//-----------------------------------------------------------------------------
// Name: Open()
// Desc: Opens an existing chunk.
//-----------------------------------------------------------------------------
HRESULT CRiffChunk::Open()
{
    RIFFHEADER rhRiffHeader;
    LONG       lOffset = 0;

    // Seek to the first byte of the parent chunk's data section
    if( m_pParentChunk )
    {
        lOffset = m_pParentChunk->m_dwDataOffset;

        // Special case the RIFF chunk
        if( FOURCC_RIFF == m_pParentChunk->m_fccChunkId )
            lOffset += sizeof(FOURCC);
    }
    
    // Read each child chunk header until we find the one we're looking for
    for( ;; )
    {
        if( INVALID_SET_FILE_POINTER == SetFilePointer( m_hFile, lOffset, NULL, FILE_BEGIN ) )
            return HRESULT_FROM_WIN32( GetLastError() );

        DWORD dwRead;
        if( 0 == ReadFile( m_hFile, &rhRiffHeader, sizeof(rhRiffHeader), &dwRead, NULL ) )
            return HRESULT_FROM_WIN32( GetLastError() );

        // Check if we found the one we're looking for
        if( m_fccChunkId == rhRiffHeader.fccChunkId )
        {
            // Save the chunk size and data offset
            m_dwDataOffset = lOffset + sizeof(rhRiffHeader);
            m_dwDataSize   = rhRiffHeader.dwDataSize;

            // Success
            m_dwFlags |= RIFFCHUNK_FLAGS_VALID;

            return S_OK;
        }

        lOffset += sizeof(rhRiffHeader) + rhRiffHeader.dwDataSize;
    }
}




//-----------------------------------------------------------------------------
// Name: Read()
// Desc: Reads from the file
//-----------------------------------------------------------------------------
HRESULT CRiffChunk::ReadData( LONG lOffset, VOID* pData, DWORD dwDataSize )
{
    // Seek to the offset
    DWORD dwPosition = SetFilePointer( m_hFile, m_dwDataOffset+lOffset, NULL, FILE_BEGIN );
    if( INVALID_SET_FILE_POINTER == dwPosition )
        return HRESULT_FROM_WIN32( GetLastError() );

    // Read from the file
    DWORD dwRead;
    if( 0 == ReadFile( m_hFile, pData, dwDataSize, &dwRead, NULL ) )
        return HRESULT_FROM_WIN32( GetLastError() );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CWaveFile()
// Desc: Object constructor.
//-----------------------------------------------------------------------------
CWaveFile::CWaveFile()
{
    m_hFile = INVALID_HANDLE_VALUE;
}




//-----------------------------------------------------------------------------
// Name: ~CWaveFile()
// Desc: Object destructor.
//-----------------------------------------------------------------------------
CWaveFile::~CWaveFile()
{
    Close();
}




//-----------------------------------------------------------------------------
// Name: Open()
// Desc: Initializes the object.
//-----------------------------------------------------------------------------
HRESULT CWaveFile::Open( const CHAR* strFileName )
{
    // If we're already open, close
    Close();
    
    // Open the file
    m_hFile = CreateFile( strFileName, GENERIC_READ, FILE_SHARE_READ, NULL, 
                          OPEN_EXISTING, 0L, NULL );
    if( INVALID_HANDLE_VALUE == m_hFile )
        return HRESULT_FROM_WIN32( GetLastError() );

    // Initialize the chunk objects
    m_RiffChunk.Initialize( FOURCC_RIFF, NULL, m_hFile );
    m_FormatChunk.Initialize( FOURCC_FORMAT, &m_RiffChunk, m_hFile );
    m_DataChunk.Initialize( FOURCC_DATA, &m_RiffChunk, m_hFile );

    HRESULT hr = m_RiffChunk.Open();
    if( FAILED(hr) )
        return hr;

    hr = m_FormatChunk.Open();
    if( FAILED(hr) )
        return hr;

    hr = m_DataChunk.Open();
    if( FAILED(hr) )
        return hr;

    // Validate the file type
    FOURCC fccType;
    hr = m_RiffChunk.ReadData( 0, &fccType, sizeof(fccType) );
    if( FAILED(hr) )
        return hr;

    if( FOURCC_WAVE != fccType )
        return HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: GetFormat()
// Desc: Gets the wave file format
//-----------------------------------------------------------------------------
HRESULT CWaveFile::GetFormat( WAVEFORMATEX* pwfxFormat, DWORD dwFormatSize )
{
    DWORD dwValidSize = m_FormatChunk.GetDataSize();

    if( NULL == pwfxFormat || 0 == dwFormatSize )
        return E_INVALIDARG;

    // Read the format chunk into the buffer
    HRESULT hr = m_FormatChunk.ReadData( 0, pwfxFormat, min(dwFormatSize, dwValidSize) );
    if( FAILED(hr) )
        return hr;

    // Zero out remaining bytes, in case enough bytes were not read
    if( dwFormatSize > dwValidSize )
        ZeroMemory( (BYTE*)pwfxFormat + dwValidSize, dwFormatSize - dwValidSize );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: ReadSample()
// Desc: Reads data from the audio file.
//-----------------------------------------------------------------------------
HRESULT CWaveFile::ReadSample( DWORD dwPosition, VOID* pBuffer, 
                               DWORD dwBufferSize, DWORD* pdwRead )
{                                   
    // Don't read past the end of the data chunk
    DWORD dwDuration;
    GetDuration( &dwDuration );

    if( dwPosition + dwBufferSize > dwDuration )
        dwBufferSize = dwDuration - dwPosition;

    HRESULT hr = S_OK;
    if( dwBufferSize )
        hr = m_DataChunk.ReadData( (LONG)dwPosition, pBuffer, dwBufferSize );

    if( pdwRead )
        *pdwRead = dwBufferSize;

    return hr;
}




//-----------------------------------------------------------------------------
// Name: Close()
// Desc: Closes the object
//-----------------------------------------------------------------------------
VOID CWaveFile::Close()
{
    if( m_hFile != INVALID_HANDLE_VALUE )
    {
        CloseHandle( m_hFile );
        m_hFile = INVALID_HANDLE_VALUE;
    }
}




//-----------------------------------------------------------------------------
// Name: CXBSound()
// Desc: 
//-----------------------------------------------------------------------------
CXBSound::CXBSound()
{
    m_pDSoundBuffer = NULL;
    m_dwBufferSize  = 0L;
}




//-----------------------------------------------------------------------------
// Name: ~CXBSound()
// Desc: 
//-----------------------------------------------------------------------------
CXBSound::~CXBSound()
{
    Destroy();
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Creates the sound. Sound is buffered to memory allocated internally
//       by DirectSound.
//-----------------------------------------------------------------------------
HRESULT CXBSound::Create( const CHAR* strFileName, DWORD dwFlags )
{
    // Find the media file
    CHAR strWavePath[512];
    HRESULT   hr;
    if( FAILED( hr = XBUtil_FindMediaFile( strWavePath, strFileName ) ) )
        return hr;

    // Open the .wav file
    CWaveFile waveFile;
    hr = waveFile.Open( strWavePath );
    if( FAILED(hr) )
        return hr;

    // Get the WAVEFORMAT structure for the .wav file
    hr = waveFile.GetFormat( &m_WaveFormat, sizeof(WAVEFORMATEX) );
    if( FAILED(hr) )
        return hr;

    // Get the size of the .wav file
    waveFile.GetDuration( &m_dwBufferSize );

    // Create the sound buffer
    hr = Create( &m_WaveFormat, dwFlags, NULL, m_dwBufferSize );
    if( FAILED(hr) )
        return hr;

    // Lock the buffer so it can be filled
    VOID* pLock1 = NULL;
    VOID* pLock2 = NULL;
    DWORD dwLockSize1 = 0L;
    DWORD dwLockSize2 = 0L;
    hr = m_pDSoundBuffer->Lock( 0L, m_dsbd.dwBufferBytes, &pLock1, &dwLockSize1, 
                                &pLock2, &dwLockSize2, 0L );
    if( FAILED(hr) )
        return hr;

    // Read the wave file data into the buffer
    hr = waveFile.ReadSample( 0L, pLock1, dwLockSize1, NULL );
    if( FAILED(hr) )
        return hr;

    // Unlock the buffer
    hr = m_pDSoundBuffer->Unlock( &pLock1, dwLockSize1, &pLock2, dwLockSize2 );
    if( FAILED(hr) )
        return hr;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Creates the sound and tells DirectSound where the sound data will be
//       stored. If pBuffer is NULL, DirectSound handles buffer creation.
//-----------------------------------------------------------------------------
HRESULT CXBSound::Create( const WAVEFORMATEX* pwfxFormat, DWORD dwFlags,
                          const VOID* pBuffer, DWORD dwBytes )
{
    // Setup the sound buffer description
    ZeroMemory( &m_dsbd, sizeof(DSBUFFERDESC) );
    m_dsbd.dwSize      = sizeof(DSBUFFERDESC);
    m_dsbd.dwFlags     = dwFlags;
    m_dsbd.lpwfxFormat = (LPWAVEFORMATEX)pwfxFormat;

    // If pBuffer is non-NULL, dwBufferBytes will be zero, which informs
    // DirectSoundCreateBuffer that we will presently be using SetBufferData().
    // Otherwise, we set dwBufferBytes to the size of the WAV data, potentially
    // including alignment bytes.
    if( pBuffer == NULL )
    {
        m_dsbd.dwBufferBytes = ( 0 == m_WaveFormat.nBlockAlign ) ? dwBytes : 
                                 dwBytes - ( dwBytes % m_WaveFormat.nBlockAlign );
    }

    HRESULT hr = DirectSoundCreateBuffer(&m_dsbd, &m_pDSoundBuffer);
    if( FAILED(hr) )
        return hr;

    // If buffer specified, tell DirectSound to use it
    if( pBuffer != NULL )
    {
        hr = m_pDSoundBuffer->SetBufferData( (LPVOID)pBuffer, dwBytes );
        if( FAILED(hr) )
            return hr;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Destroys the resources used by the sound
//-----------------------------------------------------------------------------
VOID CXBSound::Destroy()
{
    SAFE_RELEASE( m_pDSoundBuffer );
}




//-----------------------------------------------------------------------------
// Name: Play()
// Desc: Plays the sound
//-----------------------------------------------------------------------------
HRESULT CXBSound::Play( DWORD dwFlags ) const
{
    if( NULL == m_pDSoundBuffer )
        return E_INVALIDARG;
        
    return m_pDSoundBuffer->Play( 0, 0, dwFlags );
}

//-----------------------------------------------------------------------------
// Name: SetMixBins()
// Desc: Allows the dsound mixbin arguments to be passed to the active soundbuffer
//-----------------------------------------------------------------------------
HRESULT CXBSound::SetMixBins( LPCDSMIXBINS pMixBins ) const
{
    if( NULL == m_pDSoundBuffer )
        return E_INVALIDARG;
        
    return m_pDSoundBuffer->SetMixBins(pMixBins);
}



//-----------------------------------------------------------------------------
// Name: Stop()
// Desc: Stops the sound
//-----------------------------------------------------------------------------
HRESULT CXBSound::Stop() const
{
    if( NULL == m_pDSoundBuffer )
        return E_INVALIDARG;
        
    return m_pDSoundBuffer->Stop();
}




//-----------------------------------------------------------------------------
// Name: SetPosition()
// Desc: Positions the sound
//-----------------------------------------------------------------------------
HRESULT CXBSound::SetPosition( const D3DXVECTOR3& v ) const
{
    if( NULL == m_pDSoundBuffer )
        return E_INVALIDARG;
        
    return m_pDSoundBuffer->SetPosition( v.x, v.y, v.z, DS3D_IMMEDIATE );
}




//-----------------------------------------------------------------------------
// Name: SetVelocity()
// Desc: Sets the sound's velocity
//-----------------------------------------------------------------------------
HRESULT CXBSound::SetVelocity( const D3DXVECTOR3& v ) const
{
    if( NULL == m_pDSoundBuffer )
        return E_INVALIDARG;
        
    return m_pDSoundBuffer->SetVelocity( v.x, v.y, v.z, DS3D_IMMEDIATE );
}



//-----------------------------------------------------------------------------
// Name: CDSPImage (constructor)
// Desc: Initializes member variables
//-----------------------------------------------------------------------------
CDSPImage::CDSPImage()
{
    m_dwImageSize = 0;
    m_pbImageData = NULL;
}




//-----------------------------------------------------------------------------
// Name: ~CDSPImage (destructor)
// Desc: Releases memory held by the object
//-----------------------------------------------------------------------------
CDSPImage::~CDSPImage()
{
    delete[] m_pbImageData;
}


//-----------------------------------------------------------------------------
// Name: LoadFromFile
// Desc: Loads the DSP image from the given file.  Searches in the media 
//       directory if it can't find the file as specified.
//-----------------------------------------------------------------------------
HRESULT 
CDSPImage::LoadFromFile( char * szFilename )
{
    HRESULT hr = S_OK;
    char szImagePath[MAX_PATH];
    HANDLE hFile = INVALID_HANDLE_VALUE;

    // Find the media file
    hr = XBUtil_FindMediaFile( szImagePath, szFilename );
    if( FAILED( hr ) )
        return hr;

    // open scratch image file generated by XGPImage tool
    hFile = CreateFile( szImagePath,
                        GENERIC_READ,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );
    if( INVALID_HANDLE_VALUE == hFile )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        return hr;
    }

    // Determine the size of the scratch image by seeking to
    // the end of the file
    m_dwImageSize = SetFilePointer( hFile, 0, NULL, FILE_END );
    SetFilePointer(hFile, 0, NULL, FILE_BEGIN);

    // Delete and re-allocate buffer
    delete[] m_pbImageData;
    m_pbImageData = new BYTE[ m_dwImageSize ];

    // Read the image into memory
    DWORD dwBytesRead;
    BOOL bResult = ReadFile( hFile,
                             m_pbImageData,
                             m_dwImageSize,
                             &dwBytesRead,
                             0 );

    if( !bResult || dwBytesRead != m_dwImageSize )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        return hr;
    }

    CloseHandle( hFile );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DownloadImage
// Desc: Downloads the DSP image by calling DownloadEffectsImage on the 
//       given DSound object
//-----------------------------------------------------------------------------
HRESULT 
CDSPImage::DownloadImage( LPDIRECTSOUND8 pDSound )
{
    HRESULT hr = S_OK;
    LPDSEFFECTIMAGEDESC pDesc;

    // Use a copy of the buffer so we can keep the original intact
    BYTE * pBuffer = new BYTE[ m_dwImageSize ];
    memcpy( pBuffer, m_pbImageData, m_dwImageSize );

    // call dsound api to download the image..
    hr = pDSound->DownloadEffectsImage( pBuffer,
                                        m_dwImageSize,
                                        NULL,
                                        &pDesc );
    // delete our modified copy
    delete[] pBuffer;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\src\xdpvoice.cpp ===
//-----------------------------------------------------------------------------
// File: xdpvoice.cpp
//
// Desc: DVoice common routines
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <assert.h>
#include <string.h>

#include "xdppeer.h"
#include "xdpvoice.h"


//-----------------------------------------------------------------------------
// client and server objects
//-----------------------------------------------------------------------------
IDirectPlayVoiceServer *g_pDVServer;				// server object
IDirectPlayVoiceClient *g_pDVClient;				// client object


//-----------------------------------------------------------------------------
// message handlers
//-----------------------------------------------------------------------------
HRESULT (WINAPI *g_AppDVMsgHandler)(void *, DWORD, void *); // app message handler
HRESULT __stdcall XDVMsgHandler(LPVOID *, DWORD, LPVOID *);	// our message handler


//-----------------------------------------------------------------------------
// voice peripheral stuff
//-----------------------------------------------------------------------------
DWORD XDVFindHawk();								// searches for hawk peripherals
DWORD g_dwHawkPort;									// port hawk is in


//-----------------------------------------------------------------------------
// voice targets
//-----------------------------------------------------------------------------
DVID g_dvidTargets[MAX_TARGETS];					// transmit target array
DWORD g_dwNumTargets;								// # of targets in array


//-----------------------------------------------------------------------------
// Name: XDVInit
// Desc: Initialize Voice subsystem and other relevant stuff.
//-----------------------------------------------------------------------------
HRESULT XDVInit(LONG (WINAPI *DVMsgHandler)(void *, DWORD, void *))
{
	HRESULT hr;

	// Save message handler pointer
	g_AppDVMsgHandler = DVMsgHandler;

	// create server object
	hr = XDirectPlayVoiceCreate(IID_IDirectPlayVoiceServer, (LPVOID *)&g_pDVServer);
	assert(SUCCEEDED(hr));

	// create client object
	hr = XDirectPlayVoiceCreate(IID_IDirectPlayVoiceClient, (LPVOID *)&g_pDVClient);
	assert(SUCCEEDED(hr));

	// find hawk port
	g_dwHawkPort = XDVFindHawk();

	// init target array
	g_dwNumTargets = 0;

	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: XDVDoWork
// Desc: Does DVoice work.
//-----------------------------------------------------------------------------
HRESULT XDVDoWork()
{
	if(g_pDVClient)
		return g_pDVClient->DoWork();

	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: XDVMsgHandler
// Desc: Voice message callback
//-----------------------------------------------------------------------------
HRESULT __stdcall XDVMsgHandler(LPVOID pvUserContext, DWORD dwMsgType, LPVOID pMsg)
{
	switch(dwMsgType)
	{
		// once we are connected, set targets to all players
		// we can override this in our app handler if we want to
        case DVMSGID_CONNECTRESULT:
			XDVAddTransmitTarget(DVID_ALLPLAYERS);
            break;
	}

	// call app DV message handler
	return g_AppDVMsgHandler(pvUserContext, dwMsgType, pMsg);
}

//-----------------------------------------------------------------------------
// Name: XDVCreate
// Desc: Create a DVoice session on the host player
// Params: dwSessionType - DVSESSIONTYPE_PEER, _FORWARDING
//         guidCT - GUID specifying compression for this session
//-----------------------------------------------------------------------------
HRESULT XDVCreate(DWORD dwSessionType, GUID guidCT)
{
	HRESULT hr;
	DVSESSIONDESC dvSession;

	// initialize DVoice server
	hr = g_pDVServer->Initialize(g_pDP, NULL, NULL, NULL, 0);
	assert(SUCCEEDED(hr));

	// initialize the session description
	ZeroMemory(&dvSession, sizeof(DVSESSIONDESC));
	dvSession.dwSize = sizeof(DVSESSIONDESC);
	dvSession.dwFlags = 0;
	dvSession.dwSessionType = dwSessionType;
	dvSession.guidCT = guidCT;

	// start the session
	hr = g_pDVServer->StartSession(&dvSession, 0);
	assert(SUCCEEDED(hr));

	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: XDVConnect
// Desc: Connect to an existing DVoice session
//-----------------------------------------------------------------------------
HRESULT XDVConnect(DWORD dwFlags)
{
	HRESULT hr;
	DVCLIENTCONFIG dvConfig;

	// initialize dvoice
	hr = g_pDVClient->Initialize(g_pDP, XDVMsgHandler, NULL, NULL, 0);
	assert(SUCCEEDED(hr));

	// initialize client configuration
	ZeroMemory(&dvConfig, sizeof(DVCLIENTCONFIG));
	dvConfig.dwSize = sizeof(DVCLIENTCONFIG);

	// the flags dword specifies the type of voice activation
	// it can have DVCLIENTCONFIG_MANUALVOICEACTIVATED set or
	// DVCLIENTCONFIG_AUTOVOICEACTIVATED set, or neither of them set.
	dvConfig.dwFlags = dwFlags;

	// if MANUALVOICEACTIVATED is set, we set the threshold manually.
	// if AUTOVOICEACTIVATED is set, we set the threshold to UNUSED.
	// if neither is set, we set to UNUSED, and voice will 
	// be active whenever there is a valid transmit target.
	if(dwFlags&DVCLIENTCONFIG_MANUALVOICEACTIVATED)
		dvConfig.dwThreshold = DVTHRESHOLD_DEFAULT;
	else
		dvConfig.dwThreshold = DVTHRESHOLD_UNUSED;

	// if hawk was not enumerated, pass a valid value to dvoice anyway
    if(g_dwHawkPort==-1) 
        g_dwHawkPort = 0;
	dvConfig.dwPort = g_dwHawkPort;

	// do the connect
	hr = g_pDVClient->Connect(&dvConfig, 0);
	assert(SUCCEEDED(hr));

	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: XDVDisconnect
// Desc: Disconnect from a DVoice session
//-----------------------------------------------------------------------------
HRESULT XDVDisconnect()
{
	HRESULT hr;
	
	hr = g_pDVClient->Disconnect(0);
	assert(SUCCEEDED(hr));

	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: XDVStopSession
// Desc: Terminates the DVoice session. Does not allow host migration.
//-----------------------------------------------------------------------------
HRESULT XDVStopSession()
{
	HRESULT hr;
	
	hr = g_pDVServer->StopSession(DVFLAGS_NOHOSTMIGRATE);
	assert(SUCCEEDED(hr));

	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: XDVFindHawk
// Desc: Finds a usable voice peripheral.
//-----------------------------------------------------------------------------
DWORD XDVFindHawk()
{
	DWORD dwInsertions, i;
	DWORD dwPort, dwSlot;
	DWORD ticks;

	ticks = GetTickCount();

	OutputDebugStringA("xdpvoice: Searching for Hawk voice peripheral\n");
	
	dwInsertions = 0;
	dwPort = -1;
	while(!dwInsertions)
	{
		dwInsertions = XGetDevices(XDEVICE_TYPE_VOICE_MICROPHONE);
		if(dwInsertions)
			for(i=0; i<32; i++)
				if(dwInsertions&(1<<i))
				{
					if(i<16)
					{
						dwPort = i;
						dwSlot = XDEVICE_TOP_SLOT;
					}
					else
					{
						dwPort = i-16;
						dwSlot = XDEVICE_BOTTOM_SLOT;
					}

					if(dwPort>=4)
						OutputDebugStringA("\nxdpvoice: Hawk in illegal port\n\n");
					
					break;
				}

		if((GetTickCount()-ticks)>2000)
		{
			OutputDebugStringA("Hawk search timed out.\n");
			break;
		}
	}

	if(dwPort!=-1)
		OutputDebugStringA("Hawk found...\n");

	return dwPort;
}

//-----------------------------------------------------------------------------
// Name: XDVAddTransmitTarget
// Desc: Adds a transmit target to the current list.
//       If DVID_ALLPLAYERS is added, it sets the array to hold only
//       this single element. If anything besides ALLPLAYERS is added,
//       ALLPLAYERS is removed from the list.
//-----------------------------------------------------------------------------
HRESULT XDVAddTransmitTarget(DVID dvidTarget)
{
	DWORD i;

	if(dvidTarget==DVID_ALLPLAYERS)
	{
		g_dvidTargets[0] = DVID_ALLPLAYERS;
		g_dwNumTargets = 1;
	}
	else if(g_dvidTargets[0]==DVID_ALLPLAYERS || g_dwNumTargets==0)
	{
		g_dvidTargets[0] = dvidTarget;
		g_dwNumTargets = 1;
	}
	else
	{
		for(i=0; i<g_dwNumTargets; i++)
			if(g_dvidTargets[i]==dvidTarget)
				return S_FALSE;

		g_dvidTargets[g_dwNumTargets++] = dvidTarget;
	}

	return XDVSetTransmitTargets();
}

//-----------------------------------------------------------------------------
// Name: XDVRemoveTransmitTarget
// Desc: Removes a target from the transmit list.
//-----------------------------------------------------------------------------
HRESULT XDVRemoveTransmitTarget(DVID dvidTarget)
{
	DWORD i;

	for(i=0; i<g_dwNumTargets; i++)
		if(g_dvidTargets[i]==dvidTarget)
		{
			g_dvidTargets[i] = g_dvidTargets[--g_dwNumTargets];
			return XDVSetTransmitTargets();
		}

	return S_FALSE;
}

//-----------------------------------------------------------------------------
// Name: XDVSetTransmitTargets
// Desc: Sends the current target list to DVoice.
//-----------------------------------------------------------------------------
HRESULT XDVSetTransmitTargets()
{
	HRESULT hr;

	if(g_dwNumTargets!=0)
		hr = g_pDVClient->SetTransmitTargets(g_dvidTargets, g_dwNumTargets, 0);
	else
		hr = g_pDVClient->SetTransmitTargets(NULL, 0, 0);

    assert(SUCCEEDED(hr));

	return hr;
}

//-----------------------------------------------------------------------------
// Name: XDVClearTransmitTargets
// Desc: Clears the transmit target list.
//-----------------------------------------------------------------------------
HRESULT XDVClearTransmitTargets()
{
	HRESULT hr;

	g_dwNumTargets = 0;

    hr = g_pDVClient->SetTransmitTargets(NULL, 0, 0);
    assert(SUCCEEDED(hr));

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\src\xbutil.cpp ===
//-----------------------------------------------------------------------------
// File: XBUtil.cpp
//
// Desc: Shortcut macros and helper functions for the XBox samples
//
// Hist: 11.01.00 - New for November XDK release
//       12.01.00 - Moved input code to XBInput.cpp
//       12.15.00 - Changes for December XDK release
//       02.19.00 - Changes for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xgraphics.h>
#include <tchar.h> 
#include <stdio.h> 
#include "XBUtil.h"




//-----------------------------------------------------------------------------
// Path to the XBox media files on the target machine
//-----------------------------------------------------------------------------
CHAR g_strMediaPath[512] = "D:\\Media\\";




//-----------------------------------------------------------------------------
// Name: XBUtil_SetMediaPath()
// Desc: Sets the path to media files
//-----------------------------------------------------------------------------
VOID XBUtil_SetMediaPath( const CHAR* strPath )
{
    strcpy( g_strMediaPath, strPath );
}

    
    
    
//-----------------------------------------------------------------------------
// Name: XBUtil_FindMediaFile()
// Desc: Returns a valid path to a media file.
//-----------------------------------------------------------------------------
HRESULT XBUtil_FindMediaFile( CHAR* strPath, const CHAR* strFilename )
{
    // Check for valid arguments
    if( NULL==strFilename || NULL==strPath )
    {
        OutputDebugStringA( "XBUtil_FindMediaFile(): Invalid arguments\n" );
        return E_INVALIDARG;
    }

    // Default path is the filename itself as a fully qualified path
    strcpy( strPath, strFilename );

    // Check for the ':' character to see if the filename is a fully
    // qualified path. If not, prepend the media directory
    if( strFilename[1] != ':' )
        sprintf( strPath, "%s%s", g_strMediaPath, strFilename );

    // Try to open the file
    HANDLE hFile = CreateFile( strPath, GENERIC_READ, FILE_SHARE_READ, NULL, 
                               OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
    {
        // Return error
        CHAR strBuffer[80];
        sprintf( strBuffer, "XBUtil_FindMediaFile(): Could not find file [%s]\n", 
                            strFilename );
        OutputDebugStringA( strBuffer );
        return 0x82000004;
    }

    // Found the file. Close the file and return
    CloseHandle( hFile );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_Timer()
// Desc: Performs timer opertations. Use the following commands:
//          TIMER_RESET           - to reset the timer
//          TIMER_START           - to start the timer
//          TIMER_STOP            - to stop (or pause) the timer
//          TIMER_ADVANCE         - to advance the timer by 0.1 seconds
//          TIMER_GETABSOLUTETIME - to get the absolute system time
//          TIMER_GETAPPTIME      - to get the current time
//-----------------------------------------------------------------------------
FLOAT XBUtil_Timer( TIMER_COMMAND command )
{
    static BOOL  m_bTimerInitialized = FALSE;
    static FLOAT m_fSecsPerTick = 0.0f;
    static FLOAT m_fBaseTime    = 0.0f;
    static FLOAT m_fStopTime    = 0.0f;
    FLOAT        fTime;

    // Initialize the timer
    if( FALSE == m_bTimerInitialized )
    {
        m_bTimerInitialized = TRUE;

        // Use QueryPerformanceFrequency() to get frequency of timer.
        LARGE_INTEGER qwTicksPerSec;
        QueryPerformanceFrequency( &qwTicksPerSec );
        m_fSecsPerTick = 1.0f / (FLOAT)qwTicksPerSec.QuadPart;
    }

    // Get the current time using QueryPerformanceCounter() or timeGetTime()
    LARGE_INTEGER qwTime;
    QueryPerformanceCounter( &qwTime );
    fTime = ((FLOAT)qwTime.QuadPart) * m_fSecsPerTick;

    // Reset the timer
    if( command == TIMER_RESET )
    {
        m_fBaseTime = fTime;
        return 0.0f;
    }

    // Return the current time
    if( command == TIMER_GETAPPTIME )
        return fTime - m_fBaseTime;

    // Start the timer
    if( command == TIMER_START )
        m_fBaseTime += fTime - m_fStopTime;

    // Stop the timer
    if( command == TIMER_STOP )
        m_fStopTime = fTime;

    // Advance the timer by 1/10th second
    if( command == TIMER_ADVANCE )
        m_fBaseTime += fTime - ( m_fStopTime + 0.1f );

    // Retract the timer by 1/10th second
    if( command == TIMER_RETRACT )
        m_fBaseTime += fTime - ( m_fStopTime - 0.1f );

    return fTime;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_InitMaterial()
// Desc: Initializes a D3DMATERIAL8 structure, setting the diffuse and ambient
//       colors. It does not set emissive or specular colors.
//-----------------------------------------------------------------------------
VOID XBUtil_InitMaterial( D3DMATERIAL8& mtrl, FLOAT r, FLOAT g, FLOAT b,
                          FLOAT a )
{
    ZeroMemory( &mtrl, sizeof(D3DMATERIAL8) );
    mtrl.Diffuse.r = mtrl.Ambient.r = r;
    mtrl.Diffuse.g = mtrl.Ambient.g = g;
    mtrl.Diffuse.b = mtrl.Ambient.b = b;
    mtrl.Diffuse.a = mtrl.Ambient.a = a;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_InitLight()
// Desc: Initializes a D3DLIGHT structure, setting the light position. The
//       diffuse color is set to white, specular and ambient left as black.
//-----------------------------------------------------------------------------
VOID XBUtil_InitLight( D3DLIGHT8& light, D3DLIGHTTYPE ltType,
                       FLOAT x, FLOAT y, FLOAT z )
{
    ZeroMemory( &light, sizeof(D3DLIGHT8) );
    light.Type         = ltType;
    light.Diffuse.r    = 1.0f;
    light.Diffuse.g    = 1.0f;
    light.Diffuse.b    = 1.0f;
    light.Position     = D3DXVECTOR3(x,y,z);

    light.Position.x   = x;
    light.Position.y   = y;
    light.Position.z   = z;
    D3DXVECTOR3 vSource(x,y,z);
    D3DXVec3Normalize( (D3DXVECTOR3*)&light.Direction, &vSource );
    light.Range        = 1000.0f;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateTexture()
// Desc: Helper function to create a texture.
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateTexture( LPDIRECT3DDEVICE8 pd3dDevice, const CHAR* strTexture,
                              LPDIRECT3DTEXTURE8* ppTexture, D3DFORMAT d3dFormat )
{
    HRESULT hr;

    // Find the media file
    CHAR strTexturePath[512];
    if( FAILED( hr = XBUtil_FindMediaFile( strTexturePath, strTexture ) ) )
        return hr;

    // Create the texture using D3DX. Check the current directory
    return D3DXCreateTextureFromFileEx( pd3dDevice, strTexturePath, 
                                        D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 
                                        0, d3dFormat, D3DPOOL_DEFAULT, 
                                        D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, 
                                        ppTexture );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_UnswizzleTexture2D()
// Desc: Unswizzles a 2D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_UnswizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGUnswizzleRect( pSrcBits, pDesc->Width, pDesc->Height, NULL, pLock->pBits, 
                     0, NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_UnswizzleTexture3D()
// Desc: Unswizzles a 3D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_UnswizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * pDesc->Depth * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGUnswizzleBox( pSrcBits, pDesc->Width, pDesc->Height, pDesc->Depth, NULL, pLock->pBits,
                    0, 0, NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_SwizzleTexture2D()
// Desc: Swizzles a 2D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_SwizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGSwizzleRect( pSrcBits, 0, NULL, pLock->pBits,
                  pDesc->Width, pDesc->Height, 
                  NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_SwizzleTexture3D()
// Desc: Swizzles a 3D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_SwizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * pDesc->Depth * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGSwizzleBox( pSrcBits, 0, 0, NULL, pLock->pBits,
                  pDesc->Width, pDesc->Height, pDesc->Depth, 
                  NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateVertexShader()
// Desc: Creates a file-based vertex shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateVertexShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                   const CHAR* strFilename,
                                   const DWORD* pdwVertexDecl,
                                   DWORD* pdwVertexShader )
{
    HRESULT hr;

    // Find the media file
    CHAR strShaderPath[512];
    if( FAILED( hr = XBUtil_FindMediaFile( strShaderPath, strFilename ) ) )
        return hr;

    // Open the vertex shader file
    HANDLE hFile = CreateFile( strShaderPath, GENERIC_READ, FILE_SHARE_READ, 
                               NULL, OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
        return E_FAIL;

    // Allocate memory to read the vertex shader file
    DWORD dwSize = GetFileSize( hFile, NULL );
    BYTE* pData  = new BYTE[dwSize+4];
    if( NULL == pData )
        return E_FAIL;
    ZeroMemory( pData, dwSize+4 );

    // Read the pre-compiled vertex shader microcode
    DWORD dwBytesRead;
    ReadFile( hFile, pData, dwSize, &dwBytesRead, NULL );

    // Create the vertex shader
    hr = pd3dDevice->CreateVertexShader( pdwVertexDecl, (const DWORD*)pData,
                                         pdwVertexShader, 0 );

    // Cleanup and return
    CloseHandle( hFile );
    delete [] pData;
    return hr;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreatePixelShader()
// Desc: Creates a file-based pixel shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreatePixelShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                  const CHAR* strFilename, DWORD* pdwPixelShader )
{
    HRESULT hr;

    // Find the media file
    CHAR strShaderPath[512];
    if( FAILED( hr = XBUtil_FindMediaFile( strShaderPath, strFilename ) ) )
        return hr;

    // Open the pixel shader file
    HANDLE hFile = CreateFile( strShaderPath, GENERIC_READ, FILE_SHARE_READ, 
                               NULL, OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
        return E_FAIL;

    // Load the pre-compiled pixel shader microcode
    D3DPIXELSHADERDEF_FILE psdf;
    DWORD                  dwBytesRead;
    ReadFile( hFile, &psdf, sizeof(D3DPIXELSHADERDEF_FILE), &dwBytesRead, NULL );
    CloseHandle( hFile );

    // Make sure the pixel shader is valid
    if( dwBytesRead != sizeof(D3DPIXELSHADERDEF_FILE) || 
        psdf.FileID != D3DPIXELSHADERDEF_FILE_ID )
    {
        OutputDebugString( _T("XBUtil_CreatePixelShader(): Invalid pixel shader file\n") );
        return E_FAIL;
    }

    // Create the pixel shader
    if( FAILED( hr = pd3dDevice->CreatePixelShader( &(psdf.Psd), pdwPixelShader ) ) )
    {
        OutputDebugString( _T("XBUtil_CreatePixelShader(): Could not create pixel shader\n") );
        return hr;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_GetCubeMapViewMatrix()
// Desc: Returns a view matrix for rendering to a face of a cubemap.
//-----------------------------------------------------------------------------
D3DXMATRIX XBUtil_GetCubeMapViewMatrix( DWORD dwFace )
{
    D3DXVECTOR3 vEyePt   = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vLookDir = D3DXVECTOR3( 1.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );

    switch( dwFace )
    {
        case D3DCUBEMAP_FACE_POSITIVE_X:
            vLookDir = D3DXVECTOR3( 1.0f, 0.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
        case D3DCUBEMAP_FACE_NEGATIVE_X:
            vLookDir = D3DXVECTOR3(-1.0f, 0.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
        case D3DCUBEMAP_FACE_POSITIVE_Y:
            vLookDir = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 0.0f,-1.0f );
            break;
        case D3DCUBEMAP_FACE_NEGATIVE_Y:
            vLookDir = D3DXVECTOR3( 0.0f,-1.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 0.0f, 1.0f );
            break;
        case D3DCUBEMAP_FACE_POSITIVE_Z:
            vLookDir = D3DXVECTOR3( 0.0f, 0.0f, 1.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
        case D3DCUBEMAP_FACE_NEGATIVE_Z:
            vLookDir = D3DXVECTOR3( 0.0f, 0.0f,-1.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
    }

    // Set the view transform for this cubemap surface
    D3DXMATRIX matView;
    D3DXMatrixLookAtLH( &matView, &vEyePt, &vLookDir, &vUpDir );
    return matView;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateNormalizationCubeMap()
// Desc: Creates a cubemap and fills it with normalized RGBA vectors
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateNormalizationCubeMap( LPDIRECT3DDEVICE8 pd3dDevice, 
                                           DWORD dwSize, 
                                           LPDIRECT3DCUBETEXTURE8* ppCubeMap )
{
    HRESULT hr;

    // Create the cube map
    if( FAILED( hr = pd3dDevice->CreateCubeTexture( dwSize, 1, 0, D3DFMT_X8R8G8B8, 
                                                    D3DPOOL_DEFAULT, ppCubeMap ) ) )
        return E_FAIL;
    
    // Allocate temp space for swizzling the cubemap surfaces
    DWORD* pSourceBits = new DWORD[ dwSize * dwSize ];

    // Fill all six sides of the cubemap
    for( DWORD i=0; i<6; i++ )
    {
        // Lock the i'th cubemap surface
        LPDIRECT3DSURFACE8 pCubeMapFace;
        (*ppCubeMap)->GetCubeMapSurface( (D3DCUBEMAP_FACES)i, 0, &pCubeMapFace );

        // Write the RGBA-encoded normals to the surface pixels
        DWORD*      pPixel = pSourceBits;
        D3DXVECTOR3 n;
        FLOAT       w, h;

        for( DWORD y = 0; y < dwSize; y++ )
        {
            h  = (FLOAT)y / (FLOAT)(dwSize-1);  // 0 to 1
            h  = ( h * 2.0f ) - 1.0f;           // -1 to 1
            
            for( DWORD x = 0; x < dwSize; x++ )
            {
                w = (FLOAT)x / (FLOAT)(dwSize-1);   // 0 to 1
                w = ( w * 2.0f ) - 1.0f;            // -1 to 1

                // Calc the normal for this texel
                switch( i )
                {
                    case D3DCUBEMAP_FACE_POSITIVE_X:    // +x
                        n.x = +1.0;
                        n.y = -h;
                        n.z = -w;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_X:    // -x
                        n.x = -1.0;
                        n.y = -h;
                        n.z = +w;
                        break;
                        
                    case D3DCUBEMAP_FACE_POSITIVE_Y:    // y
                        n.x = +w;
                        n.y = +1.0;
                        n.z = +h;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_Y:    // -y
                        n.x = +w;
                        n.y = -1.0;
                        n.z = -h;
                        break;
                        
                    case D3DCUBEMAP_FACE_POSITIVE_Z:    // +z
                        n.x = +w;
                        n.y = -h;
                        n.z = +1.0;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_Z:    // -z
                        n.x = -w;
                        n.y = -h;
                        n.z = -1.0;
                        break;
                }

                // Store the normal as an RGBA color
                D3DXVec3Normalize( &n, &n );
                *pPixel++ = XBUtil_VectorToRGBA( &n );
            }
        }
        
        // Swizzle the result into the cubemap face surface
        D3DLOCKED_RECT lock;
        pCubeMapFace->LockRect( &lock, 0, 0L );
        XGSwizzleRect( pSourceBits, 0, NULL, lock.pBits, dwSize, dwSize,
                       NULL, sizeof(DWORD) );
        pCubeMapFace->UnlockRect();

        // Release the cubemap face
        pCubeMapFace->Release();
    }

    // Free temp space
    SAFE_DELETE_ARRAY( pSourceBits );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_DumpSurface()
// Desc: Writes the contents of a surface (32-bit only) to a .tga file. This
//       could be a backbuffer, texture, or any other 32-bit surface.
//-----------------------------------------------------------------------------
HRESULT XBUtil_DumpSurface( LPDIRECT3DSURFACE8 pSurface, const CHAR* strFileName )
{
    // Get the surface description. Make sure it's a 32-bit format
    D3DSURFACE_DESC desc;
    pSurface->GetDesc( &desc );
    if( desc.Size != ( desc.Width * desc.Height * sizeof(DWORD) ) )
        return E_NOTIMPL;

    // Lock the surface
    D3DLOCKED_RECT lock;
    if( FAILED( pSurface->LockRect( &lock, 0, 0 ) ) )
        return E_FAIL;

    // Allocate memory for storing the surface bits
    VOID* pBits = (VOID*)new DWORD[desc.Width*desc.Height];

    // Unswizzle the bits, if necessary
    if( XGIsSwizzledFormat( desc.Format ) )
        XGUnswizzleRect( lock.pBits, desc.Width, desc.Height, NULL,
                         pBits, lock.Pitch, NULL, sizeof(DWORD) );
    else
        memcpy( pBits, lock.pBits, desc.Size );
    
    // Unlock the surface
    pSurface->UnlockRect();

    // Setup the TGA file header
    struct TargaHeader
    {
        BYTE IDLength;
        BYTE ColormapType;
        BYTE ImageType;
        BYTE ColormapSpecification[5];
        WORD XOrigin;
        WORD YOrigin;
        WORD ImageWidth;
        WORD ImageHeight;
        BYTE PixelDepth;
        BYTE ImageDescriptor;
    } tgaHeader;

    ZeroMemory( &tgaHeader, sizeof(tgaHeader) );
    tgaHeader.IDLength        = 0;
    tgaHeader.ImageType       = 2;
    tgaHeader.ImageWidth      = (WORD)desc.Width;
    tgaHeader.ImageHeight     = (WORD)desc.Height;
    tgaHeader.PixelDepth      = 32;
    tgaHeader.ImageDescriptor = 0x28;

    // Create a new file
    FILE* file = fopen( strFileName, "wb" );
    if( NULL == file )
    {
        pSurface->UnlockRect();
        return E_FAIL;
    }

    // Write the Targa header and the surface pixels to the file
    fwrite( &tgaHeader, sizeof(TargaHeader), 1, file );
    fwrite( pBits, sizeof(BYTE), desc.Size, file );
    fclose( file );

    // Cleanup and return
    delete[] pBits;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateHermite()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Hermite curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateHermite( const D3DXVECTOR3& p0, const D3DXVECTOR3& p1, 
                                    const D3DXVECTOR3& v0, const D3DXVECTOR3& v1,
                                    FLOAT u )
{
    // Generate coeffecients from the two end points and two tangents
    D3DXVECTOR3 a =  2*p0 - 2*p1 +   v0 + v1; // a = 2p0 - 2p1 +  v0 + v1
    D3DXVECTOR3 b = -3*p0 + 3*p1 - 2*v0 - v1; // b =-3p0 + 3p1 - 2v0 + v1
    D3DXVECTOR3 c =                  v0;      // c = v0  
    D3DXVECTOR3 d =    p0;                    // d = p0

    // Evaluate the equation at u, where:
    //    f(u) = au^3 + bu^2 + cu + d
    return ( ( a * u + b ) * u + c ) * u + d;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateCatmullRom()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Catmull-Rom curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateCatmullRom( const D3DXVECTOR3& p1, const D3DXVECTOR3& p2, 
                                       const D3DXVECTOR3& p3, const D3DXVECTOR3& p4,
                                       FLOAT u )
{
    // Generate coeffecients from four spline points
    D3DXVECTOR3 a =   -p1 + 3*p2 - 3*p3 + p4;
    D3DXVECTOR3 b =  2*p1 - 5*p2 + 4*p3 - p4;
    D3DXVECTOR3 c =   -p1        +   p3;
    D3DXVECTOR3 d =         2*p2;

    // Evaluate the equation at u, where:
    //    f(u) = 0.5 * ( au^3 + bu^2 + cu + d )
    return 0.5f * ( ( ( a * u + b ) * u + c ) * u + d );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_GetSplinePoint()
// Desc: Returns a point on a spline. The spline is defined by an array of
//       points, and the point and tangent returned are located at position t
//       on the spline, where 0 < t < dwNumSpinePts.
//-----------------------------------------------------------------------------
VOID XBUtil_GetSplinePoint( const D3DXVECTOR3* pSpline, DWORD dwNumSpinePts,
                            FLOAT t, D3DXVECTOR3* pvPoint, D3DXVECTOR3* pvTangent )
{
    DWORD p0 = ( t > 1.0 ) ? (DWORD)floorf(t)-1 : dwNumSpinePts-1;
    DWORD p1 = ( p0 < dwNumSpinePts-1 ) ? p0 + 1 : 0;
    DWORD p2 = ( p1 < dwNumSpinePts-1 ) ? p1 + 1 : 0;
    DWORD p3 = ( p2 < dwNumSpinePts-1 ) ? p2 + 1 : 0;
    FLOAT u  = t - floorf(t);

    if( pvPoint )
        (*pvPoint) = XBUtil_EvaluateCatmullRom( pSpline[p0], pSpline[p1], 
                                                pSpline[p2], pSpline[p3], u );

    if( pvTangent )
        (*pvTangent) = 0.5f * ( (1-u) * ( pSpline[p2] - pSpline[p0] ) + 
                                  (u) * ( pSpline[p3] - pSpline[p1] ) );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_RenderSpline()
// Desc: For debugging purposes, visually renders a spline.
//-----------------------------------------------------------------------------
VOID XBUtil_RenderSpline( LPDIRECT3DDEVICE8 pd3dDevice, const D3DXVECTOR3* pSpline, 
                          DWORD dwNumSplinePts, DWORD dwColor, BOOL bRenderAxes )
{
    pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TFACTOR );
    pd3dDevice->SetVertexShader( D3DFVF_XYZ );

    for( FLOAT u = 0; u < dwNumSplinePts; u += 1.0f )
    {
        D3DXVECTOR3 p[2];
        D3DXVECTOR3 vTangent, vSide, vUp;

        XBUtil_GetSplinePoint( pSpline, dwNumSplinePts, u+0, &p[0], &vTangent );
        XBUtil_GetSplinePoint( pSpline, dwNumSplinePts, u+1, &p[1], NULL );

        D3DXVec3Normalize( &vTangent, &vTangent );
        D3DXVECTOR3 v1( 0, 1, 0 );
        D3DXVec3Cross( &vSide, &v1, &vTangent );
        D3DXVec3Cross( &vUp, &vTangent, &vSide );

        pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, dwColor );
        pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );

        if( bRenderAxes )
        {
            p[1] = p[0] + vTangent/4;
            pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xffff0000 );
            pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );

            p[1] = p[0] + vSide/4;
            pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xff00ff00 );
            pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );

            p[1] = p[0] + vUp/4;
            pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xffffffff );
            pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );
        }
    }
}




//-----------------------------------------------------------------------------
// Name: XBUtil_DeclaratorFromFVF()
// Desc: Create a vertex declaration from an FVF. Registers are assigned as
//       follows:
//          v0     = Vertex position
//          v1     = Vertex blend weights
//          v2     = Vertex normal
//          v3     = Vertex diffuse color
//          v4     = Vertex specular color
//       // v5     = Vertex fog (no FVF code)
//       // v6     = Vertex pointsize (no FVF code)
//       // v7     = Vertex back diffuse color (no FVF code)
//       // v8     = Vertex back specular color (no FVF code)
//          v9-v12 = Vertex texture coords
//-----------------------------------------------------------------------------
HRESULT XBUtil_DeclaratorFromFVF( DWORD dwFVF, 
                                  DWORD Declaration[MAX_FVF_DECL_SIZE] )
{
    // Start the declaration
    DWORD decl = 0;
    Declaration[decl++] = D3DVSD_STREAM(0);

    // Handle position
    DWORD dwPositionFVF = ( dwFVF & D3DFVF_POSITION_MASK );
    if( dwPositionFVF == D3DFVF_XYZRHW ) Declaration[decl++] = D3DVSD_REG( 0, D3DVSDT_FLOAT4 ); 
    else                                 Declaration[decl++] = D3DVSD_REG( 0, D3DVSDT_FLOAT3 ); 

    // Handle blend weights
    if( dwPositionFVF == D3DFVF_XYZB1 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT1 ); 
    if( dwPositionFVF == D3DFVF_XYZB2 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT2 ); 
    if( dwPositionFVF == D3DFVF_XYZB3 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT3 ); 
    if( dwPositionFVF == D3DFVF_XYZB4 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT4 ); 

    // Handle normal, diffuse, and specular
    if( dwFVF & D3DFVF_NORMAL )          Declaration[decl++] = D3DVSD_REG( 2, D3DVSDT_FLOAT3 );
    if( dwFVF & D3DFVF_DIFFUSE )         Declaration[decl++] = D3DVSD_REG( 3, D3DVSDT_D3DCOLOR );
    if( dwFVF & D3DFVF_SPECULAR )        Declaration[decl++] = D3DVSD_REG( 4, D3DVSDT_D3DCOLOR );

    // Handle texture coordinates
    DWORD dwNumTextures = (dwFVF & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT;

    for( DWORD i=0; i<dwNumTextures; i++ )
    {
        DWORD dwNumTexCoords = 0;
        if( ( dwFVF & D3DFVF_TEXCOORDSIZE1(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE1(i) )
            dwNumTexCoords = D3DVSDT_FLOAT1;
        if( ( dwFVF & D3DFVF_TEXCOORDSIZE2(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE2(i) )
            dwNumTexCoords = D3DVSDT_FLOAT2;
        if( ( dwFVF & D3DFVF_TEXCOORDSIZE3(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE3(i) )
            dwNumTexCoords = D3DVSDT_FLOAT3;
        if( ( dwFVF & D3DFVF_TEXCOORDSIZE4(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE4(i) )
            dwNumTexCoords = D3DVSDT_FLOAT4;

        Declaration[decl++] = D3DVSD_REG( 9 + i, dwNumTexCoords );
    }

    // End the declarator
    Declaration[decl++] = D3DVSD_END();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\src\XbStorageDevice.cpp ===
//-----------------------------------------------------------------------------
// File: XbStorageDevice.cpp
//
// Desc: Hard disk and memory unit devices. Provides save and load game
//       functionality.
//
// Hist: 01.30.01 - New for March XDK release
//       04.13.01 - Added GetClusterSize(), GetSaveGameOverhead() and
//                  GetFileBytes() for more accurate calculation of
//                  file sizes.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "XbStorageDevice.h"
#include <cassert>




//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------
const CHAR* strROOT_PATH = "#:\\";  // "#:\", where # is the drive letter
const DWORD BLOCK_SIZE = 16 * 1024; // TCR 3-11 Space Display




//-----------------------------------------------------------------------------
// Name: CXBStorageDevice()
// Desc: Construct storage device
//-----------------------------------------------------------------------------
CXBStorageDevice::CXBStorageDevice( CHAR chDriveLetter )
:
    m_hSaveGame( INVALID_HANDLE_VALUE ),
    m_strRootPath()
{
    lstrcpyA( m_strRootPath, strROOT_PATH );
    *m_strRootPath = chDriveLetter;
}




//-----------------------------------------------------------------------------
// Name: CXBStorageDevice()
// Desc: Copy storage device
//-----------------------------------------------------------------------------
CXBStorageDevice::CXBStorageDevice( const CXBStorageDevice& rhs )
:
    m_hSaveGame( INVALID_HANDLE_VALUE ),
    m_strRootPath()
{
    lstrcpyA( m_strRootPath, strROOT_PATH );
    *m_strRootPath = *rhs.m_strRootPath;
}




//-----------------------------------------------------------------------------
// Name: CXBStorageDevice()
// Desc: Copy storage device
//-----------------------------------------------------------------------------
CXBStorageDevice& CXBStorageDevice::operator=( const CXBStorageDevice& rhs )
{
    Cleanup();
    *m_strRootPath = *rhs.m_strRootPath;
    return *this;
}




//-----------------------------------------------------------------------------
// Name: ~CXBStorageDevice()
// Desc: Tear down the storage device
//-----------------------------------------------------------------------------
CXBStorageDevice::~CXBStorageDevice()
{
    Cleanup();
}




//-----------------------------------------------------------------------------
// Name: GetUserRegion()
// Desc: Get the object representing the save/load region of the Xbox hard drive
//-----------------------------------------------------------------------------
CXBStorageDevice CXBStorageDevice::GetUserRegion() // static
{
    return CXBStorageDevice( 'U' );
}




//-----------------------------------------------------------------------------
// Name: GetTitleRegion()
// Desc: Get the object representing the title persistent data region of the
//       Xbox hard drive
//-----------------------------------------------------------------------------
CXBStorageDevice CXBStorageDevice::GetTitleRegion() // static
{
    return CXBStorageDevice( 'T' );
}




//-----------------------------------------------------------------------------
// Name: GetUtilityRegion()
// Desc: Get the object representing the utility region of the Xbox hard drive
//-----------------------------------------------------------------------------
CXBStorageDevice CXBStorageDevice::GetUtilityRegion( BOOL fFormatClean ) // static
{
    XMountUtilityDrive( fFormatClean );
    return CXBStorageDevice( 'Z' );
}




//-----------------------------------------------------------------------------
// Name: GetBlockSize()
// Desc: Get the size of a device block in bytes
//-----------------------------------------------------------------------------
DWORD CXBStorageDevice::GetBlockSize() // static
{
    // TCR 3-11 Space Display
    return BLOCK_SIZE;
}




//-----------------------------------------------------------------------------
// Name: GetDrive()
// Desc: Returns the drive letter of this device. Returns 0 if device
//       identifies a nul device.
//-----------------------------------------------------------------------------
CHAR CXBStorageDevice::GetDrive() const
{
    return *m_strRootPath;
}




//-----------------------------------------------------------------------------
// Name: SetDrive()
// Desc: Changes the device to refer to a new drive. Invalidates any save game
//       enumeration.
//-----------------------------------------------------------------------------
VOID CXBStorageDevice::SetDrive( CHAR chDriveLetter )
{
    Cleanup();
    *m_strRootPath = chDriveLetter;
}




//-----------------------------------------------------------------------------
// Name: IsValid()
// Desc: TRUE if object specifies a valid storage device (drive letter != 0)
//-----------------------------------------------------------------------------
BOOL CXBStorageDevice::IsValid() const
{
    return( *m_strRootPath != 0 );
}




//-----------------------------------------------------------------------------
// Name: IsUserRegion()
// Desc: TRUE if device specifies location of saved games, etc.
//-----------------------------------------------------------------------------
BOOL CXBStorageDevice::IsUserRegion() const
{
    return( *m_strRootPath == 'U' ||
            *m_strRootPath == 'F' ||
            *m_strRootPath == 'G' ||
            *m_strRootPath == 'H' ||
            *m_strRootPath == 'I' ||
            *m_strRootPath == 'J' ||
            *m_strRootPath == 'K' ||
            *m_strRootPath == 'L' ||
            *m_strRootPath == 'M' );
}




//-----------------------------------------------------------------------------
// Name: IsMemoryUnit()
// Desc: TRUE if drive specifies a memory unit
//-----------------------------------------------------------------------------
BOOL CXBStorageDevice::IsMemoryUnit() const
{
    return( *m_strRootPath >= 'F' && *m_strRootPath <= 'M' );
}




//-----------------------------------------------------------------------------
// Name: IsTitleRegion()
// Desc: TRUE if device specifies location of title persistent storage
//-----------------------------------------------------------------------------
BOOL CXBStorageDevice::IsTitleRegion() const
{
    return( *m_strRootPath == 'T' );
}




//-----------------------------------------------------------------------------
// Name: IsUtilityRegion()
// Desc: TRUE if device specifies location of utility/cache region
//-----------------------------------------------------------------------------
BOOL CXBStorageDevice::IsUtilityRegion() const
{
    return( *m_strRootPath == 'Z' );
}




//-----------------------------------------------------------------------------
// Name: GetName()
// Desc: Get the full name of the device. Assumes the buffer holds at least
//       MAX_MUNAME + 32 characters.
//-----------------------------------------------------------------------------
VOID CXBStorageDevice::GetName( WCHAR* strPathBuffer ) const
{
    assert( strPathBuffer != NULL );
    if( *m_strRootPath == 0 )
    {
        *strPathBuffer = 0;
        return;
    }

    if( IsMemoryUnit() )
    {
        // Build the default name
        lstrcpyW( strPathBuffer, L"Xbox MU " );
        switch( *m_strRootPath )
        {
            case 'F' : lstrcatW( strPathBuffer, L"1A" ); break;
            case 'G' : lstrcatW( strPathBuffer, L"1B" ); break;
            case 'H' : lstrcatW( strPathBuffer, L"2A" ); break;
            case 'I' : lstrcatW( strPathBuffer, L"2B" ); break;
            case 'J' : lstrcatW( strPathBuffer, L"3A" ); break;
            case 'K' : lstrcatW( strPathBuffer, L"3B" ); break;
            case 'L' : lstrcatW( strPathBuffer, L"4A" ); break;
            case 'M' : lstrcatW( strPathBuffer, L"4B" ); break;
            default: assert( FALSE ); break;
        }

        // TCR 3-10 Memory Unit Personalization
        // If the player has named the memory unit, append the name
        WCHAR strName[ MAX_MUNAME ];
        DWORD dwSuccess = XMUNameFromDriveLetter( *m_strRootPath, strName, 
                                                  MAX_MUNAME );
        if( dwSuccess == ERROR_SUCCESS && *strName != 0 )
        {
            WCHAR strFmtName[ MAX_MUNAME + 3 ];
            wsprintfW( strFmtName, L" (%ls)", strName );
            lstrcatW( strPathBuffer, strFmtName );
        }
    }
    else
    {
        lstrcpyW( strPathBuffer, L"Xbox Hard Disk" );
    }
}




//-----------------------------------------------------------------------------
// Name: GetSize()
// Desc: Get the total, used and free bytes. These values are always cluster
//       based; in other words, they're always evenly divisible by the
//       cluster size of the device.
//-----------------------------------------------------------------------------
BOOL CXBStorageDevice::GetSize( ULONGLONG& qwTotalBytes, ULONGLONG& qwUsedBytes,
                                ULONGLONG& qwFreeBytes ) const
{
    if( !IsValid() )
        return FALSE;

    ULARGE_INTEGER lFreeBytesAvailable;
    ULARGE_INTEGER lTotalNumberOfBytes;
    ULARGE_INTEGER lTotalNumberOfFreeBytes;

    BOOL bSuccess = GetDiskFreeSpaceEx( m_strRootPath,
                                        &lFreeBytesAvailable,
                                        &lTotalNumberOfBytes,
                                        &lTotalNumberOfFreeBytes );

    if( !bSuccess )
        return FALSE;

    qwTotalBytes = lTotalNumberOfBytes.QuadPart;
    qwFreeBytes  = lFreeBytesAvailable.QuadPart;
    qwUsedBytes  = qwTotalBytes - qwFreeBytes;
    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: GetSavedGameCount()
// Desc: Returns the number of games currently saved on the device
//-----------------------------------------------------------------------------
DWORD CXBStorageDevice::GetSavedGameCount() const
{
    // Use a local CXBStorageDevice object so we don't affect the state of
    // the save game handle.
    CXBStorageDevice thisDevice( *this );
    XGAME_FIND_DATA SaveGameData;

    // Any saves?
    if( !thisDevice.FindFirstSaveGame( SaveGameData ) )
        return 0;

    // At least one; count up the rest
    DWORD dwCount = 1;
    while( thisDevice.FindNextSaveGame( SaveGameData ) )
        ++dwCount;

    return dwCount;
}




//-----------------------------------------------------------------------------
// Name: GetSectorSize()
// Desc: Returns the sector size of the device in bytes
//-----------------------------------------------------------------------------
DWORD CXBStorageDevice::GetSectorSize() const
{
    return XGetDiskSectorSize( m_strRootPath );
}




//-----------------------------------------------------------------------------
// Name: GetClusterSize()
// Desc: Returns the cluster size of the device in bytes
//-----------------------------------------------------------------------------
DWORD CXBStorageDevice::GetClusterSize() const
{
    return XGetDiskClusterSize( m_strRootPath );
}




//-----------------------------------------------------------------------------
// Name: GetOverhead()
// Desc: Number of bytes used on device by XCreateSaveGame. Includes the
//       size of the save game directory and text meta data.
//-----------------------------------------------------------------------------
DWORD CXBStorageDevice::GetSaveGameOverhead() const
{
    // XCreateSaveGame() uses two clusters, one for the saved game directory,
    // and one for the saved game text meta data file.

    return( GetClusterSize() * 2 );
}




//-----------------------------------------------------------------------------
// Name: GetFileBytes()
// Desc: The total number of bytes a file will consume on the device.
//       Automatically pads to the cluster size of the device.
//-----------------------------------------------------------------------------
DWORD CXBStorageDevice::GetFileBytes( DWORD dwBytes ) const
{
    DWORD dwClusterSize = GetClusterSize();

    // Determine clusters required for this file
    DWORD dwClusters = ( dwBytes + ( dwClusterSize-1 ) ) / dwClusterSize;

    // Return total bytes
    return( dwClusters * dwClusterSize );
}




//-----------------------------------------------------------------------------
// Name: FindFirstSaveGame()
// Desc: Returns information about the first save game on the device. Returns
//       FALSE if no saves on the device.
//-----------------------------------------------------------------------------
BOOL CXBStorageDevice::FindFirstSaveGame( XGAME_FIND_DATA& SaveGameData ) const
{
    Cleanup();
    if( *m_strRootPath == 0 )
        return FALSE;

    m_hSaveGame = XFindFirstSaveGame( m_strRootPath, &SaveGameData );
    return( m_hSaveGame != INVALID_HANDLE_VALUE );
}




//-----------------------------------------------------------------------------
// Name: FindNextSaveGame()
// Desc: Returns information about the next save game on the device. Returns
//       FALSE if no more saves on the device.
//-----------------------------------------------------------------------------
BOOL CXBStorageDevice::FindNextSaveGame( XGAME_FIND_DATA& SaveGameData ) const
{
    return XFindNextSaveGame( m_hSaveGame, &SaveGameData );
}




//-----------------------------------------------------------------------------
// Name: Cleanup()
// Desc: Tear down the storage device
//-----------------------------------------------------------------------------
VOID CXBStorageDevice::Cleanup() const
{
    if( m_hSaveGame != INVALID_HANDLE_VALUE )
    {
        XFindClose( m_hSaveGame );
        m_hSaveGame = INVALID_HANDLE_VALUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\src\XBStrip.cpp ===
//-----------------------------------------------------------------------------
// File: XBStrip.cpp
//
// Desc: Tristrip routines (which convert a mesh into a list of optimized
//       triangle strips).
//
// Hist: 02.01.01 - New for March XDK release
//       06.10.01 - Revised algorithm for better cache performance
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <stdio.h>
#include <stdarg.h>
#include <algorithm> // This is the STL header for the sort template

#include <assert.h>

#if defined(_XBOX)
#include <xtl.h>
#else
#include <limits.h>
#include <D3D8.h>
#endif

#include "XBStrip.h"




// Cache size to optimize for.  The actual cache size is 24, but it is in 
// general not good to use the oldest 6 entries.
#define CACHE_SIZE 18


// Estimated length of the vertex shader to use when comparing the cost of
// different stripifications.
#define SHADER_CYCLES 20




//-----------------------------------------------------------------------------
// structs
//-----------------------------------------------------------------------------
typedef WORD (*TRIANGLELIST)[3];


struct TRIANGLEINFO
{
    int neighbortri[3];     // Triangle sharing edge (i,i+1), or -1
    int neighboredge[3];    // Edge (j,j+1) of neighboring triangle.
};




//-----------------------------------------------------------------------------
// Name: struct CStrip
// Desc: A single triangle strip. After a mesh is stripified, it typically is 
//       composed of several of these.
//-----------------------------------------------------------------------------
struct CStrip
{
    BOOL  m_bIsStripCW;

    DWORD m_dwNumTriangles;
    int*  m_pTriangles;

    DWORD m_dwNumIndices;
    WORD* m_pIndices;

    DWORD m_dwNumNeighbors;

    CStrip( DWORD num_tris, DWORD num_indices ) 
    {
        m_dwNumTriangles = num_tris;
        m_pTriangles = new int[ num_tris ]; 

        m_dwNumIndices = num_indices;
        m_pIndices = new WORD[ num_indices ];
    }

    ~CStrip()
    {
        delete[] m_pTriangles;
        delete[] m_pIndices;
    }
};




//-----------------------------------------------------------------------------
// Name: struct CSubStrip
// Desc: A structure that specifies part of a strip in a striplist.
//-----------------------------------------------------------------------------
struct CSubStrip
{
    int m_iStrip;   // Index into striplist.
    int m_iStart;   // Starting triangle index
    int m_iEnd;     // Ending triangle index.
};




//-----------------------------------------------------------------------------
// Name: struct CStripList
// Desc: A list of triangle strips.
//-----------------------------------------------------------------------------
struct CStripList
{
    CStrip** m_pStrips;
    DWORD    m_dwNumStrips;

    CStrip** begin() { return (m_dwNumStrips) ? &m_pStrips[0] : NULL; }

    VOID RemoveStripFromList( CStrip** pStrip )
    {
        for( DWORD i=0; i<m_dwNumStrips; i++ )
        {
            if( &m_pStrips[i] == pStrip )
            {
                delete m_pStrips[i];
                m_dwNumStrips--;

                while( i < m_dwNumStrips )
                {
                    m_pStrips[i] = m_pStrips[i+1];
                    i++;
                }
                break;
            }
        }
    }
    
    VOID RemoveFirst()
    {
        RemoveStripFromList( &m_pStrips[0] );
    }

    VOID AddStripToList( CStrip* pStrip )
    {
        m_pStrips[m_dwNumStrips++] = pStrip;
    }

    CStripList(DWORD dwMaxSize)
    {
        m_pStrips     = new CStrip*[dwMaxSize];
        m_dwNumStrips = 0L;
    }

    ~CStripList()
    {
        for( DWORD i=0; i<m_dwNumStrips; i++ )
        {
            delete m_pStrips[i];
        }

        delete[] m_pStrips;
    }
};




//-----------------------------------------------------------------------------
// Class used to vertices for locality of access.
//-----------------------------------------------------------------------------
struct SortEntry
{
    int iFirstUsed;
    int iOrigIndex;

    // Define the < operator, which is needed for the STL sort() routine.
    BOOL operator<( const SortEntry& rhs ) { return iFirstUsed < rhs.iFirstUsed; }
};




//-----------------------------------------------------------------------------
// Name: 
// Desc: vertex cache class
//-----------------------------------------------------------------------------
class CVertCache
{
public:
    CVertCache()    { Reset(); }
    ~CVertCache()   {};

    // Reset cache
    void Reset()
    {
        m_iCachePtr = 0;
        m_cachehits = 0;
        memset( m_rgCache, 0xff, sizeof(m_rgCache) );
    }

    // Add vertindex to cache
    int Add(int strip, int vertindex);

    // Check if a vert is in the cache.
    BOOL IsCached(int vertindex)
    {
        for( int iCache = 0; iCache < CACHE_SIZE; iCache++ )
        {
            if( vertindex == m_rgCache[iCache] )
            {
                // Item is in the cache
                return TRUE;
            }
        }

        return FALSE;
    }

    // Check if a vert uses one of the last two cached verts.
    BOOL IsOld(int vertindex)
    {
        if( vertindex == m_rgCache[m_iCachePtr] )
        {
            // Item is in the cache
            return TRUE;
        }

        return FALSE;
    }

    int NumCacheHits() const
    {
        return m_cachehits;
    }

private:
    int  m_cachehits;                // current # of cache hits
    WORD m_rgCache[CACHE_SIZE];      // vertex cache
    int  m_rgCacheStrip[CACHE_SIZE]; // strip # which added or re-used vert
    int  m_iCachePtr;                // fifo ptr
    bool m_bReUsed[CACHE_SIZE];      // true if vert was re-used.
};




//-----------------------------------------------------------------------------
// Name: 
// Desc: main stripper class
//-----------------------------------------------------------------------------
class CStripper
{
public:
    int           m_dwNumTris;   // # tris
    TRIANGLELIST  m_pTriangles;  // trilist

    TRIANGLEINFO* m_pTriInfo;    // tri edge, neighbor info
    int*          m_pUsed;       // tri used flag

    // ctors/dtors
    CStripper( int dwNumtris, TRIANGLELIST pTriangles );
    ~CStripper();

    // initialize tri info
    VOID InitTriangleInfo( int tri, int vert );

    // get maximum length strip from tri/vert
    int CreateStrip( int tri, int vert, int maxlen, int *pswaps, 
                     BOOL bLookAhead, BOOL bNonSequential, BOOL bStartCW, 
                     int* pTris );

    // Turn a list of triangles into indices.
    int CreateIndices( BOOL bStartCW, int iNumTriangles, int* pTriangles, 
                       WORD* pStripVerts );

    // stripify entire mesh
    VOID BuildStrips( CStripList* pStripList, int maxlen, BOOL bLookAhead, 
                      BOOL bNonSequential, BOOL bSwapOrientation );

    // blast strip indices to ppstripindices
    int CreateManyStrips( CStripList *pstriplist, WORD **ppstripindices );
    int CreateLongStrip( CStripList *pstriplist, WORD **ppstripindices );
    int CreateCachedStrip( CStripList *pstriplist, WORD **ppstripindices );

    // find the best cached strip.
    CStrip** FindBestCachedStrip( CStripList* pStripList, const CVertCache &VertexCache );

    int GetNeighborCount( int tri )
    {
        int count = 0;
        for( int vert = 0; vert < 3; vert++ )
        {
            int neighbortri = m_pTriInfo[tri].neighbortri[vert];
            count += (neighbortri != -1) && !m_pUsed[neighbortri];
        }
        return count;
    }
};




//-----------------------------------------------------------------------------
// Name: CreateStrip()
// Desc: Get maximum length of strip starting at tri/vert
//-----------------------------------------------------------------------------
int CStripper::CreateStrip( int tri, int vert, int maxlen, int *pswaps,
                            BOOL bLookAhead, BOOL bNonSequential, 
                            BOOL bStartCW, int* pTris )
{
    *pswaps = 0;

    // this guy has already been used?
    if(m_pUsed[tri])
        return 0;

    // mark tri as used
    m_pUsed[tri] = 1;

    int swaps = 0;

    // add first tri
    int iNumTris = 0;
    pTris[iNumTris++] = tri;

    bStartCW = !bStartCW;

    // get next tri information
    int edge     = (bStartCW ? vert + 2 : vert + 1) % 3;
    int nexttri  = m_pTriInfo[tri].neighbortri[edge];
    int nextvert = m_pTriInfo[tri].neighboredge[edge];

    // start building the strip until we run out of room or indices
    for(int stripcount = 3; stripcount < maxlen; stripcount++)
    {
        // dead end?
        if(nexttri == -1 || m_pUsed[nexttri])
            break;

        // move to next tri
        tri  = nexttri;
        vert = nextvert;

        // toggle orientation
        bStartCW = !bStartCW;

        // find the next natural edge
        int edge = (bStartCW ? vert + 2 : vert + 1) % 3;
        nexttri  = m_pTriInfo[tri].neighbortri[edge];
        nextvert = m_pTriInfo[tri].neighboredge[edge];

        BOOL bSwap = FALSE;
        if(nexttri == -1 || m_pUsed[nexttri])
        {
            // if the next tri is a dead end - try swapping orientation
            bSwap = TRUE;
        }
        else if( bLookAhead )
        {
            // try a swap and see who our new neighbor would be
            int edgeswap     = (bStartCW ? vert + 1 : vert + 2) % 3;
            int nexttriswap  = m_pTriInfo[tri].neighbortri[edgeswap];
            int nextvertswap = m_pTriInfo[tri].neighboredge[edgeswap];

            if( nexttriswap != -1 && !m_pUsed[nexttriswap] )
            {
                // if the swap neighbor has a lower count, change directions
                if( GetNeighborCount(nexttriswap) < GetNeighborCount(nexttri) )
                {
                    bSwap = TRUE;
                }
                else if( GetNeighborCount(nexttriswap) == GetNeighborCount(nexttri) )
                {
                    // if they have the same number of neighbors - check their neighbors
                    edgeswap    = (bStartCW ? nextvertswap + 2 : nextvertswap + 1) % 3;
                    nexttriswap = m_pTriInfo[nexttriswap].neighbortri[edgeswap];

                    int edge1    = (bStartCW ? nextvert + 1 : nextvert + 2) % 3;
                    int nexttri1 = m_pTriInfo[nexttri].neighbortri[edge1];

                    if( nexttri1 == -1 || m_pUsed[nexttri1] )
                    {
                        // natural winding order leads us to a dead end so turn
                        bSwap = TRUE;
                    }
                    else if( nexttriswap != -1 && !m_pUsed[nexttriswap] )
                    {
                        // check neighbor counts on both directions and swap if it's better
                        if( GetNeighborCount(nexttriswap) < GetNeighborCount(nexttri1) )
                            bSwap = TRUE;
                    }
                }
            }
        }

        if( bSwap && bNonSequential )
        {
            // we've been told to change directions so make sure we actually can
            // and then add the swap vertex
            int edgeswap = (bStartCW ? vert + 1 : vert + 2) % 3;
            nexttri      = m_pTriInfo[tri].neighbortri[edgeswap];
            nextvert     = m_pTriInfo[tri].neighboredge[edgeswap];

            if( nexttri != -1 && !m_pUsed[nexttri] )
            {
                stripcount++;
                swaps++;
                bStartCW = !bStartCW;
            }
        }

        pTris[iNumTris++] = tri;

        // mark triangle as used
        m_pUsed[tri] = 1;
    }

    // clear the used flags
    for( int j = 0; j < iNumTris; j++ )
        m_pUsed[pTris[j]] = 0;

    // return swap count and striplen
    *pswaps = swaps;

    return iNumTris;
}




//-----------------------------------------------------------------------------
// Name: CStripper::CreateIndices()
// Desc: Make strip indices from triangle list.
//-----------------------------------------------------------------------------
int CStripper::CreateIndices( BOOL bStartCW, int iNumTriangles, int* pTriangles, WORD* pStripVerts )
{
    int stripcount = 0;
    BOOL bCW = bStartCW;
    int in_edge = -1;

    for( int i = 0; i < iNumTriangles; i++ )
    {
        int out_edge;

        int tri = pTriangles[i];

        // get next tri information
        if( i < iNumTriangles-1 )
        {
            int nexttri = pTriangles[i+1];

            for( out_edge = 0; out_edge < 3; out_edge++ )
                if( m_pTriInfo[tri].neighbortri[out_edge] == nexttri )
                    break;
        }
        else
        {
            out_edge = (bCW ? (in_edge + 1) : (in_edge + 2)) % 3;
        }

        if( i == 0 )
        {
            if( bCW )
            {
                pStripVerts[0] = m_pTriangles[tri][(out_edge + 2) % 3];
                pStripVerts[1] = m_pTriangles[tri][(out_edge + 0) % 3];
                pStripVerts[2] = m_pTriangles[tri][(out_edge + 1) % 3];
            }
            else
            {
                pStripVerts[0] = m_pTriangles[tri][(out_edge + 2) % 3];
                pStripVerts[1] = m_pTriangles[tri][(out_edge + 1) % 3];
                pStripVerts[2] = m_pTriangles[tri][(out_edge + 0) % 3];
            }

            stripcount = 3;
        }
        else
        {
            if( out_edge == (bCW ? (in_edge + 1) : (in_edge + 2)) % 3 )
            {
                // In order.
                pStripVerts[stripcount++] = m_pTriangles[tri][(in_edge + 2) % 3];
            }
            else
            {
                // Swap.
                if( bCW )
                {
                    pStripVerts[stripcount++] = m_pTriangles[tri][(in_edge + 0) % 3];
                    pStripVerts[stripcount++] = m_pTriangles[tri][(in_edge + 2) % 3];
                }
                else
                {
                    pStripVerts[stripcount++] = m_pTriangles[tri][(in_edge + 1) % 3];
                    pStripVerts[stripcount++] = m_pTriangles[tri][(in_edge + 2) % 3];
                }

                bCW = !bCW;
            }
        }

        in_edge = m_pTriInfo[tri].neighboredge[out_edge];
        bCW = !bCW;
    }

    return stripcount;
}




//-----------------------------------------------------------------------------
// Name: FindBestStrip()
// Desc: Given a striplist and current cache state, pick the best next strip
//-----------------------------------------------------------------------------
CStrip** FindBestStrip( CStripList* pStripList,
                              const CVertCache &VertexCache )
{
    if( 0 == pStripList->m_dwNumStrips ) 
        return NULL;

    CStrip** ppBestStrip       = pStripList->begin();
    DWORD    dwBestStripLen    = (*ppBestStrip)->m_dwNumIndices;
    BOOL     bStartCW          = (*ppBestStrip)->m_bIsStripCW;
    BOOL     bBestStripFlipped = FALSE;
    int      MaxCacheHits      = -1;

    // Go through all the other strips looking for the best caching
    for( DWORD i = 0; i < pStripList->m_dwNumStrips; i++ )
    {
        CStrip* pStrip        = pStripList->m_pStrips[i];
        DWORD   dwStripLen    = pStrip->m_dwNumIndices;
        BOOL    bStripFlipped = FALSE;

        // Check cache if this strip is the same type as us (ie: cw/odd)
        if( ( pStrip->m_bIsStripCW == bStartCW) && ( (dwBestStripLen & 0x1) == (dwStripLen & 0x1) ) )
        {
            // Copy current state of cache
            CVertCache NewVertexCache = VertexCache;

            // Figure out what this guy would do to our cache
            for( DWORD ivert = 0; ivert < dwStripLen; ivert++ )
                NewVertexCache.Add( 2, pStrip->m_pIndices[ivert] );

            // For even length strips - see if we can get better cache hits
            // if we reverse the vertex cache contents
            if( !(dwStripLen & 0x1) )
            {
                // Create a copy of the vertex cache, with all vertices flipped
                CVertCache FlippedVertexCache = VertexCache;
                for( int ivert = pStrip->m_dwNumIndices-1; ivert >= 0; ivert-- )
                    FlippedVertexCache.Add( 2, pStrip->m_pIndices[ivert] );

                // Accept the flipped cache if it gives us more cahce hits
                if( FlippedVertexCache.NumCacheHits() > NewVertexCache.NumCacheHits() )
                {
                    NewVertexCache = FlippedVertexCache;
                    bStripFlipped  = TRUE;
                }
            }

            // Record the best number of cache hits to date
            int NumCacheHits = NewVertexCache.NumCacheHits() - VertexCache.NumCacheHits();
            
            if( NumCacheHits > MaxCacheHits )
            {
                MaxCacheHits      = NumCacheHits;
                ppBestStrip       = &pStripList->m_pStrips[i];
                dwBestStripLen    = dwStripLen;//? added by mikey
                bBestStripFlipped = bStripFlipped;
            }
        }
    }

    if( bBestStripFlipped )
    {
        CStrip* pStrip = *ppBestStrip;
        int first = 0;
        int last  = pStrip->m_dwNumIndices - 1;

        while( first < last )
        {
            // Swap vertex indices
            WORD temp                 = pStrip->m_pIndices[first];
            pStrip->m_pIndices[first] = pStrip->m_pIndices[last];
            pStrip->m_pIndices[last]  = temp;
            first++;
            last--;
        }
    }

    // Make sure we keep the list in order and always pull off
    // the first dude.
    if( ppBestStrip != pStripList->begin() )
    {
        // Swap strips
        CStrip* temp           = (*ppBestStrip);
        (*ppBestStrip)         = (*pStripList->begin());
        (*pStripList->begin()) = temp;
    }

    return pStripList->begin();
}




//-----------------------------------------------------------------------------
// Name: CStripper::FindBestCachedStrip()
// Desc: Given a striplist and current cache state, pick the best next strip
//-----------------------------------------------------------------------------
CStrip** CStripper::FindBestCachedStrip( CStripList* pStripList,
                                         const CVertCache &VertexCache )
{
    if( 0 == pStripList->m_dwNumStrips ) 
        return NULL;

    CStrip** ppBestStrip       = pStripList->begin();

    BOOL     bBestStripFlipped = FALSE;

    int      MaxCacheHits      = -1;

    DWORD    dwBestNeighborCount = (*ppBestStrip)->m_dwNumNeighbors;

    // Go through all the other strips looking for the best caching
    for( DWORD i = 0; i < pStripList->m_dwNumStrips; i++ )
    {
        CStrip* pStrip        = pStripList->m_pStrips[i];
        DWORD   dwStripLen    = pStrip->m_dwNumIndices;
        BOOL    bStripFlipped = FALSE;

        // Copy current state of cache
        CVertCache NewVertexCache = VertexCache;

        // Figure out what this guy would do to our cache
        for( DWORD ivert = 0; ivert < dwStripLen; ivert++ )
            NewVertexCache.Add( 2, pStrip->m_pIndices[ivert] );

        // See if we can get better cache hits if we reverse the order we draw
        // the strip in.
        {
            // Create a copy of the vertex cache, with all vertices flipped
            CVertCache FlippedVertexCache = VertexCache;
            for( int ivert = pStrip->m_dwNumIndices-1; ivert >= 0; ivert-- )
                FlippedVertexCache.Add( 2, pStrip->m_pIndices[ivert] );

            // Accept the flipped cache if it gives us more cahce hits
            if( FlippedVertexCache.NumCacheHits() > NewVertexCache.NumCacheHits() )
            {
                NewVertexCache = FlippedVertexCache;
                bStripFlipped  = TRUE;
            }
        }

        // Record the best number of cache hits to date
        int NumCacheHits = NewVertexCache.NumCacheHits() - VertexCache.NumCacheHits();
        
        if( NumCacheHits > MaxCacheHits )
        {
            MaxCacheHits        = NumCacheHits;
            ppBestStrip         = &pStripList->m_pStrips[i];
            bBestStripFlipped   = bStripFlipped;
            dwBestNeighborCount = pStripList->m_pStrips[i]->m_dwNumNeighbors;
        }
        else if ( NumCacheHits == MaxCacheHits && 
                  pStripList->m_pStrips[i]->m_dwNumNeighbors < dwBestNeighborCount )
        {
            ppBestStrip         = &pStripList->m_pStrips[i];
            bBestStripFlipped   = bStripFlipped;
            dwBestNeighborCount = pStripList->m_pStrips[i]->m_dwNumNeighbors;
        }
    }

    if( bBestStripFlipped )
    {
        CStrip* pStrip = *ppBestStrip;
        int first = 0;
        int last  = pStrip->m_dwNumIndices - 1;

        while( first < last )
        {
            // Swap vertex indices
            WORD temp                 = pStrip->m_pIndices[first];
            pStrip->m_pIndices[first] = pStrip->m_pIndices[last];
            pStrip->m_pIndices[last]  = temp;
            first++;
            last--;
        }

        // We must also reverse the starting winding for odd length strips.
        if( (pStrip->m_dwNumIndices & 0x1) )
        {
            pStrip->m_bIsStripCW = !pStrip->m_bIsStripCW;
        }
    }

    // Make sure we keep the list in order and always pull off
    // the first dude.
    if( ppBestStrip != pStripList->begin() )
    {
        // Swap strips
        CStrip* temp           = (*ppBestStrip);
        (*ppBestStrip)         = (*pStripList->begin());
        (*pStripList->begin()) = temp;
    }

    return pStripList->begin();
}




//-----------------------------------------------------------------------------
// Name: CStripper::CreateManyStrips()
// Desc: Don't merge the strips - just blast em into the stripbuffer one by one
//       (useful for debugging)
//-----------------------------------------------------------------------------
int CStripper::CreateManyStrips( CStripList* pStripList, WORD** ppStripIndices )
{
    // Count the number of indices. Allow room for each of the strips size
    // plus the final 0
    DWORD dwIndexCount = pStripList->m_dwNumStrips + 1;

    // We're storing the strips in [size1 i1 i2 i3][size2 i4 i5 i6][0] format
    for( DWORD i = 0; i < pStripList->m_dwNumStrips; i++ )
    {
        // Add striplength plus potential degenerate to swap ccw --> cw
        dwIndexCount += pStripList->m_pStrips[i]->m_dwNumIndices + 1;
    }

    // Alloc the space for all this stuff
    WORD*      pStripIndices     = new WORD[dwIndexCount];
    DWORD      dwNumStripIndices = 0;
    CVertCache VertexCache;

    // Loop through all strips
    CStrip** ppStrip = pStripList->begin();

    while( pStripList->m_dwNumStrips > 0 )
    {
        CStrip* pStrip = *ppStrip;

        if( !pStrip->m_bIsStripCW )
        {
            // add an extra index if it's ccw
            pStripIndices[dwNumStripIndices++] = (WORD)pStrip->m_dwNumIndices + 1;
            pStripIndices[dwNumStripIndices++] = pStrip->m_pIndices[0];
        }
        else
        {
            // add the strip length
            pStripIndices[dwNumStripIndices++] = (WORD)pStrip->m_dwNumIndices;
        }

        // add all the strip indices
        for( DWORD i = 0; i < pStrip->m_dwNumIndices; i++)
        {
            pStripIndices[dwNumStripIndices++] = pStrip->m_pIndices[i];
            VertexCache.Add( 1, pStrip->m_pIndices[i] );
        }

        // free this guy and pop him off the list
        pStripList->RemoveFirst();

        // Get the next best strip
        ppStrip = FindBestStrip( pStripList, VertexCache );
    }

    // add terminating zero
    pStripIndices[dwNumStripIndices++] = 0;
    (*ppStripIndices) = pStripIndices;

    return dwNumStripIndices;
}




//-----------------------------------------------------------------------------
// Name: CStripper::CreateLongStrip()
// Desc: Merge striplist into one big uberlist with (hopefully) optimal caching
//-----------------------------------------------------------------------------
int CStripper::CreateLongStrip( CStripList* pStripList, WORD** ppwStripIndices )
{
    // Allow room for one strip length plus a possible 3 extra indices per
    // concatenated strip list plus the final 0
    int dwIndexCount = (pStripList->m_dwNumStrips * 3) + 2;

    // We're storing the strips in [size1 i1 i2 i3][size2 i4 i5 i6][0] format
    for( DWORD i=0; i < pStripList->m_dwNumStrips; i ++ )
    {
        dwIndexCount += pStripList->m_pStrips[i]->m_dwNumIndices;
    }

    // Alloc the space for all this stuff
    WORD*      pStripIndices     = new WORD[dwIndexCount];
    int        dwNumStripIndices = 0;
    CVertCache VertexCache;

    // Add first strip
    CStrip** ppStrip = pStripList->begin();
    CStrip*  pStrip = *ppStrip;

    // Note: first strip should be cw

    for( DWORD ivert = 0; ivert < pStrip->m_dwNumIndices; ivert++ )
    {
        pStripIndices[dwNumStripIndices++] = pStrip->m_pIndices[ivert];
        VertexCache.Add( 1, pStrip->m_pIndices[ivert] );
    }

    // Kill first dude
    pStripList->RemoveStripFromList( ppStrip );

    // Add all the others
    while( pStripList->m_dwNumStrips )
    {
        ppStrip = FindBestStrip( pStripList, VertexCache );
        CStrip* pStrip = *ppStrip;
        WORD wLastVertex  = pStripIndices[dwNumStripIndices - 1];
        WORD wFirstVertex = pStrip->m_pIndices[0];

        if( wFirstVertex != wLastVertex )
        {
            // Add degenerate from last strip
            pStripIndices[dwNumStripIndices++] = wLastVertex;

            // Add degenerate from our strip
            pStripIndices[dwNumStripIndices++] = wFirstVertex;
        }

        // If we're not orientated correctly, we need to add a degenerate
        if( pStrip->m_bIsStripCW != !(dwNumStripIndices & 0x1) )
        {
            // This shouldn't happen - we're currently trying very hard
            // to keep everything oriented correctly.
            pStripIndices[dwNumStripIndices++] = wFirstVertex;
        }

        // Add these verts
        for( DWORD ivert = 0; ivert < pStrip->m_dwNumIndices; ivert++ )
        {
            pStripIndices[dwNumStripIndices++] = pStrip->m_pIndices[ivert];
            VertexCache.Add( 1, pStrip->m_pIndices[ivert] );
        }

        // Free these guys
        pStripList->RemoveStripFromList( ppStrip );
    }

    (*ppwStripIndices) = pStripIndices;
    return dwNumStripIndices;
}




//-----------------------------------------------------------------------------
// Name: CStripper::CreateCachedStrip()
// Desc: Merge striplist into one big uberlist with (hopefully) optimal caching
//-----------------------------------------------------------------------------
int CStripper::CreateCachedStrip( CStripList* pStripList, WORD** ppwStripIndices )
{
    DWORD i;
    WORD pTempVerts[CACHE_SIZE*4];

    // Split up the strips into cache friendly pieces.
    CStripList* pNewList = new CStripList(m_dwNumTris);

    while( pStripList->m_dwNumStrips )
    {
        CStrip** ppStrip = pStripList->begin();
        CStrip* pStrip = *ppStrip;

        int start = 0;
        int ssize = pStrip->m_dwNumTriangles;

        do
        {
            int dsize = ssize;

            if (dsize > CACHE_SIZE)
                dsize = CACHE_SIZE;

            int j = pNewList->m_dwNumStrips++;

            // Create temp triaingle list/index list.
            int num_indices = CreateIndices( pStrip->m_bIsStripCW, dsize, 
                                             pStrip->m_pTriangles + start, 
                                             pTempVerts );
    
            // Make new strip.
            pNewList->m_pStrips[j] = new CStrip( dsize, num_indices );

            pNewList->m_pStrips[j]->m_bIsStripCW = pStrip->m_bIsStripCW;

            // Copy triangles.
            memcpy( pNewList->m_pStrips[j]->m_pTriangles, 
                    pStrip->m_pTriangles + start, dsize * sizeof(int) );

            // Copy indices.
            memcpy( pNewList->m_pStrips[j]->m_pIndices, 
                    pTempVerts, num_indices * sizeof(WORD) );

            start += dsize;
            ssize -= dsize;
        }
        while (ssize > 0);

        pStripList->RemoveStripFromList( ppStrip );
    }

    // Count the number of adjacent triangles to each strip.
    // an edge of the mesh.
    for( i = 0; i < pNewList->m_dwNumStrips; i++ )
    {
        CStrip* pStrip = pNewList->m_pStrips[i];

        DWORD count = 0;

        for( DWORD j = 0; j < pStrip->m_dwNumTriangles; j++ )
        {
            // Count the number of neighbors.
            for( int vert = 0; vert < 3; vert++ )
            {
                if (m_pTriInfo[pStrip->m_pTriangles[j]].neighbortri[vert] != -1)
                    count++;
            }
        }

        pStrip->m_dwNumNeighbors = count;
    }

    // Should we remove/ignore very small strips?

    // Allow room for one strip length plus a possible 3 extra indices per
    // concatenated strip list plus the final 0
    int dwIndexCount = (pNewList->m_dwNumStrips * 3) + 2;

    // We're storing the strips in [size1 i1 i2 i3][size2 i4 i5 i6][0] format
    for( i = 0; i < pNewList->m_dwNumStrips; i++ )
    {
        dwIndexCount += pNewList->m_pStrips[i]->m_dwNumIndices;
    }

    // Alloc the space for all this stuff
    WORD*      pStripIndices     = new WORD[dwIndexCount];
    DWORD      dwNumStripIndices = 0;
    CVertCache VertexCache;

    // Add the strips.
    while( pNewList->m_dwNumStrips )
    {
        CStrip** ppStrip = FindBestCachedStrip( pNewList, VertexCache );
        CStrip* pStrip = *ppStrip;

        WORD wFirstVertex = pStrip->m_pIndices[0];

        DWORD ivert = 0;

        if (dwNumStripIndices > 0)
        {
            WORD wLastVertex = pStripIndices[dwNumStripIndices - 1];
        
            assert( dwNumStripIndices > 2 );

            if( wLastVertex == pStrip->m_pIndices[1] &&
                pStripIndices[dwNumStripIndices - 2] == wFirstVertex &&
                pStrip->m_bIsStripCW == !(dwNumStripIndices & 0x1) )
            {
                // We are re-stitching strips together, so skip the first two
                // verts of this strip.
                ivert = 2;
            }
            else if( wFirstVertex != wLastVertex )
            {
                // Add degenerate from last strip
                pStripIndices[dwNumStripIndices++] = wLastVertex;

                // Add degenerate from our strip
                pStripIndices[dwNumStripIndices++] = wFirstVertex;
            }
        }

        // If we're not orientated correctly, we need to add a degenerate
        if( pStrip->m_bIsStripCW != !(dwNumStripIndices & 0x1) )
        {
            pStripIndices[dwNumStripIndices++] = wFirstVertex;
        }

        // Add these verts and update cache.
        while( ivert < pStrip->m_dwNumIndices )
        {
            pStripIndices[dwNumStripIndices] = pStrip->m_pIndices[ivert];
            VertexCache.Add( 1, pStrip->m_pIndices[ivert] );
            dwNumStripIndices++;
            ivert++;
        }

        // Free these guys
        pNewList->RemoveStripFromList( ppStrip );
    }

    (*ppwStripIndices) = pStripIndices;
    return dwNumStripIndices;
}




//-----------------------------------------------------------------------------
// Name: CStripper::BuildStrips()
// Desc: Build a (hopefully) optimal set of strips from a trilist
//-----------------------------------------------------------------------------
void CStripper::BuildStrips( CStripList* pStripList, int maxlen, BOOL bLookAhead, 
                             BOOL bNonSequential, BOOL bSwapOrientation )
{
    // temp indices storage
    const int cNumTmpVerts = 1024;
    WORD pStripVerts[cNumTmpVerts + 1];
    int pStripTris[cNumTmpVerts + 1];

    // clear all the used flags for the tris
    ZeroMemory( m_pUsed, m_dwNumTris * sizeof(m_pUsed[0]) );

    BOOL bStartCW = TRUE;

    while( TRUE )
    {
        int   besttri;
        int   bestvert;
        float bestratio = 2.0f;
        int   bestneighborcount = INT_MAX;

        for( int tri = 0; tri < m_dwNumTris; tri++)
        {
            // if used the continue
            if(m_pUsed[tri])
                continue;

            // get the neighbor count
            int curneighborcount = GetNeighborCount(tri);

            // push all the singletons to the very end
            if( !curneighborcount )
                curneighborcount = 4;

            // if this guy has more neighbors than the current best - bail
            if( curneighborcount > bestneighborcount )
                continue;

            // try starting the strip with each of this tris verts
            for( int vert = 0; vert < 3; vert++ )
            {
                int swaps;
                int num_tris = CreateStrip( tri, vert, maxlen, &swaps, bLookAhead, 
                                            bNonSequential, bStartCW, pStripTris );

                int len = 2 + num_tris + swaps;
                float ratio = (len == 3) ? 1.0f : (float)swaps / len;

                // check if this ratio is better than what we've already got for
                // this neighborcount
                if( (curneighborcount < bestneighborcount) ||
                    (curneighborcount == bestneighborcount && ratio < bestratio) )
                {
                    bestneighborcount = curneighborcount;
                    besttri = tri;
                    bestvert = vert;
                    bestratio = ratio;
                }

            }
        }

        // no strips found?
        if( bestneighborcount == INT_MAX )
            break;

        // recreate this strip
        int swaps;
        int num_tris = CreateStrip( besttri, bestvert, maxlen, &swaps, bLookAhead, 
                                    bNonSequential, bStartCW, pStripTris );

        // Mark the tris on the best strip as used
        for( tri = 0; tri < num_tris; tri++ )
            m_pUsed[pStripTris[tri]] = 1;

        // Make the indices from the triangle verts.
        int num_indices = CreateIndices( bStartCW, num_tris, pStripTris, pStripVerts );

        // Create a new CStrip and stuff in the list.
        CStrip* pStrip = new CStrip( num_tris, num_indices );

        pStrip->m_bIsStripCW = bStartCW;

        for( int j = 0; j < num_tris; j++ )
            pStrip->m_pTriangles[j] = pStripTris[j];

        for( int k = 0; k < num_indices; k++ )
            pStrip->m_pIndices[k] = pStripVerts[k];

        // Store the CStrip
        pStripList->AddStripToList( pStrip );

        if( bSwapOrientation )
        {
            // if strip was odd - swap orientation
            if( (num_indices & 0x1) )
              bStartCW = !bStartCW;
        }
    }
}




//-----------------------------------------------------------------------------
// Name: CStripper::InitTriangleInfo()
// Desc: Initialize triangle information (edges, #neighbors, etc.)
//-----------------------------------------------------------------------------
void CStripper::InitTriangleInfo(int tri, int vert)
{
    WORD* ptriverts = &m_pTriangles[tri + 1][0];
    int   vert1     =  m_pTriangles[tri][(vert + 1) % 3];
    int   vert2     =  m_pTriangles[tri][vert];

    for( int itri = tri + 1; itri < m_dwNumTris; itri++, ptriverts += 3 )
    {
        if( m_pUsed[itri] != 0x7 )
        {
            for( int ivert = 0; ivert < 3; ivert++ )
            {
                if( ( ptriverts[ivert] == vert1) &&
                    ( ptriverts[(ivert + 1) % 3] == vert2 ) )
                {
                    // add the triangle info
                    m_pTriInfo[tri].neighbortri[vert]  = itri;
                    m_pTriInfo[tri].neighboredge[vert] = ivert;
                    m_pUsed[tri] |= (1 << vert);

                    m_pTriInfo[itri].neighbortri[ivert]  = tri;
                    m_pTriInfo[itri].neighboredge[ivert] = vert;
                    m_pUsed[itri] |= (1 << ivert);
                    return;
                }
            }
        }
    }
}




//-----------------------------------------------------------------------------
// Name: CStripper()
// Desc: CStripper ctor
//-----------------------------------------------------------------------------
CStripper::CStripper( int dwNumTris, TRIANGLELIST pTriangles )
{
    // store trilist info
    m_dwNumTris  = dwNumTris;
    m_pTriangles = pTriangles;
    m_pUsed      = new int[dwNumTris];
    m_pTriInfo   = new TRIANGLEINFO[dwNumTris];

    // init triinfo
    for( int itri = 0; itri < dwNumTris; itri++ )
    {
        m_pTriInfo[itri].neighbortri[0] = -1;
        m_pTriInfo[itri].neighbortri[1] = -1;
        m_pTriInfo[itri].neighbortri[2] = -1;
    }

    // Clear the used flag
    ZeroMemory( m_pUsed, m_dwNumTris * sizeof(m_pUsed[0]) );

    // Go through all the triangles and find edges, neighbor counts
    for( itri = 0; itri < dwNumTris; itri++ )
    {
        for( int ivert = 0; ivert < 3; ivert++ )
        {
            if( !(m_pUsed[itri] & (1 << ivert)) )
                InitTriangleInfo( itri, ivert );
        }
    }

    // Clear the used flags from InitTriangleInfo
    ZeroMemory( m_pUsed, m_dwNumTris * sizeof(m_pUsed[0]) );
}




//-----------------------------------------------------------------------------
// Name: ~CStripper
// Desc: CStripper dtor
//-----------------------------------------------------------------------------
CStripper::~CStripper()
{
    // free stuff
    delete[] m_pUsed;
    m_pUsed = NULL;

    delete[] m_pTriInfo;
    m_pTriInfo = NULL;
}




//-----------------------------------------------------------------------------
// Name: CVertCache::Add()
// Desc: Add an index to the cache - returns true if it was added, false otherwise
//-----------------------------------------------------------------------------
int CVertCache::Add( int strip, int vertindex )
{
    // Find index in cache
    for( int iCache = 0; iCache < CACHE_SIZE; iCache++ )
    {
        if( vertindex == m_rgCache[iCache] )
        {
            // If it's in the cache and it's from a different strip
            // change the strip to the new one and count the cache hit
            if( strip != m_rgCacheStrip[iCache] )
            {
                m_cachehits++;
                m_rgCacheStrip[iCache] = strip;
                m_bReUsed[iCache] = true;
            }

            // Item is already in the cache, so no need to add it
            return 0;
        }
    }

    int retval = 1;

    // If we are push one of the verts add by our strip out of the cache, return two.
    if ( m_rgCache[m_iCachePtr] != -1 && m_rgCacheStrip[m_iCachePtr] == strip && 
         !m_bReUsed[m_iCachePtr] )
        retval = 2;

    // Not in cache, add vert and strip
    m_rgCache[m_iCachePtr]      = (WORD)vertindex;
    m_rgCacheStrip[m_iCachePtr] = strip;
    m_bReUsed[m_iCachePtr]      = false;
    m_iCachePtr                 = (m_iCachePtr + 1) % CACHE_SIZE;
    
    return retval;
}




//-----------------------------------------------------------------------------
// Name: CountCacheMisses()
// Desc: Count the number of cache misses for a given strip.
//-----------------------------------------------------------------------------
DWORD CountCacheMisses( DWORD dwIndexCount, WORD *pStripIndices )
{
    CVertCache VertexCache;

    DWORD dwMisses = 0;

    for ( DWORD i = 0; i < dwIndexCount; i++ )
        dwMisses += (VertexCache.Add( 1, pStripIndices[i] ) != 0);

    return dwMisses;
}




//-----------------------------------------------------------------------------
// Name: TriStripToTriList()
// Desc: Convert a tri-strip to a tri-list.
//-----------------------------------------------------------------------------
DWORD TriStripToTriList( DWORD dwNumStripIndices, const WORD *pStripIndices, 
                         WORD *pTriangleIndices )
{
    DWORD dwNumTriangleIndices = 0;
        
    // Unstrip the indices.
    WORD ind0 = 0;
    WORD ind1 = pStripIndices[0];
    WORD ind2 = pStripIndices[1];

    for( DWORD src = 2; src < dwNumStripIndices; src++ )
    {
        ind0 = ind1;
        ind1 = ind2;
        ind2 = pStripIndices[src];
    
        // Check for null-triangles.    
        if( ind0 != ind1 && ind1 != ind2 && ind2 != ind0 )
        {
            if( src & 1 )
            {
                pTriangleIndices[dwNumTriangleIndices] = ind1;
                dwNumTriangleIndices++;

                pTriangleIndices[dwNumTriangleIndices] = ind0;
                dwNumTriangleIndices++;

                // always put the new index last
                pTriangleIndices[dwNumTriangleIndices] = ind2;
                dwNumTriangleIndices++;
            }
            else
            {
                pTriangleIndices[dwNumTriangleIndices] = ind0;
                dwNumTriangleIndices++;

                pTriangleIndices[dwNumTriangleIndices] = ind1;
                dwNumTriangleIndices++;

                // always put the new index last
                pTriangleIndices[dwNumTriangleIndices] = ind2;
                dwNumTriangleIndices++;
            }
        }
    }

    return dwNumTriangleIndices;
}




//-----------------------------------------------------------------------------
// Name: Stripify()
// Desc: Stripify routine
//-----------------------------------------------------------------------------
DWORD Stripify( DWORD dwNumTriangles, WORD* pTriangles, 
                DWORD* pdwNumIndices, WORD** ppStripIndices, DWORD dwFlags )
{
    if( 0 == dwNumTriangles || NULL == pTriangles )
        return 0;

    *ppStripIndices = 0;

    // The stipper, and storage for it's best results
    CStripper   stripper( dwNumTriangles, (TRIANGLELIST)pTriangles );

    DWORD       dwBestCost = 0xffffffff;
    DWORD       dwBestIndexCount;
    WORD*       pTempStripIndices;

    // Map of various args to try stripifying mesh with
    struct ARGMAP
    {
        DWORD   dwMaxLength;    // Maximum length of strips
        BOOL    bLookAhead;     // Whether to use sgi greedy lookahead
        BOOL    bNonSequential; // Take non-sequential exits to lengthen strips.
    };
    
    ARGMAP argmap[] =
    {
        { 1024,  TRUE, TRUE  },
        { 1024,  FALSE, TRUE },
        { 1024,  FALSE, FALSE },
    };
    const int dwNumArgMaps = sizeof(argmap)/sizeof(ARGMAP);

    // Build strips with the various maxlength and lookahead arguments, and
    // pick the one with the least result index count.
    for( int map = 0; map < dwNumArgMaps; map++ )
    {
        // Build the strip with the various maxlength and lookahead arguments
        CStripList* pStripList = new CStripList(dwNumTriangles);

        stripper.BuildStrips( pStripList, argmap[map].dwMaxLength, 
                              argmap[map].bLookAhead, argmap[map].bNonSequential,
                              (dwFlags & OPTIMIZE_FOR_INDICES) != 0 );

        DWORD dwIndexCount;
        DWORD dwCost;

        // Build strip (freeing the strip list).
        if( dwFlags & OPTIMIZE_FOR_INDICES )
        {
            dwIndexCount = stripper.CreateLongStrip( pStripList, &pTempStripIndices );

            // Cost is just the number of indices.
            dwCost = dwIndexCount;
        }
        else
        {
            dwIndexCount = stripper.CreateCachedStrip( pStripList, &pTempStripIndices );

            // Count number of cache misses.
            DWORD dwMisses = CountCacheMisses( dwIndexCount, pTempStripIndices );

            if( dwFlags & OUTPUT_TRILIST )
            {
                // Nulls don't matter for tri-lists.
                dwCost = dwMisses;
            }
            else
            {
                // Cost is the (shader length) / 2 + (# null tris) * 2
                dwCost = dwMisses * (SHADER_CYCLES/2) + 
                         (dwIndexCount - (dwNumTriangles + 2)) * 2;
            }
        }

        if ( dwCost < dwBestCost )
        {
            // Free the old best list
            if( *ppStripIndices )
                delete[] *ppStripIndices;

            // store the new best list
            *ppStripIndices  = pTempStripIndices;
            dwBestCost       = dwCost;
            dwBestIndexCount = dwIndexCount;
        }
        else
        {
            delete[] pTempStripIndices;
        }
    }

    if( dwFlags & OUTPUT_TRILIST )
    {
        // Convert to triangle list.
        WORD* pTempIndices = new WORD[dwNumTriangles*3];

        dwBestIndexCount = TriStripToTriList( dwBestIndexCount, *ppStripIndices, 
                                              pTempIndices );

        assert( dwBestIndexCount <= dwNumTriangles*3 );

        delete[] *ppStripIndices;
        *ppStripIndices = pTempIndices;
    }

    if( pdwNumIndices )
        (*pdwNumIndices) = dwBestIndexCount;
    
    return dwBestIndexCount;
}




//-----------------------------------------------------------------------------
// Name: ComputeVertexPermutation()
// Desc: Reorder the vertices
//-----------------------------------------------------------------------------
VOID ComputeVertexPermutation( DWORD dwNumStripIndices, WORD* pStripIndices,
                               DWORD dwNumVertices, WORD** ppVertexPermutation )
{
    // Sort verts to maximize locality.
    SortEntry* pSortTable = new SortEntry[dwNumVertices];

    // Fill in original index.
    for( DWORD i = 0; i < dwNumVertices; i++ )
    {
        pSortTable[i].iOrigIndex = i;
        pSortTable[i].iFirstUsed = -1;
    }

    // Fill in first used flag.
    for( i = 0; i < dwNumStripIndices; i++ )
    {
        int index = pStripIndices[i];

        if( pSortTable[index].iFirstUsed == -1 )
            pSortTable[index].iFirstUsed = i;
    }

    // Sort the table, using the STL sort() routine.
    std::sort( pSortTable, pSortTable + dwNumVertices );

    // Copy re-mapped to orignal vertex permutaion into output array.
    (*ppVertexPermutation) = new WORD[dwNumVertices];

    for( i = 0; i < dwNumVertices; i++ )
    {
        (*ppVertexPermutation)[i] = (WORD)pSortTable[i].iOrigIndex;
    }

    // Build original to re-mapped permutation.
    WORD* pInversePermutation = new WORD[dwNumVertices];

    for( i = 0; i < dwNumVertices; i++ )
    {
        pInversePermutation[pSortTable[i].iOrigIndex] = (WORD)i;
    }

    // We need to remap indices as well.
    for( i = 0; i < dwNumStripIndices; i++ )
    {
        pStripIndices[i] = pInversePermutation[ pStripIndices[i] ];
    }

    delete[] pSortTable;
    delete[] pInversePermutation;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\src\xdppeer.cpp ===
//-----------------------------------------------------------------------------
// File: xdppeer.cpp
//
// Desc: DirectPlay peer routines
//
// Copyright (c) 1998-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

// TODO : do 'connect' timeout

#include <assert.h>
#include "xdppeer.h"

LPDIRECTPLAY8PEER g_pDP;						// DirectPlay peer object
LPDIRECTPLAY8ADDRESS g_pDeviceAddress;			// device address of SP
LPDIRECTPLAY8ADDRESS g_pHostAddress;			// host address of SP

HRESULT (WINAPI *g_AppDPMsgHandler)(void *, DWORD, void *); // apps message handler
HRESULT WINAPI XDPMsgHandler(void *, DWORD, void *);

DPNHANDLE g_hAsyncOp;

DWORD g_dwConnectStatus;						// connection status
WCHAR g_wszXDPPlayerName[32];					// players name
WCHAR g_wszXDPSessionName[32];					// session name

// active game list stuff
ActiveGame *ActiveGames[MAX_ACTIVEGAMES];
DWORD g_dwNumActiveGames;
void XDPDeleteGames();

// DPNID stuff
DPNID g_dpnidLocalPlayer;
DPNID g_dpnidHost;

DWORD g_dwNumPlayers;

//-----------------------------------------------------------------------------
// Name: DPInit
// Desc: Initialize DirectPlay and other relevant stuff.
//-----------------------------------------------------------------------------
HRESULT XDPInit(HRESULT (WINAPI *DPMsgHandler)(void *, DWORD, void *))
{
    HRESULT hr;
	int err;

    OutputDebugStringA("xdppeer: initializing\n");

	// Save message handler pointer
	g_AppDPMsgHandler = DPMsgHandler;

	// initialize Xnet
	err = XNetStartup(NULL);
	assert(err==NO_ERROR);

	// initialize DPlay
	hr = DPlayInitialize(200000);
	assert(SUCCEEDED(hr));

	// create DPlay Peer object & get DVoice interface
    hr = DirectPlay8Create(IID_IDirectPlay8Peer, (void **) &g_pDP, NULL);
	assert(SUCCEEDED(hr));

    // Init IDirectPlay8Peer
    hr = g_pDP->Initialize(NULL, XDPMsgHandler, 0);
	assert(SUCCEEDED(hr));

	// create device address
    hr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (void **) &g_pDeviceAddress, NULL);
	assert(SUCCEEDED(hr));

	// create host address
    hr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (void **) &g_pHostAddress, NULL);
	assert(SUCCEEDED(hr));

	// clear connect state
	g_dwConnectStatus = GAME_NOTCONNECTED;

	// clear active games list
	ZeroMemory(ActiveGames, MAX_ACTIVEGAMES*sizeof(DPN_APPLICATION_DESC *));
	g_dwNumActiveGames = 0;

	// clear # of players
	g_dwNumPlayers = 0;

	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: XDPShutdown
// Desc: Close existing connection, do cleanup, release DPlay object,
//       and shut down COM.
//-----------------------------------------------------------------------------
void XDPShutdown()
{
	// close the connection
	// this blocks until all callbacks are completed
	g_pDP->Close(0);

	// release the address objects we are using
    if(g_pDeviceAddress)
		g_pDeviceAddress->Release();
    if(g_pHostAddress)
		g_pHostAddress->Release();

	// release our dplay object
	g_pDP->Release();

	// shut down DPlay
	DPlayCleanup();

	// clean up Xnet
    XNetCleanup();
}

//-----------------------------------------------------------------------------
// Name: XDPDoWork
// Desc: Does DPlay work.
//-----------------------------------------------------------------------------
HRESULT XDPDoWork(DWORD msec)
{
	DWORD time;
	static DWORD dwExpireTime = 0;
	HRESULT hr;

	// get current time in msec
	time = GetTickCount();

	// expire games if we are enumerating
	if(g_dwConnectStatus==GAME_ENUMERATING)
	{
		if(time>dwExpireTime)
		{
			dwExpireTime += 2000;	// 2 sec
			XDPExpireGames();
		}
	}

	// call the dplay DoWork function until work is done
	// or we have used up all available time
	if(msec==0)
	{
		do
			hr = g_pDP->DoWork(0);
		while(hr!=S_FALSE);
	}
	else
	{
		do
			hr = g_pDP->DoWork(0);
		while(hr!=S_FALSE && ((GetTickCount()-time)<msec));
	}

	// check for disconnect
	if(g_dwConnectStatus==GAME_DISCONNECTING)
		return XDPDisconnect();

	return hr;
}

//-----------------------------------------------------------------------------
// Name: XDPMsgHandler
// Desc: Handles some DPlay messages
//-----------------------------------------------------------------------------
HRESULT WINAPI XDPMsgHandler(PVOID pvUserContext, DWORD dwMsgType, PVOID pMsg)
{
	PDPNMSG_HOST_MIGRATE pHostMigrateMsg;

	switch(dwMsgType)
	{
        case DPN_MSGID_CONNECT_COMPLETE:
			g_dwConnectStatus = GAME_CONNECTED;
			break;

        case DPN_MSGID_TERMINATE_SESSION:
			g_dwConnectStatus = GAME_DISCONNECTING;
			break;

        case DPN_MSGID_HOST_MIGRATE:
            pHostMigrateMsg = (DPNMSG_HOST_MIGRATE *)pMsg;
			g_dpnidHost = pHostMigrateMsg->dpnidNewHost;
            if(g_dpnidHost==g_dpnidLocalPlayer)
				g_dwConnectStatus = GAME_HOSTING;
			break;
	}

	// call app DP message handler
	return g_AppDPMsgHandler(pvUserContext, dwMsgType, pMsg);
}

//-----------------------------------------------------------------------------
// Name: XDPEnumHosts
// Desc: Searches for all active games on the network
//-----------------------------------------------------------------------------
HRESULT XDPEnumHosts(DWORD port, GUID *pGuid)
{
    HRESULT hr;
	DWORD dwPort = port;

	// Delete active games
	XDPDeleteGames();

    // Enumerate hosts
    DPN_APPLICATION_DESC dnAppDesc;
    ZeroMemory(&dnAppDesc, sizeof(DPN_APPLICATION_DESC));
    dnAppDesc.dwSize = sizeof(DPN_APPLICATION_DESC);
    dnAppDesc.guidApplication = *pGuid;

	// set port
	hr = g_pHostAddress->AddComponent(DPNA_KEY_PORT, (void *)&dwPort, sizeof(dwPort), DPNA_DATATYPE_DWORD);
	assert(SUCCEEDED(hr));

    // Enumerate all the active DirectPlay games on the selected connection
    hr = g_pDP->EnumHosts(&dnAppDesc,                  // application description
                          g_pHostAddress,              // host address
                          g_pDeviceAddress,            // device address
                          NULL,                        // pointer to user data
                          0,                           // user data size
                          INFINITE,                    // retry count (forever)
                          0,                           // retry interval (0=default)
                          INFINITE,                    // time out (forever)
                          NULL,                        // user context
                          &g_hAsyncOp,		           // async handle
                          0							   // flags
                          );

	assert(SUCCEEDED(hr));

	g_dwConnectStatus = GAME_ENUMERATING;

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: XDPCancelEnumHosts
// Desc: Stops searching for active games on the network.
//-----------------------------------------------------------------------------
void XDPCancelEnumHosts()
{
	g_pDP->CancelAsyncOperation(g_hAsyncOp, 0);				// stop the game search operation
	g_dwConnectStatus = GAME_NOTCONNECTED;
}

//-----------------------------------------------------------------------------
// Name: XDPAddGame
// Desc: Add an active game to the game list
//-----------------------------------------------------------------------------
ActiveGame *XDPAddGame(DPNMSG_ENUM_HOSTS_RESPONSE *pHost)
{
	DWORD i;
	const DPN_APPLICATION_DESC *pApp;
	HRESULT hr;
	ActiveGame *pGame;

	pApp = pHost->pApplicationDescription;

	// See if game already in list
	pGame = NULL;
	for(i=0; i<g_dwNumActiveGames; i++)
		if(ActiveGames[i])
			if(ActiveGames[i]->AppDesc.guidInstance==pApp->guidInstance)
			{
				pGame = ActiveGames[i];
				break;
			}

	// if game not already in list, add a new one
	if(!pGame)
	{
		ActiveGames[g_dwNumActiveGames] = new ActiveGame;
		pGame = ActiveGames[g_dwNumActiveGames];

		// set address information
		hr = pHost->pAddressSender->Duplicate(&pGame->pHostAddr);
		assert(SUCCEEDED(hr));
		hr = pHost->pAddressDevice->Duplicate(&pGame->pDevAddr);
		assert(SUCCEEDED(hr));

		// bump active game count
		g_dwNumActiveGames++;
	}

	// update game information
	memcpy(&pGame->AppDesc, pApp, sizeof(DPN_APPLICATION_DESC));
	pGame->dwPing = pHost->dwRoundTripLatencyMS;

	// set report time
	pGame->dwReportTime = GetTickCount();

	return pGame;
}

//-----------------------------------------------------------------------------
// Name: XDPDeleteGames
// Desc: Deletes active games list.
//-----------------------------------------------------------------------------
void XDPDeleteGames()
{
	DWORD i;

	for(i=0; i<g_dwNumActiveGames; i++)
		if(ActiveGames[i])
		{
			ActiveGames[i]->pHostAddr->Release();		// release address objects
			ActiveGames[i]->pDevAddr->Release();

			delete ActiveGames[i];						// free up the memory
			ActiveGames[i] = NULL;
		}

	g_dwNumActiveGames = 0;
}

//-----------------------------------------------------------------------------
// Name: XDPCreate
// Desc: Creates a multiplayer game with us as a host.
//-----------------------------------------------------------------------------
HRESULT XDPCreate(DWORD port, GUID *pGuid, DWORD dwMaxPlayers, DWORD flags)
{
	HRESULT hr;
    DPN_PLAYER_INFO dpPlayerInfo;
    DPN_APPLICATION_DESC dnAppDesc;
	DWORD dwPort = port;
    DPNHANDLE hAsync;

    OutputDebugStringA("xdppeer: hosting\n");

	// set up player info for ourself as we create the game
    ZeroMemory(&dpPlayerInfo, sizeof(DPN_PLAYER_INFO));
    dpPlayerInfo.dwSize = sizeof(DPN_PLAYER_INFO);
    dpPlayerInfo.dwInfoFlags = DPNINFO_NAME;
    dpPlayerInfo.pwszName = g_wszXDPPlayerName;

	// set peer info. this is sent to all other machines via
	// the CREATE_PLAYER message
    hr = g_pDP->SetPeerInfo(&dpPlayerInfo, NULL, &hAsync, 0);
	assert(SUCCEEDED(hr));

    // Setup the application description
    ZeroMemory(&dnAppDesc, sizeof(DPN_APPLICATION_DESC));
    dnAppDesc.dwSize = sizeof(DPN_APPLICATION_DESC);
    dnAppDesc.guidApplication = *pGuid;
    dnAppDesc.dwMaxPlayers = dwMaxPlayers;
    dnAppDesc.dwFlags = flags;

	// set the name of the game
    dnAppDesc.pwszSessionName = g_wszXDPSessionName;

    // Host a game on m_pDeviceAddress as described by dnAppDesc
	g_pDeviceAddress->AddComponent(DPNA_KEY_PORT, (void *)&dwPort, sizeof(dwPort), DPNA_DATATYPE_DWORD);
	assert(SUCCEEDED(hr));

    hr = g_pDP->Host(&dnAppDesc, &g_pDeviceAddress, 1, NULL, NULL, NULL, 0);
	assert(SUCCEEDED(hr));

	g_dwConnectStatus = GAME_HOSTING;

	return hr;
}

//-----------------------------------------------------------------------------
// Name: XDPConnect
// Desc: Connect to an existing game.
//-----------------------------------------------------------------------------
HRESULT XDPConnect(DPN_APPLICATION_DESC *pAppDesc, IDirectPlay8Address *pHostAddr, IDirectPlay8Address *pDevAddr)
{
	static float time = 0.0f;
	static TCHAR s[80];
	HRESULT hr;
    DPNHANDLE hAsync;

    OutputDebugStringA("xdppeer: connecting\n");

	// cancel host enumeration
	XDPCancelEnumHosts();

	// Set player info
	DPN_PLAYER_INFO dpPlayerInfo;
	ZeroMemory(&dpPlayerInfo, sizeof(DPN_PLAYER_INFO));
	dpPlayerInfo.dwSize = sizeof(DPN_PLAYER_INFO);
	dpPlayerInfo.dwInfoFlags = DPNINFO_NAME;
	dpPlayerInfo.pwszName = g_wszXDPPlayerName;

	// set the peer info for the client
	hr = g_pDP->SetPeerInfo(&dpPlayerInfo, NULL, &hAsync, 0);
	assert(SUCCEEDED(hr));

	// connect to the game
	hr = g_pDP->Connect( pAppDesc,								// the application description
						 pHostAddr,								// address of the host of the session
						 pDevAddr,								// address of the local device the enum responses were received on
						 NULL, NULL,							// DPN_SECURITY_DESC, DPN_SECURITY_CREDENTIALS
						 NULL, 0,								// user data, user data size
						 NULL,									// player context,
						 NULL, &g_hAsyncOp,						// async context, async handle,
						 0);									// flags

	assert(hr==E_PENDING || SUCCEEDED(hr));

	g_dwConnectStatus = GAME_CONNECTING;

	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: XDPDisconnect
// Desc: Disconnect from the current game
//-----------------------------------------------------------------------------
HRESULT XDPDisconnect()
{
	HRESULT hr;

    OutputDebugStringA("xdppeer: disconnecting\n");

	g_pDP->Close(0);										// close the dplay connection
    hr = g_pDP->Initialize(NULL, XDPMsgHandler, 0);			// reinitialize dplay
	assert(SUCCEEDED(hr));

	g_dwConnectStatus = GAME_NOTCONNECTED;

	return hr;
}

//-----------------------------------------------------------------------------
// Name: XDPTerminate
// Desc: Terminate the current game as the host
//-----------------------------------------------------------------------------
HRESULT XDPTerminate()
{
	// send the terminate session message
	if(g_dwConnectStatus==GAME_HOSTING)
	{
	    OutputDebugStringA("xdppeer: terminating session\n");
		g_pDP->TerminateSession(NULL, 0, 0);
	}

	// and reset DPlay
	return XDPDisconnect();
}

//-----------------------------------------------------------------------------
// Name: XDPExpireGames
// Desc: Thread that expires old games in the ActiveGames list.
//-----------------------------------------------------------------------------
void XDPExpireGames()
{
	DWORD i;

	// search for expired games
	for(i=0; i<g_dwNumActiveGames; i++)
	{
		if((ActiveGames[i]->dwReportTime+3000)<GetTickCount())
		{
			// send delete game message to message handler
			g_AppDPMsgHandler(NULL, DPPEER_MSGID_DELETE_GAME, ActiveGames[i]);

			// delete the expired active game
			ActiveGames[i]->pHostAddr->Release();
			ActiveGames[i]->pDevAddr->Release();
			delete ActiveGames[i];

			// and remove it from our list
			ActiveGames[i] = ActiveGames[g_dwNumActiveGames-1];
			ActiveGames[g_dwNumActiveGames-1] = NULL;
			g_dwNumActiveGames--;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\src\xshadow.cpp ===
#include "xshadow.h"

extern LPDIRECT3DDEVICE8 g_pd3dDevice;

#define MAX_SHADOWTRIS 32767

// full screen shadow poly
FVFT_XYZRHWDIFF shadowpoly[4] =
{
	{ 0.0f, 0.0f, 0.0f, 1.0f, 0x3f000000 },
	{ 0.0f, 0.0f, 0.0f, 1.0f, 0x3f000000 },
	{ 0.0f, 0.0f, 0.0f, 1.0f, 0x3f000000 },
	{ 0.0f, 0.0f, 0.0f, 1.0f, 0x3f000000 }
};

CXShadowVolume::CXShadowVolume(float w, float h)
{
	memset(this, 0, sizeof(CXShadowVolume));
	m_fWidth = w;
	m_fHeight = h;
}

CXShadowVolume::~CXShadowVolume()
{
}

//
// shadow volume code
//
void CXShadowVolume::AddEdge(DWORD *edgelist, WORD v0, WORD v1)
{
	DWORD i, key;

	if(v0<v1)
		key = (v0<<16)|v1;
	else
		key = (v1<<16)|v0;

	// remove duplicate edges from list		
	for(i=0; i<m_dwNumEdges; i++)
		if(edgelist[i*3]==key)
		{
			m_dwNumEdges--;
			edgelist[i*3+0] = edgelist[3*m_dwNumEdges+0];
			edgelist[i*3+1] = edgelist[3*m_dwNumEdges+1];
			edgelist[i*3+2] = edgelist[3*m_dwNumEdges+2];
			return;
		}

	// no dup found, add this edge
	if(v0<v1)
		edgelist[m_dwNumEdges*3] = (v0<<16)|v1;
	else
		edgelist[m_dwNumEdges*3] = (v1<<16)|v0;

	edgelist[m_dwNumEdges*3+1] = (DWORD)v0;
	edgelist[m_dwNumEdges*3+2] = (DWORD)v1;
	m_dwNumEdges++;
}

void CXShadowVolume::AddObj(CXObject *obj, D3DXVECTOR3 *lightpos)
{
	DWORD *edgelist;
	D3DXMATRIX im;									// inverse matrix
	D3DXVECTOR4 lpos;								// light position
	BYTE *vptr, *iptr;								// vertex/index pointer
	WORD *tris;										// trilist pointer
	DWORD stride, i, nsi, fvf;
	WORD i0, i1, i2, nsvert;
	D3DXVECTOR3 v, v0, v1, v2;
	D3DXVECTOR3 norm, e0, e1;

	// allocate memory for edge list
	edgelist = new DWORD[2*MAX_SHADOWTRIS];

	// calculate inverse matrix (->object space)
	D3DXMatrixInverse(&im, NULL, (D3DXMATRIX *)&obj->m_matOrientation);

	// transform light into object space
	D3DXVec3Transform(&lpos, lightpos, &im);

	// get object info
	obj->m_Model->LockVB(&vptr, 0);
	obj->m_Model->LockIB(&iptr, 0);
	tris = (WORD *)iptr;
	fvf = obj->m_Model->m_dwFVF;
	stride = FVF_VSize(fvf);		// get vertex size

	// add edges
	m_dwNumEdges = 0;
	for(i=0; i<obj->m_Model->m_dwNumTriangles; i++)
	{
		i0 = tris[i*3+0];
		i1 = tris[i*3+1];
		i2 = tris[i*3+2];

		v0 = *((D3DXVECTOR3 *)(vptr + stride*i0));
		v1 = *((D3DXVECTOR3 *)(vptr + stride*i1));
		v2 = *((D3DXVECTOR3 *)(vptr + stride*i2));

		// calc tri normal
		D3DXVec3Cross(&norm, &(v2-v1), &(v1-v0));
		D3DXVec3Normalize(&norm, &norm);

		// dot light vector with tri norm to see if 
		// triangle faces the light
		v.x = lpos.x - v0.x;		// light-vert
		v.y = lpos.y - v0.y;
		v.z = lpos.z - v0.z;

		if(D3DXVec3Dot(&norm, &v)>0.0f)
		{
			AddEdge(edgelist, i0, i1);
			AddEdge(edgelist, i1, i2);
			AddEdge(edgelist, i2, i0);
		}
	}

	// allocate shadowvolume object
	if(m_Vert)
		delete m_Vert;
	if(m_Tris)
		delete m_Tris;

	m_Vert = new FVFT_XYZDIFF[m_dwNumEdges*4];			// allocate vertex memory
	stride = FVF_VSize(FVF_XYZDIFF);
	m_Tris = new WORD[m_dwNumEdges*6];					// allocate triangle memory

	m_dwNumTriangles = m_dwNumEdges*2;
	m_dwNumVertices = m_dwNumEdges*4;
	m_Matrix = obj->m_matOrientation;

	// extrude edges
	nsvert = 0;
	nsi = 0;
	for(i=0; i<m_dwNumEdges; i++)
	{
		FVF_GetVert(vptr, &e0, edgelist[i*3+1], 1, fvf);
		FVF_GetVert(vptr, &e1, edgelist[i*3+2], 1, fvf);

		m_Tris[nsi++] = nsvert+0;
		m_Tris[nsi++] = nsvert+1;
		m_Tris[nsi++] = nsvert+2;
		m_Tris[nsi++] = nsvert+1;
		m_Tris[nsi++] = nsvert+3;
		m_Tris[nsi++] = nsvert+2;

		// e0
		m_Vert[nsvert].v.x = e0.x;
		m_Vert[nsvert].v.y = e0.y;
		m_Vert[nsvert++].v.z = e0.z;

		// e1
		m_Vert[nsvert].v.x = e1.x;
		m_Vert[nsvert].v.y = e1.y;
		m_Vert[nsvert++].v.z = e1.z;

		// e2
		m_Vert[nsvert].v.x = 20*(e0.x - lpos.x);
		m_Vert[nsvert].v.y = 20*(e0.y - lpos.y);
		m_Vert[nsvert++].v.z = 20*(e0.z - lpos.z);

		// e3
		m_Vert[nsvert].v.x = 20*(e1.x - lpos.x);
		m_Vert[nsvert].v.y = 20*(e1.y - lpos.y);
		m_Vert[nsvert++].v.z = 20*(e1.z - lpos.z);
	}

	obj->m_Model->UnlockVB();
	obj->m_Model->UnlockIB();

	delete edgelist;
}

void CXShadowVolume::Render()
{
	shadowpoly[0].v.y = m_fHeight;
	shadowpoly[2].v.x = m_fWidth;
	shadowpoly[2].v.y = m_fHeight;
	shadowpoly[3].v.x = m_fWidth;

	// set up for shadow volume render
	g_pd3dDevice->SetRenderState(D3DRS_ZWRITEENABLE, FALSE);		// disable writes, tests still occur
	g_pd3dDevice->SetRenderState(D3DRS_STENCILENABLE, TRUE);		// enable stencil buffer
	g_pd3dDevice->SetRenderState(D3DRS_SHADEMODE, D3DSHADE_FLAT);	// dont interpolate colors
	g_pd3dDevice->SetRenderState(D3DRS_STENCILFUNC, D3DCMP_ALWAYS);	// stencil test always passes
																	// dont need fail setup since always passes
	g_pd3dDevice->SetRenderState(D3DRS_STENCILREF, 0x1);			// bump stencil count for each pixel
	g_pd3dDevice->SetRenderState(D3DRS_STENCILMASK, 0Xffffffff);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILWRITEMASK, 0Xffffffff);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILPASS, D3DSTENCILOP_INCR);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);		// dont draw any pixels
	g_pd3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ZERO);
	g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE);

	// draw fronts w/ stencil increment
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_DISABLE);
	g_pd3dDevice->SetVertexShader(FVF_XYZDIFF);
	g_pd3dDevice->SetTransform(D3DTS_WORLD, &m_Matrix);

	g_pd3dDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_CCW);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILPASS, D3DSTENCILOP_INCR);
	g_pd3dDevice->DrawIndexedPrimitiveUP(D3DPT_TRIANGLELIST, 0, m_dwNumVertices, m_dwNumTriangles, m_Tris,
							D3DFMT_INDEX16, m_Vert, sizeof(FVFT_XYZDIFF));

	// draw rears with stencil decrement
	g_pd3dDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_CW);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILPASS, D3DSTENCILOP_DECR);
	g_pd3dDevice->DrawIndexedPrimitiveUP(D3DPT_TRIANGLELIST, 0, m_dwNumVertices, m_dwNumTriangles, m_Tris,
							D3DFMT_INDEX16, m_Vert, sizeof(FVFT_XYZDIFF));

	// attenuate pixels in stencil region (shadow)
	g_pd3dDevice->SetRenderState(D3DRS_ZENABLE, FALSE);				// no zbuffer
	g_pd3dDevice->SetRenderState(D3DRS_STENCILENABLE, TRUE);		// uses stencil compare
	g_pd3dDevice->SetRenderState(D3DRS_STENCILREF, 0X1);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILFUNC, D3DCMP_LESSEQUAL); // <= 1
	g_pd3dDevice->SetRenderState(D3DRS_STENCILPASS, D3DSTENCILOP_KEEP);
	g_pd3dDevice->SetRenderState(D3DRS_FOGENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
	g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
	g_pd3dDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_CCW);

	g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_MODULATE);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE);

	g_pd3dDevice->SetVertexShader(FVF_XYZRHWDIFF);
	g_pd3dDevice->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, shadowpoly, sizeof(FVFT_XYZRHWDIFF));

	// reset render state
	g_pd3dDevice->SetRenderState(D3DRS_ZENABLE, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_ZWRITEENABLE, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_SHADEMODE, D3DSHADE_GOURAUD);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\src\xmenu.cpp ===
#include <xtl.h>
#include "assert.h"
#include "XBUtil.h"
#include "XBInput.h"
#include "xmenu.h"

extern LPDIRECT3DDEVICE8 g_pd3dDevice;

CXBFont *XMenu_Font = NULL;				// pointer to font
DWORD XMenu_FontLoaded = FALSE;			// font loaded flag
XMenu *XMenu_CurMenu = NULL;
int (*XMenu_CurRoutine)(DWORD cmd, XMenuItem *mi);			// called when item selected

void DrawRect(float x, float y, float w, float h, DWORD dwTopColor, DWORD dwBottomColor);

void XMenu_SetFont(CXBFont *font)
{
	XMenu_Font = font;
}

XMenu *XMenu_Init(float x, float y, DWORD maxitems, DWORD flags, DWORD (*abortroutine)(DWORD, XMenuItem *))
{
	XMenu *m;
	BYTE *mem;

	assert(XMenu_Font!=NULL);				// make sure font is set

	// allocate memory for menu
	mem = new BYTE[sizeof(XMenu) + maxitems*sizeof(XMenuItem)];
	memset(mem, 0, sizeof(XMenu) + maxitems*sizeof(XMenuItem));

	m = (XMenu *)mem;
	m->items = (XMenuItem *)(mem+sizeof(XMenu));
	m->flags = flags;
	m->topcolor = 0xff000000;
	m->bottomcolor = 0xff0000c0;
	m->seltopcolor = 0xff000000;
	m->selbotcolor = 0xffc00000;
	m->maxitems = maxitems;
	m->abortroutine = abortroutine;
	m->itemcolor = 0xffffffff;

	m->x = x;
	m->y = y;
	m->w = 100.0f;

	XMenu_SetMaxShow(m, m->maxitems);		// sets height

	return m;
}

void XMenu_Delete(XMenu *m)
{
	delete m;
}

void XMenu_SetMaxShow(XMenu *m, DWORD maxshow)
{
	m->maxshow = maxshow;
	m->h = (float)(m->maxshow+1) * XMenu_Font->GetFontHeight();
}

XMenuItem *XMenu_AddItem(XMenu *m, DWORD flags, WCHAR *string, void *action)
{
	XMenuItem *mi;

	assert(m->nitems<m->maxitems);		// make sure we dont overstep our allocation
	mi = &m->items[m->nitems];

	mi->flags = flags;
	mi->action = action;
	mi->val1 = 0;
	mi->val2 = 0;
	mi->menu = m;
	mi->color = m->itemcolor;
	XMenu_SetItemText(&m->items[m->nitems], string);

	m->nitems++;

	return &m->items[m->nitems-1];
}

void XMenu_DeleteItem(XMenuItem *mi)
{
	XMenu *m;
	DWORD i;
	
	// get pointer to the menu that owns this item
	m = mi->menu;

	// find the item to delete
	for(i=0; i<m->nitems; i++)
		if(&m->items[i]==mi)
		{
			// shift em down
			memcpy(&m->items[i], &m->items[i+1], (m->nitems-i-1)*sizeof(XMenuItem));
			m->nitems--;
			break;
		}
}

void XMenu_SetTitle(XMenu *m, WCHAR *string, DWORD color)
{
	float w, h;

	m->titlecolor = color;

	if(string)
	{
		// set string
		wcsncpy(m->title, string, MITEM_STRINGLEN-1);

		// calculate new menu width based on this item
		XMenu_Font->GetTextExtent(string, &w, &h);
		if(m->w<(w+16.0f))
			m->w = w+16.0f;
	
		m->h = ((float)m->maxshow+2.5f) * XMenu_Font->GetFontHeight();
	}
	else
		m->h = (float)(m->maxshow+1) * XMenu_Font->GetFontHeight();
}

void XMenu_SetItemText(XMenuItem *mi, WCHAR *string)
{
	float w, h;

	if(!string || (mi->flags&MITEM_SEPARATOR))
		return;

	// set string
	wcsncpy(mi->string, string, MITEM_STRINGLEN-1);

	// calculate new menu width based on this item
	XMenu_Font->GetTextExtent(string, &w, &h);
	if(mi->menu->w<(w+16.0f))
		mi->menu->w = w+16.0f;
}

DWORD XMenu_Activate(XMenu *m)
{
	XMenu_CurMenu = m;

	return 1;
}

DWORD XMenu_GetCommand(XBGAMEPAD *gamepad)
{
	DWORD command;

	command = 0;

	// get menu command
	if(XMenu_CurMenu || XMenu_CurRoutine)
	{
		if(gamepad->bPressedAnalogButtons[XINPUT_GAMEPAD_A] ||
		   gamepad->wPressedButtons&XINPUT_GAMEPAD_START)
			command = MENU_SELECTITEM;
		else if(gamepad->bPressedAnalogButtons[XINPUT_GAMEPAD_B] ||
		   gamepad->wPressedButtons&XINPUT_GAMEPAD_BACK)
			command = MENU_BACK;
		else if(gamepad->fY1>0.25f)
			command = MENU_PREVITEM;
		else if(gamepad->fY1<-0.25f)
			command = MENU_NEXTITEM;
	}
	else if(gamepad->wPressedButtons&XINPUT_GAMEPAD_START)
		command = MENU_ACTIVATE;

	return command;
}

DWORD XMenu_Routine(DWORD command)
{
	float menux, menuy;
	float rectx, recty, rectw, recth;
	float itemy, itemh;
	DWORD i, color;
	static float menutime = 0.0f;
	float time;
	XMenu *m;
	XMenuItem *mi;
	DWORD firstitem, nitems;
	WCHAR ddd[16] = L"[--MORE--]";
	WCHAR *str;
	DWORD status;

	// check for menu routine first
	if(XMenu_CurRoutine)
	{
		status = XMenu_CurRoutine(command, NULL);
		if(status==MROUTINE_DIE)
			XMenu_CurRoutine = NULL;
		return 0;
	}

	// no routine so do menu processing
	m = XMenu_CurMenu;
	if(!m)
		return 0;

	// get height of font
	itemh = (float)XMenu_Font->GetFontHeight();

	// draw menu background
	rectx = m->x;
	recty = m->y - itemh/2.0f;
	rectw = m->w;
	recth = m->h;

	if(m->flags&(MENU_LEFT|MENU_RIGHT))
		DrawRect(rectx-8.0f, recty, rectw, recth, m->topcolor, m->bottomcolor);
	else
		DrawRect(rectx-(rectw/2.0f), recty, rectw, recth, m->topcolor, m->bottomcolor);

	menux = m->x;
	menuy = m->y;

	// determine which menu items to show (firstitem, nitems)
	if(m->nitems>m->maxshow)
	{
		if(m->curitem<(m->maxshow/2))
			firstitem = 0;
		else if(m->curitem<(m->nitems-(m->maxshow/2)))
			firstitem = m->curitem-(m->maxshow/2)+1;
		else
			firstitem = m->nitems-m->maxshow;
	}
	else
		firstitem = 0;

	if(m->nitems>m->maxshow)
		nitems = m->maxshow;
	else
		nitems = m->nitems;

	itemy = menuy;

	// draw the menu title
	if(m->title[0])
	{
		if(m->flags&MENU_LEFT)
			XMenu_Font->DrawText(menux, itemy, m->titlecolor, m->title);
		else if(m->flags&MENU_RIGHT)
			XMenu_Font->DrawText(menux, itemy, m->titlecolor, m->title, XBFONT_RIGHT);
		else
			XMenu_Font->DrawText(menux, itemy, m->titlecolor, m->title, XBFONT_CENTER_X);
			
		itemy += 1.5f*itemh;
	}

	// draw the menu items
	for(i=firstitem; i<nitems+firstitem; i++)
	{
		mi = &m->items[i];

		if(!(mi->flags&MITEM_SEPARATOR))
		{
			// do menu scroll
			str = mi->string;
			if(m->nitems>m->maxshow)
			{
				if((i==firstitem) && (firstitem!=0))
					str = ddd;
				if((i==(firstitem+nitems-1)) && (firstitem!=(m->nitems-m->maxshow)))
					str = ddd;
			}

			// draw menu hilight bar
			if(i==m->curitem)
			{
				if(m->flags&(MENU_LEFT|MENU_RIGHT))
					DrawRect(rectx-8.0f, itemy-2.0f, rectw, XMenu_Font->GetFontHeight()+4.0f, m->seltopcolor, m->selbotcolor);
				else
					DrawRect(rectx-(rectw/2.0f), itemy-2.0f, rectw, XMenu_Font->GetFontHeight()+4.0f, m->seltopcolor, m->selbotcolor);
			}

			// set item color
			if(mi->flags&MITEM_DISABLED)
				color = (mi->color&0xffffff) | 0x40000000;	// lower alpha
			else
				color = mi->color;
	
			// draw the menu text
			if(!(m->flags&(MENU_LEFT|MENU_RIGHT)))
				XMenu_Font->DrawText(menux, itemy, color, str, XBFONT_CENTER_X);
			else if(m->flags&MENU_LEFT)
				XMenu_Font->DrawText(menux, itemy, color, str);
			else if(m->flags&MENU_RIGHT)
				XMenu_Font->DrawText(menux, itemy, color, str, XBFONT_RIGHT);
		}

		itemy += XMenu_Font->GetFontHeight();
	}

	time = XBUtil_Timer(TIMER_GETABSOLUTETIME);

	switch(command)
	{
		case MENU_NEXTITEM:
			if((time-menutime)<0.2f)
				return 0;
			menutime = time;

			do
			{
				m->curitem++;
				if(m->curitem==m->nitems)
					if(m->flags&MENU_WRAP)
						m->curitem = 0;
					else
						m->curitem = m->nitems-1;
			} while(m->items[m->curitem].flags&(MITEM_SEPARATOR|MITEM_DISABLED));
			break;

		case MENU_PREVITEM:
			if((time-menutime)<0.2f)
				return 0;
			menutime = time;

			do 
			{
				m->curitem--;
				if(m->curitem==-1)
					if(m->flags&MENU_WRAP)
						m->curitem = m->nitems-1;
					else
						m->curitem = 0;
			} while(m->items[m->curitem].flags&(MITEM_SEPARATOR|MITEM_DISABLED));

			menutime = time;
			break;

		case MENU_SELECTITEM:
			mi = &m->items[m->curitem];

			if(mi->flags&MITEM_ROUTINE)
			{
				// do routine
				XMenu_CurRoutine = (int (*)(DWORD, XMenuItem *))mi->action;
				status = XMenu_CurRoutine(MROUTINE_INIT, mi);

				// check return value... 
				if(status==MROUTINE_DIE)
				{
					XMenu_Activate(NULL);			// kill the current menu
					XMenu_CurRoutine = NULL;		// and the routine
				}
				else if(status==MROUTINE_RETURN)	// just kill the routine
					XMenu_CurRoutine = NULL;
				else if(status==MROUTINE_SLEEP)
					XMenu_Activate(NULL);			// just kill current menu
			}
			else
			{	
				// activate next menu if it exists
				if(mi->action)
				{
					XMenu_Activate((XMenu *)mi->action);
					XMenu_CurMenu->parent = m;		// the menu that called me
				}
				else
				{
					if(m->abortroutine)
						m->abortroutine(MROUTINE_ABORT, NULL);

					XMenu_Activate(NULL);
				}
			}
			break;

		case MENU_BACK:
			if(!(m->flags&MENU_NOBACK))
			{
				if(m->abortroutine)						// call abort routine if it exists
					m->abortroutine(MROUTINE_ABORT, NULL);

				if(m->parent)							// activate parent menu if it exists
					XMenu_Activate(m->parent);
				else
					XMenu_Activate(NULL);
			}
			break;

		default:
			break;
	}

	return 1;
}

//-----------------------------------------------------------------------------
// Name: DrawRect
// Desc: Draws a gradient filled rectangle
//-----------------------------------------------------------------------------
void DrawRect(float x, float y, float w, float h, DWORD dwTopColor, DWORD dwBottomColor)
{
    static LPDIRECT3DVERTEXBUFFER8 XMenu_VB = NULL;
    struct BACKGROUNDVERTEX 
	{ 
		D3DXVECTOR4 p; 
		D3DCOLOR color; 
	} *v;

    if(XMenu_VB == NULL)
        g_pd3dDevice->CreateVertexBuffer(4*sizeof(BACKGROUNDVERTEX), D3DUSAGE_WRITEONLY, 
                                          0L, D3DPOOL_DEFAULT, &XMenu_VB);

    // Setup vertices for a background-covering quad
	XMenu_VB->Lock(0, 0, (BYTE **)&v, 0L);
    v[0].p = D3DXVECTOR4(x, y, 1.0f, 1.0f);
	v[0].color = dwTopColor;
    v[1].p = D3DXVECTOR4(x+w, y, 1.0f, 1.0f);
	v[1].color = dwTopColor;
    v[2].p = D3DXVECTOR4(x, y+h, 1.0f, 1.0f); 
	v[2].color = dwBottomColor;
    v[3].p = D3DXVECTOR4(x+w, y+h, 1.0f, 1.0f);
	v[3].color = dwBottomColor;
	XMenu_VB->Unlock();

	// set render states
    g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE); 
	g_pd3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
	g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
	g_pd3dDevice->SetRenderState(D3DRS_ZENABLE, FALSE);

    // Set states
    g_pd3dDevice->SetTexture(0, NULL);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_DISABLE);
    g_pd3dDevice->SetVertexShader(D3DFVF_XYZRHW|D3DFVF_DIFFUSE);
    g_pd3dDevice->SetStreamSource(0, XMenu_VB, sizeof(BACKGROUNDVERTEX));

    // Render the quad
    g_pd3dDevice->DrawPrimitive(D3DPT_TRIANGLESTRIP, 0, 2);

	// restore render state
    g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE); 
	g_pd3dDevice->SetRenderState(D3DRS_ZENABLE, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\src\xfvf.cpp ===
//-----------------------------------------------------------------------------
// File: xfvf.cpp
//
// Desc: routines for manipulating d3d fixed vertex formats
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "xfvf.h"

//-----------------------------------------------------------------------------
//
// Name: FVF_Get Routines
//
// Desc: gets cnt items starting at vertex first from fvf memory
//       starting at verts which has FVF format of fvf.
//       the vertices are output to vout.
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//
// Name: FVF_Set Routines
//
// Desc: sets cnt items starting at vertex first from fvf memory
//       starting at verts which has FVF format of fvf.
//       the vertices are set from vin.
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Name: FVF_VSize
// Desc: returns the size of an FVF
//-----------------------------------------------------------------------------
DWORD FVF_VSize(DWORD fvf)
{
	int size;
	
	size = 0;
	
	if(fvf&D3DFVF_XYZ)
		size += sizeof(D3DVECTOR);
	if(fvf&D3DFVF_XYZRHW)
		size += sizeof(D3DVECTOR)+sizeof(float);
	if(fvf&D3DFVF_NORMAL)
		size += sizeof(D3DVECTOR);
	if(fvf&D3DFVF_DIFFUSE)
		size += sizeof(DWORD);
	if(fvf&D3DFVF_TEX1)
		size += 2*sizeof(float);

	return size;
}

void FVF_GetVert(void *verts, D3DVECTOR *vout, DWORD first, DWORD cnt, DWORD fvf)
{
	DWORD i, idx;

	FVFT_XYZDIFF *fvf1;
	FVFT_XYZNORM *fvf2;
	FVFT_XYZTEX1 *fvf3;
	FVFT_XYZRHWTEX1 *fvf4;
	FVFT_XYZDIFFTEX1 *fvf5;
	FVFT_XYZNORMTEX1 *fvf6;
	FVFT_XYZNORMDIFF *fvf7;
	FVFT_XYZNORMDIFFTEX1 *fvf8;

	idx = 0;

	switch(fvf)
	{
		case FVF_XYZDIFF:
			fvf1 = (FVFT_XYZDIFF *)verts;
			for(i=first; i<first+cnt; i++)
				memcpy(&vout[idx++], &fvf1[i].v, sizeof(D3DVECTOR));
			break;
		case FVF_XYZNORM:
			fvf2 = (FVFT_XYZNORM *)verts;
			for(i=first; i<first+cnt; i++)
				memcpy(&vout[idx++], &fvf2[i].v, sizeof(D3DVECTOR));
			break;
		case FVF_XYZTEX1:
			fvf3 = (FVFT_XYZTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
				memcpy(&vout[idx++], &fvf3[i].v, sizeof(D3DVECTOR));
			break;
		case FVF_XYZRHWTEX1:
			fvf4 = (FVFT_XYZRHWTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
				memcpy(&vout[idx++], &fvf4[i].v, sizeof(D3DVECTOR));
			break;
		case FVF_XYZDIFFTEX1:
			fvf5 = (FVFT_XYZDIFFTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
				memcpy(&vout[idx++], &fvf5[i].v, sizeof(D3DVECTOR));
			break;
		case FVF_XYZNORMTEX1:
			fvf6 = (FVFT_XYZNORMTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
				memcpy(&vout[idx++], &fvf6[i].v, sizeof(D3DVECTOR));
			break;
		case FVF_XYZNORMDIFF:
			fvf7 = (FVFT_XYZNORMDIFF *)verts;
			for(i=first; i<first+cnt; i++)
				memcpy(&vout[idx++], &fvf7[i].v, sizeof(D3DVECTOR));
			break;
		case FVF_XYZNORMDIFFTEX1:
			fvf8 = (FVFT_XYZNORMDIFFTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
				memcpy(&vout[idx++], &fvf8[i].v, sizeof(D3DVECTOR));
			break;
	}
}

void FVF_GetNorm(void *verts, D3DVECTOR *nout, DWORD first, DWORD cnt, DWORD fvf)
{
	DWORD i, idx;

	FVFT_XYZNORM *fvf2;
	FVFT_XYZNORMTEX1 *fvf6;
	FVFT_XYZNORMDIFF *fvf7;
	FVFT_XYZNORMDIFFTEX1 *fvf8;

	idx = 0;

	switch(fvf)
	{
		case FVF_XYZNORM:
			fvf2 = (FVFT_XYZNORM *)verts;
			for(i=first; i<first+cnt; i++)
				memcpy(&nout[idx++], &fvf2[i].norm, sizeof(D3DVECTOR));
			break;
		case FVF_XYZNORMTEX1:
			fvf6 = (FVFT_XYZNORMTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
				memcpy(&nout[idx++], &fvf6[i].norm, sizeof(D3DVECTOR));
			break;
		case FVF_XYZNORMDIFF:
			fvf7 = (FVFT_XYZNORMDIFF *)verts;
			for(i=first; i<first+cnt; i++)
				memcpy(&nout[idx++], &fvf7[i].norm, sizeof(D3DVECTOR));
			break;
		case FVF_XYZNORMDIFFTEX1:
			fvf8 = (FVFT_XYZNORMDIFFTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
				memcpy(&nout[idx++], &fvf8[i].norm, sizeof(D3DVECTOR));
			break;
	}
}

void FVF_GetDiff(void *verts, DWORD *dout, DWORD first, DWORD cnt, DWORD fvf)
{
	DWORD i, idx;

	FVFT_XYZDIFF *fvf1;
	FVFT_XYZDIFFTEX1 *fvf5;
	FVFT_XYZNORMDIFF *fvf7;
	FVFT_XYZNORMDIFFTEX1 *fvf8;

	idx = 0;

	switch(fvf)
	{
		case FVF_XYZDIFF:
			fvf1 = (FVFT_XYZDIFF *)verts;
			for(i=first; i<first+cnt; i++)
				dout[idx++] = fvf1[i].diff;
			break;
		case FVF_XYZDIFFTEX1:
			fvf5 = (FVFT_XYZDIFFTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
				dout[idx++] = fvf5[i].diff;
			break;
		case FVF_XYZNORMDIFF:
			fvf7 = (FVFT_XYZNORMDIFF *)verts;
			for(i=first; i<first+cnt; i++)
				dout[idx++] = fvf7[i].diff;
			break;
		case FVF_XYZNORMDIFFTEX1:
			fvf8 = (FVFT_XYZNORMDIFFTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
				dout[idx++] = fvf8[i].diff;
			break;
	}
}

void FVF_GetUV(void *verts, float *uvout, DWORD first, DWORD cnt, DWORD fvf)
{
	DWORD i, idx;

	FVFT_XYZTEX1 *fvf3;
	FVFT_XYZRHWTEX1 *fvf4;
	FVFT_XYZDIFFTEX1 *fvf5;
	FVFT_XYZNORMTEX1 *fvf6;
	FVFT_XYZNORMDIFFTEX1 *fvf8;

	idx = 0;

	switch(fvf)
	{
		case FVF_XYZTEX1:
			fvf3 = (FVFT_XYZTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
			{
				uvout[idx*2] = fvf3[i].tu;
				uvout[idx*2+1] = fvf3[i].tv;
				idx++;
			}
			break;
		case FVF_XYZRHWTEX1:
			fvf4 = (FVFT_XYZRHWTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
			{
				uvout[idx*2] = fvf4[i].tu;
				uvout[idx*2+1] = fvf4[i].tv;
				idx++;
			}
			break;
		case FVF_XYZDIFFTEX1:
			fvf5 = (FVFT_XYZDIFFTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
			{
				uvout[idx*2] = fvf5[i].tu;
				uvout[idx*2+1] = fvf5[i].tv;
				idx++;
			}
			break;
		case FVF_XYZNORMTEX1:
			fvf6 = (FVFT_XYZNORMTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
			{
				uvout[idx*2] = fvf6[i].tu;
				uvout[idx*2+1] = fvf6[i].tv;
				idx++;
			}
			break;
		case FVF_XYZNORMDIFFTEX1:
			fvf8 = (FVFT_XYZNORMDIFFTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
			{
				uvout[idx*2] = fvf8[i].tu;
				uvout[idx*2+1] = fvf8[i].tv;
				idx++;
			}
			break;
	}
}

void FVF_SetVert(void *verts, D3DVECTOR *vin, DWORD first, DWORD cnt, DWORD fvf)
{
	DWORD i, idx;

	FVFT_XYZDIFF *fvf1;
	FVFT_XYZNORM *fvf2;
	FVFT_XYZTEX1 *fvf3;
	FVFT_XYZRHWTEX1 *fvf4;
	FVFT_XYZDIFFTEX1 *fvf5;
	FVFT_XYZNORMTEX1 *fvf6;
	FVFT_XYZNORMDIFF *fvf7;
	FVFT_XYZNORMDIFFTEX1 *fvf8;

	idx = 0;

	switch(fvf)
	{
		case FVF_XYZDIFF:
			fvf1 = (FVFT_XYZDIFF *)verts;
			for(i=first; i<first+cnt; i++)
				memcpy(&fvf1[i].v, &vin[idx++], sizeof(D3DVECTOR));
			break;
		case FVF_XYZNORM:
			fvf2 = (FVFT_XYZNORM *)verts;
			for(i=first; i<first+cnt; i++)
				memcpy(&fvf2[i].v, &vin[idx++], sizeof(D3DVECTOR));
			break;
		case FVF_XYZTEX1:
			fvf3 = (FVFT_XYZTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
				memcpy(&fvf3[i].v, &vin[idx++], sizeof(D3DVECTOR));
			break;
		case FVF_XYZRHWTEX1:
			fvf4 = (FVFT_XYZRHWTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
				memcpy(&fvf4[i].v, &vin[idx++], sizeof(D3DVECTOR));
			break;
		case FVF_XYZDIFFTEX1:
			fvf5 = (FVFT_XYZDIFFTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
				memcpy(&fvf5[i].v, &vin[idx++], sizeof(D3DVECTOR));
			break;
		case FVF_XYZNORMTEX1:
			fvf6 = (FVFT_XYZNORMTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
				memcpy(&fvf6[i].v, &vin[idx++], sizeof(D3DVECTOR));
			break;
		case FVF_XYZNORMDIFF:
			fvf7 = (FVFT_XYZNORMDIFF *)verts;
			for(i=first; i<first+cnt; i++)
				memcpy(&fvf7[i].v, &vin[idx++], sizeof(D3DVECTOR));
			break;
		case FVF_XYZNORMDIFFTEX1:
			fvf8 = (FVFT_XYZNORMDIFFTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
				memcpy(&fvf8[i].v, &vin[idx++], sizeof(D3DVECTOR));
			break;
	}
}

void FVF_SetNorm(void *verts, D3DVECTOR *nin, DWORD first, DWORD cnt, DWORD fvf)
{
	DWORD i, idx;

	FVFT_XYZNORM *fvf2;
	FVFT_XYZNORMTEX1 *fvf6;
	FVFT_XYZNORMDIFF *fvf7;
	FVFT_XYZNORMDIFFTEX1 *fvf8;

	idx = 0;

	switch(fvf)
	{
		case FVF_XYZNORM:
			fvf2 = (FVFT_XYZNORM *)verts;
			for(i=first; i<first+cnt; i++)
				memcpy(&fvf2[i].norm, &nin[idx++], sizeof(D3DVECTOR));
			break;
		case FVF_XYZNORMTEX1:
			fvf6 = (FVFT_XYZNORMTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
				memcpy(&fvf6[i].norm, &nin[idx++], sizeof(D3DVECTOR));
			break;
		case FVF_XYZNORMDIFF:
			fvf7 = (FVFT_XYZNORMDIFF *)verts;
			for(i=first; i<first+cnt; i++)
				memcpy(&fvf7[i].norm, &nin[idx++], sizeof(D3DVECTOR));
			break;
		case FVF_XYZNORMDIFFTEX1:
			fvf8 = (FVFT_XYZNORMDIFFTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
				memcpy(&fvf8[i].norm, &nin[idx++], sizeof(D3DVECTOR));
			break;
	}
}

void FVF_SetDiff(void *verts, DWORD *din, DWORD first, DWORD cnt, DWORD fvf)
{
	DWORD i, idx;

	FVFT_XYZDIFF *fvf1;
	FVFT_XYZDIFFTEX1 *fvf5;
	FVFT_XYZNORMDIFF *fvf7;
	FVFT_XYZNORMDIFFTEX1 *fvf8;

	idx = 0;

	switch(fvf)
	{
		case FVF_XYZDIFF:
			fvf1 = (FVFT_XYZDIFF *)verts;
			for(i=first; i<first+cnt; i++)
				fvf1[i].diff = din[idx++];
			break;
		case FVF_XYZDIFFTEX1:
			fvf5 = (FVFT_XYZDIFFTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
				fvf5[i].diff = din[idx++];
			break;
		case FVF_XYZNORMDIFF:
			fvf7 = (FVFT_XYZNORMDIFF *)verts;
			for(i=first; i<first+cnt; i++)
				fvf7[i].diff = din[idx++];
			break;
		case FVF_XYZNORMDIFFTEX1:
			fvf8 = (FVFT_XYZNORMDIFFTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
				fvf8[i].diff = din[idx++];
			break;
	}
}

void FVF_SetAllDiff(void *verts, DWORD din, DWORD first, DWORD cnt, DWORD fvf)
{
	DWORD i;

	FVFT_XYZDIFF *fvf1;
	FVFT_XYZDIFFTEX1 *fvf5;
	FVFT_XYZNORMDIFF *fvf7;
	FVFT_XYZNORMDIFFTEX1 *fvf8;

	switch(fvf)
	{
		case FVF_XYZDIFF:
			fvf1 = (FVFT_XYZDIFF *)verts;
			for(i=first; i<first+cnt; i++)
				fvf1[i].diff = din;
			break;
		case FVF_XYZDIFFTEX1:
			fvf5 = (FVFT_XYZDIFFTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
				fvf5[i].diff = din;
			break;
		case FVF_XYZNORMDIFF:
			fvf7 = (FVFT_XYZNORMDIFF *)verts;
			for(i=first; i<first+cnt; i++)
				fvf7[i].diff = din;
			break;
		case FVF_XYZNORMDIFFTEX1:
			fvf8 = (FVFT_XYZNORMDIFFTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
				fvf8[i].diff = din;
			break;
	}
}

void FVF_SetUV(void *verts, float *uvin, DWORD first, DWORD cnt, DWORD fvf)
{
	DWORD i, idx;

	FVFT_XYZTEX1 *fvf3;
	FVFT_XYZRHWTEX1 *fvf4;
	FVFT_XYZDIFFTEX1 *fvf5;
	FVFT_XYZNORMTEX1 *fvf6;
	FVFT_XYZNORMDIFFTEX1 *fvf8;

	idx = 0;

	switch(fvf)
	{
		case FVF_XYZTEX1:
			fvf3 = (FVFT_XYZTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
			{
				fvf3[i].tu = uvin[idx*2];
				fvf3[i].tv = uvin[idx*2+1];
				idx++;
			}
			break;
		case FVF_XYZRHWTEX1:
			fvf4 = (FVFT_XYZRHWTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
			{
				fvf4[i].tu = uvin[idx*2];
				fvf4[i].tv = uvin[idx*2+1];
				idx++;
			}
			break;
		case FVF_XYZDIFFTEX1:
			fvf5 = (FVFT_XYZDIFFTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
			{
				fvf5[i].tu = uvin[idx*2];
				fvf5[i].tv = uvin[idx*2+1];
				idx++;
			}
			break;
		case FVF_XYZNORMTEX1:
			fvf6 = (FVFT_XYZNORMTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
			{
				fvf6[i].tu = uvin[idx*2];
				fvf6[i].tv = uvin[idx*2+1];
				idx++;
			}
			break;
		case FVF_XYZNORMDIFFTEX1:
			fvf8 = (FVFT_XYZNORMDIFFTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
			{
				fvf8[i].tu = uvin[idx*2];
				fvf8[i].tv = uvin[idx*2+1];
				idx++;
			}
			break;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\src\xmodel.cpp ===
//-----------------------------------------------------------------------------
// File: xmodel.cpp
//
// Desc: routines for loading, saving, and building models
//       vertex buffers, etc...
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <stdio.h>
#include <assert.h>

#include "xmodel.h"
#include "xparse.h"
#include "xpath.h"
#include "xfvf.h"

#ifndef _XBOX
#include <d3dx8.h>
#endif

float g_fNormLength = 0.005f;
extern LPDIRECT3DDEVICE8 g_pd3dDevice;

CXBPackedResource *g_pModelResource = NULL;


//-----------------------------------------------------------------------------
// Constructor and destructor
//-----------------------------------------------------------------------------
CXModel::CXModel()
{
	m_pVB = NULL;
	m_pIB = NULL;
	m_pTexture = NULL;
	m_dwRefCount = 1;
}

CXModel::~CXModel()
{
	assert(m_dwRefCount==0);

	if(m_pVB)
		m_pVB->Release();
	if(m_pIB)
		m_pIB->Release();
	if(m_pTexture)
		m_pTexture->Release();
}

//-----------------------------------------------------------------------------
// Name: Release
// Desc: Release someones claim to this model
//-----------------------------------------------------------------------------
int CXModel::Release()
{
	if(--m_dwRefCount)
		return m_dwRefCount;

	delete this;
	return 0;
}

//-----------------------------------------------------------------------------
// Name: Build
// Desc: builds a model from vertices, a triangle list, a list
//		 of texture coordinates and an FVF. Vertices and the 
//		 trilist are required. UV's & colors are optional
//-----------------------------------------------------------------------------
DWORD CXModel::Build(DWORD nvert, D3DVECTOR *vert, DWORD ntri, DWORD nidx, WORD *trilist, float *tc, D3DVECTOR *norm, DWORD *diff, DWORD fvf, DWORD flags)
{
	byte *bptr;
	DWORD i;
	D3DVECTOR *norm2 = NULL;
	float r, maxr;

	m_dwNumVertices = nvert;
	m_dwNumTriangles = ntri;
	m_dwFVF = fvf;
	m_dwVShader = fvf;				// set vshader to fixed function (user can chang manually)
	m_dwFlags = flags;

	// calculate radius
	maxr = 0.0f;
	for(i=0; i<nvert; i++)
	{	
		r = vert[i].x*vert[i].x + vert[i].y*vert[i].y + vert[i].z*vert[i].z;
		if(r>maxr)
			maxr = r;
	}
	m_fRadius2 = maxr;
	m_fRadius = (float)sqrt(maxr);

	// crunch normals if desired
	if(m_dwFVF&D3DFVF_NORMAL && !norm)
		norm2 = GenNormals(nvert, vert, ntri, trilist);

	// allocate vertex buffer
	m_dwVBStride = FVF_VSize(m_dwFVF);
	m_dwVBSize = m_dwNumVertices*m_dwVBStride;
#ifdef _XBOX
	g_pd3dDevice->CreateVertexBuffer(m_dwVBSize, 0, m_dwFVF, D3DPOOL_DEFAULT, &m_pVB);
#else
	g_pd3dDevice->CreateVertexBuffer(m_dwVBSize, D3DUSAGE_DYNAMIC, m_dwFVF, D3DPOOL_DEFAULT, &m_pVB);
#endif

	m_dwNumIndices = nidx;

	// allocate index buffer
	m_dwIBSize = m_dwNumIndices*sizeof(WORD);
#ifdef _XBOX
	g_pd3dDevice->CreateIndexBuffer(m_dwIBSize, 0, D3DFMT_INDEX16, D3DPOOL_DEFAULT, &m_pIB);
#else
	g_pd3dDevice->CreateIndexBuffer(m_dwIBSize, D3DUSAGE_DYNAMIC, D3DFMT_INDEX16, D3DPOOL_DEFAULT, &m_pIB);
#endif
	// fill vertex buffer
	LockVB(&bptr, 0L);
	FVF_SetVert(bptr, vert, 0, m_dwNumVertices, m_dwFVF);
	if(m_dwFVF&D3DFVF_DIFFUSE)
		FVF_SetDiff(bptr, diff, 0, m_dwNumVertices, m_dwFVF);
	if(m_dwFVF&D3DFVF_NORMAL)
	{
		if(norm2)
		{
			FVF_SetNorm(bptr, norm2, 0, m_dwNumVertices, m_dwFVF);
			delete norm2;		// free up memory allocated from GenNormals
		}
		else		// user specified own normals
			FVF_SetNorm(bptr, norm, 0, m_dwNumVertices, m_dwFVF);
	}
	if(m_dwFVF&D3DFVF_TEX1)
		FVF_SetUV(bptr, tc, 0, m_dwNumVertices, m_dwFVF);
	UnlockVB();
	
	// fill index buffer
	LockIB(&bptr, 0L);
	memcpy(bptr, trilist, m_dwIBSize);
	UnlockIB();

	m_PrimType = D3DPT_TRIANGLELIST;

	return 1;
}

//-----------------------------------------------------------------------------
// Name: GenNormals
// Desc: Generate vertex normals for a model and returns a pointer to
//       the memory allocated to store them.
//       *Note that this routine allocates memory that must be freed
//       manually.
//-----------------------------------------------------------------------------
D3DVECTOR *CXModel::GenNormals(DWORD nvert, D3DVECTOR *vert, DWORD ntri, WORD *trilist)
{
	DWORD i, v0, v1, v2;
	D3DVECTOR *tnorm, *vnorm;
	D3DVECTOR d, e;

	tnorm = new D3DVECTOR[ntri];
	memset(tnorm, 0, ntri*sizeof(D3DVECTOR));
	vnorm = new D3DVECTOR[nvert];
	memset(vnorm, 0, nvert*sizeof(D3DVECTOR));

	// calculate triangle normals
	for(i=0; i<ntri; i++)
	{
		v0 = trilist[i*3+0];
		v1 = trilist[i*3+1];
		v2 = trilist[i*3+2];

		// cross product
		d.x = vert[v1].x - vert[v0].x;
		d.y = vert[v1].y - vert[v0].y;
		d.z = vert[v1].z - vert[v0].z;
		e.x = vert[v2].x - vert[v1].x;
		e.y = vert[v2].y - vert[v1].y;
		e.z = vert[v2].z - vert[v1].z;

		tnorm[i].x = d.y*e.z - d.z*e.y;
		tnorm[i].y = d.z*e.x - d.x*e.z;
		tnorm[i].z = d.x*e.y - d.y*e.x;

		// normalize result
		float ool = 1.0f/(float)sqrt(tnorm[i].x*tnorm[i].x + tnorm[i].y*tnorm[i].y + tnorm[i].z*tnorm[i].z);
		tnorm[i].x *= ool;
		tnorm[i].y *= ool;
		tnorm[i].z *= ool;

		// contribute to vertex normals
		vnorm[v0].x += tnorm[i].x;
		vnorm[v0].y += tnorm[i].y;
		vnorm[v0].z += tnorm[i].z;
		vnorm[v1].x += tnorm[i].x;
		vnorm[v1].y += tnorm[i].y;
		vnorm[v1].z += tnorm[i].z;
		vnorm[v2].x += tnorm[i].x;
		vnorm[v2].y += tnorm[i].y;
		vnorm[v2].z += tnorm[i].z;
	}

	// normalize vertex normals
	for(i=0; i<nvert; i++)
		D3DXVec3Normalize((D3DXVECTOR3 *)&vnorm[i], (D3DXVECTOR3 *)&vnorm[i]);

	delete tnorm;
	return vnorm;
}

//-----------------------------------------------------------------------------
// Name: DrawNormals
// Desc: Draw a models normals. Note that g_fNormLength is defined at the
//       top of this file and should be set appropriately based on your world
//       dimensions.
//-----------------------------------------------------------------------------
void CXModel::DrawNormals()
{
	FVFT_XYZDIFF *verts;
	D3DVECTOR *vbuf, *nbuf;
	BYTE *bptr;
	DWORD i;

	verts = new FVFT_XYZDIFF[m_dwNumVertices*2];
	vbuf = new D3DVECTOR[m_dwNumVertices];
	nbuf = new D3DVECTOR[m_dwNumVertices];

	LockVB(&bptr, 0L);
	FVF_GetVert(bptr, vbuf, 0, m_dwNumVertices, m_dwFVF);
	FVF_GetNorm(bptr, nbuf, 0, m_dwNumVertices, m_dwFVF);
	UnlockVB();

	// draw normals
	g_pd3dDevice->SetTexture(0, NULL);
	g_pd3dDevice->SetVertexShader(FVF_XYZDIFF);

    g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAOP,   D3DTOP_DISABLE);

	for(i=0; i<m_dwNumVertices; i++)
	{
		verts[i*2].v.x = vbuf[i].x;
		verts[i*2].v.y = vbuf[i].y;
		verts[i*2].v.z = vbuf[i].z;
		verts[i*2].diff = 0xffff0000;

		verts[i*2+1].v.x = g_fNormLength*nbuf[i].x + verts[i*2].v.x;
		verts[i*2+1].v.y = g_fNormLength*nbuf[i].y + verts[i*2].v.y;
		verts[i*2+1].v.z = g_fNormLength*nbuf[i].z + verts[i*2].v.z;
		verts[i*2+1].diff = 0xffff0000;
	}

	g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, FALSE);

	g_pd3dDevice->DrawPrimitiveUP(D3DPT_LINELIST, m_dwNumVertices, verts, sizeof(FVFT_XYZDIFF));

	// draw unit vector
	verts[0].v.x = 0.0f;
	verts[0].v.y = 0.0f;
	verts[0].v.z = 0.0f;
	verts[0].diff = 0xffffffff;
	verts[1].v.x = 0.0f;
	verts[1].v.y = 0.0f;
	verts[1].v.z = g_fNormLength;
	verts[1].diff = 0xffffffff;
	g_pd3dDevice->DrawPrimitiveUP(D3DPT_LINELIST, 1, verts, sizeof(FVFT_XYZDIFF));

	g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, TRUE);

	delete verts;
	delete vbuf;
	delete nbuf;
}

//-----------------------------------------------------------------------------
// Name: Read_M
// Desc: Read a .m model file.
//-----------------------------------------------------------------------------
#define MAX_MVERTS 32767
#define MAX_MTRIS 65000
DWORD CXModel::Read_M(char *fname, char *imgname, DWORD fvf, DWORD flags, void (*vfunc)(int, int, float))
{
	FILE *fp;
	D3DVECTOR *vert = NULL;
	float *uvv = NULL, f;
	WORD *trilist = NULL;
	DWORD *diff = NULL, d;
	D3DVECTOR *norm = NULL;
	bool bFoundNorm = false;

	char buf[512];
	DWORD nt, vidx, i, nvert = 0;
	DWORD tidx = 0, v0, v1, v2;

	char texname[80];
	
	// load texture
	if(imgname)
		strcpy(texname, imgname);
	else
		texname[0] = '\0';

	// load mesh
	fp = fopen(fname, "rt");
	assert(fp!=NULL);

	vert = new D3DVECTOR[MAX_MVERTS];
	memset(vert, 0, MAX_MVERTS*sizeof(D3DVECTOR));
	trilist = new WORD[MAX_MTRIS*3];
	memset(trilist, 0, MAX_MTRIS*3*sizeof(WORD));
	if(fvf&D3DFVF_NORMAL)
	{
		norm = new D3DVECTOR[MAX_MVERTS];
		memset(norm, 0, MAX_MVERTS*sizeof(D3DVECTOR));
	}
	if(fvf&D3DFVF_TEX1)
	{
		uvv = new float[MAX_MVERTS*2];
		memset(uvv, 0, MAX_MVERTS*2*sizeof(float));
	}
	if(fvf&D3DFVF_DIFFUSE)
	{
		diff = new DWORD[MAX_MVERTS];
		memset(diff, 0, MAX_MVERTS*sizeof(DWORD));
	}

	while(1)
	{
		fgets(buf, 512, fp);
		if(feof(fp))
			break;

		nt = Parse(buf, NULL);
		if(!nt)
			continue;

		if(!strcmp(tokens[0].str, "IMAGE"))
		{
			LoadTexture(tokens[1].str);
		}
		else if(!strcmp(tokens[0].str, "VERTEX"))
		{
			vidx = atoi(tokens[1].str);

			vert[vidx].x = (float)atof(tokens[2].str);
			vert[vidx].y = (float)atof(tokens[3].str);
			vert[vidx].z = (float)atof(tokens[4].str);

			for(i=5; i<nt; i++)
			{
				if(fvf&D3DFVF_NORMAL && (!strcmp(tokens[i].str, "{NORMAL=") || !strcmp(tokens[i].str, "NORMAL=")))
				{
					bFoundNorm = true;
					norm[vidx].x = (float)atof(tokens[i+1].str);
					norm[vidx].y = (float)atof(tokens[i+2].str);
					norm[vidx].z = (float)atof(tokens[i+3].str);
					i+=3;
				}
				else if(fvf&D3DFVF_TEX1 && (!strcmp(tokens[i].str, "{UV=") || !strcmp(tokens[i].str, "UV=")))
				{
					uvv[vidx*2] = (float)atof(tokens[i+1].str);
					uvv[vidx*2+1] = (float)atof(tokens[i+2].str);
					i+=2;
				}
				else if(!strncmp(tokens[i].str, "EYELIDWT", 8) && vfunc)			// check for eyelid weights & receiving function
				{
					f = (float)atof(tokens[i+1].str);
					if(tokens[i].str[8]=='L')
						vfunc(MFP_EYEWT, 0x10000|vidx, -f);
					else
						vfunc(MFP_EYEWT, vidx, f);
					i+=1;
				}
			}

			if(vidx+1>nvert)
				nvert = vidx+1;
		}
		else if(!strcmp(tokens[0].str, "FACE"))
		{
			v0 = atoi(tokens[2].str);
			v1 = atoi(tokens[3].str);
			v2 = atoi(tokens[4].str);

			if(fvf&D3DFVF_DIFFUSE)
				for(i=5; i<nt; i++)
				{
					if(!strcmp(tokens[i].str, "RGB="))
					{
						d = (DWORD)((float)atof(tokens[i+1].str)*255.0f);
						d<<=8;
						d |= (DWORD)((float)atof(tokens[i+2].str)*255.0f);
						d<<=8;
						d |= (DWORD)((float)atof(tokens[i+3].str)*255.0f);

						diff[v0] = d;
						diff[v1] = d;
						diff[v2] = d;

						i+=3;
					}
				}

			trilist[tidx] = (WORD)v0;
			tidx++;
			trilist[tidx] = (WORD)v1;
			tidx++;
			trilist[tidx] = (WORD)v2;
			tidx++;
		}
	}

	fclose(fp);

	Build(nvert, vert, tidx/3, tidx, trilist, uvv, bFoundNorm ? norm : NULL, diff, fvf, flags);
	
	if(texname[0])
		LoadTexture(texname);

	if(vert)
		delete vert;
	if(trilist)
		delete trilist;
	if(norm)
		delete norm;
	if(uvv)
		delete uvv;
	if(diff)
		delete diff;

	return 1;
}
//-----------------------------------------------------------------------------
// Name: Sphere
// Desc: Generate a sphere model and texture it with imgname.
//-----------------------------------------------------------------------------
#define PI 3.14159f
#define TWOPI (2*PI)
DWORD CXModel::Sphere(float radius, DWORD tessx, DWORD tessy, DWORD fvf, char *imgname, float txscale)
{
	DWORD tidx;
	D3DVECTOR *vert;		// vertices
	WORD *tlist;			// triangle indices
	float *tc;				// index texcoords
	DWORD row, col;
	float ra, rr, ss, cc;
	DWORD vidx, *diff;

	vert = new D3DVECTOR[tessx*tessy];
	tlist = new WORD[(tessy-1)*(tessx-1)*6];
	tc = new float[tessx*tessy*2];

	// vertices
	for(row=0; row<tessy; row++)
	{
		ra = (float)row/(float)(tessy-1)*(PI*0.875f)+(PI*0.0625f);
		rr = radius * (float)sin(ra);

		for(col=0; col<tessx; col++)
		{
			vidx = row*tessx+col;
			ss = (float)sin(TWOPI*(float)(col)/(float)(tessx-1));
			cc = (float)cos(TWOPI*(float)(col)/(float)(tessx-1));

			vert[vidx].x = -rr*ss;
			vert[vidx].y = radius*(float)cos(ra);
			vert[vidx].z = rr*cc;

			tc[vidx*2] = txscale*(float)col/(float)(tessx-1);
			tc[vidx*2+1] = txscale*(float)row/(float)(tessy-1);
		}
	}

	// triangles
	tidx = 0;
	for(row=0; row<tessy-1; row++)
		for(col=0; col<tessx-1; col++)
		{
			tlist[tidx++] = (WORD)(row*tessx+col);
			tlist[tidx++] = (WORD)(row*tessx+col+1);
			tlist[tidx++] = (WORD)((row+1)*tessx+col);
			tlist[tidx++] = (WORD)((row+1)*tessx+col);
			tlist[tidx++] = (WORD)(row*tessx+col+1);
			tlist[tidx++] = (WORD)((row+1)*tessx+col+1);
		}

	if(fvf&D3DFVF_DIFFUSE)
	{
		diff = new DWORD[tessx*tessy];
		for(row=0; row<tessx*tessy; row++)
			diff[row] = (rand()<<16) | rand() | 0xff000000; 
	}
	else
		diff = NULL;


	Build(tessx*tessy, vert, tidx/3, tidx, tlist, tc, NULL, diff, fvf, 0);

	if(fvf&D3DFVF_DIFFUSE)
		delete diff;

    if(imgname)
		LoadTexture(imgname);

	delete vert;
	delete tlist;
	delete tc;

	return 1;
}

//-----------------------------------------------------------------------------
// Name: GridXZ
// Desc: Generate an XZ grid model.
//-----------------------------------------------------------------------------
DWORD CXModel::GridXZ(DWORD tessx, DWORD tessz, float xsize, float zsize, DWORD fvf, char *imgname, float texx, float texz)
{
	DWORD tidx, i;
	D3DVECTOR *vert;		// vertices
	D3DVECTOR *norm;
	WORD *tlist;			// triangle indices
	float *tc;				// index texcoords
	DWORD row, col;
	DWORD vidx;

	// clear normal flag because GenNormals does not support tristrips
	if(fvf&D3DFVF_NORMAL)
	{
		norm = new D3DVECTOR[tessx*tessz];
		ZeroMemory(norm, tessx*tessz*sizeof(D3DVECTOR));
		for(i=0; i<tessx*tessz; i++)
			norm[i].y = 1.0f;
	}
	else
		norm = NULL;

	vert = new D3DVECTOR[tessx*tessz];
	tlist = new WORD[(tessz-1)*(tessx-1)*6];
	tc = new float[tessx*tessz*2];

	// vertices, texcoords
	for(row=0; row<tessz; row++)
	{
		for(col=0; col<tessx; col++)
		{
			vidx = row*tessx+col;

			vert[vidx].x = (float)col*(xsize/(float)(tessx-1)) - (xsize/2.0f);
			vert[vidx].y = 0.0f;
			vert[vidx].z = (float)row*(zsize/(float)(tessz-1)) - (zsize/2.0f);

			tc[vidx*2] = (vert[vidx].z+(xsize/2.0f))/texz;
			tc[vidx*2+1] = (vert[vidx].x+(zsize/2.0f))/texx;
		}
	}
	
	// triangles
	tidx = 0;
	for(row=0; row<tessz-1; row++)
	{
		for(col=0; col<tessx; col++)
		{
			// add duplicate vertex for new row
			// (except on first row)
			if(col==0 && row!=0)
				tlist[tidx++] = (WORD)((row*tessx+col)&0xffff);

			tlist[tidx++] = (WORD)((row*tessx+col)&0xffff);
			tlist[tidx++] = (WORD)(((row+1)*tessx+col)&0xffff);
		}

		// add duplicate vertex at end of row
		// (except on last row)
		if(row!=(tessz-1))
		{
			tlist[tidx] = tlist[tidx-1];
			tidx++;
		}
	}

	Build(tessx*tessz, vert, tidx-2, tidx, tlist, tc, norm, NULL, fvf, 0);
	m_PrimType = D3DPT_TRIANGLESTRIP;

	if(imgname)
		LoadTexture(imgname);

	if(norm)
		delete norm;

	delete vert;
	delete tlist;
	delete tc;

	return 1;
}

//-----------------------------------------------------------------------------
// Name: Cylinder
// Desc: Generate a cylinder model and texture it with imgname.
//-----------------------------------------------------------------------------
DWORD CXModel::Cylinder(float rad0, DWORD diff0, float rad1, DWORD diff1, float len, DWORD tess, DWORD fvf, char *imgname, float txscale)
{
	DWORD tidx;
	D3DVECTOR *vert;		// vertices
	WORD *tlist;			// triangle indices
	float *tc;				// index texcoords
	DWORD col;
	float ss, cc;
	DWORD *diff;

	vert = new D3DVECTOR[tess*2];		// top & bottom disc
	tlist = new WORD[tess*2*3];			// 2 * tess * 3/tri
	tc = new float[tess*2*2];			// 2 * tess * 2/tri

	// vertices
	for(col=0; col<tess; col++)
	{
		ss = (float)sin(TWOPI*(float)(col)/(float)(tess-1));
		cc = (float)cos(TWOPI*(float)(col)/(float)(tess-1));

		// top disc
		vert[col].x = -rad0*ss;
		vert[col].y = rad0*cc;
		vert[col].z = 0.0f;

		// bottom disc
		vert[col+tess].x = -rad1*ss;
		vert[col+tess].y = rad1*cc;
		vert[col+tess].z = len;

		// texture samples
		tc[col*2] = txscale*(float)col/(float)(tess-1);
		tc[col*2+1] = 0.0f;
		tc[(col+tess)*2] = tc[col*2];
		tc[(col+tess)*2+1] = 1.0f;
	}

	// triangles
	tidx = 0;
	for(col=0; col<tess; col++)
	{
		tlist[tidx++] = (WORD)(col);
		tlist[tidx++] = (WORD)((col+1)%tess);
		tlist[tidx++] = (WORD)((col+tess+1)%(tess*2));
		tlist[tidx++] = tlist[tidx-3];
		tlist[tidx++] = tlist[tidx-2];
		tlist[tidx++] = (WORD)((col+tess)%(tess*2));
	}

	if(fvf&D3DFVF_DIFFUSE)
	{
		diff = new DWORD[tess*2];
		for(col=0; col<tess; col++)
		{
			diff[col] = diff0;
			diff[col+tess] = diff1;
		}
	}
	else
		diff = NULL;


	Build(tess*2, vert, tidx/3, tidx, tlist, tc, NULL, diff, fvf, 0);

	if(fvf&D3DFVF_DIFFUSE)
		delete diff;

    if(imgname)
		LoadTexture(imgname);

	delete vert;
	delete tlist;
	delete tc;

	return 1;
}

//-----------------------------------------------------------------------------
// Name: Render
// Desc: Render a model. Note that render/texture state needs to be
//       set before you call this routine.
//-----------------------------------------------------------------------------
DWORD CXModel::Render()
{
	g_pd3dDevice->SetTexture(0, m_pTexture);
	g_pd3dDevice->SetVertexShader(m_dwVShader);
	g_pd3dDevice->SetIndices(m_pIB, 0);
	g_pd3dDevice->SetStreamSource(0, m_pVB, m_dwVBStride);
	g_pd3dDevice->DrawIndexedPrimitive(m_PrimType, 0, m_dwNumVertices, 0, m_dwNumTriangles);

	return 1;
}

//-----------------------------------------------------------------------------
// Name: LoadTexture
// Desc: Load a texture for use in a model.
//-----------------------------------------------------------------------------
void CXModel::LoadTexture(char *imgname)
{
	if(g_pModelResource!=NULL)
		m_pTexture = g_pModelResource->GetTexture(imgname);

	if(!m_pTexture)
	{
		OutputDebugStringA("XModel: Error getting texture from resource file: ");
		OutputDebugStringA(imgname);
		OutputDebugStringA("\n");
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\src\xobj.cpp ===
//-----------------------------------------------------------------------------
// File: xobj.cpp
//
// Desc: routines for displaying objects
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "xmodel.h"
#include "xobj.h"

extern LPDIRECT3DDEVICE8 g_pd3dDevice;

//-----------------------------------------------------------------------------
// Constructor and destructor
//-----------------------------------------------------------------------------
CXObject::CXObject()
{
    // clear out relevant fields

    m_Model = NULL;
    m_pXBMesh = NULL;

    SetPosition(0.0f, 0.0f, 0.0f);
    SetRotation(0.0f, 0.0f, 0.0f);
    D3DXMatrixIdentity(&m_matOrientation);
    m_Material = NULL;

    m_dwFlags = 0;
    m_dwType = 0;
    m_pvInfo = NULL;
}

CXObject::~CXObject()
{
    if(m_Model)
        m_Model->Release();
#ifdef _XBOX
    if(m_pXBMesh)
        m_pXBMesh->Release();
#endif
}

//-----------------------------------------------------------------------------
// Name: SetModel
// Desc: Set the model for this object.
//-----------------------------------------------------------------------------
void CXObject::SetModel(CXModel *model)
{
    if(m_Model)                         // release existing model
        m_Model->Release();
#ifdef _XBOX
    else if(m_pXBMesh)
    {
        m_pXBMesh->Release();
        m_pXBMesh = NULL;
    }
#endif

    if(model)
        model->AddRef();                // addref to new model
    m_Model = model;                    // set new model pointer
}


#ifdef _XBOX
//-----------------------------------------------------------------------------
// Name: SetXBG
// Desc: Set the XBMesh for this object.
//-----------------------------------------------------------------------------
void CXObject::SetXBMesh(CXBMesh *xbm)
{
    if(m_pXBMesh)
        m_pXBMesh->Release();
    else if(m_Model)
    {
        m_Model->Release();
        m_Model = NULL;
    }

    if(xbm)
        xbm->AddRef();                  // addref to new xbg
    m_pXBMesh = xbm;                    // set new model pointer
}
#endif

//-----------------------------------------------------------------------------
// Name: GetRadius functions
// Desc: Since objects can be either CXModel or CXBGMesh, we return a
//       radius based on which is active.
//-----------------------------------------------------------------------------
float CXObject::GetRadius()
{
    if(m_Model)
    {
        return m_Model->m_fRadius;
    }
    else if(m_pXBMesh)
    {
        return m_pXBMesh->ComputeRadius();
    }

    return 0.0f;
}

float CXObject::GetRadius2()
{
    if(m_Model)
    {
        return m_Model->m_fRadius2;
    }
    else if(m_pXBMesh)
    {
        float fRadius = m_pXBMesh->ComputeRadius();
        return fRadius*fRadius;
    }

    return 0.0f;
}

//-----------------------------------------------------------------------------
// Name: Render
// Desc: Calculate an objects matrix, set its relevant material, and
//       render its model.
//-----------------------------------------------------------------------------
void CXObject::Render(int flags)
{
    // set the position and orientation of the object
    if(!(flags&OBJ_NOMCALCS))
        CrunchMatrix();

    g_pd3dDevice->SetTransform(D3DTS_WORLD, &m_matOrientation);

    // set material
    if(m_Material)
        g_pd3dDevice->SetMaterial(m_Material);
    
    // render
#ifdef _XBOX
    if(m_Model)
        m_Model->Render();
    else if(m_pXBMesh)
        m_pXBMesh->Render(g_pd3dDevice, 0);
#else
    m_Model->Render();
#endif
}

//-----------------------------------------------------------------------------
// Name: CrunchMatrix
// Desc: Calculate an objects matrix.
//-----------------------------------------------------------------------------
void CXObject::CrunchMatrix()
{
    D3DXMATRIX m;

    D3DXMatrixRotationYawPitchRoll(&m_matOrientation, m_vRotation.y, m_vRotation.x, m_vRotation.z);
    D3DXMatrixTranslation(&m, m_vPosition.x, m_vPosition.y, m_vPosition.z);
    D3DXMatrixMultiply(&m_matOrientation, &m_matOrientation, &m);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\src\xparse.cpp ===
//-----------------------------------------------------------------------------
// File: parse.cpp
//
// Desc: Routines to parse a string into distinct tokens.
//       Should probably be called tokenize...
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <string.h>
#include "xparse.h"

Token tokens[MAX_TOKENS];

//-----------------------------------------------------------------------------
// Name: ParseTok
// Desc: Parse a string into its relevant token from the Parse Block
//-----------------------------------------------------------------------------
int ParseTok(char *string, struct sParseBlk *pb)
{
	int idx;

	idx = 0;

	while(pb[idx].val!=TOK_ERR)
	{
		if(!_stricmp(string, pb[idx].str))
			return pb[idx].val;

		idx++;
	}

	return TOK_ERR;
}

//-----------------------------------------------------------------------------
// Name: Parse
// Desc: Generate distinct tokens from a string
//-----------------------------------------------------------------------------
int	Parse(char *string, struct sParseBlk *pb)
{
	int	i, ntok;
	char *sp, *tp;
	char parsestr[256];

	strncpy(parsestr, string, 256);
	_strupr(parsestr);
	sp = parsestr;

	ntok = 0;

	while ((*sp!=0) && (ntok<MAX_TOKENS) && (*sp!=';') && (*sp!='\n')) 
	{
		while(*sp==' ' || *sp=='\t')
			sp++;

		tp = tokens[ntok].str;
		while(  (*sp!=0) && (*sp!=' ') && (*sp!='\t') && 
				(*sp!=',') && (*sp!='\n') && (*sp!='(') &&
				(*sp!=')') && (*sp!=13) )
			*tp++ = *sp++;

		*tp = 0;
		ntok++;

		if(*sp)
			sp++;
	}

	// parse all the tokens
	if(pb)
		for(i=0; i<ntok; i++)
			tokens[i].val = ParseTok(tokens[i].str, pb);

	return ntok;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\src\xpath.cpp ===
//-----------------------------------------------------------------------------
// File: xpath.cpp
//
// Desc: Routines to help us point to the right data files.
//
// Note: If you dont specify an out pointer in GetFileName, the routine
//       will use g_tstrXPathFileName[] to store the resulting file/path
//       info and return a pointer to it. The maximum number of these
//       that can exist at one time is defined by MAX_XPATHS.
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifdef _XBOX
#include <xtl.h>
#else
#include <windows.h>
#endif
#include <tchar.h>
#include "xpath.h"

#define MAX_XPATHS 4
DWORD g_dwXPathCurPathIdx = 0;
TCHAR g_tstrXPathBasePathT[MAX_PATH];
char g_tstrXPathBasePathA[MAX_PATH];
WORD g_tstrXPathFileName[MAX_XPATHS][MAX_PATH];

//-----------------------------------------------------------------------------
// Name: XPath_SetBasePath
// Desc: Set the base path for all our files
//-----------------------------------------------------------------------------
void XPath_SetBasePath(TCHAR *path)
{
	_tcsncpy(g_tstrXPathBasePathT, path, MAX_PATH);
	if(sizeof(TCHAR)==sizeof(WCHAR))
		WideCharToMultiByte(CP_ACP, 0, (WCHAR *)path, -1, g_tstrXPathBasePathA, MAX_PATH, NULL, NULL);
	else
		strncpy(g_tstrXPathBasePathA, (char *)path, MAX_PATH);
}

//-----------------------------------------------------------------------------
// Name: XPath_GetFileNameT
// Desc: TCHAR version of GetFileName
//-----------------------------------------------------------------------------
TCHAR *XPath_GetFileNameT(TCHAR *in, TCHAR *out)
{
	if(!out)
	{
		out = (TCHAR *)g_tstrXPathFileName[g_dwXPathCurPathIdx];
		g_dwXPathCurPathIdx = (g_dwXPathCurPathIdx+1)&(MAX_XPATHS-1);
	}

	_tcscpy(out, g_tstrXPathBasePathT);
	_tcscat(out, in);

	return out;
}

//-----------------------------------------------------------------------------
// Name: XPath_GetFileNameA
// Desc: char version of GetFileName
//-----------------------------------------------------------------------------
char *XPath_GetFileNameA(char *in, char *out)
{
	if(!out)
	{
		out = (char *)g_tstrXPathFileName[g_dwXPathCurPathIdx];
		g_dwXPathCurPathIdx = (g_dwXPathCurPathIdx+1)&(MAX_XPATHS-1);
	}

	strcpy(out, g_tstrXPathBasePathA);
	strcat(out, in);

	return out;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\cover35src\bbt\bbreg.h ===
#ifndef __BBREG_H__
#define __BBREG_H__

#ifndef DWORD
#define DWORD unsigned long
#endif

#include "md5.h"

#define BBREG_VERSION	0x00030002

typedef struct _BBREG_HEADER	BBREG_HEADER,	*PBBREG_HEADER;

struct _BBREG_HEADER {
	DWORD	dwVersion;
	DWORD	dwSizeOfBBRegHeader;
	DWORD	dwOffsetOfBinaryName;
	DWORD	dwOffsetOfGUID;
	DWORD	dwOffsetOfLoggingRegion;
	DWORD	dwCheckSumOfBinary;
	PCHAR	pBaseOfLoggingRegion;
	DWORD	dwSizeOfLoggingRegion;
};


#endif __BBREG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\common\src\xtextbox.cpp ===
#include <xtl.h>
#include <assert.h>

#include "xtextbox.h"

extern LPDIRECT3DDEVICE8 g_pd3dDevice;

CXBFont *XTextBox_Font=NULL;
DWORD XTextBox_FontLoaded = FALSE;
void XTextBox_DrawRect(float x, float y, float w, float h, DWORD dwTopColor, DWORD dwBottomColor);

void XTextBox_SetFont(CXBFont *font)
{
	XTextBox_Font = font;
}

XTextBox *XTextBox_Init(float x, float y, float w, DWORD maxitems, DWORD flags)
{
	XTextBox *xbox;		// pun intended
	BYTE *mem;

	assert(XTextBox_Font!=NULL);

	// bump maxitems for circular array padding
	maxitems++;

	// allocate memory for textbox
	mem = new BYTE[sizeof(XTextBox) + maxitems*sizeof(XTextBoxItem)];
	memset(mem, 0, sizeof(XTextBox) + maxitems*sizeof(XTextBoxItem));

	xbox = (XTextBox *)mem;
	xbox->items = (XTextBoxItem *)(mem+sizeof(XTextBox));
	xbox->flags = flags;

	xbox->maxitems = maxitems;
	xbox->maxshow = (maxitems-1);
	xbox->textcolor = 0xffffffff;

	xbox->topcolor = 0x40000000;
	xbox->bottomcolor = 0x40000000;

	xbox->x = x;
	xbox->y = y;
	xbox->w = w;
	xbox->h = (float)(xbox->maxshow+1)*XTextBox_Font->GetFontHeight();

	return xbox;
}

XTextBoxItem *XTextBox_AddItem(XTextBox *xbox, WCHAR *string)
{
	XTextBoxItem *item;

	if(!string)
		return NULL;

	// copy string to tail
	item = &xbox->items[xbox->tail];
	wcsncpy(item->string, string, TBOX_STRINGLEN-1);

	// set color
	item->color = xbox->textcolor;

	// set expire time
	item->expiretime = GetTickCount() + xbox->expiretime;
	
	// bump tail pointer
	xbox->tail++;
	if(xbox->tail==xbox->maxitems)
		xbox->tail = 0;

	// bump head if necessary
	if(xbox->head==xbox->tail)
	{
		xbox->head++;
		if(xbox->head==xbox->maxitems)
			xbox->head = 0;
	}

	// return pointer to the item we just added
	return item;
}

// Draw the textbox
// Only draw the background if it has color specified.
// If TBOX_POPUP is specified, only draw background if there is visible text.
void XTextBox_Display(XTextBox *xbox)
{
	DWORD idx, cnt=0;
	float itemx, itemy;

	// expire stale entries
	if(xbox->expiretime>0)
		XTextBox_Expire(xbox);

	// check for empty textbox and draw background if appropriate
	if(xbox->head==xbox->tail)
	{
		if(!(xbox->flags&TBOX_POPUP) && (xbox->topcolor!=0 && xbox->bottomcolor!=0))
			XTextBox_DrawRect(xbox->x, xbox->y, xbox->w, xbox->h, xbox->topcolor, xbox->bottomcolor);
		return;		// return if no items to display
	}
	else if(xbox->topcolor!=0 && xbox->bottomcolor!=0)
		XTextBox_DrawRect(xbox->x, xbox->y, xbox->w, xbox->h, xbox->topcolor, xbox->bottomcolor);

	// draw the text
	itemx = xbox->x + 8.0f;
	itemy = xbox->y + XTextBox_Font->GetFontHeight()*0.5f;

	idx = xbox->head;
	do
	{
		XTextBox_Font->DrawText(itemx, itemy, xbox->items[idx].color, xbox->items[idx].string);
		itemy += XTextBox_Font->GetFontHeight();
		
		// bump index & count
		idx++;
		if(idx==xbox->maxitems)
			idx = 0;
		cnt++;

	} while((idx!=xbox->tail) && (cnt<xbox->maxshow));
}

void XTextBox_Expire(XTextBox *xbox)
{
	DWORD time;

	if(xbox->head==xbox->tail)
		return;

	time = GetTickCount();

	while((time>xbox->items[xbox->head].expiretime) && (xbox->head!=xbox->tail))
	{
		xbox->head++;
		if(xbox->head==xbox->maxitems)
			xbox->head = 0;
	}
}

//-----------------------------------------------------------------------------
// Name: DrawRect
// Desc: Draws a gradient filled rectangle
//-----------------------------------------------------------------------------
void XTextBox_DrawRect(float x, float y, float w, float h, DWORD dwTopColor, DWORD dwBottomColor)
{
    static LPDIRECT3DVERTEXBUFFER8 XMenu_VB = NULL;
    struct BACKGROUNDVERTEX 
	{ 
		D3DXVECTOR4 p; 
		D3DCOLOR color; 
	} *v;

    if(XMenu_VB == NULL)
        g_pd3dDevice->CreateVertexBuffer(4*sizeof(BACKGROUNDVERTEX), D3DUSAGE_WRITEONLY, 
                                          0L, D3DPOOL_DEFAULT, &XMenu_VB);

    // Setup vertices for a background-covering quad
	XMenu_VB->Lock(0, 0, (BYTE **)&v, 0L);
    v[0].p = D3DXVECTOR4(x, y, 1.0f, 1.0f);
	v[0].color = dwTopColor;
    v[1].p = D3DXVECTOR4(x+w, y, 1.0f, 1.0f);
	v[1].color = dwTopColor;
    v[2].p = D3DXVECTOR4(x, y+h, 1.0f, 1.0f); 
	v[2].color = dwBottomColor;
    v[3].p = D3DXVECTOR4(x+w, y+h, 1.0f, 1.0f);
	v[3].color = dwBottomColor;
	XMenu_VB->Unlock();

	// set render states
    g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE); 
	g_pd3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
	g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
	g_pd3dDevice->SetRenderState(D3DRS_ZENABLE, FALSE);

    // Set states
    g_pd3dDevice->SetTexture(0, NULL);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_DISABLE);
    g_pd3dDevice->SetVertexShader(D3DFVF_XYZRHW|D3DFVF_DIFFUSE);
    g_pd3dDevice->SetStreamSource(0, XMenu_VB, sizeof(BACKGROUNDVERTEX));

    // Render the quad
    g_pd3dDevice->DrawPrimitive(D3DPT_TRIANGLESTRIP, 0, 2);

	// restore render state
    g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE); 
	g_pd3dDevice->SetRenderState(D3DRS_ZENABLE, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\cover35src\covfile\covfile.c ===
#pragma warning( disable: 4200 )    // zero sized array in structure
#pragma warning( disable: 4201 )    // nameless struct/union
#pragma warning( disable: 4213 )    // cast on l-value
#pragma warning( disable: 4214 )    // bitfields other than int
#pragma warning( disable: 4514 )    // unreferenced inline function

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN 1
#endif

#include <windows.h>
#pragma warning( disable: 4200 4201 4213 4214 4514 )
#include "covfile.h"

unsigned int __cdecl _rotl( unsigned int value, int shift );

#pragma intrinsic( strlen, _rotl )

#pragma optimize( "at", on )    // optimize for speed and assume no aliasing

VOID
PackByteVectorToBitVector(
    IN  DWORD ByteCount,
    IN  PBYTE ByteVector,
    OUT PBYTE BitVector
    )
    {
    DWORD EightByteCount;
    DWORD BitsRemaining;
    DWORD Source1;
    DWORD Source2;
    DWORD PadBits;
    DWORD PackedByte;

    EightByteCount = ByteCount / 8;

    while ( EightByteCount-- ) {

        Source1 = ( *(DWORD*)( ByteVector     )) & 0x01010101;
        Source2 = ( *(DWORD*)( ByteVector + 4 )) & 0x01010101;

        ByteVector += 8;

        *BitVector++ = (BYTE)(( Source1 <<  7 ) | ( Source2 <<  3 ) |
                              ( Source1 >>  2 ) | ( Source2 >>  6 ) |
                              ( Source1 >> 11 ) | ( Source2 >> 24 ) |
                              ( Source1 >> 20 ) | ( Source2 >> 15 ));
        }

    BitsRemaining = ByteCount & 7;

    if ( BitsRemaining ) {

        PadBits    = 8 - BitsRemaining;
        PackedByte = 0;

        while ( BitsRemaining-- ) {
            PackedByte = ( PackedByte << 1 ) | ( *ByteVector++ & 1 );
            }

        *BitVector = (BYTE)( PackedByte << PadBits );

        }
    }


VOID
UnpackBitVectorToByteVector(
    IN  DWORD BitCount,
    IN  PBYTE BitVector,
    OUT PBYTE ByteVector
    )
    {
    DWORD EightBitCount;
    DWORD BitsRemaining;
    DWORD Target1;
    DWORD Target2;
    DWORD PackedByte;

    EightBitCount = BitCount / 8;

    while ( EightBitCount-- ) {

        PackedByte = *BitVector++;

        Target1 = (( PackedByte >>  7 ) |
                   ( PackedByte <<  2 ) |
                   ( PackedByte << 11 ) |
                   ( PackedByte << 20 ));

        Target2 = (( PackedByte >>  3 ) |
                   ( PackedByte <<  6 ) |
                   ( PackedByte << 15 ) |
                   ( PackedByte << 24 ));

        *(DWORD*)( ByteVector )     = Target1 & 0x01010101;
        *(DWORD*)( ByteVector + 4 ) = Target2 & 0x01010101;

        ByteVector += 8;

        }

    BitsRemaining = BitCount & 7;

    if ( BitsRemaining ) {

        PackedByte = *BitVector;

        while ( BitsRemaining-- ) {
            *ByteVector++ = (BYTE)(( PackedByte & 0x80 ) >> 7 );
            PackedByte <<= 1;
            }
        }
    }


VOID
OrBufferWithBuffer(
    IN PVOID TargetBuffer,
    IN PVOID SourceBuffer,
    IN ULONG Size
    )
    {
    ULONG CountLongs = Size / 4;
    ULONG CountBytes = Size & 3;

    while ( CountLongs-- ) {
        *((UNALIGNED ULONG*) TargetBuffer )++ |= *((UNALIGNED ULONG*) SourceBuffer )++;
        }

    while ( CountBytes-- ) {
        *((UNALIGNED UCHAR*) TargetBuffer )++ |= *((UNALIGNED UCHAR*) SourceBuffer )++;
        }
    }


VOID
XorBufferWithBuffer(
    IN PVOID TargetBuffer,
    IN PVOID SourceBuffer,
    IN ULONG Size
    )
    {
    ULONG CountLongs = Size / 4;
    ULONG CountBytes = Size & 3;

    while ( CountLongs-- ) {
        *((UNALIGNED ULONG*) TargetBuffer )++ ^= *((UNALIGNED ULONG*) SourceBuffer )++;
        }

    while ( CountBytes-- ) {
        *((UNALIGNED UCHAR*) TargetBuffer )++ ^= *((UNALIGNED UCHAR*) SourceBuffer )++;
        }
    }


VOID
BufferAndNotBuffer(
    IN PVOID TargetBuffer,
    IN PVOID SourceBuffer,
    IN ULONG Size
    )
    {
    ULONG CountLongs = Size / 4;
    ULONG CountBytes = Size & 3;

    while ( CountLongs-- ) {
        *((UNALIGNED ULONG*) TargetBuffer )++ &= ~( *((UNALIGNED ULONG*) SourceBuffer )++ );
        }

    while ( CountBytes-- ) {
        *((UNALIGNED UCHAR*) TargetBuffer )++ &= ~( *((UNALIGNED UCHAR*) SourceBuffer )++ );
        }
    }


ULONG
__inline
CountBitsSetInValue(
    IN ULONG Value
    )
    {
    ULONG Count = 0;

    while ( Value != 0 ) {
        Count += ( Value & 1 );
        Value >>= 1;
        }

    return Count;
    }


ULONG
CountBitsSetInBuffer(
    IN PVOID Buffer,
    IN ULONG Size
    )
    {
    ULONG CountLongs = Size / 4;
    ULONG CountBytes = Size & 3;
    ULONG CountBits  = 0;

    while ( CountLongs-- ) {
        CountBits += CountBitsSetInValue( *((UNALIGNED ULONG*) Buffer )++ );
        }

    while ( CountBytes-- ) {
        CountBits += CountBitsSetInValue( *((UNALIGNED UCHAR*) Buffer )++ );
        }

    return CountBits;
    }


BOOL
DoesBufferContainAllZeros(
    IN PVOID Buffer,
    IN DWORD Size
    )
    {
    ULONG CountLongs = Size / 4;
    ULONG CountBytes = Size & 3;

    while ( CountLongs-- ) {
        if ( *((UNALIGNED ULONG*) Buffer )++ ) {
            return FALSE;
            }
        }

    while ( CountBytes-- ) {
        if ( *((UNALIGNED UCHAR*) Buffer )++ ) {
            return FALSE;
            }
        }

    return TRUE;
    }


BOOL
DoesBufferContainOnlyHex01s(
    IN PVOID Buffer,
    IN DWORD Size
    )
    {
    ULONG CountLongs = Size / 4;
    ULONG CountBytes = Size & 3;

    while ( CountLongs-- ) {
        if (( *((UNALIGNED ULONG*) Buffer )++ ) & 0xFEFEFEFE ) {
            return FALSE;
            }
        }

    while ( CountBytes-- ) {
        if (( *((UNALIGNED UCHAR*) Buffer )++ ) & 0xFE ) {
            return FALSE;
            }
        }

    return TRUE;
    }


ULONG
HashName(                   // case insensitive
    IN LPCSTR Name
    )
    {
    ULONG Length = strlen( Name );
    ULONG Hash   = ~ Length;

    while ( Length-- )
        Hash = _rotl( Hash, 3 ) ^ ( *Name++ & 0xDF );     // mask case bit

    return Hash;
    }


#pragma optimize( "", on )      // restore to default optimizations
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\cover35src\dll20\coverdll.h ===
#ifndef _COVERAGE_H_
#define _COVERAGE_H_

#ifndef INLINE
#define INLINE __inline
#endif

#ifndef STDCALL
#define STDCALL __stdcall
#endif

#ifndef DECLSPEC
#define DECLSPEC __declspec( dllimport )
#endif

#include "bbreg.h"

typedef struct _REGISTERED_BINARY REGISTERED_BINARY, *PREGISTERED_BINARY;

struct _REGISTERED_BINARY {
    PREGISTERED_BINARY pNext;           // singly linked list
    PCHAR  pBaseOfLoggingRegion;
    PCHAR  pEndOfLoggingRegion;
    DWORD  dwCheckSumOfBinary;
	MD5_HASH	md5;
    CHAR   szBinaryName[ 1 ];           // variable length, multiple of 4 bytes
    };

//
//  Exported routines from coverage.dll
//

DECLSPEC
BOOL
STDCALL
CoverageRegisterBinary(
    IN LPCSTR pszBinaryName,            // must be lowercase or case consistent
    IN DWORD  dwCheckSumOfBinary,       // checksum of original binary
    IN PCHAR  pBaseOfLoggingRegion,     // instrumented logging region base
    IN DWORD  dwSizeOfLoggingRegion     // instrumented logging region size
    );

DECLSPEC
BOOL
STDCALL
CoverageRegisterBinaryNotSharedRegion(
    IN LPCSTR pszBinaryName,            // must be lowercase or case consistent
	IN LPCSTR pszGUID,
    IN DWORD  dwCheckSumOfBinary,       // checksum of original binary
    IN PCHAR  pBaseOfLoggingRegion,     // instrumented logging region base
    IN DWORD  dwSizeOfLoggingRegion     // instrumented logging region size
    );

DECLSPEC
BOOL
STDCALL
CoverageRegisterBinaryWithStruct(
	IN PBBREG_HEADER	pBBStruct
	);

DECLSPEC
BOOL
STDCALL
CoverageUnregisterBinary(
    IN LPCSTR pszBinaryName            // must be lowercase or case consistent
    );

DECLSPEC
BOOL
STDCALL
CoverageEnumerateBinaries(
    IN  DWORD  dwSizeOfBuffer,
    OUT PCHAR  pBuffer,
    OUT PDWORD pdwSizeOfData
    );

DECLSPEC
BOOL
STDCALL
CoveragePollLogging(
    IN  LPCSTR  pszBinaryName,                // must be lowercase
    IN  DWORD   dwSizeOfBuffer,
    OUT PVOID   pBuffer,
    OUT PDWORD  pdwSizeOfData,
    OUT PDWORD  pdwCheckSumOfBinary,
	OUT PMD5_HASH pMD5
    );

DECLSPEC
BOOL
STDCALL
CoverageFlushLogging(
    IN LPCSTR pszBinaryName OPTIONAL        // must be lowercase if specified
    );

DECLSPEC
VOID
STDCALL
CoverageGetSharedLoggingRegion(
    OUT PCHAR *ppBaseOfRegion,
    OUT DWORD *pdwSizeOfRegion
    );

DECLSPEC
DWORD
STDCALL
CoverageGetDllVersion(
     VOID
     );

#define COVERAGE_DLL_VERSION ( 0x00020002 ) // rev this if change interface

#endif /* _COVERAGE_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\cover35src\md5\md5.h ===
/*
 ***********************************************************************
 ** md5.h -- Header file for implementation of MD5                    **
 ** RSA Data Security, Inc. MD5 Message-Digest Algorithm              **
 ** Created: 2/17/90 RLR                                              **
 ** Revised: 12/27/90 SRD,AJ,BSK,JT Reference C version               **
 ** Revised (for MD5): RLR 4/27/91                                    **
 **   -- G modified to have y&~z instead of y&z                       **
 **   -- FF, GG, HH modified to add in last register done             **
 **   -- Access pattern: round 2 works mod 5, round 3 works mod 3     **
 **   -- distinct additive constant for each step                     **
 **   -- round 4 added, working mod 7                                 **
 ***********************************************************************
 */

/*
 ***********************************************************************
 ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved.  **
 **                                                                   **
 ** License to copy and use this software is granted provided that    **
 ** it is identified as the "RSA Data Security, Inc. MD5 Message-     **
 ** Digest Algorithm" in all material mentioning or referencing this  **
 ** software or this function.                                        **
 **                                                                   **
 ** License is also granted to make and use derivative works          **
 ** provided that such works are identified as "derived from the RSA  **
 ** Data Security, Inc. MD5 Message-Digest Algorithm" in all          **
 ** material mentioning or referencing the derived work.              **
 **                                                                   **
 ** RSA Data Security, Inc. makes no representations concerning       **
 ** either the merchantability of this software or the suitability    **
 ** of this software for any particular purpose.  It is provided "as  **
 ** is" without express or implied warranty of any kind.              **
 **                                                                   **
 ** These notices must be retained in any copies of any part of this  **
 ** documentation and/or software.                                    **
 ***********************************************************************
 */

/*                                                                         */
/* This copy of md5.h modified and adapted for my purposes, tommcg 6/28/96 */
/*                                                                         */

#ifndef _MD5_H_
#define _MD5_H_

#ifdef __cplusplus
extern "C" {
#endif

#pragma warning( disable: 4201 4204 )

#ifndef VOID
typedef void VOID;
#endif

typedef unsigned char UCHAR;
typedef unsigned long ULONG;
typedef unsigned __int64 ULONGLONG;
typedef const void * PCVOID;

#define IN
#define OUT

typedef struct _MD5_HASH MD5_HASH, *PMD5_HASH;

struct _MD5_HASH {
    union {
        ULONG Word32[  4 ];
        UCHAR Byte  [ 16 ];
        };
    };

#define MD5_SIZE	sizeof(MD5_HASH)

#define MD5_INITIAL_VALUE { 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476 }

VOID
InitMD5(
    IN OUT PMD5_HASH HashValue
    );

VOID
UpdateMD5_64ByteChunk(
    IN OUT PMD5_HASH HashValue,         // existing hash value
    IN     PCVOID    DataChunk          // pointer to 64 bytes of data
    );

VOID
FinalizeMD5(
    IN OUT PMD5_HASH HashValue,         // existing hash value
    IN     PCVOID    RemainingData,     // remaining data to hash
    IN     ULONG     RemainingBytes,    // 0 <= RemainingBytes < 64
    IN     ULONGLONG TotalBytesHashed   // total bytes hashed
    );

VOID
ComputeCompleteMD5(                     // complete MD5 in one call
    IN  PCVOID    DataBuffer,           // buffer to compute MD5 over
    IN  ULONGLONG DataLength,           // bytes of data in buffer
    OUT PMD5_HASH HashValue             // return finalized MD5 value
    );

#ifdef __cplusplus
}
#endif

#endif // _MD5_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\cover35src\mon20\service\xbox\precomp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This module contains simple routines to poll and save coverage logging
    data to disk

Author:

    Sakphong Chanbai (schanbai) 22-Aug-2000

Environment:

    Xbox

Revision History:

--*/


#ifndef __COVERMON_H__
#define __COVERMON_H__

#include <nt.h>
#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <xtl.h>
#include <winioctl.h>
#include <xlog.h>

#include <stdio.h>

#include "coverdll.h"
#include "coversys.h"
#include "covfile.h"
#include "bbreg.h"

#ifndef bool
#define bool BOOL
#endif

#ifndef true
#define true TRUE
#endif

#ifndef false
#define false FALSE
#endif

#define COVERMON_POOLTAG 'rvoC'

ULONG
DebugPrint(
    PCHAR Format,
    ...
    );

#endif // __COVERMON_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\cover35src\covfile\covfile.h ===
#ifndef _COVFILE_H_
#define _COVFILE_H_

//
//  Coverage data file is stored as follows:
//
//  COVFILE_HEADER at offset zero in the file.
//  First COVFILE_DIRECTORY entry immediately follows COVFILE_HEADER.
//  Next COVFILE_DIRECTORY entry follows previous entry, etc.
//       (add entry's dwLengthOfEntry to its offset for offset of next entry)
//  Last COVFILE_DIRECTORY entry is empty with dwLengthOfEntry set to zero.
//
//  Order of directory entries is currently random to facilitate speedy
//  insertion of new record (simply appended to end).
//
//  Directory chain is contiguous and is contained within the first
//  dwHeaderLength bytes of the file (multiple of 512 bytes).  First data
//  vector is stored at offset dwHeaderBytes, so directory can grow up to
//  dwHeaderBytes without moving any of the data.
//
//  When directory needs to grow beyond dwHeaderBytes, it will grow by
//  ROUNDUP2( BITVECTOR_STORAGE_SIZE( dwBlockCount ), 512 ) bytes, and that
//  much of the data will be moved from offset at dwHeaderBytes to end of
//  the file (corresponding offsets in directory will be adjusted).
//
//  To facilitate fewer disk sector reads and writes to maintain the data
//  file, data vectors will be stored such that they do not span any
//  ROUNDUP2( BITVECTOR_STORAGE_SIZE( dwBlockCount ), 512 ) byte boundaries.
//  This will guarantee that growing the header by that many bytes will never
//  chop a stored data vector.
//
//  For COVFILE_VERSION 2.01 (0x00020001), all vectors are stored as bit
//  vectors of length dwBlockCount.  The allocation size for such a vector is
//  computed as dwBlockCount rounded up to multiple of 8 then divided by 8
//  (number of bytes) then rounded up to multiple of 4 bytes (dword alignment).
//
//  For version 2.01, 32-bit offsets are used implying a maximum file size of
//  2^32-1 (4GB) bytes.  For a binary that contains 100,000 blocks (a very
//  large binary), each vector would require 12,800 bytes of storage in
//  addition to the directory information for that vector.  For an average
//  name length of 64 bytes, the directory entry is 80 bytes, so roughly
//  12,880 bytes of storage would be required per named vector.  This yields
//  roughly 333,460 maximum named vectors that could be stored for a 100,000
//  block binary (4 gigabytes).
//
//  For version 2.02, 64-bit offsets are used implying a maximum file size of
//  2^64-2 bytes for the data vectors, but the directory chain contained in
//  the header is still limited to 2^32 bytes.  For an average name length of
//  64 bytes, which is 80 bytes per directory entry, this yields space for
//  roughly 50,000,000 test names.
//
//  While the file format will support directory chains of 2^32 bytes, the
//  current implementation of the coverage monitoring service (covermon.exe)
//  caches the entire directory chain for each binary in memory, and walks
//  the chain linearly to search for a matching test name each time coverage
//  information is saved.  This limits the "usable" size of the directory
//  chain (combined for all active .covdata files) to available RAM.  Future
//  implementations of the coverage monitoring service will likely address
//  this limitation by storing only the directory name hashes in memory in a
//  btree format, increasing the "usable" limit to roughly 50,000,000 test
//  names of any length.
//

#ifndef ROUNDUP2
#define ROUNDUP2( x, n ) ((((ULONG)(x)) + (((ULONG)(n)) - 1 )) & ~(((ULONG)(n)) - 1 ))
#endif

#define COVFILE_HEADER_MIN_SIZE  512        // must be power of 2
#define COVFILE_VECTOR_BOUNDARY  512        // must be power of 2

#define BITVECTOR_STORAGE_SIZE( NumberOfBits ) \
           ( ROUNDUP2( ROUNDUP2(( NumberOfBits ), 8 ) / 8, 4 ))

#define COVFILE_SIGNATURE   ( 0xDADAC0BB )    // "BBC0DADA" (BB Cover Data)
#define COVFILE_VERSION     ( 0x00020003 )    // rev this if change structure
#define COVFILE_VERSION_202 ( 0x00020002 )    // older version
#define COVFILE_VERSION_201 ( 0x00020001 )    // older version

typedef struct _COVFILE_HEADER        COVFILE_HEADER,        *PCOVFILE_HEADER;
typedef struct _COVFILE_HEADER_202    COVFILE_HEADER_202,    *PCOVFILE_HEADER_202;
typedef struct _COVFILE_DIRECTORY     COVFILE_DIRECTORY,     *PCOVFILE_DIRECTORY;
typedef struct _COVFILE_DIRECTORY_201 COVFILE_DIRECTORY_201, *PCOVFILE_DIRECTORY_201;

struct _COVFILE_HEADER {
    DWORD dwSignature;          // always COVFILE_SIGNATURE
    DWORD dwVersion;            // always COVFILE_VERSION
    DWORD dwCheckSum;           // checksum of original binary
    DWORD dwBlockCount;         // number of basic blocks (bit vector length)
    DWORD dwHeaderLength;       // multiple of 512, includes entire directory
	DWORD dwOffsetOfFirstDir;
	DWORD dwOffsetOfGUID;
    };

struct _COVFILE_HEADER_202 {
    DWORD dwSignature;          // always COVFILE_SIGNATURE
    DWORD dwVersion;            // always COVFILE_VERSION
    DWORD dwCheckSum;           // checksum of original binary
    DWORD dwBlockCount;         // number of basic blocks (bit vector length)
    DWORD dwHeaderLength;       // multiple of 512, includes entire directory
    };

struct _COVFILE_DIRECTORY_201 {
    DWORD dwLengthOfEntry;      // multiple of 4, zero indicates end of list
    DWORD dwHashOfName;         // to make searching for matches faster
    DWORD dwOffsetOfData;       // size is BITVECTOR_STORAGE_SIZE( dwBlockCount )
    CHAR  szName[];             // variable length, null-terminated
    };

struct _COVFILE_DIRECTORY {
    DWORD     dwLengthOfEntry;  // multiple of 4, zero indicates end of list
    DWORD     dwHashOfName;     // to make searching for matches faster
    DWORDLONG dwlOffsetOfData;  // size is BITVECTOR_STORAGE_SIZE( dwBlockCount )
    CHAR      szName[];         // variable length, null-terminated
    };

VOID
PackByteVectorToBitVector(
    IN  DWORD ByteCount,
    IN  PBYTE ByteVector,
    OUT PBYTE BitVector
    );

VOID
UnpackBitVectorToByteVector(
    IN  DWORD BitCount,
    IN  PBYTE BitVector,
    OUT PBYTE ByteVector
    );

VOID
OrBufferWithBuffer(
    IN PVOID TargetBuffer,
    IN PVOID SourceBuffer,
    IN ULONG Size
    );

VOID
XorBufferWithBuffer(
    IN PVOID TargetBuffer,
    IN PVOID SourceBuffer,
    IN ULONG Size
    );

VOID
BufferAndNotBuffer(
    IN PVOID TargetBuffer,
    IN PVOID SourceBuffer,
    IN ULONG Size
    );

ULONG
CountBitsSetInBuffer(
    IN PVOID Buffer,
    IN ULONG Size
    );

BOOL
DoesBufferContainAllZeros(
    IN PVOID Buffer,
    IN DWORD Size
    );

BOOL
DoesBufferContainOnlyHex01s(
    IN PVOID Buffer,
    IN DWORD Size
    );

ULONG
HashName(
    IN LPCSTR Name
    );

#endif /* _COVFILE_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\cover35src\md5\md5.c ===
/*
 ***********************************************************************
 ** md5.c                                                             **
 ** RSA Data Security, Inc. MD5 Message-Digest Algorithm              **
 ** Created: 2/17/90 RLR                                              **
 ** Revised: 1/91 SRD,AJ,BSK,JT Reference C Version                   **
 ***********************************************************************
 */

/*
 ***********************************************************************
 ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved.  **
 **                                                                   **
 ** License to copy and use this software is granted provided that    **
 ** it is identified as the "RSA Data Security, Inc. MD5 Message-     **
 ** Digest Algorithm" in all material mentioning or referencing this  **
 ** software or this function.                                        **
 **                                                                   **
 ** License is also granted to make and use derivative works          **
 ** provided that such works are identified as "derived from the RSA  **
 ** Data Security, Inc. MD5 Message-Digest Algorithm" in all          **
 ** material mentioning or referencing the derived work.              **
 **                                                                   **
 ** RSA Data Security, Inc. makes no representations concerning       **
 ** either the merchantability of this software or the suitability    **
 ** of this software for any particular purpose.  It is provided "as  **
 ** is" without express or implied warranty of any kind.              **
 **                                                                   **
 ** These notices must be retained in any copies of any part of this  **
 ** documentation and/or software.                                    **
 ***********************************************************************
 */

//  Portions copyright (c) 1992 Microsoft Corp.
//  All rights reserved

//
//  This copy of md5.c modified and adapted for my purposes, tommcg 6/28/96
//  Copyright (C) 1996-1999, Microsoft Corporation.
//


#include "md5.h"
#include <stdlib.h>
#include <string.h>

typedef const unsigned char * PCUCHAR;
typedef const unsigned long * PCULONG;


/* Constants for Transform routine. */
#define S11 7
#define S12 12
#define S13 17
#define S14 22
#define S21 5
#define S22 9
#define S23 14
#define S24 20
#define S31 4
#define S32 11
#define S33 16
#define S34 23
#define S41 6
#define S42 10
#define S43 15
#define S44 21


/* ROTATE_LEFT rotates x left n bits. */

#define ROTATE_LEFT(x, n) ((x << n) | (x >> (32 - n)))

//
//  Intel and PowerPC both have a hardware rotate instruction with intrinsic
//  (inline) function for them.  Rough measurements show a 25% speed increase
//  for Intel and 10% speed increase for PowerPC when using the instrinsic
//  rotate versus the above defined shift/shift/or implemenation.
//

#if defined(_M_IX86) || defined(_M_PPC)
    #undef  ROTATE_LEFT
    #define ROTATE_LEFT(x, n) _rotl(x, n)
#endif


/* F, G and H are basic MD5 functions */
#define F(x, y, z) ((x & y) | (~x & z))
#define G(x, y, z) ((x & z) | (y & ~z))
#define H(x, y, z) (x ^ y ^ z)
#define I(x, y, z) (y ^ (x | ~z))


/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4 */
/* Rotation is separate from addition to prevent recomputation */
#define FF(a, b, c, d, x, s, ac) \
   a += F(b, c, d) + x + ac; \
   a = ROTATE_LEFT(a, s); \
   a += b;

#define GG(a, b, c, d, x, s, ac) \
   a += G(b, c, d) + x + ac; \
   a = ROTATE_LEFT(a, s); \
   a += b;

#define HH(a, b, c, d, x, s, ac) \
   a += H(b, c, d) + x + ac; \
   a = ROTATE_LEFT(a, s); \
   a += b;

#define II(a, b, c, d, x, s, ac) \
   a += I(b, c, d) + x + ac; \
   a = ROTATE_LEFT(a, s); \
   a += b;


VOID
InitMD5(
    IN OUT PMD5_HASH HashValue
    )
    {
    HashValue->Word32[ 0 ] = 0x67452301;
    HashValue->Word32[ 1 ] = 0xefcdab89;
    HashValue->Word32[ 2 ] = 0x98badcfe;
    HashValue->Word32[ 3 ] = 0x10325476;
    }

VOID
UpdateMD5_64ByteChunk(
    IN OUT PMD5_HASH HashValue,         // existing hash value
    IN     PCVOID    DataChunk          // ULONG-aligned pointer to 64-byte message chunk
    )
    {
    PCULONG MessageWord32 = DataChunk;
    ULONG a = HashValue->Word32[ 0 ];
    ULONG b = HashValue->Word32[ 1 ];
    ULONG c = HashValue->Word32[ 2 ];
    ULONG d = HashValue->Word32[ 3 ];

    /* Round 1 */
    FF ( a, b, c, d, MessageWord32[  0 ], S11, 0xd76aa478 ) /* 1 */
    FF ( d, a, b, c, MessageWord32[  1 ], S12, 0xe8c7b756 ) /* 2 */
    FF ( c, d, a, b, MessageWord32[  2 ], S13, 0x242070db ) /* 3 */
    FF ( b, c, d, a, MessageWord32[  3 ], S14, 0xc1bdceee ) /* 4 */
    FF ( a, b, c, d, MessageWord32[  4 ], S11, 0xf57c0faf ) /* 5 */
    FF ( d, a, b, c, MessageWord32[  5 ], S12, 0x4787c62a ) /* 6 */
    FF ( c, d, a, b, MessageWord32[  6 ], S13, 0xa8304613 ) /* 7 */
    FF ( b, c, d, a, MessageWord32[  7 ], S14, 0xfd469501 ) /* 8 */
    FF ( a, b, c, d, MessageWord32[  8 ], S11, 0x698098d8 ) /* 9 */
    FF ( d, a, b, c, MessageWord32[  9 ], S12, 0x8b44f7af ) /* 10 */
    FF ( c, d, a, b, MessageWord32[ 10 ], S13, 0xffff5bb1 ) /* 11 */
    FF ( b, c, d, a, MessageWord32[ 11 ], S14, 0x895cd7be ) /* 12 */
    FF ( a, b, c, d, MessageWord32[ 12 ], S11, 0x6b901122 ) /* 13 */
    FF ( d, a, b, c, MessageWord32[ 13 ], S12, 0xfd987193 ) /* 14 */
    FF ( c, d, a, b, MessageWord32[ 14 ], S13, 0xa679438e ) /* 15 */
    FF ( b, c, d, a, MessageWord32[ 15 ], S14, 0x49b40821 ) /* 16 */

    /* Round 2 */
    GG ( a, b, c, d, MessageWord32[  1 ], S21, 0xf61e2562 ) /* 17 */
    GG ( d, a, b, c, MessageWord32[  6 ], S22, 0xc040b340 ) /* 18 */
    GG ( c, d, a, b, MessageWord32[ 11 ], S23, 0x265e5a51 ) /* 19 */
    GG ( b, c, d, a, MessageWord32[  0 ], S24, 0xe9b6c7aa ) /* 20 */
    GG ( a, b, c, d, MessageWord32[  5 ], S21, 0xd62f105d ) /* 21 */
    GG ( d, a, b, c, MessageWord32[ 10 ], S22, 0x02441453 ) /* 22 */
    GG ( c, d, a, b, MessageWord32[ 15 ], S23, 0xd8a1e681 ) /* 23 */
    GG ( b, c, d, a, MessageWord32[  4 ], S24, 0xe7d3fbc8 ) /* 24 */
    GG ( a, b, c, d, MessageWord32[  9 ], S21, 0x21e1cde6 ) /* 25 */
    GG ( d, a, b, c, MessageWord32[ 14 ], S22, 0xc33707d6 ) /* 26 */
    GG ( c, d, a, b, MessageWord32[  3 ], S23, 0xf4d50d87 ) /* 27 */
    GG ( b, c, d, a, MessageWord32[  8 ], S24, 0x455a14ed ) /* 28 */
    GG ( a, b, c, d, MessageWord32[ 13 ], S21, 0xa9e3e905 ) /* 29 */
    GG ( d, a, b, c, MessageWord32[  2 ], S22, 0xfcefa3f8 ) /* 30 */
    GG ( c, d, a, b, MessageWord32[  7 ], S23, 0x676f02d9 ) /* 31 */
    GG ( b, c, d, a, MessageWord32[ 12 ], S24, 0x8d2a4c8a ) /* 32 */

    /* Round 3 */
    HH ( a, b, c, d, MessageWord32[  5 ], S31, 0xfffa3942 ) /* 33 */
    HH ( d, a, b, c, MessageWord32[  8 ], S32, 0x8771f681 ) /* 34 */
    HH ( c, d, a, b, MessageWord32[ 11 ], S33, 0x6d9d6122 ) /* 35 */
    HH ( b, c, d, a, MessageWord32[ 14 ], S34, 0xfde5380c ) /* 36 */
    HH ( a, b, c, d, MessageWord32[  1 ], S31, 0xa4beea44 ) /* 37 */
    HH ( d, a, b, c, MessageWord32[  4 ], S32, 0x4bdecfa9 ) /* 38 */
    HH ( c, d, a, b, MessageWord32[  7 ], S33, 0xf6bb4b60 ) /* 39 */
    HH ( b, c, d, a, MessageWord32[ 10 ], S34, 0xbebfbc70 ) /* 40 */
    HH ( a, b, c, d, MessageWord32[ 13 ], S31, 0x289b7ec6 ) /* 41 */
    HH ( d, a, b, c, MessageWord32[  0 ], S32, 0xeaa127fa ) /* 42 */
    HH ( c, d, a, b, MessageWord32[  3 ], S33, 0xd4ef3085 ) /* 43 */
    HH ( b, c, d, a, MessageWord32[  6 ], S34, 0x04881d05 ) /* 44 */
    HH ( a, b, c, d, MessageWord32[  9 ], S31, 0xd9d4d039 ) /* 45 */
    HH ( d, a, b, c, MessageWord32[ 12 ], S32, 0xe6db99e5 ) /* 46 */
    HH ( c, d, a, b, MessageWord32[ 15 ], S33, 0x1fa27cf8 ) /* 47 */
    HH ( b, c, d, a, MessageWord32[  2 ], S34, 0xc4ac5665 ) /* 48 */

    /* Round 4 */
    II ( a, b, c, d, MessageWord32[  0 ], S41, 0xf4292244 ) /* 49 */
    II ( d, a, b, c, MessageWord32[  7 ], S42, 0x432aff97 ) /* 50 */
    II ( c, d, a, b, MessageWord32[ 14 ], S43, 0xab9423a7 ) /* 51 */
    II ( b, c, d, a, MessageWord32[  5 ], S44, 0xfc93a039 ) /* 52 */
    II ( a, b, c, d, MessageWord32[ 12 ], S41, 0x655b59c3 ) /* 53 */
    II ( d, a, b, c, MessageWord32[  3 ], S42, 0x8f0ccc92 ) /* 54 */
    II ( c, d, a, b, MessageWord32[ 10 ], S43, 0xffeff47d ) /* 55 */
    II ( b, c, d, a, MessageWord32[  1 ], S44, 0x85845dd1 ) /* 56 */
    II ( a, b, c, d, MessageWord32[  8 ], S41, 0x6fa87e4f ) /* 57 */
    II ( d, a, b, c, MessageWord32[ 15 ], S42, 0xfe2ce6e0 ) /* 58 */
    II ( c, d, a, b, MessageWord32[  6 ], S43, 0xa3014314 ) /* 59 */
    II ( b, c, d, a, MessageWord32[ 13 ], S44, 0x4e0811a1 ) /* 60 */
    II ( a, b, c, d, MessageWord32[  4 ], S41, 0xf7537e82 ) /* 61 */
    II ( d, a, b, c, MessageWord32[ 11 ], S42, 0xbd3af235 ) /* 62 */
    II ( c, d, a, b, MessageWord32[  2 ], S43, 0x2ad7d2bb ) /* 63 */
    II ( b, c, d, a, MessageWord32[  9 ], S44, 0xeb86d391 ) /* 64 */

    HashValue->Word32[ 0 ] += a;
    HashValue->Word32[ 1 ] += b;
    HashValue->Word32[ 2 ] += c;
    HashValue->Word32[ 3 ] += d;
    }


VOID
FinalizeMD5(
    IN OUT PMD5_HASH HashValue,
    IN     PCVOID    RemainingData,     // remaining data to hash
    IN     ULONG     RemainingBytes,    // 0 <= RemainingBytes < 64
    IN     ULONGLONG TotalBytesHashed   // total bytes hashed
    )
    {
    union {
        ULONGLONG Qword[  8 ];
        UCHAR     Byte [ 64 ];
        } LocalBuffer;

    //
    //  Always append a pad byte of 0x80 to the message.
    //
    //  If RemainingBytes is less than (but not equal to) 56 bytes, then
    //  the final bits hashed count will be stored in the last 8 bytes of
    //  this 64 byte hash chunk.
    //
    //  If RemainingBytes is exactly 56 bytes, the appended 0x80 pad byte
    //  will force an extra chunk.
    //
    //  If RemainingBytes is greater than or equal to 56 bytes, then the
    //  final bits hashed count will be stored in the last 8 bytes of the
    //  NEXT 64 byte chunk that is otherwise zeroed, so THIS chunk needs to
    //  be zero-padded beyond the first pad byte and then hashed, then zero
    //  the first 56 bytes of the LocalBuffer for the NEXT chunk hash.
    //

    RemainingBytes &= 63;           // prevent stupidity (no error return)

    //
    //  Zero init local buffer.
    //

    memset( &LocalBuffer, 0, 64 );

    //
    //  Append 0x80 pad byte to message.
    //

    LocalBuffer.Byte[ RemainingBytes ] = 0x80;

    if ( RemainingBytes > 0 ) {

        //
        //  Copy remaining data bytes (0 < RemainingBytes < 64) to LocalBuffer
        //  (remainder of LocalBuffer already zeroed except for pad byte).
        //

        memcpy( &LocalBuffer, RemainingData, RemainingBytes );

        if ( RemainingBytes >= 56 ) {

            UpdateMD5_64ByteChunk( HashValue, &LocalBuffer );

            memset( &LocalBuffer, 0, 56 );

            }
        }

    //
    //  Number of BITS hashed goes into last 8 bytes of last chunk.  This
    //  is a 64-bit value.  Note that if the number of BITS exceeds 2^64
    //  then this number is the low order 64 bits of the result.
    ///

    LocalBuffer.Qword[ 7 ] = ( TotalBytesHashed * 8 );      // number of BITS

    UpdateMD5_64ByteChunk( HashValue, &LocalBuffer );

    }


VOID
ComputeCompleteMD5(
    IN  PCVOID    DataBuffer,
    IN  ULONGLONG DataLength,
    OUT PMD5_HASH HashValue
    )
    {
    PCUCHAR   DataPointer = DataBuffer;
    ULONGLONG ChunkCount  = DataLength / 64;
    ULONG     OddBytes    = (ULONG)DataLength & 63;

    InitMD5( HashValue );

    while ( ChunkCount-- ) {
        UpdateMD5_64ByteChunk( HashValue, DataPointer );
        DataPointer += 64;
        }

    FinalizeMD5( HashValue, DataPointer, OddBytes, DataLength );
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\cover35src\mon20\service\xbox\covermon.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    covermon.c

Abstract:

    This module contains simple routines to poll and save coverage logging
    data to disk

Environment:

    Xbox

Revision History:

--*/


#include "precomp.h"

#define ROUNDUPN( x, n )    ((((x) + ((n) - 1 )) / (n)) * (n))
#define ROUNDUP2( x, n )    ((((ULONG)(x)) + (((ULONG)(n)) - 1 )) & ~(((ULONG)(n)) - 1 ))
#define ROUNDUP2_64( x, n ) ((((DWORDLONG)(x)) + (((DWORDLONG)(n)) - 1 )) & ~(((DWORDLONG)(n)) - 1 ))

typedef struct _SAVED_VECTOR SAVED_VECTOR, *PSAVED_VECTOR;

struct _SAVED_VECTOR {
	PVOID			pSavedBitVector;
	PCHAR			pszTestName;
	PSAVED_VECTOR	next;
};

typedef struct _COVMON_REGISTERED_BINARY COVMON_REGISTERED_BINARY, *PCOVMON_REGISTERED_BINARY;

struct _COVMON_REGISTERED_BINARY {
    PCOVMON_REGISTERED_BINARY pNext;                   // singly linked list
    DWORD              dwBlockCount;
    DWORD              dwCheckSumOfBinary;
    DWORD              dwUniquifier;
    HANDLE             hLogFileHandle;
    PCOVFILE_HEADER    pCachedCovFileHeader;
    DWORDLONG          dwlFileSize;
    bool               bKernelBinary;
	bool               bClearForShutdown;
	PSAVED_VECTOR      pLastSavedBitVectorList;     // bit vector for system shutdown
	DWORD              dwSavedVectorCount;
	MD5_HASH           md5;
////////////////////
	PCHAR			   mGuid;
	HANDLE			   ptrFuncDataBase ;
////////////////////
    CHAR               szBinaryName[ 1 ];       // variable length
};


HANDLE hKernelCoverageHandle;
HANDLE CoverMonHeapHandle;

CRITICAL_SECTION NameBufferCritSect;
CRITICAL_SECTION PollBufferCritSect;
CRITICAL_SECTION RegistrationCritSect;

CHAR szNameBuffer[ 65000 ];     // 64K buffer for list of names (not on stack)
LPSTR pCoverageDir;

DWORD  dwPollBufferSize = 0x100000;
PVOID  pPollBuffer;

volatile BOOL bShutdownInProgress = FALSE;
volatile BOOL bMediaWriteProtected = FALSE;
volatile BOOL bCacheAlways = FALSE;
volatile BOOL bCacheMRU = TRUE;

PCOVMON_REGISTERED_BINARY RegisteredBinaryList = (PCOVMON_REGISTERED_BINARY)&RegisteredBinaryList;


BOOL
CovMonIsRunning(
    VOID
    )
{
    return hKernelCoverageHandle != NULL;
}


BOOL
CoverageMonitorInit(
    VOID
    )
{
    hKernelCoverageHandle = KernelCoverageConnectToDriver();
		
    if ( hKernelCoverageHandle == NULL ) {
	    DebugPrint( "COVERMON: coverage.sys was not loaded\n" );
        return FALSE;
    }

    InitializeCriticalSection( &NameBufferCritSect );
    InitializeCriticalSection( &PollBufferCritSect );
    InitializeCriticalSection( &RegistrationCritSect );

    dwPollBufferSize = ROUNDUP2( dwPollBufferSize, 8192 );
    pPollBuffer = ExAllocatePoolWithTag( dwPollBufferSize, COVERMON_POOLTAG );

    if ( !pPollBuffer ) {
        return FALSE;
    }

    pCoverageDir = "z:\\coverage";
    CoverMonHeapHandle = HeapCreate( 0, 0, 0 );

    return CoverMonHeapHandle != NULL;
}


VOID
CDECL
CoverMonStartup(
    VOID
    )
{
    CoverageMonitorInit();
}


VOID
CDECL
CoverMonCleanup(
    VOID
    )
{
    HeapDestroy( CoverMonHeapHandle );
}


//
// Setup a startup pointer to be called by CRT
//
#pragma data_seg(".CRT$XIU")
PROC covermon_startup = (PROC)CoverMonStartup;
#pragma data_seg()


//
// Setup a cleanup pointer to be called by CRT
//
#pragma data_seg(".CRT$XTU")
PROC covermon_cleanup = (PROC)CoverMonCleanup;
#pragma data_seg()


#pragma comment( linker, "/include:_covermon_startup" )
#pragma comment( linker, "/include:_covermon_cleanup" )


VOID
UuidToString(
    GUID * guid,
    LPSTR * pszString
    )
{
    const LPCSTR pszTemplate = "%8.8lX-%4.4X-%4.4X-%2.2X%2.2X-%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X";

    *pszString = HeapAlloc( CoverMonHeapHandle, 0, sizeof("5bca35fd-5d73-40b9-b9a8-49c12c629168") );
    if ( *pszString == NULL ) {
        return;
    }

    sprintf(
        *pszString, 
        pszTemplate, 
        guid->Data1, guid->Data2, guid->Data3,
        guid->Data4[0], guid->Data4[1], guid->Data4[2], guid->Data4[3],
        guid->Data4[4], guid->Data4[5], guid->Data4[6], guid->Data4[7]
        );
}


VOID
INLINE
AddRegisteredBinaryNodeToList(
    IN PCOVMON_REGISTERED_BINARY pPrev,
    IN PCOVMON_REGISTERED_BINARY pNode
    )
{
    pNode->pNext = pPrev->pNext;
    pPrev->pNext = pNode;
}


PCOVMON_REGISTERED_BINARY
INLINE
AllocateRegisteredBinaryNode(
    IN ULONG BinaryNameLength
    )
{
    return HeapAlloc( CoverMonHeapHandle, 0, sizeof(COVMON_REGISTERED_BINARY) + BinaryNameLength );
}


PCOVMON_REGISTERED_BINARY
INLINE
AllocateRegisteredBinaryNodeWithNameAndGUID(
    IN LPCSTR pszBinaryName,
	IN PMD5_HASH pMD5
    )
{
    ULONG NameLength = strlen( pszBinaryName );
    PCOVMON_REGISTERED_BINARY pNode = AllocateRegisteredBinaryNode( NameLength );
	
    if ( pNode != NULL ) {
        ZeroMemory( pNode, sizeof( COVMON_REGISTERED_BINARY ) - 1 );
        CopyMemory( pNode->szBinaryName, pszBinaryName, NameLength + 1 );
		CopyMemory( &(pNode->md5), pMD5, MD5_SIZE);
		UuidToString((UUID*)pMD5, &(pNode->mGuid));
		pNode->pLastSavedBitVectorList = NULL;
		pNode->bClearForShutdown = false;
		pNode->dwSavedVectorCount = 0;
	}
	
    return pNode;
}


PCOVMON_REGISTERED_BINARY
CovMonInternalFindOrAddRegistration(
									IN LPCSTR pszBinaryName,        // lowercase
									IN DWORD  dwBlockCount,
									IN DWORD  dwCheckSum,
									IN bool   bKernelBinary,
									IN PMD5_HASH pMD5
									)
{
    PCOVMON_REGISTERED_BINARY pNode;
    PCOVMON_REGISTERED_BINARY pPrev;
    bool bFound = false;
	
    EnterCriticalSection( &RegistrationCritSect );
	
    //
    //  Walk list of registered binaries looking for name
    //
	
    pPrev = (PCOVMON_REGISTERED_BINARY)&RegisteredBinaryList;
    pNode = RegisteredBinaryList;
	
    while ( pNode != (PCOVMON_REGISTERED_BINARY)&RegisteredBinaryList ) {
		
        if ( strcmp( pNode->szBinaryName, pszBinaryName ) == 0 ) {
            bFound = true;
            break;
		}
		
        pPrev = pNode;
        pNode = pNode->pNext;
		
	}
	
    if ( ! bFound ) {
		
        pNode = AllocateRegisteredBinaryNodeWithNameAndGUID( pszBinaryName, pMD5 );
		
        if ( pNode != NULL ) {

			DebugPrint("Name: %s\tGUID: %s\n", pNode->szBinaryName, pNode->mGuid);
			
            pNode->dwBlockCount       = dwBlockCount;
            pNode->dwCheckSumOfBinary = dwCheckSum;
            pNode->bKernelBinary      = bKernelBinary;
			
            AddRegisteredBinaryNodeToList( pPrev, pNode );
			
		}
	}
	
    LeaveCriticalSection( &RegistrationCritSect );
	
    return pNode;
}


DWORDLONG
GetFileSize64(
    IN HANDLE hFile
    )
{
    ULARGE_INTEGER FileSize;
	
    FileSize.LowPart = GetFileSize( hFile, &FileSize.HighPart );
	
    if (( FileSize.LowPart == 0xFFFFFFFF ) && ( GetLastError() != NO_ERROR )) {
        FileSize.HighPart = 0xFFFFFFFF;
	}
	
    return FileSize.QuadPart;
}


BOOL
SetFilePointer64(
    IN HANDLE    hFile,
    IN DWORDLONG dwlOffset
    )
{
    ULARGE_INTEGER Position;
	
    Position.QuadPart = dwlOffset;
    Position.LowPart  = SetFilePointer( hFile, (LONG)Position.LowPart, (PLONG)&Position.HighPart, FILE_BEGIN );
	
    if (( Position.LowPart == 0xFFFFFFFF ) && ( GetLastError() != NO_ERROR )) {
        return false;
	}
	
    return ( Position.QuadPart == dwlOffset );
}


BOOL
CovMonInternalOpenLogFile(
    IN OUT PCOVMON_REGISTERED_BINARY pNode
	)
{
    PCOVFILE_HEADER pCovFileHeader;
    CHAR      szUniquifier[ 16 ];
    CHAR      szLogFileName[ 256 ];
    CHAR      szNewFileName[ 256 ];
    DWORD     dwLastError;
    DWORDLONG dwlFileSize;
    DWORD     dwActual;
    DWORD     dwHeaderSize;
    DWORD     dwAttr;
	DWORD     dwGUIDLength;
    HANDLE    hFile;
	
    strcpy( szLogFileName, pCoverageDir );
    strcat( szLogFileName, "\\" );

    //
    // Create coverage directory first
    //
    CreateDirectory( szLogFileName, NULL );

    strcat( szLogFileName, pNode->szBinaryName );
    dwAttr = GetFileAttributes( szLogFileName );
	
    if ( ! ( dwAttr & FILE_ATTRIBUTE_DIRECTORY )) {
		
        //
        //  There's a file, not a directory, by this name already.  We'll
        //  have to rename the file before we can create the directory.
        //
		
        strcpy( szNewFileName, pCoverageDir );
        strcat( szNewFileName, "\\~" );
        strcat( szNewFileName, szLogFileName );
        DeleteFile( szNewFileName );
        MoveFile( szLogFileName, szNewFileName );
        dwAttr = GetFileAttributes( szLogFileName );
	}
	
    if (( dwAttr == 0xFFFFFFFF ) || ( ! ( dwAttr & FILE_ATTRIBUTE_DIRECTORY ))) {
		
        if ( ! CreateDirectory( szLogFileName, NULL )) {
			
            dwLastError = GetLastError();
			
            DebugPrint(
                "COVERMON: LOST DATA for %s because failed to access or create\n"
                "          directory %s (error %d)\n",
                pNode->szBinaryName,
                szLogFileName,
                dwLastError
                );
			
            SetLastError( dwLastError );
            return false;
		}
	}
	
    strcat( szLogFileName, "\\" );
    strcat( szLogFileName, pNode->szBinaryName );
	
    if ( pNode->dwUniquifier != 0 ) {
        sprintf( szUniquifier, ".%08X.%d", pNode->dwCheckSumOfBinary, pNode->dwUniquifier );
        strcat( szLogFileName, szUniquifier );
	}

    strcat( szLogFileName, ".covdata" );
	
    hFile = CreateFile(
		szLogFileName,
		GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_READ,
		NULL,
		OPEN_ALWAYS,
		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS | FILE_FLAG_WRITE_THROUGH,
		NULL
		);
	
    if ( hFile == INVALID_HANDLE_VALUE ) {
		
        dwLastError = GetLastError();
		
        DebugPrint(
            "COVERMON: LOST DATA for %s because failed to open or create\n"
            "          file %s (error %d)\n",
            pNode->szBinaryName,
            szLogFileName,
            dwLastError
            );
		
        SetLastError( dwLastError );
        return false;
	}
	
    dwlFileSize = GetFileSize64( hFile );
	
    if ( dwlFileSize == (DWORDLONG) -1 ) {
		
        dwLastError = GetLastError();
		
        DebugPrint(
            "COVERMON: LOST DATA for %s because failed to query file %s (error %d)\n",
            pNode->szBinaryName,
            szLogFileName,
            dwLastError
            );
		
        CloseHandle( hFile );
        SetLastError( dwLastError );
        return false;
	}
	
    pCovFileHeader = HeapAlloc( CoverMonHeapHandle, 0, COVFILE_HEADER_MIN_SIZE );
	
    if ( pCovFileHeader == NULL ) {
		
        DebugPrint(
            "COVERMON: LOST DATA for %s because failed to allocate memory (%d bytes).\n",
            pNode->szBinaryName,
            COVFILE_HEADER_MIN_SIZE
            );
		
        CloseHandle( hFile );
        SetLastError( ERROR_OUTOFMEMORY );
        return false;
	}
	
    dwActual = 0;
	
    if ( dwlFileSize >= COVFILE_HEADER_MIN_SIZE ) {
		
        if (( ! ReadFile( hFile, pCovFileHeader, COVFILE_HEADER_MIN_SIZE, &dwActual, NULL )) &&
            (( dwLastError = GetLastError() ) != ERROR_HANDLE_EOF )) {
			
            DebugPrint(
                "COVERMON: LOST DATA for %s because failed to read file %s (error %d)\n",
                pNode->szBinaryName,
                szLogFileName,
                dwLastError
                );
			
            CloseHandle( hFile );
            SetLastError( dwLastError );
            return false;
		}
	}
	
    if ( dwActual != COVFILE_HEADER_MIN_SIZE ) {
		
        //
        //  New file being created.
        //
		
        DebugPrint( "COVERMON: New file: %s.\n", szLogFileName );
		
        ZeroMemory( pCovFileHeader, COVFILE_HEADER_MIN_SIZE );

		dwGUIDLength = MD5_SIZE;
		
        pCovFileHeader->dwSignature    = COVFILE_SIGNATURE;
        pCovFileHeader->dwVersion      = COVFILE_VERSION;
        pCovFileHeader->dwCheckSum     = pNode->dwCheckSumOfBinary;
        pCovFileHeader->dwBlockCount   = pNode->dwBlockCount;

		// Header length is defined to be COVFILE_HEADER + GUID + one DIR_ENTRY,
		// rounded up to 512
        pCovFileHeader->dwHeaderLength =
			ROUNDUP2(
			sizeof(COVFILE_HEADER) + MD5_SIZE + sizeof(COVFILE_DIRECTORY),
			COVFILE_HEADER_MIN_SIZE
			);

		// Put GUID at end of header
		pCovFileHeader->dwOffsetOfGUID = sizeof( COVFILE_HEADER );

		// Put the first dir entry after the GUID
		pCovFileHeader->dwOffsetOfFirstDir = ROUNDUP2(sizeof( COVFILE_HEADER ) + dwGUIDLength, 4);

		CopyMemory( (PCHAR)pCovFileHeader + pCovFileHeader->dwOffsetOfGUID, &(pNode->md5), dwGUIDLength);
		
        dwlFileSize = COVFILE_HEADER_MIN_SIZE;
	}
	
    else if (( pCovFileHeader->dwSignature  != COVFILE_SIGNATURE ) ||
		( pCovFileHeader->dwCheckSum   != pNode->dwCheckSumOfBinary ) ||
		( pCovFileHeader->dwBlockCount != pNode->dwBlockCount )) {
		
        //
        //  Existing file does not match checksum, close existing and open new.
        //
		
        DebugPrint(
            "COVERMON: Binary %s contains different checksum than %s\n",
            pNode->szBinaryName,
            szLogFileName
            );
		
        CloseHandle( hFile );
		
        pNode->dwUniquifier++;
		
        return CovMonInternalOpenLogFile( pNode );
		
	}
	
    else if ( pCovFileHeader->dwVersion > COVFILE_VERSION ) {
		
        //
        //  File is of newer version than we understand.
        //
		
        DebugPrint(
            "COVERMON: %s is %s version than covermon understands\n",
            szLogFileName,
            "newer"
            );
		
        CloseHandle( hFile );
		
        pNode->dwUniquifier++;
		
        return CovMonInternalOpenLogFile( pNode );
		
	}
	
    else if ( pCovFileHeader->dwVersion < COVFILE_VERSION ) {
		
        //
        //  File is of older version than we understand.
        //
		
        DebugPrint(
            "COVERMON: %s is %s version than covermon understands\n",
            szLogFileName,
            "older"
            );
		
        CloseHandle( hFile );
		
        pNode->dwUniquifier++;
		
        return CovMonInternalOpenLogFile( pNode );
		
	}
	
    else if ( pCovFileHeader->dwHeaderLength > COVFILE_HEADER_MIN_SIZE ) {
		
        //
        //  More header needs to be read and cached.
        //
		
        dwHeaderSize = pCovFileHeader->dwHeaderLength;
		
        pCovFileHeader = HeapReAlloc( CoverMonHeapHandle, 0, pCovFileHeader, dwHeaderSize );
		
        if ( pCovFileHeader == NULL ) {
			
            DebugPrint(
                "COVERMON: LOST DATA for %s because failed to allocate memory (%d bytes).\n",
                pNode->szBinaryName,
                dwHeaderSize
                );
			
            CloseHandle( hFile );
            SetLastError( ERROR_OUTOFMEMORY );
            return false;
		}
		
        dwActual = 0;
		
        if ( ! ReadFile( hFile,
			(PCHAR)pCovFileHeader + COVFILE_HEADER_MIN_SIZE,
			dwHeaderSize - COVFILE_HEADER_MIN_SIZE,
			&dwActual,
			NULL )) {
			
            dwLastError = GetLastError();
			
            DebugPrint(
                "COVERMON: LOST DATA for %s because failed to read file %s (error %d)\n",
                pNode->szBinaryName,
                szLogFileName,
                dwLastError
                );
			
            CloseHandle( hFile );
            SetLastError( dwLastError );
            return false;
		}
	}
	
    pNode->pCachedCovFileHeader = pCovFileHeader;
    pNode->hLogFileHandle = hFile;
    pNode->dwlFileSize = dwlFileSize;
	
    return true;
}


VOID
CovMonInternalClearCache(
	PCOVMON_REGISTERED_BINARY pNode
	)
{
	PSAVED_VECTOR pTmpVectorNode;
	PSAVED_VECTOR pNxtVectorNode;

	for ( pTmpVectorNode = pNode->pLastSavedBitVectorList;
	      pTmpVectorNode != NULL;
	      pTmpVectorNode = pNxtVectorNode) {
		pNxtVectorNode = pTmpVectorNode->next;
		HeapFree( CoverMonHeapHandle, 0, pTmpVectorNode->pszTestName);
		HeapFree( CoverMonHeapHandle, 0, pTmpVectorNode->pSavedBitVector);
		HeapFree( CoverMonHeapHandle, 0, pTmpVectorNode);
		pNode->dwSavedVectorCount--;
	}

	pNode->pLastSavedBitVectorList = NULL;
}


BOOL
CovMonInternalUpdateLogFile(
    IN PCOVMON_REGISTERED_BINARY pNode,
    IN LPCSTR pszTestName
    )
{
    PCOVFILE_HEADER pHeader;
    PCOVFILE_DIRECTORY pDirEntry;
    PCOVFILE_DIRECTORY_201 pDirEntry201;
    HANDLE hFile;
    DWORD dwNameHash;
    DWORD dwVectorSize;
    PVOID pNewBitVector;
    PVOID pOldBitVector;
    PVOID pMoveBuffer;
    bool  bFound;
    DWORD dwLastError;
    DWORD dwActual;
    DWORDLONG dwlOffset;
    DWORDLONG dwlFileSize;
    DWORDLONG dwlVectorOffset;
    DWORDLONG dwlMoveBias;
    DWORDLONG dwlExtent;
    PVOID pNewHeader;
    DWORD dwNameLength;
    DWORD dwEntryLength;
    DWORD dwGrowSize;
	DWORD dwOffsetOfFirstDir;
    bool  bSuccess;
    LPSTR pszName;
	bool  bAlreadyHasSavedVector;
	bool  bDataHasChanged;
	DWORD i;
	PSAVED_VECTOR pTmpVectorNode;
	PSAVED_VECTOR pPrvVectorNode;
	PSAVED_VECTOR pNxtVectorNode;
	PSAVED_VECTOR pNewVectorNode;
//	LPSTR pszVectorTestName;
	bool bFoundNode;
	
    //
    //  Note pPollBuffer is a global that is an implied [IN] parameter.
    //  Assume PollBufferCritSect is held.
    //
	
    pNewBitVector = NULL;
    pOldBitVector = NULL;
	pTmpVectorNode= NULL;
	pPrvVectorNode= NULL;
	pNxtVectorNode= NULL;
	pNewVectorNode= NULL;
    pMoveBuffer   = NULL;
    bSuccess      = false;
    dwLastError   = 0;
	bAlreadyHasSavedVector = false;
	bDataHasChanged = true;
	
    ASSERT( DoesBufferContainOnlyHex01s( pPollBuffer, pNode->dwBlockCount ));

    try {
		
        dwVectorSize = BITVECTOR_STORAGE_SIZE( pNode->dwBlockCount );

        pNewBitVector = HeapAlloc( CoverMonHeapHandle, 0, dwVectorSize );
		
        if ( pNewBitVector == NULL ) {
			
            DebugPrint(
                "COVERMON: LOST DATA for %s because failed to allocate memory (%d bytes).\n",
                pNode->szBinaryName,
                dwVectorSize
                );
			
            dwLastError = ERROR_OUTOFMEMORY;
            leave;
		}
		
        *(UNALIGNED DWORD*)((PCHAR)pNewBitVector + dwVectorSize - 4 ) = 0;

        PackByteVectorToBitVector(
            pNode->dwBlockCount,
            pPollBuffer,
            pNewBitVector
            );
		
        ASSERT( CountBitsSetInBuffer( pPollBuffer, pNode->dwBlockCount ) ==
			CountBitsSetInBuffer( pNewBitVector, dwVectorSize ));

		// If the first test name is not "(system shutdown)", then clear out the cache
		if( (bCacheAlways || bCacheMRU) && 
			bShutdownInProgress &&
			(pNode->bClearForShutdown != true)
			){

			// Iterate over the saved vectors and free memory back to the heap
			CovMonInternalClearCache( pNode );

			pNode->bClearForShutdown = true;
		}

        bFound     = false;
        hFile      = pNode->hLogFileHandle;
        dwNameHash = HashName( pszTestName );
        pHeader    = pNode->pCachedCovFileHeader;
		dwOffsetOfFirstDir = pHeader->dwOffsetOfFirstDir;
//        pDirEntry  = (PCOVFILE_DIRECTORY)((PCHAR)pHeader + sizeof( COVFILE_HEADER ));
        pDirEntry  = (PCOVFILE_DIRECTORY)((PCHAR)pHeader + dwOffsetOfFirstDir);
		
        while ( pDirEntry->dwLengthOfEntry != 0 ) {
			
            if ( pDirEntry->dwHashOfName == dwNameHash ) {
				
                //
                //  Offset of pDirEntry->szName is different for versions
                //  201 and 202 of covdata file.
                //
				
                if ( pHeader->dwVersion == COVFILE_VERSION_201 ) {
                    pszName = ((PCOVFILE_DIRECTORY_201)pDirEntry)->szName;
				}
                else {
                    ASSERT( pHeader->dwVersion == COVFILE_VERSION );
                    pszName = pDirEntry->szName;
				}

                if ( _stricmp( pszName, pszTestName ) == 0 ) {
					
                    bFound = true;
                    break;
				}
			}
			
            pDirEntry = (PVOID)((PCHAR)pDirEntry + pDirEntry->dwLengthOfEntry );
			
		}
#pragma warning(disable: 4127)
        if ( bFound ) {
			
            //
            //  If test name found, read existing vector, OR with new vector,
            //  write back to file.
            //

			if( bCacheAlways || bCacheMRU ){
				bFoundNode = false;
				// See if we already have the vector stored in memory
				pTmpVectorNode = pNode->pLastSavedBitVectorList;

				// Only search through list if we are *always* caching
				// Otherwise, we only cache the MRU
				if( bCacheAlways ){
					for( i=0; i < pNode->dwSavedVectorCount; i++ ){
						if( _stricmp( pTmpVectorNode->pszTestName, pszTestName ) == 0 ){
							bFoundNode = true;
							break;
						}
						pPrvVectorNode = pTmpVectorNode;
						pTmpVectorNode = pTmpVectorNode->next;
					}

				} else {
					// If Cache MRU, then check if the MRU test name matches
					if( (pTmpVectorNode != NULL) &&
						_stricmp( pTmpVectorNode->pszTestName, pszTestName ) == 0 ){
						bFoundNode = true;

					// If the test names don't match, then delete the node
					} else if( pTmpVectorNode != NULL ){
						CovMonInternalClearCache( pNode );

						bFoundNode = false;
					}
				}

				if( !bFoundNode ){

					pNewVectorNode = HeapAlloc( CoverMonHeapHandle, 0, sizeof(SAVED_VECTOR) );

					if( pNewVectorNode == NULL ){
						DebugPrint( "COVERMON: Failed to allocate memory for vector node (%s, %d bytes).\n", pNode->szBinaryName, sizeof(SAVED_VECTOR) );
						dwLastError = ERROR_OUTOFMEMORY;
						leave;
					}

					pNewVectorNode->next = NULL;
					
					pNewVectorNode->pSavedBitVector = HeapAlloc( CoverMonHeapHandle, 0, dwVectorSize );

					if( pNewVectorNode->pSavedBitVector == NULL ){
						DebugPrint( "COVERMON: Failed to allocate memory for vector (%s, %d bytes).\n", pNode->szBinaryName, dwVectorSize );
						dwLastError = ERROR_OUTOFMEMORY;
						leave;
					}

					pNewVectorNode->pszTestName = HeapAlloc( CoverMonHeapHandle, 0, strlen(pszTestName)+1 );
					
					if( pNewVectorNode->pszTestName == NULL ){
						DebugPrint( "COVERMON: Failed to allocate memory for vector name (%s, %d bytes).\n", pNode->szBinaryName, strlen(pszTestName)+1 );
						dwLastError = ERROR_OUTOFMEMORY;
						leave;
					}

					strcpy( pNewVectorNode->pszTestName, pszTestName );

					if( pNode->pLastSavedBitVectorList == NULL ){
						pNode->pLastSavedBitVectorList = pNewVectorNode;
						
					} else if( bCacheAlways ){
						pPrvVectorNode->next = pNewVectorNode;

					}

					pNode->dwSavedVectorCount++;
					
					bAlreadyHasSavedVector = false;

					pOldBitVector = pNewVectorNode->pSavedBitVector;

				} else {
					bAlreadyHasSavedVector = true;

					pOldBitVector = pTmpVectorNode->pSavedBitVector; // Used for the ReadFile down below
					
				}

			} else {
				pOldBitVector = HeapAlloc( CoverMonHeapHandle, 0, dwVectorSize );

				if( pOldBitVector == NULL ){
					DebugPrint( "COVERMON: LOST DATA for %s because failed to allocate memory (%d bytes).\n", pNode->szBinaryName, dwVectorSize );
					dwLastError = ERROR_OUTOFMEMORY;
					leave;
				}
			}
			
            if ( pHeader->dwVersion == COVFILE_VERSION_201 ) {
                dwlVectorOffset = ((PCOVFILE_DIRECTORY_201)pDirEntry)->dwOffsetOfData;
			}
            else {
                ASSERT( pHeader->dwVersion == COVFILE_VERSION );
                dwlVectorOffset = pDirEntry->dwlOffsetOfData;
			}
			
            dwActual = 0;

			// If there is already a saved vector, or we are not caching, then read from covdata file
			if( !bAlreadyHasSavedVector ||
				!(bCacheAlways || bCacheMRU) ){

				if (( ! SetFilePointer64( hFile, dwlVectorOffset )) ||
					( ! ReadFile( hFile, pOldBitVector, dwVectorSize, &dwActual, NULL )) ||
					( dwActual != dwVectorSize )) {
					
					dwLastError = GetLastError();
					
					DebugPrint(
						"COVERMON: LOST DATA for %s because failed to read covdata file (error %d)\n",
						pNode->szBinaryName,
						dwLastError
						);
					
					leave;
				}
			}

			//
			// 1) NewBuf = NewBuf OR OldBuf
			// 2) OldBuf = NewBuf XOR OldBuf
			// 3) If any 1's in OldBuf, then there were changes; save data
			//    otherwise, no changes, so don't save
			//
            OrBufferWithBuffer( pNewBitVector, pOldBitVector, dwVectorSize );
			
            ASSERT( CountBitsSetInBuffer( pNewBitVector, dwVectorSize ) >=
				CountBitsSetInBuffer( pOldBitVector, dwVectorSize ));

			XorBufferWithBuffer( pOldBitVector, pNewBitVector, dwVectorSize );

			if( DoesBufferContainAllZeros( pOldBitVector, dwVectorSize ) ){
				bDataHasChanged = false;
			} else {
				bDataHasChanged = true;
			}

			//////////////////////////////////////////////////
			
			//
			// Save the logging info for the purposes of shutdown
			//

			if( bCacheAlways || bCacheMRU ){
				CopyMemory( pOldBitVector, pNewBitVector, dwVectorSize );
			}
			
            dwActual = 0;
			
			if( bDataHasChanged ){
				if (( ! SetFilePointer64( hFile, dwlVectorOffset )) ||
					( ! WriteFile( hFile, pNewBitVector, dwVectorSize, &dwActual, NULL )) ||
					( dwActual != dwVectorSize )) {
					
					dwLastError = GetLastError();
					
					if( dwLastError == ERROR_WRITE_PROTECT ){
						DebugPrint(
							"COVERMON: Unable to save further data because the filesystem has been shutdown.\n"
							);
						bMediaWriteProtected = true;

					} else {
						DebugPrint(
							"COVERMON: LOST DATA for %s because failed to write covdata file (error %d)\n",
							pNode->szBinaryName,
							dwLastError
							);
						
					}
					
					leave;
				}
			}
			
            FlushFileBuffers( hFile );
		}
		
        else {
			
            //
            //  If test not found, write new vector then update header (grow
            //  header if necessary).  We write new vector first in case later
            //  fail to write updated header -- file will still be valid but
            //  without new vector.  If wrote header first then failed to write
            //  vector, file would left in invalid state.
            //

            dwlVectorOffset = ROUNDUP2_64( pNode->dwlFileSize, COVFILE_VECTOR_BOUNDARY );
            dwActual = 0;
			
            if (( ! SetFilePointer64( hFile, dwlVectorOffset )) ||
                ( ! WriteFile( hFile, pNewBitVector, dwVectorSize, &dwActual, NULL )) ||
                ( dwActual != dwVectorSize )) {
				
                dwLastError = GetLastError();
				
				if( dwLastError == ERROR_WRITE_PROTECT ){
					bMediaWriteProtected = true;
					DebugPrint(
						"COVERMON: Unable to save further data because the filesystem has been shutdown.\n"
						);

				} else {
					DebugPrint(
						"COVERMON: LOST DATA for %s because failed to write covdata file (error %d)\n",
						pNode->szBinaryName,
						dwLastError
						);
					
				}

                leave;
			}
			
            FlushFileBuffers( hFile );
			
            dwlFileSize = dwlVectorOffset + dwActual;
			
            //
            //  Now update the header.
            //
			
            dwNameLength  = strlen( pszTestName ) + 1;
            dwEntryLength = ROUNDUP2( sizeof( COVFILE_DIRECTORY ) + dwNameLength, 4 );
			
            if ((((PCHAR)pDirEntry - (PCHAR)pHeader ) + dwEntryLength + 4 ) > pHeader->dwHeaderLength ) {
				
                //
                //  Not enough room in existing header, need to grow it by multiple
                //  of ROUNDUP2( dwVectorSize, COVFILE_VECTOR_BOUNDARY ).
                //
				
                dwGrowSize  = ROUNDUPN( dwEntryLength, ROUNDUP2( dwVectorSize, COVFILE_VECTOR_BOUNDARY ));
				
                dwlFileSize = ROUNDUP2_64( dwlFileSize, COVFILE_VECTOR_BOUNDARY );
				
                dwlOffset   = ROUNDUP2_64( pHeader->dwHeaderLength, COVFILE_VECTOR_BOUNDARY );
				
                dwlExtent   = dwlOffset + dwGrowSize;
				
                dwlMoveBias = dwlFileSize - dwlOffset;
				
                dwActual    = 0;
				
                if (( pHeader->dwVersion == COVFILE_VERSION_201 ) &&
                    ( dwlFileSize + dwGrowSize > 0xF0000000 )) {
					
                    DebugPrint(
                        "COVERMON: LOST DATA for %s because covdata file is too large.\n"
                        "    Use covdata.exe tool to upgrade covdata file to new version.\n",
                        pNode->szBinaryName
                        );
					
                    leave;
				}
				
                pMoveBuffer = ExAllocatePoolWithTag( dwGrowSize, COVERMON_POOLTAG );
				
                if ( pMoveBuffer == NULL ) {
					
                    DebugPrint(
                        "COVERMON: LOST DATA for %s because failed to allocate buffer.\n",
                        pNode->szBinaryName
                        );
					
                    leave;
				}
				
                if (( ! SetFilePointer64( hFile, dwlOffset )) ||
                    ( ! ReadFile( hFile, pMoveBuffer, dwGrowSize, &dwActual, NULL ))) {
					
                    dwLastError = GetLastError();
					
                    DebugPrint(
                        "COVERMON: LOST DATA for %s because failed to read covdata file (error %d)\n",
                        pNode->szBinaryName,
                        dwLastError
                        );
					
                    leave;
				}
				
                if (( ! SetFilePointer64( hFile, dwlFileSize )) ||
                    ( ! WriteFile( hFile, pMoveBuffer, dwActual, &dwActual, NULL ))) {
					
                    dwLastError = GetLastError();
					
					if( dwLastError == ERROR_WRITE_PROTECT ){
						bMediaWriteProtected = true;
						DebugPrint(
							"COVERMON: Unable to save further data because the filesystem has been shutdown.\n"
							);

					} else {
						DebugPrint(
							"COVERMON: LOST DATA for %s because failed to write covdata file (error %d)\n",
							pNode->szBinaryName,
							dwLastError
							);
						
					}

                    leave;
				}
				
                FlushFileBuffers( hFile );
				
                dwlFileSize = dwlFileSize + dwActual;
				
                pNewHeader = HeapReAlloc(
					CoverMonHeapHandle,
					HEAP_ZERO_MEMORY,
					pHeader,
					pHeader->dwHeaderLength + dwGrowSize
					);
				
                if ( pNewHeader == NULL ) {
					
                    DebugPrint(
                        "COVERMON: LOST DATA for %s because failed to allocate memory (%d bytes).\n",
                        pNode->szBinaryName,
                        pHeader->dwHeaderLength + dwGrowSize
                        );
					
                    dwLastError = ERROR_OUTOFMEMORY;
                    leave;
				}
				
                pHeader = pNewHeader;
				
                pNode->pCachedCovFileHeader = pHeader;
				
                pHeader->dwHeaderLength += dwGrowSize;
				
//                pDirEntry = (PCOVFILE_DIRECTORY)((PCHAR)pHeader + sizeof( COVFILE_HEADER ));
                pDirEntry = (PCOVFILE_DIRECTORY)((PCHAR)pHeader + dwOffsetOfFirstDir);
				
                while ( pDirEntry->dwLengthOfEntry != 0 ) {
					
                    if ( pHeader->dwVersion == COVFILE_VERSION_201 ) {
						
                        pDirEntry201 = (PCOVFILE_DIRECTORY_201) pDirEntry;
						
                        if (( pDirEntry201->dwOffsetOfData >= dwlOffset ) &&
                            ( pDirEntry201->dwOffsetOfData <  dwlExtent )) {
							
                            ASSERT((( pDirEntry201->dwOffsetOfData + dwlMoveBias ) >> 32 ) == 0 );
							
                            pDirEntry201->dwOffsetOfData += (DWORD) dwlMoveBias;
							
						}
						
					}
                    else {
						
                        ASSERT( pHeader->dwVersion == COVFILE_VERSION );
						
                        if (( pDirEntry->dwlOffsetOfData >= dwlOffset ) &&
                            ( pDirEntry->dwlOffsetOfData <  dwlExtent )) {
							
                            pDirEntry->dwlOffsetOfData += dwlMoveBias;
							
						}
					}
					
                    pDirEntry = (PVOID)((PCHAR)pDirEntry + pDirEntry->dwLengthOfEntry );
					
				}
            }
			
            pDirEntry->dwLengthOfEntry = dwEntryLength;
            pDirEntry->dwHashOfName    = dwNameHash;
			
            if ( pHeader->dwVersion == COVFILE_VERSION_201 ) {
				
                pDirEntry201 = (PCOVFILE_DIRECTORY_201) pDirEntry;
				
                ASSERT(( dwlVectorOffset >> 32 ) == 0 );
				
                pDirEntry201->dwOffsetOfData = (DWORD)dwlVectorOffset;
                strcpy( pDirEntry201->szName, pszTestName );
				
			}
			
            else {
				
                ASSERT( pHeader->dwVersion == COVFILE_VERSION );
				
                pDirEntry->dwlOffsetOfData = dwlVectorOffset;
                strcpy( pDirEntry->szName, pszTestName );
				
			}
			
            if (( ! SetFilePointer64( hFile, 0 )) ||
                ( ! WriteFile( hFile, pHeader, pHeader->dwHeaderLength, &dwActual, NULL ))) {
				
                dwLastError = GetLastError();
				
				if( dwLastError == ERROR_WRITE_PROTECT ){
					bMediaWriteProtected = true;
					DebugPrint(
						"COVERMON: Unable to save further data because the filesystem has been shutdown.\n"
						);

				} else {
					DebugPrint(
						"COVERMON: LOST DATA for %s because failed to write covdata file (error %d)\n",
						pNode->szBinaryName,
						dwLastError
						);
				}

                leave;
			}
			
            FlushFileBuffers( hFile );
			
            pNode->dwlFileSize = dwlFileSize;   // only if everything successful

			// Now we need to cache this info
			if( bCacheAlways || bCacheMRU ){

				// If Cache MRU and the test names don't match, then delete the node
				if( bCacheMRU && 
					(pNode->pLastSavedBitVectorList != NULL) &&
					(_stricmp( pNode->pLastSavedBitVectorList->pszTestName, pszTestName ) != 0)
					){
					CovMonInternalClearCache( pNode );
				}

				// Only allocate new Node if necessary
				if( bCacheAlways || (bCacheMRU && (pNode->pLastSavedBitVectorList == NULL)) ){
					
					pNewVectorNode = HeapAlloc( CoverMonHeapHandle, 0, sizeof(SAVED_VECTOR) );
					
					if( pNewVectorNode == NULL ){
						DebugPrint( "COVERMON: Failed to allocate memory for vector node (%s, %d bytes).\n", pNode->szBinaryName, sizeof(SAVED_VECTOR) );
						dwLastError = ERROR_OUTOFMEMORY;
						leave;
					}
					
					pNewVectorNode->next = NULL;
					
					pNewVectorNode->pSavedBitVector = HeapAlloc( CoverMonHeapHandle, 0, dwVectorSize );
					
					if( pNewVectorNode->pSavedBitVector == NULL ){
						DebugPrint( "COVERMON: Failed to allocate memory for vector (%s, %d bytes).\n", pNode->szBinaryName, dwVectorSize );
						dwLastError = ERROR_OUTOFMEMORY;
						leave;
					}
					
					CopyMemory( pNewVectorNode->pSavedBitVector, pNewBitVector, dwVectorSize );
					
					pNewVectorNode->pszTestName = HeapAlloc( CoverMonHeapHandle, 0, strlen(pszTestName)+1 );
					
					if( pNewVectorNode->pszTestName == NULL ){
						DebugPrint( "COVERMON: Failed to allocate memory for vector name (%s, %d bytes).\n", pNode->szBinaryName, strlen(pszTestName)+1 );
						dwLastError = ERROR_OUTOFMEMORY;
						leave;
					}
					
					strcpy( pNewVectorNode->pszTestName, pszTestName );
				}

				if( pNode->pLastSavedBitVectorList == NULL ){
					pNode->pLastSavedBitVectorList = pNewVectorNode;
					
				} else if( bCacheAlways ){
					for( pTmpVectorNode = pNode->pLastSavedBitVectorList;
						pTmpVectorNode != NULL;
						pTmpVectorNode = pTmpVectorNode->next ){
						pPrvVectorNode = pTmpVectorNode;
					}
					pPrvVectorNode->next = pNewVectorNode;
					
				}
				
				pNode->dwSavedVectorCount++;
			}
        }
		
        bSuccess = true;
    }
	
    except( EXCEPTION_EXECUTE_HANDLER ) {
		
        DebugPrint(
            "COVERMON: LOST DATA for %s because an exception occurred while "
            "updating the file.  This probably indicates a corrupt data file.\n",
            pNode->szBinaryName
            );
		
        dwLastError = ERROR_FILE_CORRUPT;
	}
	
    if ( pMoveBuffer ) {
        ExFreePool( pMoveBuffer );
	}

	if( !(bCacheAlways || bCacheMRU) ){
		HeapFree( CoverMonHeapHandle, 0, pOldBitVector );
	}
    HeapFree( CoverMonHeapHandle, 0, pNewBitVector );
	
    SetLastError( dwLastError );
	
    return bSuccess;
}


DWORD
CovMonInternalPollAndSaveLogging(
    IN LPCSTR pszBinaryName,            // must be non-NULL, lowercase
    IN LPCSTR pszTestName               // must be non-NULL (case insensitive)
    )
{
    PCOVMON_REGISTERED_BINARY pNode;
    DWORD  dwReturnCode = 0;
    DWORD  dwDataSize = 0;
    DWORD  dwCheckSum = 0;
	MD5_HASH md5;
    bool   bSuccess;
    bool   bKernel;
	
    EnterCriticalSection( &PollBufferCritSect );

    try {
		
        bKernel  = false;
        bSuccess = false;

		if( bShutdownInProgress && bMediaWriteProtected ){
//			DebugPrint("COVERMON: Nope! No more! %s\n", pszBinaryName);
			leave;
		}

        try {

            bSuccess = false;
            /*bSuccess = CoveragePollLogging(
				pszBinaryName,
				dwPollBufferSize,
				pPollBuffer,
				&dwDataSize,
				&dwCheckSum,
				&md5
				);*/
			
            if (( ! bSuccess ) && ( hKernelCoverageHandle )) {
				
                bKernel = true;
				
                bSuccess = KernelCoveragePollLogging(
					hKernelCoverageHandle,
					pszBinaryName,
					dwPollBufferSize,
					pPollBuffer,
					&dwDataSize,
					&dwCheckSum
					);
			}
		}
        except( EXCEPTION_EXECUTE_HANDLER ) {
            SetLastError( GetExceptionCode() );
		}
		
        if ( ! bSuccess ) {
            dwReturnCode = GetLastError();
            DebugPrint(
                "COVERMON: Poll %s failed (error %d)\n",
                pszBinaryName,
                dwReturnCode
                );
            leave;
		}
		
        if ( DoesBufferContainAllZeros( pPollBuffer, dwDataSize )) {
            if ( ! bShutdownInProgress ) {
                DebugPrint(
                    "COVERMON: No new data for %s.\n",
                    pszBinaryName
                    );
			}
            leave;
		}
		
        ASSERT( DoesBufferContainOnlyHex01s( pPollBuffer, dwDataSize ));

		// If this is a kernel mode binary, then extract the MD5 hash
		// from the end of the logging buffer
		if( bKernel ){
			CopyMemory(&md5, (PCHAR)pPollBuffer + dwDataSize, MD5_SIZE);
		}

        //
        //  If we get to here, we polled some data and we need to save it.
        //
		
        DebugPrint( "COVERMON: Poll %s, save as \"%s\"\n", pszBinaryName, pszTestName );
		
        //
        //  Now find or add registration entry.
        //
		
        pNode = CovMonInternalFindOrAddRegistration( pszBinaryName, dwDataSize, dwCheckSum, bKernel, &md5 );
		
        if ( pNode == NULL ) {
            dwReturnCode = GetLastError();
            DebugPrint(
                "COVERMON: LOST DATA for %s because failed to allocate memory (error %d)\n",
                pszBinaryName,
                dwReturnCode
                );
            leave;
		}
		
        if ( pNode->hLogFileHandle != NULL ) {
			
            if (( pNode->dwCheckSumOfBinary != dwCheckSum ) ||
                ( pNode->dwBlockCount != dwDataSize )) {
				
                DebugPrint(
                    "COVERMON: Closing covdata file for %s (checksums don't match)\n",
                    pszBinaryName
                    );
				
                pNode->dwUniquifier = 0;
				
                HeapFree( CoverMonHeapHandle, 0, pNode->pCachedCovFileHeader );
                pNode->pCachedCovFileHeader = NULL;
				
                CloseHandle( pNode->hLogFileHandle );
                pNode->hLogFileHandle = NULL;
				
                pNode->dwCheckSumOfBinary = dwCheckSum;
                pNode->dwBlockCount       = dwDataSize;
				
			}
		}
		
        if ( pNode->hLogFileHandle == NULL ) {
            if ( ! CovMonInternalOpenLogFile( pNode )) {
                dwReturnCode = GetLastError();
                leave;
			}
		}
		
		if ( ! bMediaWriteProtected ){
			if ( ! CovMonInternalUpdateLogFile( pNode, pszTestName )) {
				dwReturnCode = GetLastError();
				leave;
			}
		}
    }
	
    finally {
		
        LeaveCriticalSection( &PollBufferCritSect );
		
	}
	
    return dwReturnCode;
}


DWORD
WINAPI
CovMonInternalPollLoggingAllBinaries(
    LPCSTR TestName
    )
{
    DWORD dwReturnOne;
    DWORD dwReturnAny;
    DWORD dwDataSize;
    DWORD nBinaries;
    bool  bSuccess;
    PCHAR p;

    if ( !CovMonIsRunning() ) {
        return ERROR_INVALID_HANDLE;
    }

    EnterCriticalSection( &NameBufferCritSect );

    if (( TestName == NULL ) || ( *TestName == 0 )) {
        TestName = "(no test name)";
	}
	
    dwReturnAny = 0;
    nBinaries = 0;
	
    if ( hKernelCoverageHandle ) {
		
        bSuccess = KernelCoverageEnumerateBinaries(
			hKernelCoverageHandle,
			sizeof( szNameBuffer ),
			szNameBuffer,
			&dwDataSize
			);
		
        if ( bSuccess ) {

            for ( p = szNameBuffer; *p; p += (strlen(p)+MD5_SIZE+2) ) {
				
                dwReturnOne = CovMonInternalPollAndSaveLogging( p, TestName );
				
                if ( ! dwReturnAny ) {
                    dwReturnAny = dwReturnOne;
				}
				
                nBinaries++;
			}
		}
	}
	
    LeaveCriticalSection( &NameBufferCritSect );

    return ( dwReturnAny ? dwReturnAny : ( nBinaries ? 0 : ERROR_FILE_NOT_FOUND ));
}


VOID
CovMonInternalCloseLogFile(
    PCOVMON_REGISTERED_BINARY pNode
    )
{
    if ( pNode->hLogFileHandle != NULL ) {

		if( (bCacheAlways || bCacheMRU) &&
			(pNode->pLastSavedBitVectorList != NULL)
			){
			DebugPrint("COVERMON: Clearing cache for %s\n", pNode->szBinaryName);
			CovMonInternalClearCache( pNode );
		}
		
        DebugPrint(
            "COVERMON: Closing covdata file for %s\n",
            pNode->szBinaryName
            );
		
        pNode->dwUniquifier = 0;
		
        CloseHandle( pNode->hLogFileHandle );
        pNode->hLogFileHandle = NULL;
		
        if ( pNode->pCachedCovFileHeader != NULL ) {
            HeapFree( CoverMonHeapHandle, 0, pNode->pCachedCovFileHeader );
            pNode->pCachedCovFileHeader = NULL;
		}
	}
}


DWORD
WINAPI
CovMonInternalCloseLogFileAllBinaries(
    VOID
    )
{
    PCOVMON_REGISTERED_BINARY pNode;

    if ( !CovMonIsRunning() ) {
        return ERROR_INVALID_HANDLE;
    }
	
    EnterCriticalSection( &RegistrationCritSect );
	
    //
    //  Walk list of registered binaries
    //
	
    pNode = RegisteredBinaryList;
	
    while ( pNode != (PCOVMON_REGISTERED_BINARY)&RegisteredBinaryList ) {
		
        CovMonInternalCloseLogFile( pNode );
		
        pNode = pNode->pNext;
		
	}
	
    LeaveCriticalSection( &RegistrationCritSect );
	
    return ERROR_SUCCESS;
}


BOOL
WINAPI
CovMonRegisterNoImportCoverageBinary(
    HANDLE ImageBase
    )
{
    if ( !CovMonIsRunning() ) {
        SetLastError( ERROR_INVALID_HANDLE );
        return FALSE;
    }

    return KernelRegisterNoImportCoverageBinary( hKernelCoverageHandle, ImageBase );
}


BOOL
WINAPI
CovMonRegisterAllNoImportCoverageBinaries(
    VOID
    )
{
    if ( !CovMonIsRunning() ) {
        SetLastError( ERROR_INVALID_HANDLE );
        return FALSE;
    }

    return KernelRegisterAllNoImportCoverageBinaries( hKernelCoverageHandle );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\coverage\bbt\bbreg.h ===
#ifndef __BBREG_H__
#define __BBREG_H__

#ifndef DWORD
#define DWORD unsigned long
#endif

#include "md5.h"

#define BBREG_VERSION	0x00030002

typedef struct _BBREG_HEADER	BBREG_HEADER,	*PBBREG_HEADER;

struct _BBREG_HEADER {
	DWORD	dwVersion;
	DWORD	dwSizeOfBBRegHeader;
	DWORD	dwOffsetOfBinaryName;
	DWORD	dwOffsetOfGUID;
	DWORD	dwOffsetOfLoggingRegion;
	DWORD	dwCheckSumOfBinary;
	PCHAR	pBaseOfLoggingRegion;
	DWORD	dwSizeOfLoggingRegion;
};


#endif __BBREG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\cover35src\sys20\coversys.c ===
//
//  coversys.c
//
//  tommcg, 3/1/95
//

#include <ntddk.h>
#include <ntimage.h>
#include <stdarg.h>
#include "coversys.h"
#include "bbreg.h"

//
//  I can't figure out how to include both ntddk.h and ntrtl.h and ntexapi.h,
//  so I putting private typedefs and prototypes here.  These interfaces should
//  probably be public to DDK developers anyway.  Shoot me.
//

typedef struct _SYSTEM_BASIC_INFORMATION {
    ULONG Reserved;
    ULONG TimerResolution;
    ULONG PageSize;
    ULONG NumberOfPhysicalPages;
    ULONG LowestPhysicalPageNumber;
    ULONG HighestPhysicalPageNumber;
    ULONG AllocationGranularity;
    ULONG MinimumUserModeAddress;
    ULONG MaximumUserModeAddress;
    KAFFINITY ActiveProcessorsAffinityMask;
    CCHAR NumberOfProcessors;
} SYSTEM_BASIC_INFORMATION, *PSYSTEM_BASIC_INFORMATION;

typedef struct _RTL_PROCESS_MODULE_INFORMATION {
    HANDLE Section;                 // Not filled in
    PVOID MappedBase;
    PVOID ImageBase;
    ULONG ImageSize;
    ULONG Flags;
    USHORT LoadOrderIndex;
    USHORT InitOrderIndex;
    USHORT LoadCount;
    USHORT OffsetToFileName;
    UCHAR  FullPathName[ 256 ];
} RTL_PROCESS_MODULE_INFORMATION, *PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES {
    ULONG NumberOfModules;
    RTL_PROCESS_MODULE_INFORMATION Modules[ 1 ];
} RTL_PROCESS_MODULES, *PRTL_PROCESS_MODULES;

typedef enum _SYSTEM_INFORMATION_CLASS {
    SystemBasicInformation,
    SystemProcessorInformation,
    SystemPerformanceInformation,
    SystemTimeOfDayInformation,
    SystemPathInformation,
    SystemProcessInformation,
    SystemCallCountInformation,
    SystemDeviceInformation,
    SystemProcessorPerformanceInformation,
    SystemFlagsInformation,
    SystemCallTimeInformation,
    SystemModuleInformation
    } SYSTEM_INFORMATION_CLASS;

NTSYSAPI
NTSTATUS
NTAPI
NtQuerySystemInformation (
    IN  SYSTEM_INFORMATION_CLASS SystemInformationClass,
    OUT PVOID  SystemInformation,
    IN  ULONG  SystemInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );

int __cdecl _vsnprintf( char *, size_t, const char *, va_list );

#ifndef STDCALL
#define STDCALL __stdcall
#endif

#ifndef INLINE
#define INLINE __inline
#endif

#define ROUNDUP2( x, n ) ((((ULONG)(x)) + (((ULONG)(n)) - 1 )) & ~(((ULONG)(n)) - 1 ))

//#define DECLSPEC __declspec( dllexport )
#define DECLSPEC

typedef struct _REGISTERED_BINARY REGISTERED_BINARY, *PREGISTERED_BINARY;

struct _REGISTERED_BINARY {
    PREGISTERED_BINARY pNext;                   // singly linked list
    PCHAR              BaseOfLoggingRegion;
    ULONG              SizeOfLoggingRegion;
    ULONG              CheckSumOfBinary;
    PDRIVER_OBJECT     DriverObject;
    PDRIVER_UNLOAD     DriverUnload;
    PVOID              CapturedLogging;
	MD5_HASH           md5;						// pointer to GUID which goes after binary name
    CHAR               BinaryName[ 1 ];         // variable length
    };

NTSTATUS
STDCALL
DriverEntry(
    IN PDRIVER_OBJECT DriverObject
    );

VOID
STDCALL
DriverUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
STDCALL
DeviceOpen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
STDCALL
DeviceClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
STDCALL
DeviceIoctl(
    IN PDEVICE_OBJECT IoctlDeviceObject,
    IN PIRP Irp
    );

VOID
STDCALL
RegisterNoImportCoverageBinaries(
    VOID
    );

VOID
STDCALL
RegisterNoImportCoverageBinary(
    IN PVOID ImageBase
    );

DECLSPEC
VOID
STDCALL
CoverageRegisterBinary(
    IN LPCSTR BinaryName,
    IN LPCSTR pszGUID,
    IN ULONG  CheckSumOfBinary,
    IN PCHAR  BaseOfLoggingRegion,
    IN ULONG  SizeOfLoggingRegion
    );

DECLSPEC
VOID
STDCALL
InternalCoverageRegisterBinary(
    IN LPCSTR BinaryName,
	IN LPCSTR pszGUID,
    IN ULONG  CheckSumOfBinary,
    IN PCHAR  BaseOfLoggingRegion,
    IN ULONG  SizeOfLoggingRegion
    );

DECLSPEC
VOID
STDCALL
CoverageRegisterBinaryWithStruct(
    IN PBBREG_HEADER pBBHeader
    );

DECLSPEC
VOID
STDCALL
CoverageRegisterUnloadHook(
    IN     LPCSTR         BinaryName,
    IN OUT PDRIVER_OBJECT DriverObject
    );

DECLSPEC
VOID
STDCALL
CoverageUnRegisterBinary(
    IN LPCSTR BinaryName
    );

VOID
STDCALL
CoverageUnloadDriver(
    IN PDRIVER_OBJECT DriverObject
    );

VOID
STDCALL
CoverageUnRegisterBinaryNode(
    IN PREGISTERED_BINARY pNode
    );


NTSTATUS
STDCALL
CoverageEnumerateBinaries(
    IN  ULONG  BufferSize,
    OUT PCHAR  Buffer,
    OUT PULONG ActualSize
    );

NTSTATUS
STDCALL
CoveragePollLogging(
    IN  LPCSTR BinaryName,
    IN  ULONG  BufferSize,
    OUT PVOID  Buffer,
    OUT PULONG ActualSize,
    OUT PULONG CheckSum
    );

NTSTATUS
STDCALL
CoverageFlushLogging(
    IN LPCSTR BinaryName OPTIONAL
    );

VOID
OrBufferWithBuffer(
    IN OUT PVOID TargetBuffer,
    IN     PVOID SourceBuffer,
    IN     ULONG Size
    );

BOOLEAN
DoesBufferContainAllZeros(
    IN PVOID Buffer,
    IN ULONG Size
    );

VOID
MoveLoggingInformationToBuffer(
    IN     ULONG BufferSize,
    IN OUT PVOID ActiveBuffer,
       OUT PVOID ReturnBuffer
    );

VOID
CoverageDbgPrint(
    IN LONG  InfoLevel,
    IN PCHAR Format,
    ...
    );


//
//  Default data segment for uninitialized data is .bss which is then
//  merged into initialized data segment .data.  We want these following
//  uninitialized data objects to be in .bss or .data because it must
//  be non-paged memory.
//

RTL_CRITICAL_SECTION RegistrationMutex;

#pragma data_seg( "PAGEDATA" )  // remainder of data in this driver is pageable

//
//  Internal CoverageDbgPrint is paged code.  This whole driver is essentially
//  paged code.  If we need to call CoverageDbgPrint in the future from
//  non-paged code, we need to move this CoverageDbgLogLevel variable to
//  non-paged data section.
//

enum {
    DBGLOG_NONE    = 0,
    DBGLOG_ERROR   = 1,
    DBGLOG_WARNING = 2,
    DBGLOG_INFO    = 3,
    DBGLOG_DEBUG   = 4
    } CoverageDbgLogLevel;

BOOLEAN DriverInitialized;

PREGISTERED_BINARY RegisteredBinaryList = (PREGISTERED_BINARY)&RegisteredBinaryList;

#pragma  code_seg( "INIT" )      //  DriverEntry is discardable after init
#pragma const_seg( "INITDATA" )  //  for const strings in code
#pragma  data_seg( "INITDATA" )  //  for strings in INIT code


NTSTATUS
STDCALL
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject
    )
    {
    PDEVICE_OBJECT           DeviceObject = NULL;
    OBJECT_STRING            DeviceName;
    NTSTATUS                 Status;
    ULONG                    DefaultDebugLogLevel;

    CoverageDbgLogLevel  = DBGLOG_INFO;
    DefaultDebugLogLevel = DBGLOG_INFO;

    RtlInitObjectString( &DeviceName, OTEXT("\\??\\Coverage:") );

    Status = IoCreateDevice(
                 DriverObject,
                 0,
                 &DeviceName,
                 FILE_DEVICE_UNKNOWN,
                 0,
                 TRUE,
                 &DeviceObject
                 );

    if ( NT_SUCCESS( Status )) {

        DriverObject->DriverUnload                         = DriverUnload;
        DriverObject->MajorFunction[IRP_MJ_CREATE]         = DeviceOpen;
        DriverObject->MajorFunction[IRP_MJ_CLOSE]          = DeviceClose;
        DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DeviceIoctl;

        RtlInitializeCriticalSection( &RegistrationMutex );

        DriverInitialized = TRUE;

        CoverageDbgPrint( DBGLOG_INFO, "COVERAGE: Driver loaded\n" );

        //
        //  Now attempt to register "no import" coverage binaries
        //  that have already been loaded.
        //
        RegisterNoImportCoverageBinaries();

        //
        // The driver is supposed to clear that flag when the device is ready to be used.
        // NT used to manually clear the flag for boot loaded drivers, but in Xbox
        // we don't do that, so do it manually here
        //
        DeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

        }
    else {
        CoverageDbgPrint( DBGLOG_ERROR, "COVERAGE: Driver load failed (0x%x)\n", Status );
        }

    return Status;
    }


VOID
STDCALL
RegisterNoImportCoverageBinaries(
    VOID
    )
    {
    SYSTEM_BASIC_INFORMATION BasicInformation;
    PRTL_PROCESS_MODULES pModuleInformation;
    RTL_PROCESS_MODULES ModuleInformation;
    ULONG AllocationSize;
    NTSTATUS Status;
    ULONG i;

    Status = NtQuerySystemInformation(
                 SystemBasicInformation,
                 &BasicInformation,
                 sizeof( BasicInformation ),
                 NULL
                 );

    if ( NT_SUCCESS( Status )) {

        ModuleInformation.NumberOfModules = 0;

        NtQuerySystemInformation(
           SystemModuleInformation,
           &ModuleInformation,
           sizeof( ModuleInformation ),
           NULL
           );

        if ( ModuleInformation.NumberOfModules != 0 ) {

            AllocationSize = sizeof( RTL_PROCESS_MODULES ) +
                             sizeof( RTL_PROCESS_MODULE_INFORMATION ) *
                             ModuleInformation.NumberOfModules;

            pModuleInformation = ExAllocatePoolWithTag(
                                     PagedPool,
                                     AllocationSize,
                                     'RVOC'
                                     );

            if ( pModuleInformation != NULL ) {

                Status = NtQuerySystemInformation(
                            SystemModuleInformation,
                            pModuleInformation,
                            AllocationSize,
                            NULL
                            );

                if ( NT_SUCCESS( Status )) {

                    for ( i = 0; i < pModuleInformation->NumberOfModules; i++ ) {

#if 0   // too verbose

                        CoverageDbgPrint(
                             DBGLOG_DEBUG,
                             "COVERAGE: Inspecting module at %08X (%s)\n",
                             pModuleInformation->Modules[ i ].ImageBase,
                             pModuleInformation->Modules[ i ].FullPathName + pModuleInformation->Modules[ i ].OffsetToFileName
                             );

#endif  // too verbose

                        RegisterNoImportCoverageBinary( pModuleInformation->Modules[ i ].ImageBase );

                        }
                    }

                else {
                    CoverageDbgPrint( DBGLOG_DEBUG, "COVERAGE: Failed querying system modules info (0x%x)\n", Status );
                    }

                ExFreePool( pModuleInformation );
                }

            else {
                CoverageDbgPrint( DBGLOG_DEBUG, "COVERAGE: Failed allocating memory for querying system modules info\n" );
                }
            }

        else {
            CoverageDbgPrint( DBGLOG_DEBUG, "COVERAGE: Failed querying system modules info\n" );
            }
        }

    else {
        CoverageDbgPrint( DBGLOG_DEBUG, "COVERAGE: Failed querying system info (0x%x)\n", Status );
        }
    }


VOID
STDCALL
RegisterNoImportCoverageBinary(
    IN PVOID ImageBase
    )
    {
    PIMAGE_DOS_HEADER     DosHeader;
    PIMAGE_NT_HEADERS     NtHeader;
    PIMAGE_SECTION_HEADER SectionHeader;
    ULONGLONG             SectionName;
    ULONG                 SectionCount;
    PCHAR                 SectionBase;
    ULONG                 i;

    //
    //  We assume that each module's PE header is resident at its mapped
    //  base address.  We walk the PE header and PE section table looking
    //  for ".cover" section.  If we find it, we register the binary.
    //
    //  If we do eventually make this routine callable other than during
    //  DriverEntry, then we'll need to move it to the PAGE section rather
    //  than the INIT section.
    //

    try {

        if ( ! MmIsAddressValid( ImageBase )) {
            leave;
            }

        DosHeader = (PIMAGE_DOS_HEADER) ImageBase;

        if ( DosHeader->e_magic == IMAGE_DOS_SIGNATURE ) {

            NtHeader = (PIMAGE_NT_HEADERS)((PCHAR)ImageBase + DosHeader->e_lfanew );

            if ( ! MmIsAddressValid( NtHeader )) {
                leave;
                }
            }
        else {
            NtHeader = (PIMAGE_NT_HEADERS)( ImageBase );
            }

        if ( NtHeader->Signature != IMAGE_NT_SIGNATURE ) {
            leave;
            }

        SectionHeader = IMAGE_FIRST_SECTION( NtHeader );
        SectionCount  = NtHeader->FileHeader.NumberOfSections;

        if ( ! MmIsAddressValid( &SectionHeader[ SectionCount ] )) {
            leave;
            }

        for ( i = 0; i < SectionCount; i++ ) {

            //
            //  To make section name comparison fast, read it into an 8-byte
            //  DWORDLONG, do a sneaky lowercase by ORing all the characters
            //  with 0x20, which also has the effect of "normalizing" any
            //  zero byte characters to spaces.  Then we can just do a simple
            //  DWORDLONG comparison with the ".cover  " equivalent value.
            //

            SectionName  = *(UNALIGNED ULONGLONG*)( &SectionHeader[ i ].Name );
            SectionName |= 0x2020202020202020;

#if 0   // too verbose

            CoverageDbgPrint(
                 DBGLOG_DEBUG,
                 "COVERAGE: Inspecting section \"%c%c%c%c%c%c%c%c\" at %08X\n",
                 (UCHAR)( SectionName >>  0 ),
                 (UCHAR)( SectionName >>  8 ),
                 (UCHAR)( SectionName >> 16 ),
                 (UCHAR)( SectionName >> 24 ),
                 (UCHAR)( SectionName >> 32 ),
                 (UCHAR)( SectionName >> 40 ),
                 (UCHAR)( SectionName >> 48 ),
                 (UCHAR)( SectionName >> 56 ),
                 (PCHAR)ImageBase + SectionHeader[ i ].VirtualAddress
                 );

#endif  // too verbose

            if ( SectionName == 0x20207265766F632E ) {      // ".cover  "

                //
                //  Data stored in coverage section looks like this:
                //
                //      Offset 0: DWORD  SizeOfLoggingRegion
                //      Offset 4: DWORD  CheckSumOfOriginalBinary
                //      Offset 8: CHAR[] FileNameOfOriginalBinary (null terminated string)
                //      Offset X: CHAR[] LoggingBuffer (size is SizeOfLoggingRegion)
                //
                //      X is computed as ROUNDUP2(( strlen( name ) + 1 + 8 ), 32 ) to
                //      place the LoggingBuffer on a 32-byte boundary.
                //

                SectionBase = (PVOID)((PCHAR)ImageBase + SectionHeader[ i ].VirtualAddress );

                CoverageDbgPrint( DBGLOG_DEBUG, "COVERAGE: Found \".cover\" section in image %08X at %08X\n", ImageBase, SectionBase );

                if ( MmIsAddressValid( SectionBase )) {

					CoverageRegisterBinaryWithStruct( (PBBREG_HEADER)SectionBase );

/*                    SizeOfLoggingRegion = *(PULONG)( SectionBase + 0 );
                    OriginalCheckSum    = *(PULONG)( SectionBase + 4 );
                    OriginalFileName    = SectionBase + 8;
                    BaseOfLoggingRegion = SectionBase + ROUNDUP2(( strlen( OriginalFileName ) + 1 + 8 ), 32 );

                    CoverageRegisterBinary(
                        OriginalFileName,
                        OriginalCheckSum,
                        BaseOfLoggingRegion,
                        SizeOfLoggingRegion
                        );*/
                    }

                break;
                }
            }
        }

    except( EXCEPTION_EXECUTE_HANDLER ) {
        }
    }


#pragma  code_seg( "PAGE" )      // remainder of code in this driver is pageable
#pragma const_seg( "PAGEDATA" )  // for const strings in code
#pragma  data_seg( "PAGEDATA" )  // remainder of data in this driver is pageable

VOID
CoverageDbgPrint(
    IN LONG  InfoLevel,
    IN PCHAR Format,
    ...
    )
    {
    CHAR Buffer[ 512 ];
    va_list ArgList;

    va_start( ArgList, Format );

    if ( InfoLevel <= CoverageDbgLogLevel ) {

        _vsnprintf( Buffer, sizeof( Buffer ), Format, ArgList );
        Buffer[ sizeof( Buffer ) - 2 ] = '\n';
        Buffer[ sizeof( Buffer ) - 1 ] = 0;
        DbgPrint( Buffer );
	}

    va_end( ArgList );
}


//
//  Note that following DeviceOpen and DeviceClose implementations are the
//  exact same code.  The linker is kind enough to "fold" them into a single
//  piece of code (identical comdat elimination), so no need to obfuscate the
//  source code here by creating a single function named DeviceOpenClose that
//  does both duties.
//

NTSTATUS
STDCALL
DeviceOpen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return STATUS_SUCCESS;
}


NTSTATUS
STDCALL
DeviceClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return STATUS_SUCCESS;
}


NTSTATUS
STDCALL
DeviceIoctl(
    IN PDEVICE_OBJECT IoctlDeviceObject,
    IN PIRP Irp
    )
{
    PIO_STACK_LOCATION IrpStack      = IoGetCurrentIrpStackLocation( Irp );
    PVOID              OutBuffer     = Irp->UserBuffer;
    ULONG              OutBufferSize = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    ULONG              InBufferSize  = IrpStack->Parameters.DeviceIoControl.InputBufferLength;
    PVOID              InBuffer      = IrpStack->Parameters.DeviceIoControl.InputBuffer;
    ULONG              ActualSize    = 0;
    NTSTATUS           Status;
	
    switch ( IrpStack->Parameters.DeviceIoControl.IoControlCode ) {
		
	case IOCTL_COVERAGE_ENUM_BINARIES:
		
		Status = CoverageEnumerateBinaries(
			OutBufferSize,
			OutBuffer,
			&ActualSize
			);
		break;
		
	case IOCTL_COVERAGE_POLL_LOGGING:
		
		Status = CoveragePollLogging(
			InBuffer,              /* pszBinaryName      */
			OutBufferSize,
			OutBuffer,
			&ActualSize,
			(PULONG)InBufferSize   /* return checksum */
			);
		break;
		
	case IOCTL_COVERAGE_FLUSH_LOGGING:
		
		Status = CoverageFlushLogging(
			InBuffer                /* pszBinaryName */
			);
		break;

    case IOCTL_COVERAGE_REGISTER_NO_IMPORT_BINARY:
        if ( InBufferSize == sizeof(HANDLE) ) {
            RegisterNoImportCoverageBinary( InBuffer );
            Status = STATUS_SUCCESS;
        } else {
            Status = STATUS_INVALID_PARAMETER;
        }
        break;

    case IOCTL_COVERAGE_REGISTER_ALL_NO_IMPORT_BINARIES:
        if ( InBufferSize == 0 ) {
            RegisterNoImportCoverageBinaries();
            Status = STATUS_SUCCESS;
        } else {
            Status = STATUS_INVALID_PARAMETER;
        }
		
	default:
		
		Status = STATUS_INVALID_PARAMETER;
		
	}
	
    Irp->IoStatus.Status      = Status;
    Irp->IoStatus.Information = ActualSize;
	
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
	
    return Status;
}


//
//  Following support functions are inlined, so do not actually exist
//  as functions in the binary.
//

VOID
INLINE
AcquireRegistrationMutex(
    VOID
    )
{
    RtlEnterCriticalSection( &RegistrationMutex );
}


VOID
INLINE
AcquireRegistrationMutexIfInitialized(
    VOID
    )
{
    if ( DriverInitialized ) RtlEnterCriticalSection( &RegistrationMutex );
}


VOID
INLINE
ReleaseRegistrationMutex(
    VOID
    )
{
    RtlLeaveCriticalSection( &RegistrationMutex );
}


VOID
INLINE
ReleaseRegistrationMutexIfInitialized(
    VOID
    )
{
    if ( DriverInitialized ) RtlLeaveCriticalSection( &RegistrationMutex );
}


PREGISTERED_BINARY
INLINE
AllocateRegisteredBinaryNode(
    IN ULONG BinaryNameLength
    )
{
    return ExAllocatePoolWithTag(
		PagedPool,
		sizeof( REGISTERED_BINARY ) + BinaryNameLength,
		'RVOC'
		);
}


PREGISTERED_BINARY
INLINE
AllocateRegisteredBinaryNodeWithName(
    IN LPCSTR BinaryName
    )
{
    ULONG NameLength = strlen( BinaryName ) + 1;
    PREGISTERED_BINARY pNode = AllocateRegisteredBinaryNode( NameLength );
	
    if ( pNode != NULL ) {
        RtlZeroMemory( pNode, sizeof( *pNode ) - sizeof( pNode->BinaryName ));
        RtlCopyMemory( pNode->BinaryName, BinaryName, NameLength );
	}
	
    return pNode;
}


PREGISTERED_BINARY
INLINE
AllocateRegisteredBinaryNodeWithNameAndGUID(
    IN LPCSTR BinaryName,
	IN LPCSTR pszGUID
    )
{
    ULONG NameLength = strlen( BinaryName ) + 1;
	ULONG GUIDLength = MD5_SIZE;
    PREGISTERED_BINARY pNode = AllocateRegisteredBinaryNode( NameLength );

    if ( pNode != NULL ) {
        RtlZeroMemory( pNode, sizeof( *pNode ) - sizeof( pNode->BinaryName ));
        RtlCopyMemory( pNode->BinaryName, BinaryName, NameLength );

//		pNode->pszGUID = pNode->BinaryName + NameLength;
		RtlCopyMemory( &(pNode->md5), pszGUID, GUIDLength );
	}
	
    return pNode;
}


VOID
INLINE
AddRegisteredBinaryNodeToList(
    IN PREGISTERED_BINARY pPrev,
    IN PREGISTERED_BINARY pNode
    )
{
    pNode->pNext = pPrev->pNext;
    pPrev->pNext = pNode;
}


//
//  Following functions are exported for coverage-instrumented binaries to
//  register at load and deregister at unload with the coverage.sys driver.
//  Note that these functions are in paged memory, so should never instrument
//  a driver with /Entry or /EntryExports if the instrumented entry points
//  get called at DPC level or higher where touching non-paged code or data
//  is not allowed.
//


DECLSPEC
VOID
STDCALL
CoverageRegisterBinary(
    IN LPCSTR BinaryName,               // must be lowercase or case consistent
	IN LPCSTR pszGUID,
    IN ULONG  CheckSumOfBinary,         // checksum of original binary
    IN PCHAR  BaseOfLoggingRegion,      // instrumented logging region base
    IN ULONG  SizeOfLoggingRegion       // instrumented logging region size
    )
{
    InternalCoverageRegisterBinary(
        BinaryName,
		NULL,
        CheckSumOfBinary,
        BaseOfLoggingRegion,
        SizeOfLoggingRegion
        );
}


DECLSPEC
VOID
STDCALL
InternalCoverageRegisterBinary(
    IN LPCSTR BinaryName,               // must be lowercase or case consistent
	IN LPCSTR pszGUID,
    IN ULONG  CheckSumOfBinary,         // checksum of original binary
    IN PCHAR  BaseOfLoggingRegion,      // instrumented logging region base
    IN ULONG  SizeOfLoggingRegion       // instrumented logging region size
    )
{
    PCHAR EndOfLoggingRegion;
    PREGISTERED_BINARY pNode;
    PREGISTERED_BINARY pPrev;
    BOOLEAN Found = FALSE;

    //
    //  This is an exported entry point, and it's possible that this will
    //  get called before our DriverEntry gets a chance to initialize (when
    //  a binary that imports this binary gets loaded first).  If this
    //  happens, it is a bad thing because we can never get a DriverObject
    //  created for this driver, so we can never communicate with user mode.
    //  Detect if this is the case and display a warning.
    //

    if ( ! DriverInitialized ) {
        CoverageDbgPrint(
            DBGLOG_WARNING,
            "COVERAGE: %s loaded before coverage.sys initialized, kernel-mode\n"
            "    logging data may be lost (inaccessible).\n",
            BinaryName
            );
	}

    AcquireRegistrationMutexIfInitialized();

    EndOfLoggingRegion = BaseOfLoggingRegion + SizeOfLoggingRegion - 1;

    //
    //  Walk list of registered binaries looking for name or logging region
    //

    pPrev = (PREGISTERED_BINARY)&RegisteredBinaryList;
    pNode = RegisteredBinaryList;

    while ( pNode != (PREGISTERED_BINARY)&RegisteredBinaryList ) {

        //
        //  Test if names match.  Names are always lowercase from BBCOVER.
        //

        if ( strcmp( pNode->BinaryName, BinaryName ) == 0 ) {

            //
            //  Reloading binary with same name.  If not same checksum or
            //  size of logging region, need to invalidate old data.
            //

            if (( pNode->CheckSumOfBinary    != CheckSumOfBinary    ) ||
                ( pNode->SizeOfLoggingRegion != SizeOfLoggingRegion )) {

                //
                //  Reloading different version of binary with same name.
                //  Must invalidate any existing data for previous binary.
                //

                if ( pNode->CapturedLogging ) {

                    if ( ! DoesBufferContainAllZeros( pNode->CapturedLogging, pNode->SizeOfLoggingRegion )) {

						CoverageDbgPrint(
							DBGLOG_ERROR,
							"COVERAGE: %s logging data lost when new version of driver\n"
							"    was loaded because data was not saved after previous version\n"
							"    of driver was unloaded.\n",
							BinaryName
							);
					}

                    ExFreePool( pNode->CapturedLogging );
                    pNode->CapturedLogging     = NULL;
                    pNode->CheckSumOfBinary    = CheckSumOfBinary;
                    pNode->BaseOfLoggingRegion = NULL;
                    pNode->SizeOfLoggingRegion = 0;

				}
			}

            //
            //  Names match, but now need to determine:
            //
            //      1) original driver still loaded, just re-registering (pnode->base == newbase)
            //      2) original driver unloaded, now reloading (pnode->base == NULL)
            //      3) original driver still loaded, loading new instance (pnode->base != NULL) && (pnode->base != newbase)
            //

			if ( pNode->BaseOfLoggingRegion == BaseOfLoggingRegion ){

				//
				// Re-registering at same address, nothing to do.
				//

                CoverageDbgPrint(
                    DBGLOG_INFO,
                    "COVERAGE: %s re-registered at same address (0x%x - 0x%x)\n",
                    BinaryName,
                    BaseOfLoggingRegion,
                    EndOfLoggingRegion
                    );

				Found = TRUE;
				break;
			}
			
			else if ( pNode->BaseOfLoggingRegion == NULL ) {

                //
                //  Originally unloaded, now reloading at new address.
                //

                CoverageDbgPrint(
                    DBGLOG_INFO,
                    "COVERAGE: %s registered (0x%x - 0x%x) (reloaded)\n",
                    BinaryName,
                    BaseOfLoggingRegion,
                    EndOfLoggingRegion
                    );

                pNode->BaseOfLoggingRegion = BaseOfLoggingRegion;
                pNode->SizeOfLoggingRegion = SizeOfLoggingRegion;

                Found = TRUE;
                break;
			}

            else if ( pNode->BaseOfLoggingRegion != BaseOfLoggingRegion ) {

                //
                //  Original is still loaded (or unload hook never called),
                //  so need to create new instance. (below)
                //

                CoverageDbgPrint(
                    DBGLOG_INFO,
                    "COVERAGE: %s re-registered (0x%x - 0x%x)\n",
                    BinaryName,
                    BaseOfLoggingRegion,
                    EndOfLoggingRegion
                    );

                break;
			}
		}

        else {

            //
            //  Not the same binary name, sanity test logging regions.
            //

            if (( pNode->BaseOfLoggingRegion != NULL ) &&
                (( pNode->BaseOfLoggingRegion < EndOfLoggingRegion  ) ^
                 (( pNode->BaseOfLoggingRegion + pNode->SizeOfLoggingRegion - 1 ) < BaseOfLoggingRegion ))) {

                //
                //  Some other binary already logging in requested range.
                //  This should never happen since a driver that can unload
                //  must have gone through our unload hook which would have
                //  zeroed the registered logging region.  We might hit this
                //  if we're not instrumenting to hook unload routines.
                //

                CoverageDbgPrint(
                    DBGLOG_WARNING,
                    "COVERAGE: %s logging region (0x%x - 0x%x) overlaps region\n"
                    "    previously occupied by %s (%s - %s).  Must assume\n"
                    "    %s has been unloaded and will now be deregistered.\n",
                    BinaryName,
                    BaseOfLoggingRegion,
                    EndOfLoggingRegion,
                    pNode->BinaryName,
                    pNode->BaseOfLoggingRegion,
                    pNode->BaseOfLoggingRegion + pNode->SizeOfLoggingRegion - 1,
                    pNode->BinaryName
                    );

                pNode->BaseOfLoggingRegion = NULL;

			}
		}

        pPrev = pNode;
        pNode = pNode->pNext;

	}

    if ( ! Found ) {

        //
        //  New binary, add to list.
        //

        pNode = AllocateRegisteredBinaryNodeWithNameAndGUID( BinaryName, pszGUID );

        if ( pNode ) {

            pNode->BaseOfLoggingRegion = BaseOfLoggingRegion;
            pNode->SizeOfLoggingRegion = SizeOfLoggingRegion;
            pNode->CheckSumOfBinary    = CheckSumOfBinary;

            AddRegisteredBinaryNodeToList( pPrev, pNode );

            CoverageDbgPrint(
                DBGLOG_INFO,
                "COVERAGE: %s registered (0x%x - 0x%x)\n",
                BinaryName,
                BaseOfLoggingRegion,
                EndOfLoggingRegion
                );

		}

        else {

            CoverageDbgPrint(
                DBGLOG_ERROR,
                "COVERAGE: %s could not be registered (failed to allocate memory).\n",
                BinaryName
                );
		}
	}

    ReleaseRegistrationMutexIfInitialized();

    //return TRUE;
}


DECLSPEC
VOID
STDCALL
CoverageRegisterBinaryWithStruct(
    IN PBBREG_HEADER pBBHeader
    )
{
	InternalCoverageRegisterBinary(
        (PCHAR)pBBHeader + pBBHeader->dwOffsetOfBinaryName,
		(PCHAR)pBBHeader + pBBHeader->dwOffsetOfGUID,
        pBBHeader->dwCheckSumOfBinary,
        (PCHAR)pBBHeader + pBBHeader->dwOffsetOfLoggingRegion,
        pBBHeader->dwSizeOfLoggingRegion
        );
}


DECLSPEC
VOID
STDCALL
CoverageRegisterUnloadHook(
    IN     LPCSTR         BinaryName,
    IN OUT PDRIVER_OBJECT DriverObject
    )
    {
    PREGISTERED_BINARY pNode;
    PDRIVER_UNLOAD TempDriverUnload;

    AcquireRegistrationMutexIfInitialized();

    pNode = RegisteredBinaryList;

    while ( pNode != (PREGISTERED_BINARY)&RegisteredBinaryList ) {

        if ( strcmp( pNode->BinaryName, BinaryName ) == 0 ) {

            try {

                //
                //  First try to dereference DriverObject and verify it
                //  really is a pointer to a DriverObject before storing
                //  any values in the DriverObject or in pNode.
                //

                if (( DriverObject != NULL ) &&
                    ( DriverObject->Type == IO_TYPE_DRIVER )) {

                    TempDriverUnload = DriverObject->DriverUnload;

                    if ( TempDriverUnload != NULL ) {

                        //
                        //  Only hook drivers that have an Unload routine
                        //  because drivers without Unload routines are not
                        //  unloadable.
                        //

                        DriverObject->DriverUnload = CoverageUnloadDriver;

                        //
                        //  If successfully read and updated DriverObject's
                        //  DriverUnload pointer, then update pNode to reflect
                        //  that we've hooked this driver's unload routine.
                        //

                        pNode->DriverUnload = TempDriverUnload;
                        pNode->DriverObject = DriverObject;

                        }

                    leave;
                    }

                CoverageDbgPrint(
                    DBGLOG_WARNING,
                    "COVERAGE: %s could not hook unload -- must save coverage\n"
                    "    logging data before unloading %s or coverage logging\n"
                    "    data will be lost.\n",
                    BinaryName,
                    BinaryName
                    );
                }

            except ( EXCEPTION_EXECUTE_HANDLER ) {

                CoverageDbgPrint(
                    DBGLOG_ERROR,
                    "COVERAGE: %s exception 0x%x hooking unload\n",
                    BinaryName,
                    GetExceptionCode()
                    );
                }

            break;

            }

        pNode = pNode->pNext;

        }

    ReleaseRegistrationMutexIfInitialized();

    }


VOID
STDCALL
CoverageUnloadDriver(
    IN PDRIVER_OBJECT DriverObject
    )
    {
    PREGISTERED_BINARY pNode;
    BOOLEAN Found = FALSE;

    AcquireRegistrationMutexIfInitialized();

    pNode = RegisteredBinaryList;

    while ( pNode != (PREGISTERED_BINARY)&RegisteredBinaryList ) {

        //
        //  pNode->DriverObject is non-NULL only for binaries that successfully
        //  hooked the DriverUnload routine.
        //

        if ( pNode->DriverObject == DriverObject ) {

            //
            //  First call driver's original unload routine to let it clean
            //  up and log its cleanup activity in its logging buffer.
            //  Implementation note: if driver's unload routine causes
            //  another coverage-instrumented driver to unload or load,
            //  we'll deadlock on the mutex if this driver doesn't return
            //  from its unload first.
            //

            ( pNode->DriverUnload )( DriverObject );

            //
            //  Now unregister the binary while the driver is still mapped.
            //  This will capture the logging buffer for later polling.
            //

            CoverageUnRegisterBinaryNode( pNode );

            Found = TRUE;
            break;
            }

        pNode = pNode->pNext;
        }

    if ( ! Found ) {

        CoverageDbgPrint(
            DBGLOG_ERROR,
            "COVERAGE: CoverageUnloadDriver called for unregistered binary.\n"
            "    Don't know original UnloadDriver routine to call.\n"
            );

        DbgBreakPoint();
        }

    ReleaseRegistrationMutexIfInitialized();

    }


VOID
STDCALL
CoverageUnRegisterBinaryNode(
    IN PREGISTERED_BINARY pNode
    )
{
    PCHAR CaptureBuffer;
    PCHAR BaseOfLogging;
    ULONG SizeOfLogging;
	
    //
    //  Allocate a paged-pool buffer to store logging buffer
    //  and save the binary's logging buffer contents into it.
    //
	
    BaseOfLogging = pNode->BaseOfLoggingRegion;
    SizeOfLogging = pNode->SizeOfLoggingRegion;
	
    if ( BaseOfLogging != NULL ) {
		
        //
        //  Allocate capture buffer and copy logging information
        //  into it.
        //
		
        CaptureBuffer = ExAllocatePoolWithTag(
			PagedPool,
			SizeOfLogging,
			'RVOC'
			);
		
        if ( CaptureBuffer != NULL ) {
			
            MoveLoggingInformationToBuffer(
                SizeOfLogging,
                BaseOfLogging,
                CaptureBuffer
                );

            //
            //  Now, if an existing capture buffer already exists for
            //  this binary, OR the newly captured contents into the
            //  existing capture buffer and free the newly allocated
            //  capture buffer.
            //
            //  Buf if an existing capture buffer does not exist, use
            //  the newly allocated capture buffer as the capture
            //  buffer for this node (will be freed when polled).
            //

            if ( pNode->CapturedLogging == NULL ) {
				pNode->CapturedLogging = CaptureBuffer;
			}
			
            else {
				
                OrBufferWithBuffer(
                    pNode->CapturedLogging,
                    CaptureBuffer,
                    SizeOfLogging
                    );
				
                ExFreePool( CaptureBuffer );
			}
			
            CoverageDbgPrint(
                DBGLOG_WARNING,
                "COVERAGE: %s unloaded, captured logging needs to be saved\n",
                pNode->BinaryName
                );
		}

        else {
			
            if ( ! DoesBufferContainAllZeros( BaseOfLogging, SizeOfLogging )) {
				
				CoverageDbgPrint(
					DBGLOG_ERROR,
					"COVERAGE: %s logging data lost when driver unloaded because\n"
					"    failed to allocate memory for logging buffer.\n",
					pNode->BinaryName
					);
            }
		}
		
        //
        //  Once unregistered, set these to NULL so we know we've
        //  unregistered when try to re-register.
        //
		
        pNode->BaseOfLoggingRegion = NULL;
        pNode->DriverObject        = NULL;
        pNode->DriverUnload        = NULL;
	}
	
    else {
		
        //
        //  BaseOfLogging is NULL.  This can only happen if reloaded
        //  but we didn't catch the first unload.  This is just a
        //  sanity test to keep us from blowing up.
        //
		
        CoverageDbgPrint(
            DBGLOG_ERROR,
            "COVERAGE: %s logging data lost when driver unloaded because\n"
            "    driver already marked as unloaded.\n",
            pNode->BinaryName
            );
	}
}
	

DECLSPEC
VOID
STDCALL
CoverageUnRegisterBinary(
    IN LPCSTR BinaryName                // must be lowercase or case consistent
    )
    {
    PREGISTERED_BINARY pNode;
    PREGISTERED_BINARY pNodeToUnRegister;

    AcquireRegistrationMutexIfInitialized();

    pNode = RegisteredBinaryList;

    pNodeToUnRegister = NULL;

    //
    //  HACK: we want to find the LAST of this name in the list and unload
    //  that one.
	//  REAL fix should be to pass in BaseAddress of the binary so we can
	//  search on that as well.
    //

    while ( pNode != (PREGISTERED_BINARY)&RegisteredBinaryList ) {

        if ( strcmp( pNode->BinaryName, BinaryName ) == 0 ) {
            pNodeToUnRegister = pNode;
		}

        pNode = pNode->pNext;
	}

    if ( pNodeToUnRegister != NULL ) {
        CoverageUnRegisterBinaryNode( pNodeToUnRegister );
	}

    else {

        CoverageDbgPrint(
            DBGLOG_ERROR,
            "COVERAGE: CoverageUnRegisterBinary called for unregistered binary %s.\n",
            BinaryName
            );
	}

    ReleaseRegistrationMutexIfInitialized();
}


BOOLEAN
DoesBufferContainAllZeros(
    IN PVOID Buffer,
    IN ULONG Size
    )
{
    ULONG CountLongs = Size / 4;
    ULONG CountBytes = Size & 3;
	
    while ( CountLongs-- ) {
        if ( *((UNALIGNED ULONG*) Buffer )++ ) {
            return FALSE;
		}
	}
	
    while ( CountBytes-- ) {
        if ( *((UNALIGNED UCHAR*) Buffer )++ ) {
            return FALSE;
		}
	}
	
    return TRUE;
}


VOID
OrBufferWithBuffer(
    IN PVOID TargetBuffer,
    IN PVOID SourceBuffer,
    IN ULONG Size
    )
{
    ULONG CountLongs = Size / 4;
    ULONG CountBytes = Size & 3;
	
    while ( CountLongs-- ) {
        *((UNALIGNED ULONG*) TargetBuffer )++ |= *((UNALIGNED ULONG*) SourceBuffer )++;
	}
	
    while ( CountBytes-- ) {
        *((UNALIGNED UCHAR*) TargetBuffer )++ |= *((UNALIGNED UCHAR*) SourceBuffer )++;
	}
}


//
//  Following functions are exported via corresponding IOCTLs to allow
//  user-mode coverage service to poll and flush the kernel-mode logging
//  information.  Note that probe-and-capture of caller parameters is not
//  bulletproof here (caller could supply kernel-mode addresses for arguments),
//  but this driver is not intended as a released product.  Basic verification
//  is performed to prevent "accidental" mistakes by the caller.
//


NTSTATUS
STDCALL
CoveragePollLogging(
    IN  LPCSTR BinaryName,
    IN  ULONG  BufferSize,
    OUT PVOID  Buffer,
    OUT PULONG ActualSize,
    OUT PULONG CheckSum
    )
{
    PREGISTERED_BINARY pNode;
    PCHAR	BaseOfLogging;
    ULONG	SizeOfLogging;
	PCHAR	LocalBuffer;
    NTSTATUS Status;
	BOOLEAN bFound = FALSE;

    if ( BinaryName == NULL ) {
        return STATUS_INVALID_PARAMETER;
	}

    Status = STATUS_SUCCESS;

    AcquireRegistrationMutex();

    try {

        if ( ActualSize ) {
            *ActualSize = 0;
		}

        if ( CheckSum ) {
            *CheckSum = 0;
		}

		pNode = RegisteredBinaryList;

        while ( pNode != (PREGISTERED_BINARY)&RegisteredBinaryList ) {

            if ( strcmp( pNode->BinaryName, BinaryName ) == 0 ) {

                if ( CheckSum ) {
                    *CheckSum = pNode->CheckSumOfBinary;
				}

                SizeOfLogging = pNode->SizeOfLoggingRegion;

				if( (SizeOfLogging + MD5_SIZE) < BufferSize ){
					// Put the MD5 Hash at the end of the logging buffer
					RtlCopyMemory((PCHAR)Buffer + SizeOfLogging, &(pNode->md5), MD5_SIZE);
				} else {
					Status = STATUS_BUFFER_TOO_SMALL;
					leave;
				}

                if ( SizeOfLogging != 0 ) {

                    if ( ActualSize ) {
                        *ActualSize = SizeOfLogging;
					}

                    if (( Buffer == NULL ) || ( BufferSize < SizeOfLogging )) {

                        Status = STATUS_BUFFER_TOO_SMALL;
                        leave;
					}

                    BaseOfLogging = pNode->BaseOfLoggingRegion;

                    if ( BaseOfLogging != NULL ) {

                        MoveLoggingInformationToBuffer(
                            SizeOfLogging,
                            BaseOfLogging,
                            Buffer
                            );

                        if ( pNode->CapturedLogging != NULL ) {

                            OrBufferWithBuffer(
                                Buffer,
                                pNode->CapturedLogging,
                                SizeOfLogging
                                );

                            ExFreePool( pNode->CapturedLogging );
                            pNode->CapturedLogging = NULL;
						}
					}

                    else if ( pNode->CapturedLogging != NULL ) {

                        RtlCopyMemory(
                            Buffer,
                            pNode->CapturedLogging,
                            SizeOfLogging
                            );

                        ExFreePool( pNode->CapturedLogging );
                        pNode->CapturedLogging = NULL;
					}

                    else {

                        RtlZeroMemory(
                            Buffer,
                            SizeOfLogging
                            );
					}
				}

				bFound = TRUE;

                //
                //  Now continue through the rest of the list to see if any
                //  more instances of same registered binary name.
                //
				
                pNode = pNode->pNext;
				
                while ( pNode != (PREGISTERED_BINARY)&RegisteredBinaryList ) {
					
                    if (( strcmp( pNode->BinaryName, BinaryName ) == 0 ) &&
                        ( pNode->SizeOfLoggingRegion == SizeOfLogging )  &&
                        ( pNode->BaseOfLoggingRegion != NULL )) {
						
                        //
                        //  Allocate a temporary buffer to "move" logging into,
                        //  then OR that with the return buffer.  We can't just
                        //  OR directly into the return buffer because we need
                        //  to do the atomic move operation.
                        //
						
                        LocalBuffer = ExAllocatePoolWithTag(
							PagedPool,
							SizeOfLogging,
							'RVOC'
							);
						
                        if ( LocalBuffer != NULL ) {
							
                            MoveLoggingInformationToBuffer(
                                SizeOfLogging,
                                pNode->BaseOfLoggingRegion,
                                LocalBuffer
                                );
							
                            OrBufferWithBuffer(
                                Buffer,
                                LocalBuffer,
                                SizeOfLogging
                                );
							
                            ExFreePool( LocalBuffer );
						}
						
                        else {
							
                            if ( ! DoesBufferContainAllZeros( pNode->BaseOfLoggingRegion, SizeOfLogging )) {
								
                                CoverageDbgPrint(
                                    DBGLOG_ERROR,
                                    "COVERAGE: %s logging data not completely saved because\n"
                                    "    failed to allocate memory to save logging buffer.\n",
                                    pNode->BinaryName
                                    );
							}
						}
						bFound = TRUE;
					}
					
                    pNode = pNode->pNext;
				}
				leave;
			}

            pNode = pNode->pNext;
		}

        Status = bFound ? STATUS_SUCCESS : STATUS_NOT_FOUND;
	}

    except ( EXCEPTION_EXECUTE_HANDLER ) {
        Status = GetExceptionCode();
	}

    ReleaseRegistrationMutex();

    return Status;
}


VOID
MoveLoggingInformationToBuffer(
    IN     ULONG BufferSize,
    IN OUT PVOID ActiveBuffer,
       OUT PVOID ReturnBuffer
    )
{

    //
    //  The purpose of this function is to copy the contents of the logging
    //  buffer to the output buffer and reset the logging buffer to zero at
    //  the same time.  Since this can occur realtime while new logging is
    //  written to the logging buffer, must be multiprocessor/multithread
    //  safe.  This means atomic "FetchAndSet" of each element to zero.
    //  Caller should handle exceptions from invalid memory access.
    //

#ifdef _M_IX86

    __asm {

        mov     ecx, BufferSize
        xor     eax, eax
        mov     esi, ActiveBuffer
        mov     edx, ecx
        mov     edi, ReturnBuffer
        shr     ecx, 2          ; ecx is now number of dwords to move
        jz      BYTES

LOOPD:  lock xchg    [esi], eax      ; xchg implies lock prefix (mp safe)
        add     esi, 4
        stosd                   ; mov dword ptr [edi++], eax
        xor     eax, eax
        dec     ecx
        jnz     LOOPD

BYTES:  and     edx, 3          ; edx is now remainder odd bytes to move
        jz      DONE

LOOPB:  lock xchg    [esi], al       ; xchg implies lock prefix (mp safe)
        add     esi, 1
        stosb                   ; mov byte ptr [edi++], al
        mov     al, 0
        dec     edx
        jnz     LOOPB

DONE:
	}

#else // not x86

    #error "Must implement MoveLoggingInformationToBuffer() for this platform"

#endif // _M_IX86

}


NTSTATUS
STDCALL
CoverageFlushLogging(
    IN LPCSTR BinaryName OPTIONAL
    )
    {
    PREGISTERED_BINARY pNode;
    PCHAR BaseOfLogging;
    ULONG SizeOfLogging;
    NTSTATUS Status = STATUS_SUCCESS;
	BOOLEAN bFound = FALSE;

    AcquireRegistrationMutex();

    try {

        pNode = RegisteredBinaryList;

        while ( pNode != (PREGISTERED_BINARY)&RegisteredBinaryList ) {

			// (BinaryName == NULL) means flush everything
			// otherwise, flush only the ones that match BinaryName

            if (( BinaryName == NULL ) ||
                ( strcmp( pNode->BinaryName, BinaryName ) == 0 )) {

                BaseOfLogging = pNode->BaseOfLoggingRegion;

                if ( BaseOfLogging != NULL ) {

                    SizeOfLogging = pNode->SizeOfLoggingRegion;

                    if ( SizeOfLogging != 0 ) {

                        try {
                            RtlZeroMemory( BaseOfLogging, SizeOfLogging );
						}
                        except ( EXCEPTION_EXECUTE_HANDLER ) {
                            Status = GetExceptionCode();
						}
					}
				}

                if ( pNode->CapturedLogging ) {
                    ExFreePool( pNode->CapturedLogging );
                    pNode->CapturedLogging = NULL;
				}

				bFound = TRUE;
			}

            pNode = pNode->pNext;
		}

        if (( BinaryName != NULL ) && !bFound ) {
            Status = STATUS_NOT_FOUND;
		}
	}

    except ( EXCEPTION_EXECUTE_HANDLER ) {
        Status = GetExceptionCode();
	}

    ReleaseRegistrationMutex();

    return Status;
}


NTSTATUS
STDCALL
CoverageEnumerateBinaries(
    IN  ULONG  BufferSize,
    OUT PCHAR  Buffer,
    OUT PULONG ActualSize
    )
{
    PREGISTERED_BINARY pNode;
    NTSTATUS Status = STATUS_SUCCESS;
    PCHAR BufferPointer = Buffer;

    AcquireRegistrationMutex();

    try {

        ULONG TotalSize = 0;

        if ( ActualSize ) {
            *ActualSize = 0;
		}

        pNode = RegisteredBinaryList;

        while ( pNode != (PREGISTERED_BINARY)&RegisteredBinaryList ) {

            ULONG NameLength = strlen( pNode->BinaryName ) + 1;
			ULONG GUIDLength = MD5_SIZE;

            TotalSize += NameLength;
			TotalSize += (GUIDLength+1);

            if ( TotalSize <= BufferSize ) {
                RtlCopyMemory( BufferPointer, pNode->BinaryName, NameLength );
                BufferPointer += NameLength;
				RtlCopyMemory( BufferPointer, &(pNode->md5), GUIDLength );
				BufferPointer += GUIDLength;
				*BufferPointer = 0;
				BufferPointer++;
			}

            pNode = pNode->pNext;
		}

        if ( ++TotalSize <= BufferSize ) {
            *BufferPointer = 0;
		}
        else {
            Status = STATUS_BUFFER_TOO_SMALL;
		}

        if ( ActualSize ) {
            *ActualSize = TotalSize;
		}
	}
    except ( EXCEPTION_EXECUTE_HANDLER ) {
        Status = GetExceptionCode();
	}

    ReleaseRegistrationMutex();

    return Status;
}


VOID
STDCALL
DriverUnload(
    IN PDRIVER_OBJECT DriverObject
    )
{
    PREGISTERED_BINARY pNode, pNext;

    //
    //  NOTE: We're relying on NT's refcounting for this driver to prevent it
    //        from being unloaded while instrumented drivers that import from
    //        this driver are still loaded.  Since we may have hooked other
    //        instrumented drivers unload routines to call code in this driver
    //        first, the system would blow up if this driver were unloaded and
    //        later an instrumented driver was unloaded.
    //

    AcquireRegistrationMutex();

    pNode = RegisteredBinaryList;

    RegisteredBinaryList = (PREGISTERED_BINARY)&RegisteredBinaryList;   // make list empty

    ReleaseRegistrationMutex();

    while ( pNode != (PREGISTERED_BINARY)&RegisteredBinaryList ) {

        if ( pNode->CapturedLogging ) {

            if ( ! DoesBufferContainAllZeros( pNode->CapturedLogging, pNode->SizeOfLoggingRegion )) {

				CoverageDbgPrint(
					DBGLOG_ERROR,
					"COVERAGE: %s logging data lost when coverage.sys unloaded.\n",
					pNode->BinaryName
					);
			}
				
            ExFreePool( pNode->CapturedLogging );

		}

        pNext = pNode->pNext;

        ExFreePool( pNode );

        pNode = pNext;

	}

    IoDeleteDevice( DriverObject->DeviceObject );

    CoverageDbgPrint( DBGLOG_INFO, "COVERAGE: Driver unloaded\n" );

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\coverage\coverage.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    coverage.h

Abstract:

    This module contains various data structures and procedure prototypes
    of code coverage debugger extension.  The extension is loaded by XBDM
    under Xbox development kit (XDK) only.

--*/

#ifndef _COVERAGE_INCLUDED
#define _COVERAGE_INCLUDED

#ifdef __cplusplus
extern "C" {
#endif

#if defined(__cplusplus) && !defined(EXTERN_C)
#define EXTERN_C extern "C"
#endif

#define DM_COVERAGE_COMMAND     "BBCOVER"
#define COVERAGE_COMMAND_HEADER "!Cmd"

//
// List of commands available in debug extension
//

enum COVERAGE_COMMAND {
    CoverageCmdSave = 1,
    CoverageCmdReset,
    CoverageCmdPeriodic,
    CoverageCmdList,
    CoverageCmdMax
};

#define DM_RESPONSE_MSG_OFFSET  5
#define GET_RESPONSE_ERR( b )   strtoul(&(b)[DM_RESPONSE_MSG_OFFSET], 0, 16)
#define GET_RESPONSE( b )       (&(b)[DM_RESPONSE_MSG_OFFSET])

#ifdef __cplusplus
}
#endif

#endif // _COVERAGE_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\cover35src\sys20\nt5\coversys.h ===
//
//  coversys.h
//
//  Must include either <winioctl.h> (for user-mode app) or <ntddk.h>
//  (kernel-mode driver) to get the CTL_CODE macro definition.
//

#ifndef _COVERSYS_H_
#define _COVERSYS_H_

#ifndef CTL_CODE
#error "Must include either winioctl.h or ntddk.h before including coversys.h"
#endif

#define IOCTL_COVERAGE_ENUM_BINARIES CTL_CODE( FILE_DEVICE_UNKNOWN, 0x87A, METHOD_NEITHER, FILE_READ_ACCESS )
#define IOCTL_COVERAGE_POLL_LOGGING  CTL_CODE( FILE_DEVICE_UNKNOWN, 0x87B, METHOD_NEITHER, FILE_READ_ACCESS | FILE_WRITE_ACCESS )
#define IOCTL_COVERAGE_FLUSH_LOGGING CTL_CODE( FILE_DEVICE_UNKNOWN, 0x87C, METHOD_NEITHER, FILE_WRITE_ACCESS )

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  IOCTL_COVERAGE_ENUM_BINARIES                                              //
//                                                                            //
//      IN  pInBuffer   -- not used                                           //
//      IN  cbInBuffer  -- not used                                           //
//      OUT pOutBuffer  -- buffer to return list of binaries                  //
//      IN  cbOutBuffer -- size of pOutBuffer in bytes                        //
//      OUT cbOutActual -- actual size of data returned in pOutBuffer.        //
//                                                                            //
//      This returns the list of registered logging binaries as a NULL-       //
//      terminated sequence of NULL-terminated strings, for example:          //
//      name1<0>name2<0>name3<0><0>.  This list of binaries can be used       //
//      in subsequent calls to IOCTL_COVERAGE_POLL_LOGGING and                //
//      IOCTL_COVERAGE_FLUSH_LOGGING.  Binary names are always returned       //
//      in lowercase.                                                         //
//                                                                            //
//  IOCTL_COVERAGE_POLL_LOGGING                                               //
//                                                                            //
//      IN  pInBuffer   -- (LPCSTR) pszBinaryName (must be lowercase)         //
//      OUT cbInBuffer  -- (PDWORD) returned checksum of original binary      //
//      OUT pOutBuffer  -- buffer to return logging data                      //
//      IN  cbOutBuffer -- size of pOutBuffer in bytes                        //
//      OUT cbOutActual -- actual size of data returned in pOutBuffer.        //
//                                                                            //
//      This reads the current logging information for a given binary into    //
//      a user supplied buffer and resets the logging buffer to zero, so      //
//      subsequent reads will return only new logging information.  Note      //
//      that logging is not disabled during the read, so no hits are lost.    //
//                                                                            //
//  IOCTL_COVERAGE_FLUSH_LOGGING                                              //
//                                                                            //
//      IN  pInBuffer   -- (LPCSTR) pszBinaryName OPTIONAL (lowercase)        //
//      IN  cbInBuffer  -- not used.                                          //
//      OUT pOutBuffer  -- not used.                                          //
//      IN  cbOutBuffer -- not used.                                          //
//      OUT cbOutActual -- not used.                                          //
//                                                                            //
//      This flushes the logging buffer for the given binary, or for all      //
//      registered binaries if pInBuffer (pszBinaryName) is NULL.  It is      //
//      not necessary to do a flush after a poll, but it might be useful      //
//      to issue a flush before starting a new testing scenario.              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef _NTDDK_

//
//  Define user-mode interface for kernel-mode coverage driver.
//

HANDLE
__inline
KernelCoverageConnectToDriver(
    VOID
    )
    {
    HANDLE hDeviceHandle;

    hDeviceHandle = CreateFile(
                        "\\\\.\\Coverage",
                         GENERIC_READ | GENERIC_WRITE,
                         0,  // exclusive access
                         NULL,
                         OPEN_EXISTING,
                         FILE_FLAG_NO_BUFFERING,
                         NULL
                         );

    if ( hDeviceHandle == INVALID_HANDLE_VALUE )
         hDeviceHandle = NULL;

    return hDeviceHandle;
    }

BOOL
__inline
KernelCoverageEnumerateBinaries(
    IN  HANDLE hKernelCoverageConnectionHandle,
    IN  DWORD  dwSizeOfBuffer,
    OUT LPSTR  pListOfNamesBuffer,      // name1<0>name2<0>name3<0><0>
    OUT PDWORD pdwActualSize
    )
    {
    return DeviceIoControl(
               hKernelCoverageConnectionHandle,
               IOCTL_COVERAGE_ENUM_BINARIES,
               NULL,
               0,
               pListOfNamesBuffer,
               dwSizeOfBuffer,
               pdwActualSize,
               NULL
               );
    }

BOOL
__inline
KernelCoveragePollLogging(
    IN  HANDLE  hKernelCoverageConnectionHandle,
    IN  LPCSTR  pszBinaryName,
    IN  DWORD   dwSizeOfBuffer,
    OUT PVOID   pLoggingBuffer,
    OUT PDWORD  pdwActualSize,
    OUT PDWORD  pdwCheckSumOfBinary
    )
    {
    return DeviceIoControl(
               hKernelCoverageConnectionHandle,
               IOCTL_COVERAGE_POLL_LOGGING,
               (PVOID)pszBinaryName,
               (DWORD)pdwCheckSumOfBinary,
               pLoggingBuffer,
               dwSizeOfBuffer,
               pdwActualSize,
               NULL
               );
    }

BOOL
__inline
KernelCoverageFlushLogging(
    IN HANDLE hKernelCoverageConnectionHandle,
    IN LPCSTR pszBinaryName OPTIONAL
    )
    {
    DWORD dwActualSize;     // not used, but required by DeviceIoControl()

    return DeviceIoControl(
               hKernelCoverageConnectionHandle,
               IOCTL_COVERAGE_FLUSH_LOGGING,
               (PVOID)pszBinaryName,
               0,
               NULL,
               0,
               &dwActualSize,
               NULL
               );
    }

VOID
__inline
KernelCoverageDisconnect(
    IN HANDLE hKernelCoverageConnectionHandle
    )
    {
    CloseHandle( hKernelCoverageConnectionHandle );
    }

#endif /* ! _NTDDK_ */

#endif /* _COVERSYS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\cover35src\sys20\coversys.h ===
//
//  coversys.h
//
//  Must include either <winioctl.h> (for user-mode app) or <ntddk.h>
//  (kernel-mode driver) to get the CTL_CODE macro definition.
//

#ifndef _COVERSYS_H_
#define _COVERSYS_H_

#ifndef CTL_CODE
#error "Must include either winioctl.h or ntddk.h before including coversys.h"
#endif

#define IOCTL_COVERAGE_ENUM_BINARIES                    CTL_CODE( FILE_DEVICE_UNKNOWN, 0x87A, METHOD_NEITHER, FILE_READ_ACCESS )
#define IOCTL_COVERAGE_POLL_LOGGING                     CTL_CODE( FILE_DEVICE_UNKNOWN, 0x87B, METHOD_NEITHER, FILE_READ_ACCESS | FILE_WRITE_ACCESS )
#define IOCTL_COVERAGE_FLUSH_LOGGING                    CTL_CODE( FILE_DEVICE_UNKNOWN, 0x87C, METHOD_NEITHER, FILE_WRITE_ACCESS )
#define IOCTL_COVERAGE_REGISTER_NO_IMPORT_BINARY        CTL_CODE( FILE_DEVICE_UNKNOWN, 0x87D, METHOD_NEITHER, FILE_WRITE_ACCESS )
#define IOCTL_COVERAGE_REGISTER_ALL_NO_IMPORT_BINARIES  CTL_CODE( FILE_DEVICE_UNKNOWN, 0x87E, METHOD_NEITHER, FILE_WRITE_ACCESS )

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  IOCTL_COVERAGE_ENUM_BINARIES                                              //
//                                                                            //
//      IN  pInBuffer   -- not used                                           //
//      IN  cbInBuffer  -- not used                                           //
//      OUT pOutBuffer  -- buffer to return list of binaries                  //
//      IN  cbOutBuffer -- size of pOutBuffer in bytes                        //
//      OUT cbOutActual -- actual size of data returned in pOutBuffer.        //
//                                                                            //
//      This returns the list of registered logging binaries as a NULL-       //
//      terminated sequence of NULL-terminated strings and MD5s               //
//      For example:                                                          //
//      name1<0>MD5_1<0>name2<0>MD5_2<0>name3<0>MD5_3<0><0>.                  //
//      This list of binaries can be used                                     //
//      in subsequent calls to IOCTL_COVERAGE_POLL_LOGGING and                //
//      IOCTL_COVERAGE_FLUSH_LOGGING.  Binary names are always returned       //
//      in lowercase.                                                         //
//                                                                            //
//  IOCTL_COVERAGE_POLL_LOGGING                                               //
//                                                                            //
//      IN  pInBuffer   -- (LPCSTR) pszBinaryName (must be lowercase)         //
//      OUT cbInBuffer  -- (PDWORD) returned checksum of original binary      //
//      OUT pOutBuffer  -- buffer to return logging data                      //
//      IN  cbOutBuffer -- size of pOutBuffer in bytes                        //
//      OUT cbOutActual -- actual size of data returned in pOutBuffer.        //
//                                                                            //
//      This reads the current logging information for a given binary into    //
//      a user supplied buffer and resets the logging buffer to zero, so      //
//      subsequent reads will return only new logging information.  Note      //
//      that logging is not disabled during the read, so no hits are lost.    //
//                                                                            //
//  IOCTL_COVERAGE_FLUSH_LOGGING                                              //
//                                                                            //
//      IN  pInBuffer   -- (LPCSTR) pszBinaryName OPTIONAL (lowercase)        //
//      IN  cbInBuffer  -- not used.                                          //
//      OUT pOutBuffer  -- not used.                                          //
//      IN  cbOutBuffer -- not used.                                          //
//      OUT cbOutActual -- not used.                                          //
//                                                                            //
//      This flushes the logging buffer for the given binary, or for all      //
//      registered binaries if pInBuffer (pszBinaryName) is NULL.  It is      //
//      not necessary to do a flush after a poll, but it might be useful      //
//      to issue a flush before starting a new testing scenario.              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#if !defined(_NTDDK_) || defined(COVERMON)

//
//  Define user-mode interface for kernel-mode coverage driver.
//

HANDLE
__inline
KernelCoverageConnectToDriver(
    VOID
    )
    {
    HANDLE hDeviceHandle;

    hDeviceHandle = CreateFile(
                         OTEXT("Coverage:"),
                         GENERIC_READ | GENERIC_WRITE,
                         0,  // exclusive access
                         NULL,
                         OPEN_EXISTING,
                         FILE_FLAG_NO_BUFFERING,
                         NULL
                         );

    if ( hDeviceHandle == INVALID_HANDLE_VALUE )
         hDeviceHandle = NULL;

    return hDeviceHandle;
    }

BOOL
__inline
KernelCoverageEnumerateBinaries(
    IN  HANDLE hKernelCoverageConnectionHandle,
    IN  DWORD  dwSizeOfBuffer,
    OUT LPSTR  pListOfNamesBuffer,      // name1<0>name2<0>name3<0><0>
    OUT PDWORD pdwActualSize
    )
    {
    return DeviceIoControl(
               hKernelCoverageConnectionHandle,
               IOCTL_COVERAGE_ENUM_BINARIES,
               NULL,
               0,
               pListOfNamesBuffer,
               dwSizeOfBuffer,
               pdwActualSize,
               NULL
               );
    }

BOOL
__inline
KernelCoveragePollLogging(
    IN  HANDLE  hKernelCoverageConnectionHandle,
    IN  LPCSTR  pszBinaryName,
    IN  DWORD   dwSizeOfBuffer,
    OUT PVOID   pLoggingBuffer,
    OUT PDWORD  pdwActualSize,
    OUT PDWORD  pdwCheckSumOfBinary
    )
    {
    return DeviceIoControl(
               hKernelCoverageConnectionHandle,
               IOCTL_COVERAGE_POLL_LOGGING,
               (PVOID)pszBinaryName,
               (DWORD)pdwCheckSumOfBinary,
               pLoggingBuffer,
               dwSizeOfBuffer,
               pdwActualSize,
               NULL
               );
    }

BOOL
__inline
KernelCoverageFlushLogging(
    IN HANDLE hKernelCoverageConnectionHandle,
    IN LPCSTR pszBinaryName OPTIONAL
    )
    {
    DWORD dwActualSize;     // not used, but required by DeviceIoControl()

    return DeviceIoControl(
               hKernelCoverageConnectionHandle,
               IOCTL_COVERAGE_FLUSH_LOGGING,
               (PVOID)pszBinaryName,
               0,
               NULL,
               0,
               &dwActualSize,
               NULL
               );
    }

VOID
__inline
KernelCoverageDisconnect(
    IN HANDLE hKernelCoverageConnectionHandle
    )
    {
    CloseHandle( hKernelCoverageConnectionHandle );
    }

BOOL
__inline
KernelRegisterNoImportCoverageBinary(
    IN HANDLE hKernelCoverageConnectionHandle,
    IN HANDLE ImageBase
    )
    {
    DWORD BytesReturned;

    return DeviceIoControl(
               hKernelCoverageConnectionHandle,
               IOCTL_COVERAGE_REGISTER_NO_IMPORT_BINARY,
               (PVOID)ImageBase,
               sizeof(HANDLE),
               NULL,
               0,
               &BytesReturned,
               NULL
               );
    }

BOOL
__inline
KernelRegisterAllNoImportCoverageBinaries(
    IN HANDLE hKernelCoverageConnectionHandle
    )
    {
    DWORD BytesReturned;

    return DeviceIoControl(
               hKernelCoverageConnectionHandle,
               IOCTL_COVERAGE_REGISTER_ALL_NO_IMPORT_BINARIES,
               NULL,
               0,
               NULL,
               0,
               &BytesReturned,
               NULL
               );
    }

#endif /* ! _NTDDK_ */

#endif /* _COVERSYS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\coverage\covfile\covfile.h ===
#ifndef _COVFILE_H_
#define _COVFILE_H_

#ifdef __cplusplus
extern "C" {
#endif

//
//  Coverage data file is stored as follows:
//
//  COVFILE_HEADER at offset zero in the file.
//  First COVFILE_DIRECTORY entry immediately follows COVFILE_HEADER.
//  Next COVFILE_DIRECTORY entry follows previous entry, etc.
//       (add entry's dwLengthOfEntry to its offset for offset of next entry)
//  Last COVFILE_DIRECTORY entry is empty with dwLengthOfEntry set to zero.
//
//  Order of directory entries is currently random to facilitate speedy
//  insertion of new record (simply appended to end).
//
//  Directory chain is contiguous and is contained within the first
//  dwHeaderLength bytes of the file (multiple of 512 bytes).  First data
//  vector is stored at offset dwHeaderBytes, so directory can grow up to
//  dwHeaderBytes without moving any of the data.
//
//  When directory needs to grow beyond dwHeaderBytes, it will grow by
//  ROUNDUP2( BITVECTOR_STORAGE_SIZE( dwBlockCount ), 512 ) bytes, and that
//  much of the data will be moved from offset at dwHeaderBytes to end of
//  the file (corresponding offsets in directory will be adjusted).
//
//  To facilitate fewer disk sector reads and writes to maintain the data
//  file, data vectors will be stored such that they do not span any
//  ROUNDUP2( BITVECTOR_STORAGE_SIZE( dwBlockCount ), 512 ) byte boundaries.
//  This will guarantee that growing the header by that many bytes will never
//  chop a stored data vector.
//
//  For COVFILE_VERSION 2.01 (0x00020001), all vectors are stored as bit
//  vectors of length dwBlockCount.  The allocation size for such a vector is
//  computed as dwBlockCount rounded up to multiple of 8 then divided by 8
//  (number of bytes) then rounded up to multiple of 4 bytes (dword alignment).
//
//  For version 2.01, 32-bit offsets are used implying a maximum file size of
//  2^32-1 (4GB) bytes.  For a binary that contains 100,000 blocks (a very
//  large binary), each vector would require 12,800 bytes of storage in
//  addition to the directory information for that vector.  For an average
//  name length of 64 bytes, the directory entry is 80 bytes, so roughly
//  12,880 bytes of storage would be required per named vector.  This yields
//  roughly 333,460 maximum named vectors that could be stored for a 100,000
//  block binary (4 gigabytes).
//
//  For version 2.02, 64-bit offsets are used implying a maximum file size of
//  2^64-2 bytes for the data vectors, but the directory chain contained in
//  the header is still limited to 2^32 bytes.  For an average name length of
//  64 bytes, which is 80 bytes per directory entry, this yields space for
//  roughly 50,000,000 test names.
//
//  While the file format will support directory chains of 2^32 bytes, the
//  current implementation of the coverage monitoring service (covermon.exe)
//  caches the entire directory chain for each binary in memory, and walks
//  the chain linearly to search for a matching test name each time coverage
//  information is saved.  This limits the "usable" size of the directory
//  chain (combined for all active .covdata files) to available RAM.  Future
//  implementations of the coverage monitoring service will likely address
//  this limitation by storing only the directory name hashes in memory in a
//  btree format, increasing the "usable" limit to roughly 50,000,000 test
//  names of any length.
//

#ifndef ROUNDUP2
#define ROUNDUP2( x, n ) ((((ULONG)(x)) + (((ULONG)(n)) - 1 )) & ~(((ULONG)(n)) - 1 ))
#endif

#define COVFILE_HEADER_MIN_SIZE  512        // must be power of 2
#define COVFILE_VECTOR_BOUNDARY  512        // must be power of 2

#define BITVECTOR_STORAGE_SIZE( NumberOfBits ) \
           ( ROUNDUP2( ROUNDUP2(( NumberOfBits ), 8 ) / 8, 4 ))

#define COVFILE_SIGNATURE   ( 0xDADAC0BB )    // "BBC0DADA" (BB Cover Data)
#define COVFILE_VERSION     ( 0x00020003 )    // rev this if change structure
#define COVFILE_VERSION_202 ( 0x00020002 )    // older version
#define COVFILE_VERSION_201 ( 0x00020001 )    // older version

typedef struct _COVFILE_HEADER        COVFILE_HEADER,        *PCOVFILE_HEADER;
typedef struct _COVFILE_HEADER_202    COVFILE_HEADER_202,    *PCOVFILE_HEADER_202;
typedef struct _COVFILE_DIRECTORY     COVFILE_DIRECTORY,     *PCOVFILE_DIRECTORY;
typedef struct _COVFILE_DIRECTORY_201 COVFILE_DIRECTORY_201, *PCOVFILE_DIRECTORY_201;

struct _COVFILE_HEADER {
    DWORD dwSignature;          // always COVFILE_SIGNATURE
    DWORD dwVersion;            // always COVFILE_VERSION
    DWORD dwCheckSum;           // checksum of original binary
    DWORD dwBlockCount;         // number of basic blocks (bit vector length)
    DWORD dwHeaderLength;       // multiple of 512, includes entire directory
        DWORD dwOffsetOfFirstDir;
        DWORD dwOffsetOfGUID;
    };

struct _COVFILE_HEADER_202 {
    DWORD dwSignature;          // always COVFILE_SIGNATURE
    DWORD dwVersion;            // always COVFILE_VERSION
    DWORD dwCheckSum;           // checksum of original binary
    DWORD dwBlockCount;         // number of basic blocks (bit vector length)
    DWORD dwHeaderLength;       // multiple of 512, includes entire directory
    };

struct _COVFILE_DIRECTORY_201 {
    DWORD dwLengthOfEntry;      // multiple of 4, zero indicates end of list
    DWORD dwHashOfName;         // to make searching for matches faster
    DWORD dwOffsetOfData;       // size is BITVECTOR_STORAGE_SIZE( dwBlockCount )
    CHAR  szName[];             // variable length, null-terminated
    };

struct _COVFILE_DIRECTORY {
    DWORD     dwLengthOfEntry;  // multiple of 4, zero indicates end of list
    DWORD     dwHashOfName;     // to make searching for matches faster
    DWORDLONG dwlOffsetOfData;  // size is BITVECTOR_STORAGE_SIZE( dwBlockCount )
    CHAR      szName[];         // variable length, null-terminated
    };

VOID
PackByteVectorToBitVector(
    IN  DWORD ByteCount,
    IN  PBYTE ByteVector,
    OUT PBYTE BitVector
    );

VOID
UnpackBitVectorToByteVector(
    IN  DWORD BitCount,
    IN  PBYTE BitVector,
    OUT PBYTE ByteVector
    );

VOID
OrBufferWithBuffer(
    IN PVOID TargetBuffer,
    IN PVOID SourceBuffer,
    IN ULONG Size
    );

VOID
XorBufferWithBuffer(
    IN PVOID TargetBuffer,
    IN PVOID SourceBuffer,
    IN ULONG Size
    );

VOID
BufferAndNotBuffer(
    IN PVOID TargetBuffer,
    IN PVOID SourceBuffer,
    IN ULONG Size
    );

ULONG
CountBitsSetInBuffer(
    IN PVOID Buffer,
    IN ULONG Size
    );

BOOL
DoesBufferContainAllZeros(
    IN PVOID Buffer,
    IN DWORD Size
    );

BOOL
DoesBufferContainOnlyHex01s(
    IN PVOID Buffer,
    IN DWORD Size
    );

ULONG
HashName(
    IN LPCSTR Name
    );

#ifdef __cplusplus
}
#endif

#endif /* _COVFILE_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\coverage\md5\md5.h ===
/*
 ***********************************************************************
 ** md5.h -- Header file for implementation of MD5                    **
 ** RSA Data Security, Inc. MD5 Message-Digest Algorithm              **
 ** Created: 2/17/90 RLR                                              **
 ** Revised: 12/27/90 SRD,AJ,BSK,JT Reference C version               **
 ** Revised (for MD5): RLR 4/27/91                                    **
 **   -- G modified to have y&~z instead of y&z                       **
 **   -- FF, GG, HH modified to add in last register done             **
 **   -- Access pattern: round 2 works mod 5, round 3 works mod 3     **
 **   -- distinct additive constant for each step                     **
 **   -- round 4 added, working mod 7                                 **
 ***********************************************************************
 */

/*
 ***********************************************************************
 ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved.  **
 **                                                                   **
 ** License to copy and use this software is granted provided that    **
 ** it is identified as the "RSA Data Security, Inc. MD5 Message-     **
 ** Digest Algorithm" in all material mentioning or referencing this  **
 ** software or this function.                                        **
 **                                                                   **
 ** License is also granted to make and use derivative works          **
 ** provided that such works are identified as "derived from the RSA  **
 ** Data Security, Inc. MD5 Message-Digest Algorithm" in all          **
 ** material mentioning or referencing the derived work.              **
 **                                                                   **
 ** RSA Data Security, Inc. makes no representations concerning       **
 ** either the merchantability of this software or the suitability    **
 ** of this software for any particular purpose.  It is provided "as  **
 ** is" without express or implied warranty of any kind.              **
 **                                                                   **
 ** These notices must be retained in any copies of any part of this  **
 ** documentation and/or software.                                    **
 ***********************************************************************
 */

/*                                                                         */
/* This copy of md5.h modified and adapted for my purposes, tommcg 6/28/96 */
/*                                                                         */

#ifndef _MD5_H_
#define _MD5_H_

#ifdef __cplusplus
extern "C" {
#endif

#pragma warning( disable: 4201 4204 )

#ifndef VOID
typedef void VOID;
#endif

typedef unsigned char UCHAR;
typedef unsigned long ULONG;
typedef unsigned __int64 ULONGLONG;
typedef const void * PCVOID;

#define IN
#define OUT

typedef struct _MD5_HASH MD5_HASH, *PMD5_HASH;

struct _MD5_HASH {
    union {
        ULONG Word32[  4 ];
        UCHAR Byte  [ 16 ];
        };
    };

#define MD5_SIZE	sizeof(MD5_HASH)

#define MD5_INITIAL_VALUE { 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476 }

VOID
InitMD5(
    IN OUT PMD5_HASH HashValue
    );

VOID
UpdateMD5_64ByteChunk(
    IN OUT PMD5_HASH HashValue,         // existing hash value
    IN     PCVOID    DataChunk          // pointer to 64 bytes of data
    );

VOID
FinalizeMD5(
    IN OUT PMD5_HASH HashValue,         // existing hash value
    IN     PCVOID    RemainingData,     // remaining data to hash
    IN     ULONG     RemainingBytes,    // 0 <= RemainingBytes < 64
    IN     ULONGLONG TotalBytesHashed   // total bytes hashed
    );

VOID
ComputeCompleteMD5(                     // complete MD5 in one call
    IN  PCVOID    DataBuffer,           // buffer to compute MD5 over
    IN  ULONGLONG DataLength,           // bytes of data in buffer
    OUT PMD5_HASH HashValue             // return finalized MD5 value
    );

#ifdef __cplusplus
}
#endif

#endif // _MD5_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\cover35src\sys20\nt5\coversys.c ===
//
//  coversys.c
//
//  tommcg, 3/1/95
//

#include <ntddk.h>
#include <ntimage.h>
#include <stdarg.h>
#include "coversys.h"

//
//  I can't figure out how to include both ntddk.h and ntrtl.h and ntexapi.h,
//  so I putting private typedefs and prototypes here.  These interfaces should
//  probably be public to DDK developers anyway.  Shoot me.
//

typedef struct _SYSTEM_BASIC_INFORMATION {
    ULONG Reserved;
    ULONG TimerResolution;
    ULONG PageSize;
    ULONG NumberOfPhysicalPages;
    ULONG LowestPhysicalPageNumber;
    ULONG HighestPhysicalPageNumber;
    ULONG AllocationGranularity;
    ULONG MinimumUserModeAddress;
    ULONG MaximumUserModeAddress;
    KAFFINITY ActiveProcessorsAffinityMask;
    CCHAR NumberOfProcessors;
} SYSTEM_BASIC_INFORMATION, *PSYSTEM_BASIC_INFORMATION;

typedef struct _RTL_PROCESS_MODULE_INFORMATION {
    HANDLE Section;                 // Not filled in
    PVOID MappedBase;
    PVOID ImageBase;
    ULONG ImageSize;
    ULONG Flags;
    USHORT LoadOrderIndex;
    USHORT InitOrderIndex;
    USHORT LoadCount;
    USHORT OffsetToFileName;
    UCHAR  FullPathName[ 256 ];
} RTL_PROCESS_MODULE_INFORMATION, *PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES {
    ULONG NumberOfModules;
    RTL_PROCESS_MODULE_INFORMATION Modules[ 1 ];
} RTL_PROCESS_MODULES, *PRTL_PROCESS_MODULES;

typedef enum _SYSTEM_INFORMATION_CLASS {
    SystemBasicInformation,
    SystemProcessorInformation,
    SystemPerformanceInformation,
    SystemTimeOfDayInformation,
    SystemPathInformation,
    SystemProcessInformation,
    SystemCallCountInformation,
    SystemDeviceInformation,
    SystemProcessorPerformanceInformation,
    SystemFlagsInformation,
    SystemCallTimeInformation,
    SystemModuleInformation
    } SYSTEM_INFORMATION_CLASS;

NTSYSAPI
NTSTATUS
NTAPI
ZwQuerySystemInformation (
    IN  SYSTEM_INFORMATION_CLASS SystemInformationClass,
    OUT PVOID  SystemInformation,
    IN  ULONG  SystemInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );

int __cdecl _vsnprintf( char *, size_t, const char *, va_list );

#ifndef STDCALL
#define STDCALL __stdcall
#endif

#ifndef INLINE
#define INLINE __inline
#endif

#define ROUNDUP2( x, n ) ((((ULONG)(x)) + (((ULONG)(n)) - 1 )) & ~(((ULONG)(n)) - 1 ))

//#define DECLSPEC __declspec( dllexport )
#define DECLSPEC

typedef struct _REGISTERED_BINARY REGISTERED_BINARY, *PREGISTERED_BINARY;

struct _REGISTERED_BINARY {
    PREGISTERED_BINARY pNext;                   // singly linked list
    PCHAR              BaseOfLoggingRegion;
    ULONG              SizeOfLoggingRegion;
    ULONG              CheckSumOfBinary;
    PDRIVER_OBJECT     DriverObject;
    PDRIVER_UNLOAD     DriverUnload;
    PVOID              CapturedLogging;
    CHAR               BinaryName[ 1 ];         // variable length
    };

NTSTATUS
STDCALL
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
STDCALL
DriverUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
STDCALL
DeviceOpen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
STDCALL
DeviceClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
STDCALL
DeviceIoctl(
    IN PDEVICE_OBJECT IoctlDeviceObject,
    IN PIRP Irp
    );

VOID
STDCALL
RegisterNoImportCoverageBinaries(
    VOID
    );

VOID
STDCALL
RegisterNoImportCoverageBinary(
    IN PVOID ImageBase
    );

DECLSPEC
VOID
STDCALL
CoverageRegisterBinary(
    IN LPCSTR BinaryName,
    IN ULONG  CheckSumOfBinary,
    IN PCHAR  BaseOfLoggingRegion,
    IN ULONG  SizeOfLoggingRegion
    );

DECLSPEC
VOID
STDCALL
CoverageRegisterUnloadHook(
    IN     LPCSTR         BinaryName,
    IN OUT PDRIVER_OBJECT DriverObject
    );

DECLSPEC
VOID
STDCALL
CoverageUnRegisterBinary(
    IN LPCSTR BinaryName
    );

VOID
STDCALL
CoverageUnloadDriver(
    IN PDRIVER_OBJECT DriverObject
    );

VOID
STDCALL
CoverageUnRegisterBinaryNode(
    IN PREGISTERED_BINARY pNode
    );


NTSTATUS
STDCALL
CoverageEnumerateBinaries(
    IN  ULONG  BufferSize,
    OUT PCHAR  Buffer,
    OUT PULONG ActualSize
    );

NTSTATUS
STDCALL
CoveragePollLogging(
    IN  LPCSTR BinaryName,
    IN  ULONG  BufferSize,
    OUT PVOID  Buffer,
    OUT PULONG ActualSize,
    OUT PULONG CheckSum
    );

NTSTATUS
STDCALL
CoverageFlushLogging(
    IN LPCSTR BinaryName OPTIONAL
    );

NTSTATUS
STDCALL
CoverageStoreLogHandle(
    IN LPCSTR BinaryName,
    IN ULONG  LogHandle
    );

VOID
OrBufferWithBuffer(
    IN OUT PVOID TargetBuffer,
    IN     PVOID SourceBuffer,
    IN     ULONG Size
    );

VOID
MoveLoggingInformationToBuffer(
    IN     ULONG BufferSize,
    IN OUT PVOID ActiveBuffer,
       OUT PVOID ReturnBuffer
    );

VOID
CoverageDbgPrint(
    IN LONG  InfoLevel,
    IN PCHAR Format,
    ...
    );


//
//  Default data segment for uninitialized data is .bss which is then
//  merged into initialized data segment .data.  We want these following
//  uninitialized data objects to be in .bss or .data because it must
//  be non-paged memory.
//

FAST_MUTEX RegistrationMutex;

#pragma data_seg( "PAGEDATA" )  // remainder of data in this driver is pageable

//
//  Internal CoverageDbgPrint is paged code.  This whole driver is essentially
//  paged code.  If we need to call CoverageDbgPrint in the future from
//  non-paged code, we need to move this CoverageDbgLogLevel variable to
//  non-paged data section.
//

enum {
    DBGLOG_NONE    = 0,
    DBGLOG_ERROR   = 1,
    DBGLOG_WARNING = 2,
    DBGLOG_INFO    = 3,
    DBGLOG_DEBUG   = 4
    } CoverageDbgLogLevel;

BOOLEAN DriverInitialized;

PREGISTERED_BINARY RegisteredBinaryList = (PREGISTERED_BINARY)&RegisteredBinaryList;

#pragma  code_seg( "INIT" )      //  DriverEntry is discardable after init
#pragma const_seg( "INITDATA" )  //  for const strings in code
#pragma  data_seg( "INITDATA" )  //  for strings in INIT code


NTSTATUS
STDCALL
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
    {
    RTL_QUERY_REGISTRY_TABLE RegConfigData[ 2 ];
    PDEVICE_OBJECT           DeviceObject = NULL;
    UNICODE_STRING           DeviceName;
    NTSTATUS                 Status;
    ULONG                    DefaultDebugLogLevel;

    RtlZeroMemory( &RegConfigData, sizeof( RegConfigData ));

    CoverageDbgLogLevel  = DBGLOG_INFO;
    DefaultDebugLogLevel = DBGLOG_INFO;

    RegConfigData[ 0 ].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    RegConfigData[ 0 ].Name          = L"DebugLogLevel";
    RegConfigData[ 0 ].EntryContext  = &CoverageDbgLogLevel;
    RegConfigData[ 0 ].DefaultType   = REG_DWORD;
    RegConfigData[ 0 ].DefaultData   = &DefaultDebugLogLevel;
    RegConfigData[ 0 ].DefaultLength = sizeof( ULONG );

    RtlQueryRegistryValues(
        RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
        RegistryPath->Buffer,
        RegConfigData,
        NULL,
        NULL
        );

    RtlInitUnicodeString( &DeviceName, L"\\DosDevices\\Coverage" );

    Status = IoCreateDevice(
                 DriverObject,
                 0,
                 &DeviceName,
                 FILE_DEVICE_UNKNOWN,
                 0,
                 TRUE,
                 &DeviceObject
                 );

    if ( NT_SUCCESS( Status )) {

        DriverObject->DriverUnload                         = DriverUnload;
        DriverObject->MajorFunction[IRP_MJ_CREATE]         = DeviceOpen;
        DriverObject->MajorFunction[IRP_MJ_CLOSE]          = DeviceClose;
        DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DeviceIoctl;

        ExInitializeFastMutex( &RegistrationMutex );

        DriverInitialized = TRUE;

        CoverageDbgPrint( DBGLOG_INFO, "COVERAGE: Driver loaded\n" );

        //
        //  Now attempt to register "no import" coverage binaries
        //  that have already been loaded.
        //

        RegisterNoImportCoverageBinaries();
        }
    else {
        CoverageDbgPrint( DBGLOG_ERROR, "COVERAGE: Driver load failed (%X)\n", Status );
        }

    return Status;
    }


VOID
STDCALL
RegisterNoImportCoverageBinaries(
    VOID
    )
    {
    SYSTEM_BASIC_INFORMATION BasicInformation;
    PRTL_PROCESS_MODULES pModuleInformation;
    RTL_PROCESS_MODULES ModuleInformation;
    ULONG AllocationSize;
    NTSTATUS Status;
    ULONG i;

    Status = ZwQuerySystemInformation(
                 SystemBasicInformation,
                 &BasicInformation,
                 sizeof( BasicInformation ),
                 NULL
                 );

    if ( NT_SUCCESS( Status )) {

        ModuleInformation.NumberOfModules = 0;

        ZwQuerySystemInformation(
           SystemModuleInformation,
           &ModuleInformation,
           sizeof( ModuleInformation ),
           NULL
           );

        if ( ModuleInformation.NumberOfModules != 0 ) {

            AllocationSize = sizeof( RTL_PROCESS_MODULES ) +
                             sizeof( RTL_PROCESS_MODULE_INFORMATION ) *
                             ModuleInformation.NumberOfModules;

            pModuleInformation = ExAllocatePoolWithTag(
                                     PagedPool,
                                     AllocationSize,
                                     'RVOC'
                                     );

            if ( pModuleInformation != NULL ) {

                Status = ZwQuerySystemInformation(
                            SystemModuleInformation,
                            pModuleInformation,
                            AllocationSize,
                            NULL
                            );

                if ( NT_SUCCESS( Status )) {

                    for ( i = 0; i < pModuleInformation->NumberOfModules; i++ ) {

                        if ((ULONG)pModuleInformation->Modules[ i ].ImageBase > BasicInformation.MaximumUserModeAddress ) {

#if 0   // too verbose

                            CoverageDbgPrint(
                                 DBGLOG_DEBUG,
                                 "COVERAGE: Inspecting module at %08X (%s)\n",
                                 pModuleInformation->Modules[ i ].ImageBase,
                                 pModuleInformation->Modules[ i ].FullPathName + pModuleInformation->Modules[ i ].OffsetToFileName
                                 );

#endif  // too verbose

                            RegisterNoImportCoverageBinary( pModuleInformation->Modules[ i ].ImageBase );

                            }
                        }
                    }

                else {
                    CoverageDbgPrint( DBGLOG_DEBUG, "COVERAGE: Failed querying system modules info (%X)\n", Status );
                    }

                ExFreePool( pModuleInformation );
                }

            else {
                CoverageDbgPrint( DBGLOG_DEBUG, "COVERAGE: Failed allocating memory for querying system modules info\n" );
                }
            }

        else {
            CoverageDbgPrint( DBGLOG_DEBUG, "COVERAGE: Failed querying system modules info\n" );
            }
        }

    else {
        CoverageDbgPrint( DBGLOG_DEBUG, "COVERAGE: Failed querying system info (%X)\n", Status );
        }
    }


VOID
STDCALL
RegisterNoImportCoverageBinary(
    IN PVOID ImageBase
    )
    {
    PIMAGE_DOS_HEADER     DosHeader;
    PIMAGE_NT_HEADERS     NtHeader;
    PIMAGE_SECTION_HEADER SectionHeader;
    ULONGLONG             SectionName;
    ULONG                 SectionCount;
    PCHAR                 SectionBase;
    ULONG                 OriginalCheckSum;
    LPSTR                 OriginalFileName;
    PCHAR                 BaseOfLoggingRegion;
    ULONG                 SizeOfLoggingRegion;
    ULONG                 i;

    //
    //  We assume that each module's PE header is resident at its mapped
    //  base address.  We walk the PE header and PE section table looking
    //  for ".cover" section.  If we find it, we register the binary.
    //
    //  If we do eventually make this routine callable other than during
    //  DriverEntry, then we'll need to move it to the PAGE section rather
    //  than the INIT section.
    //

    try {

        if ( ! MmIsAddressValid( ImageBase )) {
            leave;
            }

        DosHeader = (PIMAGE_DOS_HEADER) ImageBase;

        if ( DosHeader->e_magic == IMAGE_DOS_SIGNATURE ) {

            NtHeader = (PIMAGE_NT_HEADERS)((PCHAR)ImageBase + DosHeader->e_lfanew );

            if ( ! MmIsAddressValid( NtHeader )) {
                leave;
                }
            }
        else {
            NtHeader = (PIMAGE_NT_HEADERS)( ImageBase );
            }

        if ( NtHeader->Signature != IMAGE_NT_SIGNATURE ) {
            leave;
            }

        SectionHeader = IMAGE_FIRST_SECTION( NtHeader );
        SectionCount  = NtHeader->FileHeader.NumberOfSections;

        if ( ! MmIsAddressValid( &SectionHeader[ SectionCount ] )) {
            leave;
            }

        for ( i = 0; i < SectionCount; i++ ) {

            //
            //  To make section name comparison fast, read it into an 8-byte
            //  DWORDLONG, do a sneaky lowercase by ORing all the characters
            //  with 0x20, which also has the effect of "normalizing" any
            //  zero byte characters to spaces.  Then we can just do a simple
            //  DWORDLONG comparison with the ".cover  " equivalent value.
            //

            SectionName  = *(UNALIGNED ULONGLONG*)( &SectionHeader[ i ].Name );
            SectionName |= 0x2020202020202020;

#if 0   // too verbose

            CoverageDbgPrint(
                 DBGLOG_DEBUG,
                 "COVERAGE: Inspecting section \"%c%c%c%c%c%c%c%c\" at %08X\n",
                 (UCHAR)( SectionName >>  0 ),
                 (UCHAR)( SectionName >>  8 ),
                 (UCHAR)( SectionName >> 16 ),
                 (UCHAR)( SectionName >> 24 ),
                 (UCHAR)( SectionName >> 32 ),
                 (UCHAR)( SectionName >> 40 ),
                 (UCHAR)( SectionName >> 48 ),
                 (UCHAR)( SectionName >> 56 ),
                 (PCHAR)ImageBase + SectionHeader[ i ].VirtualAddress
                 );

#endif  // too verbose

            if ( SectionName == 0x20207265766F632E ) {      // ".cover  "

                //
                //  Data stored in coverage section looks like this:
                //
                //      Offset 0: DWORD  SizeOfLoggingRegion
                //      Offset 4: DWORD  CheckSumOfOriginalBinary
                //      Offset 8: CHAR[] FileNameOfOriginalBinary (null terminated string)
                //      Offset X: CHAR[] LoggingBuffer (size is SizeOfLoggingRegion)
                //
                //      X is computed as ROUNDUP2(( strlen( name ) + 1 + 8 ), 32 ) to
                //      place the LoggingBuffer on a 32-byte boundary.
                //

                SectionBase = (PVOID)((PCHAR)ImageBase + SectionHeader[ i ].VirtualAddress );

                CoverageDbgPrint( DBGLOG_DEBUG, "COVERAGE: Found \".cover\" section in image %08X at %08X\n", ImageBase, SectionBase );

                if ( MmIsAddressValid( SectionBase )) {

                    SizeOfLoggingRegion = *(PULONG)( SectionBase + 0 );
                    OriginalCheckSum    = *(PULONG)( SectionBase + 4 );
                    OriginalFileName    = SectionBase + 8;
                    BaseOfLoggingRegion = SectionBase + ROUNDUP2(( strlen( OriginalFileName ) + 1 + 8 ), 32 );

                    CoverageRegisterBinary(
                        OriginalFileName,
                        OriginalCheckSum,
                        BaseOfLoggingRegion,
                        SizeOfLoggingRegion
                        );
                    }

                break;
                }
            }
        }

    except( EXCEPTION_EXECUTE_HANDLER ) {
        }
    }


#pragma  code_seg( "PAGE" )      // remainder of code in this driver is pageable
#pragma const_seg( "PAGEDATA" )  // for const strings in code
#pragma  data_seg( "PAGEDATA" )  // remainder of data in this driver is pageable

VOID
CoverageDbgPrint(
    IN LONG  InfoLevel,
    IN PCHAR Format,
    ...
    )
    {
    CHAR Buffer[ 512 ];
    va_list ArgList;

    va_start( ArgList, Format );

    if ( InfoLevel <= CoverageDbgLogLevel ) {

        _vsnprintf( Buffer, sizeof( Buffer ), Format, ArgList );
        Buffer[ sizeof( Buffer ) - 2 ] = '\n';
        Buffer[ sizeof( Buffer ) - 1 ] = 0;
        DbgPrint( Buffer );
        }

    va_end( ArgList );
    }


//
//  Note that following DeviceOpen and DeviceClose implementations are the
//  exact same code.  The linker is kind enough to "fold" them into a single
//  piece of code (identical comdat elimination), so no need to obfuscate the
//  source code here by creating a single function named DeviceOpenClose that
//  does both duties.
//

NTSTATUS
STDCALL
DeviceOpen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
    {
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return STATUS_SUCCESS;
    }


NTSTATUS
STDCALL
DeviceClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
    {
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return STATUS_SUCCESS;
    }


NTSTATUS
STDCALL
DeviceIoctl(
    IN PDEVICE_OBJECT IoctlDeviceObject,
    IN PIRP Irp
    )
    {
    PIO_STACK_LOCATION IrpStack      = IoGetCurrentIrpStackLocation( Irp );
    PVOID              OutBuffer     = Irp->UserBuffer;
    ULONG              OutBufferSize = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    ULONG              InBufferSize  = IrpStack->Parameters.DeviceIoControl.InputBufferLength;
    PVOID              InBuffer      = IrpStack->Parameters.DeviceIoControl.Type3InputBuffer;
    ULONG              ActualSize    = 0;
    NTSTATUS           Status;

    switch ( IrpStack->Parameters.DeviceIoControl.IoControlCode ) {

        case IOCTL_COVERAGE_ENUM_BINARIES:

            Status = CoverageEnumerateBinaries(
                         OutBufferSize,
                         OutBuffer,
                         &ActualSize
                         );
            break;

        case IOCTL_COVERAGE_POLL_LOGGING:

            Status = CoveragePollLogging(
                         InBuffer,              /* pszBinaryName      */
                         OutBufferSize,
                         OutBuffer,
                         &ActualSize,
                         (PULONG)InBufferSize   /* return checksum */
                         );
            break;

        case IOCTL_COVERAGE_FLUSH_LOGGING:

            Status = CoverageFlushLogging(
                         InBuffer                /* pszBinaryName */
                         );
            break;

        default:

            Status = STATUS_INVALID_PARAMETER;

        }

    Irp->IoStatus.Status      = Status;
    Irp->IoStatus.Information = ActualSize;

    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return Status;
    }


//
//  Following support functions are inlined, so do not actually exist
//  as functions in the binary.
//

VOID
INLINE
AcquireRegistrationMutex(
    VOID
    )
    {
    ExAcquireFastMutex( &RegistrationMutex );
    }


VOID
INLINE
AcquireRegistrationMutexIfInitialized(
    VOID
    )
    {
    if ( DriverInitialized ) ExAcquireFastMutex( &RegistrationMutex );
    }


VOID
INLINE
ReleaseRegistrationMutex(
    VOID
    )
    {
    ExReleaseFastMutex( &RegistrationMutex );
    }


VOID
INLINE
ReleaseRegistrationMutexIfInitialized(
    VOID
    )
    {
    if ( DriverInitialized ) ExReleaseFastMutex( &RegistrationMutex );
    }


PREGISTERED_BINARY
INLINE
AllocateRegisteredBinaryNode(
    IN ULONG BinaryNameLength
    )
    {
    return ExAllocatePoolWithTag(
               PagedPool,
               sizeof( REGISTERED_BINARY ) + BinaryNameLength,
               'RVOC'
               );
    }


PREGISTERED_BINARY
INLINE
AllocateRegisteredBinaryNodeWithName(
    IN LPCSTR BinaryName
    )
    {
    ULONG NameLength = strlen( BinaryName );
    PREGISTERED_BINARY pNode = AllocateRegisteredBinaryNode( NameLength );

    if ( pNode != NULL ) {
        RtlZeroMemory( pNode, sizeof( *pNode ) - sizeof( pNode->BinaryName ));
        RtlCopyMemory( pNode->BinaryName, BinaryName, NameLength + 1 );
        }

    return pNode;
    }


VOID
INLINE
AddRegisteredBinaryNodeToList(
    IN PREGISTERED_BINARY pPrev,
    IN PREGISTERED_BINARY pNode
    )
    {
    pNode->pNext = pPrev->pNext;
    pPrev->pNext = pNode;
    }


//
//  Following functions are exported for coverage-instrumented binaries to
//  register at load and deregister at unload with the coverage.sys driver.
//  Note that these functions are in paged memory, so should never instrument
//  a driver with /Entry or /EntryExports if the instrumented entry points
//  get called at DPC level or higher where touching non-paged code or data
//  is not allowed.
//


DECLSPEC
VOID
STDCALL
CoverageRegisterBinary(
    IN LPCSTR BinaryName,               // must be lowercase or case consistent
    IN ULONG  CheckSumOfBinary,         // checksum of original binary
    IN PCHAR  BaseOfLoggingRegion,      // instrumented logging region base
    IN ULONG  SizeOfLoggingRegion       // instrumented logging region size
    )
    {
    PCHAR EndOfLoggingRegion;
    PREGISTERED_BINARY pNode;
    PREGISTERED_BINARY pPrev;
    BOOLEAN Found = FALSE;

    //
    //  This is an exported entry point, and it's possible that this will
    //  get called before our DriverEntry gets a chance to initialize (when
    //  a binary that imports this binary gets loaded first).  If this
    //  happens, it is a bad thing because we can never get a DriverObject
    //  created for this driver, so we can never communicate with user mode.
    //  Detect if this is the case and display a warning.
    //

    if ( ! DriverInitialized ) {
        CoverageDbgPrint(
            DBGLOG_WARNING,
            "COVERAGE: %s loaded before coverage.sys initialized, kernel-mode\n"
            "    logging data may be lost (inaccessible).\n",
            BinaryName
            );
        }

    AcquireRegistrationMutexIfInitialized();

    EndOfLoggingRegion = BaseOfLoggingRegion + SizeOfLoggingRegion - 1;

    //
    //  Walk list of registered binaries looking for name or logging region
    //

    pPrev = (PREGISTERED_BINARY)&RegisteredBinaryList;
    pNode = RegisteredBinaryList;

    while ( pNode != (PREGISTERED_BINARY)&RegisteredBinaryList ) {

        //
        //  Test if names match.  Names are always lowercase from BBCOVER.
        //

        if ( strcmp( pNode->BinaryName, BinaryName ) == 0 ) {

            //
            //  Reloading binary with same name.  If same checksum, just
            //  update new logging buffer location and continue.
            //

            if (( pNode->CheckSumOfBinary    != CheckSumOfBinary    ) ||
                ( pNode->SizeOfLoggingRegion != SizeOfLoggingRegion )) {

                //
                //  Reloading different version of binary with same name.
                //  Must invalidate any existing data for previous binary.
                //

                if ( pNode->CapturedLogging ) {

                    CoverageDbgPrint(
                        DBGLOG_ERROR,
                        "COVERAGE: %s logging data lost when new version of driver\n"
                        "    was loaded because data was not saved after previous version\n"
                        "    of driver was unloaded.\n",
                        BinaryName
                        );

                    ExFreePool( pNode->CapturedLogging );
                    pNode->CapturedLogging  = NULL;
                    pNode->CheckSumOfBinary = CheckSumOfBinary;

                    }
                }

            CoverageDbgPrint(
                DBGLOG_INFO,
                "COVERAGE: %s registered (%x - %x) (reloaded)\n",
                BinaryName,
                BaseOfLoggingRegion,
                EndOfLoggingRegion
                );

            pNode->BaseOfLoggingRegion = BaseOfLoggingRegion;
            pNode->SizeOfLoggingRegion = SizeOfLoggingRegion;

            Found = TRUE;
            break;
            }

        else {

            //
            //  Not the same binary name, sanity test logging regions.
            //

            if (( pNode->BaseOfLoggingRegion != NULL ) &&
                (( pNode->BaseOfLoggingRegion < EndOfLoggingRegion  ) ^
                 (( pNode->BaseOfLoggingRegion + pNode->SizeOfLoggingRegion - 1 ) < BaseOfLoggingRegion ))) {

                //
                //  Some other binary already logging in requested range.
                //  This should never happen since a driver that can unload
                //  must have gone through our unload hook which would have
                //  zeroed the registered logging region.  We might hit this
                //  if we're not instrumenting to hook unload routines.
                //

                CoverageDbgPrint(
                    DBGLOG_WARNING,
                    "COVERAGE: %s logging region (%x - %x) overlaps region\n"
                    "    previously occupied by %s (%s - %s).  Must assume\n"
                    "    %s has been unloaded and will now be deregistered.\n",
                    BinaryName,
                    BaseOfLoggingRegion,
                    EndOfLoggingRegion,
                    pNode->BinaryName,
                    pNode->BaseOfLoggingRegion,
                    pNode->BaseOfLoggingRegion + pNode->SizeOfLoggingRegion - 1,
                    pNode->BinaryName
                    );

                pNode->BaseOfLoggingRegion = NULL;

                }
            }

        pPrev = pNode;
        pNode = pNode->pNext;

        }

    if ( ! Found ) {

        //
        //  New binary, add to list.
        //

        pNode = AllocateRegisteredBinaryNodeWithName( BinaryName );

        if ( pNode ) {

            pNode->BaseOfLoggingRegion = BaseOfLoggingRegion;
            pNode->SizeOfLoggingRegion = SizeOfLoggingRegion;
            pNode->CheckSumOfBinary    = CheckSumOfBinary;

            AddRegisteredBinaryNodeToList( pPrev, pNode );

            CoverageDbgPrint(
                DBGLOG_INFO,
                "COVERAGE: %s registered (%x - %x)\n",
                BinaryName,
                BaseOfLoggingRegion,
                EndOfLoggingRegion
                );

            }

        else {

            CoverageDbgPrint(
                DBGLOG_ERROR,
                "COVERAGE: %s could not be registered (failed to allocate memory).\n",
                BinaryName
                );
            }
        }

    ReleaseRegistrationMutexIfInitialized();
    }


DECLSPEC
VOID
STDCALL
CoverageRegisterUnloadHook(
    IN     LPCSTR         BinaryName,
    IN OUT PDRIVER_OBJECT DriverObject
    )
    {
    PREGISTERED_BINARY pNode;
    PDRIVER_UNLOAD TempDriverUnload;

    AcquireRegistrationMutexIfInitialized();

    pNode = RegisteredBinaryList;

    while ( pNode != (PREGISTERED_BINARY)&RegisteredBinaryList ) {

        if ( strcmp( pNode->BinaryName, BinaryName ) == 0 ) {

            try {

                //
                //  First try to dereference DriverObject and verify it
                //  really is a pointer to a DriverObject before storing
                //  any values in the DriverObject or in pNode.
                //

                if (( DriverObject != NULL ) &&
                    ( DriverObject->Type == IO_TYPE_DRIVER )) {

                    TempDriverUnload = DriverObject->DriverUnload;

                    if ( TempDriverUnload != NULL ) {

                        //
                        //  Only hook drivers that have an Unload routine
                        //  because drivers without Unload routines are not
                        //  unloadable.
                        //

                        DriverObject->DriverUnload = CoverageUnloadDriver;

                        //
                        //  If successfully read and updated DriverObject's
                        //  DriverUnload pointer, then update pNode to reflect
                        //  that we've hooked this driver's unload routine.
                        //

                        pNode->DriverUnload = TempDriverUnload;
                        pNode->DriverObject = DriverObject;

                        }

                    leave;
                    }

                CoverageDbgPrint(
                    DBGLOG_WARNING,
                    "COVERAGE: %s could not hook unload -- must save coverage\n"
                    "    logging data before unloading %s or coverage logging\n"
                    "    data will be lost.\n",
                    BinaryName,
                    BinaryName
                    );
                }

            except ( EXCEPTION_EXECUTE_HANDLER ) {

                CoverageDbgPrint(
                    DBGLOG_ERROR,
                    "COVERAGE: %s exception %x hooking unload\n",
                    BinaryName,
                    GetExceptionCode()
                    );
                }

            break;

            }

        pNode = pNode->pNext;

        }

    ReleaseRegistrationMutexIfInitialized();

    }


VOID
STDCALL
CoverageUnloadDriver(
    IN PDRIVER_OBJECT DriverObject
    )
    {
    PREGISTERED_BINARY pNode;
    PCHAR BaseOfLogging;
    ULONG SizeOfLogging;
    BOOLEAN Found = FALSE;

    AcquireRegistrationMutexIfInitialized();

    pNode = RegisteredBinaryList;

    while ( pNode != (PREGISTERED_BINARY)&RegisteredBinaryList ) {

        //
        //  pNode->DriverObject is non-NULL only for binaries that successfully
        //  hooked the DriverUnload routine.
        //

        if ( pNode->DriverObject == DriverObject ) {

            //
            //  First call driver's original unload routine to let it clean
            //  up and log its cleanup activity in its logging buffer.
            //  Implementation note: if driver's unload routine causes
            //  another coverage-instrumented driver to unload or load,
            //  we'll deadlock on the mutex if this driver doesn't return
            //  from its unload first.
            //

            ( pNode->DriverUnload )( DriverObject );

            //
            //  Now unregister the binary while the driver is still mapped.
            //  This will capture the logging buffer for later polling.
            //

            CoverageUnRegisterBinaryNode( pNode );

            Found = TRUE;
            break;
            }

        pNode = pNode->pNext;
        }

    if ( ! Found ) {

        CoverageDbgPrint(
            DBGLOG_ERROR,
            "COVERAGE: CoverageUnloadDriver called for unregistered binary.\n"
            "    Don't know original UnloadDriver routine to call.\n"
            );

        DbgBreakPoint();
        }

    ReleaseRegistrationMutexIfInitialized();

    }


VOID
STDCALL
CoverageUnRegisterBinaryNode(
    IN PREGISTERED_BINARY pNode
    )
    {
    PCHAR CaptureBuffer;
    PCHAR BaseOfLogging;
    ULONG SizeOfLogging;

    //
    //  Allocate a paged-pool buffer to store logging buffer
    //  and save the binary's logging buffer contents into it.
    //

    BaseOfLogging = pNode->BaseOfLoggingRegion;
    SizeOfLogging = pNode->SizeOfLoggingRegion;

    if ( BaseOfLogging != NULL ) {

        //
        //  Allocate capture buffer and copy logging information
        //  into it.
        //

        CaptureBuffer = ExAllocatePoolWithTag(
                            PagedPool,
                            SizeOfLogging,
                            'RVOC'
                            );

        if ( CaptureBuffer != NULL ) {

            MoveLoggingInformationToBuffer(
                SizeOfLogging,
                BaseOfLogging,
                CaptureBuffer
                );

            //
            //  Now, if an existing capture buffer already exists for
            //  this binary, OR the newly captured contents into the
            //  existing capture buffer and free the newly allocated
            //  capture buffer.
            //
            //  Buf if an existing capture buffer does not exist, use
            //  the newly allocated capture buffer as the capture
            //  buffer for this node (will be freed when polled).
            //

            if ( pNode->CapturedLogging == NULL ) {
                 pNode->CapturedLogging = CaptureBuffer;
                 }

            else {

                OrBufferWithBuffer(
                    pNode->CapturedLogging,
                    CaptureBuffer,
                    SizeOfLogging
                    );

                ExFreePool( CaptureBuffer );
                }

            CoverageDbgPrint(
                DBGLOG_WARNING,
                "COVERAGE: %s unloaded, captured logging needs to be saved\n",
                pNode->BinaryName
                );
            }

        else {

            CoverageDbgPrint(
                DBGLOG_ERROR,
                "COVERAGE: %s logging data lost when driver unloaded because\n"
                "    failed to allocate memory for logging buffer.\n",
                pNode->BinaryName
                );
            }

        //
        //  Once unregistered, set these to NULL so we know we've
        //  unregistered when try to re-register.
        //

        pNode->BaseOfLoggingRegion = NULL;
        pNode->DriverObject        = NULL;
        pNode->DriverUnload        = NULL;
        }

    else {

        //
        //  BaseOfLogging is NULL.  This can only happen if reloaded
        //  but we didn't catch the first unload.  This is just a
        //  sanity test to keep us from blowing up.
        //

        CoverageDbgPrint(
            DBGLOG_ERROR,
            "COVERAGE: %s logging data lost when driver unloaded because\n"
            "    driver already marked as unloaded.\n",
            pNode->BinaryName
            );
        }
    }


DECLSPEC
VOID
STDCALL
CoverageUnRegisterBinary(
    IN LPCSTR BinaryName                // must be lowercase or case consistent
    )
    {
    PREGISTERED_BINARY pNode;
    BOOLEAN Found = FALSE;

    AcquireRegistrationMutexIfInitialized();

    pNode = RegisteredBinaryList;

    while ( pNode != (PREGISTERED_BINARY)&RegisteredBinaryList ) {

        if ( strcmp( pNode->BinaryName, BinaryName ) == 0 ) {

            CoverageUnRegisterBinary( pNode->BinaryName );

            Found = TRUE;
            break;
            }

        pNode = pNode->pNext;
        }

    if ( ! Found ) {

        CoverageDbgPrint(
            DBGLOG_ERROR,
            "COVERAGE: CoverageUnRegisterBinary called for unregistered binary %s.\n",
            BinaryName
            );
        }

    ReleaseRegistrationMutexIfInitialized();
    }


VOID
OrBufferWithBuffer(
    IN PVOID TargetBuffer,
    IN PVOID SourceBuffer,
    IN ULONG Size
    )
    {
    ULONG CountLongs = Size / 4;
    ULONG CountBytes = Size & 3;

    while ( CountLongs-- ) {
        *((UNALIGNED ULONG*) TargetBuffer )++ |= *((UNALIGNED ULONG*) SourceBuffer )++;
        }

    while ( CountBytes-- ) {
        *((UNALIGNED UCHAR*) TargetBuffer )++ |= *((UNALIGNED UCHAR*) SourceBuffer )++;
        }
    }


//
//  Following functions are exported via corresponding IOCTLs to allow
//  user-mode coverage service to poll and flush the kernel-mode logging
//  information.  Note that probe-and-capture of caller parameters is not
//  bulletproof here (caller could supply kernel-mode addresses for arguments),
//  but this driver is not intended as a released product.  Basic verification
//  is performed to prevent "accidental" mistakes by the caller.
//


NTSTATUS
STDCALL
CoveragePollLogging(
    IN  LPCSTR BinaryName,
    IN  ULONG  BufferSize,
    OUT PVOID  Buffer,
    OUT PULONG ActualSize,
    OUT PULONG CheckSum
    )
    {
    PREGISTERED_BINARY pNode;
    PCHAR BaseOfLogging;
    ULONG SizeOfLogging;
    NTSTATUS Status;

    if ( BinaryName == NULL ) {
        return STATUS_INVALID_PARAMETER;
        }

    Status = STATUS_SUCCESS;

    AcquireRegistrationMutex();

    try {

        if ( ActualSize ) {
            *ActualSize = 0;
            }

        if ( CheckSum ) {
            *CheckSum = 0;
            }

        pNode = RegisteredBinaryList;

        while ( pNode != (PREGISTERED_BINARY)&RegisteredBinaryList ) {

            if ( strcmp( pNode->BinaryName, BinaryName ) == 0 ) {

                if ( CheckSum ) {
                    *CheckSum = pNode->CheckSumOfBinary;
                    }

                SizeOfLogging = pNode->SizeOfLoggingRegion;

                if ( SizeOfLogging != 0 ) {

                    if ( ActualSize ) {
                        *ActualSize = SizeOfLogging;
                        }

                    if (( Buffer == NULL ) || ( BufferSize < SizeOfLogging )) {

                        Status = STATUS_BUFFER_TOO_SMALL;
                        leave;
                        }

                    BaseOfLogging = pNode->BaseOfLoggingRegion;

                    if ( BaseOfLogging != NULL ) {

                        MoveLoggingInformationToBuffer(
                            SizeOfLogging,
                            BaseOfLogging,
                            Buffer
                            );

                        if ( pNode->CapturedLogging != NULL ) {

                            OrBufferWithBuffer(
                                Buffer,
                                pNode->CapturedLogging,
                                SizeOfLogging
                                );

                            ExFreePool( pNode->CapturedLogging );
                            pNode->CapturedLogging = NULL;
                            }
                        }

                    else if ( pNode->CapturedLogging != NULL ) {

                        RtlCopyMemory(
                            Buffer,
                            pNode->CapturedLogging,
                            SizeOfLogging
                            );

                        ExFreePool( pNode->CapturedLogging );
                        pNode->CapturedLogging = NULL;
                        }

                    else {

                        RtlZeroMemory(
                            Buffer,
                            SizeOfLogging
                            );
                        }
                    }

                leave;
                }

            pNode = pNode->pNext;
            }

        Status = STATUS_NOT_FOUND;
        }

    except ( EXCEPTION_EXECUTE_HANDLER ) {
        Status = GetExceptionCode();
        }

    ReleaseRegistrationMutex();

    return Status;
    }


VOID
MoveLoggingInformationToBuffer(
    IN     ULONG BufferSize,
    IN OUT PVOID ActiveBuffer,
       OUT PVOID ReturnBuffer
    )
    {

    //
    //  The purpose of this function is to copy the contents of the logging
    //  buffer to the output buffer and reset the logging buffer to zero at
    //  the same time.  Since this can occur realtime while new logging is
    //  written to the logging buffer, must be multiprocessor/multithread
    //  safe.  This means atomic "FetchAndSet" of each element to zero.
    //  Caller should handle exceptions from invalid memory access.
    //

#ifdef _M_IX86

    __asm {

        mov     ecx, BufferSize
        xor     eax, eax
        mov     esi, ActiveBuffer
        mov     edx, ecx
        mov     edi, ReturnBuffer
        shr     ecx, 2          ; ecx is now number of dwords to move
        jz      BYTES

LOOPD:  xchg    [esi], eax      ; xchg implies lock prefix (mp safe)
        add     esi, 4
        stosd                   ; mov dword ptr [edi++], eax
        xor     eax, eax
        dec     ecx
        jnz     LOOPD

BYTES:  and     edx, 3          ; edx is now remainder odd bytes to move
        jz      DONE

LOOPB:  xchg    [esi], al       ; xchg implies lock prefix (mp safe)
        add     esi, 1
        stosb                   ; mov byte ptr [edi++], al
        mov     al, 0
        dec     edx
        jnz     LOOPB

DONE:
        }

#else // not x86

    #error "Must implement MoveLoggingInformationToBuffer() for this platform"

#endif // _M_IX86

    }


NTSTATUS
STDCALL
CoverageFlushLogging(
    IN LPCSTR BinaryName OPTIONAL
    )
    {
    PREGISTERED_BINARY pNode;
    PCHAR BaseOfLogging;
    ULONG SizeOfLogging;
    NTSTATUS Status = STATUS_SUCCESS;

    AcquireRegistrationMutex();

    try {

        pNode = RegisteredBinaryList;

        while ( pNode != (PREGISTERED_BINARY)&RegisteredBinaryList ) {

            if (( BinaryName == NULL ) ||
                ( strcmp( pNode->BinaryName, BinaryName ) == 0 )) {

                BaseOfLogging = pNode->BaseOfLoggingRegion;

                if ( BaseOfLogging != NULL ) {

                    SizeOfLogging = pNode->SizeOfLoggingRegion;

                    if ( SizeOfLogging != 0 ) {

                        try {
                            RtlZeroMemory( BaseOfLogging, SizeOfLogging );
                            }
                        except ( EXCEPTION_EXECUTE_HANDLER ) {
                            Status = GetExceptionCode();
                            }
                        }
                    }

                if ( pNode->CapturedLogging ) {
                    ExFreePool( pNode->CapturedLogging );
                    pNode->CapturedLogging = NULL;
                    }

                if ( BinaryName != NULL ) {
                    break;
                    }
                }

            pNode = pNode->pNext;
            }

        if (( BinaryName != NULL ) && ( Status == STATUS_SUCCESS )) {
            Status = STATUS_NOT_FOUND;
            }
        }

    except ( EXCEPTION_EXECUTE_HANDLER ) {
        Status = GetExceptionCode();
        }

    ReleaseRegistrationMutex();

    return Status;
    }


NTSTATUS
STDCALL
CoverageEnumerateBinaries(
    IN  ULONG  BufferSize,
    OUT PCHAR  Buffer,
    OUT PULONG ActualSize
    )
    {
    PREGISTERED_BINARY pNode;
    NTSTATUS Status = STATUS_SUCCESS;
    PCHAR BufferPointer = Buffer;

    AcquireRegistrationMutex();

    try {

        ULONG TotalSize = 0;

        if ( ActualSize ) {
            *ActualSize = 0;
            }

        pNode = RegisteredBinaryList;

        while ( pNode != (PREGISTERED_BINARY)&RegisteredBinaryList ) {

            ULONG NameLength = strlen( pNode->BinaryName ) + 1;

            TotalSize += NameLength;

            if ( TotalSize <= BufferSize ) {
                RtlCopyMemory( BufferPointer, pNode->BinaryName, NameLength );
                BufferPointer += NameLength;
                }

            pNode = pNode->pNext;
            }

        if ( ++TotalSize <= BufferSize ) {
            *BufferPointer = 0;
            }
        else {
            Status = STATUS_BUFFER_TOO_SMALL;
            }

        if ( ActualSize ) {
            *ActualSize = TotalSize;
            }
        }
    except ( EXCEPTION_EXECUTE_HANDLER ) {
        Status = GetExceptionCode();
        }

    ReleaseRegistrationMutex();

    return Status;
    }


VOID
STDCALL
DriverUnload(
    IN PDRIVER_OBJECT DriverObject
    )
    {
    PREGISTERED_BINARY pNode, pNext;

    //
    //  NOTE: We're relying on NT's refcounting for this driver to prevent it
    //        from being unloaded while instrumented drivers that import from
    //        this driver are still loaded.  Since we may have hooked other
    //        instrumented drivers unload routines to call code in this driver
    //        first, the system would blow up if this driver were unloaded and
    //        later an instrumented driver was unloaded.
    //

    AcquireRegistrationMutex();

    pNode = RegisteredBinaryList;

    RegisteredBinaryList = (PREGISTERED_BINARY)&RegisteredBinaryList;   // make list empty

    ReleaseRegistrationMutex();

    while ( pNode != (PREGISTERED_BINARY)&RegisteredBinaryList ) {

        if ( pNode->CapturedLogging ) {

            CoverageDbgPrint(
                DBGLOG_ERROR,
                "COVERAGE: %s logging data lost when coverage.sys unloaded.\n",
                pNode->BinaryName
                );

            ExFreePool( pNode->CapturedLogging );

            }

        pNext = pNode->pNext;

        ExFreePool( pNode );

        pNode = pNext;

        }

    IoDeleteDevice( DriverObject->DeviceObject );

    CoverageDbgPrint( DBGLOG_INFO, "COVERAGE: Driver unloaded\n" );

    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\coverage\dxt\core.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    coverage.cpp

Abstract:

    This module implements routines which provide support for collecting code
    coverage data for bbcover version 3.5

--*/

#include "coveragep.h"

INITIALIZED_CRITICAL_SECTION( CoverageRegistrationLock );

PREGISTERED_BINARY RegisteredBinaryList = (PREGISTERED_BINARY)&RegisteredBinaryList;

DWORD dwPollBufferSize = 0x100000;
PVOID pPollBuffer;



/*

Routine Description:

    RtlAppendAsciizToString was yanked from the libraries, 
    so a version is coded up here.

Arguments:

    STRING *ctString    - counted string 
    char *str           - ascii string to tack onto the end of ctString

Return Value:

    NTSTATUS

*/
NTSTATUS RtlAppendAsciizToString(STRING *ctString, char *str)
    {
    if(!str) return STATUS_INVALID_PARAMETER;
    USHORT len = (USHORT)strlen(str);

    if(len + ctString->Length > ctString->MaximumLength) return STATUS_BUFFER_TOO_SMALL;

    strcpy(ctString->Buffer+ctString->Length, str);
    ctString->Length = ctString->Length + len;

    return STATUS_SUCCESS;
    }


PVOID
CoverageAllocatePool(
    IN SIZE_T Size
    )
{
    PVOID p = ExAllocatePoolWithTag( Size, 'RVOC' );

    if ( p ) {
        RtlZeroMemory( p, Size );
    }

    return p;
}

PVOID
CoverageReAllocPool(
    IN SIZE_T Size,
    IN PVOID Ptr
    )
/*++

Routine Description:

    This routine reallocates a block of memory from kernel pool. This function
    resizes a memory block and change other memory block properties.

Arguments:

    Size - New size of memory block in bytes

    Ptr - Pointer to the block of memory that the function reallocates

Return Value:

    If the function succeeds, the return value is a pointer to the reallocated
    memory block and Ptr will be freed.  If the function fails, the return
    value is NULL

--*/
{
    PVOID NewPtr;
    SIZE_T PreviousSize;

    NewPtr = CoverageAllocatePool( Size );

    if ( NewPtr && Ptr ) {
        PreviousSize = ExQueryPoolBlockSize(Ptr);
        ASSERT( Size > PreviousSize );
        RtlCopyMemory( NewPtr, Ptr, PreviousSize );
        ExFreePool( Ptr );
    }

    return NewPtr;
}

PREGISTERED_BINARY
GetRegisteredBinaryList(
    VOID
    )
/*++

Routine Description:

    This in-line routine returns pointer to the list of registered binaries.

Arguments:

    None

Return Value:

    Pointer to the head of registered binary

--*/
{
    return RegisteredBinaryList;
}

PREGISTERED_BINARY
GetRegisteredBinaryListHead(
    VOID
    )
/*++

Routine Description:

    This in-line routine returns pointer to head of the list of registered
    binaries.

Arguments:

    None

Return Value:

    Pointer to the head of registered binary

--*/
{
    return (PREGISTERED_BINARY)&RegisteredBinaryList;
}

VOID
AcquireRegistrationLock(
    VOID
    )
/*++

Routine Description:

    This routine acquires the registration lock by entering critical section

Arguments:

    None

Return Value:

    None

--*/
{
    RtlEnterCriticalSection( &CoverageRegistrationLock );
}

VOID
ReleaseRegistrationLock(
    VOID
    )
/*++

Routine Description:

    This routine releases the registration lock by leaving critical section

Arguments:

    None

Return Value:

    None

--*/
{
    RtlLeaveCriticalSection( &CoverageRegistrationLock );
}

PREGISTERED_BINARY
INLINE
AllocateRegisteredBinaryNode(
    IN ULONG BinaryNameLength
    )
/*++

Routine Description:

    This routine allocates buffer for new registered binrary node.  The memory
    is allocated from kernel non-paged pool with pool tag 'COVR'

Arguments:

    BinaryNameLength - Length in bytes of binary name

Return Value:

    Pointer to newly allocated buffer or NULL

--*/
{
    return (PREGISTERED_BINARY)CoverageAllocatePool(
        sizeof(REGISTERED_BINARY) + BinaryNameLength );
}

PREGISTERED_BINARY
AllocateRegisteredBinaryNodeWithNameAndGUID(
    IN LPCSTR BinaryName,
    IN LPCSTR pszGUID
    )
/*++

Routine Description:

    Routine to allocate new node and initialize binary name and its GUID

Arguments:

    BinaryName - Name of binary being registered

    pszGUID - GUID of binary being registered

Return Value:

    Pointer to new registered node or NULL

--*/
{
    ULONG NameLength = strlen(BinaryName) + 1;
    ULONG GUIDLength = MD5_SIZE;
    PREGISTERED_BINARY pNode = AllocateRegisteredBinaryNode( NameLength );

    if ( pNode != NULL ) {
        RtlZeroMemory( pNode, sizeof( *pNode ) - sizeof( pNode->BinaryName ));
        RtlCopyMemory( pNode->BinaryName, BinaryName, NameLength );
        RtlCopyMemory( &(pNode->md5), pszGUID, GUIDLength );
    }

    return pNode;
}

VOID
INLINE
AddRegisteredBinaryNodeToList(
    IN PREGISTERED_BINARY pPrev,
    IN PREGISTERED_BINARY pNode
    )
{
    pNode->pNext = pPrev->pNext;
    pPrev->pNext = pNode;
}

VOID
NTAPI
InternalCoverageRegisterBinary(
    IN LPCSTR BinaryName,               // must be lowercase or case consistent
    IN LPCSTR pszGUID,
    IN ULONG  CheckSumOfBinary,         // checksum of original binary
    IN PCHAR  BaseOfLoggingRegion,      // instrumented logging region base
    IN ULONG  SizeOfLoggingRegion       // instrumented logging region size
    )
{
    PCHAR EndOfLoggingRegion;
    PREGISTERED_BINARY pNode;
    PREGISTERED_BINARY pPrev;
    BOOLEAN Found = FALSE;

    AcquireRegistrationLock();

    EndOfLoggingRegion = BaseOfLoggingRegion + SizeOfLoggingRegion - 1;

    //
    //  Walk list of registered binaries looking for name or logging region
    //

    pPrev = (PREGISTERED_BINARY)&RegisteredBinaryList;
    pNode = RegisteredBinaryList;

    while ( pNode != (PREGISTERED_BINARY)&RegisteredBinaryList ) {

        //
        //  Test if names match.  Names are always lowercase from BBCOVER.
        //

        if ( strcmp(pNode->BinaryName, BinaryName) == 0 ) {

            //
            //  Reloading binary with same name.  If not same checksum or
            //  size of logging region, need to invalidate old data.
            //

            if (( pNode->CheckSumOfBinary    != CheckSumOfBinary    ) ||
                ( pNode->SizeOfLoggingRegion != SizeOfLoggingRegion )) {

                //
                //  Reloading different version of binary with same name.
                //  Must invalidate any existing data for previous binary.
                //

                if ( pNode->CapturedLogging ) {

                    if ( !DoesBufferContainAllZeros(pNode->CapturedLogging, \
                                                    pNode->SizeOfLoggingRegion) ) {

                        DbgPrint(
                            "COVERAGE: %s logging data lost when new version of binary\n"
                            "    was loaded because data was not saved after previous version\n"
                            "    of binary was unloaded.\n",
                            BinaryName
                            );
                    }

                    ExFreePool( pNode->CapturedLogging );

                    pNode->CapturedLogging     = NULL;
                    pNode->CheckSumOfBinary    = CheckSumOfBinary;
                    pNode->BaseOfLoggingRegion = NULL;
                    pNode->SizeOfLoggingRegion = 0;

                }
            }

            //
            //  Names match, but now need to determine:
            //
            //      1) original driver still loaded, just re-registering (pnode->base == newbase)
            //      2) original driver unloaded, now reloading (pnode->base == NULL)
            //      3) original driver still loaded, loading new instance (pnode->base != NULL) && (pnode->base != newbase)
            //

            if ( pNode->BaseOfLoggingRegion == BaseOfLoggingRegion ) {

                //
                // Re-registering at same address, nothing to do.
                //

                DbgPrint(
                    "COVERAGE: %s re-registered at same address (0x%x - 0x%x)\n",
                    BinaryName, BaseOfLoggingRegion, EndOfLoggingRegion );

                Found = TRUE;
                break;

            }

            else if ( pNode->BaseOfLoggingRegion == NULL ) {

                //
                //  Originally unloaded, now reloading at new address.
                //

                DbgPrint( "COVERAGE: %s registered (0x%x - 0x%x) (reloaded)\n",
                          BinaryName, BaseOfLoggingRegion, EndOfLoggingRegion );

                pNode->BaseOfLoggingRegion = BaseOfLoggingRegion;
                pNode->SizeOfLoggingRegion = SizeOfLoggingRegion;

                Found = TRUE;
                break;

            }

            else if ( pNode->BaseOfLoggingRegion != BaseOfLoggingRegion ) {

                //
                //  Original is still loaded (or unload hook never called),
                //  so need to create new instance. (below)
                //

                DbgPrint( "COVERAGE: %s re-registered (0x%x - 0x%x)\n",
                          BinaryName, BaseOfLoggingRegion, EndOfLoggingRegion );

                break;

            }
        } else {

            //
            //  Not the same binary name, sanity test logging regions.
            //

            if ( (pNode->BaseOfLoggingRegion != NULL) &&
                 ((pNode->BaseOfLoggingRegion < EndOfLoggingRegion) ^ \
                  ((pNode->BaseOfLoggingRegion + pNode->SizeOfLoggingRegion - 1) < \
                   BaseOfLoggingRegion )) ) {

                //
                //  Some other binary already logging in requested range.
                //  This should never happen since a driver that can unload
                //  must have gone through our unload hook which would have
                //  zeroed the registered logging region.  We might hit this
                //  if we're not instrumenting to hook unload routines.
                //

                DbgPrint(
                    "COVERAGE: %s logging region (0x%x - 0x%x) overlaps region\n"
                    "    previously occupied by %s (%s - %s).  Must assume\n"
                    "    %s has been unloaded and will now be deregistered.\n",
                    BinaryName, BaseOfLoggingRegion, EndOfLoggingRegion,
                    pNode->BinaryName, pNode->BaseOfLoggingRegion,
                    pNode->BaseOfLoggingRegion + pNode->SizeOfLoggingRegion - 1,
                    pNode->BinaryName );

                pNode->BaseOfLoggingRegion = NULL;

            }
        }

        pPrev = pNode;
        pNode = pNode->pNext;

    }

    if ( !Found ) {

        //
        //  New binary, add to list.
        //

        pNode = AllocateRegisteredBinaryNodeWithNameAndGUID( BinaryName, pszGUID );

        if ( pNode ) {

            pNode->BaseOfLoggingRegion = BaseOfLoggingRegion;
            pNode->SizeOfLoggingRegion = SizeOfLoggingRegion;
            pNode->CheckSumOfBinary    = CheckSumOfBinary;

            AddRegisteredBinaryNodeToList( pPrev, pNode );

            DbgPrint( "COVERAGE: %s registered (0x%x - 0x%x)\n", BinaryName,
                      BaseOfLoggingRegion, EndOfLoggingRegion );

        } else {

            DbgPrint(
                "COVERAGE: %s could not be registered (failed to allocate memory).\n",
                BinaryName );

        }
    }

    ReleaseRegistrationLock();
}

VOID
NTAPI
CoverageRegisterBinaryWithStruct(
    IN PBBREG_HEADER pBBHeader
    )
{
    InternalCoverageRegisterBinary(
        (PCHAR)pBBHeader + pBBHeader->dwOffsetOfBinaryName,
        (PCHAR)pBBHeader + pBBHeader->dwOffsetOfGUID,
        pBBHeader->dwCheckSumOfBinary,
        (PCHAR)pBBHeader + pBBHeader->dwOffsetOfLoggingRegion,
        pBBHeader->dwSizeOfLoggingRegion
        );
}

VOID
NTAPI
RegisterNoImportCoverageBinary(
    IN PVOID ImageBase
    )
{
    PIMAGE_DOS_HEADER DosHeader;
    PIMAGE_NT_HEADERS NtHeader;
    ULONGLONG SectionName;
    ULONG SectionCount;
    PCHAR SectionBase;
    ULONG i;
    PIMAGE_SECTION_HEADER SectionHeader;

    //
    //  We assume that each module's PE header is resident at its mapped
    //  base address.  We walk the PE header and PE section table looking
    //  for ".cover" section.  If we find it, we register the binary.
    //
    //  If we do eventually make this routine callable other than during
    //  DriverEntry, then we'll need to move it to the PAGE section rather
    //  than the INIT section.
    //

    __try {

        if ( !MmIsAddressValid(ImageBase) ) {
            __leave;
        }

        DosHeader = (PIMAGE_DOS_HEADER)ImageBase;

        if ( DosHeader->e_magic == IMAGE_DOS_SIGNATURE ) {

            NtHeader = RtlImageNtHeader( ImageBase );

            if ( ! MmIsAddressValid(NtHeader) ) {
                __leave;
            }

        } else {

            NtHeader = (PIMAGE_NT_HEADERS)ImageBase;

        }

        if ( NtHeader->Signature != IMAGE_NT_SIGNATURE ) {
            __leave;
        }

        SectionHeader = IMAGE_FIRST_SECTION( NtHeader );
        SectionCount  = NtHeader->FileHeader.NumberOfSections;

        if ( !MmIsAddressValid(&SectionHeader[SectionCount]) ) {
            __leave;
        }

        for ( i=0; i<SectionCount; i++ ) {

            //
            //  To make section name comparison fast, read it into an 8-byte
            //  DWORDLONG, do a sneaky lowercase by ORing all the characters
            //  with 0x20, which also has the effect of "normalizing" any
            //  zero byte characters to spaces.  Then we can just do a simple
            //  DWORDLONG comparison with the ".cover  " equivalent value.
            //

            SectionName = *(UNALIGNED ULONGLONG*)( &SectionHeader[ i ].Name );
            SectionName |= 0x2020202020202020;

#if 0   // too verbose

            KdPrint(( "COVERAGE: Inspecting section \"%c%c%c%c%c%c%c%c\" at %08X\n",
                      (UCHAR)(SectionName >> 0), (UCHAR)(SectionName >> 8),
                      (UCHAR)(SectionName >> 16), (UCHAR)(SectionName >> 24),
                      (UCHAR)(SectionName >> 32), (UCHAR)(SectionName >> 40),
                      (UCHAR)(SectionName >> 48), (UCHAR)(SectionName >> 56),
                      (PCHAR)ImageBase + SectionHeader[i].VirtualAddress ));

#endif  // too verbose

            if ( SectionName == 0x20207265766F632E ) {      // ".cover  "

                //
                //  Data stored in coverage section looks like this:
                //
                //      Offset 0: DWORD  SizeOfLoggingRegion
                //      Offset 4: DWORD  CheckSumOfOriginalBinary
                //      Offset 8: CHAR[] FileNameOfOriginalBinary (null terminated string)
                //      Offset X: CHAR[] LoggingBuffer (size is SizeOfLoggingRegion)
                //
                //      X is computed as ROUNDUP2(( strlen( name ) + 1 + 8 ), 32 ) to
                //      place the LoggingBuffer on a 32-byte boundary.
                //

                SectionBase = (PCHAR)((PCHAR)ImageBase + SectionHeader[i].VirtualAddress);

                KdPrint(( "COVERAGE: Found \".cover\" section in image %08X at %08X\n",
                           ImageBase, SectionBase ));

                if ( MmIsAddressValid(SectionBase) ) {
                    CoverageRegisterBinaryWithStruct( (PBBREG_HEADER)SectionBase );
                }

                break;
            }
        }
    } __except( EXCEPTION_EXECUTE_HANDLER ) {
          KdPrint(( "COVERAGE: exception 0x%x while registerring image base = %p\n",
                    GetExceptionCode(), ImageBase ));
    }
}

NTSTATUS
CoverageInternalOpenLogFile(
    IN PREGISTERED_BINARY Node
    )
/*++

Routine Description:

    This routine opens coverage log file under c:\devkit\coverage\<BinaryName>\
    <BinaryName>.covdata.  It also read in previously saved data if exists.
    New covdata file will be created if the checksym of the binary does not
    match the previously saved data.

Arguments:

    Node - Registered node of the binary

Return Value:

    NT status code

--*/
{
    OBJECT_ATTRIBUTES ObjA;
    OBJECT_STRING PathString;
    OCHAR UniquifierBuffer[18];
    OCHAR PathBuffer[MAX_PATH+100];
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE Handle = NULL;
    FILE_NETWORK_OPEN_INFORMATION NetworkInfo;
    PCOVFILE_HEADER pCovFileHeader = NULL;
    PCOVFILE_HEADER pCovHeader;
    ULONG NumberOfBytesRead;
    DWORD dwHeaderSize;
    BOOL fRecurse = FALSE;

    ASSERT( Node->LogFileHandle == NULL );

    __try {

        //
        // Make sure we have coverage directory created under c:\devkit\coverage
        // We don't have to check for c:\devkit first because we were loaded
        // from c:\devkit\dxt\coverage.dxt
        //

        PathString.Buffer = PathBuffer;
        PathString.Length = 0;
        PathString.MaximumLength = sizeof(PathBuffer);

        Status = RtlAppendAsciizToString( &PathString,
            "\\Device\\Harddisk0\\Partition1\\Devkit\\Coverage\\" );

        if ( !NT_SUCCESS(Status) ) {
            __leave;
        }

        InitializeObjectAttributes( &ObjA, &PathString, OBJ_CASE_INSENSITIVE,
                                    NULL, NULL );

        Status = NtCreateFile( &Handle, FILE_LIST_DIRECTORY | SYNCHRONIZE,
                               &ObjA, &IoStatusBlock, NULL,
                               FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ | \
                               FILE_SHARE_WRITE, FILE_CREATE, \
                               FILE_DIRECTORY_FILE | \
                               FILE_SYNCHRONOUS_IO_NONALERT | \
                               FILE_OPEN_FOR_BACKUP_INTENT );

        if ( NT_SUCCESS(Status) ) {
            NtClose( Handle );
            Handle = NULL;
        } else if ( Status != STATUS_OBJECT_NAME_COLLISION ) {
            DbgPrint( "COVERAGE: LOST DATA for %s because failed to open directory\n"
                      "    %Z (0x%x)\n", Node->BinaryName,
                      &PathString, Status );
            __leave;
        }

        //
        // Now create a directory named <BinaryName> under Coverage
        //

        Status = RtlAppendAsciizToString( &PathString, Node->BinaryName );

        if ( !NT_SUCCESS(Status) ) {
            __leave;
        }

        Status = NtCreateFile( &Handle, FILE_LIST_DIRECTORY | SYNCHRONIZE,
                               &ObjA, &IoStatusBlock, NULL,
                               FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ | \
                               FILE_SHARE_WRITE, FILE_CREATE, \
                               FILE_DIRECTORY_FILE | \
                               FILE_SYNCHRONOUS_IO_NONALERT | \
                               FILE_OPEN_FOR_BACKUP_INTENT );

        if ( NT_SUCCESS(Status) ) {
            NtClose( Handle );
            Handle = NULL;
        } else if ( Status != STATUS_OBJECT_NAME_COLLISION ) {
            DbgPrint( "COVERAGE: LOST DATA for %s because failed to open directory\n"
                      "    directory %Z (0x%x)\n", Node->BinaryName,
                      &PathString, Status );
            __leave;
        }

        //
        // Now create a log file for this binary and also append checksum of
        // the binary if the this a newer version
        //

        Status = RtlAppendAsciizToString( &PathString, "\\" );

        if ( !NT_SUCCESS(Status) ) {
            __leave;
        }

        Status = RtlAppendAsciizToString( &PathString, Node->BinaryName );

        if ( !NT_SUCCESS(Status) ) {
            __leave;
        }

        if ( Node->dwUniquifier ) {
            sprintf( UniquifierBuffer, "%.08X.%X", Node->CheckSumOfBinary,
                     Node->dwUniquifier );
            Status = RtlAppendAsciizToString( &PathString, UniquifierBuffer );
            if ( !NT_SUCCESS(Status) ) {
                __leave;
            }
        }

        Status = RtlAppendAsciizToString( &PathString, ".covdata" );

        if ( !NT_SUCCESS(Status) ) {
            __leave;
        }

        Status = NtCreateFile( &Handle, GENERIC_READ | GENERIC_WRITE | \
                               SYNCHRONIZE | FILE_READ_ATTRIBUTES, &ObjA,
                               &IoStatusBlock, 0, FILE_ATTRIBUTE_NORMAL,
                               FILE_SHARE_READ, FILE_OPEN_IF,
                               FILE_RANDOM_ACCESS | FILE_WRITE_THROUGH
                               );

        if ( !NT_SUCCESS(Status) ) {
            DbgPrint( "COVERAGE: LOST DATA for %s because failed to open file\n"
                      "    %Z (0x%x)\n", Node->BinaryName,
                      &PathString, Status );
            __leave;
        }

        //
        // Query size of the file to see if we already have previously saved data
        //

        Status = NtQueryInformationFile( Handle, &IoStatusBlock,
                                         &NetworkInfo, sizeof(NetworkInfo),
                                         FileNetworkOpenInformation );

        if ( !NT_SUCCESS(Status) ) {
            KdPrint(( "COVERAGE: LOST DATA for %s because failed to query file\n"
                      "    %Z (0x%x)\n", Node->BinaryName, &PathString, Status ));
            __leave;
        }

        pCovFileHeader = (PCOVFILE_HEADER)CoverageAllocatePool(
            COVFILE_HEADER_MIN_SIZE );

        if ( !pCovFileHeader ) {
            Status = STATUS_NO_MEMORY;
            KdPrint(( "COVERAGE: LOST DATA for %s because failed to allocate memory\n",
                      Node->BinaryName ));
            __leave;
        }

        //
        // Read in the previously saved data if exists
        //

        NumberOfBytesRead = 0;

        if ( NetworkInfo.EndOfFile.QuadPart >= COVFILE_HEADER_MIN_SIZE ) {

            Status = NtReadFile( Handle, 0, 0, 0, &IoStatusBlock,
                                 pCovFileHeader, COVFILE_HEADER_MIN_SIZE,
                                 0 );

            if ( NT_SUCCESS(Status) ) {
                NumberOfBytesRead = IoStatusBlock.Information;
            } else {
                KdPrint(( "COVERAGE: LOST DATA for %s because failed to read file\n"
                          "    %Z (0x%x)\n", Node->BinaryName, &PathString, Status ));
                __leave;
            }
        }

        if ( NumberOfBytesRead != COVFILE_HEADER_MIN_SIZE ) {

            //
            // New file being created
            //

            KdPrint(( "COVERAGE: New file: %Z\n", &PathString ));

            RtlZeroMemory( pCovFileHeader, COVFILE_HEADER_MIN_SIZE );

            pCovFileHeader->dwSignature  = COVFILE_SIGNATURE;
            pCovFileHeader->dwVersion    = COVFILE_VERSION;
            pCovFileHeader->dwCheckSum   = Node->CheckSumOfBinary;
            pCovFileHeader->dwBlockCount = Node->SizeOfLoggingRegion;

            //
            // Header length is defined to be COVFILE_HEADER + GUID + one DIR_ENTRY,
            // rounded up to 512
            //

            pCovFileHeader->dwHeaderLength = ROUNDUP2( sizeof(COVFILE_HEADER) +
                MD5_SIZE + sizeof(COVFILE_DIRECTORY), COVFILE_HEADER_MIN_SIZE );

            //
            // Put GUID at end of header
            //

            pCovFileHeader->dwOffsetOfGUID = sizeof(COVFILE_HEADER);

            //
            // Put the first dir entry after the GUID
            //

            pCovFileHeader->dwOffsetOfFirstDir = ROUNDUP2( sizeof(COVFILE_HEADER) +
                                                           MD5_SIZE, 4 );

            RtlCopyMemory( (PCHAR)pCovFileHeader + pCovFileHeader->dwOffsetOfGUID,
                           &(Node->md5), MD5_SIZE );

            NetworkInfo.EndOfFile.QuadPart = COVFILE_HEADER_MIN_SIZE;

        } else if ( pCovFileHeader->dwSignature != COVFILE_SIGNATURE ||
                    pCovFileHeader->dwCheckSum != Node->CheckSumOfBinary ||
                    pCovFileHeader->dwBlockCount != Node->SizeOfLoggingRegion ) {

            //
            //  Existing file does not match checksum, close existing and open new.
            //

            DbgPrint( "COVERMON: Binary %s contains different checksum than %Z\n",
                      Node->BinaryName, &PathString );

            Node->dwUniquifier++;
            fRecurse = TRUE;
            Status = STATUS_PENDING;

            __leave;

        } else if ( pCovFileHeader->dwVersion > COVFILE_VERSION ) {

            //
            //  File is of newer version than we understand.
            //

            DbgPrint( "COVERMON: %Z is %s version than covermon understands\n",
                      &PathString, "newer" );

            Node->dwUniquifier++;
            fRecurse = TRUE;
            Status = STATUS_PENDING;

            __leave;

        } else if ( pCovFileHeader->dwVersion < COVFILE_VERSION ) {

            //
            //  File is of older version than we understand.
            //

            DbgPrint( "COVERMON: %Z is %s version than covermon understands\n",
                      &PathString, "older" );

            Node->dwUniquifier++;
            fRecurse = TRUE;
            Status = STATUS_PENDING;

            __leave;

        } else if ( pCovFileHeader->dwHeaderLength > COVFILE_HEADER_MIN_SIZE ) {

            //
            //  More header needs to be read and cached.
            //

            dwHeaderSize = pCovFileHeader->dwHeaderLength;
            pCovHeader = pCovFileHeader;

            pCovFileHeader = (PCOVFILE_HEADER)CoverageReAllocPool(
                dwHeaderSize, pCovHeader );

            if ( pCovFileHeader == NULL ) {

                DbgPrint( "COVERMON: LOST DATA for %s because failed to "
                          "allocate memory (%d bytes).\n", Node->BinaryName,
                          dwHeaderSize );

                pCovFileHeader = pCovHeader;
                Status = STATUS_NO_MEMORY;
                __leave;
            }

            NumberOfBytesRead = 0;

            Status = NtReadFile( Handle, 0, 0, 0, &IoStatusBlock,
                                 (PCHAR)pCovFileHeader + COVFILE_HEADER_MIN_SIZE,
                                 dwHeaderSize - COVFILE_HEADER_MIN_SIZE,
                                 0);

            if ( NT_SUCCESS(Status) ) {
                NumberOfBytesRead = IoStatusBlock.Information;
            } else {
                KdPrint(( "COVERAGE: LOST DATA for %s because failed to read file\n"
                          "    %Z (0x%x)\n", Node->BinaryName, &PathString, Status ));
                __leave;
            }
        }

        Node->pCachedCovFileHeader = pCovFileHeader;
        Node->LogFileHandle = Handle;
        Node->FileSize = NetworkInfo.EndOfFile;
        Status = STATUS_SUCCESS;

    } __finally {
        if ( !NT_SUCCESS(Status) ) {
            if ( Handle ) {
                NtClose( Handle );
            }
            if ( pCovFileHeader ) {
                ExFreePool( pCovFileHeader );
            }
        } else {
            Node->LogFileHandle = Handle;
        }
    }

    return fRecurse ? CoverageInternalOpenLogFile( Node ) : Status;
}

VOID
CoverageInternalCloseLogFile(
    PREGISTERED_BINARY Node
    )
/*++

Routine Description:

    This routine closes log file for the binary specified by registration
    node.  It also free memory allocated by CoverageInternalOpenLogFile.

Arguments:

    Node - Pointer to registration node

Return Value:

    None

--*/
{
    if ( Node->LogFileHandle != NULL ) {

        DbgPrint( "COVERMON: Closing covdata file for %s\n", Node->BinaryName );
        Node->dwUniquifier = 0;

        NtClose( Node->LogFileHandle );
        Node->LogFileHandle = NULL;

        if ( Node->pCachedCovFileHeader != NULL ) {
            ExFreePool( Node->pCachedCovFileHeader );
            Node->pCachedCovFileHeader = NULL;
        }
    }
}

VOID
CoverageInternalCloseLogFileAllBinaries(
    VOID
    )
/*++

Routine Description:

    This routine closes log files for all binaries.  It is called during the
    reboot notification.

Arguments:

    None

Return Value:

    None

--*/
{
    PREGISTERED_BINARY Node;

    AcquireRegistrationLock();

    Node = GetRegisteredBinaryList();
    while ( Node != GetRegisteredBinaryListHead() ) {
        CoverageInternalCloseLogFile( Node );
        Node = Node->pNext;
    }

    ReleaseRegistrationLock();
}

NTSTATUS
NTAPI
CoverageFlushLogging(
    IN PCSTR BinaryName OPTIONAL
    )
/*++

Routine Description:

    Resets (discards) any existing coverage information that has not been
    polled and saved for one or all running coverage binaries.  This can
    be useful to "zero" any coverage information prior to running a
    specific test.

Arguments:

    BinaryName - Optional name of the binary, if this argument is present
        only binary name matches will be flush

Return Value:

    NT status code

--*/
{
    NTSTATUS Status;
    PREGISTERED_BINARY Node;
    BOOL bFound = FALSE;

    AcquireRegistrationLock();

    Node = GetRegisteredBinaryList();

    while ( Node != GetRegisteredBinaryListHead() ) {
        if ( !ARGUMENT_PRESENT(BinaryName) ||
             !_stricmp(Node->BinaryName, BinaryName) ) {

            //
            // Zero out all the coverage data
            //

            if ( Node->BaseOfLoggingRegion && Node->SizeOfLoggingRegion ) {
                RtlZeroMemory( Node->BaseOfLoggingRegion, Node->SizeOfLoggingRegion );
            }

            if ( Node->CapturedLogging ) {
                ExFreePool( Node->CapturedLogging );
                Node->CapturedLogging = NULL;
            }

            bFound = TRUE;
        }

        Node = Node->pNext;
    }

    if ( ARGUMENT_PRESENT(BinaryName) && !bFound ) {
        Status = STATUS_DLL_NOT_FOUND;
    } else {
        Status = STATUS_SUCCESS;
    }

    ReleaseRegistrationLock();

    return Status;
}

BOOL
CoverageInitPoolBuffer(
    VOID
    )
/*++

Routine Description:

    This routine allocates memory for poll buffer.  The memory is allocated
    from non-paged kernel pool.

Arguments:

    None

Return Value:

    None

--*/
{
    dwPollBufferSize = ROUNDUP2( dwPollBufferSize, 8192 );
    pPollBuffer = CoverageAllocatePool( dwPollBufferSize );
    return pPollBuffer != NULL;
}

NTSTATUS
CoverageInternalUpdateLogFile(
    IN PREGISTERED_BINARY pNode,
    IN PCSTR pszTestName
    )
/*++

Routine Description:

    This routine updates coverage data to log file.  The file format is based
    on bbcover version 3.5

Arguments:

    Node - Registration node of the binary

    TestName - Name of the test to be saved

Return Value:

    NT status code

--*/
{
    PCOVFILE_HEADER pHeader;
    PCOVFILE_DIRECTORY pDirEntry;
    PCOVFILE_DIRECTORY_201 pDirEntry201;
    HANDLE hFile;
    DWORD dwNameHash;
    DWORD dwVectorSize;
    PVOID pNewBitVector;
    PVOID pOldBitVector;
    PVOID pMoveBuffer;
    bool  bFound;
    DWORD dwActual;
    DWORDLONG dwlOffset;
    DWORDLONG dwlFileSize;
    DWORDLONG dwlVectorOffset;
    DWORDLONG dwlMoveBias;
    DWORDLONG dwlExtent;
    PVOID pNewHeader;
    DWORD dwNameLength;
    DWORD dwEntryLength;
    DWORD dwGrowSize;
    DWORD dwOffsetOfFirstDir;
    LPSTR pszName;
    bool  bDataHasChanged;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_POSITION_INFORMATION CurrentPosition;

    //
    //  BUGBUG: The old code assumes that PollBufferCritSect is held.
    //

    pNewBitVector  = NULL;
    pOldBitVector  = NULL;
    pMoveBuffer    = NULL;
    pNewHeader     = NULL;
    bDataHasChanged = true;

    ASSERT( DoesBufferContainOnlyHex01s(pPollBuffer, pNode->SizeOfLoggingRegion) );

    __try {

        dwVectorSize = BITVECTOR_STORAGE_SIZE( pNode->SizeOfLoggingRegion );

        pNewBitVector = CoverageAllocatePool( dwVectorSize );

        if ( pNewBitVector == NULL ) {
            DbgPrint( "COVERMON: LOST DATA for %s because failed to allocate "
                     "memory (%d bytes).\n", pNode->BinaryName, dwVectorSize );
            Status = STATUS_NO_MEMORY;
            __leave;
        }

        *(UNALIGNED DWORD*)((PCHAR)pNewBitVector + dwVectorSize - 4 ) = 0;

        PackByteVectorToBitVector( pNode->SizeOfLoggingRegion,
                                   (PBYTE)pPollBuffer, (PBYTE)pNewBitVector );

        ASSERT( CountBitsSetInBuffer(pPollBuffer, pNode->SizeOfLoggingRegion) ==
            CountBitsSetInBuffer(pNewBitVector, dwVectorSize) );

        bFound     = false;
        hFile      = pNode->LogFileHandle;
        dwNameHash = HashName( pszTestName );
        pHeader    = pNode->pCachedCovFileHeader;
        dwOffsetOfFirstDir = pHeader->dwOffsetOfFirstDir;
        pDirEntry  = (PCOVFILE_DIRECTORY)((PCHAR)pHeader + dwOffsetOfFirstDir);

        while ( pDirEntry->dwLengthOfEntry != 0 ) {

            if ( pDirEntry->dwHashOfName == dwNameHash ) {

                //
                //  Offset of pDirEntry->szName is different for versions
                //  201 and 202 of covdata file.
                //

                if ( pHeader->dwVersion == COVFILE_VERSION_201 ) {
                    pszName = ((PCOVFILE_DIRECTORY_201)pDirEntry)->szName;
                } else {
                    ASSERT( pHeader->dwVersion == COVFILE_VERSION );
                    pszName = pDirEntry->szName;
                }

                if ( _stricmp( pszName, pszTestName ) == 0 ) {
                    bFound = true;
                    break;
                }
            }

            pDirEntry = (PCOVFILE_DIRECTORY)( (PCHAR)pDirEntry +
                                              pDirEntry->dwLengthOfEntry );
        }

        if ( bFound ) {

            //
            //  If test name found, read existing vector, OR with new vector,
            //  write back to file.
            //

            pOldBitVector = CoverageAllocatePool( dwVectorSize );

            if( pOldBitVector == NULL ){
                DbgPrint( "COVERMON: LOST DATA for %s because failed to "
                          "allocate memory (%d bytes).\n", pNode->BinaryName,
                          dwVectorSize );
                Status = STATUS_NO_MEMORY;
                __leave;
            }

            if ( pHeader->dwVersion == COVFILE_VERSION_201 ) {
                dwlVectorOffset = ((PCOVFILE_DIRECTORY_201)pDirEntry)->dwOffsetOfData;
            }
            else {
                ASSERT( pHeader->dwVersion == COVFILE_VERSION );
                dwlVectorOffset = pDirEntry->dwlOffsetOfData;
            }

            dwActual = 0;

            //
            // If there is already a saved vector, then read from covdata file
            //

            CurrentPosition.CurrentByteOffset.QuadPart = dwlVectorOffset;

            Status = NtSetInformationFile( hFile, &IoStatusBlock,
                &CurrentPosition, sizeof(CurrentPosition),
                FilePositionInformation );

            if ( !NT_SUCCESS(Status) ) {
                __leave;
            }

            Status = NtReadFile( hFile, 0, 0, 0, &IoStatusBlock, pOldBitVector,
                                 dwVectorSize, 0);

            if ( NT_SUCCESS(Status) ) {
                dwActual = IoStatusBlock.Information;
            } else {
                DbgPrint( "COVERMON: LOST DATA for %s because failed to read "
                          "covdata file (0x%x)\n", pNode->BinaryName,
                          Status );
                __leave;
            }

            //
            // 1) NewBuf = NewBuf OR OldBuf
            // 2) OldBuf = NewBuf XOR OldBuf
            // 3) If any 1's in OldBuf, then there were changes; save data
            //    otherwise, no changes, so don't save
            //
            OrBufferWithBuffer( pNewBitVector, pOldBitVector, dwVectorSize );

            ASSERT( CountBitsSetInBuffer( pNewBitVector, dwVectorSize ) >=
                CountBitsSetInBuffer( pOldBitVector, dwVectorSize ));

            XorBufferWithBuffer( pOldBitVector, pNewBitVector, dwVectorSize );

            if( DoesBufferContainAllZeros( pOldBitVector, dwVectorSize ) ){
                bDataHasChanged = false;
            } else {
                bDataHasChanged = true;
            }

            dwActual = 0;

            if( bDataHasChanged ){
                CurrentPosition.CurrentByteOffset.QuadPart = dwlVectorOffset;

                Status = NtSetInformationFile( hFile, &IoStatusBlock,
                    &CurrentPosition, sizeof(CurrentPosition),
                    FilePositionInformation );

                if ( !NT_SUCCESS(Status) ) {
                    __leave;
                }

                Status = NtWriteFile( hFile, 0, 0, 0, &IoStatusBlock,
                                      pNewBitVector, dwVectorSize, 0);

                if ( !NT_SUCCESS(Status) ) {
                    DbgPrint( "COVERMON: LOST DATA for %s because failed "
                              "to write covdata file (0x%x)\n",
                              pNode->BinaryName, Status );
                    __leave;
                }
            }

            NtFlushBuffersFile( hFile, &IoStatusBlock );

        } else {

            //
            //  If test not found, write new vector then update header (grow
            //  header if necessary).  We write new vector first in case later
            //  fail to write updated header -- file will still be valid but
            //  without new vector.  If wrote header first then failed to write
            //  vector, file would left in invalid state.
            //

            dwlVectorOffset = ROUNDUP2_64( pNode->FileSize.QuadPart, COVFILE_VECTOR_BOUNDARY );
            dwActual = 0;

            CurrentPosition.CurrentByteOffset.QuadPart = dwlVectorOffset;

            Status = NtSetInformationFile( hFile, &IoStatusBlock,
                &CurrentPosition, sizeof(CurrentPosition),
                FilePositionInformation );

            if ( !NT_SUCCESS(Status) ) {
                __leave;
            }

            Status = NtWriteFile( hFile, 0, 0, 0, &IoStatusBlock, pNewBitVector,
                                  dwVectorSize, 0);

            if ( NT_SUCCESS(Status) ) {
                dwActual = IoStatusBlock.Information;
            } else {
                DbgPrint( "COVERMON: LOST DATA for %s because failed to "
                          "write covdata file (0x%x)\n",
                          pNode->BinaryName, Status );
                __leave;
            }

            NtFlushBuffersFile( hFile, &IoStatusBlock );

            dwlFileSize = dwlVectorOffset + dwActual;

            //
            //  Now update the header.
            //

            dwNameLength  = strlen( pszTestName ) + 1;
            dwEntryLength = ROUNDUP2( sizeof( COVFILE_DIRECTORY ) + dwNameLength, 4 );

            if ((((PCHAR)pDirEntry - (PCHAR)pHeader ) + dwEntryLength + 4 ) > pHeader->dwHeaderLength ) {

                //
                //  Not enough room in existing header, need to grow it by multiple
                //  of ROUNDUP2( dwVectorSize, COVFILE_VECTOR_BOUNDARY ).
                //

                dwGrowSize  = ROUNDUPN( dwEntryLength, ROUNDUP2( dwVectorSize, COVFILE_VECTOR_BOUNDARY ));
                dwlFileSize = ROUNDUP2_64( dwlFileSize, COVFILE_VECTOR_BOUNDARY );
                dwlOffset   = ROUNDUP2_64( pHeader->dwHeaderLength, COVFILE_VECTOR_BOUNDARY );

                dwlExtent   = dwlOffset + dwGrowSize;
                dwlMoveBias = dwlFileSize - dwlOffset;
                dwActual    = 0;

                if (( pHeader->dwVersion == COVFILE_VERSION_201 ) &&
                    ( dwlFileSize + dwGrowSize > 0xF0000000 )) {

                    DbgPrint(
                        "COVERMON: LOST DATA for %s because covdata file is too large.\n"
                        "    Use covdata.exe tool to upgrade covdata file to new version.\n",
                        pNode->BinaryName
                        );

                    __leave;
                }

                pMoveBuffer = CoverageAllocatePool( dwGrowSize );

                if ( pMoveBuffer == NULL ) {

                    DbgPrint(
                        "COVERMON: LOST DATA for %s because failed to allocate buffer.\n",
                        pNode->BinaryName
                        );

                    __leave;
                }

                CurrentPosition.CurrentByteOffset.QuadPart = dwlOffset;

                Status = NtSetInformationFile( hFile, &IoStatusBlock,
                    &CurrentPosition, sizeof(CurrentPosition),
                    FilePositionInformation );

                if ( !NT_SUCCESS(Status) ) {
                    __leave;
                }

                Status = NtReadFile( hFile, 0, 0, 0, &IoStatusBlock, pMoveBuffer, dwGrowSize, 0);

                if ( NT_SUCCESS(Status) ) {
                    dwActual = IoStatusBlock.Information;
                } else {
                    DbgPrint(
                        "COVERMON: LOST DATA for %s because failed to read covdata file (0x%x)\n",
                        pNode->BinaryName, Status
                        );
                    __leave;
                }

                CurrentPosition.CurrentByteOffset.QuadPart = dwlFileSize;

                Status = NtSetInformationFile( hFile, &IoStatusBlock,
                    &CurrentPosition, sizeof(CurrentPosition),
                    FilePositionInformation );

                if ( !NT_SUCCESS(Status) ) {
                    __leave;
                }

                Status = NtWriteFile( hFile, 0, 0, 0, &IoStatusBlock, pMoveBuffer, dwActual, 0);

                if ( NT_SUCCESS(Status) ) {
                    dwActual = IoStatusBlock.Information;
                } else {
                    DbgPrint(
                        "COVERMON: LOST DATA for %s because failed to write covdata file (0x%x)\n",
                        pNode->BinaryName, Status
                        );
                    __leave;
                }

                NtFlushBuffersFile( hFile, &IoStatusBlock );

                dwlFileSize = dwlFileSize + dwActual;

                pNewHeader = CoverageReAllocPool(
                    pHeader->dwHeaderLength + dwGrowSize, pHeader );

                if ( pNewHeader == NULL ) {

                    DbgPrint(
                        "COVERMON: LOST DATA for %s because failed to allocate memory (%d bytes).\n",
                        pNode->BinaryName,
                        pHeader->dwHeaderLength + dwGrowSize
                        );

                    Status = STATUS_NO_MEMORY;
                    __leave;
                }

                pHeader = (PCOVFILE_HEADER)pNewHeader;
                pNode->pCachedCovFileHeader = pHeader;
                pHeader->dwHeaderLength += dwGrowSize;
                pDirEntry = (PCOVFILE_DIRECTORY)((PCHAR)pHeader + dwOffsetOfFirstDir);

                while ( pDirEntry->dwLengthOfEntry != 0 ) {

                    if ( pHeader->dwVersion == COVFILE_VERSION_201 ) {

                        pDirEntry201 = (PCOVFILE_DIRECTORY_201) pDirEntry;

                        if (( pDirEntry201->dwOffsetOfData >= dwlOffset ) &&
                            ( pDirEntry201->dwOffsetOfData <  dwlExtent )) {

                            ASSERT((( pDirEntry201->dwOffsetOfData + dwlMoveBias ) >> 32 ) == 0 );

                            pDirEntry201->dwOffsetOfData += (DWORD) dwlMoveBias;

                        }

                    } else {

                        ASSERT( pHeader->dwVersion == COVFILE_VERSION );

                        if (( pDirEntry->dwlOffsetOfData >= dwlOffset ) &&
                            ( pDirEntry->dwlOffsetOfData <  dwlExtent )) {

                            pDirEntry->dwlOffsetOfData += dwlMoveBias;

                        }
                    }

                    pDirEntry = (PCOVFILE_DIRECTORY)((PCHAR)pDirEntry + pDirEntry->dwLengthOfEntry );

                }
            }

            pDirEntry->dwLengthOfEntry = dwEntryLength;
            pDirEntry->dwHashOfName    = dwNameHash;

            if ( pHeader->dwVersion == COVFILE_VERSION_201 ) {

                pDirEntry201 = (PCOVFILE_DIRECTORY_201) pDirEntry;

                ASSERT(( dwlVectorOffset >> 32 ) == 0 );

                pDirEntry201->dwOffsetOfData = (DWORD)dwlVectorOffset;
                strcpy( pDirEntry201->szName, pszTestName );

            } else {

                ASSERT( pHeader->dwVersion == COVFILE_VERSION );

                pDirEntry->dwlOffsetOfData = dwlVectorOffset;
                strcpy( pDirEntry->szName, pszTestName );

            }

            CurrentPosition.CurrentByteOffset.QuadPart = 0;

            Status = NtSetInformationFile( hFile, &IoStatusBlock,
                &CurrentPosition, sizeof(CurrentPosition),
                FilePositionInformation );

            if ( !NT_SUCCESS(Status) ) {
                __leave;
            }

            Status = NtWriteFile( hFile, 0, 0, 0, &IoStatusBlock, pHeader,
                                  pHeader->dwHeaderLength, 0);

            if ( NT_SUCCESS(Status) ) {
                dwActual = IoStatusBlock.Information;
            } else {
                DbgPrint(
                    "COVERMON: LOST DATA for %s because failed to write covdata file (0x%x)\n",
                    pNode->BinaryName, Status
                    );
                __leave;
            }

            NtFlushBuffersFile( hFile, &IoStatusBlock );

            pNode->FileSize.QuadPart = dwlFileSize;   // only if everything successful
        }
    } __except( EXCEPTION_EXECUTE_HANDLER ) {

        DbgPrint( "COVERMON: LOST DATA for %s because an exception occurred\n"
                  "    while updating the file.  This probably indicates a \n"
                  "corrupt data file.\n", pNode->BinaryName );

        Status = GetExceptionCode();
    }

    if ( pMoveBuffer ) {
        ExFreePool( pMoveBuffer );
    }

    if ( pOldBitVector ) {
        ExFreePool( pOldBitVector );
    }

    if ( pNewHeader ) {
        ExFreePool( pNewBitVector );
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\coverage\covfile\covfile.c ===
#pragma warning( disable: 4200 )    // zero sized array in structure
#pragma warning( disable: 4201 )    // nameless struct/union
#pragma warning( disable: 4213 )    // cast on l-value
#pragma warning( disable: 4214 )    // bitfields other than int
#pragma warning( disable: 4514 )    // unreferenced inline function

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN 1
#endif

#include <xtl.h>
#pragma warning( disable: 4200 4201 4213 4214 4514 )
#include "covfile.h"

unsigned int __cdecl _rotl( unsigned int value, int shift );

#pragma intrinsic( strlen, _rotl )

#pragma optimize( "at", on )    // optimize for speed and assume no aliasing

VOID
PackByteVectorToBitVector(
    IN  DWORD ByteCount,
    IN  PBYTE ByteVector,
    OUT PBYTE BitVector
    )
    {
    DWORD EightByteCount;
    DWORD BitsRemaining;
    DWORD Source1;
    DWORD Source2;
    DWORD PadBits;
    DWORD PackedByte;

    EightByteCount = ByteCount / 8;

    while ( EightByteCount-- ) {

        Source1 = ( *(DWORD*)( ByteVector     )) & 0x01010101;
        Source2 = ( *(DWORD*)( ByteVector + 4 )) & 0x01010101;

        ByteVector += 8;

        *BitVector++ = (BYTE)(( Source1 <<  7 ) | ( Source2 <<  3 ) |
                              ( Source1 >>  2 ) | ( Source2 >>  6 ) |
                              ( Source1 >> 11 ) | ( Source2 >> 24 ) |
                              ( Source1 >> 20 ) | ( Source2 >> 15 ));
        }

    BitsRemaining = ByteCount & 7;

    if ( BitsRemaining ) {

        PadBits    = 8 - BitsRemaining;
        PackedByte = 0;

        while ( BitsRemaining-- ) {
            PackedByte = ( PackedByte << 1 ) | ( *ByteVector++ & 1 );
            }

        *BitVector = (BYTE)( PackedByte << PadBits );

        }
    }

VOID
UnpackBitVectorToByteVector(
    IN  DWORD BitCount,
    IN  PBYTE BitVector,
    OUT PBYTE ByteVector
    )
    {
    DWORD EightBitCount;
    DWORD BitsRemaining;
    DWORD Target1;
    DWORD Target2;
    DWORD PackedByte;

    EightBitCount = BitCount / 8;

    while ( EightBitCount-- ) {

        PackedByte = *BitVector++;

        Target1 = (( PackedByte >>  7 ) |
                   ( PackedByte <<  2 ) |
                   ( PackedByte << 11 ) |
                   ( PackedByte << 20 ));

        Target2 = (( PackedByte >>  3 ) |
                   ( PackedByte <<  6 ) |
                   ( PackedByte << 15 ) |
                   ( PackedByte << 24 ));

        *(DWORD*)( ByteVector )     = Target1 & 0x01010101;
        *(DWORD*)( ByteVector + 4 ) = Target2 & 0x01010101;

        ByteVector += 8;

        }

    BitsRemaining = BitCount & 7;

    if ( BitsRemaining ) {

        PackedByte = *BitVector;

        while ( BitsRemaining-- ) {
            *ByteVector++ = (BYTE)(( PackedByte & 0x80 ) >> 7 );
            PackedByte <<= 1;
            }
        }
    }

VOID
OrBufferWithBuffer(
    IN PVOID TargetBuffer,
    IN PVOID SourceBuffer,
    IN ULONG Size
    )
    {
    ULONG CountLongs = Size / 4;
    ULONG CountBytes = Size & 3;

    while ( CountLongs-- ) {
        *((UNALIGNED ULONG*) TargetBuffer )++ |= *((UNALIGNED ULONG*) SourceBuffer )++;
        }

    while ( CountBytes-- ) {
        *((UNALIGNED UCHAR*) TargetBuffer )++ |= *((UNALIGNED UCHAR*) SourceBuffer )++;
        }
    }

VOID
XorBufferWithBuffer(
    IN PVOID TargetBuffer,
    IN PVOID SourceBuffer,
    IN ULONG Size
    )
    {
    ULONG CountLongs = Size / 4;
    ULONG CountBytes = Size & 3;

    while ( CountLongs-- ) {
        *((UNALIGNED ULONG*) TargetBuffer )++ ^= *((UNALIGNED ULONG*) SourceBuffer )++;
        }

    while ( CountBytes-- ) {
        *((UNALIGNED UCHAR*) TargetBuffer )++ ^= *((UNALIGNED UCHAR*) SourceBuffer )++;
        }
    }

VOID
BufferAndNotBuffer(
    IN PVOID TargetBuffer,
    IN PVOID SourceBuffer,
    IN ULONG Size
    )
    {
    ULONG CountLongs = Size / 4;
    ULONG CountBytes = Size & 3;

    while ( CountLongs-- ) {
        *((UNALIGNED ULONG*) TargetBuffer )++ &= ~( *((UNALIGNED ULONG*) SourceBuffer )++ );
        }

    while ( CountBytes-- ) {
        *((UNALIGNED UCHAR*) TargetBuffer )++ &= ~( *((UNALIGNED UCHAR*) SourceBuffer )++ );
        }
    }

ULONG
__inline
CountBitsSetInValue(
    IN ULONG Value
    )
    {
    ULONG Count = 0;

    while ( Value != 0 ) {
        Count += ( Value & 1 );
        Value >>= 1;
        }

    return Count;
    }

ULONG
CountBitsSetInBuffer(
    IN PVOID Buffer,
    IN ULONG Size
    )
    {
    ULONG CountLongs = Size / 4;
    ULONG CountBytes = Size & 3;
    ULONG CountBits  = 0;

    while ( CountLongs-- ) {
        CountBits += CountBitsSetInValue( *((UNALIGNED ULONG*) Buffer )++ );
        }

    while ( CountBytes-- ) {
        CountBits += CountBitsSetInValue( *((UNALIGNED UCHAR*) Buffer )++ );
        }

    return CountBits;
    }

BOOL
DoesBufferContainAllZeros(
    IN PVOID Buffer,
    IN DWORD Size
    )
    {
    ULONG CountLongs = Size / 4;
    ULONG CountBytes = Size & 3;

    while ( CountLongs-- ) {
        if ( *((UNALIGNED ULONG*) Buffer )++ ) {
            return FALSE;
            }
        }

    while ( CountBytes-- ) {
        if ( *((UNALIGNED UCHAR*) Buffer )++ ) {
            return FALSE;
            }
        }

    return TRUE;
    }

BOOL
DoesBufferContainOnlyHex01s(
    IN PVOID Buffer,
    IN DWORD Size
    )
    {
    ULONG CountLongs = Size / 4;
    ULONG CountBytes = Size & 3;

    while ( CountLongs-- ) {
        if (( *((UNALIGNED ULONG*) Buffer )++ ) & 0xFEFEFEFE ) {
            return FALSE;
            }
        }

    while ( CountBytes-- ) {
        if (( *((UNALIGNED UCHAR*) Buffer )++ ) & 0xFE ) {
            return FALSE;
            }
        }

    return TRUE;
    }

ULONG
HashName(                   // case insensitive
    IN LPCSTR Name
    )
    {
    ULONG Length = strlen( Name );
    ULONG Hash   = ~ Length;

    while ( Length-- )
        Hash = _rotl( Hash, 3 ) ^ ( *Name++ & 0xDF );     // mask case bit

    return Hash;
    }

#pragma optimize( "", on )      // restore to default optimizations
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\coverage\dxt\coverage.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    coverage.cpp

Abstract:

    This module implements routines to collect coverage data from Xbox.
    It is loaded by XBDM on Xbox machine (devkit only).

--*/

#include "coveragep.h"

PDMN_SESSION DmNotifySession;


/*
Routine Description:

    Simple local version of atoi until the crt is no longer broken:

        libcntpr.lib(atox.obj) : error LNK2019: unresolved 
        external symbol __ismbcspace referenced in function _atol

Arguments:

    see atoi()

Return Value:

    see atoi()

*/
int myatoi(char *src)
    {
    if(!src) return 0;
    int value = 0;

    while(*src)
        {
        if(*src == ' ' || *src == '\t' || *src == '\r' || *src == '\n') break;
        value *= 10;
        value += *src - '0';
        ++src;
        }

    return value;
    }



HRESULT
CoverageSaveData(
    IN  PCSTR  szCmd,
    OUT PSTR   szResp,
    IN  SIZE_T cchResp
    )
/*++

--*/
{
    KdPrint(( "COVERAGE: save data\n" ));
    return XBDM_BUFFER_TOO_SMALL;
}

HRESULT
CoverageResetData(
    IN  PCSTR  szCmd,
    OUT PSTR   szResp,
    IN  SIZE_T cchResp
    )
/*++

Routine Description:

    Resets (discards) any existing coverage information that has not been
    polled and saved for one or all running coverage binaries.  This can
    be useful to "zero" any coverage information prior to running a
    specific test.

Arguments:

    szCommand - The string of the reset command.  The format for this
        command is in the following form

        "BBCOVER!Cmd=CmdId Only=<BinaryName>"

    szResponse - Buffer for response results

    cchResponse - Size of response buffer in character

Return Value:

    HRESULT of the operation

--*/
{
    NTSTATUS Status;
    PCSTR BinaryName;
    HRESULT hr;

    BinaryName = strstr( szCmd, "Only=" );
    if ( BinaryName ) {
        BinaryName += sizeof("Only=") - 1;
    }

    Status = CoverageFlushLogging( BinaryName );

    if ( NT_SUCCESS(Status) ) {
        hr = XBDM_NOERR;
    } else {
        SetResponseError( szResp, cchResp, ERROR_MOD_NOT_FOUND );
        hr = XBDM_NOMODULE;
    }

    return hr;
}

HRESULT
CoverageSetPeriodic(
    IN  PCSTR  szCmd,
    OUT PSTR   szResp,
    IN  SIZE_T cchResp
    )
/*++

Routine Description:

    Automatically polls and saves all current coverage information
    every <Frequency> seconds.  This option should rarely be used,
    typically only when anticipating a system crash before "covercmd
    /Save" can be issued.  Note that an application crash will not
    cause any coverage information to be lost.  The /Save and /Reset
    options cannot be used while periodic logging is active.

Arguments:

    szCommand - The string of the periodic command.  The format for this
        command is in the following form

        "BBCOVER!Cmd=CmdId Frequency=<freq>"

    szResponse - Buffer for response results

    cchResponse - Size of response buffer in character

Return Value:

    HRESULT of the operation

--*/
{
    KdPrint(( "COVERAGE: set periodic\n" ));
    return XBDM_BUFFER_TOO_SMALL;
}

HRESULT
CoverageListBinary(
    IN  PCSTR  szCmd,
    OUT PSTR   szResp,
    IN  SIZE_T cchResp
    )
/*++

Routine Description:

    Display the list of coverage binaries that are running or have
    run.  This can be useful to determine which binary names can be
    used with "/Only" for "/Save" or "/Reset".

Arguments:

    szCommand - The string of the list command.  The format for this
        command is in the following form

        "BBCOVER!Cmd=CmdId"

    szResponse - Buffer for response results

    cchResponse - Size of response buffer in character

Return Value:

    HRESULT of the operation

--*/
{
    PSTR CurrentBuffer = szResp;
    PREGISTERED_BINARY Node;
    SIZE_T BufferSize = 0;
    SIZE_T NodeCount = 0;
    HRESULT hr;

    //
    // Calculate size of return buffer for list of registered modules
    // The returned buffer is array of string pointer
    //

    AcquireRegistrationLock();

    Node = GetRegisteredBinaryList();
    while ( Node != GetRegisteredBinaryListHead() ) {

        //
        // The length of binary name itself plus the new line character
        //

        BufferSize += strlen(Node->BinaryName) + sizeof(' ');
        NodeCount++;
    }

    //
    // Including the last null terminator
    //

    if ( NodeCount ) {
        BufferSize += sizeof('\0');
    } else {
        BufferSize = sizeof("None");
    }

    if ( cchResp < BufferSize ) {

        SetResponseError( szResp, cchResp, ERROR_INSUFFICIENT_BUFFER );
        hr = XBDM_BUFFER_TOO_SMALL;

    } else {

        //
        // Loop over again and this time copy data to the output buffer
        //

        if ( !NodeCount ) {
            strcpy( CurrentBuffer, "None" );
        } else {

            Node = GetRegisteredBinaryList();
            while ( Node != GetRegisteredBinaryListHead() ) {
                strcpy( CurrentBuffer, Node->BinaryName );
                CurrentBuffer += strlen(CurrentBuffer);
                *CurrentBuffer++ = ' ';
            }

            *CurrentBuffer = '\0';
        }

        hr = XBDM_NOERR;
    }

    ReleaseRegistrationLock();

    return hr;
}

HRESULT
WINAPI
CoverageCmdProc(
    PCSTR  szCmd,
    PSTR   szResp,
    SIZE_T cchResp,
    PDM_CMDCONT /* pDmCc */
    )
/*++

Routine Description:

    This is a callback routine that process coverage commands sent from
    remote machine.  The command format is

    "BBCOVER!Cmd=id OptionalCmd=string ..."

Arguments:

    szCommand - The string of command mentioned above

    szResponse - Buffer for response results

    cchResponse - Size of response buffer in character

    pDmCc - Unused

Return Value:

    HRESULT

--*/
{
    PCSTR CmdIdPtr;
    ULONG CmdId;
    HRESULT hr = E_INVALIDARG;

    ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );

    //
    // Looking for the command id in the command string and process it
    //

    CmdIdPtr = strstr( szCmd, COVERAGE_COMMAND_HEADER );

    if ( CmdIdPtr ) {

        CmdIdPtr += sizeof(COVERAGE_COMMAND_HEADER) - 1;
        CmdId = myatoi( (char*)CmdIdPtr );

        switch ( CmdId ) {

        case CoverageCmdSave:
            hr = CoverageSaveData( szCmd, szResp, cchResp );
            break;

        case CoverageCmdReset:
            hr = CoverageResetData( szCmd, szResp, cchResp );
            break;

        case CoverageCmdPeriodic:
            hr = CoverageSetPeriodic( szCmd, szResp, cchResp );
            break;

        case CoverageCmdList:
            hr = CoverageListBinary( szCmd, szResp, cchResp );
            break;

        default:
            KdPrint(( "COVERAGE: invalid command id (%u)", CmdId ));
        }

    } else {
        DbgPrint( "COVERAGE: invalid command '%s'\n", szCmd );
    }

    return hr;
}

DWORD
WINAPI
CoverageNotifyHandler(
    IN ULONG Notification,
    IN DWORD Parameter
    )
/*++

Routine Description:

    This is a notification routine called when module load/unload and
    execution event occur.  We monitor these events and save coverage
    information as needed.

Arguments:

    Notification - Type of notification.  This parameter can be
        DM_EXEC, DM_MODLOAD, DM_MODUNLOAD

    Parameter - Optional parameter based on type of notification

Return Value:

    Always zero

--*/
{
    PDMN_MODLOAD DmModLoad;

    ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );

    switch ( Notification ) {

    case DM_MODLOAD:
        DmModLoad = (PDMN_MODLOAD)Parameter;
        RegisterNoImportCoverageBinary( DmModLoad->BaseAddress );
        break;

    case DM_EXEC:
        if ( Parameter == DMN_EXEC_REBOOT ) {
            KdPrint(( "COVERAGE: system reboot, saving coverage data...\n\n" ));
            CoverageInternalCloseLogFileAllBinaries();
        }
        break;

    }

    return 0;
}

EXTERN_C
VOID
WINAPI
CoverageAbsEntry(
    VOID
    )
/*++

Routine Description:

    This is an absolute entry point of the module.  It registers XBDM
    external command processor and registers notification event to see
    module load and unload notification.

Arguments:

    None

Return Value:

    None

--*/
{
    HRESULT hr;
    PDM_WALK_MODULES DmWalkModules;
    DMN_MODLOAD DmModLoad;

    //
    // Register XBDM external command processor for code coverage command and
    // register notification handler so that when the module is loaded, unload,
    // or system reboot, its coverage data will be saved.
    //

    hr = DmRegisterCommandProcessor( DM_COVERAGE_COMMAND, CoverageCmdProc );

    if ( SUCCEEDED(hr) ) {
        hr = DmOpenNotificationSession( DM_PERSISTENT, &DmNotifySession );
        if ( FAILED(hr) ) {
            KdPrint(( "COVERAGE: DmOpenNotificationSession failed\n" ));
        }
    }

    if ( SUCCEEDED(hr) ) {
        hr = DmNotify( DmNotifySession, DM_MODLOAD, CoverageNotifyHandler );
        if ( FAILED(hr) ) {
            KdPrint(( "COVERAGE: DmNotify(DM_MODLOAD) failed\n" ));
        }
    }

    if ( SUCCEEDED(hr) ) {
        hr = DmNotify( DmNotifySession, DM_MODUNLOAD, CoverageNotifyHandler );
        if ( FAILED(hr) ) {
            KdPrint(( "COVERAGE: DmNotify(DM_MODUNLOAD) failed\n" ));
        }
    }

    if ( SUCCEEDED(hr) ) {
        hr = DmNotify( DmNotifySession, DM_EXEC, CoverageNotifyHandler );
        if ( FAILED(hr) ) {
            KdPrint(( "COVERAGE: DmNotify(DM_EXEC) failed\n" ));
        }
    }

    if ( FAILED(hr) ) {
        DbgPrint( "COVERAGE: unable to load extension (hr=0x%x)\n", hr );
        return;
    }

    if ( !CoverageInitPoolBuffer() ) {
        DbgPrint( "COVERAGE: unable to allocate poll buffer\n" );
        return;
    }

    DbgPrint( "COVERAGE: coverage engine loaded\n" );

    //
    // Try to register all loaded modules.  Module will be registered if it
    // has .cover section in its PE image
    //

    DmWalkModules = NULL;

    while ( SUCCEEDED(DmWalkLoadedModules(&DmWalkModules, &DmModLoad)) ) {
        RegisterNoImportCoverageBinary( DmModLoad.BaseAddress );
    }

    if ( DmWalkModules ) {
        DmCloseLoadedModules( DmWalkModules );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\coverage\xbcovcmd\cmdutils.cpp ===
/*++

Copyright (c) Microsoft Coroporation. All rights reserved.

Module Name:

    cmdutils.cpp

Abstract:

    This module implements various utility routines to send commands to
    coverage debug extension (coverage.dxt).  It can be used for collecting
    code coverage data.

--*/

#include "xbcovcmdp.h"

DWORD
CoverageFormatCommand(
    IN  ULONG  Command,
    OUT PSTR   Buffer,
    IN  SIZE_T BufferSize,
    IN  PCSTR   Format OPTIONAL,
    IN  va_list argptr OPTIONAL
    )
/*++

Routine Description:

    This routine formats command being sent to Xbox into text string format.
    The optional command parameters also can be specified.

Arguments:

    Command - Command ID, e.g. CoverageCmdSave

    Buffer - Output buffer to receive formatted command

    BufferSize - Size in bytes of output buffer

    Format - Format string, see printf for more information

    argptr - Optional parameter (use with Format)

Return Value:

    NOERROR or HRESULT of ERROR_INSUFFICIENT_BUFFER

--*/
{
    int BytesStored;
    SIZE_T CmdLen;
    CONST SIZE_T MinBufferSize = sizeof(DM_COVERAGE_COMMAND) - 1 +
        sizeof(COVERAGE_COMMAND_HEADER) - 1 + sizeof('\0');

    ASSERT( Command < CoverageCmdMax );

    //
    // Verify that buffer size is bug enough to hold BBCOVER command +
    // command id + NULL terminator
    //

    if ( BufferSize < MinBufferSize ) {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // Copy BBCOVER command, command id header and append the command id
    //

    strcpy( Buffer, DM_COVERAGE_COMMAND );
    strcat( Buffer, COVERAGE_COMMAND_HEADER );
    CmdLen = MinBufferSize - sizeof('\0');
    CmdLen += strlen( _ultoa(Command, &Buffer[CmdLen], 10) );

    //
    // Format optional parameter if format string is not null
    //

    if ( Format ) {

        //
        // Append space to the command before trying to append other
        // optional parameters
        //

        Buffer[ CmdLen++ ] = ' ';

        BytesStored = _vsnprintf( &Buffer[CmdLen], BufferSize-CmdLen, Format,
                                 argptr );

        //
        // Check to see if we overflow the buffer
        //

        if ( BytesStored < 0 ) {
            return ERROR_INSUFFICIENT_BUFFER;
        }
    }

    return ERROR_SUCCESS;
}

DWORD
CoverageSendCommand(
    IN  ULONG  Command,
    OUT PVOID  Buffer OPTIONAL,
    IN OUT SIZE_T *BufferSize OPTIONAL,
    IN  PCSTR Format OPTIONAL,
    ...
    )
/*++

Routine Description:

    This routine formats coverage command and sends to Xbox.  The response
    also copied to buffer if specified.

Arguments:

    Command - Coverage command ID, e.g. CoverageCmdSave

    Buffer - Optional buffer to receive response

    BufferSize - Size in bytes of response buffer

    Format - String format of optional parameters

Return Value:

    Return value from Xbox

--*/
{
    DWORD Error;
    CHAR CmdBuffer[512];
    va_list argptr;
    HRESULT hr;
    SIZE_T BufferLen;

    va_start( argptr, Format );

    Error = CoverageFormatCommand( Command, CmdBuffer, sizeof(CmdBuffer),
                                   Format, argptr );

    va_end( argptr );

    if ( Error == ERROR_SUCCESS ) {

        //
        // If buffer size is less than 8 digit hex + sizeof('\0') + internal
        // area used by xbdm (DM_RESPONSE_MSG_OFFSET), we will redirect it
        //

        if ( Buffer == NULL || BufferSize == NULL ||
             (BufferSize &&
              *BufferSize < (8 + sizeof('\0') + DM_RESPONSE_MSG_OFFSET)) ) {
            Buffer = CmdBuffer;
            BufferLen = sizeof(CmdBuffer);
            BufferSize = &BufferLen;
        }

        hr = DmSendCommand( NULL, CmdBuffer, (PCHAR)Buffer, BufferSize );

        if ( FAILED(hr) ) {
            Error = GET_RESPONSE_ERR( (PSTR)Buffer );
        }
    }

    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\coverage\dxt\coveragep.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    coveragep.h

Abstract:

    This is a pre-compiled header for Xbox code coverage debugger extension.
    It also contains various data strutures and procedure prototypes.

--*/

#include <ntos.h>
#include <ntrtl.h>
#include <xtl.h>
#include <xbdm.h>
#include <stdio.h>
#include "coverage.h"
#include "bbreg.h"
#include "covfile.h"

#ifndef INLINE
#define INLINE __inline
#endif

#define ROUNDUPN( x, n )    ((((x) + ((n) - 1 )) / (n)) * (n))
#define ROUNDUP2( x, n )    ((((ULONG)(x)) + (((ULONG)(n)) - 1 )) & ~(((ULONG)(n)) - 1 ))
#define ROUNDUP2_64( x, n ) ((((DWORDLONG)(x)) + (((DWORDLONG)(n)) - 1 )) & ~(((DWORDLONG)(n)) - 1 ))

typedef struct _REGISTERED_BINARY REGISTERED_BINARY, *PREGISTERED_BINARY;

struct _REGISTERED_BINARY {
    PREGISTERED_BINARY pNext;                   // singly linked list
    PCHAR              BaseOfLoggingRegion;
    ULONG              SizeOfLoggingRegion;
    ULONG              CheckSumOfBinary;
    PVOID              CapturedLogging;
    DWORD              dwUniquifier;
    HANDLE             LogFileHandle;
    PCOVFILE_HEADER    pCachedCovFileHeader;
    LARGE_INTEGER      FileSize;
    MD5_HASH           md5;                     // pointer to GUID which goes after binary name
    CHAR               BinaryName[ 1 ];         // variable length
};

VOID
NTAPI
RegisterNoImportCoverageBinary(
    IN PVOID ImageBase
    );

VOID
INLINE
SetResponseError(
    OUT PSTR   szResp,
    IN  SIZE_T cchResp,
    IN  DWORD  LastError
    )
/*++

Routine Description:

    This routine stores error value at the beginning of the response buffer.
    It can be used only if HRESULT of the send operation indicates error.

Arguments:

    szResp - Response buffer to be sent

    cchResp - Size in character of response buffer

Return Value:

    None

--*/
{
    if ( _snprintf(szResp, cchResp, "%x", LastError) < 0 && cchResp ) {
        *szResp = '\0';
    }
}

PREGISTERED_BINARY
GetRegisteredBinaryList(
    VOID
    );

PREGISTERED_BINARY
GetRegisteredBinaryListHead(
    VOID
    );

VOID
AcquireRegistrationLock(
    VOID
    );

VOID
ReleaseRegistrationLock(
    VOID
    );

NTSTATUS
NTAPI
CoverageFlushLogging(
    IN PCSTR BinaryName OPTIONAL
    );

VOID
CoverageInternalCloseLogFileAllBinaries(
    VOID
    );

BOOL
CoverageInitPoolBuffer(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\coverage\xbcovcmd\xbcovcmdp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    xbcovcmdp.h

Abstract:

    This is a pre-compiled header module for xbcovcmd

--*/

#include <windows.h>
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <xboxdbg.h>
#include "coverage.h"

#if DBG
#include <assert.h>
#define ASSERT(exp) assert(exp)
#else
#define ASSERT(exp)
#endif

DWORD
CoverageSendCommand(
    IN  ULONG  Command,
    OUT PVOID  Buffer OPTIONAL,
    IN OUT SIZE_T *BufferSize OPTIONAL,
    IN PCSTR Format OPTIONAL,
    ...
    );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\coverage\md5\md5.c ===
/*
 ***********************************************************************
 ** md5.c                                                             **
 ** RSA Data Security, Inc. MD5 Message-Digest Algorithm              **
 ** Created: 2/17/90 RLR                                              **
 ** Revised: 1/91 SRD,AJ,BSK,JT Reference C Version                   **
 ***********************************************************************
 */

/*
 ***********************************************************************
 ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved.  **
 **                                                                   **
 ** License to copy and use this software is granted provided that    **
 ** it is identified as the "RSA Data Security, Inc. MD5 Message-     **
 ** Digest Algorithm" in all material mentioning or referencing this  **
 ** software or this function.                                        **
 **                                                                   **
 ** License is also granted to make and use derivative works          **
 ** provided that such works are identified as "derived from the RSA  **
 ** Data Security, Inc. MD5 Message-Digest Algorithm" in all          **
 ** material mentioning or referencing the derived work.              **
 **                                                                   **
 ** RSA Data Security, Inc. makes no representations concerning       **
 ** either the merchantability of this software or the suitability    **
 ** of this software for any particular purpose.  It is provided "as  **
 ** is" without express or implied warranty of any kind.              **
 **                                                                   **
 ** These notices must be retained in any copies of any part of this  **
 ** documentation and/or software.                                    **
 ***********************************************************************
 */

//  Portions copyright (c) 1992 Microsoft Corp.
//  All rights reserved

//
//  This copy of md5.c modified and adapted for my purposes, tommcg 6/28/96
//  Copyright (C) 1996-1999, Microsoft Corporation.
//


#include "md5.h"
#include <stdlib.h>
#include <string.h>

typedef const unsigned char * PCUCHAR;
typedef const unsigned long * PCULONG;


/* Constants for Transform routine. */
#define S11 7
#define S12 12
#define S13 17
#define S14 22
#define S21 5
#define S22 9
#define S23 14
#define S24 20
#define S31 4
#define S32 11
#define S33 16
#define S34 23
#define S41 6
#define S42 10
#define S43 15
#define S44 21


/* ROTATE_LEFT rotates x left n bits. */

#define ROTATE_LEFT(x, n) ((x << n) | (x >> (32 - n)))

//
//  Intel and PowerPC both have a hardware rotate instruction with intrinsic
//  (inline) function for them.  Rough measurements show a 25% speed increase
//  for Intel and 10% speed increase for PowerPC when using the instrinsic
//  rotate versus the above defined shift/shift/or implemenation.
//

#if defined(_M_IX86) || defined(_M_PPC)
    #undef  ROTATE_LEFT
    #define ROTATE_LEFT(x, n) _rotl(x, n)
#endif


/* F, G and H are basic MD5 functions */
#define F(x, y, z) ((x & y) | (~x & z))
#define G(x, y, z) ((x & z) | (y & ~z))
#define H(x, y, z) (x ^ y ^ z)
#define I(x, y, z) (y ^ (x | ~z))


/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4 */
/* Rotation is separate from addition to prevent recomputation */
#define FF(a, b, c, d, x, s, ac) \
   a += F(b, c, d) + x + ac; \
   a = ROTATE_LEFT(a, s); \
   a += b;

#define GG(a, b, c, d, x, s, ac) \
   a += G(b, c, d) + x + ac; \
   a = ROTATE_LEFT(a, s); \
   a += b;

#define HH(a, b, c, d, x, s, ac) \
   a += H(b, c, d) + x + ac; \
   a = ROTATE_LEFT(a, s); \
   a += b;

#define II(a, b, c, d, x, s, ac) \
   a += I(b, c, d) + x + ac; \
   a = ROTATE_LEFT(a, s); \
   a += b;


VOID
InitMD5(
    IN OUT PMD5_HASH HashValue
    )
    {
    HashValue->Word32[ 0 ] = 0x67452301;
    HashValue->Word32[ 1 ] = 0xefcdab89;
    HashValue->Word32[ 2 ] = 0x98badcfe;
    HashValue->Word32[ 3 ] = 0x10325476;
    }

VOID
UpdateMD5_64ByteChunk(
    IN OUT PMD5_HASH HashValue,         // existing hash value
    IN     PCVOID    DataChunk          // ULONG-aligned pointer to 64-byte message chunk
    )
    {
    PCULONG MessageWord32 = DataChunk;
    ULONG a = HashValue->Word32[ 0 ];
    ULONG b = HashValue->Word32[ 1 ];
    ULONG c = HashValue->Word32[ 2 ];
    ULONG d = HashValue->Word32[ 3 ];

    /* Round 1 */
    FF ( a, b, c, d, MessageWord32[  0 ], S11, 0xd76aa478 ) /* 1 */
    FF ( d, a, b, c, MessageWord32[  1 ], S12, 0xe8c7b756 ) /* 2 */
    FF ( c, d, a, b, MessageWord32[  2 ], S13, 0x242070db ) /* 3 */
    FF ( b, c, d, a, MessageWord32[  3 ], S14, 0xc1bdceee ) /* 4 */
    FF ( a, b, c, d, MessageWord32[  4 ], S11, 0xf57c0faf ) /* 5 */
    FF ( d, a, b, c, MessageWord32[  5 ], S12, 0x4787c62a ) /* 6 */
    FF ( c, d, a, b, MessageWord32[  6 ], S13, 0xa8304613 ) /* 7 */
    FF ( b, c, d, a, MessageWord32[  7 ], S14, 0xfd469501 ) /* 8 */
    FF ( a, b, c, d, MessageWord32[  8 ], S11, 0x698098d8 ) /* 9 */
    FF ( d, a, b, c, MessageWord32[  9 ], S12, 0x8b44f7af ) /* 10 */
    FF ( c, d, a, b, MessageWord32[ 10 ], S13, 0xffff5bb1 ) /* 11 */
    FF ( b, c, d, a, MessageWord32[ 11 ], S14, 0x895cd7be ) /* 12 */
    FF ( a, b, c, d, MessageWord32[ 12 ], S11, 0x6b901122 ) /* 13 */
    FF ( d, a, b, c, MessageWord32[ 13 ], S12, 0xfd987193 ) /* 14 */
    FF ( c, d, a, b, MessageWord32[ 14 ], S13, 0xa679438e ) /* 15 */
    FF ( b, c, d, a, MessageWord32[ 15 ], S14, 0x49b40821 ) /* 16 */

    /* Round 2 */
    GG ( a, b, c, d, MessageWord32[  1 ], S21, 0xf61e2562 ) /* 17 */
    GG ( d, a, b, c, MessageWord32[  6 ], S22, 0xc040b340 ) /* 18 */
    GG ( c, d, a, b, MessageWord32[ 11 ], S23, 0x265e5a51 ) /* 19 */
    GG ( b, c, d, a, MessageWord32[  0 ], S24, 0xe9b6c7aa ) /* 20 */
    GG ( a, b, c, d, MessageWord32[  5 ], S21, 0xd62f105d ) /* 21 */
    GG ( d, a, b, c, MessageWord32[ 10 ], S22, 0x02441453 ) /* 22 */
    GG ( c, d, a, b, MessageWord32[ 15 ], S23, 0xd8a1e681 ) /* 23 */
    GG ( b, c, d, a, MessageWord32[  4 ], S24, 0xe7d3fbc8 ) /* 24 */
    GG ( a, b, c, d, MessageWord32[  9 ], S21, 0x21e1cde6 ) /* 25 */
    GG ( d, a, b, c, MessageWord32[ 14 ], S22, 0xc33707d6 ) /* 26 */
    GG ( c, d, a, b, MessageWord32[  3 ], S23, 0xf4d50d87 ) /* 27 */
    GG ( b, c, d, a, MessageWord32[  8 ], S24, 0x455a14ed ) /* 28 */
    GG ( a, b, c, d, MessageWord32[ 13 ], S21, 0xa9e3e905 ) /* 29 */
    GG ( d, a, b, c, MessageWord32[  2 ], S22, 0xfcefa3f8 ) /* 30 */
    GG ( c, d, a, b, MessageWord32[  7 ], S23, 0x676f02d9 ) /* 31 */
    GG ( b, c, d, a, MessageWord32[ 12 ], S24, 0x8d2a4c8a ) /* 32 */

    /* Round 3 */
    HH ( a, b, c, d, MessageWord32[  5 ], S31, 0xfffa3942 ) /* 33 */
    HH ( d, a, b, c, MessageWord32[  8 ], S32, 0x8771f681 ) /* 34 */
    HH ( c, d, a, b, MessageWord32[ 11 ], S33, 0x6d9d6122 ) /* 35 */
    HH ( b, c, d, a, MessageWord32[ 14 ], S34, 0xfde5380c ) /* 36 */
    HH ( a, b, c, d, MessageWord32[  1 ], S31, 0xa4beea44 ) /* 37 */
    HH ( d, a, b, c, MessageWord32[  4 ], S32, 0x4bdecfa9 ) /* 38 */
    HH ( c, d, a, b, MessageWord32[  7 ], S33, 0xf6bb4b60 ) /* 39 */
    HH ( b, c, d, a, MessageWord32[ 10 ], S34, 0xbebfbc70 ) /* 40 */
    HH ( a, b, c, d, MessageWord32[ 13 ], S31, 0x289b7ec6 ) /* 41 */
    HH ( d, a, b, c, MessageWord32[  0 ], S32, 0xeaa127fa ) /* 42 */
    HH ( c, d, a, b, MessageWord32[  3 ], S33, 0xd4ef3085 ) /* 43 */
    HH ( b, c, d, a, MessageWord32[  6 ], S34, 0x04881d05 ) /* 44 */
    HH ( a, b, c, d, MessageWord32[  9 ], S31, 0xd9d4d039 ) /* 45 */
    HH ( d, a, b, c, MessageWord32[ 12 ], S32, 0xe6db99e5 ) /* 46 */
    HH ( c, d, a, b, MessageWord32[ 15 ], S33, 0x1fa27cf8 ) /* 47 */
    HH ( b, c, d, a, MessageWord32[  2 ], S34, 0xc4ac5665 ) /* 48 */

    /* Round 4 */
    II ( a, b, c, d, MessageWord32[  0 ], S41, 0xf4292244 ) /* 49 */
    II ( d, a, b, c, MessageWord32[  7 ], S42, 0x432aff97 ) /* 50 */
    II ( c, d, a, b, MessageWord32[ 14 ], S43, 0xab9423a7 ) /* 51 */
    II ( b, c, d, a, MessageWord32[  5 ], S44, 0xfc93a039 ) /* 52 */
    II ( a, b, c, d, MessageWord32[ 12 ], S41, 0x655b59c3 ) /* 53 */
    II ( d, a, b, c, MessageWord32[  3 ], S42, 0x8f0ccc92 ) /* 54 */
    II ( c, d, a, b, MessageWord32[ 10 ], S43, 0xffeff47d ) /* 55 */
    II ( b, c, d, a, MessageWord32[  1 ], S44, 0x85845dd1 ) /* 56 */
    II ( a, b, c, d, MessageWord32[  8 ], S41, 0x6fa87e4f ) /* 57 */
    II ( d, a, b, c, MessageWord32[ 15 ], S42, 0xfe2ce6e0 ) /* 58 */
    II ( c, d, a, b, MessageWord32[  6 ], S43, 0xa3014314 ) /* 59 */
    II ( b, c, d, a, MessageWord32[ 13 ], S44, 0x4e0811a1 ) /* 60 */
    II ( a, b, c, d, MessageWord32[  4 ], S41, 0xf7537e82 ) /* 61 */
    II ( d, a, b, c, MessageWord32[ 11 ], S42, 0xbd3af235 ) /* 62 */
    II ( c, d, a, b, MessageWord32[  2 ], S43, 0x2ad7d2bb ) /* 63 */
    II ( b, c, d, a, MessageWord32[  9 ], S44, 0xeb86d391 ) /* 64 */

    HashValue->Word32[ 0 ] += a;
    HashValue->Word32[ 1 ] += b;
    HashValue->Word32[ 2 ] += c;
    HashValue->Word32[ 3 ] += d;
    }


VOID
FinalizeMD5(
    IN OUT PMD5_HASH HashValue,
    IN     PCVOID    RemainingData,     // remaining data to hash
    IN     ULONG     RemainingBytes,    // 0 <= RemainingBytes < 64
    IN     ULONGLONG TotalBytesHashed   // total bytes hashed
    )
    {
    union {
        ULONGLONG Qword[  8 ];
        UCHAR     Byte [ 64 ];
        } LocalBuffer;

    //
    //  Always append a pad byte of 0x80 to the message.
    //
    //  If RemainingBytes is less than (but not equal to) 56 bytes, then
    //  the final bits hashed count will be stored in the last 8 bytes of
    //  this 64 byte hash chunk.
    //
    //  If RemainingBytes is exactly 56 bytes, the appended 0x80 pad byte
    //  will force an extra chunk.
    //
    //  If RemainingBytes is greater than or equal to 56 bytes, then the
    //  final bits hashed count will be stored in the last 8 bytes of the
    //  NEXT 64 byte chunk that is otherwise zeroed, so THIS chunk needs to
    //  be zero-padded beyond the first pad byte and then hashed, then zero
    //  the first 56 bytes of the LocalBuffer for the NEXT chunk hash.
    //

    RemainingBytes &= 63;           // prevent stupidity (no error return)

    //
    //  Zero init local buffer.
    //

    memset( &LocalBuffer, 0, 64 );

    //
    //  Append 0x80 pad byte to message.
    //

    LocalBuffer.Byte[ RemainingBytes ] = 0x80;

    if ( RemainingBytes > 0 ) {

        //
        //  Copy remaining data bytes (0 < RemainingBytes < 64) to LocalBuffer
        //  (remainder of LocalBuffer already zeroed except for pad byte).
        //

        memcpy( &LocalBuffer, RemainingData, RemainingBytes );

        if ( RemainingBytes >= 56 ) {

            UpdateMD5_64ByteChunk( HashValue, &LocalBuffer );

            memset( &LocalBuffer, 0, 56 );

            }
        }

    //
    //  Number of BITS hashed goes into last 8 bytes of last chunk.  This
    //  is a 64-bit value.  Note that if the number of BITS exceeds 2^64
    //  then this number is the low order 64 bits of the result.
    ///

    LocalBuffer.Qword[ 7 ] = ( TotalBytesHashed * 8 );      // number of BITS

    UpdateMD5_64ByteChunk( HashValue, &LocalBuffer );

    }


VOID
ComputeCompleteMD5(
    IN  PCVOID    DataBuffer,
    IN  ULONGLONG DataLength,
    OUT PMD5_HASH HashValue
    )
    {
    PCUCHAR   DataPointer = DataBuffer;
    ULONGLONG ChunkCount  = DataLength / 64;
    ULONG     OddBytes    = (ULONG)DataLength & 63;

    InitMD5( HashValue );

    while ( ChunkCount-- ) {
        UpdateMD5_64ByteChunk( HashValue, DataPointer );
        DataPointer += 64;
        }

    FinalizeMD5( HashValue, DataPointer, OddBytes, DataLength );
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\qalibrary.h ===
#if !defined(__QALIBRARY_H__)
#define __QALIBRARY_H__

//
// Master header file for the library.  Since the library can be used in both
// source only or DLL version mode this header encapsulates which is used based
// on macros that are defined when test is built.
//

#include "qalib.h"      // always included.  also includes thread support if
                        // needed.
#if !defined(QA_MULTI_FILE_TEST)
#include "qalib.cpp"    // contains guards for DLL use case (as do all the
                        // source files).
#endif 

//
// Include other components base on need.
//

// Command line manager class.
//
#if defined(QA_USE_CMD_LINE_MGR)
#include "qa_cmdlinemgr.h"
#if !defined(QA_MULTI_FILE_TEST)
#include "qa_cmdlinemgr.cpp"
#endif 
#endif 

// Stdio stream redirection class.
//
#if defined(QA_USE_REDIRECT_STD)
#include "qa_redirectstd.h"
#if !defined(QA_MULTI_FILE_TEST)
#include "qa_redirectstd.cpp"
#endif 
#endif 

// STL style algorithm functions for converting strings to upper and lower case.
//
#if defined(QA_USE_STRING_ALGO)
#include "qa_util.h"
#endif 

// Other utilities.
//
#include "qa_util2.h"

// simple vector class.
//
#if defined(QA_USE_VECTOR)
#include "qa_vect.h"
#endif 

// Random number generator class.
//
#if defined(QA_USE_RANDOM_NUMBER)
#include "qa_rand.h"
#endif 

// Performace timer class.
//
#if defined(QA_USE_PERF_TIMER)
#include "qa_perftimer.h"
#endif 

// String table.
//
#if defined(QA_USE_STRINGTABLE) && !defined(QA_MULTI_FILE_TEST)
#include "qa_str_table.cpp"
#endif 

// MapNetworkDrive()
//
#if defined(QA_USE_MAP_NETWORK_DRIVE)
#include "qa_mapdrive.h"
#if !defined(QA_MULTI_FILE_TEST)
#include "qa_mapdrive.cpp"
#endif 
#endif 

// Auto pointer class (CAutoPtr).
//
#if defined(QA_USE_AUTOPTR)
#include "qa_autoptr.h"
#endif 

#endif // __QALIBRARY_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\qalib.cpp ===
#if !defined(__QALIB_CPP__)
#define __QALIB_CPP__

#if !defined(QA_USE_QALIB_DLL)

#include "qa_base.cpp"
#if defined(QA_USE_THREADS)
#include "qa_thread.cpp"
#endif 

#endif 

#endif // __QALIB_CPP__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\qalib.h ===
#if !defined(__QALIB_H__)
#define __QALIB_H__

#include "qa_base.h"

#endif // __QALIB_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\coverage\xbcovcmd\xbcovcmd.cpp ===
/*++

Copyright (c) Microsoft Coroporation. All rights reserved.

Module Name:

    xbcovcmd.cpp

Abstract:

    This module implements routines to send commands to coverage debug
    extension (coverage.dxt).  It can be used for collecting code coverage
    data.

--*/

#include "xbcovcmdp.h"

VOID
TranslateDmResult(
    IN HRESULT hr
    )
/*++

Routine Description:

    This routine translates HRESULT returned from XboxDbg APIs into string
    and output to standard error

Auguments:

    hr - HRESULT returned from various XboxDbg APIs

Return Value:

    None

--*/
{
    CHAR Buffer[512];

    DmTranslateErrorA( hr, Buffer, sizeof(Buffer) );
    fprintf( stderr, Buffer );
}

VOID
VerifyDmResult(
    IN HRESULT hr,
    IN BOOL fTerminate = FALSE
    )
/*++

Routine Description:

    This routine translates HRESULT and output to standard error output if
    the result indicates failure code.  It also terminates the process if
    the parameter fTerminate is non-zero

Arguments:

    hr - HRESULT returned by various XboxDbg APIs

    fTerminate - Set to TRUE to terminate the process if the specified HRESULT
        indicates failure code

Return Value:

    None or terminate the process if specified hr is a failure code

--*/
{
    if ( FAILED(hr) ) {
        TranslateDmResult( hr );
        if ( fTerminate ) {
            exit( 1 );
        }
    }
}

VOID
VerifyWin32Error(
    IN DWORD ErrorCode,
    IN BOOL fTerminate = FALSE
    )
/*++

Routine Description:

    This routine translates Win32 error code and output to standard error
    output if the result indicates failure code.  It also terminates the
    process if the parameter fTerminate is non-zero

Arguments:

    ErrorCode - Win32 error code

    fTerminate - Set to TRUE to terminate the process if the specified HRESULT
        indicates failure code

Return Value:

    None or terminate the process if specified hr is a failure code

--*/
{
    PSTR lpMsgBuf;

    if ( ErrorCode == ERROR_SUCCESS ) {
        return;
    }

    FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | \
        FORMAT_MESSAGE_IGNORE_INSERTS, NULL, ErrorCode,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpMsgBuf, 0,
        NULL );

    fprintf( stderr, lpMsgBuf );

    LocalFree( lpMsgBuf );

    if ( fTerminate ) {
        exit( 1 );
    }
}

VOID
DisplayHelpMessage(
    VOID
    )
/*++

Routine Description:

    This routine displays help message of available parameters and terminate
    the process

Arguments:

    None

Return Value:

    None

--*/
{
    fputs( "Usage:  XBCOVCMD </Save, /Reset, /Periodic or /List] [/Machine:XboxName]\n"
           "\n"
           "\t  /Save  [/Only <BinaryName>]  [/As \"<TestName>\"]\n\n"
           "\t  Polls and saves current coverage information to the database file\n"
           "\t  %coverage%\\<BinaryName>\\<BinaryName>.covdata for one or all\n"
           "\t  running coverage binaries and optionally tags the polled coverage\n"
           "\t  information with a given test name for subsequent reporting.  The\n"
           "\t  current coverage information is automatically reset when polled.\n\n"
           "\t  It is not necessary to poll and save coverage information before\n"
           "\t  a binary is unloaded (process termination, etc).  All coverage\n"
           "\t  information is retained until covercmd \"/Save\" or \"/Reset\" is\n"
           "\t  executed.  Any coverage information that has not been saved when\n"
           "\t  system shutdown occurs is automatically saved during shutdown.\n"
           "\n"
           "\t/Reset [/Only <BinaryName>]\n"
           "\n"
           "\t   Resets (discards) any existing coverage information that has not\n"
           "\t   been polled and saved for one or all running coverage binaries.\n"
           "\t   This can be useful to \"zero\" any coverage information prior to\n"
           "\t   running a specific test.\n"
           "\n"
           "\t/Periodic <Frequency>\n"
           "\n"
           "\t   Automatically polls and saves all current coverage information\n"
           "\t   every <Frequency> seconds.  This option should rarely be used,\n"
           "\t   typically only when anticipating a system crash before \"xbcovcmd\n"
           "\t   /Save\" can be issued.  Note that an application crash will not\n"
           "\t   cause any coverage information to be lost.  The /Save and /Reset\n"
           "\t   options cannot be used while periodic logging is active.\n"
           "\n"
           "\t/Periodic /Stop\n"
           "\n"
           "\t   Stops periodic logging.\n"
           "\n"
           "\t/List\n"
           "\n"
           "\t   Display the list of coverage binaries that are running or have\n"
           "\t   run.  This can be useful to determine which binary names can be\n"
           "\n"
           "\t/Machine:XboxName\n"
           "\n"
           "\t   Specify the machine name of the Xbox\n",
           stderr );
    exit( 1 );
}

VOID
CoverageSetXboxName(
    IN PCSTR XboxName
    )
/*++

Routine Description:

    This routine set active Xbox name for future uses.  The configuration will
    be persistently saved and will affect most of XDK tools

Arguments:

    XboxName - Name or IP address of Xbox

Return Value:

    None

--*/
{
    VerifyDmResult( DmUseSharedConnection(TRUE), TRUE );
    VerifyDmResult( DmSetXboxName(XboxName), TRUE );
    DmUseSharedConnection( FALSE );
}

VOID
CoverageListBinary(
    VOID
    )
/*++

Routine Description:

    This routine sends command to coverage debug extension to get the list
    of binaries on Xbox machine.

Arguments:

    None

Return Value:

    None

--*/
{
    DWORD Error;
    PCHAR Buffer = NULL;
    SIZE_T BufferSize = 65536;

    VerifyDmResult( DmUseSharedConnection(TRUE), TRUE );

    //
    // Continue to send the command as long as we receive the error
    // indicating that the output buffer is not large enough
    //

    do {

        Buffer = (PCHAR)realloc( Buffer, BufferSize );
        if ( !Buffer ) {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        Error = CoverageSendCommand( CoverageCmdList, Buffer, &BufferSize, 0 );
        if ( Error == ERROR_INSUFFICIENT_BUFFER ) {
            BufferSize += 4096;
        }

    } while ( Error == ERROR_INSUFFICIENT_BUFFER );

    if ( Error == ERROR_SUCCESS ) {
        fprintf( stdout, "%s\n", GET_RESPONSE(Buffer) );
    } else {
        VerifyWin32Error( Error );
    }

    free( Buffer );

    DmUseSharedConnection( FALSE );
}

VOID
CoverageResetData(
    PCSTR BinaryName OPTIONAL
    )
/*++

Routine Description:

    This routine sends command to coverage debug extension to flush coverage
    data.  If BinaryName is specified, only coverage data for BinaryName
    will be flushed.

Arguments:

    BinaryName - Optional name of binary.  If not specified, all coverage
        data will be flushed

Return Value:

    None

--*/
{
    DWORD Error;

    Error = CoverageSendCommand( CoverageCmdReset, 0, 0, BinaryName ? \
                                 "Only=%s" : 0, BinaryName );

    if ( Error != ERROR_SUCCESS ) {
        VerifyWin32Error( Error );
    }
}

void __cdecl main( int argc, char **argv )
{
    int i;
    char *arg;
    DWORD dwFrequency = 0;
    BOOL bList = FALSE;
    BOOL bSave = FALSE;
    BOOL bReset = FALSE;
    BOOL bPeriodic = FALSE;
    BOOL bPeriodicStop = FALSE;
    PSTR pszMachine = NULL;
    PSTR pszTestName = NULL;
    PSTR pszOnlyBinary = NULL;

    for ( i=1; i<argc; i++) {
        arg = argv[i];

        if ( *arg == '/' || *arg == '-' ) {
            _strlwr( ++arg );

            if ( !strcmp(arg, "save") ) {
                bSave = TRUE;
            } else if ( !strcmp(arg, "reset") ) {
                bReset = TRUE;
            } else if ( !strcmp(arg, "list") ) {
                bList = TRUE;
            } else if ( strstr(arg, "machine") ) {
                pszMachine = strchr( arg, ':' ) + 1;
            } else if ( !strcmp(arg, "only") ) {
                pszOnlyBinary = argv[ ++i ];
            } else if ( !strcmp(arg, "as") ) {
                pszTestName = argv[ ++i ];
            } else if ( !strcmp(arg, "periodic") ) {
                bPeriodic = TRUE;
                if ( argv[i+1] && isdigit(argv[i+1][0]) ) {
                    dwFrequency = strtoul( argv[++i], NULL, 0 );
                }
            } else if ( !strcmp(arg,"stop") ) {
                bPeriodicStop = TRUE;
            } else {
                DisplayHelpMessage();
            }
        } else {
            DisplayHelpMessage();
        }
    }

    if (( ! ( bSave ^ bReset ^ bList ^ bPeriodic)) ||     // one and only one selected
        (( ! bPeriodic ) && ( bPeriodicStop || dwFrequency )) ||
        (( bPeriodicStop ) && ( dwFrequency )) ||
        (( ! bSave ) && ( pszTestName )) ||
        (( pszOnlyBinary ) && ( ! ( bSave || bReset))) ||
        (( pszOnlyBinary ) && ( ! ( *pszOnlyBinary )))) {
       DisplayHelpMessage();
    }

    if (( bPeriodic ) && ( ! bPeriodicStop ) && ( dwFrequency == 0 )) {
        dwFrequency = 30;
    }

    if ( pszMachine ) {
        CoverageSetXboxName( pszMachine );
    }

    if ( bSave ) {
        //CoverageSaveData( pszOnlyBinary, pszTestName );
    } else if ( bReset ) {
        CoverageResetData( pszOnlyBinary );
    } else if ( bList ) {
        CoverageListBinary();
    } else if ( bPeriodic ) {
        if ( bPeriodicStop ) {
            //CoverageStopPeriodic();
        } else {
            //CoverageSetPeriodic( dwFrequency );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\qa_base.cpp ===
#if !defined(__QALIB_BASE_CPP__)
#define __QALIB_BASE_CPP__

#if !defined(QA_USE_QALIB_DLL)

#include <float.h>
#include <limits.h>
#ifndef _XTL_
#include <xtl.h>
#endif

#include "qalib.h"

namespace QaLib 
{

//
// variables/objects.
// 
static const int      g_MaxTestIdSize = 256*sizeof(char);  // max chars in test id.

static bool           g_bTestFailed = 0;          // flag to indicate test failed.
static bool           g_bTCFailed = 0;            // flag to indicate testcase failed.
static char          g_tzTestId[g_MaxTestIdSize+1];  // buffer for test id.

static double         g_DDelta = (double)0.0;
static long double    g_LDDelta = (long double)0.0;
static float          g_FDelta = (float)0.0;
//!: may be used later if output is to be sent to a file.
//static _TCHAR*        g_fileName = _QT("CON");     //!: using this will not 
                                                    //   allow redirects.

//
// Reporting results.
//

////////////////////////////////////////
// ReportTest - Send text to log object indicating results (pass or fail) of test.
//              Reset test state.
//
void
ReportTest(bool bClearFail)
{
#ifdef QA_SIMPLE_QALIB
    if (g_bTestFailed)
	    DbgPrint(_QT("\n** %d Failed **\n"), g_tzTestId);
    else
	    DbgPrint(_QT("** %d Passed **\n"), g_tzTestId);
#else
    if (g_bTestFailed)
        QALog << _QT("\n** ") << g_tzTestId << _QT(" Failed **\n") << QAEndl;
    else
        QALog << _QT("** ") << g_tzTestId << _QT(" Passed **\n") << QAEndl;
#endif
    if (bClearFail)
        ClearFailures();
}

////////////////////////////////////////
// ReportTC - Print text to stdout if testcase failed.  Reset testcase state.
//
void
ReportTC(unsigned p_tc, bool bClearFail)
{
    if (g_bTCFailed)
    {
        SetTestFailure();
#ifdef QA_SIMPLE_QALIB
	DbgPrint(_QT("\n\t** TC %d Failed **\n"), p_tc);
#else
	QALog << _QT("\n") << INDENT1 << _QT("** TC ") << p_tc << _QT(" Failed **\n") << QAEndl;
#endif
    }
    if (bClearFail)
        SetTCFailure(false);
}


//
// Math functions.
//

////////////////////////////////////////
// Pow - Calc x^y.
//
// Returns: x to the power of y.
// 
double
Pow(
    double p_d,     // > operand.
    unsigned p_u)   // > power.
{
    double p = 1.0;
    
    while (p_u-- > 0)
        p *= p_d;
    return p;
}


//
// Compare functions, used with CheckE() and CheckNE().
//

////////////////////////////////////////
// Compare - Compare 2 doubles.  compare is not exact, but includes a delta.
//
// Returns: true if equal, false otherwise.
//
bool
Compare(
    double p_val1,  // > src double.
    double p_val2)  // > double to compare to.
{
    if (g_DDelta == 0.0) 
        SetDDelta(0.5 / Pow(10.0, DBL_DIG - 1));

    if (p_val1 == p_val2)
        return true;

    if ((p_val1 + g_DDelta) > p_val2 && 
        (p_val1 - g_DDelta) < p_val2)
        return true;
    return false;
}

////////////////////////////////////////
// Compare - Compare 2 floats.  compare is not exact, but includes a delta.
//
// Returns: true if equal, false otherwise.
//
bool
Compare(
    float p_val1,   // > src float.          
    float p_val2)   // > float to compare to.
{
    
    if (g_FDelta == 0.0) 
        SetFDelta((float) (0.5 / Pow(10.0, FLT_DIG - 1)));

    if (p_val1 == p_val2)
        return true;

    if ((p_val1 + g_FDelta) > p_val2 && 
        (p_val1 - g_FDelta) < p_val2)
        return true;
    return false;
}

////////////////////////////////////////
// Compare - Compare 2 doubles.  compare is not exact, but includes a delta.
//
// Returns: true if equal, false otherwise.
//
bool
Compare(
    long double p_val1,   // > src long double.          
    long double p_val2)   // > long double to compare to.
{
    if (g_LDDelta == 0.0L) 
        SetLDDelta(0.5L / Pow(10.0, DBL_DIG - 1));

    if (p_val1 == p_val2)
        return true;
    if ((p_val1 + g_LDDelta) > p_val2 && 
        (p_val1 - g_LDDelta) < p_val2)
        return true;
    return false;
}

//
// Test validation functions.
//

////////////////////////////////////////
// Check
//
bool
Check(bool b, int line, const char* p_tzFile, const char* p_tzExp, unsigned tid)
{
    if (b)
        return true;
#ifdef QA_SIMPLE_QALIB
    QA_ERROR_TEXT(line, p_tzFile, tid);
    DbgPrint(p_tzExp);
    DbgPrint(_QT("\n"));
#else
    QALog << QA_ERROR_TEXT(line, p_tzFile, tid) << p_tzExp 
          << (*p_tzExp != 0 ? _QT(".") : p_tzExp) << QAEndl;
#endif
    SetTCFailure();
    return false;
}

////////////////////////////////////////
// Fail - Prints error message and sets error flags.
//
void
Fail(int line, const char* p_tzFile, const char* p_tzMsg, unsigned tid)
{
#ifdef QA_SIMPLE_QALIB
    QA_ERROR_TEXT(line, p_tzFile, tid);
    DbgPrint(p_tzMsg);
    DbgPrint(_QT("\n"));
#else
    QALog << QA_ERROR_TEXT(line, p_tzFile, tid) << p_tzMsg
          << (*p_tzMsg != 0 ? _QT(".") : p_tzMsg) << QAEndl;
#endif
    SetTCFailure();
}

void
Fail(int line, const char* p_tzFile, int e, unsigned tid)
{
    char  buf[10];
    _itoa(e, buf, 10); //_itot(e, buf, 10);
    Fail(line, p_tzFile, buf, tid);
}

void
Trace(int line, const char* p_tzFile, const char* p_tzMsg, unsigned tid)
{
#ifdef QA_SIMPLE_QALIB
    QA_ERROR_TEXT(line, p_tzFile, tid);
    DbgPrint(p_tzMsg);
    DbgPrint(_QT("\n"));
#else
    QALog << QA_TRACE_TEXT(line, p_tzFile, tid) << p_tzMsg 
          << (*p_tzMsg != 0 ? _QT(".") : p_tzMsg) << QAEndl;
#endif
}

//
// Initialization and termination.
//

////////////////////////////////////////
// Init - stores test id and prints test header.  Also sets a debug report
// hook. 
//

// iainb:06/05/2000 We were using QALog here to print out the debug hook reports
// this is not good if the debug report comes AFTER the globals have been destructed,
// as it will if it's a CRT memory leak report. The problem is with the global critical
// section used in the object QALog creates' constructor (i.e. via QA_LOCK).
static int __cdecl DbgReportHook(int nRptType, char *szMsg, int *retVal)
{
#pragma message("xbox -- STD_ERROR_HANDLE undefined: " __FILE__)
  /*
  HANDLE hStdErr = ::GetStdHandle(STD_ERROR_HANDLE);
  DWORD nBytesWritten;
  ::WriteFile(hStdErr, szMsg, (DWORD)strlen(szMsg), &nBytesWritten, NULL);
  */
  *retVal = 1;
  return 0;
}

static int __cdecl DbgReportHookTerm(int nRptType, char *szMsg, int *retVal)
{
#if !defined(QA_SHOW_MEM_LEAKS)

#pragma message("xbox -- STD_ERROR_HANDLE undefined: " __FILE__)
  /*
  HANDLE hStdErr = ::GetStdHandle(STD_ERROR_HANDLE);
  DWORD nBytesWritten;
  ::WriteFile(hStdErr, szMsg, (DWORD)strlen(szMsg), &nBytesWritten, NULL);
  */
  *retVal = 1;
  return 0;
#else
  return 0;
#endif 
}

void
Init(const char* p_testid, bool bBanner)
{
    /* SetErrorMode(2); */
    QA_DISPLAY_MEM_LEAKS_STDOUT();
#ifdef _DEBUG
    _CrtSetReportHook(DbgReportHook);
#endif
    QA_AUTO_LOCK2;
    strcpy(g_tzTestId, p_testid);
    ClearFailures();
    if (bBanner)
#ifdef QA_SIMPLE_QALIB
	DbgPrint(_QT("Test Id: %d\n\n"), g_tzTestId);
#else
	    QALog << _QT("Test Id: ") << g_tzTestId << _QT("\n") << QAEndl;
#endif
}

////////////////////////////////////////
// Terminate - optionally print test footer.
//
// Returns: 1 if test failed, 0 otherwise.
//
int
Terminate(bool bReportTest)   // > indicates whether test footer should be printed.
{
    int ret = GetTestFailure() ? 1 : 0;
    if (bReportTest)
        ReportTest(false);
    ClearFailures();
#ifdef _DEBUG
    _CrtSetReportHook(DbgReportHookTerm);
#endif
    return ret;
}

//
// Accsessor functions.
//

void SetTestFailure(bool b) 
{
    QA_AUTO_LOCK2;
    g_bTestFailed = b;
}

bool GetTestFailure() 
{
    return g_bTestFailed;
}

void SetTCFailure(bool b) 
{
    QA_AUTO_LOCK2;
    g_bTCFailed = b;
    if (b)
        g_bTestFailed = b;
}

bool GetTCFailure() 
{
    return g_bTCFailed;
}

void ClearFailures()
{
    SetTestFailure(false);
    SetTCFailure(false);
}

//
// Set/Get delta value for float/double compare funtions.
//

void SetDDelta(double d) 
{
    QA_AUTO_LOCK2;
    g_DDelta = d;
}

double GetDDelta() 
{
    return g_DDelta;
}

void SetLDDelta(long double d)
{
    QA_AUTO_LOCK2;
    g_LDDelta = d;
}

long double GetLDDelta() 
{
    return g_LDDelta;
}

void SetFDelta(float d) 
{
    QA_AUTO_LOCK2;
    g_FDelta = d;
}

float GetFDelta() 
{
    return g_FDelta;
}

//
// Accessor functions.
//
int GetMaxTestIdSize()
{
    return  g_MaxTestIdSize;
}

char* GetTestId()
{
    return g_tzTestId;
}

void SetTestId(const char* szId)
{
    QA_AUTO_LOCK2;
    strcpy(g_tzTestId, szId);
}

} // QaLib

#endif // !QA_USE_QALIB_DLL
#endif // __QALIB_BASE_CPP__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\internat\drv.c ===
#include <xtl.h>

int _mbslenEntry();
int _WCSICOLEntry();
int localecoEntry();
int mbstowcsEntry();
int mbtowcEntry();
int WCSCOLLEntry();
int wcsftimeEntry();
int wcstod1Entry();
int wcstod2Entry();
int wcstod3Entry();
int wcstol1Entry();
int wcstol2Entry();
int wcstol3Entry();
int wcstombsEntry();
int wcstoul1Entry();
int wcstoul2Entry();
int wcstoul3Entry();
int WCSXFRMEntry();
int wctombEntry();


#ifdef __cplusplus
extern "C"
#endif
void __cdecl internatStartTest()
{
	_mbslenEntry();
	_WCSICOLEntry();
	localecoEntry();
	mbstowcsEntry();
	mbtowcEntry();
	WCSCOLLEntry();
	wcsftimeEntry();
	wcstod1Entry();
	wcstod2Entry();
	wcstod3Entry();
	wcstol1Entry();
	wcstol2Entry();
	wcstol3Entry();
	wcstombsEntry();
	wcstoul1Entry();
	wcstoul2Entry();
	wcstoul3Entry();
	WCSXFRMEntry();
	wctombEntry();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\qa_macro.h ===
#if !defined(__QALIB_MACRO_H__)
#define __QALIB_MACRO_H__

#include "qa_nowarns.h"

//
// macros
//

// set unicode macros
//
#if defined(_UNICODE) && !defined(UNICODE)
#define UNICODE
#endif

#if defined(UNICODE) && !defined(_UNICODE)
#define _UNICODE
#endif

// if building QALIB dll then turn everything on.
//
#if defined(QA_BUILD_QALIB_DLL)
#define QA_USE_THREADS
#endif 

#ifndef QA_NO_STD_PREFIX
#undef STD
#define STD std::
#else
#undef STD
#define STD
namespace std {}
using namespace std;
#endif 

// may want to do typedefs for those not in the lib.
// check out iosfwd header.
//!: basic_*fstream, basic_ios, locale

#if defined(_UNICODE) || defined(UNICODE)
#define _tios           STD wios
#define _tstreambuf     STD wstreambuf
#define _tistream       STD wistream
#define _tostream       STD wostream
#define _tiostream      STD wiostream
#define _tstringbuf     STD wstringbuf
#define _tistringstream STD wistringstream
#define _tostringstream STD wostringstream
#define _tstringstream  STD wstringstream
#define _tfilebuf       STD wfilebuf
#define _tifstream      STD wifstream
#define _tofstream      STD wofstream
#define _tfstream       STD wfstream
#define _tstring        STD wstring
#define _tcout          STD wcout
#define _tcerr          STD wcerr
#define _tcin           STD wcin
#define _tclog          STD wclog
#else
#define _tios           STD ios
#define _tstreambuf     STD streambuf
#define _tistream       STD istream
#define _tostream       STD ostream
#define _tiostream      STD iostream
#define _tstringbuf     STD stringbuf
#define _tistringstream STD istringstream
#define _tostringstream STD ostringstream
#define _tstringstream  STD stringstream
#define _tfilebuf       STD filebuf
#define _tifstream      STD ifstream
#define _tofstream      STD ofstream
#define _tfstream       STD fstream
#define _tstring        STD string
#define _tcout          STD cout
#define _tcerr          STD cerr
#define _tcin           STD cin
#define _tclog          STD clog
#endif 

#define _QT

#define INDENT1 _QT("  ")      // first level of indentation, used for printing.
#define INDENT2 _QT("    ")    // second level of indentation, used for printing.

#if defined(QA_BUILD_QALIB_DLL)
#define QADllExport __declspec( dllexport )
#define QADllImport QADllExport                 //!__declspec( dllimport )
#elif defined(QA_USE_QALIB_DLL)
#define QADllExport __declspec( dllexport )
#define QADllImport __declspec( dllimport )
#else
#define QADllImport
#define QADllExport
#endif

// user versions of the above, for tests that are built as DLLs.
//
#if defined(QA_BUILD_DLL)
#define QAUDllExport __declspec( dllexport )
#define QAUDllImport QAUDllExport
#elif defined(QA_USE_DLL)
#define QAUDllExport __declspec( dllexport )
#define QAUDllImport __declspec( dllimport )
#else
#define QAUDllImport
#define QAUDllExport
#endif

// second set of the above
//
#if defined(QA_BUILD_DLL2)
#define QAUDllExport2 __declspec( dllexport )
#define QAUDllImport2 QAUDllExport2
#elif defined(QA_USE_DLL2)
#define QAUDllExport2 __declspec( dllexport )
#define QAUDllImport2 __declspec( dllimport )
#else
#define QAUDllImport2
#define QAUDllExport2
#endif


#define QA_DECL __stdcall           // used for exported global functions.

// set OS convienence macros.
//
#if defined(QA_OS_PMAC) || defined(QA_OS_68K) || defined(_MAC)
#define QA_OS_MAC
#endif

#if defined(QA_OS_WIN32S) || defined(QA_OS_WIN95) || defined(QA_OS_NT)
#define QA_WIN32
#endif

#if defined(QA_OS_WIN16) || defined(QA_WIN32)
#define QA_WIN
#endif

// set other macros.
//
#if defined(_MT)
#define QA_MT_LIBS
#endif

#if defined(_DEBUG)
#define QA_DEBUG
#endif

// Log macros.
//
// If building the QLIB DLL use STDIO log.
#if (!defined(QA_USE_IOS_LOG) && !defined(QA_USE_STDIO_LOG)) || defined(QA_BUILD_QALIB_DLL)
#undef QA_USE_IOS_LOG
#undef QA_USE_STDIO_LOG
#define QA_USE_STDIO_LOG
#endif 

#define QAEndl CEndl()

#if defined(QA_USE_IOS_LOG)
#define QALog CIOStreamLog()
#define QA_LOG(x)   CIOStreamLog x
#endif 

#if defined(QA_USE_STDIO_LOG)
#define QALog CStdioLog()
#define QA_LOG(x)   CStdioLog x
#endif 

// Validation macros. 
//
#define QA_LF  __LINE__,_QT(__FILE__)

#define QACheck(x)      QaLib::Check((x), QA_LF, QA_STR(x))
#define QACheckE(x,y)   QaLib::CheckE((x),(y), QA_LF)
#define QACheckNE(x,y)  QaLib::CheckNE((x),(y), QA_LF)
#define QAFail(x)       QaLib::Fail(QA_LF, x)
#define QAFail0()       QaLib::Fail(QA_LF)

#if defined(QA_TEST_DEBUG)

#ifdef QA_SIMPLE_QALIB
#define QATrace(x)      QA_TRACE_TEXT(__LINE__, _QT(__FILE__),0)
#define QATrace0()      QA_TRACE_TEXT(__LINE__, _QT(__FILE__),0)
#define QATrace1(x)     QA_TRACE_TEXT(__LINE__, _QT(__FILE__),0 
#define QATrace2(a,b)   QA_TRACE_TEXT(__LINE__, _QT(__FILE__),0)
#define QATrace3(a,b,c) QA_TRACE_TEXT(__LINE__, _QT(__FILE__),0)
#define QATrace4(a,b,c,d)   QA_TRACE_TEXT(__LINE__, _QT(__FILE__),0)
#define QATrace5(a,b,c,d,e) QA_TRACE_TEXT(__LINE__, _QT(__FILE__),0)
#define QATrace6(a,b,c,d,e,f)   QA_TRACE_TEXT(__LINE__, _QT(__FILE__),0)
#define QATrace7(a,b,c,d,e,f,g) QA_TRACE_TEXT(__LINE__, _QT(__FILE__),0)
#define QATrace8(a,b,c,d,e,f,g,h)   QA_TRACE_TEXT(__LINE__, _QT(__FILE__),0)
#else
#define QATrace(x)      QALog << QA_TRACE_TEXT(__LINE__, _QT(__FILE__),0) << (x) << QAEndl
#define QATrace0()      QALog << QA_TRACE_TEXT(__LINE__, _QT(__FILE__),0) << QAEndl
#define QATrace1(x)     QALog << QA_TRACE_TEXT(__LINE__, _QT(__FILE__),0) \
<< (x) << QAEndl

#define QATrace2(a,b)   QALog << QA_TRACE_TEXT(__LINE__, _QT(__FILE__),0) \
<< (a) << (b) << QAEndl

#define QATrace3(a,b,c) QALog << QA_TRACE_TEXT(__LINE__, _QT(__FILE__),0) \
<< (a) << (b) << (c) << QAEndl

#define QATrace4(a,b,c,d)   QALog << QA_TRACE_TEXT(__LINE__, _QT(__FILE__),0) \
<< (a) << (b) << (c) << (d) << QAEndl

#define QATrace5(a,b,c,d,e) QALog << QA_TRACE_TEXT(__LINE__, _QT(__FILE__),0) \
<< (a) << (b) << (c) << (d) << (e) << QAEndl

#define QATrace6(a,b,c,d,e,f)   QALog << QA_TRACE_TEXT(__LINE__, _QT(__FILE__),0) \
<< (a) << (b) << (c) << (d) << (e) << (f) << QAEndl

#define QATrace7(a,b,c,d,e,f,g) QALog << QA_TRACE_TEXT(__LINE__, _QT(__FILE__),0) \
<< (a) << (b) << (c) << (d) << (e) << (f) << (g) << QAEndl

#define QATrace8(a,b,c,d,e,f,g,h)   QALog << QA_TRACE_TEXT(__LINE__, _QT(__FILE__),0) \
<< (a) << (b) << (c) << (d) << (e) << (f) << (g) << (h) << QAEndl
#endif

#else

#define QATrace(x)
#define QATrace0()
#define QATrace1(x)
#define QATrace2(a,b)
#define QATrace3(a,b,c)
#define QATrace4(a,b,c,d)
#define QATrace5(a,b,c,d,e)
#define QATrace6(a,b,c,d,e,f)
#define QATrace7(a,b,c,d,e,f,g)
#define QATrace8(a,b,c,d,e,f,g,h)
#endif 

// thread specific.
//
#define QATCheck(x)      QaLib::Check((x), QA_LF, QA_STR(x), QA_TID)
#define QATCheckE(x,y)   QaLib::CheckE((x),(y), QA_LF, QA_TID)
#define QATCheckNE(x,y)  QaLib::CheckNE((x),(y), QA_LF, QA_TID)
#define QATFail(x)       QaLib::Fail(QA_LF, x, QA_TID)
#define QATFail2()       QaLib::Fail(QA_LF, _QT(""), QA_TID)

#if defined(QA_TEST_DEBUG)

#define QATTrace(x)     QALog << QA_TRACE_TEXT(__LINE__, _QT(__FILE__),QA_TID) << (x) << QAEndl
#define QATTrace0()     QALog << QA_TRACE_TEXT(__LINE__, _QT(__FILE__),0) << QAEndl
#define QATTrace1(x)    QALog << QA_TRACE_TEXT(__LINE__, _QT(__FILE__),QA_TID) \
<< (x) << QAEndl

#define QATTrace2(a,b)  QALog << QA_TRACE_TEXT(__LINE__, _QT(__FILE__),QA_TID) \
<< (a) << (b) << QAEndl

#define QATTrace3(a,b,c) QALog << QA_TRACE_TEXT(__LINE__, _QT(__FILE__),QA_TID) \
<< (a) << (b) << (c) << QAEndl

#define QATTrace4(a,b,c,d)  QALog << QA_TRACE_TEXT(__LINE__, _QT(__FILE__),QA_TID) \
<< (a) << (b) << (c) << (d) << QAEndl

#define QATTrace5(a,b,c,d,e)    QALog << QA_TRACE_TEXT(__LINE__, _QT(__FILE__),QA_TID) \
<< (a) << (b) << (c) << (d) << (e) << QAEndl

#define QATTrace6(a,b,c,d,e,f)  QALog << QA_TRACE_TEXT(__LINE__, _QT(__FILE__),QA_TID) \
<< (a) << (b) << (c) << (d) << (e) << (f) << QAEndl

#define QATTrace7(a,b,c,d,e,f,g)    QALog << QA_TRACE_TEXT(__LINE__, _QT(__FILE__),QA_TID) \
<< (a) << (b) << (c) << (d) << (e) << (f) << (g) << QAEndl

#define QATTrace8(a,b,c,d,e,f,g,h)  QALog << QA_TRACE_TEXT(__LINE__, _QT(__FILE__),QA_TID) \
<< (a) << (b) << (c) << (d) << (e) << (f) << (g) << (h) << QAEndl

#else

#define QATTrace(x)
#define QATTrace0()
#define QATTrace1(x)
#define QATTrace2(a,b)
#define QATTrace3(a,b,c)
#define QATTrace4(a,b,c,d)
#define QATTrace5(a,b,c,d,e)
#define QATTrace6(a,b,c,d,e,f)
#define QATTrace7(a,b,c,d,e,f,g)
#define QATTrace8(a,b,c,d,e,f,g,h)
#endif 


// Helper macros.
//
#define QA_STR(x) (_QT(#x))
#define QA_EVAL_DESC(x) STR(x)
#define QA_EVAL(x) x

// Testcase macros.
//

#if defined(QA_ENABLE_TC_EH)
#define QA_BEGIN_TC_EH try {
#define QA_END_TC_EH(x) } catch(...) { QaLib::Fail(QA_LF, _QT("TC Exception"), x); }
#else
#define QA_BEGIN_TC_EH
#define QA_END_TC_EH(x)
#endif 

#define QA_BEGIN_TC2(x)  { QaLib::CAutoTC auto_tc(100 * x + QA_TID); \
{ QA_MEM_CHECK_OBJECT; { QATTrace2(_QT("Testcase: "), (x)); QA_BEGIN_TC_EH

#define QA_END_TC2(x)    QA_END_TC_EH(x) }}}

// Doesn't use memcheck object.
//
#ifdef QA_SIMPLE_QALIB
#define QA_BEGIN_TC(x)  { { QATTrace2(_QT("Testcase: "), x); QA_BEGIN_TC_EH
#else
#define QA_BEGIN_TC(x)  { QaLib::CAutoTC auto_tc(100 * x + QA_TID); \
{ QATTrace2(_QT("Testcase: "), x); QA_BEGIN_TC_EH
#endif // QA_SIMPLE_QALIB

#define QA_END_TC(x)    QA_END_TC_EH(x) }}

// Convenance macro for Init and Terminate.
//
#define QA_INIT QaLib::Init(_QT(__FILE__))
#define QA_TERM return QaLib::Terminate()

//
///////////////////////////////////////////////////////////////////////////////
// thread support.
///////////////////////////////////////////////////////////////////////////////
//
#define QA_THREAD_PARAM_NAME    qaThreadParam
#define QA_THREAD_PARAM         void* QA_THREAD_PARAM_NAME = 0

#define QA_THREAD_DECL(x) QAUDllExport unsigned __stdcall x (QA_THREAD_PARAM)

// thread function decl.
//

#if (defined(QA_MT_MIX) || defined(QA_MT_SEQ)) && !defined(QA_USE_THREADS)
#define QA_USE_THREADS
#endif

#if defined(QA_USE_THREADS) && (!defined(QA_MT_MIX) && !defined(QA_MT_SEQ))
#define QA_MT_MIX
#endif 

#if defined(QA_USE_THREADS)
#define QA_TID (QA_THREAD_PARAM_NAME == 0 ? 0 : (*(unsigned*)QA_THREAD_PARAM_NAME))
#else
#define QA_TID 0
#endif 

//
//QA_MT_SEQ   // (sequential) fire off all threads for a test before going on.
//QA_MT_MIX   // (mixed) fire off a thread for each test before going on.
//
// timeout interval. 10 min. for default.
//
#if !defined(QA_MT_TIMEOUT)
#define QA_MT_TIMEOUT   600000L
#endif

// for number of threads.  5 is the default.
//
#if defined(QA_USE_THREADS) && !defined(QA_NTHREADS)
#define QA_NTHREADS 5
#endif

// boilerplate code for thread execution.
//
#if defined(QA_MT_MIX) 
#define QA_DEF_RUNOBJ_TYPE QaLib::CRunMTMix
#elif defined(QA_MT_SEQ)
#define QA_DEF_RUNOBJ_TYPE QaLib::CRunMTSeq
#else
#define QA_DEF_RUNOBJ_TYPE QaLib::CRunNoMT
#endif

#define QA_DEF_TESTMGR(x,y) QaLib::CTestMgr<x> testMgr(y);

#define QA_RUN_CODE(rot,testl,s) \
rot runObj(testl, (s)); \
QA_DEF_TESTMGR(rot, runObj)

//
// Default main implementation macros.
//
#if !defined(QA_MT_LIBS) && (defined(QA_MT_SEQ) || defined(QA_MT_MIX))
#define QA_DEF_RUN \
    QALog << _QT("Running with QA_USE_THREADS but without _MT. Skipping") << QAEndl; exit(2); 
#define QA_DEF_RUN3(rot,x) \
    QALog << _QT("Running with QA_USE_THREADS but without _MT. Skipping") << QAEndl; exit(2); 
#else
#define QA_DEF_RUN \
    QA_RUN_CODE(QA_DEF_RUNOBJ_TYPE, TestFuncList, \
                sizeof(TestFuncList)/sizeof(TestFuncList[0])) \
    return testMgr.Run(_QT(__FILE__));
#define QA_DEF_RUN3(rot,x) \
    QA_RUN_CODE(rot,TestFuncList, \
                sizeof(TestFuncList)/sizeof(TestFuncList[0])) \
    return testMgr.Run(_QT(__FILE__), x);
#endif

#if !defined (QA_USE_WINMAIN)
#define QA_MAIN \
    int  _tmain (int argc, char* argv[])

#else

#define QA_MAIN \
    WINAPI _tWinMain( \
          HINSTANCE hInstance, \
          HINSTANCE hPrevInstance, \
          LPTSTR lpCmdLine, \
          int nShowCmd \
          )

#endif

// use these macros if not using QA_DEF_RUN, that is, you need to do custom 
// test run code.
//
#define QA_BEGIN_TEST_MAIN QA_MAIN { QA_INIT;
#define QA_END_TEST_MAIN QA_TERM; }

#define QA_DEF_TESTLIST static QaLib::TestFunc TestFuncList[] =

#ifdef QA_SIMPLE_QALIB

#define QA_DEF_TEST_MAIN QA_MAIN {\
	int nTests = (sizeof(TestFuncList)/sizeof(TestFuncList[0]));\
	int iTest = 0;\
	bool bRunTerm = false;\
\
	if (TestFuncList[0] == 0){\
		if (nTests == 1) return 3; \
		iTest = 2;\
		if (TestFuncList[1] != 0)\
			TestFuncList[1](0);\
	};\
	if (nTests >= 4)\
	{\
		if (TestFuncList[2] == 0){\
			bRunTerm = true;\
			iTest = 4;\
		};\
	};\
	for (; iTest < nTests; iTest++)\
		if(TestFuncList[iTest] != 0)\
			TestFuncList[iTest](0);\
	if (bRunTerm) {\
		if (!TestFuncList[3]) {\
			_tprintf(_QT("Term function NULL!\n"));\
		} else {\
			TestFuncList[3](0);\
		}\
	}\
	int ret = GetTestFailure() ? 1 : 0;\
	ReportTest(false);\
	ClearFailures();\
	return ret;\
}

// locale versions of above.
//
#define QA_DEF_RUN2 QA_DEF_RUN3(QA_DEF_RUNOBJ_TYPE,QA_DEF_LC_TABLE_NAME)
#define QA_DEF_TEST_MAIN2 QA_MAIN { QA_DEF_RUN3(QA_DEF_RUNOBJ_TYPE,QA_DEF_LC_TABLE_NAME) }
#define QA_DEF_TEST_MAIN3(x) QA_MAIN { QA_DEF_RUN3(QA_DEF_RUNOBJ_TYPE,x) }

#else
#define QA_DEF_TEST_MAIN QA_MAIN { /* ::SetErrorMode(QA_SETERRORMODE); */ QA_DEF_RUN }

// locale versions of above.
//
#define QA_DEF_RUN2 QA_DEF_RUN3(QA_DEF_RUNOBJ_TYPE,QA_DEF_LC_TABLE_NAME)
#define QA_DEF_TEST_MAIN2 QA_MAIN { /* ::SetErrorMode(QA_SETERRORMODE); */ QA_DEF_RUN3(QA_DEF_RUNOBJ_TYPE,QA_DEF_LC_TABLE_NAME) }
#define QA_DEF_TEST_MAIN3(x) QA_MAIN { /* ::SetErrorMode(QA_SETERRORMODE); */ QA_DEF_RUN3(QA_DEF_RUNOBJ_TYPE,x) }
#endif // QA_SIMPLE_QALIB

//
// Misc. macros.
//
// macro for string literals when passed to Check* or Compare functions.
//
#define QA_SL(x)  ((const char*) _QT(x))   // cast string literals to char*.
#define _SL(x)  QA_SL(x)
#define _STR(x) (const char*)(x)          // cast string variables to char*.

#if defined(_MT)
#define QA_TLS __declspec(thread)           // for TLS variables (global).
#else
#define QA_TLS
#endif

//
// Memcheck macros
//
#if defined(_DEBUG)
#include <crtdbg.h>

#if !defined(QA_DBG_OUTPUT_DEBUGWIN)

#define  QA_SEND_TO_STDOUT() \
     { _CrtSetReportMode( _CRT_WARN, _CRTDBG_MODE_FILE ); \
    _CrtSetReportFile( _CRT_WARN, _CRTDBG_FILE_STDOUT ); \
    _CrtSetReportMode( _CRT_ERROR, _CRTDBG_MODE_FILE ); \
    _CrtSetReportFile( _CRT_ERROR, _CRTDBG_FILE_STDOUT ); \
    _CrtSetReportMode( _CRT_ASSERT, _CRTDBG_MODE_FILE ); \
    _CrtSetReportFile( _CRT_ASSERT, _CRTDBG_FILE_STDOUT ); };
#else
#define  QA_SEND_TO_STDOUT()
#endif

#define  SET_CRT_DEBUG_FIELD(a) \
            _CrtSetDbgFlag((a) | _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG))
#define  CLEAR_CRT_DEBUG_FIELD(a) \
            _CrtSetDbgFlag(~(a) & _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG))

#define QA_DISPLAY_MEM_LEAKS_STDOUT() \
    QA_SEND_TO_STDOUT(); \
    SET_CRT_DEBUG_FIELD(_CRTDBG_LEAK_CHECK_DF);

#define QA_MEM_CHECK_OBJECT QaLib::CMemCheck      memCheck(__LINE__)
#define QA_MEM_CHECK_OBJECT_GLOBAL QaLib::CMemCheck g_memCheck(__LINE__)

#else

#define QA_MEM_CHECK_OBJECT
#define QA_MEM_CHECK_OBJECT_GLOBAL

#define SET_CRT_DEBUG_FIELD(a)
#define CLEAR_CRT_DEBUG_FIELD(a)

#define QA_SEND_TO_STDOUT()

#define QA_DISPLAY_MEM_LEAKS_STDOUT()

#endif

// By default the using namespace statement is used.
//
#if !defined(QA_NO_USING_QALIB_NS)
namespace QaLib {}
using namespace QaLib;
#endif

// other useful macros.
//
#define QA_TEST_SERVER_SHARE _QT("\\\\vcuser\\exchange")
#define QA_TEST_SERVER_DIR _QT("crttest")

// length of array.
//
#define QALengthOf(x) (sizeof(x)/sizeof((x)[0]))

#endif // __QALIB_MACRO_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\test.h ===
/* Test.h -- testing include file.
 *
 *              Copyright (C) Microsoft Corp. 1993
 *
 *
 *  This include file contains macros and functions for reporting
 *  test failures.
 *
 *  Required constants:
 *
 *      test     -- char array, name of test.
 *      perfect  -- int, test success/failure flag;
 *          0 => success, 1 => failure
 *
 *
 *  Macros/functions defined are:
 *
 *  check( e )      -- confirm that expression e is zero.
 *  checke( e1, e2 )    -- confirm that expressions e1 and e2 are equal.
 *  checkne( e1, e2 )   -- confirm that expressions e1 and e2 are NOT equal.
 *  check32( e )        -- confirm that expression e is zero.
 *  checke32( e1, e2 )  -- confirm that expressions e1 and e2 are equal.
 *  checkne32( e1, e2 ) -- confirm that expressions e1 and e2 are NOT equal.
 *  checkNULL( p )      -- confirm that pointer p is NULL.
 *  checknNULL( p )     -- confirm that pointer p is NOT NULL.
 *  fail( n )       -- report failure, test number specified.
 *  faill(  )       -- report failure, no test number specified.
 *  finish()        -- summarize test pass/fail status.
 *  WinLogString( p, ... )  -- Redefines printf to TextOut() and file write
 *  WinFLogString ( f, ... ) -- Redefines printf to TextOut() and file write, ignored fptr
 *
 *
 *  Modifications
 *  M000   22-Mar-89  waltcr
 *  - added #includes for stdio, and stdlib.  removed defines of cdecl and near.
 *  M001   06-Apr-89  waltcr
 *  - doscalls doesn't exist anymore. now use os2.h.  change DOSSLEEP to DosSleep
 *  M001   06-Apr-89  waltcr
 *  - define REGVARS macro to help find more optimization bugs.
 *  M002   20-May-89  waltcr
 *  - convert function declerations to new style function declerations.
 *  M003   06-Jun-89  waltcr
 *  - define INCL_NOPM so when os2.h is included, pm headers are not included.
 *  M004   27-Mar-90  mattheww
 *  - define far etc. to nothing if using c386 compiler
 *  M005   29-Mar-90  waltcr
 *  - merge in CXX test.h - change finish() to macro, define TEST_H.
 *  M006   02-Apr-90  mrw
 *  - remove MTHREAD if's and put them into seperate THREAD.H
 *  M007   10-Apr-90  chauv
 *  - changed most "int" variables to "unsigned long" variables.
 *  - changed those "%d" associated with "int" variables to "%lu" in printf().
 *  M008  12-Apr-90   mattheww
 *  - move c386 specific defines to a seperate include file c386.h (undo M004)
 *  - put printf back in check_func (mistakenly deleted before)
 *  M009  31-May-90  brucemc
 *  - added CALLCONV as macro for _cdecl vs _stdcall prototypes.
 *  M010  06-Jun-90  chauv
 *  - changed all "unsigned long" back to "int" and duplicate these
 *  - functions for unsigned long adding "32" to function name.
 *  M011  20-Jun-90  mattheww
 *  - fixed format spec for printing line number in faill_func()
 *  M012  28-Dec-90  alans
 *  - undefined fail() when __IOSTREAM_H is defined due to conflict with
 *  - ios::fail() member function.
 *  M013  16-May-91  tomca
 *  - c7/386 defines _M_I386 only (not M_I386)
 *  M014  01-Aug-91  bos
 *  - Modified printf statements for Failure output to confirm with
 *  - standard C error output.  This allows PWB and M to track a test's
 *  - runtime errors in the build results window.
 *  M015  01-Aug-91  xiangjun
 *  - remove "#include <callcon.h>" because of the usage change of "stdcall"
 *  - and "#define CALLCONV" to make the tests still valid.
 *  M016  23-Aug-91  georgech
 *  - remove _threadid duplicated in thread.h as far
 *  M017  23-Aug-91  bos
 *  - removed extraneous #endif after _threadid definition comment
 *  M018  10-Jan-92  alans
 *  - a couple of the 32-bit macros were missing the unsigned long cast
 *  M019  13-Jan-92  alans
 *  - the 32-bit functions protoed the __LINE__ as an unsigned long but
 *  - it is an int always.
 *  M020  15-Jan-92  alans
 *  - added checkNULL and checknNULL for checking pointers
 *  M021  16-Feb-92  bos
 *  - moved some declarations and macros outside the extern "C"
 *  M022  22-Jan-92  v-stevek
 *  - included <ntport.h> to support nt
 *  M023  04-Jun-92  patlo
 *  - if _WINDOWS is defined, redefined printf, main to run tests as
 *  - win-16 apps
 *  M024  06-Jul-92  patlo
 *  - Split into test.h and test.c
 *  M025  13-Jul-92  Patlo
 *  - Added errdefs to Win16 code
 *  M026  16-Jul-92  patlo
 *  - Merged test.c back into test.h, put all WinTest code in wintest.h,
 *  - added conditional compilation of wintest.h
 *  M027  12-Aug-92  judithla
 *  - added check for defines of WIN32S or WINNT to add proper includes
 *  M028  09-nov-92 tomca
 *  - include if NT_TEST, _M_I386 or _M_M68K is defined. no more c386.h
 *  M029  30-Dec-1992 mattheww
 *  - For NT, define has been changed to _M_IX86; check for this to determine whether
 *    or not to include 
 *  M030  18-Feb-1993 a-aarond
 *  - If TEST_NT is defined, do not include ntport.h or c32.h.
 *  M031  25-Mar-1993 a-jasonw
 *  - If _M_MRX000 is defined (when using Centaur) include c32.h.
 *  M032  12-Aug-1994 a-timke
 *  - Removed define of CALLCONV. This is no longer needed but caused
 *  - compiler errors in oleauto.h.
 *  M033  23-Jan-1994 a-timke
 *  - __IOSTREAM_H header flag was changed to __INC_IOS (in ios.h)
 *  M034  17-Apr-1995 a-timke
 *  - Support for TEST_WIN32S switch.
 *  M035  03-Apr-1995 mmalone
 *  - Added code to block the Debug CRT report message box from openning.
 *    writes to stdout instead.
 *  M035  07-July-1995 mmalone
 *  - Added check for QA_NO_DBGCRT_HOOK, if defined will not install a report
 *    hook.  Added 2 global variables:
 *       reportHookCalled  : set to 1 if the report hook has been called.
 *       dbgCrtCont        : set to 1 if you want to return from report hook
 *                           instead of exiting.
 *
 * M036   24-Oct-1995 mmalone
 *  - added include for skiptest.h (added) so failing tests can be turned
 *    on/off and kept track of more easily.
 * M037   29-Jan-1998 mmalone
 *  - added _WIN64 (i64) versions of checkNULL and checknNULL.  
 * M038   29-Jan-1998 mmalone
 *  - added 64 bit version of check_func().
 * M039	Nov-30-98 anitag
 *	- added _Win64 to include c32.h to tests for P7
 *
 */


#include <stdio.h>                                                   /* M000 */
#include <stdlib.h>
/* M009 */
/* M015
#include <callcon.h>
*/


/*M032# CALLCONV*/


/* M005*/
#ifndef TEST_H
#define TEST_H

/* M026 */
/* M034 */
/* not needed for xbox
#ifdef _WINDOWS
# include <wintest.h>
#elif defined(WIN32S) || defined(TEST_WIN32S) || defined(WINNT)
# define _WINDOWS
# include <wintest.h>
#endif
*/

#include <xtl.h>
int DbgPrint(const char *, ...);
#define QA_NO_DBGCRT_HOOK

#define T(x) x
#define V(x) x
#define PDV(x) x
#define starthread()  perfect = 0

/* M035 */
#if defined(_DEBUG) && !defined(QA_NO_DBGCRT_HOOK)
#include <crtdbg.h>

static int oldRetVal = 0;
static int reportHookCalled = 0; /* 1 if report hook called */
static int dbgCrtCont = 0;       /* 0 == exit, 1 = continue program. */

static void logDbgCrtExit(void)
{
  exit(99);
}

extern char test[];
static int logDbgCrtReport(int nRptType, char *szMsg, int* retval)
{
  oldRetVal = 0;
  reportHookCalled = 1;
  if (dbgCrtCont)
    return 1;
  DbgPrint("\nDebug CRT Report: %s", szMsg);
  DbgPrint("%s: ----- FAILED -----\n", test);
  logDbgCrtExit();
  return 0;    /* never gets called, but compiler complains if not here.*/
}

#define startest()  _CrtSetReportHook((_CRT_REPORT_HOOK)logDbgCrtReport); perfect = 0
#else
#define startest()  perfect = 0
#endif





/* This macro is used to confirm its argument is zero.
*/
#ifdef _WIN64
#define check( a ) check_func64( (__int64)(a), __LINE__ )
#else
#define check( a ) check_func( (int)(a), __LINE__ )
#endif 

/* This macro is used to confirm its arguments are equal.
*/
#ifdef _WIN64
#define checke( a, b ) checke_func64( (__int64)(a), (__int64)(b), __LINE__ )
#else
#define checke( a, b ) checke_func( (int)(a), (int)(b), __LINE__ )
#endif 

#define checke32( a, b ) checke_func32( (unsigned long)(a), (unsigned long)(b), __LINE__ )    /* M010 */

/* This macro is used to confirm its arguments are NOT equal.
*/
#ifdef _WIN64
#define checkne( a, b ) checkne_func64( (__int64)(a), (__int64)(b), __LINE__ )
#else
#define checkne( a, b ) checkne_func( (int)(a), (int)(b), __LINE__ )
#endif 
/* M018 */
/* M019 */
#define checkne32( a, b ) checkne_func32( (unsigned long)(a), (unsigned long)(b), __LINE__ )  /* M010 */


/* This macro is used to report failures of tests that are explicitely
 * numbered.
*/
#if !defined(QA_NO_FAIL_MACRO)
#define fail( n ) fail_func( (n), __LINE__ )
#endif
/* M018 */
#define fail32( n ) fail_func32( ((unsigned long)n), __LINE__ )    /* M010 */


/* This macro is used to report failures of tests that are NOT explicitely
 * numbered.
*/
#define faill( ) faill_func( __LINE__ )
#define faill32( ) faill_func32( __LINE__ )         /* M010 */

/* M037 */
#if !defined(_WIN64)

/* M020 */
/* This macro is used to confirm that its argument is a NULL pointer.
*/
#define checkNULL( a ) if ( sizeof( a ) == 4 ) \
               check_func32( (unsigned long)(a), __LINE__ ); \
               else \
               check_func( (unsigned int)(a),  __LINE__ )

/* M020 */
/* This macro is used to confirm that its argument is NOT a NULL pointer.
*/
#define checknNULL( a ) if ( sizeof( a ) == 4 ) \
                check_func32( (unsigned long)!(a), __LINE__ ); \
            else \
                check_func( (unsigned int)!(a), __LINE__ )

#else 

#define checkNULL( a ) check_func64( (unsigned __int64)(a), __LINE__ )
#define checknNULL( a ) check_func64( (unsigned __int64)!(a), __LINE__ )

#endif 

/* Report test results
**
*/

#define finish() \
    if( !V(perfect) ) DbgPrint("%s: ***** PASSED *****\n",test); \
    else DbgPrint("%s: ----- FAILED -----\n",test); \
    return (int)( V(perfect) ? 1 : 0 )\


/* M005*/
#if defined( __cplusplus )
extern "C" {
#endif

/* M022 */
#if defined(TEST_NT)

/* M030 */
/*
#include <ntport.h>
*/

#undef M_I386
#undef _M_I386

#endif


extern char Result[ 64 ] ;
extern unsigned Synchronize ;
extern int  T(perfect);


/* M008 */
/* M028 */
/* M029 */
/* M030 */
/* M031 */
/* #if defined(M_IX86) || defined(_M_IX86) || defined(_M_M68K) || defined(_M_MRX000) || defined(_M_MPPC) || defined(_M_PPC) || defined(_WIN64) */
#ifndef TEST_NT
// not needed for xbox
// #include <c32.h>
#endif
/* #endif */

#define REGVARS   register int _r1 = 1;  register int _r2 = 2        /* M002 */

/* extern int * _threadid ;     M016 */

/* the use of "far pascal" was conflicting with use of -Za switch, so */
/* replaced prototype of DOSSLEEP with following three lines, 7-6-88  */

static void  check_func(int  a,int  l);
static void  checke_func(int  a,int  b,int  l);
static void  checkne_func(int  a,int  b,int  l);
static void  fail_func(int  n,int  l);
static void  faill_func(int  l);


/* M010 */
static void  check_func32(unsigned long  a,int  l);
static void  checke_func32(unsigned long  a,unsigned long  b,int  l);
static void  checkne_func32(unsigned long  a,unsigned long  b,int  l);
static void  fail_func32(unsigned long  n,int  l);
static void  faill_func32(int  l);

#if defined(_WIN64)
static void  check_func64(unsigned __int64  a, int  l);
static void  checke_func64(unsigned __int64  a, unsigned __int64 b,int  l);
static void  checkne_func64(unsigned __int64  a, unsigned __int64 b,int  l);
#endif 

/* M012 */
/* M033 */
#if defined(__IOSTREAM_H) || defined(_INC_IOSTREAM) || defined(_INC_IOS) || defined(_IOSTREAM_)
 #undef fail
#endif

/**************************************************************/
/*****  SPLIT HERE IF YOU WANT TEST.H AND TEST.C SEPARATE *****/
/**************************************************************/

extern char test[];
static void check_func( int a, int l )
{
    if( !a ) return;
    DbgPrint("%s(%d): Failure: --- %d != 0\n",test, l, a );
    V(perfect) = 1;
}

/* M010 */
/* M019 */
static void check_func32( unsigned long a, int l )
{
    if( !a ) return;
    DbgPrint("%s(%d): Failure: --- %lu != 0\n",test, l, a );
    V(perfect) = 1;
}

/* M038 */
#if defined(_WIN64)
static void check_func64( unsigned __int64 a, int l )
{
    if( !a ) return;
    DbgPrint("%s(%d): Failure: --- %I64u != 0\n",test, l, a );
    V(perfect) = 1;
}

static void checke_func64(unsigned __int64 a, unsigned __int64 b, int l )
{
    if( a == b ) return;
    DbgPrint("%s(%d): Failure: --- %I64u != %I64u\n",test, l, a, b );
    V(perfect) = 1;
}

static void checkne_func64( unsigned __int64 a, unsigned __int64 b, int l )
{
    if( a != b ) return;
    DbgPrint("%s(%d): Failure: --- %I64u == %I64u\n",test, l, a, b );
    V(perfect) = 1;
}
#endif 


static void checke_func(int a, int b, int l )
{
    if( a == b ) return;
    DbgPrint("%s(%d): Failure: --- %d != %d\n",test, l, a, b );
    V(perfect) = 1;
}

/* M010 */
/* M019 */
static void checke_func32(unsigned long a, unsigned long b, int l )
{
    if( a == b ) return;
    DbgPrint("%s(%d): Failure: --- %lu != %lu\n",test, l, a, b );
    V(perfect) = 1;
}

static void checkne_func( int a, int b, int l )
{
    if( a != b ) return;
    DbgPrint("%s(%d): Failure: --- %d == %d\n",test, l, a, b );
    V(perfect) = 1;
}

/* M010 */
/* M019 */
static void checkne_func32( unsigned long a, unsigned long b, int l )
{
    if( a != b ) return;
    DbgPrint("%s(%d): Failure: --- %lu == %lu\n",test, l, a, b );
    V(perfect) = 1;
}



static void fail_func( int n, int l )
{
    DbgPrint("%s(%d): Failure: --- test %d\n",test, l, n );
    V(perfect) = 1;
}

/* M010 */
/* M019 */
static void fail_func32( unsigned long n, int l )
{
    DbgPrint("%s(%d): Failure: --- test %lu\n",test, l, n );
    V(perfect) = 1;
}



static void faill_func( int l )
{
    DbgPrint("%s(%d): Failure:\n",test, l);           /* M011 */
    V(perfect) = 1;
}

/* M010 */
/* M019 */
static void faill_func32( int l )
{
    DbgPrint("%s(%d): Failure:\n",test, l);
    V(perfect) = 1;
}


#if defined( __cplusplus )
};
#endif

/*M036*/
// xbox
// #include "skiptest.h"

#ifdef __cplusplus
#if !defined(QA_DISABLE_USING_NAMESPACE)
namespace std {}
using namespace std;
#endif
#endif

// xbox - redefine any lingering printf's
#pragma message("pointing printf to DbgPrint")
#define printf DbgPrint

// not supported in xbox, so undefine this
#define _putenv(x) 

#endif /* #ifndef TEST_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\qa_nowarns.h ===
#if !defined(__QA_NOWARNS_H__)
#define __QA_NOWARNS_H__

#if !defined(QA_ENABLE_WARNS)

#pragma warning(disable:4786)

#endif

#endif // __QA_NOWARNS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\qa_util2.h ===
#if !defined(__QALIB_UTIL2_H__)
#define __QALIB_UTIL2_H__

#include "qa_macro.h"

///////////////////////////////////////////////////////////////////////////////
// header includes
//

#if defined(QA_USE_STRSTRM) || defined(QA_INC_ALL)
#include <sstream>
#endif //QA_USE_STRSTRM

#if defined(QA_USE_TEMP_DATA_FILE) || defined(QA_INC_ALL)
#include <stdio.h>
#include <io.h>
#include <sys\stat.h>
#endif //QA_USE_TEMP_DATA_FILE

#if defined(QA_USE_COMPOSE) || defined(QA_INC_ALL)
#include <functional>
#endif //QA_USE_COMPOSE

namespace QaLib
{

///////////////////////////////////////////////////////////////////////////////
// typedefs
#if defined(QA_USE_STRSTRM) || defined(QA_INC_ALL)

typedef _tostringstream COStrStream;
typedef _tistringstream CIStrStream;
#define QA_DEF_STRSTRM QaLib::COStrStream  ostrstrm
#define QA_DECL_STRSTRM(x) QaLib::COStrStream x
#define QA_DEF_OSTRSTRM QaLib::COStrStream  ostrstrm
#define QA_DECL_OSTRSTRM(x) QaLib::COStrStream x
#define QA_DEF_ISTRSTRM QaLib::CIStrStream  istrstrm
#define QA_DECL_ISTRSTRM(x) QaLib::CIStrStream x

#endif //QA_USE_STRSTRM

#if defined(QA_USE_TEMP_DATA_FILE) || defined(QA_INC_ALL)

//
// create datafile.
//
class CTempDataFile
{
public:
    CTempDataFile(const char* file, const char* data = 0, bool bClose = false)
    : m_file(file)
    {
        m_pFile = _tfopen(file, _T("w+"));
        if (m_pFile && data)
            _fputts(data, m_pFile);
        if (bClose)
            Close();
    }

    ~CTempDataFile()
    {
        Close();
        _tchmod(m_file, S_IWRITE);
        _tunlink(m_file);
    }

    bool operator !() const { return Fail(); }
    FILE* operator *() const { return m_pFile; }

    bool            Fail() const { return !m_pFile; }
    const char*     Path() const { return m_file; }

    bool            Close() 
    { 
        bool    retVal = false;
        if (m_pFile)
            retVal = fclose(m_pFile) == 0; 
        m_pFile = 0; 
        return retVal;
    }

protected:
    const char*     m_file;     // path to file.
    FILE*           m_pFile;    // file handle.
};

#endif // QA_USE_TEMP_DATA_FILE

#if defined(QA_USE_IOTAGEN) || defined(QA_INC_ALL)

template<class _Ty> struct IotaGen
{
    IotaGen() {}
    IotaGen(_Ty v) : init(v) {}
    _Ty operator()()
    {
        return init++; 
    }
private:
    _Ty     init;
};

#endif // QA_USE_IOTAGEN

///////////////////////////////////////////////////////////////////////////////
// template functions.

#if defined(QA_USE_IOTA) || defined(QA_INC_ALL)

//
// iota() : sets all values in container to 'v'.
//
template<class _OI, class _V> inline void iota(_OI _F, _OI _L, _V v)
{
    _V  x = v;
    for (; _F != _L; ++_F)
        *_F = x++;
}

#endif // QA_USE_IOTA

///////////////////////////////////////////////////////////////////////////////

#if defined(QA_USE_CLEAR) || defined(QA_INC_ALL)

//
// free contained pointers. assumes container contains pointers to T.
//
template<class _II> inline void ClearPtrContainer(_II _F, _II _L)
{
    for (; _F != _L; ++_F)
        delete *_F;
}

#endif // QA_USE_CLEAR

///////////////////////////////////////////////////////////////////////////////

#if defined(QA_USE_FILL_CONTAINER) || defined(QA_INC_ALL)

//
// Fill given container with values of T1 specified by "b" and "e".
//
template <class T, class T1> void FillContainer(T& l, T1* b, T1* e)
{
    T1* x = b;
    while (x != e)
        l.push_back(*x++);
}

#endif //QA_USE_FILL_CONTAINER

#if defined(QA_USE_COMPOSE) || defined(QA_INC_ALL)

//
// these functions are taken from the HP version of STL since the current
// c++ standard doesn't define them.
//

template <class Operation1, class Operation2>
class unary_compose : public STD unary_function<Operation2::argument_type,
                                                 Operation1::result_type> {
protected:
    Operation1 op1;
    Operation2 op2;
public:
    unary_compose(const Operation1& x, const Operation2& y) : op1(x), op2(y) {}
    result_type operator()(const argument_type& x) const {
    return op1(op2(x));
    }
};

template <class Operation1, class Operation2>
unary_compose<Operation1, Operation2> compose1(const Operation1& op1, 
                           const Operation2& op2) {
    return unary_compose<Operation1, Operation2>(op1, op2);
}

template <class Operation1, class Operation2, class Operation3>
class binary_compose : public STD unary_function<Operation2::argument_type,
                                                  Operation1::result_type> {
protected:
    Operation1 op1;
    Operation2 op2;
    Operation3 op3;
public:
    binary_compose(const Operation1& x, const Operation2& y, 
           const Operation3& z) : op1(x), op2(y), op3(z) { }
    result_type operator()(const argument_type& x) const {
    return op1(op2(x), op3(x));
    }
};

template <class Operation1, class Operation2, class Operation3>
binary_compose<Operation1, Operation2, Operation3> 
compose2(const Operation1& op1, const Operation2& op2, const Operation3& op3) {
    return binary_compose<Operation1, Operation2, Operation3>(op1, op2, op3);
}

#endif // QA_USE_COMPOSE

#if defined(QA_USE_VERIFY_SORT) || defined(QA_INC_ALL)

// verify a stable sort using a weak relation, op
// not a particularly fast implementation (choose to reuse):
// (1) checks that the sort is correct with VerifyWeakSort
// (2) checks that 
// NOTE: we require that a == be defined on these elements that
// can determine the correspondance between elements in the sorted and unsorted
// lists. If such an operator is not defined, the test is useless (but doesn't fail)
// REF: verifies the result of stable_sort, as defined in C++ Standard, 25.3.1.2
template <class T, class F>
bool VerifyStableSort(_tostream& o, T firstSorted, T lastSorted, F op, T firstUnsorted, T lastUnsorted)
{
  if (VerifyWeakSort(o, firstSorted, lastSorted, op))
    {
      for (T c = firstSorted; c != lastSorted; c++)
	{
	  T t = c;
	  t++;
	  for (; t != lastSorted; t++)
	    {
	      if (op(*c, *t))
		continue; // after we see an ordering,
	                  // skip to the next equivalent group
	      
	      // c and t are equivalent, check that c comes before t in the original
	      // (unsorted) sequence
	      for (T u = firstUnsorted; u != lastUnsorted; u++)
		{
		  // the order here is important if == is defined badly
		  // (e.g. (!op(*x,*y) && !op(*y,*x))).
		  if (*u == *c) break;
		  if (*u == *t)
		  {
		    o << "Invalid stable sort. ";
		    o << " Sorted element "  << c - firstSorted;
		    o << " is equivalent to sorted element " << t - firstSorted;
		    o << " but the pair's order is reversed with respect to ";
		    o << " the unsorted list" << STD endl;
		    return false;
		  };
		};
	    };
	};
      return true;
    };

    return false;
}

// verify a sort using a weak relation, op
// every element must be followed by 0 or more equivalent elements
// (for which the op returns false in both directions). All the elements
// after the equivalent set must make op(X,?)  true. 
// REF: verifies the result of sort, as defined in C++ Standard, 25.3.1.1
template <class T, class F>
bool VerifyWeakSort(_tostream& o, T f, T l, F op)
{
    for (T c = f; c != l; c++)
    {
      bool bEquiv = true;
        for (T t = c; t != l; t++)
        {
            if (!(*t == *c))
	      {
		if (op(*c, *t)) bEquiv = false;
		if (bEquiv)
		  {
		    // verify that t and c are equivalent
		    bool bTC = QACheck(!op(*t, *c));
		    bool bCT = QACheck(!op(*c, *t));
		    if (!bTC || !bCT)
		      {
			o << "Invalid weak sort: error at location: "
			  << f-c << " not equivalent, but not strongly ordered"
			  << STD endl;
			return false; // quit after first error -- don't pollute logs
		      };
		  }
		else
		  {
		    if (!QACheck(op(*c, *t)))
		      {
			o << "Invalid weak sort: error at location: "
			  << f-c << " after equivalence" << STD endl;
			return false; // quit after first error -- don't pollute logs
		      };
		  };
	      };
        }
    }
    return true;
}

// verify partial sort. all the elements from f to m are
// "op" w.r.t. all the elements from m to l.
// REF: verifies the result of partial_sort, as defined in C++ Standard, 25.3.1.3
template <class T, class F>
bool VerifyPartialSort(_tostream& o, T f, T m, T l, F op)
{
    for (T c = f; c != m-1; c++)
    {
          for (T t = m; t != l; t++)
        {
	  if (!QACheck(op(*c, *t)))
	    {
	      o << "Invalid partial sort: error at location: " << c-f << " , " << t-f <<
		" (middle at " << m-f << ") " << STD endl;
	      return false; // quit after first error -- don't pollute logs
	    };
        }
    }
    return true;
}

template <class T, class F>
void VerifySort(_tostream& o, T f, T l, F op)
{
    T s = f;
    for (T c = f; c != l; c++)
    {
        for (T t = s; t != c; t++)
        {
            if (!(*t == *c))
                if (!QACheck(op(*t, *c)))
                    o << "\terror at location: " << c - t << STD endl;
        }
    }
}

template <class T, class F>
void VerifySort(T f, T l, F op)
{
    VerifySort(_tcout, f, l, op);
}
                      

#endif //QA_USE_VERIFY_SORT

#if defined(QA_USE_PRINT_SEQ) || defined(QA_INC_ALL)

//
// Both functions print the sequence defined by "first" and "last" to 
// an output stream.  The first function takes the stream to print to.
// The second function is for compatibility with old tests - requires a global
// output stream object called "ostrstrm".
// When writing new code, use the first version.
//
template <class O, class T> O& PrintSeq(O& o, T first, T last)
{
    T   t = first;
    while (t != last)
        o << *t++ << _T(" ");
    if (first != last)
        o << STD endl;
    return o;
}

template <class T> void print_seq(T first, T last)
{
    T   t = first;
    while (t != last)
        ostrstrm << *t++ << _T(" ");
    if (first != last)
        ostrstrm << STD endl;
}

#endif // QA_USE_PRINT_SEQ

}   // namespace QaLib

#endif  //__QALIB_UTIL2_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\qa_thread.h ===
#if !defined(__QALIB_THREAD_H__)
#define __QALIB_THREAD_H__


#include "qa_macro.h"

#if defined(QA_USE_THREADS)
#include <process.h>
#include <xtl.h>
#include "qa_threads.h"
#include "qa_cs.h"
#endif 

// Convenance locking macros for the tests.
//
#if defined(QA_USE_THREADS)

#define QA_CS(x)        CCriticalSection        x
#define QA_AUTO_LOCK(x) CAutoLock<CCriticalSection> qaAutoLock(x)
#define QA_LOCK(x)      x.Lock()
#define QA_UNLOCK(x)    x.Unlock()

#else

#define QA_CS(x)
#define QA_AUTO_LOCK(x)
#define QA_LOCK(x)
#define QA_UNLOCK(x)

#endif 

namespace QaLib 
{

#if defined(QA_USE_THREADS)
extern CCriticalSection g_qalibCS1;             // log object.
extern CCriticalSection g_qalibCS2;             // global variable access

#define QA_AUTO_LOCK1   QA_AUTO_LOCK(g_qalibCS1)
#define QA_AUTO_LOCK2   QA_AUTO_LOCK(g_qalibCS2)
#define QA_LOCK1        g_qalibCS1.Lock()
#define QA_LOCK2        g_qalibCS2.Lock()
#define QA_UNLOCK1      g_qalibCS1.Unlock()
#define QA_UNLOCK2      g_qalibCS2.Unlock()
#else
#define QA_AUTO_LOCK1
#define QA_AUTO_LOCK2
#define QA_LOCK1
#define QA_LOCK2
#define QA_UNLOCK1
#define QA_UNLOCK2
#endif 

}       // QaLib

#endif // __QALIB_THREAD_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\qa_base.h ===
#if !defined(__QALIB_BASE_H__)
#define __QALIB_BASE_H__

#include <string.h>
#include <tchar.h> 
#include <math.h>
#include <stdlib.h>

#if defined(_DEBUG)
# include <crtdbg.h>
#endif //defined(_DEBUG)

#include "qa_macro.h"

#if defined(_DEBUG)
// windows must be included AFTER qa_macro.h for UNICODE runs!
#include <xtl.h>
#endif //defined(_DEBUG)

#include "qa_macro.h"
#if defined(QA_USE_IOS_LOG) || defined(QA_BUILD_QALIB_DLL)
#include <iostream>
#endif
#if defined(QA_USE_STDIO_LOG) || defined(QA_BUILD_QALIB_DLL)
#include <stdio.h>
#endif 

#include "qa_thread.h"

#if defined(QA_USE_STRINGTABLE)
#include "qa_str_table.h"
#endif

// declare Windows API SetErrorMode to turn off GPF/AV dialog.
//
#if !defined(_WINDOWS_)
extern "C" __declspec(dllimport) unsigned __stdcall SetErrorMode(unsigned uMode);

#ifndef QA_SETERRORMODE
// these values are the same as the #defines used in the #else branch for Win2K
#define QA_SETERRORMODE (0x0001 | 0x8000 | 0x0002)
#endif // QA_SETERRORMODE

#else // defined(_WINDOWS_)

#ifndef QA_SETERRORMODE
#define QA_SETERRORMODE (SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX | SEM_NOGPFAULTERRORBOX)
#endif // QA_SETERRORMODE

#endif 

extern "C" { int __cdecl DbgPrint(const char*, ...); }

namespace QaLib 
{

//
///////////////////////////////////////////////////////////////////////////
// Global Typedefs.
///////////////////////////////////////////////////////////////////////////
//

typedef QAUDllImport unsigned (__stdcall* TestFunc)(void*);

//
///////////////////////////////////////////////////////////////////////////
// Classes.
///////////////////////////////////////////////////////////////////////////
//

//!: build all flavors for qalib dll, need to include the correct version of GetLog
// in user code.
// macros (QALog, QAEndl) should not be defined when building DLL.

struct QADllImport CEndl {}; // basically tells the log class to print a new line and
                             // flush buffers.

// used to print diagnostic text and default information like line # and file.
class QADllImport CDiagText
{
public:
    CDiagText(const char* tzText, int line, const char* tzFile, unsigned tid)
    : m_tzText(tzText), m_line(line), m_tzFile(tzFile), m_tid(tid) {}

    const char*     m_tzText;
    int             m_line;
    const char*     m_tzFile;
    unsigned        m_tid;
};

//
// Log classes.  There are currently (2/17/97) 2 classes.  One sends output
// to stdout via the iostreams (std::cout) and the other class uses printf.
// The interface is similar to ostream except manipulators can't be used.
//
#if defined(QA_USE_IOS_LOG) || defined(QA_BUILD_QALIB_DLL)

class QADllImport CIOStreamLog
{
public:
    // lock and unlock
    CIOStreamLog() 
    {
        QA_LOCK1;
        m_os = &_tcout;
    }

    ~CIOStreamLog()
    {
        QA_UNLOCK1;
    }
#ifdef _WIN64					//it is the testharness utility anyway. LX: 11101999	
    CIOStreamLog& operator << (size_t _X) { 	//This fix is ad hoc, but so is the design
	 DbgPrint(_QT("%I64i"), _X); 
	return *this; 
	}
#endif

    //!mmalone: no int64 support in iostream yet so use stdio.
    CIOStreamLog& operator << (__int64 _X) { DbgPrint(_QT("%I64i"), _X); return *this; }
    CIOStreamLog& operator << (bool _X) { (*m_os) << _X; return *this; }
    CIOStreamLog& operator << (short _X) { (*m_os) << _X; return *this; }
#if !defined(_UNICODE)
    CIOStreamLog& operator << (unsigned short _X) { (*m_os) << _X; return *this; }
#endif 
    CIOStreamLog& operator << (int _X) { (*m_os) << _X; return *this; }
    CIOStreamLog& operator << (unsigned int _X) { (*m_os) << _X; return *this; }
    CIOStreamLog& operator << (long _X) { (*m_os) << _X; return *this; }
    CIOStreamLog& operator << (unsigned long _X) { (*m_os) << _X; return *this; }
    CIOStreamLog& operator << (float _X) { (*m_os) << _X; return *this; }
    CIOStreamLog& operator << (double _X) { (*m_os) << _X; return *this; }
    CIOStreamLog& operator << (long double _X) { (*m_os) << _X; return *this; }
    CIOStreamLog& operator << (const void* _X) { (*m_os) << _X; return *this; }
    CIOStreamLog& operator << (char* _X) { (*m_os) << _X; return *this; }
    CIOStreamLog& operator << (const char* _X) { (*m_os) << _X; return *this; }
    CIOStreamLog& operator << (char _X) { (*m_os) << _X; return *this; }
    CIOStreamLog& operator << (const CEndl& _X) { (*m_os) << std::endl; return *this; }
    CIOStreamLog& operator << (const CDiagText& x)
    { 
        (*m_os) << x.m_tzText << x.m_tzFile << _QT(" (") << x.m_line << _QT("). ");
        if (x.m_tid)
            (*m_os) << _QT("tid(") << x.m_tid << _QT("). ");
        return *this;
    }
#if defined(_XSTRING_) || defined(QA_DEF_QALOG_STRING_OP)
    CIOStreamLog& operator << (const _tstring& x)
    { (*m_os) << x.c_str(); return *this; }
#endif

protected:
    std::basic_ostream<char>* m_os;
};

#endif

#if defined (QA_USE_STDIO_LOG) || defined(QA_BUILD_QALIB_DLL)

class QADllImport CStdioLog
{
public:
    // lock and unlock
    CStdioLog()
    {
        QA_LOCK1;
    }

    ~CStdioLog()
    {
        QA_UNLOCK1;
    }

#ifdef _WIN64					//it is the testharness utility anyway. LX: 11101999	
    CStdioLog& operator << (size_t _X) { 	//This fix is ad hoc, but so is the design
	 DbgPrint(_QT("%I64i"), _X); 
	return *this; 
	}
#endif

    CStdioLog& operator << (__int64 _X) { DbgPrint(_QT("%I64i"), _X); return *this; }
    CStdioLog& operator << (bool _X) { DbgPrint(_QT("%d"), _X ? 1 : 0); return *this; }
    CStdioLog& operator << (short _X) { DbgPrint(_QT("%hd"), _X); return *this; }
#if !defined(_UNICODE)
    CStdioLog& operator << (unsigned short _X) { DbgPrint(_QT("%hu"), _X); return *this; }
#endif 
    CStdioLog& operator << (int _X) { DbgPrint(_QT("%d"), _X); return *this; }
    CStdioLog& operator << (unsigned int _X) { DbgPrint(_QT("%u"), _X); return *this; }
    CStdioLog& operator << (long _X) { DbgPrint(_QT("%ld"), _X); return *this; }
    CStdioLog& operator << (unsigned long _X) { DbgPrint(_QT("%lu"), _X); return *this; }
    CStdioLog& operator << (float _X) { DbgPrint(_QT("%g"), (double)_X); return *this; }
    CStdioLog& operator << (double _X) { DbgPrint(_QT("%g"), _X); return *this; }
    CStdioLog& operator << (long double _X) { DbgPrint(_QT("%Lg"), _X); return *this; }
    CStdioLog& operator << (const void* _X) { DbgPrint(_QT("%p"), _X); return *this; }
    CStdioLog& operator << (char* _X) { DbgPrint(_QT("%s"), _X); return *this; }
    CStdioLog& operator << (const char* _X) { DbgPrint(_QT("%s"), _X); return *this; }
    CStdioLog& operator << (char _X) { DbgPrint(_QT("%c"), _X); return *this; }
    CStdioLog& operator << (const CEndl& _X) { DbgPrint(_QT("\n")); _flushall(); return *this; }
    CStdioLog& operator << (const CDiagText& x)
    { 
        DbgPrint(_QT("%s: %s (%d). "), x.m_tzText, x.m_tzFile, x.m_line); 
        if (x.m_tid)
            DbgPrint(_QT("tid(%d). "), x.m_tid);
        return *this; 
    }
#if defined(_XSTRING_) || defined(QA_DEF_QALOG_STRING_OP)
    CStdioLog& operator << (const _tstring& x)
    { DbgPrint(_QT("%s"), x.c_str()); return *this; }
#endif
};

#endif // QA_USE_IOS_LOG else QA_USE_STDIO_LOG

//
///////////////////////////////////////////////////////////////////////////
// Global Functions
///////////////////////////////////////////////////////////////////////////
//

//
// Accessor functions.
//

QADllImport int     GetMaxTestIdSize();
QADllImport char* GetTestId();
QADllImport void    SetTestId(const char* szId);


//
// Reporting results.
//

QADllImport void    ReportTest(bool bClearFail = true);
QADllImport void    ReportTC(unsigned p_tc, bool bClearFail = true);

//
// Double math functions, used with real versions Compare().
//

////////////////////////////////////////
// DAbs - calc. the absolute value of given double.
//
inline double DAbs(double p_d) {      // > double to take abs of.
    return (p_d >= 0.0) ? p_d : -p_d;
}

QADllImport double  Pow(double p_d, unsigned p_u);

//
// Compare functions, used with CheckE() and CheckNE().
//

////////////////////////////////////////
// Compare - template version, use == operator.
//

#if !defined(QA_NO_TMPL_CMP)
template <class T1, class T2> inline bool Compare(
    const T1& p_x,       // > first object to compare.
    const T2& p_y)       // > object to compare with.
{
    return p_x == p_y;
}
#endif

////////////////////////////////////////
// Compare - _TCHAR* version.
//

////////////////////////////////////////
// Compare - const _TCHAR* version.
//

inline bool Compare(
    const char* p_x,  // > src string.          
    const char* p_y)  // > string to compare to.
{
    if (p_x == NULL && p_y == NULL)
        return 1;
    if (p_x == NULL || p_y == NULL)
        return 0;
    return strcmp(p_x,p_y) == 0;
}

inline bool Compare(char* p_x,char* p_y) 
    { return Compare(_STR(p_x), _STR(p_y)); }

inline bool Compare(const char* p_x,char* p_y) 
    { return Compare(_STR(p_x), _STR(p_y)); }

inline bool Compare(char* p_x, const char* p_y) 
    { return Compare(_STR(p_x), _STR(p_y)); }


QADllImport bool     Compare(double p_val1, double p_val2);
QADllImport bool     Compare(float p_val1, float p_val2);
QADllImport bool     Compare(long double p_val1, long double p_val2);


//
// Test validation functions.
//

#ifdef QA_SIMPLE_QALIB
#define QA_ERROR_TEXT(l,f,id) DbgPrint(_QT("Error@line %d, file %s, id %d"), l, f, id);
#define QA_TRACE_TEXT(l,f,id) DbgPrint(_QT("Trace@line %d, file %s, id %d"), l, f, id);
#else
#define QA_ERROR_TEXT(l,f,id) CDiagText(_QT("Error"), l, f, id)
#define QA_TRACE_TEXT(l,f,id) CDiagText(_QT("Trace"), l, f, id)
#endif

QADllImport bool     Check(bool b, int line, const char* p_tzFile, 
                           const char* p_tzExp = _QT(""), 
                           unsigned tid = 0);

////////////////////////////////////////
// CheckE - compares 2 given values.  If not equal then print error message
//          and set error flags.
//
// Returns: true if equal, false otherwise.
//
template <class T1, class T2> bool
CheckE(const T1& p_x, const T2& p_y, int line, const char* p_tzFile, unsigned tid = 0)
{
    if (Compare(p_x,p_y))
        return true;
#ifdef QA_SIMPLE_QALIB   
    DbgPrint(_QT("CheckE failed line %d file: "), line);
    _putts(p_tzFile);
    DbgPrint(_QT("tid %d file: "), tid);
#else
    QALog << QA_ERROR_TEXT(line, p_tzFile, tid) << _QT("\"") << p_x 
          << _QT("\" != \"") << p_y << _QT("\". ") << QAEndl;
#endif// QA_SIMPLE_QALIB

    SetTCFailure();
    return false;
}

////////////////////////////////////////
// CheckNE - compares 2 given values.  If equal then print error message
//          and set error flags.
//
// Returns: 1 if not equal, 0 otherwise.
//
template <class T1, class T2> bool
CheckNE(const T1& p_x, const T2& p_y, int line, const char* p_tzFile, unsigned tid = 0)
{
    if (!Compare(p_x,p_y))
        return true;
    
#ifdef QA_SIMPLE_QALIB   
    DbgPrint(_QT("CheckE failed line %d file: "), line);
    _putts(p_tzFile);
    DbgPrint(_QT("tid %d file: "), tid);
#else
    QALog << QA_ERROR_TEXT(line, p_tzFile, tid) << _QT("\"") << p_x << _QT("\" == \"") 
          << p_y << _QT("\". ") << QAEndl;
#endif //QA_SIMPLE_QALIB
    SetTCFailure();
    return false;
}

QADllImport void    Fail(int line, const char* p_tzFile, const char* p_tzMsg = _QT(""), 
                         unsigned tid = 0);
QADllImport void    Fail(int line, const char* p_tzFile, int e, unsigned tid = 0);
QADllImport void    Trace(int line, const char* p_tzFile, const char* p_tzMsg, 
                          unsigned tid = 0);
//
// Initialization and termination.
//

QADllImport void    Init(const char* testid, bool banner = true);
QADllImport int     Terminate(bool bReportTest = true);

//
// Get/Set of error flags.
//
QADllImport void    SetTestFailure(bool b = true);
QADllImport bool    GetTestFailure();
QADllImport void    SetTCFailure(bool b = true);
QADllImport bool    GetTCFailure();
QADllImport void    ClearFailures();

//
// Set/Get delta value for float/double compare funtions.
//
QADllImport void    SetDDelta(double d);
QADllImport double  GetDDelta();
QADllImport void    SetLDDelta(long double d);
QADllImport long double GetLDDelta();
QADllImport void    SetFDelta(float d);
QADllImport float   GetFDelta();


//
///////////////////////////////////////////////////////////////////////////
// Classes.
///////////////////////////////////////////////////////////////////////////
//

//
// The following classes (CRunBase, etc.) are used with CTestMgr below
// to create a test manager appropriate to the threading style required.
// NOTE:  The test list can optionally contain initialize and terminate 
// enteries.  These functions are called before and after the tests have been
// run.  They may be called more than once in the case where a locale lists 
// is used.
// The terminate function is optional.  If it is defined then the initalize 
// entry must be specified.
// If the initialize function returns anything other than 0 then no tests
// are run and the terminate function is not called.
//

// Base class.  Keeps track of list and # of test functions.
//
class QADllImport CRunBase
{
public:
    CRunBase(TestFunc* funcs, int size)
    : m_nFuncs(size), m_pFuncs(funcs) {}

protected:
    int         m_nFuncs;       // # of test funtions.
    TestFunc*   m_pFuncs;       // list of test function pointers.

    int     Init() 
    { 
        if (!m_pFuncs[0])
            return m_pFuncs[1](0) == 0 ? !m_pFuncs[2] ? 4 : 2 : -1;
        return 0; 
    }

    void    Term() 
    {
        if (!m_pFuncs[0] && !m_pFuncs[2])
            m_pFuncs[3](0);
    }
};

#if defined(QA_USE_THREADS)

// Multi-threaded support base class.  Contains support for managing the threads
// created by the manager.
//
class QADllImport CRunMTBase : public CRunBase
{
public:
    CRunMTBase(TestFunc* funcs, int nFuncs)
        : CRunBase(funcs, nFuncs)
    {
        m_nThreads = QA_NTHREADS * m_nFuncs;
        m_threads = new HANDLE[m_nThreads];
        m_ids = new unsigned[QA_NTHREADS];
    }
    ~CRunMTBase()
    {
        delete[] m_ids;
        delete[] m_threads;
    }
    void PostRun()
    {
        DWORD ret = ::WaitForMultipleObjects(m_nThreads, m_threads, TRUE, QA_MT_TIMEOUT);
        if (ret == WAIT_TIMEOUT)
            QAFail(_QT("waiting for threads to finish timed out!"));
        else if (ret == WAIT_FAILED)
            QAFail(_QT("waiting for threads failed!"));
        for (int x = 0; x < m_nThreads; x++)
            CloseHandle(m_threads[x]);
    }

protected:
    int         m_nThreads;     // # of threads started.
    HANDLE*     m_threads;      // list of handles to threads.
    unsigned*   m_ids;          // list of thread ids.
};

struct QATestFuncRecord {
	TestFunc m_func;
	int m_test_id;
};

//#define QA_TIMES_TO_RERUN_TEST_THREAD 5000
#ifndef QA_TIMES_TO_RERUN_TEST_THREAD
#define QA_TIMES_TO_RERUN_TEST_THREAD 1
#endif

#if QA_TIMES_TO_RERUN_TEST_THREAD  > 1
static unsigned int QATestRunner(void *pv)
{
	struct QATestFuncRecord *pRun = (struct QATestFuncRecord *)pv;
	for (int k = 0; k < QA_TIMES_TO_RERUN_TEST_THREAD; k++)
	{
		(*pRun->m_func)((void*)&pRun->m_test_id);
	};
	return 0;
}
#endif

// Multi-thread version that "mixes" the order of threads relative to the
// test funtion order.  
//
class QADllImport CRunMTMix : public CRunMTBase
{
 public:
  CRunMTMix(TestFunc* funcs, int nFuncs)
        : CRunMTBase(funcs, nFuncs) {}
  int Run()
    {
#ifdef _MT
        int s = Init();
        if (s == -1)
	  return 1;
#if QA_TIMES_TO_RERUN_TEST_THREAD  > 1
	struct QATestFuncRecord *pTestRecords;
	pTestRecords = new struct QATestFuncRecord[QA_NTHREADS*m_nFuncs];
#endif

	m_nThreads = 0;

        for (int i = 0; i < QA_NTHREADS; i++)
	  for (int j = s; j < m_nFuncs; j++)
            {
	      unsigned threadID;
	      m_ids[i] = i;
#if QA_TIMES_TO_RERUN_TEST_THREAD  > 1
	      pTestRecords[j*m_nFuncs + i].m_func = m_pFuncs[j];
	      pTestRecords[j*m_nFuncs + i].m_test_id = i;
	      m_threads[m_nThreads] = 
		(HANDLE)_beginthreadex(0, 0, (TestFunc)&QATestRunner, (void*)&pTestRecords[j*m_nFuncs + i], 0, &threadID);
#else
	      m_threads[m_nThreads] = 
		(HANDLE)_beginthreadex(0, 0, m_pFuncs[j], m_ids+i, 0, &threadID);
#endif
	      if (m_threads[m_nThreads] == 0)
		{
		  QAFail(_QT("Could not spawn thread\n"));
		}
	      else
		m_nThreads++;
            }
        PostRun();
        Term();
#if QA_TIMES_TO_RERUN_TEST_THREAD  > 1
	delete[] pTestRecords;
#endif
#else // !defined(_MT)

#ifdef QA_SIMPLE_QALIB   
    DbgPrint(_QT(" Trying to execute MT test code without _MT libs!\nWe should never have gotten here.\n"));
#else
      QALog << _QT("Trying to execute MT test code without _MT libs!\nWe should never have gotten here.\n");
#endif //QA_SIMPLE_QALIB

      exit(2);
#endif
      return 0;
    }
};

// Multi-thread version that, for each test funtion, starts all threads for
// that function before moving on.
//
class QADllImport CRunMTSeq : public CRunMTBase
{
public:
    CRunMTSeq(TestFunc* funcs, int nFuncs)
        : CRunMTBase(funcs, nFuncs) {}

    int Run()
    {
#ifdef _MT
        int s = Init();
        if (s == -1)
            return 1;
	m_nThreads = 0;

        for (int j = s; j < m_nFuncs; j++)
            for (int i = 0; i < QA_NTHREADS; i++)
            {
                m_ids[i] = i;
                m_threads[m_nThreads] = 
                    (HANDLE)_beginthreadex(0, 0, m_pFuncs[j], m_ids+i, 0, 0);

		if ( m_threads[m_nThreads] )
		  m_nThreads++;
            }
        PostRun();
        Term();
#else // !defined(_MT)
#ifdef QA_SIMPLE_QALIB   
    DbgPrint(_QT("Trying to execute MT test code without _MT libs!\nWe should never have gotten here.\n"));
#else
      QALog << _QT("Trying to execute MT test code without _MT libs!\nWe should never have gotten here.\n");
#endif //QA_SIMPLE_QALIB
      exit(2);
#endif
        return 0;
    }
};

#endif // QA_USE_THREADS

// Single-thread version, just calls each test function in sequence.
//
class QADllImport CRunNoMT : public CRunBase
{
public:
    CRunNoMT(TestFunc* funcs, int nFuncs)
        : CRunBase(funcs, nFuncs) {}

    int Run()
    {
        int s = Init();
        if (s == -1)
            return 1;
        for (int i = s; i < m_nFuncs; i++)
            m_pFuncs[i](0);
        Term();
        return 0;
    }
};

// Creates an instance of the given helper class and delegates responsibility
// of running the tests to it.
//
template <class T> class CTestMgr
{
public:
    CTestMgr(T& runObj) : m_runObj(runObj) {}

#if defined(QA_USE_STRINGTABLE)
    int Run(const char* szTestId = 0,
            LocaleIdT* localeIds = s_defLocaleIds) 
#else
    int Run(const char* szTestId = 0)
#endif 
    { 
        QaLib::Init(szTestId);
#if defined(QA_USE_STRINGTABLE)
        for (int i = 0; localeIds[i]; i++)
        {
            QATrace2(_QT("Locale: "), locales[i]);
            CAutoLocale autoLocale(localeIds[i]);
            if (QACheck(autoLocale.Ok()))
                m_runObj.Run();
            else
#ifdef QA_SIMPLE_QALIB
		    DbgPrint("  Locale Not set: %s\n", localeIds[i]);
#else
                QALog << _QT("  Locale NOT set: ") << localeIds[i] << QAEndl;
#endif // QA_SIMPLE_QALIB
	}
#else
        m_runObj.Run();
#endif
        QA_TERM;
    }

    T&                  m_runObj;
#if defined(QA_USE_STRINGTABLE)
    static LocaleIdT    s_defLocaleIds[];
#endif 
};

#if defined(QA_USE_STRINGTABLE)
template <class T> LocaleIdT CTestMgr<T>::s_defLocaleIds[] = 
{ 
    QA_LC_NoChange, 
    0
};
#endif 

//
// memory check object, used in QA_BEGIN_TC.
//
#if defined(_DEBUG)
class QADllImport CMemCheck
{
public:
    CMemCheck(int line)
    : m_line(line)
    {
        QA_DISPLAY_MEM_LEAKS_STDOUT();
        _CrtMemCheckpoint(&m_memState);
    }
    ~CMemCheck()
    {
        _CrtMemState  cur;
        _CrtMemState  result;
        _CrtMemCheckpoint(&cur);
        
        if (_CrtMemDifference(&result, &m_memState, &cur ))
        {
            char buf[80];
            sprintf(buf, _QT("Error: Memory Leak in block (or testcase) starting on line: %d."), 
                      m_line);
#ifdef QA_SIMPLE_QALIB
	    DbgPrint("%s\n", buf);
#else
	    QALog << buf << QAEndl;
#endif // QA_SIMPLE_QALIB
	    SetTCFailure();
            _CrtMemDumpAllObjectsSince(&m_memState);
        }
    }

private:
    int             m_line;
    _CrtMemState    m_memState;
};

#else

class QADllImport CMemCheck
{
public:
    CMemCheck(int line) {}
    ~CMemCheck() {}
};

#endif //_DEBUG

//
// Automatically setup and cleanup a testcase.
//
class QADllImport CAutoTC
{
public:
    CAutoTC(long tc) 
        : m_tc(tc) { QaLib::SetTCFailure(false);}
    ~CAutoTC()
        { QaLib::ReportTC(m_tc); }
    long    m_tc;
};

} // QaLib

#endif // __QALIB_BASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\internat\sources.inc ===
TARGETTYPE=LIBRARY
TARGETPATH=..\..\lib

SOURCES=\
	_mbslen.c \
	_WCSICOL.C \
	localeco.c \
	mbstowcs.c \
	mbtowc.c \
	WCSCOLL.C \
	wcsftime.c \
	wcstod1.c \
	wcstod2.c \
	wcstod3.c \
	wcstol1.c \
	wcstol2.c \
	wcstol3.c \
	wcstombs.c \
	wcstoul1.c \
	wcstoul2.c \
	wcstoul3.c \
	WCSXFRM.C \
	wctomb.c \
	drv.C

INCLUDES=$(BASEDIR)\private\test\crttests\test\clib;$(SDK_INC_PATH)

MSC_WARNING_LEVEL=/W2
MSC_OPTIMIZATION=/Od

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\internat\WCSCOLL.C ===
/***************************************************************************

		   Copyright (c) 1992, Microsoft Corporation

Method:



Switches:   NONE


Abstract:   Test for: wcscoll

          int wcscoll(const wchar_t *, const wchar_t *);

OS Version:
CPU:
Dependencies:		NONE
Environment Vars:	NONE
Verification Method:	TBD
Priority:		1/2/3/4
Notes:			NONE
Products:


Revision History:

    Date	emailname   description
----------------------------------------------------------------------------
    28-May-92	xiangjun    created
----------------------------------------------------------------------------

EndHeader:

****************************************************************************/


#include <string.h>
#include <stdio.h>
#include "test.h"

static char test[] = "wcscoll";
static int perfect = 0;

static wchar_t wcs_lowest[] = L"\1";
static wchar_t wcs_highest[] = {65033,0};
static wchar_t wcs_empty[] = L"";

int WCSCOLLEntry(){

/* Begin */

   startest();

/* For C LOCALE only now */

/* Less */

   if( !(wcscoll( wcs_lowest, wcs_highest ) < 0) )
      fail( 0 );

   if( !(wcscoll( L"ABC", L"ABD" ) < 0) )
      fail( 1 );

   if( !(wcscoll( L"ABC", L"AbC" ) < 0) )
      fail( 2 );

   if( !(wcscoll( L"", L"A" ) < 0) )
      fail( 3 );


/* Greater */

   if( !(wcscoll( wcs_highest, wcs_lowest ) > 0) )
      fail( 10 );

   if( !(wcscoll( L"ABD", L"ABC" ) > 0) )
      fail( 11 );

   if( !(wcscoll( L"AbC", L"ABC" ) > 0) )
      fail( 12 );

   if( !(wcscoll( L"A", L"" ) > 0) )
      fail( 13 );

/* Equal */

   if( !(wcscoll( wcs_lowest, L"\1" ) == 0) )
      fail( 20 );

   if( !(wcscoll( wcs_highest, wcs_highest ) == 0) )
      fail( 21 );

   if( !(wcscoll( L"aBc", L"aBc" ) == 0) )
      fail( 22 );

/* end */

   finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\internat\mbstowcs.c ===
/***************************************************************************

		   Copyright (c) 1993 Microsoft Corporation

Test:	    mbstowcs

Abstract:   Verify functionality of mbstowcs in the "C" locale.

===========================================================================
Syntax

===========================================================================
Priority:		1
Products:		WIN NT

Revision History:
    Date		emailname   description
----------------------------------------------------------------------------
  03-May-93		kevinboy    created
  17-April-95           a-timke     Enabled for Mac
----------------------------------------------------------------------------

EndHeader:
****************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "test.h"

static unsigned char string[] = { "a z" };

static char 	test[] = "mbstowcs";
static int 	perfect=0;

#if defined(TEST_PMAC) || defined(TEST_M68K)

#define wcsncmp WCSNCMP
//Implement the wcscmp() function, without using APIs.
static int WCSNCMP(wchar_t *pwchS1, wchar_t *pwchS2, int nCount)
{
  if (nCount==0)
    return 0;

  while (--nCount > 0 && *pwchS1 && *pwchS2)
  {
    if (*pwchS1 != *pwchS2)
      break;
    pwchS1++;
    pwchS2++;
  }
  return *pwchS1 - *pwchS2;
}
#endif //TEST_PMAC || TEST_M68K

int mbstowcsEntry ( ){
	wchar_t		outstr[500];
	
	startest ();

	/* Verify handling of string with a char > 128 */

	string[1] = 0x82;

	if ( mbstowcs ( outstr, string, 500 ) != 3 ) 
		fail ( 26 );

	if ( ( outstr[0] != 97 ) || ( outstr[1] != 0x82 ) || ( outstr[2] != 122 ) )
		fail ( 27 );

	/* Scene 1A: Verify passing a single-byte NULL string returns the 
							necessary size */

	if ( mbstowcs ( NULL, "string1", 500 ) != 7 ) 
		fail ( 1 );

	/* Scene 1: Verify passing a wide NULL string returns the 
							necessary size */

	if ( mbstowcs ( L'\0', "string1", 500 ) != 7 ) 
		fail ( 1 );

	/* Scene 2: Verify passing a size 0 fails */

	if ( mbstowcs ( outstr, "string2", 0 ) != 0 ) 
		fail ( 2 );

	/* Scene 3: Verify passing a size of 1 passes */

	if ( mbstowcs ( outstr, "a", 1 ) != 1 ) 
		fail ( 3 );

	if ( wcsncmp ( outstr, L"a", 1 ) ) 
		fail ( 4 );

	/* Scene 4: Verify passing a size < necessary size by one passes */

	if ( mbstowcs ( outstr, "string2", 6 ) != 6 ) 
		fail ( 5 );

	if ( wcsncmp ( outstr, L"string", 6 ) ) 
		fail ( 6 );

	/* Scene 5: Pass size = necessary size works */

	if ( mbstowcs ( outstr, "string3", 7 ) != 7 ) 
		fail ( 7 );

	if ( wcsncmp ( outstr, L"string3", 7 ) ) 
		fail ( 8 );

	/* Scene 6: Pass size > necessary size by one works */

	if ( mbstowcs ( outstr, "string3", 8 ) != 7 ) 
		fail ( 9 );

	if ( wcsncmp ( outstr, L"string3", 7 ) ) 
		fail ( 10 );

	/* Scene 8: Passing a "\n" as the from string works */


	if ( mbstowcs ( outstr, "\n", 8 ) != 1 ) 
		fail ( 13 );

	if ( outstr[0] != L'\n' ) 
		fail ( 14 );

	/* Scene 9: Passing a single character works */

	if ( mbstowcs ( outstr, "a", 20 ) != 1 ) 
		fail ( 15 );

	if ( outstr[0] != L'a' ) 
		fail ( 16 );

	/* Scene 10: Passing two chars works */

	if ( mbstowcs ( outstr, "ab", 40 ) != 2 ) 
		fail ( 17 );

	if ( wcsncmp ( outstr, L"ab", 2 ) ) 
		fail ( 18 );

	/* Scene 11: Passing three chars works */

	if ( mbstowcs ( outstr, "abc", 40 ) != 3 ) 
		fail ( 19 );

	if ( wcsncmp ( outstr, L"abc", 3 ) ) 
		fail ( 20 );

	/* Scene 12: Passing a string with a NULL */

	if ( mbstowcs ( outstr, "foo\0", 500 ) != 3 ) 
		fail ( 21 );

	if ( wcsncmp ( outstr, L"foo\0", 4 ) ) 
		fail ( 22 );

	/* Scene 13: Passing a large string works */

	if ( mbstowcs ( outstr, "abcdefghijklmnopqrstuvwxyz1234abcdefghijklmnopqrstuvwxyz1234abcdefghijklmnopqrstuvwxyz1234abcdefghijklmnopqrstuvwxyz1234abcdefghijklmnopqrstuvwxyz1234", 500 ) != 150 ) 
		fail ( 23 );

	if ( wcsncmp ( outstr, L"abcdefghijklmnopqrstuvwxyz1234abcdefghijklmnopqrstuvwxyz1234abcdefghijklmnopqrstuvwxyz1234abcdefghijklmnopqrstuvwxyz1234abcdefghijklmnopqrstuvwxyz1234", 150 ) ) 
		fail ( 24 );

	/* Scene 14: Passing a large string containing "\n" works */

	if ( mbstowcs ( outstr, "abcdefghijklmnopqrstuvwxyz1234\nabcdefghijklmnopqrstuvwxyz1234abcdefghijklmnopqrstuvwxyz1234abcdefghijklmnopqrstuvwxyz1234abcdefghijklmnopqrstuvwxyz1234", 500 ) != 151 ) 
		fail ( 25 );

	if ( wcsncmp ( outstr, L"abcdefghijklmnopqrstuvwxyz1234\nabcdefghijklmnopqrstuvwxyz1234abcdefghijklmnopqrstuvwxyz1234abcdefghijklmnopqrstuvwxyz1234abcdefghijklmnopqrstuvwxyz1234", 151 ) ) 
		fail ( 26 );

	finish ();

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\internat\mbtowc.c ===
/***************************************************************************

		   Copyright (c) 1993 Microsoft Corporation

Test:	    mbtowc

Abstract:   Verify functionality of mbtowc in the "C" locale.

===========================================================================
Syntax

===========================================================================
Priority:		1
Products:		WIN NT

Revision History:
    Date		emailname   description
----------------------------------------------------------------------------
  03-May-93		kevinboy    created
  17-April-95           a-timke     Enabled for Mac
----------------------------------------------------------------------------

EndHeader:
****************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "test.h"

static char 	test[] = "mbtowc";
static int 	perfect=0;

#if defined(TEST_PMAC) || defined(TEST_M68K)

#define wcsncmp WCSNCMP
//Implement the wcscmp() function, without using APIs.
static int WCSNCMP(wchar_t *pwchS1, wchar_t *pwchS2, int nCount)
{
  if (nCount==0)
    return 0;

  while (--nCount > 0 && *pwchS1 && *pwchS2)
  {
    if (*pwchS1 != *pwchS2)
      break;
    pwchS1++;
    pwchS2++;
  }
  return *pwchS1 - *pwchS2;
}
#endif //TEST_PMAC || TEST_M68K

int mbtowcEntry ( ){
	wchar_t			outstr[50];
	unsigned int	tmp;

	startest ();

	/* Scene 1A: Verify passing a single-byte NULL string returns one */

	if ( mbtowc ( NULL, "s", 1 ) != 1 ) 
		fail ( 1 );

	/* Scene 1: Verify passing a wide NULL string returns one */

	if ( mbtowc ( L'\0', "s", 1 ) != 1 ) 
		fail ( 1 );

	/* Scene 3: Passing a "\n" as the from string works */

	if ( mbtowc ( outstr, "\n", 1 ) != 1 ) 
		fail ( 3 );

	if ( outstr[0] != L'\n' ) 
		fail ( 4 );

	/* Scene 4: Passing a single character works */

	if ( mbtowc ( outstr, "a", 1 ) != 1 ) 
		fail ( 5 );

	if ( outstr[0] != L'a' ) 
		fail ( 6 );

	/* Scene 5: Passing two chars works */

	if ( mbtowc ( outstr, "ab", 1 ) != 1 ) 
		fail ( 7 );

	if ( wcsncmp ( outstr, L"a", 1 ) ) 
		fail ( 8 );

	/* Verify 0 is returned if mbchar is NULL */

	if ( mbtowc ( outstr, '\0', 1 ) != 0 ) 
		fail ( 20 );

	if ( mbtowc ( outstr, NULL, 1 ) != 0 ) 
		fail ( 21 );

// Repeat the above with count > 1

	/* Scene 1A: Verify passing a single-byte NULL string returns the 
							necessary size */

	if ( mbtowc ( NULL, "s", 20 ) != 1 ) 
		fail ( 9 );

	/* Scene 1: Verify passing a wide NULL string returns the 
							necessary size */

	if ( mbtowc ( L'\0', "s", 20 ) != 1 ) 
		fail ( 10 );

	/* Scene 3: Passing a "\n" as the from string works */

	if ( mbtowc ( outstr, "\n", 20 ) != 1 ) 
		fail ( 12 );

	if ( outstr[0] != L'\n' ) 
		fail ( 13 );

	/* Scene 4: Passing a single character works */

	if ( mbtowc ( outstr, "a", 20 ) != 1 ) 
		fail ( 14 );

	if ( outstr[0] != L'a' ) 
		fail ( 15 );

	/* Scene 5: Passing two chars works */

	if ( mbtowc ( outstr, "ab", 20 ) != 1 ) 
		fail ( 16 );

	if ( wcsncmp ( outstr, L"a", 1 ) ) 
		fail ( 17 );

	/* Verify 0 is returned if mbchar is NULL */

	if ( mbtowc ( outstr, '\0', 20 ) != 0 ) 
		fail ( 22 );

	if ( mbtowc ( outstr, NULL, 20 ) != 0 ) 
		fail ( 23 );

// With a count of zero

	if ( mbtowc ( outstr, "s", 0 ) != 0 ) 
		fail ( 18 );

	/* Verify 
	if ( mbtowc ( outstr, "s", 0 ) != -1 ) 
		fail ( 18 );

	/* Verify 0 is returned if mbchar is NULL */

	if ( mbtowc ( outstr, '\0', 0 ) != 0 ) 
		fail ( 24 );

	if ( mbtowc ( outstr, NULL, 0 ) != 0 ) 
		fail ( 25 );

	/* Attempt with a char > 128 */

	tmp = 0x82;

	if ( mbtowc ( outstr, (char *)&tmp, 1 ) != 1  )
		fail ( 26 );

	if ( outstr[0] != 0x82 )
		fail ( 27 );

	finish ();

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\internat\wcstod1.c ===
/***************************************************************************

		   Copyright (c) 1992, Microsoft Corporation

Method:



Switches:   NONE


Abstract:   Test for: wcstod

          double wcstod(const wchar_t *nptr, wchar_t **endptr);

OS Version:
CPU:
Dependencies:		NONE
Environment Vars:	NONE
Verification Method:	TBD
Priority:		1/2/3/4
Notes:			NONE
Products:


Revision History:

    Date	emailname   description
----------------------------------------------------------------------------
    27-Jan-93	xiangjun    created
----------------------------------------------------------------------------

EndHeader:

****************************************************************************/


#include <string.h>
#include <wchar.h>
#include <math.h>
#include <float.h>
#include <errno.h>
#include "test.h"

#define STRINGIZE0(x) L#x
#define STRINGIZE(x) STRINGIZE0(x)


static char test[] = "wcstod";
static int perfect = 0;

typedef struct {
   wchar_t * string;
   double expected;
   } DATA;

static DATA data1[] = {
                L" \f\n\r\t\v123456.789final string", 123456.789,
                L" \f\n\r\t\v+123456.789final string", 123456.789,
                L" \f\n\r\t\v-123456.789final string", -123456.789,

                L" \f\n\r\t\v" STRINGIZE(DBL_MAX) L"final string", DBL_MAX,
                L" \f\n\r\t\v" STRINGIZE(-DBL_MAX) L"final string", -DBL_MAX,
                L" \f\n\r\t\v" STRINGIZE(DBL_MIN) L"final string", DBL_MIN,
                L" \f\n\r\t\v" STRINGIZE(-DBL_MIN) L"final string", -DBL_MIN,

                L" \f\n\r\t\v-4.000000e+000final string", -4.0,
                L" \f\n\r\t\v4.000000E+000final string", 4.0,
                L" \f\n\r\t\v-6.85E+001final string", -68.5,
                L" \f\n\r\t\v-7.45E+001final string", -74.5,
                L" \f\n\r\t\v 6.7844324e+004final string", 67844.324,
                L" \f\n\r\t\v  +6.7844324e+004final string", 67844.324,
                L" \f\n\r\t\v    0.000000e+000final string", 0.0,
                L" \f\n\r\t\v-00007.4673e-001final string", -0.74673,

                L"-4.000000final string", -4.0,
                L"4.000000final string", 4.0,
                L"0.400000final string",  0.4,
                L"-69final string", -69,
                L"-74final string", -74.,
                L" 67844.324final string", 67844.324,
                L"   +67844.324final string", 67844.324,
                L"         0.000000final string", 0.0,
                L"-0000000000.74673final string", -0.74673,
                };

static DATA data2[] = {
                L" \f\n\r\t\v0.0009", 0.0009,

                L" \f\n\r\t\v3.1415926535E-005", 0.000031415926535,
                L" \f\n\r\t\v0.00031415926535", 0.00031415926535,
                L" \f\n\r\t\v0.0031415926535", 0.0031415926535,
                L" \f\n\r\t\v0.031415926535", 0.031415926535,
                L" \f\n\r\t\v0.31415926535", 0.31415926535,
                L" \f\n\r\t\v3.1415926535", 3.1415926535,
                L" \f\n\r\t\v31.415926535", 31.415926535,
                L" \f\n\r\t\v314.15926535", 314.15926535,
                L" \f\n\r\t\v3141.5926535", 3141.5926535,
                L" \f\n\r\t\v31415.926535", 31415.926535,
                L" \f\n\r\t\v314159.26535", 314159.26535,
                L" \f\n\r\t\v3.1415926535e+006", 3141592.6535,
                L" \f\n\r\t\v3", 3.0,
                L" \f\n\r\t\v3e+006", 3000000.0,
                L" \f\n\r\t\v   3.1402", 3.1402,
                L" \f\n\r\t\v 3.1402", 3.1402,
                L" \f\n\r\t\v+0023.000", 23.0,
                L" \f\n\r\t\v23.", 23.0,
                L" \f\n\r\t\v23",  23.0,
                };

static DATA specialData[] = {
                L" \f\n\r\t\v", 0,
                L"", 0,
                L" \f\n\r\t\vhello3.1415926535", 0,
                L"hello3.1415926535", 0,
                L"?3.1415926535", 0,
                L" \f\n\r\t\v-+123456.789final string", 0,
                };






int wcstod1Entry(){
int i;
wchar_t * endptr;

/* Begin */

   startest();


/* with final string */

for( i = 0; i < sizeof(data1)/sizeof(data1[0]); i++ ) {

   if( data1[i].expected != wcstod( data1[i].string, &endptr )
      ||
       endptr != wcsstr(data1[i].string, L"final string" ) )
{
      fail( 1 );
DbgPrint( "%g %g", wcstod( data1[i].string, &endptr ), data1[i].expected );
}
   }

/* without final string */

for( i = 0; i < sizeof(data2)/sizeof(data2[0]); i++ ) {

   if( data2[i].expected != wcstod( data2[i].string, &endptr )
      ||
       endptr != data2[i].string+wcslen( data2[i].string ) )
      fail( 12 );
   }

/* without sequence string */

for( i = 0; i < sizeof(specialData)/sizeof(specialData[0]); i++ ) {

   if( specialData[i].expected != wcstod( specialData[i].string, &endptr ) 
       ||
       endptr != specialData[i].string )
      fail( 2 );
}

/* out of range */

errno = 0;

if( wcstod( L"123456789e500", &endptr ) != HUGE_VAL
   ||
    errno != ERANGE )
   fail( 3 );

errno = 0;

if( wcstod( L"-123456789e500", &endptr ) != -HUGE_VAL
   ||
    errno != ERANGE )
   fail( 4 );

errno = 0;

if( wcstod( L"-123456789e-500", &endptr ) != 0
   ||
    errno != ERANGE )
   fail( 5 );

/* NULL endptr */

if( wcstod( L"-123456789", NULL ) != -123456789 )
   fail( 6 );

   finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\internat\wcstod2.c ===
/***************************************************************************

           Copyright (c) 1993, Microsoft Corporation

Method:



Switches:   NONE


Abstract:   Test for: wcstod in a non-C locale.  
            Test that wcstod handles characters in a non-c locale
            by setting LC_NUMERIC and checking the radix character.

OS Version:
CPU:
Dependencies:       NONE
Environment Vars:   NONE
Verification Method:    EXECUTE
Priority:       1/2/3/4
Notes:          NONE
Products:


Revision History:

    Date    emailname   description
----------------------------------------------------------------------------
    02-Nov-93   patlo    Created by copying wcstod.c
----------------------------------------------------------------------------

EndHeader:

****************************************************************************/

#include <locale.h>
#include <string.h>
#include <wchar.h>
#include <math.h>
#include <float.h>
#include "test.h"


static char test[] = "wcstod1";
static int perfect = 0;

static void compare (double, double, int testno);


int wcstod2Entry(){
    double d_result;

    startest();

    if ( setlocale ( LC_NUMERIC, "French") == NULL)
    { 
        fail (10);
        finish();
    }

    d_result = wcstod ( L"3,5", NULL);
/*  
    Note, if wcstod doesn't respond to a non-c locale, it's likely that
    d_result will contain 3 instead of 3.5
*/
    compare ( d_result, 3.5, 1 );

    finish();
}



void compare (double f1, double f2, int testno)
{
    if (fabs(f1-f2)>=0.01) 
    {
        printf("Was:       \"%lf\"\nShould be: \"%lf\"\n", f1, f2);
        fail( testno );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\internat\localeco.c ===
/***************************************************************************

                   Copyright (c) 1994 Microsoft Corporation


Test:           localeco.c

Abstract:       Verify the localconv() function returns the correct values.


===========================================================================
Syntax

===========================================================================
Priority:               1
Products:               WIN NT


Revision History:

    Date        emailname       description
----------------------------------------------------------------------------
    10-05-94    a-timke         created
    11-17-94    a-timke         Fixed n_sign_posn test.
    02-27-95    a-timke         Modified to reflect ANSI implementation
                                of 'grouping' and 'mon_grouping'.
----------------------------------------------------------------------------

EndHeader:

****************************************************************************/
#include <stdio.h>
#include <string.h>
#include <locale.h>
#include "test.h"

#ifdef _WIN64

#define CHECK(e)  if (!(e))\
   {printf("  %s(%d): %s (%I64)\n", __FILE__, __LINE__, #e, (__int64)e); return 1;}
#define CHECKE(e, r)  if ((e)!=(r))\
   {printf("  %s(%d): %s != %s (%I64 != %I64)\n", __FILE__, __LINE__, #e, #r, (__int64)e, (__int64)r); return 1;}
#define CHECKNE(e, r) if ((e)==(r))\
   {printf("  %s(%d): %s == %s (%I64 != %I64)\n", __FILE__, __LINE__, #e, #r, (__int64)e, (__int64)r); return 1;}

#else

#define CHECK(e)  if (!(e))\
   {printf("  %s(%d): %s (%d)\n", __FILE__, __LINE__, #e, e); return 1;}
#define CHECKE(e, r)  if ((e)!=(r))\
   {printf("  %s(%d): %s != %s (%d != %d)\n", __FILE__, __LINE__, #e, #r, e, r); return 1;}
#define CHECKNE(e, r) if ((e)==(r))\
   {printf("  %s(%d): %s == %s (%d != %d)\n", __FILE__, __LINE__, #e, #r, e, r); return 1;}

#endif 

static int perfect = 0;
static char test[] = __FILE__;

#if DEBUG
static void ViewLocale(void)
{
  struct lconv *p = localeconv();

  printf("decimal_point     = <%s>\n", p->decimal_point);
  printf("thoushands_sp     = <%s>\n", p->thousands_sep);
  printf("grouping          = <%s>\n", p->grouping);
  printf("curr_symbol       = <%s>\n", p->int_curr_symbol);
  printf("currency_symbol   = <%s>\n", p->currency_symbol);
  printf("mon_decimal_point = <%s>\n", p->mon_decimal_point);
  printf("mon_thousands_sep = <%s>\n", p->mon_thousands_sep);
  printf("mon_grouping      = <%s>\n", p->mon_grouping);
  printf("positive_sign     = <%s>\n", p->positive_sign);
  printf("negative_sign     = <%s>\n", p->negative_sign);
  printf("int_frac_digits   = <%d>\n", p->int_frac_digits&0xff);
  printf("frac_digits       = <%d>\n", p->frac_digits&0xff);
  printf("p_cs_precedes     = <%d>\n", p->p_cs_precedes&0xff);
  printf("p_sep_by_space    = <%d>\n", p->p_sep_by_space&0xff);
  printf("n_cs_precedes     = <%d>\n", p->n_cs_precedes&0xff);
  printf("n_sep_by_space    = <%d>\n", p->n_sep_by_space&0xff);
  printf("p_sign_posn       = <%d>\n", p->p_sign_posn&0xff);
  printf("n_sign_posn       = <%d>\n", p->n_sign_posn&0xff);
}
#endif

//Verify "C" locale values.
static int localeconvV1(void)
{
  struct lconv *pLc = localeconv();

  CHECKE(strcmp(pLc->decimal_point,     "."), 0);
  CHECKE(strcmp(pLc->thousands_sep,     ""), 0);
  CHECKE(strcmp(pLc->grouping,          ""), 0);
  CHECKE(strcmp(pLc->int_curr_symbol,   ""), 0);
  CHECKE(strcmp(pLc->currency_symbol,   ""), 0);
  CHECKE(strcmp(pLc->mon_decimal_point, ""), 0);
  CHECKE(strcmp(pLc->mon_thousands_sep, ""), 0);
  CHECKE(strcmp(pLc->mon_grouping,      ""), 0);
  CHECKE(strcmp(pLc->positive_sign,     ""), 0);
  CHECKE(strcmp(pLc->negative_sign,     ""), 0);
  CHECKE(pLc->int_frac_digits&0xff,      127);
  CHECKE(pLc->frac_digits&0xff,          127);
  CHECKE(pLc->p_cs_precedes&0xff,        127);
  CHECKE(pLc->p_sep_by_space&0xff,       127);
  CHECKE(pLc->n_cs_precedes&0xff,        127);
  CHECKE(pLc->n_sep_by_space&0xff,       127);
  CHECKE(pLc->p_sign_posn&0xff,          127);
  CHECKE(pLc->n_sign_posn&0xff,          127);

  return 0;
}

//Verify US locale values, category=LC_ALL.
static int localeconvV2(void)
{
  struct lconv *pLc;

  CHECKNE(setlocale(LC_ALL, "C"), NULL);
  CHECKE(localeconvV1(), 0);
  CHECKNE(setlocale(LC_ALL,  "English_United States.OCP"), NULL);
  pLc = localeconv();

  CHECKE(strcmp(pLc->decimal_point,     "."),   0);
  CHECKE(strcmp(pLc->thousands_sep,     ","),   0);
  CHECKE(strcmp(pLc->grouping,          "\3"),  0);
  CHECKE(strcmp(pLc->int_curr_symbol,   "USD"), 0);
  CHECKE(strcmp(pLc->currency_symbol,   "$"),   0);
  CHECKE(strcmp(pLc->mon_decimal_point, "."),   0);
  CHECKE(strcmp(pLc->mon_thousands_sep, ","),   0);
  CHECKE(strcmp(pLc->mon_grouping,      "\3"),  0);
  CHECKE(strcmp(pLc->positive_sign,     ""),    0);
  CHECKE(strcmp(pLc->negative_sign,     "-"),   0);
  CHECKE(pLc->int_frac_digits&0xff,      2);
  CHECKE(pLc->frac_digits&0xff,          2);
  CHECKE(pLc->p_cs_precedes&0xff,        1);
  CHECKE(pLc->p_sep_by_space&0xff,       0);
  CHECKE(pLc->n_cs_precedes&0xff,        1);
  CHECKE(pLc->n_sep_by_space&0xff,       0);
  CHECKE(pLc->p_sign_posn&0xff,          3);
  CHECKE(pLc->n_sign_posn&0xff,          0);

  return 0;
}

//Verify US locale values, category=LC_MONETARY.
static int localeconvV3(void)
{
  struct lconv *pLc;

  CHECKNE(setlocale(LC_ALL, "C"), NULL);
  CHECKE(localeconvV1(), 0);
  CHECKNE(setlocale(LC_MONETARY,  "English_United States.OCP"), NULL);
  pLc = localeconv();

  CHECKE(strcmp(pLc->decimal_point,     "."),   0);
  CHECKE(strcmp(pLc->thousands_sep,     ""),    0);
  CHECKE(strcmp(pLc->grouping,          ""),    0);
  CHECKE(strcmp(pLc->int_curr_symbol,   "USD"), 0);
  CHECKE(strcmp(pLc->currency_symbol,   "$"),   0);
  CHECKE(strcmp(pLc->mon_decimal_point, "."),   0);
  CHECKE(strcmp(pLc->mon_thousands_sep, ","),   0);
  CHECKE(strcmp(pLc->mon_grouping,      "\3"),  0);
  CHECKE(strcmp(pLc->positive_sign,     ""),    0);
  CHECKE(strcmp(pLc->negative_sign,     "-"),   0);
  CHECKE(pLc->int_frac_digits&0xff,      2);
  CHECKE(pLc->frac_digits&0xff,          2);
  CHECKE(pLc->p_cs_precedes&0xff,        1);
  CHECKE(pLc->p_sep_by_space&0xff,       0);
  CHECKE(pLc->n_cs_precedes&0xff,        1);
  CHECKE(pLc->n_sep_by_space&0xff,       0);
  CHECKE(pLc->p_sign_posn&0xff,          3);
  CHECKE(pLc->n_sign_posn&0xff,          0);

  return 0;
}

//Verify US locale values, category=LC_NUMERIC.
static int localeconvV4(void)
{
  struct lconv *pLc;

  CHECKNE(setlocale(LC_ALL, "C"), NULL);
  CHECKE(localeconvV1(), 0);
  CHECKNE(setlocale(LC_NUMERIC,  "English_United States.OCP"), NULL);
  pLc = localeconv();

  CHECKE(strcmp(pLc->decimal_point,     "."),   0);
  CHECKE(strcmp(pLc->thousands_sep,     ","),   0);
  CHECKE(strcmp(pLc->grouping,          "\3"),  0);
  CHECKE(strcmp(pLc->int_curr_symbol,   ""),    0);
  CHECKE(strcmp(pLc->currency_symbol,   ""),    0);
  CHECKE(strcmp(pLc->mon_decimal_point, ""),    0);
  CHECKE(strcmp(pLc->mon_thousands_sep, ""),    0);
  CHECKE(strcmp(pLc->mon_grouping,      ""),    0);
  CHECKE(strcmp(pLc->positive_sign,     ""),    0);
  CHECKE(strcmp(pLc->negative_sign,     ""),    0);
  CHECKE(pLc->int_frac_digits&0xff,      127);
  CHECKE(pLc->frac_digits&0xff,          127);
  CHECKE(pLc->p_cs_precedes&0xff,        127);
  CHECKE(pLc->p_sep_by_space&0xff,       127);
  CHECKE(pLc->n_cs_precedes&0xff,        127);
  CHECKE(pLc->n_sep_by_space&0xff,       127);
  CHECKE(pLc->p_sign_posn&0xff,          127);
  CHECKE(pLc->n_sign_posn&0xff,          127);

  return 0;
}

//Verify Swedish locale values, category=LC_ALL.
static int localeconvV5(void)
{
  struct lconv *pLc;

  CHECKNE(setlocale(LC_ALL, "C"), NULL);
  CHECKE(localeconvV1(), 0);
  CHECKNE(setlocale(LC_ALL,  "Swedish"), NULL);
  pLc = localeconv();

  CHECKE(strcmp(pLc->decimal_point,     ","),    0);
  CHECKE(strcmp(pLc->thousands_sep,     "\xa0"), 0);
  CHECKE(strcmp(pLc->grouping,          "\3"),   0);
  CHECKE(strcmp(pLc->int_curr_symbol,   "SEK"),  0);
  CHECKE(strcmp(pLc->currency_symbol,   "kr"),   0);
  CHECKE(strcmp(pLc->mon_decimal_point, ","),    0);
#if 1 /*!defined(TEST_WIN95)*/
  CHECKE(strcmp(pLc->mon_thousands_sep, "."), 0); //QA: "\xa0"
#else
  CHECKE(strcmp(pLc->mon_thousands_sep, "\xa0"), 0); //QA: "\xa0"
#endif
  CHECKE(strcmp(pLc->mon_grouping,      "\3"),   0);
  CHECKE(strcmp(pLc->positive_sign,     ""),     0);
  CHECKE(strcmp(pLc->negative_sign,     "-"),    0);
  CHECKE(pLc->int_frac_digits&0xff,      2);
  CHECKE(pLc->frac_digits&0xff,          2);
  CHECKE(pLc->p_cs_precedes&0xff,        0);
  CHECKE(pLc->p_sep_by_space&0xff,       1);
  CHECKE(pLc->n_cs_precedes&0xff,        0);
  CHECKE(pLc->n_sep_by_space&0xff,       1);
  CHECKE(pLc->p_sign_posn&0xff,          1);
  CHECKE(pLc->n_sign_posn&0xff,          1);

  return 0;
}

#if defined(_M_M68K) || defined(_M_MPPC)
int localecoEntry(void){
  startest();
  checke(localeconvV1(), 0);
  checke(localeconvV2(), 1);
  checke(localeconvV3(), 1);
  checke(localeconvV4(), 1);
  checke(localeconvV5(), 1);
  finish();
}
#else
int localecoEntry(void){
  startest();
  checke(localeconvV1(), 0);
  checke(localeconvV2(), 0);
  checke(localeconvV3(), 0);
  checke(localeconvV4(), 0);
  checke(localeconvV5(), 0);
  finish();
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\internat\wcsftime.c ===
/***************************************************************************

		   Copyright (c) 1993 Microsoft Corporation

Method: Arrays of test data.  Loop through the arrays.


Switches:   NONE


Abstract:   This test is mainly a check to see that all of formats are 
	recognized. It also runs through all months and days (abbreviated 
	and long forms) to see that they are correct.

	4 dates were chosen for initial test version- 2 during non-leap years 
	and 2 during leap years. Additional tests require additions to 
	descriptions array (the expected output) and the test array (which 
	defines the tm structure sent to the function strftime()). A better 
	and more complete test would call time() and localtime(), generate 
	the expected information and check it against information returned 
	by strftime().

	If future versions of strftime() add additional formats, changes need 
	to be made to the formats array, descriptions array and the test array.


===========================================================================
Syntax

===========================================================================
OS Version:
CPU:
Dependencies:           
Environment Vars:       
Verification Method:    
Priority:               1
Notes:                  
Products:               WIN NT


Revision History:

    Date        emailname   description
----------------------------------------------------------------------------
    20-Jun-1989 mrw         created
    21-Aug-1991 xc          change void main() to int main() to
    22-Mar-93   kevinboy    ported f_strftm.c
    9-Jul-1993  a-marca     added putenv call to set timezone.
    29-Dec-1994 a-timke     Fixed parameter type mismatch for wcsftime().

----------------------------------------------------------------------------

EndHeader:

****************************************************************************/

#include <stdio.h>
#include <time.h>
#include <string.h>
#include "test.h"
#include <wchar.h>



#define BUFF_SIZE   128
#define NUM_MONTHS   12
#define NUM_DAYS      7

static wchar_t *short_months[12]= {
		       L"Jan",
		       L"Feb",
		       L"Mar",
		       L"Apr",
		       L"May",
		       L"Jun",
		       L"Jul",
		       L"Aug",
		       L"Sep",
		       L"Oct",
		       L"Nov",
		       L"Dec"
		      };
static wchar_t *long_months[12] = {
		       L"January",
		       L"February",
		       L"March",
		       L"April",
		       L"May",
		       L"June",
		       L"July",
		       L"August",
		       L"September",
		       L"October",
		       L"November",
		       L"December"
		      };
static wchar_t *short_days[7] = {
		       L"Sun",
		       L"Mon",
		       L"Tue",
		       L"Wed",
		       L"Thu",
		       L"Fri",
		       L"Sat"
		     };

static wchar_t *long_days[7] = {
		       L"Sunday",
		       L"Monday",
		       L"Tuesday",
		       L"Wednesday",
		       L"Thursday",
		       L"Friday",
		       L"Saturday"
		     };

static wchar_t *formats[] = {
		    L"%a",
		    L"%A",
		    L"%b",
		    L"%B",
		    L"%c",
		    L"%d",
		    L"%H",
		    L"%I",
		    L"%j",
		    L"%m",
		    L"%M",
		    L"%p",
		    L"%S",
		    L"%U",
		    L"%w",
		    L"%W",
		    L"%x",
		    L"%X",
		    L"%y",
		    L"%Y",
		    L"%z"
		   };

#define ARRAY_SIZE sizeof(formats)/sizeof(char *)

static wchar_t *descriptions[][ARRAY_SIZE]=

{
 { L"Tue",L"Tuesday",L"Jan",L"January",L"01/01/99 00:00:59",L"01",L"00",L"12",
 L"001",L"01",L"00",L"AM",L"59",L"00",L"2",
 L"00",L"01/01/99",L"00:00:59",L"99",L"1999",L"PST"
 },

/* 1st day after feb 29, 1996 */
 {
 L"Fri",L"Friday",L"Mar",L"March",L"03/01/96 23:59:59",L"01",L"23",L"11",
 L"061",L"03",L"59",L"PM",L"59",L"08",L"5",
 L"09",L"03/01/96",L"23:59:59",L"96",L"1996",L"PST"
 },

/* last day of a leap year in the next century */
 {
 L"Wed",L"Wednesday",L"Dec",L"December",L"12/31/08 12:01:30",L"31",L"12",L"12",
 L"366",L"12",L"01",L"PM",L"30",L"52",L"3",
 L"52",L"12/31/08",L"12:01:30",L"08",L"2008",L"PST"
 },

 {
 L"Sun",L"Sunday",L"Jun",L"June",L"06/15/91 01:15:55",L"15",L"01",L"01",
 L"166",L"06",L"15",L"AM",L"55",L"24",L"0",
 L"23",L"06/15/91",L"01:15:55",L"91",L"1991",L"PDT"
 }


} ;



struct tm test_array[] = {
				{ 59 , 0  , 0  , 1  , 0  , 99 , 2 , 0  , 0 },
				{ 59 , 59 , 23 , 1  , 2  , 96 , 5 , 60 , 0 },
				{ 30 , 01 , 12 , 31 , 11 , 108, 3 , 365, 0 },
				{ 55 , 15 , 1  , 15 , 5  , 91 , 0 , 165, 1 }
			       };

#define NUM_TESTS sizeof(test_array)/sizeof(struct tm)


static int perfect;
static char test[] = "wcsftime";

int wcsftimeEntry(void);
int wcsftimeEntry( void ){
  wchar_t buff[BUFF_SIZE];
  int i,j;


  startest();
  
  // set the time zone
  _putenv("TZ=PST8PDT");
  _tzset();	//To register time zone

  for (j = 0 ; j < NUM_TESTS ; j++)
   for (i = 0 ; i < ARRAY_SIZE ; i++ )
    {
      wcsftime(buff,BUFF_SIZE,formats[i],&test_array[j]);
      if (wcscmp(buff,descriptions[j][i]) != 0)
	{
	DbgPrint ( "\n\nexpected = %ls\nactual = %ls\n", descriptions[j][i], buff );
       faill();
	}
    }
      wcsftime(buff,BUFF_SIZE,L"%%",&test_array[j]);
      if (wcscmp(buff,L"%") != 0)
       faill();

 for ( i = 0 ; i <  NUM_MONTHS ; i++ )
  {
   test_array[0].tm_mon = i;
   wcsftime(buff,BUFF_SIZE,L"%b",&test_array[0]);
   if (wcscmp(buff,short_months[i]) != 0 )
	faill();

   wcsftime(buff,BUFF_SIZE,L"%B",&test_array[0]);
   if (wcscmp(buff,long_months[i]) != 0 )
	faill();
  }
 for ( i = 0 ; i <  NUM_DAYS ; i++  )
  {
   test_array[1].tm_wday = i;
   wcsftime(buff,BUFF_SIZE,L"%a",&test_array[1]);
   if (wcscmp(buff,short_days[i]) != 0 )
	faill();

   wcsftime(buff,BUFF_SIZE,L"%A",&test_array[1]);
   if (wcscmp(buff,long_days[i]) != 0 )
	faill();
  }
 finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\internat\wcstod3.c ===
/***************************************************************************

           Copyright (c) 1993, Microsoft Corporation

Method:



Switches:   NONE


Abstract:   Test for: wcstod in a non-C locale.  
            Test that wcstod handles characters > 127.

OS Version:
CPU:
Dependencies:       NONE
Environment Vars:   NONE
Verification Method:    EXECUTE
Priority:       1/2/3/4
Notes:          NONE
Products:


Revision History:

    Date    emailname   description
----------------------------------------------------------------------------
    03-Nov-93   patlo    Created by copying wcstod1.c
----------------------------------------------------------------------------

EndHeader:

****************************************************************************/

#include <locale.h>
#include <string.h>
#include <wchar.h>
#include <math.h>
#include <float.h>
#include "test.h"


static char test[] = "wcstod2";
static int perfect = 0;



int wcstod3Entry(){
    double d_result;

    startest();

    if ( setlocale ( LC_ALL, "French") == NULL)
    { 
        fail (10);
        finish();
    }

    d_result = wcstod ( L"3,5", NULL);

    finish();
}



void compare (double f1, double f2, int testno)
{
    if (fabs(f1-f2)>=0.01) 
    {
        DbgPrint("Was:       \"%lf\"\nShould be: \"%lf\"\n", f1, f2);
        fail( testno );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\internat\wcstol3.c ===
/***************************************************************************

           Copyright (c) 1993, Microsoft Corporation

Method:



Switches:   NONE


Abstract:   Test for: wcstol in a non-C locale.  
            Test that wcstol handles characters in a non-c locale
            by setting LC_NUMERIC and checking the radix character.

OS Version:
CPU:
Dependencies:       NONE
Environment Vars:   NONE
Verification Method:    EXECUTE
Priority:       1/2/3/4
Notes:          NONE
Products:


Revision History:

    Date    emailname   description
----------------------------------------------------------------------------
    03-Nov-93   patlo    Created by copying wcstod1.c
----------------------------------------------------------------------------

EndHeader:

****************************************************************************/

#include <locale.h>
#include <string.h>
#include <wchar.h>
#include <float.h>
#include "test.h"


static char test[] = "wcstol2";
static int perfect = 0;

static void compare (long, long, int testno);

int wcstol3Entry(){
    long l_result;

    startest();

    if ( setlocale ( LC_NUMERIC, "French") == NULL)
    { 
        fail (10);
        finish();
    }

    l_result = wcstol ( L"3,5", NULL, 10);

    compare ( l_result, 3, 1 );

    finish();
}



void compare (long f1, long f2, int testno)
{
    if (f1 != f2) 
    {
        DbgPrint("Was:       \"%l\"\nShould be: \"%l\"\n", f1, f2);
        fail( testno );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\internat\wcstol2.c ===
/***************************************************************************

           Copyright (c) 1993, Microsoft Corporation

Method:



Switches:   NONE


Abstract:   Test for: wcstol in a non-C locale.  
            Test that wcstol handles characters in a non-c locale
            by setting LC_NUMERIC and checking the radix character.

OS Version:
CPU:
Dependencies:       NONE
Environment Vars:   NONE
Verification Method:    EXECUTE
Priority:       1/2/3/4
Notes:          NONE
Products:


Revision History:

    Date    emailname   description
----------------------------------------------------------------------------
    03-Nov-93   patlo    Created by copying wcstod1.c
----------------------------------------------------------------------------

EndHeader:

****************************************************************************/

#include <locale.h>
#include <string.h>
#include <wchar.h>
#include <float.h>
#include "test.h"


static char test[] = "wcstol1";
static int perfect = 0;

static void compare (long, long, int testno);

int wcstol2Entry(){
    long l_result;

    startest();

    if ( setlocale ( LC_NUMERIC, "French") == NULL)
    { 
        fail (10);
        finish();
    }

    l_result = wcstol ( L"3,5", NULL, 10);

    compare ( l_result, 3, 1 );

    finish();
}



void compare (long f1, long f2, int testno)
{
    if (f1 != f2) 
    {
        printf("Was:       \"%l\"\nShould be: \"%l\"\n", f1, f2);
        fail( testno );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\internat\wcstoul2.c ===
/***************************************************************************

           Copyright (c) 1993, Microsoft Corporation

Method:



Switches:   NONE


Abstract:   Test for: wcstoul in a non-C locale.  
            Test that wcstoul handles characters in a non-c locale
            by setting LC_NUMERIC and checking the radix character.

OS Version:
CPU:
Dependencies:       NONE
Environment Vars:   NONE
Verification Method:    EXECUTE
Priority:       1/2/3/4
Notes:          NONE
Products:


Revision History:

    Date    emailname   description
----------------------------------------------------------------------------
    03-Nov-93   patlo    Created by copying wcstod1.c
----------------------------------------------------------------------------

EndHeader:

****************************************************************************/

#include <locale.h>
#include <string.h>
#include <wchar.h>
#include <float.h>
#include "test.h"


static char test[] = "wcstoul1";
static int perfect = 0;

static void compare (unsigned long, unsigned long, int testno);

int wcstoul2Entry(){
    unsigned long l_result;

    startest();

    if ( setlocale ( LC_NUMERIC, "French") == NULL)
    { 
        fail (10);
        finish();
    }

    l_result = wcstoul ( L"3,5", NULL, 10);

    compare ( l_result, 3, 1 );

    finish();
}



void compare (unsigned long f1, unsigned long f2, int testno)
{
    if (f1 != f2) 
    {
        printf("Was:       \"%lu\"\nShould be: \"%lu\"\n", f1, f2);
        fail( testno );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\internat\wcstoul1.c ===
/***************************************************************************

		   Copyright (c) 1992, Microsoft Corporation

Method:



Switches:   NONE


Abstract:   Test for: wcstoul

          unsigned long int wcstoul(const wchar_t *nptr, wchar_t **endptr, int base);

OS Version:
CPU:
Dependencies:		NONE
Environment Vars:	NONE
Verification Method:	TBD
Priority:		1/2/3/4
Notes:			NONE
Products:


Revision History:

    Date	emailname   description
----------------------------------------------------------------------------
    28-Jan-93	xiangjun    created
----------------------------------------------------------------------------

EndHeader:

****************************************************************************/


#include <string.h>
#include <wchar.h>
#include <math.h>
#include <limits.h>
#include <errno.h>
#include "test.h"

#define STRINGIZE0(x) L#x
#define STRINGIZE1(x) STRINGIZE0(x)
#define STRINGIZE(x) STRINGIZE1(x)

static char test[] = "wcstoul";
static int perfect = 0;

typedef struct {
   wchar_t * string;
   unsigned long int expected;
   int base;
   } DATA;

static DATA data1[] = {
                L" \f\n\r\t\v123456unsigned long constant", 123456, 0,
                L" \f\n\r\t\v+123456unsigned long constant", 123456, 0,
                L" \f\n\r\t\v-123456unsigned long constant", -123456, 0,
                L" \f\n\r\t\v" STRINGIZE(ULONG_MAX) L"unsigned long constant", ULONG_MAX, 0,
                L" \f\n\r\t\v" STRINGIZE(-ULONG_MAX) L"unsigned long constant", -ULONG_MAX, 0,


                L" \f\n\r\t\v123456unsigned long constant", 123456, 10,
                L" \f\n\r\t\v+123456unsigned long constant", 123456, 10,
                L" \f\n\r\t\v-123456unsigned long constant", -123456, 10,

                L" \f\n\r\t\v0x123456unsigned long constant", 0x123456, 0,
                L" \f\n\r\t\v+0X123456unsigned long constant", 0x123456, 0,
                L" \f\n\r\t\v-0x123456unsigned long constant", -0X123456, 0,


                L" \f\n\r\t\v0x123456unsigned long constant", 0x123456, 16,
                L" \f\n\r\t\v+0X123456unsigned long constant", 0x123456, 16,
                L" \f\n\r\t\v-0x123456unsigned long constant", -0X123456, 16,
                L" \f\n\r\t\v" STRINGIZE(ULONG_MAX) L"unsigned long constant", ULONG_MAX, 16,
                L" \f\n\r\t\v" STRINGIZE(-ULONG_MAX) L"unsigned long constant", -ULONG_MAX, 16,
                };


static DATA data2[] = {
                L" \f\n\r\t\v123456", 123456, 0,
                L" \f\n\r\t\v+123456", 123456, 0,
                L" \f\n\r\t\v-123456", -123456, 0,
                L" \f\n\r\t\v" STRINGIZE(ULONG_MAX), ULONG_MAX, 0,
                L" \f\n\r\t\v" STRINGIZE(-ULONG_MAX), -ULONG_MAX, 0,


                L" \f\n\r\t\v123456", 123456, 10,
                L" \f\n\r\t\v+123456", 123456, 10,
                L" \f\n\r\t\v-123456", -123456, 10,

                L" \f\n\r\t\v0x123456", 0x123456, 0,
                L" \f\n\r\t\v+0X123456", 0x123456, 0,
                L" \f\n\r\t\v-0x123456", -0X123456, 0,

                L" \f\n\r\t\v0x123456", 0x123456, 16,
                L" \f\n\r\t\v+0X123456", 0x123456, 16,
                L" \f\n\r\t\v-0x123456", -0X123456, 16,
                };

                
static DATA specialData[] = {
                L" \f\n\r\t\v", 0, 2,
                L"", 0, 3,
                L" \f\n\r\t\vhello3.1415926535", 0, 4,
                L"hello3.1415926535", 0, 5,
                L"?3.1415926535", 0, 6,
                L" \f\n\r\t\v-+123456unsigned long constant", 0, 0,
                };
int wcstoul1Entry(){
int i;
wchar_t * endptr;
unsigned long int ulong_number;
wchar_t ulong_number_string[33];

/* Begin */

   startest();


/* with final string */

for( i = 0; i < sizeof(data1)/sizeof(data1[0]); i++ ) {

   if( data1[i].expected != wcstoul( data1[i].string, &endptr, data1[i].base ))
   {
      fail( 1 );
   }
   else
   {
      //Adjust comparison for 'UL' in LIMITS constants
      if (*endptr == (wchar_t)'U' && *++endptr == (wchar_t)'L')
        endptr++;

      if (endptr != wcsstr(data1[i].string, L"unsigned long constant" ) )
      {
        fail( 1 );
      }
   }
}

/* without final string */

for( i = 0; i < sizeof(data2)/sizeof(data2[0]); i++ ) {

   if( data2[i].expected != wcstoul( data2[i].string, &endptr, data2[i].base ))
   {
     fail( 12 );
   }
   else
   {
      //Adjust comparison for 'UL' in LIMITS constants
      if (*endptr == (wchar_t)'U' && *++endptr == (wchar_t)'L')
        endptr++;

      if (endptr != data2[i].string+wcslen( data2[i].string ) )
	fail( 12 );
   }
}

/* without sequence string */

for( i = 0; i < sizeof(specialData)/sizeof(specialData[0]); i++ ) {

   if( specialData[i].expected != wcstoul( specialData[i].string, &endptr, specialData[i].base ) 
       ||
       endptr != specialData[i].string )
      fail( 2 );
}

/* out of range */

errno = 0;

if( wcstoul( STRINGIZE(ULONG_MAX), &endptr, 16 ) != ULONG_MAX 
   ||
    errno != 0 )
   fail( 3 );

errno = 0;

if(
//    wcstoul( L"4294967296", &endptr, 10 ) != ULONG_MAX
    wcstoul( L"4294967296", &endptr, 10 ) != ULONG_MAX
   ||
    errno != ERANGE )
   fail( 31 );

errno = 0;

if( wcstoul( STRINGIZE(-ULONG_MAX), &endptr, 16 ) != -ULONG_MAX
   ||
    errno != 0 )
   fail( 4 );

if(
    wcstoul( L"-4294967296", &endptr, 10 ) != -ULONG_MAX
   ||
    errno != ERANGE )
   fail( 41 );

errno = 0;

/* NULL endptr */

if( wcstoul( L"-123456789", NULL, 10 ) != -123456789 )
   fail( 5 );


/* test for number base 2-32 */

ulong_number = ULONG_MAX;

for( i = 2; i < 33; i++ ) {

   unsigned long int ul;
   int j;
   int remainder;

   for( ul = ulong_number, j = 0 ;
        ul > 0;
         ) {
      remainder = ul%i;
      ul/=i;

      ulong_number_string[j] =  remainder < 10 ?
                               remainder+'0' : remainder-10+'a';
      j++;
      }

   ulong_number_string[j] = 0;

   _wcsrev( ulong_number_string );

   if( wcstoul( ulong_number_string, &endptr, i ) != ulong_number ) {
      fail(6);
      DbgPrint( "failed when base = %d\n", i );
      DbgPrint( "wcstoul() = %xuld, from %xuld\n", wcstoul( ulong_number_string, &endptr, i ), ulong_number );
      }
   }
  

   finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\internat\wcstol1.c ===
/***************************************************************************

		   Copyright (c) 1992, Microsoft Corporation

Method:



Switches:   NONE


Abstract:   Test for: wcstol

	  long int wcstol(const wchar_t *nptr, wchar_t **endptr, int base);

OS Version:
CPU:
Dependencies:           NONE
Environment Vars:       NONE
Verification Method:    TBD
Priority:               1/2/3/4
Notes:                  NONE
Products:


Revision History:

    Date        emailname   description
----------------------------------------------------------------------------
    28-Jan-93   xiangjun    created
----------------------------------------------------------------------------
    27-May-93   a-marca     changed out of range -2147483648 to -2147483649
			    for call wcstol( L"", &endptr, 10 ) != LONG_MIN
----------------------------------------------------------------------------

						     
EndHeader:

****************************************************************************/

#include <string.h>
#include <wchar.h>
#include <math.h>
#include <limits.h>
#include <errno.h>
#include "test.h"

/* MAY CHANGE IN FUTURE RELEASESES, hard-coded to get this test to run */
#define ABS_LONG_MIN    2147483648

#define STRINGIZE0(x) L#x
#define STRINGIZE1(x) STRINGIZE0(x)
#define STRINGIZE(x) STRINGIZE1(x)

static char test[] = "wcstol";
static int perfect = 0;

typedef struct {
   wchar_t * string;
   long expected;
   int base;
   } DATA;

static DATA data1[] = {
		L" \f\n\r\t\v123456long constant", 123456, 0,
		L" \f\n\r\t\v+123456long constant", 123456, 0,
		L" \f\n\r\t\v-123456long constant", -123456, 0,
		L" \f\n\r\t\v" STRINGIZE(LONG_MAX) L"long constant", LONG_MAX, 0,
		L" \f\n\r\t\v" STRINGIZE(-ABS_LONG_MIN) L"long constant", LONG_MIN, 0,


		L" \f\n\r\t\v123456long constant", 123456, 10,
		L" \f\n\r\t\v+123456long constant", 123456, 10,
		L" \f\n\r\t\v-123456long constant", -123456, 10,
		L" \f\n\r\t\v" STRINGIZE(LONG_MAX) L"long constant", LONG_MAX, 10,
		L" \f\n\r\t\v" STRINGIZE(-ABS_LONG_MIN) L"long constant", LONG_MIN, 10,

		L" \f\n\r\t\v0x123456long constant", 0x123456, 0,
		L" \f\n\r\t\v+0X123456long constant", 0x123456, 0,
		L" \f\n\r\t\v-0x123456long constant", -0X123456, 0,


		L" \f\n\r\t\v0x123456long constant", 0x123456, 16,
		L" \f\n\r\t\v+0X123456long constant", 0x123456, 16,
		L" \f\n\r\t\v-0x123456long constant", -0X123456, 16,
		};


static DATA data2[] = {
		L" \f\n\r\t\v123456", 123456, 0,
		L" \f\n\r\t\v+123456", 123456, 0,
		L" \f\n\r\t\v-123456", -123456, 0,
		L" \f\n\r\t\v" STRINGIZE(LONG_MAX), LONG_MAX, 0,
		L" \f\n\r\t\v" STRINGIZE(-ABS_LONG_MIN), LONG_MIN, 0,


		L" \f\n\r\t\v123456", 123456, 10,
		L" \f\n\r\t\v+123456", 123456, 10,
		L" \f\n\r\t\v-123456", -123456, 10,
		L" \f\n\r\t\v" STRINGIZE(LONG_MAX), LONG_MAX, 10,
		L" \f\n\r\t\v" STRINGIZE(-ABS_LONG_MIN), LONG_MIN, 10,

		L" \f\n\r\t\v0x123456", 0x123456, 0,
		L" \f\n\r\t\v+0X123456", 0x123456, 0,
		L" \f\n\r\t\v-0x123456", -0X123456, 0,

		L" \f\n\r\t\v0x123456", 0x123456, 16,
		L" \f\n\r\t\v+0X123456", 0x123456, 16,
		L" \f\n\r\t\v-0x123456", -0X123456, 16,
		};

		
static DATA specialData[] = {
		L" \f\n\r\t\v", 0, 2,
		L"", 0, 3,
		L" \f\n\r\t\vhello3.1415926535", 0, 4,
		L"hello3.1415926535", 0, 5,
		L"?3.1415926535", 0, 6,
		L" \f\n\r\t\v-+123456long constant", 0, 0,
		};

int wcstol1Entry(){
int i;
wchar_t * endptr;
long int long_number;
wchar_t long_number_string[32];

/* Begin */

   startest();

/* with final string */

for( i = 0; i < sizeof(data1)/sizeof(data1[0]); i++ ) {

   if( data1[i].expected != wcstol( data1[i].string, &endptr, data1[i].base ))
   {
      fail( 1 );
   }
   else
   {
      //Adjust comparison for 'L' in LIMITS constants
      if (*endptr == (wchar_t)'L')
        endptr++;

      if (endptr != wcsstr(data1[i].string, L"long constant" ) )
      {
        fail( 1 );
      }
   }
}

/* without final string */

for( i = 0; i < sizeof(data2)/sizeof(data2[0]); i++ ) {

   if( data2[i].expected != wcstol( data2[i].string, &endptr, data2[i].base ))
   {
     fail( 12 );
   }
   else
   {
      //Adjust comparison for 'L' in LIMITS constants
      if (*endptr == (wchar_t)'L')
        endptr++;

      if (endptr != data2[i].string+wcslen( data2[i].string ) )
	fail( 12 );
   }
}

/* without sequence string */

for( i = 0; i < sizeof(specialData)/sizeof(specialData[0]); i++ ) {

   if( specialData[i].expected != wcstol( specialData[i].string, &endptr, specialData[i].base ) 
       ||
       endptr != specialData[i].string )
      fail( 2 );
}

/* out of range */

errno = 0;

if( wcstol( STRINGIZE(LONG_MAX), &endptr, 10 ) != LONG_MAX 
   ||
    errno != 0
   ||
    wcstol( L"2147483649", &endptr, 10 ) != LONG_MAX
   ||
    errno != ERANGE )
   fail( 3 );

errno = 0;

if( wcstol( STRINGIZE(-ABS_LONG_MIN), &endptr, 10 ) != LONG_MIN
   ||
    errno != 0
   ||
    wcstol( L"-2147483649", &endptr, 10 ) != LONG_MIN
   ||
    errno != ERANGE )
   fail( 4 );

errno = 0;

/* NULL endptr */

if( wcstol( L"-123456789", NULL, 10 ) != -123456789 )
   fail( 5 );


/* test for number base 2-32 */

long_number = LONG_MAX;

for( i = 2; i < 33; i++ ) {

   long l;
   int j;
   int remainder;

   for( l = long_number, j = 0 ;
	l > 0;
	 ) {
      remainder = l%i;
      l/=i;

      long_number_string[j] =  remainder < 10 ?
			       remainder+'0' : remainder-10+'a';
      j++;
      }

   long_number_string[j] = 0;

   _wcsrev( long_number_string );

   if( wcstol( long_number_string, &endptr, i ) != long_number ) {
      fail(6);
      printf( "failed when base = %d\n", i );
      printf( "wcstol() = %ld, from %ld\n",
	 wcstol( long_number_string, &endptr, i ),
	 long_number );
      }
    
   }
  

   finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\internat\wcstoul3.c ===
/***************************************************************************

           Copyright (c) 1993, Microsoft Corporation

Method:



Switches:   NONE


Abstract:   Test for: wcstol in a non-C locale.  
            Test that wcstol handles characters in a non-c locale
            by setting LC_NUMERIC and checking the radix character.

OS Version:
CPU:
Dependencies:       NONE
Environment Vars:   NONE
Verification Method:    EXECUTE
Priority:       1/2/3/4
Notes:          NONE
Products:


Revision History:

    Date    emailname   description
----------------------------------------------------------------------------
    03-Nov-93   patlo    Created by copying wcstod1.c
----------------------------------------------------------------------------

EndHeader:

****************************************************************************/

#include <locale.h>
#include <string.h>
#include <wchar.h>
#include <float.h>
#include "test.h"


static char test[] = "wcstoul2";
static int perfect = 0;

static void compare (unsigned long, unsigned long, int testno);

int wcstoul3Entry(){
    unsigned long l_result;

    startest();

    if ( setlocale ( LC_NUMERIC, "French") == NULL)
    { 
        fail (10);
        finish();
    }

    l_result = wcstol ( L"3,5", NULL, 10);

    compare ( l_result, 3, 1 );

    finish();
}



void compare (unsigned long f1, unsigned long f2, int testno)
{
    if (f1 != f2) 
    {
        DbgPrint("Was:       \"%lu\"\nShould be: \"%lu\"\n", f1, f2);
        fail( testno );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\internat\wcstombs.c ===
/***************************************************************************

		   Copyright (c) 1993 Microsoft Corporation

Test:	    wcstombs

Abstract:   Verify functionality of wcstombs in the "C" locale.

===========================================================================
Syntax

===========================================================================
Priority:		1
Products:		WIN NT

Revision History:
    Date		emailname   description
----------------------------------------------------------------------------
  03-May-93		kevinboy    created
----------------------------------------------------------------------------

EndHeader:
****************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <locale.h>
#include "test.h"

static wchar_t string[] = { L"a z" };

static char 	test[] = "wcstombs";
static int 	perfect=0;

int wcstombsEntry ( ){
	char		outstr[500];
	
	startest ();

	/* Verify case where a char in the string is > 128 */
	string[1] = 0x82;

	if ( wcstombs ( outstr, string, 50 ) != 3 )
		fail ( 27 );

	if ( ( outstr[0] != 'a' ) || ( outstr[1] != '\x82' ) || ( outstr[2] != 'z' ) )
		fail ( 28 );

	/* Scene 1: Verify passing a NULL string returns the necessary size */

	if ( wcstombs ( NULL, L"string1", 500 ) != 7 ) 
		fail ( 1 );

	/* Scene 2: Verify passing a size 0 fails */

	if ( wcstombs ( outstr, L"string1", 0 ) != 0 ) 
		fail ( 2 );

	/* Scene 3: Verify passing a size of 1 passes */

	if ( wcstombs ( outstr, L"a", 1 ) != 1 ) 
		fail ( 3 );

	if ( strncmp ( outstr, "a", 1 ) ) 
		fail ( 4 );

	/* Scene 4: Verify passing a size < necessary size by one passes */

	if ( wcstombs ( outstr, L"string2", 6 ) != 6 ) 
		fail ( 5 );

	if ( strncmp ( outstr, "string", 6 ) ) 
		fail ( 6 );

	/* Scene 5: Pass size = necessary size works */

	if ( wcstombs ( outstr, L"string3", 7 ) != 7 ) 
		fail ( 7 );

	if ( strncmp ( outstr, "string3", 7 ) ) 
		fail ( 8 );

	/* Scene 6: Pass size > necessary size by one works */

	if ( wcstombs ( outstr, L"string3", 8 ) != 7 ) 
		fail ( 9 );

	if ( strncmp ( outstr, "string3", 7 ) ) 
		fail ( 10 );

	/* Scene 7: Passing null as the from string works */

	if ( wcstombs ( outstr, L"\0", 8 ) != 0 ) 
		fail ( 11 );

	if ( outstr[0] != '\0' ) 
		fail ( 12 );

	/* Scene 8: Passing a "\n" as the from string works */

	if ( wcstombs ( outstr, L"\n", 8 ) != 1 ) 
		fail ( 13 );

	if ( outstr[0] != '\n' ) 
		fail ( 14 );

	/* Scene 9: Passing a single character works */

	if ( wcstombs ( outstr, L"a", 20 ) != 1 ) 
		fail ( 15 );

	if ( outstr[0] != 'a' ) 
		fail ( 16 );

	/* Scene 10: Passing two chars works */

	if ( wcstombs ( outstr, L"ab", 40 ) != 2 ) 
		fail ( 17 );

	if ( strncmp ( outstr, "ab", 2 ) ) 
		fail ( 18 );

	/* Scene 11: Passing three chars works */

	if ( wcstombs ( outstr, L"abc", 40 ) != 3 ) 
		fail ( 19 );

	if ( strncmp ( outstr, "abc", 3 ) ) 
		fail ( 20 );

	/* Scene 12: Passing a large string works */

	if ( wcstombs ( outstr, L"foo\0", 500 ) != 3 ) 
		fail ( 21 );

	if ( strncmp ( outstr, "foo\0", 4 ) ) 
		fail ( 22 );

	/* Scene 13: Passing a large string works */

	if ( wcstombs ( outstr, L"abcdefghijklmnopqrstuvwxyz1234abcdefghijklmnopqrstuvwxyz1234abcdefghijklmnopqrstuvwxyz1234abcdefghijklmnopqrstuvwxyz1234abcdefghijklmnopqrstuvwxyz1234", 500 ) != 150 ) 
		fail ( 23 );

	if ( strncmp ( outstr, "abcdefghijklmnopqrstuvwxyz1234abcdefghijklmnopqrstuvwxyz1234abcdefghijklmnopqrstuvwxyz1234abcdefghijklmnopqrstuvwxyz1234abcdefghijklmnopqrstuvwxyz1234", 150 ) ) 
		fail ( 24 );

	/* Scene 14: Passing a large string containing a "\n" works */

	if ( wcstombs ( outstr, L"abcdefghijklmnopqrstuvwxyz1234\nabcdefghijklmnopqrstuvwxyz1234abcdefghijklmnopqrstuvwxyz1234abcdefghijklmnopqrstuvwxyz1234abcdefghijklmnopqrstuvwxyz1234", 500 ) != 151 ) 
		fail ( 25 );

	if ( strncmp ( outstr, "abcdefghijklmnopqrstuvwxyz1234\nabcdefghijklmnopqrstuvwxyz1234abcdefghijklmnopqrstuvwxyz1234abcdefghijklmnopqrstuvwxyz1234abcdefghijklmnopqrstuvwxyz1234", 151 ) ) 
		fail ( 26 );

	finish ();

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\internat\wctomb.c ===
/***************************************************************************

		   Copyright (c) 1993 Microsoft Corporation

Test:	    wctomb

Abstract:   Verify functionality of wctomb in the "C" locale.

===========================================================================
Syntax

===========================================================================
Priority:		1
Products:		WIN NT

Revision History:
    Date		emailname   description
----------------------------------------------------------------------------
  03-May-93		kevinboy    created
----------------------------------------------------------------------------

EndHeader:
****************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "test.h"

static char 	test[] = "wctomb";
static int 	perfect=0;

int wctombEntry ( ){
	char		outstr;
	wchar_t		in;	


	startest ();

	/* Verify for char > 128 */
	in = 0x82;
	if ( wctomb ( &outstr, in ) != 1 )
		fail ( 7 );

	if ( outstr != '\x82' )
		fail ( 8 );

	/* Scene 1: Passing null as the from string works */

	if ( wctomb ( &outstr, '\0' ) != 1 ) 
		fail ( 2 );

	/* Scene 2: Passing a L"\n" as the from string works */

	if ( wctomb ( &outstr, L'\n' ) != 1 ) 
		fail ( 3 );

	if ( outstr != '\n' ) 
		fail ( 4 );

	/* Scene 3: Passing a single character works */

	if ( wctomb ( &outstr, L'a' ) != 1 ) 
		fail ( 5 );

	if ( outstr != 'a' ) 
		fail ( 6 );

	finish ();

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\internat\WCSXFRM.C ===
/***************************************************************************

		   Copyright (c) 1992, Microsoft Corporation

Method:



Switches:   NONE


Abstract:   Test for: wcsxfrm

          wchar_t * wcsxfrm(const wchar_t *, const wchar_t *, size_t);

OS Version:
CPU:
Dependencies:		NONE
Environment Vars:	NONE
Verification Method:	TBD
Priority:		1/2/3/4
Notes:			NONE
Products:


Revision History:

    Date	emailname   description
----------------------------------------------------------------------------
    28-May-92	xiangjun    created
----------------------------------------------------------------------------

EndHeader:

****************************************************************************/


#include <string.h>
#include <stdio.h>
#include "test.h"

static char test[] = "wcsxfrm";
static int perfect = 0;

static wchar_t wcs_string0[100];
static wchar_t wcs_string1[] = {1,65033,L'A',L'z',0};
static wchar_t wcs_string2[] = L"ABCDEFGH['ijklmnopqrstuvwxyz";


int WCSXFRMEntry(){

int i, n;

/* Begin */

   startest();

/* testing for C LOCALE for now */

   n =  (int)wcsxfrm( wcs_string0, wcs_string1, 30 );
   i = 0;
   while( wcs_string1[i] ) {
      if( wcs_string0[i] !=  wcs_string1[i] )
         fail( i );
      i++;
      }
   if( n != i )
      fail( 100 );

   n = (int)wcsxfrm( wcs_string0, wcs_string1, 0 );
   if( n != i )
      fail( 200 );

   n = (int)wcsxfrm( wcs_string0, wcs_string2, 100 );
   i = 0;
   while( wcs_string2[i] ) {
      if( wcs_string0[i] !=  wcs_string2[i] )
         fail( i+300 );
      i++;
      }
   if( n != i )
      fail( 300 );


   n = (int)wcsxfrm( wcs_string0, wcs_string2, 13 );
   if( n != i )
      fail( 400 );


/* end */

   finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\internat\_WCSICOL.C ===
/***************************************************************************

		   Copyright (c) 1992, Microsoft Corporation

Method:



Switches:   NONE


Abstract:   Test for: _wcsicoll

          int _wcsicoll(const wchar_t *, const wchar_t *);

OS Version:
CPU:
Dependencies:		NONE
Environment Vars:	NONE
Verification Method:	TBD
Priority:		1/2/3/4
Notes:			NONE
Products:


Revision History:

    Date	emailname   description
----------------------------------------------------------------------------
    28-May-92	xiangjun    created
----------------------------------------------------------------------------

EndHeader:

****************************************************************************/


#include <string.h>
#include <stdio.h>
#include "test.h"

static char test[] = "_wcsicoll";
static int perfect = 0;

static wchar_t wcs_lowest[] = L"\1";
static wchar_t wcs_highest[] = {65033, 0};
static wchar_t wcs_empty[] = L"";

int _WCSICOLEntry(){

/* for C LOCATE only for now */

/* Begin */

   startest();

/* Less */

   if( !(_wcsicoll( wcs_lowest, wcs_highest ) < 0) )
      fail( 0 );

   if( !(_wcsicoll( L"ABC", L"ABD" ) < 0) )
      fail( 1 );

   if( !(_wcsicoll( L"AB[", L"ABC" ) < 0) )
      fail( 2 );

   if( !(_wcsicoll( L"ab[", L"abc" ) < 0) )
      fail( 3 );

   if( !(_wcsicoll( L"", L"A" ) < 0) )
      fail( 4 );


/* Greater */

   if( !(_wcsicoll( wcs_highest, wcs_lowest ) > 0) )
      fail( 10 );

   if( !(_wcsicoll( L"ABD", L"ABC" ) > 0) )
      fail( 11 );

   if( !(_wcsicoll( L"ABC", L"AB`" ) > 0) )
      fail( 12 );

   if( !(_wcsicoll( L"abc", L"ab`" ) > 0) )
      fail( 13 );

   if( !(_wcsicoll( L"A", L"" ) > 0) )
      fail( 14 );

/* Equal */

   if( !(_wcsicoll( wcs_lowest, L"\1" ) == 0) )
      fail( 20 );

   if( !(_wcsicoll( wcs_highest, wcs_highest ) == 0) )
      fail( 21 );

   if( !(_wcsicoll( L"aBc", L"aBc" ) == 0) )
      fail( 22 );

/* end */

   finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\signal\drv.c ===
#include <xtl.h>

int e_sig1Entry();
int f_sig1Entry();
int f_sig2Entry();
int f_sig3Entry();
int i_sig1Entry();
int i_sig2Entry();


#ifdef __cplusplus
extern "C"
#endif
void __cdecl signalStartTest()
{
	e_sig1Entry();
	f_sig1Entry();
	f_sig2Entry();
	f_sig3Entry();
	i_sig1Entry();
	i_sig2Entry();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\internat\_mbslen.c ===
/***************************************************************************

		   Copyright (c) 1993 Microsoft Corporation

Method: Calling the function with the test string.


Switches:   NONE


Abstract:   Test for _mbstrlen under the "C" locale.
	    (There are no muliple byte characters under the "C" locale
	    so this test just verifies the single byte functionality 
	    works.)


===========================================================================
Syntax

===========================================================================
OS Version:
CPU:
Dependencies:           
Environment Vars:       
Verification Method:    
Priority:               1
Notes:                  
Products:               WIN NT


Revision History:

    Date        emailname   description
----------------------------------------------------------------------------
    17-Mar-93   kevinboy    created
----------------------------------------------------------------------------

EndHeader:

****************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include "test.h"

static char test[] = "_mbslen";
static int perfect;

int _mbslenEntry ( ){

	char    zero [1] = { '\0' };
	char    one [2] = { 'a', '\0' };
	char    two [3] = { 'a', 'b', '\0' };
	char    three [4] = { 'a', 'b', 'c', '\0' };

	unsigned int great[] = { 0x82 };

	startest();

	if ( _mbstrlen ( zero ) != 0 )
		fail( 0 );

	if (  _mbstrlen ( one ) != 1 )
		fail( 1 );
	
	if (  _mbstrlen ( two ) != 2 )
		fail( 3 );

	if (  _mbstrlen ( three ) != 3 )
		fail( 4 );

	if ( _mbstrlen ( (char *)great ) != 1 )
		fail( 5 );

	finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\signal\e_sig1.c ===
/*****************************************************************************
 *									     *
 * Test Name: e_sig1.c    Date: 1/29/91   Author: Microsoft                  *
 *===========================================================================*
 *									     *
 * Suite: signal                                                             *
 *===========================================================================*
 *									     *
 * Tested Op/Func: signal						     *
 *---------------------------------------------------------------------------*
 * PURPOSE: Tests that signal returns SIG_ERR when given an invalid value.   *
 *									     *
 * METHOD:                                                                   *
 *                                                                           *
 * MEMORY MODEL(S):                                                          *
 *      32-bit								     *
 * COMPILE/LINK OPTIONS:                                                     *
 *      No restrictions.                                                     *
 * OPERATING SYSTEM(S):                                                      *
 *      NT.  								     *
 * HARDWARE:                                                                 *	
 *      No restrictions                                                      *
 * SOFTWARE:                                                                 *
 *      No restrictions                                                      *
 * CONFIG.SYS:                                                               *
 *      Should contain what is required for compiler/linker                  *
 * ENVIRONMENT VARIABLES:                                                    *
 *      Should contain what is required for compiler/linker                  *
 *---------------------------------------------------------------------------*
 * TEST-RESULT OUTPUT: The outputs for this test shall be as follows:        *
 *      Normal: ***** PASSED *****                                           *
 *      Error:  ----- FAILED -----                                           *
 *---------------------------------------------------------------------------*
 * MODIFICATION HISTORY:                                                     *
 *                                                                           *
 *  Date       Initials Version PTR #   Description                          *
 *  ---------  -------- ------- ------- -------------------------------------*
 *  1/29/91    SDK      1.00                                                 *
 *									     *
 *****************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <test.h>

static int sigtypes[] = { SIGABRT, SIGBREAK, SIGFPE, SIGILL,
	           SIGINT,  SIGSEGV,  SIGTERM };

#define NUM_SIG_TYPES ( sizeof(sigtypes) / sizeof(int) )

static int  find_sig_entry(int sigid);

static int T(perfect) = PDV(0);

static char test[] = "e_sig1";

static void __cdecl myhandler(int sigid);

int e_sig1Entry(void){
	int i, counter = 0;

	startest();

	/* Try some positive numbers. */

	for ( i = 0; i < 100; i++ ){

	    /* skip if valid. */

	    if ( find_sig_entry(i) >= 0 )
		continue;

	    /* try invalid value. */

	    if ( signal(i, myhandler) != SIG_ERR )
		fail(i);
	}

	/* Try some negative numbers. */

	for ( i = -100; i < 0; i++ ){

	    /* skip if valid. */

	    if ( find_sig_entry(i) >= 0 )
		continue;

	    /* try invalid value. */

	    if ( signal(i, myhandler) != SIG_ERR )
		fail(200+i);
	}
	
	/* Try very big and very small. */

	if ( signal(0x7fffffff, myhandler) != SIG_ERR )
	    fail(300);

	if ( signal(0x80000000, myhandler) != SIG_ERR )
	    fail(301);
	
	finish();
}

static int find_sig_entry(int sigid)
{
	int i;

	for ( i = 0; i < NUM_SIG_TYPES; i++ )
	    if ( sigtypes[i] == sigid )
		return(i);

	return(-1);
}

static void __cdecl myhandler(int sigid)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\signal\f_sig1.c ===
/*****************************************************************************
 *									     *
 * Test Name: sig1.c    Date: 1/29/91   Author: Microsoft                    *
 *===========================================================================*
 *									     *
 * Suite: signal                                                             *
 *===========================================================================*
 *									     *
 * Tested Op/Func: signal						     *
 *---------------------------------------------------------------------------*
 * PURPOSE: Basic sanity check of functionality of signal.  Will verify that *
 *	    a signal handler can be installed for each type of exception     *
 *	    supported, and that the handler will be called for each time     *
 *	    that signal is raised via the raise() function.  It will also    *
 *	    implicitly verify that execution resumes after the raise when    *
 *	    the handler returns.					     *
 *									     *
 * METHOD:                                                                   *
 *                                                                           *
 * MEMORY MODEL(S):                                                          *
 *      32-bit								     *
 * COMPILE/LINK OPTIONS:                                                     *
 *      No restrictions.                                                     *
 * OPERATING SYSTEM(S):                                                      *
 *      NT.  								     *
 * HARDWARE:                                                                 *	
 *      No restrictions                                                      *
 * SOFTWARE:                                                                 *
 *      No restrictions                                                      *
 * CONFIG.SYS:                                                               *
 *      Should contain what is required for compiler/linker                  *
 * ENVIRONMENT VARIABLES:                                                    *
 *      Should contain what is required for compiler/linker                  *
 *---------------------------------------------------------------------------*
 * TEST-RESULT OUTPUT: The outputs for this test shall be as follows:        *
 *      Normal: ***** PASSED *****                                           *
 *      Error:  ----- FAILED -----                                           *
 *---------------------------------------------------------------------------*
 * MODIFICATION HISTORY:                                                     *
 *                                                                           *
 *  Date       Initials Version PTR #   Description                          *
 *  ---------  -------- ------- ------- -------------------------------------*
 *  1/29/91    SDK      1.00                                                 *
 *									     *
 *****************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <test.h>

static int sigtypes[] = { SIGABRT, SIGBREAK, SIGFPE, SIGILL,
	           SIGINT,  SIGSEGV,  SIGTERM };

#define NUM_SIG_TYPES ( sizeof(sigtypes) / sizeof(int) )

static int handled[NUM_SIG_TYPES] = { 0 };

static void __cdecl myhandler(int sigid);
static int  find_sig_entry(int sigid);

static int perfect = 0;

static char test[] = "f_sig1";

int f_sig1Entry(void){
	int i, counter = 0;

	startest();

	/* Install the handler for each type of signal. */

	for ( i = 0; i < NUM_SIG_TYPES; i++ )
	    if ( signal(sigtypes[i], myhandler) == SIG_ERR )
		fail(10+i);

	/* Raise each type of signal. */

	for ( i = 0; i < NUM_SIG_TYPES; i++ ){
	    if ( raise(sigtypes[i]) != 0 )
		fail(20+i);
	    else
		counter++;
	}

	/* Verify recovery ocurred for each exception raised. */

	if ( counter != NUM_SIG_TYPES )
	    fail(2);

	finish();
}

static void __cdecl myhandler(int sigid)
{
	int entry;

	if ( (entry = find_sig_entry(sigid)) < 0 )
	    fail(1);

	handled[entry]++;
}

static int find_sig_entry(int sigid)
{
	int i;

	for ( i = 0; i < NUM_SIG_TYPES; i++ )
	    if ( sigtypes[i] == sigid )
		return(i);

	return(-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\signal\f_sig2.c ===
/*****************************************************************************
 *									     *
 * Test Name: sig2.c    Date: 1/29/91   Author: Microsoft                    *
 *===========================================================================*
 *									     *
 * Suite: signal                                                             *
 *===========================================================================*
 *									     *
 * Tested Op/Func: signal						     *
 *---------------------------------------------------------------------------*
 * PURPOSE: This tests that each signal that can be raised by the operating  *
 *	    system, will result in a call to installed signal handler.       *
 *									     *
 * METHOD:                                                                   *
 *                                                                           *
 * MEMORY MODEL(S):                                                          *
 *      32-bit								     *
 * COMPILE/LINK OPTIONS:                                                     *
 *      No restrictions.                                                     *
 * OPERATING SYSTEM(S):                                                      *
 *      NT.  								     *
 * HARDWARE:                                                                 *	
 *      No restrictions                                                      *
 * SOFTWARE:                                                                 *
 *      No restrictions                                                      *
 * CONFIG.SYS:                                                               *
 *      Should contain what is required for compiler/linker                  *
 * ENVIRONMENT VARIABLES:                                                    *
 *      Should contain what is required for compiler/linker                  *
 *---------------------------------------------------------------------------*
 * TEST-RESULT OUTPUT: The outputs for this test shall be as follows:        *
 *      Normal: ***** PASSED *****                                           *
 *      Error:  ----- FAILED -----                                           *
 *---------------------------------------------------------------------------*
 * MODIFICATION HISTORY:                                                     *
 *                                                                           *
 *  Date       Initials Version PTR #   Description                          *
 *  ---------  -------- ------- ------- -------------------------------------*
 *  1/29/91    SDK      1.00                                                 *
 *  6/23/92    xiangjun 2.00            add longjmp and setjmp to make       *
 *                                      for SIGSEGV work                     *
 *									     *
 *****************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <test.h>
#include <setjmp.h>

static void __cdecl myhandler(int sigid);
static void __cdecl myhandler_SIGSEGV(int sigid);

static int perfect = 0;

static char test[] = "f_sig2";

static double T(z)  = PDV(0.0);
static char T(*ptr) = PDV(0);
static char valid_address[128];
static int sig_err;
static jmp_buf mark;

int f_sig2Entry(void){
	int counter = 0;
	double x, y = 1.0;

        int jmpret;

	startest();

	/* Install the handler for each type. */

	if ( signal(SIGFPE, myhandler) == SIG_ERR )
	    fail(10);

	if ( signal(SIGILL, myhandler) == SIG_ERR )
	    fail(11);

	if ( signal(SIGSEGV, myhandler_SIGSEGV) == SIG_ERR )
	    fail(12);

	/* Cause a floating-point exception to ocurr. */

	x = y / z;

	counter++;

	/* Raise a SIGILL.  It would be much better if we would at least
	   call the OS API to raise an illegal instruction exception.
	   In NT, the API is RaiseException, I have no idea of what to
	   pass it though. */

	raise(SIGILL);

	counter++;

	/* Cause a segmentation violation. */

        jmpret = setjmp( mark );
        if( jmpret == 0 ) {

    	   *V(ptr) = '\0';
           printf( "Error: program should have not reached here\n" );
           }
        else {
           if( sig_err == SIGSEGV )
           counter++;
           else
              fail(15);
           } 

	/* Be sure signal was raised, and recovered 3 times. */

	if ( counter != 3 )
	    fail(20);

	finish();
}

static void __cdecl myhandler(int sigid)
{
	switch(sigid){

	    /* Clear up the divide by zero problem. */

	    case SIGFPE:

		V(z) = 0.5;

	    break;

	    /* Clear up the NULL pointer problem. */

	    case SIGSEGV:

		V(ptr) = valid_address;

	    break;

	    /* Nothing to clear up here, don't have a method of causing
	       the OS to raise this. */

	    case SIGILL:

	    break;

	    default:

		fail(1);
	}
}

static void __cdecl myhandler_SIGSEGV(int sigid) {
    sig_err = sigid;
    longjmp( mark, -1 );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\signal\i_sig1.c ===
/*****************************************************************************
 *									     *
 * Test Name: i_sig1.c    Date: 1/29/91   Author: Microsoft                  *
 *===========================================================================*
 *									     *
 * Suite: signal                                                             *
 *===========================================================================*
 *									     *
 * Tested Op/Func: signal						     *
 *---------------------------------------------------------------------------*
 * PURPOSE: This tests that ^C interrupts caused by the user will            *
 *	    result in our installed exception handler to be called.          *
 *									     *
 * METHOD: This test must be ran manually.  It installs a handler for ^C     *
 *         then loops forcing the user to hit ^C eight times.                *
 *                                                                           *
 * MEMORY MODEL(S):                                                          *
 *      32-bit								     *
 * COMPILE/LINK OPTIONS:                                                     *
 *      No restrictions.                                                     *
 * OPERATING SYSTEM(S):                                                      *
 *      NT.  								     *
 * HARDWARE:                                                                 *	
 *      No restrictions                                                      *
 * SOFTWARE:                                                                 *
 *      No restrictions                                                      *
 * CONFIG.SYS:                                                               *
 *      Should contain what is required for compiler/linker                  *
 * ENVIRONMENT VARIABLES:                                                    *
 *      Should contain what is required for compiler/linker                  *
 *---------------------------------------------------------------------------*
 * TEST-RESULT OUTPUT: The outputs for this test shall be as follows:        *
 *      It will tell you to type ^C, over and over, until you do so 8 times. *
 *	Then it will exit.					             *
 *---------------------------------------------------------------------------*
 * MODIFICATION HISTORY:                                                     *
 *                                                                           *
 *  Date       Initials Version PTR #   Description                          *
 *  ---------  -------- ------- ------- -------------------------------------*
 *  1/29/91    SDK      1.00                                                 *
 *									     *
 *****************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <test.h>

static void __cdecl myhandler(int);

static int T(event_ocurred) = PDV(0);
static int T(event_count)   = PDV(0);

static int T(perfect) = PDV(0);

static char test[] = "i_sig1";

int i_sig1Entry(void){
	int i;

	startest();

	/* install handler for ^C handler. */

	if ( signal(SIGINT, myhandler) == SIG_ERR ) {
		printf("handler install for SIGINT failed!\n");
		exit(1);
	}

	/* Wait for ^C's. */

	for ( i = 0 ; (i < 1000) && (V(event_count) < 8) ; i++ ) {

	    if ( event_ocurred ) {
		printf("^C was hit\n");
		V(event_ocurred) = 0;
	    } else
		printf("Type ^C\n");
	}

	finish();
}

static void __cdecl myhandler(int sigid)
{
	V(event_ocurred) = 1;

	V(event_count)++;

	if ( sigid != SIGINT )
	    fail(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\signal\sources.inc ===
TARGETTYPE=LIBRARY
TARGETPATH=..\..\lib

SOURCES=\
	e_sig1.c \
	f_sig1.c \
	f_sig2.c \
	f_sig3.c \
	i_sig1.c \
	i_sig2.c \
	drv.c

INCLUDES=$(BASEDIR)\private\test\crttests\test\clib;$(SDK_INC_PATH)

MSC_WARNING_LEVEL=/W2
MSC_OPTIMIZATION=/Od

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\signal\i_sig2.c ===
/*****************************************************************************
 *									     *
 * Test Name: i_sig1.c    Date: 1/29/91   Author: Microsoft                  *
 *===========================================================================*
 *									     *
 * Suite: signal                                                             *
 *===========================================================================*
 *									     *
 * Tested Op/Func: signal						     *
 *---------------------------------------------------------------------------*
 * PURPOSE: This tests that ^BREAK interrupts caused by the user will        *
 *	    result in our installed exception handler to be called.          *
 *									     *
 * METHOD: This test must be ran manually.  It installs a handler for ^BREAK *
 *         then loops forcing the user to hit ^BREAK eight times.            *
 *                                                                           *
 * MEMORY MODEL(S):                                                          *
 *      32-bit								     *
 * COMPILE/LINK OPTIONS:                                                     *
 *      No restrictions.                                                     *
 * OPERATING SYSTEM(S):                                                      *
 *      NT.  								     *
 * HARDWARE:                                                                 *	
 *      No restrictions                                                      *
 * SOFTWARE:                                                                 *
 *      No restrictions                                                      *
 * CONFIG.SYS:                                                               *
 *      Should contain what is required for compiler/linker                  *
 * ENVIRONMENT VARIABLES:                                                    *
 *      Should contain what is required for compiler/linker                  *
 *---------------------------------------------------------------------------*
 * TEST-RESULT OUTPUT: The outputs for this test shall be as follows:        *
 *      It will tell you to type ^BREAK, over and over, until you do so      *
 *	8 times.  Then it will exit.			                     *
 *---------------------------------------------------------------------------*
 * MODIFICATION HISTORY:                                                     *
 *                                                                           *
 *  Date       Initials Version PTR #   Description                          *
 *  ---------  -------- ------- ------- -------------------------------------*
 *  1/29/91    SDK      1.00                                                 *
 *									     *
 *****************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <test.h>

static void __cdecl myhandler(int);

static int T(event_ocurred) = PDV(0);
static int T(event_count)   = PDV(0);

static int T(perfect) = PDV(0);

static char test[] = "i_sig1";

int i_sig2Entry(void){
	int i;

	startest();

	/* install handler for ^BREAK handler. */

	if ( signal(SIGBREAK, myhandler) == SIG_ERR ) {
		printf("handler install for SIGBREAK failed!\n");
		exit(1);
	}

	/* Wait for ^BREAK's. */

	for ( i = 0 ; (i < 1000) && (V(event_count) < 8) ; i++ ) {

	    if ( event_ocurred ) {
		printf("^BREAK was hit\n");
		V(event_ocurred) = 0;
	    } else
		printf("Type ^BREAK\n");
	}

	finish();
}

static void __cdecl myhandler(int sigid)
{
	V(event_ocurred) = 1;

	V(event_count)++;

	if ( sigid != SIGBREAK )
	    fail(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\stdlib\drv.c ===
#include <xtl.h>

int _ecvtEntry();


#ifdef __cplusplus
extern "C"
#endif
void __cdecl stdlibStartTest()
{
	_ecvtEntry();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\signal\f_sig3.c ===
/*****************************************************************************
 *									     *
 * Test Name: sig3.c    Date: 1/29/91   Author: Microsoft                    *
 *===========================================================================*
 *									     *
 * Suite: signal                                                             *
 *===========================================================================*
 *									     *
 * Tested Op/Func: signal						     *
 *---------------------------------------------------------------------------*
 * PURPOSE: Tests that signal will properly return the address of the        *
 *	    previously installed handler.				     *
 *									     *
 * METHOD:                                                                   *
 *                                                                           *
 * MEMORY MODEL(S):                                                          *
 *      32-bit								     *
 * COMPILE/LINK OPTIONS:                                                     *
 *      No restrictions.                                                     *
 * OPERATING SYSTEM(S):                                                      *
 *      NT.  								     *
 * HARDWARE:                                                                 *	
 *      No restrictions                                                      *
 * SOFTWARE:                                                                 *
 *      No restrictions                                                      *
 * CONFIG.SYS:                                                               *
 *      Should contain what is required for compiler/linker                  *
 * ENVIRONMENT VARIABLES:                                                    *
 *      Should contain what is required for compiler/linker                  *
 *---------------------------------------------------------------------------*
 * TEST-RESULT OUTPUT: The outputs for this test shall be as follows:        *
 *      Normal: ***** PASSED *****                                           *
 *      Error:  ----- FAILED -----                                           *
 *---------------------------------------------------------------------------*
 * MODIFICATION HISTORY:                                                     *
 *                                                                           *
 *  Date       Initials Version PTR #   Description                          *
 *  ---------  -------- ------- ------- -------------------------------------*
 *  1/29/91    SDK      1.00                                                 *
 *									     *
 *****************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <test.h>

static int sigtypes[] = { SIGABRT, SIGBREAK, SIGFPE, SIGILL,
	           SIGINT,  SIGSEGV,  SIGTERM };

#define NUM_SIG_TYPES ( sizeof(sigtypes) / sizeof(int) )

static int handled[NUM_SIG_TYPES] = { 0 };

static void __cdecl myhandler1(int sigid);
static void __cdecl myhandler2(int sigid);

static int  find_sig_entry(int sigid);

static int perfect = 0;

static char test[] = "f_sig1";

int f_sig3Entry(void){
	int i, counter = 0;

	startest();

	/* Install the handler1 for each type of signal. */

	for ( i = 0; i < NUM_SIG_TYPES; i++ )
	    if ( signal(sigtypes[i], myhandler1) == SIG_ERR )
		fail(10+i);

	/* Install handler 2 - and be sure the returned value is handler1. */

	for ( i = 0; i < NUM_SIG_TYPES; i++ )
	    if ( signal(sigtypes[i], myhandler2) != myhandler1 )
		fail(20+i);

	finish();
}

static void __cdecl myhandler1(int sigid)
{
}

static void __cdecl myhandler2(int sigid)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\stdlib\sources.inc ===
TARGETTYPE=LIBRARY
TARGETPATH=..\..\lib

SOURCES=\
	_ecvt.c \
	drv.c

INCLUDES=$(BASEDIR)\private\test\crttests\test\clib;$(SDK_INC_PATH)

MSC_WARNING_LEVEL=/W2
MSC_OPTIMIZATION=/Od

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\drv.c ===
#include <xtl.h>

int strerror1Entry();
int strerror2Entry();
int strerror3Entry();
int _stricolEntry();
int strlwr1Entry();
int strlwr2Entry();
int strlwr3Entry();
int strupr1Entry();
int strupr2Entry();
int strupr3Entry();
int memccpy1Entry();
int memccpy2Entry();
int memccpy3Entry();
int memccpy4Entry();
int memccpy5Entry();
int memchr1Entry();
int memchr2Entry();
int memchr3Entry();
int memchr4Entry();
int memchr5Entry();
int memcmp1Entry();
int memcmp2Entry();
int memcmp3Entry();
int memcmp4Entry();
int memcpy1Entry();
int memcpy2Entry();
int memcpy3Entry();
int memcpy4Entry();
int memicm5Entry();
int memicmp1Entry();
int memicmp2Entry();
int memicmp3Entry();
int memicmp4Entry();
int memicmp5Entry();
int memmove1Entry();
int memmove2Entry();
int memmove3Entry();
int memmove4Entry();
int memset1Entry();
int memset2Entry();
int memset3Entry();
int memset4Entry();
int strcat1Entry();
int strcat2Entry();
int strchr1Entry();
int strchr2Entry();
int strchr3Entry();
int strchr4Entry();
int strcmp1Entry();
int strcmp2Entry();
int strcmp3Entry();
int strcmp4Entry();
int strcoll1Entry();
int strcoll2Entry();
int strcoll3Entry();
int strcoll4Entry();
int strcpy1Entry();
int strcpy2Entry();
int strcpy3Entry();
int strcspn1Entry();
int strcspn2Entry();
int strcspn3Entry();
int strcspn4Entry();
int strdup1Entry();
int strdup2Entry();
int strdup3Entry();
int stricmp1Entry();
int stricmp2Entry();
int strlen1Entry();
int strlen2Entry();
int strncat1Entry();
int strncat2Entry();
int strncmp1Entry();
int strncmp2Entry();
int strncmp3Entry();
int strncpy1Entry();
int strncpy2Entry();
int strncpy3Entry();
int strnicm1Entry();
int strnicm2Entry();
int strnicm3Entry();
int strnicm4Entry();
int strnset1Entry();
int strnset2Entry();
int strnset3Entry();
int strpbrk1Entry();
int strpbrk2Entry();
int strpbrk3Entry();
int strpbrk4Entry();
int strrchr1Entry();
int strrchr2Entry();
int strrchr3Entry();
int strrchr4Entry();
int strrev1Entry();
int strrev2Entry();
int strrev3Entry();
int strset1Entry();
int strset2Entry();
int strset3Entry();
int strstr1Entry();
int strstr2Entry();
int strtok1Entry();
int strtok2Entry();
int strtol1Entry();
int strtol2Entry();
int strtoul1Entry();
int strtoul2Entry();
int strxfrm1Entry();
int strxfrm2Entry();
int tstrchr2Entry();
int tstrncatEntry();
int tstrncpyEntry();
int tstrstr2Entry();


#ifdef __cplusplus
extern "C"
#endif
void __cdecl stringStartTest()
{
	strerror1Entry();
	strerror2Entry();
	strerror3Entry();
	_stricolEntry();
	strlwr1Entry();
	strlwr2Entry();
	strlwr3Entry();
	strupr1Entry();
	strupr2Entry();
	strupr3Entry();
	memccpy1Entry();
	memccpy2Entry();
	memccpy3Entry();
	memccpy4Entry();
	memccpy5Entry();
	memchr1Entry();
	memchr2Entry();
	memchr3Entry();
	memchr4Entry();
	memchr5Entry();
	memcmp1Entry();
	memcmp2Entry();
	memcmp3Entry();
	memcmp4Entry();
	memcpy1Entry();
	memcpy2Entry();
	memcpy3Entry();
	memcpy4Entry();
	memicm5Entry();
	memicmp1Entry();
	memicmp2Entry();
	memicmp3Entry();
	memicmp4Entry();
	memicmp5Entry();
	memmove1Entry();
	memmove2Entry();
	memmove3Entry();
	memmove4Entry();
	memset1Entry();
	memset2Entry();
	memset3Entry();
	memset4Entry();
	strcat1Entry();
	strcat2Entry();
	strchr1Entry();
	strchr2Entry();
	strchr3Entry();
	strchr4Entry();
	strcmp1Entry();
	strcmp2Entry();
	strcmp3Entry();
	strcmp4Entry();
	strcoll1Entry();
	strcoll2Entry();
	strcoll3Entry();
	strcoll4Entry();
	strcpy1Entry();
	strcpy2Entry();
	strcpy3Entry();
	strcspn1Entry();
	strcspn2Entry();
	strcspn3Entry();
	strcspn4Entry();
	strdup1Entry();
	strdup2Entry();
	strdup3Entry();
	stricmp1Entry();
	stricmp2Entry();
	strlen1Entry();
	strlen2Entry();
	strncat1Entry();
	strncat2Entry();
	strncmp1Entry();
	strncmp2Entry();
	strncmp3Entry();
	strncpy1Entry();
	strncpy2Entry();
	strncpy3Entry();
	strnicm1Entry();
	strnicm2Entry();
	strnicm3Entry();
	strnicm4Entry();
	strnset1Entry();
	strnset2Entry();
	strnset3Entry();
	strpbrk1Entry();
	strpbrk2Entry();
	strpbrk3Entry();
	strpbrk4Entry();
	strrchr1Entry();
	strrchr2Entry();
	strrchr3Entry();
	strrchr4Entry();
	strrev1Entry();
	strrev2Entry();
	strrev3Entry();
	strset1Entry();
	strset2Entry();
	strset3Entry();
	strstr1Entry();
	strstr2Entry();
	strtok1Entry();
	strtok2Entry();
	strtol1Entry();
	strtol2Entry();
	strtoul1Entry();
	strtoul2Entry();
	strxfrm1Entry();
	strxfrm2Entry();
	tstrchr2Entry();
	tstrncatEntry();
	tstrncpyEntry();
	tstrstr2Entry();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\memccpy1.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl memccpy1.c
                     memccpy1
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the _memccpy() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 01-May-92    edv            created


---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;


static char src[60] = "AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYy";
/*                       1         2         3         4         5
*/


int memccpy1Entry(){
    int c;
    unsigned int count;
    char dest[60];
    char *pdest;

    startest();


/*  Scenario 1: Verify that if the char c is copied, a pointer to the byte
                in dest that immediately follows the char is returned.
*/
    c = 'j';
    count = 60;
    pdest = _memccpy( dest, src, c, count );
    checke( pdest, (dest + 20) );



/*  Scenario 2: Verify that if the char c is not copied, a NULL pointer
                is returned.
*/
    c = 'z';
    count = 60;
    pdest = _memccpy( dest, src, c, count );
    checkNULL( pdest );



/*  Scenario 3: Verify that the function works correctly when c occurs
                in the first byte of src.
*/
    c = 'A';
    count = 60;

/*  clear dest string
*/
    pdest = dest;
    *pdest = '\0';

    pdest = _memccpy( dest, src, c, count );
    checke( pdest, (dest + 1) );
    checke( dest[0], src[0] );



/*  Scenario 4: Verify that the function works correctly when c occurs
                in the first byte of src and count equals 1.
*/
    c = 'A';
    count = 1;

/*  clear dest string
*/
    pdest = dest;
    *pdest = '\0';

    pdest = _memccpy( dest, src, c, count );
    checke( pdest, (dest + 1) );
    checke( dest[0], src[0] );



/*  Scenario 5: Verify that the function works correctly when c occurs
                in the last byte of src.
*/
    c = 'y';
    count = 60;
    pdest = _memccpy( dest, src, c, count );
    checke( pdest, (dest + 50) );

/*  check that all characters got copied
*/
    for (c = 0; c < 50; c++)
        checke( dest[c], src[c] );


    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\stdlib\_ecvt.c ===
/***************************************************************************

           Copyright (c) 1994 Microsoft Corporation


Test:           _ecvt

Abstract:       This test verifies the functionality of _ecvt().  Test
                ensures proper handling of overflow case.

===========================================================================
Syntax

===========================================================================
Priority:               1
Products:               WIN NT


Revision History:

    Date        emailname       description
----------------------------------------------------------------------------
    05-06-94    lhanson         created
----------------------------------------------------------------------------

EndHeader:

****************************************************************************/

#include <stdlib.h>
#include <string.h>
#include "test.h"

static char test[] = __FILE__;
static int perfect;

int _ecvtEntry(){
    double dbl;
    char *pchRet;
    int cch, iDec, fSign;
    char szExpected[25];


    startest();


    // Simple case

    dbl = .1;
    cch = 4;
    strcpy(szExpected, "1000");

    pchRet = _ecvt(dbl, cch, &iDec, &fSign);

    if(strcmp(pchRet, szExpected))
    {
        fail(10);
        printf("Expected == \"%s\"\n"
               "Actual   == \"%s\"\n", szExpected, pchRet);
    }
    checke(strlen(pchRet), cch);
    checke(iDec, 0);
    checke(fSign, 0);


    // Overflow case

    dbl = .15 - .05;  // Should be same value as simple case
    cch = 4;
    strcpy(szExpected, "1000");

    pchRet = _ecvt(dbl, cch, &iDec, &fSign);

    if(strcmp(pchRet, szExpected))
    {
        fail(20);
        printf("Expected == \"%s\"\n"
               "Actual   == \"%s\"\n", szExpected, pchRet);
    }
    checke(strlen(pchRet), cch);
    checke(iDec, 0);
    checke(fSign, 0);


    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\memccpy2.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl memccpy2.c
                     memccpy2
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the _memccpy() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 01-May-92    edv            created


---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <limits.h>
#include <test.h>

static char test[] =__FILE__;
static int perfect;


static unsigned char src[20] = "abcdefghijklmnopqrst";
static unsigned char baseline[20] = "abcdefghij";
static unsigned char dest[20];


int memccpy2Entry(){
    int c, i;
    unsigned int count = 20;

    startest();

/*  Scenario 6: Verify that c can be any value from 0 to UCHAR_MAX,
                and will be recognized as a delimiter of the string
                to be copied.
*/

    for (c = 0; c < 'a'; c++) {
        src[9] = baseline[9] = c;
        _memccpy( dest, src, c, count );
        for (i = 0; i < (int) count; i++)
	  {
	    if (dest[i] != baseline[i])
	      {
		checke( dest[i], baseline[i] );
		printf("error with delimiter %x\n", (unsigned int)c);
	      };
	  };
    }


/*  Change string in src and baseline because _memccpy will halt when
    the first 'c' is copied.
*/
    strcpy( src, "ABCDEFGHIJKLMNOPQRST" );
    strcpy( baseline, "ABCDEFGHIJ" );

    for (c = 'a'; c <= UCHAR_MAX; c++) {
        src[9] = baseline[9] = c;
        _memccpy( dest, src, c, count );
        for (i = 0; i < (int) count; i++)
	  {
	    if (dest[i] != baseline[i])
	      {
            checke( dest[i], baseline[i] );
	    printf("error with delimiter %x\n", (unsigned int)c);
	      };
	  };
    }


    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\memccpy5.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl memccpy5.c
                     memccpy5
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the _memccpy() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 01-May-92    edv            created


---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <malloc.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;

#define DELTA    2000
#define LARGEST (SHRT_MAX - DELTA)


int memccpy5Entry(){
    int c;
    unsigned int count, i, buf_size;
    unsigned char *src, *dest;
    /* size_t contig; */

    startest();


/*  Scenario 11: Verify that dest and src can be as large as
         LARGEST using any string model.
*/

       buf_size = LARGEST;

       src = malloc( buf_size );
       if (src == NULL)
       {
          faill();
          exit( 1 );
       }

       dest = malloc( buf_size );
       if (dest == NULL)
       {
          faill();
          exit( 1 );
       }

       memset( src, '+', buf_size );
       memset( dest, '-', buf_size );
       count = buf_size;
       c = 'C';
       _memccpy( dest, src, c, count );

       for (i = 0; i < count; i++)
           checke( dest[i], src[i] );



    free( src );
    free( dest );


    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\memccpy4.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl memccpy4.c
                     memccpy4
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the _memccpy() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 16-Apr-92    edv            created


---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;

#define ZERO            0
#define TWENTY         20
#define HUNDRED       100
#define THOUSAND     1000
#define TEN_THOU    10000
#define THIRTY_THOU 30000
#define DELTA 2000
#define ALMOST_MAX  (SHRT_MAX - DELTA)


/*  Scenario 9: Verify that dest and src can be almost as large as
        SHRT_MAX when using SMALL model.
*/

static unsigned char src[ALMOST_MAX];
static unsigned char dest[ALMOST_MAX] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
static unsigned char ivals[10] = "!@#$%^&*()";


int memccpy4Entry(){
    int c, i;
    unsigned int count, j;


    startest();


/*  Scenario 10: Verify that count can be anywhere in the range
         0 to aproximately SHRT_MAX when using SMALL model.
*/

    memset( src, '+', ALMOST_MAX );
    c = '1';

    for (count = ZERO, i = ZERO; count < TWENTY; count++, i++)
    {
        memset( src, ivals[i], count );
        if (i == 9) i = 0;
        _memccpy( dest, src, c, count );
        for (j = 0; j < count; j++)
            checke( dest[j], src[j] );
    }



    memset( src, '-', ALMOST_MAX );
    c = '2';

    for (count = HUNDRED, i = ZERO; count < (HUNDRED + TWENTY); count++, i++)
    {
        memset( src, ivals[i], count );
        if (i == 9) i = 0;
        _memccpy( dest, src, c, count );
        for (j = 0; j < count; j++)
            checke( dest[j], src[j] );
    }



    memset( src, '=', ALMOST_MAX );
    c = '3';

    for (count = THOUSAND, i = ZERO; count < (THOUSAND + TWENTY); count++, i++)
    {
        memset( src, ivals[i], count );
        if (i == 9) i = 0;
        _memccpy( dest, src, c, count );
        for (j = 0; j < count; j++)
            checke( dest[j], src[j] );
    }


#ifndef QA_SIMPLE_QALIB

    memset( src, '{', ALMOST_MAX );
    c = '4';
    i = ZERO;

    for (count = TEN_THOU; count < (TEN_THOU + TWENTY); count++, i++)
    {
        memset( src, ivals[i], count );
        if (i == 9) i = 0;
        _memccpy( dest, src, c, count );
        for (j = 0; j < count; j++)
            checke( dest[j], src[j] );
    }




    memset( src, '}', ALMOST_MAX );
    c = '5';
    i = ZERO;

    for (count = THIRTY_THOU; count < (THIRTY_THOU + TWENTY); count++, i++)
    {
        memset( src, ivals[i], count );
        if (i == 9) i = 0;
        _memccpy( dest, src, c, count );
        for (j = 0; j < count; j++)
            checke( dest[j], src[j] );
    }




    memset( src, '|', ALMOST_MAX );
    c = '6';
    i = ZERO;

    for (count = (ALMOST_MAX - TWENTY); count < ALMOST_MAX; count++, i++)
    {
        memset( src, ivals[i], count );
        if (i == 9) i = 0;
        _memccpy( dest, src, c, count );
        for (j = 0; j < count; j++)
            checke( dest[j], src[j] );
    }

#endif

    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\memccpy3.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl /AL memccpy3.c
                     memccpy3
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the _memccpy() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        Must be compiled with LARGE memory model.
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 01-May-92    edv            created


---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <limits.h>
#include <test.h>

static char test[] =__FILE__;
static int perfect;

#define ZERO           0
#define TWENTY        20
#define HUNDRED      100
#define THOUSAND    1000
#define TEN_THOU   10000
#define FORTY_THOU 40000

#define TWO	2
#ifdef QA_SIMPLE_QALIB
#define MAX_STEPS TWO
#else
#define MAX_STEPS TWENTY
#endif


/*  Scenario 7: Verify that dest and src can be as large as
        USHRT_MAX when using LARGE model.

*/

static unsigned char src[USHRT_MAX];
static unsigned char dest[USHRT_MAX] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
static unsigned char ivals[10] = "!@#$%^&*()";


int memccpy3Entry(){
    int c, i;
    unsigned int count, j;

    startest();


/*  Scenario 8: Verify that count can be anywhere in the range
        0 to USHRT_MAX when using LARGE model.

*/

    memset( src, '+', USHRT_MAX );
    c = '1';

    for (count = ZERO, i = ZERO; count < TWENTY; count++, i++)
    {
        memset( src, ivals[i], count );
        if (i == 9) i = 0;
        _memccpy( dest, src, c, count );
        for (j = 0; j < count; j++)
            checke32( dest[j], src[j] );
    }



    memset( src, '-', USHRT_MAX );
    c = '2';

    for (count = HUNDRED, i = ZERO; count < (HUNDRED + MAX_STEPS); count++, i++)
    {
        memset( src, ivals[i], count );
        if (i == 9) i = 0;
        _memccpy( dest, src, c, count );
        for (j = 0; j < count; j++)
            checke32( dest[j], src[j] );
    }



    memset( src, '=', USHRT_MAX );
    c = '3';

    for (count = THOUSAND, i = ZERO; count < (THOUSAND + MAX_STEPS); count++, i++)
    {
        memset( src, ivals[i], count );
        if (i == 9) i = 0;
        _memccpy( dest, src, c, count );
        for (j = 0; j < count; j++)
            checke32( dest[j], src[j] );
    }



    memset( src, '{', USHRT_MAX );
    c = '4';
    i = ZERO;

    for (count = TEN_THOU; count < (TEN_THOU + MAX_STEPS); count++, i++)
    {
        memset( src, ivals[i], count );
        if (i == 9) i = 0;
        _memccpy( dest, src, c, count );
        for (j = 0; j < count; j++)
            checke32( dest[j], src[j] );
    }




    memset( src, '}', USHRT_MAX );
    c = '5';
    i = ZERO;

    for (count = FORTY_THOU; count < (FORTY_THOU + MAX_STEPS); count++, i++)
    {
        memset( src, ivals[i], count );
        if (i == 9) i = 0;
        _memccpy( dest, src, c, count );
        for (j = 0; j < count; j++)
            checke32( dest[j], src[j] );
    }

#ifndef QA_SIMPLE_QALIB

    memset( src, '|', USHRT_MAX );
    c = '6';
    i = ZERO;

    for (count = (USHRT_MAX - TWENTY); count < USHRT_MAX; count++, i++)
    {
        memset( src, ivals[i], count );
        if (i == 9) i = 0;
        _memccpy( dest, src, c, count );
        for (j = 0; j < count; j++)
            checke32( dest[j], src[j] );
    }
#endif


    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\memchr1.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl memchr1.c
                     memchr1
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the memchr() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 01-May-92    edv            created


---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;


static char buf[50] = "AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYy";
/*                       1         2         3         4         5
*/


int memchr1Entry(){
    int c;
/*    size_t count; */
    char *pbuf;

    startest();


/*  Scenario 1: Verify that if successful, a pointer to the first location
                of c in buf is returned.
*/
    c = 'o';
    pbuf = memchr( buf, c, sizeof( buf ) );

/*  Subtract one because relative addresses start at plus 0
*/
    checke( pbuf, (buf + 30 - 1) );



/*  Scenario 2: Verify that if unsuccessful, a NULL pointer is returned.
*/
    c = 'z';
    pbuf = memchr( buf, c, sizeof( buf ) );
    checkNULL( pbuf );


/*  Scenario 3: Verify that the function works correctly when c occurs
                in the first byte of buf.
*/
    c = 'A';
    pbuf = memchr( buf, c, sizeof( buf ) );
    checke( pbuf, buf );



/*  Scenario 4: Verify that the function works correctly when c occurs
                in the last byte of buf.
*/
    c = 'y';
    pbuf = memchr( buf, c, sizeof( buf ) );

/*  Subtract one because relative addresses start at plus 0
*/
    checke( pbuf, (buf + 50 - 1) );



    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\memchr2.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl memchr2.c
                     memchr2
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the memchr() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0]  1-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;

static unsigned char buf[20] = "abcdefghijklmnopqrst";


int memchr2Entry(){
    int c;
    size_t count;
    unsigned char *pbuf;

    startest();


/*  Scenario 5: Verify that c can be any value from 0 to UCHAR_MAX,
                and will be recognized as the character to be found.
*/

    count = sizeof( buf );

    for (c = 0; c < 'a'; c++) {
        buf[9] = c;
        pbuf = memchr( buf, c, count );
        checke( pbuf, buf + 9 );
    }


/*  Change string in buf because first occurence will be found.
*/

    strcpy( buf, "ABCDEFGHIJKLMNOPQRST" );

    for (c = 'a'; c <= UCHAR_MAX; c++) {
        buf[9] = c;
        pbuf = memchr( buf, c, count );
        checke( pbuf, buf + 9 );
    }



    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\memchr3.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl /AL memchr3.c
                     memchr3
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the memchr() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        Must be compiled using LARGE model
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0]  1-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;

#define TWO            2
#define TWENTY        20
#define HUNDRED      100
#define THOUSAND    1000
#define TEN_THOU   10000
#define FORTY_THOU 40000


/*  Scenario 6: Verify tat buf can be as large as USHRT_MAX
                when using LARGE model.
*/

static unsigned char buf[USHRT_MAX];


int memchr3Entry(){
    int c, d=0x01;
    size_t count;
    unsigned char *pbuf;

    startest();


/*  Scenario 7: Verify that count can be anywhere in the range of
        0 to USHRT_MAX when using the LARGE model.
*/

    c = '^';
    memset( buf, d, sizeof( buf ) );

    count = 0;
    pbuf = memchr( buf, c, count );
    checkNULL( pbuf );


    for (count = TWO; count < TWENTY; count++)
    {
        buf[count - TWO] = c;
        pbuf = memchr( buf, c, count );
        checke( pbuf, buf + count - TWO );
        buf[count - TWO] = d;
    }



    for (count = HUNDRED; count < (HUNDRED + TWENTY); count++)
    {
        buf[count - TWO] = c;
        pbuf = memchr( buf, c, count );
        checke( pbuf, buf + count - TWO );
        buf[count - TWO] = d;
    }


    for (count = THOUSAND; count < (THOUSAND + TWENTY); count++)
    {
        buf[count - TWO] = c;
        pbuf = memchr( buf, c, count );
        checke( pbuf, buf + count - TWO );
        buf[count - TWO] = d;
    }


    for (count = TEN_THOU; count < (TEN_THOU + TWENTY); count++)
    {
        buf[count - TWO] = c;
        pbuf = memchr( buf, c, count );
        checke( pbuf, buf + count - TWO );
        buf[count - TWO] = d;
    }


    for (count = FORTY_THOU; count < (FORTY_THOU + TWENTY); count++)
    {
        buf[count - TWO] = c;
        pbuf = memchr( buf, c, count );
        checke( pbuf, buf + count - TWO );
        buf[count - TWO] = d;
    }


    for (count = (USHRT_MAX - TWENTY); count < USHRT_MAX; count++)
    {
        buf[count - TWO] = c;
        pbuf = memchr( buf, c, count );
        checke( pbuf, buf + count - TWO );
        buf[count - TWO] = d;
    }


    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\memchr4.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl memchr4.c
                     memchr4
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the memchr() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0]  1-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;

#define TWO             2
#define TWENTY         20
#define HUNDRED       100
#define THOUSAND     1000
#define TEN_THOU    10000
#define THIRTY_THOU 30000
#define DELTA        1850
#define ALMOST_MAX  (SHRT_MAX - DELTA)


/*  Scenario 8: Verify tat buf can almost as large as SHRT_MAX
                when using SMALL model.
*/

static unsigned char buf[ALMOST_MAX];



int memchr4Entry(){
    int c, d=0x01;
    size_t count;
    unsigned char *pbuf;


    startest();



/*  Scenario 9: Verify that count can be anywhere in the range of
        0 to approximately SHRT_MAX when using SMALL model.
*/

    c = '^';
    memset( buf, d, sizeof( buf ) );

    count = 0;
    pbuf = memchr( buf, c, count );
    checkNULL( pbuf );


    for (count = TWO; count < TWENTY; count++)
    {
        buf[count - TWO] = c;
        pbuf = memchr( buf, c, count );
        checke( pbuf, buf + count - TWO );
        buf[count - TWO] = d;
    }



    for (count = HUNDRED; count < (HUNDRED + TWENTY); count++)
    {
        buf[count - TWO] = c;
        pbuf = memchr( buf, c, count );
        checke( pbuf, buf + count - TWO );
        buf[count - TWO] = d;
    }



    for (count = THOUSAND; count < (THOUSAND + TWENTY); count++)
    {
        buf[count - TWO] = c;
        pbuf = memchr( buf, c, count );
        checke( pbuf, buf + count - TWO );
        buf[count - TWO] = d;
    }



    for (count = TEN_THOU; count < (TEN_THOU + TWENTY); count++)
    {
        buf[count - TWO] = c;
        pbuf = memchr( buf, c, count );
        checke( pbuf, buf + count - TWO );
        buf[count - TWO] = d;
    }



    for (count = THIRTY_THOU; count < (THIRTY_THOU + TWENTY); count++)
    {
        buf[count - TWO] = c;
        pbuf = memchr( buf, c, count );
        checke( pbuf, buf + count - TWO );
        buf[count - TWO] = d;
    }



    for (count = (ALMOST_MAX - TWENTY); count < ALMOST_MAX; count++)
    {
        buf[count - TWO] = c;
        pbuf = memchr( buf, c, count );
        checke( pbuf, buf + count - TWO );
        buf[count - TWO] = d;
    }



    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\memcmp1.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl memcmp1.c
                     memcmp1
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the memcmp() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests decribed in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 01-May-92    edv            created


---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;


static char bufval1[51] = "AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYy";
static char bufval2[51] = "AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxyz";
/*                                                                  ^
                                                         ___________|
*/

int memcmp1Entry(){
    int i, outcome;
    size_t count;
    char buf1[51], buf2[51];

    startest();


/*  Scenario 1: Verify that the function returns a negative value
                when buf1 < buf2.
*/
    for (i = 0; i < 51; i++ )
    {
        buf1[i] = bufval1[i];
        buf2[i] = bufval2[i];
    }
    count = 51;
    outcome = 999;
    outcome = memcmp( buf1, buf2, count);
    checke( (outcome < 0), 1 );



/*  Scenario 2: Verify that the function returns a positive value
                when buf1 > buf2.
*/
    for (i = 0; i < 51; i++ )
    {
        buf1[i] = bufval2[i];
        buf2[i] = bufval1[i];
    }
    count = 51;
    outcome = -999;
    outcome = memcmp( buf1, buf2, count);
    checke( (outcome > 0), 1 );



/*  Scenario 3: Verify that the function returns zero when buf1 = buf2.
*/
    for (i = 0; i < 51; i++ )
    {
        buf1[i] = bufval1[i];
        buf2[i] = bufval1[i];
    }
    count = 51;
    outcome = 999;
    outcome = memcmp( buf1, buf2, count);
    checke( (outcome == 0), 1 );


    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\memcmp4.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:          cl memcmp4.c
             memcmp4
Switches:            NONE
Hard/Soft Needs:
Abstract:        This test verifies the memcmp() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 01-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <malloc.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;

#define DELTA    2000
#define LARGEST (SHRT_MAX - DELTA)


int memcmp4Entry(){
    int outcome;
    unsigned int buf_size;
    unsigned char *buf1, *buf2;
    size_t count;


    startest();


/*  Scenario 8: Verify that buf1 and buf2 can be as large as
         LARGEST using any STRING model.
*/

    buf_size = LARGEST;

    buf1 = malloc( buf_size );
    if (buf1 == NULL)
    {
       faill();
       exit( 1 );
    }

    buf2 = malloc( buf_size );
    if (buf2 == NULL)
    {
       faill();
       exit( 1 );
    }

    memset( buf1, 'a', buf_size );
    memset( buf2, 'a', buf_size );
    count = buf_size;

    outcome = memcmp( buf1, buf2, count );
    checke( (outcome == 0), 1 );


    buf1[buf_size - 1] = 'b';
    outcome = memcmp( buf1, buf2, count );
    checke( (outcome > 0), 1 );
    buf1[buf_size - 1] = 'a';


    buf1[1] = 'X';
    outcome = memcmp( buf1, buf2, count );
    checke( (outcome < 0), 1 );



    free( buf1 );
    free( buf2 );


    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\memchr5.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:          cl memchr5.c
             memchr5
Switches:            NONE
Hard/Soft Needs:
Abstract:        This test verifies the memchr() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0]  1-May-92    edv            created


---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <malloc.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;

#define DELTA    2000
#define LARGEST  (USHRT_MAX - DELTA)


int memchr5Entry(){
    int c;
    unsigned int buf_size;
    unsigned char *pbuf1, *pbuf2;

    startest();


/*  Scenario 10: Verify that buf can be as large as LARGEST
                 using any STRING model.
*/

    buf_size = LARGEST;

    pbuf1 = malloc( buf_size );
    if (pbuf1 == NULL)
    {
      faill();
      exit( 1 );
    }
    memset( pbuf1, '+', buf_size );
    pbuf1[5] = c = 'X';
    pbuf2 = memchr( pbuf1, c, buf_size );
    checke( pbuf2, pbuf1 + 5 );


    free( pbuf1 );


    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\memcpy1.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl memcpy1.c
                     memcpy1
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the memcpy() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0]  1-May-92    edv            created


---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <test.h>

static char test[] =__FILE__;
static int perfect;


static char src[30]  = "A1B2C3D4E5F6G7H8I9J0KkLlMmNnOo";

static char bsl1[30] = "A1B2C3D4E5A1B2C3D4E5A1B2C3D4E5";
static char bsl2[30] = "F6G7H8I9J0A1B2C3D4E5A1B2C3D4E5";



int memcpy1Entry(){
    unsigned int count;
    char dest[30];
    char *pdest;



    startest();


/*  Scenario 1: Verify that the function returns a pointer to dest.
*/

    count = sizeof( src );
    pdest = memcpy( dest, src, count );
    checke( pdest, dest );




/*  Scenario 2: Verify that the function works correctly when
                dest overlaps src.
*/

/*  Invalid scenario: undefined behaviour when overlap

    for (i = 0; i < sizeof( dest ); i++)
        dest[i] = src[i];
    count = 20;

    pdest = memcpy( dest + 10, dest, count );

    for (i = 0; i < sizeof( dest ); i++)
        checke( dest[i], bsl1[i]);
*/


/*  Scenario 3: Verify that the function works correctly when
                src overlaps dest.
*/

/*  Invalid scenario: undefined behaviour when overlap

    for (i = 0; i < count; i++)
        dest[i] = src[i];
    count = 20;

    pdest = memcpy( dest, dest + 10, count );

    for (i = 0; i < sizeof( dest ); i++)
        checke( dest[i], bsl2[i] );
*/



    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\memcmp2.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl /AL memcmp2.c
                     memcmp2
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the memcmp() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        Must be compiled with LARGE STRING model.
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests decribed in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0]  1-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;


#define ONE            1
#define TWENTY        20
#define HUNDRED      100
#define THOUSAND    1000
#define TEN_THOU   10000
#define FORTY_THOU 40000

#define TWO	2
#ifdef QA_SIMPLE_QALIB
#define MAX_STEPS TWO
#else
#define MAX_STEPS TWENTY
#endif



/*  Scenario 4: Verify that buf1 and buf2 can be as large as
        USHRT_MAX when using LARGE model.
*/

static unsigned char buf1[USHRT_MAX];
static unsigned char buf2[USHRT_MAX];



int memcmp2Entry(){
    int c, d, outcome;
    size_t count;


    startest();


/*  Scenario 5: Verify that count can be anywhere in the range
        0 to USHRT_MAX when using the LARGE model.
*/

    c = 'x';
    memset( buf1, c, sizeof( buf1 ) );
    memset( buf2, c, sizeof( buf2 ) );



    d = 'w';
    buf1[0] = d;

/* Note that buf1 is less than buf2, but count is zero,
   so it should return zero.
*/
    count = 0;
    outcome = 1;
    outcome = memcmp( buf1, buf2, count );
    checke( (outcome == 0), 1 );

    buf1[0] = c;




    d = 'y';
    buf1[(USHRT_MAX - TEN_THOU)] = d;

    count = (USHRT_MAX - TEN_THOU + 1);
    outcome = - 1;
    outcome = memcmp( buf1, buf2, count );
    checke( (outcome > 0), 1 );

    buf1[(USHRT_MAX - TEN_THOU)] = c;





    for (count = ONE; count < TWENTY; count++)
    {
        outcome = -1;
        outcome = memcmp( buf1, buf2, count );
        checke( (outcome == 0), 1 );
    }





    d = 'd';
    for (count = HUNDRED; count < (HUNDRED + MAX_STEPS); count++)
    {
        buf1[count - 1] = d;
        outcome = 0;
        outcome = memcmp( buf1, buf2, count );
        checke( (outcome < 0), 1 );
        buf1[count - 1] = c;
    }



    d = 'y';
    for (count = THOUSAND; count < (THOUSAND + MAX_STEPS); count++)
    {
        buf1[count - 1] = d;
        outcome = 0;
        outcome = memcmp( buf1, buf2, count );
        checke( (outcome > 0), 1 );
        buf1[count - 1] = c;
    }


#ifndef QA_SIMPLE_QALIB

    for (count = TEN_THOU; count < (TEN_THOU + MAX_STEPS); count++)
    {
        outcome = -1;
        outcome = memcmp( buf1, buf2, count );
        checke( (outcome == 0), 1 );
    }




    d = 'X';
    for (count = FORTY_THOU; count < (FORTY_THOU + MAX_STEPS); count++)
    {
        buf1[count - 1] = d;
        outcome = 1;
        outcome = memcmp( buf1, buf2, count );
        checke( (outcome < 0), 1 );
        buf1[count - 1] = c;
    }


   d = '{';
    for (count = (USHRT_MAX - MAX_STEPS); count < USHRT_MAX; count++)
    {
        buf1[count - 1] = d;
        outcome = 0;
        outcome = memcmp( buf1, buf2, count );
        checke( (outcome > 0), 1 );
        buf1[count - 1] = c;
    }
#endif

    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\memcmp3.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl memcmp3.c
                     memcmp3
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the memcmp() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests decribed in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0]  1-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;


#define ONE             1
#define TWO             2
#define TWENTY         20
#define HUNDRED       100
#define THOUSAND     1000
#define TEN_THOU    10000
#define THIRTY_THOU 30000
#define DELTA        2000
#define ALMOST_MAX  (SHRT_MAX - DELTA)


/*  Scenario 6: Verify that buf1 and buf2 can be almost as large as
        SHRT_MAX when using SMALL model.
*/

static unsigned char buf1[ALMOST_MAX];
static unsigned char buf2[ALMOST_MAX];



int memcmp3Entry(){
    int c, d, outcome;
    size_t count;


    startest();


/*  Scenario 7: Verify that count can be anywhere in the range
        0 to aproximately SHRT_MAX when using SMALL model.
*/

    c = 'x';
    memset( buf1, c, sizeof( buf1 ) );
    memset( buf2, c, sizeof( buf2 ) );



    d = 'w';
    buf1[0] = d;

/* Note that buf1 is less than buf2, but count is zero,
   so it should return zero.
*/
    count = 0;
    outcome = 1;
    outcome = memcmp( buf1, buf2, count );
    checke( (outcome == 0), 1 );

    buf1[0] = c;



    d = 'y';
    buf1[(ALMOST_MAX - TEN_THOU)] = d;

    count = (ALMOST_MAX - TEN_THOU + 1);
    outcome = - 1;
    outcome = memcmp( buf1, buf2, count );
    checke( (outcome > 0), 1 );

    buf1[(ALMOST_MAX - TEN_THOU)] = c;



    for (count = ONE; count < TWENTY; count++)
    {
        outcome = -1;
        outcome = memcmp( buf1, buf2, count );
        checke( (outcome == 0), 1 );
    }



    d = 'd';
    for (count = HUNDRED; count < (HUNDRED + TWENTY); count++)
    {
        buf1[count - 1] = d;
        outcome = 0;
        outcome = memcmp( buf1, buf2, count );
        checke( (outcome < 0), 1 );
        buf1[count - 1] = c;
    }



    d = 'y';
    for (count = THOUSAND; count < (THOUSAND + TWENTY); count++)
    {
        buf1[count - 1] = d;
        outcome = 0;
        outcome = memcmp( buf1, buf2, count );
        checke( (outcome > 0), 1 );
        buf1[count - 1] = c;
    }



    for (count = TEN_THOU; count < (TEN_THOU + TWENTY); count++)
    {
        outcome = -1;
        outcome = memcmp( buf1, buf2, count );
        checke( (outcome == 0), 1 );
    }



    d = 'X';
    for (count = THIRTY_THOU; count < (THIRTY_THOU + TWENTY); count++)
    {
        buf1[count - 1] = d;
        outcome = 1;
        outcome = memcmp( buf1, buf2, count );
        checke( (outcome < 0), 1 );
        buf1[count - 1] = c;
    }



    d = '{';
    for (count = (ALMOST_MAX - TWENTY); count < ALMOST_MAX; count++)
    {
        buf1[count - 1] = d;
        outcome = 0;
        outcome = memcmp( buf1, buf2, count );
        checke( (outcome > 0), 1 );
        buf1[count - 1] = c;
    }




    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\memcpy2.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl /AL memcpy2.c
                     memcpy2
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the memcpy() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        Must be compiled with LARGE memory model.
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0]  1-May-92    edv            created


---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;

#define ZERO           0
#define TWENTY        20
#define HUNDRED      100
#define THOUSAND    1000
#define TEN_THOU   10000
#define FORTY_THOU 40000


#define TWO	2
#ifdef QA_SIMPLE_QALIB
#define MAX_STEPS TWO
#else
#define MAX_STEPS TWENTY
#endif


/*  Scenario 4: Verify that dest and src can be as large as
        USHRT_MAX when using LARGE model.

*/

static unsigned char src[USHRT_MAX];
static unsigned char dest[USHRT_MAX] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
static unsigned char ivals[10] = "!@#$%^&*()";


int memcpy2Entry(){
    int i;
    unsigned int count, j;

    startest();


/*  Scenario 5: Verify that count can be anywhere in the range
        0 to USHRT_MAX when using LARGE model.

*/

    memset( src, '+', USHRT_MAX );


    for (count = ZERO, i = ZERO; count < TWENTY; count++, i++)
    {
        memset( src, ivals[i], count );
        if (i == 9) i = 0;
        memcpy( dest, src, count );
        for (j = 0; j < count; j++)
            checke32( dest[j], src[j] );
    }



    memset( src, '-', USHRT_MAX );


    for (count = HUNDRED, i = ZERO; count < (HUNDRED + MAX_STEPS); count++, i++)
    {
        memset( src, ivals[i], count );
        if (i == 9) i = 0;
        memcpy( dest, src, count );
        for (j = 0; j < count; j++)
            checke32( dest[j], src[j] );
    }



    memset( src, '=', USHRT_MAX );


    for (count = THOUSAND, i = ZERO; count < (THOUSAND + MAX_STEPS); count++, i++)
    {
        memset( src, ivals[i], count );
        if (i == 9) i = 0;
        memcpy( dest, src, count );
        for (j = 0; j < count; j++)
            checke32( dest[j], src[j] );
    }


#ifndef QA_SIMPLE_QALIB

    memset( src, '{', USHRT_MAX );


    for (count = TEN_THOU, i = 0; count < (TEN_THOU + MAX_STEPS); count++, i++)
    {
        memset( src, ivals[i], count );
        if (i == 9) i = 0;
        memcpy( dest, src, count );
        for (j = 0; j < count; j++)
            checke32( dest[j], src[j] );
    }




    memset( src, '}', USHRT_MAX );


    for (count = FORTY_THOU, i = 0; count < (FORTY_THOU + MAX_STEPS); count++, i++)
    {
        memset( src, ivals[i], count );
        if (i == 9) i = 0;
        memcpy( dest, src, count );
        for (j = 0; j < count; j++)
            checke32( dest[j], src[j] );
    }





    memset( src, '|', USHRT_MAX );


    for (count = (USHRT_MAX - MAX_STEPS), i = 0; count < USHRT_MAX; count++, i++)
    {
        memset( src, ivals[i], count );
        if (i == 9) i = 0;
        memcpy( dest, src, count );
        for (j = 0; j < count; j++)
            checke32( dest[j], src[j] );
    }
#endif


    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\memcpy3.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl memcpy3.c
                     memcpy3
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the memcpy() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0]  1-May-92    edv            created


---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;

#define ZERO            0
#define TWENTY         20
#define HUNDRED       100
#define THOUSAND     1000
#define TEN_THOU    10000
#define THIRTY_THOU 30000
#define DELTA        2000
#define ALMOST_MAX  (SHRT_MAX - DELTA)


/*  Scenario 6 Verify that dest and src can be almost as large as
        SHRT_MAX when using SMALL model.
*/

static unsigned char src[ALMOST_MAX];
static unsigned char dest[ALMOST_MAX] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
static unsigned char ivals[10] = "!@#$%^&*()";


int memcpy3Entry(){
    unsigned int count, i, j;


    startest();


/*  Scenario 7: Verify that count can be anywhere in the range
         0 to aproximately SHRT_MAX when using SMALL model.
*/

    memset( src, '+', ALMOST_MAX );

    for (count = ZERO, i = ZERO; count < TWENTY; count++, i++)
    {
        memset( src, ivals[i], count );
        if (i == 9) i = 0;
        memcpy( dest, src, count );
        for (j = 0; j < count; j++)
            checke( dest[j], src[j] );
    }



    memset( src, '-', ALMOST_MAX );
    i = 0;

    for (count = HUNDRED; count < (HUNDRED + TWENTY); count++, i++)
    {
        memset( src, ivals[i], count );
        if (i == 9) i = 0;
        memcpy( dest, src, count );
        for (j = 0; j < count; j++)
            checke( dest[j], src[j] );
    }



    memset( src, '=', ALMOST_MAX );
    i = 0;

    for (count = THOUSAND; count < (THOUSAND + TWENTY); count++, i++)
    {
        memset( src, ivals[i], count );
        if (i == 9) i = 0;
        memcpy( dest, src, count );
        for (j = 0; j < count; j++)
            checke( dest[j], src[j] );
    }

#ifndef QA_SIMPLE_QALIB

    memset( src, '{', ALMOST_MAX );
    i = 0;

    for (count = TEN_THOU; count < (TEN_THOU + TWENTY); count++, i++)
    {
        memset( src, ivals[i], count );
        if (i == 9) i = 0;
        memcpy( dest, src, count );
        for (j = 0; j < count; j++)
            checke( dest[j], src[j] );
    }




    memset( src, '}', ALMOST_MAX );
    i = 0;

    for (count = THIRTY_THOU; count < (THIRTY_THOU + TWENTY); count++, i++)
    {
        memset( src, ivals[i], count );
        if (i == 9) i = 0;
        memcpy( dest, src, count );
        for (j = 0; j < count; j++)
            checke( dest[j], src[j] );
    }




    memset( src, '|', ALMOST_MAX );
    i = 0;

    for (count = (ALMOST_MAX - TWENTY); count < ALMOST_MAX; count++, i++)
    {
        memset( src, ivals[i], count );
        if (i == 9) i = 0;
        memcpy( dest, src, count );
        for (j = 0; j < count; j++)
            checke( dest[j], src[j] );
    }

#endif

    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\memcpy4.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:          cl memcpy4.c
             memcpy4
Switches:            NONE
Hard/Soft Needs:
Abstract:        This test verifies the memcpy() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 01-May-92    edv            created


---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <malloc.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;

#define DELTA    2000
#define LARGEST (SHRT_MAX - DELTA)


int memcpy4Entry(){
    unsigned int count, i, buf_size;
    unsigned char *src, *dest;


    startest();


/*  Scenario 10: Verify that dest and src can be as large as
         LARGEST using any memory model.
*/

    buf_size = LARGEST;
    src = malloc( buf_size );
    if (src == NULL)
    {
       faill();
       exit( 1 );
    }

    dest = malloc( buf_size );
    if (dest == NULL)
    {
       faill();
       exit( 1 );
    }

    memset( src, '+', buf_size );
    memset( dest, '-', buf_size );
    count = buf_size;

    memcpy( dest, src, count );

    for (i = 0; i < count; i++)
       checke( dest[i], src[i] );


    free( src );
    free( dest );


    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\memicmp2.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl memicmp2.c
                     memicmp2
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the _memicmp() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests decribed in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 01-May-92    edv            created


---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;


static char buf1[15] = "ABCDEFGHIJKLMNO";
static char buf2[15] = "ABCDEFGHIJKLMNO";


int memicmp2Entry(){
    int outcome;
    size_t count;


    startest();


    count = sizeof( buf1 );


/*  Scenario 4: Verify that the function is, in fact, case insensitive
                by making the first letter in each buffer differ in the
                case (ie. 'abcd...' vs. 'Abcd...').
*/
    buf1[0] = 'a';
    outcome = 999;
    outcome = (int)_memicmp( buf1, buf2, count);
    checke( (outcome == 0), 1 );
    buf1[0] = 'A';



/*  Scenario 5: Verify that the function is, in fact, case insensitive
                by making the last letter in each buffer differ in the
                case (ie. 'abcD...' vs. 'abcd...').
*/
    buf1[count - 1] = 'o';
    outcome = -999;
    outcome = (int)_memicmp( buf1, buf2, count);
    checke( (outcome == 0), 1 );


    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\memicmp1.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl memicmp1.c
                     memicmp1
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the _memicmp() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests decribed in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 01-May-92    edv            created


---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;


static char buf1[51] = "aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyY";
static char buf2[51] = "AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYy";


int memicmp1Entry(){
    int outcome;
    size_t count;


    startest();


    count = sizeof( buf1 );


/*  Scenario 1: Verify that the function returns a negative value
                when buf1 < buf2.
*/
    buf1[49] = 'X';
    outcome = 0;
    outcome = (int)_memicmp( buf1, buf2, count);
    checke( (outcome < 0), 1 );
    buf1[49] = 'Y';



/*  Scenario 2: Verify that the function returns a positive value
                when buf1 > buf2.
*/
    buf1[49] = '{';
    outcome = -999;
    outcome = (int)_memicmp( buf1, buf2, count);
    checke( (outcome > 0), 1 );
    buf1[49] = 'Y';



/*  Scenario 3: Verify that the function returns zero when buf1 = buf2.
*/
    outcome = 999;
    outcome = (int)_memicmp( buf1, buf2, count);
    checke( (outcome == 0), 1 );


    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\memicm5.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:          cl memicmp5.c
             memicmp5
Switches:            NONE
Hard/Soft Needs:
Abstract:        This test verifies the _memicmp() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 01-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <malloc.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;

#define DELTA    2000
#define LARGEST (SHRT_MAX - DELTA)


int memicm5Entry(){
    int outcome;
    unsigned int buf_size;
    unsigned char *buf1, *buf2;
    size_t count;


    startest();



/*  Scenario 10: Verify that buf1 and buf2 can be as large as
         LARGEST using any memory model.
*/

    buf_size = LARGEST;

    buf1 = malloc( buf_size );
    if (buf1 == NULL)
    {
       faill();
       exit( 1 );
    }

    buf2 = malloc( buf_size );
    if (buf2 == NULL)
    {
       faill();
       exit( 1 );
    }

    memset( buf1, 'a', buf_size );
    memset( buf2, 'a', buf_size );
    count = buf_size;

    outcome = _memicmp( buf1, buf2, count );
    checke( (outcome == 0), 1 );


    buf1[buf_size - 1] = 'b';
    outcome = _memicmp( buf1, buf2, count );
    checke( (outcome > 0), 1 );
    buf1[buf_size - 1] = 'a';


    buf1[1] = '1';
    outcome = _memicmp( buf1, buf2, count );
    checke( (outcome < 0), 1 );


    free( buf1 );
    free( buf2 );


    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\memicmp4.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl memicmp4.c
                     memicmp4
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the _memicmp() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests decribed in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 01-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;


#define ONE             1
#define TWO             2
#define TWENTY         20
#define HUNDRED       100
#define THOUSAND     1000
#define TEN_THOU    10000
#define THIRTY_THOU 30000
#define DELTA        2000
#define ALMOST_MAX  (SHRT_MAX - DELTA)


/*  Scenario 8: Verify that buf1 and buf2 can be almost as large as
        SHRT_MAX when using SMALL model.
*/

static unsigned char buf1[ALMOST_MAX];
static unsigned char buf2[ALMOST_MAX];



int memicmp4Entry(){
    int c, d, outcome;
    size_t count;


    startest();


/*  Scenario 9: Verify that count can be anywhere in the range
        0 to aproximately SHRT_MAX when using SMALL model.
*/

    c = 'x';
    memset( buf1, c, sizeof( buf1 ) );
    memset( buf2, c, sizeof( buf2 ) );



    d = 'a';
    buf1[0] = d;

/* Note that buf1 is less than buf2, but count is zero,
   so it should return zero.
*/
    count = 0;
    outcome = 1;
    outcome = (int)_memicmp( buf1, buf2, count );
    checke( (outcome == 0), 1 );

    buf1[0] = c;



    d = 'y';
    buf1[(ALMOST_MAX - TEN_THOU)] = d;

    count = (ALMOST_MAX - TEN_THOU + 1);
    outcome = - 1;
    outcome = (int)_memicmp( buf1, buf2, count );
    checke( (outcome > 0), 1 );

    buf1[(ALMOST_MAX - TEN_THOU)] = c;



    for (count = ONE; count < TWENTY; count++)
    {
        outcome = -1;
        outcome = (int)_memicmp( buf1, buf2, count );
        checke( (outcome == 0), 1 );
    }



    d = 'd';
    for (count = HUNDRED; count < (HUNDRED + TWENTY); count++)
    {
        buf1[count - 1] = d;
        outcome = 0;
        outcome = (int)_memicmp( buf1, buf2, count );
        checke( (outcome < 0), 1 );
        buf1[count - 1] = c;
    }



    d = 'y';
    for (count = THOUSAND; count < (THOUSAND + TWENTY); count++)
    {
        buf1[count - 1] = d;
        outcome = 0;
        outcome = (int)_memicmp( buf1, buf2, count );
        checke( (outcome > 0), 1 );
        buf1[count - 1] = c;
    }



    for (count = TEN_THOU; count < (TEN_THOU + TWENTY); count++)
    {
        outcome = -1;
        outcome = (int)_memicmp( buf1, buf2, count );
        checke( (outcome == 0), 1 );
    }



    d = 'W';
    for (count = THIRTY_THOU; count < (THIRTY_THOU + TWENTY); count++)
    {
        buf1[count - 1] = d;
        outcome = 1;
        outcome = (int)_memicmp( buf1, buf2, count );
        checke( (outcome < 0), 1 );
        buf1[count - 1] = c;
    }



    d = '{';
    for (count = (ALMOST_MAX - TWENTY); count < ALMOST_MAX; count++)
    {
        buf1[count - 1] = d;
        outcome = 0;
        outcome = (int)_memicmp( buf1, buf2, count );
        checke( (outcome > 0), 1 );
        buf1[count - 1] = c;
    }




    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\memicmp3.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl /AL memicmp3.c
                     memicmp3
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the _memicmp() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        Must be compiled with LARGE STRING model.
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests decribed in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 01-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;


#define ONE            1
#define TWENTY        20
#define HUNDRED      100
#define THOUSAND    1000
#define TEN_THOU   10000
#define FORTY_THOU 40000

#define TWO	2
#ifdef QA_SIMPLE_QALIB
#define MAX_STEPS TWO
#else
#define MAX_STEPS TWENTY
#endif


/*  Scenario 6: Verify that buf1 and buf2 can be as large as
        USHRT_MAX when using LARGE model.
*/

static unsigned char buf1[USHRT_MAX];
static unsigned char buf2[USHRT_MAX];



int memicmp3Entry(){
    int c, d, outcome;
    size_t count;


    startest();


/*  Scenario 7: Verify that count can be anywhere in the range
        0 to USHRT_MAX when using the LARGE model.
*/

    c = 'x';
    memset( buf1, c, sizeof( buf1 ) );
    memset( buf2, c, sizeof( buf2 ) );



    d = 'a';
    buf1[0] = d;

/* Note that buf1 is less than buf2, but count is zero,
   so it should return zero.
*/
    count = 0;
    outcome = 1;

    outcome = (int)_memicmp( buf1, buf2, count );
    checke( (outcome == 0), 1 );

    buf1[0] = c;



    d = 'z';
    buf1[(USHRT_MAX - TEN_THOU)] = d;
    count = (USHRT_MAX - TEN_THOU + 1);
    outcome = - 1;

    outcome = (int)_memicmp( buf1, buf2, count );
    checke( (outcome > 0), 1 );

    buf1[(USHRT_MAX - TEN_THOU)] = c;



    for (count = ONE; count < TWENTY; count++)
    {
        outcome = -1;
        outcome = (int)_memicmp( buf1, buf2, count );
        checke( (outcome == 0), 1 );
    }



    d = 'd';
    for (count = HUNDRED; count < (HUNDRED + MAX_STEPS ); count++)
    {
        buf1[count - 1] = d;
        outcome = 0;
        outcome = (int)_memicmp( buf1, buf2, count );
        checke( (outcome < 0), 1 );
        buf1[count - 1] = c;
    }



    d = 'y';
    for (count = THOUSAND; count < (THOUSAND + MAX_STEPS ); count++)
    {
        buf1[count - 1] = d;
        outcome = 0;
        outcome = (int)_memicmp( buf1, buf2, count );
        checke( (outcome > 0), 1 );
        buf1[count - 1] = c;
    }

#ifndef QA_SIMPLE_QALIB

    for (count = TEN_THOU; count < (TEN_THOU + MAX_STEPS ); count++)
    {
        outcome = -1;
        outcome = (int)_memicmp( buf1, buf2, count );
        checke( (outcome == 0), 1 );
    }



    d = 'w';
    for (count = FORTY_THOU; count < (FORTY_THOU + MAX_STEPS ); count++)
    {
        buf1[count - 1] = d;
        outcome = 1;
        outcome = (int)_memicmp( buf1, buf2, count );
        checke( (outcome < 0), 1 );
        buf1[count - 1] = c;
    }


    d = '{';
    for (count = (USHRT_MAX - MAX_STEPS ); count < USHRT_MAX; count++)
    {
        buf1[count - 1] = d;
        outcome = 0;
        outcome = (int)_memicmp( buf1, buf2, count );
        checke( (outcome > 0), 1 );
        buf1[count - 1] = c;
    }

#endif

    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\memmove1.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl memmove1.c
                     memmove1
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the memmove() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include MEMORY.H
                     Tests described in the testplan MEMORY.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 22-Apr-92    edv            created


---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;


static char src[45]  = "A1 B2 C3 D4 E5 F6 G7 H8 I9 J0 Kk Ll Mm Nn Oo ";

static char bsl1[45] = "F6 G7 H8 I9 J0 Kk Ll Mm Nn Oo Kk Ll Mm Nn Oo ";
static char bsl2[45] = "A1 B2 C3 D4 E5 A1 B2 C3 D4 E5 F6 G7 H8 I9 J0 ";


int memmove1Entry(){
    int i;
    size_t count;
    char dest[45];
    char *pdest;



    startest();


/*  Scenario 1: Verify that the function returns a pointer to dest.
*/

    count = sizeof( src );
    pdest = memmove( dest, src, count );
    checke( pdest, dest );



/*  Scenario 2: Verify that if src overlaps dest, the original source bytes
                in the overlapping region are copied before being overwritten.
*/

    for (i = 0; i < (int) count; i++)             /* Initialize dest */
        dest[i] = src[i];

    count = 30;

    pdest = memmove( dest, dest + 15, count );

    for (i = 0; i < sizeof( dest ); i++)
        checke( dest[i], bsl1[i] );



/*  Scenario 3: Verify that if dest overlaps src, the original source bytes
                in the overlapping region are copied before being overwritten.
*/

    for (i = 0; i < sizeof( dest ); i++)    /* Initialize dest */
        dest[i] = src[i];

    count = 30;

    pdest = memmove( dest + 15, dest, count );

    for (i = 0; i < sizeof( dest ); i++)
        checke( dest[i], bsl2[i]);



    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\memicmp5.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl memicmp5.c
                     memicmp5
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the _memicmp() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 01-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <malloc.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;

#define DELTA    2000
#define LARGEST (SHRT_MAX - DELTA)


int memicmp5Entry(){
    int outcome;
    unsigned int buf_size;
    unsigned char *buf1, *buf2;
    size_t count;


    startest();



/*  Scenario 10: Verify that buf1 and buf2 can be as large as
         LARGEST using any memory model.
*/

       buf_size = LARGEST;

       buf1 = malloc( buf_size );
       if (buf1 == NULL)
       {
          faill();
          exit( 1 );
       }

       buf2 = malloc( buf_size );
       if (buf2 == NULL)
       {
          faill();
          exit( 1 );
       }

       memset( buf1, 'a', buf_size );
       memset( buf2, 'a', buf_size );
       count = buf_size;

       outcome = (int)_memicmp( buf1, buf2, count );
       checke( (outcome == 0), 1 );


       buf1[buf_size - 1] = 'b';
       outcome = (int)_memicmp( buf1, buf2, count );
       checke( (outcome > 0), 1 );
       buf1[buf_size - 1] = 'a';


       buf1[1] = '1';
       outcome = (int)_memicmp( buf1, buf2, count );
       checke( (outcome < 0), 1 );




    free( buf1 );
    free( buf2 );


    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\memmove3.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl memmove3.c
                     memmove3
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the memmove() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 06-May-92    edv            created


---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;

#define ZERO            0
#define TWENTY         20
#define HUNDRED       100
#define THOUSAND     1000
#define TEN_THOU    10000
#define THIRTY_THOU 30000
#define DELTA        2000
#define ALMOST_MAX  (SHRT_MAX - DELTA)


/*  Scenario 6 Verify that dest and src can be almost as large as
        SHRT_MAX when using SMALL model.
*/

static unsigned char src[ALMOST_MAX];
static unsigned char dest[ALMOST_MAX] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
static unsigned char ivals[10] = "!@#$%^&*()";


int memmove3Entry(){
    unsigned int count, i, j;


    startest();


/*  Scenario 7: Verify that count can be anywhere in the range
         0 to aproximately SHRT_MAX when using SMALL model.
*/

    memset( src, '+', ALMOST_MAX );

    for (count = ZERO, i = ZERO; count < TWENTY; count++, i++)
    {
        memset( src, ivals[i], count );
        if (i == 9) i = 0;
        memmove( dest, src, count );
        for (j = 0; j < count; j++)
            checke( dest[j], src[j] );
    }



    memset( src, '-', ALMOST_MAX );
    i = 0;

    for (count = HUNDRED; count < (HUNDRED + TWENTY); count++, i++)
    {
        memset( src, ivals[i], count );
        if (i == 9) i = 0;
        memmove( dest, src, count );
        for (j = 0; j < count; j++)
            checke( dest[j], src[j] );
    }



    memset( src, '=', ALMOST_MAX );
    i = 0;

    for (count = THOUSAND; count < (THOUSAND + TWENTY); count++, i++)
    {
        memset( src, ivals[i], count );
        if (i == 9) i = 0;
        memmove( dest, src, count );
        for (j = 0; j < count; j++)
            checke( dest[j], src[j] );
    }


#ifndef QA_SIMPLE_QALIB

    memset( src, '{', ALMOST_MAX );
    i = 0;

    for (count = TEN_THOU; count < (TEN_THOU + TWENTY); count++, i++)
    {
        memset( src, ivals[i], count );
        if (i == 9) i = 0;
        memmove( dest, src, count );
        for (j = 0; j < count; j++)
            checke( dest[j], src[j] );
    }




    memset( src, '}', ALMOST_MAX );
    i = 0;

    for (count = THIRTY_THOU; count < (THIRTY_THOU + TWENTY); count++, i++)
    {
        memset( src, ivals[i], count );
        if (i == 9) i = 0;
        memmove( dest, src, count );
        for (j = 0; j < count; j++)
            checke( dest[j], src[j] );
    }




    memset( src, '|', ALMOST_MAX );
    i = 0;

    for (count = (ALMOST_MAX - TWENTY); count < ALMOST_MAX; count++, i++)
    {
        memset( src, ivals[i], count );
        if (i == 9) i = 0;
        memmove( dest, src, count );
        for (j = 0; j < count; j++)
            checke( dest[j], src[j] );
    }
#endif
    
    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\memmove4.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl memmove4.c
                     memmove4
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the memmove() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 06-May-92    edv            created


---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <malloc.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;

#define DELTA    2000
#define LARGEST (SHRT_MAX - DELTA)


int memmove4Entry(){
    unsigned int count, i, buf_size;
    unsigned char *src, *dest;

    startest();


/*  Scenario 10: Verify that dest and src can be as large as
         LARGEST using any memory model.
*/

       buf_size = LARGEST;

       src = malloc( buf_size );
       if (src == NULL)
       {
          faill();
          exit( 1 );
       }

       dest = malloc( buf_size );
       if (dest == NULL)
       {
          faill();
          exit( 1 );
       }

       memset( src, '+', buf_size );
       memset( dest, '-', buf_size );
       count = buf_size;

       memmove( dest, src, count );

       for (i = 0; i < count; i++)
           checke( dest[i], src[i] );



    free( src );
    free( dest );


    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\memmove2.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl /AL memmove2.c
                     memmove2
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the memmove() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        Must be compiled with LARGE memory model.
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 06-May-92    edv            created


---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;

#define ZERO           0
#define TWENTY        20
#define HUNDRED      100
#define THOUSAND    1000
#define TEN_THOU   10000
#define FORTY_THOU 40000

#define TWO	2
#ifdef QA_SIMPLE_QALIB
#define MAX_STEPS TWO
#else
#define MAX_STEPS TWENTY
#endif


/*  Scenario 4: Verify that dest and src can be as large as
        USHRT_MAX when using LARGE model.

*/

static unsigned char src[USHRT_MAX];
static unsigned char dest[USHRT_MAX] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
static unsigned char ivals[10] = "!@#$%^&*()";


int memmove2Entry(){
    int i;
    unsigned int count, j;

    startest();


/*  Scenario 5: Verify that count can be anywhere in the range
        0 to USHRT_MAX when using LARGE model.

*/

    memset( src, '+', USHRT_MAX );


    for (count = ZERO, i = ZERO; count < TWENTY; count++, i++)
    {
        memset( src, ivals[i], count );
        if (i == 9) i = 0;
        memmove( dest, src, count );
        for (j = 0; j < count; j++)
            checke32( dest[j], src[j] );
    }




    memset( src, '-', USHRT_MAX );


    for (count = HUNDRED, i = ZERO; count < (HUNDRED + MAX_STEPS); count++, i++)
    {
        memset( src, ivals[i], count );
        if (i == 9) i = 0;
        memmove( dest, src, count );
        for (j = 0; j < count; j++)
            checke32( dest[j], src[j] );
    }




    memset( src, '=', USHRT_MAX );


    for (count = THOUSAND, i = ZERO; count < (THOUSAND + MAX_STEPS); count++, i++)
    {
        memset( src, ivals[i], count );
        if (i == 9) i = 0;
        memmove( dest, src, count );
        for (j = 0; j < count; j++)
            checke32( dest[j], src[j] );
    }



#ifndef QA_SIMPLE_QALIB

    memset( src, '{', USHRT_MAX );


    for (count = TEN_THOU, i = 0; count < (TEN_THOU + MAX_STEPS); count++, i++)
    {
        memset( src, ivals[i], count );
        if (i == 9) i = 0;
        memmove( dest, src, count );
        for (j = 0; j < count; j++)
            checke32( dest[j], src[j] );
    }





    memset( src, '}', USHRT_MAX );


    for (count = FORTY_THOU, i = 0; count < (FORTY_THOU + MAX_STEPS); count++, i++)
    {
        memset( src, ivals[i], count );
        if (i == 9) i = 0;
        memmove( dest, src, count );
        for (j = 0; j < count; j++)
            checke32( dest[j], src[j] );
    }



    memset( src, '|', USHRT_MAX );



    for (count = (USHRT_MAX - MAX_STEPS), i = 0; count < USHRT_MAX; count++, i++)
    {
        memset( src, ivals[i], count );
        if (i == 9) i = 0;
        memmove( dest, src, count );
        for (j = 0; j < count; j++)
            checke32( dest[j], src[j] );
    }

#endif

    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\memset2.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl /AL memset2.c
                     memset2
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the memset() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        Must be compiled using LARGE model
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0]  1-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;

#define TWO            2
#define TWENTY        20
#define HUNDRED      100
#define THOUSAND    1000
#define TEN_THOU   10000
#define FORTY_THOU 40000

#define TWO	2
#ifdef QA_SIMPLE_QALIB
#define MAX_STEPS TWO
#else
#define MAX_STEPS TWENTY
#endif

/*  Scenario 3: Verify that buf can be as large as USHRT_MAX
                when using LARGE model.
*/

static unsigned char dest[USHRT_MAX] = "813748973498 JUNK 71239847981237481720177";


int memset2Entry(){
    int c, d;
    size_t count;
    unsigned char *pdest;



    startest();



/*  Scenario 4: Verify that count can be anywhere in the range of
        0 to USHRT_MAX when using the LARGE model.
*/
    c = 'A';

    count = 0;
    pdest = memset( dest, c, count );
    checke( pdest, dest );
    checke( dest[0], '8' );            /*  still 8 because count = 0  */



    d = 0x00;

    for (count = TWO; count < TWENTY; count++)
    {
        dest[count] = d;                   /* NULL to terminate string */
        pdest = memset( dest, c, count );
        checke( dest[0], c );
        checke( dest[count - 1], c );
        checke( dest[count], d );
        dest[count] = c;
    }



    for (count = HUNDRED; count < (HUNDRED + MAX_STEPS); count++)
    {
        dest[count] = d;                   /* NULL to terminate string */
        pdest = memset( dest, c, count );
        checke( dest[0], c );
        checke( dest[count - 1], c );
        checke( dest[count], d );
        dest[count] = c;
    }


    for (count = THOUSAND; count < (THOUSAND + MAX_STEPS); count++)
    {
        dest[count] = d;                   /* NULL to terminate string */
        pdest = memset( dest, c, count );
        checke( dest[0], c );
        checke( dest[count - 1], c );
        checke( dest[count], d );
        dest[count] = c;
    }


    for (count = TEN_THOU; count < (TEN_THOU + MAX_STEPS); count++)
    {
        dest[count] = d;                   /* NULL to terminate string */
        pdest = memset( dest, c, count );
        checke( dest[0], c );
        checke( dest[count - 1], c );
        checke( dest[count], d );
        dest[count] = c;
    }


    for (count = FORTY_THOU; count < (FORTY_THOU + MAX_STEPS); count++)
    {
        dest[count] = d;                   /* NULL to terminate string */
        pdest = memset( dest, c, count );
        checke( dest[0], c );
        checke( dest[count - 1], c );
        checke( dest[count], d );
        dest[count] = c;
    }


    for (count = (USHRT_MAX - MAX_STEPS); count < USHRT_MAX; count++)
    {
        dest[count] = d;                   /* NULL to terminate string */
        pdest = memset( dest, c, count );
        checke( dest[0], c );
        checke( dest[count - 1], c );
        checke( dest[count], d );
        dest[count] = c;
    }


    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\memset3.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl memset3.c
                     memset3
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the memset() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0]  1-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;


#define ZERO            0
#define TWO             2
#define TWENTY         20
#define HUNDRED       100
#define THOUSAND     1000
#define TEN_THOU    10000
#define THIRTY_THOU 30000
#define DELTA        1850
#define ALMOST_MAX  (SHRT_MAX - DELTA)


/*  Scenario 5: Verify that dest can be almost as large as
        SHRT_MAX when using SMALL model.
*/

static unsigned char dest[ALMOST_MAX] = "813748973498 JUNK 71239847981237481720177";


int memset3Entry(){
    int c, d;
    size_t count;
    unsigned char *pdest;



    startest();



/*  Scenario 6: Verify that count can be anywhere in the range of
        0 to USHRT_MAX when using the LARGE model.
*/
    c = 'A';

    count = 0;
    pdest = memset( dest, c, count );
    checke( pdest, dest );
    checke( dest[0], '8' );            /*  still 8 because count = 0  */



    d = 0x00;

    for (count = TWO; count < TWENTY; count++)
    {
        dest[count] = d;                   /* NULL to terminate string */
        pdest = memset( dest, c, count );
        checke( dest[0], c );
        checke( dest[count - 1], c );
        checke( dest[count], d );
        dest[count] = c;
    }



    for (count = HUNDRED; count < (HUNDRED + TWENTY); count++)
    {
        dest[count] = d;                   /* NULL to terminate string */
        pdest = memset( dest, c, count );
        checke( dest[0], c );
        checke( dest[count - 1], c );
        checke( dest[count], d );
        dest[count] = c;
    }


    for (count = THOUSAND; count < (THOUSAND + TWENTY); count++)
    {
        dest[count] = d;                   /* NULL to terminate string */
        pdest = memset( dest, c, count );
        checke( dest[0], c );
        checke( dest[count - 1], c );
        checke( dest[count], d );
        dest[count] = c;
    }


    for (count = TEN_THOU; count < (TEN_THOU + TWENTY); count++)
    {
        dest[count] = d;                   /* NULL to terminate string */
        pdest = memset( dest, c, count );
        checke( dest[0], c );
        checke( dest[count - 1], c );
        checke( dest[count], d );
        dest[count] = c;
    }


    for (count = THIRTY_THOU; count < (THIRTY_THOU + TWENTY); count++)
    {
        dest[count] = d;                   /* NULL to terminate string */
        pdest = memset( dest, c, count );
        checke( dest[0], c );
        checke( dest[count - 1], c );
        checke( dest[count], d );
        dest[count] = c;
    }


    for (count = (ALMOST_MAX - TWENTY); count < ALMOST_MAX; count++)
    {
        dest[count] = d;                   /* NULL to terminate string */
        pdest = memset( dest, c, count );
        checke( dest[0], c );
        checke( dest[count - 1], c );
        checke( dest[count], d );
        dest[count] = c;
    }



    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\sources.inc ===
TARGETTYPE=LIBRARY
TARGETPATH=..\..\lib

SOURCES=\
	strerror1.c \
	strerror2.c \
	strerror3.c \
	_stricol.c \
	strlwr1.c \
	strlwr2.c \
	strlwr3.c \
	strupr1.c \
	strupr2.c \
	strupr3.c \
	memccpy1.c \
	memccpy2.c \
	memccpy3.c \
	memccpy4.c \
	memccpy5.c \
	memchr1.c \
	memchr2.c \
	memchr3.c \
	memchr4.c \
	memchr5.c \
	memcmp1.c \
	memcmp2.c \
	memcmp3.c \
	memcmp4.c \
	memcpy1.c \
	memcpy2.c \
	memcpy3.c \
	memcpy4.c \
	memicm5.c \
	memicmp1.c \
	memicmp2.c \
	memicmp3.c \
	memicmp4.c \
	memicmp5.c \
	memmove1.c \
	memmove2.c \
	memmove3.c \
	memmove4.c \
	memset1.c \
	memset2.c \
	memset3.c \
	memset4.c \
	strcat1.c \
	strcat2.c \
	strchr1.c \
	strchr2.c \
	strchr3.c \
	strchr4.c \
	strcmp1.c \
	strcmp2.c \
	strcmp3.c \
	strcmp4.c \
	strcoll1.c \
	strcoll2.c \
	strcoll3.c \
	strcoll4.c \
	strcpy1.c \
	strcpy2.c \
	strcpy3.c \
	strcspn1.c \
	strcspn2.c \
	strcspn3.c \
	strcspn4.c \
	strdup1.c \
	strdup2.c \
	strdup3.c \
	stricmp1.c \
	stricmp2.c \
	strlen1.c \
	strlen2.c \
	strncat1.c \
	strncat2.c \
	strncmp1.c \
	strncmp2.c \
	strncmp3.c \
	strncpy1.c \
	strncpy2.c \
	strncpy3.c \
	strnicm1.c \
	strnicm2.c \
	strnicm3.c \
	strnicm4.c \
	strnset1.c \
	strnset2.c \
	strnset3.c \
	strpbrk1.c \
	strpbrk2.c \
	strpbrk3.c \
	strpbrk4.c \
	strrchr1.c \
	strrchr2.c \
	strrchr3.c \
	strrchr4.c \
	strrev1.c \
	strrev2.c \
	strrev3.c \
	strset1.c \
	strset2.c \
	strset3.c \
	strstr1.c \
	strstr2.c \
	strtok1.c \
	strtok2.c \
	strtol1.c \
	strtol2.c \
	strtoul1.c \
	strtoul2.c \
	strxfrm1.c \
	strxfrm2.c \
	tstrchr2.c \
	tstrncat.c \
	tstrncpy.c \
	tstrstr2.c \
	drv.c

INCLUDES=$(BASEDIR)\private\test\crttests\test\clib;$(SDK_INC_PATH)

MSC_WARNING_LEVEL=/W2
MSC_OPTIMIZATION=/Od

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\memset1.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl memset1.c
                     memset1
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the memset() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0]  1-May-92    edv            created


---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;


static unsigned char buf[20] = "AaBbCcDdEeFfGgHhIiJj";


int memset1Entry(){
    int c, i;
    size_t count;
    unsigned char *pbuf;

    startest();


/*  Scenario 1: Verify that the function returns a pointer to dest.
*/

    count = 5;
    buf[count] = '*';

    pbuf = memset( buf, '%', count );

    checke( pbuf, buf );

    for (i = 0; i < (int) count; i++)
        checke( buf[i], '%' );

    checke( buf[count], '*' );





/*  Scenario 2: Verify that c can be any value from 0 to UCHAR_MAX.
*/

    count = 10;

    for (c = 0; c < UCHAR_MAX; c++)
    {
        buf[count] = '*';

        pbuf = memset( buf, c, count );

        for (i = 0; i < (int) count; i++)
            checke( buf[i], c );

        checke( buf[count], '*' );

    }




    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\memset4.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:          cl memset4.c
             memset4
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the _fmemset() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0]  1-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <malloc.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;

#define DELTA    2000
#define LARGEST  (USHRT_MAX - DELTA)


int memset4Entry(){
    int c, d;
    unsigned int dest_size;
    unsigned char *pdest1, *pdest2;



    startest();



/*  Scenario 7: Verify that dest can be as large as LARGEST
                using any STRING model.
*/



    dest_size = LARGEST;

    pdest1 = malloc( dest_size + 1 );    /* add 1 to delimit memory */
    if (pdest1 == NULL)
    {
       faill();
       exit( 1 );
    }

    c = '+';
    d = '\0';
    pdest1[dest_size] = d;

    pdest2 = memset( pdest1, c, dest_size );

    checke( pdest2, pdest1 );
    checke( pdest1[0], c );
    checke( pdest1[dest_size - 1], c );
    checke( pdest1[dest_size], d );


    free( pdest1 );


    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strcat1.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strcat1.c
                     strcat1
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the strcat() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 05-May-92    edv            created


---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;


static char nullstr1[20] = "\0";
static char nullstr2[20] = "\0";
static char nullstr3[20] = "\0";

static char string1[20] = "String 1";
static char string2[20] = "String 2";

static char baseln1[] = "String 1String 2";
#define length1 16

static char baseln2[] = "String 2";
#define length2 8



int strcat1Entry(){
    int i;
    char *pstr;


    startest();



/*  Scenario 1: Verify that a pointer to string1 is returned.
*/
    pstr = strcat( string1, string2 );
    checke( pstr, string1 );

    for (i = 0; i < length1; i++)
        checke( pstr[i], baseln1[i] );





/*  Scenario 2: Verify that the function works correctly when
                string1 is a null string.
*/
    pstr = strcat( nullstr1, string2 );

    for (i = 0; i < length2; i++)
        checke( pstr[i], baseln2[i] );





/*  Scenario 3: Verify that the function works correctly when
                string2 is a null string.
*/
    pstr = strcat( string2, nullstr2 );

    for (i = 0; i < length2; i++)
        checke( pstr[i], baseln2[i] );





/*  Scenario 4: Verify that the function works correctly when
                both strings are null strings.
*/
    pstr = strcat( nullstr2, nullstr3 );

    checke( pstr[0], '\0' );





/*  Scenario 5: Verify that the function works correctly when
                string2 is only one byte long.
*/
    pstr = strcat( nullstr2, "1" );

    checke( pstr[0], '1' );
    checke( pstr[1], '\0' );





    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strcat2.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strcat2.c
                     strcat2
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the strcat() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 05-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;


#define DELTA 2000
#define ALMOST_MAX  (SHRT_MAX - DELTA)

static unsigned char max_str1[ALMOST_MAX] = "\0";
static unsigned char max_str2[ALMOST_MAX];

static unsigned char string1[10] = "\0";
static unsigned char string2[10] = "A1B2C3D4 ";



int strcat2Entry(){
    int c, i;
    unsigned char *pstr;

    startest();




/*  Scenario 6: Verify that string2 can contain any value from
                0 to UCHAR_MAX.
*/

    for (c = 0; c <= UCHAR_MAX; c++)
    {
        string2[8] = c;
        pstr = strcat( string1, string2 );

        for (i = 0; i < 10; i++)
            checke( pstr[i], string2[i]);

        string1[0] = '\0';
    }





/*  Scenario 7: Verify that string1 and string2 can be almost as
        large as SHRT_MAX.
*/

    memset( max_str2, '*', sizeof( max_str2 ) );
    max_str2[ALMOST_MAX - 2] = 'X';
    max_str2[ALMOST_MAX - 1] = '\0';

    pstr = strcat( max_str1, max_str2);

    checke( pstr[0], max_str2[0] );
    checke( pstr[ALMOST_MAX / 2], max_str2[ALMOST_MAX / 2] );
    checke( pstr[ALMOST_MAX - 2], 'X' );
    checke( pstr[ALMOST_MAX - 1], '\0' );

    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strchr1.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strchr1.c
                     strchr1
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the strchr() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 06-May-92    edv            created


---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;


static char string[50] = "AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYy";
/*                       1         2         3         4         5
*/


int strchr1Entry(){
    int c;
    char *pstr;

    startest();


/*  Scenario 1: Verify that if successful, a pointer to the first location
                of c in string is returned.
*/
    c = 'o';
    pstr = strchr( string, c );

/*  Subtract one because relative addresses start at plus 0
*/
    checke( pstr, (string + 30 - 1) );



/*  Scenario 2: Verify that if unsuccessful, a NULL pointer is returned.
*/
    c = 'z';
    pstr = strchr( string, c );
    checkNULL( pstr );



/*  Scenario 3: Verify that the function works correctly when c occurs
                in the first byte of string.
*/
    c = 'A';
    pstr = strchr( string, c );
    checke( pstr, string );



/*  Scenario 4: Verify that the function works correctly when c occurs
                in the last byte of string.
*/
    c = 'y';
    pstr = strchr( string, c );

/*  Subtract one because relative addresses start at plus 0
*/
    checke( pstr, (string + 50 - 1) );



    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strcmp1.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strcmp1.c
                     strcmp1
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the strcmp() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests decribed in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 09-Apr-92    edv            created


---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;


static char stringval1[51] = "AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYy";
static char stringval2[51] = "AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxyz";
/*                                                                  ^
                                                         ___________|
*/

int strcmp1Entry(){
    int i, outcome;
    char string1[51], string2[51];

    startest();


/*  Scenario 1: Verify that the function returns a negative value
                when string1 < string2.
*/
    for (i = 0; i < 51; i++ )
    {
        string1[i] = stringval1[i];
        string2[i] = stringval2[i];
    }
    outcome = 999;
    outcome = strcmp( string1, string2 );
    checke( (outcome < 0), 1 );



/*  Scenario 2: Verify that the function returns a positive value
                when string1 > string2.
*/
    for (i = 0; i < 51; i++ )
    {
        string1[i] = stringval2[i];
        string2[i] = stringval1[i];
    }
    outcome = -999;
    outcome = strcmp( string1, string2 );
    checke( (outcome > 0), 1 );



/*  Scenario 3: Verify that the function returns zero when string1 = string2.
*/
    for (i = 0; i < 51; i++ )
    {
        string1[i] = stringval1[i];
        string2[i] = stringval1[i];
    }
    outcome = 999;
    outcome = strcmp( string1, string2 );
    checke( (outcome == 0), 1 );


    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strchr2.c ===
/***************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strchr2.c
                     strchr2
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the strchr() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 06-May-92    edv            created
 [ 1] 28-Jan-98    a-hemalk       fixed 64bit warning (C4311) - fixed

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;

static unsigned char string[20] = "abcdefghijklmnopqrst";


int strchr2Entry(){
    int c;
    unsigned char *pstr;

    startest();


/*  Scenario 5: Verify that c can be any value from 0 to UCHAR_MAX,
                and will be recognized as the character to be found.
*/

    for (c = 0; c < 'a'; c++) {
        string[9] = c;
        pstr = strchr( string, c );
        checknNULL(pstr);
    }


/*  Change string in string because first occurence will be found.
*/

    strcpy( string, "ABCDEFGHIJKLMNOPQRST" );

    for (c = 'a'; c <= UCHAR_MAX; c++) {
        string[9] = c;
        pstr = strchr( string, c );
        checknNULL(pstr);
    }



    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strcmp2.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strcmp2.c
                     strcmp2
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the strcmp() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests decribed in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 08-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;


#define DELTA        2000
#define ALMOST_MAX  (SHRT_MAX - DELTA)


/*  Scenario 6: Verify that string1 and string2 can be almost
        as large as SHRT_MAX.
*/

static unsigned char string1[ALMOST_MAX];
static unsigned char string2[ALMOST_MAX];



int strcmp2Entry(){
    int outcome;



    startest();



    memset( string1, 'x', sizeof( string1 ) );
    memset( string2, 'x', sizeof( string2 ) );
    string1[ALMOST_MAX - 1] = '\0';
    string2[ALMOST_MAX - 1] = '\0';


    outcome = 1;
    outcome = strcmp( string1, string2 );
    checke( (outcome == 0), 1 );



    string1[ALMOST_MAX - 2] = 'W';
    string2[ALMOST_MAX - 2] = 'w';

    outcome = 1;
    outcome = strcmp( string1, string2 );
    checke( (outcome < 0), 1 );



    string1[ALMOST_MAX - 3] = 'y';

    outcome = -1;
    outcome = strcmp( string1, string2 );
    checke( (outcome > 0), 1 );




    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strchr3.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strchr3.c
                     strchr3
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the strchr() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 08-May-92    edv            created
 [ 1] 28-Jan-98    a-hemalk       64bit warning (C4311) fix.

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;

#define DELTA        4000
#define ALMOST_MAX  (USHRT_MAX - DELTA)


/*  Scenario 6: Verify that string can be almost as large as USHRT_MAX.
*/

static unsigned char string[ALMOST_MAX];



int strchr3Entry(){
    int c;
    unsigned char *pstr;


    startest();



    c = '^';
    memset( string, c, sizeof(string) );  /* Fill string with '^'        */
    string[ALMOST_MAX - 1] = '\0';        /* NULL terminate the string   */




    pstr = strchr( string, '#' );
    checkNULL( pstr );                    /* NULL because no # in string */





    string[ALMOST_MAX - 2] = 'X';
    pstr  = strchr( string, 'X' );
    checknNULL(pstr);





    string[100] = 'X';
    pstr  = strchr( string, 'X' );
    checknNULL(pstr);   /* Ensure that we did find occurence - and not a null */



    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strchr4.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:          cl strchr4.c
             strchr4
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the _fstrchr() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 08-May-92    edv            created
 [ 1] 28-Jan-98    a-hemalk       64bit warning (C4311) fix


---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <malloc.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;

#define DELTA    2000
#define LARGEST  (USHRT_MAX - DELTA)


int strchr4Entry(){
    int c;
    unsigned int str_size;
    unsigned char *pstr1, *pstr2;

    startest();


/*  Scenario 7: Verify that str can be as large as LARGEST
                using any memory model.
*/

    str_size = LARGEST;

    pstr1 = malloc( str_size );
    if (pstr1 == NULL)
    {
       faill();
       exit( 1 );
    }
    memset( pstr1, '+', str_size );
    pstr1[str_size - 1] = '\0';

    pstr1[str_size - 100] = c = 'X';
    pstr2 = strchr( pstr1, c );

    checknNULL(pstr2);

    free( pstr1 );


    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strcmp3.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:          cl strcmp3.c
             strcmp3
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the _fstrcmp() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 08-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <malloc.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;

#define DELTA    2000
#define LARGEST (SHRT_MAX - DELTA)


int strcmp3Entry(){
    int outcome;
    unsigned int string_size;
    unsigned char *string1, *string2;


    startest();


/*  Scenario 5: Verify that string1 and string2 can be
        as large as LARGEST.
*/

    string_size = LARGEST;

    string1 = malloc( string_size );
    if (string1 == NULL)
    {
       faill();
       exit( 1 );
    }

    string2 = malloc( string_size );
    if (string2 == NULL)
    {
       faill();
       exit( 1 );
    }

    memset( string1, 'a', string_size );
    string1[string_size - 1] = '\0';

    memset( string2, 'a', string_size );
    string2[string_size - 1] = '\0';



    outcome = -1;
    outcome = strcmp( string1, string2 );
    checke( (outcome == 0), 1 );



    string1[string_size - 2] = 'b';
    outcome = 0;
    outcome = strcmp( string1, string2 );
    checke( (outcome > 0), 1 );
    string1[string_size - 2] = 'a';


    string2[string_size - 2] = 'd';
    outcome = -1;
    outcome = strcmp( string1, string2 );
    checke( (outcome < 0), 1 );




    free( string1 );
    free( string2 );


    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strcmp4.c ===
/***************************************************************************

		   Copyright (c) 1994 Microsoft Corporation

Test:       strcmp

Abstract:   Verify strcmp()with strings that contain control characters.

===========================================================================
Syntax

===========================================================================
Priority:               1
Products:               WIN NT


Revision History:

    Date        emailname   description
----------------------------------------------------------------------------
    11-May-94   a-timke     created
----------------------------------------------------------------------------

EndHeader:

****************************************************************************/
#include <string.h>
#include <test.h>

static char    test[] = __FILE__;
static int     perfect=0;

typedef struct TSTRINGTEST
{
  char *String1;
  char *String2;
  int   ExpectedResult;
} tStringTest;

//
// Tests for strcmp().
//
int strcmp4Entry ( void ){
  static tStringTest rgStringTest[] =
  {    
    {"Strings that are the same.\n",     "Strings that are the same.\n", 0},
    {"Strings that are not the same.\n", "Strings THAT are not same.\n", 1},
    {"Strings THAT are not the same.\n", "Strings that are not same.\n", -1},

    {"\n",       "\n",          0},
    {"\n",       "",            1},
    {"",         "\n",         -1},

    {"\a",       "\a",          0},
    {"\a",       "",            1},
    {"",         "\a",         -1},

    {"\a\b\a\b", "\a\b\a\b",    0},
    {"\a\b\a\b", "",            1},
    {"",         "\a\b\a\b",   -1},

    {"a\a\bb",   "a\a\bb",      0},
    {"ab",       "a\a\bb",      1},
    {"a\a\bb",   "ab",         -1},

    {"\n\v\n\v", "\n\v\n\v",    0},
    {"\n\v\n\v", "",            1},
    {"",         "\n\v\n\v",   -1},

    {"\a\n\vb", "\a\n\vb",      0},
    {"ab",      "\a\n\vb",      1},
    {"\a\n\vb", "ab",          -1},

    {"\r\n\n\r\n", "\r\n\n\r\n", 0},
    {"\r\n\n\r\n", "\r\n",       1},
    {"\r\n",       "\r\n\n\r\n", -1},
  };
  int i;
  int iReturn, iReturnSave;
  startest ();

  for (i=0; i<sizeof(rgStringTest)/sizeof(tStringTest); i++)
  {
    tStringTest *pTest = &rgStringTest[i];
    iReturn = iReturnSave = strcmp(pTest->String1, pTest->String2);

    if (iReturn < -1)
      iReturn = -1;
    else if (iReturn > 1)
      iReturn = 1;

    if (iReturn != pTest->ExpectedResult)
    {
      fail(i);
      printf("Failure: strcmp(\"%s\", \"%s\") returned=%d, expected=%d\n",
         pTest->String1, pTest->String2, iReturnSave, pTest->ExpectedResult);
    }
  }

  finish ();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strcoll1.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strcoll1.c
                     strcoll1
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the strcoll() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests decribed in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 26-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <locale.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;


static char stringval1[51] = "AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYy";
static char stringval2[51] = "AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxyz";
/*                                                                     ^
                                                            ___________|
*/

int strcoll1Entry(){
    int i, outcome;
    char string1[51], string2[51];

    startest();

    setlocale( LC_COLLATE, "C" );

/*  Scenario 1: Verify that the function returns a negative value
                when string1 < string2.
*/
    for (i = 0; i < 51; i++ )
    {
        string1[i] = stringval1[i];
        string2[i] = stringval2[i];
    }
    outcome = 999;
    outcome = strcoll( string1, string2 );
    checke( (outcome < 0), 1 );



/*  Scenario 2: Verify that the function returns a positive value
                when string1 > string2.
*/
    for (i = 0; i < 51; i++ )
    {
        string1[i] = stringval2[i];
        string2[i] = stringval1[i];
    }
    outcome = -999;
    outcome = strcoll( string1, string2 );
    checke( (outcome > 0), 1 );



/*  Scenario 3: Verify that the function returns zero when string1 = string2.
*/
    for (i = 0; i < 51; i++ )
    {
        string1[i] = stringval1[i];
        string2[i] = stringval1[i];
    }
    outcome = 999;
    outcome = strcoll( string1, string2 );
    checke( (outcome == 0), 1 );


    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strcoll4.c ===
/***************************************************************************

         Copyright (C) Microsoft Corp. 1993


Test:   strcoll

Abstract:   Vefifies that strcoll is effected by a change in the locale,
            and handles chars >127.  Also verifies that setting LC_COLLATE
            alone performs correct sort order for graphic chars.
            
===========================================================================
Syntax

===========================================================================
Priority:               1
Products:               WIN NT


Revision History:

    Date        emailname       description
----------------------------------------------------------------------------
    11-03-93    lhanson         created
    11-22-94    a-timke         Modified for NT3.5 results.
    01-28-98    a-hemalk        64bit warning (C4311) fix
----------------------------------------------------------------------------

EndHeader:

****************************************************************************/

#include <string.h>
#include <locale.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;


int strcoll4Entry(){
    unsigned char *psz1 = "AaBbC\x8A\x8B\xC0\xCF\xD0Zz";
    unsigned char *psz2 = "aabbc\x9A\x8B\xE0\xEF\xF0zz";
    unsigned char *psz3 = "\x9A\x8B\xE0\xEF\xF0zzAaBbC";

    startest();

    check(strcoll(psz1, psz2) >= 0);

    // French locale with LC_COLLATE only
    
    checknNULL(setlocale(LC_ALL, "French_France.OCP"));
#if defined(TEST_WIN95)
    check(strcoll(psz1, psz2) <= 0);
#else
    check(strcoll(psz1, psz2) > 0);
#endif
    check(strcoll(psz1, psz3) >= 0);  // Should sort alpha before graphic

    // French locale with LC_ALL

    checknNULL(setlocale(LC_ALL, "French_France.OCP"));
#if defined(TEST_WIN95)
    check(strcoll(psz1, psz2) <= 0);
#else
    check(strcoll(psz1, psz2) > 0);
#endif
    check(strcoll(psz1, psz3) >= 0);  // Should sort alpha before graphic  

    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strcpy1.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strcpy1.c
                     strcpy1
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the strcpy() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 08-May-92    edv            created
 [ 1] 28-Jan-98    a-hemalk       64bit warning (C4311) fix


---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;


static char string1[10] = "abc";
static char string2[10] = "def";

static char bsl1[4] = "ABC\0";
static char bsl2[2] = "X\0";



int strcpy1Entry(){
    int i;
    char *pstr;



    startest();


/*  Scenario 1: Verify that the function returns a pointer to string1.
*/

    pstr = strcpy( string1, string2 );
    checke( pstr, string1 );




/*  Scenario 2: Verify that the function works correctly when
                string1 is NULL.
*/

    string1[0] = '\0';
    pstr = strcpy( string1, string2 );

    checke( pstr, string1 );
    
    for (i = 0; i < sizeof( string2 ); i++)    /* Initialize string1 */
        checke( pstr[i], string2[i]);




/*  Scenario 3: Verify that the function works correctly when
                string2 is NULL.
*/

    string2[0] = '\0';

    string1[0] = 'A';
    string1[1] = 'B';
    string1[2] = 'C';
    string1[3] = '\0';

    pstr = strcpy( string1, string2 );

    //checke( pstr[0], '\0' );
    checkNULL(pstr[0]);




/*  Scenario 4: Verify that the function works correctly when both
                string1 and string2 are NULL.
*/

    string1[0] = '\0';
    string2[0] = '\0';

    pstr = strcpy( string1, string2 );

    //checke( pstr[0], '\0' );
    checkNULL(pstr[0]);




/*  Scenario 5: Verify that the function works correctly when
                string2 is one byte.
*/


    string1[0] = 'A';
    string1[1] = 'B';
    string1[2] = 'C';
    string1[3] = 'D';
    string1[4] = 'E';
    string1[5] = '\0';

    string2[0] = 'X';
    string2[1] = '\0';

    pstr = strcpy( string1, string2 );

    for (i = 0; i < 2; i++)
        checke( pstr[i], bsl2[i] );



    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strcpy2.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strcpy2.c
                     strcpy2
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the strcpy() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 11-May-92    edv            created


---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;


static char string1[100];

static char str2A[60]  = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
static char str2B[100] = "-:-{}-[]-()-<>-:-{}-[]-()-<>-:-{}-[]-()-<>-:-{}-[]-+";
static char str2C[32] = "123456789012345678901234567890";

static char bsl1[52] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
static char bsl2[52] = "-:-{}-[]-()-<>-:-{}-[]-()-<>-:-{}-[]-()-<>-:-{}-[]-+";
static char bsl3[30] = "123456789012345678901234567890";



int strcpy2Entry(){
    int i;
    char *pstr;



    startest();



/*  Scenario 6: Verify that the function works correctly with
                larger strings.
*/

    string1[0] = '\0';
    pstr = strcpy( string1, str2A );

    checke( pstr, string1 );

    for (i = 0; i < sizeof( bsl1 ); i++)
        checke( pstr[i], bsl1[i] );





    string1[0] = '\0';
    pstr = strcpy( string1, str2B );

    checke( pstr, string1 );

    for (i = 0; i < sizeof( bsl2 ); i++)
        checke( pstr[i], bsl2[i] );





    string1[0] = '\0';
    pstr = strcpy( string1, str2C );

    checke( pstr, string1 );

    for (i = 0; i < sizeof( bsl3 ); i++)
        checke( pstr[i], bsl3[i] );






    string1[0] = '\0';
    memset( str2B, '*', sizeof( str2B ) );
    str2B[sizeof( str2B ) - 1] = '\0';

    pstr = strcpy( string1, str2B );

    checke( pstr, string1 );

    for (i = 0; i < sizeof( str2B ); i++)
        checke( pstr[i], str2B[i] );



    finish();

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strcpy3.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strcpy3.c
                     strcpy3
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the strcpy() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests decribed in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 11-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;


#define DELTA        2000
#define ALMOST_MAX  (SHRT_MAX - DELTA)


/*  Scenario 7: Verify that string1 and string2 can be almost
        as large as SHRT_MAX.
*/

static unsigned char string1[ALMOST_MAX];
static unsigned char string2[ALMOST_MAX];



int strcpy3Entry(){
    int i;
    char *pstr;



    startest();


    string1[0] = '\0';

    memset( string2, 'x', sizeof( string2 ) );
    string2[ALMOST_MAX - 1] = '\0';


    string2[10] = '&';
    string2[100] = '*';
    string2[1000] = '%';

    pstr = strcpy( string1, string2 );
    checke( pstr, string1 );

    for(i = 0; i < sizeof(string2); i++)
       checke( pstr[i], string1[i] );



    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strcoll3.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strcoll2.c
                     strcoll2
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the strcoll() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests decribed in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 26-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <locale.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;


#define DELTA        2000
#define ALMOST_MAX  (SHRT_MAX - DELTA)


/*  Scenario 6: Verify that string1 and string2 can be almost
        as large as SHRT_MAX.
*/

static unsigned char string1[ALMOST_MAX];
static unsigned char string2[ALMOST_MAX];



int strcoll3Entry(){
    int outcome;



    startest();


    setlocale( LC_COLLATE, "C" );


    memset( string1, 'x', sizeof( string1 ) );
    memset( string2, 'x', sizeof( string2 ) );
    string1[ALMOST_MAX - 1] = '\0';
    string2[ALMOST_MAX - 1] = '\0';


    outcome = 1;
    outcome = strcoll( string1, string2 );
    checke( (outcome == 0), 1 );



    string1[ALMOST_MAX - 2] = 'W';
    string2[ALMOST_MAX - 2] = 'w';

    outcome = 1;
    outcome = strcoll( string1, string2 );
    checke( (outcome < 0), 1 );



    string1[ALMOST_MAX - 3] = 'y';

    outcome = -1;
    outcome = strcoll( string1, string2 );
    checke( (outcome > 0), 1 );




    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strcoll2.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strcoll2.c
                     strcoll2
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the strcoll() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 26-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <malloc.h>
#include <locale.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;

#define DELTA    2000
#define LARGEST (SHRT_MAX - DELTA)


int strcoll2Entry(){
    int outcome;
    unsigned int string_size;
    unsigned char *string1, *string2;


    startest();


    setlocale( LC_COLLATE, "C" );



/*  Scenario 5: Verify that string1 and string2 can be
        as large as LARGEST.
*/

       string_size = LARGEST;

       string1 = malloc( string_size );
       if (string1 == NULL)
       {
          faill();
          exit( 1 );
       }

       string2 = malloc( string_size );
       if (string2 == NULL)
       {
          faill();
          exit( 1 );
       }

       memset( string1, 'a', string_size );
       string1[string_size - 1] = '\0';

       memset( string2, 'a', string_size );
       string2[string_size - 1] = '\0';



       outcome = -1;
       outcome = strcoll( string1, string2 );
       checke( (outcome == 0), 1 );



       string1[string_size - 2] = 'b';
       outcome = 0;
       outcome = strcoll( string1, string2 );
       checke( (outcome > 0), 1 );
       string1[string_size - 2] = 'a';


       string2[string_size - 2] = 'd';
       outcome = -1;
       outcome = strcoll( string1, string2 );
       checke( (outcome < 0), 1 );



    free( string1 );
    free( string2 );


    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strcspn1.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strcspn1.c
                     strcspn1
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the strcspn() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 22-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;


static char string1a[128] = "12345678901234567890123456789012\0";
static char string1b[32]  = "AabCcDdEeFfghI\0";
static char string1c[16]  = "\0";
static char string1d[64]  = "String2d is null - 21\0";
static char string1e[8]   = "\0";


static char string2a[55] = "Mutually Exclusive String\0";
static char string2b[75] = "Last Char Starts string1b xxxxx12345xxxxxxA\0";
static char string2c[27] = "String1c is null\0";
static char string2d[15] = "\0";
static char string2e[9]  = "\0";


#define RESULT1   32
#define RESULT2    0
#define RESULT3    0
#define RESULT4   21
#define RESULT5    0


int strcspn1Entry(){
    int  index;



    startest();



/*  Scenario 1: Verify that the function works correctly when string1
                and string2 are mutually exclusive.  The return value
                should be equal to the length of string1.
*/

    index = (int)strcspn( string1a, string2a );
    checke( index, RESULT1 );



/*  Scenario 2: Verify that the function returns zero when string1
                begins with a characters in string2.
*/
    index = (int)strcspn( string1b, string2b );
    checke( index, RESULT2 );



/*  Scenario 3: Verify that the function works correctly when string1
                is NULL.  Should return zero.
*/
    index = (int)strcspn( string1c, string2c );
    checke( index, RESULT3 );



/*  Scenario 4: Verify that the function works correctly when string2
                is NULL.  Should return length of string1.
*/
    index = (int)strcspn( string1d, string2d );
    checke( index, RESULT4 );



/*  Scenario 5: Verify that the function works correctly when both string1
                and string2 are NULL.
*/
    index = (int)strcspn( string1e, string2e );
    checke( index, 0 );




    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strcspn2.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strcspn2.c
                     strcspn2
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the strcspn() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 22-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;

static char string1a[2]   = "1\0";
static char string1b[64]  = "A1B2C3D4E5F6G7H8I9J0\0";
static char string1c[2]   = "7\0";

static char string2a[27]  = "AaBbCc0987654321\0";
static char string2b[2]   = "J\0";
static char string2c[2]   = "7\0";

#define RESULT1   0
#define RESULT2  18
#define RESULT3   0


int strcspn2Entry(){
    int index;



    startest();



/*  Scenario 6: Verify that the function works correctly when string1 only
                holds 1 character.
*/
    index = (int)strcspn( string1a, string2a );
    checke( index, RESULT1 );


/*  Scenario 7: Verify that the function works correctly when string2 only
                holds 1 character.
*/
    index = (int)strcspn( string1b, string2b );
    checke( index, RESULT2 );


/*  Scenario 8: Verify that the function works correctly when both string1
                and string2 only hold 1 character.
*/
    index = (int)strcspn( string1c, string2c );
    checke( index, RESULT3 );



    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strcspn4.c ===
/***************************************************************************

           Copyright (c) 1992, Microsoft Corporation

Method:



Switches:   NONE


Abstract:   Test for: strcspn

          size_t strcspn(const char *, const char *);

OS Version:
CPU:
Dependencies:       NONE
Environment Vars:   NONE
Verification Method:    TBD
Priority:       1/2/3/4
Notes:          NONE
Products:


Revision History:

    Date    emailname   description
----------------------------------------------------------------------------
    18-Feb-93   xiangjun    created
----------------------------------------------------------------------------

EndHeader:

****************************************************************************/


#include <string.h>
#include <stdio.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect = 0;

static char string0[] = "1234567890abcdefghijABCDEFGHIJ";
static char string1[] = "abcde";
static char string2[] = "ABCDEFGHIJLKMNOPQ";
static char string3[] = "abcdeABCD";
static char string4[] = "uvxwzy";
static char string5[] = "abcdefghiABCDEFGHI";

int strcspn4Entry(){

/* Begin */

   startest();

/* normal cases */

   if( strcspn( string0, string1 ) != 10 )
      fail(0);

   if( strcspn( string0, string2 ) != 20 )
      fail(1);

   if( strcspn( string0, string3 ) != 10 )
      fail(2);

   if( strcspn( string0, string4 ) != 30 )
      fail(3);

/* return 0 case */

   if( strcspn( string5, string1 ) != 0 )
      fail(4);

/* end */

   finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strdup2.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strdup2.c
                     strdup2
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the _strdup() function.
OS Version           REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests decribed in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 28-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;



#define LEN1   31
#define LEN2   55
#define LEN3   53
#define LEN4  258
#define LEN5 2007



static char str1[32]  =  "123456789012345678901234567890\0";
static char str2[97]  =  "abcdefghijklmnopqrstuvwxyz**ABCDEFGHIJKLMNOPQRSTUVWXYZ\0";
static char str3[128] =  "\0";
static char str4[500] =  { "-:-{}-[]-()-<>-:-{}-[]-()-<>-:-{}-[]-()-<>-:-{}-[]-+"
                    "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
                    "123456789012345678901234567890\"~!@#$%^&*()_+=-/.,?>"
                    ""
                    "ThTh123456789\0"
                    "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
                  };
static char str5[2048] = { "12345678901234567890123456789012345678901234567890"
                    "12345678901234567890123456789012345678901234567890"
                    "12345678901234567890123456789012345678901234567890"
                    "12345678901234567890123456789012345678901234567890"
                    "12345678901234567890123456789012345678901234567890"
                    "12345678901234567890123456789012345678901234567890"
                    "12345678901234567890123456789012345678901234567890"
                    "12345678901234567890123456789012345678901234567890"
                    "12345678901234567890123456789012345678901234567890"
                    "12345678901234567890123456789012345678901234567890"
                    "12345678901234567890123456789012345678901234567890"
                    "12345678901234567890123456789012345678901234567890"
                    "12345678901234567890123456789012345678901234567890"
                    "12345678901234567890123456789012345678901234567890"
                    "12345678901234567890123456789012345678901234567890"
                    "12345678901234567890123456789012345678901234567890"
                    "12345678901234567890123456789012345678901234567890"
                    "12345678901234567890123456789012345678901234567890"
                    "12345678901234567890123456789012345678901234567890"
                    "12345678901234567890123456789012345678901234567890"
                    "12345678901234567890123456789012345678901234567890"
                    "12345678901234567890123456789012345678901234567890"
                    "12345678901234567890123456789012345678901234567890"
                    "12345678901234567890123456789012345678901234567890"
                    "12345678901234567890123456789012345678901234567890"
                    "12345678901234567890123456789012345678901234567890"
                    "12345678901234567890123456789012345678901234567890"
                    "12345678901234567890123456789012345678901234567890"
                    "12345678901234567890123456789012345678901234567890"
                    "12345678901234567890123456789012345678901234567890"
                    "12345678901234567890123456789012345678901234567890"
                    "12345678901234567890123456789012345678901234567890"
                    "12345678901234567890123456789012345678901234567890"
                    "12345678901234567890123456789012345678901234567890"
                    "12345678901234567890123456789012345678901234567890"
                    "12345678901234567890123456789012345678901234567890"
                    "12345678901234567890123456789012345678901234567890"
                    "12345678901234567890123456789012345678901234567890"
                    "12345678901234567890123456789012345678901234567890"
                    "12345678901234567890123456789012345678901234567890"
                    "123456\0"
                 };



int strdup2Entry(){
    int i;
    char *pstr;


    startest();



/*  Scenario 5: Verify that the function works correctly with larger
                strings.
*/

    pstr = _strdup( str1 );

    for (i = 0; i < LEN1; i++)
        checke( pstr[i], str1[i] );



    pstr = _strdup( str2 );

    for (i = 0; i < LEN2; i++)
        checke( pstr[i], str2[i] );



    pstr = _strdup( str3 );

    for (i = 0; i < LEN3; i++)
        checke( pstr[i], str3[i] );



    pstr = _strdup( str4 );

    for (i = 0; i < LEN4; i++)
        checke( pstr[i], str4[i] );



    pstr = _strdup( str5 );

    for (i = 0; i < LEN5; i++)
        checke( pstr[i], str5[i] );





    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strdup3.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strdup3.c
                     strdup3
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the _strdup() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 28-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;


#define DELTA        2000
#define ALMOST_MAX  (SHRT_MAX - DELTA)


/*  Scenario 6: Verify that string can be almost as large as SHRT_MAX.
*/

static char string[ALMOST_MAX] = "JUNK";


int strdup3Entry(){
    int i;
    char *pstr;



    startest();



    for (i = 4; i < ALMOST_MAX - 1; i++)   /*   Initialize string   */
        string[i] = '*';

    string[i] = '\0';                      /* Null-terminate string */


    pstr = _strdup( string );

    checke( pstr[0], 'J' );
    checke( pstr[1], 'U' );
    checke( pstr[2], 'N' );
    checke( pstr[3], 'K' );
    checke( pstr[4], '*' );

    for (i = (ALMOST_MAX - 40); i < (ALMOST_MAX - 2); i++)
        checke( pstr[i], '*' );

    checke( pstr[ALMOST_MAX - 1], '\0' );





    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strdup1.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strdup1.c
                     strdup1
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the _strdup() function.
OS Version           REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests decribed in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 28-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;



#define LEN1  11
#define LEN2   1
#define LEN3   2
#define LEN4   3

static char str1[11]  = "0123456789\0";
static char str2[1]   = "\0";
static char str3[2]   = "2\0";
static char str4[3]   = "23\0";



int strdup1Entry(){
    int i;
    char *pstr;


    startest();


/*  Scenario 1: Verify that the function returns a pointer to the
                duplicated string.
*/

    pstr = _strdup( str1 );

    for (i = 0; i < LEN1; i++)
        checke( pstr[i], str1[i] );




/*  Scenario 2: Verify that the function works correctly when string
                is NULL.
*/

    pstr = _strdup( str2 );

    checke( pstr[0], '\0' );



    pstr = _strdup("");

    checke( pstr[0], '\0' );




/*  Scenario 3: Verify that the function works correctly when string
                only holds one character.
*/

    pstr = _strdup( str3 );

    for (i = 0; i < LEN3; i++)
        checke( pstr[i], str3[i] );




/*  Scenario 4: Verify that the function works correctly when string
                only holds two characters.
*/

    pstr = _strdup( str4 );

    for (i = 0; i < LEN4; i++)
        checke( pstr[i], str4[i] );





    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strerror1.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strerro1.c
                     strerro1
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the strerror() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H and ERRNO.H
                     Tests decribed in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 27-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <errno.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;

static char error0[9] = "No error";
#define ERRLEN1 9

static char errorx[14] = "Unknown error";
#define ERRLEN2 14

int strerror1Entry(){
    int i, j;
    char *errorstr;


    startest();

/*  Scenario 1: Verify that the function returns a pointer to the string
                containing the error message.
*/

    errorstr = strerror(0);

    for (i = 0; i < ERRLEN1; i++)
        checke( errorstr[i], error0[i] );



/*  Scenario 2: Verify that the function returns the correct string for each
                error number.
*/

    for (i = 0; i < sys_nerr; i++)
    {
        errorstr = strerror( i );
        for (j = 0; j < (int) strlen( sys_errlist[i] ); j++)
            checke( errorstr[j], sys_errlist[i][j] );
    }



/*  Scenario 3: Verify that the function works correctly when illegal error
                numbers are passed.
*/

    for (i = 90; i < 110; i++)
    {
        errorstr = strerror( i );
        for (j = 0; j < ERRLEN2; j++)
            checke( errorstr[j], errorx[j] );
    }



    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strerror2.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strerro2.c
                     strerro2
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the strerror() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H and ERRNO.H
                     Tests decribed in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 27-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <errno.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;

static char text1[8] = "Testing\0";
static char maxtext[95] = { "1234567890123456789012345678901234567890"
                     "1234567890123456789012345678901234567890"
                     "12345678901234\0"
                   };

static char baseln1[27] = "Testing: Arg list too long\n";
static char baseln2[122] = { "1234567890123456789012345678901234567890"
                      "1234567890123456789012345678901234567890"
                      "12345678901234: No such file or directory\n"
                    };
static char baseln3[12] = "File exists\n";

#define ERRLEN1  27
#define ERRLEN2 122
#define ERRLEN3  12


int strerror2Entry(){
    int i, j;
    char *errorstr;


    startest();



/*  Scenario 1: Verify that the function returns a pointer to a string
                containing (in order) the string passed, a colon, a space,
                the system error message and a newline character.
*/

    errno = 7;
    errorstr = _strerror( text1 );

    for (i = 0; i < ERRLEN1; i++)
        checke( errorstr[i], baseln1[i] );




/*  Scenario 2: Verify that string can be up to 94 characters.
*/

    errno = 2;
    errorstr = _strerror( maxtext );

    for (i = 0; i < ERRLEN2; i++)
        checke( errorstr[i], baseln2[i] );




/*  Scenario 3: Verify that if string is NULL, the function returns a
                pointer to a string containing the system error message
                for the last library call that produced an error.
*/

    errno = 17;
    errorstr = _strerror( NULL );

    for (i = 0; i < ERRLEN3; i++)
        checke( errorstr[i], baseln3[i] );




/*  Scenario 4: Verify that the function returns the correct error string
                for each error in sys_errlist.
*/

    for (i = 0; i < sys_nerr; i++)
    {
        errno = i;
        errorstr = _strerror( NULL );
        for (j = 0; j < (int) strlen( sys_errlist[i] ); j++)
            checke( errorstr[j], sys_errlist[i][j] );
    };



    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strcspn3.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strcspn3.c
                     strcspn3
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the strcspn() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 22-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;

static char string1a[200] = { "`1234567890-=~!@#$%^&*()_+"
                       "qwertyuiop[]QWERTYUIOP{}|\\"
                       "asdfghjkl;'ASDFGHJKL:\""
                       "zxcvbnm,./ZXCVBNM<>? \0" };
static char string1b[250] =  "`1234567890-=qwertyuiop[]asdfghjkl;'zxcvbnm,./ \0";
static char string1c[300] =  "1234567890abcdefgHIJKLMNOPqrstuvWXYZ\0";
static char string1d[100] =  "abcdefgHIJKLMNOPqrstuvWXYZ0123456789\0";
static char string1e[120] =  "abcdefgHIJKLMNOPqrstuvWXYZ0123456789./?\0";
static char string1f[210] =  "1234567890ABCDEFGHI";



static char string2a[155] = { "QWERTYUIOP{}|qwertyuiop[]"
                       "ASDFGHJKL:\"asdfghjkl;'"
                       "ZXCVBNM<>? zxcvbnm,./"
                       "~!@#$%^&*()_+`1234567890-=\0" };
static char string2b[555] =  "~!@#$%^&*()_+QWERTYUIOP{}|ASDFGHJKL:\"ZXCVBNM<>?\\\0";
static char string2c[111] =  "abcdefgHIJKLMNOPqrstuvWXYZ!@#$%^&*()_+-=1234567890\0";
static char string2d[333] =  "!@#$%^&*()_+-=9\0";
static char string2e[151] =  "&*<t>_+-=9\0";
static char string2f[351] =  "JKAAAAAAAAALMNOAAAAAAAAAPQRAAAAAAAASTUAAAAVWXYZAAA\0";


#define RESULT1    0
#define RESULT2   47
#define RESULT3    0
#define RESULT4   35
#define RESULT5   19
#define RESULT6   10


int strcspn3Entry(){
    int index;


    startest();



/*  Scenario 9: Verify that the function works correctly when both string1
                and string2 are large and equal.
*/
    index = (int)strcspn( string1a, string2a );
    checke( index, RESULT1 );



/*  Scenario 10: Verify that the function works correctly when both string1
                 and string2 are large but mutually exclusive.
*/
    index = (int)strcspn( string1b, string2b );
    checke( index, RESULT2 );



/*  Scenario 11: Verify that the function works correctly when string2 is
                 a superset of string1.
*/
    index = (int)strcspn( string1c, string2c );
    checke( index, RESULT3 );



/*  Scenario 12: Verify that the function works correctly when a character
                 in string2 occurs in the last character of string1.
*/
    index = (int)strcspn( string1d, string2d );
    checke( index, RESULT4 );



/*  Scenario 13: Verify that the function works correctly when a character
                 in string2 occurs in the middle of string1.
*/
    index = (int)strcspn( string1e, string2e );
    checke( index, RESULT5 );



/*  Scenario 14: Verify that the function works correctly when string2
                 is larger than string1 but only because of a repetitve
                 character.
*/
    index = (int)strcspn( string1f, string2f );
    checke( index, RESULT6 );




    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strlen2.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strlen2.c
                     strlen2
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the strlen() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 22-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;

#define ZERO            0
#define TWENTY         20
#define HUNDRED       100
#define THOUSAND     1000
#define TEN_THOU    10000
#define THIRTY_THOU 30000
#define FIFTY_THOU  50000
#define DELTA        4000
#define ALMOST_MAX  (USHRT_MAX - DELTA)

#define TWO	2
#ifdef QA_SIMPLE_QALIB
#define MAX_STEPS TWO
#else
#define MAX_STEPS TWENTY
#endif


/*  Scenario 7: Verify that string can be almost as large as USHRT_MAX.
*/

static unsigned char string[ALMOST_MAX];



int strlen2Entry(){
    unsigned int i;
    size_t length;


    startest();


    for (i = ZERO; i < ALMOST_MAX; i++)
        string[i] = 'X';



/*  Scenario 8: Verify that the return value can be anywhere in the range
        of 0 to almost USHRT_MAX.
*/

    for (i = ZERO; i < TWENTY; i++)
    {
        string[i] = '\0';
        length = strlen( string );
        checke( length, (size_t) i );
        string[i] = 'X';
    }


    for (i = HUNDRED; i < (HUNDRED + MAX_STEPS); i++)
    {
        string[i] = '\0';
        length = strlen( string );
        checke( length, (size_t) i );
        string[i] = 'X';
    }


    for (i = THOUSAND; i < (THOUSAND + MAX_STEPS); i++)
    {
        string[i] = '\0';
        length = strlen( string );
        checke( length, (size_t) i );
        string[i] = 'X';
    }


    for (i = TEN_THOU; i < (TEN_THOU + MAX_STEPS); i++)
    {
        string[i] = '\0';
        length = strlen( string );
        checke( length, (size_t) i );
        string[i] = 'X';
    }


    for (i = THIRTY_THOU; i < (THIRTY_THOU + MAX_STEPS); i++)
    {
        string[i] = '\0';
        length = strlen( string );
        checke( length, (size_t) i );
        string[i] = 'X';
    }


    for (i = FIFTY_THOU; i < (FIFTY_THOU + MAX_STEPS); i++)
    {
        string[i] = '\0';
        length = strlen( string );
        checke( length, (size_t) i );
        string[i] = 'X';
    }


    for (i = (ALMOST_MAX - MAX_STEPS); i < ALMOST_MAX; i++)
    {
        string[i] = '\0';
        length = strlen( string );
        checke( length, (size_t) i );
        string[i] = 'X';
    }




    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strlwr1.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strlwr1.c
                     strlwr1
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the _strlwr() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 19-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;

static char string1[30] = "THIS STRING IS ALL SAME CASE\0";
static char string2[30] = "this string is all same case\0";

int strlwr1Entry(){
    char *p, c[2], x[2], z;
    int i;


    startest();



/*  Scenario 1: Verify that the function returns a pointer to the
                converted string.
*/

    p = _strlwr( string1 );
    checke( p, string1 );

    for (i = 0; i < sizeof( string1 ); i++)
        checke( string1[i], string2[i] );





/*  Scenario 2: Loop through all the uppercase letters and verify
                that they get converted to lowercase.
*/

    c[1] = x[1] = '\0';          /*  NULL terminate the strings  */


    for (i = 'A', x[0] = 'a'; i <= 'Z'; i++, x[0]++)
    {
        c[0] = i;
        _strlwr( c );
        checke( c[0], x[0] );
    }




/*  Scenario 3: Loop through the remainder of the ASCII characters
                and verify that the characters remain unchanged.
*/

    for (i = 0X00; i <= 0X40; i++)
    {
        c[0] = z = i;
        _strlwr( c );
        checke( c[0], z );
    }


    for (i = 0X5B; i <= 0X7F; i++)
    {
        c[0] = z = i;
        _strlwr( c );
        checke( c[0], z );
    }




    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\stricmp1.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl stricmp1.c
                     stricmp1
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the _stricmp() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests decribed in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 11-Apr-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;


static char strval1A[11] = "AaBbCcDdE1\0";
static char strval1B[11] = "AaBbCcDdEe\0";

static char strval2A[53] = "AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz\0";
static char strval2B[53] = "aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ\0";


int stricmp1Entry(){
    int i, outcome;
    char string1[52], string2[52];

    startest();


/*  Scenario 1: Verify that the function returns a negative value
                when string1 < string2.
*/
    for (i = 0; i < (sizeof( strval1A ) - 1); i++ )
    {
        string1[i] = strval1A[i];
        string2[i] = strval1B[i];
    }

    string1[i] = '\0';
    string2[i] = '\0';

    outcome = 999;
    outcome = _stricmp( string1, string2 );
    checke( (outcome < 0), 1 );




/*  Scenario 2: Verify that the function returns a positive value
                when string1 > string2.
*/
    strval1A[sizeof( strval1A ) - 2] = 'e';
    for (i = 0; i < (sizeof( strval1A ) - 1); i++ )
    {
        string1[i] = strval1A[i];
        string2[i] = strval1B[i];
    }

    string1[i] = '\0';
    string2[i] = '\0';


    outcome = -999;
    outcome = _stricmp( string1, string2 );
    checke( (outcome == 0), 1 );



/*  Scenario 3: Verify that the function returns zero when string1 = string2.
*/
    strval1A[sizeof( strval1A ) - 2] = 'f';
    for (i = 0; i < (sizeof( strval1A ) - 1); i++ )
    {
        string1[i] = strval1A[i];
        string2[i] = strval1B[i];
    }

    string1[i] = '\0';
    string2[i] = '\0';


    outcome = 999;
    outcome = _stricmp( string1, string2 );
    checke( (outcome > 0), 1 );



/*  Scenario 4: Verify that the function is, in fact, case sensitive
                by making the first letter of each string differ only
                in the case (ie. 'abcd...' vs. 'Abcd...').
*/
    for (i = 0; i < (sizeof( strval2A ) - 2); i++ )
    {
        string1[i] = strval2A[i];
        string2[i] = strval2B[i];
    }

    string1[i] = '\0';
    string2[i] = '\0';


    outcome = 999;
    outcome = _stricmp( string1, string2 );
    checke( (outcome == 0), 1 );



/*  Scenario 5: Verify that the function is, in fact, case sensitive
                by making the last letter of each string differ only
                in the case (ie. '...abcd' vs. '...abcD').
*/
    for (i = 0; i < (sizeof( strval2A ) - 2); i++ )
    {
        string1[i] = strval2A[i];
        string2[i] = strval2B[i];
    }

    string1[i] = '\0';
    string2[i] = '\0';


    outcome = 999;
    outcome = _stricmp( string1, string2 );
    checke( (outcome == 0), 1 );


    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strlwr2.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strlwr2.c
                     strlwr2
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the _strlwr() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 19-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;

static char string1[70] = { "ABC DEF GHI JKL MNO PQR STU VWX YZA BCD EFG HIJ "
                     "KLM NOP QRS TUV WXY Z\0"
                   };


static char baseln1[70] = { "abc def ghi jkl mno pqr stu vwx yza bcd efg hij "
                     "klm nop qrs tuv wxy z\0"
                   };

static char string2[100] = { "1A2B3C4D5E6F7G8H9I0J!K@L#M$N%O^P&Q*R(S)T_U+V-W=X :"
                      "; [Y]Z1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ<><>?/'\0"
                    };

static char baseln2[100] = { "1a2b3c4d5e6f7g8h9i0j!k@l#m$n%o^p&q*r(s)t_u+v-w=x :"
                      "; [y]z1234567890abcdefghijklmnopqrstuvwxyz<><>?/'\0"
                    };

static char string3[200] = { "ABC DEF GHI JKL MNO PQR STU VWX YZA BCD EFG HIJ kl"
                      "; [Y]Z1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ<><>?/'x"
                      "1a2b3c4d5e6f7g8h9i0j!k@l#m$n%o^p&q*r(s)t_u+v-w=x :"
                      "; [y]z1234567890abcdefghijklmnopqrstuvwxyz<><>?/'\0"
                    };

static char baseln3[200] = { "abc def ghi jkl mno pqr stu vwx yza bcd efg hij kl"
                      "; [y]z1234567890abcdefghijklmnopqrstuvwxyz<><>?/'x"
                      "1a2b3c4d5e6f7g8h9i0j!k@l#m$n%o^p&q*r(s)t_u+v-w=x :"
                      "; [y]z1234567890abcdefghijklmnopqrstuvwxyz<><>?/'\0"
                    };


int strlwr2Entry(){
    char *p;
    int i;


    startest();



/*  Scenario 4: Verify that the function works correctly with
                larger strings.
*/

    p = _strlwr( string1 );
    checke( p, string1 );

    for (i = 0; i < sizeof( string1 ); i++)
        checke( string1[i], baseln1[i] );




    p = _strlwr( string2 );
    checke( p, string2 );

    for (i = 0; i < sizeof( string2 ); i++)
        checke( string2[i], baseln2[i] );




    p = _strlwr( string3 );
    checke( p, string3 );

    for (i = 0; i < sizeof( string3 ); i++)
        checke( string3[i], baseln3[i] );





    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strlwr3.c ===
/***************************************************************************

         Copyright (C) Microsoft Corp. 1993


Test:   _strlwr

Abstract:   Vefifies that _strlwr is effected by a change in the locale,
            and handles chars >127.

===========================================================================
Syntax

===========================================================================
Priority:               1
Products:               WIN NT


Revision History:

    Date        emailname       description
----------------------------------------------------------------------------
    11-03-93    lhanson         created
    11-22-94    a-timke         Modified for NT3.5 results.
----------------------------------------------------------------------------

EndHeader:

****************************************************************************/

#include <string.h>
#include <locale.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;


int strlwr3Entry(void){
    unsigned char *psz1_us = "AaBbC\x8A\x8B\xC0\xCF\xD0Zz";
    unsigned char *psz1    = "AaBbC\x8A\x8B\xC0\xCF\xD0Zz";
    unsigned char *psz2    = "aabbc\x9A\x8B\xE0\xEF\xF0zz";

    startest();

    checke(_strlwr(psz1_us), psz1_us);
    checkne(strcmp(psz1_us, psz2), 0);

    checkne(setlocale( LC_ALL, "French_France.OCP" ), NULL);

    checke(_strlwr(psz1), psz1);
#if defined(TEST_WIN95) /*prior to NLS work of 2/97.*/
    checke(strcmp(psz1, psz2), 0);
#else
    checke(strcmp(psz1, psz2), -1);
#endif
    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strlen1.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strlen1.c
                     strlen1
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the strlen() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 21-May-92    edv            created


---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;


static char string0[20]    = "\0";
static char string1[35]    = "1\0";
static char string2[40]    = "12\0";
static char string33[75]   = "123456789012345678901234567890123\0";
static char string50[95]   = "12345678901234567890123456789012345678901234567890\0";
static char string101[195] = {
                       "123456789012345678901234567890123456789012345678901"
                       "12345678901234567890123456789012345678901234567890\0"
                      };



int strlen1Entry(){
    size_t length=999;



    startest();



/*  Scenario 1: Verify that the function works correctly when string
                is NULL.
*/
    length = strlen( string0 );
    checke( length, 0 );




/*  Scenario 2: Verify that the function works correctly when string
                contains only 1 character.
*/
    length = strlen( string1 );
    checke( length, 1 );




/*  Scenario 3: Verify that the function works correctly when string
                contains only 2 characters.
*/
    length = strlen( string2 );
    checke( length, 2 );




/*  Scenario 4: Verify that the function works correctly when string
                contains 33 characters.
*/
    length = strlen( string33 );
    checke( length, 33 );




/*  Scenario 5: Verify that the function works correctly when string
                contains 50 characters.
*/
    length = strlen( string50 );
    checke( length, 50 );




/*  Scenario 6: Verify that the function works correctly when string
                contains 101 characters.
*/
    length = strlen( string101 );
    checke( length, 101 );




    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\stricmp2.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl stricmp2.c
                     stricmp2
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the _stricmp() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests decribed in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 11-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;


#define DELTA        2000
#define ALMOST_MAX  (SHRT_MAX - DELTA)


/*  Scenario 6: Verify that string1 and string2 can be almost as large as
        SHRT_MAX when using SMALL model.
*/

static unsigned char string1[ALMOST_MAX];
static unsigned char string2[ALMOST_MAX];



int stricmp2Entry(){
    int outcome;



    startest();


/*  Scenario 9: Verify that count can be anywhere in the range
        0 to aproximately SHRT_MAX when using SMALL model.
*/

    memset( string1, '*', sizeof( string1 ) );
    memset( string2, '*', sizeof( string2 ) );

    string1[sizeof(string1) - 1] = '\0';
    string2[sizeof(string2) - 1] = '\0';

    string1[sizeof(string1) - 2] = 'z';
    string2[sizeof(string2) - 2] = 'Z';

    string1[0] = 'A';
    string2[0] = 'a';

    string1[100] = '^';
    string2[100] = '^';

    outcome = -1;
    outcome = _stricmp( string1, string2 );
    checke( (outcome == 0), 1 );




    string1[ALMOST_MAX - 2] = '1';
    string2[ALMOST_MAX - 2] = '2';

    outcome = 1;
    outcome = _stricmp( string1, string2 );
    checke( (outcome < 0), 1 );





    string1[ALMOST_MAX - 2] = '3';

    outcome = -1;
    outcome = _stricmp( string1, string2 );
    checke( (outcome > 0), 1 );





    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strerror3.c ===
/***************************************************************************

		   Copyright (c) 1992, Microsoft Corporation

Method:



Switches:   NONE


Abstract:   Test for: _strerror

===========================================================================
Syntax 	
	char *strerror( int errnum );
	char *_strerror( const char *string );

Parameter	Description
errnum		Error number
string		User-supplied message

The strerror function maps errnum to an error-message string, returning a
pointer to the string. The function itself does not actually print the
message; for that, you need to call an output function such as fprintf:

if (( _access( "datafile",2 )) == -1 )
   fprintf( stderr, strerror(NULL) );

If string is passed as NULL, _strerror returns a pointer to a string containing
the system error message for the last library call that produced an error. The
error-message string is terminated by the newline character ('\n').
If string is not equal to NULL, then _strerror returns a pointer to a string
containing (in order) your string message, a colon, a space, the system error
message for the last library call producing an error, and a newline character.
Your string message can be a maximum of 94 bytes long.

Unlike perror, _strerror alone does not print any messages. To print the
message returned by _strerror to stderr, your program will need an fprintf
statement, as shown in the following lines:

if (( _access( "datafile",2 )) == -1 )
   fprintf( stderr, _strerror(NULL) );

The actual error number for _strerror is stored in the variable errno. The
system error messages are accessed through the variable _sys_errlist, which
is an array of messages ordered by error number. 
The _strerror function accesses the appropriate error message by using the
errno value as an index to the variable _sys_errlist. The value of the variable
_sys_nerr is defined as the maximum number of elements in the _sys_errlist
array.

To produce accurate results, _strerror should be called immediately after a
library routine returns with an error. Otherwise, the errno value may be
overwritten by subsequent calls.

Note that the _strerror function under Microsoft C version 5.0 is identical to
the version 4.0 strerror function. The name was altered to permit the inclusion
in Microsoft C version 5.0 of the ANSI-conforming strerror function. The
_strerror function is not part of the ANSI definition but is instead a
Microsoft extension to it; it should not be used where portability is desired.
For ANSI compatibility,  use strerror instead.

Include File    <string.h>is required only for function declarations.

Return Value    The strerror and _strerror functions return a pointer to the
		error-message string. The string can be overwritten by
		subsequent calls to strerror or _strerror, respectively.

===========================================================================
OS Version:
CPU:
Dependencies:		
Environment Vars:	
Verification Method:	
Priority:		1
Notes:			
Products:		WIN NT


Revision History:

    Date	emailname   description
----------------------------------------------------------------------------
    27-Jul-92	xiangjun    created
----------------------------------------------------------------------------

EndHeader:

****************************************************************************/
#include <stdio.h>
#include <string.h>
#include <test.h>

static char test[] = "strerror3";
static int perfect;


int strerror3Entry(){
static char error_string[100];
static int i;

   startest();

   for( i = 0; i < 37; i++ ) {

      errno = i;

      strcpy( error_string, strerror( i ) );
      strcat( error_string, "\n" );
      if( strcmp( error_string, _strerror( NULL ) ) )
         fail( i );

      strcpy( error_string, "my_str_error" );
      strcat( error_string, ": " );
      strcat( error_string, strerror( i ) );
      strcat( error_string, "\n" );

      if( strcmp( error_string, _strerror( "my_str_error" ) ) )
 	 fail( 100+i );
      }

   finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strncmp3.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strncmp3.c
                     strncmp3
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the strncmp() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 11-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <malloc.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;

#define DELTA    2000
#define LARGEST (SHRT_MAX - DELTA)


int strncmp3Entry(){
    int outcome;
    unsigned int str_size;
    unsigned char *str1, *str2;
    size_t count;


    startest();


/*  Scenario 6: Verify that str1 and str2 can be as large as
        LARGEST using any memory model.
*/

       str_size = LARGEST;

       str1 = malloc( str_size );
       if (str1 == NULL)
       {
          faill();
          exit( 1 );
       }

       str2 = malloc( str_size );
       if (str2 == NULL)
       {
          faill();
          exit( 1 );
       }

       memset( str1, 'a', str_size );
       memset( str2, 'a', str_size );
       count = str_size;

       outcome = strncmp( str1, str2, count );
       checke( (outcome == 0), 1 );


       str1[str_size - 1] = 'b';
       outcome = strncmp( str1, str2, count );
       checke( (outcome > 0), 1 );
       str1[str_size - 1] = 'a';


       str1[1] = 'X';
       outcome = strncmp( str1, str2, count );
       checke( (outcome < 0), 1 );




    free( str1 );
    free( str2 );


    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strncmp2.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strncmp2.c
                     strncmp2
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the strncmp() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests decribed in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 11-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;


#define ONE             1
#define TWO             2
#define TWENTY         20
#define HUNDRED       100
#define THOUSAND     1000
#define TEN_THOU    10000
#define THIRTY_THOU 30000
#define DELTA        2000
#define ALMOST_MAX  (SHRT_MAX - DELTA)

#define TWO	2
#ifdef QA_SIMPLE_QALIB
#define MAX_STEPS TWO
#else
#define MAX_STEPS TWENTY
#endif


/*  Scenario 6: Verify that str1 and str2 can be almost as large as
        SHRT_MAX when using SMALL model.
*/

static unsigned char str1[ALMOST_MAX];
static unsigned char str2[ALMOST_MAX];



int strncmp2Entry(){
    int c, d, outcome;
    size_t count;


    startest();


/*  Scenario 4: Verify that count can be anywhere in the range
        0 to aproximately SHRT_MAX.
*/

    c = 'x';
    memset( str1, c, sizeof( str1 ) );
    memset( str2, c, sizeof( str2 ) );



    d = 'w';
    str1[0] = d;

/* Note that str1 is less than str2, but count is zero,
   so it should return zero.
*/
    count = 0;
    outcome = 1;
    outcome = strncmp( str1, str2, count );
    checke( (outcome == 0), 1 );

    str1[0] = c;



    d = 'y';
    str1[(ALMOST_MAX - TEN_THOU)] = d;

    count = (ALMOST_MAX - TEN_THOU + 1);
    outcome = - 1;
    outcome = strncmp( str1, str2, count );
    checke( (outcome > 0), 1 );

    str1[(ALMOST_MAX - TEN_THOU)] = c;



    for (count = ONE; count < TWENTY; count++)
    {
        outcome = -1;
        outcome = strncmp( str1, str2, count );
        checke( (outcome == 0), 1 );
    }



    d = 'd';
    for (count = HUNDRED; count < (HUNDRED + MAX_STEPS); count++)
    {
        str1[count - 1] = d;
        outcome = 0;
        outcome = strncmp( str1, str2, count );
        checke( (outcome < 0), 1 );
        str1[count - 1] = c;
    }



    d = 'y';
    for (count = THOUSAND; count < (THOUSAND + MAX_STEPS); count++)
    {
        str1[count - 1] = d;
        outcome = 0;
        outcome = strncmp( str1, str2, count );
        checke( (outcome > 0), 1 );
        str1[count - 1] = c;
    }



    for (count = TEN_THOU; count < (TEN_THOU + MAX_STEPS); count++)
    {
        outcome = -1;
        outcome = strncmp( str1, str2, count );
        checke( (outcome == 0), 1 );
    }



    d = 'X';
    for (count = THIRTY_THOU; count < (THIRTY_THOU + MAX_STEPS); count++)
    {
        str1[count - 1] = d;
        outcome = 1;
        outcome = strncmp( str1, str2, count );
        checke( (outcome < 0), 1 );
        str1[count - 1] = c;
    }



    d = '{';
    for (count = (ALMOST_MAX - MAX_STEPS); count < ALMOST_MAX; count++)
    {
        str1[count - 1] = d;
        outcome = 0;
        outcome = strncmp( str1, str2, count );
        checke( (outcome > 0), 1 );
        str1[count - 1] = c;
    }




    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strncat1.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strncat1.c
                     strncat1
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the strncat() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 19-May-92    edv            created


---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;

static char string1[20] = "String 1\0";
static char string2[20] = "String 2\0";

static char string3[20] = "String 3\0";
static char string4[20] = "String 4\0";

static char string5[20] = "String 5\0";
static char string6[20] = "String 6\0";

static char string7[20] = "String 7\0";
static char string8[20] = "String 8\0";

static char string9[20]  = "\0";
static char string10[20] = "String 10\0";

static char string11[20] = "String 11\0";
static char string12[20] = "\0";

static char string13[20] = "\0";
static char string14[20] = "\0";


static char baseln1[17] = "String 1String 2\0";
#define length1 17

static char baseln2[9] = "String 3\0";
#define length2 9

static char baseln3[10] = "String 5S\0";
#define length3 10

static char baseln4[17] = "String 7String 8\0";
#define length4 17

static char baseln5[10] = "String 10\0";
#define length5 10

static char baseln6[10] = "String 11\0";
#define length6 10

static char baseln7[10] = "\0";
#define length7 1

#define lengthX 10


int strncat1Entry(){
    int i;
    char *pstr;


    startest();



/*  Scenario 1: Verify that the function returns a pointer
                to the concatenated string.
*/

    pstr = strncat( string1, string2, length1 );
    checke( pstr, string1 );

    for (i = 0; i < length1; i++)
        checke( pstr[i], baseln1[i] );





/*  Scenario 2: Verify that the function works correctly when
                count is zero.
*/

    pstr = strncat( string3, string4, 0 );

    for (i = 0; i < length2; i++)
        checke( pstr[i], baseln2[i] );





/*  Scenario 3: Verify that the function works correctly when
                count is 1.
*/

    pstr = strncat( string5, string6, 1 );

    for (i = 0; i < length3; i++)
        checke( pstr[i], baseln3[i] );





/*  Scenario 4: Verify that the length of string2 is used in place of
                count when count is greater than the length of string2.
*/
    pstr = strncat( string7, string8, 100 );

    for (i = 0; i < length4; i++)
        checke( pstr[i], baseln4[i] );





/*  Scenario 5: Verify that the function works correctly when string1
                is NULL.
*/
    pstr = strncat( string9, string10, length5 );

    for (i = 0; i < length5; i++)
        checke( pstr[i], baseln5[i] );




/*  Scenario 6: Verify that the function works correctly when string2
                is NULL.
*/
    pstr = strncat( string11, string12, length6 );

    for (i = 0; i < length6; i++)
        checke( pstr[i], baseln6[i] );




/*  Scenario 7: Verify that the function works correctly when both
                string1 and string2 are NULL.
*/
    pstr = strncat( string13, string14, length7 );

    for (i = 0; i < length7; i++)
        checke( pstr[i], baseln7[i] );





    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strncat2.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strncat2.c
                     strncat2
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the strncat() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 20-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;


#define ZERO            0
#define TWO             2
#define TWENTY         20
#define HUNDRED       100
#define THOUSAND     1000
#define TEN_THOU    10000
#define THIRTY_THOU 30000
#define DELTA        2000
#define ALMOST_MAX  (SHRT_MAX - DELTA)

#define TWO	2
#ifdef QA_SIMPLE_QALIB
#define MAX_STEPS TWO
#else
#define MAX_STEPS TWENTY
#endif


/*  Scenario 8: Verify that string1 and string2 can be almost
        as large as SHRT_MAX.
*/

static char string1[ALMOST_MAX] = "\0";
static char string2[ALMOST_MAX] = "\0";


int strncat2Entry(){
    int i, c, Null='\0';
    size_t count;
    char *pstr;



    startest();



/*  Scenario 9: Verify that count can be anywhere in the range
        0 to almost SHRT_MAX.
*/
    c = 'X';

    for (i = 0; i < (ALMOST_MAX - 2); i++)       /* Initialize string2 */
        string2[i] = c;

    string2[ALMOST_MAX - 1] = Null;

    for (count = TWO; count < TWENTY; count++)
    {
        string1[0] = Null;                       /* Set string1 to NULL */
        pstr = strncat( string1, string2, count );
        checke( pstr[0], c );
        checke( pstr[1], c );
        checke( pstr[count - 2], c );
        checke( pstr[count - 1], c );
        checke( pstr[count], Null );
    }



    for (count = HUNDRED; count < (HUNDRED + MAX_STEPS); count++)
    {
        string1[0] = Null;                       /* Set string1 to NULL */
        pstr = strncat( string1, string2, count );
        checke( string1[0], c );
        checke( string1[1], c );
        checke( string1[count - 50], c );
        checke( string1[count - 25], c );
        checke( string1[count - 2], c );
        checke( string1[count - 1], c );
        checke( string1[count], Null );
    }


    for (count = THOUSAND; count < (THOUSAND + MAX_STEPS); count++)
    {
        string1[0] = Null;                       /* Set string1 to NULL */
        pstr = strncat( string1, string2, count );
        checke( string1[0], c );
        checke( string1[1], c );
        checke( string1[count - 500], c );
        checke( string1[count - 250], c );
        checke( string1[count - 50], c );
        checke( string1[count - 25], c );
        checke( string1[count - 2], c );
        checke( string1[count - 1], c );
        checke( string1[count], Null );
    }


    for (count = TEN_THOU; count < (TEN_THOU + MAX_STEPS); count++)
    {
        string1[0] = Null;                       /* Set string1 to NULL */
        pstr = strncat( string1, string2, count );
        checke( string1[0], c );
        checke( string1[1], c );
        checke( string1[count - 5000], c );
        checke( string1[count - 2500], c );
        checke( string1[count - 500], c );
        checke( string1[count - 250], c );
        checke( string1[count - 50], c );
        checke( string1[count - 25], c );
        checke( string1[count - 2], c );
        checke( string1[count - 1], c );
        checke( string1[count], Null );
    }


    for (count = THIRTY_THOU; count < (THIRTY_THOU + MAX_STEPS); count++)
    {
        string1[0] = Null;                       /* Set string1 to Null */
        pstr = strncat( string1, string2, count );
        checke( string1[0], c );
        checke( string1[1], c );
        checke( string1[count - 25000], c );
        checke( string1[count - 5000], c );
        checke( string1[count - 2500], c );
        checke( string1[count - 500], c );
        checke( string1[count - 250], c );
        checke( string1[count - 50], c );
        checke( string1[count - 25], c );
        checke( string1[count - 2], c );
        checke( string1[count - 1], c );
        checke( string1[count], Null );
    }


    for (count = (ALMOST_MAX - MAX_STEPS); count < (ALMOST_MAX - 1); count++)
    {
        string1[0] = Null;                       /* Set string1 to Null */
        pstr = strncat( string1, string2, count );
        checke( string1[0], c );
        checke( string1[1], c );
        checke( string1[count - 25000], c );
        checke( string1[count - 5000], c );
        checke( string1[count - 2500], c );
        checke( string1[count - 500], c );
        checke( string1[count - 250], c );
        checke( string1[count - 50], c );
        checke( string1[count - 25], c );
        checke( string1[count - 2], c );
        checke( string1[count - 1], c );
        checke( string1[count], Null );
    }





    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strncmp1.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strncmp1.c
                     strncmp1
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the strncmp() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests decribed in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 11-May-92    edv            created


---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;


static char strval1[51] = "AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYy";
static char strval2[51] = "AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxyz";
/*                                                                  ^
                                                         ___________|
*/

int strncmp1Entry(){
    int i, outcome;
    size_t count;
    char str1[51], str2[51];

    startest();


/*  Scenario 1: Verify that the function returns a negative value
                when string1 < string2.
*/
    for (i = 0; i < 51; i++ )
    {
        str1[i] = strval1[i];
        str2[i] = strval2[i];
    }
    count = 51;
    outcome = 999;
    outcome = strncmp( str1, str2, count);
    checke( (outcome < 0), 1 );



/*  Scenario 2: Verify that the function returns a positive value
                when string1 > string2.
*/
    for (i = 0; i < 51; i++ )
    {
        str1[i] = strval2[i];             /*  Just reverse values   */
        str2[i] = strval1[i];
    }
    count = 51;
    outcome = -999;
    outcome = strncmp( str1, str2, count);
    checke( (outcome > 0), 1 );



/*  Scenario 3: Verify that the function returns zero
                when string1 = string2.
*/
    for (i = 0; i < 51; i++ )
    {
        str1[i] = strval1[i];             /*  Just repeat values   */
        str2[i] = strval1[i];
    }
    count = 51;
    outcome = 999;
    outcome = strncmp( str1, str2, count);
    checke( (outcome == 0), 1 );


    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strncpy3.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strncpy3.c
                     strncpy3
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the strncpy() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 12-May-92    edv            created


---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <malloc.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;

#define DELTA    2000
#define LARGEST (SHRT_MAX - DELTA)


int strncpy3Entry(){
    unsigned int count, i, buf_size;
    unsigned char *string2, *string1;

    startest();


/*  Scenario 8: Verify that string1 and string2 can be as large as
        LARGEST using any STRING model.
*/


       buf_size = LARGEST;
       count = buf_size;


       string2 = malloc( buf_size );
       if (string2 == NULL)
       {
          faill();
          exit( 1 );
       }

       string1 = malloc( buf_size );
       if (string1 == NULL)
       {
          faill();
          exit( 1 );
       }

       memset( string2, '+', buf_size - 1 );
       memset( string1, '-', buf_size - 1 );
       string1[buf_size - 1] = string2[buf_size - 1] = '\0';

       strncpy( string1, string2, count );

       for (i = 0; i < count; i++)
           checke( string1[i], string2[i] );


    free( string2 );
    free( string1 );



    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strncpy2.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strncpy2.c
                     strncpy2
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the strncpy() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 12-May-92    edv            created


---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;

#define ZERO            0
#define TWENTY         20
#define HUNDRED       100
#define THOUSAND     1000
#define TEN_THOU    10000
#define THIRTY_THOU 30000
#define DELTA        2000
#define ALMOST_MAX  (SHRT_MAX - DELTA)

#define TWO	2
#ifdef QA_SIMPLE_QALIB
#define MAX_STEPS TWO
#else
#define MAX_STEPS TWENTY
#endif



/*  Scenario 6: Verify that string1 and string2 can be almost as
        large as SHRT_MAX when using SMALL model.
*/

static unsigned char string2[ALMOST_MAX];
static unsigned char string1[ALMOST_MAX] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
static unsigned char ivals[10] = "!@#$%^&*()";


int strncpy2Entry(){
    unsigned int count, i, j;


    startest();


/*  Scenario 7: Verify that count can be anywhere in the range
        0 to aproximately SHRT_MAX when using SMALL model.
*/

    memset( string2, '+', ALMOST_MAX );

    for (count = ZERO, i = ZERO; count < TWENTY; count++, i++)
    {
        memset( string2, ivals[i], count );
        if (i == 9) i = 0;
        strncpy( string1, string2, count );
        for (j = 0; j < count; j++)
            checke( string1[j], string2[j] );
    }



    memset( string2, '-', ALMOST_MAX );
    i = 0;

    for (count = HUNDRED; count < (HUNDRED + MAX_STEPS); count++, i++)
    {
        memset( string2, ivals[i], count );
        if (i == 9) i = 0;
        strncpy( string1, string2, count );
        for (j = 0; j < count; j++)
            checke( string1[j], string2[j] );
    }



    memset( string2, '=', ALMOST_MAX );
    i = 0;

    for (count = THOUSAND; count < (THOUSAND + MAX_STEPS); count++, i++)
    {
        memset( string2, ivals[i], count );
        if (i == 9) i = 0;
        strncpy( string1, string2, count );
        for (j = 0; j < count; j++)
            checke( string1[j], string2[j] );
    }

#ifndef QA_SIMPLE_QALIB


    memset( string2, '{', ALMOST_MAX );
    i = 0;

    for (count = TEN_THOU; count < (TEN_THOU + MAX_STEPS); count++, i++)
    {
        memset( string2, ivals[i], count );
        if (i == 9) i = 0;
        strncpy( string1, string2, count );
        for (j = 0; j < count; j++)
            checke( string1[j], string2[j] );
    }




    memset( string2, '}', ALMOST_MAX );
    i = 0;

    for (count = THIRTY_THOU; count < (THIRTY_THOU + MAX_STEPS); count++, i++)
    {
        memset( string2, ivals[i], count );
        if (i == 9) i = 0;
        strncpy( string1, string2, count );
        for (j = 0; j < count; j++)
            checke( string1[j], string2[j] );
    }




    memset( string2, '|', ALMOST_MAX );
    i = 0;

    for (count = (ALMOST_MAX - MAX_STEPS); count < ALMOST_MAX; count++, i++)
    {
        memset( string2, ivals[i], count );
        if (i == 9) i = 0;
        strncpy( string1, string2, count );
        for (j = 0; j < count; j++)
            checke( string1[j], string2[j] );
    }

#endif

    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strnicm2.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strnicm2.c
                     strnicm2
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the _strnicmp() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests decribed in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 12-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;


static char string1[16] = "ABCDEFGHIJKLMNO\0";
static char string2[16] = "ABCDEFGHIJKLMNO\0";


int strnicm2Entry(){
    int outcome;
    size_t count;


    startest();


    count = sizeof( string1 );


/*  Scenario 4: Verify that the function is, in fact, case insensitive
                by making the first letter in each buffer differ in the
                case (ie. 'abcd...' vs. 'Abcd...').
*/
    string1[0] = 'a';
    outcome = 999;
    outcome = _strnicmp( string1, string2, count);
    checke( (outcome == 0), 1 );
    string1[0] = 'A';



/*  Scenario 5: Verify that the function is, in fact, case insensitive
                by making the last letter in each buffer differ in the
                case (ie. 'abcD...' vs. 'abcd...').
*/
    string1[count - 2] = 'o';
    outcome = -999;
    outcome = _strnicmp( string1, string2, count);
    checke( (outcome == 0), 1 );


    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strnicm1.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strnicm1.c
                     strnicm1
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the _strnicmp() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests decribed in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 12-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;


static char string1[51] = "aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyY\0";
static char string2[51] = "AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYy\0";

int strnicm1Entry(){
    int outcome;
    size_t count;


    startest();


    count = sizeof( string1 );



/*  Scenario 1: Verify that the function returns a negative value
                when string1 < string2.
*/
    string1[49] = 'X';
    outcome = 0;
    outcome = _strnicmp( string1, string2, count);
    checke( (outcome < 0), 1 );
    string1[49] = 'Y';




/*  Scenario 2: Verify that the function returns a positive value
                when string1 > string2.
*/
    string1[49] = '{';
    outcome = -999;
    outcome = _strnicmp( string1, string2, count);
    checke( (outcome > 0), 1 );
    string1[49] = 'Y';




/*  Scenario 3: Verify that the function returns zero
                when string1 = string2.
*/
    outcome = 999;
    outcome = _strnicmp( string1, string2, count);
    checke( (outcome == 0), 1 );


    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strncpy1.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strncpy1.c
                     strncpy1
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the strncpy() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 12-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;


static char string2[31]  = "A1B2C3D4E5F6G7H8I9J0KkLlMmNnOo\0";
static char string3[11]  = "1234567890\0";

static char bsl1[31] = "A1B2C3D4E5A1B2C3D4E5A1B2C3D4E5\0";
static char bsl2[31] = "F6G7H8I9J0KkLlMmNnOoKkLlMmNnOo\0";
static char bsl3[31] = "A1B2C3D4E5********************\0";
static char bsl4[31] = "1234567890\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";



int strncpy1Entry(){
    int i;
    unsigned int count;
    char string1[31];
    char *pstring1;



    startest();


/*  Scenario 1: Verify that the function returns a pointer to string1.
*/

    count = sizeof( string2 );
    pstring1 = strncpy( string1, string2, count );
    checke( pstring1, string1 );







/*  Scenario 2: Verify that the function works correctly when
                string1 overlaps string2.
*/

    count = sizeof( string1 ) - 1;
    for (i = 0; i < (int) count; i++)                /* Initialize string1 */
        string1[i] = string2[i];
    string1[count] = '\0';
    count = 20;

    pstring1 = strncpy( string1 + 10, string1, count );

    for (i = 0; i < sizeof( string1 ); i++)
        checke( string1[i], bsl1[i]);







/*  Scenario 3: Verify that the function works correctly when
                string2 overlaps string1.
*/

    count = sizeof( string1 ) - 1;
    for (i = 0; i < (int) count; i++)                /* Initialize string1 */
        string1[i] = string2[i];
    string1[count] = '\0';
    count = 20;

    pstring1 = strncpy( string1, string1 + 10, count );

    for (i = 0; i < sizeof( string1 ); i++)
        checke( string1[i], bsl2[i] );






/*  Scenario 4: Verify that when count is less than the length of
                string2, a null is not appended.
*/

    count = sizeof( string1 ) - 1;
    for (i = 0; i < (int) count; i++)                /* Initialize string1 */
        string1[i] = '*';
    string1[count] = '\0';
    count = 10;

    pstring1 = strncpy( string1, string2, count );

    for (i = 0; i < sizeof( string1 ); i++)
        checke( string1[i], bsl3[i] );






/*  Scenario 5: Verify that when count is greater than the length of
                string2, string1 gets padded with NULL.
*/

    count = sizeof( string1 ) - 1;
    for (i = 0; i < (int) count; i++)                /* Initialize string1 */
        string1[i] = '#';
    string1[count] = '\0';
    count = 30;

    pstring1 = strncpy( string1, string3, count );

    for (i = 0; i < sizeof( string1 ); i++)
        checke( string1[i], bsl4[i] );




    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strnicm4.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strnicm4.c
                     strnicm4
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the _strnicmp() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 12-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <malloc.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;

#define DELTA    2000
#define LARGEST (SHRT_MAX - DELTA)


int strnicm4Entry(){
    int outcome;
    unsigned int str_size;
    unsigned char *string1, *string2;
    size_t count;


    startest();



/*  Scenario 10: Verify that string1 and string2 can be as large as
         LARGEST using any memory model.
*/

       str_size = LARGEST;

       string1 = malloc( str_size );
       if (string1 == NULL)
       {
          faill();
          exit( 1 );
       }

       string2 = malloc( str_size );
       if (string2 == NULL)
       {
          faill();
          exit( 1 );
       }

       memset( string1, 'a', str_size );
       memset( string2, 'a', str_size );
       string1[str_size - 1] = string2[str_size - 1] = '\0';
       count = str_size;

       outcome = _strnicmp( string1, string2, count );
       checke( (outcome == 0), 1 );


       string1[str_size - 2] = 'b';
       outcome = _strnicmp( string1, string2, count );
       checke( (outcome > 0), 1 );
       string1[str_size - 2] = 'a';


       string1[1] = '1';
       outcome = _strnicmp( string1, string2, count );
       checke( (outcome < 0), 1 );



    free( string1 );
    free( string2 );


    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strnicm3.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strnicm3.c
                     strnicm3
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the _strnicmp() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests decribed in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 12-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;


#define ONE             1
#define TWO             2
#define TWENTY         20
#define HUNDRED       100
#define THOUSAND     1000
#define TEN_THOU    10000
#define THIRTY_THOU 30000
#define DELTA        2000
#define ALMOST_MAX  (SHRT_MAX - DELTA)


#define TWO	2
#ifdef QA_SIMPLE_QALIB
#define MAX_STEPS TWO
#else
#define MAX_STEPS TWENTY
#endif


/*  Scenario 6: Verify that string1 and string2 can be almost
        as large as SHRT_MAX.
*/

static unsigned char string1[ALMOST_MAX];
static unsigned char string2[ALMOST_MAX];



int strnicm3Entry(){
    int c, d, outcome;
    size_t count;


    startest();


/*  Scenario 7: Verify that count can be anywhere in the
        range 0 to aproximately SHRT_MAX.
*/

    c = 'x';
    memset( string1, c, sizeof( string1 ) );
    memset( string2, c, sizeof( string2 ) );
    string1[sizeof( string1 ) -1] = string2[sizeof( string2 ) -1] = '\0';


    d = 'a';
    string1[0] = d;

/* Note that string1 is less than string2, but count is zero,
   so it should return zero.
*/
    count = 0;
    outcome = 1;
    outcome = _strnicmp( string1, string2, count );
    checke( (outcome == 0), 1 );

    string1[0] = c;



    d = 'y';
    string1[(ALMOST_MAX - TEN_THOU)] = d;

    count = (ALMOST_MAX - TEN_THOU + 1);
    outcome = - 1;
    outcome = _strnicmp( string1, string2, count );
    checke( (outcome > 0), 1 );

    string1[(ALMOST_MAX - TEN_THOU)] = c;



    for (count = ONE; count < TWENTY; count++)
    {
        outcome = -1;
        outcome = _strnicmp( string1, string2, count );
        checke( (outcome == 0), 1 );
    }



    d = 'd';
    for (count = HUNDRED; count < (HUNDRED + MAX_STEPS); count++)
    {
        string1[count - 1] = d;
        outcome = 0;
        outcome = _strnicmp( string1, string2, count );
        checke( (outcome < 0), 1 );
        string1[count - 1] = c;
    }



    d = 'y';
    for (count = THOUSAND; count < (THOUSAND + MAX_STEPS); count++)
    {
        string1[count - 1] = d;
        outcome = 0;
        outcome = _strnicmp( string1, string2, count );
        checke( (outcome > 0), 1 );
        string1[count - 1] = c;
    }


#ifndef QA_SIMPLE_QALIB

    for (count = TEN_THOU; count < (TEN_THOU + MAX_STEPS); count++)
    {
        outcome = -1;
        outcome = _strnicmp( string1, string2, count );
        checke( (outcome == 0), 1 );
    }



    d = 'W';
    for (count = THIRTY_THOU; count < (THIRTY_THOU + MAX_STEPS); count++)
    {
        string1[count - 1] = d;
        outcome = 1;
        outcome = _strnicmp( string1, string2, count );
        checke( (outcome < 0), 1 );
        string1[count - 1] = c;
    }



    d = '{';
    for (count = (ALMOST_MAX - MAX_STEPS); count < ALMOST_MAX; count++)
    {
        string1[count - 1] = d;
        outcome = 0;
        outcome = _strnicmp( string1, string2, count );
        checke( (outcome > 0), 1 );
        string1[count - 1] = c;
    }

#endif


    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strnset1.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strnset1.c
                     strnset1
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the _strnset() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 14-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;


static unsigned char string1[21] = "AaBbCcDdEeFfGgHhIiJj\0";
static unsigned char string2[21] = "XXXXXXXXXXXXXXXXXXXX\0";

static unsigned char baseline1[21] = "%%%%%*DdEeFfGgHhIiJj\0";
static unsigned char baseline2[21] = "????????????????????\0";
static unsigned char baseline3[21] = "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
static unsigned char baseline4[21] = "  XXXXXXXXXXXXXXXXXX\0";


int strnset1Entry(){
    int c, i;
    size_t count;
    unsigned char *pstr;

    startest();


/*  Scenario 1: Verify that the function returns a pointer to string.
*/

    count = 5;
    string1[count] = '*';

    pstr = _strnset( string1, '%', count );

    checke( pstr, string1 );

    for (i = 0; i < sizeof( string1 ) - 1; i++)
        checke( string1[i], baseline1[i] );





/*  Scenario 2: Verify that if count is greater than the length of string,
                the length of string is used in place of count.
*/

    count = sizeof( string1 ) * 2;

    pstr = _strnset( string1, '?', count );

    checke( pstr, string1 );

    for (i = 0; i < sizeof( string1 ) - 1; i++)
        checke( string1[i], baseline2[i] );





/*  Scenario 3: Verify that c can be any value from 0 to UCHAR_MAX.
*/

    c = 0;
    count = 20;

    pstr = _strnset( string1, c, count );

    for (i = 0; i < sizeof( string1 ) - 1; i++)
        checke( pstr[i], baseline3[i] );



    count = 2;

    for (c = 1; c < UCHAR_MAX; c++)
    {
        baseline4[0] = c;
        baseline4[1] = c;

        pstr = _strnset( string2, c, count );

        for (i = 0; i < sizeof( string2 ) - 1; i++)
            checke( pstr[i], baseline4[i] );

    }




    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strnset2.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strnset2.c
                     strnset2
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the _strnset() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 14-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;


#define ZERO            0
#define TWO             2
#define TWENTY         20
#define HUNDRED       100
#define THOUSAND     1000
#define TEN_THOU    10000
#define THIRTY_THOU 30000
#define DELTA        4000
#define ALMOST_MAX  (USHRT_MAX - DELTA)


#define TWO	2
#ifdef QA_SIMPLE_QALIB
#define MAX_STEPS TWO
#else
#define MAX_STEPS TWENTY
#endif

/*  Scenario 4: Verify that string can be almost as large as USHRT_MAX.
*/

static unsigned char string[ALMOST_MAX] = "JUNK\0";


int strnset2Entry(){
    int c, d, i;
    size_t count;
    unsigned char *pstr;



    startest();



/*  Scenario 5: Verify that count can be anywhere in the range
        0 to almost SHRT_MAX.
*/
    c = 'A';

    count = 0;
    pstr = _strnset( string, c, count );
    checke( pstr, string );

    checke( string[0], 'J' );                 /*  Still JUNK because  */
    checke( string[1], 'U' );                 /*   count is zero.     */
    checke( string[2], 'N' );
    checke( string[3], 'K' );
    checke( string[4], '\0' );



    for (i = 0; i < (ALMOST_MAX - 2); i++)  /* Prepare string for test */
        string[i] = 'X';

    d = '\0';                               /* Set d to NULL */
    string[ALMOST_MAX - 1] = d;

    for (count = TWO; count < TWENTY; count++)
    {
        string[count] = d;                   /* NULL to terminate string */
        pstr = _strnset( string, c, count );
        checke( string[0], c );
        checke( string[1], c );
        checke( string[count - 2], c );
        checke( string[count - 1], c );
        checke( string[count], d );
        string[count] = c;
    }



    for (count = HUNDRED; count < (HUNDRED + MAX_STEPS ); count++)
    {
        string[count] = d;                   /* NULL to terminate string */
        pstr = _strnset( string, c, count );
        checke( string[0], c );
        checke( string[1], c );
        checke( string[count - 50], c );
        checke( string[count - 25], c );
        checke( string[count - 2], c );
        checke( string[count - 1], c );
        checke( string[count], d );
        string[count] = c;
    }


    for (count = THOUSAND; count < (THOUSAND + MAX_STEPS ); count++)
    {
        string[count] = d;                   /* NULL to terminate string */
        pstr = _strnset( string, c, count );
        checke( string[0], c );
        checke( string[1], c );
        checke( string[count - 500], c );
        checke( string[count - 250], c );
        checke( string[count - 50], c );
        checke( string[count - 25], c );
        checke( string[count - 2], c );
        checke( string[count - 1], c );
        checke( string[count], d );
        string[count] = c;
    }


    for (count = TEN_THOU; count < (TEN_THOU + MAX_STEPS ); count++)
    {
        string[count] = d;                   /* NULL to terminate string */
        pstr = _strnset( string, c, count );
        checke( string[0], c );
        checke( string[1], c );
        checke( string[count - 5000], c );
        checke( string[count - 2500], c );
        checke( string[count - 500], c );
        checke( string[count - 500], c );
        checke( string[count - 250], c );
        checke( string[count - 50], c );
        checke( string[count - 25], c );
        checke( string[count - 2], c );
        checke( string[count - 1], c );
        checke( string[count], d );
        string[count] = c;
    }


    for (count = THIRTY_THOU; count < (THIRTY_THOU + MAX_STEPS ); count++)
    {
        string[count] = d;                   /* NULL to terminate string */
        pstr = _strnset( string, c, count );
        checke( string[0], c );
        checke( string[1], c );
        checke( string[count - 25000], c );
        checke( string[count - 5000], c );
        checke( string[count - 2500], c );
        checke( string[count - 500], c );
        checke( string[count - 500], c );
        checke( string[count - 250], c );
        checke( string[count - 50], c );
        checke( string[count - 25], c );
        checke( string[count - 2], c );
        checke( string[count - 1], c );
        checke( string[count], d );
        string[count] = c;
    }


    for (count = (ALMOST_MAX - MAX_STEPS ); count < ALMOST_MAX; count++)
    {
        string[count] = d;                   /* NULL to terminate string */
        pstr = _strnset( string, c, count );
        checke( string[0], c );
        checke( string[1], c );
        checke( string[count - 25000], c );
        checke( string[count - 5000], c );
        checke( string[count - 2500], c );
        checke( string[count - 500], c );
        checke( string[count - 500], c );
        checke( string[count - 250], c );
        checke( string[count - 50], c );
        checke( string[count - 25], c );
        checke( string[count - 2], c );
        checke( string[count - 1], c );
        checke( string[count], d );
        string[count] = c;
    }





    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strpbrk4.c ===
/***************************************************************************

           Copyright (c) 1992, Microsoft Corporation

Method:



Switches:   NONE


Abstract:   Test for: strpbrk

          char * strpbrk(const char *, const char *);

OS Version:
CPU:
Dependencies:       NONE
Environment Vars:   NONE
Verification Method:    TBD
Priority:       1/2/3/4
Notes:          NONE
Products:


Revision History:

    Date    emailname   description
----------------------------------------------------------------------------
    18-Feb-93   xiangjun    created
----------------------------------------------------------------------------

EndHeader:

****************************************************************************/


#include <string.h>
#include <stdio.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect = 0;

static char string1[] = "ABCDEFGHijklmnopq";
static char string2[] = {'a','b',
               /* 1st break */     '?',    'c','d',
               /* 2nd break */     ',',
               /* 3nd break */     1,        'e',
               /* 4nd break */     'z',     'Z',0};
static char str_brkset[] = {',',1,'?','z',0};

int strpbrk4Entry(){

static char * str_ptr;

/* Begin */

   startest();

   /* expect NULL resulte */

   if( NULL != (str_ptr = strpbrk( string1, str_brkset )) )
      fail(0);

   /* other normal cases */

   if( NULL == (str_ptr = strpbrk( string2, str_brkset )) ||
       *str_ptr != '?' )
      fail(1);

   if( NULL == (str_ptr = strpbrk( str_ptr+1, str_brkset )) ||
       *str_ptr != ',' )
      fail(2);

   if( NULL == (str_ptr = strpbrk( str_ptr+1, str_brkset )) ||
       *str_ptr != 1 )
      fail(3);

   if( NULL == (str_ptr = strpbrk( str_ptr+1, str_brkset )) ||
       *str_ptr != 'z' )
      fail(4);

   if( str_ptr = strpbrk( str_ptr+1, str_brkset ) )
      fail(5);

/* end */

   finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strrchr1.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strrchr1.c
                     strrchr1
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the strrchr() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 12-May-92    edv            created


---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;


static char string[51] = "AaBbCcDdE1FfGgHhIiJ1KkLlMmNnO1PpQqRrSsT1UuVvWwXxY1\0";
/*                          1         2         3         4         5
*/


int strrchr1Entry(){
    int c;
    char *pstr;

    startest();


/*  Scenario 1: Verify that if successful, a pointer to the first location
                of c in string is returned.
*/
    c = '1';
    pstr = strrchr( string, c );

/*  Subtract one because relative addresses start at plus 0
*/
    checke( pstr, (string + 50 - 1) );



/*  Scenario 2: Verify that if unsuccessful, a NULL pointer is returned.
*/
    c = 'z';
    pstr = strrchr( string, c );
    checkNULL( pstr );



/*  Scenario 3: Verify that the function works correctly when c occurs
                in the first byte of string.
*/
    c = 'A';
    pstr = strrchr( string, c );
    checke( pstr, string );



/*  Scenario 4: Verify that the function works correctly when c occurs
                in the last byte of string.
*/
    c = '1';
    pstr = strrchr( string, c );

/*  Subtract one because relative addresses start at plus 0
*/
    checke( pstr, (string + 50 - 1) );



    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strpbrk1.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strpbrk1.c
                     strpbrk1
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the strpbrk() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 21-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;


static char string1a[50] = "AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxY\0";
static char string1b[30] = "\0";


static char string2a[15]  = "1234567890aA\0";
static char string2b[35]  = "yZz1234567890)(*&^%$#@!~\0";
static char string2c[15] = "\0";


int strpbrk1Entry(){
    char *pstr1;



    startest();




/*  Scenario 1: Verify that the function returns a pointer to the first
                occurence of a character of string2 in string1.
*/

    pstr1 = strpbrk( string1a, string2a );

    checke( pstr1, string1a );





/*  Scenario 2: Verify that the function returns NULL when the strings have
                no characters in common.
*/
    pstr1 = strpbrk( string1a, string2b );
    checkNULL( pstr1 );





/*  Scenario 3: Verify that the function works correctly when string1
                is NULL.
*/
    pstr1 = strpbrk( string1b, string2b );
    checkNULL( pstr1 );





/*  Scenario 4: Verify that the function works correctly when string2
                is NULL.
*/
    pstr1 = strpbrk( string1a, string2c );
    checkNULL( pstr1 );





/*  Scenario 5: Verify that the function works correctly when both string1
                and string2 are NULL.
*/
    pstr1 = strpbrk( string1b, string2c );
    checkNULL( pstr1 );





    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strpbrk2.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strpbrk2.c
                     strpbrk2
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the strpbrk() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 21-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;

static char string1a[2]   = "1\0";
static char string1b[40]  = "A1B2C3D4E5F6G7H8I9J0\0";
static char string1c[2]   = "7\0";

static char string2a[27]  = "AaBbCc0987654321\0";
static char string2b[2]   = "J\0";
static char string2c[2]   = "7\0";



int strpbrk2Entry(){
    char *pstr1;



    startest();



/*  Scenario 6: Verify that the function works correctly when string1 only
                holds 1 character.
*/
    pstr1 = strpbrk( string1a, string2a );
    checke( pstr1, string1a );




/*  Scenario 7: Verify that the function works correctly when string2 only
                holds 1 character.
*/
    pstr1 = strpbrk( string1b, string2b );
    checke( pstr1, string1b + 19 - 1);




/*  Scenario 8: Verify that the function works correctly when both string1
                and string2 only hold 1 character.
*/
    pstr1 = strpbrk( string1c, string2c );
    checke( pstr1, string1c );




    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strnset3.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strnset3.c
                     strnset3
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the _strnset() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 14-May-92    edv            created
 [ 1] 10-Jan-95    a-timke        Fixed memory overrun problem.

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <malloc.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;

#define DELTA    1000
#define LARGEST  (USHRT_MAX - DELTA)


int strnset3Entry(){
    int i;
    unsigned char *pstr1, *pstr2;
    size_t str_size, count;



    startest();



/*  Scenario 6: Verify that str can be as large as LARGEST
                using any STRING model.
*/


       str_size = LARGEST;

       pstr1 = malloc( str_size );
       if (pstr1 == NULL)
       {
          faill();
          exit( 1 );
       }

       count = str_size-1;

       for (i = 0; i < (int) count; i++)      /* Initialize string */
           pstr1[i] = ' ';
       pstr1[count] = '\0';


       pstr2 = _strnset( pstr1, 'X', count );

       for (i = 0; i < (int) count; i++)
           checke( pstr2[i], 'X' );
       checke( pstr2[count], '\0' );


    free( pstr1 );


    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strrchr2.c ===
/***************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strrchr2.c
                     strrchr2
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the strrchr() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 13-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;

static unsigned char string[21] = "$$$$$$$$$$$$$$$$$$$$\0";


int strrchr2Entry(){
    int c;
    unsigned char *pstr;

    startest();


/*  Scenario 5: Verify that c can be any value from 0 to UCHAR_MAX,
                and will be recognized as the character to be found.
*/

    pstr = strrchr( string, '\0' );
    checke( pstr, string + 20);



    for (c = 1; c < '$'; c++)
    {
        string[1] = c;
        string[3] = c;
        string[5] = c;
        string[7] = c;
        string[9] = c;
        string[15] = c;
        pstr = strrchr( string, c );
        checke( pstr, string + 15 );
    }




/*  Change values in string to avoid finding the wrong dollar sign.
*/

    strcpy( string, "####################\0" );

    for (c = '$'; c <= UCHAR_MAX; c++)
    {
        string[1] = c;
        string[3] = c;
        string[5] = c;
        string[7] = c;
        string[9] = c;
        string[15] = c;
        pstr = strrchr( string, c );
        checke( pstr, string + 15 );
    }



    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strpbrk3.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strpbrk3.c
                     strpbrk3
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the strpbrk() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 21-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;

static char string1a[200] = { "`1234567890-=~!@#$%^&*()_+"
                       "qwertyuiop[]QWERTYUIOP{}|\\"
                       "asdfghjkl;'ASDFGHJKL:\""
                       "zxcvbnm,./ZXCVBNM<>? \0" };
static char string1b[250] =  "`1234567890-=qwertyuiop[]asdfghjkl;'zxcvbnm,./ \0";
static char string1c[300] =  "1234567890abcdefgHIJKLMNOPqrstuvWXYZ\0";
static char string1d[100] =  "abcdefgHIJKLMNOPqrstuvWXYZ0123456789\0";
static char string1e[120] =  "abcdefgHIJKLMNOPqrstuvWXYZ0123456789./?\0";
static char string1f[210] =  "1234567890ABCDEFGHI";



static char string2a[155] = { "QWERTYUIOP{}|qwertyuiop[]"
                       "ASDFGHJKL:\"asdfghjkl;'"
                       "ZXCVBNM<>? zxcvbnm,./"
                       "~!@#$%^&*()_+`1234567890-=\0" };
static char string2b[555] =  "~!@#$%^&*()_+QWERTYUIOP{}|ASDFGHJKL:\"ZXCVBNM<>?\\\0";
static char string2c[111] =  "abcdefgHIJKLMNOPqrstuvWXYZ!@#$%^&*()_+-=1234567890\0";
static char string2d[333] =  "!@#$%^&*()_+-=9\0";
static char string2e[151] =  "&*<t>_+-=9\0";
static char string2f[351] =  "JKAAAAAAAAALMNOAAAAAAAAAPQRAAAAAAAASTUAAAAVWXYZAAA\0";



int strpbrk3Entry(){
    char *pstr1;


    startest();



/*  Scenario 9: Verify that the function works correctly when both string1
                and string2 are large and equal.
*/
    pstr1 = strpbrk( string1a, string2a );
    checke( pstr1, string1a );




/*  Scenario 10: Verify that the function works correctly when both string1
                 and string2 are large but mutually exclusive.
*/
    pstr1 = strpbrk( string1b, string2b );
    checkNULL( pstr1 );




/*  Scenario 11: Verify that the function works correctly when string2 is
                 a superset of string1.
*/
    pstr1 = strpbrk( string1c, string2c );
    checke( pstr1, string1c );




/*  Scenario 12: Verify that the function works correctly when a character
                 in string2 occurs in the last character of string1.
*/
    pstr1 = strpbrk( string1d, string2d );
    checke( pstr1, (string1d + 36 - 1) );




/*  Scenario 13: Verify that the function works correctly when a character
                 in string2 occurs in the middle of string1.
*/
    pstr1 = strpbrk( string1e, string2e );
    checke( pstr1, (string1e + 20 - 1) );




/*  Scenario 14: Verify that the function works correctly when string2
                 is larger than string1 but only because of a repetitve
                 character.
*/
    pstr1 = strpbrk( string1f, string2f );
    checke( pstr1, (string1f + 11 - 1) );





    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strrchr3.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strrchr3.c
                     strrchr3
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the strrchr() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 13-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;

#define DELTA        1850
#define ALMOST_MAX  (SHRT_MAX - DELTA)


/*  Scenario 6: Verify that string can be almost as large as SHRT_MAX.
*/

static unsigned char string[ALMOST_MAX];



int strrchr3Entry(){
    int c;
    unsigned char *pstr;


    startest();



    c = '^';
    memset( string, c, sizeof(string) );  /* Fill string with '^'        */
    string[ALMOST_MAX - 1] = '\0';        /* NULL terminate the string   */



    pstr = strrchr( string, '#' );
    checkNULL( pstr );                    /* NULL because no # in string */



    string[ALMOST_MAX - 2000] = 'X';      /* Prepare string for the test */
    string[ALMOST_MAX - 1500] = 'X';
    string[ALMOST_MAX - 1000] = 'X';
    string[ALMOST_MAX - 500]  = 'X';
    string[ALMOST_MAX - 200]  = 'X';
    string[ALMOST_MAX - 170]  = 'X';
    string[ALMOST_MAX - 150]  = 'X';
    string[ALMOST_MAX - 130]  = 'X';
    string[ALMOST_MAX - 100]  = 'X';
    string[ALMOST_MAX - 50]   = 'X';
    string[ALMOST_MAX - 25]   = 'X';
    string[ALMOST_MAX - 2]    = 'X';


    pstr  = strrchr( string, 'X' );

    checke( pstr, string + ALMOST_MAX - 2 );




    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strrchr4.c ===
/**************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strrchr4.c
                     strrchr4
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the strrchr() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 13-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <malloc.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;

#define DELTA    1000
#define LARGEST  (USHRT_MAX - DELTA)


int strrchr4Entry(){
    int c;
    unsigned int str_size;
    unsigned char *pstr1, *pstr2;

    startest();


/*  Scenario 7: Verify that string can be as large as LARGEST
                using any memory model.
*/

       str_size = LARGEST;

       pstr1 = malloc( str_size );
       if (pstr1 == NULL)
       {
          faill();
          exit( 1 );
       }
       memset( pstr1, '+', str_size );

       pstr1[str_size - 100] = c = 'X';
       pstr2 = strrchr( pstr1, c );

       checke( pstr2, pstr1 + str_size - 100 );

    free( pstr1 );


    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strrev2.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strrev2.c
                     strrev2
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the _strrev() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 14-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;


#define DELTA  4000
#define ALMOST_MAX (USHRT_MAX - DELTA)


/*  Scenario 6: Verify that string can be almost as large as USHRT_MAX.
*/

static unsigned char string[ALMOST_MAX] = { "0123456789"
                                     "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                                     "!@#$%^&*()_+-={}|[]:;'/?,.<>\0"
                                   };

static unsigned char baseline[65] = { "><.,?/';:][|}{=-+_)(*&^%$#@!"
                               "ZYXWVUTSRQPONMLKJIHGFEDCBA"
                               "9876543210\0"
                              };

int strrev2Entry(){
    int i;
    unsigned char *pstr;

    startest();



    pstr = _strrev( string );

    checke( pstr, string );

    for (i = 0; i < sizeof( baseline ); i++)
        checke( pstr[i], baseline[i] );

    checke( pstr[i], '\0' );




    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strrev1.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strrev1.c
                     strrev1
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the _strrev() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 14-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;


static unsigned char string1[6] = "ABCDE\0";
static unsigned char string2[5] = "\0\0\0\0\0";
static unsigned char string3[2] = "1\0";
static unsigned char string4[3] = "12\0";
static unsigned char string5[37] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\0";

static unsigned char baseline1[6] = "EDCBA\0";
static unsigned char baseline5[37] = "ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210\0";

int strrev1Entry(){
    int i;
    unsigned char *pstr;

    startest();



/*  Scenario 1: Verify that the function returns a pointer to the
                altered string.
*/

    pstr = _strrev( string1 );

    checke( pstr, string1 );

    for (i = 0; i < (sizeof( string1 ) - 1); i++)
        checke( pstr[i], baseline1[i] );

    checke( pstr[i], '\0' );





/*  Scenario 2: Verify that the function works correctly when string
                is NULL.
*/

    pstr = _strrev( string2 );            /* String begins with NULL,  */
                                         /*  so string is unalterred. */
    checke( pstr, string2 );

    for (i = 0; i < (sizeof( string2 ) ); i++)
        checke( string2[i], '\0' );




/*  Scenario 3: Verify that the function works correctly when string
                can hold only 1 character.
*/

    pstr = _strrev( string3 );

    checke( pstr, string3 );

    checke( pstr[0], '1' );

    checke( pstr[1], '\0' );




/*  Scenario 4: Verify that the function works correctly when string
                can hold only 2 characters.
*/

    pstr = _strrev( string4 );

    checke( pstr, string4 );

    checke( pstr[0], '2' );

    checke( pstr[1], '1' );

    checke( pstr[2], '\0' );




/*  Scenario 5: Verify that the function works correctly using a
                larger string.
*/

    pstr = _strrev( string5 );

    checke( pstr, string5 );

    for (i = 0; i < (sizeof( string5 ) ); i++)
        checke( pstr[i], baseline5[i] );

    checke( pstr[i], '\0' );




    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strrev3.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strrev3.c
                     strrev3
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the _strrev() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 14-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <malloc.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;

#define DELTA    2000
#define LARGEST  (USHRT_MAX - DELTA)



static unsigned char strinit[65] = { "0123456789"
                              "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                              "!@#$%^&*()_+-={}|[]:;'/?,.<>\0"
                            };

static unsigned char baseline[65] = { "><.,?/';:][|}{=-+_)(*&^%$#@!"
                               "ZYXWVUTSRQPONMLKJIHGFEDCBA"
                               "9876543210\0"
                              };

int strrev3Entry(){

    int i;
    unsigned int str_size;
    unsigned char *pstr1, *pstr2;

    startest();


/*  Scenario 7: Verify that string can be almost as large as
        LARGEST using any memory model.
*/

       str_size = LARGEST;

       pstr1 = malloc( str_size );

       if (pstr1 == NULL)
       {
          faill();
          exit( 1 );
       }

       for (i = 0; i < sizeof( strinit ); i++)   /* Initialize string */
           pstr1[i] = strinit[i];

       pstr2 = _strrev( pstr1 );

       checke( pstr2, pstr1 );

       for (i = 0; i < sizeof( baseline ); i++)
           checke( pstr2[i], baseline[i] );



    free( pstr1 );


    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strset1.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strset1.c
                     strset1
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the _strset() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 13-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;


static unsigned char string1[6] = "ABCDE\0";
static unsigned char string2[5] = "\0\0\0\0\0";
static unsigned char string3[2] = "1\0";
static unsigned char string4[3] = "22\0";


int strset1Entry(){
    int i;
    unsigned char *pstr;

    startest();



/*  Scenario 1: Verify that the function returns a pointer to the
                altered string.
*/

    pstr = _strset( string1, '%' );

    checke( pstr, string1 );

    for (i = 0; i < (sizeof( string1 ) - 1); i++)
        checke( string1[i], '%' );

    checke( string1[i], '\0' );




/*  Scenario 2: Verify that the function works correctly when string
                is NULL.
*/

    pstr = _strset( string2, 'X' );      /* String begins with NULL,  */
                                         /*  so string is unalterred. */
    checke( pstr, string2 );

    for (i = 0; i < (sizeof( string2 ) ); i++)
        checke( string2[i], '\0' );




/*  Scenario 3: Verify that the function works correctly when string
                can hold only 1 character.
*/

    pstr = _strset( string3, '*' );

    checke( pstr, string3 );

    checke( pstr[0], '*' );

    checke( pstr[1], '\0' );




/*  Scenario 4: Verify that the function works correctly when string
                can hold only 2 characters.
*/

    pstr = _strset( string4, '$' );

    checke( pstr, string4 );

    checke( pstr[0], '$' );

    checke( pstr[1], '$' );

    checke( pstr[2], '\0' );




    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strset3.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strset3.c
                     strset3
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the _strset() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 13-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <malloc.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;

#define DELTA    100
#define LARGEST  (USHRT_MAX - DELTA)


int strset3Entry(){
    int c, d, i;
    unsigned int str_size;
    unsigned char *pstr1, *pstr2;



    startest();



/*  Scenario 7: Verify that string1 can be as large as LARGEST
                using any memory model.
*/


       str_size = LARGEST;

       pstr1 = malloc( str_size );

       if (pstr1 == NULL)
       {
          faill();
          exit( 1 );
       }

       memset( pstr1, ' ', str_size );       /* Clear the string.      */

       d = '\0';
       pstr1[str_size - 1] = d;              /* Terminate with NULL.   */

       c = '+';
       pstr2 = _strset( pstr1, c );
                                             /* Check the pointers.    */
       checke( pstr2, pstr1 );

       for (i = 0; i < (int) (str_size - 1); i++)  /* Check each char.       */
             checke( pstr2[i], c );

       checke( pstr2[i], d );                /* Check NULL terminator. */


    free( pstr1 );


    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strset2.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strset2.c
                     strset2
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the _strset() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 13-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <limits.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;


#define DELTA       100
#define ALMOST_MAX (SHRT_MAX - DELTA)

/*  Scenario 5: Verify that string can be almost as large as SHRT_MAX.
*/

static unsigned char string1[ALMOST_MAX];

static unsigned char string2[11] = "0123456789\0";



int strset2Entry(){
    int c, i;
    unsigned char *pstr;

    startest();


    c = ' ';
    memset( string1, c, ALMOST_MAX);
    string1[ALMOST_MAX - 1] = '\0';

    c = 'X';
    pstr = _strset( string1, c );

    checke( pstr, string1 );

    for (i = 0; i < ALMOST_MAX - 1; i++)
        checke( pstr[i], c );

    checke( pstr[i], '\0' );





/*  Scenario 6: Verify that c can be any value from 1 to UCHAR_MAX.
*/

    for (c = 1; c < UCHAR_MAX; c++)
    {
        pstr = _strset( string2, c );

        for (i = 0; i < (sizeof( string2 ) - 1); i++)
            checke( pstr[i], c );

        checke( pstr[i], '\0' );

    }




    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strstr1.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strstr1.c
                     strstr1
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the strstr() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 20-May-92    edv            created


---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;


static char string1a[50] = "AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxY\0";
static char string1b[10] = "\0";


static char string2a[4]  = "eFf\0";
static char string2b[3]  = "tT\0";
static char string2c[10] = "\0";


int strstr1Entry(){
    char *pstr1;



    startest();




/*  Scenario 1: Verify that the function returns a pointer to the first
                occurence of string2 in string1.
*/

    pstr1 = strstr( string1a, string2a );

    checke( pstr1, (string1a + 10 - 1) );





/*  Scenario 2: Verify that when string2 is not found in string1, the
                function returns NULL.
*/
    pstr1 = strstr( string1a, string2b );
    checkNULL( pstr1 );





/*  Scenario 3: Verify that the function works correctly when string1
                is NULL.
*/
    pstr1 = strstr( string1b, string2b );
    checkNULL( pstr1 );





/*  Scenario 4: Verify that the function works correctly when string2
                is NULL.  This should return string1 because string2
                has length zero.
*/
    pstr1 = strstr( string1a, string2c );
    checke( pstr1, string1a );





/*  Scenario 5: Verify that the function works correctly when both string1
                and string2 are NULL.  This should return string1 because
                string2 has length zero.
*/
    pstr1 = strstr( string1b, string2c );
    checke( pstr1, string1b );





    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strtok1.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strtok1.c
                     strtok1
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the strtok() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 05-May-92    edv            created


---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;

#define TOK_LEN 7    /* length of tokens */
#define TOK_ID  5    /* position in baseline identifying which token */

static char tokenstring[] = ";Token1,;Token2 Token3\t, Token4\nToken5 \t\n;,";
static char separators[] = "\t\n ,;";
static char baseline[] = "Token1";
static char *token;


int strtok1Entry( void ){

    int i;

    startest();


/*  Scenario 1: Verify that the function returns a pointer to string1.
*/

    token = strtok( tokenstring, separators );

    for (i = 0; i < TOK_LEN; i++)
       checke( token[i], baseline[i] );




/*  Scenario 2: Verify that the function inserts a NULL to end string1.
*/

    checke( token[TOK_LEN - 1], NULL );




/*  Scenario 3: Verify that if string1 is NULL, the function returns the
                next token in the previous token string.
*/

    baseline[TOK_ID] = '2';

    token = strtok( NULL, separators );

    for (i = 0; i < TOK_LEN; i++)
       checke( token[i], baseline[i] );


    baseline[TOK_ID] = '3';

    token = strtok( NULL, separators );

    for (i = 0; i < TOK_LEN; i++)
       checke( token[i], baseline[i] );


    baseline[TOK_ID] = '4';

    token = strtok( NULL, separators );

    for (i = 0; i < TOK_LEN; i++)
       checke( token[i], baseline[i] );


    baseline[TOK_ID] = '5';

    token = strtok( NULL, separators );

    for (i = 0; i < TOK_LEN; i++)
       checke( token[i], baseline[i] );




/*  Scenario 4: Verify that if string1 is NULL, the function returns the
                next token in the previous token string.
*/


    token = strtok( NULL, separators );

    checke( token, NULL );


    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strstr2.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strstr2.c
                     strstr2
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the strstr() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 21-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;

static char string1a[50] = "AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxY\0";
static char string1b[40] = "A1B2C3D4E5F6G7H8I9J0\0";


static char string2a[7]  = "AaBbCc\0";
static char string2b[11] = "tUuVvWwXxY\0";
static char string2c[25] = "A1B2C3D4E5F6G7H8I9J0\0";
static char string2d[30] = "1B2C3D4E5F6G7H8I9J0\0";


int strstr2Entry(){
    char *pstr1;


    startest();



/*  Scenario 6: Verify that the function works correctly when string2 occurs
                in the first byte of string1.
*/
    pstr1 = strstr( string1a, string2a );
    checke( pstr1, string1a );




/*  Scenario 7: Verify that the function works correctly when string2 occurs
                in the last byte of string1.
*/
    pstr1 = strstr( string1a, string2b );

    checke( pstr1, (string1a + 40 - 1) );



/*  Scenario 8: Verify that the function works correctly when both string1
                and string2 are equal.
*/
    pstr1 = strstr( string1b, string2c );

    checke( pstr1, string1b );



/*  Scenario 9: Verify that the function works correctly when string2 is
                a substring equal to string1 minus string1[0].
*/
    pstr1 = strstr( string1b, string2d );

    checke( pstr1, string1b + 1 );




    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strtok2.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strtok2.c
                     strtok2
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the strtok() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 05-May-92    edv            created


---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;

static char big_tokenstr[] = "Token01!Token02@Token03#Token04$Token05%Token06^"
                      "Token07&Token08*Token09(Token10)Token11-Token12_"
                      "Token13=Token14+Token15[Token16]Token17{Token18}"
                      "Token19|Token20:Token21;Token22<Token23>Token24,"
                      "Token25.Token26/Token27?Token28 Token29\tToken30\n";

static char separators[] =  "!@#$%^&*()-_=+[]{}|:;<>,./? \t\n";

static char tokenstring1[] = " * Token01 * Token02 * ";
static char tokenstring2[] = "         Token01           Token02             ";
static char separator[] = " ";
static char baseline[] = "Token01";
static char null_str[] = "";
static char *token;


static void check_token( char *str1, char *str2 )
{
    int i;

    for (i = 0; i < 8; i++)
       checke( str1[i], str2[i] );
}


int strtok2Entry( void ){

    int i;

    startest();


/*  Scenario 5: Verify that the function works correctly when
                string1 is NULL.
*/

    token = strtok( null_str, separators );
    checkNULL( token );




/*  Scenario 6: Verify that the function works correctly when
                string2 is NULL.
*/

    token = strtok( tokenstring1, "");

    check_token( token, " * Token01 * Token02 * " );




/*  Scenario 7: Verify that the function works correctly when
                string2 is 1 byte long.
*/

    token = strtok( tokenstring2, " " );
    check_token( token, "Token01" );


    token = strtok( NULL, " " );
    check_token( token, "Token02" );




/*  Scenario 8: Verify that the function works correctly when
                string1 is large.
*/

    token = strtok( big_tokenstr, separators );
    check_token( token, "Token01" );

    for ( i = 1; i < 6; i++ )
        token = strtok( NULL, separators );
    check_token( token, "Token06" );


    for ( i = 1; i < 7; i++ )
        token = strtok( NULL, separators );
    check_token( token, "Token12" );


    for ( i = 1; i < 7; i++ )
        token = strtok( NULL, separators );
    check_token( token, "Token18" );


    for ( i = 1; i < 7; i++ )
        token = strtok( NULL, separators );
    check_token( token, "Token24" );


    for ( i = 1; i < 7; i++ )
        token = strtok( NULL, separators );
    check_token( token, "Token30" );

    token = strtok( NULL, separators );
    checkNULL( token );


    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strtol2.c ===
/***************************************************************************

           Copyright (c) 1993, Microsoft Corporation

Method:



Switches:   NONE


Abstract:   Test for: strtol in a non-C locale.
            Test that strtol handles characters in a non-c locale
            by setting LC_NUMERIC and checking the radix character.

OS Version:
CPU:
Dependencies:       NONE
Environment Vars:   NONE
Verification Method:    EXECUTE
Priority:       1/2/3/4
Notes:          NONE
Products:


Revision History:

    Date    emailname   description
----------------------------------------------------------------------------
    03-Nov-93   patlo    Created by copying strtoul2.c
----------------------------------------------------------------------------

EndHeader:

****************************************************************************/

#include <locale.h>
#include <string.h>
#include <stdlib.h>
#include <float.h>
#include <test.h>


static char test[] = "strtol2";
static int perfect = 0;

static void compare (long, long, int testno);

int strtol2Entry(){
    long l_result;

    startest();

    if ( setlocale ( LC_NUMERIC, "French") == NULL)
    { 
        fail (10);
        finish();
    }

    l_result = strtol ( "3,5", NULL, 10);

    compare ( l_result, 3, 1 );

    finish();
}



static void compare (long f1, long f2, int testno)
{
    if (f1 != f2) 
    {
        printf("Was:       \"%l\"\nShould be: \"%l\"\n", f1, f2);
        fail( testno );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strtol1.c ===
/***************************************************************************

           Copyright (c) 1993, Microsoft Corporation

Method:



Switches:   NONE


Abstract:   Test for: strtol in a non-C locale.
            Test that strtol handles characters in a non-c locale
            by setting LC_NUMERIC and checking the radix character.

OS Version:
CPU:
Dependencies:       NONE
Environment Vars:   NONE
Verification Method:    EXECUTE
Priority:       1/2/3/4
Notes:          NONE
Products:


Revision History:

    Date    emailname   description
----------------------------------------------------------------------------
    03-Nov-93   patlo    Created by copying strtoul.c
----------------------------------------------------------------------------

EndHeader:

****************************************************************************/

#include <locale.h>
#include <string.h>
#include <stdlib.h>
#include <float.h>
#include <test.h>


static char test[] = "strtol1";
static int perfect = 0;

static void compare (long, long, int testno);

int strtol1Entry(){
    long l_result;

    startest();

    if ( setlocale ( LC_NUMERIC, "French") == NULL)
    { 
        fail (10);
        finish();
    }

    l_result = strtol ( "3,5", NULL, 10);

    compare ( l_result, 3, 1 );

    finish();
}



static void compare (long f1, long f2, int testno)
{
    if (f1 != f2) 
    {
        printf("Was:       \"%l\"\nShould be: \"%l\"\n", f1, f2);
        fail( testno );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strtoul2.c ===
/***************************************************************************

           Copyright (c) 1993, Microsoft Corporation

Method:



Switches:   NONE


Abstract:   Test for: strtoul in a non-C locale.  
            Test that strtoul handles characters in a non-c locale
            by setting LC_NUMERIC and checking the radix character.

OS Version:
CPU:
Dependencies:       NONE
Environment Vars:   NONE
Verification Method:    EXECUTE
Priority:       1/2/3/4
Notes:          NONE
Products:


Revision History:

    Date    emailname   description
----------------------------------------------------------------------------
    03-Nov-93   patlo    Created by copying wcstoul2.c
----------------------------------------------------------------------------

EndHeader:

****************************************************************************/

#include <locale.h>
#include <string.h>
#include <stdlib.h>
#include <float.h>
#include <test.h>


static char test[] = "strtoul2";
static int perfect = 0;

static void compare (unsigned long, unsigned long, int testno);

int strtoul2Entry(){
    unsigned long l_result;

    startest();

    if ( setlocale ( LC_NUMERIC, "French") == NULL)
    { 
        fail (10);
        finish();
    }

    l_result = strtoul ( "3,5", NULL, 10);

    compare ( l_result, 3, 1 );

    finish();
}



static void compare (unsigned long f1, unsigned long f2, int testno)
{
    if (f1 != f2) 
    {
        printf("Was:       \"%lu\"\nShould be: \"%lu\"\n", f1, f2);
        fail( testno );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strupr3.c ===
/***************************************************************************

         Copyright (C) Microsoft Corp. 1993


Test:   _strupr

Abstract:   Vefifies that _strupr is effected by a change in the locale,
            and handles chars >127.

===========================================================================
Syntax

===========================================================================
Priority:               1
Products:               WIN NT


Revision History:

    Date        emailname       description
----------------------------------------------------------------------------
    11-03-93    lhanson         created
    11-22-94    a-timke         Modified for NT3.5 results.
----------------------------------------------------------------------------

EndHeader:

****************************************************************************/

#include <string.h>
#include <locale.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;


int strupr3Entry(){
    unsigned char *psz1_us = "AaBbC\x9A\x8B\xE0\xEF\xF0Zz";
    unsigned char *psz1    = "AaBbC\x9A\x8B\xE0\xEF\xF0Zz";
    unsigned char *psz2    = "AABBC\x8A\x8B\xC0\xCF\xD0ZZ";

    startest();

    checke(_strupr(psz1_us), psz1_us);
    checkne(strcmp(psz1_us, psz2), 0);

    checkne(setlocale( LC_ALL, "French_France.OCP" ), NULL);

    checke(_strupr(psz1), psz1);
#if defined(TEST_WIN95) /*prior to NLS work of 2/97.*/
    checke(strcmp(psz1, psz2), 0);
#else
    checke(strcmp(psz1, psz2), 1);
#endif
    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strtoul1.c ===
/***************************************************************************

           Copyright (c) 1993, Microsoft Corporation

Method:



Switches:   NONE


Abstract:   Test for: strtoul in a non-C locale.  
            Test that strtoul handles characters in a non-c locale
            by setting LC_NUMERIC and checking the radix character.

OS Version:
CPU:
Dependencies:       NONE
Environment Vars:   NONE
Verification Method:    EXECUTE
Priority:       1/2/3/4
Notes:          NONE
Products:


Revision History:

    Date    emailname   description
----------------------------------------------------------------------------
    03-Nov-93   patlo    Created by copying wcstod1.c
----------------------------------------------------------------------------

EndHeader:

****************************************************************************/

#include <locale.h>
#include <string.h>
#include <stdlib.h>
#include <float.h>
#include <test.h>


static char test[] = "strtoul1";
static int perfect = 0;

static void compare (unsigned long, unsigned long, int testno);

int strtoul1Entry(){
    unsigned long l_result;

    startest();

    if ( setlocale ( LC_NUMERIC, "French") == NULL)
    { 
        fail (10);
        finish();
    }

    l_result = strtoul ( "3,5", NULL, 10);

    compare ( l_result, 3, 1 );

    finish();
}



static void compare (unsigned long f1, unsigned long f2, int testno)
{
    if (f1 != f2) 
    {
        printf("Was:       \"%lu\"\nShould be: \"%lu\"\n", f1, f2);
        fail( testno );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\tstrchr2.c ===
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "test.h"

#ifdef QA_SIMPLE_QALIB
#define TEST_MAX    500
#else
#define TEST_MAX    1000
#endif

static char buf[ 0x410 ];

static char test[] = __FILE__;
static int perfect;

int tstrchr2Entry(void){
        char *pbuf,*pret;
        int test_count, srch_char, length;
        int i;
        int success_flag;

        startest();

        for ( test_count = 0 ; test_count < TEST_MAX ; test_count++ ) {

            // Using the random number generator, set the length of the search
            // string, the search character and the alignment of the string to
            // be searched.

            length = rand() & 0x03ff;
            srch_char = rand() & 0x0ff;
            pbuf = buf + (rand() & 3);            

            // Fill the search string with non-zero random characters.

            for ( i = 0 ; i < length ; i++ )
                while ( (pbuf[i] = rand() & 0x0ff) == 0 );

            pbuf[length] = '\0';

            // print out test header.
/*
            printf( "test %d: search char = %x, strlen = %d, offset = %d, result = ",
                          test_count,       srch_char,   length,      (pbuf - buf) );
*/
            // run the test

            pret = strchr( pbuf, srch_char );

            // check the result

            if ( pret == NULL ) {

                // strchr reports failure. make sure there is no instance of 
                // srch_char in the string.

                success_flag = 1;

                for ( i = 0 ; i <= length ; i++ )
                    if ( srch_char == (pbuf[i] & 0x0ff) ) {
                        success_flag = 0;
                        fail(test_count);
                        break;
                    }

            }
            else {

                // strchr reports success. make sure an instance of srch_char 
                // was really found, and that it was the first such instance.

                if ( srch_char != (*pret & 0x0ff) ) {
                    success_flag = 0;
                    fail(test_count+100);
                }
                else {

                    success_flag = 1;

                    for ( i = 0 ; (pbuf + i) < pret ; i++ )
                        if ( (srch_char == (pbuf[i] & 0x0ff)) || 
                             (0 == pbuf[i]) ) 
                        {
                            success_flag = 0;
                            fail(test_count+200);
                            break;
                        }

                }
            }
/*
            if ( success_flag )
                printf("PASSED\n\n");
            else
                printf("FAILED\n\n");
*/
        }
        finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strxfrm1.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strxfrm1.c
                     strxfrm1
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the strxfrm() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               Must include STRING.H
                     Tests decribed in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 22-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <locale.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;


static char string1a[52] = "AaBbCc\0";
static char string2a[39] = "0123456789012345678901234567890123\0";

static char string1b[69] = "\0";
static char string2b[75] = "Copy 30 characters to string1b\0";

static char string1c[69] = "\0";
static char string2c[75] = "Copy only 35 characters to string1c\0";

static char string1d[20] = "0123456789\0";
static char string2d[51] = "This length is 17\0";

static char string1e[69] = "\0";
static char string2e[75] = "abcdefg\0";

static char string1f[23] = "1234567890\0";
static char string2f[32] = "\0";

static char string1g[47] = "\0";
static char string2g[64] = "\0";

#define LEN1 34
#define LEN2 30
#define LEN3 35
#define LEN4 17
#define LEN5  7
#define LEN6  0
#define LEN7  0

int strxfrm1Entry(){
    int i, count;
    size_t retvalue;


    startest();



    setlocale( LC_COLLATE, "C" );




/*  Scenario 1: Verify that the function returns the length of the
                transformed string (should = len( string2 )).
*/

    retvalue = 0;
    count = LEN1 + 1;
    retvalue = strxfrm( string1a, string2a, count );

    checke( retvalue, LEN1 );




/*  Scenario 2: Verify that count characters are copied from string2
                to string1.
*/

    retvalue = 0;
    count = LEN2 + 1;

    retvalue = strxfrm( string1b, string2b, count );

    checke( retvalue, LEN2 );

    for (i = 0; i < count; i++ )
        checke( string1b[i], string2b[i] );

    checke( string1b[i], '\0' );




/*  Scenario 3: Verify that when count is greater than the length of string2,
                only length(string2) + 1 characters are copied from string2
                to string1.
*/

    retvalue = 0;
    count = 2 * LEN3;

    retvalue = strxfrm( string1c, string2c, count );

    checke( retvalue, LEN3 );

    for (i = 0; i < LEN3; i++ )
        checke( string1c[i], string2c[i] );

    checke( string1c[i], '\0' );




/*  Scenario 4: Verify that when count equals zero the function returns
                the length of string2 and string1 is unaltered.

*/

    retvalue = 0;
    count = 0;

    retvalue = strxfrm( string1d, string2d, count );

    checke( retvalue, LEN4 );

    for (i = 0; i < 10; i++ )
        checke( string1d[i],  i + '0' );

    checke( string1d[i], '\0' );




/*  Scenario 5: Verify that the function works correctly when string1 is
                NULL.

*/

    retvalue = 0;
    count = LEN5 + 1;

    retvalue = strxfrm( string1e, string2e, count );

    checke( retvalue, LEN5 );

    for (i = 0; i <= LEN5; i++ )
        checke( string1e[i],  string2e[i] );




/*  Scenario 6: Verify that the function works correctly when string2 is
                NULL.

*/

    retvalue = 0;
    count = LEN6 + 1;

    retvalue = strxfrm( string1f, string2f, count );

    checke( retvalue, LEN6 );

    checke( string1f[0], '\0' );




/*  Scenario 7: Verify that the function works correctly when both string1
                and string2 are NULL.

*/

    retvalue = 0;
    count = LEN7 + 1;

    retvalue = strxfrm( string1g, string2g, count );

    checke( retvalue, LEN7 );

    checke( string1g[0], '\0' );




    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strupr1.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strupr1.c
                     strupr1
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the _strupr() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 19-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;

static char string1[30] = "this string is all same case\0";
static char string2[30] = "THIS STRING IS ALL SAME CASE\0";

int strupr1Entry(){
    char *p, c[2], x[2], z;
    int i;


    startest();



/*  Scenario 1: Verify that the function returns a pointer to the
                converted string.
*/

    p = _strupr( string1 );
    checke( p, string1 );

    for (i = 0; i < sizeof( string1 ); i++)
        checke( string1[i], string2[i] );





/*  Scenario 2: Loop through all the lowercase letters and verify
                that they get converted to uppercase.
*/

    c[1] = x[1] = '\0';          /*  NULL terminate the strings  */


    for (i = 'a', x[0] = 'A'; i <= 'z'; i++, x[0]++)
    {
        c[0] = i;
        _strupr( c );
        checke( c[0], x[0] );
    }




/*  Scenario 3: Loop through the remainder of the ASCII characters
                and verify that the characters remain unchanged.
*/

    for (i = 0X00; i <= 0X60; i++)
    {
        c[0] = z = i;
        _strupr( c );
        checke( c[0], z );
    }


    for (i = 0X7B; i <= 0X7F; i++)
    {
        c[0] = z = i;
        _strupr( c );
        checke( c[0], z );
    }




    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strxfrm2.c ===
/***************************************************************************

         Copyright (C) Microsoft Corp. 1993


Test:   strxfrm

Abstract:   Vefifies that strxfrm is effected by a change in the locale,
            and handles chars >127.

===========================================================================
Syntax

===========================================================================
Priority:               1
Products:               WIN NT


Revision History:

    Date        emailname       description
----------------------------------------------------------------------------
    11-03-93    lhanson         created
----------------------------------------------------------------------------

EndHeader:

****************************************************************************/

#include <string.h>
#include <locale.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;

#define MAX_LEN     32

int strxfrm2Entry(){
    unsigned char sz1[MAX_LEN] = "Ab";
    unsigned char sz2[MAX_LEN] = { (unsigned char)'A', 
                            (unsigned char)0x85,  // lower a grave
                            (unsigned char)'\0' };
    unsigned char szNew1[MAX_LEN],
                  szNew2[MAX_LEN];

    startest();

    checkne(setlocale( LC_ALL, "French_France.OCP" ), NULL);
    check(strxfrm(szNew1, sz1, MAX_LEN) == (size_t)-1);
    check(strxfrm(szNew2, sz2, MAX_LEN) == (size_t)-1);

    check(strcmp(szNew1, szNew2) <= 0);

    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\strupr2.c ===
/****************************************************************************
              Copyright (C) 1992, Microsoft Corporation
Method:              cl strupr2.c
                     strupr2
Switches:            NONE
Hard/Soft Needs:
Abstract:            This test verifies the _strupr() function.
OS Version:          REAL/PROT/ALL
CPU:                 8086
Dependencies:        NONE
Environment Vars:    NONE
Verification Method: COMPILE/EXECUTE/COMPARE
Notes:               must include STRING.H
                     Tests described in the testplan STRING.DOC
Products:            C800
Test Type:       DEPTH

Revision History:
 Date              emailname      description
---------------------------------------------------------------------------
 [ 0] 19-May-92    edv            created

---------------------------------------------------------------------------
EndHeader:
*****************************************************************************/

#include <string.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;

static char string1[70] = { "abc def ghi jkl mno pqr stu vwx yza bcd efg hij "
                     "klm nop qrs tuv wxy z\0"
                   };

static char baseln1[70] = { "ABC DEF GHI JKL MNO PQR STU VWX YZA BCD EFG HIJ "
                     "KLM NOP QRS TUV WXY Z\0"
                   };


static char string2[100] = { "1a2b3c4d5e6f7g8h9i0j!k@l#m$n%o^p&q*r(s)t_u+v-w=x :"
                      "; [y]z1234567890abcdefghijklmnopqrstuvwxyz<><>?/'\0"
                    };

static char baseln2[100] = { "1A2B3C4D5E6F7G8H9I0J!K@L#M$N%O^P&Q*R(S)T_U+V-W=X :"
                      "; [Y]Z1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ<><>?/'\0"
                    };

static char string3[200] = { "ABC DEF GHI JKL MNO PQR STU VWX YZA BCD EFG HIJ kl"
                      "; [Y]Z1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ<><>?/'x"
                      "1a2b3c4d5e6f7g8h9i0j!k@l#m$n%o^p&q*r(s)t_u+v-w=x :"
                      "; [y]z1234567890abcdefghijklmnopqrstuvwxyz<><>?/'\0"
                    };

static char baseln3[200] = { "ABC DEF GHI JKL MNO PQR STU VWX YZA BCD EFG HIJ KL"
                      "; [Y]Z1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ<><>?/'X"
                      "1A2B3C4D5E6F7G8H9I0J!K@L#M$N%O^P&Q*R(S)T_U+V-W=X :"
                      "; [Y]Z1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ<><>?/'\0"
                    };


int strupr2Entry(){
    char *p;
    int i;


    startest();



/*  Scenario 4: Verify that the function works correctly with
                larger strings.
*/

    p = _strupr( string1 );
    checke( p, string1 );

    for (i = 0; i < sizeof( string1 ); i++)
        checke( string1[i], baseln1[i] );




    p = _strupr( string2 );
    checke( p, string2 );

    for (i = 0; i < sizeof( string2 ); i++)
        checke( string2[i], baseln2[i] );




    p = _strupr( string3 );
    checke( p, string3 );

    for (i = 0; i < sizeof( string3 ); i++)
        checke( string3[i], baseln3[i] );





    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\tstrncat.c ===
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "test.h"

#define FOREVER     while(1)

#ifdef QA_SIMPLE_QALIB
#define OUTER_ITERATIONS 10
#define MAX_STRING_LENGTH 1000
#else 
#define OUTER_ITERATIONS 200
#define MAX_STRING_LENGTH 10000
#endif


static char mainbuf[10004];
static char chkbuf[10004];
static char catbuf[120];

static char test[] = __FILE__;
static int perfect;

int tstrncatEntry(void){
        int i, j, l, m, n;
        int testiter;

        char *p, *q, *r;

        startest();

        printf("start of strncat test\n");

        for ( testiter = 0 ; testiter < OUTER_ITERATIONS ; testiter++ ) {

            // Initialize mainbuf and chkbuf

            for ( i = 0 ; i < 10000 ; i++ ) mainbuf[i] = chkbuf[i] = 0;

            p = mainbuf + (rand() % 4);
            q = catbuf + (rand() % 4);
            r = chkbuf + (p - mainbuf);

            FOREVER {

                l = rand() % 100;
                m = rand() % 100;

                n = min(l, m);

                if ( strlen(p) + n + 1 > MAX_STRING_LENGTH )
                    break;

                // build a random string of strlen == l

                for ( j = 0 ; j < l ; j++ )
                    if ( (q[j] = rand()) == 0 )
                        j--;
                q[l] = 0;

                // strncat the random string onto the big main string

                strncat(p, q, m);

                // update the big check string the hardway

                for ( j = 0 ; j < n ; j++ )
                    *(r++) = q[j];
                *r = 0;

            }

            if ( memcmp(mainbuf, chkbuf, 10000) == 0 )
              ;
//!                printf("%d-th iteration of test succeeded!\n", testiter);
            else {
//!                printf("%d-th iteration of test failed!\n", testiter);
                fail(testiter);
                break;
            }
        }

        printf("end of strncat test\n");
        finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\_stricol.c ===
/***************************************************************************

         Copyright (C) Microsoft Corp. 1993


Test:   _stricol

Abstract:   Vefifies that _stricoll is effected by a change in the locale,
            and handles chars >127.

===========================================================================
Syntax

===========================================================================
Priority:               1
Products:               WIN NT


Revision History:

    Date        emailname       description
----------------------------------------------------------------------------
    11-03-93    lhanson         created
    11-22-94    a-timke         Modified for NT3.5 results.
    11-07-2000  a-antra         Modified to match characters with locales.
----------------------------------------------------------------------------

EndHeader:

****************************************************************************/

#include <string.h>
#include <locale.h>
#include <test.h>

static char test[] = __FILE__;
static int perfect;


int _stricolEntry(){
//    unsigned char *psz1 = "AaBbC\x8A\x8B\xC0\xCF\xD0Zz";
//    unsigned char *psz2 = "aabbc\x9A\x8B\xE0\xEF\xF0zz";

    unsigned char *psz1 = "AaBbC\x82\x8B\xEC\x8C\xA3Zz";
    unsigned char *psz2 = "aabbc\x90\x8B\xED\xD7\xE9zz";

    startest();

    checkne(_stricoll(psz1, psz2), 0);

    checkne(setlocale( LC_ALL, "French_France.OCP" ), NULL);
#if defined(TEST_WIN95)  /*prior to NLS work of 2/97. */
    checke(_stricoll(psz1, psz2), 0);
    checke(_stricoll(psz2, psz1), 0);
#else
    checke(_stricoll(psz1, psz2), 0);
    checke(_stricoll(psz2, psz1), 0);
#endif
    finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\tstrncpy.c ===
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "test.h"

#define FOREVER     while(1)

//This test takes too much time on simulated platforms: do only 10 iterations there
#ifdef QA_SIMPLE_QALIB
#define OUTER_ITERATIONS 10
#else
#define OUTER_ITERATIONS 200
#endif

static char mainbuf[10004];
static char chkbuf[10004];
static char cpybuf[120];

static char test[] = __FILE__;
static int perfect;

int tstrncpyEntry(void){
        int i, j, l, m;
        int testiter;

        char *p, *q, *r;

        startest();

        printf("start of strncpy test\n");

        for ( testiter = 0 ; testiter < OUTER_ITERATIONS ; testiter++ ) {

            // Initialize mainbuf and chkbuf

            for ( i = 0 ; i < 10000 ; i++ ) mainbuf[i] = chkbuf[i] = 0;

            p = mainbuf;
            q = cpybuf + (rand() % 4);
            r = chkbuf;

            FOREVER {
              
                l = rand() % 100;
                m = rand() % 100;
               
                if ( p + m > mainbuf + 10000 )
                    break;

                // build a random string of strlen == l

                for ( j = 0 ; j < l ; j++ ) 
                    if ( (q[j] = rand()) == 0 )
                        j--;
                q[l] = 0;

                // strncat the random string onto the big main string

                strncpy(p, q, m);

                p += m;

                // update the big check string the hardway

                for ( j = 0 ; j < m ; j++ )
                    if ( j < l )
                        *(r++) = q[j];
                    else
                        *(r++) = 0;

            }

            if ( memcmp(mainbuf, chkbuf, 10000) != 0 ) {
                printf("%d-th iteration of test failed!\n", testiter);
                fail(testiter);
                break;
            }
        }

        printf("end of strncpy test\n");
        finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\time\CRunTime.cpp ===
#include <xtl.h>
#include <stdio.h>
#include <tchar.h>
#include <time.h>
//#include <afx.h>
#include "CRunTime.h"
#include "testcrt.h"
#ifndef _WIN32
#include <dos.h>
#endif
/*
BOOL isDST(CTime cTime) {
	BOOL bRetVal = FALSE;
	if ((cTime.GetMonth() == 4) && (cTime.GetDay() > cTime.GetDayOfWeek())) {
		bRetVal = TRUE;
	}
	else if ((cTime.GetMonth() > 4) && (cTime.GetMonth() < 10)) {
		bRetVal = TRUE;
	}
	else if (cTime.GetMonth() == 10 ) {
		if ((31-cTime.GetDay()) < 7) {
			if ((7 - (31-cTime.GetDay())) >= cTime.GetDayOfWeek()) {
				bRetVal = FALSE;
			}
			else bRetVal = TRUE;
			}
		else bRetVal = TRUE;
	}
	return bRetVal;
}
*/

#ifndef _WIN32
void Sleep (clock_t wait) {
	clock_t goal;
	goal = wait + clock();
	while (goal > clock());
}
#endif


BOOL CheckDatesDOSTm(struct tm *ptmTime, DTMINFO tDates) {
	BOOL bRetVal;
	bRetVal =           compare(_T("Year     "), ptmTime->tm_year + 1900, tDates.nYear);
	bRetVal = bRetVal | compare(_T("Month    "), ptmTime->tm_mon + 1    , tDates.nMonth);
	bRetVal = bRetVal | compare(_T("Day      "), ptmTime->tm_mday       , tDates.nDay);
	bRetVal = bRetVal | compare(_T("DayOfWeek"), ptmTime->tm_wday + 1   , tDates.nDayOfWeek);
	bRetVal = bRetVal | compare(_T("Hour     "), ptmTime->tm_hour       , tDates.nHour);
	bRetVal = bRetVal | compare(_T("Minute   "), ptmTime->tm_min        , tDates.nMinute);
	bRetVal = bRetVal | compare(_T("Second   "), ptmTime->tm_sec        , tDates.nSecond);

	return bRetVal;
}

#ifndef _WIN32 
BOOL CheckDatesDOSSYS(_dosdate_t sysDate, DTMINFO tDates) {
	BOOL bRetVal;
	bRetVal =           compare(_T("Year     "), sysDate.year         , tDates.nYear);
	bRetVal = bRetVal | compare(_T("Month    "), sysDate.month        , tDates.nMonth);
	bRetVal = bRetVal | compare(_T("Day      "), sysDate.day          , tDates.nDay);
	bRetVal = bRetVal | compare(_T("DayOfWeek"), sysDate.dayofweek + 1, tDates.nDayOfWeek);
	return bRetVal;
}

#else
BOOL CheckDatesSYS(SYSTEMTIME sysDate,  DTMINFO tDates) {
	BOOL bRetVal;
	bRetVal =           compare(_T("Year     "), sysDate.wYear         , tDates.nYear);
	bRetVal = bRetVal | compare(_T("Month    "), sysDate.wMonth        , tDates.nMonth);
	bRetVal = bRetVal | compare(_T("Day      "), sysDate.wDay          , tDates.nDay);
	bRetVal = bRetVal | compare(_T("DayOfWeek"), sysDate.wDayOfWeek + 1, tDates.nDayOfWeek);
	return bRetVal;
}

BOOL CheckDatesSYS2(SYSTEMTIME sysDate,  DTMINFO tDates) {
	BOOL bRetVal;
	bRetVal =           compare(_T("Year     "), sysDate.wYear         , tDates.nYear);
	bRetVal = bRetVal | compare(_T("Month    "), sysDate.wMonth        , tDates.nMonth);
	bRetVal = bRetVal | compare(_T("Day      "), sysDate.wDay          , tDates.nDay);
	bRetVal = bRetVal | compare(_T("DayOfWeek"), sysDate.wDayOfWeek + 1, tDates.nDayOfWeek);
	bRetVal = bRetVal | compare(_T("Hour     "), sysDate.wHour         , tDates.nHour);
	bRetVal = bRetVal | compare(_T("Minute   "), sysDate.wMinute       , tDates.nMinute);
	bRetVal = bRetVal | compare(_T("Second   "), sysDate.wSecond       , tDates.nSecond);
	return bRetVal;
}

#endif

BOOL TestCRunTime() {
	BOOL bRetVal;
	BOOL bResult;
//	CString sOut(' ', 128);

	struct tm tmTime;
	struct tm *ptmTime2;
	time_t tTime;
#ifndef _WIN32
	struct _dosdate_t sysDate;
	struct _dostime_t sysTime;
	struct _dosdate_t sysDate2;
	struct _dostime_t sysTime2;
#else	
	SYSTEMTIME sysDate;
	SYSTEMTIME sysDate2;
	FILETIME fileTime;
	FILETIME fileTime2;
#endif
	int x;

	bRetVal = FALSE;
#ifndef _WIN32
//	sOut = "Checking CRunTime: _dos_setdate(_dosdate_t &sysDate);\n";
	fputs ("Checking CRunTime: _dos_setdate(_dosdate_t &sysDate);\n", f1);
//	f1.WriteString(sOut);
//	sOut = "                   _dos_settime(_dostime_t &sysTime);\n";
	fputs ("                   _dos_settime(_dostime_t &sysTime);\n", f1);
#else
//	sOut = "Checking CRunTime: SetSystemTime(SYSTEMTIME &sysTime);\n";
	fputs ("Checking CRunTime: SetSystemTime(SYSTEMTIME &sysTime);\n", f1);
#endif
//	f1.WriteString(sOut);
	for (x = 0; tDates[x].nYear != 0;x++) {
		if (((tDates[x].nMonth == 2) && (tDates[x].nDay == 28) ) || ((tDates[x].nMonth == 12) && (tDates[x].nDay == 31))) {

#ifndef _WIN32
			sysDate2.year = tDates[x].nYear;
			sysDate2.month = tDates[x].nMonth;
			sysDate2.day = tDates[x].nDay;
			sysDate2.dayofweek = tDates[x].nDayOfWeek - 1;
			sysTime2.hour = 23;
			sysTime2.minute = 59;
			sysTime2.second = 59;
			sysTime2.hsecond = 0;
			_dos_getdate(&sysDate);
			_dos_gettime(&sysTime);
			bResult = _dos_setdate(&sysDate2);
			bResult = _dos_settime(&sysTime2);
			Sleep(2000);
			_dos_getdate(&sysDate2);
			_dos_gettime(&sysTime2);
			bResult = _dos_setdate(&sysDate);
			bResult = _dos_settime(&sysTime);
			bRetVal = bRetVal | CheckDatesDOSSYS(sysDate2,tDates[x + 1]);
#else
			sysDate2.wYear = tDates[x].nYear;
			sysDate2.wMonth = tDates[x].nMonth;
			sysDate2.wDay = tDates[x].nDay;
			sysDate2.wDayOfWeek = tDates[x].nDayOfWeek - 1;
			sysDate2.wHour = 23;
			sysDate2.wMinute = 59;
			sysDate2.wSecond = 59;
			sysDate2.wMilliseconds = 0;
			GetSystemTime(&sysDate);
            // xbox does not have SetSystemTime()
			// bResult = SetSystemTime(&sysDate2);
			Sleep(2000);
			GetSystemTime(&sysDate2);
            // xbox does not have SetSystemTime()
			// bResult = SetSystemTime(&sysDate);
			bRetVal = bRetVal | CheckDatesSYS(sysDate2,tDates[x + 1]);
#endif		
		}
	}
	PrintPassFail(bRetVal);

	bRetVal = FALSE;
////#ifndef _WIN32
//	sOut = "Checking CRunTime: mktime(struct tm *tmTime);\n";
	fputs ("Checking CRunTime: mktime(struct tm *tmTime);\n", f1);
//	f1.WriteString(sOut);
//	sOut = "                   localtime(time_t *timer);\n";
	fputs ("                   localtime(time_t *timer);\n", f1);
////#else	
//	sOut = "Checking CRunTime: SystemTimeToFileTime(SYSTEMTIME *sysTime, FILETIME *fileTime);\n";
	fputs ("Checking CRunTime: SystemTimeToFileTime(SYSTEMTIME *sysTime, FILETIME *fileTime);\n", f1);
//	f1.WriteString(sOut);
//	sOut = "                   SystemTimeToFileTime(FILETIME *fileTime, SYSTEMTIME &sysTime);\n";
	fputs ("                   SystemTimeToFileTime(FILETIME *fileTime, SYSTEMTIME &sysTime);\n", f1);
////#endif
//	f1.WriteString(sOut);
	for (x = 0; tDates[x].nYear != 0;x++) {

////#ifndef _WIN32
		tmTime.tm_year = tDates[x].nYear - 1900;
		tmTime.tm_mon = tDates[x].nMonth - 1;
		tmTime.tm_mday = tDates[x].nDay;
		tmTime.tm_wday = tDates[x].nDayOfWeek - 1;
		tmTime.tm_hour = tDates[x].nHour;
		tmTime.tm_min = tDates[x].nMinute;
		tmTime.tm_sec = tDates[x].nSecond;
		tmTime.tm_isdst = -1;
		tTime = mktime(&tmTime);
		ptmTime2 = localtime(&tTime);		
		bRetVal = bRetVal | CheckDatesDOSTm(ptmTime2,tDates[x]);
////#else
		sysDate.wYear = tDates[x].nYear;
		sysDate.wMonth = tDates[x].nMonth;
		sysDate.wDay = tDates[x].nDay;
		sysDate.wDayOfWeek = tDates[x].nDayOfWeek - 1;
		sysDate.wHour = tDates[x].nHour;
		sysDate.wMinute = tDates[x].nMinute;
		sysDate.wSecond = tDates[x].nSecond;
		sysDate.wMilliseconds = 0;
		bResult = SystemTimeToFileTime(&sysDate, &fileTime);
		bResult = LocalFileTimeToFileTime(&fileTime, &fileTime2);
		bResult = FileTimeToLocalFileTime(&fileTime2, &fileTime);
		bResult = FileTimeToSystemTime(&fileTime, &sysDate2);
		bRetVal = bRetVal | CheckDatesSYS2(sysDate2,tDates[x]);
////#endif		
	}
	PrintPassFail(bRetVal);

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\string\tstrstr2.c ===
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "test.h"

static char searched_string[1024];

static char *basestr = "unbelievable";

static char *fillchar = "Z";

struct srchdata {
        char *  key_string;
        int     success_code;
}; 

struct srchdata scenarios[10] = {
        {"v",            1},    /* 0 */
        {"w",            0},    /* 1 */
        {"un",           1},    /* 2 */
        {"uv",           0},    /* 3 */
        {"unbe",         1},    /* 4 */
        {"unba",         0},    /* 5 */
        {"unbelie",      1},    /* 6 */
        {"unbelix",      0},    /* 7 */
        {"unbelievable", 1},    /* 8 */
        {"unbelievablz", 0}     /* 9 */ };


static char test[] = __FILE__;
static int perfect;

int tstrstr2Entry(void){
        int i, j;

        size_t len;

        char *psrch, *pret;

        startest();

        // build searched_string[] out of copies of basestr, separated by 
        // increasing numbers of fillchar copies.

        searched_string[0] ='\0';

        for ( i = 0 ; i < 10 ; i++ ) {

            strcat(searched_string, basestr);

            for ( j = 0 ; j < i + 1 ; j++ )
                strcat(searched_string, fillchar);
        }

 
        for ( i = 0 ; i < 10 ; i++ ) {
            
            psrch = searched_string;
           
            if ( scenarios[i].success_code == 1 ) {

                // In this case, where strstr() is supposed to succeed, we run five
                // searches, each starting just after the substring located by the 
                // the last.

                len = strlen(scenarios[i].key_string);

                for ( j = 0 ; j < 5 ; j++ )
                    if ( ((pret = strstr(psrch, scenarios[i].key_string)) != NULL) &&
                         (strncmp(pret, scenarios[i].key_string, len) == 0) )
                    {
                        if ( j == 4 ) 
                            printf("test %d passed\n", i);
                        else
                            psrch = pret + len;
                    }
                    else {
                        printf("test %d failed (%d-th iteration)\n", i, j);
                        fail(i);
                        break;
                    }
            }
            else {

                // In this test, strstr() is supposed to fail.

                if ( strstr(scenarios[i].key_string, psrch) == NULL )
                    printf("test %d passed\n", i);
                else
                    fail(i+100);
            }

        }
        finish();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\time\CRunTime.h ===
//#include <afx.h>

BOOL TestCRunTime();
//extern CStdioFile f1;
extern FILE * f1;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\time\drv.cpp ===
#include <xtl.h>

int gmtime1Entry();
int localtime1Entry();
int mktime1Entry();
int mktime2Entry();
//int mktime3Entry();
int futime1Entry();
int futime2Entry();
int utime1Entry();
int utime2Entry();
int ftime1Entry();
int time1Entry();
int ctime1Entry();
//int strftime1Entry();
int testcrtEntry();


#ifdef __cplusplus
extern "C"
#endif
void __cdecl timeStartTest()
{
	gmtime1Entry();
	localtime1Entry();
	mktime1Entry();
	mktime2Entry();
	//mktime3Entry();
	futime1Entry();
	futime2Entry();
	utime1Entry();
	utime2Entry();
	ftime1Entry();
	time1Entry();
	ctime1Entry();
	//strftime1Entry();
	testcrtEntry();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\time\ctime1.cpp ===
#define QaLib ctime1NameSpace

#include <stdio.h>
#include <time.h>
#include <string.h>

#define QA_NTHREADS 1
#include "qalibrary.h"

/*@ ctime

ctime(), wctime(), _ctime64(), _wctime64().

Will need to set the system time for boundary and Y2K testing.

Test Cases:
------------
 1. date < 1/1/1970.
 2. string size == 25.
 3. that 24hr clock is used.
 4. all fields have the following format: (3s3s2s2:2:2s4\n\0).
 5. time is adjusted to local time zone.
 6. use of static buffer does not fail when threads are used.
 7. shared access to static buffer with asctime, localtime, and gmtime 
    acts as expected (overwrites but is thread safe).
    
General time related TCs: 
 8. YK2 issue:
    8a. 2000
    8b. 2001
    ?? others ??
 9. boundary:
    9a. 2038 (32bit)
    9b. 2039 (32bit) - fail.
    9c. 2999 (64bit)
    9d. 3000 (64bit) - fail.
10. "edge" conditions:
    10a. 2100, 2200, 2300, 2500 is NOT a leap year.
    10b. 2000 (32bit also), 2400, 2800 is a leap year.
    
@*/


// globals.
//
// leave room so strlen won't crash if greater than 26.
#define BUFF_SIZE           128 
#define NUM_MONTHS          12
#define NUM_DAYS            7
#define OFFSET_YR           1994
#define INITIAL_TEST_TIME   757411200
#define EXPECTED_SIZE       25

_TCHAR *short_months[12]= 
{
    _T("Jan"),
    _T("Feb"),
    _T("Mar"),
    _T("Apr"),
    _T("May"),
    _T("Jun"),
    _T("Jul"),
    _T("Aug"),
    _T("Sep"),
    _T("Oct"),
    _T("Nov"),
    _T("Dec")
};

_TCHAR *short_days[7] = 
{
    _T("Sat"),
    _T("Sun"),
    _T("Mon"),
    _T("Tue"),
    _T("Wed"),
    _T("Thu"),
    _T("Fri")
};

bool    VerifyFormat(const _TCHAR* s)
{
    _TCHAR  szDOW[4];
    _TCHAR  szMon[4];
    _TCHAR  szDay[3];
    _TCHAR  szHour[3];
    _TCHAR  szMin[3];
    _TCHAR  szSec[3];
    _TCHAR  szYear[5];
    bool    ok = false;
    bool    retval = true;

    if (!QACheckE(_tcslen(s), (size_t)EXPECTED_SIZE))
        return false;

    _stscanf(s, _T("%3s %3s %2s %2s:%2s:%2s %4s"), 
             szDOW, szMon, szDay, szHour, szMin, szSec, szYear);

    // check day of week
    //
    for (int i = 0; i < 7; i++)
        if (_tcscmp(szDOW, short_days[i]) == 0)
        {
            ok = true;
            break;
        }
    if (!QACheck(ok))
        QALog << _T("Day of week incorrect. \"") << szDOW 
              << _T("\" not found. index = ") << i << QAEndl;
    retval &= ok;
    ok = false;

    // check month
    //
    for (i = 0; i < 12; i++)
        if (_tcscmp(szMon, short_months[i]) == 0)
        {
            ok = true;
            break;
        }
    if (!QACheck(ok))
        QALog << _T("Month incorrect. \"") << szMon
              << _T("\" not found. index = ") << i << QAEndl;
    retval &= ok;
    ok = false;

    // check day
    //
    retval &= QACheckE(_tcslen(szDay), (size_t)2);
    retval &= QACheck(_ttoi(szDay) >= 0 && _ttoi(szDay) <= 31);

    // check hour
    //
    retval &= QACheckE(_tcslen(szHour), (size_t)2);
    retval &= QACheck(_ttoi(szHour) >= 0 && _ttoi(szHour) <= 24);

    // check minute
    //
    retval &= QACheckE(_tcslen(szMin), (size_t)2);
    retval &= QACheck(_ttoi(szMin) >= 0 && _ttoi(szMin) <= 60);

    // check seconds
    //
    retval &= QACheckE(_tcslen(szSec), (size_t)2);
    retval &= QACheck(_ttoi(szSec) >= 0 && _ttoi(szSec) <= 60);

    // check year
    //
    retval &= QACheckE(_tcslen(szYear), (size_t)4);
    retval &= QACheck(_ttoi(szYear) >= 1970 && _ttoi(szYear) <= 2999);

    return retval;
}

// Helper test functions.  These are template functions to test both 32bit
// and 64bit.
//
template <class TT, class TF> bool TC1(TF tf, TT tt = 0)
{
    _TCHAR  buff[ BUFF_SIZE ];
    int     number;
    TT      test_time = INITIAL_TEST_TIME;
    bool    ret = true;

    for (int loop1 = 0; loop1 <= 20; loop1++)
    {
        QATTrace2(_T("loop count: "), loop1);
        // Decimal year
        _tcsncpy(buff, tf(&test_time), BUFF_SIZE);
        _stscanf(buff, _T("%*s%*s%*s%*s%d"), &number);
            
        ret &= QACheckE(number, (OFFSET_YR + loop1));
        ret &= QACheck(VerifyFormat(buff));

        test_time += 31622400;
    }

    return ret;
}

template <class TT, class TF> bool TC2(TF tf, TT tt = 0)
{
    _TCHAR  buff[ BUFF_SIZE ];
    _TCHAR  string[20];
    TT      test_time = INITIAL_TEST_TIME;
    bool    ret = true;

    // Test months
    //
    for (int loop1 = 0; loop1 < NUM_MONTHS; loop1++)
    {
        _tcsncpy( buff, tf(&test_time), BUFF_SIZE);
        _stscanf( buff, _T("%*s%s"), string);

        ret &= QACheckE(_tcslen(buff), (size_t)25);
        ret &= QACheckE(string, short_months[loop1]);

        test_time += 2707200;
    }

    return ret;
}

template <class TT, class TF> bool TC3(TF tf, TT tt = 0)
{
    _TCHAR  buff[ BUFF_SIZE ];
    _TCHAR  string[20];
    TT      test_time = INITIAL_TEST_TIME;
    bool    ret = true;

    /* Test days */

    for ( int loop1 = 0; loop1 < NUM_DAYS; loop1++ )
    {

        /* Day as an abbreviation */

        _tcsncpy( buff, tf( &test_time ), BUFF_SIZE );
        _stscanf( buff, _T("%s"), string );

        ret &= QACheckE(_tcslen(buff), (size_t)25);
        ret &= QACheckE(string, short_days[loop1]);

        test_time += 86400;
    }

    return ret;
}

template <class TT, class TF> bool TC4(TF tf, TT tt = 0)
{
    _TCHAR  buff[ BUFF_SIZE ];
    _TCHAR  string[20];
    int     number;
    TT      test_time = INITIAL_TEST_TIME;
    bool    ret = true;

    /* Hour */

    for ( int loop1 = 0; loop1 < 24; loop1++ )
    {
        _tcsncpy( buff, tf ( &test_time ), BUFF_SIZE );
        _stscanf( buff, _T("%[^:]"), string );
        _stscanf( string, _T("%*s%*s%*s%d"), &number );

        ret &= QACheckE(_tcslen(buff), (size_t)25);
        ret &= QACheckE(number, loop1);

        test_time += 3600;
    }

    return ret;
}

template <class TT, class TF> bool TC5(TF tf, TT tt = 0)
{
    _TCHAR  buff[ BUFF_SIZE ];
    _TCHAR  string[20];
    int     number;
    TT      test_time = INITIAL_TEST_TIME;
    bool    ret = true;

    for (int loop1 = 0; loop1 < 60; loop1++)
    {

        _tcsncpy( buff, tf( &test_time ), BUFF_SIZE );
        _stscanf ( buff, _T("%*s%*s%*s%s"), string );
        _stscanf ( string, _T("%*d:%d:%*d"), &number );

        ret &= QACheckE(_tcslen(buff), (size_t)25);
        ret &= QACheckE(number, loop1);

        test_time += 60;
    }

    return ret;
}

template <class TT, class TF> bool TC6(TF tf, TT tt = 0)
{
    _TCHAR  buff[ BUFF_SIZE ];
    _TCHAR  string[20];
    int     number;
    TT      test_time = INITIAL_TEST_TIME;
    bool    ret = true;

    for (int loop1 = 0; loop1 < 60; loop1++)
    {

        _tcsncpy( buff, tf( &test_time ), BUFF_SIZE );
        _stscanf( buff, _T("%*s%*s%*s%s"), string );
        _stscanf( string, _T("%*d:%*d:%d"), &number );

        ret &= QACheckE(_tcslen(buff), (size_t)25);
        ret &= QACheckE(number, loop1);

        test_time++;

    }

    return ret;
}

template <class TT, class TF> bool TC7(TF tf, TT tt = 0)
{
    TT      test_time = (TT)-1;
    return QACheck(tf(&test_time) == NULL);
}

template <class TT, class TF> bool TC8(TF tf, TT tt = 0)
{
    _TCHAR* pchResult;
    TT      nTime = 0x2e19bd9c;
    bool    retval = true;
    
    _tzset();
    pchResult = tf(&nTime);
    retval &= QACheck(pchResult != NULL);
    retval &= QACheckE(pchResult, _T("Tue Jul 05 13:07:56 1994\n"));
    return retval;
}

////////////////////////////////////////////////////////////////////////////////
// <function name> 
//  <description of what the function does>
//
static unsigned __stdcall ctime1CTime1(void* qaThreadParam = 0)
{
    // Test Year.
    //
    QA_BEGIN_TC(1)

        QATCheck(TC1<time_t>(_tctime));

#if (_MSC_VER > 1200)
        QATCheck(TC1<__time64_t>(_tctime64));
#endif /* (_MSC_VER > 1200) */

    QA_END_TC(1)
    return 0;
}

////////////////////////////////////////////////////////////////////////////////
// <function name> 
//  <description of what the function does>
//
static unsigned __stdcall ctime1CTime2(void* qaThreadParam = 0)
{
    // Test Month.
    //
    QA_BEGIN_TC(2)
    
        QATCheck(TC2<time_t>(_tctime));

#if (_MSC_VER > 1200)
        QATCheck(TC2<__time64_t>(_tctime64));
#endif /* (_MSC_VER > 1200) */

    QA_END_TC(2)
    return 0;
}

////////////////////////////////////////////////////////////////////////////////
// <function name> 
//  <description of what the function does>
//
static unsigned __stdcall ctime1CTime3(void* qaThreadParam = 0)
{
    QA_BEGIN_TC(3)
    
        QATCheck(TC3<time_t>(_tctime));

#if (_MSC_VER > 1200)
	QATCheck(TC3<__time64_t>(_tctime64));
#endif /* (_MSC_VER > 1200) */

    QA_END_TC(3)
    return 0;
}

////////////////////////////////////////////////////////////////////////////////
// <function name> 
//  <description of what the function does>
//
static unsigned __stdcall ctime1CTime4(void* qaThreadParam = 0)
{
    QA_BEGIN_TC(4)

        QATCheck(TC4<time_t>(_tctime));
	
#if (_MSC_VER > 1200)
        QATCheck(TC4<__time64_t>(_tctime64));
#endif /* (_MSC_VER > 1200) */
    
    QA_END_TC(4)
    return 0;
}

////////////////////////////////////////////////////////////////////////////////
// <function name> 
//  <description of what the function does>
//
static unsigned __stdcall ctime1CTime5(void* qaThreadParam = 0)
{
    QA_BEGIN_TC(5)
    
        QATCheck(TC5<time_t>(_tctime));
	
#if (_MSC_VER > 1200)
        QATCheck(TC5<__time64_t>(_tctime64));
#endif /* (_MSC_VER > 1200) */
    
    QA_END_TC(5)
    return 0;
}

////////////////////////////////////////////////////////////////////////////////
// <function name> 
//  <description of what the function does>
//
static unsigned __stdcall ctime1CTime6(void* qaThreadParam = 0)
{
    QA_BEGIN_TC(6)
    
        QATCheck(TC6<time_t>(_tctime));
	
#if (_MSC_VER > 1200)
        QATCheck(TC6<__time64_t>(_tctime64));
#endif /* (_MSC_VER > 1200) */
    
    QA_END_TC(6)
    return 0;
}

////////////////////////////////////////////////////////////////////////////////
// <function name> 
//  <description of what the function does>
//
static unsigned __stdcall ctime1CTime7(void* qaThreadParam = 0)
{
    QA_BEGIN_TC(7)
    
        QATCheck(TC7<time_t>(_tctime));
	
#if (_MSC_VER > 1200)
        QATCheck(TC7<__time64_t>(_tctime64));
#endif /* (_MSC_VER > 1200) */
    
    QA_END_TC(7)
    return 0;
}

////////////////////////////////////////////////////////////////////////////////
// <function name> 
//  <description of what the function does>
//
static unsigned __stdcall ctime1CTime8(void* qaThreadParam = 0)
{
    QA_BEGIN_TC(8)
    
        QATCheck(TC8<time_t>(_tctime));
	
#if (_MSC_VER > 1200)
        QATCheck(TC8<__time64_t>(_tctime64));
#endif /* (_MSC_VER > 1200) */
    
    QA_END_TC(8)
    return 0;
}

TestFunc ctime1TestFuncList[] =
{
    ctime1CTime1,
    ctime1CTime2,
    ctime1CTime3,
    ctime1CTime4,
    ctime1CTime5,
    ctime1CTime6,
    ctime1CTime7,
    ctime1CTime8
};

int ctime1Entry()
{
    int nTests = (sizeof(ctime1TestFuncList)/sizeof(ctime1TestFuncList[0]));
    int iTest = 0;
    bool bRunTerm = false;

    if (ctime1TestFuncList[0] == 0)
    {
        if (nTests == 1) return 3; /* error, not enough data */
        /* if the 0th element is zero, then 1st element is a */
        /* thread kickoff function */
        iTest = 2;
        if (ctime1TestFuncList[1] != 0)
            ctime1TestFuncList[1](0);
    }

    if (nTests >= 4)
    {
        if (ctime1TestFuncList[2] == 0)
        {
            bRunTerm = true;
            iTest = 4;
        }
    }

    for (; iTest < nTests; iTest++)
        if(ctime1TestFuncList[iTest] != 0)
            ctime1TestFuncList[iTest](0);
    if (bRunTerm)
    {
        if (!ctime1TestFuncList[3])
            DbgPrint("Term function NULL!\n");
        else
            ctime1TestFuncList[3](0);
    }
    int ret = GetTestFailure() ? 1 : 0;
    ReportTest(false);
    ClearFailures();
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\time\ftime1.cpp ===
#define QaLib ftime1NameSpace

#include <time.h>
#include <sys\timeb.h>

#undef QA_USE_THREADS   // due to use of putenv() threads can't be used.
#include "qalibrary.h"

/*@ ftime

Test Cases:
------------
  1-3. set timezone and call function.  make simple checks for correctness.
  
@*/

#define Y1993 725328000L  /* approx. number of seconds between 1970 & 1993 */
#define Y1994 756864000L  /* approx. number of seconds between 1970 & 1994 */
#define Y1995 788400000L  /* approx. number of seconds between 1970 & 1995 */
#define Y1997 851472000L  /* approx. number of seconds between 1970 & 1997 */
#define Y1999 914544000L
#define Y2036 2081376000L
#define Y2037 2145904712L   /* actual number of seconds between 1970 & 12/31/2037 - 12:35 p.m. */

#define YMIN  Y1994       /* Range (in seconds) for time tests */
#define YMAX  Y2037

_TCHAR *envstr[] = 
{  
    _T("TZ=PST8PDT"),   /* Pacific Standard Time */
    _T("TZ=MST7MDT"),   /* Mountain Standard Time */
    _T("TZ=EST5EDT")    /* Eastern Standard Time */
};

int zones[] = { 480, 420, 300 };

template <class TT, class TF> bool TC1(TF timeFunc, QA_THREAD_PARAM)
{
    bool    retVal = true;
    TT      times;

    if (!QATCheck(_tputenv(envstr[0]) == 0))
        return false;

    _tzset();
    timeFunc(&times);
    retVal &= QATCheck(times.time > YMIN);
    retVal &= QATCheck(times.time < YMAX);
    retVal &= QATCheck(times.millitm < 999);
    retVal &= QATCheckE(times.timezone, zones[0]);          

    return retVal;
}

template <class TT, class TF> bool TC2(TF timeFunc, QA_THREAD_PARAM)
{
    bool    retVal = true;
    TT      times;

    if (!QATCheck(_tputenv(envstr[1]) == 0))
        return false;

    _tzset();
    timeFunc(&times);
    retVal &= QATCheck(times.time > YMIN);
    retVal &= QATCheck(times.time < YMAX);
    retVal &= QATCheck(times.millitm < 999);
    retVal &= QATCheckE(times.timezone, zones[1]);          

    return retVal;
}

template <class TT, class TF> bool TC3(TF timeFunc, QA_THREAD_PARAM)
{
    bool    retVal = true;
    TT      times;

    if (!QATCheck(_tputenv(envstr[2]) == 0))
        return false;

    _tzset();
    timeFunc(&times);
    retVal &= QATCheck(times.time > YMIN);
    retVal &= QATCheck(times.time < YMAX);
    retVal &= QATCheck(times.millitm < 999);
    retVal &= QATCheckE(times.timezone, zones[2]);          

    return retVal;
}


static unsigned __stdcall ftime1FTime1(void* qaThreadParam = 0)
{
    QA_BEGIN_TC(1)

        QATTrace1(_T("ftime()"));
        QATCheck(TC1<struct _timeb>(_ftime, QA_THREAD_PARAM_NAME));

#if ( _MSC_VER > 1200)
        QATTrace1(_T("ftime64()"));
        QATCheck(TC1<struct __timeb64>(_ftime64, QA_THREAD_PARAM_NAME));
#endif /* (_MSC_VER > 1200) */

    QA_END_TC(1)
    return 0;
}

static unsigned __stdcall ftime1FTime2(void* qaThreadParam = 0)
{
    QA_BEGIN_TC(2)

        QATTrace1(_T("ftime()"));
        QATCheck(TC2<struct _timeb>(_ftime, QA_THREAD_PARAM_NAME));

#if ( _MSC_VER > 1200)        
		QATTrace1(_T("ftime64()"));
        QATCheck(TC2<struct __timeb64>(_ftime64, QA_THREAD_PARAM_NAME));
#endif /* (_MSC_VER > 1200) */

    QA_END_TC(2)
    return 0;
}

static unsigned __stdcall ftime1FTime3(void* qaThreadParam = 0)
{
    QA_BEGIN_TC(3)

        QATTrace1(_T("ftime()"));
        QATCheck(TC3<struct _timeb>(_ftime, QA_THREAD_PARAM_NAME));
		
#if ( _MSC_VER > 1200)
        QATTrace1(_T("ftime64()"));
        QATCheck(TC3<struct __timeb64>(_ftime64, QA_THREAD_PARAM_NAME));
#endif /* (_MSC_VER > 1200) */

    QA_END_TC(3)
    return 0;
}

TestFunc ftime1TestFuncList[] =
{
    ftime1FTime1,
    ftime1FTime2,
    ftime1FTime3
};


int ftime1Entry()
{
    int nTests = (sizeof(ftime1TestFuncList)/sizeof(ftime1TestFuncList[0]));
    int iTest = 0;
    bool bRunTerm = false;

    if (ftime1TestFuncList[0] == 0)
    {
        if (nTests == 1) return 3; /* error, not enough data */
        /* if the 0th element is zero, then 1st element is a */
        /* thread kickoff function */
        iTest = 2;
        if (ftime1TestFuncList[1] != 0)
            ftime1TestFuncList[1](0);
    }

    if (nTests >= 4)
    {
        if (ftime1TestFuncList[2] == 0)
        {
            bRunTerm = true;
            iTest = 4;
        }
    }

    for (; iTest < nTests; iTest++)
        if(ftime1TestFuncList[iTest] != 0)
            ftime1TestFuncList[iTest](0);
    if (bRunTerm)
    {
        if (!ftime1TestFuncList[3])
            DbgPrint("Term function NULL!\n");
        else
            ftime1TestFuncList[3](0);
    }
    int ret = GetTestFailure() ? 1 : 0;
    ReportTest(false);
    ClearFailures();
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\time\futime2.cpp ===
#define QaLib futime2NameSpace

#include <windows.h>
#include <time.h>
#include <sys\stat.h>
#include <sys\timeb.h>
#include <sys\utime.h>
#include <fcntl.h>
#include <sys\types.h>
#include <io.h>
#include <errno.h>

#define QA_NTHREADS 1
#include "qalibrary.h"

/*@ futime

TestCases:
-----------
  1. Check that futime() on a file opened as read only fails and that errno
     is set to EINVAL. 
  2. Check the futime() on a valid file returns success value and that
     the time values are as expected.
  
@*/

// global variables/macros.
//
#define k_cchFileSystemName 12

const _TCHAR* testfile = _T("futime.tst");
const _TCHAR* testfile2 = _T("futime2.tst");


/////////////////////////
//GetFileSystemType - Determine the file system of the current drive.
//  Returns: 0 if FAT
//           1 if NTFS
//          -1 if unknown
int GetFileSystemType()
{
    DWORD              dwMaximumComponentLength;
    DWORD              dwFileSystemFlags;
    char               szFileSystemNameBuffer[k_cchFileSystemName];
    
    if (GetVolumeInformation(NULL, NULL, 0,
                             NULL, &dwMaximumComponentLength, &dwFileSystemFlags,
                             szFileSystemNameBuffer, k_cchFileSystemName))
    {
        if (strcmp(szFileSystemNameBuffer, "FAT") == 0)
            return 0;
        if (strcmp(szFileSystemNameBuffer, "NTFS") == 0)
            return 1;
    }
    return -1;
}

bool DelFile(const _TCHAR* szFile)
{
  int rv;
  rv = _tchmod(szFile, _S_IREAD|_S_IWRITE);
  if (rv == -1) {
    printf("chmod failed errno %d %s %x\n", errno, strerror(errno), GetLastError());
  };
  
  rv = _tremove(szFile);
  if (rv == -1) {
    printf("remove failed errno %d %s %x\n", errno, strerror(errno), GetLastError());
  };
  return rv==0;
}

// testcases.
//
template <class UTIMBUF, class TF1, class TF2> 
bool TC1(TF1 futimeFunc, TF2 timeFunc, QA_THREAD_PARAM)
{
    bool            retVal = false;
    UTIMBUF         filetime;
    int             fh;

    filetime.actime = filetime.modtime = timeFunc(NULL);

    if (QATCheck((fh = _topen(testfile, _O_CREAT | _O_RDONLY)) != -1))
    {
        retVal = QATCheck(futimeFunc(fh, &filetime) != 0);
        retVal &= QATCheckE(errno, EINVAL);
        _close(fh);
        QATCheck(DelFile(testfile));
    }

    return retVal;
}
template <class UTIMBUF, class STAT,
          class TF1, class TF2, class TF3, class TF4> 
bool TC2(TF1 futimeFunc, TF2 fstatFunc, TF3 timeFunc, TF4 localtimeFunc,
         QA_THREAD_PARAM)
{
    bool            retVal = false;
    STAT            file_stat;
    int             fh;
    UTIMBUF         filetime;
    long            openMode = _O_RDWR | _O_TRUNC | _O_APPEND | _O_TEXT | _O_CREAT;

    if (QATCheck((fh = _topen(testfile2, openMode)) != -1))
    {
        retVal = true;

        filetime.actime = filetime.modtime = timeFunc(NULL);

        if (QATCheck(futimeFunc(fh, &filetime) == 0))
        {
            if (QATCheck(fstatFunc(fh, &file_stat) == 0))
            {
                if (GetFileSystemType() == 0)
                {
                    //FAT - Access times for hr, min, sec are not stored
                    //      for FAT file systems. Just compare year, month,
                    //      and day for the access times.
                    struct tm*      ptmTime;
                    struct tm       tmTimeSave;
                    
                    ptmTime = localtimeFunc(&filetime.actime);
                    memcpy(&tmTimeSave, ptmTime, sizeof(struct tm));
                    ptmTime = localtimeFunc(&file_stat.st_atime);
                    
                    if (tmTimeSave.tm_mday  != ptmTime->tm_mday
                     || tmTimeSave.tm_mon   != ptmTime->tm_mon
                     || tmTimeSave.tm_year  != ptmTime->tm_year
                     || tmTimeSave.tm_wday  != ptmTime->tm_wday
                     || tmTimeSave.tm_yday  != ptmTime->tm_yday
                     || tmTimeSave.tm_isdst != ptmTime->tm_isdst)
                        QATFail(10);
                   else
                        retVal = true;
                }
                else
                {
                   //NTFS
                    if(!(filetime.actime+filetime.actime % 2 == file_stat.st_atime
                      || filetime.actime == file_stat.st_atime)) 
                        QATFail(11);
                    else
                        retVal = true;
                }
            }
        }
        _close(fh);
        QATCheck(DelFile(testfile2));
    }

    return retVal;
}

static unsigned __stdcall futime2FUTime1(void* qaThreadParam = 0)
{
    QA_BEGIN_TC(1)
    
        QATTrace1(_T("*** futime() ***"));
        if (!TC1<struct _utimbuf>(_futime, time, QA_THREAD_PARAM_NAME))
            QATFail(10);

#if (_MSC_VER > 1200)
        QATTrace1(_T("*** futime64() ***"));
        if (!TC1<struct __utimbuf64>(_futime64, _time64, QA_THREAD_PARAM_NAME))
            QATFail(11);
#endif  /* (_MSC_VER > 1200) */
    
    QA_END_TC(1)
    return 0;
}

static unsigned __stdcall futime2FUTime2(void* qaThreadParam = 0)
{
    QA_BEGIN_TC(2)
    
        QATTrace1(_T("*** futime() ***"));
        if (!TC2<struct _utimbuf, 
                 struct _stat>(_futime, _fstat, time, localtime, 
                               QA_THREAD_PARAM_NAME))
            QATFail(12);

#if (_MSC_VER > 1200)
        QATTrace1(_T("*** futime64() ***"));
        if (!TC2<struct __utimbuf64, 
                 struct __stat64>(_futime64, _fstat64, _time64, _localtime64,
                                  QA_THREAD_PARAM_NAME))
            QATFail(13);
#endif  /* (_MSC_VER > 1200) */
    
    QA_END_TC(2)
    return 0;
}

TestFunc futime2TestFuncList[] =
{
    futime2FUTime1,
    futime2FUTime2
};


int futime2Entry()
{
    int nTests = (sizeof(futime2TestFuncList)/sizeof(futime2TestFuncList[0]));
    int iTest = 0;
    bool bRunTerm = false;

    if (futime2TestFuncList[0] == 0)
    {
        if (nTests == 1) return 3; /* error, not enough data */
        /* if the 0th element is zero, then 1st element is a */
        /* thread kickoff function */
        iTest = 2;
        if (futime2TestFuncList[1] != 0)
            futime2TestFuncList[1](0);
    }

    if (nTests >= 4)
    {
        if (futime2TestFuncList[2] == 0)
        {
            bRunTerm = true;
            iTest = 4;
        }
    }

    for (; iTest < nTests; iTest++)
        if(futime2TestFuncList[iTest] != 0)
            futime2TestFuncList[iTest](0);
    if (bRunTerm)
    {
        if (!futime2TestFuncList[3])
            DbgPrint("Term function NULL!\n");
        else
            futime2TestFuncList[3](0);
    }
    int ret = GetTestFailure() ? 1 : 0;
    ReportTest(false);
    ClearFailures();
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\time\futime1.cpp ===
#define QaLib futime1NameSpace

#include <time.h>
#include <sys\stat.h>
#include <sys\timeb.h>
#include <sys\utime.h>
#include <fcntl.h>
#include <sys\types.h>
#include <io.h>
#include <errno.h>

// ALPHA64_UPDATE: 59
// ALPHA64_CHANGE: needed for the OS DST stuff
#include <windows.h>

#define QA_NTHREADS 1
#include "qalibrary.h"

/*@ futime

TestCases:
------------
  1. Opens file with different modes (binary and text).
     applies different times:
        o max
        o mid May 2074.
        o mid Jun 2001.
        o mid Sep 1972.
  2. Passes NULL as the second parameter, which should use the current time.
  
@*/

static const _TCHAR* testfile = _T("futime.tst");
static const _TCHAR* testfile2 = _T("futime2.tst");

/*
 *  Types of operation allowed for open file used for testing _futime().
 *  Note that the file must have write permision.  Also note that since
 *  _fstat() is used to verify _futime(), the file must have read access.
 *  So, ...
 */

int operations[] =
{
    _O_RDWR | _O_BINARY | _O_CREAT,
    _O_RDWR | _O_TRUNC | _O_APPEND | _O_TEXT | _O_CREAT
};

/*  The following unsigned long array holds the values used to test _utime().
 *  These values are in seconds from 00:00:00 Jan 1, 1970.
 *
 *  It is undocumented as of 2/12/93, but any time value greater than 1980
 *  is supposed to be valid.
 */

static unsigned long try_times[] =
{
    0xFFFFFFFEL,    /* valid    - maximum value */
    3294636800L,    /* valid    - approx. mid May 2074 */
     994967294L,    /* valid    - approx. mid Jun 2001 */
      88965439L     /* valid    - approx. mid Sep 1972 */
};

// ALPHA64_UPDATE: 60
// ALPHA64_CHANGE: helper functions for getting DST settings

// find out whether the "Adjust automatically to DST" is turned on
bool IsAdjustDSTEnabled (void) {
    TIME_ZONE_INFORMATION tzi;
    if(!GetTimeZoneInformation(&tzi)) {
        printf("could not find timezone information");
    }
    return (tzi.StandardBias != tzi.DaylightBias);
}

// find out whether we have DST right now
bool IsDSTNow(void) {
    _timeb tb;
    _ftime(&tb);
    return ((tb.dstflag != 0) ? true : false);
}

// is particular time DST
bool IsDST(time_t time) {
    tm* mytm;
    mytm = localtime(&time);
    return ((mytm->tm_isdst > 0) ? true : false);
}
// ALPHA64_UPDATE_END: 60

template <class T, class UTIMBUF, class STAT, class TF1, class TF2> 
bool TC1(TF1 futimeFunc, TF2 fstatFunc, QA_THREAD_PARAM)
{
    bool        retVal = true;
    
// ALPHA64_UPDATE: 81
// ALPHA64_CHANGE: DST functionality
    bool bAdjustDSTEnabled = IsAdjustDSTEnabled();
    bool bDSTNow = IsDSTNow();

    for (int n = 0; n < (sizeof(operations)/sizeof(operations[0])); n++)
    {
        UTIMBUF utimes;
        STAT    stimes;

        QATTrace2(_T("n == "), n);
        int     fhndl = _topen( testfile, operations[n] );
    
        if (QATCheck(fhndl != -1))
        {
            for(int i = 0; i < (sizeof(try_times)/sizeof(try_times[0])); i++)
            {
                QATTrace2(_T("i == "), i);
                utimes.modtime = try_times[i];
                utimes.actime = try_times[i];

                if(futimeFunc(fhndl, &utimes) == -1)
                {
                    QATCheckE(errno, EINVAL);
                }
                else
                {
                    if (QATCheck(fstatFunc(fhndl, &stimes ) == 0))
                    {

// ALPHA64_UPDATE: 82
// ALPHA64_CHANGE: adjust the time according OS settings, current time and test time
#ifdef _M_ALPHA64
                        // adjust time according to bAdjustDSTEnabled, bDSTNow and IsDST
                        // if !bAdjustDSTEnabled, we don't need to do anything
                        if (bAdjustDSTEnabled) {
                            if (bDSTNow && !IsDST(stimes.st_mtime)) stimes.st_mtime += 3600;
                            else if (!bDSTNow && IsDST(stimes.st_mtime)) stimes.st_mtime -= 3600;
                        }
#endif

                        QATCheckE(stimes.st_mtime, (T)try_times[i]);
                    }
                }
            }
            if (!QATCheck(_close( fhndl ) != -1))
                break;
        }
        _tsystem(_T("attrib -r futime.tst"));
        _tremove(testfile);
    }

    return retVal;
}

template <class T, class UTIMBUF, class TIMEB, class STAT, class TF1, class TF2, 
          class TF3> 
bool TC2(TF1 futimeFunc, TF2 fstatFunc, TF3 ftimeFunc, QA_THREAD_PARAM)
{
    bool    retVal = true;

    int     fhndl = _topen( testfile2, operations[0] );

    if (QATCheck(fhndl != -1))
    {
        TIMEB   times;
        STAT    stimes;

        /* check that when the 2nd arg is NULL, _futime sets the file's
         * modification and access time to the present time.
         */
    
        QATCheck(futimeFunc(fhndl, NULL) == 0);
        ftimeFunc(&times);
        if (QATCheck(fstatFunc( fhndl, &stimes ) == 0))
        {
            /* Note this test allows for 2 seconds of difference which may
             * not be enough if your machine is bogged down.  Two seconds is
             * a long time, but rounding off could contribute to this also.
             */
        
            QATCheck(stimes.st_mtime - times.time <= 2);
        }
    
        _close(fhndl);
        _tsystem(_T("attrib -r futime2.tst"));
        _tremove(testfile2);
    }

    return retVal;
}

static unsigned __stdcall futime1FUTime1(void* qaThreadParam = 0)
{
    QA_BEGIN_TC(1)
    
#if (_MSC_VER > 1200) 
        QATTrace1(_T("*** futime64() ***"));
        if (!TC1<__int64,
                 struct __utimbuf64, 
                 struct __stat64>(_futime64, _fstat64, QA_THREAD_PARAM_NAME))
            QATFail(11);
// ALPHA64_UPDATE: 83
// ALPHA64_CHANGE: put the 32 bit code into the else clause
#else
        QATTrace1(_T("*** futime() ***"));
        if (!TC1<int,
                 struct _utimbuf, 
                 struct _stat>(_futime, _fstat, QA_THREAD_PARAM_NAME))
            QATFail(10);
#endif  /* (_MSC_VER > 1200) */
// ALPHA64_UPDATE_END: 83

    QA_END_TC(1)
    return 0;
}

static unsigned __stdcall futime1FUTime2(void* qaThreadParam = 0)
{
    QA_BEGIN_TC(2)
    
#if (_MSC_VER > 1200) 
        QATTrace1(_T("*** futime64() ***"));
        if (!TC2<__int64,
                 struct __utimbuf64, 
                 struct __timeb64,
                 struct __stat64>(_futime64, _fstat64, _ftime64, QA_THREAD_PARAM_NAME))
            QATFail(13);
// ALPHA64_UPDATE: 84
// ALPHA64_CHANGE: put the 32 bit code into the else clause
#else
        QATTrace1(_T("*** futime() ***"));
        if (!TC2<int,
                 struct _utimbuf, 
                 struct _timeb,
                 struct _stat>(_futime, _fstat, _ftime, QA_THREAD_PARAM_NAME))
            QATFail(12);
#endif  /* (_MSC_VER > 1200) */
// ALPHA64_UPDATE_END: 84

    QA_END_TC(2)
    return 0;
}

TestFunc futime1TestFuncList[] =
{
    futime1FUTime1,
    futime1FUTime2
};


int futime1Entry()
{
    int nTests = (sizeof(futime1TestFuncList)/sizeof(futime1TestFuncList[0]));
    int iTest = 0;
    bool bRunTerm = false;

    if (futime1TestFuncList[0] == 0)
    {
        if (nTests == 1) return 3; /* error, not enough data */
        /* if the 0th element is zero, then 1st element is a */
        /* thread kickoff function */
        iTest = 2;
        if (futime1TestFuncList[1] != 0)
            futime1TestFuncList[1](0);
    }

    if (nTests >= 4)
    {
        if (futime1TestFuncList[2] == 0)
        {
            bRunTerm = true;
            iTest = 4;
        }
    }

    for (; iTest < nTests; iTest++)
        if(futime1TestFuncList[iTest] != 0)
            futime1TestFuncList[iTest](0);
    if (bRunTerm)
    {
        if (!futime1TestFuncList[3])
            DbgPrint("Term function NULL!\n");
        else
            futime1TestFuncList[3](0);
    }
    int ret = GetTestFailure() ? 1 : 0;
    ReportTest(false);
    ClearFailures();
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\time\gmtime1.cpp ===
#define QaLib gmtime1NameSpace

#include <string.h>
#include <time.h>

#include "qalibrary.h"

/*@ gmtime

Test Cases:
------------
  1. 'timer' == -1.  Should FAIL.
  2. 'timer' == 0.  Should PASS - 1/1/1970.
  
@*/

// Helper test functions.  These are template functions to test both 32bit
// and 64bit.
//
template <class TT, class TF> bool TC1(TF timeFunc, QA_THREAD_PARAM, TT tt = 0)
{
    bool        retVal = true;
    struct tm*  ptm;
    TT          timer;

    timer = -1;
    ptm = timeFunc(&timer);
    QATCheck(ptm == 0);

    return retVal;
}

template <class TT, class TF> bool TC2(TF timeFunc, QA_THREAD_PARAM, TT tt = 0)
{
    bool        retVal = true;
    struct tm*  ptm;
    TT          timer;

    timer = 0;
    ptm = timeFunc(&timer);
    if (QATCheck(ptm != 0))
    {
        retVal &= QATCheckE(ptm->tm_mon, 0);
        retVal &= QATCheckE(ptm->tm_mday, 1);
        retVal &= QATCheckE(ptm->tm_year, 70);
    }
    else
        retVal = false;

    return retVal;
}

static unsigned __stdcall gmtime1GMTime1(void* qaThreadParam = 0)
{
    QA_BEGIN_TC(1)

        QATCheck(TC1<time_t>(gmtime, QA_THREAD_PARAM_NAME));

#if (_MSC_VER > 1200)	
		QATCheck(TC1<__time64_t>(_gmtime64, QA_THREAD_PARAM_NAME));
#endif  /* (_MSC_VER > 1200) */


    QA_END_TC(1)
    return 0;
}

static unsigned __stdcall gmtime1GMTime2(void* qaThreadParam = 0)
{
    QA_BEGIN_TC(2)

        QATCheck(TC2<time_t>(gmtime, QA_THREAD_PARAM_NAME));

#if (_MSC_VER > 1200)
		QATCheck(TC2<__time64_t>(_gmtime64, QA_THREAD_PARAM_NAME));
#endif  /* (_MSC_VER > 1200) */

    QA_END_TC(2)
    return 0;
}

TestFunc gmtime1TestFuncList[] =
{
    gmtime1GMTime1,
    gmtime1GMTime2
};


int gmtime1Entry()
{
    int nTests = (sizeof(gmtime1TestFuncList)/sizeof(gmtime1TestFuncList[0]));
    int iTest = 0;
    bool bRunTerm = false;

    if (gmtime1TestFuncList[0] == 0)
    {
        if (nTests == 1) return 3; /* error, not enough data */
        /* if the 0th element is zero, then 1st element is a */
        /* thread kickoff function */
        iTest = 2;
        if (gmtime1TestFuncList[1] != 0)
            gmtime1TestFuncList[1](0);
    }

    if (nTests >= 4)
    {
        if (gmtime1TestFuncList[2] == 0)
        {
            bRunTerm = true;
            iTest = 4;
        }
    }

    for (; iTest < nTests; iTest++)
        if(gmtime1TestFuncList[iTest] != 0)
            gmtime1TestFuncList[iTest](0);
    if (bRunTerm)
    {
        if (!gmtime1TestFuncList[3])
            DbgPrint("Term function NULL!\n");
        else
            gmtime1TestFuncList[3](0);
    }
    int ret = GetTestFailure() ? 1 : 0;
    ReportTest(false);
    ClearFailures();
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\time\localtime1.cpp ===
#define QaLib localtime1NameSpace

#include <string.h>
#include <time.h>

#undef QA_USE_THREADS   // because of the putenv() calls this test can't 
                        // support threads.
#include "qalibrary.h"

/*@ localtime

Test Cases:
------------
  1. Timezone at 0 and timer at 0.  Should PASS.
  2. Timezone at 0 and timer at -1. Should Fail.
  3. Timezone at 8 and timer at 0.  Should PASS.
  4. Timezone at 8 and timer at -1. SHould FAIL.
  
@*/

// Helper test functions.  These are template functions to test both 32bit
// and 64bit.
//
template <class TT, class TF> bool TC1(TF tf, QA_THREAD_PARAM, TT tt = 0)
{
    TT          timer;
    struct tm*  ptm;
    bool        retVal = true;

    /* no putenv in xbox
    if (!QATCheck(_tputenv(_T("TZ=UCT+0")) == 0))
        return false;
    */

    _tzset();

    timer = 0;
    retVal &= QATCheck((ptm = tf(&timer)) != 0);
    retVal &= QATCheckE(_tcscmp(_tasctime(ptm), _T("Thu Jan 01 00:00:00 1970\n")), 0);
    return retVal;
}

template <class TT, class TF> bool TC2(TF tf, QA_THREAD_PARAM, TT tt = 0)
{
    TT          timer;
    struct tm*  ptm;
    bool        retVal = true;

    /* no putenv in xbox
    if (!QATCheck(_tputenv(_T("TZ=PDT+0")) == 0))
        return false;
    */

    _tzset();

    timer = -1;
    ptm = tf(&timer);
    QATCheck(ptm == 0);

    return retVal;
}

template <class TT, class TF> bool TC3(TF tf, QA_THREAD_PARAM, TT tt = 0)
{
    TT          timer;
    struct tm*  ptm;
    bool        retVal = true;

    /* no putenv in xbox
    if (!QATCheck((_tputenv(_T("TZ=PST+8")) == 0)))
        return false;
    */

    _tzset();

    timer = 0;
    QATCheck((ptm = tf(&timer)) != 0);
    //QATCheckE(_tcscmp(_tasctime(ptm), _T("Wed Dec 31 16:00:00 1969\n")), 0);
	//xbox can't set to a different timezone
    QATCheckE(_tcscmp(_tasctime(ptm), _T("Thu Jan 01 00:00:00 1970\n")), 0);

    return retVal;
}

template <class TT, class TF> bool TC4(TF tf, QA_THREAD_PARAM, TT tt = 0)
{
    TT          timer;
    struct tm*  ptm;
    bool        retVal = true;

    /* no putenv in xbox
    if (!QATCheck(_tputenv(_T("TZ=PST+8")) == 0))
        return false;
    */

    _tzset();

    timer = -1;
    QATCheck((ptm = tf(&timer)) == 0);

    return retVal;
}

static unsigned __stdcall localtime1LocalTime1(void* qaThreadParam = 0)
{
    QA_BEGIN_TC(1)

        QATCheck(TC1<time_t>(localtime, QA_THREAD_PARAM_NAME));

#if (_MSC_VER > 1200)
        QATCheck(TC1<__time64_t>(_localtime64, QA_THREAD_PARAM_NAME));
#endif  /* (_MSC_VER > 1200) */

    QA_END_TC(1)
    return 0;
}

static unsigned __stdcall localtime1LocalTime2(void* qaThreadParam = 0)
{
    QA_BEGIN_TC(2)

        QATCheck(TC2<time_t>(localtime, QA_THREAD_PARAM_NAME));

#if (_MSC_VER > 1200)
        QATCheck(TC2<__time64_t>(_localtime64, QA_THREAD_PARAM_NAME));
#endif  /* (_MSC_VER > 1200) */

    QA_END_TC(2)
    return 0;
}

static unsigned __stdcall localtime1LocalTime3(void* qaThreadParam = 0)
{
    QA_BEGIN_TC(3)

        QATCheck(TC3<time_t>(localtime, QA_THREAD_PARAM_NAME));

#if (_MSC_VER > 1200)
        QATCheck(TC3<__time64_t>(_localtime64, QA_THREAD_PARAM_NAME));
#endif  /* (_MSC_VER > 1200) */

    QA_END_TC(3)
    return 0;
}

static unsigned __stdcall localtime1LocalTime4(void* qaThreadParam = 0)
{
    QA_BEGIN_TC(4)

        QATCheck(TC4<time_t>(localtime, QA_THREAD_PARAM_NAME));

#if (_MSC_VER > 1200)
        QATCheck(TC4<__time64_t>(_localtime64, QA_THREAD_PARAM_NAME));
#endif  /* (_MSC_VER > 1200) */

    QA_END_TC(4)
    return 0;
}


TestFunc localtime1TestFuncList[] =
{
    localtime1LocalTime1,
    localtime1LocalTime2,
    localtime1LocalTime3,
    localtime1LocalTime4
};


int localtime1Entry()
{
    int nTests = (sizeof(localtime1TestFuncList)/sizeof(localtime1TestFuncList[0]));
    int iTest = 0;
    bool bRunTerm = false;

    if (localtime1TestFuncList[0] == 0)
    {
        if (nTests == 1) return 3; /* error, not enough data */
        /* if the 0th element is zero, then 1st element is a */
        /* thread kickoff function */
        iTest = 2;
        if (localtime1TestFuncList[1] != 0)
            localtime1TestFuncList[1](0);
    }

    if (nTests >= 4)
    {
        if (localtime1TestFuncList[2] == 0)
        {
            bRunTerm = true;
            iTest = 4;
        }
    }

    for (; iTest < nTests; iTest++)
        if(localtime1TestFuncList[iTest] != 0)
            localtime1TestFuncList[iTest](0);
    if (bRunTerm)
    {
        if (!localtime1TestFuncList[3])
            DbgPrint("Term function NULL!\n");
        else
            localtime1TestFuncList[3](0);
    }
    int ret = GetTestFailure() ? 1 : 0;
    ReportTest(false);
    ClearFailures();
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\time\mktime3.cpp ===
/*@ mktime

Test Cases:  Daylight Savings Time (DST) boundry tests.
-----------
 1. mktime failure boundries.
    Test extremes for failure (TM_MKTIME_FAILURE) return.

 2. _mktime64 failure boundries. (if MSC_VER > 1200)
    Test extremes for failure (TM_MKTIME_FAILURE) return.

 3. mktime DST boundry test.
    Each year is tested (68 total).
	The last ten days March through the first nine days 
	of April are tested for each year.  Also, for each
	year the last ten days of October through the first 
	three days of Novemeber are tested.
	Midnight and every four hours through the day is 
	tested for each day.
	Note that the exact hour of a DST switch is either
	invalid or undefined.

 4. _mktime64 DST boundry test. (if MSC_VER > 1200)
	Each year within 8 years of the turn of the century 
	(21st through 30th) is tested.
	The last ten days March through the first nine days 
	of April are tested for each year.  Also, for each
	year the last ten days of October through the first 
	three days of Novemeber are tested.
	Midnight and every four hours through the day is 
	tested for each day.
	Note that the exact hour of a DST switch is either
	invalid or undefined.
  
@*/

#include <time.h>
#include <malloc.h>
#include <memory.h>
#include <stdio.h>

//	"constant" values for test result
#define	TEST_PASS		0
#define	TEST_FAIL		1
#define	TEST_SKIPPED	2
#define	TEST_CASCADE	3
#define	TEST_NORESULT	4

// macros
//
#define	MAX_FAILED_MSG_PER_TC	4096
#define	MAX_32TM_YEARS			51
#define	MAX_CENTURIES			10
#define	NUM_BOUNDRIES			16
#define	NUM_FAILURES			16
#define	TM_NO_DAYS_CHECKED		32
#define	TM_NO_YEARS_CHECKED		16
#define	EUROPE_HOUR				1
#define	USA_HOUR				2
#define	TM_INVALID_VALUE		0x4000
#define	TM_INVALID_DOW			7
#define	TM_UNDETIRMINED_ISDST	-1
#define	TM_MKTIME_FAILURE		-1
#define	TM_BASE_YEAR			87
#define	True					1
#define	False					0

enum	DSTType
{
	none,
	fixed,
	usa,
	europe
};

char*	g_szFile = __FILE__ ;
int		g_nTC1TestsFailed = 0;
int		g_nTC2TestsFailed = 0;
int		g_nTC3TestsFailed = 0;
int		g_nTC4TestsFailed = 0;

/*
 *  Structures for tests of type 1 above.
 */

tm	TM_Base[TM_NO_DAYS_CHECKED] = 
{
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE, 22,  2, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE, 23,  2, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE, 24,  2, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE, 25,  2, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE, 26,  2, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE, 27,  2, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE, 28,  2, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE, 29,  2, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE, 30,  2, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE, 31,  2, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE,  1,  3, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE,  2,  3, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE,  3,  3, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE,  4,  3, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE,  5,  3, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE,  6,  3, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE,  7,  3, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE,  8,  3, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE,  9,  3, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE, 22,  9, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE, 23,  9, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE, 24,  9, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE, 25,  9, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE, 26,  9, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE, 27,  9, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE, 28,  9, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE, 29,  9, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE, 30,  9, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE, 31,  9, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE,  1, 10, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE,  2, 10, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE,  3, 10, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST}
};


// Helper test functions.  
/*
 *  dstInit() takes dstTest array an array of structures made up of 16 type "tm" structures
 *  initializes tm fields and copies the time fields from the parameters provided.  
 *  Also initializes the year field from 8 years before the turn of the century to 8 years 
 *  after the century.  Starts at the 21st century and will continue for MAX_CENTURIES centuries.
 */

void	tmInit(tm tmTest[MAX_32TM_YEARS * TM_NO_DAYS_CHECKED], int nHour = 12, int nMin = 0, int nSec = 0)
{
	tm*	ptm = tmTest;
	int	nYear = TM_BASE_YEAR;

	for	(int i=0; i<(MAX_32TM_YEARS); ++i)
	{
		memcpy(ptm, TM_Base, sizeof(TM_Base));

		for	(int k=0; k<TM_NO_DAYS_CHECKED; ++k)
		{
			ptm->tm_sec = nSec;
			ptm->tm_min = nMin;
			ptm->tm_hour = nHour;
			ptm->tm_year = nYear;
			++ptm;
		}

		++nYear;
	}
}

void	tmInitFailures(tm tmTest[NUM_FAILURES], int nHour = 12, int nMin = 0, int nSec = 0)
{
	tmTest[0].tm_sec = nSec;	/* seconds after the minute - [0,59] */
	tmTest[0].tm_min = nMin;	/* minutes after the hour - [0,59] */
	tmTest[0].tm_hour = nHour;	/* hours since midnight - [0,23] */
	tmTest[0].tm_mday = 1;		/* day of the month - [1,31] */
	tmTest[0].tm_mon = 0;		/* months since January - [0,11] */
	tmTest[0].tm_year = 0;		/* years since 1900 */
	tmTest[0].tm_wday = TM_INVALID_DOW;		/* days since Sunday - [0,6] */
	tmTest[0].tm_yday = TM_INVALID_VALUE;	/* days since January 1 - [0,365] */
	tmTest[0].tm_isdst = TM_UNDETIRMINED_ISDST;/* daylight savings time flag */

	tmTest[1].tm_sec = nSec;	/* seconds after the minute - [0,59] */
	tmTest[1].tm_min = nMin;	/* minutes after the hour - [0,59] */
	tmTest[1].tm_hour = nHour;	/* hours since midnight - [0,23] */
	tmTest[1].tm_mday = 30;		/* day of the month - [1,31] */
	tmTest[1].tm_mon = 5;		/* months since January - [0,11] */
	tmTest[1].tm_year = 0;		/* years since 1900 */
	tmTest[1].tm_wday = TM_INVALID_DOW;		/* days since Sunday - [0,6] */
	tmTest[1].tm_yday = TM_INVALID_VALUE;	/* days since January 1 - [0,365] */
	tmTest[1].tm_isdst = TM_UNDETIRMINED_ISDST;/* daylight savings time flag */

	tmTest[2].tm_sec = nSec;	/* seconds after the minute - [0,59] */
	tmTest[2].tm_min = nMin;	/* minutes after the hour - [0,59] */
	tmTest[2].tm_hour = nHour;	/* hours since midnight - [0,23] */
	tmTest[2].tm_mday = 1;		/* day of the month - [1,31] */
	tmTest[2].tm_mon = 6;		/* months since January - [0,11] */
	tmTest[2].tm_year = 0;		/* years since 1900 */
	tmTest[2].tm_wday = TM_INVALID_DOW;		/* days since Sunday - [0,6] */
	tmTest[2].tm_yday = TM_INVALID_VALUE;	/* days since January 1 - [0,365] */
	tmTest[2].tm_isdst = TM_UNDETIRMINED_ISDST;/* daylight savings time flag */

	tmTest[3].tm_sec = nSec;	/* seconds after the minute - [0,59] */
	tmTest[3].tm_min = nMin;	/* minutes after the hour - [0,59] */
	tmTest[3].tm_hour = nHour;	/* hours since midnight - [0,23] */
	tmTest[3].tm_mday = 31;		/* day of the month - [1,31] */
	tmTest[3].tm_mon = 11;		/* months since January - [0,11] */
	tmTest[3].tm_year = 0;		/* years since 1900 */
	tmTest[3].tm_wday = TM_INVALID_DOW;		/* days since Sunday - [0,6] */
	tmTest[3].tm_yday = TM_INVALID_VALUE;	/* days since January 1 - [0,365] */
	tmTest[3].tm_isdst = TM_UNDETIRMINED_ISDST;/* daylight savings time flag */

	tmTest[4].tm_sec = nSec;	/* seconds after the minute - [0,59] */
	tmTest[4].tm_min = nMin;	/* minutes after the hour - [0,59] */
	tmTest[4].tm_hour = nHour;	/* hours since midnight - [0,23] */
	tmTest[4].tm_mday = 1;		/* day of the month - [1,31] */
	tmTest[4].tm_mon = 0;		/* months since January - [0,11] */
	tmTest[4].tm_year = 69;		/* years since 1900 */
	tmTest[4].tm_wday = TM_INVALID_DOW;		/* days since Sunday - [0,6] */
	tmTest[4].tm_yday = TM_INVALID_VALUE;	/* days since January 1 - [0,365] */
	tmTest[4].tm_isdst = TM_UNDETIRMINED_ISDST;/* daylight savings time flag */

	tmTest[5].tm_sec = nSec;	/* seconds after the minute - [0,59] */
	tmTest[5].tm_min = nMin;	/* minutes after the hour - [0,59] */
	tmTest[5].tm_hour = nHour;	/* hours since midnight - [0,23] */
	tmTest[5].tm_mday = 30;		/* day of the month - [1,31] */
	tmTest[5].tm_mon = 5;		/* months since January - [0,11] */
	tmTest[5].tm_year = 69;		/* years since 1900 */
	tmTest[5].tm_wday = TM_INVALID_DOW;		/* days since Sunday - [0,6] */
	tmTest[5].tm_yday = TM_INVALID_VALUE;	/* days since January 1 - [0,365] */
	tmTest[5].tm_isdst = TM_UNDETIRMINED_ISDST;/* daylight savings time flag */

	tmTest[6].tm_sec = nSec;	/* seconds after the minute - [0,59] */
	tmTest[6].tm_min = nMin;	/* minutes after the hour - [0,59] */
	tmTest[6].tm_hour = nHour;	/* hours since midnight - [0,23] */
	tmTest[6].tm_mday = 1;		/* day of the month - [1,31] */
	tmTest[6].tm_mon = 6;		/* months since January - [0,11] */
	tmTest[6].tm_year = 69;		/* years since 1900 */
	tmTest[6].tm_wday = TM_INVALID_DOW;		/* days since Sunday - [0,6] */
	tmTest[6].tm_yday = TM_INVALID_VALUE;	/* days since January 1 - [0,365] */
	tmTest[6].tm_isdst = TM_UNDETIRMINED_ISDST;/* daylight savings time flag */

	tmTest[7].tm_sec = nSec;	/* seconds after the minute - [0,59] */
	tmTest[7].tm_min = nMin;	/* minutes after the hour - [0,59] */
	tmTest[7].tm_hour = nHour;	/* hours since midnight - [0,23] */
	tmTest[7].tm_mday = 30;		/* day of the month - [1,31] */
	tmTest[7].tm_mon = 11;		/* months since January - [0,11] */
	tmTest[7].tm_year = 69;		/* years since 1900 */
	tmTest[7].tm_wday = TM_INVALID_DOW;		/* days since Sunday - [0,6] */
	tmTest[7].tm_yday = TM_INVALID_VALUE;	/* days since January 1 - [0,365] */
	tmTest[7].tm_isdst = TM_UNDETIRMINED_ISDST;/* daylight savings time flag */


	tmTest[8].tm_sec = nSec;	/* seconds after the minute - [0,59] */
	tmTest[8].tm_min = nMin;	/* minutes after the hour - [0,59] */
	tmTest[8].tm_hour = nHour;	/* hours since midnight - [0,23] */
	tmTest[8].tm_mday = 20;		/* day of the month - [1,31] */
	tmTest[8].tm_mon = 0;		/* months since January - [0,11] */
	tmTest[8].tm_year = 138;	/* years since 1900 */
	tmTest[8].tm_wday = TM_INVALID_DOW;		/* days since Sunday - [0,6] */
	tmTest[8].tm_yday = TM_INVALID_VALUE;	/* days since January 1 - [0,365] */
	tmTest[8].tm_isdst = TM_UNDETIRMINED_ISDST;/* daylight savings time flag */

	tmTest[9].tm_sec = nSec;	/* seconds after the minute - [0,59] */
	tmTest[9].tm_min = nMin;	/* minutes after the hour - [0,59] */
	tmTest[9].tm_hour = nHour;	/* hours since midnight - [0,23] */
	tmTest[9].tm_mday = 30;		/* day of the month - [1,31] */
	tmTest[9].tm_mon = 5;		/* months since January - [0,11] */
	tmTest[9].tm_year = 138;	/* years since 1900 */
	tmTest[9].tm_wday = TM_INVALID_DOW;		/* days since Sunday - [0,6] */
	tmTest[9].tm_yday = TM_INVALID_VALUE;	/* days since January 1 - [0,365] */
	tmTest[9].tm_isdst = TM_UNDETIRMINED_ISDST;/* daylight savings time flag */

	tmTest[10].tm_sec = nSec;	/* seconds after the minute - [0,59] */
	tmTest[10].tm_min = nMin;	/* minutes after the hour - [0,59] */
	tmTest[10].tm_hour = nHour;	/* hours since midnight - [0,23] */
	tmTest[10].tm_mday = 1;		/* day of the month - [1,31] */
	tmTest[10].tm_mon = 6;		/* months since January - [0,11] */
	tmTest[10].tm_year = 138;	/* years since 1900 */
	tmTest[10].tm_wday = TM_INVALID_DOW;	/* days since Sunday - [0,6] */
	tmTest[10].tm_yday = TM_INVALID_VALUE;	/* days since January 1 - [0,365] */
	tmTest[10].tm_isdst = TM_UNDETIRMINED_ISDST;/* daylight savings time flag */

	tmTest[11].tm_sec = nSec;	/* seconds after the minute - [0,59] */
	tmTest[11].tm_min = nMin;	/* minutes after the hour - [0,59] */
	tmTest[11].tm_hour = nHour;	/* hours since midnight - [0,23] */
	tmTest[11].tm_mday = 31;	/* day of the month - [1,31] */
	tmTest[11].tm_mon = 11;		/* months since January - [0,11] */
	tmTest[11].tm_year = 138;	/* years since 1900 */
	tmTest[11].tm_wday = TM_INVALID_DOW;	/* days since Sunday - [0,6] */
	tmTest[11].tm_yday = TM_INVALID_VALUE;	/* days since January 1 - [0,365] */
	tmTest[11].tm_isdst = TM_UNDETIRMINED_ISDST;/* daylight savings time flag */

	tmTest[12].tm_sec = nSec;	/* seconds after the minute - [0,59] */
	tmTest[12].tm_min = nMin;	/* minutes after the hour - [0,59] */
	tmTest[12].tm_hour = nHour;	/* hours since midnight - [0,23] */
	tmTest[12].tm_mday = 1;		/* day of the month - [1,31] */
	tmTest[12].tm_mon = 0;		/* months since January - [0,11] */
	tmTest[12].tm_year = 1100;	/* years since 1900 */
	tmTest[12].tm_wday = TM_INVALID_DOW;	/* days since Sunday - [0,6] */
	tmTest[12].tm_yday = TM_INVALID_VALUE;	/* days since January 1 - [0,365] */
	tmTest[12].tm_isdst = TM_UNDETIRMINED_ISDST;/* daylight savings time flag */

	tmTest[13].tm_sec = nSec;	/* seconds after the minute - [0,59] */
	tmTest[13].tm_min = nMin;	/* minutes after the hour - [0,59] */
	tmTest[13].tm_hour = nHour;	/* hours since midnight - [0,23] */
	tmTest[13].tm_mday = 30;	/* day of the month - [1,31] */
	tmTest[13].tm_mon = 5;		/* months since January - [0,11] */
	tmTest[13].tm_year = 1100;	/* years since 1900 */
	tmTest[13].tm_wday = TM_INVALID_DOW;	/* days since Sunday - [0,6] */
	tmTest[13].tm_yday = TM_INVALID_VALUE;	/* days since January 1 - [0,365] */
	tmTest[13].tm_isdst = TM_UNDETIRMINED_ISDST;/* daylight savings time flag */

	tmTest[14].tm_sec = nSec;	/* seconds after the minute - [0,59] */
	tmTest[14].tm_min = nMin;	/* minutes after the hour - [0,59] */
	tmTest[14].tm_hour = nHour;	/* hours since midnight - [0,23] */
	tmTest[14].tm_mday = 1;		/* day of the month - [1,31] */
	tmTest[14].tm_mon = 6;		/* months since January - [0,11] */
	tmTest[14].tm_year = 1100;	/* years since 1900 */
	tmTest[14].tm_wday = TM_INVALID_DOW;	/* days since Sunday - [0,6] */
	tmTest[14].tm_yday = TM_INVALID_VALUE;	/* days since January 1 - [0,365] */
	tmTest[14].tm_isdst = TM_UNDETIRMINED_ISDST;/* daylight savings time flag */

	tmTest[15].tm_sec = nSec;	/* seconds after the minute - [0,59] */
	tmTest[15].tm_min = nMin;	/* minutes after the hour - [0,59] */
	tmTest[15].tm_hour = nHour;	/* hours since midnight - [0,23] */
	tmTest[15].tm_mday = 31;	/* day of the month - [1,31] */
	tmTest[15].tm_mon = 11;		/* months since January - [0,11] */
	tmTest[15].tm_year = 1100;	/* years since 1900 */
	tmTest[15].tm_wday = TM_INVALID_DOW;	/* days since Sunday - [0,6] */
	tmTest[15].tm_yday = TM_INVALID_VALUE;	/* days since January 1 - [0,365] */
	tmTest[15].tm_isdst = TM_UNDETIRMINED_ISDST;/* daylight savings time flag */
}

int	CheckTM(DSTType enumDSTType, const tm& tmCheck, int* pbDST, int* pbNext, 
				int nSpMon = 2, int nSpDay = 30, int nFallMon = 9, int nFallDay = 25, int nFixedHour = 1)
{
	if	(*pbNext)
	{
		*pbNext = False;

		if	(*pbDST)
			*pbDST = False;
		else
			*pbDST = True;
	}
	else
	{
		switch	(enumDSTType)
		{
			case fixed:
			{
				if	(!*pbDST && (tmCheck.tm_mon == nSpMon) && (tmCheck.tm_mday == nSpDay))
				{
					if	(tmCheck.tm_hour >= nFixedHour)
						*pbDST = True;
					else
						*pbNext = True;
				}

				if	(*pbDST && (tmCheck.tm_mon == nSpMon) && (tmCheck.tm_mday == nFallDay))
				{
					if	(tmCheck.tm_hour >= nFixedHour -1)
						*pbDST = False;
					else
						*pbNext = True;
				}

				break;
			}

			case usa:
			{
				if	(!*pbDST && (tmCheck.tm_mon == 3) && (tmCheck.tm_wday == 0))
				{
					if	(tmCheck.tm_hour >= USA_HOUR)
						*pbDST = True;
					else
						*pbNext = True;
				}

				if	(*pbDST && (tmCheck.tm_mon == 9) && (tmCheck.tm_wday == 0) && (tmCheck.tm_mday > 24))
				{
					if	(tmCheck.tm_hour >= USA_HOUR - 1)
						*pbDST = False;
					else
						*pbNext = True;
				}

				break;
			}

			case europe:
			{
				if	(!*pbDST && (tmCheck.tm_mon == 2) && (tmCheck.tm_wday == 0) && (tmCheck.tm_mday > 24))
				{
					if	(tmCheck.tm_hour >= EUROPE_HOUR)
						*pbDST = True;
					else
						*pbNext = True;
				}

				if	(*pbDST && (tmCheck.tm_mon == 9) && (tmCheck.tm_wday == 0) && (tmCheck.tm_mday > 24))
				{
					if	(tmCheck.tm_hour >= EUROPE_HOUR -1)
						*pbDST = False;
					else
						*pbNext = True;
				}

				break;
			}
		}
	}

	if	(*pbDST && !tmCheck.tm_isdst)
		return	False;
	else if	(!*pbDST && tmCheck.tm_isdst)
		return	False;

	return	True;
}


int TC1()
{
	char		szMsg[400];
	tm			tmTest[NUM_FAILURES];
	tm*			ptm = tmTest;
	DSTType		enumDSTType = usa;
	int		bDST = False, bNext = False, bRet = True;

	// test mktime for boundries that should fail
	tmInitFailures(tmTest);
	ptm = tmTest;

	for	(int i=0; i<NUM_FAILURES; ++i)
	{
		if	(!(mktime(ptm) == time_t(TM_MKTIME_FAILURE)))
		{
			sprintf(szMsg, "File %s FAILED: mktime ( %d/%d/%d ) did not return -1\n", 
							g_szFile, ptm->tm_mon+1, ptm->tm_mday, ptm->tm_year+1900);
						
			if	(g_nTC1TestsFailed < MAX_FAILED_MSG_PER_TC)
				printf(szMsg);

			++g_nTC1TestsFailed;
			bRet = False;
		}

		++ptm;
	}

    return bRet;
}

int TC2()
{
	char	szMsg[400];
	tm		tmTest[MAX_32TM_YEARS * TM_NO_DAYS_CHECKED];
	tm*		ptm = tmTest;
	DSTType	enumDSTType = usa;
	int		i, j, nHour;
	int		bDST = False, bNext = False, bRet = True;

	for	(nHour=0; nHour<24; ++nHour)
	{
		// test mktime DST change boundries for all years
		tmInit(tmTest, nHour);
		ptm = tmTest;

		for	(i=0; i<MAX_32TM_YEARS; ++i)
		{
			bDST = False;
			bNext = False;

			for	(j=0; j<TM_NO_DAYS_CHECKED; ++j)
			{
				if	(mktime(ptm) == time_t(TM_MKTIME_FAILURE))
				{
					sprintf(szMsg, "File %s FAILED: mktime ( %d/%d/%d  %d hundred hours ) returned -1\n", 
									g_szFile, ptm->tm_mon+1, ptm->tm_mday, ptm->tm_year+1900, ptm->tm_hour);
						
					if	(g_nTC3TestsFailed < MAX_FAILED_MSG_PER_TC)
						printf(szMsg);

					++g_nTC3TestsFailed;
					bRet = False;
				}
				else
				{
					if	(CheckTM(enumDSTType, *ptm, &bDST, &bNext) == 0)
					{
						sprintf(szMsg, "File %s FAILED: mktime ( %d/%d/%d  %d hundred hours ), tm_isdst = %d\n", 
								g_szFile, ptm->tm_mon+1, ptm->tm_mday, ptm->tm_year+1900, ptm->tm_hour, ptm->tm_isdst);
						
						if	(g_nTC3TestsFailed < MAX_FAILED_MSG_PER_TC)
							printf(szMsg);

						++g_nTC3TestsFailed;
						bRet = False;
					}
				}
				
				++ptm;
			}
		}
	}

    return bRet;
}

int	main()
{
	int	nRet = TEST_SKIPPED;

	if	(sizeof(time_t) == 4)
	{
		int	bSucceed = TC1();
		
		nRet = TEST_FAIL;
		bSucceed &= TC2();

		if	(bSucceed)
		{
			printf("\ntest succeeded\n");
			nRet = TEST_PASS;
		}
	}

	return	nRet;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\time\mktime2.cpp ===
#define QaLib mktime2NameSpace

#include <time.h>
#include "qalibrary.h"

/*@ mktime

Test Cases:  Daylight Savings Time (DST) boundry tests.
-----------
 1. mktime failure boundries.
    Test extremes for failure (TM_MKTIME_FAILURE) return.

 2. _mktime64 failure boundries. (if MSC_VER > 1200)
    Test extremes for failure (TM_MKTIME_FAILURE) return.

 3. mktime DST boundry test.
    Each year is tested (68 total).
	The last ten days March through the first nine days 
	of April are tested for each year.  Also, for each
	year the last ten days of October through the first 
	three days of Novemeber are tested.
	Midnight and every four hours through the day is 
	tested for each day.
	Note that the exact hour of a DST switch is either
	invalid or undefined.

 4. _mktime64 DST boundry test. (if MSC_VER > 1200)
	Each year within 8 years of the turn of the century 
	(21st through 30th) is tested.
	The last ten days March through the first nine days 
	of April are tested for each year.  Also, for each
	year the last ten days of October through the first 
	three days of Novemeber are tested.
	Midnight and every four hours through the day is 
	tested for each day.
	Note that the exact hour of a DST switch is either
	invalid or undefined.
  
@*/

// macros
//
#define	MAX_32TM_YEARS			68
#define	MAX_CENTURIES			10
#define	NUM_BOUNDRIES			16
#define	NUM_FAILURES			16
#define	TM_NO_DAYS_CHECKED		32
#define	TM_NO_YEARS_CHECKED		16
#define	EUROPE_HOUR				1
#define	USA_HOUR				2
#define	TM_INVALID_VALUE		0x4000
#define	TM_INVALID_DOW			7
#define	TM_UNDETIRMINED_ISDST	-1
#define	TM_MKTIME_FAILURE		-1
#define	TM_BASE_YEAR			70

enum	DSTType
{
	none,
	fixed,
	usa,
	europe
};

/*
 *  Structures for tests of type 1 above.
 */

static tm TM_Base[TM_NO_DAYS_CHECKED] = 
{
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE, 22,  2, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE, 23,  2, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE, 24,  2, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE, 25,  2, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE, 26,  2, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE, 27,  2, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE, 28,  2, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE, 29,  2, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE, 30,  2, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE, 31,  2, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE,  1,  3, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE,  2,  3, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE,  3,  3, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE,  4,  3, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE,  5,  3, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE,  6,  3, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE,  7,  3, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE,  8,  3, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE,  9,  3, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE, 22,  9, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE, 23,  9, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE, 24,  9, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE, 25,  9, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE, 26,  9, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE, 27,  9, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE, 28,  9, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE, 29,  9, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE, 30,  9, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE, 31,  9, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE,  1, 10, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE,  2, 10, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST},
	{TM_INVALID_VALUE, TM_INVALID_VALUE, TM_INVALID_VALUE,  3, 10, 0, TM_INVALID_DOW, TM_INVALID_VALUE, TM_UNDETIRMINED_ISDST}
};


// Helper test functions.  
// 
//
static void	tmInit(tm tmTest[MAX_32TM_YEARS * TM_NO_DAYS_CHECKED], int nHour = 12, int nMin = 0, int nSec = 0)
{
	tm*	ptm = tmTest;
	int	nYear = TM_BASE_YEAR;

	for	(int i=0; i<(MAX_32TM_YEARS); ++i)
	{
		memcpy(ptm, TM_Base, sizeof(TM_Base));

		for	(int k=0; k<TM_NO_DAYS_CHECKED; ++k)
		{
			ptm->tm_sec = nSec;
			ptm->tm_min = nMin;
			ptm->tm_hour = nHour;
			ptm->tm_year = nYear;
			++ptm;
		}

		++nYear;
	}
}

static void tmInitFailures(tm tmTest[NUM_FAILURES], int nHour = 12, int nMin = 0, int nSec = 0)
{
	tmTest[0].tm_sec = nSec;	/* seconds after the minute - [0,59] */
	tmTest[0].tm_min = nMin;	/* minutes after the hour - [0,59] */
	tmTest[0].tm_hour = nHour;	/* hours since midnight - [0,23] */
	tmTest[0].tm_mday = 1;		/* day of the month - [1,31] */
	tmTest[0].tm_mon = 0;		/* months since January - [0,11] */
	tmTest[0].tm_year = 0;		/* years since 1900 */
	tmTest[0].tm_wday = TM_INVALID_DOW;		/* days since Sunday - [0,6] */
	tmTest[0].tm_yday = TM_INVALID_VALUE;	/* days since January 1 - [0,365] */
	tmTest[0].tm_isdst = TM_UNDETIRMINED_ISDST;/* daylight savings time flag */

	tmTest[1].tm_sec = nSec;	/* seconds after the minute - [0,59] */
	tmTest[1].tm_min = nMin;	/* minutes after the hour - [0,59] */
	tmTest[1].tm_hour = nHour;	/* hours since midnight - [0,23] */
	tmTest[1].tm_mday = 30;		/* day of the month - [1,31] */
	tmTest[1].tm_mon = 5;		/* months since January - [0,11] */
	tmTest[1].tm_year = 0;		/* years since 1900 */
	tmTest[1].tm_wday = TM_INVALID_DOW;		/* days since Sunday - [0,6] */
	tmTest[1].tm_yday = TM_INVALID_VALUE;	/* days since January 1 - [0,365] */
	tmTest[1].tm_isdst = TM_UNDETIRMINED_ISDST;/* daylight savings time flag */

	tmTest[2].tm_sec = nSec;	/* seconds after the minute - [0,59] */
	tmTest[2].tm_min = nMin;	/* minutes after the hour - [0,59] */
	tmTest[2].tm_hour = nHour;	/* hours since midnight - [0,23] */
	tmTest[2].tm_mday = 1;		/* day of the month - [1,31] */
	tmTest[2].tm_mon = 6;		/* months since January - [0,11] */
	tmTest[2].tm_year = 0;		/* years since 1900 */
	tmTest[2].tm_wday = TM_INVALID_DOW;		/* days since Sunday - [0,6] */
	tmTest[2].tm_yday = TM_INVALID_VALUE;	/* days since January 1 - [0,365] */
	tmTest[2].tm_isdst = TM_UNDETIRMINED_ISDST;/* daylight savings time flag */

	tmTest[3].tm_sec = nSec;	/* seconds after the minute - [0,59] */
	tmTest[3].tm_min = nMin;	/* minutes after the hour - [0,59] */
	tmTest[3].tm_hour = nHour;	/* hours since midnight - [0,23] */
	tmTest[3].tm_mday = 31;		/* day of the month - [1,31] */
	tmTest[3].tm_mon = 11;		/* months since January - [0,11] */
	tmTest[3].tm_year = 0;		/* years since 1900 */
	tmTest[3].tm_wday = TM_INVALID_DOW;		/* days since Sunday - [0,6] */
	tmTest[3].tm_yday = TM_INVALID_VALUE;	/* days since January 1 - [0,365] */
	tmTest[3].tm_isdst = TM_UNDETIRMINED_ISDST;/* daylight savings time flag */

	tmTest[4].tm_sec = nSec;	/* seconds after the minute - [0,59] */
	tmTest[4].tm_min = nMin;	/* minutes after the hour - [0,59] */
	tmTest[4].tm_hour = nHour;	/* hours since midnight - [0,23] */
	tmTest[4].tm_mday = 1;		/* day of the month - [1,31] */
	tmTest[4].tm_mon = 0;		/* months since January - [0,11] */
	tmTest[4].tm_year = 69;		/* years since 1900 */
	tmTest[4].tm_wday = TM_INVALID_DOW;		/* days since Sunday - [0,6] */
	tmTest[4].tm_yday = TM_INVALID_VALUE;	/* days since January 1 - [0,365] */
	tmTest[4].tm_isdst = TM_UNDETIRMINED_ISDST;/* daylight savings time flag */

	tmTest[5].tm_sec = nSec;	/* seconds after the minute - [0,59] */
	tmTest[5].tm_min = nMin;	/* minutes after the hour - [0,59] */
	tmTest[5].tm_hour = nHour;	/* hours since midnight - [0,23] */
	tmTest[5].tm_mday = 30;		/* day of the month - [1,31] */
	tmTest[5].tm_mon = 5;		/* months since January - [0,11] */
	tmTest[5].tm_year = 69;		/* years since 1900 */
	tmTest[5].tm_wday = TM_INVALID_DOW;		/* days since Sunday - [0,6] */
	tmTest[5].tm_yday = TM_INVALID_VALUE;	/* days since January 1 - [0,365] */
	tmTest[5].tm_isdst = TM_UNDETIRMINED_ISDST;/* daylight savings time flag */

	tmTest[6].tm_sec = nSec;	/* seconds after the minute - [0,59] */
	tmTest[6].tm_min = nMin;	/* minutes after the hour - [0,59] */
	tmTest[6].tm_hour = nHour;	/* hours since midnight - [0,23] */
	tmTest[6].tm_mday = 1;		/* day of the month - [1,31] */
	tmTest[6].tm_mon = 6;		/* months since January - [0,11] */
	tmTest[6].tm_year = 69;		/* years since 1900 */
	tmTest[6].tm_wday = TM_INVALID_DOW;		/* days since Sunday - [0,6] */
	tmTest[6].tm_yday = TM_INVALID_VALUE;	/* days since January 1 - [0,365] */
	tmTest[6].tm_isdst = TM_UNDETIRMINED_ISDST;/* daylight savings time flag */

	tmTest[7].tm_sec = nSec;	/* seconds after the minute - [0,59] */
	tmTest[7].tm_min = nMin;	/* minutes after the hour - [0,59] */
	tmTest[7].tm_hour = nHour;	/* hours since midnight - [0,23] */
	tmTest[7].tm_mday = 30;		/* day of the month - [1,31] */
	tmTest[7].tm_mon = 11;		/* months since January - [0,11] */
	tmTest[7].tm_year = 69;		/* years since 1900 */
	tmTest[7].tm_wday = TM_INVALID_DOW;		/* days since Sunday - [0,6] */
	tmTest[7].tm_yday = TM_INVALID_VALUE;	/* days since January 1 - [0,365] */
	tmTest[7].tm_isdst = TM_UNDETIRMINED_ISDST;/* daylight savings time flag */


	tmTest[8].tm_sec = nSec;	/* seconds after the minute - [0,59] */
	tmTest[8].tm_min = nMin;	/* minutes after the hour - [0,59] */
	tmTest[8].tm_hour = nHour;	/* hours since midnight - [0,23] */
	tmTest[8].tm_mday = 20;		/* day of the month - [1,31] */
	tmTest[8].tm_mon = 0;		/* months since January - [0,11] */
	tmTest[8].tm_year = 138;	/* years since 1900 */
	tmTest[8].tm_wday = TM_INVALID_DOW;		/* days since Sunday - [0,6] */
	tmTest[8].tm_yday = TM_INVALID_VALUE;	/* days since January 1 - [0,365] */
	tmTest[8].tm_isdst = TM_UNDETIRMINED_ISDST;/* daylight savings time flag */

	tmTest[9].tm_sec = nSec;	/* seconds after the minute - [0,59] */
	tmTest[9].tm_min = nMin;	/* minutes after the hour - [0,59] */
	tmTest[9].tm_hour = nHour;	/* hours since midnight - [0,23] */
	tmTest[9].tm_mday = 30;		/* day of the month - [1,31] */
	tmTest[9].tm_mon = 5;		/* months since January - [0,11] */
	tmTest[9].tm_year = 138;	/* years since 1900 */
	tmTest[9].tm_wday = TM_INVALID_DOW;		/* days since Sunday - [0,6] */
	tmTest[9].tm_yday = TM_INVALID_VALUE;	/* days since January 1 - [0,365] */
	tmTest[9].tm_isdst = TM_UNDETIRMINED_ISDST;/* daylight savings time flag */

	tmTest[10].tm_sec = nSec;	/* seconds after the minute - [0,59] */
	tmTest[10].tm_min = nMin;	/* minutes after the hour - [0,59] */
	tmTest[10].tm_hour = nHour;	/* hours since midnight - [0,23] */
	tmTest[10].tm_mday = 1;		/* day of the month - [1,31] */
	tmTest[10].tm_mon = 6;		/* months since January - [0,11] */
	tmTest[10].tm_year = 138;	/* years since 1900 */
	tmTest[10].tm_wday = TM_INVALID_DOW;	/* days since Sunday - [0,6] */
	tmTest[10].tm_yday = TM_INVALID_VALUE;	/* days since January 1 - [0,365] */
	tmTest[10].tm_isdst = TM_UNDETIRMINED_ISDST;/* daylight savings time flag */

	tmTest[11].tm_sec = nSec;	/* seconds after the minute - [0,59] */
	tmTest[11].tm_min = nMin;	/* minutes after the hour - [0,59] */
	tmTest[11].tm_hour = nHour;	/* hours since midnight - [0,23] */
	tmTest[11].tm_mday = 31;	/* day of the month - [1,31] */
	tmTest[11].tm_mon = 11;		/* months since January - [0,11] */
	tmTest[11].tm_year = 138;	/* years since 1900 */
	tmTest[11].tm_wday = TM_INVALID_DOW;	/* days since Sunday - [0,6] */
	tmTest[11].tm_yday = TM_INVALID_VALUE;	/* days since January 1 - [0,365] */
	tmTest[11].tm_isdst = TM_UNDETIRMINED_ISDST;/* daylight savings time flag */

	tmTest[12].tm_sec = nSec;	/* seconds after the minute - [0,59] */
	tmTest[12].tm_min = nMin;	/* minutes after the hour - [0,59] */
	tmTest[12].tm_hour = nHour;	/* hours since midnight - [0,23] */
	tmTest[12].tm_mday = 1;		/* day of the month - [1,31] */
	tmTest[12].tm_mon = 0;		/* months since January - [0,11] */
	tmTest[12].tm_year = 1100;	/* years since 1900 */
	tmTest[12].tm_wday = TM_INVALID_DOW;	/* days since Sunday - [0,6] */
	tmTest[12].tm_yday = TM_INVALID_VALUE;	/* days since January 1 - [0,365] */
	tmTest[12].tm_isdst = TM_UNDETIRMINED_ISDST;/* daylight savings time flag */

	tmTest[13].tm_sec = nSec;	/* seconds after the minute - [0,59] */
	tmTest[13].tm_min = nMin;	/* minutes after the hour - [0,59] */
	tmTest[13].tm_hour = nHour;	/* hours since midnight - [0,23] */
	tmTest[13].tm_mday = 30;	/* day of the month - [1,31] */
	tmTest[13].tm_mon = 5;		/* months since January - [0,11] */
	tmTest[13].tm_year = 1100;	/* years since 1900 */
	tmTest[13].tm_wday = TM_INVALID_DOW;	/* days since Sunday - [0,6] */
	tmTest[13].tm_yday = TM_INVALID_VALUE;	/* days since January 1 - [0,365] */
	tmTest[13].tm_isdst = TM_UNDETIRMINED_ISDST;/* daylight savings time flag */

	tmTest[14].tm_sec = nSec;	/* seconds after the minute - [0,59] */
	tmTest[14].tm_min = nMin;	/* minutes after the hour - [0,59] */
	tmTest[14].tm_hour = nHour;	/* hours since midnight - [0,23] */
	tmTest[14].tm_mday = 1;		/* day of the month - [1,31] */
	tmTest[14].tm_mon = 6;		/* months since January - [0,11] */
	tmTest[14].tm_year = 1100;	/* years since 1900 */
	tmTest[14].tm_wday = TM_INVALID_DOW;	/* days since Sunday - [0,6] */
	tmTest[14].tm_yday = TM_INVALID_VALUE;	/* days since January 1 - [0,365] */
	tmTest[14].tm_isdst = TM_UNDETIRMINED_ISDST;/* daylight savings time flag */

	tmTest[15].tm_sec = nSec;	/* seconds after the minute - [0,59] */
	tmTest[15].tm_min = nMin;	/* minutes after the hour - [0,59] */
	tmTest[15].tm_hour = nHour;	/* hours since midnight - [0,23] */
	tmTest[15].tm_mday = 31;	/* day of the month - [1,31] */
	tmTest[15].tm_mon = 11;		/* months since January - [0,11] */
	tmTest[15].tm_year = 1100;	/* years since 1900 */
	tmTest[15].tm_wday = TM_INVALID_DOW;	/* days since Sunday - [0,6] */
	tmTest[15].tm_yday = TM_INVALID_VALUE;	/* days since January 1 - [0,365] */
	tmTest[15].tm_isdst = TM_UNDETIRMINED_ISDST;/* daylight savings time flag */
}

#if	(_MSC_VER > 1200)
void	tm64Init(tm tmTest[MAX_CENTURIES * TM_NO_DAYS_CHECKED * TM_NO_YEARS_CHECKED], int nHour = 12, int nMin = 0, int nSec = 0)
{
	tm*	ptm = tmTest;
	int	nYear;

	for	(int i=0; i<(MAX_CENTURIES); ++i)
	{
		nYear = ((i + 1) * 100) - 7;

		for	(int j=0; j<TM_NO_YEARS_CHECKED; ++j)
		{
			memcpy(ptm, TM_Base, sizeof(TM_Base));

			for	(int k=0; k<TM_NO_DAYS_CHECKED; ++k)
			{
				ptm->tm_sec = nSec;
				ptm->tm_min = nMin;
				ptm->tm_hour = nHour;
				ptm->tm_year = nYear;
				++ptm;
			}
			++nYear;
		}
	}
}

void	tm64InitBoundries(tm tmTest[NUM_BOUNDRIES * 2], int nHour = 12, int nMin = 0, int nSec = 0)
{
	tm*	ptm = tmTest;
	int	nYear = TM_BASE_YEAR, i;

	for	(i=0; i<NUM_BOUNDRIES; ++i)
	{
		memcpy(ptm, TM_Base, sizeof(TM_Base));

		for	(int k=0; k<TM_NO_DAYS_CHECKED; ++k)
		{
			ptm->tm_sec = nSec;
			ptm->tm_min = nMin;
			ptm->tm_hour = nHour;
			ptm->tm_year = nYear;
			++ptm;
		}
		++nYear;
	}

	nYear = (3001 - 1900) - NUM_BOUNDRIES;
	for	(i=0; i<NUM_BOUNDRIES; ++i)
	{
		memcpy(ptm, TM_Base, sizeof(TM_Base));

		for	(int k=0; k<TM_NO_DAYS_CHECKED; ++k)
		{
			ptm->tm_sec = nSec;
			ptm->tm_min = nMin;
			ptm->tm_hour = nHour;
			ptm->tm_year = nYear;
			++ptm;
		}
		++nYear;
	}
}

void	tmInit64Failures(tm tmTest[NUM_FAILURES], int nHour = 12, int nMin = 0, int nSec = 0)
{
	tmTest[0].tm_sec = nSec;	/* seconds after the minute - [0,59] */
	tmTest[0].tm_min = nMin;	/* minutes after the hour - [0,59] */
	tmTest[0].tm_hour = nHour;	/* hours since midnight - [0,23] */
	tmTest[0].tm_mday = 1;		/* day of the month - [1,31] */
	tmTest[0].tm_mon = 0;		/* months since January - [0,11] */
	tmTest[0].tm_year = 0;		/* years since 1900 */
	tmTest[0].tm_wday = TM_INVALID_DOW;		/* days since Sunday - [0,6] */
	tmTest[0].tm_yday = TM_INVALID_VALUE;	/* days since January 1 - [0,365] */
	tmTest[0].tm_isdst = TM_UNDETIRMINED_ISDST;	/* daylight savings time flag */

	tmTest[1].tm_sec = nSec;	/* seconds after the minute - [0,59] */
	tmTest[1].tm_min = nMin;	/* minutes after the hour - [0,59] */
	tmTest[1].tm_hour = nHour;	/* hours since midnight - [0,23] */
	tmTest[1].tm_mday = 30;		/* day of the month - [1,31] */
	tmTest[1].tm_mon = 5;		/* months since January - [0,11] */
	tmTest[1].tm_year = 0;		/* years since 1900 */
	tmTest[1].tm_wday = TM_INVALID_DOW;		/* days since Sunday - [0,6] */
	tmTest[1].tm_yday = TM_INVALID_VALUE;	/* days since January 1 - [0,365] */
	tmTest[1].tm_isdst = TM_UNDETIRMINED_ISDST;/* daylight savings time flag */

	tmTest[2].tm_sec = nSec;	/* seconds after the minute - [0,59] */
	tmTest[2].tm_min = nMin;	/* minutes after the hour - [0,59] */
	tmTest[2].tm_hour = nHour;	/* hours since midnight - [0,23] */
	tmTest[2].tm_mday = 1;		/* day of the month - [1,31] */
	tmTest[2].tm_mon = 6;		/* months since January - [0,11] */
	tmTest[2].tm_year = 0;		/* years since 1900 */
	tmTest[2].tm_wday = TM_INVALID_DOW;		/* days since Sunday - [0,6] */
	tmTest[2].tm_yday = TM_INVALID_VALUE;	/* days since January 1 - [0,365] */
	tmTest[2].tm_isdst = TM_UNDETIRMINED_ISDST;/* daylight savings time flag */

	tmTest[3].tm_sec = nSec;	/* seconds after the minute - [0,59] */
	tmTest[3].tm_min = nMin;	/* minutes after the hour - [0,59] */
	tmTest[3].tm_hour = nHour;	/* hours since midnight - [0,23] */
	tmTest[3].tm_mday = 31;		/* day of the month - [1,31] */
	tmTest[3].tm_mon = 11;		/* months since January - [0,11] */
	tmTest[3].tm_year = 0;		/* years since 1900 */
	tmTest[3].tm_wday = TM_INVALID_DOW;		/* days since Sunday - [0,6] */
	tmTest[3].tm_yday = TM_INVALID_VALUE;	/* days since January 1 - [0,365] */
	tmTest[3].tm_isdst = TM_UNDETIRMINED_ISDST;/* daylight savings time flag */

	tmTest[4].tm_sec = nSec;	/* seconds after the minute - [0,59] */
	tmTest[4].tm_min = nMin;	/* minutes after the hour - [0,59] */
	tmTest[4].tm_hour = nHour;	/* hours since midnight - [0,23] */
	tmTest[4].tm_mday = 1;		/* day of the month - [1,31] */
	tmTest[4].tm_mon = 0;		/* months since January - [0,11] */
	tmTest[4].tm_year = 69;		/* years since 1900 */
	tmTest[4].tm_wday = TM_INVALID_DOW;		/* days since Sunday - [0,6] */
	tmTest[4].tm_yday = TM_INVALID_VALUE;	/* days since January 1 - [0,365] */
	tmTest[4].tm_isdst = TM_UNDETIRMINED_ISDST;/* daylight savings time flag */

	tmTest[5].tm_sec = nSec;	/* seconds after the minute - [0,59] */
	tmTest[5].tm_min = nMin;	/* minutes after the hour - [0,59] */
	tmTest[5].tm_hour = nHour;	/* hours since midnight - [0,23] */
	tmTest[5].tm_mday = 30;		/* day of the month - [1,31] */
	tmTest[5].tm_mon = 5;		/* months since January - [0,11] */
	tmTest[5].tm_year = 69;		/* years since 1900 */
	tmTest[5].tm_wday = TM_INVALID_DOW;		/* days since Sunday - [0,6] */
	tmTest[5].tm_yday = TM_INVALID_VALUE;	/* days since January 1 - [0,365] */
	tmTest[5].tm_isdst = TM_UNDETIRMINED_ISDST;/* daylight savings time flag */

	tmTest[6].tm_sec = nSec;	/* seconds after the minute - [0,59] */
	tmTest[6].tm_min = nMin;	/* minutes after the hour - [0,59] */
	tmTest[6].tm_hour = nHour;	/* hours since midnight - [0,23] */
	tmTest[6].tm_mday = 1;		/* day of the month - [1,31] */
	tmTest[6].tm_mon = 6;		/* months since January - [0,11] */
	tmTest[6].tm_year = 69;		/* years since 1900 */
	tmTest[6].tm_wday = TM_INVALID_DOW;		/* days since Sunday - [0,6] */
	tmTest[6].tm_yday = TM_INVALID_VALUE;	/* days since January 1 - [0,365] */
	tmTest[6].tm_isdst = TM_UNDETIRMINED_ISDST;/* daylight savings time flag */

	tmTest[7].tm_sec = nSec;	/* seconds after the minute - [0,59] */
	tmTest[7].tm_min = nMin;	/* minutes after the hour - [0,59] */
	tmTest[7].tm_hour = nHour;	/* hours since midnight - [0,23] */
	tmTest[7].tm_mday = 30;		/* day of the month - [1,31] */
	tmTest[7].tm_mon = 11;		/* months since January - [0,11] */
	tmTest[7].tm_year = 69;		/* years since 1900 */
	tmTest[7].tm_wday = TM_INVALID_DOW;		/* days since Sunday - [0,6] */
	tmTest[7].tm_yday = TM_INVALID_VALUE;	/* days since January 1 - [0,365] */
	tmTest[7].tm_isdst = TM_UNDETIRMINED_ISDST;/* daylight savings time flag */


	tmTest[8].tm_sec = nSec;	/* seconds after the minute - [0,59] */
	tmTest[8].tm_min = nMin;	/* minutes after the hour - [0,59] */
	tmTest[8].tm_hour = nHour;	/* hours since midnight - [0,23] */
	tmTest[8].tm_mday = 2;		/* day of the month - [1,31] */
	tmTest[8].tm_mon = 0;		/* months since January - [0,11] */
	tmTest[8].tm_year = 1101;	/* years since 1900 */
	tmTest[8].tm_wday = TM_INVALID_DOW;		/* days since Sunday - [0,6] */
	tmTest[8].tm_yday = TM_INVALID_VALUE;	/* days since January 1 - [0,365] */
	tmTest[8].tm_isdst = TM_UNDETIRMINED_ISDST;/* daylight savings time flag */

	tmTest[9].tm_sec = nSec;	/* seconds after the minute - [0,59] */
	tmTest[9].tm_min = nMin;	/* minutes after the hour - [0,59] */
	tmTest[9].tm_hour = nHour;	/* hours since midnight - [0,23] */
	tmTest[9].tm_mday = 30;		/* day of the month - [1,31] */
	tmTest[9].tm_mon = 5;		/* months since January - [0,11] */
	tmTest[9].tm_year = 1101;	/* years since 1900 */
	tmTest[9].tm_wday = TM_INVALID_DOW;		/* days since Sunday - [0,6] */
	tmTest[9].tm_yday = TM_INVALID_VALUE;	/* days since January 1 - [0,365] */
	tmTest[9].tm_isdst = TM_UNDETIRMINED_ISDST;/* daylight savings time flag */

	tmTest[10].tm_sec = nSec;	/* seconds after the minute - [0,59] */
	tmTest[10].tm_min = nMin;	/* minutes after the hour - [0,59] */
	tmTest[10].tm_hour = nHour;	/* hours since midnight - [0,23] */
	tmTest[10].tm_mday = 1;		/* day of the month - [1,31] */
	tmTest[10].tm_mon = 6;		/* months since January - [0,11] */
	tmTest[10].tm_year = 1101;	/* years since 1900 */
	tmTest[10].tm_wday = TM_INVALID_DOW;	/* days since Sunday - [0,6] */
	tmTest[10].tm_yday = TM_INVALID_VALUE;	/* days since January 1 - [0,365] */
	tmTest[10].tm_isdst = TM_UNDETIRMINED_ISDST;/* daylight savings time flag */

	tmTest[11].tm_sec = nSec;	/* seconds after the minute - [0,59] */
	tmTest[11].tm_min = nMin;	/* minutes after the hour - [0,59] */
	tmTest[11].tm_hour = nHour;	/* hours since midnight - [0,23] */
	tmTest[11].tm_mday = 31;	/* day of the month - [1,31] */
	tmTest[11].tm_mon = 11;		/* months since January - [0,11] */
	tmTest[11].tm_year = 1101;	/* years since 1900 */
	tmTest[11].tm_wday = TM_INVALID_DOW;	/* days since Sunday - [0,6] */
	tmTest[11].tm_yday = TM_INVALID_VALUE;	/* days since January 1 - [0,365] */
	tmTest[11].tm_isdst = TM_UNDETIRMINED_ISDST;/* daylight savings time flag */

	tmTest[12].tm_sec = nSec;	/* seconds after the minute - [0,59] */
	tmTest[12].tm_min = nMin;	/* minutes after the hour - [0,59] */
	tmTest[12].tm_hour = nHour;	/* hours since midnight - [0,23] */
	tmTest[12].tm_mday = 1;		/* day of the month - [1,31] */
	tmTest[12].tm_mon = 0;		/* months since January - [0,11] */
	tmTest[12].tm_year = 0x80000000;		/* years since 1900 */
	tmTest[12].tm_wday = TM_INVALID_DOW;	/* days since Sunday - [0,6] */
	tmTest[12].tm_yday = TM_INVALID_VALUE;	/* days since January 1 - [0,365] */
	tmTest[12].tm_isdst = TM_UNDETIRMINED_ISDST;/* daylight savings time flag */

	tmTest[13].tm_sec = nSec;	/* seconds after the minute - [0,59] */
	tmTest[13].tm_min = nMin;	/* minutes after the hour - [0,59] */
	tmTest[13].tm_hour = nHour;	/* hours since midnight - [0,23] */
	tmTest[13].tm_mday = 30;	/* day of the month - [1,31] */
	tmTest[13].tm_mon = 5;		/* months since January - [0,11] */
	tmTest[13].tm_year = 0x80000000;		/* years since 1900 */
	tmTest[13].tm_wday = TM_INVALID_DOW;	/* days since Sunday - [0,6] */
	tmTest[13].tm_yday = TM_INVALID_VALUE;	/* days since January 1 - [0,365] */
	tmTest[13].tm_isdst = TM_UNDETIRMINED_ISDST;/* daylight savings time flag */

	tmTest[14].tm_sec = nSec;	/* seconds after the minute - [0,59] */
	tmTest[14].tm_min = nMin;	/* minutes after the hour - [0,59] */
	tmTest[14].tm_hour = nHour;	/* hours since midnight - [0,23] */
	tmTest[14].tm_mday = 1;		/* day of the month - [1,31] */
	tmTest[14].tm_mon = 6;		/* months since January - [0,11] */
	tmTest[14].tm_year = 0x80000000;		/* years since 1900 */
	tmTest[14].tm_wday = TM_INVALID_DOW;	/* days since Sunday - [0,6] */
	tmTest[14].tm_yday = TM_INVALID_VALUE;	/* days since January 1 - [0,365] */
	tmTest[14].tm_isdst = TM_UNDETIRMINED_ISDST;/* daylight savings time flag */

	tmTest[15].tm_sec = nSec;	/* seconds after the minute - [0,59] */
	tmTest[15].tm_min = nMin;	/* minutes after the hour - [0,59] */
	tmTest[15].tm_hour = nHour;	/* hours since midnight - [0,23] */
	tmTest[15].tm_mday = 31;	/* day of the month - [1,31] */
	tmTest[15].tm_mon = 11;		/* months since January - [0,11] */
	tmTest[15].tm_year = 0x80000000;		/* years since 1900 */
	tmTest[15].tm_wday = TM_INVALID_DOW;	/* days since Sunday - [0,6] */
	tmTest[15].tm_yday = TM_INVALID_VALUE;	/* days since January 1 - [0,365] */
	tmTest[15].tm_isdst = TM_UNDETIRMINED_ISDST;/* daylight savings time flag */
}
#endif // (_MSC_VER > 1200)

bool	CheckTM(DSTType enumDSTType, const tm& tmCheck, bool* pbDST, bool* pbNext, 
				int nSpMon = 2, int nSpDay = 30, int nFallMon = 9, int nFallDay = 25, int nFixedHour = 1)
{
	if	(*pbNext)
	{
		*pbNext = false;

		if	(*pbDST)
			*pbDST = false;
		else
			*pbDST = true;
	}
	else
	{
		switch	(enumDSTType)
		{
			case fixed:
			{
				if	(!*pbDST && (tmCheck.tm_mon == nSpMon) && (tmCheck.tm_mday == nSpDay))
				{
					if	(tmCheck.tm_hour >= nFixedHour)
						*pbDST = true;
					else
						*pbNext = true;
				}

				if	(*pbDST && (tmCheck.tm_mon == nSpMon) && (tmCheck.tm_mday == nFallDay))
				{
					if	(tmCheck.tm_hour >= nFixedHour -1)
						*pbDST = false;
					else
						*pbNext = true;
				}

				break;
			}

			case usa:
			{
				if	(!*pbDST && (tmCheck.tm_mon == 3) && (tmCheck.tm_wday == 0))
				{
					if	(tmCheck.tm_hour >= USA_HOUR)
						*pbDST = true;
					else
						*pbNext = true;
				}

				if	(*pbDST && (tmCheck.tm_mon == 9) && (tmCheck.tm_wday == 0) && (tmCheck.tm_mday > 24))
				{
					if	(tmCheck.tm_hour >= USA_HOUR - 1)
						*pbDST = false;
					else
						*pbNext = true;
				}

				break;
			}

			case europe:
			{
				if	(!*pbDST && (tmCheck.tm_mon == 2) && (tmCheck.tm_wday == 0) && (tmCheck.tm_mday > 24))
				{
					if	(tmCheck.tm_hour >= EUROPE_HOUR)
						*pbDST = true;
					else
						*pbNext = true;
				}

				if	(*pbDST && (tmCheck.tm_mon == 9) && (tmCheck.tm_wday == 0) && (tmCheck.tm_mday > 24))
				{
					if	(tmCheck.tm_hour >= EUROPE_HOUR -1)
						*pbDST = false;
					else
						*pbNext = true;
				}

				break;
			}
		}
	}

	if	(*pbDST && !tmCheck.tm_isdst)
		return	false;
	else if	(!*pbDST && tmCheck.tm_isdst)
		return	false;

	return	true;
}


bool TC1(QA_THREAD_PARAM)
{
	char		szMsg[400];
	tm			tmTest[NUM_FAILURES];
	tm*			ptm = tmTest;
	DSTType		enumDSTType = usa;
	bool		bDST = false, bNext = false, bRet = true;

	if	(sizeof(time_t) == 4)
	{
		// test mktime for boundries that should fail
		tmInitFailures(tmTest);
		ptm = tmTest;

		for	(int i=0; i<NUM_FAILURES; ++i)
		{
			if	(!Compare<time_t, time_t>(mktime(ptm), time_t(TM_MKTIME_FAILURE)))
			{
				sprintf(szMsg, "FAILED: mktime ( %d/%d/%d ) did not return -1", 
								ptm->tm_mon+1, ptm->tm_mday, ptm->tm_year+1900);
				Fail(__LINE__, __FILE__, szMsg);
				bRet = false;
			}

			++ptm;
		}
	}

    return bRet;
}

bool TC2(QA_THREAD_PARAM)
{
	bool		bRet = true;

#if (_MSC_VER > 1200)
	char		szMsg[400];
	tm			tmTest[NUM_FAILURES];
	tm*			ptm = tmTest;
	DSTType		enumDSTType = usa;
	bool		bDST = false, bNext = false;

	// test _mktime64 for boundries that should fail
	tmInit64Failures(tmTest);
	ptm = tmTest;

	for	(int i=0; i<NUM_FAILURES; ++i)
	{
		if	(!Compare<__time64_t, __time64_t>(_mktime64(ptm), __time64_t(TM_MKTIME_FAILURE)))
		{
			sprintf(szMsg, "FAILED: _mktime64 ( %d/%d/%d ) did not return -1", 
							ptm->tm_mon+1, ptm->tm_mday, ptm->tm_year+1900);
			Fail(__LINE__, __FILE__, szMsg);
			bRet = false;
		}

		++ptm;
	}
#endif // (_MSC_VER > 1200)

    return bRet;
}

bool TC3(QA_THREAD_PARAM)
{
	char		szMsg[400];
	tm			tmTest[MAX_32TM_YEARS * TM_NO_DAYS_CHECKED];
	tm*			ptm = tmTest;
	DSTType		enumDSTType = usa;
	int			i, j, nHour;
	bool		bDST = false, bNext = false, bRet = true;

	if	(sizeof(time_t) == 4)
	{
		for	(nHour=0; nHour<24; ++nHour)
		{
			// test mktime DST change boundries for all years
			tmInit(tmTest, nHour);
			ptm = tmTest;

			for	(i=0; i<MAX_32TM_YEARS; ++i)
			{
				bDST = false;
				bNext = false;

				for	(j=0; j<TM_NO_DAYS_CHECKED; ++j)
				{
					if	(Compare<time_t, time_t>(mktime(ptm), time_t(TM_MKTIME_FAILURE)))
					{
						sprintf(szMsg, "FAILED: mktime ( %d/%d/%d  %d hundred hours ) returned -1", 
										ptm->tm_mon+1, ptm->tm_mday, ptm->tm_year+1900, ptm->tm_hour);
						Fail(__LINE__, __FILE__, szMsg);
						bRet = false;
					}
					else
					{
						if	(Compare<bool, bool>(CheckTM(enumDSTType, *ptm, &bDST, &bNext), 0))
						{
							sprintf(szMsg, "FAILED: mktime ( %d/%d/%d  %d hundred hours ), tm_isdst = %d", 
											ptm->tm_mon+1, ptm->tm_mday, ptm->tm_year+1900, ptm->tm_hour, ptm->tm_isdst);
							Fail(__LINE__, __FILE__, szMsg);
							bRet = false;
						}
					}
					
					++ptm;
				}
			}
		}
	}

    return bRet;
}

bool TC4(QA_THREAD_PARAM)
{
	bool		bRet = true;

#if (_MSC_VER > 1200)
	char		szMsg[400];
	tm			tmTest[MAX_CENTURIES * TM_NO_DAYS_CHECKED * TM_NO_YEARS_CHECKED];
	tm*			ptm = tmTest;
	DSTType		enumDSTType = usa;
	int			i, j, k, nHour;
	bool		bDST = false, bNext = false;

	for	(nHour=0; nHour<24; ++nHour)
	{
		// test _mktime64 DST change boundries for years 
		// within 8 years of the turn of a century.
		tm64Init(tmTest, nHour);
		ptm = tmTest;

		for	(i=0; i<MAX_CENTURIES; ++i)
		{
			for	(j=0; j<TM_NO_YEARS_CHECKED; ++j)
			{
				bDST = false;
				bNext = false;

				for	(k=0; k<TM_NO_DAYS_CHECKED; ++k)
				{
					if	(Compare<__time64_t, __time64_t>(_mktime64(ptm), __time64_t(TM_MKTIME_FAILURE)))
					{
						sprintf(szMsg, "FAILED: _mktime64 ( %d/%d/%d  %d hundred hours ) returned -1", 
										ptm->tm_mon+1, ptm->tm_mday, ptm->tm_year+1900, ptm->tm_hour);
						Fail(__LINE__, __FILE__, szMsg);
						bRet = false;
					}
					else
					{
						if	(Compare<bool, bool>(CheckTM(enumDSTType, *ptm, &bDST, &bNext), 0))
						{
							sprintf(szMsg, "FAILED: _mktime64 ( %d/%d/%d  %d hundred hours ), tm_isdst = %d", 
											ptm->tm_mon+1, ptm->tm_mday, ptm->tm_year+1900, ptm->tm_hour, ptm->tm_isdst);
							Fail(__LINE__, __FILE__, szMsg);
							bRet = false;
						}
					}

					++ptm;
				}
			}
		}

		tm64InitBoundries(tmTest, nHour);
		ptm = tmTest;

		for	(i=0; i<NUM_BOUNDRIES*2; ++i)
		{
			bDST = false;
			bNext = false;

			for	(k=0; k<TM_NO_DAYS_CHECKED; ++k)
			{
				if	(Compare<__time64_t, __time64_t>(_mktime64(ptm), __time64_t(TM_MKTIME_FAILURE)))
				{
					sprintf(szMsg, "FAILED: _mktime64 ( %d/%d/%d  %d hundred hours ) returned -1", 
									ptm->tm_mon+1, ptm->tm_mday, ptm->tm_year+1900, ptm->tm_hour);
					Fail(__LINE__, __FILE__, szMsg);
					bRet = false;
				}
				else
				{
					if	(Compare<bool, bool>(CheckTM(enumDSTType, *ptm, &bDST, &bNext), 0))
					{
						sprintf(szMsg, "FAILED: _mktime64 ( %d/%d/%d  %d hundred hours ), tm_isdst = %d", 
										ptm->tm_mon+1, ptm->tm_mday, ptm->tm_year+1900, ptm->tm_hour, ptm->tm_isdst);
						Fail(__LINE__, __FILE__, szMsg);
						bRet = false;
					}
				}

				++ptm;
			}
		}
	}
#endif // (_MSC_VER > 1200)

    return bRet;
}

static unsigned __stdcall mktime2MkTime1(void* qaThreadParam = 0)
{
	QA_BEGIN_TC(1)

		QATTrace1(_T("mktime()"));
		QATCheck(TC1(QA_THREAD_PARAM_NAME));

	QA_END_TC(1)

	return 0;
}

static unsigned __stdcall mktime2MkTime2(void* qaThreadParam = 0)
{
	QA_BEGIN_TC(2)

		QATTrace1(_T("mktime()"));
		QATCheck(TC2(QA_THREAD_PARAM_NAME));

	QA_END_TC(2)

	return 0;
}

static unsigned __stdcall mktime2MkTime3(void* qaThreadParam = 0)
{
	QA_BEGIN_TC(3)

		QATTrace1(_T("mktime()"));
		QATCheck(TC3(QA_THREAD_PARAM_NAME));

	QA_END_TC(3)

	return 0;
}

static unsigned __stdcall mktime2MkTime4(void* qaThreadParam = 0)
{
	QA_BEGIN_TC(4)

		QATTrace1(_T("mktime()"));
		QATCheck(TC4(QA_THREAD_PARAM_NAME));

	QA_END_TC(4)

	return 0;
}


// helper functions.
//
/*
 *  dstInit() takes dstTest array an array of structures made up of 16 type "tm" structures
 *  initializes tm fields and copies the time fields from the parameters provided.  
 *  Also initializes the year field from 8 years before the turn of the century to 8 years 
 *  after the century.  Starts at the 21st century and will continue for MAX_CENTURIES centuries.
 */

TestFunc mktime2TestFuncList[] =
{
    mktime2MkTime1,
    mktime2MkTime2,
    mktime2MkTime3,
    mktime2MkTime4
};


int mktime2Entry()
{
    int nTests = (sizeof(mktime2TestFuncList)/sizeof(mktime2TestFuncList[0]));
    int iTest = 0;
    bool bRunTerm = false;

    if (mktime2TestFuncList[0] == 0)
    {
        if (nTests == 1) return 3; /* error, not enough data */
        /* if the 0th element is zero, then 1st element is a */
        /* thread kickoff function */
        iTest = 2;
        if (mktime2TestFuncList[1] != 0)
            mktime2TestFuncList[1](0);
    }

    if (nTests >= 4)
    {
        if (mktime2TestFuncList[2] == 0)
        {
            bRunTerm = true;
            iTest = 4;
        }
    }

    for (; iTest < nTests; iTest++)
        if(mktime2TestFuncList[iTest] != 0)
            mktime2TestFuncList[iTest](0);
    if (bRunTerm)
    {
        if (!mktime2TestFuncList[3])
            DbgPrint("Term function NULL!\n");
        else
            mktime2TestFuncList[3](0);
    }
    int ret = GetTestFailure() ? 1 : 0;
    ReportTest(false);
    ClearFailures();
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\time\mktime1.cpp ===
#define QaLib mktime1NameSpace

#include <time.h>
#include "qalibrary.h"

/*@ mktime

Test Cases:
-----------
 1-5. timeptr points to a tm struct in which all values are in correct      
      range, and the time represented is before midnight 1/1/1970 or after   
      midnight 2/5/2036 (32bit) OR 12/31/2999 (64bit).  The return value from 
      mktime() should be (time_t)-1.
     
 6. timeptr points to a tm struct in which all values are in correct        
    range, and the time represented is after midnight 1/1/1970 and before  
    midnight 2/5/2036.  Verify that the struct's values have not been      
    changed.   Verify that the return value represents the same time as the 
    struct.                                     
                                         
 7-8. timeptr points to a tm struct in which all values but tm_wday and      
      tm_yday are in correct range, and the time represented is after       
      midnight 1/1/70. Verify that the values for tm_wday and/or tm_yday    
      are in range.                                 
                                         
 9. timeptr points to a tm struct in which some, possibly all, fields are  
    out-of-range.  If -1 is not returned, check that the structure is      
    complete and normalized (in range).        
    
10. Regression test from Plum Hall C library test suite. 

11. 32bit/64bit leap year recognition for year 2000. 

12-17. 64bit leap year recognition.
       12-15: not a leap year: 2100, 2200, 2300, 2500.
       16-17: leap year: 2400, 2800.
 
@*/

// macros
//
#define NOT_EQUAL 1
#define EQUAL     0

/*
 *  Structures for tests of type 1 above.
 */

struct tm A[] = {  { 12, 32, 15, 20,  4, 50, 0,  0, -1 },
           { 59, 59, 15, 31, 11, 69, 0,  0,  0 },
           {  0,  0,  0,  1,  0,  0, 0,  0,  0 },
           { 34, 45,  8, 21,  7, 29, 0,  0, -1 } };

// 32bit version.
struct tm A1[] = {  
    { 21, 21, 21, 21,  2,151, 0,     0, -1 },
    {  0,  0,  0,  6,  1,138, 0,     0, -1 }
};

// 64bit version.
struct tm A2[] = {  
    { 21, 21, 21, 21,  2,151, 0,     0, 0 },
    {  0,  0,  0,  6,  1,138, 0,     0, 0 }
};


/*
 *  Structures for tests of type 2 above.  These structures are also used
 *  when testing type 3.
 */

struct tm B[] = { { 12, 32, 15, 20,  1, 98, 5,  50,  0 },
          {  1,  1,  1, 28,  6, 80, 1, 209,  1 },
          { 59, 59, 23,  8,  8,130, 0, 250,  1 },
          { 29, 38,  8, 19, 10,110, 5, 322,  0 } };


/*
 *  Structures for tests of type 3 above.
 */

struct tm C[] = {  { 53, 22,  5, 10,  8,125, 0,  0, -1 },
           { 59, 59, 23, 31, 11, 99, 0,  0, -1 },
           { 50, 40, 20, 30, 10,100, 0,  0, -1 },
           {  0,  0,  0,  1,  0, 70, 0,  0, -1 },
           { 28, 36, 18, 24,  5,104, 0,  0, -1 } };


/*
 *  Structures for tests of type 4 above.
 */

struct tm D[] = {  { 95, 22, -5, 10,  8,125, 9,  0, -1 },
           { 12, 12, 12, 12, 12, 99, 0, 12, -1 },
           {  0,  0,  0,  1,  0,170, 0,  0, -1 },
           { 45, 66,  9, 27,  7, 89, 0,  0, -1 },
           {  9, 41, 20, 66, 11,100, 1, 66, -1 },
           { 33, 55, 11,  1, -4,111, 0,  0, -1 },
           { 99,-21, 33,  9, 20, 91, 5,  5, -1 },
           {-86,  1, 42, 18,  1, 76, 0,  0, -1 },
           { 28, 36, 18,-24,  5,104,-6, -6, -1 } };


void copyStruct(struct tm *src, struct tm *dest);
int  compareStruct(struct tm *t1, struct tm *t2);


// Helper test functions.  These are template functions to test both 32bit
// and 64bit.
//

// all should fail.
//
template <class TT, class TF> bool TC1(TF timeFunc, QA_THREAD_PARAM, TT tt = 0)
{
    struct tm   Temp;

    for (int i = 0; i < sizeof(A)/sizeof(A[0]); i++)
    {
        copyStruct(&Temp, &A[i]);

        if (!QATCheckE(timeFunc(&Temp), (TT)-1))
        {
            QATFail(i);
            return false;
        }
    }

    return true;
}

template <class TT, class TF1, class TF2> 
bool TC6(TF1 mktimeFunc, TF2 localtimeFunc, QA_THREAD_PARAM, TT tt = 0)
{
    TT          result;
    struct tm   Temp;
    struct tm*  ptr;
    bool        retVal = true;

    for (int i = 0; i < sizeof(B)/sizeof(B[0]); i++)
    {
        copyStruct( &Temp, &B[i] );
    
        result = mktimeFunc(&Temp);
        if ( result == (TT)-1 )
            QATFail( 10 + i );
        else
        {
            if ( compareStruct( &Temp, &B[i] ) == NOT_EQUAL )
                QATFail( 20 + i );
    
            ptr = localtimeFunc( &result );
            if ( ptr == NULL )
                QATFail( 30 + i );
            else if ( compareStruct( ptr, &B[i] ) == NOT_EQUAL )
                QATFail( 40 + i );
            else
            {
                retVal &= true;
                continue;
            }
        }
        retVal = false;
    }

    return retVal;
}

template <class TT, class TF> bool TC7(TF timeFunc, QA_THREAD_PARAM, TT tt = 0)
{
    TT          result;
    struct tm   Temp;
    bool        retVal = true;

    for (int i = 0; i < sizeof(C)/sizeof(C[0]); i++)
    {
        copyStruct( &Temp, &C[i] );
    
        result = timeFunc( &Temp );
        if ( result == (TT)-1 )
        {
            QATFail( 10 + i );
            retVal = false;
        }
        else
        {
            if ( (Temp.tm_wday < 0) || (Temp.tm_wday > 6) )
            {
                QATFail( 20 + i );
                retVal = false;
            }
    
            if ( (Temp.tm_yday < 0) || (Temp.tm_yday > 365) )
            {
                QATFail( 30 + i );
                retVal = false;
            }
        }
    }

    return retVal;
}

template <class TT, class TF> bool TC8(TF timeFunc, QA_THREAD_PARAM, TT tt = 0)
{
    TT          result;
    struct tm   Temp;
    bool        retVal = true;

    for (int i = 0; i < sizeof(B)/sizeof(B[0]); i++)
    {
        copyStruct( &Temp, &B[i] );
    
        result = timeFunc( &Temp );
        if ( result == (TT)-1 )
        {
            QATFail( 10 + i );
            retVal = false;
        }
        else
        {
            if ( Temp.tm_wday != B[i].tm_wday )
            {
                QATFail( 20 + i );
                retVal = false;
            }
    
            if ( Temp.tm_yday != B[i].tm_yday )
            {
                QATFail( 30 + i );
                retVal = false;
            }
        }
    }

    return retVal;
}

template <class TT, class TF> bool TC9(TF timeFunc, QA_THREAD_PARAM, TT tt = 0)
{
    TT          result;
    struct tm   Temp;
    bool        retVal = true;

    for (int i = 0; i < sizeof(D)/sizeof(D[0]); i++)
    {
        copyStruct( &Temp, &D[i] );
    
        result = timeFunc( &Temp );
        if ( result != (TT)-1 )
        {
            if ( (Temp.tm_sec < 0) || (Temp.tm_sec > 59) )
            {
                QATFail( 10 + i );
                retVal = false;
            }
    
            if ( (Temp.tm_min < 0) || (Temp.tm_min > 59) )
            {
                QATFail( 20 + i );
                retVal = false;
            }
    
            if ( (Temp.tm_hour < 0) || (Temp.tm_hour > 23) )
            {
                QATFail( 30 + i );
                retVal = false;
            }
    
            if ( (Temp.tm_mon < 0) || (Temp.tm_mon > 11) )
            {
                QATFail( 40 + i );
                retVal = false;
            }
    
            if ( (Temp.tm_year < 70) || (Temp.tm_wday > 1099) )
            {
                QATFail( 50 + i );
                retVal = false;
            }
    
            if ( (Temp.tm_wday < 0) || (Temp.tm_wday > 6) )
            {
                QATFail( 60 + i );
                retVal = false;
            }
    
            if ( (Temp.tm_wday < 0) || (Temp.tm_wday > 6) )
            {
                QATFail( 70 + i );
                retVal = false;
            }
    
            if ( (Temp.tm_yday < 0) || (Temp.tm_yday > 365) )
            {
                QATFail( 80 + i );
                retVal = false;
            }
        }
    }

    return retVal;
}

template <class TT, class TF> bool TC10(TF timeFunc, QA_THREAD_PARAM, TT tt = 0)
{
    struct tm   tm1;
    TT          time_t1, time_t2;
    bool        retVal = true;

    /* make sure that all of the required fields are there */
    tm1.tm_sec = 0;
    tm1.tm_min = 49;
    tm1.tm_hour = 20;
    tm1.tm_mday = 12;
    tm1.tm_mon = 8;
    tm1.tm_year = 76;
    tm1.tm_wday = -99;
    tm1.tm_yday = -99;
    tm1.tm_isdst = 1;

    /*
     * compute the difference between two times
     */
    time_t1 = timeFunc(&tm1);
    tm1.tm_sec = 5;
    time_t2 = timeFunc(&tm1);

    if( time_t1 == time_t2 )
    {
        _tprintf( _T("mktime failed\n") );
        retVal = false;
    }
    else
    {
        if(!QATCheckE((time_t1 - time_t2), (TT)-5))
        {
            _tprintf( _T("difftime failed\n") );
            retVal = false;
        }
    }
    return retVal;
}

template <class TT, class TF> bool TC11(TF timeFunc, QA_THREAD_PARAM, TT tt = 0)
{
    struct tm   tm1;
    bool        retVal = true;

    // set time to be 2/29/2000.
    //
    tm1.tm_sec = 0;
    tm1.tm_min = 0;
    tm1.tm_hour = 0;
    tm1.tm_mday = 29;
    tm1.tm_mon = 1;
    tm1.tm_year = 100;
    tm1.tm_wday = -1;
    tm1.tm_yday = -1;
    tm1.tm_isdst = 0;
    
    if (QATCheckNE(timeFunc(&tm1), (TT)-1))
    {
        QATCheckE(tm1.tm_mon, 1);
        QATCheckE(tm1.tm_mday, 29);
    }
    else
        retVal = false;

    return retVal;
}

static unsigned __stdcall mktime1MkTime1(void* qaThreadParam = 0)
{
    QA_BEGIN_TC(1)

	if	(sizeof(time_t) == 4)
	{
        QATTrace1(_T("mktime()"));
        QATCheck(TC1<time_t>(mktime, QA_THREAD_PARAM_NAME));
	}

#if (_MSC_VER > 1200)
        QATTrace1(_T("mktime64()"));
        QATCheck(TC1<__time64_t>(_mktime64, QA_THREAD_PARAM_NAME));
#endif  /* (_MSC_VER > 1200) */
    
    QA_END_TC(1)

    QA_BEGIN_TC(2)

	if	(sizeof(time_t) == 4)
	{
        struct tm   temp = A1[0];

        QATTrace1(_T("mktime()"));
        QATCheckE(mktime(&temp), (time_t)-1);
	}
    
    QA_END_TC(2)

    QA_BEGIN_TC(3)

	if	(sizeof(time_t) == 4)
	{
        struct tm   temp = A1[1];
    
        QATTrace1(_T("mktime()"));
        QATCheckE(mktime(&temp), (time_t)-1);
	}
    
    QA_END_TC(3)

    QA_BEGIN_TC(4)

#if (_MSC_VER > 1200)

		struct tm   temp = A1[0];
    
        QATTrace1(_T("mktime64()"));
        QATCheckNE(_mktime64(&temp), (__time64_t)-1);
#endif  /* (_MSC_VER > 1200) */
    
    QA_END_TC(4)

    QA_BEGIN_TC(5)

#if (_MSC_VER > 1200)   

		struct tm   temp = A1[1];
 
        QATTrace1(_T("mktime64()"));
        QATCheckNE(_mktime64(&temp), (__time64_t)-1);
#endif  /* (_MSC_VER > 1200) */
    
    QA_END_TC(5)

    return 0;
}

static unsigned __stdcall mktime1MkTime2(void* qaThreadParam = 0)
{
    QA_BEGIN_TC(6)

	if	(sizeof(time_t) == 4)
	{
        QATTrace1(_T("mktime()"));
        QATCheck(TC6<time_t>(mktime, localtime, QA_THREAD_PARAM_NAME));
	}

#if (_MSC_VER > 1200)
        QATTrace1(_T("mktime64()"));
        QATCheck(TC6<__time64_t>(_mktime64, _localtime64, QA_THREAD_PARAM_NAME));
#endif  /* (_MSC_VER > 1200) */
    
    QA_END_TC(6)
    return 0;
}

static unsigned __stdcall mktime1MkTime3(void* qaThreadParam = 0)
{
    QA_BEGIN_TC(7)

	if	(sizeof(time_t) == 4)
	{
        QATTrace1(_T("mktime()"));
        QATCheck(TC7<time_t>(mktime, QA_THREAD_PARAM_NAME));
	}

#if (_MSC_VER > 1200)
        QATTrace1(_T("mktime64()"));
        QATCheck(TC7<__time64_t>(_mktime64, QA_THREAD_PARAM_NAME));
#endif  /* (_MSC_VER > 1200) */
    
    QA_END_TC(7)

    QA_BEGIN_TC(8)

	if	(sizeof(time_t) == 4)
	{
        QATTrace1(_T("mktime()"));
        QATCheck(TC8<time_t>(mktime, QA_THREAD_PARAM_NAME));
	}

#if (_MSC_VER > 1200)
        QATTrace1(_T("mktime64()"));
        QATCheck(TC8<__time64_t>(_mktime64, QA_THREAD_PARAM_NAME));
#endif  /* (_MSC_VER > 1200) */
    
    QA_END_TC(8)

    return 0;
}

static unsigned __stdcall mktime1MkTime4(void* qaThreadParam = 0)
{
    QA_BEGIN_TC(9)

	if	(sizeof(time_t) == 4)
	{
        QATTrace1(_T("mktime()"));
        QATCheck(TC9<time_t>(mktime, QA_THREAD_PARAM_NAME));
	}
		
#if (_MSC_VER > 1200)
        QATTrace1(_T("mktime64()"));
        QATCheck(TC9<__time64_t>(_mktime64, QA_THREAD_PARAM_NAME));
#endif  /* (_MSC_VER > 1200) */
    
    QA_END_TC(9)
    return 0;
}

static unsigned __stdcall mktime1MkTime5(void* qaThreadParam = 0)
{
    QA_BEGIN_TC(10)

	if	(sizeof(time_t) == 4)
	{
        QATTrace1(_T("mktime()"));
        QATCheck(TC10<time_t>(mktime, QA_THREAD_PARAM_NAME));
	}
		
#if (_MSC_VER > 1200)
        QATTrace1(_T("mktime64()"));
        QATCheck(TC10<__time64_t>(_mktime64, QA_THREAD_PARAM_NAME));
#endif  /* (_MSC_VER > 1200) */
    
    QA_END_TC(10)
    return 0;
}

static unsigned __stdcall mktime1MkTime6(void* qaThreadParam = 0)
{
    QA_BEGIN_TC(11)

	if	(sizeof(time_t) == 4)
	{
        QATTrace1(_T("mktime()"));
        QATCheck(TC11<time_t>(mktime, QA_THREAD_PARAM_NAME));
	}
		
#if (_MSC_VER > 1200)
        QATTrace1(_T("mktime64()"));
        QATCheck(TC11<__time64_t>(_mktime64, QA_THREAD_PARAM_NAME));
#endif  /* (_MSC_VER > 1200) */
    
    QA_END_TC(11)
    return 0;
}

static unsigned __stdcall mktime1MkTime7(void* qaThreadParam = 0)
{
    QA_BEGIN_TC(12)

#if (_MSC_VER > 1200)
        QATTrace1(_T("mktime64()"));
    
        struct tm   tm1;
    
        // set time to be 2/29/2100.
        //
        tm1.tm_sec = 0;
        tm1.tm_min = 0;
        tm1.tm_hour = 0;
        tm1.tm_mday = 29;
        tm1.tm_mon = 1;
        tm1.tm_year = 200;
        tm1.tm_wday = -1;
        tm1.tm_yday = -1;
        tm1.tm_isdst = 0;
        
        if (QATCheckNE(_mktime64(&tm1), (__time64_t)-1))
        {
            QATCheckE(tm1.tm_mon, 2);
            QATCheckE(tm1.tm_mday, 1);
        }
#endif  /* (_MSC_VER > 1200) */

    QA_END_TC(12)

    QA_BEGIN_TC(13)

#if (_MSC_VER > 1200)
        QATTrace1(_T("mktime64()"));
    
        struct tm   tm1;
    
        // set time to be 2/29/2200.
        //
        tm1.tm_sec = 0;
        tm1.tm_min = 0;
        tm1.tm_hour = 0;
        tm1.tm_mday = 29;
        tm1.tm_mon = 1;
        tm1.tm_year = 300;
        tm1.tm_wday = -1;
        tm1.tm_yday = -1;
        tm1.tm_isdst = 0;
        
        if (QATCheckNE(_mktime64(&tm1), (__time64_t)-1))
        {
            QATCheckE(tm1.tm_mon, 2);
            QATCheckE(tm1.tm_mday, 1);
        }
#endif  /* (_MSC_VER > 1200) */
    
    QA_END_TC(13)

    QA_BEGIN_TC(14)

#if (_MSC_VER > 1200)
        QATTrace1(_T("mktime64()"));
    
        struct tm   tm1;
    
        // set time to be 2/29/2300.
        //
        tm1.tm_sec = 0;
        tm1.tm_min = 0;
        tm1.tm_hour = 0;
        tm1.tm_mday = 29;
        tm1.tm_mon = 1;
        tm1.tm_year = 400;
        tm1.tm_wday = -1;
        tm1.tm_yday = -1;
        tm1.tm_isdst = 0;
        
        if (QATCheckNE(_mktime64(&tm1), (__time64_t)-1))
        {
            QATCheckE(tm1.tm_mon, 2);
            QATCheckE(tm1.tm_mday, 1);
        }
#endif  /* (_MSC_VER > 1200) */
    
    QA_END_TC(14)

    QA_BEGIN_TC(15)

#if (_MSC_VER > 1200)
        QATTrace1(_T("mktime64()"));
    
        struct tm   tm1;
    
        // set time to be 2/29/2500.
        //
        tm1.tm_sec = 0;
        tm1.tm_min = 0;
        tm1.tm_hour = 0;
        tm1.tm_mday = 29;
        tm1.tm_mon = 1;
        tm1.tm_year = 600;
        tm1.tm_wday = -1;
        tm1.tm_yday = -1;
        tm1.tm_isdst = 0;
        
        if (QATCheckNE(_mktime64(&tm1), (__time64_t)-1))
        {
            QATCheckE(tm1.tm_mon, 2);
            QATCheckE(tm1.tm_mday, 1);
        }
#endif  /* (_MSC_VER > 1200) */
    
    QA_END_TC(15)

    return 0;
}

static unsigned __stdcall mktime1MkTime8(void* qaThreadParam = 0)
{
    QA_BEGIN_TC(16)

#if (_MSC_VER > 1200)
        QATTrace1(_T("mktime64()"));
    
        struct tm   tm1;
    
        // set time to be 2/29/2400.
        //
        tm1.tm_sec = 0;
        tm1.tm_min = 0;
        tm1.tm_hour = 0;
        tm1.tm_mday = 29;
        tm1.tm_mon = 1;
        tm1.tm_year = 500;
        tm1.tm_wday = -1;
        tm1.tm_yday = -1;
        tm1.tm_isdst = 0;
        
        if (QATCheckNE(_mktime64(&tm1), (__time64_t)-1))
        {
            QATCheckE(tm1.tm_mon, 1);
            QATCheckE(tm1.tm_mday, 29);
        }
#endif  /* (_MSC_VER > 1200) */

    QA_END_TC(16)

    QA_BEGIN_TC(17)

#if (_MSC_VER > 1200)
        QATTrace1(_T("mktime64()"));
    
        struct tm   tm1;
    
        // set time to be 2/29/2800.
        //
        tm1.tm_sec = 0;
        tm1.tm_min = 0;
        tm1.tm_hour = 0;
        tm1.tm_mday = 29;
        tm1.tm_mon = 1;
        tm1.tm_year = 900;
        tm1.tm_wday = -1;
        tm1.tm_yday = -1;
        tm1.tm_isdst = 0;
        
        if (QATCheckNE(_mktime64(&tm1), (__time64_t)-1))
        {
            QATCheckE(tm1.tm_mon, 1);
            QATCheckE(tm1.tm_mday, 29);
        }
#endif  /* (_MSC_VER > 1200) */

    QA_END_TC(17)

    return 0;
}

// helper functions.
//
/*
 *  copyStruct() takes two pointers to structures of type "tm" and
 *  copies the fields of src to the fields of dest.
 */

void copyStruct(struct tm *src, struct tm *dest)
{
    src->tm_sec   = dest->tm_sec;
    src->tm_min   = dest->tm_min;
    src->tm_hour  = dest->tm_hour;
    src->tm_mday  = dest->tm_mday;
    src->tm_mon   = dest->tm_mon;
    src->tm_year  = dest->tm_year;
    src->tm_wday  = dest->tm_wday;
    src->tm_yday  = dest->tm_yday;
    src->tm_isdst = dest->tm_isdst;
}


/*
 *  compareStruct() takes two pointers to structures of type "tm" and
 *  compares the fields of t1 to those of t2.
 */

int compareStruct(struct tm *t1, struct tm *t2)
{
    if ( t1->tm_sec   != t2->tm_sec   ||
         t1->tm_min   != t2->tm_min   ||
         t1->tm_hour  != t2->tm_hour  ||
         t1->tm_mday  != t2->tm_mday  ||
         t1->tm_mon   != t2->tm_mon   ||
         t1->tm_year  != t2->tm_year  ||
         t1->tm_wday  != t2->tm_wday  ||
         t1->tm_yday  != t2->tm_yday  ||
         t1->tm_isdst != t2->tm_isdst )
        return( NOT_EQUAL );
    else
        return( EQUAL );
}

TestFunc mktime1TestFuncList[] =
{
    mktime1MkTime1,
    mktime1MkTime2,
    mktime1MkTime3,
    mktime1MkTime4,
    mktime1MkTime5,
    mktime1MkTime6,
    mktime1MkTime7,
    mktime1MkTime8
};


int mktime1Entry()
{
    int nTests = (sizeof(mktime1TestFuncList)/sizeof(mktime1TestFuncList[0]));
    int iTest = 0;
    bool bRunTerm = false;

    if (mktime1TestFuncList[0] == 0)
    {
        if (nTests == 1) return 3; /* error, not enough data */
        /* if the 0th element is zero, then 1st element is a */
        /* thread kickoff function */
        iTest = 2;
        if (mktime1TestFuncList[1] != 0)
            mktime1TestFuncList[1](0);
    }

    if (nTests >= 4)
    {
        if (mktime1TestFuncList[2] == 0)
        {
            bRunTerm = true;
            iTest = 4;
        }
    }

    for (; iTest < nTests; iTest++)
        if(mktime1TestFuncList[iTest] != 0)
            mktime1TestFuncList[iTest](0);
    if (bRunTerm)
    {
        if (!mktime1TestFuncList[3])
            DbgPrint("Term function NULL!\n");
        else
            mktime1TestFuncList[3](0);
    }
    int ret = GetTestFailure() ? 1 : 0;
    ReportTest(false);
    ClearFailures();
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\time\sources.inc ===
TARGETTYPE=LIBRARY
TARGETPATH=..\..\lib

SOURCES=\
	gmtime1.cpp \
	localtime1.cpp \
	mktime1.cpp \
	mktime2.cpp \
	futime1.cpp \
	futime2.cpp \
	utime1.cpp \
	utime2.cpp \
	ftime1.cpp \
	time1.cpp \
	ctime1.cpp \
	CRunTime.cpp \
    testcrt.cpp \
	drv.cpp

# excluded mktime3.cpp, strftime1.cpp

INCLUDES=$(BASEDIR)\private\test\crttests\test\clib;$(SDK_INC_PATH)

MSC_WARNING_LEVEL=/W2
MSC_OPTIMIZATION=/Od

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\time\testcrt.h ===
struct DTMINFO {
	int nYear;
	int nMonth;
	int nDay;
	int nDayOfWeek;
	int nHour;
	int nMinute;
	int nSecond;
};

DTMINFO tDates[];

struct LangName {
	DWORD	wLANGID;
	DWORD	wSUBLANGID;
	_TCHAR* pszLangName;
};

LangName LangNameTable[];

BOOL compare(_TCHAR *sText, int x, int y);

void PrintPassFail(BOOL bFailed);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\time\testcrt.cpp ===
#include <xtl.h>
#include <stdio.h>
#include <tchar.h>
//#include <afx.h>
//#include <afxdisp.h>
#include "testcrt.h"
#include "CRunTime.h"
//#include "CTime.h"
//#include "COleDT.h"

//CStdioFile f1;
FILE * f1;

DTMINFO tDates[] = {
	{1996,2,28,4,12,0,0},
	{1996,2,29,5,12,0,0},
	{1996,3,1,6,12,0,0},
	{1997,2,28,6,12,0,0},
	{1997,3,1,7,12,0,0},
	{1998,2,28,7,12,0,0},
	{1998,3,1,1,12,0,0},
	{1998,4,3,6,12,0,0},
	{1998,4,4,7,12,0,0},
	{1998,4,5,1,1,59,58},
	{1998,4,5,1,3,0,0},
	{1998,4,6,2,12,0,0},
	{1998,10,23,6,12,0,0},
	{1998,10,24,7,12,0,0},
	{1998,10,25,1,1,59,58},
	{1998,10,25,1,2,0,0},
	{1998,10,26,2,12,0,0},
	{1999,2,28,1,12,0,0},
	{1999,3,1,2,12,0,0},
	{1999,4,2,6,12,0,0},
	{1999,4,3,7,12,0,0},
	{1999,4,4,1,1,59,58},
	{1999,4,4,1,3,0,0},
	{1999,4,5,2,12,0,0},
	{1999,10,29,6,12,0,0},
	{1999,10,30,7,12,0,0},
	{1999,10,31,1,1,59,58},
	{1999,10,31,1,2,0,0},
	{1999,11,1,2,12,0,0},
	{1999,12,31,6,12,0,0},
	{2000,1,1,7,12,0,0},
	{2000,2,28,2,12,0,0},
	{2000,2,29,3,12,0,0},
	{2000,3,1,4,12,0,0},
	{2000,3,31,6,12,0,0},
	{2000,4,1,7,12,0,0},
	{2000,4,2,1,1,59,58},
	{2000,4,2,1,3,0,0},
	{2000,4,3,2,12,0,0},
	{2000,10,27,6,12,0,0},
	{2000,10,28,7,12,0,0},
	{2000,10,29,1,1,59,58},
	{2000,10,29,1,2,0,0},
	{2000,10,30,2,12,0,0},
	{2000,12,31,1,12,0,0},
	{2001,1,1,2,12,0,0},
	{2001,2,28,4,12,0,0},
	{2001,3,1,5,12,0,0},
	{2001,3,30,6,12,0,0},
	{2001,3,31,7,12,0,0},
	{2001,4,1,1,1,59,58},
	{2001,4,1,1,3,0,0},
	{2001,4,2,2,12,0,0},
	{2001,4,6,6,12,0,0},
	{2001,4,7,7,12,0,0},
	{2001,4,8,1,1,59,58},
	{2001,4,8,1,3,0,0},
	{2001,4,9,2,12,0,0},
	{2001,10,26,6,12,0,0},
	{2001,10,27,7,12,0,0},
	{2001,10,28,1,1,59,58},
	{2001,10,28,1,2,0,0},
	{2001,10,29,2,12,0,0},
	{0,0,0,0,0,0,0}
};

LangName LangNameTable[] = {
		//*0x01,0x00,	_T("Arabic"), 
		//*0x01,0x01,	_T("Arabic (Saudi Arabia)"),
		//*0x01,0x02,	_T("Arabic (Iraq)"),
		//*0x01,0x03,	_T("Arabic (Egypt)"),
		//*0x01,0x04,	_T("Arabic (Libya)"),
		0x01,0x05,	_T("Arabic (Algeria)"),
		0x01,0x06,	_T("Arabic (Morocco)"),
		0x01,0x07,	_T("Arabic (Tunisia)"),
		//*0x01,0x08,	_T("Arabic (Oman)"),
		//*0x01,0x09,	_T("Arabic (Yemen)"),
		//*0x01,0x0A,	_T("Arabic (Syria)"),
		//*0x01,0x0B,	_T("Arabic (Jordan)"),
		//*0x01,0x0C,	_T("Arabic (Lebanon)"),
		//*0x01,0x0D,	_T("Arabic (Kuwait)"),
		//*0x01,0x0E,	_T("Arabic (U.A.E)"),
		//*0x01,0x0F,	_T("Arabic (Bahrain)"),
		//*0x01,0x10,	_T("Arabic (Qatar)"),
		//*0x02,0x01,	_T("Bulgarian"),
		0x03,0x01,	_T("Catalan"),				
		//*0x04,0x00,	_T("Chinese"),
		//*0x04,0x01,	_T("Chinese (Taiwan)"),
		0x04,0x02,	_T("Chinese (PRC)"),
		0x04,0x03,	_T("Chinese (Hong Kong)"),
		0x04,0x04,	_T("Chinese (Singapore)"),
		0x05,0x01,	_T("Czech"),
		0x06,0x01,	_T("Danish"),			
		0x07,0x01,	_T("German (Standard)"),			
		0x07,0x02,	_T("German (Swiss)"),
		0x07,0x03,	_T("German (Austrian)"),
		0x07,0x04,	_T("German (Luxembourg)"),
		0x07,0x05,	_T("German (Liechtenstein)"),
		//*0x08,0x01,	_T("Greek"),
		0x09,0x00,	_T("English"),
		0x09,0x01,	_T("English (United States)"),
		0x09,0x02,	_T("English (British)"),
		0x09,0x03,	_T("English (Australian)"),
		0x09,0x04,	_T("English (Canadian)"),
		0x09,0x05,	_T("English (New Zealand)"),
		0x09,0x06,	_T("English (Ireland)"),
		0x09,0x07,	_T("English (South Africa)"),
		0x09,0x08,	_T("English (Jamaica)"),
		0x09,0x0A,	_T("English (Belise)"),
		0x09,0x0B,	_T("English (Trinidad)"),
		0x0A,0x01,	_T("Spanish"),
		0x0A,0x02,	_T("Spanish (Mexican)"),
		0x0A,0x03,	_T("Spanish"),
		0x0A,0x04,	_T("Spanish (Guatemala)"),
		0x0A,0x05,	_T("Spanish (Costa Rica)"),
		0x0A,0x06,	_T("Spanish (Panama)"),
		0x0A,0x07,	_T("Spanish"),
		0x0A,0x08,	_T("Spanish (Venezuela)"),
		0x0A,0x09,	_T("Spanish (Columbia)"),
		0x0A,0x0A,	_T("Spanish (Peru)"),
		0x0A,0x0B,	_T("Spanish (Argentina)"),
		0x0A,0x0C,	_T("Spanish (Ecuador)"),
		0x0A,0x0D,	_T("Spanish (Chile)"),
		0x0A,0x0E,	_T("Spanish (Uruguay)"),
		0x0A,0x0F,	_T("Spanish (Paraguay)"),
		0x0A,0x10,	_T("Spanish (Bolivia)"),
		0x0A,0x11,	_T("Spanish (El Salvador)"),
		0x0A,0x12,	_T("Spanish (Honduras)"),
		0x0A,0x13,	_T("Spanish (Nicaragua)"),
		0x0A,0x14,	_T("Spanish (Puerto Rico)"),
		0x0B,0x01,	_T("Finnish"),	
		0x0C,0x01,	_T("French (Standard)"),			
		0x0C,0x02,	_T("French (Belgian)"),
		0x0C,0x03,	_T("French (Canadian)"),
		0x0C,0x04,	_T("French (Swiss)"),
		0x0C,0x05,	_T("French (Luxembourg)"),
		0x0D,0x01,	_T("Hebrew"),			
		0x0E,0x01,	_T("Hungarian"),
		0x0F,0x01,	_T("Icelandic"),		
		0x10,0x01,	_T("Italian (Standard)"),			
		0x10,0x02,	_T("Italian (Swiss)"),
		0x11,0x01,	_T("Japanese"),		
		//*0x12,0x01,	_T("Korean"),		
		0x13,0x01,	_T("Dutch (Standard)"),		
		0x13,0x02,	_T("Dutch (Belgian)"),
		0x14,0x01,	_T("Norwegian (Bokmal)"),
		0x14,0x02,	_T("Norwegian (Nynorsk)"),	
		0x15,0x01,	_T("Polish"),
		0x16,0x01,	_T("Portuguese (Brazilian)"),
		0x16,0x02,	_T("Portuguese (Standard)"),
		//0x17,0x01,	_T("Rhaeto-Romanic"),
		0x18,0x01,	_T("Romanian"),
		//0x18,0x02,	_T("Romanian (Moldavia)"),
		0x19,0x01,	_T("Russian"),
		//0x19,0x02,	_T("Russian (Moldavia)"),
		0x1A,0x01,	_T("Croatian"),
		0x1A,0x02,	_T("Serbian (Latin)"),
		0x1A,0x03,	_T("Serbian (Cyrillic)"),
		0x1B,0x01,	_T("Slovak"),
		0x1C,0x01,	_T("Albanian"),
		0x1D,0x01,	_T("Swedish"),
		0x1D,0x02,	_T("Swedish (Finland)"),
		0x1E,0x01,	_T("Thai"),
		0x1F,0x01,	_T("Turkish"),
		//0x20,0x01,	_T("Urdu"),
		0x21,0x01,	_T("Indonesian"),
		0x22,0x01,	_T("Ukranian"),
		0x23,0x01,	_T("Belarusian"),
		0x24,0x01,	_T("Slovenian"),
		0x25,0x01,	_T("Estonian"),
		0x26,0x01,	_T("Latvian"),
		0x27,0x01,	_T("Lithuanian"),
		//*0x29,0x01,	_T("Farsi"),
		0x2A,0x01,	_T("Vietnamese"),
		0x2D,0x01,	_T("Basque"),
		//0x2E,0x01,	_T("Sorbian"),
		//0x2F,0x01,	_T("FYROM"),
		//0x30,0x01,	_T("Sutu"),
		//0x31,0x01,	_T("Tsonga"),
		//0x32,0x01,	_T("Tswana"),
		//0x34,0x01,	_T("Xhosa"),
		//0x35,0x01,	_T("Zulu"),
		0x36,0x01,	_T("Afrikaans"),
		0x38,0x01,	_T("Faeroese"),
		//0x39,0x01,	_T("Hindi"),
		//0x3A,0x01,	_T("Maltese"),
		//0x3C,0x01,	_T("Gaelic"),
		//0x3D,0x01,	_T("Yiddish"),
		//0x3E,0x01,	_T("Malaysian"),
		0x00,0x00,  _T("Language neutral")
};

int testcrtEntry() {
	BOOL bRetVal;

	f1= fopen("Results.log","wt");
	fputs ("Testing CRunTime\n", f1);
	bRetVal = TestCRunTime();
	fclose (f1);

	// bRetVal == TRUE if test passed
	if (bRetVal)
	{
		return 0;
	}
	else
	{
		puts ("FAIL\n");
		return 1;
	}
}

BOOL compare(_TCHAR *sText, int x, int y) {
//	CString sOut(' ', 128);
	if (x != y) {
//		sOut.Format("\t%s: %4d not equal to %4d\n", sText, x, y);
//		f1.WriteString(sOut);
		fprintf (f1, "\t%s: %4d not equal to %4d\n", sText, x, y);
		return TRUE;
	}
	else {
		return FALSE;
	}
}

void PrintPassFail(BOOL bFailed) {
//	CString sOut(' ',128);
	if (bFailed) 
		fputs ("Test Failed!\n\n", f1);
//		sOut = "Test Failed!\n\n";
	else
		fputs ("Test Passed!\n\n", f1);
//		sOut = "Test Passed!\n\n";
//	f1.WriteString(sOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\time\strftime1.cpp ===
#if defined(_MT)

// Compile /MT or /MD
//
// Tests that setlocale() and strftime() and be used together in a multi-threaded 
// program.
//
#include <process.h>
#include <time.h>
#include <locale.h>
#include <stdio.h>
#include <tchar.h>

#ifdef _M_IA64
#pragma warning( disable : 4244)
#endif

unsigned __stdcall work( void* pArg ) // This uses the locale info pointer.
{
    _TCHAR          str256[256];
    time_t          t;
    struct tm*      ptm;

    t = time(0);
    ptm = localtime( &t );

    for (int i = 0; i < 100; i++) 
        _tcsftime( str256, 256, _T("%a%b%c%d%x%y"), ptm );
    return 0;
}

int main()
{
    unsigned thrdid = 0;
    _beginthreadex( 0, 0, work, 0, 0, &thrdid );

    for (int i = 0; i < 1000; i++) // This changes the locale info pointer.
    {
        _tsetlocale(LC_ALL,_T("english"));
        _tsetlocale(LC_ALL,_T("german"));
        _tsetlocale(LC_ALL,_T("french"));
        _tsetlocale(LC_ALL,_T("spannis"));
        _tsetlocale(LC_ALL,_T("russian"));
    }
    _tprintf(_T("passed\n"));
    return 0;
}

#else

int main() { return 0; }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\time\time1.cpp ===
#define QaLib time1NameSpace

#include <time.h>
#include "qalibrary.h"

/*@ time

Test Cases:
------------
  1. just check that reported time is within reasonable range.
  2. same as #1 but pass NULL for argument.

@*/

#define Y1993 725328000L  /* approx. number of seconds between 1970 & 1993 */
#define Y1994 756864000L  /* approx. number of seconds between 1970 & 1994 */
#define Y1995 788400000L  /* approx. number of seconds between 1970 & 1995 */
#define Y1997 851472000L  /* approx. number of seconds between 1970 & 1997 */
#define Y1999 914544000L
#define Y2036 2081376000L
#define Y2037 2145904712L   /* actual number of seconds between 1970 & 12/31/2037 - 12:35 p.m. */

#define YMIN  Y1994       /* Range (in seconds) for time tests */
#define YMAX  Y2037

template <class TT, class TF> bool TC1(TF timeFunc, QA_THREAD_PARAM, TT tt = 0)
{
    bool        retVal = true;

    TT          time1 = 0;
    TT          time2 = timeFunc(&time2);

    retVal &= QATCheck(time2 > YMIN);
    retVal &= QATCheck(time2 < YMAX);
    retVal &= QATCheckNE(time2, time1);

    return retVal;
}

template <class TT, class TF> bool TC2(TF timeFunc, QA_THREAD_PARAM, TT tt = 0)
{
    bool        retVal = true;

    TT          time1 = 0;
    TT          time2 = timeFunc(0);

    retVal &= QATCheck(time2 > YMIN);
    retVal &= QATCheck(time2 < YMAX);
    retVal &= QATCheckNE(time2, time1);

    return retVal;
}

static unsigned __stdcall time1Time1(void* qaThreadParam = 0)
{
    QA_BEGIN_TC(1)

        QATTrace1(_T("mktime()"));
        QATCheck(TC1<time_t>(time, QA_THREAD_PARAM_NAME));
		
#if ( _MSC_VER > 1200)
        QATTrace1(_T("mktime64()"));
        QATCheck(TC1<__time64_t>(_time64, QA_THREAD_PARAM_NAME));
#endif /* (_MSC_VER > 1200) */

    QA_END_TC(1)

    QA_BEGIN_TC(2)

        QATTrace1(_T("mktime()"));
        QATCheck(TC2<time_t>(time, QA_THREAD_PARAM_NAME));
		
#if ( _MSC_VER > 1200)
        QATTrace1(_T("mktime64()"));
        QATCheck(TC2<__time64_t>(_time64, QA_THREAD_PARAM_NAME));
#endif /* (_MSC_VER > 1200) */

    QA_END_TC(2)

    return 0;
}

TestFunc time1TestFuncList[] =
{
    time1Time1
};


int time1Entry()
{
    int nTests = (sizeof(time1TestFuncList)/sizeof(time1TestFuncList[0]));
    int iTest = 0;
    bool bRunTerm = false;

    if (time1TestFuncList[0] == 0)
    {
        if (nTests == 1) return 3; /* error, not enough data */
        /* if the 0th element is zero, then 1st element is a */
        /* thread kickoff function */
        iTest = 2;
        if (time1TestFuncList[1] != 0)
            time1TestFuncList[1](0);
    }

    if (nTests >= 4)
    {
        if (time1TestFuncList[2] == 0)
        {
            bRunTerm = true;
            iTest = 4;
        }
    }

    for (; iTest < nTests; iTest++)
        if(time1TestFuncList[iTest] != 0)
            time1TestFuncList[iTest](0);
    if (bRunTerm)
    {
        if (!time1TestFuncList[3])
            DbgPrint("Term function NULL!\n");
        else
            time1TestFuncList[3](0);
    }
    int ret = GetTestFailure() ? 1 : 0;
    ReportTest(false);
    ClearFailures();
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\time\utime1.cpp ===
#define QaLib utime1NameSpace

#include <stdio.h>
#include <direct.h>
#include <fcntl.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <sys\utime.h>
#include <sys\timeb.h>
#include <io.h>
#include <errno.h>

#define QA_NTHREADS 1
#include "qalibrary.h"

/*@ utime

TestCases:
-----------
  1. Attempt to modify the time of a directory.  Should fail and set errno to
     EACCES.
  2. Attempt to modify the time of a read-only file.  Should fail and set
     errno to EACCES.
  3. utime() should fail if given a 'bad' file name. errno should be set to
     on of the following: ENOENT, EINVAL or EACCES.
  4. Modify the time for 'normal' file.  Should succeed.
  5. When second argument is 0 the current time should be used.
  
@*/

static _TCHAR readonlyfile[] = _T("e_utime.ro");
_TCHAR testfile1[] = _T("utime1.tst");
_TCHAR testfile2[] = _T("utime2.tst");

_TCHAR* invalid_file_names[] = {
    _T("noprog.non"),
    _T("nodir.nod\\filename.non"),
    _T("\\rootdir\\nofile.non"),
    _T("..\\nofile.non"),
    _T("nodrive:\\file.non"),
    _T("toomany\\\\\\\\\\\\separaters"),
    _T("...........\\toomany\\dots"),
    _T("manybad<<<>>>>|||||^^^chars")
};

/*  The following unsigned long array holds the values used to test _utime().
 *  These values are in seconds from 00:00:00 Jan 1, 1970.
 *
 *  It is undocumented as of 2/12/93, but any time value greater than 1980
 *  is supposed to be valid.
 */

unsigned long try_times[] =
{
    0xFFFFFFFEL,    /* valid     - maximum value */
    3294636800L,    /* valid     - approx. mid May 2074 */
     994967294L,    /* valid     - approx. mid Jun 2001 */
      88965439L     /* valid     - approx. mid Sep 1972 */
};

//
// testcases
//
template <class TF> bool TC1(TF utimeFunc, QA_THREAD_PARAM)
{
    bool retVal = false;

    if (QATCheck(_tmkdir(_T("foobar.qa")) == 0))
    {
        errno = 0;
        retVal = QATCheckE(utimeFunc(_T("foobar.qa"), 0), -1);
        retVal &= QATCheckE(errno, EACCES);
        retVal &= QATCheck(_trmdir(_T("foobar.qa")) == 0);
    }

    return retVal;
}

template <class TF> bool TC2(TF utimeFunc, QA_THREAD_PARAM)
{
    bool retVal = false;

    int  fhandle = _topen(readonlyfile, O_CREAT | O_RDWR, S_IREAD);
    if (QATCheckNE(fhandle, -1))
    {
        QATCheck(_close(fhandle) == 0);
        errno = 0;
        retVal = QATCheckE(utimeFunc(readonlyfile, 0), -1);
        retVal &= QATCheckE(errno, EACCES);
        QATCheck(_tchmod(readonlyfile, S_IWRITE) == 0);
        QATCheck(_tunlink(readonlyfile) == 0);
    }

    return retVal;
}

template <class UTIMBUF, class TF> bool TC3(TF utimeFunc, QA_THREAD_PARAM)
{
    bool retVal = true;

    for (_TCHAR** test_name = invalid_file_names;
         test_name < &invalid_file_names[sizeof( invalid_file_names )/sizeof( invalid_file_names[0] ) ];
         test_name++)
    {
        UTIMBUF thistimebuf;
        errno = 0;
        if (QATCheck(utimeFunc(*test_name, &thistimebuf) == -1))
        {
            retVal &= QATCheck(errno == ENOENT || errno == EINVAL);
        }
        else
            retVal = false;
    }

    return retVal;
}

template <class T, class UTIMBUF, class STAT, class TF1, class TF2> 
bool TC4(TF1 utimeFunc, TF2 statFunc, QA_THREAD_PARAM)
{
    bool    retVal = false;
    UTIMBUF utimes;
    STAT    stimes;
    FILE*   fp;

    if(QATCheck((fp = _tfopen(testfile1, _T("w+"))) != 0))
    {
        retVal = QATCheck(_fputts(_T("Where's the beef?"), fp) != EOF);
        retVal &= QATCheck(fclose(fp) == 0);
    
        for(int i = 0; i < (sizeof(try_times)/sizeof(try_times[0])); i++)
        {
            utimes.modtime = (T)try_times[i];
            utimes.actime = (T)try_times[i];
        
            if(utimeFunc(testfile1, &utimes) == -1 )
            {
                 retVal &= QATCheckE(errno, EINVAL);
            }
            else
            {
                retVal &= QATCheck(statFunc(testfile1, &stimes) == 0);

                // Added this quick fix for NTFS drives when the OS is setting DST.
                // When we have time we should change to check for NTFS partition
                // and if automatic Daylight Savings Time adjustments are turned on.
                // And only then we should add 3600 (1 hour) for DST.

                if (stimes.st_mtime != (T)try_times[i])
                    stimes.st_mtime += 3600; // adjust for dst

                retVal &= QATCheckE(stimes.st_mtime, (T)try_times[i]);
            }
        }
        _tunlink(testfile1);
    }

    return retVal;
}

template <class TIMEB, class STAT, class TF1, class TF2, class TF3> 
bool TC5(TF1 utimeFunc, TF2 statFunc, TF3 ftimeFunc, QA_THREAD_PARAM)
{
    TIMEB   times;
    STAT    stimes;
    FILE*   fp;

    if (!QATCheck((fp = _tfopen(testfile2, _T("w+"))) != 0))
        return false;
    fclose(fp);

    if (QATCheck(utimeFunc(testfile2, NULL) == 0))
    {
        ftimeFunc(&times);
        if(QATCheck(statFunc(testfile2, &stimes) == 0))
        {
            /* Note this test allows for 2 seconds of difference which may not 
             * be enough if your machine is bogged down.  Two seconds is a long 
             * time, but rounding off could contribute to this also.
             */
            QATCheck(_tunlink(testfile2) == 0);
            return QATCheck(stimes.st_mtime - times.time <= 2);
        }
    }

    return false;
}

static unsigned __stdcall utime1UTime1(void* qaThreadParam = 0)
{
    QA_BEGIN_TC(1)

        QATTrace1(_T("*** utime() ***"));
        QATCheck(TC1(_tutime, QA_THREAD_PARAM_NAME));

#if (_MSC_VER > 1200) 
        QATTrace1(_T("*** utime64() ***"));
        QATCheck(TC1(_tutime64, QA_THREAD_PARAM_NAME));
#endif  /* (_MSC_VER > 1200) */

    QA_END_TC(1)
    return 0;
}

static unsigned __stdcall utime1UTime2(void* qaThreadParam = 0)
{
    QA_BEGIN_TC(2)

        QATTrace1(_T("*** utime() ***"));
        QATCheck(TC2(_tutime, QA_THREAD_PARAM_NAME));

#if (_MSC_VER > 1200) 
        QATTrace1(_T("*** utime64() ***"));
        QATCheck(TC2(_tutime64, QA_THREAD_PARAM_NAME));
#endif  /* (_MSC_VER > 1200) */

    QA_END_TC(2)
    return 0;
}

static unsigned __stdcall utime1UTime3(void* qaThreadParam = 0)
{
    QA_BEGIN_TC(3)

        QATTrace1(_T("*** utime() ***"));
        QATCheck(TC3<struct _utimbuf>(_tutime, QA_THREAD_PARAM_NAME));

#if (_MSC_VER > 1200) 
        QATTrace1(_T("*** utime64() ***"));
        QATCheck(TC3<struct __utimbuf64>(_tutime64, QA_THREAD_PARAM_NAME));
#endif  /* (_MSC_VER > 1200) */

    QA_END_TC(3)
    return 0;
}

static unsigned __stdcall utime1UTime4(void* qaThreadParam = 0)
{
    QA_BEGIN_TC(4)

        QATTrace1(_T("*** utime() ***"));
        if (!TC4<long, 
                 struct _utimbuf,
                 struct _stat>(_tutime, _tstat, QA_THREAD_PARAM_NAME))
            QATFail(10);

#if (_MSC_VER > 1200) 
        QATTrace1(_T("*** utime64() ***"));
        if (!TC4<__int64, 
                 struct __utimbuf64,
                 struct __stat64>(_tutime64, _tstat64, QA_THREAD_PARAM_NAME))
            QATFail(20);
#endif  /* (_MSC_VER > 1200) */

    QA_END_TC(4)
    return 0;
}

static unsigned __stdcall utime1UTime5(void* qaThreadParam = 0)
{
    QA_BEGIN_TC(5)

        QATTrace1(_T("*** utime() ***"));
        if (!TC5<struct _timeb,
                 struct _stat>(_tutime, _tstat, _ftime, QA_THREAD_PARAM_NAME))
            QATFail(10);

#if (_MSC_VER > 1200) 
        QATTrace1(_T("*** utime64() ***"));
        if (!TC5<struct __timeb64,
                 struct __stat64>(_tutime64, _tstat64, _ftime64, QA_THREAD_PARAM_NAME))
            QATFail(20);
#endif  /* (_MSC_VER > 1200) */

    QA_END_TC(5)
    return 0;
}



TestFunc utime1TestFuncList[] =
{
    utime1UTime1,
    utime1UTime2,
    utime1UTime3,
    utime1UTime4,
    utime1UTime5
};


int utime1Entry()
{
    int nTests = (sizeof(utime1TestFuncList)/sizeof(utime1TestFuncList[0]));
    int iTest = 0;
    bool bRunTerm = false;

    if (utime1TestFuncList[0] == 0)
    {
        if (nTests == 1) return 3; /* error, not enough data */
        /* if the 0th element is zero, then 1st element is a */
        /* thread kickoff function */
        iTest = 2;
        if (utime1TestFuncList[1] != 0)
            utime1TestFuncList[1](0);
    }

    if (nTests >= 4)
    {
        if (utime1TestFuncList[2] == 0)
        {
            bRunTerm = true;
            iTest = 4;
        }
    }

    for (; iTest < nTests; iTest++)
        if(utime1TestFuncList[iTest] != 0)
            utime1TestFuncList[iTest](0);
    if (bRunTerm)
    {
        if (!utime1TestFuncList[3])
            DbgPrint("Term function NULL!\n");
        else
            utime1TestFuncList[3](0);
    }
    int ret = GetTestFailure() ? 1 : 0;
    ReportTest(false);
    ClearFailures();
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\clib\time\utime2.cpp ===
#define QaLib utime2NameSpace

#include <stdio.h>
#include <direct.h>
#include <fcntl.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <sys\utime.h>
#include <sys\timeb.h>
#include <io.h>
#include <errno.h>

#undef QA_USE_THREADS   // theads make no sense with this test.
#include "qalibrary.h"

/*@ utime

TestCases:
-----------
  1. utime() should fail gracefully when no more file handles.  errno should
     be set to EMFILE.
  
@*/

#define MAXHANDLES 2048
int handles[MAXHANDLES];

_TCHAR readonlyfile[] = _T("utime2.tst");

//
// testcases
//
template <class TF> bool TC1(TF utimeFunc, QA_THREAD_PARAM)
{
    bool retVal = true;

    int fhandle;
    int fh = 0;
    int chk1,chk2,chk3;

    if (!QATCheck((fhandle = _topen(readonlyfile, O_CREAT | O_RDWR, S_IREAD)) != -1))
        return false;
    QACheck(_close(fhandle) == 0);

/* loop until no more file handles are availiable, then
 * make sure utime() fails eloquently:
 *
 * use the file readonlyfile, which happens to be a handy file.
*/
    errno = 0;
    while ((fh < MAXHANDLES ) &&
           errno != EMFILE    &&
           (-1 != (handles[fh++] = _topen(readonlyfile, O_RDONLY))))
        ; /* loop until done */

    retVal &= QATCheck(fh > 150);   // should have opened at least this many.

    chk1 = errno == EMFILE;

    /* no more file handles.. */

    errno = 0;
    chk2 = -1 == utimeFunc(readonlyfile, NULL);

#if !defined(_MAC)
    chk3 = errno == EMFILE;
#else
    chk3 = errno == EACCES;   /* _utime() for mac never sets errno to EMFILE
                                 according to porting doc. */
#endif

    while (--fh >= 0)
    {
        if (handles[fh] == -1)
            continue;
        if (!QATCheck(_close(handles[fh]) == 0))
        {
            QALog << _T("    ** fh == ") << fh << QAEndl;
            retVal = false;
        }
    }

    /* now report if errors */
    retVal &= QATCheck(chk1 != 0);
    retVal &= QATCheck(chk2 != 0);
    retVal &= QATCheck(chk3 != 0);

    retVal &= QATCheck(_tchmod(readonlyfile, S_IWRITE) == 0);
    retVal &= QATCheck(_tunlink(readonlyfile) == 0);

    return retVal;
}

static unsigned __stdcall utime2UTime1(void* qaThreadParam = 0)
{
    QA_BEGIN_TC(1)

        QATTrace1(_T("*** utime() ***"));
        QATCheck(TC1(_tutime, QA_THREAD_PARAM_NAME));

#if (_MSC_VER > 1200)
        QATTrace1(_T("*** utime64() ***"));
        QATCheck(TC1(_tutime64, QA_THREAD_PARAM_NAME));
#endif /* (_MSC_VER > 1200) */

    QA_END_TC(1)
    return 0;
}

TestFunc utime2TestFuncList[] =
{
    utime2UTime1
};


int utime2Entry()
{
    int nTests = (sizeof(utime2TestFuncList)/sizeof(utime2TestFuncList[0]));
    int iTest = 0;
    bool bRunTerm = false;

    if (utime2TestFuncList[0] == 0)
    {
        if (nTests == 1) return 3; /* error, not enough data */
        /* if the 0th element is zero, then 1st element is a */
        /* thread kickoff function */
        iTest = 2;
        if (utime2TestFuncList[1] != 0)
            utime2TestFuncList[1](0);
    }

    if (nTests >= 4)
    {
        if (utime2TestFuncList[2] == 0)
        {
            bRunTerm = true;
            iTest = 4;
        }
    }

    for (; iTest < nTests; iTest++)
        if(utime2TestFuncList[iTest] != 0)
            utime2TestFuncList[iTest](0);
    if (bRunTerm)
    {
        if (!utime2TestFuncList[3])
            DbgPrint("Term function NULL!\n");
        else
            utime2TestFuncList[3](0);
    }
    int ret = GetTestFailure() ? 1 : 0;
    ReportTest(false);
    ClearFailures();
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\c_plumhall\COMPIL.H ===
/* The Plum Hall Validation Suite for C
 * Unpublished copyright (c) 1986-1990, Chiron Systems Inc and Plum Hall Inc.
 * VERSION: 2.00
 * DATE: 90/04/05
 * The "ANSI" mode of this suite corresponds to official ANSI C, X3.159-1989.
 * As per your license agreement, your distribution is not to be moved or copied outside the Designated Site
 * without specific permission from Plum Hall Inc.
 */

/* CONFIGURATION -- ADAPT THE FOLLOWING PAGE OF DEFINITIONS TO LOCAL VALUES APPROPRIATE TO COMPILER  */

#ifndef COMPILER_H
   #define COMPILER_H
   #define ANSI  1	/* conforms to (1986 draft) ANSI X3J11 standard */
   #define V7	 0

/* The following named-constants can be configured independently */

   #define UNIQ_MEMB_NAMES	1	/* Does each struct-or-union have unique member name table */
   #define VOID_OK		1	/* Does compiler recognize "void" */
   #define LONG_IDENTIFIERS	1	/* Is name significance at least 31 */
   #define STRUCT_COND_OK	1	/* Can conditional (?:) operator take struct-or-union operands */
   #define TAG_AND_MEMB_SPACES	1	/* Are name spaces of tags and members separate */
   #define ALL_STRING_FNS	1	/* Are all string fns (see d11.c pg 1) provided */
   #define ALL_CTYPE_FNS	1	/* Are all ctype fns (esp. isgraph, tolower, toupper) provided */
   #define HAS_PROTOTYPES	1	/* Does compiler support "prototype" declarations -- int f(int); */
   #define NEW_STYLE_FN_DEF	1	/* Does compiler support "prototype" fn definitions -- int f(int i) { ... } */
   #define MACRO_NOV_86		1	/* Full Nov 86 draft -- rescan cat'ed names, full re-scan */
   #define LIB_NOV_86		1	/* Full Nov 86 library */
   #define WIDE_CHARS		1	/* has L'x', L"x", and wc*mb* functions */
   #define PP_CAT_AND_STR	1	/* has preprocessor catenate and stringize */
   #define TRIGRAPHS		1	/* supports trigraphs */
   #define ANSI8612		1	/* embodies Dec 86 decisions (see Suite User Manual) */
   #define ANSI8703		1	/* embodies Mar 87 decisions (see Suite User Manual) */
   #define ANSI8706		1	/* embodies Jun 87 decisions (see Suite User Manual) */
   #define ANSI8709		1	/* embodies Sep 87 decisions (see decision.88 */
   #define ANSI8712		1	/* embodies Dec 87 decisions (see decision.88 */
   #define ANSI8804		1	/* embodies Apr 88 decisions (see decision.88 */
   #define ANSI8809		1	/* embodies Sep 88 decisions (see decision.88 */

   #if !LIB_NOV_86
      #include "stubs.h"
   #endif	/* LIB_NOV_86 */

   #ifndef LIB_TEST
      #include <limits.h>
      #include <float.h>
      #include <stddef.h>

   #if ANSI8703	/* to get errno */
      #include <errno.h>
   #endif	/* ANSI8703 */
      #define LIB_TEST 0
   #endif	/* !LIB_TEST */

   #define UCHAR	unsigned char		/* For pre-ANSI compiler, these */
   #define USHORT	unsigned short		/* can be simulated or faked */
   #define ULONG	unsigned long		/* as needed */

   #ifndef Dgeneric_ptr
      #define Dgeneric_ptr
      typedef void *generic_ptr;
   #endif	/* Dgeneric_ptr */

#endif	/* COMPILER_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\c_plumhall\D410.c ===
/* The Plum Hall Validation Suite for C
 * Unpublished copyright (c) 1986-1990, Chiron Systems Inc and Plum Hall Inc.
 * VERSION: 2.00
 * DATE: 90/04/05
 * The "ANSI" mode of this suite corresponds to official ANSI C, X3.159-1989.
 * As per your license agreement, your distribution is not to be moved or copied outside the Designated Site
 * without specific permission from Plum Hall Inc.
 */

#ifndef SKIP410
#define LIB_TEST 1
#include "defs.h"

/*
 * 4.10 - General Utilities <stdlib.h>
 */

#if ANSI
#include <stdlib.h>
#if ANSI8703
#include <errno.h>
#endif  /* ANSI8703 */
#else   /* if !ANSI */
#include <stdio.h>  /* for NULL, at least */
extern int errno;
double atof();
int atoi();
long atol();
char *calloc(), *malloc(), *realloc();
void free();
void abort();
void exit();
#ifndef _XBOX
char *getenv();
int system();
#endif  /* XBOX */
#endif  /* ANSI */

int strcmp( const char *, const char * );
size_t strlen( const char * );

#include <math.h>
static void d4_10_1();
static void d4_10_2();
static void d4_10_3();
static void d4_10_4();
static void d4_10_4x();
static void d4_10_5();
static void d4_10_6();
static void d4_10_7();
static void d4_10_8();



static char *string1 = "1.234 2.3e99999999999999999999";
static char *string2 = "         123 10";
static char *string3 = "999999999999999999999999999999999999999999999999999999";
static char *string4 = "-99999999999999999999999999999999999999999999999999999";
static char *string5 = "   XXX";

void d4_10()
    {

    Filename = "d410.c";
#if ANSI
    {
    /* check existence of types */
/*//!:  div_t dummy1;
    ldiv_t dummy2; */
#if 0 /*//!: WIDE_CHARS*/
    wchar_t wc;
#endif /* WIDE_CHARS */
    size_t si;
    int i;

    /* check definition of required macros */
    #if !defined(EXIT_FAILURE)
        complain(__LINE__);
    #elif !defined(EXIT_SUCCESS)
        complain(__LINE__);
    #elif !defined(RAND_MAX)
        complain(__LINE__);
    #elif !defined(MB_CUR_MAX)
        complain(__LINE__);
    #endif

    checkthat(__LINE__, sizeof(div_t) >= 2*sizeof(int));
    checkthat(__LINE__, sizeof(ldiv_t) >= 2*sizeof(long));
#if WIDE_CHARS
    checkthat(__LINE__, MB_CUR_MAX >= 1);
#endif /* WIDE_CHARS */

    /* make sure that these expand to integral expressions (compile
     * fails if not).
     */
    i = ivalue(-99); if (i == EXIT_FAILURE) do_nothing(&si);
    i = ivalue(-99); if (i == EXIT_SUCCESS) do_nothing(&si);
    i = ivalue(-99); switch (i) { case RAND_MAX: do_nothing(&si); }
    }
#endif  /* ANSI */
    d4_10_1();
    d4_10_2();
    d4_10_3();
    d4_10_4();
    d4_10_5();
    d4_10_6();
    d4_10_7();
    d4_10_8();
    }

#if ANSI
#include <limits.h>
#include <float.h>
#endif  /* ANSI */
/*
 * 4.10.1 String conversion functions
 */
static void d4_10_1()
    {
    char *p;
    int i;
/*//!   long l;*/
    double d;

    /* atof, atoi, atol do not affect errno */
    errno = 99;

    /* 4.10.1.1 atof
     * text to float
     */
    dequals(__LINE__, atof("XXX"), 0.0);
    dequals(__LINE__, atof("\f\t\n\r\v1.234"), 1.234);
    dequals(__LINE__, atof("1.234"), 1.234);
    dequals(__LINE__, atof("     +1.234"), 1.234);
    dequals(__LINE__, atof("     +1.234"), 1.234);
    dequals(__LINE__, atof("     -1.234"), -1.234);
    dequals(__LINE__, atof("     +1.234e1"), 1.234e1);
    dequals(__LINE__, atof("     +1.234E1"), 1.234E1);
    dequals(__LINE__, atof("     +1.234E-1"), 1.234E-1);
    dequals(__LINE__, atof("     +1.234XE-1"), 1.234);

    /* 4.10.1.2 atoi
     * text to int
     */
    iequals(__LINE__, atoi("XXX"), 0);
    iequals(__LINE__, atoi("123"), 123);
    iequals(__LINE__, atoi("+123"), 123);
    iequals(__LINE__, atoi("-123"), -123);
    iequals(__LINE__, atoi("    +123"), 123);
    iequals(__LINE__, atoi("    0123"), 123);
    iequals(__LINE__, atoi("    0x123"), 0);
    iequals(__LINE__, atoi("    12a3"), 12);

    /* 4.10.1.3 atol
     * text to long
     */
    lequals(__LINE__, atol("XXX"), 0L);
    lequals(__LINE__, atol("123456"), 123456);
    lequals(__LINE__, atol("+123456"), 123456);
    lequals(__LINE__, atol("-123456"), -123456);
    lequals(__LINE__, atol("    +123456"), 123456);
    lequals(__LINE__, atol("    0123456"), 123456); /* not octal !! */
    lequals(__LINE__, atol("    0x123456"), 0L);
    lequals(__LINE__, atol("    12a3"), 12L);

    /* none of the above calls should have affected this */
    iequals(__LINE__, errno, 99);
    errno = 0;

#if ANSI
    /* 4.10.1.4 strtod
     * Same as atof, but gets pointer to end character and error checking
     */
    dequals(__LINE__, strtod("XXX", &p), 0.0);
    dequals(__LINE__, strtod("\f\t\n\r\v1.1", &p), 1.1);
    dequals(__LINE__, strtod("1.234", &p), 1.234);
    dequals(__LINE__, strtod("   +1.234", &p), 1.234);
    dequals(__LINE__, strtod("   +1.234", &p), 1.234);
    dequals(__LINE__, strtod("   -1.234", &p), -1.234);
    dequals(__LINE__, strtod("   +1.234e1", &p), 1.234e1);
    dequals(__LINE__, strtod("   +1.234E1", &p), 1.234E1);
    dequals(__LINE__, strtod("   +1.234E-1", &p), 1.234E-1);
    dequals(__LINE__, strtod("   +1.234XE-1", &p), 1.234);

    /* on no conversion, end pointer doesn't move */
    d = strtod(string5+3, &p);
    aequals(__LINE__, p, string5+3);
    d = strtod(string5, &p);
    aequals(__LINE__, p, string5);

    /* endptr gets pointer to remaining string */
    dequals(__LINE__, strtod(string1, &p), 1.234);
    aequals(__LINE__, p++, string1+5);

    /* overflow returns +/- HUGE_VAL */
    errno = 0;
    dequals(__LINE__, strtod(p, NULL), HUGE_VAL);
    iequals(__LINE__, errno, ERANGE);
    errno = 0;
    dequals(__LINE__, strtod("-1e99999999999999999999", NULL), -HUGE_VAL);
    iequals(__LINE__, errno, ERANGE);

    /* underflow returns 0 */
    errno = 0;
    dequals(__LINE__, strtod("1e-9999999999999999", NULL), 0.0);
    iequals(__LINE__, errno, ERANGE);

    /* 4.10.1.5 strtol
     * same as atol but with pointer, base, and error checking
     */
    lequals(__LINE__, strtol("XXX", &p, 0), 0L);
    lequals(__LINE__, strtol(string2, &p, 8), 0123L);
    aequals(__LINE__, p++, string2+12);

    /* check out bases */
    for (i = 2; i <= 36; ++i)
        lequals(__LINE__, strtol("11", NULL, i), (long)(i+1));
    lequals(__LINE__, strtol("zzz", NULL, 36), (((35L*36L)+35L)*36L)+35L);

    /* 0 base uses default C parsing rules */
    lequals(__LINE__, strtol("0x12345", NULL, 0), 0x12345L);
    lequals(__LINE__, strtol("0123", NULL, 0), 0123L);
    lequals(__LINE__, strtol("       -123", NULL, 0), -123L);
    lequals(__LINE__, strtol("       +123", NULL, 0), 123L);

    /* otherwise, same as atol */
    lequals(__LINE__, strtol("\f\t\n\r\v7", &p, 10), 7L);
    lequals(__LINE__, strtol("123456", &p, 10), 123456L);
    lequals(__LINE__, strtol("+123456", &p, 10), 123456L);
    lequals(__LINE__, strtol("-123456", &p, 10), -123456L);
    lequals(__LINE__, strtol("  +123456", &p, 10), 123456L);
    lequals(__LINE__, strtol("  0123456", &p, 10), 123456L);
    lequals(__LINE__, strtol("  0x123456", &p, 10), 0L);
    lequals(__LINE__, strtol("  0x123456", &p, 16), 0x123456L);
    lequals(__LINE__, strtol("  -0X123456", &p, 16), -0x123456L);
    lequals(__LINE__, strtol("  12a3", &p, 10), 12L);

    /* on no conversion, end pointer doesn't move */
    d = strtol(string5+3, &p, 10);
    aequals(__LINE__, p, string5+3);
    d = strtol(string5, &p, 10);
    aequals(__LINE__, p, string5);

    /* error checking */
    errno = 0;
    lequals(__LINE__, strtol(string3, NULL, 0), LONG_MAX);
    iequals(__LINE__, errno, ERANGE);
    errno = 0;
    lequals(__LINE__, strtol(string4, NULL, 0), LONG_MIN);
    iequals(__LINE__, errno, ERANGE);



    /* 4.10.1.6 strtoul
     * same conversions as strtol, but to unsigned long
     */
    lequals(__LINE__, strtoul("XXX", &p, 0), 0L);
    lequals(__LINE__, strtoul(string2, &p, 8), 0123L);
    aequals(__LINE__, p++, string2+12);

    /* check out bases */
    for (i = 2; i <= 36; ++i)
        lequals(__LINE__, strtoul("11", NULL, i), (long)(i+1));
    lequals(__LINE__, strtoul("zzz", NULL, 36), (((35L*36L)+35L)*36L)+35L);

    /* 0 base uses default C parsing rules */
    lequals(__LINE__, strtoul("0x12345", NULL, 0), 0x12345L);
    lequals(__LINE__, strtoul("0123", NULL, 0), 0123L);

    lequals(__LINE__, strtoul("\f\t\n\r\v7", &p, 10), 7L);
    lequals(__LINE__, strtoul("123456", &p, 10), 123456L);
    lequals(__LINE__, strtoul("     0123456", &p, 10), 123456L);
    lequals(__LINE__, strtoul("     0x123456", &p, 10), 0L);
    lequals(__LINE__, strtoul("     0x123456", &p, 16), 0x123456L);
    lequals(__LINE__, strtoul("     0X123456", &p, 16), 0x123456L);
    lequals(__LINE__, strtoul("     12a3", &p, 10), 12L);
#if ANSI8712
    lequals(__LINE__, strtoul("     +12", &p, 10), 12L);
#endif  /* ANSI8712 */

    /* on no conversion, end pointer doesn't move */
    d = strtoul(string5+3, &p, 10);
    aequals(__LINE__, p, string5+3);
    d = strtoul(string5, &p, 10);
    aequals(__LINE__, p, string5);

    /* error checking */
    errno = 0;
    lequals(__LINE__, strtoul(string3, NULL, 0), ULONG_MAX);
    iequals(__LINE__, errno, ERANGE);
#endif  /* ANSI */
    }










/*
 * 4.10.2 - Random number generation functions.
 */
static void d4_10_2()
    {
    int i1, i2, i3, j1, j2, j3;

    /* 4.10.2.1 rand
     * before ansi, all we can count on is that the sequence exists
     */
    i1 = rand();
    i2 = rand();
    i3 = rand();

    /* 4.10.2.2 srand
     * that it can be reset to the default
     */
    srand(1);
    j1 = rand();
    j2 = rand();
    j3 = rand();
    iequals(__LINE__, i1, j1);
    iequals(__LINE__, i2, j2);
    iequals(__LINE__, i3, j3);

    /* and reset arbitrarily */
    srand(11);
    i1 = rand();
    i2 = rand();
    i3 = rand();
    srand(11);
    j1 = rand();
    j2 = rand();
    j3 = rand();
    iequals(__LINE__, i1, j1);
    iequals(__LINE__, i2, j2);
    iequals(__LINE__, i3, j3);

#if ANSI
    /* now the range is specified */
    for (i1 = 0; i1 < 30; ++i1)
        {
        j1 = rand();
        checkthat(__LINE__, 0 <= j1 && j1 <= RAND_MAX);
        }
#endif  /* ANSI */
    }



/*
 * 4.10.3 - Memory management functions
 */
static void d4_10_3()
    {
    int i;
    char *pc;
    long *pl;
    double d = 9.87;
    union all
        {
        char c;
        short s;
        int i;
        long l;
        double d;
#if ANSI
        long double ld;
#endif  /* ANSI */
        char *pc;
        long *pl;
        double *pd;
        } *pu;

    /* 4.10.3.1 calloc
     * Can't do much more than check for existence and see if
     * using them doesn't crash the program. Calloc zeros out
     * the space.
     */
    pc = calloc(100, sizeof(long));
    for (i = 0; i < 100*sizeof(long); ++i)
        iequals(__LINE__, pc[i], 0);

    pl = (long *)pc;
    for (i = 0; i < 100; ++i)
        lequals(__LINE__, pl[i], 0L);

    free((char *)pl);












    /* Check alignment properties ... presumably the program
     * could crash if there is an alignment error. Here is a case
     * where it is important to try to defeat optimizers, so ivalue, etc.
     * are used for the assignments..
     */
#pragma warning( disable : 4242 )
    pu = (union all *)calloc(100, sizeof(*pu));
    pu->c = ivalue('a');
    iequals(__LINE__, pu->c, 'a');
    pu->s = ivalue(SHRT_MAX);
#pragma warning( default : 4242 )
    iequals(__LINE__, pu->s, SHRT_MAX);
    pu->i = ivalue(INT_MAX);
    iequals(__LINE__, pu->i, INT_MAX);
    pu->l = lvalue(LONG_MAX);
    lequals(__LINE__, pu->l, LONG_MAX);
    pu->d = dvalue(2.34);
    dequals(__LINE__, pu->d, 2.34);
#if ANSI
    pu->ld = 3.45L;
    ldequals(__LINE__, pu->ld, 3.45L);
#endif  /* ANSI */
    /* pointer to integral types already checked */
    pu->pd = (double *)avalue(&d);
    dequals(__LINE__, *(pu->pd), 9.87);

    /* check for 0 as arguments */
    aequals(- __LINE__, calloc(0, 100), NULL);  /* ANSI8612: behavior is implem-def; see 4.10.3 P1s1 */
    aequals(- __LINE__, calloc(100, 0), NULL);  /* ANSI8612: behavior is implem-def; see 4.10.3 P1s1 */

    /* 4.10.3.2 free used throughout.  ANSI requires free to accept a NULL argument.  */
#if ANSI
    free(NULL);
#endif  /* ANSI */

    /* 4.10.3.3 malloc
     */
    pc = malloc(100 * sizeof(long));
    for (i = 0; i < 100*sizeof(long); ++i)
        pc[i] = i%128;
    for (i = 0; i < 100*sizeof(long); ++i)
        iequals(__LINE__, pc[i], i%128);
    pl = (long *)pc;
    for (i = 0; i < 100; ++i)
        pl[i] = i;
    for (i = 0; i < 100; ++i)
        lequals(__LINE__, pl[i], (long)i);


    /* check for 0 as arguments */
    aequals(- __LINE__, malloc(0), NULL);   /* ANSI8612: behavior is implem-def; see 4.10.3 P1s1 */

    /* 4.10.3.4 realloc
     * contents should be the same up to the lesser size
     */
    pc = realloc((char *)pl, 200*sizeof(long));
    pl = (long *)pc;
    for (i = 0; i < 100; ++i)
        lequals(__LINE__, pl[i], (long)i);
    pc = realloc((char *)pl, 50*sizeof(long));
    pl = (long *)pc;
    for (i = 0; i < 50; ++i)
        lequals(__LINE__, pl[i], (long)i);
    free(pc);
#if ANSI
    /* ANSI requires that NULL and 0 are acceptable as arguments */
    pc = realloc(NULL, 400);
    for (i = 0; i < 400; ++i)
        pc[i] = i%128;
    for (i = 0; i < 400; ++i)
        iequals(__LINE__, pc[i], i%128);
    aequals(- __LINE__, realloc(pc, 0), NULL);  /* ANSI8612: behavior is implem-def; see 4.10.3 P1s1 */
#endif  /* ANSI */
    }




























/*
 * 4.10.4 - Communication with the environment.
 */
typedef int (*PIF)();
#if ANSI8712
static void d4_10_4y(void);
static void d4_10_4z(void);
#endif  /* ANSI8712 */
static void d4_10_4()
    {
    PIF p;
    int i;
    void d4_10_4x(void);

    /* Existence of these functions has been checked in 4.1.
     * Most of these we can't call without terminating the program,
     * in which case no real testing is done.
     */

#if ANSI
    /* 4.10.4.1 abort
     * terminates the program, so don't call it.
     */
    p = (PIF)abort;

    /* 4.10.4.2 atexit
     * register functions to be called at exit. At least
     * 32 must be allowed. As of ANSI8712 it is required that
     * they be called in reverse order of registry.
     */
#if ANSI8712
    iequals(__LINE__, atexit(d4_10_4x), 0);
    for (i = 0; i < 30; ++i)
        iequals(__LINE__, atexit(d4_10_4y), 0);
    iequals(__LINE__, atexit(d4_10_4z), 0);
#else
    for (i = 0; i < 32; ++i)
        iequals(__LINE__, atexit(d4_10_4x), 0);
#endif  /* ANSI8712 */
#endif  /* ANSI */

    /* 4.10.4.3 exit
     * will be tested at the end of main
     */
#if ANSI8612
    checkthat(__LINE__, EXIT_SUCCESS != EXIT_FAILURE);
#endif  /* ANSI8612 */
    p = (PIF)exit;

    /* 4.10.4.4 getenv
     * returns an implementation dependant pointer
     */
#ifndef _XBOX
    aequals(- __LINE__, getenv("this is probably a NULL pointer"), NULL);

    /* 4.10.4.4 system
     * is very implementation dependent. Does a command processor
     * exist? Return of 0 says not.
     */
    checkthat(- __LINE__, system(NULL) != 0);
#endif
    }

static int i = 0;
#if ANSI8712
static void d4_10_4z()
    {
    Filename = "d410.c";
    /* this function was registered last, so it should be called first */
    if (++i != 1)
        complain(__LINE__);
    }
static void d4_10_4y()
    {
    Filename = "d410.c";
    /* there should be exactly 30 invocations of this function */
    if (i < 1 || i > 30)
        complain(__LINE__);
    ++i;
    }
static void d4_10_4x()
    {
    Filename = "d410.c";
    /* this function was registered first, so it should be called last */
    if (++i != 32)
        complain(__LINE__);
    }
#else   /* if !ANSI8712 */
static void d4_10_4x()
    {
    if (++i == 32)
        printf("ATEXIT successfully registered 32 functions\n");
    Filename = "d410.c";
    checkthat(__LINE__, i <= 32);
    }
#endif  /* ANSI8712 */







/*
 * 4.10.5 - Searching and sorting.
 */

#if !ANSI
static void d4_10_5() { }
#else   /* if ANSI */
int mycmpfn PARMS((const void *, const void *));
int mycmpfn(s1, s2)
    const void *s1, *s2;
    {
    return (strcmp((const char *)s1, (const char *)s2));
    }

static void d4_10_5()
    {
/*  generic_ptr bsearch(); depend upon declaration in <stdlib.h> */
/*//!:  char *p;*/
    static char names[][4] = {"abc", "jkl", "yzz", "def", "stu", "mno", "vwx", "pqr", "ghi"};
                            /* Since we are in a "C" locale, these strings can be expected */
                            /* to collate as abc, def, ghi, jkl, mno, pqr, stu, vwx, yzz. */
    /* 4.10.5.1 qsort
     * sort using user comparison routine.
     */
    qsort(names, 9, 4, mycmpfn);
    stequals(__LINE__, names[0], "abc");
    stequals(__LINE__, names[1], "def");
    stequals(__LINE__, names[2], "ghi");
    stequals(__LINE__, names[3], "jkl");
    stequals(__LINE__, names[4], "mno");
    stequals(__LINE__, names[5], "pqr");
    stequals(__LINE__, names[6], "stu");
    stequals(__LINE__, names[7], "vwx");
    stequals(__LINE__, names[8], "yzz");
    /* 4.10.5.2 bsearch
     * find the entries in the array
     */
    checkthat(__LINE__, bsearch("abc", names, 9, 4, mycmpfn) == names[0]);
    aequals(__LINE__, bsearch("def", names, 9, 4, mycmpfn), names[1]);
    aequals(__LINE__, bsearch("ghi", names, 9, 4, mycmpfn), names[2]);
    aequals(__LINE__, bsearch("jkl", names, 9, 4, mycmpfn), names[3]);
    aequals(__LINE__, bsearch("mno", names, 9, 4, mycmpfn), names[4]);
    aequals(__LINE__, bsearch("pqr", names, 9, 4, mycmpfn), names[5]);
    aequals(__LINE__, bsearch("stu", names, 9, 4, mycmpfn), names[6]);
    aequals(__LINE__, bsearch("vwx", names, 9, 4, mycmpfn), names[7]);
    /* no match returns NULL */
    aequals(__LINE__, bsearch("123", (char*)names, 9, 4, mycmpfn), NULL);
    }
#endif  /* !ANSI */

/*
 * 4.10.6 - Integer arithmetic functions.
 */
static void d4_10_6()
    {
    /* 4.10.6.1 abs
     * absolute value
     */
    iequals(__LINE__, abs(10), 10);
    iequals(__LINE__, abs(-10), 10);

#if ANSI
    {
    div_t d;
    ldiv_t ld;

    /* 4.10.6.2 div
     * get dividend and remainder.
     */
    d = div(-5, 2);
    iequals(__LINE__, d.quot, -2);
    iequals(__LINE__, d.rem, -1);
    d = div(5, 2);
    iequals(__LINE__, d.quot, 2);
    iequals(__LINE__, d.rem, 1);

    /* 4.10.6.3 labs
     * same as abs, but for longs
     */
    lequals(__LINE__, labs(2147483647), 2147483647);
    lequals(__LINE__, labs(-2147483647), 2147483647);

    /* 4.10.6.4 ldiv
     * get long dividend and remainder.
     */
    ld = ldiv(-5L, 2L);
    lequals(__LINE__, ld.quot, -2L);
    lequals(__LINE__, ld.rem, -1L);
    ld = ldiv(5L, 2L);
    lequals(__LINE__, ld.quot, 2L);
    lequals(__LINE__, ld.rem, 1L);
    }
#endif  /* ANSI */
    }





/*
 * 4.10.7 - Multibyte character functions
 */
#if !ANSI
static void d4_10_7(){}
#else   /* if ANSI */
static void d4_10_7()
    {
    const char *s = "Test string";
    size_t len = strlen(s); /*LX:10131999 /int/size_t for 64-bit friendliness */
    const char *ps = s + len;                   /* points to 0 */
#if WIDE_CHARS
    wchar_t wc;
#endif  /* WIDE_CHARS */
    char buff[10];

    /* Only the "C" locale can be tested here, which has no
     * specific requirements.  Vendor specific tests can be added to
     * test actual multibyte encodings.
     */
#if WIDE_CHARS
    /* 4.10.7.1 The mblen function */
    iequals( - __LINE__, mblen(NULL, 1000), 0);     /* no multibytes */
    iequals( - __LINE__, mblen(NULL, 0), 0);            /* no multibytes */
    iequals(__LINE__, mblen(ps, 1), 0);             /* pointer to 0 */
    iequals(__LINE__, mblen(s, len), 1);            /* 1 byte per char */

    /* 4.10.7.2 The mbtowc function */
    iequals(__LINE__, mbtowc(&wc, NULL, 0), 0);     /* no multibytes */
    iequals(__LINE__, mbtowc(&wc, ps, 1), 0);       /* pointer to 0 */
    lequals(__LINE__, (long)wc, 0L);                /* big enough for wchar_t */
    iequals(__LINE__, mbtowc(&wc, s, len), 1);      /* pointer to 0 */
    lequals(__LINE__, (long)wc, (long)'T');         /* big enough for wchar_t */
    checkthat(__LINE__, MB_CUR_MAX >= 1);

    /* 4.10.7.3 The wctomb function */
    iequals(__LINE__, wctomb(NULL, wc), 0);         /* no multibytes */
    iequals(__LINE__, wctomb(NULL, 0), 0);          /* no multibytes */
    iequals(__LINE__, wctomb(buff, wc), 1);         /* 1 byte per char */
    iequals(__LINE__, buff[0], 'T');
    wc = 0;
    iequals(__LINE__, wctomb(buff, wc), 1);
    iequals(__LINE__, buff[0], 0);
#endif  /* WIDE_CHARS */
    }
#endif  /* ANSI */




/*
 * 4.10.8 - Multibyte string functions
 * The size_t checks are done as long because sizeof(long) >= sizeof(size_t).
 * Also, it is assumed that sizeof(long) >= sizeof(wchar_t);
 */
#if !ANSI || !WIDE_CHARS
static void d4_10_8()
        {}
#else   /* if ANSI && WIDE_CHARS */
static void d4_10_8()
    {
    int i;
    const char *s = "A test string";
    long len = (long)strlen(s);
    #define WLEN 20
    wchar_t warray[WLEN];
    char buf[WLEN];

    /* if wchar_t is bigger than a long, these tests will not work */
    if (sizeof(long) < sizeof(wchar_t))
        {
        complain(- __LINE__);
        return;
        }

    /* initialize warray and buf to all 1 */
    for (i = 0; i < WLEN; ++i)
        {
        warray[i] = 1;
        buf[i] = 1;
        }

    /* in the "C" locale it is assumed that the MB representation
     * is the same as the wchar_t representation for printable
     * characters.
     */

    /* 4.10.8.1 the mbstowcs function */
    lequals(__LINE__, (long) mbstowcs(warray, s, 1), 1L);
    lequals(__LINE__, (long) warray[0], (long)'A');
    lequals(__LINE__, (long) warray[1], 1L);            /* no terminating 0 */
    lequals(__LINE__, (long) mbstowcs(warray, s, WLEN), len);
    lequals(__LINE__, (long) warray[len-1], (long)'g');
    lequals(__LINE__, (long) warray[len], 0L);          /* terminating 0 */

    /* 4.10.8.2 the wcstombs function */
    lequals(__LINE__, (long) wcstombs(buf, warray, 1), 1L);
    lequals(__LINE__, (long) buf[0], (long)'A');
    lequals(__LINE__, (long) buf[1], 1L);               /* no terminating 0 */
    lequals(__LINE__, (long) wcstombs(buf, warray, WLEN), len);
    lequals(__LINE__, (long) buf[len-1], (long)'g');
    lequals(__LINE__, (long) buf[len], 0L);             /* terminating 0 */
    }
#endif  /* ANSI  && WIDE_CHARS */

#else /* if SKIP410 */
void d4_10() { pr_err("d4_10: SKIPPED ENTIRELY\n"); }
#endif  /* SKIP410 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\c_plumhall\d41.c ===
/* The Plum Hall Validation Suite for C
 * Unpublished copyright (c) 1986-1990, Chiron Systems Inc and Plum Hall Inc.
 * VERSION: 2.00
 * DATE: 90/04/05
 * The "ANSI" mode of this suite corresponds to official ANSI C, X3.159-1989.
 * As per your license agreement, your distribution is not to be moved or copied outside the Designated Site
 * without specific permission from Plum Hall Inc.
 */

#define LIB_TEST 1
#include "defs.h"
#if !ANSI || !HAS_PROTOTYPES
#define SKIP41 1
#endif
#ifndef SKIP41

static void d4_1_1();
static void d4_1a();
static void d4_1_2();
void d4_1_3();
void d41_4a();
void d41_4b();
void d4_1_5();
static void d4_1_6();

/*
 * NON_PH
 *
 * The following conditional compilation directive, "#ifndef _DLL", is a
 * non-Plum Hall alteration.  This has been made since run-time functions
 * like atoi() are prototyped with a different linkage type
 * (__declspec(dllimport) instead of extern) when used from a DLL like
 * msvcrt.dll.
 */
#ifndef _DLL
extern int atoi(const char *);
#endif

/*
 * 4.1 - Introduction
 * This file is not relevant to pre ANSI C compilers.
 */
void d4_1()
    {
    Filename = "d41.c";
    d4_1_1();
    d4_1_2();
    d4_1_3();
    d41_4a();
    d41_4b();
    d4_1_5();
    d4_1_6();
    /* test various methods of library call here,
     * before including the headers.
     */
        /* implicit declaration */
        {
/*
 * NON_PH
 *
 * The following conditional compilation directive, "#ifndef _DLL", is a
 * non-Plum Hall alteration.
 */
#ifndef _DLL
        int i;
        i = atoi("4");
        iequals(__LINE__, i, 4);
        }

        /* explicit declaration */
        {
        int i;
        extern int atoi(const char *);
        i = atoi("4");
        iequals(__LINE__, i, 4);
#endif

        /* using its header */
        d4_1a();
        }
    }


#include <stdlib.h>
static void d4_1a()
    {
        {
        /* by use of the associated header */
        int i;

        i = atoi("5");
        iequals(__LINE__, i, 5);

        i = (atoi)("7");
        iequals(__LINE__, i, 7);

        #undef atoi
        i = atoi("6");
        iequals(__LINE__, i, 6);
        }

    }


/*
 * 4.1.1 - Definitions of terms
 */
static void d4_1_1()
    {
    /* definitions of "string", "letter", and "decimal-point character" */
    }

/*
 * 4.1.2 - Headers
 */
/* int near, far, cdecl, unix, vax;*/       /* non-reserved names */
/* int globaldef, asm, fortran, pascal, entry;*/    /* non-reserved names */
/* int environ, i386, i387;*/           /* non-reserved names */

/* make sure that all of the specified headers exist */

#define value (Be sure that any dummy names used in headers are valid.)
#define filename (A conforming implementation cannot just copy the library synopsis.)
#define stream (One possible technique is to have NO dummy names in headers.)
#define nmemb

// (If headers have this problem, they can be altered manually to proceed with testing.)

#include <assert.h>
#include <ctype.h>
#include <errno.h>
#include <float.h>
#include <limits.h>
#include <locale.h>
#include <math.h>
#include <setjmp.h>
#include <signal.h>
#include <stdarg.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

/* check that another order and multiple includes are OK */

#include <time.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <stddef.h>
#include <stdarg.h>
#include <signal.h>
#include <setjmp.h>
#include <math.h>
#include <locale.h>
#include <limits.h>
#include <float.h>
#include <ctype.h>
#include <assert.h>
#include <errno.h>

static void d4_1_2()
    {
    int _ok = 8703;

    /* ANSI8703: internal id's of underscore + lowercase letter now OK */

    iequals(__LINE__, _ok, 8703);
    }
/*
 * 4.1.6 - Use of library functions.
 */
static void d4_1_6()
    {
    /* All library functions must be accessible as real
     * functions, whether implemented as macros or not.
     * Each of these routines is supposed to have an underlying
     * real function. Make sure that it exists. The definitions
     * are supposed to occur in the standard header files.
     */
    /* <ctype.h> */
    checkthat(__LINE__, isalnum != 0);
    checkthat(__LINE__, isalpha != 0);
    checkthat(__LINE__, iscntrl != 0);
    checkthat(__LINE__, isdigit != 0);
    checkthat(__LINE__, isgraph != 0);
    checkthat(__LINE__, islower != 0);
    checkthat(__LINE__, isprint != 0);
    checkthat(__LINE__, ispunct != 0);
    checkthat(__LINE__, isspace != 0);
    checkthat(__LINE__, isupper != 0);
    checkthat(__LINE__, isxdigit != 0);
    checkthat(__LINE__, tolower != 0);
    checkthat(__LINE__, toupper != 0);
    #undef isalnum
    #undef isalpha
    #undef iscntrl
    #undef isdigit
    #undef isgraph
    #undef islower
    #undef isprint
    #undef ispunct
    #undef isspace
    #undef isupper
    #undef isxdigit
    #undef tolower
    #undef toupper

    {
    int isalnum(int);
    int isalpha(int);
    int iscntrl(int);
    int isdigit(int);
    int isgraph(int);
    int islower(int);
    int isprint(int);
    int ispunct(int);
    int isspace(int);
    int isupper(int);
    int isxdigit(int);
    int tolower(int);
    int toupper(int);
    }

    /* <locale.h> */
    checkthat(__LINE__, setlocale != 0);
#if ANSI8709
    checkthat(__LINE__, localeconv != 0);
#endif
    #undef setlocale
    #undef localeconv
    {
    char *setlocale(int, const char *);
#if ANSI8709
    struct lconv *localeconv(void);
#endif
    }

    /* <math.h> */
    checkthat(__LINE__, acos != 0);
    checkthat(__LINE__, asin != 0);
    checkthat(__LINE__, atan != 0);
    checkthat(__LINE__, atan2 != 0);
    checkthat(__LINE__, cos != 0);
    checkthat(__LINE__, sin != 0);
    checkthat(__LINE__, tan != 0);
    checkthat(__LINE__, cosh != 0);
    checkthat(__LINE__, sinh != 0);
    checkthat(__LINE__, tanh != 0);
    checkthat(__LINE__, exp != 0);
    checkthat(__LINE__, frexp != 0);
    checkthat(__LINE__, ldexp != 0);
    checkthat(__LINE__, log != 0);
    checkthat(__LINE__, log10 != 0);
    checkthat(__LINE__, modf != 0);
    checkthat(__LINE__, pow != 0);
    checkthat(__LINE__, sqrt != 0);
    checkthat(__LINE__, ceil != 0);
    checkthat(__LINE__, fabs != 0);
    checkthat(__LINE__, floor != 0);
    checkthat(__LINE__, fmod != 0);

    #undef acos
    #undef asin
    #undef atan
    #undef atan2
    #undef cos
    #undef sin
    #undef tan
    #undef cosh
    #undef sinh
    #undef tanh
    #undef exp
    #undef frexp
    #undef ldexp
    #undef log
    #undef log10
    #undef modf
    #undef pow
    #undef sqrt
    #undef ceil
    #undef fabs
    #undef floor
    #undef fmod

    {
    double acos(double);
    double asin(double);
    double atan(double);
    double atan2(double, double);
    double cos(double);
    double sin(double);
    double tan(double);
    double cosh(double);
    double sinh(double);
    double tanh(double);
    double exp(double);
    double frexp(double, int *);
    double ldexp(double, int);
    double log(double);
    double log10(double);
    double modf(double, double *);
    double pow(double, double);
    double sqrt(double);
    double ceil(double);
    double fabs(double);
    double floor(double);
    double fmod(double, double);
    }

    /* <setjmp.h> */
    /* ANSI8706 now setjmp must be a macro - see 4.6 P3 */
    checkthat(__LINE__, longjmp != 0);
    #undef longjmp
    {
    void longjmp(jmp_buf, int);
    }

    /* <signal.h> */
    checkthat(__LINE__, signal != 0);
    checkthat(__LINE__, raise != 0);
    #undef signal
    #undef raise
    {
    void (*signal(int, void (*)(int)))(int);
    int raise(int);
    }


    /* <stdio.h> */
    checkthat(__LINE__, remove != 0);
    checkthat(__LINE__, rename != 0);
    checkthat(__LINE__, tmpfile != 0);
    checkthat(__LINE__, tmpnam != 0);
//  checkthat(__LINE__, fclose != 0);
    checkthat(__LINE__, fflush != 0);
//  checkthat(__LINE__, fopen != 0);
    checkthat(__LINE__, freopen != 0);
    checkthat(__LINE__, setbuf != 0);
    checkthat(__LINE__, setvbuf != 0);
    checkthat(__LINE__, fprintf != 0);
    checkthat(__LINE__, fscanf != 0);
    checkthat(__LINE__, printf != 0);
    checkthat(__LINE__, scanf != 0);
    checkthat(__LINE__, sprintf != 0);
    checkthat(__LINE__, sscanf != 0);
    checkthat(__LINE__, vfprintf != 0);
    checkthat(__LINE__, vprintf != 0);
    checkthat(__LINE__, vsprintf != 0);
    checkthat(__LINE__, fgetc != 0);
    checkthat(__LINE__, fgets != 0);
    checkthat(__LINE__, fputc != 0);
    checkthat(__LINE__, fputs != 0);
    checkthat(__LINE__, gets != 0);
    checkthat(__LINE__, getc != 0);
    checkthat(__LINE__, getchar != 0);
    checkthat(__LINE__, puts != 0);
    checkthat(__LINE__, putc != 0);
    checkthat(__LINE__, putchar != 0);
    checkthat(__LINE__, ungetc != 0);
    checkthat(__LINE__, fread != 0);
    checkthat(__LINE__, fwrite != 0);
    checkthat(__LINE__, fgetpos != 0);
    checkthat(__LINE__, fseek != 0);
    checkthat(__LINE__, fsetpos != 0);
    checkthat(__LINE__, ftell != 0);
    checkthat(__LINE__, rewind != 0);
    checkthat(__LINE__, clearerr != 0);
    checkthat(__LINE__, feof != 0);
    checkthat(__LINE__, ferror != 0);
    checkthat(__LINE__, perror != 0);

    #undef remove
    #undef rename
    #undef tmpfile
    #undef tmpnam
    #undef fclose
    #undef fflush
    #undef fopen
    #undef freopen
    #undef setbuf
    #undef setvbuf
    #undef fprintf
    #undef fscanf
    #undef printf
    #undef scanf
    #undef sprintf
    #undef sscanf
    #undef vfprintf
    #undef vprintf
    #undef vsprintf
    #undef fgetc
    #undef fgets
    #undef fputc
    #undef fputs
    #undef getc
    #undef getchar
    #undef gets
    #undef putc
    #undef putchar
    #undef puts
    #undef ungetc
    #undef fread
    #undef fwrite
    #undef fgetpos
    #undef fseek
    #undef fsetpos
    #undef ftell
    #undef rewind
    #undef clearerr
    #undef feof
    #undef ferror
    #undef perror

    {
    int remove(const char *);
    int rename(const char *, const char *);
    FILE *tmpfile(void);
    char *tmpnam(char *);
    int fclose(FILE *);
    int fflush(FILE *);
    FILE *fopen(const char *, const char *);
    FILE *freopen(const char *, const char *, FILE *);
    void setbuf(FILE *, char *);
    int setvbuf(FILE *, char *, int, size_t);
    int fprintf(FILE *, const char *, ...);
    int fscanf(FILE *, const char *, ...);
    int printf(const char *, ...);
    int scanf(const char *, ...);
    int sprintf(char *, const char *, ...);
    int sscanf(const char *, const char *, ...);
    int vfprintf(FILE *, const char *, va_list);
    int vprintf(const char *, va_list);
    int vsprintf(char *, const char *, va_list);
    int fgetc(FILE *);
    char *fgets(char *, int, FILE *);
    int fputc(int, FILE *);
    int fputs(const char *, FILE *);
    int getc(FILE *);
    int getchar(void);
    char *gets(char *);
    int putc(int, FILE *);
    int putchar(int);
    int puts(const char *);
    int ungetc(int, FILE *);
    size_t fread(void *, size_t, size_t, FILE *);
    size_t fwrite(const void *, size_t, size_t, FILE *);
    int fgetpos(FILE *, fpos_t *);
    int fseek(FILE *, long, int);
    int fsetpos(FILE *, const fpos_t *);
    long ftell(FILE *);
    void rewind(FILE *);
    void clearerr(FILE *);
    int feof(FILE *);
    int ferror(FILE *);
    void perror(const char *);
    }

    /* <stdlib.h> */
    checkthat(__LINE__, atof != 0);
    checkthat(__LINE__, atoi != 0);
    checkthat(__LINE__, atol != 0);
    checkthat(__LINE__, strtod != 0);
    checkthat(__LINE__, strtol != 0);
    checkthat(__LINE__, strtoul != 0);
    checkthat(__LINE__, rand != 0);
    checkthat(__LINE__, srand != 0);
    checkthat(__LINE__, calloc != 0);
    checkthat(__LINE__, free != 0);
    checkthat(__LINE__, malloc != 0);
    checkthat(__LINE__, realloc != 0);
    checkthat(__LINE__, abort != 0);
    checkthat(__LINE__, atexit != 0);
    checkthat(__LINE__, exit != 0);
#ifndef _XBOX
    checkthat(__LINE__, getenv != 0);
    checkthat(__LINE__, system != 0);
#endif
    checkthat(__LINE__, bsearch != 0);
    checkthat(__LINE__, qsort != 0);
    checkthat(__LINE__, abs != 0);
    checkthat(__LINE__, div != 0);
    checkthat(__LINE__, labs != 0);
    checkthat(__LINE__, ldiv != 0);
#if WIDE_CHARS
    checkthat(__LINE__, mblen != 0);
    checkthat(__LINE__, mbtowc != 0);
    checkthat(__LINE__, wctomb != 0);
    checkthat(__LINE__, mbstowcs != 0);
    checkthat(__LINE__, wcstombs != 0);
#endif

    #undef atof
    #undef atoi
    #undef atol
    #undef strtod
    #undef strtol
    #undef strtoul
    #undef rand
    #undef srand
    #undef calloc
    #undef free
    #undef malloc
    #undef realloc
    #undef abort
    #undef atexit
    #undef exit
#ifndef _XBOX
    #undef getenv
    #undef system
#endif
    #undef bsearch
    #undef qsort
    #undef abs
    #undef div
    #undef labs
    #undef ldiv
    #undef mblen
    #undef mbtowc
    #undef wctomb
    #undef mbstowcs
    #undef wcstombs

    {
    double atof(const char *);
    int atoi(const char *);
    long atol(const char *);
    double strtod(const char *, char **);
    long strtol(const char *, char **, int );
    unsigned long strtoul(const char *, char **, int);
    int rand(void);
    void srand(unsigned int);
    void *calloc(size_t, size_t);
    void free(void *);
    void *malloc(size_t);
    void *realloc(void *, size_t);
    void abort(void);
    int atexit(void (*)(void));
    void exit(int);
#ifndef _XBOX
    char *getenv(const char *);
    int system(const char *);
#endif
    void *bsearch(const void *, const void *, size_t, size_t, int (*)(const void *, const void *));
    void qsort(void *, size_t, size_t, int (*)(const void *, const void *));
    int abs(int);
    div_t div(int, int);
    long labs(long);
    ldiv_t ldiv(long, long);
#if WIDE_CHARS
    int mblen(const char *, size_t);
    int mbtowc(wchar_t *, const char *, size_t);
    int wctomb(char *, wchar_t);
    size_t mbstowcs(wchar_t *, const char *, size_t);
    size_t wcstombs(char *, const wchar_t *, size_t);
#endif
    }

    /* <string.h> */
    checkthat(__LINE__, memcpy != 0);
    checkthat(__LINE__, memmove != 0);
    checkthat(__LINE__, strcpy != 0);
    checkthat(__LINE__, strncpy != 0);
    checkthat(__LINE__, strcat != 0);
    checkthat(__LINE__, strncat != 0);
    checkthat(__LINE__, memcmp != 0);
    checkthat(__LINE__, strcmp != 0);
    checkthat(__LINE__, strncmp != 0);
    checkthat(__LINE__, strcoll != 0);
#if ANSI8612
    checkthat(__LINE__, strxfrm != 0);
#endif
    checkthat(__LINE__, memchr != 0);
    checkthat(__LINE__, strchr != 0);
    checkthat(__LINE__, strcspn != 0);
    checkthat(__LINE__, strpbrk != 0);
    checkthat(__LINE__, strrchr != 0);
    checkthat(__LINE__, strspn != 0);
    checkthat(__LINE__, strstr != 0);
    checkthat(__LINE__, strtok != 0);
    checkthat(__LINE__, memset != 0);
    checkthat(__LINE__, strerror != 0);
    checkthat(__LINE__, strlen != 0);
    #undef memcpy
    #undef memmove
    #undef strcpy
    #undef strncpy
    #undef strcat
    #undef strncat
    #undef memcmp
    #undef strcmp
    #undef strncmp
    #undef strcoll
    #undef memchr
    #undef strchr
    #undef strcspn
    #undef strpbrk
    #undef strrchr
    #undef strspn
    #undef strstr
    #undef strtok
    #undef memset
    #undef strerror
    #undef strlen
    {
    void *memcpy(void *, const void *, size_t);
    void *memmove(void *, const void *, size_t);
    char *strcpy(char *, const char *);
    char *strncpy(char *, const char *, size_t);
    char *strcat(char *, const char *);
    char *strncat(char *, const char *, size_t);
    int memcmp(const void *, const void *, size_t);
    int strcmp(const char *, const char *);
    int strncmp(const char *, const char *, size_t);
#if ANSI8612
    int strcoll(const char *, const char *);
    size_t strxfrm(char *, const char *, size_t);
#else
    size_t strcoll(char *, size_t, const char *);
#endif
    void *memchr(const void *, int, size_t);
    char *strchr(const char *, int);
    size_t strcspn(const char *, const char *);
    char *strpbrk(const char *, const char *);
    char *strrchr(const char *, int);
    size_t strspn(const char *, const char *);
    char *strstr(const char *, const char *);
    char *strtok(char *, const char *);
    void *memset(void *, int, size_t);
    char *strerror(int);
    size_t strlen(const char *);
    }

    /* <time.h> */
    checkthat(__LINE__, clock != 0);
    checkthat(__LINE__, difftime != 0);
    checkthat(__LINE__, mktime != 0);
    checkthat(__LINE__, time != 0);
    checkthat(__LINE__, asctime != 0);
    checkthat(__LINE__, ctime != 0);
    checkthat(__LINE__, gmtime != 0);
    checkthat(__LINE__, localtime != 0);
    checkthat(__LINE__, strftime != 0);

    #undef clock
    #undef difftime
    #undef mktime
    #undef time
    #undef asctime
    #undef ctime
    #undef gmtime
    #undef localtime
    #undef strftime
    {
    clock_t clock(void);
    double difftime(time_t, time_t);
    time_t mktime(struct tm *);
    time_t time(time_t *);
    char *asctime(const struct tm *);
    char *ctime(const time_t *);
    struct tm *gmtime(const time_t *);
    struct tm *localtime(const time_t *);
    size_t strftime(char *, size_t, const char *, const struct tm *);
    }
    }

#else /* if SKIP41 */
void d4_1() { pr_err("d4_1: SKIPPED ENTIRELY\n"); }
#endif  /* SKIP41 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\c_plumhall\D410DRV.c ===
/* The Plum Hall Validation Suite for C
 * Unpublished copyright (c) 1986-1988, Chiron Systems Inc and Plum Hall Inc.
 * VERSION: 1.09
 * DATE: 88/09/20
 * Each distribution of the Suite is unique in distinct but inconsequential ways.
 * As per your license agreement, your distribution is not to be moved or copied outside the Designated Site
 * without specific permission from Plum Hall Inc.
 */
/*
 * this source must be compiled with FUNCTION=d4_# defined where # is a
 * number between 1 and 12
 */

/*
 * LIB - standard library tests
 */

/* 14-Dec-1989 mrw added this to prevent unresolved external from d41a.c */
//int errno_init = 0;  /* set in lib.c */

#define LIB_TEST 1      /* prevents inclusion of limits.h and float.h */
#include "defs.h"

extern void d4_10();

d410_main(int argc, char ** argv)
    /*int argc;
    char **argv;*/
    {
    extern int Debug;

    if (argc > 1)
        Debug = TRUE;
    Filename = __FILE__;
    d4_10();
    report("d410");
    }
/*
 * For "almost-ANSI" compilers that are missing parts of the latest ANSI library,
 * include stubs for these functions here.
 */
#if (ANSI && !LIB_NOV_86)
#include "stubs.c"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\c_plumhall\D411DRV.c ===
/* The Plum Hall Validation Suite for C
 * Unpublished copyright (c) 1986-1988, Chiron Systems Inc and Plum Hall Inc.
 * VERSION: 1.09
 * DATE: 88/09/20
 * Each distribution of the Suite is unique in distinct but inconsequential ways.
 * As per your license agreement, your distribution is not to be moved or copied outside the Designated Site
 * without specific permission from Plum Hall Inc.
 */
/*
 * this source must be compiled with FUNCTION=d4_# defined where # is a
 * number between 1 and 12
 */

/*
 * LIB - standard library tests
 */

/* 14-Dec-1989 mrw added this to prevent unresolved external from d41a.c */
//int errno_init = 0;  /* set in lib.c */

#define LIB_TEST 1      /* prevents inclusion of limits.h and float.h */
#include "defs.h"

extern void d4_11();

d411_main(int argc, char ** argv)
    /*int argc;
    char **argv;*/
    {
    extern int Debug;

    if (argc > 1)
        Debug = TRUE;
    Filename = __FILE__;
    d4_11();
    report("d411");
    }
/*
 * For "almost-ANSI" compilers that are missing parts of the latest ANSI library,
 * include stubs for these functions here.
 */
#if (ANSI && !LIB_NOV_86)
#include "stubs.c"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\c_plumhall\D411.c ===
/* The Plum Hall Validation Suite for C
 * Unpublished copyright (c) 1986-1990, Chiron Systems Inc and Plum Hall Inc.
 * VERSION: 2.00
 * DATE: 90/04/05
 * The "ANSI" mode of this suite corresponds to official ANSI C, X3.159-1989.
 * As per your license agreement, your distribution is not to be moved or copied outside the Designated Site
 * without specific permission from Plum Hall Inc.
 */

#ifndef SKIP411
#define LIB_TEST 1
#include "defs.h"

/*
 * 4.11 - String Handling
 */

#if ANSI
#include <stddef.h>
#include <string.h>
#else
#if ALL_STRING_FNS
char *memcpy();
char *memset();
char *strcpy();
char *strncpy();
char *strcat();
char *strncat();
char *memchr();
char *strchr();
char *strrchr();
char *strpbrk();
char *strtok();
int strspn();
int strcspn();
#endif
#endif

static void d4_11_2();
static void d4_11_3();
void d4_11b();









static char mem1[15] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14};
static char mem2[15] = {9,9,9,9,9,9,9,9,9,9,9,9,9,9,9};
static char string1[] = "aaaaaaaaaa";
static char string2[] = "bbbb\0bbbb";
static char string3[] = "cccccccccc";
static char string4[21] = "dddddddddd";
static char string5[] = "abcdefgX\0Y";
static char string6[] = "abcXabcX\0Y";
static char string7[] = "oneXtwoYXthreeYYXXZZfourGFGF";
static char string8[] = "oneXtwoYXthreeYYXXZZfourGFGF";
static char string9[60];
void d4_11()
	{

	Filename = "d411.c";
	d4_11_2();
	d4_11_3();
	d4_11b();
	}

/*
 * 4.11.2 - Copying functions
 */
static void d4_11_2()
	{
	int i;
	char *p;

	/* 4.11.2.1 memcpy
	 * basic copy
	 */
	p = memcpy(mem2, mem1, 15);
	aequals(__LINE__, mem2, p);
	for (i = 0; i < 15; ++i)
		iequals(__LINE__, mem1[i], mem2[i]);

#if ANSI













	/* 4.11.2.2 memmove
	 * "correct" memory copy.
	 * First, shift left copy
	 */
	memmove(mem2, mem2+1, 14);
	for (i = 0; i < 14; ++i)
		iequals(__LINE__, mem2[i], mem1[i+1]);
	iequals(__LINE__, mem2[14], mem1[14]);

	/* Then shift right copy */
	memmove(mem2+1, mem2, 14);
	for (i = 1; i < 15; ++i)
		iequals(__LINE__, mem2[i], mem1[i]);
	iequals(__LINE__, mem2[0], mem2[1]);
#endif
	/* 4.11.2.3 strcpy
	 * string copy
	 */
	p = strcpy(string1+1, string2);
	aequals(__LINE__, p, string1+1);
	iequals(__LINE__, string1[0], 'a');
	for (i = 1; i < 10; ++i)
		if (i < 5)
			iequals(__LINE__, string1[i], 'b');
		else if (i == 5)
			iequals(__LINE__, string1[i], 0);
		else
			iequals(__LINE__, string1[i], 'a');
	iequals(__LINE__, string1[10], 0);

	/* 4.11.2.4 strncpy
	 * string copy with count
	 */
	p = strncpy(string1, string3, 9);
	aequals(__LINE__, p, string1);
	for (i = 0; i < 9; ++i)
		iequals(__LINE__, string1[i], 'c');
	iequals(__LINE__, string1[9], 'a');
	iequals(__LINE__, string1[10], 0);

	/* fill with nulls if too few */
	strncpy(string1, string2, 8);
	for (i = 0; i < 8; ++i)
		if (i < 4)
			iequals(__LINE__, string1[i], 'b');
		else
			iequals(__LINE__, string1[i], 0);
	iequals(__LINE__, string1[9], 'a');
	iequals(__LINE__, string1[10], 0);
	}

/*
 * 4.11.3 - Concatenation functions
 */
static void d4_11_3()
	{
	int i;
	char *p;

	/* 4.11.3.1 strcat
	 * string concatenation
	 */
	p = strcat(string4, string3);
	aequals(__LINE__, p, string4);
	for (i = 0; i < 20; ++i)
		if (i < 10)
			iequals(__LINE__, string4[i], 'd');
		else
			iequals(__LINE__, string4[i], 'c');
	iequals(__LINE__, string4[20], 0);

	/* 4.11.3.2 strncat
	 * string concatenation with maximum length
	 */
	string4[10] = 0;
	/* if there are not enough chars, then it is the same as strcat */
	p = strncat(string4, string3, 12);
	aequals(__LINE__, p, string4);
	for (i = 0; i < 20; ++i)
		if (i < 10)
			iequals(__LINE__, string4[i], 'd');
		else
			iequals(__LINE__, string4[i], 'c');
	iequals(__LINE__, string4[20], 0);
	string4[10] = 0;
	/* otherwise concatenate fewer characters */
	strncat(string4, string3, 4);
	for (i = 0; i < 14; ++i)
		if (i < 10)
			iequals(__LINE__, string4[i], 'd');
		else
			iequals(__LINE__, string4[i], 'c');
	iequals(__LINE__, string4[14], 0);
	}






#else /* if SKIP411 */
void d4_11() { pr_err("d4_11: SKIPPED ENTIRELY\n"); }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\c_plumhall\D412.c ===
/* The Plum Hall Validation Suite for C
 * Unpublished copyright (c) 1986-1990, Chiron Systems Inc and Plum Hall Inc.
 * VERSION: 2.00
 * DATE: 90/04/05
 * The "ANSI" mode of this suite corresponds to official ANSI C, X3.159-1989.
 * As per your license agreement, your distribution is not to be moved or copied outside the Designated Site
 * without specific permission from Plum Hall Inc.
 */

#define LIB_TEST 1
#include "defs.h"
#if !ANSI
#define SKIP412 1 /* This file is almost irrelevant for non-ANSI */
#endif
#ifndef SKIP412
/*
 * 4.12 - Date and time
 */
#include <time.h>
#include <limits.h>
#include <string.h>
struct tm tm1, tm2, *ptm;
static time_t time_t1, time_t2, time_t3;
static void d4_12_1();
static void d4_12_2();
static void d4_12_3();
void d4_12()
	{
	Filename = "d412.c";
	d4_12_1();
	d4_12_2();
	d4_12_3();
	}

/*
 * 4.12.1 Components of time
 */
static void d4_12_1()
	{
	/* make sure that all of the required fields are there */
	tm1.tm_sec = 0;
	tm1.tm_min = 49;
	tm1.tm_hour = 20;
	tm1.tm_mday = 12;
	tm1.tm_mon = 8;
	tm1.tm_year = 76;
	tm1.tm_wday = -99;
	tm1.tm_yday = -99;
	tm1.tm_isdst = 1;
	}

/*
 * 4.12.2 Time manipulation functions.
 */
static void d4_12_2()
	{
	int sec;
	clock_t c;

	/* 4.12.2.1 clock
	 * system time. Also check existence of CLOCKS_PER_SEC macro
	 */
	sec = (c = clock()) / CLOCKS_PER_SEC;

	/* is the processor time available via "clock" ? */
	if (c == (clock_t)-1)
		complain(- __LINE__);

	/* 4.12.2.2 difftime
	 * compute the difference between two times
	 */
	time_t1 = mktime(&tm1);
	tm1.tm_sec = 5;
	time_t2 = mktime(&tm1);
	dequals(__LINE__, difftime(time_t1, time_t2), -5.0);

	/* 4.12.2.3 mktime
	 * convert a "struct tm" to a "time_t". Return
	 * (time_t)-1 if it is unrepresentable
	 */
	tm2.tm_sec = tm2.tm_min = tm2.tm_hour = tm2.tm_mday =
			tm2.tm_mon = tm2.tm_year = INT_MIN;
	checkthat(__LINE__, mktime(&tm2) == (time_t)-1);

	/* now check that the day of the week for tm1 is Sunday. */
	iequals(__LINE__, tm1.tm_wday, 0);

	/* 4.12.2.4 time
	 * present time of day
	 */
	time_t1 = time_t2;
	time_t3 = time(&time_t1);

	/* check whether the time is available */
	if (time_t3 == (time_t)-1)
		complain(- __LINE__);
	dequals(__LINE__, difftime(time_t3, time_t1), 0.0);
	checkthat(__LINE__, difftime(time_t1, time_t2) > 0.0);
	}

/*
 * 4.12.3 Time conversion functions
 */
static void d4_12_3()
	{
	char s[64];
	char *p;

	/* 4.12.3.1 asctime
	 * convert a "struct tm" to a string
	 */
	p = asctime(&tm1);

	/* 4.12.3.2 ctime
	 * convert a "time_t" to a string
	 */
	time_t1 = mktime(&tm1);
	stequals(__LINE__, p, ctime(&time_t1));
	iequals(__LINE__, tm1.tm_wday, 0);	/* Sunday */
	iequals(__LINE__, tm1.tm_yday, 255);

	/* 4.12.3.3 gmtime
	 * convert a "time_t" to a Greenwich Mean Time string
	 */
	ptm = gmtime(&time_t1);

	/* 4.12.3.4 localtime
	 * convert a "time_t" to a "struct tm"
	 */
	ptm = localtime(&time_t1);
	time_t2 = mktime(ptm);
	/* this should be an isomorphic change */
	dequals(__LINE__, difftime(time_t1, time_t2), 0.0);

















	/* 4.12.3.5 strftime
	 * encode time information in a locale dependant way.
	 * This test will make sure that the "C" locale works right.
	 */
	 iequals(__LINE__, strftime(s, 64, "XXX", &tm1), 3);
	 iequals(__LINE__, strftime(s,  2, "XXX", &tm1), 0);

	 #define ST(in, out) strftime(s, 64, in, &tm1); stequals(__LINE__, s, out);
	 #define ST2(in, out) strftime(s, 64, in, &tm1); stequals( - __LINE__, s, out);

	/* check each of the formatting directives */
	ST("%a", "Sun");
	ST("%A", "Sunday");
	ST("%b", "Sep");
	ST("%B", "September");
	{
		static char a[31] = {0};

		strftime(a, 30, "%c", &tm1);
		if (strchr(a, '\n') == 0)
			*strchr(a, '\0') = '\n';
		stequals(- __LINE__, a, asctime(&tm1));
	}
	ST("%d", "12");
	ST("%H", "20");
	ST("%I", "08");
	ST("%j", "256");
	ST("%m", "09");
	ST("%M", "49");
	ST("%p", "PM");
	ST("%S", "05");
	ST("%U", "37");
	ST("%w", "0");
	ST("%W", "36");
	ST2("%x", "Sun Sep 12, 1976");
	ST2("%X", "20:49:05");
	ST("%y", "76");
	ST("%Y", "1976");
	ST("%%", "%");
	}

#else /* if SKIP412 */
void d4_12() { pr_err("d4_12: SKIPPED ENTIRELY\n"); }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\c_plumhall\D41B.c ===
/* The Plum Hall Validation Suite for C
 * Unpublished copyright (c) 1986-1990, Chiron Systems Inc and Plum Hall Inc.
 * VERSION: 2.00
 * DATE: 90/04/05
 * The "ANSI" mode of this suite corresponds to official ANSI C, X3.159-1989.
 * As per your license agreement, your distribution is not to be moved or copied outside the Designated Site
 * without specific permission from Plum Hall Inc.
 */

#define LIB_TEST 1
#include "defs.h"
#if !ANSI || !HAS_PROTOTYPES
#define SKIP41 1
#endif
#ifndef SKIP41
#include <limits.h>
/*
 * 4.1.4 - Limits <limits.h>
 */
void d41_4a()
	{
	Filename = "d41b.c";

	/* All of these must be restricted constant expresions. */
if (CHAR_BIT < 8)
	complain(__LINE__);
if (SCHAR_MIN > -127)
	complain(__LINE__);
if (SCHAR_MAX < 127)
	complain(__LINE__);
if (UCHAR_MAX < 255U)
	complain(__LINE__);
if (CHAR_MIN != SCHAR_MIN && CHAR_MIN != 0)
	complain(__LINE__);
if (CHAR_MAX != SCHAR_MAX && CHAR_MAX != UCHAR_MAX)
	complain(__LINE__);
if (SHRT_MIN > -32767)
	complain(__LINE__);
if (SHRT_MAX < 32767)
	complain(__LINE__);
if (USHRT_MAX < 65535U)
	complain(__LINE__);
if (INT_MIN > -32767)
	complain(__LINE__);
if (INT_MAX < 32767)
	complain(__LINE__);
if (UINT_MAX < 65535U)
	complain(__LINE__);

if (LONG_MIN > -2147483647)
	complain(__LINE__);
if (LONG_MAX <  2147483647)
	complain(__LINE__);
if (ULONG_MAX < 0xffffffff)
	complain(__LINE__);


#if !defined(CHAR_BIT) ||  !defined(SCHAR_MIN) ||  !defined(SCHAR_MAX) ||  !defined(UCHAR_MAX) ||  !defined(CHAR_MIN)
	complain(__LINE__);
#endif
#if !defined(CHAR_MAX) ||  !defined(SHRT_MIN) ||  !defined(SHRT_MAX) ||  !defined(USHRT_MAX) ||  !defined(INT_MIN)
	complain(__LINE__);
#endif
#if !defined(INT_MAX) ||  !defined(UINT_MAX) ||  !defined(LONG_MIN) ||  !defined(LONG_MAX) ||  !defined(ULONG_MAX)
	complain(__LINE__);
#endif

/* ANSI8809 - Each limit must be properly represented to equal its value stored in appropriate object */
	#if ANSI8809
	{
	char cmin = CHAR_MIN;
	char c = CHAR_MAX;
	signed char scmin = SCHAR_MIN;
	signed char sc = SCHAR_MAX;
	unsigned char uc = UCHAR_MAX;
	short smin = SHRT_MIN;
	short s = SHRT_MAX;
	unsigned short us = USHRT_MAX;
	int imin = INT_MIN;
	int i = INT_MAX;
	unsigned int ui = UINT_MAX;
	long Lmin = LONG_MIN;
	long L = LONG_MAX;
	unsigned long uL = ULONG_MAX;
	


	if ((char)CHAR_MIN != cmin)
		complain(__LINE__);
	if (CHAR_MAX != c)
		complain(__LINE__);
	if (SCHAR_MIN != scmin)
		complain(__LINE__);
	if (SCHAR_MAX != sc)
		complain(__LINE__);
	if (UCHAR_MAX != uc)
		complain(__LINE__);
	if (SHRT_MIN != smin)
		complain(__LINE__);
	if (SHRT_MAX != s)
		complain(__LINE__);
	if (USHRT_MAX != us)
		complain(__LINE__);
	if (INT_MIN != imin)
		complain(__LINE__);
	if (INT_MAX != i)
		complain(__LINE__);

	if (UINT_MAX != ui)
		complain(__LINE__);
	if (LONG_MIN != Lmin)
		complain(__LINE__);
	if (LONG_MAX != L)
		complain(__LINE__);
	if (ULONG_MAX != uL)
		complain(__LINE__);
	}
	#endif	/* ANSI8809 */
	}
#else	/* SKIP41 */
int skp41b = 1;	/* must have one def */
#endif	/* SKIP41 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\c_plumhall\D411B.c ===
/* The Plum Hall Validation Suite for C
 * Unpublished copyright (c) 1986-1990, Chiron Systems Inc and Plum Hall Inc.
 * VERSION: 2.00
 * DATE: 90/04/05
 * The "ANSI" mode of this suite corresponds to official ANSI C, X3.159-1989.
 * As per your license agreement, your distribution is not to be moved or copied outside the Designated Site
 * without specific permission from Plum Hall Inc.
 */

#ifndef SKIP411
#define LIB_TEST 1
#include "defs.h"

/*
 * 4.11(b) - String Handling (continued)
 */

#if ANSI
#include <stddef.h>
#include <string.h>
#else
#if ALL_STRING_FNS
char *memcpy();
char *memset();
char *strcpy();
char *strncpy();
char *strcat();
char *strncat();
char *memchr();
char *strchr();
char *strrchr();
char *strpbrk();
char *strtok();
int strspn();
int strcspn();
#endif
#endif

static char mem1[15] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14};
static char mem2[15] = {9,9,9,9,9,9,9,9,9,9,9,9,9,9,9};
static char string1[] = "aaaaaaaaaa";
static char string2[] = "aaaa\0bbbb";
static char string3[] = "cccccccccc";
static char string4[21] = "dddddddddd";
static char string5[] = "abcdefgX\0Y";
static char string6[] = "abcXabcX\0Y";
static char string7[] = "oneXtwoYXthreeYYXXZZfourGFGF";
static char string8[] = "oneXtwoYXthreeYYXXZZfourGFGF";
static char string9[60];
static void d4_11_4();
static void d4_11_5();
static void d4_11_6();
void d4_11b()
    {
    Filename = "d411b.c";
    d4_11_4();
    d4_11_5();
    d4_11_6();
    }









































/*
 * 4.11.4 - Comparison functions
 */
static void d4_11_4()
    {
/*//!:  int i;
    char *p;*/

    /* 4.11.4.1 memcmp
     * memory compare
     */
    checkthat(__LINE__, memcmp(string4, string3, 5) > 0);
    checkthat(__LINE__, memcmp(string3, string4, 5) < 0);
    checkthat(__LINE__, memcmp(string1, string2, 4) == 0);

    /* 4.11.4.2 strcmp
     * string compare
     */
    checkthat(__LINE__, strcmp("bbc", "abc") > 0);
    checkthat(__LINE__, strcmp("abc", "bbc") < 0);
    checkthat(__LINE__, strcmp("hi ma", "hi ma") == 0);

    /* 4.11.4.4 strncmp
     * string compare with length
     */
    checkthat(__LINE__, strncmp("bbc", "abc", 1) > 0);
    checkthat(__LINE__, strncmp("abc", "bbc", 1) < 0);
    checkthat(__LINE__, strncmp("hi max", "hi may", 5) == 0);

#if ANSI8612
    /* 4.11.4.5 strxfrm
     * make the string collatable through strcmp, memcmp.
     * This is implementation dependent. For the "C" locale, this 
     * just copies the source into the target, if space permits.
     */

     checkthat(__LINE__, strxfrm(string9, string8, 60) > 0);
     iequals(- __LINE__, strcmp(string9, string8), 0);

    /* 4.11.4.3 strcoll
     * implementation dependent
     */
    iequals(- __LINE__, strcoll(string9, string8), 0);
#if ANSI8706
    checkthat(__LINE__, strxfrm(string9, "abc", 2) == 3);   /* ANSI8706: now returns required length */
#endif
#endif
    }


/*
 * 4.11.5 - Search functions
 */
static void d4_11_5()
    {
/*//!   int i;*/
    char *p;

    /* 4.11.5.1 memchr
     * search memory
     */
    p = memchr(string5, 'X', 10);
    aequals(__LINE__, p, string5+7);
    p = memchr(string5, 'X', 3);
    aequals(__LINE__, p, (char *)0);
    p = memchr(string5, 'Y', 10);
    aequals(__LINE__, p, string5+9);
    p = memchr(string5, 'Z', 8);
    aequals(__LINE__, p, (char *)0);

    /* 4.11.5.2 strchr
     * search strings
     */
    p = strchr(string5, 'X');
    aequals(__LINE__, p, string5+7);
    p = strchr(string5, 'Y');
    aequals(__LINE__, p, (char *)0);

    /* 4.11.5.3 strcspn
     * count number of leading characters not in set
     */
    iequals(__LINE__, strcspn(string5, string5), 0);
    iequals(__LINE__, strcspn(string5, "ABC"), 8);
    iequals(__LINE__, strcspn(string5, "ABCX"), 7);

    /* 4.11.5.4 strpbrk
     * get pointer to first character in the set
     */
    p = strpbrk(string5, string5);
    aequals(__LINE__, p, string5);
    p = strpbrk(string5, "ABC");
    aequals(__LINE__, p, (char *)0);
    p = strpbrk(string5, "ABCX");
    aequals(__LINE__, p, string5+7);






    /* 4.11.5.5 strrchr
     * locate last occurrence of character in a string
     */
    p = strrchr(string6, 'Y');
    aequals(__LINE__, p, (char *)0);
    p = strrchr(string6, 'X');
    aequals(__LINE__, p, string6+7);

    /* 4.11.5.6 strspn
     * length of segment consisting of characters in set
     */
    iequals(__LINE__, strspn(string6, "ABC"), 0);
    iequals(__LINE__, strspn(string6, "cba"), 3);
    iequals(__LINE__, strspn(string6, "cXba"), 8);

    /* 4.11.5.7 strstr
     * locate a substring
     */
#if ANSI
    aequals(__LINE__, strstr(string8, "one"), string8+0);
    aequals(__LINE__, strstr(string8, "YX"), string8+7);
    aequals(__LINE__, strstr(string8, "GFGF"), string8+24);
    aequals(__LINE__, strstr(string8, "not there"), NULL);
    aequals(__LINE__, strstr(string8, ""), string8);    /* ANSI8703: was previously vague */

#endif
    /* 4.11.5.8 strtok
     * string parsing
     */
    p = strtok(string7, "YX");
    checkthat(__LINE__, strcmp(p, "one") == 0);
    p = strtok((char *)0, "YZ");
    checkthat(__LINE__, strcmp(p, "two") == 0);
    p = strtok((char *)0, "ZYX");
    checkthat(__LINE__, strcmp(p, "three") == 0);
    p = strtok((char *)0, "ZYXFGHIJ");
    checkthat(__LINE__, strcmp(p, "four") == 0);
    /* this should detect that despite the "space", no token remains */
    p = strtok((char *)0, "FGHIJ");
    aequals(__LINE__, p, (char *)0);
    /* re-initialize */
    p = strtok(string8, "XY");
    checkthat(__LINE__, strcmp(p, "one") == 0);
    /* check for nothing available at first parse */
    p = strtok("XYZ", "XYZ");
    aequals(__LINE__, p, (char *)0);
    }




/*
 * 4.11.6 - Miscellaneous functions
 */
static void d4_11_6()
    {
    int i;
    char *p;

    /* 4.11.6.1 memset
     * memory fill
     */
    memcpy(mem2, mem1, 15);
    p = memset(mem2+1, 99, 4);
    aequals(__LINE__, mem2+1, p);
    for (i = 0; i < 15; ++i)
        if (1 <= i && i <= 4)
            iequals(__LINE__, mem2[i], 99);
        else
            iequals(__LINE__, mem1[i], mem2[i]);
#if ANSI
    /* 4.11.6.2 strerror
     * map to an error message string. Since the string
     * is implementation defined, we can only check for existance.
     */
    p = strerror(0);
#endif
    /* 4.11.6.3 strlen
     * find string length
     */
    iequals(__LINE__, strlen("123456789"), 9);
    iequals(__LINE__, strlen(""), 0);
    }


#endif /* SKIP411 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\c_plumhall\D412DRV.c ===
/* The Plum Hall Validation Suite for C
 * Unpublished copyright (c) 1986-1988, Chiron Systems Inc and Plum Hall Inc.
 * VERSION: 1.09
 * DATE: 88/09/20
 * Each distribution of the Suite is unique in distinct but inconsequential ways.
 * As per your license agreement, your distribution is not to be moved or copied outside the Designated Site
 * without specific permission from Plum Hall Inc.
 */
/*
 * this source must be compiled with FUNCTION=d4_# defined where # is a
 * number between 1 and 12
 */

/*
 * LIB - standard library tests
 */

/* 14-Dec-1989 mrw added this to prevent unresolved external from d41a.c */
//int errno_init = 0;  /* set in lib.c */

#define LIB_TEST 1      /* prevents inclusion of limits.h and float.h */
#include "defs.h"

extern void d4_12();

d412_main(int argc, char ** argv)
    /*int argc;
    char **argv;*/
    {
    extern int Debug;

    if (argc > 1)
        Debug = TRUE;
    Filename = __FILE__;
    d4_12();
    report("d412");
    }
/*
 * For "almost-ANSI" compilers that are missing parts of the latest ANSI library,
 * include stubs for these functions here.
 */
#if (ANSI && !LIB_NOV_86)
#include "stubs.c"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\c_plumhall\D41A.c ===
/* The Plum Hall Validation Suite for C
 * Unpublished copyright (c) 1986-1990, Chiron Systems Inc and Plum Hall Inc.
 * VERSION: 2.00
 * DATE: 90/04/05
 * The "ANSI" mode of this suite corresponds to official ANSI C, X3.159-1989.
 * As per your license agreement, your distribution is not to be moved or copied outside the Designated Site
 * without specific permission from Plum Hall Inc.
 */

#define LIB_TEST 1
#include "defs.h"
#if !ANSI || !HAS_PROTOTYPES
#define SKIP41 1
#endif
#ifndef SKIP41
#include <errno.h>

/*
 * 4.1.3 - Errors <errno.h>
 */
void d4_1_3()
	{
	extern int errno_init;	/* set in lib.c */
	Filename = "d41a.c";
	/* make sure that EDOM and ERANGE are macros */
	#if !defined(EDOM) || !defined(ERANGE)
		complain(__LINE__);
	#endif

	/* errno is a modifiable lvalue initialized to 0 */
	iequals(__LINE__, errno_init, 0);
	errno = 1;
	iequals(__LINE__, errno, 1);
	errno = 0;
	iequals(__LINE__, errno, 0);
	inotequals(__LINE__, EDOM, 0);
	inotequals(__LINE__, ERANGE, 0);
	}
#else
int skp41a = 1;	/* must have one def */
#endif /* SKIP41 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\c_plumhall\D41DRV.c ===
/* The Plum Hall Validation Suite for C
 * Unpublished copyright (c) 1986-1988, Chiron Systems Inc and Plum Hall Inc.
 * VERSION: 1.09
 * DATE: 88/09/20
 * Each distribution of the Suite is unique in distinct but inconsequential ways.
 * As per your license agreement, your distribution is not to be moved or copied outside the Designated Site
 * without specific permission from Plum Hall Inc.
 */
/*
 * this source must be compiled with FUNCTION=d4_# defined where # is a
 * number between 1 and 12
 */

/*
 * LIB - standard library tests
 */

/* 14-Dec-1989 mrw added this to prevent unresolved external from d41a.c */
int errno_init = 0;  /* set in lib.c */

#define LIB_TEST 1      /* prevents inclusion of limits.h and float.h */
#include "defs.h"

extern void d4_1();

d41_main(int argc, char ** argv)
    {
    extern int Debug;

    if (argc > 1)
        Debug = TRUE;
    Filename = __FILE__;
    d4_1();
    report("d41");
    }
/*
 * For "almost-ANSI" compilers that are missing parts of the latest ANSI library,
 * include stubs for these functions here.
 */
#if (ANSI && !LIB_NOV_86)
#include "stubs.c"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\c_plumhall\D41D.c ===
/* The Plum Hall Validation Suite for C
 * Unpublished copyright (c) 1986-1990, Chiron Systems Inc and Plum Hall Inc.
 * VERSION: 2.00
 * DATE: 90/04/05
 * The "ANSI" mode of this suite corresponds to official ANSI C, X3.159-1989.
 * As per your license agreement, your distribution is not to be moved or copied outside the Designated Site
 * without specific permission from Plum Hall Inc.
 */

#define LIB_TEST 1
#include "defs.h"
#if !ANSI || !HAS_PROTOTYPES
#define SKIP41 1
#endif
#ifndef SKIP41
#include <stddef.h>

/*
 * 4.1.5 - Common definitions <stddef.h>
 */
void d4_1_5()
    {
    char *p = 0, *q = 0;
    struct s1
        {
        char c;
        int d;
        };
#if WIDE_CHARS
    char c1 = 'a';
    wchar_t w1;
#endif

    Filename = "d41d.c";

    iequals(__LINE__, sizeof(ptrdiff_t), sizeof(p - q)); 
    iequals(__LINE__, offsetof(struct s1, c), 0);
    checkthat(__LINE__, offsetof(struct s1, c) < offsetof(struct s1, d));
#if WIDE_CHARS
    iequals(__LINE__, sizeof(size_t), sizeof(sizeof(int)));
    checkthat(__LINE__, sizeof(wchar_t) >= sizeof(char));

    /* representation as char must == representation as wchar_t */
    w1 = (wchar_t)c1;
    iequals(__LINE__, w1, c1);
    c1 = (char)w1;
    iequals(__LINE__, w1, c1);
    p = NULL;
#endif
    }

#else
int skp41d = 1; /* must have one def */
#endif  /* SKIP41 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\c_plumhall\D41C.c ===
/* The Plum Hall Validation Suite for C
 * Unpublished copyright (c) 1986-1990, Chiron Systems Inc and Plum Hall Inc.
 * VERSION: 2.00
 * DATE: 90/04/05
 * The "ANSI" mode of this suite corresponds to official ANSI C, X3.159-1989.
 * As per your license agreement, your distribution is not to be moved or copied outside the Designated Site
 * without specific permission from Plum Hall Inc.
 */

#define LIB_TEST 1
#include "defs.h"
#if !ANSI || !HAS_PROTOTYPES
#define SKIP41 1
#endif
#ifndef SKIP41
#include <float.h>
/*
 * 4.1.4 - Limits <float.h>
 */
void d41_4b()
	{
	Filename = "d41c.c";

	/* FLT_RADIX must be a restricted constant expression.
	 * All the others need not be constant expressions (ANSI8706).
	 */
#if FLT_RADIX < 2
	complain(__LINE__);
#endif

	checkthat( - __LINE__, FLT_ROUNDS >= -1);	/* other values of FLT_ROUNDS may be implem-def */
	{
		double d1, d2, d3;

		d1 = dvalue(1.);
		d2 = dvalue(2 * DBL_EPSILON / 3);
		d3 = d1 + d2;	/* should cause rounding into lowest-order digit */
		     if (FLT_ROUNDS == 0 /* toward zero    */ && d3  > d1) complain(__LINE__);
		else if (FLT_ROUNDS == 1 /* to nearest     */ && d3 <= d1) complain(__LINE__);
		else if (FLT_ROUNDS == 2 /* toward pos inf */ && d3 <= d1) complain(__LINE__);
		else if (FLT_ROUNDS == 3 /* to neg inf     */ && d3  > d1) complain(__LINE__);

		d1 = -dvalue(1.);
		d2 = -dvalue(2 * DBL_EPSILON / 3);
		d3 = d1 + d2;	/* should cause rounding into lowest-order digit */
		     if (FLT_ROUNDS == 0 /* toward zero    */ && d3  < d1) complain(__LINE__);
		else if (FLT_ROUNDS == 1 /* to nearest     */ && d3 >= d1) complain(__LINE__);
		else if (FLT_ROUNDS == 2 /* toward pos inf */ && d3  < d1) complain(__LINE__);
		else if (FLT_ROUNDS == 3 /* to neg inf     */ && d3 >= d1) complain(__LINE__);
	}

	checkthat(__LINE__, FLT_MANT_DIG > 0);
	checkthat(__LINE__, DBL_MANT_DIG > 0);
	checkthat(__LINE__, LDBL_MANT_DIG > 0);
	checkthat(__LINE__, FLT_DIG >= 6);
	checkthat(__LINE__, DBL_DIG >= (ANSI8703 ? 10 : 6));
	checkthat(__LINE__, LDBL_DIG >= (ANSI8703 ? 10 : 6));
	checkthat(__LINE__, FLT_MIN_EXP < 0);
	checkthat(__LINE__, DBL_MIN_EXP < 0);
	checkthat(__LINE__, LDBL_MIN_EXP < 0);
	checkthat(__LINE__, FLT_MIN_10_EXP <= -37);
	checkthat(__LINE__, DBL_MIN_10_EXP <= -37);
	checkthat(__LINE__, LDBL_MIN_10_EXP <= -37);
	checkthat(__LINE__, FLT_MAX_EXP > 0);
	checkthat(__LINE__, DBL_MAX_EXP > 0);
	checkthat(__LINE__, LDBL_MAX_EXP > 0);
	checkthat(__LINE__, FLT_MAX_10_EXP >= 37);
	checkthat(__LINE__, DBL_MAX_10_EXP >= 37);
	checkthat(__LINE__, LDBL_MAX_10_EXP >= 37);
	checkthat(__LINE__, FLT_MAX >= 1E+37);
	checkthat(__LINE__, DBL_MAX >= 1E+37);
	checkthat(__LINE__, LDBL_MAX >= 1E+37);
	checkthat(__LINE__, FLT_EPSILON <= 1E-5);
	checkthat(__LINE__, DBL_EPSILON <= (ANSI8703 ? 1E-9 : 1E-5));
	checkthat(__LINE__, LDBL_EPSILON <= (ANSI8703 ? 1E-9 : 1E-5));
	checkthat(__LINE__, FLT_MIN <= 1E-37);
	checkthat(__LINE__, DBL_MIN <= 1E-37);
	checkthat(__LINE__, LDBL_MIN <= 1E-37);

	/* check that all names are really macros */
#if !defined(FLT_MANT_DIG) || !defined(DBL_MANT_DIG) || !defined(LDBL_MANT_DIG)
	complain(__LINE__);
#endif
#if !defined(FLT_DIG) || !defined(DBL_DIG) || !defined(LDBL_DIG)
	complain(__LINE__);
#endif
#if !defined(FLT_MIN_EXP) || !defined(DBL_MIN_EXP) || !defined(LDBL_MIN_EXP)
	complain(__LINE__);
#endif
#if !defined(FLT_MIN_10_EXP) || !defined(DBL_MIN_10_EXP) || !defined(LDBL_MIN_10_EXP)
	complain(__LINE__);
#endif
#if !defined(FLT_MAX_EXP) || !defined(DBL_MAX_EXP) || !defined(LDBL_MAX_EXP)
	complain(__LINE__);
#endif
#if !defined(FLT_MAX_10_EXP) || !defined(DBL_MAX_10_EXP) || !defined(LDBL_MAX_10_EXP)
	complain(__LINE__);
#endif


#if !defined(FLT_MAX) || !defined(DBL_MAX) || !defined(LDBL_MAX)
	complain(__LINE__);
#endif
#if !defined(FLT_EPSILON) || !defined(DBL_EPSILON) || !defined(LDBL_EPSILON)
	complain(__LINE__);
#endif
#if !defined(FLT_MIN) || !defined(DBL_MIN) || !defined(LDBL_MIN)
	complain(__LINE__);
#endif
	}
#else
int skp41c = 1;	/* must have one def */
#endif	/* SKIP41 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\c_plumhall\D42DRV.c ===
/* The Plum Hall Validation Suite for C
 * Unpublished copyright (c) 1986-1988, Chiron Systems Inc and Plum Hall Inc.
 * VERSION: 1.09
 * DATE: 88/09/20
 * Each distribution of the Suite is unique in distinct but inconsequential ways.
 * As per your license agreement, your distribution is not to be moved or copied outside the Designated Site
 * without specific permission from Plum Hall Inc.
 */
/*
 * this source must be compiled with FUNCTION=d4_# defined where # is a
 * number between 1 and 12
 */

/*
 * LIB - standard library tests
 */

/* 14-Dec-1989 mrw added this to prevent unresolved external from d41a.c */
//int errno_init = 0;  /* set in lib.c */

#define LIB_TEST 1      /* prevents inclusion of limits.h and float.h */
#include "defs.h"

extern void d4_2();

d42_main(int argc, char ** argv)
    {
    extern int Debug;

    if (argc > 1)
        Debug = TRUE;
    Filename = __FILE__;
    d4_2();
    report("d42");
    }
/*
 * For "almost-ANSI" compilers that are missing parts of the latest ANSI library,
 * include stubs for these functions here.
 */
#if (ANSI && !LIB_NOV_86)
#include "stubs.c"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\c_plumhall\d42.c ===
/* The Plum Hall Validation Suite for C
 * Unpublished copyright (c) 1986-1990, Chiron Systems Inc and Plum Hall Inc.
 * VERSION: 2.00
 * DATE: 90/04/05
 * The "ANSI" mode of this suite corresponds to official ANSI C, X3.159-1989.
 * As per your license agreement, your distribution is not to be moved or copied outside the Designated Site
 * without specific permission from Plum Hall Inc.
 */

#ifndef SKIP42
#define LIB_TEST 1
/*
 * 4.2 - Diagnostics <assert.h>
 */
#include "defs.h"
#undef NDEBUG
#include <assert.h>
#if !ANSI
#include <stdio.h>
#endif
void d4_2();
static void d4_2_1();
#if ANSI
void d4_2_1b();
#endif

/* NDEBUG is not defined by <assert.h>. Force an error if it is */
#if defined(NDEBUG)
    complain(__LINE__);
#endif

void d4_2()
    {
    d4_2_1();
    }
















/*
 * 4.2.1 - Program Diagnostics
 * Since assert() must abort when the argument is FALSE, we can't
 * test that here. We can, however, test that NDEBUG disables it.
 */
static void d4_2_1()
    {
    int i = ivalue(1);
    int j = ivalue(0);

    /* 4.2.1.1 assert */
#if ANSI8712
    /* assert is an expression */
    assert(i == 1), assert(j == 0);
#else
    assert(i == 1);
#endif
#if ANSI
    d4_2_1b();
#endif
    }

#else /* if SKIP42 */
void d4_2() { pr_err("d4_2: SKIPPED ENTIRELY\n"); }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\c_plumhall\D42A.c ===
/* The Plum Hall Validation Suite for C
 * Unpublished copyright (c) 1986-1990, Chiron Systems Inc and Plum Hall Inc.
 * VERSION: 2.00
 * DATE: 90/04/05
 * The "ANSI" mode of this suite corresponds to official ANSI C, X3.159-1989.
 * As per your license agreement, your distribution is not to be moved or copied outside the Designated Site
 * without specific permission from Plum Hall Inc.
 */

#ifndef SKIP42
#define LIB_TEST 1
#include "defs.h"
#if ANSI
        /* this definition should make the assertion disappear */
#undef NDEBUG
#define NDEBUG
#include <assert.h>
void d4_2_1b()
        {
        int i = ivalue(1);
        assert(i != 1);
        }
#endif

#endif /* SKIP42 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\c_plumhall\D43DRV.c ===
/* The Plum Hall Validation Suite for C
 * Unpublished copyright (c) 1986-1988, Chiron Systems Inc and Plum Hall Inc.
 * VERSION: 1.09
 * DATE: 88/09/20
 * Each distribution of the Suite is unique in distinct but inconsequential ways.
 * As per your license agreement, your distribution is not to be moved or copied outside the Designated Site
 * without specific permission from Plum Hall Inc.
 */
/*
 * this source must be compiled with FUNCTION=d4_# defined where # is a
 * number between 1 and 12
 */

/*
 * LIB - standard library tests
 */

/* 14-Dec-1989 mrw added this to prevent unresolved external from d41a.c */
//int errno_init = 0;  /* set in lib.c */

#define LIB_TEST 1      /* prevents inclusion of limits.h and float.h */
#include "defs.h"

extern void d4_3();

d43_main(int argc, char ** argv)
    {
    extern int Debug;

    if (argc > 1)
        Debug = TRUE;
    Filename = __FILE__;
    d4_3();
    report("d43");
    }
/*
 * For "almost-ANSI" compilers that are missing parts of the latest ANSI library,
 * include stubs for these functions here.
 */
#if (ANSI && !LIB_NOV_86)
#include "stubs.c"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\c_plumhall\D45.c ===
/* The Plum Hall Validation Suite for C
 * Unpublished copyright (c) 1986-1990, Chiron Systems Inc and Plum Hall Inc.
 * VERSION: 2.00
 * DATE: 90/04/05
 * The "ANSI" mode of this suite corresponds to official ANSI C, X3.159-1989.
 * As per your license agreement, your distribution is not to be moved or copied outside the Designated Site
 * without specific permission from Plum Hall Inc.
 */

#define LIB_TEST 1
#include "defs.h"
#if !ANSI && !V7
#define SKIP45 /* prior to V7, too little commonality in math to be tested */
#endif
#ifndef SKIP45
/*
 * 4.5 - Mathematics
 */
#include <math.h>
#if !ANSI
#include <errno.h>
extern int errno;
#ifndef HUGE_VAL
#define HUGE_VAL HUGE  /* the most common other name */
#endif /* of HUGE_VAL */
#else   /* if ANSI */
#if ANSI8703
#include <errno.h>
#else   /* ANSI, but not 8703 */
#include <stddef.h>
#endif  /* ANSI8703 */
#endif /* !ANSI */
static void d4_5_2();
static void d4_5_3();
static void d4_5_4();
static void d4_5_5();
static void d4_5_6();
/* 4.5 - Mathmatics <math.h>
 * This version is not intended to verify the "correctness" of the
 * results of the math library, but rather to verify the existence
 * of the functions and some domain/range properties.
 */
void d4_5()
    {
    Filename = "d45.c";
    checkthat(__LINE__, EDOM != ERANGE);
    checkthat(__LINE__, EDOM != 0);
    checkthat(__LINE__, ERANGE != 0);
    checkthat(__LINE__, HUGE_VAL > 0);
    d4_5_2();
    d4_5_3();
    d4_5_4();
    d4_5_5();
    d4_5_6();
    }

/*
 * 4.5.2 - Trignometric functions
 */
static void d4_5_2()
    {
    double pi = acos(-1.);
    double dummy = 0;

    /* 4.5.2.1 acos
     * has domain on [-1,1]
     */
    errno = 0;  /* return value on the domain errors is implem-def */
    dequals( - __LINE__, acos(-1.1), 0.0);
    iequals(__LINE__, errno, EDOM);
    errno = 0;
    dequals( - __LINE__, acos(1.1), 0.0);
    iequals(__LINE__, errno, EDOM);
    dequals(__LINE__, acos(1.), 0.0);
    dequals(__LINE__, acos(0.), pi/2);
    dequals(__LINE__, acos(-1.), pi);
    dequals(__LINE__, acos(cos(pi/4)), pi/4);

    /* 4.5.2.2 asin
     * has domain on [-1,1]
     */
    errno = 0;
    dequals( - __LINE__, asin(-1.1), 0.0);
    iequals(__LINE__, errno, EDOM);
    errno = 0;
    dequals( - __LINE__, asin(1.1), 0.0);
    iequals(__LINE__, errno, EDOM);
    dequals(__LINE__, asin(1.), pi/2);
    dequals(__LINE__, asin(0.), 0.0);
    dequals(__LINE__, asin(-1.), -pi/2);
    dequals(__LINE__, asin(cos(pi/4)), pi/4);

    /* 4.5.2.3 atan
     * has domain (-HUGE_VAL, HUGE_VAL)
     */
    dequals(__LINE__, atan(0.0), 0.0);
    dequals(__LINE__, atan(1.0), pi/4);
    dequals(__LINE__, atan(tan(pi/7)), pi/7);


    /* 4.5.2.4 atan2
     * figures out the correct quadrant
     */
    dequals(__LINE__, atan2(sin(pi/4), cos(pi/4)), pi/4);
    dequals(__LINE__, atan2(sin(3*pi/4), cos(3*pi/4)), 3*pi/4);
    dequals(__LINE__, atan2(sin(-pi/4), cos(-pi/4)), -pi/4);
    dequals(__LINE__, atan2(sin(-3*pi/4), cos(-3*pi/4)), -3*pi/4);
    errno = 0;
    atan2(0.0, 0.0);
    iequals( - __LINE__, errno, EDOM);

    /* 4.5.2.5 cos
     * works in radians
     */
    dequals(__LINE__, cos(0.0), 1.0);
    dequals(__LINE__, cos(pi/2), 0.0);
    dequals(__LINE__, cos(pi), -1.0);
    dequals(__LINE__, cos(3*pi/2), 0.0);
    dequals(__LINE__, cos(pi/4), cos(-pi/4));
    dequals(__LINE__, cos(pi/4), sin(pi/4));

    /* 4.5.2.6 sin
     * works in radians
     */
    dequals(__LINE__, sin(0.0), 0.0);
    dequals(__LINE__, sin(pi/2), 1.0);
    dequals(__LINE__, sin(pi), 0.0);
    dequals(__LINE__, sin(3*pi/2), -1.0);
    dequals(__LINE__, sin(pi/2), -sin(-pi/2));

    /* 4.5.2.7 tan
     * also works on radians
     */
    dequals(__LINE__, tan(0.0), 0.0);
    dequals(__LINE__, tan(pi/4), 1.0);
    dequals(__LINE__, tan(-pi/4), -1.0);
    }













/*
 * 4.5.3 - Hyperbolic functions
 */
static void d4_5_3()
    {
    double pi = acos(-1.);

    /* 4.5.3.1 cosh
     * range error returns HUGE_VAL and sets errno
     */
    errno = 0;
    dequals(__LINE__, cosh(HUGE_VAL), HUGE_VAL);
    iequals( - __LINE__, errno, ERANGE);
    dequals(__LINE__, cosh(1.234), cosh(-1.234));
    errno = 0;

    /* 4.5.3.2 sinh
     */
    dequals(__LINE__, sinh(HUGE_VAL), HUGE_VAL);
    iequals( - __LINE__, errno, ERANGE);
    dequals(__LINE__, sinh(1.234), -sinh(-1.234));

    /* 4.5.3.3 tanh
     */
    dequals(__LINE__, tanh(1.234), sinh(1.234)/cosh(1.234));
    dequals(__LINE__, tanh(0.0), 0.0);
    dequals(__LINE__, tanh(1.234), -tanh(-1.234));
    }

/*
 * 4.5.4 - Exponential and logrithmic functions
 */
static void d4_5_4()
    {
    int i;
    double dummy;

    /* 4.5.4.1 exp
     */
    dequals(__LINE__, exp(HUGE_VAL), HUGE_VAL);
    iequals( - __LINE__, errno, ERANGE);
    dequals(__LINE__, exp(0.0), 1.0);
    dequals(__LINE__, exp(-1.1), 1.0/exp(1.1));







    /* 4.5.4.2 frexp
     */
    dequals(__LINE__, frexp(1.234, &i), .617);
    iequals(__LINE__, i, 1);
    dequals(__LINE__, frexp(12.34, &i), .77125);
    iequals(__LINE__, i, 4);
    dequals(__LINE__, frexp(0.0, &i), 0.0);
    iequals(__LINE__, i, 0);

    /* 4.5.4.3 ldexp
     */
    dequals(__LINE__, ldexp(3.0, 2), 12.0);
    errno = 0;
    dequals(__LINE__, ldexp(1e37, 32767), HUGE_VAL);
    iequals( - __LINE__, errno, ERANGE);

    /* 4.5.4.4 log
     */
#ifndef _XBOX
    errno = 0;
    dummy = log(-1.0);
    iequals(__LINE__, errno, EDOM);
#endif
    errno = 0;
    dequals( - __LINE__, log(0.0), -HUGE_VAL);
    iequals( - __LINE__, errno, ERANGE);
    dequals(__LINE__, exp(log(1.234)), 1.234);

    /* 4.5.4.5 log10
     */
#ifndef _XBOX
    errno = 0;
    dummy = log10(-1.0);
    iequals(__LINE__, errno, EDOM);
#endif
    errno = 0;
    dequals( - __LINE__, log10(0.0), - HUGE_VAL);
    iequals( - __LINE__, errno, ERANGE);
    dequals(__LINE__, log10(1.0), 0.0);
    dequals(__LINE__, log10(1.e10), 10.0);

    /* 4.5.4.6 modf
     */
    dequals(__LINE__, modf(12.345, &dummy), .345);
    dequals(__LINE__, dummy, 12.);
    dequals(__LINE__, modf(0.0, &dummy), 0.0);
    dequals(__LINE__, dummy, 0.0);
    }






/*
 * 4.5.5 - Power functions
 */
static void d4_5_5()
    {
    double dummy;

    /* 4.5.5.1 pow
     */
    errno = 0;
    dummy = pow(0.0, 0.0);
    iequals( - __LINE__, errno, EDOM);
    errno = 0;
    dummy = pow(0.0, -1.0);
    iequals( - __LINE__, errno, EDOM);
#ifndef _XBOX
    errno = 0;
    dummy = pow(-4.3, 1.1);
    iequals(__LINE__, errno, EDOM);
#endif
    dequals(__LINE__, log10(pow(10.0, 1.234)), 1.234);
    dequals(__LINE__, pow(-3.0, 3.0), -27.0);

    /* range errors */
    errno = 0;
    dequals(__LINE__, pow(10.0, HUGE_VAL), HUGE_VAL);
    iequals( - __LINE__, errno, ERANGE);
    errno = 0;
    /* underflow */
    dequals(__LINE__, pow(10.0, -HUGE_VAL), 0.0);
    iequals( - __LINE__, errno, ERANGE);

    /* 4.5.5.2 sqrt
     */
    errno = 0;
    dequals( - __LINE__, sqrt(-1.0), 0.0);
#ifndef _XBOX
    iequals(__LINE__, errno, EDOM);
#endif
    dequals(__LINE__, pow(sqrt(1.234), 2.0), 1.234);
    }













/*
 * 4.5.6 - Nearest integer, absolute value, and remainder functions
 */
static void d4_5_6()
    {

    /* 4.5.6.1 ceil
    */
    dequals(__LINE__, ceil(0.0), 0.0);
    dequals(__LINE__, ceil(12.345), 13.0);
    dequals(__LINE__, ceil(-12.345), -12.0);

    /* 4.5.6.2 fabs
     */
    dequals(__LINE__, fabs(12.345), 12.345);
    dequals(__LINE__, fabs(-12.345), 12.345);

    /* 4.5.6.3 floor
     */
    dequals(__LINE__, floor(0.0), 0.0);
    dequals(__LINE__, floor(12.345), 12.0);
    dequals(__LINE__, floor(-12.345), -13.0);
#if ANSI
    /* 4.5.6.4 fmod
     */
    dequals(__LINE__, fmod(13.1, 5.0), 3.1);
    dequals(__LINE__, fmod(-13.1, 5.0), -3.1);
    dequals(__LINE__, fmod(13.1, -5.0), 3.1);
    dequals(__LINE__, fmod(-13.1, -5.0), -3.1);
#if ANSI8612
    dequals(- __LINE__, fmod(1., 0.), 0.);  /* DEC86 */
    checkthat(__LINE__, fmod(1E38, 1E-38) <= 1E-38);    /* DEC86 */
#endif
#endif
    }

#else /* if SKIP45 */
void d4_5() { pr_err("d4_5: SKIPPED ENTIRELY\n"); }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\c_plumhall\D44DRV.c ===
/* The Plum Hall Validation Suite for C
 * Unpublished copyright (c) 1986-1988, Chiron Systems Inc and Plum Hall Inc.
 * VERSION: 1.09
 * DATE: 88/09/20
 * Each distribution of the Suite is unique in distinct but inconsequential ways.
 * As per your license agreement, your distribution is not to be moved or copied outside the Designated Site
 * without specific permission from Plum Hall Inc.
 */
/*
 * this source must be compiled with FUNCTION=d4_# defined where # is a
 * number between 1 and 12
 */

/*
 * LIB - standard library tests
 */

/* 14-Dec-1989 mrw added this to prevent unresolved external from d41a.c */
//int errno_init = 0;  /* set in lib.c */

#define LIB_TEST 1      /* prevents inclusion of limits.h and float.h */
#include "defs.h"

extern d4_4();

d44_main(int argc, char ** argv)
    /*int argc;
    char **argv;*/
    {
    extern int Debug;

    if (argc > 1)
        Debug = TRUE;
    Filename = __FILE__;
    d4_4();
    report("d44");
    }
/*
 * For "almost-ANSI" compilers that are missing parts of the latest ANSI library,
 * include stubs for these functions here.
 */
#if (ANSI && !LIB_NOV_86)
#include "stubs.c"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\c_plumhall\D43H.h ===
/* The Plum Hall Validation Suite for C
 * Unpublished copyright (c) 1986-1990, Chiron Systems Inc and Plum Hall Inc.
 * VERSION: 2.00
 * DATE: 90/04/05
 * The "ANSI" mode of this suite corresponds to official ANSI C, X3.159-1989.
 * As per your license agreement, your distribution is not to be moved or copied outside the Designated Site
 * without specific permission from Plum Hall Inc.
 */

    int i;
    static char *digits = "0123456789";
    static char *lower = "abcdefghijklmnopqrstuvwxyz";
    static char *upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    static char *graph = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
    static char *space = " \f\t\n\r\v";
    static char *xdigit = "abcdefABCDEF";
    char *p = 0;

    Filename = "d43h.h";


    for (i = 0; i < (ANSI ? 256 : 128); ++i)
        {
        /* 4.3.1.1 isalnum
         */
        if (isalpha(i) || isdigit(i))
            checkthat(__LINE__, isalnum(i));
        else
            checkthat(__LINE__, !isalnum(i));

        /* 4.3.1.2 isalpha
         */
        if (islower(i) || isupper(i))
            checkthat(__LINE__, isalpha(i));
        else
            checkthat(__LINE__, !isalpha(i));

        /* 4.3.1.3 iscntrl
         * implementation defined, but not printable
         */
        if (isprint(i))
            checkthat(__LINE__, !iscntrl(i));

        /* 4.3.1.4 isdigit
         */
        if (in_set(i, digits))
            checkthat(__LINE__, isdigit(i));
        else
            checkthat(__LINE__, !isdigit(i));

        /* 4.3.1.5 isgraph
         */
        if (isalnum(i) || in_set(i, graph))
            checkthat(__LINE__, isgraph(i));
        else
            checkthat( - __LINE__, !isgraph(i));

        /* 4.3.1.6 islower
         */
        if (in_set(i, lower))
            checkthat(__LINE__, islower(i));
        else
            checkthat(__LINE__, !islower(i));

        /* 4.3.1.7 isprint
         */
        if (isgraph(i) || i == ' ')
            checkthat(__LINE__, isprint(i));
        else
            checkthat(__LINE__, !isprint(i));

        /* 4.3.1.8 ispunct
         */
        if (isgraph(i) && !isalnum(i))
            checkthat(__LINE__, ispunct(i));
        else
            checkthat(__LINE__, !ispunct(i));

        /* 4.3.1.9 isspace
         */
        if (in_set(i, space))
            checkthat(__LINE__, isspace(i));
        else
            checkthat(__LINE__, !isspace(i));

        /* 4.3.1.10 isupper
         */
        if (in_set(i, upper))
            checkthat(__LINE__, isupper(i));
        else
            checkthat(__LINE__, !isupper(i));

        /* 4.3.1.11 isxdigit
         */
        if (isdigit(i) || in_set(i, xdigit))
            checkthat(__LINE__, isxdigit(i));
        else
            checkthat(__LINE__, !isxdigit(i));


        /* 4.3.2.1 tolower
         * does nothing for !isalpha
         */
        /* 4.3.2.2 toupper
         * does nothing for !isalpha
         */
        if (islower(i))
            checkthat(__LINE__, toupper(i) != i);
        else if (isupper(i))
            checkthat(__LINE__, tolower(i) != i);
        else
            {
            iequals(__LINE__, toupper(i), i);
            iequals(__LINE__, tolower(i), i);
            }
        }

    /* check case mapping */
    for (i = 0; i < (int)strlen(upper); ++i)
        {
        iequals(__LINE__, tolower(upper[i]), lower[i]);
        iequals(__LINE__, toupper(lower[i]), upper[i]);
        }

    /* EOF is a legal argument to these functions */
    if (isalnum(EOF))
        complain(__LINE__);
    if (isalpha(EOF))
        complain(__LINE__);
    if (iscntrl(EOF))
        complain(__LINE__);
    if (isdigit(EOF))
        complain(__LINE__);
    if (isgraph(EOF))
        complain(__LINE__);
    if (islower(EOF))
        complain(__LINE__);
    if (isprint(EOF))
        complain(__LINE__);
    if (ispunct(EOF))
        complain(__LINE__);
    if (isspace(EOF))
        complain(__LINE__);
    if (isupper(EOF))
        complain(__LINE__);
    if (isxdigit(EOF))
        complain(__LINE__);

    checkthat(__LINE__, toupper(EOF) == EOF);
    checkthat(__LINE__, tolower(EOF) == EOF);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\c_plumhall\D43.c ===
/* The Plum Hall Validation Suite for C
 * Unpublished copyright (c) 1986-1990, Chiron Systems Inc and Plum Hall Inc.
 * VERSION: 2.00
 * DATE: 90/04/05
 * The "ANSI" mode of this suite corresponds to official ANSI C, X3.159-1989.
 * As per your license agreement, your distribution is not to be moved or copied outside the Designated Site
 * without specific permission from Plum Hall Inc.
 */

#ifndef SKIP43
#define LIB_TEST 1
#include "defs.h"

void d4_3_1();
void d4_3_real();

/*
 * 4.3 - Character handling.
 * Note that these tests assume the "C" locale.
 */
void d4_3()
	{
	d4_3_1();
	d4_3_real();
	}

#if (!ANSI && !ALL_CTYPE_FNS)
#define isgraph(c) (isprint(c) && (c)!=' ')
#define toupper(c) (islower(c) ? (c)+('A'-'a') : (c))
#define tolower(c) (isupper(c) ? (c)+('a'-'A') : (c))
#endif

#include <stdio.h>
#include <ctype.h>
size_t strlen( const char * );
int in_set(int i, char * string);
/*int in_set();*/
/*
 * 4.3.1 Character testing functions
 */
void d4_3_1()
	{
#include "d43h.h"
	}







/*
 * IN_SET - check that the character is in the set. We
 * won't try to use the string library functions.
 */
int in_set(int i, char * string)
	/*int i;
	char *string;*/
	{
	while (*string)
		{
		if (*string == i)
			return(TRUE);
		++string;
		}
	return(FALSE);
	}

/* 
 * D4_3_REAL: undefine all of the macros and do the
 * same set of tests for the underlying functions.
 */
#undef isalpha
#undef isupper
#undef islower
#undef isdigit
#undef isxdigit
#undef isspace
#undef ispunct
#undef isalnum
#undef isprint
#undef isgraph
#undef iscntrl
#undef toupper
#undef tolower
void d4_3_real()
	{
#if ANSI
#include "d43h.h"
#endif
	}

#else /* if SKIP43 */
void d4_3() { pr_err("d4_3: SKIPPED ENTIRELY\n"); }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\c_plumhall\D45DRV.c ===
/* The Plum Hall Validation Suite for C
 * Unpublished copyright (c) 1986-1988, Chiron Systems Inc and Plum Hall Inc.
 * VERSION: 1.09
 * DATE: 88/09/20
 * Each distribution of the Suite is unique in distinct but inconsequential ways.
 * As per your license agreement, your distribution is not to be moved or copied outside the Designated Site
 * without specific permission from Plum Hall Inc.
 */
/*
 * this source must be compiled with FUNCTION=d4_# defined where # is a
 * number between 1 and 12
 */

/*
 * LIB - standard library tests
 */

/* 14-Dec-1989 mrw added this to prevent unresolved external from d41a.c */
//int errno_init = 0;  /* set in lib.c */

#define LIB_TEST 1      /* prevents inclusion of limits.h and float.h */
#include "defs.h"

extern void d4_5();

d45_main(int argc, char ** argv)
    /*int argc;
    char **argv;*/
    {
    extern int Debug;

    if (argc > 1)
        Debug = TRUE;
    Filename = __FILE__;
    d4_5();
    report("d45");
    }
/*
 * For "almost-ANSI" compilers that are missing parts of the latest ANSI library,
 * include stubs for these functions here.
 */
#if (ANSI && !LIB_NOV_86)
#include "stubs.c"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\c_plumhall\D44.c ===
/* The Plum Hall Validation Suite for C
 * Unpublished copyright (c) 1986-1990, Chiron Systems Inc and Plum Hall Inc.
 * VERSION: 2.00
 * DATE: 90/04/05
 * The "ANSI" mode of this suite corresponds to official ANSI C, X3.159-1989.
 * As per your license agreement, your distribution is not to be moved or copied outside the Designated Site
 * without specific permission from Plum Hall Inc.
 */

#define LIB_TEST 1
#include "defs.h"
#if !ANSI
#define SKIP44 1
#endif

#ifndef SKIP44

/*
 * 4.4 - Localization
 * This file is not relevant to pre ANSI C compilers.
 */
#include <string.h>
void d4_4();
void d4_4_1();
void d4_4_2();
#include <locale.h>

void d4_4()
	{
	char *p;

	/* make sure that the required macros produce constant expressions */
	static int lc_all =	LC_ALL;
	static int lc_collate = LC_COLLATE;
	static int lc_ctype = LC_CTYPE;
	static int lc_numeric = LC_NUMERIC;
	static int lc_time = LC_TIME;
#if ANSI8709
	static int lc_monetary = LC_MONETARY;
#if !defined(LC_MONETARY)
	complain(__LINE__);
#endif	/* LC_MONETARY */
#endif	/* ANSI8709 */

/* make sure that these are macros */
#if !defined(LC_ALL) || !defined(LC_COLLATE) || !defined(LC_CTYPE)
	complain(__LINE__);
#elif !defined(LC_NUMERIC) || !defined(LC_TIME) || !defined(NULL)
	complain(__LINE__);
#endif	/* defined macros */

	Filename = "d44.c";
	d4_4_1();
	d4_4_2();

#if ANSI8712
	/* make sure that NULL is defined in this file */
	p = NULL;
#endif	/* ANSI8712 */
	}

/*
 * 4.4.1 Locale Control
 */
void d4_4_1()
	{
#if ANSI8709
	extern void check_locale( int, int );

	/* 4.4.1.1 setlocale
	 * startup condition must be the "C" locale
	 */
	check_locale(__LINE__, LC_COLLATE);
	check_locale(__LINE__, LC_CTYPE);
	check_locale(__LINE__, LC_NUMERIC);
	check_locale(__LINE__, LC_TIME);
	check_locale(__LINE__, LC_MONETARY);
	check_locale(__LINE__, LC_ALL);
#endif	/* ANSI8709 */

	/* Each successful call to setlocale returns the NEW locale string.
	 * Change to the "native" environment
	 * (empty string) and check that non-NULL is returned.
	 */
	checkthat(__LINE__, setlocale(LC_COLLATE, "") != NULL);	
	checkthat(__LINE__, setlocale(LC_CTYPE, "") != NULL);	
	checkthat(__LINE__, setlocale(LC_NUMERIC, "") != NULL);	
	checkthat(__LINE__, setlocale(LC_TIME, "") != NULL);	
#if ANSI8709	
	checkthat(__LINE__, setlocale(LC_MONETARY, "") != NULL);	
#endif	
	checkthat(__LINE__, setlocale(LC_ALL, "") != NULL);	

	/* now reset to the "C" environment for the rest of the tests */
	setlocale(LC_ALL, "C");
	check_locale(__LINE__, LC_COLLATE);
	check_locale(__LINE__, LC_CTYPE);
	check_locale(__LINE__, LC_NUMERIC);
	check_locale(__LINE__, LC_TIME);
	check_locale(__LINE__, LC_MONETARY);
	check_locale(__LINE__, LC_ALL);
	}

#include <limits.h>	/* to get CHAR_MAX for use below */
/*
 * 4.4.2 Locale Control
 */
void d4_4_2()
	{
#if ANSI8709
	struct lconv *plc;
	/* the default locale is "C" ... make sure that the values are correct */
	plc = localeconv();
	stequals(__LINE__, plc->decimal_point, ".");
	stequals(__LINE__, plc->thousands_sep, "");
	stequals(__LINE__, plc->grouping, "");
	stequals(__LINE__, plc->int_curr_symbol, "");
	stequals(__LINE__, plc->currency_symbol, "");
	stequals(__LINE__, plc->mon_decimal_point, "");
	stequals(__LINE__, plc->mon_thousands_sep, "");
	stequals(__LINE__, plc->mon_grouping, "");
	stequals(__LINE__, plc->positive_sign, "");
	stequals(__LINE__, plc->negative_sign, "");
	iequals(__LINE__, plc->int_frac_digits, CHAR_MAX);
	iequals(__LINE__, plc->frac_digits, CHAR_MAX);
	iequals(__LINE__, plc->p_cs_precedes, CHAR_MAX);
	iequals(__LINE__, plc->p_sep_by_space, CHAR_MAX);
	iequals(__LINE__, plc->n_cs_precedes, CHAR_MAX);
	iequals(__LINE__, plc->n_sep_by_space, CHAR_MAX);
	iequals(__LINE__, plc->p_sign_posn, CHAR_MAX);
	iequals(__LINE__, plc->n_sign_posn, CHAR_MAX);
#endif	/* ANSI8709 */
	}

















/*
 * check_locale - make sure that the initial locale
 * is equivalent to the "C" locale.
 */
void check_locale(int lineno, int localenum)
	/*int lineno;
	int localenum;*/
	{
	char *p, buff[512];
	char *nolocale = "Unrecognized Locale String";

	/* get the (non-NULL) inital value of the locale */
	p = setlocale(localenum, NULL);
	if (p == NULL)
		{
		stequals(lineno, "initial locale", "C");
		return;
		}
	strncpy(buff, p, 512);

	/* this should be the same as setting to "C" locale */
	p = setlocale(localenum, "C");
	if (p == NULL)
		{
		stequals(lineno, "C locale", "C");
		return;
		}
	stequals(lineno, p, buff);

	/* now make sure that an unrecognized string returns
	 * NULL and leaves the locale unchanged.
	 */
	p = setlocale(localenum, nolocale);
	if (p != NULL)
		{
		stequals(lineno, "unrecognized locale", "NULL");
		return;
		}

	/* is it unchanged? */
	p = setlocale(localenum, NULL);
	if (p == NULL)
		{
		stequals(lineno, "unchanged locale", "C");
		return;
		}
	stequals(lineno, p, buff);
	}



#else	/* SKIP44 */
void d4_4() { pr_err("d4_4: SKIPPED ENTIRELY\n"); }
#endif	/* SKIP44 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\c_plumhall\D46.c ===
/* The Plum Hall Validation Suite for C
 * Unpublished copyright (c) 1986-1990, Chiron Systems Inc and Plum Hall Inc.
 * VERSION: 2.00
 * DATE: 90/04/05
 * The "ANSI" mode of this suite corresponds to official ANSI C, X3.159-1989.
 * As per your license agreement, your distribution is not to be moved or copied outside the Designated Site
 * without specific permission from Plum Hall Inc.
 */

#ifndef SKIP46
#define LIB_TEST 1
#include "defs.h"

/*
 * 4.6 - Non-Local jumps
 */

#include <setjmp.h>
void d4_6x();

static jmp_buf buffer;
static int count = 0;
void d4_6()
        {
#if ANSI
        volatile int i=0;
#else
        int i=0;
#endif

        Filename = "d46.c";

        /* 4.6.1.1 setjmp
         */

        /* test in the context of an if */
        if (setjmp(buffer) == 0)
                {
                /* first time through */
                iequals(__LINE__, count, 0);
                d4_6x();
                }
        else
                iequals(__LINE__, count, 1);






        /* now make sure that it works in the context of a switch */
        count = 0;
        switch (setjmp(buffer))
                {
        case 0: /* initial call, no longjmp */
                iequals(__LINE__, count, 0);
                break;
        case 2: /* after first longjmp call */
                iequals(__LINE__, count, 1);
#if ANSI
                iequals(__LINE__, i++, 17);
#else
                iequals(-__LINE__, i++, 17);
#endif
                d4_6x();
                break;
        case 1: /* after second longjmp call */
                /* longjmp with arg of 0 makes setjmp return non-zero */
                iequals(__LINE__, count, 2);
#if ANSI
                iequals(__LINE__, i, 18);
#else
                iequals(-__LINE__, i, 18);
#endif
                return;
                }

        i = 17;
        d4_6x();
        }

void d4_6x()
        {
        /* 4.6.1.2 longjmp
         */
        if (count++ == 0)
                longjmp(buffer, 2);
        else
                longjmp(buffer, 0);

        /* this statement never reached */
        complain(__LINE__);
        }


#else /* if SKIP46 */
void d4_6() { pr_err("d4_6: SKIPPED ENTIRELY\n"); }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\c_plumhall\D46DRV.c ===
/* The Plum Hall Validation Suite for C
 * Unpublished copyright (c) 1986-1988, Chiron Systems Inc and Plum Hall Inc.
 * VERSION: 1.09
 * DATE: 88/09/20
 * Each distribution of the Suite is unique in distinct but inconsequential ways.
 * As per your license agreement, your distribution is not to be moved or copied outside the Designated Site
 * without specific permission from Plum Hall Inc.
 */
/*
 * this source must be compiled with FUNCTION=d4_# defined where # is a
 * number between 1 and 12
 */

/*
 * LIB - standard library tests
 */

/* 14-Dec-1989 mrw added this to prevent unresolved external from d41a.c */
//int errno_init = 0;  /* set in lib.c */

#define LIB_TEST 1      /* prevents inclusion of limits.h and float.h */
#include "defs.h"

extern void d4_6();

d46_main(int argc, char ** argv)
    /*int argc;
    char **argv;*/
    {
    extern int Debug;

    if (argc > 1)
        Debug = TRUE;
    Filename = __FILE__;
    d4_6();
    report("d46");
    }
/*
 * For "almost-ANSI" compilers that are missing parts of the latest ANSI library,
 * include stubs for these functions here.
 */
#if (ANSI && !LIB_NOV_86)
#include "stubs.c"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\c_plumhall\D47B.c ===
/* The Plum Hall Validation Suite for C
 * Unpublished copyright (c) 1986-1990, Chiron Systems Inc and Plum Hall Inc.
 * VERSION: 2.00
 * DATE: 90/04/05
 * The "ANSI" mode of this suite corresponds to official ANSI C, X3.159-1989.
 * As per your license agreement, your distribution is not to be moved or copied outside the Designated Site
 * without specific permission from Plum Hall Inc.
 */

#ifndef SKIP47
#define LIB_TEST 1
/*
 * 4.7 - Signal handling (Continued)
 */
#include "defs.h"

#if ANSI
#include <signal.h>
extern volatile sig_atomic_t flag_sig;
extern void (*prev_fn)(int);
typedef void (*PIF)(int);

/* handler - record signal number in flag_sig */
static void handler(int sig_no)
    {
    flag_sig = sig_no;
    }

/* d4_7b - establish handler for sig_no */
PIF d4_7b(int sig_no)
    /*int sig_no;*/
    {
    flag_sig = 0;
    prev_fn = signal(sig_no, handler);
    return (prev_fn);
    }

#include <setjmp.h>
/* d4_7b_2 - a signal handler that longjmps out */
void d4_7b_2(int sig_no)
    /*int sig_no;*/
    {
    extern jmp_buf d7jbuf;

    longjmp(d7jbuf, sig_no);    /* no-return is ok; see 3.6.6.4 */
    }
#endif  /* ANSI */

#endif  /* SKIP47 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\c_plumhall\D48DRV.c ===
/* The Plum Hall Validation Suite for C
 * Unpublished copyright (c) 1986-1988, Chiron Systems Inc and Plum Hall Inc.
 * VERSION: 1.09
 * DATE: 88/09/20
 * Each distribution of the Suite is unique in distinct but inconsequential ways.
 * As per your license agreement, your distribution is not to be moved or copied outside the Designated Site
 * without specific permission from Plum Hall Inc.
 */
/*
 * this source must be compiled with FUNCTION=d4_# defined where # is a
 * number between 1 and 12
 */

/*
 * LIB - standard library tests
 */

/* 14-Dec-1989 mrw added this to prevent unresolved external from d41a.c */
//int errno_init = 0;  /* set in lib.c */

#define LIB_TEST 1      /* prevents inclusion of limits.h and float.h */
#include "defs.h"

extern void d4_8();

d48_main(int argc, char ** argv)
    /*int argc;
    char **argv;*/
    {
    extern int Debug;

    if (argc > 1)
        Debug = TRUE;
    Filename = __FILE__;
    d4_8();
    report("d48");
    }
/*
 * For "almost-ANSI" compilers that are missing parts of the latest ANSI library,
 * include stubs for these functions here.
 */
#if (ANSI && !LIB_NOV_86)
#include "stubs.c"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\c_plumhall\D47.c ===
/* The Plum Hall Validation Suite for C
 * Unpublished copyright (c) 1986-1990, Chiron Systems Inc and Plum Hall Inc.
 * VERSION: 2.00
 * DATE: 90/04/05
 * The "ANSI" mode of this suite corresponds to official ANSI C, X3.159-1989.
 * As per your license agreement, your distribution is not to be moved or copied outside the Designated Site
 * without specific permission from Plum Hall Inc.
 */

#ifndef SKIP47
#define LIB_TEST 1
/*
 * 4.7 - Signal handling. Both signal() and raise() are tested here.
 * This file is not relevant for pre ANSI C.
 */
#include "defs.h"

#if !ANSI
void d4_7() { }
#else

#include <signal.h>
void d4_7x(int);
void d4_7y(void);
static volatile sig_atomic_t flag = 0;
volatile sig_atomic_t flag_sig = 0;
void (*prev_fn)(int) = SIG_DFL;
static int num_sig[] = {SIGABRT, SIGFPE, SIGILL, SIGINT, SIGSEGV, SIGTERM};
typedef void (*PIF)(int);
PIF d4_7b(int);
void d4_7b_2(int);

void d4_7()
	{
	int i, j;

	Filename = "d47.c";

	/* make sure that these are actually macros */
	#if !defined(SIG_DFL) || !defined(SIG_ERR) || !defined(SIG_IGN)
		complain(__LINE__);
	#elif !defined(SIGABRT) || !defined(SIGFPE) || !defined(SIGILL)
		complain(__LINE__);
	#elif !defined(SIGINT) || !defined(SIGSEGV) || !defined(SIGTERM)
		complain(__LINE__);
	#endif




	/* test that SIG modes are distinct and of type void (*)(int) */
	checkthat(__LINE__, SIG_DFL != SIG_ERR && SIG_DFL != SIG_IGN && SIG_ERR != SIG_IGN);
	{void (*p)(int) = SIG_DFL; checkthat(__LINE__, sizeof(void (*)(int)) == sizeof(SIG_DFL));}
	{void (*p)(int) = SIG_ERR; checkthat(__LINE__, sizeof(void (*)(int)) == sizeof(SIG_ERR));}
	{void (*p)(int) = SIG_IGN; checkthat(__LINE__, sizeof(void (*)(int)) == sizeof(SIG_IGN));}

	/* test that SIG numbers are positive and distinct */
	for (i = 0; i < 6; ++i)
		{
		checkthat(__LINE__, num_sig[i] > 0);
		for (j = 0; j < i; ++j)
			inotequals(__LINE__, num_sig[i], num_sig[j]);
		}



	/* 4.7.1.1 signal
	 * it can be set to a user function ... raise should change the flag
	 */
	signal(SIGINT, d4_7x);
	/* 4.7.2.1 raise
	 */
 	iequals(__LINE__, raise(SIGINT), 0);
 	iequals(__LINE__, flag, 2);

	/* after the raise, the signal handler MAY have set SIG_DFL */
	checkthat( - __LINE__, signal(SIGINT, d4_7x) == SIG_DFL);

	/* the signal can be set to ignore the raise */
	flag = 0;
	signal(SIGINT, SIG_IGN);
 	iequals(__LINE__, raise(SIGINT), 0);
 	iequals(__LINE__, flag, 0);
	
	/* the return from signal should be the "previous" value */
	signal(SIGINT, d4_7x);
	checkthat(__LINE__, d4_7x == signal(SIGINT, SIG_DFL));

	/* more extensive raise tests, with externally-linked subfunctions */
	checkthat(__LINE__, d4_7b(SIGABRT) != SIG_ERR);
	flag_sig = 0;
	raise(SIGABRT);
	checkthat(__LINE__, flag_sig == (sig_atomic_t)SIGABRT);
	prev_fn = signal(SIGABRT, SIG_DFL);
	checkthat( - __LINE__, prev_fn == SIG_DFL);





	checkthat(__LINE__, d4_7b(SIGTERM) != SIG_ERR);
	flag_sig = 0;
	raise(SIGTERM);
	checkthat(__LINE__, flag_sig == (sig_atomic_t)SIGTERM);
	prev_fn = signal(SIGTERM, SIG_DFL);
	checkthat( - __LINE__, prev_fn == SIG_DFL);

	/* test that signal returns the previous handler */
	prev_fn = signal(SIGTERM, SIG_IGN);
	prev_fn = signal(SIGTERM, SIG_DFL);
	checkthat(__LINE__, prev_fn == SIG_IGN);

	/* test that we can longjmp out of the signal handler */
	d4_7y();

	/* test that bad SIG numbers are diagnosed */
	/* (But test is only a warning, because signal numbers are implem-def'ed.) */
	checkthat( - __LINE__, SIG_ERR == signal(100+SIGABRT+SIGFPE+SIGILL+SIGINT+SIGSEGV+SIGTERM, SIG_IGN));
	}




void d4_7x(signo)
	int signo;
	{
	iequals(__LINE__, signo, SIGINT);
	flag = 2;
	}

/* make sure that a signal handler can do a longjmp */
#include <setjmp.h>
jmp_buf d7jbuf = {0};
void d4_7y()
	{
	signal(SIGINT, d4_7b_2);
	if (setjmp(d7jbuf) == 0)
		{
		raise(SIGINT);
		/* this line should never be reached */
		complain(__LINE__);
		}
	}
		
#endif

#else /* if SKIP47 */
void d4_7() { pr_err("d4_7: SKIPPED ENTIRELY\n"); }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\c_plumhall\D49.c ===
/* The Plum Hall Validation Suite for C
 * Unpublished copyright (c) 1986-1990, Chiron Systems Inc and Plum Hall Inc.
 * VERSION: 2.00
 * DATE: 90/04/05
 * The "ANSI" mode of this suite corresponds to official ANSI C, X3.159-1989.
 * As per your license agreement, your distribution is not to be moved or copied outside the Designated Site
 * without specific permission from Plum Hall Inc.
 */

#ifndef SKIP49
#define LIB_TEST 1
/*
 * 4.9 - Input / Output <stdio.h>
 */
#include <stdio.h>
#include <ctype.h>
#include "defs.h"

#if ANSI

#include <string.h>
#include <stdarg.h>
#include <stddef.h>
#define W_BIN "wb"
#define R_BIN "rb"
#define A_BIN "ab"
#define WU_BIN "w+b"
#define RU_BIN "r+b"
#define AU_BIN "a+b"
#define W_BIN_U "wb+"
#define R_BIN_U "rb+"
#define A_BIN_U "ab+"
void d4_9_6_9(char *, char *, ...);
#define L_FirstName L_tmpnam

#else

#define L_FirstName 256

#endif

static char FirstName[L_FirstName] = {0};
char names[25+1][L_FirstName] = {0};
int next_name = 0;
char *save_name(char * p)
    /*char *p;*/
    {
    if (next_name < 25)
        strcpy(names[next_name++], p);
    return (p);
    }
#if !ANSI && !V7
extern int errno;
#endif

#if ANSI8703 || V7
#include <errno.h>
#endif

/* if ANSI, but prior to 87/03, errno will be found in <stddef.h> */

#if !ANSI

#define remove unlink
#define rename(old, new) ((link(old, new) == 0 && unlink(old) == 0) ? 0 : -1)
#define SEEK_SET 0
#define SEEK_CUR 1
#define SEEK_END 2
#define W_BIN "w"
#define R_BIN "r"
#define A_BIN "a"
#define WU_BIN "w+"
#define RU_BIN "r+"
#define AU_BIN "a+"
#define W_BIN_U "w+"
#define R_BIN_U "r+"
#define A_BIN_U "a+"

#endif

static int c;   /* for use in various SKIPNULLS */
static void d4_9_1();
static void d4_9_2();
static void d4_9_3();
static void d4_9_4();
static void d4_9_4_4();
static void d4_9_5();
static void d4_9_5_3();
static void d4_9_6();
static void d4_9_7();
static void d4_9_7_11(char * afile, char * mode);
static void d4_9_8();
static void d4_9_9();
static void d4_9_10();
void print();   /* in d49a.c */
void scan();    /* in d49a.c */

void d4_9()
    {
printf("BEGIN D49 TESTS\n");
    Filename = "d49.c";
    d4_9_1();
printf("ONE\n");
    d4_9_2();
printf("TWO\n");
    d4_9_3();
printf("THREE\n");
    d4_9_4();
printf("FOUR\n");
    d4_9_5();
printf("FIVE\n");
    d4_9_6();
    d4_9_7();
    d4_9_8();
    d4_9_9();
    d4_9_10();
    d4_9_4_4(); /* do after all tmpnam calls are completed */
printf("END of D4_9 TESTS\n");
    }
/*
 * 4.9.1 - Introduction
 */
static void d4_9_1()
    {
#if ANSI

    int i, j, k;
    FILE *files[FOPEN_MAX-3];

    /* check for existence of required macros */
    i = _IOFBF;
    j = _IOLBF;
    k = _IONBF;
    checkthat(__LINE__, EOF < 0);

    /* size_t is defined here (and elsewhere) */
    iequals(__LINE__, sizeof(size_t), sizeof(size_t));

#ifndef FILENAME_MAX
    complain(__LINE__);
#endif
    /* make sure that FOPEN_MAX-3 files can be opened simultaneously ...
     * the -3 allows for stdin, stdout, and stderr.
     *
     * IT HAS BEEN DETERMINED THAT THE STANDARD DOES NOT MANDATE THAT
     * CALLING  tmpfile  FOR  FOPEN_MAX-3  TIMES MUST SUCCEED.
     * AN IMPLEMENTATION WHICH FAILS THIS FORM OF THE TEST MAY SUPPLY
     * AN ALTERNATIVE PROGRAM TO DEMONSTRATE THAT  FOPEN_MAX-3  FILES
     * CAN BE OPENED SUCCESSFULLY.
     */
    for (i = 0; i < FOPEN_MAX-3; ++i)
        {
        files[i] = tmpfile();
        if (checkthat (__LINE__, files[i] != NULL) == 0)
            break;
        }

    /* now clean it up */
    while (--i >= 0)
        iequals(__LINE__, fclose(files[i]), 0);

#endif

    }





/*
 * 4.9.2 - Streams
 */
static void d4_9_2()
    {
    int i;
    char to[254], from[254];
    FILE *fd;

    save_name(tmpnam(FirstName));

    /* in text mode, we are guaranteed to get back chars in the
     * same order as written if they are printable, HT, NL, VT, or FF
     */
    fd = fopen(FirstName, "w");
    for (i = 0; i < 256; ++i)
        if (isprint(i) || i == '\t' || i == '\v' || i == '\n' || i == '\f')
            fputc(i, fd);
    fputc('\n', fd);
    fclose(fd);
    fd = fopen(FirstName, "r");
    for (i = 0; i < 256; ++i)
        if (isprint(i) || i == '\t' || i == '\v' || i == '\n' || i == '\f')
            if (!iequals(__LINE__, fgetc(fd), i))
                break;
    iequals(__LINE__, fgetc(fd), '\n');
    iequals(__LINE__, fgetc(fd), EOF);
    fclose(fd);
    remove(FirstName);

    /* in binary mode, the characters must all match */
    fd = fopen(FirstName, W_BIN);
    for (i = 0; i < 256; ++i)
        fputc(i, fd);
    fclose(fd);
    fd = fopen(FirstName, R_BIN);
    for (i = 0; i < 256; ++i)
        if (!iequals(__LINE__, fgetc(fd), i))
            break;
#define SKIPNULLS(fd, i) \
    if ((i = fgetc(fd)) == 0) \
        { complain(- __LINE__); while ((i = fgetc(fd)) == 0) ; }
    SKIPNULLS(fd, i);

    iequals(__LINE__, i, EOF);

    fclose(fd);
    remove(FirstName);


    /* make sure that a text mode file can support a line == 254 chars */
    fd = fopen(FirstName, "w");
    for (i = 0; i < 253; ++i)
        to[i] = "0123456789"[i % 10];
    to[253] = '\n';
    fwrite(to, 254, 1, fd);
    fwrite(" \n", 2, 1, fd);    /* ANSI8612 write whitespace before newline */
    fclose(fd);
    fd = fopen(FirstName, "r");
    fread(from, 254, 1, fd);
    for (i = 0; i < 253; ++i)
        if (!iequals(__LINE__, from[i], "0123456789"[i % 10]))
            break;
    iequals(__LINE__, from[253], '\n');
    fread(from, 2, 1, fd);      /* ANSI8612 read the whitespace */
    from[2] = '\0';
    if (strcmp(from, " \n") != 0)   /* 4.9.2 P2s1 */
        {
        complain(- __LINE__);       /* whether the blank reads back is implem-def */
        iequals(__LINE__, from[0], '\n');   /* but if it does not, the line must be just newline */
        }
    fclose(fd);
    remove(FirstName);

    checkthat(__LINE__, BUFSIZ >= 256);
    }
























/*
 * 4.9.3 - Files
 */
static void d4_9_3()
    {
    char *name;
    FILE *fd;

    /* just check existence */
    FILE *f1 = stdin;
    FILE *f2 = stdout;
    FILE *f3 = stderr;

#if ANSI
#if ANSI8712
    checkthat(__LINE__, FOPEN_MAX >= 8);
#else
    checkthat(__LINE__, OPEN_MAX >= 8);
#endif

    /* whether a file of 0 length actually exists is implementation defined */
    name = save_name(tmpnam(NULL));
    fd = fopen(name, "w");
    fclose(fd);
    fd = fopen(name, "r");
    checkthat(- __LINE__, fd != NULL);
    fclose(fd);
    remove(name);
#endif
    }




















/*
 * 4.9.4 Operations on files
  */
static void d4_9_4()
    {
    FILE *f;
    char *old, *new, *tmp;
#if ANSI
    char /*name[L_tmpnam],*/ buf1[L_tmpnam], buf2[L_tmpnam], buf3[L_tmpnam];
#else
    static char name[] = "dXXXXXX";
    extern char *mktemp();
#endif

    /* 4.9.4.1 - remove */
    /* remove of non-existent file returns non-zero */
    inotequals(__LINE__, remove(save_name(tmpnam(NULL))), 0);

    /* successful remove returns 0 */
    f = fopen(new=save_name(tmpnam(NULL)), "w");
    fputc('a', f); fputc('\n', f);
    fclose(f);
    iequals(__LINE__, remove(new), 0);

    /* 4.9.4.2 The rename function */
#if ANSI
    old = save_name(tmpnam(buf1));
    new = save_name(tmpnam(buf2));
    tmp = save_name(tmpnam(buf3));
#else
    old = mktemp("aXXXXXX");
    new = mktemp("bXXXXXX");
    tmp = mktemp("cXXXXXX");
#endif
    /* make a file, write to it, rename it, check it, clean up */
    checkthat(__LINE__, (f = fopen(old, "w")) != NULL);
    fputc('x', f); fputc('\n', f);
    fclose(f);
    iequals(__LINE__, rename(old, new), 0);
    checkthat(__LINE__, (f = fopen(new, "r")) != NULL);
    iequals(__LINE__, fgetc(f), 'x');
    iequals(__LINE__, fgetc(f), '\n');
    fclose(f);

    /* make sure that the old file is effectively removed */
    checkthat(__LINE__, (f = fopen(old, "r")) == NULL);

    /* attempt to rename non-existent file should fail and return non 0 */
    inotequals(__LINE__, rename(tmp, old), 0);

    /* if the new file exists, the behavior is implementation defined */
    checkthat(__LINE__, (f = fopen(tmp, "w")) != NULL);
    fputc('x', f); fputc('\n', f);
    fclose(f);
    inotequals(- __LINE__, rename(new, tmp), 0);

    /* clean up */
    remove(new);
    remove(tmp);
#if ANSI
    /* 4.9.4.3 The tmpfile function */
    /* temporary file creation */

    f = tmpfile();
    fputc('y', f);
    fputc('\n', f);
    iequals(__LINE__, ferror(f), 0);
    fseek(f, 0L, SEEK_SET);
    iequals(__LINE__, fgetc(f), 'y');
    fclose(f);
#endif
    /* 4.9.4.4 The tmpnam function */
#if ANSI
    checkthat(__LINE__, TMP_MAX >= 25);
    old = save_name(tmpnam(buf1));
    aequals(__LINE__, old, buf1);
#else
    old = mktemp(name);
    aequals(__LINE__, old, name);
#endif
    /* old and new above should have created unique names */
    checkthat(__LINE__, strcmp(old, new) != 0);

    }

















/*
 * 4.9.5 - File access functions
 */
char details[BUFSIZ] = {0};

static void d4_9_5()
    {
    FILE *f, *g = 0;
#if ANSI
    char buf1[L_tmpnam];
    char buf2[L_tmpnam];
    char *afile = save_name(tmpnam(buf1));
    char *bfile = save_name(tmpnam(buf2));
#else
    char *afile = mktemp("aXXXXXX");
    char *bfile = mktemp("bXXXXXX");
#endif

    /* 4.9.5.1 The fclose function */
    f = fopen(afile, "w");
    fputc('z', f);
    fputc('\n', f);
    iequals(__LINE__, fclose(f), 0);

printf("mark1\n");

    /* 4.9.5.2 The fflush function */
    /* fflush undoes the effects of an ungetc ... tested in 4.9.7.11 */

/* #if ANSI8804 */
    iequals(__LINE__, fflush(NULL), 0); /* flush all output streams */
/* #endif */  /* ANSI8804 */

    /* make sure the previous write worked OK */
    f = fopen(afile, "r");
printf("mark1.1\n");
    iequals(__LINE__, fgetc(f), 'z');
    iequals(__LINE__, fgetc(f), '\n');
    fgetc(f);
printf("mark1.2\n");
    inotequals(__LINE__, feof(f), 0);
    fclose(f);
    iequals(__LINE__, remove(afile), 0);
printf("mark2\n");
    /* 4.9.5.3 The fopen function */
    d4_9_5_3();
printf("mark3\n");
    /* 4.9.5.4 The reopen function */
    f = fopen(afile, "wb");
    fputc('a', f);
    fclose(f);
    f = fopen(bfile, "w+b");
    fputc('b', f);
    rewind(f);
    checkthat(__LINE__, (f = freopen(afile, "rb", f)) != NULL);

    /* should now be reading from afile, not bfile */
    iequals(__LINE__, fgetc(f), 'a');
    fclose(f);
printf("mark4\n");
    /* do reopens to change modes */
    checkthat(__LINE__, (f = fopen(afile, "rb")) != NULL);
    iequals(__LINE__, fgetc(f), 'a');
    checkthat(__LINE__, (f = freopen(afile, "wb", f)) != NULL);
    iequals(__LINE__, fputc('c', f), 'c');
    checkthat(__LINE__, (f = freopen(afile, "rb", f)) != NULL);
    iequals(__LINE__, fgetc(f), 'c');
    checkthat(__LINE__, (f = freopen(afile, "ab", f)) != NULL);
    iequals(__LINE__, fputc('d', f), 'd');
    if (checkthat(__LINE__, (f = freopen(afile, "r+b", f)) != NULL))
        {
        iequals(__LINE__, fgetc(f), 'c');
        SKIPNULLS(f, c); iequals(__LINE__, c, 'd');
        rewind(f);
        iequals(__LINE__, fputc('e', f), 'e');
        iequals(__LINE__, fputc('f', f), 'f');
        checkthat(__LINE__, (f = freopen(afile, "rb", f)) != NULL);
        iequals(__LINE__, fgetc(f), 'e');
        iequals(__LINE__, fgetc(f), 'f');
        SKIPNULLS(f, c);
        if (c == 'd')
            SKIPNULLS(f, c);
        iequals(__LINE__, c, EOF);
        checkthat(__LINE__, (f = freopen(afile, "w+b", f)) != NULL);
        iequals(__LINE__, fputc('g', f), 'g');
        rewind(f);
        iequals(__LINE__, fgetc(f), 'g');
        SKIPNULLS(f, c);
        if (c == 'f')
            SKIPNULLS(f, c);
        iequals(__LINE__, c, EOF);
        }
    fclose(f);
    /* get NULL pointer on failure ? */
    remove(bfile);
    f = fopen(afile, "rb");
    aequals(__LINE__, freopen(bfile, "rb", f), NULL);
    fclose(f);
    /* 4.9.5.5 The setbuf function */
    /* we have already checked for existence ... about all we can do is
     * call it and make sure that it doesn't crash the program.
     */
    f = fopen(afile, "rb");
    setbuf(f, NULL);
    setbuf(f, details);
    /* 4.9.5.6 The setvbuf function */
#if ANSI
    /* not much that can be done except check for 0/nonzero return */
    /* ANSI8809 - re-affirms that setvbuf is allowed to be "unable to perform" */
    iequals( - __LINE__, setvbuf(f, details, _IOFBF, BUFSIZ/2), 0);
    iequals( - __LINE__, setvbuf(f, details, _IOLBF, BUFSIZ/2), 0);
    iequals( - __LINE__, setvbuf(f, details, _IONBF, BUFSIZ/2), 0);
    iequals( - __LINE__, setvbuf(f, NULL, _IOFBF, BUFSIZ/2), 0);
    iequals( - __LINE__, setvbuf(f, NULL, _IOLBF, BUFSIZ/2), 0);
    iequals( - __LINE__, setvbuf(f, NULL, _IONBF, BUFSIZ/2), 0);

    /* force an illegal size and mode */
    checkthat( - __LINE__, setvbuf(f, NULL, _IOFBF, -1) != 0);
    checkthat(__LINE__, setvbuf(f, NULL, _IOFBF+_IOLBF+_IONBF, 0) != 0);
#endif

    fclose(f);
    remove(afile);
    }































/*
 * 4.9.5.3 - test all of the file open modes.
 */
static void d4_9_5_3()
    {
    FILE *f;
#if ANSI
    fpos_t pos;
    char *afile = save_name(tmpnam(NULL));
#else
    char *afile = mktemp("aXXXXXX");
#endif
    int c;

    /* open with "r" and non-existent file fails */
    aequals(__LINE__, fopen(afile, "r"), NULL);

    /* TEXT MODE
     * open(write), write a char, close.
     * open(read), read a char, check value, close.
     * open(append), seek, 0, write a char,
     * open(read), check that write was to end of file
     */
    checkthat(__LINE__, (f = fopen(afile, "w")) != NULL);

    /* make sure that ferror and feof are 0 at this point */
    iequals(__LINE__, ferror(f), 0);
    iequals(__LINE__, feof(f), 0);

    fputc('d', f); fputc('\n', f);
    fclose(f);

    checkthat(__LINE__, (f = fopen(afile, "r")) != NULL);
    iequals(__LINE__, fgetc(f), 'd');
    fclose(f);

    checkthat(__LINE__, (f = fopen(afile, "a")) != NULL);
    fseek(f, 0L, SEEK_SET);
    fputc('e', f); fputc('\n', f);
    fclose(f);
    checkthat(__LINE__, (f = fopen(afile, "r")) != NULL);
    iequals(__LINE__, fgetc(f), 'd');
    iequals(__LINE__, fgetc(f), '\n');
    iequals(__LINE__, fgetc(f), 'e');
    iequals(__LINE__, fgetc(f), '\n');
    fclose(f);
    remove(afile);



    /* BINARY MODE
     * same sequence, but with binary mode opens
     */
    checkthat(__LINE__, (f = fopen(afile, W_BIN)) != NULL);
    fputc(1, f);
    fclose(f);

    checkthat(__LINE__, (f = fopen(afile, R_BIN)) != NULL);
    iequals(__LINE__, fgetc(f), 1);
    fclose(f);

    checkthat(__LINE__, (f = fopen(afile, A_BIN)) != NULL);
    fseek(f, 0L, SEEK_SET);
    fputc(2, f);
    fclose(f);
    {
    char c;

    checkthat(__LINE__, (f = fopen(afile, R_BIN)) != NULL);
    iequals(__LINE__, fgetc(f), 1);
    SKIPNULLS(f, c);
    iequals(__LINE__, c, 2);
    fclose(f);
    remove(afile);
    }

























    /* UPDATE TEXT
     * open(write update), write, seek 0, read, check, close.
     * open(read update), read, check, seek 0, write, seek 0, check, close.
     * open(append update), seek 0, write, seek 0, read, check, close
     * open(read), read, check.
     */
    checkthat(__LINE__, (f = fopen(afile, "w+")) != NULL);
    fputc('f', f); fputc('\n', f);
    fseek(f, 0L, SEEK_SET);
    iequals(__LINE__, fgetc(f), 'f');
    fclose(f);
    checkthat(__LINE__, (f = fopen(afile, "r+")) != NULL);
    iequals(__LINE__, fgetc(f), 'f');
    fseek(f, 0L, SEEK_SET);
    fputc('g', f);
    fseek(f, 0L, SEEK_SET);
    iequals(__LINE__, fgetc(f), 'g');
    fclose(f);
    checkthat(__LINE__, (f = fopen(afile, "a+")) != NULL);
    fseek(f, 0L, SEEK_SET);
    fputc('h', f);
    fputc('\n', f);
    fseek(f, 0L, SEEK_SET);
    iequals(__LINE__, fgetc(f), 'g');
    iequals(__LINE__, fgetc(f), '\n');
    SKIPNULLS(f, c); iequals(__LINE__, c, 'h'); /* open might be binary */
    iequals(__LINE__, fgetc(f), '\n');
    fclose(f);
    remove(afile);





















    /* UPDATE BINARY (X+B form)
     * open(write update), write, seek 0, read, check, close.
     * open(read update), read, check, seek 0, write, seek 0, check, close.
     * open(append update), seek 0, write, seek -2, read, check, close
     * open(read), read, check.
     */
    checkthat(__LINE__, (f = fopen(afile, WU_BIN)) != NULL);
    fputc('f', f);
    fseek(f, 0L, SEEK_SET);
    /* we wrote 'f' ... go back to zero and check that it is there */
    iequals(__LINE__, fgetc(f), 'f');
    fclose(f);
    checkthat(__LINE__, (f = fopen(afile, RU_BIN)) != NULL);
    /* close and reopen (for read-write) ... check that it is 'f' */
    iequals(__LINE__, fgetc(f), 'f');
    fseek(f, 0L, SEEK_SET);
    fputc('g', f);
    fseek(f, 0L, SEEK_SET);


    /* we wrote over it with a 'g' ... check that out */
    iequals(__LINE__, fgetc(f), 'g');
    fclose(f);
    checkthat(__LINE__, (f = fopen(afile, AU_BIN)) != NULL);
    fseek(f, 0L, SEEK_SET);
    fputc('h', f);
    fseek(f, -2L, SEEK_CUR);
    iequals( - __LINE__, fgetc(f), 'g');
    iequals(__LINE__, fgetc(f), 'h');
    fclose(f);
    checkthat(__LINE__, (f = fopen(afile, R_BIN)) != NULL);
    /* by now the file should have a 'g' and an 'h' in it */
    iequals(__LINE__, fgetc(f), 'g');
    SKIPNULLS(f, c); iequals(__LINE__, c, 'h');
    fclose(f);















    /* In update mode, there must be a fseek,rewind,fpos, or EOF between
     * input and output, or an fflush between output and input.
     * Diagrams use _ for file position, N for possible nul-padding,
     * and  n  for new-line
     */
    checkthat(__LINE__, (f = fopen(afile, W_BIN)) != NULL);
    fputc('g', f);                              /*  g_  */
    fputc('\n', f);                             /*  g n_ */
    fclose(f);                                  /*  g n N */

    checkthat(__LINE__, (f = fopen(afile, R_BIN_U)) != NULL);
    iequals(__LINE__, fgetc(f), 'g');           /*  g_n N */
    fseek(f, 0L, SEEK_SET);                     /* _g n N */
    iequals(__LINE__, fgetc(f), 'g');           /*  g_n N */
    iequals(__LINE__, fgetc(f), '\n');          /*  g n_N */
    SKIPNULLS(f, c); iequals(__LINE__, c, EOF); /*  g n N_ */
    fseek(f, 0L, SEEK_SET);                     /* _g n N */
    fputc('i', f);                              /*  i_n N */
































    /* now make sure that these work */
    fseek(f, 0L, SEEK_SET);                     /* _i n N */
    iequals(__LINE__, fgetc(f), 'i');           /*  i_n N */
    fseek(f, 0L, SEEK_SET);                     /* _i n N */
    fputc('j', f);                              /*  j_n N */
    fseek(f, 0L, SEEK_SET);                     /* _j n N */
    iequals(__LINE__, fgetc(f), 'j');           /*  j_n N */
    iequals(__LINE__, fgetc(f), '\n');          /*  j n_N */
    SKIPNULLS(f, c); iequals(__LINE__, c, EOF); /*  j n N_ */
    fseek(f, 0L, SEEK_CUR);                     /*  j n N_*/
    fputc('z', f);                              /*  j n N z_ */
    fseek(f, 0L, SEEK_SET);                     /* _j n N z N */
    iequals(__LINE__, fgetc(f), 'j');           /*  j_n N z N */
    rewind(f);                                  /* _j n N z N */
    fputc('k', f);                              /*  k_n N z N */
    rewind(f);                                  /* _k n N z N */
    iequals(__LINE__, fgetc(f), 'k');           /*  k_n N z N */
    iequals(__LINE__, fgetc(f), '\n');          /*  k n_N z N */
    SKIPNULLS(f, c); iequals(__LINE__, c, 'z'); /*  k n N z_N */
    SKIPNULLS(f, c); iequals(__LINE__, c, EOF); /*  k n N z N_ */
#if ANSI
    fseek(f, 0L, SEEK_SET);                     /* _k n N z N */
    iequals(__LINE__, fgetc(f), 'k');           /*  k_n N z N */
    fseek(f, 0L, SEEK_CUR); /* allow writing */ /*  k_n N z N */
    fputc('l', f);                              /*  k l_N z N */
    fputc('\n', f);                             /*  k l n_N z N */
    rewind(f);                                  /* _k l n N z N */
    iequals(__LINE__, fgetc(f), 'k');           /*  k_l n N z N */
    iequals(__LINE__, fgetc(f), 'l');           /*  k l_n N z N */
    iequals(__LINE__, fgetc(f), '\n');          /*  k l n_N z N */


    fseek(f, 0L, SEEK_SET);                     /* _k l n N z N */
    fgetpos(f, &pos);                           /* _k l n N z N */
    iequals(__LINE__, fgetc(f), 'k');           /*  k_l n N z N */
    fsetpos(f, &pos);                           /* _k l n N z N */
    fputc('m', f);                              /*  m_l n N z N */
    fsetpos(f, &pos);                           /* _m l n N z N */
    iequals(__LINE__, fgetc(f), 'm');           /*  m_l n N z N */
    iequals(__LINE__, fgetc(f), 'l');           /*  m l_n N z N */
    iequals(__LINE__, fgetc(f), '\n');          /*  m l n_N z N */

#endif
    fclose(f);                                  /*  m l n N z N */
    remove(afile);                              /*  removed */





    /* UPDATE BINARY (using  XB+ form)
     * open(write update), write, seek 0, read, check, close.
     * open(read update), read, check, seek 0, write, seek -1, check, close.
     * open(append update), seek 0, write, seek -1, read, check, close
     * open(read), read, check.
     */
    checkthat(__LINE__, (f = fopen(afile, W_BIN_U)) != NULL);
    fputc('f', f);                              /*  f_ */
    fseek(f, 0L, SEEK_SET);                     /* _f */
    /* we wrote 'f' ... go back to zero and check that it is there */
    iequals(__LINE__, fgetc(f), 'f');           /*  f_ */
    fclose(f);                                  /*  f N */
    checkthat(__LINE__, (f = fopen(afile, R_BIN_U)) != NULL);
    /* close and reopen (for read-write) */     /* _f N */
    iequals(__LINE__, fgetc(f), 'f');           /*  f_N */
    fseek(f, 0L, SEEK_SET);                     /* _f N */
    fputc('g', f);                              /*  g_N */
    fseek(f, -1L, SEEK_CUR);                    /* _g N */
    iequals(__LINE__, fgetc(f), 'g');           /*  g_N */
    /* we wrote over it with a 'g' */
    fclose(f);                                  /*  g N */
    checkthat(__LINE__, (f = fopen(afile, A_BIN_U)) != NULL);
    fseek(f, 0L, SEEK_SET);                     /* _g N */
    fputc('h', f);  /* appended */              /* _g N h */
    fseek(f, 1L, SEEK_SET);                     /*  g_N h */
    SKIPNULLS(f, c);                            /*  g N h_ */
    iequals(__LINE__, c, 'h');                  /*  g N h_ */
    fclose(f);                                  /*  g N h N */
    checkthat(__LINE__, (f = fopen(afile, R_BIN)) != NULL);
    /* should have a 'g' and an 'h' */          /* _g N h N */
    iequals(__LINE__, fgetc(f), 'g');           /*  g_N h N */
    SKIPNULLS(f, c);                            /*  g N h_N */
    iequals(__LINE__, c, 'h');                  /*  g N h_N */
    fclose(f);                                  /*  g N h N */

    remove(afile);                              /*  removed */
    }













/*
 * 4.9.6 Formatted input/output functions
 */
static void d4_9_6()
    {
    int i, j;
    char buff[20];
    char *p;

    /* 4.9.6.1 The fprintf function */
    /* 4.9.6.2 The fscanf function */
    /* 4.9.6.3 The printf function */
    /* 4.9.6.4 The scanf function */
    /* 4.9.6.5 The sprintf function */
    /* make sure that excess args are evaluated */
    sprintf(buff, "%d", 3, i = 17);
    stequals(__LINE__, buff, "3");
    iequals(__LINE__, i, 17);

    /* returns number of characters transmitted */
    iequals(__LINE__, sprintf(buff, "%d", 17), 2);
    iequals(__LINE__, sprintf(buff, "%d %d", 17, 123), 6);
    iequals(__LINE__, sprintf(buff, "%s", ""), 0);
    iequals(__LINE__, sprintf(buff, "%%"), 1);

    /* now check all of the formatting primitives */
    print();
    Filename = "d49.c";

    /* 4.9.6.6 The sscanf function */
    scan();
    Filename = "d49.c";
    /* return number of items converted */
    iequals(__LINE__, sscanf("def", "abc", &p), 0);
    iequals(__LINE__, sscanf("7", "%d", &i, &j), 1);
    iequals(__LINE__, sscanf("7 8", "%d", &i, &j), 1);
    iequals(__LINE__, sscanf("7 8", "%d %d", &i, &j), 2);

    /* 4.9.6.7 The vfprintf function */
    /* 4.9.6.8 The vprintf function */
    /* 4.9.6.9 The vsprintf function */
#if ANSI
    d4_9_6_9(buff, "%s %d %s", "string1", 23, "string2");
    stequals(__LINE__, buff, "string1 23 string2");
#endif
    }




/*
 * 4.9.6.9 - check out the varargs form of formatting. */
#if ANSI
#if NEW_STYLE_FN_DEF
void d4_9_6_9(char *buff, char *fmt, ...)
#else
void d4_9_6_9(char * buff, char * fmt)
    /*char *buff;
    char *fmt;*/
#endif
    {
    va_list args;

    va_start(args, fmt);
    vsprintf(buff, fmt, args);
    va_end(args);
    }
#endif
































/*
 * 4.9.7 Character input/output
 */
static void d4_9_7()
    {
    FILE *f;
    char buff[65];
    int c, i;
#if ANSI
    char *afile = save_name(tmpnam(NULL));
#else
    char *afile = mktemp("aXXXXXX");
#endif

    /* 4.9.7.1 The fgetc function */
    /* 4.9.7.2 The fgets function */
    /* 4.9.7.3 The fputc function */
    /* 4.9.7.4 The fputs function */

    /* fgetc and fputc */
    f = fopen(afile, W_BIN);
    iequals(__LINE__, fputc(255, f), 255);
    iequals(__LINE__, fputc(0, f), 0);
    fclose(f);
    f = fopen(afile, R_BIN);
    /* make sure that there is no sign extension */
    iequals(__LINE__, fgetc(f), 255);
    iequals(__LINE__, fgetc(f), 0);
    SKIPNULLS(f, c);
    iequals(__LINE__, c, EOF);
    fclose(f);
    remove(afile);


















    /* fputs and fgets */
    f = fopen(afile, "w");
    checkthat(__LINE__, fputs("string1\nstring2\nstring3\n", f) >= 0);  /* ANSI8709: weakened requirement */
    fclose(f);
    f = fopen(afile, "r");
    aequals(__LINE__, fgets(buff, 40, f), buff);
    iequals(__LINE__, strcmp(buff, "string1\n"), 0);
    fgets(buff, 3, f);
    iequals(__LINE__, strcmp(buff, "st"), 0);
    fgets(buff, 40, f);
    iequals(__LINE__, strcmp(buff, "ring2\n"), 0);
    fgets(buff, 40, f);
    iequals(__LINE__, strcmp(buff, "string3\n"), 0);
    aequals(__LINE__, fgets(buff, 40, f), NULL);
    /* buffer remains unchanged upon end of file */
    iequals(__LINE__, strcmp(buff, "string3\n"), 0);
    fclose(f);

    /* error returns NULL */
    f = fopen(afile, "w");
    aequals(__LINE__, fgets(buff, 40, f), NULL);
    /* error returns non zero */
    f = freopen(afile, "r", f);
    inotequals( - __LINE__, fputs(buff, f), 0);
    fclose(f);
    remove(afile);
























    /* 4.9.7.5 The getc function */
    /* 4.9.7.6 The getchar function */
    /* 4.9.7.7 The gets function */
    /* 4.9.7.8 The putc function */
    /* 4.9.7.9 The putchar function */
    /* 4.9.7.10 The puts function */
    /* getc and putc */
    f = fopen(afile, W_BIN);
    iequals(__LINE__, putc(255, f), 255);
    iequals(__LINE__, putc(0, f), 0);
    fclose(f);
    f = fopen(afile, R_BIN);
    /* make sure that there is no sign extension */
    iequals(__LINE__, getc(f), 255);
    iequals(__LINE__, getc(f), 0);
    SKIPNULLS(f, c);
    iequals(__LINE__, c, EOF);
    fclose(f); remove(afile);
    /* getchar, putchar, puts, gets not tested; we don't want to lose stdin and stdout. */
    /* 4.9.7.11 The ungetc function */
    f = fopen(afile, "w");
    iequals(__LINE__, fputc('a', f), 'a');
    iequals(__LINE__, fputc('z', f), 'z');
    fclose(f);
    d4_9_7_11(afile, "r");
    f = fopen(afile, "w+");
    iequals(__LINE__, fputc('a', f), 'a');
    iequals(__LINE__, fputc('z', f), 'z');
    fclose(f);
    d4_9_7_11(afile, "r+");remove(afile);

    f = fopen(afile, W_BIN);
    iequals(__LINE__, fputc('a', f), 'a');
    iequals(__LINE__, fputc('z', f), 'z');
    fclose(f);
    d4_9_7_11(afile, R_BIN);
    d4_9_7_11(afile, R_BIN_U);
#if ANSI
    /* it should be possible to do an ungetc on an empty file */
    f = fopen(afile, W_BIN_U);
    iequals(__LINE__, ungetc('b', f), 'b');
    iequals(__LINE__, getc(f), 'b');
    /* fscanf and ungetc should not get in each others way */
    rewind(f);
    fprintf(f, "123abc\n");
    rewind(f);
    fscanf(f, "%d", &i);
    ungetc('x', f);
    iequals(__LINE__, getc(f), 'x');
    iequals(__LINE__, getc(f), 'a');
    fclose(f);
#endif
    remove(afile);
    }

/*
 * 4.9.7.11 - the ungetc code will get executed for several
 * different file open modes.
 */
static void d4_9_7_11(char * afile, char * mode)
    /*char *afile;
    char *mode;*/
    {
    long oldpos;
    int c;
    FILE *f;
#if ANSI
    fpos_t pos;
#endif

    f = fopen(afile, mode);
#if ANSI
    fgetpos(f, &pos);
#endif
    iequals(__LINE__, fgetc(f), 'a');
    iequals(__LINE__, ungetc('b', f), 'b');
    iequals(__LINE__, getc(f), 'b');
    iequals(__LINE__, ungetc('c', f), 'c');

    /* fseek, rewind, and fsetpos lose ungot character */
    fseek(f, 0L, SEEK_SET);
    iequals( - __LINE__, getc(f), 'a');
    iequals(__LINE__, getc(f), 'z');
    iequals(__LINE__, ungetc('b', f), 'b');
    rewind(f);
    iequals(__LINE__, getc(f), 'a');
    iequals(__LINE__, getc(f), 'z');
#if ANSI
    ungetc('b', f);
    fsetpos(f, &pos);
    iequals(__LINE__, getc(f), 'a');
    iequals(__LINE__, getc(f), 'z');
#endif







    /* the external file remains unchanged */
    iequals(__LINE__, ungetc('b', f), 'b');
    fclose(f);
    f = fopen(afile, mode);
    iequals(__LINE__, fgetc(f), 'a');
    iequals(__LINE__, fgetc(f), 'z');
    SKIPNULLS(f, c);
    /* record oriented systems might add this newline */
    if (c == '\n')
        c = fgetc(f);
    iequals(__LINE__, c, EOF);
    fclose(f);

    /* ungetc of EOF has no effect */
    f = fopen(afile, mode);
    iequals(__LINE__, fgetc(f), 'a');
    iequals(__LINE__, ungetc(EOF, f), EOF);
    iequals(__LINE__, fgetc(f), 'z');
    SKIPNULLS(f, c);
    /* record oriented systems might add this newline */
    if (c == '\n')
        c = fgetc(f);
    iequals(__LINE__, c, EOF);
#if ANSI
    /* a successful ungetc clears the EOF indicator */
    iequals(__LINE__, ungetc('b', f), 'b');
    iequals(__LINE__, feof(f), 0);
    iequals(__LINE__, fgetc(f), 'b');
#endif
    /* after ungetc then read, the file position is restored */
    oldpos = ftell(f);
    iequals(__LINE__, ungetc('b', f), 'b');
    iequals(__LINE__, fgetc(f), 'b');
    lequals(__LINE__, ftell(f), oldpos);

    /* if binary, the file position decrements by 1 */
    if (strchr(mode, 'b') != NULL)
        {
        oldpos = ftell(f);
        iequals(__LINE__, ungetc('a', f), 'a');
        lequals(__LINE__, ftell(f), oldpos - 1L);
        }
#if ANSI
    /* ANSI requires ability to do an ungetc at the start of a file */
    rewind(f);
    iequals(__LINE__, ungetc('b', f), 'b');
    iequals(__LINE__, fgetc(f), 'b');
    iequals(__LINE__, fgetc(f), 'a');
#endif
    fclose(f);
    }

/*
 * 4.9.8 - Direct input/output functions
 */
static long array1[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
static long array2[11] = {0};
static void d4_9_8()
    {
    FILE *f;
    int i;
#if ANSI
    char *afile = save_name(tmpnam(NULL));
#else
    char *afile = mktemp("aXXXXXX");
#endif
    int c;

    /* 4.9.8.1 The fread function */
    /* 4.9.8.2 The fwrite function */

    f = fopen(afile, W_BIN);
    iequals(__LINE__, fwrite(array1, sizeof(long), 10, f), 10);
    fclose(f);
    f = fopen(afile, R_BIN);
    iequals(__LINE__, fread(array2, sizeof(long), 6, f), 6);

    /* zero size or nelem leaves array unchanged */
    iequals(__LINE__, fread(array2, 0, sizeof(long), f), 0);
    iequals(__LINE__, fread(array2, 10, 0, f), 0);

    /* incomplete read */
    iequals(__LINE__, fread(array2+6, sizeof(long), 4, f), 4);
    for (i = 0; i < 10; ++i)
        lequals(__LINE__, array2[i], array1[i]);
    SKIPNULLS(f, c);

    /* at end of file */
    iequals(__LINE__, fread(array2, 10, sizeof(long), f), 0);
    fclose(f);
    remove(afile);
    }








/*
 * 4.9.9 - Random-access functions
 */
static char buffer[] = "     this is a test string of no particular significance\n";
static char xchar[] = "abcdefghijklmnopqrstuvwxyz";
static void d4_9_9()
    {
    FILE *f;
    int i;
    long array[100];
#if ANSI
    fpos_t pos[100];
    char *afile = save_name(tmpnam(NULL));
#else
    char *afile = mktemp("aXXXXXX");
#endif

    /* 4.9.8.1 The fgetpos function */
    /* 4.9.8.2 The fseek function */
    /* 4.9.8.3 The fsetpos function */
    /* 4.9.8.4 The ftell function */

    /*
     * create a file with 100 strings, mark the "ftell" position
     * of each one, and read them in backwards.
     */
    f = fopen(afile, "w+");
    for (i = 0; i < 100; ++i)
        {
        array[i] = ftell(f);
        buffer[0] = xchar[i%26];
        fwrite(buffer, sizeof(buffer), 1, f);
        }
    for (i = 99; i >= 0; --i)
        {
        fseek(f, array[i], SEEK_SET);
        fread(buffer, sizeof(buffer), 1, f);
        iequals(__LINE__, xchar[i%26], buffer[0]);
        }
    fclose(f); remove(afile);










    /* for binary files, ftell can compute offsets */
    f = fopen(afile, WU_BIN);
    fwrite(array, sizeof(long), 100, f);
    lequals(__LINE__, ftell(f), 100L*sizeof(long));

    fseek(f, 50L, SEEK_SET);
    lequals(__LINE__, ftell(f), 50L);
    fseek(f, 40L, SEEK_CUR);
    lequals(__LINE__, ftell(f), 90L);
    fseek(f, -40L, SEEK_END);
    lequals( - __LINE__, ftell(f), 100*sizeof(long)-40L);   /* "remark" only - could be nul-padded */

    /* fseek clears the end of file indicator */
    fseek(f, 0L, SEEK_END);
    iequals(__LINE__, fgetc(f), EOF);
    fseek(f, 0L, SEEK_END);
    iequals(__LINE__, feof(f), 0);

    /* fseek: bad requests return non-zero
     * ftell: bad requests return -1L and set errno
     */
    inotequals(__LINE__, fseek(f, -1L, SEEK_SET), 0);
    fclose(f); remove(afile);
    errno = 0;

#if ANSI
    lequals(__LINE__, ftell(f), -1L);
    inotequals(__LINE__, errno, 0);
#endif





















    f = fopen(afile, W_BIN_U);
#if ANSI
    /*
     * create a file with 100 strings, mark the "getpos" position
     * of each one, and read them in backwards.
     */
    for (i = 0; i < 100; ++i)
        {
        fgetpos(f, &pos[i]);
        buffer[0] = xchar[i%26];
        fwrite(buffer, sizeof(buffer), 1, f);
        }
    for (i = 99; i >= 0; --i)
        {
        fsetpos(f, &pos[i]);
        fread(buffer, sizeof(buffer), 1, f);
        iequals(__LINE__, xchar[i%26], buffer[0]);
        }

    /* successful return is 0, unsuccessful is non-zero + errno */
    iequals(__LINE__, fgetpos(f, &pos[0]), 0);
    iequals(__LINE__, fsetpos(f, &pos[0]), 0);
#endif
    fputs("a\n", f);    /* be sure that following tests work, even for non-ANSI */
    fclose(f);

    /* 4.9.8.5 The rewind function */
    /* rewind is the same as fseek(f, 0L, SEEK_SET) */
    /* in order for  ftell(f)  to be well-defined, */
    /* file  f  must be binary (and must be created as binary) */
    f = fopen(afile, R_BIN);
    if (f == NULL)
        complain(__LINE__);
    else
        {
        fseek(f, 0L, SEEK_END);
        iequals(__LINE__, fgetc(f), EOF);
        rewind(f);
        lequals(__LINE__, ftell(f), 0L);
        fclose(f);
        }
    remove(afile);
    }







/*
 * 4.9.10 - Error-handling functions
 */
static void d4_9_10()
    {
    FILE *f;
//!:    char * (*fp)();
#if ANSI
    char *afile = save_name(tmpnam(NULL));
#else
    char *afile = mktemp("aXXXXXX");
    extern void perror();
#endif
    char c;

    /* 4.9.9.1 The clearerr function */
    /* 4.9.9.2 The feof function */

    f = fopen(afile, W_BIN);
    fputc('x', f);
    fclose(f);
    f = fopen(afile, R_BIN);
    iequals(__LINE__, feof(f), 0);
    fgetc(f);
    SKIPNULLS(f, c);
    inotequals(__LINE__, feof(f), 0);
    clearerr(f);
    iequals(__LINE__, feof(f), 0);

    /* 4.9.9.3 The ferror function */
    iequals(__LINE__, ferror(f), 0);

    /* There is unfortunately no portable way to force an "I/O error" for testing ferror */

#if ANSI
    /* 4.9.9.4 The perror function */
    /* just check for existence */
    errno = 0;
    perror(NULL);
#endif

    fclose(f);
    remove(afile);
    }






/*
 * 4.9.4.4 - Now that tmpnam() is no longer needed, verify that
* we can get at least 25 unique names (the min-max for TMP_MAX).
 * next_name is how many have been used so far.
 */
static void d4_9_4_4()
    {
    int i, j;

#if ANSI
    for (i = 0; i < next_name; ++i)
        for (j = 0; j < i; ++j)
            if (strcmp(names[i], names[j]) == 0)
                {
                complain(__LINE__);
                return;
                }
    for (i = next_name; i < 25; ++i)
        {
        if (checkthat(__LINE__, tmpnam(names[i]) != NULL) != 0)
            return;
        for (j = 0; j < i; ++j)
            if (strcmp(names[i], names[j]) == 0)
                {
                complain(__LINE__);
                return;
                }
        }
#endif
    }

#else /* if SKIP49 */
void d4_9() { pr_err("d4_9: SKIPPED ENTIRELY\n"); }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\c_plumhall\D48.c ===
/* The Plum Hall Validation Suite for C
 * Unpublished copyright (c) 1986-1990, Chiron Systems Inc and Plum Hall Inc.
 * VERSION: 2.00
 * DATE: 90/04/05
 * The "ANSI" mode of this suite corresponds to official ANSI C, X3.159-1989.
 * As per your license agreement, your distribution is not to be moved or copied outside the Designated Site
 * without specific permission from Plum Hall Inc.
 */

#ifndef SKIP48
#define LIB_TEST 1
#include <stdio.h>
#include "defs.h"

/*
 * 4.8 - Variable arguments <stdarg.h>
 * This file is not relevant for pre ANSI C compilers.
 */

#if !ANSI
void d4_8()
	{
	}
#else

#include <stdarg.h>
int d4_8_1(int, ...);

void d4_8()
	{
	Filename = "d48.c";

	/* make sure that va_start and va_arg are macros */
	#if !defined(va_start) || !defined(va_end)
		complain(__LINE__);
	#endif
	iequals(__LINE__, 1, d4_8_1(1, 1, 2, 3));
	iequals(__LINE__, 2, d4_8_1(2, 1., 2., 3.));
	}











#if NEW_STYLE_FN_DEF
int d4_8_1(int i, ...)
#else
int d4_8_1(i)
	int i;
#endif
	{
	va_list p;
	int j;

	va_start(p, i);
	for (j = 1; j <= 3; ++j)
		{
		if (i == 1)
			iequals(__LINE__, j, va_arg(p, int));
		else
			dequals(__LINE__, (double)j, va_arg(p, double));
		}
	return (i);
	va_end(p);
	}
#endif

#else /* if SKIP48 */
void d4_8() { pr_err("d4_8: SKIPPED ENTIRELY\n"); }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\c_plumhall\D47DRV.c ===
/* The Plum Hall Validation Suite for C
 * Unpublished copyright (c) 1986-1988, Chiron Systems Inc and Plum Hall Inc.
 * VERSION: 1.09
 * DATE: 88/09/20
 * Each distribution of the Suite is unique in distinct but inconsequential ways.
 * As per your license agreement, your distribution is not to be moved or copied outside the Designated Site
 * without specific permission from Plum Hall Inc.
 */
/*
 * this source must be compiled with FUNCTION=d4_# defined where # is a
 * number between 1 and 12
 */

/*
 * LIB - standard library tests
 */

/* 14-Dec-1989 mrw added this to prevent unresolved external from d41a.c */
//int errno_init = 0;  /* set in lib.c */

#define LIB_TEST 1      /* prevents inclusion of limits.h and float.h */
#include "defs.h"

extern void d4_7();

d47_main(int argc, char ** argv)
    /*int argc;
    char **argv;*/
    {
    extern int Debug;

    if (argc > 1)
        Debug = TRUE;
    Filename = __FILE__;
    d4_7();
    report("d47");
    }
/*
 * For "almost-ANSI" compilers that are missing parts of the latest ANSI library,
 * include stubs for these functions here.
 */
#if (ANSI && !LIB_NOV_86)
#include "stubs.c"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\c_plumhall\D49A.c ===
/* The Plum Hall Validation Suite for C
 * Unpublished copyright (c) 1986-1990, Chiron Systems Inc and Plum Hall Inc.
 * VERSION: 2.00
 * DATE: 90/04/05
 * The "ANSI" mode of this suite corresponds to official ANSI C, X3.159-1989.
 * As per your license agreement, your distribution is not to be moved or copied outside the Designated Site
 * without specific permission from Plum Hall Inc.
 */

/*
 * d49a - formatting tests
 */
#ifndef SKIP49
#include <stdio.h>
#define LIB_TEST 1
#include "defs.h"
#if ANSI
#include <float.h>  /* to get DBL_MAX_10_EXP, which non-ANSI machine.h defines */
#include <string.h> /* to declare strcpy before its first use below */
#else
#define remove unlink
#endif
char *save_name( char * );
/*//!:char *strcpy(); char *strstr();*/
#define T_0 0       /* no data needed */
#define T_I1 1      /* int */
#define T_I2 2      /* int (negative) */
#define T_L1 3      /* long */
#define T_SI 4      /* short */
#define T_D1 5      /* double */
#define T_P 6       /* char * */
#define T_S 7       /* string */
#define T_STAR1 8   /* width as argument */
#define T_STAR2 9   /* precision as argument */
#define T_STAR3 10  /* width and precision as arguments */
#define T_C1 11     /* character */
#define T_C2 12     /* character */
#define T_F 13      /* float */
#define T_U 14      /* unsigned int */
#define T_D2 15     /* very large double */
#define T_D3 16     /* double with zero value */
#define T_D4 17     /* double with integral value */
#define T_D5 18     /* double with exponent < -4 */
#define T_D6 19     /* double with exponent == precision */
#define T_D7 20     /* double with exponent > precision */
#define T_D8 21     /* long double */
#define T_SU 22     /* unsigned short */
#define T_I0 23     /* integer arg with value of 0 */
#define T_STARD 24  /* width and precision as arguments */
#define T_STARN 25  /* width and precision with a neg number */

static int Ival1 = 77;
static int Ival2 = -77;
static long Lval1 = 65000;
static short Sval = 0x7fff;
static unsigned short Suval = 0x7fff;
static double Dval1 = 12.3456789;
static float Fval = 2.0;
static int *Pval = &Ival1;
static char *String = "this is a string\n";
static char Cval = 'a';
static unsigned int Ui = 65000;
#if DBL_MAX_10_EXP >= 100
static double Dval2 = 1.23456789e100;
#endif
static double Dval3 = 0.0;
static double Dval4 = 1.0;
static double Dval5 = 1.23e-6;
static double Dval6 = 9.876e+2;
static double Dval7 = 9.876e+3;
#if ANSI
static long double Dval8 = 98.7654L;
#endif
void fpsteq( int line, char * pval, char * pres );


static struct output
    {
    int type;
    char *fmt;
    char *out;
    int line;
    } Output[] = 
        {
        /* %[-+ #][width|*][precision|*][h|l|L][diouxXfeEgGcspn%] */

        T_0,    "",                 "",                     __LINE__,
        T_0,    "no format chars",  "no format chars",      __LINE__,
        T_I1,   "%d",               "77",                   __LINE__,
        T_I1,   "%-3d",             "77 ",                  __LINE__,
        T_I1,   "%+d",              "+77",                  __LINE__,
        T_I2,   "%+d",              "-77",                  __LINE__,
        T_I2,   "%+4d",             " -77",                 __LINE__,
        T_I1,   "% 4d",             "  77",                 __LINE__,
        T_I2,   "% 4d",             " -77",                 __LINE__,
        T_I1,   "% +4d",            " +77",                 __LINE__,
        T_I1,   "%+ 4d",            " +77",                 __LINE__,
        T_I1,   "%+04d",            "+077",                 __LINE__, /*new*/
        T_I2,   "%04d",             "-077",                 __LINE__, /*new*/
        T_I1,   "%04.2d",           "  77",                 __LINE__, /*new*/
        T_I1,   "%.d",              "77",                   __LINE__, /*new*/
        T_I1,   "%04.d",            "  77",                 __LINE__, /*new*/
        T_I0,   "%.d",              "",                     __LINE__, /*new*/
        T_I1,   "%.4d",             "0077",                 __LINE__, /*new*/
        T_I1,   "%6.4d",            "  0077",               __LINE__, /*new*/
        T_I1,   "% 6.4d",           "  0077",               __LINE__, /*new*/
        T_I1,   "%06.4d",           "  0077",               __LINE__, /*new*/
        T_I1,   "%3d",              " 77",                  __LINE__,
        T_I1,   "%0d",              "77",                   __LINE__,
        T_I1,   "%1d",              "77",                   __LINE__,
        T_I1,   "%-1d",             "77",                   __LINE__,
        T_I1,   "%x",               "4d",                   __LINE__,
        T_I1,   "%#x",              "0x4d",                 __LINE__,
        T_I1,   "%#X",              "0X4D",                 __LINE__,
        T_I1,   "%o",               "115",                  __LINE__, /*new*/
        T_I1,   "%#o",              "0115",                 __LINE__,
        T_I1,   "%d",               "77",                   __LINE__,
        T_I1,   "%u",               "77",                   __LINE__,
        T_I1,   "%.6d",             "000077",               __LINE__,
        T_I1,   "%.d",              "77",                   __LINE__,
        T_I2,   "%.6d",             "-000077",              __LINE__,
        T_I1,   "%.1d",             "77",                   __LINE__,
        T_I1,   "%.6o",             "000115",               __LINE__,
        T_I1,   "%.d",              "77",                   __LINE__,
        T_I1,   "%4.6d",            "000077",               __LINE__,
        T_I1,   "%6.4d",            "  0077",               __LINE__,
        T_I1,   "%-6.4d",           "0077  ",               __LINE__,
        T_I1,   "%06d",             "000077",               __LINE__,
        T_I1,   "%-06d",            "77    ",               __LINE__,
        T_L1,   "%ld",              "65000",                __LINE__,
        T_D1,   "%f",               "12.345679",            __LINE__,
        T_D1,   "%6.3f",            "12.346",               __LINE__,
        T_D1,   "%.0f",             "12",                   __LINE__,
#if DBL_MAX_10_EXP >= 100
        T_D2,   "%e",               "1.234568e+100",        __LINE__,
        T_D2,   "%E",               "1.234568E+100",        __LINE__,
        T_D2,   "%.3e",             "1.235e+100",           __LINE__,
        T_D2,   "%.10e",            "1.2345678900e+100",    __LINE__,
#endif
        T_D1,   "%e",               "1.234568e+01",         __LINE__,
        T_D1,   "%+e",              "+1.234568e+01",        __LINE__, /*new*/
        T_D1,   "%15.4e",           "     1.2346e+01",      __LINE__, /*new*/
        T_D1,   "%E",               "1.234568E+01",         __LINE__,
        T_D1,   "%.3e",             "1.235e+01",            __LINE__,
        T_D1,   "%.10e",            "1.2345678900e+01",     __LINE__,
        T_D3,   "%e",               "0.000000e+00",         __LINE__,
        T_D1,   "%.0e",             "1e+01",                __LINE__,
        T_D1,   "%.e",              "1e+01",                __LINE__, /*fixed*/
        T_D1,   "%#.0e",            "1.e+01",               __LINE__, /*new*/
        T_D5,   "%.2g",             "1.2e-06",              __LINE__,
        T_D6,   "%.2g",             "9.9e+02",              __LINE__,
        T_D7,   "%.2g",             "9.9e+03",              __LINE__,
        T_D7,   "%.2G",             "9.9E+03",              __LINE__,
        T_D4,   "%.0g",             "1",                    __LINE__,
        T_D1,   "%.1g",             "1e+01",                __LINE__,
        T_D4,   "%#.0g",            "1.",                   __LINE__,
        T_D1,   "%.2g",             "12",                   __LINE__,
        T_D4,   "%.2g",             "1",                    __LINE__,
        T_D4,   "%#.4g",            "1.000",                __LINE__,
        T_S,    "free form input",  "free form input",      __LINE__,
        T_S,    "%%%s%%d",          "%this is a string\n%d",__LINE__,
        T_S,    "%-20s",            "this is a string\n   ",__LINE__, /*new*/
        T_S,    "%20s",             "   this is a string\n",__LINE__,
        T_S,    "%20.6s",           "              this i", __LINE__,
        T_S,    "%.6s",             "this i",               __LINE__,
        T_C1,   "%c",               "a",                    __LINE__,
        T_C1,   "%2c",              " a",                   __LINE__,
#if ANSI
        T_STAR1,"%.*d",             "000077",               __LINE__,
        T_STAR1,"%*d",              "    77",               __LINE__,
        T_STAR1,"%-*d",             "77    ",               __LINE__,
        T_STAR2,"%.*d",             "77",                   __LINE__,
        T_STAR2,"%*d",              "77    ",               __LINE__,
        T_STAR3,"%*.*d",            "  0077",               __LINE__,
        T_STAR3,"%-*.*d",           "0077  ",               __LINE__,
        T_STARN,"%.*e",             "1.234568e+01",         __LINE__, /*new*/
        T_STARD,"%*.*e",            "     1.2346e+01",      __LINE__, /*new*/
        T_I1,   "%06.4d",           "  0077",               __LINE__,
        T_I1,   "%i",               "77",                   __LINE__,
        T_SI,   "%#hx",             "0x7fff",               __LINE__,
        T_U,    "%u",               "65000",                __LINE__,
        T_SU,   "%ho",              "77777",                __LINE__,/*new*/
        T_SU,   "%hu",              "32767",                __LINE__,/*new*/
        T_SU,   "%hx",              "7fff",                 __LINE__,/*new*/
        T_L1,   "%lo",              "176750",               __LINE__,/*new*/
        T_L1,   "%lu",              "65000",                __LINE__,/*new*/
        T_L1,   "%lx",              "fde8",                 __LINE__,/*new*/
#ifdef LONGDOUBLE
        T_D8,   "%Le",              "9.876540e+01",         __LINE__,/*new*/
        T_D8,   "%Lf",              "98.765400",            __LINE__,/*new*/
        T_D8,   "%Lg",              "98.7654",              __LINE__,/*new*/
#endif
#endif
        0,      0,                  0,                      __LINE__,
        };

/*
 * PRINT - this test the printf, etc. scanf, etc. formatting.
 * We make the reasonable assumption that the formatting routines 
 * for sprintf are common with those for sprintf, fprintf, etc. and only
 * test one set.
 */
void print()
    {
/*//!   int i; */
    struct output *po;
    char buffer[64];

    Filename = "d49a.c";
    for (po = Output; po->fmt; ++po)
        {
        switch (po->type)
            {
        case T_0:       sprintf(buffer, po->fmt);               break;
        case T_U:       sprintf(buffer, po->fmt, Ui);           break;
        case T_I0:      sprintf(buffer, po->fmt, 0);            break;
        case T_I1:      sprintf(buffer, po->fmt, Ival1);        break;
        case T_I2:      sprintf(buffer, po->fmt, Ival2);        break;
        case T_L1:      sprintf(buffer, po->fmt, Lval1);        break;
        case T_SI:      sprintf(buffer, po->fmt, Sval);         break;
        case T_SU:      sprintf(buffer, po->fmt, Suval);        break;
        case T_D1:      sprintf(buffer, po->fmt, Dval1);        break;
#if DBL_MAX_10_EXP >= 100
        case T_D2:      sprintf(buffer, po->fmt, Dval2);        break;
#endif
        case T_D3:      sprintf(buffer, po->fmt, Dval3);        break;
        case T_D4:      sprintf(buffer, po->fmt, Dval4);        break;
        case T_D5:      sprintf(buffer, po->fmt, Dval5);        break;
        case T_D6:      sprintf(buffer, po->fmt, Dval6);        break;
        case T_D7:      sprintf(buffer, po->fmt, Dval7);        break;
#if ANSI
        case T_D8:      sprintf(buffer, po->fmt, Dval8);        break;
#endif
        case T_P:       sprintf(buffer, po->fmt, Pval);         break;
        case T_S:       sprintf(buffer, po->fmt, String);       break;
        case T_STAR1:   sprintf(buffer, po->fmt, 6, Ival1);     break;
        case T_STAR2:   sprintf(buffer, po->fmt, -6, Ival1);    break;
        case T_STAR3:   sprintf(buffer, po->fmt, 6, 4, Ival1);  break;
        case T_STARD:   sprintf(buffer, po->fmt, 15, 4, Dval1); break;
        case T_STARN:   sprintf(buffer, po->fmt, -4, Dval1);    break;
        case T_C1:      sprintf(buffer, po->fmt, Cval);         break;
            }
        
        switch (po->type)
            {
            case T_D1:
            case T_D2:
            case T_D3:
            case T_D4:
            case T_D5:
            case T_D6:
            case T_D7:
            case T_D8:
            case T_STARD:
            case T_STARN:
                fpsteq(po->line, buffer, po->out);
                break;
            default:
                stequals(po->line, buffer, po->out);
            }
        }

#if ANSI
    {
    char *buffer_p;
    int t1; short t2; long t3;
    /* some special cases not covered above */

    buffer[0] = 0;
    sprintf(buffer, "%p", buffer);
    /* implementation defined format, but it should have written something */
    inotequals(__LINE__, buffer[0], 0);
    sscanf(buffer, "%p", &buffer_p);
    aequals(__LINE__, buffer, buffer_p);

#if ANSI8712    /* added h and l modifiers to n */
    /* %.0d of 0 produces no characters */
    sprintf(buffer, "%.0d", 0);
    stequals(__LINE__, buffer, "");
#endif

#if ANSI8703    /* added h and l modifiers to n */
    sprintf(buffer, "%nabc%hn%d%ln", &t1, &t2, 123, &t3);
    stequals(__LINE__, buffer, "abc123");
    iequals(__LINE__, t1, 0);
    iequals(__LINE__, t2, 3);
    lequals(__LINE__, t3, 6L);
#endif /* ANSI8703 */
    }
#endif
    }




static struct input
    {
    int type;
    char *fmt;
    char *in;
    int line;
    } Input[] = 
        {
        T_I1,   "%d",               "77",                   __LINE__,
        T_I1,   "%d",               "         77",          __LINE__,
#if ANSI
        T_I1,   "%d",               "+77",                  __LINE__,
        T_SI,   "%hd",              "32767",                __LINE__,
#endif
        T_I2,   "%d",               "-77",                  __LINE__,
        T_I1,   "abc%d",            "abc77",                __LINE__,
        T_L1,   "%ld",              "65000",                __LINE__,
#if ANSI
        T_I1,   "%i",               "77",                   __LINE__,
        T_I1,   "%i",               "+77",                  __LINE__,
        T_I2,   "%i",               "-77",                  __LINE__,
        T_I1,   "%i",               "0115",                 __LINE__,
        T_I1,   "%i",               "0x4d",                 __LINE__,
        T_I1,   "%i",               "0X4d",                 __LINE__,
        T_SI,   "%hi",              "0x7fff",               __LINE__,
        T_SU,   "%ho",              "077777",               __LINE__,
        T_SU,   "%hu",              "32767",                __LINE__,
        T_SU,   "%hx",              "7fff",                 __LINE__,
        T_L1,   "%lo",              "0176750",              __LINE__,
        T_L1,   "%lu",              "65000",                __LINE__,
        T_L1,   "%lx",              "fde8",                 __LINE__,
#endif
        T_I1,   "%o",               "0115",                 __LINE__,
        T_I1,   "%u",               "77",                   __LINE__,
        T_I1,   "%x",               "4d",                   __LINE__,
        T_I1,   "%x",               "4D",                   __LINE__,
        T_I1,   "%X",               "4d",                   __LINE__,
        T_I1,   "%X",               "4D",                   __LINE__,
        T_S,    "%s",               " this is",             __LINE__,
        T_C1,   "%c",               "athis is",             __LINE__,
        T_C2,   "%c",               " this is",             __LINE__,
        T_F,    "%f",               "2.",                   __LINE__,
        T_F,    "%e",               "2.",                   __LINE__,
        T_F,    "%f",               ".2e+01",               __LINE__,
        T_F,    "%e",               ".2e+01",               __LINE__,
        T_F,    "%f",               "2.0",                  __LINE__,
        T_F,    "%g",               "2.0",                  __LINE__,
        T_D1,   "%le",              "12.3456789",           __LINE__,
        T_D1,   "%lf",              "12.3456789",           __LINE__,
        T_D1,   "%lg",              "1.23456789e+01",       __LINE__,
#if ANSI
        T_F,    "%E",               ".2e+01",               __LINE__,
        T_F,    "%G",               "2.0",                  __LINE__,
        T_D8,   "%Le",              "98.7654",              __LINE__,
        T_D8,   "%Lf",              "98.7654",              __LINE__,
        T_D8,   "%Lg",              "9.87654e+01",          __LINE__,
#endif
        0,      (char *)0,          (char *)0,              __LINE__,
        };



/*
 * SCAN - this test the scanf, etc. scanf, etc. number cracking.  
 * We make the reasonable assumption that the scanning routines
 * for sscanf are common with those for scanf, fscanf, etc. and only
 * test one set.
 */
void scan()
    {
    int i, n;
    struct input *pi;
    char buffer[64];
    char ctmp;
    short stmp;
    unsigned short sutmp;
    int itmp;
    long ltmp;
    double dtmp;
#if ANSI
    long double ldtmp;
#endif
    float ftmp;
/*//!   int *ptmp;*/
    char *p = buffer;
    char *q = 0;

    Filename = "d49a.c";

    for (pi = Input; pi->fmt; ++pi)
        {
        switch (pi->type)
            {
            case T_I1 :
                sscanf(pi->in, pi->fmt, &itmp);
                iequals(pi->line, itmp, Ival1);
                itmp = 0;
                break;
            case T_SI :
                sscanf(pi->in, pi->fmt, &stmp);
                iequals(pi->line, stmp, Sval);
                stmp = 0;
                break;
            case T_SU :
                sscanf(pi->in, pi->fmt, &sutmp);
                iequals(pi->line, sutmp, Suval);
                sutmp = 0;
                break;
            case T_L1 :
                sscanf(pi->in, pi->fmt, &ltmp);
                lequals(pi->line, ltmp, Lval1);
                ltmp = 0;
                break;
            case T_D1 :
                sscanf(pi->in, pi->fmt, &dtmp);
                dequals(pi->line, dtmp, Dval1);
                dtmp = 0;
                break;
#if ANSI
            case T_D8 :
                sscanf(pi->in, pi->fmt, &ldtmp);
                ldequals(pi->line, ldtmp, Dval8);
                ldtmp = 0;
                break;
#endif
            case T_F :
                sscanf(pi->in, pi->fmt, &ftmp);
                dequals(pi->line, ftmp, Fval);
                ftmp = 0;
                break;
            case T_S :
                sscanf(pi->in, pi->fmt, buffer);
                stequals(pi->line, buffer, "this");
                buffer[0] = 0;
                break;
            case T_C1 :
                sscanf(pi->in, pi->fmt, &ctmp);
                iequals(pi->line, ctmp, 'a');
                ctmp = 0;
                break;
            case T_C2 :
                sscanf(pi->in, pi->fmt, &ctmp);
                iequals(pi->line, ctmp, ' ');
                ctmp = 0;
                break;
            }
        }

    /* special cases */

    /* if a directive fails, no more input is consumed */
        {
        char filename[256];
        FILE *fd;
        int tmp1 = 0;
        int tmp2 = 0;
        char c = 0;

        save_name(tmpnam(filename));
        fd = fopen(filename, "w+");
        fprintf(fd, "xxx 17 yyy 18");
        rewind(fd);
        fscanf(fd, "xxx %d zzz %d", &tmp1, &tmp2);
        iequals(__LINE__, tmp1, 17);
        iequals(__LINE__, tmp2, 0);
        fscanf(fd, "yyy %d", &tmp2);
        iequals(__LINE__, tmp2, 18);
        fscanf(fd, "%c", &c);
        iequals(__LINE__, c, 0);

        fclose(fd);
        remove(filename); 
        }

#if ANSI
    /* skip white space unless %c, %n, or %[ ] */
    sscanf(" \f\n\r\t\v10", "%d", &Ival1);
    iequals(__LINE__, Ival1, 10);
    sscanf(" \f\n\r\t\vA", "%c%c%c%c%c%c%c", p+0, p+1, p+2, p+3, p+4, p+5, p+6);
    iequals(__LINE__, p[0], ' ');
    iequals(__LINE__, p[1], '\f');
    iequals(__LINE__, p[2], '\n');
    iequals(__LINE__, p[3], '\r');
    iequals(__LINE__, p[4], '\t');
    iequals(__LINE__, p[5], '\v');
    iequals(__LINE__, p[6], 'A');

    sscanf("xxx yyy", "xxx%n%c", &Ival1, &Cval);
    iequals(__LINE__, Ival1, 3);
    iequals(__LINE__, Cval, ' ');

    p = " \f\n\r\t\vXXX";
    sscanf(p, "%s", buffer);
    stequals(__LINE__, buffer, "XXX");
    sscanf(p, "%[ \f\n\r\t\v]", buffer);
    stequals(__LINE__, buffer, " \f\n\r\t\v");

    /* assignment supression */
    Ival1 = 1;
    Ival2 = 2;
    sscanf("77 78", "%*d%d", &Ival1, &Ival2);
    iequals(__LINE__, Ival1, 78);
    iequals(__LINE__, Ival2, 2);

    /* field widths */
    sscanf("123456", "%3d%d", &Ival1, &Ival2);
    iequals(__LINE__, Ival1, 123);
    iequals(__LINE__, Ival2, 456);
    strcpy(buffer+30, "XXXXXXX");
    sscanf("123456789", "%3d%3s%2c", &Ival2, buffer, buffer+30);
    iequals(__LINE__, Ival2, 123);
    stequals(__LINE__, buffer, "456");
    iequals(__LINE__, buffer[30], '7');
    iequals(__LINE__, buffer[31], '8');
    iequals(__LINE__, buffer[32], 'X');
    sscanf("abcabcabc", "%4[abc]", buffer);
    stequals(__LINE__, buffer, "abca");
    sscanf("xyzxyzxyz", "%4[^abc]", buffer);
    stequals(__LINE__, buffer, "xyzx");

    /* conversion count */
    sscanf("123 5", "%d%n", &i, &n);
    iequals(__LINE__, i, 123);
    iequals(__LINE__, n, 3);

    sscanf("123 5", "%d%hn", &i, &stmp);
    iequals(__LINE__, i, 123);
    iequals(__LINE__, stmp, 3);

    sscanf("123 5", "%d%ln", &i, &ltmp);
    iequals(__LINE__, i, 123);
    lequals(__LINE__, ltmp, 3L);

    /* '%%' is an  escape for '%' */
    strcpy(buffer, "xxxxxx");
    sscanf("%%aaa", "%%%%%s", buffer);
    stequals(__LINE__, buffer, "aaa");

    /* scan sets */
    sscanf("ddccbbaaxxxxx", "%[abcd]", buffer);
    stequals(__LINE__, buffer, "ddccbbaa");

    sscanf("xxyyzzaabbccdd", "%[^abcd]", buffer);
    stequals(__LINE__, buffer, "xxyyzz");

    sscanf("dd]cc]bb]aaxxxxx", "%[]abcd]", buffer);
    stequals(__LINE__, buffer, "dd]cc]bb]aa");

    sscanf("xxyyzz]aabbccdd", "%[^]abcd]", buffer);
    stequals(__LINE__, buffer, "xxyyzz");

    /* exceptional behaviour of '-' is implementation defined */
    sscanf("-", "%[a-z]", buffer);
    stequals(- __LINE__, buffer, "-");

    /* %p should be idempotent */
    sprintf(buffer, "%p", p);
    sscanf(buffer, "%p", &q);
    aequals(__LINE__, p, q);
#endif
    }

#include <string.h>
#include <ctype.h>
/*
 * fpsteq - When checking floating point output, the standard requires
 * a minimum of 2 digits for the exponent.  More is OK, so this routine
 * checks for conformance without being sensitive to the exact number
 * of digits.  When we know that the string is wrong, we call
 * stequals to create a meaningful error message. Also, compensate 
 * for differing number of white space in filling up the field width.
 */
void fpsteq(int line, char * pval, char * pres)
    /*int line;
    char *pval;
    char *pres;*/
    {
    char result[32], value[32];
    size_t len; /*LX:10131999 /int/size_t for 64-bit friendliness */
    char *p, *q;
printf("fpsteq\n");
    /* check for field width (only on leading space) */
    if (isspace(*pval) && strlen(pres) != strlen(pval))
        {
        /* this will fail */
        stequals(line, pval, pres);
        return;
        }

    /* get rid of leading whitespace */
    while (isspace(*pval))
        ++pval;
    while (isspace(*pres))
        ++pres;
    if (strstr(pres, "E+") || strstr(pres, "E-") || 
            strstr(pres, "e+") || strstr(pres, "e-"))
        {
        len = strcspn(pres, "Ee");
        if (len != (int)strcspn(pval, "Ee"))
            {
            /* this will fail */
            stequals(line, pval, pres);
            return;
            }
        strncpy(result, pres, len);
        result[len] = 0;
        strncpy(value, pval, len);
        value[len] = 0;
        if (strcmp(result, value))
            {
            /* this will fail */
            stequals(line, pval, pres);
            }
        else
            {
            /* does pval have at least 2 digits of exponent? */
            p = pval + len + 2;
            if (strlen(p) < 2)
                {
                /* this will fail */
                stequals(line, pval, pres);
                }
            else
                {
                while (*p == '0')
                    ++p;
                q = pres + len + 2;
                while (*q == '0')
                    ++q;
                if (strcmp(p, q))
                    {
                    /* this will fail */
                    stequals(line, pval, pres);
                    }
                }
            }
        }
    else
        stequals(line, pval, pres);
    }
#if !ANSI
char *strstr(s1, s2)
    char *s1, *s2;
    {
    char *p = s1;

    while ((p = strchr(p, *s2)) != 0)
        {
        if (strncmp(p, s2, strlen(s2)) == 0)
            return (p);
        ++p;
        }
    return (0);
    }
#endif /* !ANSI */

#endif /* !SKIP49 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\c_plumhall\MACHIN.H ===
/* The Plum Hall Validation Suite for C
 * Unpublished copyright (c) 1986-1990, Chiron Systems Inc and Plum Hall Inc.
 * VERSION: 2.00
 * DATE: 90/04/05
 * The "ANSI" mode of this suite corresponds to official ANSI C, X3.159-1989.
 * As per your license agreement, your distribution is not to be moved or copied outside the Designated Site
 * without specific permission from Plum Hall Inc.
 */

#ifndef MACHINE_H
#define MACHINE_H

#include <limits.h>
#define SIGNED_CHAR     (CHAR_MIN < 0)      /* Does char sign-extend ... */
#define UNSIGNED_CHAR   (CHAR_MIN == 0)     /* ... or not? */

#define MAX_UCHAR       UCHAR_MAX       /* biggest unsigned character */
#define MAX_USHORT      USHRT_MAX       /* biggest unsigned short */
#define MAX_UINT        UINT_MAX        /* biggest unsigned int */
#define MAX_INT         INT_MAX         /* biggest int */
#define MAX_ULONG       ULONG_MAX       /* biggest unsigned long */
#define MAX_LONG        LONG_MAX        /* biggest long int */

#include <float.h>
#define FDIGITS_MAX     (FLT_DIG - 1)   /* number of significant digits for single precision comparison. */
#define DIGITS_MAX      (DBL_DIG - 1)   /* number of significant digits for double precision comparison. */
#define LDIGITS_MAX     (LDBL_DIG - 1)  /* number of significant digits for long double precision comparison. */
#endif  /* MACHINE_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\c_plumhall\defs.h ===
/* The Plum Hall Validation Suite for C
 * Unpublished copyright (c) 1986-1990, Chiron Systems Inc and Plum Hall Inc.
 * VERSION: 2.00
 * DATE: 90/04/05
 * The "ANSI" mode of this suite corresponds to official ANSI C, X3.159-1989.
 * As per your license agreement, your distribution is not to be moved or copied outside the Designated Site
 * without specific permission from Plum Hall Inc.
 */

#if defined(TEST_WIN32S)
#include "wintest.h"
#endif

#ifdef _M_IA64
#pragma warning( disable : 4244)
#endif

#ifndef DEFS_H

   #define DEFS_H
   #include "compil.h"

#if !ANSI || !LIB_TEST
   #include "machin.h"
#endif

/* THE REMAINING DEFINITIONS SHOULD NOT BE MODIFIED */

#define TRUE 1
#define FALSE 0

 /* Where possible, we will try to make the compiler have
 * as many registers as possible tied up.  This usually
 * forces more error-prone paths.
 */

#define REGISTERS register int r1,r2,r3,r4,r5;register char *r6,*r7,*r8,*r9,*r10
#define USEREGISTERS r1=r2=r3=r4=r5=0;r6=r7=r8=r9=r10=0

#if !VOID_OK
   #define void int
#endif

extern char *Filename; /* will always get set to the current source file */

#if HAS_PROTOTYPES
   #define PARMS(x) x
#else
   #define PARMS(X) ()
#endif  /* HAS_PROTOTYPES */

#ifdef _WIN64
int iequals PARMS((int, size_t, size_t)); /*LX:10131999 made params size_t for 64-bit friendiness */
#else
int iequals PARMS((int,int, int));
#endif
int inotequals PARMS((int, int, int));
int aequals PARMS((int, const void *, const void *));
int faequals PARMS((int, int (*_val1)(), int (*_val2)() ));
int lequals PARMS((int, long, long));
int dequals PARMS((int, double, double));
int fequals PARMS((int, double, double));
int checkthat PARMS((int, int));
int stequals PARMS((int, char*, char*));
int scheck PARMS((int, int, int, int));
int do_nothing PARMS((void *, ...));
int complain PARMS((int));

#ifdef NT
   int ldequals PARMS((int, double, double));
#else
   int ldequals PARMS((int, long double, long double));
#endif

int ivalue PARMS((int));
long lvalue PARMS((long));
double dvalue PARMS((double));
generic_ptr avalue PARMS((generic_ptr));
void report PARMS((char *));
void pr_ok PARMS((char *));
void pr_err PARMS((char *));

#ifdef _XBOX
int _cdecl DbgPrint(const char *, ...);
#define xprintf DbgPrint
#else
#define xprintf printf
#endif

#if !ANSI

#ifndef DBL_DIG
   #define DBL_DIG DIGITS_MAX
#endif

#ifndef FLT_DIG
   #define FLT_DIG FDIGITS_MAX
#endif

#ifndef LDBL_DIG
   #define LDBL_DIG DIGITS_MAX
#endif

#ifndef DBL_MAX_10_EXP
   #define DBL_MAX_10_EXP 37    /* a portable minimum value */
#endif

#ifndef DBL_MIN_10_EXP
   #define DBL_MIN_10_EXP -37   /* a portable minimum value */
#endif

#ifndef LDBL_MIN_10_EXP
   #define LDBL_MIN_10_EXP -37  /* a portable minimum value */
#endif

#endif  /* of !ANSI */

#endif  /* of DEFS_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\c_plumhall\plumhall.c ===
#include <stdio.h>

void d41_main(int argc, char **argv);
void d42_main(int argc, char **argv);
void d43_main(int argc, char **argv);
void d44_main(int argc, char **argv);
void d45_main(int argc, char **argv);
void d46_main(int argc, char **argv);
void d47_main(int argc, char **argv);
void d48_main(int argc, char **argv);
void d49_main(int argc, char **argv);
void d410_main(int argc, char **argv);
void d411_main(int argc, char **argv);
void d412_main(int argc, char **argv);

void __cdecl PlumHallStartTest( void )
{
    d41_main(0, NULL);
    d42_main(0, NULL);
    d43_main(0, NULL);
    d44_main(0, NULL);
    d45_main(0, NULL);
    d46_main(0, NULL);
    d47_main(0, NULL);
    d48_main(0, NULL);
    d49_main(0, NULL);
    d410_main(0, NULL);
    d411_main(0, NULL);
    d412_main(0, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\c_plumhall\sources.inc ===
!IF 0

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    sources

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built

!ENDIF

TARGETTYPE=LIBRARY
TARGETPATH=..\..\lib

386_STDCALL=0

SOURCES=..\ph_util.c \
        ..\plumhall.c \
        ..\d41.c \
        ..\d410.c \
        ..\d410drv.c \
        ..\d411.c \
        ..\d411b.c \
        ..\d411drv.c \
        ..\d412.c \
        ..\d412drv.c \
        ..\d41a.c \
        ..\d41b.c \
        ..\d41c.c \
        ..\d41d.c \
        ..\d41drv.c \
        ..\d42.c \
        ..\d42a.c \
        ..\d42drv.c \
        ..\d43.c \
        ..\d43drv.c \
        ..\d44.c \
        ..\d44drv.c \
        ..\d45.c \
        ..\d45drv.c \
        ..\d46.c \
        ..\d46drv.c \
        ..\d47.c \
        ..\d47b.c \
        ..\d47drv.c \
        ..\d48.c \
        ..\d48drv.c \
        ..\d49.c \
        ..\d49a.c \
        ..\d49drv.c

MSC_WARNING_LEVEL=/W3

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\c_plumhall\D49DRV.c ===
/* The Plum Hall Validation Suite for C
 * Unpublished copyright (c) 1986-1988, Chiron Systems Inc and Plum Hall Inc.
 * VERSION: 1.09
 * DATE: 88/09/20
 * Each distribution of the Suite is unique in distinct but inconsequential ways.
 * As per your license agreement, your distribution is not to be moved or copied outside the Designated Site
 * without specific permission from Plum Hall Inc.
 */
/*
 * this source must be compiled with FUNCTION=d4_# defined where # is a
 * number between 1 and 12
 */

/*
 * LIB - standard library tests
 */

/* 14-Dec-1989 mrw added this to prevent unresolved external from d41a.c */
//int errno_init = 0;  /* set in lib.c */

#define LIB_TEST 1      /* prevents inclusion of limits.h and float.h */
#include "defs.h"

extern void d4_9();

d49_main(int argc, char ** argv)
    /*int argc;
    char **argv;*/
    {
    extern int Debug;

    if (argc > 1)
        Debug = TRUE;
    Filename = __FILE__;
    d4_9();
    report("d49");
    }
/*
 * For "almost-ANSI" compilers that are missing parts of the latest ANSI library,
 * include stubs for these functions here.
 */
#if (ANSI && !LIB_NOV_86)
#include "stubs.c"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\c_plumhall\ph_util.c ===
/* The Plum Hall Validation Suite for C
 * Unpublished copyright (c) 1986-1990, Chiron Systems Inc and Plum Hall Inc.
 * VERSION: 2.00
 * DATE: 90/04/05
 * The "ANSI" mode of this suite corresponds to official ANSI C, X3.159-1989.
 * As per your license agreement, your distribution is not to be moved or copied outside the Designated Site
 * without specific permission from Plum Hall Inc.
 */

/*
 * UTILS - various utility routines.
 */
#include <stdio.h>
#include <math.h>
#include "defs.h"
//!mmalone: #ifdef __STDC__
#include <stdlib.h>
#include <string.h>
// #endif

void setzero();
void setremark();
void trace(char * routine, int line);
int Nerrs = 0;
int Nremarks = 0;
long Nsuccess = 0;
int Debug = FALSE;
char *Filename = NULL;
static char details[BUFSIZ] = {0};
static size_t trace_msg_len = 0; //LX:10131999 /int/size_t for 64-bit friendliness
static char trace_routine[20] = "";
static char trace_filename[BUFSIZ] = "";
static int remarks = FALSE;

/*
 * ERRMSG - print and tabulate each message
 */
static void errmsg(char * msg, int line)
    {
    if (trace_msg_len != 0)
        {
        xprintf("\n");
        trace_msg_len = 0;
        strcpy(trace_routine, "");
        }
    if (line > 0 || remarks)
        xprintf("%s in %s at line %d%s\n",
            line > 0 ? "ERROR" : "REMARK",
            Filename,
            line > 0 ? line : -line, msg);
    fflush(stdout);
    if (line > 0)
        ++Nerrs;
    else
        ++Nremarks;
    }

/*
 * IEQUALS - 'int' quality check.  If val1 != val2, then report an error.
 */
int iequals(
    int line,
#ifdef _M_IA64
    size_t val1, size_t val2 /*LX:10131999 made vals size_t for 64-bit friendliness*/
#else
    int val1, int val2
#endif
    )
    {
    if (val1 != val2)
        {
        sprintf(details, ": (%d) != (%d)",  val1, val2);
        errmsg(details, line);
        return (0);
        }
    else
        trace("iequals", line);
    return (1);
    }

/*
 * INOTEQUALS - 'int' non-equality check.  If val1 == val2, then
 * report an error.
 */
int inotequals(int line, int val1, int val2)
    {
    if (val1 == val2)
        {
        sprintf(details, ": (%d) == (%d)",  val1, val2);
        errmsg(details, line);
        return (0);
        }
    else
        trace("inotequals", line);
    return (1);
    }

/*
 * LEQUALS - 'long' quality check.  If val1 != val2, then
 * report an error.
 */
int lequals(int line, long val1, long val2)
    {
    if (val1 != val2)
        {
        sprintf(details, ": (%ld) != (%ld)",  val1, val2);
        errmsg(details, line);
        return (0);
        }
    else
        trace("lequals", line);
    return (1);
    }

/*
 * COMPLAIN - unconditional failure.
 */
int complain(int line)
    {
    errmsg("", line);
    return 0;
    }

/*
 * STEQUALS - string equality.
 */
int stequals(int line, char * val1, char * val2)
    {
    if (strcmp(val1, val2))
        {
        sprintf(details, ": \"%s\" != \"%s\"",  val1, val2);
        errmsg(details, line);
        return (0);
        }
    else
        trace("stequals", line);
    return (1);
    }

/*
 * AEQUALS - 'address' equality check.  If val1 != val2, then
 * report an error.
 */
int aequals( int line,
#if ANSI
    const void * val1, const void * val2
#else
    char * val1, char * val2
#endif
     )
    {
    if (val1 != val2)
        {
#if ANSI
        sprintf(details, ": (%p) != (%p)",  val1, val2);
#else
        sprintf(details, ": (%lx) != (%lx)",  (long)val1, (long)val2);
#endif
        errmsg(details, line);
        return (0);
        }
    else
        trace("aequals", line);
    return (1);
    }

/*
 * ARBHEX - convert an arbitrary byte-sequence into hex codes
 */
#ifndef CHAR_BIT
#define CHAR_BIT 8
#endif
#define NIBBLES_PER_BYTE ((CHAR_BIT + 3) / 4)
char *arbhex(char * str, char * p, int n)
    /*char *str;   where to store the target string */
    /*char *p;     where to find the source bytes */
    /*int n;       how many bytes */
    {
    int i, nib, hex_dig;
    static char codes[] = "0123456789ABCDEF";

    for (i = 0; i < n; ++i, ++p)
        for (nib = NIBBLES_PER_BYTE - 1; nib >= 0; --nib)
            {
            hex_dig = (*p & (unsigned int)(0xF << (nib*4))) >> (nib*4);
            *str++ = codes[hex_dig];
            }
    *str = '\0';
    return str;
    }

/*
 * FAEQUALS - function address equality check.  If val1 != val2, then
 * report an error. The address of a function is not necessarily the same
 * size/type as the address of data.
 */
int faequals(int line, int (*val1)() , int (*val2)() )
    /*int (*val1)(), (*val2)();
    int line;*/
    {
    char buf1[sizeof(val1)*NIBBLES_PER_BYTE + 1];
    char buf2[sizeof(val2)*NIBBLES_PER_BYTE + 1];

    if (val1 != val2)
        {
        arbhex(buf1, (char *)&val1, (int)sizeof(val1));
        arbhex(buf2, (char *)&val2, (int)sizeof(val2));
        sprintf(details, ": (%s) != (%s)", buf1, buf2);
        errmsg(details, line);
        return (0);
        }
    else
        trace("faequals", line);
    return (1);
    }

/*
 * DEQUALS - 'double' equality check.  If val1 != val2, then
 * report an error. This is computed using an equality approximation
 * that verifies that the two numbers are equal to R digits whenever
 *
 *    |x - y|    1    1-R
 *    ------- <= - 10
 *      |x|      2
 *
 * DIGITS_MAX  is defined in defs.h
 */
double Delta = 0.0;
int dequals(int line, double val1, double val2)
    /*double val1, val2;
    int line;*/
    {
    double *pd;

    if (Delta == 0.0)
        Delta = 0.5 / pow(10.0, DIGITS_MAX-1.0);
    if (val1 == val2)
        {
        trace("dequals", line);
        return (1);
        }
    pd = &val1;
    if (val1 == 0.0)
        pd = &val2;

    /* special cases to handle zero against very small numbers */
    if (fabs(val1) == 0.0 && fabs(val2) < Delta)
        ;
    else if (fabs(val2) == 0.0 && fabs(val1) < Delta)
        ;
    else if ((fabs(val1 - val2) / fabs(*pd)) > Delta)
        {
        sprintf(details, ": (%.*G) != (%.*G)",
            DIGITS_MAX+2, val1, DIGITS_MAX+2, val2);
        errmsg(details, line);
        return (0);
        }
    trace("dequals", line);
    return (1);
    }

#if ANSI
/*
 * LDEQUALS - Long double equality ... more of the same.
 */
#define ldabs(ld) ((ld) < 0.0 ? -(ld) : (ld))
long double LDelta = 0.0;
int ldequals(int line, long double val1, long double val2)
    /*long double val1, val2;
    int line;*/
    {
    long double *pd;

    if (LDelta == 0.0)
        {
        LDelta = 0.5L / pow(10.0, LDIGITS_MAX-1.0);
        }
    if (val1 == val2)
        {
        trace("ldequals", line);
        return (1);
        }
    pd = &val1;
    if (val1 == 0.0)
        pd = &val2;

    /* special cases to handle zero against very small numbers */
    if (ldabs(val1) == 0.0 && ldabs(val2) < LDelta)
        ;
    else if (ldabs(val2) == 0.0 && ldabs(val1) < LDelta)
        ;
    else if ((ldabs(val1 - val2) / ldabs(*pd)) > LDelta)
        {
        sprintf(details, ": (%.*LE) != (%.*LE)",
            LDIGITS_MAX+2, val1, LDIGITS_MAX+2, val2);
        errmsg(details, line);
        return (0);
        }
    trace("ldequals", line);
    return (1);
    }
#endif

/*
 * FEQUALS - same as DEQUALS, but to FDIGITS_MAX instead of DIGITS_MAX.
 */
double FDelta = 0.0;
int fequals(int line, double in1, double in2)
    /*float in1, in2;
    int line;*/
    {
    float *pf;
    float val1 = (float)in1;
    float val2 = (float)in2;

    if (FDelta == 0.0)
        FDelta = 0.5 / pow(10.0, FDIGITS_MAX-1.0);
    if (val1 == val2)
        {
        trace("fequals", line);
        return (1);
        }
    pf = &val1;
    if (val1 == 0.0)
        pf = &val2;

    /* special cases to handle zero against very small numbers */
    if (fabs(val1) == 0.0 && fabs(val2) < FDelta)
        ;
    else if (fabs(val2) == 0.0 && fabs(val1) < FDelta)
        ;
    else if ((fabs(val1 - val2) / fabs(*pf)) > FDelta)
        {
        sprintf(details, ": (%.*G) != (%.*G)",
            FDIGITS_MAX+2, val1, FDIGITS_MAX+2, val2);
        errmsg(details, line);
        return (0);
        }
    trace("fequals", line);
    return (1);
    }

/*
 * CHECKTHAT - simple condition check.  If val1 == 0, then
 * report an error.
 */
int checkthat(int line, int cond)
    /*int cond;
    int line;*/
    {
    if (!cond)
        {
        errmsg("", line);
        return (0);
        }
    else
        trace("checkthat", line);
    return (1);
    }

/*
 * VALUE - the value routines are used to defeat value propagation in optimizing compilers.
 * We want to make sure that we are testing what we think we are testing, not what the compiler transformed it to.
 * 1988: Some compilers "open-code" all small functions.  Now we have to hide the constants still further.
 */
static int Zero = 0;    /* See  setzero()  below */
int ivalue(int i)
    /*int i;*/
    {
    return i + Zero;
    }
long lvalue(long i)
    /*long i;*/
    {
    return i + Zero;
    }
double dvalue(double i)
    /*double i;*/
    {
    return i + Zero;
    }
float fvalue( float i)
    /*float i;*/
    {
    return (float)(i + Zero);
    }
generic_ptr avalue(generic_ptr i)
    /*generic_ptr i;*/
    {
    return (char *)i + Zero;
    }

/*
 * SCHECK - check both values and side effects.
 */
int Side = 0;
int scheck(int line, int val1, int se, int val2)
    /*int val1, se, val2, line;*/
    {
    int status = 1;

    if (Side != se)
        {
        errmsg(": incorrect side effect", line);
        status = 0;
        }
    else
        trace("scheck", line);
    Side = 0;
    return (status == 1 && iequals(line, val1, val2));
    }

/*
 * DO_NOTHING - this is also intended to defeat optimizers by passing
 * the addresses of variables for which we want to stop any value propagation.
 */
#if ANSI
#if NEW_STYLE_FN_DEF
int do_nothing(void *p, ...) { *(char *)p = *((char *)p + Zero); return 0; }
#else
int do_nothing(void * p)  { *(char *)p = *((char *)p + Zero); return 0; }
#endif
#else
int do_nothing(){ return 0; }
#endif

/*
 * REPORT - summary report at end of testing.
 */
void report(char * program)
    /*char *program;*/
    {
    if (trace_msg_len != 0)
        xprintf("\n");
    xprintf("***** %ld successful test%s in %s *****\n", Nsuccess,
        (Nsuccess != 1) ? "s" : "", program);
    xprintf("***** %d error%s detected in %s *****\n", Nerrs,
        (Nerrs != 1) ? "s" : "", program);
    if (remarks && Nremarks != 0)
        xprintf("***** %d remark%s detected in %s *****\n", Nremarks,
            (Nremarks != 1) ? "s" : "", program);
#ifndef _XBOX
    exit(Nerrs);
#else
    Nsuccess = 0;
    Nerrs = 0;
    Nremarks = 0;
#endif
    }

/*
 * DBPRINT - print the message if the Debug flag is on.
 */
void dbprint(char * s)
    /*char *s;*/
    {
    if (Debug)
        {
        printf("***DEBUG***");
        printf(s);
        }
    }

/*
 * TRACE - print a line-number trace for debugging
 * Also count successful tests.
 */
void trace( char * routine, int line)
    /*char *routine;
    int line;*/
    {
    char buf[10];
    static int first = 1;

    if (first)
        {
        setzero();
        setremark();
        first = 0;
        xprintf("***** Reached first test *****\n");
        }
    if (Debug)
        {
        if (strcmp(trace_routine, routine) != 0 ||
            strcmp(trace_filename, Filename) != 0 ||
            trace_msg_len > 60)
            {
            xprintf("\nTRACE: %s at %s ", routine, Filename);
            strcpy(trace_routine, routine);
            strcpy(trace_filename, Filename);
            trace_msg_len = 11 + strlen(routine) + strlen(Filename);
            }
        sprintf(buf, "%d ", abs(line));
        xprintf("%s", buf);
        trace_msg_len += strlen(buf);
        fflush(stdout);
        }
    if (line > 0)   /* don't count successful warnings, for certifying */
        ++Nsuccess;
    }

/*
 * DIGITS - calculate the number of digits after the decimal
 * place so that the number is printed to DIGITS_MAX significant
 * digits.
 */
int digits( double d )
    /*double d;*/
    {
    int i;

    if (d == 0.0)
        i = 0;
    else
        i = (int)log10(fabs(d));
    return(DIGITS_MAX - (i < 0 ? 0 : i+1));
    }

int fdigits( double d)
    /*double d;*/
    {
    int i;

    if (d == 0.0)
        i = 0;
    else
        i = (int)log10(fabs(d));
    return(FDIGITS_MAX - (i < 0 ? 0 : i+1));
    }

/*
 * SETZERO - appear, to a compiler, as though Zero is unpredictably set
 */
void setzero()
    {
    FILE *fp;
    int save;

    save = errno;
    fp = fopen("nonexistent", "r");
    if (fp != 0)
        {
        fscanf(fp, "ignore format", &Zero);
        fclose(fp);
        }
    errno = save;
    }

/*
 * PR_OK - printf a text line in ok situation (no error, just text)
 */
void pr_ok(char * s)
    /*char *s;*/
    {
    fputs(s, stdout);
    }

/*
 * PR_ERR - printf a text line in error situation (such as "SKIP'ed")
 */
void pr_err(char * s)
    /*char *s;*/
    {
    ++Nerrs;
    pr_ok(s);
    }

/*
 * SETREMARK - determine whether "remark" messages should be printed
 */
void setremark()
    {
#ifndef _XBOX
    FILE *fp;

    if (getenv("SUITE_REMARK") != 0)
        remarks = TRUE;
    else if ((fp = fopen("REMARK", "r")) == 0)
        remarks = FALSE;
    else
        {
        remarks = TRUE;
        fclose(fp);
        }
#else
    //
    // BUGBUG: how do we set remark under Xbox?
    //
#endif
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\a15040.c ===
/* File: A15040.C    Version: 2.9    Date: 08/21/92
 * CVS-C++, C++ Validation Suite
 * Section: 15  Type: A - Abort Expected Test
 * Copyright 1991-92, PERENNIAL, All Rights Reserved
 */
/*======================================================================
        =================== TESTPLAN SEGMENT ===================

>KEYS:  ISO/ANSI C++ draft, X3J16/92-0060.  15.6.1 The terminate() Function
        ARM, Ellis & Stroustrup, May 91.  15.6.1 The terminate() Function

>REL:   EH Phase I and later.

>WHAT:  "Selecting a terminate function that does not in fact
        terminate but tries to return to its caller is an error."
        
        It is unclear that this error must be detected by the
        implementation.  From the ARM 15.6.1:

        "Note that terminate() may enforce this rule by calling
        abort() should a user-supplied function return."

>HOW:   Call set_terminate() with the address of eh_term(), a
        function that attempts to return. 
        Throw a handler-less exception.  Verify that 
        eh_term() gets invoked, yet does not return since
        there must be no return from terminate().
        The driver should report termination with abort().

>NOTE:  This is an implementation dependent test. 
======================================================================*/
#include "tsthd.h"        /* Perennial test suite header file */
#include "tsteh.h"        /* Perennial exception handling header */

static char prgnam[] = "A15040.C";

class C {};
static C c;

int global_x = 0;

int f00(void)
{
        int r = 0;
        try {
                throw c;        // uncaught exception.
        }
        catch (float) {
                r = 99;
        }
        return r;
}

static void eh_term(void)
{
        global_x = 1;
        b4abort();
        CreateExitFile();
        return;                 // return not permitted
}

/*--------------------------------------------------------------------*/
int a15040_main(void)
{
        int ret;

        setup();
        eh_traps();
        set_terminate (&eh_term);
/*--------------------------------------------------------------------*/
        blenter();      /* block 00 */

        fprintf(logfp,
          "REF: ISO/ANSI C++ draft, X3J16/92-0060.  15.6.1 The terminate() Function\n");
        fprintf(logfp,
          "Can an argument of set_terminate() return to its caller?\n");

        if (global_x != 0)
            failure ("eh_term() already invoked.");
        else 
        {
            ret = f00();
            if (global_x != 1)
                failure ("eh_term() not invoked.");
            else if (ret == 99)
                failure ("Wrong catch().");
            failure ("Execution should have aborted.");
        }

        blexit();
/*--------------------------------------------------------------------*/
        anyfail(1);      
        return 0;
}

#include "scaffold.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\a15039.c ===
/* File: A15039.C    Version: 2.10    Date: 08/21/92
 * CVS-C++, C++ Validation Suite
 * Section: 15  Type: A - Abort Expected Test
 * Copyright 1991-92, PERENNIAL, All Rights Reserved
 */
/*======================================================================
        =================== TESTPLAN SEGMENT ===================

>KEYS:  ISO/ANSI C++ draft, X3J16/92-0060. 15.6.1 The terminate() Function.

>REL:   EH Phase I and later.

>WHAT:  "The default function called by terminate() is abort()."

>HOW:   Do not call set_terminate().
        Throw a handler-less exception.  Verify that 
        there is no return from terminate().
        The driver should report termination with abort().

>NOTE:  None.
======================================================================*/
#include "tsthd.h"        /* Perennial test suite header file */
#include "tsteh.h"        /* Perennial exception handling header */
#include <stdlib.h>

static char prgnam[] = "A15039.C";

static void f00(void)
{
        try {
                b4abort();
                throw 'a';      // throw should cause a call to abort()
        }
        catch (float) {
                failure("Throw caught by the wrong handler");
        }
}

/*--------------------------------------------------------------------*/
int a15039_main(void)
{
        setup();
/*--------------------------------------------------------------------*/
        blenter();      /* block 00 */

        fprintf(logfp, 
          "REF: ISO/ANSI C++ draft, X3J16/92-0060.  15.6.1 The terminate() Function\n");
        fprintf(logfp, 
          "The default function called by terminate() is abort().\n");

        f00();
        failure ("Execution should have aborted.");

        blexit();
/*--------------------------------------------------------------------*/
        anyfail(1);      
        return 0;
}

#include "scaffold.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\a15051.c ===
/* File: A15051.C    Version: 1.1    Date: 08/24/92
 * CVS-C++, C++ Validation Suite
 * Section: 15  Type: A - Abort Expected Test
 * Copyright 1991-92, PERENNIAL, All Rights Reserved
 */
/*======================================================================
        =================== TESTPLAN SEGMENT ===================

>KEYS:  ISO/ANSI C++ draft, X3J16/92-0060.  15.6.1 The terminate() Function
        ARM, Ellis & Stroustrup, May 91.  15.6.1 The terminate() Function

>REL:   EH Phase III and later.

>WHAT:  "Selecting a terminate function that does not in fact
        terminate but tries to return to its caller either with
        return or by throwing an exception is an error."
        
        The ARM states in 15.6.1:

        "Note that terminate() may enforce this rule by calling
        abort() should a user-supplied function return."

        Assertion:
        When a terminate function tries to return to its caller
        by throwing an exception, the function abort() is called.

>HOW:   Call set_terminate() with the address of eh_term(), a
        function that attempts return to its caller using a throw.
        Throw an exception with no handler to catch it.
        The driver should report termination with abort().

>NOTE:  This is an implementation dependent test. 
======================================================================*/
#include "tsthd.h"        /* Perennial test suite header file */
#include "tsteh.h"        /* Perennial exception handling header */

static char prgnam[] = "A15051.C";
/*--------------------------------------------------------------------*/
struct S {
        int i;
        S() {i=1;}
};

static int xpath = 0;          // the bits of xpath indicate the execution path

static void f00(void)
{
        try {
                xpath |= 01;
                throw 'a';      // throw of uncaught exception
        }
        catch (float) {
                xpath |= 0200;  // throw of 'a' caught by wrong handler
        }
}

static void eh_term(void)
{
        S s;
        xpath |= 02;
        b4abort();
        CreateExitFile();
        throw s;        // throw is prohibited
        failure ("Throw from eh_term() was ignored");
        blexit();
        anyfail(1);
}

/*--------------------------------------------------------------------*/
int a15051_main(void)
{
        setup();
        eh_traps();             // set_terminate() and set_unexpected() 
        set_terminate (&eh_term);
/*--------------------------------------------------------------------*/
        blenter();      /* block 00 */

        fprintf(logfp, 
          "REF: ISO/ANSI C++ draft, X3J16/92-0060.  15.6.1 The terminate() Function.\n");
        fprintf(logfp, 
          "A terminate function may not return to its caller ");
        fprintf(logfp, 
          "by throwing an exception.\n");

        f00();
        failure ("abort() was not called; xpath is 0%o", xpath);

        blexit();
/*--------------------------------------------------------------------*/
        anyfail(1);      
        return 0;
}

#include "scaffold.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\a15052.c ===
/* File: A15052.C    Version: 1.1    Date: 08/24/92
 * CVS-C++, C++ Validation Suite
 * Section: 15  Type: A - Abort Expected Test
 * Copyright 1991-92, PERENNIAL, All Rights Reserved
 */
/*======================================================================
        =================== TESTPLAN SEGMENT ===================

>KEYS:  ISO/ANSI C++ draft, X3J16/92-0060.  15.6.1 The terminate() Function
        ARM, Ellis & Stroustrup, May 91.  15.6.1 The terminate() Function

>REL:   EH Phase III and later.

>WHAT:  "Selecting a terminate function that does not in fact
        terminate but tries to return to its caller either with
        return or by throwing an exception is an error."
        
        The ARM states in 15.6.1:

        "Note that terminate() may enforce this rule by calling
        abort() should a user-supplied function return."

        Assertion:
        When a terminate function tries to return to its caller
        by throwing an exception, the function abort() is called.

>HOW:   Call set_terminate() with the address of eh_term(), a
        function that attempts return to its caller using a throw.
        Throw an exception with no handler to catch it.
        The driver should report termination with abort().

>NOTE:  This is an implementation dependent test. 
======================================================================*/
#include "tsthd.h"        /* Perennial test suite header file */
#include "tsteh.h"        /* Perennial exception handling header */

static char prgnam[] = "A15052.C";
/*--------------------------------------------------------------------*/
struct S {
        int i;
        S() {i=1;}
};

static int xpath = 0;          // the bits of xpath indicate the execution path

static void eh_term(void)
{
        S s;
        xpath |= 02;
        b4abort();
        CreateExitFile();
        throw s;        // throw is prohibited
        failure ("Throw from eh_term() was ignored");
        blexit();
        anyfail(1);
}

/*--------------------------------------------------------------------*/
int a15052_main(void)
{
        setup();
        eh_traps();             // set_terminate() and set_unexpected() 
        set_terminate (&eh_term);
/*--------------------------------------------------------------------*/
        blenter();      /* block 00 */

        fprintf(logfp, 
          "REF: ISO/ANSI C++ draft, X3J16/92-0060.  15.6.1 The terminate() Function.\n");
        fprintf(logfp, 
          "A terminate function may not return to its caller ");
        fprintf(logfp, 
          "by throwing an exception.\n");

        try {
                xpath |= 01;
                throw 'a';      // throw of uncaught exception
        }
        catch (S) {
                xpath |= 0400;  // throw was caught 
        }

        failure ("abort() was not called; xpath is 0%o", xpath);

        blexit();
/*--------------------------------------------------------------------*/
        anyfail(1);      
        return 0;
}

#include "scaffold.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\a15053.c ===
/* File: A15053.C    Version: 1.2    Date: 08/24/92
 * CVS-C++, C++ Validation Suite
 * Section: 15  Type: A - Abort Expected Test
 * Copyright 1991-92, PERENNIAL, All Rights Reserved
 */
/*======================================================================
        =================== TESTPLAN SEGMENT ===================

>KEYS:  ISO/ANSI C++ draft, X3J16/92-0060.  15.6.1 The terminate() Function
        ARM, Ellis & Stroustrup, May 91.  15.6.1 The terminate() Function

>REL:   EH Phase III and later.

>WHAT:  "Selecting a terminate function that does not in fact
        terminate but tries to return to its caller either with
        return or by throwing an exception is an error."
        
        The ARM states in 15.6.1:

        "Note that terminate() may enforce this rule by calling
        abort() should a user-supplied function return."

        Assertion:
        When a terminate function tries to return to its caller
        by indirectly throwing an exception, the function abort()
        is called.

>HOW:   Call set_terminate() with the address of eh_term(), a
        function that attempts to return to its caller by calling 
        a function that throws an exception.
        Throw an exception with no handler to catch it.
        The driver should report termination with abort().

>NOTE:  This is an implementation dependent test. 
======================================================================*/
#include "tsthd.h"        /* Perennial test suite header file */
#include "tsteh.h"        /* Perennial exception handling header */

static char prgnam[] = "A15053.C";
/*--------------------------------------------------------------------*/
struct S {
        int i;
        S() {i=1;}
};

static int xpath = 0;          // the bits of xpath indicate the execution path

static void f00(void)
{
        try {
                xpath |= 01;
                throw 'a';      // throw of uncaught exception
        }
        catch (float) {
                xpath |= 0200;  // throw of 'a' caught by wrong handler
        }
}

void g(void)
{
        S s;
        xpath |= 04;
        b4abort();
        throw s;        // throw is prohibited
}

static void eh_term(void)
{
        xpath |= 02;
        CreateExitFile();
        g();            // indirect throw
        failure ("Throw from eh_term() was ignored");
        blexit();
        anyfail(1);
}

/*--------------------------------------------------------------------*/
int a15053_main(void)
{
        setup();
        eh_traps();             // set_terminate() and set_unexpected() 
        set_terminate (&eh_term);
/*--------------------------------------------------------------------*/
        blenter();      /* block 00 */

        fprintf(logfp, 
          "REF: ISO/ANSI C++ draft, X3J16/92-0060.  15.6.1 The terminate() Function.\n");
        fprintf(logfp, 
          "A terminate function may not return to its caller ");
        fprintf(logfp, 
          "by throwing an exception.\n");

        f00();
        failure ("abort() was not called; xpath is 0%o", xpath);

        blexit();
/*--------------------------------------------------------------------*/
        anyfail(1);      
        return 0;
}

#include "scaffold.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\a15050.c ===
/* File: A15050.C    Version: 1.2    Date: 08/21/92
 * CVS-C++, C++ Validation Suite
 * Section: 15  Type: A - Abort Expected Test
 * Copyright 1991-92, PERENNIAL, All Rights Reserved
 */
/*======================================================================
        =================== TESTPLAN SEGMENT ===================

>KEYS:  ISO/ANSI C++ draft, X3J16/92-0060.  15.6.1 The terminate() Function
        6.6.3 The return Statement
        ARM, Ellis & Stroustrup, May 91.  15.6.1 The terminate() Function

>REL:   EH Phase III and later.

>WHAT:  In 15.6.1:

        "Selecting a terminate function that does not in fact
        terminate but tries to return to its caller either with
        return or by throwing an exception is an error."
        
        and in 6.6.3:

        "Flowing off the end of a function is equivalent to a
        return with no value;"

        It is unclear that this error must be detected by the
        implementation.  The ARM states in 15.6.1:

        "Note that terminate() may enforce this rule by calling
        abort() should a user-supplied function return."

        Assertion:
        When the terminate function tries to return to its caller
        by flowing off the end of its definition, the function 
        abort() is called.

>HOW:   Call set_terminate() with the address of eh_term(), a
        function that flows off the end of its definition.
        Throw an exception with no handler to catch it.
        The driver should report termination with abort().

>NOTE:  This is an implementation dependent test. 
======================================================================*/
#include "tsthd.h"        /* Perennial test suite header file */
#include "tsteh.h"        /* Perennial exception handling header */

static char prgnam[] = "A15050.C";
/*--------------------------------------------------------------------*/

int pend(void);

struct S {
        int i;
        S() { i=0;}
};

static int xpath = 0;

static void eh_term(void)
{
        xpath |= 02;
        b4abort();
        CreateExitFile();
        // attempt to return to caller with an implicit return
}

/*--------------------------------------------------------------------*/
int a15050_main(void)
{
        S s;

        setup();
        eh_traps();             // set_terminate() and set_unexpected() 
        set_terminate (&eh_term);
/*--------------------------------------------------------------------*/
        blenter();      /* block 00 */

        fprintf(logfp, "REF: ISO/ANSI C++ draft, X3J16/92-0060. 15.6.1 The terminate() Function\n");
        fprintf(logfp, "The terminate function may not return to ");
        fprintf(logfp, "its caller by flowing\noff its end.\n");

        try {
                xpath |= 01;
                throw s;        // uncaught exception.
        }
        catch (char) {
                xpath = 040;    // Throw was caught by the wrong handler
        }
        failure ("eh_term() returned to its caller; xpath is 0%o", xpath);

        blexit();
/*--------------------------------------------------------------------*/
        anyfail(1);      
        return 0;
}

#include "scaffold.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\a15054.c ===
/* File: A15054.C    Version: 1.1    Date: 08/24/92
 * CVS-C++, C++ Validation Suite
 * Section: 15  Type: A - Abort Expected Test
 * Copyright 1991-92, PERENNIAL, All Rights Reserved
 */
/*======================================================================
        =================== TESTPLAN SEGMENT ===================

>KEYS:  ISO/ANSI C++ draft, X3J16/92-0060.  15.6.1 The terminate() Function
        ARM, Ellis & Stroustrup, May 91.  15.6.1 The terminate() Function

>REL:   EH Phase III and later.

>WHAT:  "Selecting a terminate function that does not in fact
        terminate but tries to return to its caller either with
        return or by throwing an exception is an error."
        
        The ARM states in 15.6.1:

        "Note that terminate() may enforce this rule by calling
        abort() should a user-supplied function return."

        Assertion:
        When a terminate function tries to return to its caller
        by rethrowing an exception, the function abort() is called.

>HOW:   Call set_terminate() with the address of eh_term(), a
        function that attempts return to its caller using a throw.
        Throw an exception with no handler to catch it.
        The driver should report termination with abort().

>NOTE:  This is an implementation dependent test. 
======================================================================*/
#include "tsthd.h"        /* Perennial test suite header file */
#include "tsteh.h"        /* Perennial exception handling header */

static char prgnam[] = "A15054.C";
/*--------------------------------------------------------------------*/
struct S {
        int i;
        S() {i=1;}
};

static int xpath = 0;          // the bits of xpath indicate the execution path

static void f00(void)
{
        try {
                xpath |= 01;
                throw 'a';      // throw of uncaught exception
        }
        catch (float) {
                xpath |= 0200;  // throw of 'a' caught by wrong handler
        }
}

static void eh_term(void)
{
        xpath |= 02;
        b4abort();
        CreateExitFile();
        throw;          // rethrow is prohibited
        failure ("Rethrow from eh_term() was ignored");
        blexit();
        anyfail(1);
}

/*--------------------------------------------------------------------*/
int a15054_main(void)
{
        setup();
        eh_traps();             // set_terminate() and set_unexpected() 
        set_terminate (&eh_term);
/*--------------------------------------------------------------------*/
        blenter();      /* block 00 */

        fprintf(logfp, 
          "REF: ISO/ANSI C++ draft, X3J16/92-0060.  15.6.1 The terminate() Function.\n");
        fprintf(logfp, 
          "A terminate function may not return to its caller ");
        fprintf(logfp, 
          "by throwing an exception.\n");

        f00();
        failure ("abort() was not called; xpath is 0%o", xpath);

        blexit();
/*--------------------------------------------------------------------*/
        anyfail(1);      
        return 0;
}

#include "scaffold.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\filbuf_2.c ===
/* @(#)File: filbuf_2.C    Version: 1.0    Date: 09/27/90             */
/* CVS-CC, C++ Validation Suite                                       */
/* Copyright 1989, Perennial, All Rights Reserved                     */
/*======================================================================
    =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Manual Select Code 307-145
    < Appendix A-4, Stream I/O Library Manual Pages, 

>WHAT:  < FILEBUF(3C++) Manual page dated 14 June 1989
    <
    < This buffer class is intended to use a file as a source or
    < sink for a stream of bytes. This test sets up some filebufs
    < and tests their functionality.
    <
    < 0. The filebuf open() member allows the file protection
    <    to be specified for file creation. 
    <

>HOW:   < 0. Test that the file is created with the correct mask
    <    using the fstat system call. Note that the indicated
    <    permissions cannot be more liberal than permitted by
    <    the umask or they will be limited and the test will
    <    fail. 

>MODS:  < 07/02/90, DRE: Removed definition of failure().
    <    Included "testhead.h" rather than "testhead.h".
    < Vers 1.0, date: 3/2/90: Created DRE

>BUGS:  < This test uses the ANSI C library routine tmpnam() to
    < get the name of a temporary file, thus it is ANSI C
    < library dependent.
    <
    < The test is Unix-dependent because it uses the
    < fstat system call to check file permissions.
======================================================================*/

#if defined(USING_OLD_IOS)
#include <iostream.h>
#include <fstream.h>
#else
#include <iostream>
#include <fstream>
#endif 
//#include <osfcn.h>
#include <sys/types.h>
#include <sys/stat.h>
//#include "remove.h"

#include "testhead.h"


static char progname[] = "filbuf_2()";

/**********************************************************************/
/*                                                                    */
/* This test uses a data file that it reads and copies. The name of   */
/* the file is stored in the datfile variable.                        */
/*                                                                    */
/**********************************************************************/

static int create_datafile(const char * filename);

static char filenamebuf[L_tmpnam];

static const char * datfile = tmpnam(filenamebuf);

/*--------------------------------------------------------------------*/
filbuf_2_main()                  
{
    setup();

/*--------------------------------------------------------------------*/
block0: blenter();          

#if defined(USING_OLD_IOS)

    DbgPrint("REF: AT&T Library Manual Appendix A-4, Stream\n");
    DbgPrint("I/O Library, testing the filebuf class.\n");
    DbgPrint("When a file is created by the open member of\n");
    DbgPrint("the filebuf class its protection mask may be\n");
    DbgPrint("specified.\n");

    filebuf fb1;
    const int prot=0600;

    if (fb1.open(datfile, ios::out, prot) == 0)
        failure("Cannot open data file.");
    else {
        // Stat the file and verify its permissions.
        struct stat buf;
        if (fstat(fb1.fd(), &buf) == -1) 
            failure("Cannot stat the data file.");
        else if ((buf.st_mode & 0777) != prot) {
            char buff[80];
            sprintf(buff, "File created with wrong mode 0%o.",
            buf.st_mode & 0777);
            failure(buff);
        }
    }
    
    // Remove the data file
    remove(datfile);

#endif 

    blexit();
/*--------------------------------------------------------------------*/
    anyfail();  
    return 0;
}                   


/**********************************************************************/
/*                                                                    */
/* create_datafile                                                    */
/*                                                                    */
/* This routine writes the known data into the data file.             */
/*                                                                    */
/* Return:                                                            */
/*                                                                    */
/*    1   success                                                     */
/*    0   failure for some reason                                     */
/*                                                                    */
/**********************************************************************/

static int create_datafile(const char * filename)
{
    ofstream ofs(filename, ios::out|ios::trunc);
    if (!ofs.good()) {
        extern int errno;
        DbgPrint( "Cannot open data file to write it.\n");
        DbgPrint( "errno is %d.\n",errno);
        return 0;
    }

    ofs << "Line 1"<< "\n";
    ofs << "Line 2"<< "\n";
    ofs << "Line 3"<< "\n";

    ofs.close();
    return 1;
}

#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\filbuf_1.c ===
/* @(#)File: filbuf_1.C    Version: 1.0    Date: 11/08/90             */
/* CVS-CC, C++ Validation Suite                                       */
/* Copyright 1989, Perennial, All Rights Reserved                     */
/*======================================================================
    =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Manual Select Code 307-145
    < Appendix A-4, Stream I/O Library Manual Pages, 

>WHAT:  < FILEBUF(3C++) Manual page dated 14 June 1989
    <
    < This buffer class is intended to use a file as a source or
    < sink for a stream of bytes. This test sets up some filebufs
    < and tests their functionality.
    <
    < 0. A filebuf is initially closed.
    <
    < 1. Open the file with the Unix open() system call. Then 
    <    declare a filebuf with the file descriptor and a buffer
    <    as arguments to the constructor. Verify the file is open.
    <
    < 2. Open the file with the Unix open() system call. Then 
    <    declare a filebuf with the file descriptor as an argument
    <    to the constructor. Check that is_open() reports that the
    <    file is open. 
    <
    < 3. Use the attach() member to attach a file descriptor to
    <    a filebuf.
    <
    < 4. Use the open() member to attach a file name to
    <    a filebuf.

>HOW:   < 0. Declare a filebuf and verify that it does not consider
    <    itself open.
    <
    < 1. Open a file with the open system call. Pass the file 
    <    descriptor to a filebuf constructor and verify that the
    <    filebuf considers itself open. Also pass in a buffer
    <    pointer and length.
    <
    < 2. Open a file with the open system call. Pass the file 
    <    descriptor to a filebuf constructor and verify that the
    <    filebuf considers itself open. Don't pass in a buffer
    <    pointer and length.
    <
    < 3. Open the file by hand and pass the file descriptor to
    <    the attach member.
    <
    < 4. Open the file with the open() member of the filebuf class.

>MODS:  < 07/02/90, DRE: Removed definition of failure().
    <    Included "testhead.h" rather than "testhead.h".
    < Vers 1.0, date: 3/1/90: Created DRE

>BUGS:  < This test uses the ANSI C library routine tmpnam() to
    < get the name of a temporary file, thus it is ANSI C
    < library dependent.
    <
    < The test is Unix-dependent because it uses the open()
    < system call to obtain file descriptors. This is required
    < to test constructors and attach() member functions that
    < take file descriptors as arguments.

======================================================================*/

#if defined(USING_OLD_IOS)
#include <iostream.h>
#include <fstream.h>
#else
#include <iostream>
#include <fstream>
#endif 
#include <fcntl.h>
//#include <osfcn.h>
//#include "remove.h"

#include "testhead.h"


static char progname[] = "filbuf_1()"; 

/**********************************************************************/
/*                                                                    */
/* This test uses a data file that it reads and copies. The name of   */
/* the file is stored in the datfile variable.                        */
/*                                                                    */
/**********************************************************************/

static int create_datafile(const char * filename);

static char filenamebuf[L_tmpnam];

static const char * datfile = tmpnam(filenamebuf);

/*--------------------------------------------------------------------*/
filbuf_1_main()                  
{
    setup();

/*--------------------------------------------------------------------*/
block0: blenter();          

    DbgPrint("Creating data file used by this test.\n");
    // Create the data file that the rest of this test uses.
    if (create_datafile(datfile) == 0) {
        failure("Cannot create data file: can't run test.");
        goto done;
    }

    DbgPrint("REF: AT&T Library Manual Appendix A-4, Stream\n");
    DbgPrint("I/O Library, testing the filebuf class.\n");
    DbgPrint("A filebuf is initially closed.\n");

    {
        filebuf fb1;

        if (fb1.is_open())
            failure("Filebuf reported as being open.");
    }
    
    blexit();
/*--------------------------------------------------------------------*/
block1: blenter();          

#if defined(USING_OLD_IOS)  /* filebuf no longer accepts file handles. */

    if (local_flag != FAILED) {

        DbgPrint("%s%s%s%s%s%s%s",
        "REF: AT&T Library Manual Appendix A-4, Stream\n",
        "I/O Library, testing the filebuf class.\n",
        "Open the file with the Unix open() system call.\n",
        "Then declare a filebuf with the file descriptor\n",
        "and a buffer as args to the constructor. Check that\n",
        "is_open() reports that the file is open.\n",
        "Check that the fd() member returns the expected fd.\n");
        
        int fd = _open(datfile, O_RDONLY);
        const int buff_size = 128;
        char buff[buff_size];

        if (fd == -1) {
            local_flag = FAILED;
            extern int errno;
            DbgPrint( "%s : %s %d!\n", 
                progname, 
                "Non-C++ error: open system call failed, errno",
                errno);
        }
        else {

        filebuf fb2(fd,buff,buff_size);

        if (!fb2.is_open()) 
            failure("File is not flagged as being open.");
        else if (fb2.fd() != fd) 
            failure("Filebuf returned unexpected file descriptor.");
        else if (fb2.close() != &fb2) 
            failure("Error on file close.");
        }

    } /* local_flag != FAILED */

#endif

    blexit();
/*--------------------------------------------------------------------*/
block2: blenter();          

#if defined(USING_OLD_IOS)

    if (local_flag != FAILED) {

        DbgPrint("%s%s%s%s%s%s%s",
        "REF: AT&T Library Manual Appendix A-4, Stream\n",
        "I/O Library, testing the filebuf class.\n",
        "Open the file with the Unix open() system call.\n",
        "Then declare a filebuf with the file descriptor\n",
        "as an argument to the constructor. Check that\n",
        "is_open() reports that the file is open.\n",
        "Check that the fd() member returns the expected fd.\n");
        
        int fd = _open(datfile, O_RDONLY);

        if (fd == -1) {
        local_flag = FAILED;
        extern int errno;
        DbgPrint( "%s : %s %d!\n", 
            progname, 
            "Non-C++ error: open system call failed, errno",
            errno);
        }
        else {
        filebuf fb3(fd);

        if (!fb3.is_open()) 
            failure("File is not flagged as being open.");
        else if (fb3.fd() != fd)
            failure("Filebuf returned unexpected file descriptor.");
        else if (fb3.close() != &fb3) 
            failure("Error on file close.");
        }
        
    } /* local_flag != FAILED */

#endif

    blexit();
/*--------------------------------------------------------------------*/
block3: blenter();          

#if defined(USING_OLD_IOS)

    if (local_flag != FAILED) {

        DbgPrint("%s%s%s%s%s",
        "REF: AT&T Library Manual Appendix A-4, Stream\n",
        "I/O Library, testing the filebuf class.\n",
        "Attach a file descriptor to a filebuf with the\n",
        "attach() member. Verify that if the filebuf is\n",
        "already open the attach() operation returns 0.\n",
        "Check that the fd() member returns the expected fd.");
        
        filebuf fb4;

        int fd = _open(datfile, O_RDONLY);

        if (fd == -1) {
        local_flag = FAILED;
        extern int errno;
        DbgPrint( "%s : %s %d!\n", 
            progname, 
            "Non-C++ error: open system call failed, errno",
            errno);
        } 
        else if (fb4.attach(fd) != &fb4) 
            failure("Could not attach file descriptor.");
        else if (fb4.fd() != fd) 
            failure("Filebuf returned wrong file descriptor.");
        else if (fb4.attach(0) != 0) 
            failure("Attaching second fd succeeded.");
        else if (fb4.fd() != fd) 
            failure("After second attach filebuf has bad fd.");
        else if (fb4.close() != &fb4) 
            failure("Error on file close.");
        
    } /* local_flag != FAILED */

#endif

    blexit();
/*--------------------------------------------------------------------*/
block4: blenter();          

#if defined(USING_OLD_IOS)

    if (local_flag != FAILED) {

        DbgPrint("%s%s%s%s%s",
            "REF: AT&T Library Manual Appendix A-4, Stream\n",
            "I/O Library, testing the filebuf class.\n",
            "Use the open() member of the filebuf to open\n",
            "a file.\n");
        
        filebuf fb4;

        if (fb4.open(datfile,ios::nocreate|ios::in) != &fb4) 
            failure("Could not open file.");
        else if (fb4.close() != &fb4) 
            failure("Error on file close.");

    } /* local_flag != FAILED */

#endif

    blexit();
/*--------------------------------------------------------------------*/
    remove(datfile);
done:
    anyfail();  
    return 0;
}                   


/**********************************************************************/
/*                                                                    */
/* create_datafile                                                    */
/*                                                                    */
/* This routine writes the known data into the data file.             */
/*                                                                    */
/* Return:                                                            */
/*                                                                    */
/*    1   success                                                     */
/*    0   failure for some reason                                     */
/*                                                                    */
/**********************************************************************/

static int create_datafile(const char * filename)
{
    ofstream ofs(filename, ios::out|ios::trunc);
    if (!ofs.good()) {
        extern int errno;
        DbgPrint( "Cannot open data file to write it.\n");
        DbgPrint( "errno is %d.\n",errno);
        return 0;
    }

    ofs << "Line 1"<< "\n";
    ofs << "Line 2"<< "\n";
    ofs << "Line 3"<< "\n";

    ofs.close();
    return 1;
}

#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\format1.c ===
/* @(#)File: format1.C      Version: 1.0        Date:11/08/90   */
/* CVS-CC, C++ Validation Suite                     */
/* Copyright 1989, Perennial, All Rights Reserved           */
/*========================================================================
        =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Manual, Appendix A, IOS(3C++)        >
    < in AT&T C++ Language System 2.0, May 89.  Select Code 307-145 >

>WHAT:  < This file tests the effects of some output related bits in    >
    < the format control word.  These effects are observed on   >
    < values inserted into a strstreambuf.              >

    < The bits tested here are : left, right and internal.      >
    < These flags control the padding of a value.  The width of >
    < the padding is set by the function width(), and the fill  >
    < character is controlled by the function fill().       >

>HOW:   < Set the width to 4, and the fill character to '!' .       >
    < Write some integer to the stream.  Check that the output  >
    < is properly padded in the the output buffer.          >

    < 0. When left is set, the fill character is added after the    >
    <    value.                         >

    < 1. When right is set, the fill character is added before the  >
    <    value.                         >

    < 2. When internal is set, the fill character is added after    >
    <    the leading sign or base but before the value.  Check  >
    <    this rule with a sign.                 >
    
    < 3. When internal is set, the fill character is added after    >
    <    the leading sign or base but before the value.  Check  >
    <    this rule with a base.                 >

    < 4. Right adjustement is the default if all three flags are    >
    <    cleared.                           >

>MODS:  < 11/08/90, DRE: Added bugs comment for cfront 2.1.             >
    < 07/02/90, DRE: Include "testhead.h" not "../../testhead.h".   >
    < Version 1.0 created by HK on 3/4/90.              >

>BUGS:  < No cfront 2.0 bugs are known.    
    < Cfront 2.1 fails block 2. It ends up with
    < ``-!!1'' in the buffer rather than ``-!!2''. 
========================================================================*/

#include "testhead.h"     

static char progname[] = "format1()";         

inline void print(char str[]) { DbgPrint( "%s\n", str); }
static void fail (char str[]) {
    local_flag =FAILED;
    DbgPrint( "\tFAILURE: %s\n", str);
    }

/*--------------------------------------------------------------------*/
#if defined(USING_OLD_IOS)
#include <iostream.h>
#else
#include <iostream>
#include <strstream>
using namespace std;
#endif

// global variable declarations

/*--------------------------------------------------------------------*/
format1_main()                                  /***** BEGINNING OF MAIN. *****/
{

        setup();
/*--------------------------------------------------------------------*/
block0: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test left padding.");

    {char buf[10];
    ostrstream s(buf, 8);   // create a stream
    s.fill('!');        // set fill character to '!'
    s.width(4);     // set width to 4
    s.setf(ios::left, ios::adjustfield);    // set flag

    s << 0;         // write to stream
    if (strncmp(buf, "0!!!", 4))
        fail ("unexpected result");
    }

        blexit();
/*--------------------------------------------------------------------*/
block1: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test right padding.");

    {char buf[10];
    ostrstream s(buf, 8);   // create a stream
    s.fill('!');        // set fill character to '!'
    s.width(4);     // set width to 4
    s.setf(ios::right, ios::adjustfield);   // set flag

    s << 1;         // write to stream
    if (strncmp(buf, "!!!1", 4))
        fail ("unexpected result");
    }

        blexit();
/*--------------------------------------------------------------------*/
block2: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test internal padding with a signed integer");

    {char buf[10];
    ostrstream s(buf, 8);   // create a stream
    s.fill('!');        // set fill character to '!'
    s.width(4);     // set width to 4
    s.setf(ios::internal, ios::adjustfield);    // set flag

    s << - 2;           // write to stream
    if (strncmp(buf, "-!!2", 4))
        fail ("unexpected result");
        DbgPrint( "got `%s', expected `-!!2'.\n", buf);
    }

        blexit();
/*--------------------------------------------------------------------*/
block3: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test internal padding with a hex integer");

    {char buf[10];
    ostrstream s(buf, 8);   // create a stream
    s.fill('!');        // set fill character to '!'
    s.width(5);     // set width to 4
    s.setf(ios::internal, ios::adjustfield);    // set flag
    s.setf(ios::hex, ios::basefield);       // set hex flag
    s.setf(ios::showbase);              // make base show

    s << 10;            // write to stream
    if (strncmp(buf, "0x!!a", 5))
        fail ("unexpected result");
    }

        blexit();
/*--------------------------------------------------------------------*/
block4: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Verify default is right padding when no flag is set");

    {char buf[10];
    ostrstream s(buf, 8);   // create a stream
    s.fill('!');        // set fill character to '!'
    s.width(4);     // set width to 4
    s.unsetf(ios::adjustfield); // unset all flags

    s << 4;         // write to stream
    if (strncmp(buf, "!!!4", 4))
        fail ("unexpected result");
    }

    blexit();
/*--------------------------------------------------------------------*/
    anyfail();      
    return 0;
}                                       /******** END OF MAIN. ********/


#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\format2.c ===
/* @(#)File: format2.C      Version: 1.0        Date:09/27/90   */
/* CVS-CC, C++ Validation Suite                     */
/* Copyright 1989, Perennial, All Rights Reserved           */
/*========================================================================
        =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Manual, Appendix A, IOS(3C++)        >
    < in AT&T C++ Language System 2.0, May 89.  Select Code 307-145 >

>WHAT:  < This file tests the effects of some output related bits in    >
    < the format control word.  These effects are observed on   >
    < values inserted into a strstreambuf.              >

    < The bits tested here are showpos and  uppercase.      >

>HOW:   < The method used is to insert some value into an output    >
    < strstreambuf and check that the value that was written to     >
    < the buffer has the proper format.             >

    < Blocks 0 thru 3 test showpos.  When showpos is set, a "+" >
    < is inserted into the decimal conversion of a positive     >
    < integral value.                       >

    < 0. Set the base field to dec.  Write a positive integer.      >
    <    Check it comes out preceded by a "+" sign.         >

    < 1. Set the base field to oct.  Write a positive integer.      >
    <    Check it doesn't come out preceded by a "+" sign.      >

    < 2. Set the base field to hex.  Write a positive integer.      >
    <    Check it doesn't come out preceded by a "+" sign.      >

    < 3. Set the base field to dec.  Unset the showpos flag.    >
    <    Write a positive integer.  Check it comes out preceded >
    <    by a "+" sign.                     >

    < Blocks 4 thru 7 test uppercase.  When uppercase is set, an    >
    < uppercase "X" is used for hexadecimal conversions and an  >
    < uppercase "E" for floating point numbers in scientific    >
    < notation.                         >

    < 4. Set uppercase and check that a "X" comes out when you  >
    <    output a hexadecimal integer.              >

    < 5. Unset uppercase and check that a "x" comes out when you    >
    <    output a hexadecimal integer.              >

    < 6. Set uppercase and check that a "E" comes out when you  >
    <    output a floating point number in scientific notation. >

    < 7. Unset uppercase and check that a "e" comes out when you    >
    <    output a floating point number in scientific notation. >

>MODS:  < Version 1.0 created by HK on 3/4/90.              >

>BUGS:  < None known.                           >
========================================================================*/
#include "testhead.h"     

static char progname[] = "format2()";         

inline void print(char str[]) { DbgPrint( "%s\n", str); }
static void fail (char str[]) {
    local_flag =FAILED;
    DbgPrint( "\tFAILURE: %s\n", str);
    }

/*--------------------------------------------------------------------*/
#if defined(USING_OLD_IOS)
#include <iostream.h>
#else
#include <iostream>
#include <strstream>
using namespace std;
#endif

// global variable declarations

/*--------------------------------------------------------------------*/
format2_main()                                  /***** BEGINNING OF MAIN. *****/
{

        setup();
/*--------------------------------------------------------------------*/
block0: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test showpos flag with decimal output");

    {char buf[10];
    ostrstream s(buf, 8);   // create a stream
    s.setf(ios::showpos);   // set the flag
    s.setf(ios::dec, ios::basefield);   //set to base 10

    s << 9;         // write to stream
    if (strncmp(buf, "+9", 2))
        fail ("unexpected result");
    }

        blexit();
/*--------------------------------------------------------------------*/
block1: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test showpos flag with oct output");

    {char buf[10];
    ostrstream s(buf, 8);   // create a stream
    s.setf(ios::showpos);   // set the flag
    s.setf(ios::oct, ios::basefield);   //set to base 8

    s << 9;         // write to stream
    if (strncmp(buf, "11", 2))
        fail ("unexpected result");
    }

        blexit();
/*--------------------------------------------------------------------*/
block2: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test showpos flag with hex output");

    {char buf[10];
    ostrstream s(buf, 8);   // create a stream
    s.setf(ios::showpos);   // set the flag
    s.setf(ios::hex, ios::basefield);   //set to base 16

    s << 16;            // write to stream
    if (strncmp(buf, "10", 2))
        fail ("unexpected result");
    }

        blexit();
/*--------------------------------------------------------------------*/
block3: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test showpos unset with decimal output");

    {char buf[10];
    ostrstream s(buf, 8);   // create a stream
    s.unsetf(ios::showpos); // set the flag
    s.setf(ios::dec, ios::basefield);   //set to base 16

    s << 16;            // write to stream
    if (strncmp(buf, "16", 2))
        fail ("unexpected result");
    }

        blexit();
/*--------------------------------------------------------------------*/
block4: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test uppercase set with a hex output");

    {char buf[10];
    ostrstream s(buf, 8);   // create a stream
    s.setf(ios::uppercase); // set the flag
    s.setf(ios::showbase);  // set the show base flag
    s.setf(ios::hex, ios::basefield);   //set to base 16

    s << 16;            // write to stream
    if (strncmp(buf, "0X10", 4))
        fail ("unexpected result");
    }

        blexit();
/*--------------------------------------------------------------------*/
block5: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test uppercase unset with a hex output");

    {char buf[10];
    ostrstream s(buf, 8);   // create a stream
    s.unsetf(ios::uppercase);   // set the flag
    s.setf(ios::showbase);  // set the show base flag
    s.setf(ios::hex, ios::basefield);   //set to base 16

    s << 16;            // write to stream
    if (strncmp(buf, "0x10", 4))
        fail ("unexpected result");
    }

        blexit();
/*--------------------------------------------------------------------*/
block6: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test uppercase set with a scientific notation");

    {char buf[30];
    ostrstream s(buf, 8);   // create a stream
    s.precision(1);     // set the precision to 1
    s.setf(ios::uppercase); // set the flag
    s.setf(ios::scientific, ios::floatfield);   //set to scientific not.

    s << 0.005;         // write to stream
    if (strncmp(buf, "5.0E-003", 7))
        fail ("unexpected result");
    }

        blexit();
/*--------------------------------------------------------------------*/
block7: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test uppercase unset with scientific notation");

    {char buf[30];
    ostrstream s(buf, 8);   // create a stream
    s.unsetf(ios::uppercase);   // set the flag
    s.precision(1);     // set the precision to 1
    s.setf(ios::scientific, ios::floatfield);   //set to scientific not.

    s << 0.005;         // write to stream
    if (strncmp(buf, "5.0e-003", 7))
    {
        fail ("unexpected result");
        DbgPrint("\t%s != 5.0e-003\n", buf);
    }
    }

        blexit();
/*--------------------------------------------------------------------*/
    anyfail();
    return 0;
}

#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\format3.c ===
/* @(#)File: format3.C      Version: 1.2        Date: 01/02/91  */
/* CVS-CC, C++ Validation Suite                     */
/* Copyright 1989, 1990, Perennial, All Rights Reserved         */
/*========================================================================
        =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Manual, Appendix A, IOS(3C++)        >
    < in AT&T C++ Language System 2.0, May 89.  Select Code 307-145 >

>WHAT:  < This file tests the effects of some output related bits in    >
    < the format control word.  These effects are observed on   >
    < values inserted into a strstreambuf.              >

    < The bits tested here are scientific and fixed.        >

>HOW:   < The method used is to insert some value into an output    >
    < strstreambuf and check that the value that was written to     >
    < the buffer has the proper format.             >

    < The flags scientific and fixed control the fomat a floating   >
    < point variable is converted for insertion into a stream.  >

    < 0. Set scientific and check the valueis converted using   >
    <    scientific notation.                   >

    < 1. Set the precision to n.  Check the scientific notation >
    <    has n digits to the right of the decimal point.        >

    < 2. Set fixed and check the value is converted to decimal  >
    <    notation.                          >

    < 3. Set the precision to n.  Check the decimal notation    >
    <    has n digits to the right of the decimal point.        >

    < Blocks 4 thru 6 test the floating point conversion when   >
    < neither scientific nor fixed are set.             >

    < 4. Unset both scientific and fixed.  Check the value is   >
    <    converted to scientific when the exponent is less than -4. >

    < 5. Unset both scientific and fixed.  Check the value is   >
    <    converted to decimal when the exponent is between -4 and   >
    <    the precision.                     >

    < 6. Unset both scientific and fixed.  Check the value is   >
    <    converted to scientific when the exponent is more than     >
    <    the precision.                     >

>MODS:  < Ver 1.3 01/02/91 RFG - Substantial corrections and refinements.
    < Ver 1.1, 07/18/90, DRE: 
    <    The previous version used the precision incorrectly. Fixed it.
    < Version 1.0 created by HK on 3/4/90.              >

>BUGS:  < No bugs or system dependencies known.
========================================================================*/
#include "testhead.h"     

static char progname[] = "format3()";

#define MYBUFSIZE   512

inline void print(char str[]) { DbgPrint( "%s\n", str); }

static void fail (char str[]) {
    local_flag =FAILED;
    DbgPrint( "\tFAILURE: %s\n", str);
    }

/*--------------------------------------------------------------------*/
#if defined(USING_OLD_IOS)
#include <iostream.h>
#else
#include <iostream>
#include <strstream>
using namespace std;
#endif

// global variable declarations

/*--------------------------------------------------------------------*/
format3_main()                                  /***** BEGINNING OF MAIN. *****/
{

        setup();
/*--------------------------------------------------------------------*/
block0: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test scientific flag causes conversion to scientific notation");

    {static char buf[MYBUFSIZE] = "                   ";
    ostrstream s(buf, 18);  // create a stream
    s.setf(ios::scientific, ios::floatfield);

    s << '{';
    s << 10.1;
    s << '}';

#undef EXPECT
#define EXPECT "{1.010000e+001}"

    if (strncmp(buf, EXPECT, strlen (EXPECT)))
        {DbgPrint( "expected = \"%s\", got = \"%s\"\n",
            EXPECT, buf);
        fail ("unexpected result");
        }
    }

        blexit();
/*--------------------------------------------------------------------*/
block1: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Check the scientific notation has \"precision\" digits to");
    print("of the decimal point");

    {static char buf[MYBUFSIZE] = "                   ";
    ostrstream s(buf, 18);  // create a stream
    s.setf(ios::scientific, ios::floatfield);
    s.precision(1);

    s << '{';
    s << 220.0;
    s << '}';

#undef EXPECT
#define EXPECT "{2.2e+002}"

    if (strncmp(buf, EXPECT, strlen (EXPECT)))
        {DbgPrint( "expected = \"%s\", got = \"%s\"\n",
            EXPECT, buf);
        fail ("unexpected result");
        }
    }

        blexit();
/*--------------------------------------------------------------------*/
block2: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test fixed flag causes conversion to decimal notation");

    {static char buf[MYBUFSIZE] = "                   ";
    ostrstream s(buf, 18);  // create a stream
    s.setf(ios::fixed, ios::floatfield);

    s << '{';
    s << 3.3;
    s << '}';

#undef EXPECT
#define EXPECT "{3.300000}"

    if (strncmp(buf, EXPECT, strlen (EXPECT)))
        {DbgPrint( "expected = \"%s\", got = \"%s\"\n",
            EXPECT, buf);
        fail ("unexpected result");
        }
    }

        blexit();
/*--------------------------------------------------------------------*/
block3: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Check the decimal notation has \"precision\" digits to");
    print("of the decimal point");

    {static char buf[MYBUFSIZE] = "                   ";
    ostrstream s(buf, 18);  // create a stream
    s.precision(1);
    s.setf(ios::fixed, ios::floatfield);

    s << '{';
    s << 4.4e2;
    s << '}';

#undef EXPECT
#define EXPECT "{440.0}"

    if (strncmp(buf, EXPECT, strlen (EXPECT)))
        {DbgPrint( "expected = \"%s\", got = \"%s\"\n",
            EXPECT, buf);
        fail ("unexpected result");
        }
    }

        blexit();
/*--------------------------------------------------------------------*/
block4: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("When both scientific and fixed are unset, the value is");
    print("converted to scientific notation if the would-be exponent");
    print("is less than - 4");

    {char buf[MYBUFSIZE];
    ostrstream s(buf, 18);  // create a stream
    s.precision(2);
    s.setf(ios::showpoint);
    s.unsetf(ios::fixed && ios::scientific);

    s << '{';
    s << 0.0000051;
    s << '}';

#undef EXPECT
#define EXPECT "{5.1e-006}"

    if (strncmp(buf, EXPECT, strlen (EXPECT)))
        {DbgPrint( "expected = \"%s\", got = \"%s\"\n",
            EXPECT, buf);
        fail ("unexpected result");
        }
    }

        blexit();
/*--------------------------------------------------------------------*/
block5: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("When both scientific and fixed are unset, the value is");
    print("converted to decimal notation if the would-be exponent");
    print("is between -4 and the precision");

    {static char buf[MYBUFSIZE] = "                   ";
    ostrstream s(buf, 18);  // create a stream
    s.precision(3);     // three **SIGNIFICANT** digits
    s.setf(ios::showpoint);
    s.unsetf(ios::fixed && ios::scientific);

    s << '{';
    s << 0.006;
    s << '}';

#undef EXPECT
#define EXPECT "{0.00600}"

    if (strncmp(buf, EXPECT, strlen (EXPECT)))
        {DbgPrint( "expected = \"%s\", got = \"%s\"\n",
            EXPECT, buf);
        fail ("unexpected result");
        }
    }

        blexit();
/*--------------------------------------------------------------------*/
block6: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("When both scientific and fixed are unset, the value is");
    print("converted to scientific notation if the would-be exponent");
    print("is larger than the precision");

    {char buf[MYBUFSIZE];
    ostrstream s(buf, 18);  // create a stream
    s.precision(3);
    s.setf(ios::showpoint);
    s.unsetf(ios::fixed && ios::scientific);

    s << '{';
    s << 70700.0;
    s << '}';

#undef EXPECT
#define EXPECT "{7.07e+004}"

    if (strncmp(buf, EXPECT, strlen (EXPECT)))
        {DbgPrint( "expected = \"%s\", got = \"%s\"\n",
            EXPECT, buf);
        fail ("unexpected result");
        }
    }


        blexit();
/*--------------------------------------------------------------------*/
    anyfail();
    return 0;
}

#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\filbuf_3.c ===
/* @(#)File: filbuf_3.C    Version: 1.1    Date: 09/27/90             */
/* CVS-CC, C++ Validation Suite                                       */
/* Copyright 1989, 1990, Perennial, All Rights Reserved               */
/*======================================================================
    =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Manual Select Code 307-145
    < Appendix A-4, Stream I/O Library Manual Pages, 

>WHAT:  < SBUF.PROT(3C++) Manual page, FILEBUF(3C++) derived class
    < Manual pages dated 14 June 1989
    <
    < This derived class is intended to use a file as a source or
    < sink for a stream of bytes. This is a test of the setbuf
    < virtual function and unbuffered I/O. The sbuf.prot(3C++)
    < manual page indicates that setbuf(p,len) requests the
    < buffer class to do unbuffered I/O when len==0. The derived
    < class need not honor this request. If it does honor the
    < request it returns the address of the buffer, otherwise it
    < returns NULL. This file tests that functionality on the
    < filebuf derived class.
    <

>HOW:   < Open a filebuf on a file. Make it unbuffered.
    < Write a byte to the file through the buffer.
    < Then we try to read the byte through the file descriptor. 
    < It should be present because there should be no buffering.
    < The semantics tested in blocks 1-3 are described on the
    < filebuf(3C++) manual page. It is supposed to honor these
    < semantics.
    <
    < 0. Make the filebuf unbuffered with the constructor.
    <
    < 1. Make the filebuf unbuffered with a setbuf call with a
    <    NULL pointer.
    <
    < 2. Make file filebuf unbuffered with a setbuf call with 
    <    a zero length.
    <
    < 3. Make file filebuf unbuffered with a setbuf call with 
    <    a negative length.
    <

>MODS:  < 07/18/90, Ver 1.1, DRE
    <    Passed explicit 0644 permissions to the open system call.
    <    Added 1990 copyright.
    < 07/02/90, DRE: Removed definition of failure().
    <    Included "testhead.h" rather than "testhead.h".
    < Vers 1.0, date: 3/5/90: Created DRE

>BUGS:  < This test uses the ANSI C library routine tmpnam() to
    < get the name of a temporary file, thus it is ANSI C
    < library dependent.
    <
    < All four blocks of this test work on filebuf operators
    < that have file descriptor arguments, thus this test is
    < Unix dependent.

======================================================================*/

#if defined(USING_OLD_IOS)
#include <iostream.h>
#include <fstream.h>
#else
#include <iostream>
#include <fstream>
#endif 
//#include <osfcn.h>
#include <sys/types.h>
//#include <unistd.h>
#include <fcntl.h>
//#include "remove.h"

#include "testhead.h"


static char progname[] = "filbuf_3()";

/**********************************************************************/
/*                                                                    */
/* This test uses a data file that it reads and copies. The name of   */
/* the file is stored in the datfile variable.                        */
/*                                                                    */
/**********************************************************************/

static char filenamebuf[L_tmpnam];

static const char * datfile = tmpnam(filenamebuf);

/**********************************************************************/
/*                                                                    */
/* Default permissions for newly-created files.                       */
/*                                                                    */
/**********************************************************************/

const int PERM = 0644;

/*--------------------------------------------------------------------*/
filbuf_3_main()                  
{
    setup();

/*--------------------------------------------------------------------*/
block0: blenter();          

#if defined(USING_OLD_IOS)

    DbgPrint("REF: AT&T Library Manual Appendix A-4, Stream\n");
    DbgPrint("I/O Library, testing the filebuf class derived\n");
    DbgPrint("from streambuf. When the filebuf is created with\n");
    DbgPrint("a buffer length of zero I/O is unbuffered.\n");

    // Create data file.
    int fd;
    extern int errno;
    if ((fd = open(datfile,O_RDWR|O_CREAT,PERM)) == -1) {
        failure("Cannot open/create data file.");
        DbgPrint("Errno is %d\n", errno);
    }
    else {
        char    write_c = 'X';
        char    read_c;
        char    dummy_c;
        filebuf fb1(fd,&dummy_c,0); // create the filebuf, unbuffered
        if (!fb1.is_open())
        failure("Cannot attach filebuf to file descriptor.");
        else {
        // Write one byte to the file. Should not be buffered.
        fb1.sputc(write_c);
        // Read it back through the file descriptor
        if (lseek(fd,0,SEEK_SET) == -1) {
            failure("Cannot lseek on file descriptor.");
            DbgPrint("Errno is %d\n", errno);
        }
        else 
            if (read(fd, &read_c, 1) != 1)
            failure("Cannot read back written data.");
            else 
            if (read_c != write_c)
                failure("Read back wrong character.");
        }
    }
#endif
    blexit();
/*--------------------------------------------------------------------*/
block1: blenter();

#if defined(USING_OLD_IOS)

    DbgPrint("REF: AT&T Library Manual Appendix A-4, Stream\n");
    DbgPrint("I/O Library, testing the filebuf class derived\n");
    DbgPrint("from streambuf. When the filebuf is given a buffer\n");
    DbgPrint("with a setbuf(p,len) call, if p is NULL the filebuf\n");
    DbgPrint("is unbuffered.\n");

    // Create data file.  
    if ((fd = open(datfile,O_RDWR|O_CREAT,PERM)) == -1) {
        failure("Cannot open data file.");
        DbgPrint("Errno is %d\n", errno);
    }
    else {
        char    write_c = 'X', read_c;
        filebuf fb1(fd);
        if (!fb1.is_open())
        failure("Cannot attach filebuf to file descriptor.");
        else if (fb1.setbuf(NULL,1) == 0)
        failure("setbuf(NULL,len) call refused.");
        else {
        // Write one byte to the file. Should not be buffered.
        fb1.sputc(write_c);
        // Read it back through the file descriptor
        if (lseek(fd,0,SEEK_SET) == -1) {
            failure("Cannot lseek on file descriptor.");
            DbgPrint("Errno is %d\n", errno);
        }
        else 
            if (read(fd, &read_c, 1) != 1)
            failure("Cannot read back written data.");
            else 
            if (read_c != write_c)
                failure("Read back wrong character.");
        }
    }

#endif 

    blexit();
/*--------------------------------------------------------------------*/
block2: blenter();

#if defined(USING_OLD_IOS)

    DbgPrint("REF: AT&T Library Manual Appendix A-4, Stream\n");
    DbgPrint("I/O Library, testing the filebuf class derived\n");
    DbgPrint("from streambuf. When the filebuf is given a buffer\n");
    DbgPrint("with a setbuf(p,len) call, if len is 0 the filebuf\n");
    DbgPrint("is unbuffered.\n");

    // Create data file.  
    if ((fd = open(datfile,O_RDWR|O_CREAT,PERM)) == -1) {
        failure("Cannot open data file.");
        DbgPrint("Errno is %d\n", errno);
    }
    else {
        char    write_c = 'X', read_c, dummy_c;
        filebuf fb1(fd);
        if (!fb1.is_open())
        failure("Cannot attach filebuf to file descriptor.");
        else if (fb1.setbuf(&dummy_c,0) == 0)
        failure("setbuf(&c,0) call refused.");
        else {
        // Write one byte to the file. Should not be buffered.
        fb1.sputc(write_c);
        // Read it back through the file descriptor
        if (lseek(fd,0,SEEK_SET) == -1) {
            failure("Cannot lseek on file descriptor.");
            DbgPrint("Errno is %d\n", errno);
        }
        else 
            if (read(fd, &read_c, 1) != 1)
            failure("Cannot read back written data.");
            else 
            if (read_c != write_c)
                failure("Read back wrong character.");
        }
    }

#endif 

    blexit();
/*--------------------------------------------------------------------*/
block3: blenter();

#if defined(USING_OLD_IOS)

    DbgPrint("REF: AT&T Library Manual Appendix A-4, Stream\n");
    DbgPrint("I/O Library, testing the filebuf class derived\n");
    DbgPrint("from streambuf. When the filebuf is given a buffer\n");
    DbgPrint("with a setbuf(p,len) call, if len is negative the\n");
    DbgPrint("filebuf is unbuffered.\n");

    // Create data file.  
    if ((fd = open(datfile,O_RDWR|O_CREAT,PERM)) == -1) {
        failure("Cannot open data file.");
        DbgPrint("Errno is %d\n", errno);
    }
    else {
        char    write_c = 'X', read_c, dummy_c;
        filebuf fb1(fd);
        if (!fb1.is_open())
        failure("Cannot attach filebuf to file descriptor.");
        else if (fb1.setbuf(&dummy_c,-3) == 0)
        failure("setbuf(&c,-3) call refused.");
        else {
        // Write one byte to the file. Should not be buffered.
        fb1.sputc(write_c);
        // Read it back through the file descriptor
        if (lseek(fd,0,SEEK_SET) == -1) {
            failure("Cannot lseek on file descriptor.");
            DbgPrint("Errno is %d\n", errno);
        }
        else 
            if (read(fd, &read_c, 1) != 1)
            failure("Cannot read back written data.");
            else 
            if (read_c != write_c)
                failure("Read back wrong character.");
        }
    }

#endif 

    blexit();
/*--------------------------------------------------------------------*/
    remove(datfile);
    anyfail();  
    return 0;
}                   

#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\format4.c ===
/* @(#)File: format4.C      Version: 1.1        Date:01/05/91   */
/* CVS-CC, C++ Validation Suite                     */
/* Copyright 1989, Perennial, All Rights Reserved           */
/*========================================================================
        =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Manual, Appendix A, IOS(3C++)        >
    < in AT&T C++ Language System 2.0, May 89.  Select Code 307-145 >

>WHAT:  < This file tests the effects of some output related bits in    >
    < the format control word.  These effects are observed on   >
    < values inserted into a strstreambuf.              >

    < The bit tested here is showpoint.             >

>HOW:   < The method used is to insert some value into an output    >
    < strstreambuf and check that the value that was written to     >
    < the buffer has the proper format.             >

    < If showpoint is set, trailing zeroes and decimal points   >
    < appear in the result of a floating point conversion.      >

    < 0. Set showpoint and check trailing zeroes appear in the  >
    <    scientific notation.                   >

    < 1. Set showpoint and check trailing zeroes appear in the  >
    <    decimal notation.                      >

    < If showpoint is not set, the trailing zeroes are removed from >
    < the result and a decimal point only appear if it is followed  >
    < by a digit.                           >

    < 2. Unset showpoint and check trailing zeroes do not appear    >
    <    in the scientific notation.                >

    < 3. Unset showpoint and check trailing zeroes do not appear    >
    <    in the scientific notation.                >

>MODS:  < Version 1.0 created by HK on 3/4/90.              >
    < 1.1 - 01/02/91: RFG - Substantial corrections and refinements.

>BUGS:  < None known.

========================================================================*/
#include "testhead.h"     

static char progname[] = "format4()";         

inline void print(char str[]) { DbgPrint( "%s\n", str); }
static void fail (char str[]) {
    local_flag =FAILED;
    DbgPrint( "\tFAILURE: %s\n", str);
    }

/*--------------------------------------------------------------------*/
#if defined(USING_OLD_IOS)
#include <iostream.h>
#else
#include <iostream>
#include <strstream>
#endif

// global variable declarations

/*--------------------------------------------------------------------*/
format4_main()                                  /***** BEGINNING OF MAIN. *****/
{

        setup();
/*--------------------------------------------------------------------*/
block0: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test that showpoint flag set causes display of trailing ");
    print("zeroes in scientific notation");

    {static char buf[20] = "                   ";
    ostrstream s(buf, 18);  // create a stream
    s.setf(ios::showpoint);

    s << '{';
    s << 0.0000101;
    s << '}';

#undef EXPECT
#define EXPECT "{1.01000e-005}"

    if (strncmp(buf, EXPECT, strlen (EXPECT)))
        {DbgPrint( "expected = \"%s\", got = \"%s\"\n",
            EXPECT, buf);
        fail ("unexpected result");
        }
    }

        blexit();
/*--------------------------------------------------------------------*/
block1: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test that showpoint flag set causes display of trailing zeroes");
    print("in decimal notation");

    {static char buf[20] = "                   ";
    ostrstream s(buf, 18);  // create a stream
    s.setf(ios::showpoint);

    s << '{';
    s << 3.3;
    s << '}';

#undef EXPECT
#define EXPECT "{3.30000}"

    if (strncmp(buf, EXPECT, strlen (EXPECT)))
        {DbgPrint( "expected = \"%s\", got = \"%s\"\n",
            EXPECT, buf);
        fail ("unexpected result");
        }
    }

        blexit();
/*--------------------------------------------------------------------*/
block2: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Check that when showpoint is unset, trailing zeroes and");
    print("decimal points do not appear in the scientific notation");

    {static char buf[20] = "                   ";
    ostrstream s(buf, 18);  // create a stream
    s.unsetf(ios::showpoint);

    s << '{';
    s << 800000000.0;
    s << '}';

#undef EXPECT
#define EXPECT "{8e+008}"

    if (strncmp(buf, EXPECT, strlen (EXPECT)))
        {DbgPrint( "expected = \"%s\", got = \"%s\"\n",
            EXPECT, buf);
        fail ("unexpected result");
        }
    }

        blexit();
/*--------------------------------------------------------------------*/
block3: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Check that when showpoint is unset, trailing zeroes and");
    print("decimal points do not appear in the decimal notation");

    {static char buf[20] = "                   ";
    ostrstream s(buf, 18);  // create a stream
    s.unsetf(ios::showpoint);

    s << '{';
    s << 9.9e3;
    s << '}';

#undef EXPECT
#define EXPECT "{9900}"

    if (strncmp(buf, EXPECT, strlen (EXPECT)))
        {DbgPrint( "expected = \"%s\", got = \"%s\"\n",
            EXPECT, buf);
        fail ("unexpected result");
        }
    }

        blexit();
/*--------------------------------------------------------------------*/
    anyfail();
    return 0;
}

#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\format5.c ===
/* @(#)File: format5.C      Version: 1.0        Date:09/27/90   */
/* CVS-CC, C++ Validation Suite                     */
/* Copyright 1989, Perennial, All Rights Reserved           */
/*========================================================================
        =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Manual, Appendix A, IOS(3C++)        >
    < in AT&T C++ Language System 2.0, May 89.  Select Code 307-145 >

>WHAT:  < This file tests the effects of some output related bits in    >
    < the format control word.  These effects are observed on   >
    < values inserted into a strstreambuf.              >

    < The bits tested here are dec, oct, hex, showbase.     >

>HOW:   < The method used is to insert some value into an output    >
    < strstreambuf and check that the value that was written to     >
    < the buffer has the proper format.             >

    < If showbase is set, insertions are converted to an external   >
    < form that can be read according to the C++ lexical        >
    < conventions for integral constants. In blocks 0 thru 2,   >
    < showbase is set.                      >

    < 0. Set the base field to dec.  Write a positive integer.      >
    <    Check it comes out in the decimal base.            >

    < 1. Set the base field to oct.  Write a positive integer.      >
    <    Check it comes out in octal form preceded by a 0.      >

    < 2. Set the base field to hex.  Write a positive integer.      >
    <    Check it comes out in hexadecimal preceded by 0x.      >

    < In blocks 3 and 4, showbase is unset.             >

    < 3. Set the base field to oct.  Write a positive integer.      >
    <    Check it comes out in octal form unpreceded by a 0.    >

    < 4. Set the base field to hex.  Write a positive integer.      >
    <    Check it comes out in hexadecimal unpreceded by 0x.    >

    < In block 5, showbase is left to the default value.        >

    < 5. Check the default value of showbase is unset.      >

>MODS:  < Version 1.0 created by HK on 3/4/90.              >

>BUGS:  < None known.                           >
========================================================================*/
#include "testhead.h"     

static char progname[] = "format5()";         

inline void print(char str[]) { DbgPrint( "%s\n", str); }
static void fail (char str[]) {
    local_flag =FAILED;
    DbgPrint( "\tFAILURE: %s\n", str);
    }

/*--------------------------------------------------------------------*/
#if defined(USING_OLD_IOS)
#include <iostream.h>
#else
#include <iostream>
#include <strstream>
#endif

// global variable declarations

/*--------------------------------------------------------------------*/
format5_main()                                  /***** BEGINNING OF MAIN. *****/
{

        setup();
/*--------------------------------------------------------------------*/
block0: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test showbase flag with decimal output");

    {char buf[10];
    memset(buf, 0, 10);
    ostrstream s(buf, 8);   // create a stream
    s.setf(ios::showbase);  // set the flag
    s.setf(ios::dec, ios::basefield);   //set to base 10

    s << 9;                 // write to stream
    if (strncmp(buf, "9", 2))
    {
        fail ("unexpected result");
        DbgPrint("%s != 9\n", buf);
    }
    }

        blexit();
/*--------------------------------------------------------------------*/
block1: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test showbase flag with oct output");

    {char buf[10];
    memset(buf, 0, 10);
    ostrstream s(buf, 8);   // create a stream
    s.setf(ios::showbase);  // set the flag
    s.setf(ios::oct, ios::basefield);   //set to base 8

    s << 9;         // write to stream
    if (strncmp(buf, "011", 3))
        fail ("unexpected result");
    }

        blexit();
/*--------------------------------------------------------------------*/
block2: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test showbase flag with hex output");

    {char buf[10];
    memset(buf, 0, 10);
    ostrstream s(buf, 8);   // create a stream
    s.setf(ios::showbase);  // set the flag
    s.setf(ios::hex, ios::basefield);   //set to base 16

    s << 16;            // write to stream
    if (strncmp(buf, "0x10", 4))
        fail ("unexpected result");
    }

        blexit();
/*--------------------------------------------------------------------*/
block3: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test showbase unset with oct output");

    {char buf[10];
    memset(buf, 0, 10);
    ostrstream s(buf, 8);   // create a stream
    s.unsetf(ios::showbase);    // unset the flag
    s.setf(ios::oct, ios::basefield);   //set to base 8

    s << 9;         // write to stream
    if (strncmp(buf, "11", 2))
        fail ("unexpected result");
    }

        blexit();
/*--------------------------------------------------------------------*/
block4: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test showbase unset with a hex output");

    {char buf[10];
    memset(buf, 0, 10);
    ostrstream s(buf, 8);   // create a stream
    s.unsetf(ios::showbase);    // unset the flag
    s.setf(ios::hex, ios::basefield);   //set to base 16

    s << 16;            // write to stream
    if (strncmp(buf, "10", 4))
        fail ("unexpected result");
    }

        blexit();
/*--------------------------------------------------------------------*/
block5: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test default value of showbase is unset");

    {char buf[10];
    memset(buf, 0, 10);
    ostrstream s(buf, 8);   // create a stream

    if (s.flags() & ios::showbase)
        fail ("showbase is set by default");
    }

        blexit();
/*--------------------------------------------------------------------*/
    anyfail();
    return 0;
}

#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\format7.c ===
/* @(#)File: format7.C      Version: 1.0        Date:11/08/90   */
/* CVS-CC, C++ Validation Suite                     */
/* Copyright 1989, Perennial, All Rights Reserved           */
/*========================================================================
        =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Manual, Appendix A, IOS(3C++)        >
    < in AT&T C++ Language System 2.0, May 89.  Select Code 307-145 >

>WHAT:  < This file tests the effects of some input related bits in >
    < the format control word.  These effects are observed on   >
    < values extracted from a strstreambuf.             >

    < The bit tested here is skipws.                >

>HOW:   < 0. Set skipws.  Place an integer by whitespace in the buffer. >
    <    Check the whitespace is skipped by extracting the integer. >

    < 1. Unset skipws and extract whitespace.                       >

    < 2. Unset skipws and try to extract a number.                  >

>MODS:  < 11/8/90, DRE: Added 2.1 bugs comment and fixed HOW comments.  >
    < Version 1.0 created by HK on 3/4/90.              >

>BUGS:  < None known for cfront 2.0.                                    >
    < Cfront 2.1 fails block 1.                                     >
========================================================================*/
#include "testhead.h"     

static char progname[] = "format7()";         

inline void print(char str[]) { DbgPrint( "%s\n", str); }
static void fail (char str[]) {
    local_flag =FAILED;
    DbgPrint( "\tFAILURE: %s\n", str);
    }

/*--------------------------------------------------------------------*/
#if defined(USING_OLD_IOS)
#include <iostream.h>
#include <strstrea.h>
#else
#include <iostream>
#include <strstream>
#endif

// global variable declarations
static int i;
static char c;
/*--------------------------------------------------------------------*/
void format7_main()                                  /***** BEGINNING OF MAIN. *****/
{

        setup();
/*--------------------------------------------------------------------*/
block0: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test skipws flag causes whitespace to be skipped");

    {static char buf[10] = "  \t a";
    istrstream s(buf, 8);   // create a stream
    s.setf(ios::skipws);

    s >> c;
    if (c != 'a')
        fail ("unexpected result");
    }

        blexit();
/*--------------------------------------------------------------------*/
block1: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test skipws unset causes whitespace to be extracted");

    {static char buf[10] = " \ta";
    istrstream s(buf, 8);   // create a stream
    s.unsetf(ios::skipws);

    s >> c;
    if (c != ' ') {
        fail ("unexpected result");
        DbgPrint( "Got `%c'(%d), expected `%c'(%d)\n", 
            c, c, ' ', ' ');
    }
    }

        blexit();
/*--------------------------------------------------------------------*/
block2: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test that when skipws is not set, if a whitespace is");
    print("encountered by a numeric extractor, an error results");

    {static char buf[10] = "  \t 10";
    istrstream s(buf, 8);   // create a stream
    s.unsetf(ios::skipws);

    s >> i;
    if (s.good())
        fail ("no error signalled");
    }

        blexit();
/*--------------------------------------------------------------------*/
    anyfail();
}

#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\format6.c ===
/* @(#)File: format6.C      Version: 1.0        Date:09/27/90   */
/* CVS-CC, C++ Validation Suite                     */
/* Copyright 1989, Perennial, All Rights Reserved           */
/*========================================================================
        =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Manual, Appendix A, IOS(3C++)        >
    < in AT&T C++ Language System 2.0, May 89.  Select Code 307-145 >

>WHAT:  < This file tests the effects of some input related bits in >
    < the format control word.  These effects are observed on   >
    < values extracted from a strstreambuf.             >

    < The bits tested here are dec, oct, and hex.           >

>HOW:   < In blocks 0 thru 2, the method used is to extract a value     >
    < from an input strstreambuf and check that the value was   >
    < properly converted from the specified base.           >

    < 0. Set the base field to dec.  Extract a positive integer.    >
    <    Check it was left in base 10.              >

    < 1. Set the base field to oct.  Extract a positive integer.    >
    <    Check it was converted from base 8 to base 10.     >

    < 2. Set the base field to hex.  Extract a positive integer.    >
    <    Check it was converted from base 16 to base 10.        >

    < Blocks 3 and 4 Check the conversion mechanism when all the    >
    < base flags are unset.                     >

    < 3. Unset all the base flags.  Extract a decimal integer.  >
    <    Check it is left in decimal.               >

    < 4. Unset all the base flags.  Extract an octal integer.   >
    <    Check it is converted to decimal.              >

    < 5. Unset all the base flags.  Extract hex integer.        >
    <    Check it is converted to decimal.              >

>MODS:  < Version 1.0 created by HK on 3/4/90.              >

>BUGS:  < None known.                           >
========================================================================*/
#include "testhead.h"     

static char progname[] = "format6()";         

inline void print(char str[]) { DbgPrint( "%s\n", str); }
static void fail (char str[]) {
    local_flag =FAILED;
    DbgPrint( "\tFAILURE: %s\n", str);
    }

/*--------------------------------------------------------------------*/
#if defined(USING_OLD_IOS)
#include <iostream.h>
#include <strstrea.h>
#else
#include <iostream>
#include <strstream>
#endif

// global variable declarations
static int i;
/*--------------------------------------------------------------------*/
void format6_main()                                  /***** BEGINNING OF MAIN. *****/
{

        setup();
/*--------------------------------------------------------------------*/
block0: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test extraction with decimal conversion");

    {static char buf[10] = "10";
    istrstream s(buf, 8);   // create a stream
    s.setf(ios::dec, ios::basefield);   //set to base 10

    s >> i;
    if (i != 10)
        fail ("unexpected result");
    }

        blexit();
/*--------------------------------------------------------------------*/
block1: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test extraction with oct conversion");

    {static char buf[10] = "10";
    istrstream s(buf, 8);   // create a stream
    s.setf(ios::oct, ios::basefield);   //set to base 8

    s >> i;
    if (i != 010)
        fail ("unexpected result");
    }

        blexit();
/*--------------------------------------------------------------------*/
block2: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test extraction with hex conversion");

    {static char buf[10] = "10";
    istrstream s(buf, 8);   // create a stream
    s.setf(ios::hex, ios::basefield);   //set to base 16

    s >> i;
    if (i != 0x10)
        fail ("unexpected result");
    }

        blexit();
/*--------------------------------------------------------------------*/
block3: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test decimal extraction when base flags are unset");

    {static char buf[10] = "10";
    istrstream s(buf, 8);   // create a stream
    s.unsetf(ios::basefield);   // unset the flag
    
    s >> i;
    if (i != 10)
        fail ("unexpected result");
    }

        blexit();
/*--------------------------------------------------------------------*/
block4: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test octal extraction when base flags are unset");

    {static char buf[10] = "010";
    istrstream s(buf, 8);   // create a stream
    s.unsetf(ios::basefield);   // unset the flag
    
    s >> i;
    if (i != 010)
        fail ("unexpected result");
    }

        blexit();
/*--------------------------------------------------------------------*/
block5: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test hexadecimal extraction when base flags are unset");

    {static char buf[10] = "0x10";
    istrstream s(buf, 8);   // create a stream
    s.unsetf(ios::basefield);   // unset the flag
    
    s >> i;
    if (i != 0x10)
        fail ("unexpected result");
    }

        blexit();
/*--------------------------------------------------------------------*/
    anyfail();
}

#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\fstream1.c ===
/* @(#)File: fstream_1.C    Version: 1.0    Date: 09/27/90            */
/* CVS-CC, C++ Validation Suite                                       */
/* Copyright 1989, Perennial, All Rights Reserved                     */
/*======================================================================
  =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Manual Select Code 307-145
  < Appendix A-4, Stream I/O Library Manual Pages,

>WHAT:  < FSTREAM(3C++) Manual page dated 14 June 1989
  < This stream class is for use in performing file I/O.
  < They use the filebuf class.
  <
  < Test the file modes
  <
  < 0. test mode ate of ifstream (at-end). Reads should return EOF.
  < 1. test mode ate of ofstream
  < 2. test mode app of ofstream
  < 3. test mode trunc of ofstream
  < 4. test mode noreplace of ofstream
  < 5. test mode nocreate of ofstream
  <

>HOW:   < 0.  Open an ifstream with mode ios::in | ios::ate.
  <     This should position the file pointer at the end of the
  <     file. According to the description of the ios::ate bit
  <     on the fstream(3C++) man page ios::ate does not imply
  <     ios::out, so this should be valid. Thus a read should
  <     return EOF immediately.
  < 1.  ofstream ate: copy the data file to the output file to
  <     give it known contents. Then close and reopen the file
  <     with mode at-end. Write a line to the file. Verify that
  <     the data was appended.
  < 2.  ofstream app: same as block 1
  < 3.  ofstream trunc: give the file known contents. Then
  <     open for trunc. Then close and verify the file is
  <     empty.
  < 4.  ofstream noreplace: give the file known contents. Then
  <     open with this mode. The open should fail.
  < 5.  ofstream nocreate: Remove the output file. Then try
  <     and open it for nocreate. That should fail.
  <

>MODS:  < 07/02/90, DRE: Changed definition of failure() to a prototype.
  <    Included "testhead.h" instead of "testhead.h"
  < Vers 1.0, date: 3/5/90: Created DRE

>BUGS:  < This test is dependent on the ANSI C libraries because it
  < uses the tmpnam() and remove() file routines.
  <
  < Block 0 is failed. Apparently the file pointer is not being
  < positioned at the end of the file, but rather the beginning.
  < Putting a unique character at the first position of the file
  < shows that that is the character being read.
  <
======================================================================*/

#if defined(USING_OLD_IOS)
#include <iostream.h>
#include <fstream.h>
#else
#include <iostream>
#include <fstream>
#endif
#include <fcntl.h>
#include <stdio.h>
//#include <osfcn.h>
//#include "remove.h"

#include "testhead.h"


static char progname[] = "fstream1()";

    // Copy known data into the data file

static int create_datafile(const char * filename);

    // Check that the file contains the expected data followed
    // by the append string

int verify_append(const char * filename);

    // Copy a src file to a dest to give the dest known contents

void copy(const char * dest, const char * src);

    // String to append to a file to test the append mode

extern const char * append_string;

/**********************************************************************/
/*                                                                    */
/* This test uses a data file that it reads and copies. The name of   */
/* the file is stored in the datfile variable. It also writes an      */
/* output file for testing file output.                               */
/*                                                                    */
/**********************************************************************/

static char namebuf1[L_tmpnam], namebuf2[L_tmpnam];

static const char * datfile = tmpnam(namebuf1);
static const char * outfile = tmpnam(namebuf2);

/*--------------------------------------------------------------------*/
void fstream1_main()          
{
  setup();

/*--------------------------------------------------------------------*/
block0: blenter();      

  DbgPrint("Creating data file used by this test.\n");
  // Create the data file that the rest of this test uses.
  if (create_datafile(datfile) == 0) {
    failure("Cannot create data file: can't run test.");
    goto done;
  }

  DbgPrint("%s%s%s",
    "REF: AT&T Library Manual Appendix A-4, Stream\n",
    "I/O Library, testing the fstream classes.\n",
    "Test opening an ifstream at-end (``ate'' mode).\n");
  
  {
#if defined(USING_OLD_IOS)
      ifstream ifs0(datfile,ios::ate|ios::in);
#else
      ifstream ifs0(datfile,ios::app|ios::ate|ios::in|ios::out);
#endif
      if (!ifs0.good())
    failure("Can't open ifstream with mode ate (at-end)");
      else {
    char c;
    ifs0 >> c;
    // That should have failed because we're at the end
    if (!ifs0.eof()) {
        failure("Should be at end of file but EOF not true.");
        DbgPrint( "Read char with val %d\n", int(c));
    }
    ifs0.close();
      }
  }

  blexit();
/*--------------------------------------------------------------------*/
block1: blenter();      

  DbgPrint("%s%s%s",
    "REF: AT&T Library Manual Appendix A-4, Stream\n",
    "I/O Library, testing the fstream classes.\n",
    "Test of ofstream mode ``ios::ate'' (at-end).\n");
  
  {
      // Give output file known contents
      copy(outfile,datfile);

#if defined(USING_OLD_IOS)
      ofstream ofs1(outfile,ios::out|ios::ate);
#else
      ofstream ofs1(outfile,ios::out|ios::app);
#endif
      if (!ofs1.good())
    failure("Can't open output fstream with more append.");
      else {

    // Append another string.
    ofs1 << append_string << "\n";
    ofs1.close();

    if (verify_append(outfile) == 0)
        failure("Output file for at-end didn't append data");
      }
  }

  blexit();
/*--------------------------------------------------------------------*/
block2: blenter();      

  DbgPrint("%s%s%s",
    "REF: AT&T Library Manual Appendix A-4, Stream\n",
    "I/O Library, testing the fstream classes.\n",
    "Test of ofstream mode ``ios::app'' (append).\n");
  
  {
      // Give output file known contents
      copy(outfile,datfile);

      // Open it with at-end mode
      ofstream ofs2(outfile,ios::app|ios::out);

      if (!ofs2.good())
    failure("Can't open output fstream with more append.");
      else {

    // Append another string.
    ofs2 << append_string << "\n";
    ofs2.close();

    if (verify_append(outfile) == 0)
        failure("Output file for append didn't append data");
      }
  }

  blexit();
/*--------------------------------------------------------------------*/
block3: blenter();      

  DbgPrint("%s%s%s",
    "REF: AT&T Library Manual Appendix A-4, Stream\n",
    "I/O Library, testing the fstream classes.\n",
    "Test of ofstream mode ``ios::trunc.''\n");
  
  {
      copy(outfile,datfile);
      ofstream ofs3(outfile,ios::trunc|ios::out);
      if (!ofs3.good())
    failure("Can't open ofstream for trunc.");
      else {

    ofs3.close();
    // verify the file is empty
    ifstream ifs(outfile,ios::in);
    char c;
    ifs >> c;
    if (!ifs.eof()) {
        failure("After open for trunc file not empty.");
        DbgPrint( "Read char with value %d\n", int(c));
    }
      }
  }

  blexit();
/*--------------------------------------------------------------------*/
block4: blenter();      

  DbgPrint("%s%s%s",
    "REF: AT&T Library Manual Appendix A-4, Stream\n",
    "I/O Library, testing the fstream classes.\n",
    "Test of ofstream mode ``ios::noreplace.''\n");
  
  {
#if defined(USING_OLD_IOS)
      copy(outfile,datfile);
      ofstream ofs4(outfile,ios::noreplace|ios::out);

      if (ofs4.good()) {
    failure("Successfully opened existing file for noreplace.");
    ofs4.close();
      }
#endif
  }

  blexit();
/*--------------------------------------------------------------------*/
block5: blenter();      

  DbgPrint("%s%s%s",
      "REF: AT&T Library Manual Appendix A-4, Stream\n",
      "I/O Library, testing the fstream classes.\n",
      "Test of ofstream mode ``ios::nocreate.''\n");
  
  {
      // Make sure the file doesn't exist.
      remove(outfile);
      // Now try not to create it.
#if defined(USING_OLD_IOS)
      ofstream ofs5(outfile, ios::out|ios::nocreate);
#else
      ofstream ofs5(outfile, ios::out|ios::in);
#endif
      if (ofs5.good())
    failure("Incorrectly opened file for nocreate.");
  }

  blexit();
/*--------------------------------------------------------------------*/
  remove(outfile);
  remove(datfile);
done:
  anyfail();  

}         


/**********************************************************************/
/*                                                                    */
/* This is the data the test expects to find in its input file.       */
/*                                                                    */
/**********************************************************************/

static const char * expected_data[] = {
  "aaaaaaaaaa",
  "bbbbbbbbbb",
  "0123456789",
  0
};

static const char * append_string = "append_me";

/**********************************************************************/
/*                                                                    */
/* copy                                                               */
/*                                                                    */
/* This routine copies one file to another. This is used to give a    */
/* file known contents.                                               */
/*                                                                    */
/**********************************************************************/

void copy(const char * dest, const char * src)
{
  ifstream ifs(src, ios::in);
#if defined(USING_OLD_IOS)
  ofstream ofs(dest, ios::out);
#else
  ofstream ofs(dest, ios::out|ios::trunc);
#endif

  const int bufsize = 256;
  char buf[bufsize];

  ifs.width(bufsize);

  while(ofs) {
    ifs >> buf;
    if (ifs.eof())
      break;
    ofs << buf << "\n";
  }
}

/**********************************************************************/
/*                                                                    */
/* verify_append                                                      */
/*                                                                    */
/* This routine reads the input file and verifies it contains the     */
/* expected data followed by the append string.                       */
/*                                                                    */
/* Return:                                                            */
/*                                                                    */
/*    1   correct data                                                */
/*    0   incorrect data                                              */
/*                                                                    */
/* Side-effect:                                                       */
/*                                                                    */
/*    The current file read/write position is undefined after this    */
/*    routine.                                                        */
/*                                                                    */
/**********************************************************************/

int verify_append(const char * filename)
{
  ifstream ifs(filename, ios::in);

  const char ** expect = expected_data;
  const int bufsize = 128;
  char buf[bufsize];

  while (*expect) {
    ifs >> buf;
    if (strcmp(buf, *expect)) {
      DbgPrint( "Read '%s', expected '%s'\n",
    