 // The column cannot be found. [,,,Column name,Table name,]
#define SSCE_M_NAMESBUFFERTOOSMALL                  29504       // Internal error: The names buffer is too small. [,,,,,]
// DEAD SSCE_M_INCORRECTNUMBEROFCOLUMNSPROCESSED    29505       // Incorrect number of columns processed. [columns processed,expected number,,,,]
#define SSCE_M_UNEXPECTEDSTATEGETTINGCOLUMNS        29506       // Internal error: Failure getting column information. Retry the operation. [,,,,,]
#define SSCE_M_UNEXPECTEDSTATEGETCOLLENGTH          29507       // Internal error: Failure getting column length. Retry the operation. [,,,,,]
#define SSCE_M_UNEXPECTEDSTATEGETCOLDATA            29508       // Internal error: Failure getting column data. Retry the operation. [,,,,,]
#define SSCE_M_UNEXPECTEDSTATESETCOLUMN             29509       // Internal error:  Failure setting column data. Retry the operation. [,,,,,]
#define SSCE_M_STREAMNOTEXHAUSTED                   29510       // BLOB data could not be completely read. Retry the operation. [,,,,,]
#define SSCE_M_GARBLEDMESSAGEFROMSERVER             29511       // Internal error: The message received from the server cannot be decoded. [,,,,,]
// DEAD SSCE_M_GARBLEDMESSAGEFROMCLIENT             29512       // The message received from the client cannot be decoded. [,,,,,]
//***** Don't add any more errors here, read the comments below and add appropriately
//
// Errors after this comment were added for v1.1 (PEBBLE) 
//


// --------------------------------------------------------------------------------------
//
// Query Compile        25500 -- 25699
//  
#define SSCE_M_QP_BADOPT                            25500       // Internal error: The execution plan cannot be generated. [,,,,,]
#define SSCE_M_QP_BADPARSE                          25501       // There was an error parsing the query. [Token line number,Token line offset,,Token in error,,]
#define SSCE_M_QP_SETLISTCOUNT                      25502       // The count of column names and source expressions do not match. [Column name count,Source expression count,,,,]
#define SSCE_M_QP_BAD_COLNAME                       25503       // The column name is not valid. [,,,Node name (if any),Column name,]
#define SSCE_M_QP_BADCNSTS                          25505       // The constraint specified is not valid. [,,,,,]
#define SSCE_M_QP_NOMEMORY                          25506       // There is not enough memory to complete the operation. [,,,,,]
#define SSCE_M_QP_UNCLOSEDCOMMENT                   25507       // There is an unclosed comment block in the SQL statement. Ensure that there are balanced '/*' and '*/' comment markers in the SQL statement. [,,,,,]
#define SSCE_M_QP_TOKTOOLONG                        25508       // The token specified is too long. The maximum length is 128 characters. [Maximum size of token (if known),,,Token(if known),,]
#define SSCE_M_QP_ATOF_OVERFLOW                     25509       // A conversion from string to float data failed. [,,,String,,]
#define SSCE_M_QP_NUME_OUTOFRANGE                   25510       // A conversion from string to numeric data failed. [,,,String value,,]
#define SSCE_M_QP_UNCLOSEDQUOTE                     25511       // A quotation mark delimiter is missing from the end of the query. [,,,,,]
#define SSCE_M_QP_BADMONEY                          25512       // Conversion from string to money data failed. [,,,Bad value,,]
#define SSCE_M_QP_IDENTWITHNULL                     25513       // Null values are not valid identifiers. [,,,Identifier,,]
#define SSCE_M_QP_NAME_EMPTY                        25514       // The identifier cannot be an empty string. [,,,,,]
#define SSCE_M_QP_NO_SCALAR_IN_SELECT               25515       // In aggregate and grouping expressions, the SELECT clause can contain only aggregates and grouping expressions. [,,,Select clause,,]
#define SSCE_M_QP_NO_AGG_IN_AGG                     25516       // Nested aggregate expressions are not allowed. [,,,,,]
#define SSCE_M_QP_NO_SCALAR_IN_HAVING               25517       // In aggregate and grouping expressions, the HAVING clause can contain only aggregate functions and grouping expressions. [,,,Having clause,,]
#define SSCE_M_QP_NO_SCALAR_IN_AGGRORDERBY          25518       // In aggregate and grouping expressions, the ORDER BY clause can contain only aggregate functions and grouping expressions. [,,,,,]
#define SSCE_M_QP_NO_AGG_IN_GROUPBY                 25519       // Expressions in the GROUP BY list cannot contain aggregate functions. [,,,,,]
#define SSCE_M_QP_NO_AGG_IN_ORDERBY                 25520       // Expressions in the ORDER BY list cannot contain aggregate functions. [,,,,,]
#define SSCE_M_QP_NO_DUPEXPR_IN_ORDERBY             25521       // The ORDER BY list cannot have duplicate expressions. [,,,Order by list,Duplicate expression,]
#define SSCE_M_QP_DUP_TABLE_ALIAS                   25522       // The table aliases must be unique. [,,,Name of duplicate alias,,]
#define SSCE_M_QP_DUP_COLUMN_ALIAS                  25523       // The column aliases must be unique. [,,,Name of duplicate alias,,]
#define SSCE_M_QP_HAVING_WITHOUT_GROUPBY            25524       // A HAVING clause must have a GROUP BY clause (implicit or explicit). [,,,,,]
#define SSCE_M_QP_NO_AGG_IN_WHERE                   25525       // The WHERE clause cannot refer to aggregate expressions. [,,,,,]
#define SSCE_M_QP_DUP_CNST                          25526       // Duplicate constraints cannot be specified. [,,,,,]
#define SSCE_M_QP_AMBIGUOUS_FUNC                    25527       // A function with the same signature already exists. [,,,Name of function,,]
// DEAD SSCE_M_QP_CANT_COCREATE                     25529       // The OLE DB provider cannot be instantiated. [,,,,,]
#define SSCE_M_QP_SETLIST_DUPCOLNAME                25530       // A column with the same name has already been specified. [,,,Name of duplicate column,,]
#define SSCE_M_QP_AMBIGUOUS_COLNAME                 25531       // The column name cannot be resolved to a table. Specify the table to which the column belongs. [,,,Name of ambiguous column,,]
#define SSCE_M_QP_BAD_FLOAT_PRECISION               25532       // The float precision is not valid. [,,,,,]
#define SSCE_M_QP_LONGIDNAME                        25533       // The identifier/column name is too long. The maximum length is 128 characters. [,,,Name of column(if known),,]
#define SSCE_M_QP_LOB_IN_ORDERBY                    25534       // Large objects (ntext and image) cannot be used in ORDER BY clauses. [,,,,,]
#define SSCE_M_QP_INVALIDMETA_FOR_LOB               25536       // Length, precision or scale cannot be specified for NTEXT or IMAGE data types. Remove these attributes from the IMAGE or NTEXT data types in the DLL statement. [,,,,,]
#define SSCE_M_QP_SUBQUERY_COLUMN_MISMATCH          25537       // The columns in the subquery do not match. [Column ordinal,,,Column name,,]
#define SSCE_M_QP_ENCRYPTION_NO_DBPASSWORD          25538       // The database is encrypted. A password must be specified. [,,,,,]
#define SSCE_M_QP_BADLIKEESCCHAR                    25539       // The escape character for the LIKE predicate is not valid. [,,,Escape character,,]
#define SSCE_M_QP_BADDATEOPTION                     25540       // The datepart is not valid. [,,,Portion of data in error,,]
#define SSCE_M_QP_INVALID_IDENTIFIER                25541       // The identifier is not valid. [,,,Identifier,,]
#define SSCE_M_QP_READONLYINSERT                    25542       // Data cannot be added to a system table or a schema information view. [,,,Name of read-only table,,]
#define SSCE_M_QP_READONLYUPDATE                    25543       // Data cannot be updated in a system table or a schema information view. [,,,Name of read-only table,,]
#define SSCE_M_QP_READONLYDELETE                    25544       // Data cannot be deleted from a system table or a schema information view. [,,,Name of read-only table,,]
#define SSCE_M_QP_NOINSERTCOLUMNS                   25545       // A value must be provided for the INSERT statement into <table_name>. [,,,Table name,,]
#define SSCE_M_QP_MODIFYPROTECTEDCOL                25546       // The column cannot be modified because it is an identity, rowversion or a system column. [,,,Column name,,]
#define SSCE_M_QP_SCALARORDERBYNOTSUPPORTED         25547       // ORDER BY <column number> not supported. [,,,,,]
#define SSCE_M_QP_LOB_IN_DISTINCT                   25548       // DISTINCT cannot be used with  ntext and image data. [,,,,,]
#define SSCE_M_QP_LOB_IN_GROUPBY                    25549       // GROUP BY cannot be used with ntext and image data. [,,,,,]
#define SSCE_M_QP_MULTI_IDENTITY_COLUMNS            25550       // Too many identity columns are specified for the table. Only one identity column for each table is allowed. [,,,,,]
#define SSCE_M_QP_BAD_IDENTITY_TYPE                 25551       // The identity column must be either an integer or big integer data type and cannot be NULL. [,,,,,]
#define SSCE_M_QP_GROUPBY_MUST_REFERENCE_COLS       25552       // Elements in the GROUP BY clause must reference columns in the select list. [,,,,,]
#define SSCE_M_QP_CASCADEONSELFREFFK                25553       // A foreign key constraint that has an UPDATE or a DELETE CASCADE rule, and self-references a column in the same table, is not allowed. [,,,Constraint name,,]
#define SSCE_M_QP_NODEFAULTONIDENTITYCOL            25554       // Defaults cannot be created on identity columns. [,,,Name of table,Name of column,,]
#define SSCE_M_QP_SUBQUERY_NOLOBCOLUMNS             25555       // Subquery columns cannot be ntext or image data types. [,,,,,]
#define SSCE_M_QP_INVALID_CHARACTER_IN_IDENTIFIER   25556       // The number sign (#) is reserved and cannot be used as the first character of an identifier. [,,,Invalid identifier,,]
//***** Don't add any more errors here, read the comments below and add appropriately
//
// Errors after this comment were added for v2.0 
//
#define SSCE_M_UNIONCOLUMNCOUNT                     25557           // Expressions combined by a UNION operator must have the same number of columns. [Number of columns in first UNION expression, Number of columns in other UNION expression,,,,]
#define SSCE_M_DIFFERENTCOLUMNCOUNT                 25558           // The number of columns in the query and the table must match. [Number of columns in query, Number of columns in table,,,,]

// Errors after this comment were added for v3.0 
//
#define SSCE_M_INVALID_INDEX_HINT_ORDINAL           25559           // Invalid index ordinal in index hint specification. [Index ordinal,,,,,]
#define SSCE_M_INVALID_INDEX_HINT_NAME              25560           // Invalid index name in index hint specification. [,,,Index name,,]
#define SSCE_M_INVALID_QUERY_HINT_OPTION            25561           // Invalid query hint specification. [,,,,,]
#define SSCE_M_QP_INVALIDPERCENTSPEC                25562           // Percentage of rows to be sampled should be an integer between 1 and 100. [,,,Table Name,,]
#define SSCE_M_QP_STATS_ALREADY_EXIST               25563           // There are already statistics existing on this index. [,,,Table Name, Index Name,]
#define SSCE_M_QP_STATS_NOT_EXIST                   25565           // Statistics on this index do not exist. [,,,Table Name, Index Name,]
#define SSCE_M_QP_STATS_TABLE_TOO_SMALL             25567           // Table has too few rows to build statistics. [,,,Table Name,,]
#define SSCE_M_QP_INVALID_STATS_OPTION              25568           // Invalid statistics creation option. [,,,Stats option,,]
#define SSCE_M_QP_INVALID_SET_OPTION                25569           // Invalid set option. [,,,Set option,,]
#define SSCE_M_QP_ORDERBY_NOT_IN_SELECT_DISTICT     25571           // ORDER BY items must appear in the select list if SELECT DISTINCT is specified. [,,,,,]
#define SSCE_M_QP_MULTIPLE_SETSHOWPLAN_IN_BATCH     25572           // The SET SHOWPLAN statements must be the only statements in the batch. [,,,,,]
#define SSCE_M_QP_MISMATCHEDPARAMETERTYPE           25573           // Query cannot use both named and unnamed parameters at the same time. [,,,,,]
#define SSCE_M_QP_DUPLICATEPARAMETERNAME            25574           // Duplicated parameter names are not allowed. [,,, Parameter name,,]
#define SSCE_M_QP_ONLY_IN_FROM                      25575           // Index hints are only allowed in a FROM clause. [,,,,,]
#define SSCE_M_QP_BAD_LOCK_HINT                     25576           // Unrecognized LOCK HINTS option. [,,,,,]
#define SSCE_M_QP_ONLY_IN_SELECT                    25577           // The NOLOCK lock hint is only allowed in a SELECT statement. [,,,,,]
#define SSCE_M_QP_CONFL_LOCKING                     25578           // Conflicting locking hints specified. [,,,,,]
#define SSCE_M_QP_BAD_SET_STMT                      25579           // Unrecognized SET statement. [,,,,,]
#define SSCE_M_QP_INVALID_SEEDINCREMENT_VALUE       25580           // Identity seed or increment value is invalid. [,,,,,]
// DEAD SSCE_M_QP_CLR_CRASM_INVALID_EXPR            25581           // Invalid expression for assembly source parameter. CREATE ASSEMBLY failed. [,,,,,]
#define SSCE_M_QP_ALTERTABLE_NONULL                 25582           // Alter table only allows columns to be added which can contain null values. The column cannot be added to the table because it does not allow null values. [,,,,,]
// DEAD SSCE_M_QP_INVALIDROWSPEC                    25583           // Number of rows to be sampled should be larger than 0. [,,,Table Name,,]
#define SSCE_M_QP_COLUMNINUSE                       25584           // The column could not be modified because one or more objects access this column. [,,,Column Name, Object Name (if available),]
#define SSCE_M_QP_QUERY_NOT_KEYSET_NO_TABLE         25585           // Cannot generate a keyset cursor for the query because there is no reference to base table. [Cursor Option,,,,,]
#define SSCE_M_QP_QUERY_NOT_UPDATABLE_DISTINCT      25586           // Cannot generate an updatable cursor for the query because there is a DISTINCT operator. [Cursor Option,,,,,]
#define SSCE_M_QP_CURSOR_NOT_UPDATABLE              25587           // Cursor is not updatable. [,,,,,]
#define SSCE_M_QP_COLUMN_NOT_UPDATABLE              25588           // Column is not updatable. [,,,Name of column,,]
#define SSCE_M_QP_INVALID_LONG_VALUE_COLUMN         25589           // Internal error: This is not a base table long value column. [,,,,,]
#define SSCE_M_QP_INVALID_CURSOR_OPTIONS            25590           // The combination of cursor options is not valid. For instance, updateable and insensitive is an invalid option. [Options specified,,,,,]
#define SSCE_M_QP_INVALID_LONG_VALUE_OBJECT_ID      25591           // Internal error: The storage interface for long value is invalid or unsupported. [,,,,,]
#define SSCE_M_QP_INVALID_SETCOLUMN                 25592           // SetColumn cannot be called during delete operation. [,,,,,]
#define SSCE_M_QP_BOOKMARK_NOT_SUPPORTED            25593           // Bookmark is not supported for this cursor. [,,,,,]
#define SSCE_M_QP_ALTERCOLUMN_LOB_INVALID           25594           // Cannot alter column of type NTEXT or IMAGE [,,,Column Name,,]
#define SSCE_M_QP_QUERY_NOT_KEYSET_DISTINCT         25595           // Cannot generate a keyset cursor for the query because there is a DISTINCT operator. [Cursor Option,,,,,]
#define SSCE_M_QP_QUERY_NOT_KEYSET_GROUPBY          25596           // Cannot generate a keyset cursor for the query because there is an explicit or implicit GROUP BY operator. [Cursor Option,,,,,]
#define SSCE_M_QP_QUERY_NOT_KEYSET_OUTER_JOIN       25597           // Cannot generate a keyset cursor for the query because there is a OUTER JOIN operator. [Cursor Option,,,,,]
// DEAD SSCE_M_QP_QUERY_NOT_KEYSET_SORT             25598           // Cannot generate a keyset cursor for the query because there is a SPOOL/SORT operator. [Cursor Option,,,,,]
#define SSCE_M_QP_QUERY_NOT_KEYSET_UNION            25599           // Cannot generate a keyset cursor for the query because there is a UNION operator. [Cursor Option,,,,,]
#define SSCE_M_QP_QUERY_NOT_UPDATABLE_GROUPBY       25600           // Cannot generate an updatable cursor for the query because there is an explicit or implicit GROUP BY operator. [Cursor Option,,,,,]
#define SSCE_M_QP_QUERY_NOT_UPDATABLE_OUTER_JOIN    25601           // Cannot generate an updatable cursor for the query because there is an OUTER JOIN operator. [Cursor Option,,,,,]
#define SSCE_M_QP_QUERY_NOT_UPDATABLE_SORT          25602           // Cannot generate an updatable cursor for the query because there is a SPOOL/SORT operator. [Cursor Option,,,,,]
#define SSCE_M_QP_QUERY_NOT_UPDATABLE_UNION         25603           // Cannot generate an updatable cursor for the query because there is a UNION operator. [Cursor Option,,,,,]
#define SSCE_M_QP_QUERY_NOT_UPDATABLE_NON_STANDARD_JOIN 25604       // Cannot generate an updatable cursor for the query because there is a non-standard join expression. [Cursor Option,,,,,]
#define SSCE_M_QP_QUERY_NOT_UPDATABLE_JOIN_GRAPH_CYCLE 25605        // Cannot generate an updatable cursor for the query because there is a cycle in join graph. [Cursor Option,,,,,]
#define SSCE_M_QP_QUERY_NOT_UPDATABLE_11_KEY_ORDER  25606           // Cannot generate an updatable cursor for the query because a one-to-one join must compare columns in the same order as declared in unique indexes. [Cursor Option,,,,,]
#define SSCE_M_QP_QUERY_NOT_UPDATABLE_MM            25607           // Cannot generate an updatable cursor for the query because there is a many-to-many relationship. [Cursor Option,,,,,]
#define SSCE_M_QP_QUERY_NOT_UPDATABLE_NON_UPDATABLE_RELATIONSHIP 25608 // Cannot generate an updatable cursor for the query because there are one or more non-updatable relationships among base tables. [Cursor Option,,,,,]
#define SSCE_M_QP_QUERY_NOT_UPDATABLE_DISCONNECTED_JOIN_GRAPH 25609 // Cannot generate an updatable cursor for the query because one or more tables are not explicitly joined together. [Cursor Option,,,,,]
#define SSCE_M_QP_QUERY_NOT_UPDATABLE_SELF_JOIN     25610           // Cannot generate an updatable cursor for the query because there is a self join. [Cursor Option,,,,,]
#define SSCE_M_QP_QUERY_NOT_UPDATABLE_NOT_SAME_COLUMNS 25611        // Cannot generate an updatable cursor for the query because updatable tables are not joined on the same columns. [Cursor Option,,,,,]
#define SSCE_M_QP_QUERY_NOT_UPDATABLE_NO_UPDATABLE_COLUMN 25612     // Cannot generate an updatable cursor for the query because there is no updatable column. [Cursor Option,,,,,]
#define SSCE_M_QP_FTOA_OVERFLOW                     25613           // A conversion from float to string data failed. [,,,,,]
#define SSCE_M_QP_MISSINGPROCEDUREPARAMETER         25614           // Procedure expects parameter, which was not supplied. [,,,Procedure Name, Parameter Name,]
#define SSCE_M_QP_SCHEMAHASCHANGED                  25615           // The table schema has changed since the query was last compiled. Recompile the query. [,,,Table Name,,]
#define SSCE_M_QP_STATS_NOT_SUPPORTED               25616           // Statistics not supported on system tables. [,,,Table Name,,]
#define SSCE_M_QP_INVALID_INDEX_OPTION              25617           // Invalid option specified in CREATE INDEX statement. [,,,Option Name,,]
#define SSCE_M_QP_INVALID_STORED_PROC_NAME          25618           // Invalid stored procedure name. [,,,Stored Proc Name,,]
#define SSCE_M_QP_FULLSCAN_REQUIRED                 25619           // FULLSCAN option is required for CREATE/UPDATE STATISTICS. [,,,,,]
#define SSCE_M_QP_NAMED_CONSTRAINT_NOT_SUPPORTED    25620           // Named Constraint is not supported for this type of constraint. [,,,Constraint Name,,]
#define SSCE_M_QP_INVALIDPROCEDUREARGS              25621           // The specified argument value for the procedure is not valid. [Argument #,,,Name of procedure(if known),,]
#define SSCE_M_QP_INVALIDTABLENAME                  25622           // The table name is not valid. [,,,Table Name,,]
#define SSCE_M_QP_INVALID_GLOBAL_VARIABLE_NAME      25623           // The global variable name is not valid. [,,,Global variable Name,,]
#define SSCE_M_QP_INVALID_CREATE_DATABASE_OPTION    25624           // Invalid CREATE DATABASE option. [,,,Option,,]


// Errors after this comment were added for v3.5
//
#define SSCE_M_QP_NODEFAULTONROWVERCOL              25625           // Defaults cannot be created on row version columns. [,,,Name of table,Name of column,,]
#define SSCE_M_QP_ALTERCOLUMN_SRC_TIMESTAMP_INVALID 25626           // Cannot alter column of type TIMESTAMP [,,,Column Name,,]
#define SSCE_M_QP_NO_ORDERBY_WITHOUT_TOP_IN_SUBQUERY    25628       // The ORDER BY clause is invalid in subqueries unless TOP is also specified. [,,,,,]
#define SSCE_M_QP_INVALID_TOP_VALUE                 25629           // The number of rows in the TOP clause must be a positive integer. [,,,,,]
#define SSCE_M_QP_INVALID_TOP_EXPRESSION            25630           // Invalid expression in the TOP clause. Provide an integer constant, expression on constants or parameter.[,,,,,]
#define SSCE_M_QP_NOCOL_ALIAS_IN_SUBQUERY           25632           // Column names must be specified for constants, expressions or aggregate functions when they occur in a FROM sub query. [,,,,,]
#define SSCE_M_QP_MULTIPLE_COL_SPEC                 25633           // Column name was specified multiple times for a sub query. [,,,Name of column, Alias of sub query,]
#define SSCE_M_QP_CORRELATED_AGGR_IN_APPLY          25634           // Aggregates on the right side of an APPLY cannot reference columns from the left side. [,,,,,]
#define SSCE_M_QP_ALTERCOLUMN_TGT_TIMESTAMP_INVALID 25635           // Cannot alter column to be type TIMESTAMP [,,,Column Name,,]
#define SSCE_M_QP_CONSTEXPR_IN_GROUP_BY             25636           // Each GROUP BY expression must contain at least one column that is not an outer reference. [,,,,,]

// Errors after this comment were added for v3.5 sp1
//
#define SSCE_M_QP_NO_CONSTANT_IN_ORDERBY             25637          // A constant expression was encountered in the ORDER BY list. [,,,Position,,]
#define SSCE_M_QP_NO_ORDERBY_WO_SELECT_IN_UNION     25638           // ORDER BY items must appear in the select list if the statement contains a UNION. [,,,,,]
// --------------------------------------------------------------------------------------
//
// Query Expression Service     25900 -- 26099
//  
#define SSCE_M_QP_BADEXPR                           25900       // The query processor encountered an error evaluating the expression. [,,,,,]
#define SSCE_M_QP_OVFLO                             25901       // Expression evaluation caused an overflow. [,,,Name of function (if known),,]
#define SSCE_M_QP_EXPRTYPECHECK                     25902       // The data types in the IN expression do not match. [,,,,,]
#define SSCE_M_QP_DATEPART                          25903       // There was an error in a part of the date format. [,,,Expression (if known),,]
#define SSCE_M_QP_DATEABORT                         25904       // There was an error in the date format. [,,,Expression,,]
#define SSCE_M_QP_SYNTAX                            25905       // There was a syntax error in the date format. [,,,Expression,,]
#define SSCE_M_QP_CONVSYNTAX                        25906       // There was a syntax error while converting from one data type to another. [,,,Expression,,]
#define SSCE_M_QP_MONEYOVERFLOW                     25907       // An overflow occurred while converting the string data type to money. [,,,String,,]
#define SSCE_M_QP_NOCOLUMNREFINDEFAULT              25909       // Default values cannot have column references. [,,,,,]
#define SSCE_M_QP_NOAGGRINDEFAULT                   25910       // Default values cannot have aggregate functions. [,,,,,]
#define SSCE_M_QP_NOAGGRONLOB                       25911       // Aggregate value expressions cannot have ntext or image data. [,,,,,]
#define SSCE_M_QP_NOCONVDUETOTRUNC                  25912       // The original data is truncated and cannot be converted. [,,,,,]
#define SSCE_M_QP_ARITHOPNOTSUPPORTED               25913       // The arithmetic operator is not supported for the data type. [,,,,,]
#define SSCE_M_QP_NOMODULOSUPPORT                   25914       // Modulo is not supported on real, float, money, and numeric data types. [,,,Data type,,]
#define SSCE_M_QP_SUBQUERYINVALIDOP                 25916       // An operator on the result data type from a subquery is not valid. [,,,,,]
#define SSCE_M_QP_NOBITOPSUPPORT                    25917       // Bit operators (&,|,^,~) are not supported on real, float, money, and numeric data types. [,,,Data type,,]
#define SSCE_M_QP_BADARITHTYPE                      25918       // The data type is not valid for the arithmetic operation. [,,,Data type (if known),,]
// DEAD SSCE_M_QP_BADARITHOP                        25919       // The arithmetic operator is not recognized by SQL Server Compact Edition. [,,,Operator,,]
#define SSCE_M_QP_TRUNCATION                        25920       // The data was truncated while converting from one data type to another. [,,,Name of function(if known),,]
#define SSCE_M_QP_INVALIDFUNCTIONNAME               25921       // The function is not recognized by SQL Server Compact Edition. [,,,Name of function,Data type (if known),]
#define SSCE_M_QP_INVALIDFUNCTIONARGS               25922       // The specified argument value for the function is not valid. [Argument #,,,Name of function(if known),,]
#define SSCE_M_QP_NOSUPPORTFORLOB                   25923       // The ntext and image data types cannot be used in WHERE, HAVING, GROUP BY, ON, or IN clauses, except when these data types are used with the LIKE or IS NULL predicates. [,,,,,]
#define SSCE_M_QP_BINDTSYNTAX                       25924       // An overflow might have occurred while converting binary to datetime.[,,,,,]
#define SSCE_M_QP_NUMDTSYNTAX                       25925       // An overflow might have occurred while converting numeric to datetime. [,,,,,]
#define SSCE_M_QP_MONDTSYNTAX                       25926       // An overflow might have occurred while converting money to datetime. [,,,,,]
#define SSCE_M_QP_BIGINTDTSYNTAX                    25927       // An overflow might have occurred while converting bigint to datetime. [,,,,,]
#define SSCE_M_QP_TOOMANYARGS                       25928       // There are too many arguments specified for the procedure or function. [Count of arguments,,,,,]
#define SSCE_M_QP_UMINUSNUMONLY                     25929       // A unary minus can be performed only on tinyint, smallint, int, bigint, money, and numeric data types. [,,,,,]
#define SSCE_M_QP_PRECISIONMISMATCH                 25930       // The operation cannot be performed because the precision of the numeric data types do not match. [Precision of right data type (if known), Precision of left data type (if known),,,]
#define SSCE_M_QP_SCALEMISMATCH                     25931       // The operation cannot be performed because the scale of the numeric data types do not match. [Scale of right data type (if known), Scale of left data type (if known),,,]
#define SSCE_M_QP_NOIMPLICITCONVALLOWED             25932       // The data types cannot be converted implicitly. [,,,Source data type,Destination data type,]
#define SSCE_M_QP_DATETIMEOVFLO                     25933       // An overflow occurred while converting to datetime. [,,,,,]
// DEAD SSCE_M_QP_MISSINGTYPELOGIC                  25934       // An error occurred when executing a code path that requires type specific logic that is missing. [,,,,,]
#define SSCE_M_QP_DIVBYZERO                         25935       // Dividing by zero is not allowed. [,,,Name of function (if known),,]
#define SSCE_M_QP_NOTIMEPARTSPECIFIED               25937       // A time datepart must be specified to convert a string to datetime. [,,,String,,]
#define SSCE_M_QP_INVALIDHOURTIMEPARTSPECIFIED      25938       // The specified hour in the time datepart is not valid. [,,,String,,]
#define SSCE_M_QP_INVALIDMINUTETIMEPARTSPECIFIED    25939       // The specified minute in the time datepart is not valid. [,,,String,,]
#define SSCE_M_QP_INVALIDSECONDIMEPARTSPECIFIED     25940       // The specified second in the time datepart is not valid. [,,,String,,]
#define SSCE_M_QP_INVALIDMSEDCONDIMEPARTSPECIFIED   25941       // The specified millisecond in the time datepart is not valid. [,,,String,,]
#define SSCE_M_QP_SYNTAXERRORINDATETIMESTRING       25942       // The specified date or time datepart is not valid. [,,,String,,]
#define SSCE_M_QP_FORMATERRORINDATETIMESTRING       25943       // The format of the specified date or time datepart is not valid. [,,,String,,]
#define SSCE_M_QP_INVALIDORDERINDATETIMESTRING      25944       // The order of the specified date or time datepart is not valid. [,,,String,,]
#define SSCE_M_QP_INVALID_ESCAPE_SEQUENCE           25945       // The escape sequence used in the LIKE predicate is not valid. [,,,,,]

//***** Don't add any more errors here, read the comments below and add appropriately
//
// Errors after this comment were added for v1.1 (PEBBLE) 
//

//Errors after this comment were added for v2.0 
//
#define SSCE_M_QP_INVALIDFUNCTIONARGNUM             25946       // The number of arguments specified for the function is not correct. [Minimum argument count, Maximum argument count,,Name of function(if known),,]
#define SSCE_M_QP_INVALIDCONVERSION                 25947       // The conversion is not supported. [,,,Type to convert from (if known), Type to convert to (if known),]
#define SSCE_M_QP_INVALIDFUNCTIONARGVALUE           25948       // The specified argument value for the function is not valid. [,,,Name of function(if known),,]
#define SSCE_M_QP_INCOMPATIBLE_TYPES                25949       // The expressions in UNION are not compatible. [Expression ordinal,,Type of left expression, Type of right expression,,]
#define SSCE_M_QP_MISSINGPARAMETER                  25950       // A parameter is missing. [Parameter ordinal,,,,,]
#define SSCE_M_QP_PARAMETERNOTALLOWED               25951       // A parameter is not allowed in this location. Ensure that the '@' sign is in a valid location or that parameters are valid at all in this SQL statement. [,,,,,]
// DEAD SSCE_M_QP_EMPTYFROMLIST                     25952       // At least one input table is required. [,,,,,]


// Errors after this comment were added for v3.0 
//
#define SSCE_M_QP_SIGNMISMATCH                      25953       // Expression evaluation caused a sign mismatch. [,,,,,]
#define SSCE_M_QP_CANNOTALTERCOLUMNWITHDEFAULT      25954       // Cannot alter column because it has a default value. [,,,Column Name,,]
#define SSCE_M_QP_BAD_BOOL_OP_TYPE                  25955       // The data type is not valid for the boolean operation. [,,,Data type (if known),Data type (if known),]

// Errors after this comment were added for v3.5
#define SSCE_M_QP_MISSINGPARAMETERTYPE              25956       // Parameter type has not been declared. [Parameter ordinal,,,Parameter name (if available),,]
#define SSCE_M_QP_LOB_IN_UNION_DISTINCT             25957       // The ntext and image data types can be used in select list of UNION only when ALL option is specified. [,,,,,]
#define SSCE_M_QP_OVERFLOW_IN_COUNT                 25958       // An overflow occurred in computing COUNT. COUNT can only be used when return values are less than 2^31. [,,,,,]

// --------------------------------------------------------------------------------------
//
// Query Storage Layer          26100 -- 26199
//  
#define SSCE_M_QP_BADTABLE                          26100       // The table name is not valid. [Token line number (if known),Token line offset (if known),,Table name,,]
// DEAD SSCE_M_QP_BADSCHEMAROWSET                   26101       // An error occurred while accessing the schema rowset. [,,,,,]
// DEAD SSCE_M_QP_TBLSCHEMAROWSET                   26102       // An error occurred while accessing the table schema rowset. [,,,Table name,,]

//***** Don't add any more errors here, read the comments below and add appropriately
//
// Errors after this comment were added for v1.1 (PEBBLE) 
//

// --------------------------------------------------------------------------------------
//
// Query Core                   26300 -- 26499
//  
// DEAD SSCE_M_QP_OLEDBERR                          26300       // OLE DB returned an error. [,,,,,]
// DEAD SSCE_M_QP_BADADT                            26301       // Cannot convert from the specified type. [,,,,,]
#define SSCE_M_QP_BADTYPE                           26302       // The specified data type is not valid. [,,,Data type (if known),,]
#define SSCE_M_QP_INTERNAL                          26303       // Internal error: A query processor error occurred. [,,,,,]
#define SSCE_M_QP_BADADTMETAINFO                    26305       // The DDL statement contains invalid parameters associated with the column definition. [,,,,,]
#define SSCE_M_QP_COERSIONERROR                     26306       // Data conversion failed. [OLE DB status value (if known),,,,,]
#define SSCE_M_QP_BADQUERY                          26307       // Syntax error in query. [,,,,,]
// DEAD SSCE_M_QP_ZEROLENGTHBINARYCONST             26308       // Zero-length binary constants are not supported in SQL Server Compact Edition. [,,,,,]

// ***********************************************************************
// NOTE : Our error number range is limited to the SQL Server error number 
//        range, Which is 25000 to 30000. DO NOT ADD ANY ERRORS ABOVE OR
//        BELOW THIS RANGE!
// ***********************************************************************


// --------------------------------------------------------------------------------------
//
// SSCERelay                    30000 -- 30499 
//
//
// Errors after this comment were added for v1.1 (PEBBLE) 
//
// DEAD SSCE_M_WSANOTINITIALISED                    30000       // The socket cannot be initialized/uninitialized. [,,,,,]
// DEAD SSCE_M_WSAENETDOWN                          30001       // The network was unavailable, and the initialization/uninitialization of the socket failed. [,,,,,]
// DEAD SSCE_M_WSAEINPROGRESS                       30002       // The socket cannot be initialized/uninitialized. A blocking operation is currently executing. [,,,,,]
// DEAD SSCE_M_WSASYSNOTREADY                       30003       // The socket caninitialized/uninitialized. Either a driver is missing or multiple implementations are being used. [,,,,,]
// DEAD SSCE_M_WSAVERNOTSUPPORTED                   30004       // The socket cannot be initialized/uninitialized. The current version is not supported. [,,,,,]
// DEAD SSCE_M_WSAEPROCLIM                          30005       // The socket cannot be initialized/uninitialized. The limit on the number of processes using Windows Sockets has been reached. [,,,,,]
// DEAD SSCE_M_WSAEFAULT                            30006       // An address passed to the function is not valid. [,,,,,]
// DEAD SSCE_M_CREATEEVENTFAILED                    30007       // A create event failed. For more information, see HRESULT. [,,,,,]
// DEAD SSCE_M_SETEVENTFAILED                       30008       // A set event failed. For more information, see HRESULT. [,,,,,]
// DEAD SSCE_M_WAITFAILED                           30009       // A WAITFOR event failed. For more information, see HRESULT. [,,,,,]
// DEAD SSCE_M_INVALIDCLIENTPORT                    30010       // The specified desktop computer port is not valid. [,,,,,]
// DEAD SSCE_M_CONVERSIONTOUNICODEFAILED            30011       // The conversion of the server name to Unicode failed. [,,,,,]
// DEAD SSCE_M_INVALIDSERVERPORT                    30012       // The server port specified is not valid. [,,,,,]
// DEAD SSCE_M_FAILUREACCESSINGSYSTEMMENU           30013       // The system menu cannot be accessed. [,,,,,]
// DEAD SSCE_M_FAILURESETTINGREGISTRY               30014       // The registry keys cannot be set or created. [,,,,,]
// DEAD SSCE_M_INVALIDARGUMENT                      30015       // A parameter passed to SQL Server Compact Edition Relay is not valid. [,,,,,]
// DEAD SSCE_M_INVALIDARGUMENT                      30015       // A parameter passed to SQL Server Compact Relay is not valid. [,,,,,]
// DEAD SSCE_M_MISSINGPORTORSERVER                  30017       // Either a port number is not valid or the server name is missing. [,,,,,]
// DEAD SSCE_M_SOCKETCALLFAILED                     30018       // The socket call failed. [,,,,,]
// DEAD SSCE_M_PORTALREADYINUSE                     30019       // The socket port is already in use on this device. [,,,,,]
// DEAD SSCE_M_BINDFAILED                           30020       // The bind failed. [,,,,,]
// DEAD SSCE_M_CANTRESOLVESERVERADDRESS             30021       // The server address cannot be resolved. [,,,,,]
// DEAD SSCE_M_LISTENFAILED                         30022       // The Listen function failed on a socket. [,,,,,]
// DEAD SSCE_M_ACCEPTFAILED                         30023       // An accept from the server failed. [,,,,,]
// DEAD SSCE_M_CONNECTFAILED                        30024       // A connection request to the server has failed. [,,,,,]
// DEAD SSCE_M_CANTCREATETHREAD                     30025       // A thread cannot be created due to system problems or lack of resources. [,,,,,]
// DEAD SSCE_M_SETKEEPALIVEFAILED                   30026       // Internal Error: Setting a socket option for keep alive failed. [,,,,,]
// DEAD SSCE_M_SETNAGLEFAILED                       30027       // Internal Error: Setting a socket option for the Nagle algorithm failed. [,,,,,]
// DEAD SSCE_M_RECEIVEFAILED                        30028       // The receive operation from the socket failed. [,,,,,]
// DEAD SSCE_M_SENDFAILED                           30029       // The send operation to the socket failed. [,,,,,]
// DEAD SSCE_M_INITARGSFAILED                       30030       // The initialization of arguments failed.[,,,,,]
// DEAD SSCE_M_WSASTARTUPFAILED                     30031       // The WSAStartup function failed during socket initialization. [,,,,,]
// DEAD SSCE_M_WSACLEANUPFAILED                     30032       // The WSACleanup function failed during a cleanup operation. [,,,,,]
// DEAD SSCE_M_INVALIDSERVERNAME                    30033       // The server name is either not valid or not specified. [,,,,,]
// DEAD SSCE_M_CONNECTIONRESET                      30034       // The socket connection was reset. [,,,,,]

// --------------------------------------------------------------------------------------
//
// Miscellaneous                    39500 -- 39999 
//
//
// Errors after this comment were added for v1.1 (PEBBLE) 
//
// DEAD SSCE_M_EVALUATIONCOPYEXPIRED                39999       // The evaluation copy has expired. [,,,,,]

// -------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------
//                              O L E D B   E R R O R   C O D E S
//
//
#define DB_E_BADACCESSORHANDLE                  (HRESULT)0x80040E00L    // Accessor is invalid. [,,,,,]
#define DB_E_ROWLIMITEXCEEDED                   (HRESULT)0x80040E01L    // Row could not be inserted into the rowset without exceeding provider's maximum number of active rows. [,,,,,]
#define DB_E_READONLYACCESSOR                   (HRESULT)0x80040E02L    // Accessor is read-only. Operation failed. [,,,,,]
#define DB_E_SCHEMAVIOLATION                    (HRESULT)0x80040E03L    // Values violate the database schema. [,,,,,]
#define DB_E_BADROWHANDLE                       (HRESULT)0x80040E04L    // Row handle is invalid. [,,,,,]
#define DB_E_OBJECTOPEN                         (HRESULT)0x80040E05L    // Object was open. [,,,,,]
#define DB_E_BADCHAPTER                         (HRESULT)0x80040E06L    // Invalid chapter. [,,,,,]
#define DB_E_CANTCONVERTVALUE                   (HRESULT)0x80040E07L    // A literal value in the command could not be converted to the correct type due to a reason other than data overflow. [,,,,,]
#define DB_E_BADBINDINFO                        (HRESULT)0x80040E08L    // Invalid binding info. [,,,,,]
#define DB_SEC_E_PERMISSIONDENIED               (HRESULT)0x80040E09L    // Permission denied. [,,,,,]
#define DB_E_NOTAREFERENCECOLUMN                (HRESULT)0x80040E0AL    // Specified column does not contain bookmarks or chapters. [,,,,,]
#define DB_E_LIMITREJECTED                      (HRESULT)0x80040E0BL    // Some cost limits were rejected. [,,,,,]
#define DB_E_NOCOMMAND                          (HRESULT)0x80040E0CL    // No command has been set for the command object. [,,,,,]
#define DB_E_COSTLIMIT                          (HRESULT)0x80040E0DL    // Unable to find a query plan within the given cost limit. [,,,,,]
#define DB_E_BADBOOKMARK                        (HRESULT)0x80040E0EL    // Invalid bookmark. [,,,,,]
#define DB_E_BADLOCKMODE                        (HRESULT)0x80040E0FL    // Invalid lock mode. [,,,,,]
#define DB_E_PARAMNOTOPTIONAL                   (HRESULT)0x80040E10L    // No value given for one or more required parameters. [,,,,,]
#define DB_E_BADCOLUMNID                        (HRESULT)0x80040E11L    // Invalid column ID. [,,,,,]
#define DB_E_BADRATIO                           (HRESULT)0x80040E12L    // Invalid ratio. [,,,,,]
#define DB_E_BADVALUES                          (HRESULT)0x80040E13L    // Invalid value. [,,,,,]
#define DB_E_ERRORSINCOMMAND                    (HRESULT)0x80040E14L    // The command contained one or more errors. [,,,,,]
#define DB_E_CANTCANCEL                         (HRESULT)0x80040E15L    // The executing command cannot be canceled. [,,,,,]
#define DB_E_DIALECTNOTSUPPORTED                (HRESULT)0x80040E16L    // The provider does not support the specified dialect. [,,,,,]
#define DB_E_DUPLICATEDATASOURCE                (HRESULT)0x80040E17L    // A data source with the specified name already exists. [,,,,,]
#define DB_E_CANNOTRESTART                      (HRESULT)0x80040E18L    // The rowset was built over a live data feed and cannot be restarted. [,,,,,]
#define DB_E_NOTFOUND                           (HRESULT)0x80040E19L    // No key matching the described characteristics could be found within the current range. [,,,,,]
#define DB_E_NEWLYINSERTED                      (HRESULT)0x80040E1BL    // The provider is unable to determine identity for newly inserted rows. [,,,,,]
#define DB_E_CANNOTFREE                         (HRESULT)0x80040E1AL    // Ownership of this tree has been given to the provider. [,,,,,]
#define DB_E_GOALREJECTED                       (HRESULT)0x80040E1CL    // No nonzero weights specified for any goals supported, so goal was rejected; current goal was not changed. [,,,,,]
#define DB_E_UNSUPPORTEDCONVERSION              (HRESULT)0x80040E1DL    // Requested conversion is not supported. [,,,,,]
#define DB_E_BADSTARTPOSITION                   (HRESULT)0x80040E1EL    // lRowsOffset would position you past either end of the rowset, regardless of the cRows value specified; cRowsObtained is 0. [,,,,,]
// DEAD DB_E_NOQUERY                            (HRESULT)0x80040E1FL    // Information was requested for a query, and the query was not set. [,,,,,]
#define DB_E_NOTREENTRANT                       (HRESULT)0x80040E20L    // Provider called a method from IRowsetNotify in the consumer and the method has not yet returned. [,,,,,]
#define DB_E_ERRORSOCCURRED                     (HRESULT)0x80040E21L    // Errors occurred. [,,,,,]
#define DB_E_NOAGGREGATION                      (HRESULT)0x80040E22L    // A non-NULL controlling IUnknown was specified and the object being created does not support aggregation. [,,,,,]
#define DB_E_DELETEDROW                         (HRESULT)0x80040E23L    // The current row was deleted. [,,,,,]
#define DB_E_CANTFETCHBACKWARDS                 (HRESULT)0x80040E24L    // The rowset does not support fetching backwards. [,,,,,]
#define DB_E_ROWSNOTRELEASED                    (HRESULT)0x80040E25L    // All HROWs must be released before new ones can be obtained. [,,,,,]
#define DB_E_BADSTORAGEFLAG                     (HRESULT)0x80040E26L    // One of the specified storage flags was not supported. [,,,,,]
#define DB_E_BADCOMPAREOP                       (HRESULT)0x80040E27L    // The comparison operator was invalid. [,,,,,]
#define DB_E_BADSTATUSVALUE                     (HRESULT)0x80040E28L    // The specified status flag was neither DBCOLUMNSTATUS_OK nor DBCOLUMNSTATUS_ISNULL. [,,,,,]
#define DB_E_CANTSCROLLBACKWARDS                (HRESULT)0x80040E29L    // The rowset cannot scroll backwards. [,,,,,]
#define DB_E_BADREGIONHANDLE                    (HRESULT)0x80040E2AL    // Invalid region handle. [,,,,,]
#define DB_E_NONCONTIGUOUSRANGE                 (HRESULT)0x80040E2BL    // The specified set of rows was not contiguous to or overlapping the rows in the specified watch region. [,,,,,]
#define DB_E_INVALIDTRANSITION                  (HRESULT)0x80040E2CL    // A transition from ALL* to MOVE* or EXTEND* was specified. [,,,,,]
#define DB_E_NOTASUBREGION                      (HRESULT)0x80040E2DL    // The specified region is not a proper subregion of the region identified by the given watch region handle. [,,,,,]
#define DB_E_MULTIPLESTATEMENTS                 (HRESULT)0x80040E2EL    // The provider does not support multi-statement commands. [,,,,,]
#define DB_E_INTEGRITYVIOLATION                 (HRESULT)0x80040E2FL    // A specified value violated the integrity constraints for a column or table. [,,,,,]
#define DB_E_BADTYPENAME                        (HRESULT)0x80040E30L    // The given type name was unrecognized. [,,,,,]
#define DB_E_ABORTLIMITREACHED                  (HRESULT)0x80040E31L    // Execution aborted because a resource limit has been reached; no results have been returned. [,,,,,]
#define DB_E_ROWSETINCOMMAND                    (HRESULT)0x80040E32L    // Cannot clone a command object whose command tree contains a rowset or rowsets. [,,,,,]
#define DB_E_CANTTRANSLATE                      (HRESULT)0x80040E33L    // Cannot represent the current tree as text. [,,,,,]
#define DB_E_DUPLICATEINDEXID                   (HRESULT)0x80040E34L    // The specified index already exists. [,,,,,]
#define DB_E_NOINDEX                            (HRESULT)0x80040E35L    // The specified index does not exist. [,,,,,]
#define DB_E_INDEXINUSE                         (HRESULT)0x80040E36L    // The specified index was in use. [,,,,,]
#define DB_E_NOTABLE                            (HRESULT)0x80040E37L    // The specified table does not exist. [,,,,,]
#define DB_E_CONCURRENCYVIOLATION               (HRESULT)0x80040E38L    // The rowset was using optimistic concurrency and the value of a column has been changed since it was last read. [,,,,,]
#define DB_E_BADCOPY                            (HRESULT)0x80040E39L    // Errors were detected during the copy. [,,,,,]
#define DB_E_BADPRECISION                       (HRESULT)0x80040E3AL    // A specified precision was invalid. [,,,,,]
#define DB_E_BADSCALE                           (HRESULT)0x80040E3BL    // A specified scale was invalid. [,,,,,]
#define DB_E_BADTABLEID                         (HRESULT)0x80040E3CL    // Invalid table ID. [,,,,,]
#define DB_E_BADTYPE                            (HRESULT)0x80040E3DL    // A specified type was invalid. [,,,,,]
#define DB_E_DUPLICATECOLUMNID                  (HRESULT)0x80040E3EL    // A column ID occurred more than once in the specification. [,,,,,]
#define DB_E_DUPLICATETABLEID                   (HRESULT)0x80040E3FL    // The specified table already exists. [,,,,,]
#define DB_E_TABLEINUSE                         (HRESULT)0x80040E40L    // The specified table was in use. [,,,,,]
#define DB_E_NOLOCALE                           (HRESULT)0x80040E41L    // The specified locale ID was not supported. [,,,,,]
#define DB_E_BADRECORDNUM                       (HRESULT)0x80040E42L    // The specified record number is invalid. [,,,,,]
#define DB_E_BOOKMARKSKIPPED                    (HRESULT)0x80040E43L    // Although the bookmark was validly formed, no row could be found to match it. [,,,,,]
#define DB_E_BADPROPERTYVALUE                   (HRESULT)0x80040E44L    // The value of a property was invalid. [,,,,,]
#define DB_E_INVALID                            (HRESULT)0x80040E45L    // The rowset was not chaptered. [,,,,,]
#define DB_E_BADACCESSORFLAGS                   (HRESULT)0x80040E46L    // Invalid accessor. [,,,,,]
#define DB_E_BADSTORAGEFLAGS                    (HRESULT)0x80040E47L    // Invalid storage flags. [,,,,,]
#define DB_E_BYREFACCESSORNOTSUPPORTED          (HRESULT)0x80040E48L    // By-ref accessors are not supported by this provider. [,,,,,]
#define DB_E_NULLACCESSORNOTSUPPORTED           (HRESULT)0x80040E49L    // Null accessors are not supported by this provider. [,,,,,]
#define DB_E_NOTPREPARED                        (HRESULT)0x80040E4AL    // The command was not prepared. [,,,,,]
#define DB_E_BADACCESSORTYPE                    (HRESULT)0x80040E4BL    // The specified accessor was not a parameter accessor. [,,,,,]
#define DB_E_WRITEONLYACCESSOR                  (HRESULT)0x80040E4CL    // The given accessor was write-only. [,,,,,]
#define DB_SEC_E_AUTH_FAILED                    (HRESULT)0x80040E4DL    // Authentication failed. [,,,,,]
#define DB_E_CANCELED                           (HRESULT)0x80040E4EL    // The change was canceled during notification; no columns are changed. [,,,,,]
#define DB_E_CHAPTERNOTRELEASED                 (HRESULT)0x80040E4FL    // The rowset was single-chaptered and the chapter was not released. [,,,,,]
#define DB_E_BADSOURCEHANDLE                    (HRESULT)0x80040E50L    // Invalid source handle. [,,,,,]
#define DB_E_PARAMUNAVAILABLE                   (HRESULT)0x80040E51L    // The provider cannot derive parameter info and SetParameterInfo has not been called. [,,,,,]
#define DB_E_ALREADYINITIALIZED                 (HRESULT)0x80040E52L    // The data source object is already initialized. [,,,,,]
#define DB_E_NOTSUPPORTED                       (HRESULT)0x80040E53L    // The provider does not support this method. [,,,,,]
#define DB_E_MAXPENDCHANGESEXCEEDED             (HRESULT)0x80040E54L    // The number of rows with pending changes has exceeded the set limit. [,,,,,]
#define DB_E_BADORDINAL                         (HRESULT)0x80040E55L    // The specified column did not exist. [,,,,,]
#define DB_E_PENDINGCHANGES                     (HRESULT)0x80040E56L    // There are pending changes on a row with a reference count of zero. [,,,,,]
#define DB_E_DATAOVERFLOW                       (HRESULT)0x80040E57L    // A literal value in the command overflowed the range of the type of the associated column. [,,,,,]
#define DB_E_BADHRESULT                         (HRESULT)0x80040E58L    // The supplied HRESULT was invalid. [,,,,,]
#define DB_E_BADLOOKUPID                        (HRESULT)0x80040E59L    // The supplied LookupID was invalid. [,,,,,]
#define DB_E_BADDYNAMICERRORID                  (HRESULT)0x80040E5AL    // The supplied DynamicErrorID was invalid. [,,,,,]
#define DB_E_PENDINGINSERT                      (HRESULT)0x80040E5BL    // Unable to get visible data for a newly-inserted row that has not yet been updated. [,,,,,]
#define DB_E_BADCONVERTFLAG                     (HRESULT)0x80040E5CL    // Invalid conversion flag. [,,,,,]
#define DB_E_BADPARAMETERNAME                   (HRESULT)0x80040E5DL    // The given parameter name was unrecognized. [,,,,,]
#define DB_E_MULTIPLESTORAGE                    (HRESULT)0x80040E5EL    // Multiple storage objects can not be open simultaneously. [,,,,,]
#define DB_E_CANTFILTER                         (HRESULT)0x80040E5FL    // The requested filter could not be opened. [,,,,,]
#define DB_E_CANTORDER                          (HRESULT)0x80040E60L    // The requested order could not be opened. [,,,,,]
#define DB_E_NOCOLUMN                           (HRESULT)0x80040E65L    // The supplied columnID was invalid. [,,,,,]
#define DB_E_COMMANDNOTPERSISTED                (HRESULT)0x80040E67L    // The supplied command does not have a DBID. [,,,,,]
#define DB_E_DUPLICATEID                        (HRESULT)0x80040E68L    // The supplied DBID already exists. [,,,,,]
#define DB_E_OBJECTCREATIONLIMITREACHED         (HRESULT)0x80040E69L    // The maximum number of Sessions supported by the provider has already been created. The consumer must release one or more currently held Sessions before obtaining a new Session Object. [,,,,,]
#define DB_E_BADINDEXID                         (HRESULT)0x80040E72L    // The index ID is invalid. [,,,,,]
#define DB_E_BADINITSTRING                      (HRESULT)0x80040E73L    // The initialization string specified does not conform to specificiation. [,,,,,]
#define DB_E_NOPROVIDERSREGISTERED              (HRESULT)0x80040E74L    // The OLE DB root enumerator did not return any providers that matched any of the SOURCES_TYPEs requested. [,,,,,]
#define DB_E_MISMATCHEDPROVIDER                 (HRESULT)0x80040E75L    // The initialization string specifies a provider which does not match the currently active provider. [,,,,,]
#define DB_E_BADCOMMANDID                       (HRESULT)0x80040E76L    // The specified DBID is invalid. [,,,,,]
#define SEC_E_BADTRUSTEEID                      (HRESULT)0x80040E6AL    // Invalid trustee value. [,,,,,]
#define SEC_E_NOTRUSTEEID                       (HRESULT)0x80040E6BL    // The trustee is not for the current data source. [,,,,,]
#define SEC_E_NOMEMBERSHIPSUPPORT               (HRESULT)0x80040E6CL    // The trustee does not support memberships/collections. [,,,,,]
#define SEC_E_INVALIDOBJECT                     (HRESULT)0x80040E6DL    // The object is invalid or unknown to the provider. [,,,,,]
#define SEC_E_NOOWNER                           (HRESULT)0x80040E6EL    // No owner exists for the object. [,,,,,]
#define SEC_E_INVALIDACCESSENTRYLIST            (HRESULT)0x80040E6FL    // The access entry list supplied is invalid. [,,,,,]
#define SEC_E_INVALIDOWNER                      (HRESULT)0x80040E70L    // The trustee supplied as owner is invalid or unknown to the provider. [,,,,,]
#define SEC_E_INVALIDACCESSENTRY                (HRESULT)0x80040E71L    // The permission supplied in the access entry list is invalid. [,,,,,]
#define DB_E_BADCONSTRAINTTYPE                  (HRESULT)0x80040E77L    // The ConstraintType was invalid or not supported by the provider. [,,,,,]
#define DB_E_BADCONSTRAINTFORM                  (HRESULT)0x80040E78L    // The ConstraintType was not DBCONSTRAINTTYPE_FOREIGNKEY and cForeignKeyColumns was not zero. [,,,,,]
#define DB_E_BADDEFERRABILITY                   (HRESULT)0x80040E79L    // The Deferrability was invalid or the value was not supported by the provider. [,,,,,]
#define DB_E_BADMATCHTYPE                       (HRESULT)0x80040E80L    // The MatchType was invalid or the value was not supported by the provider. [,,,,,]
#define DB_E_BADUPDATEDELETERULE                (HRESULT)0x80040E8AL    // The UpdateRule or DeleteRule was invalid or the value was not supported by the provider. [,,,,,]
#define DB_E_BADCONSTRAINTID                    (HRESULT)0x80040E8BL    // Constraint ID is invalid. [,,,,,]
#define DB_E_BADCOMMANDFLAGS                    (HRESULT)0x80040E8CL    // The dwFlags was invalid. [,,,,,]
#define DB_E_OBJECTMISMATCH                     (HRESULT)0x80040E8DL    // The rguidColumnType pointed to a GUID that does not match the object type of this column or this column was not set. [,,,,,]
#define DB_E_NOSOURCEOBJECT                     (HRESULT)0x80040E91L    // There is no source row. [,,,,,]
#define DB_E_RESOURCELOCKED                     (HRESULT)0x80040E92L    // The OLE DB object represented by this URL is locked by one or more other processes. [,,,,,]
#define DB_E_NOTCOLLECTION                      (HRESULT)0x80040E93L    // The client requested an object type that is only valid for a collection. [,,,,,]
#define DB_E_READONLY                           (HRESULT)0x80040E94L    // The caller requested write access to a read-only object. [,,,,,]
#define DB_E_ASYNCNOTSUPPORTED                  (HRESULT)0x80040E95L    // The provider could not connect to the server for this object. [,,,,,]
#define DB_E_CANNOTCONNECT                      (HRESULT)0x80040E96L    // The provider could not connect to the server for this object. [,,,,,]
#define DB_E_TIMEOUT                            (HRESULT)0x80040E97L    // The attempt to bind to the object timed out. [,,,,,]
#define DB_E_RESOURCEEXISTS                     (HRESULT)0x80040E98L    // The provider was unable to create an object at this URL because an object named by this URL already exists. [,,,,,]
#define DB_E_RESOURCEOUTOFSCOPE                 (HRESULT)0x80040E8EL    // The requested URL was out-of-scope. [,,,,,]
#define DB_E_DROPRESTRICTED                     (HRESULT)0x80040E90L    // Column or constraint could not be dropped because it is referenced by a dependent view or constraint. [,,,,,]
#define DB_E_DUPLICATECONSTRAINTID              (HRESULT)0x80040E99L    // Constraint already exists. [,,,,,]
#define DB_E_OUTOFSPACE                         (HRESULT)0x80040E9AL    // Object cannot be created at this URL because the server is out of physical storage. [,,,,,]
#define DB_S_ROWLIMITEXCEEDED                   (HRESULT)0x00040EC0L    // Fetching requested number of rows would have exceeded total number of active rows supported by the rowset. [,,,,,]
#define DB_S_COLUMNTYPEMISMATCH                 (HRESULT)0x00040EC1L    // One or more column types are incompatible; conversion errors will occur during copying. [,,,,,]
#define DB_S_TYPEINFOOVERRIDDEN                 (HRESULT)0x00040EC2L    // Parameter type information has been overridden by caller. [,,,,,]
#define DB_S_BOOKMARKSKIPPED                    (HRESULT)0x00040EC3L    // Skipped bookmark for deleted or non-member row. [,,,,,]
#define DB_S_NONEXTROWSET                       (HRESULT)0x00040EC5L    // There are no more rowsets. [,,,,,]
#define DB_S_ENDOFROWSET                        (HRESULT)0x00040EC6L    // Reached start or end of rowset or chapter. [,,,,,]
#define DB_S_COMMANDREEXECUTED                  (HRESULT)0x00040EC7L    // The provider re-executed the command. [,,,,,]
#define DB_S_BUFFERFULL                         (HRESULT)0x00040EC8L    // Variable data buffer full. [,,,,,]
#define DB_S_NORESULT                           (HRESULT)0x00040EC9L    // There are no more results. [,,,,,]
#define DB_S_CANTRELEASE                        (HRESULT)0x00040ECAL    // Server cannot release or downgrade a lock until the end of the transaction. [,,,,,]
#define DB_S_GOALCHANGED                        (HRESULT)0x00040ECBL    // Specified weight was not supported or exceeded the supported limit and was set to 0 or the supported limit. [,,,,,]
#define DB_S_UNWANTEDOPERATION                  (HRESULT)0x00040ECCL    // Consumer is uninterested in receiving further notification calls for this reason. [,,,,,]
#define DB_S_DIALECTIGNORED                     (HRESULT)0x00040ECDL    // Input dialect was ignored and text was returned in different dialect. [,,,,,]
#define DB_S_UNWANTEDPHASE                      (HRESULT)0x00040ECEL    // Consumer is uninterested in receiving further notification calls for this phase. [,,,,,]
#define DB_S_UNWANTEDREASON                     (HRESULT)0x00040ECFL    // Consumer is uninterested in receiving further notification calls for this reason. [,,,,,]
#define DB_S_ASYNCHRONOUS                       (HRESULT)0x00040ED0L    // The operation is being processed asynchronously. [,,,,,]
#define DB_S_COLUMNSCHANGED                     (HRESULT)0x00040ED1L    // In order to reposition to the start of the rowset, the provider had to reexecute the query; either the order of the columns changed or columns were added to or removed from the rowset. [,,,,,]
#define DB_S_ERRORSRETURNED                     (HRESULT)0x00040ED2L    // The method had some errors; errors have been returned in the error array. [,,,,,]
#define DB_S_BADROWHANDLE                       (HRESULT)0x00040ED3L    // Invalid row handle. [,,,,,]
#define DB_S_DELETEDROW                         (HRESULT)0x00040ED4L    // A given HROW referred to a hard-deleted row. [,,,,,]
#define DB_S_TOOMANYCHANGES                     (HRESULT)0x00040ED5L    // The provider was unable to keep track of all the changes; the client must refetch the data associated with the watch region using another method. [,,,,,]
#define DB_S_STOPLIMITREACHED                   (HRESULT)0x00040ED6L    // Execution stopped because a resource limit has been reached; results obtained so far have been returned but execution cannot be resumed. [,,,,,]
#define DB_S_LOCKUPGRADED                       (HRESULT)0x00040ED8L    // A lock was upgraded from the value specified. [,,,,,]
#define DB_S_PROPERTIESCHANGED                  (HRESULT)0x00040ED9L    // One or more properties were changed as allowed by provider. [,,,,,]
#define DB_S_ERRORSOCCURRED                     (HRESULT)0x00040EDAL    // Errors occurred. [,,,,,]
#define DB_S_PARAMUNAVAILABLE                   (HRESULT)0x00040EDBL    // A specified parameter was invalid. [,,,,,]
#define DB_S_MULTIPLECHANGES                    (HRESULT)0x00040EDCL    // Updating this row caused more than one row to be updated in the data source. [,,,,,]
#define DB_S_NOTSINGLETON                       (HRESULT)0x00040ED7L    // The bind failed because the provider was unable to satisfy all of the bind flags or properties. [,,,,,]
#define DB_S_NOROWSPECIFICCOLUMNS               (HRESULT)0x00040EDDL    // The row has no row-specific columns. [,,,,,]

#endif // of ! __SQLCE_ERR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\splapi.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/********************************************************************
  splapi.h
********************************************************************/

// @CESYSGEN IF CE_MODULES_SPLUSA
// @CESYSGEN ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\specstrings_undef.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
#undef __$adt_add_prop
#undef __$adt_prop
#undef __$adt_remove_prop
#undef __$adt_transfer_prop
#undef __$adt_type_props
#undef __$nonvolatile
#undef __$possibly_notnulltermiated
#undef __$volatile
#undef __allocator
#undef __analysis_assert
#undef __analysis_assume
#undef __analysis_hint
#undef __assume_ValidCompNameA
#undef __assume_ValidCompNameW
#undef __assume_bound
#undef __assume_validated
#undef __bcount
#undef __bcount_opt
#undef __blocksOn
#undef __bound
#undef __byte_readableTo
#undef __byte_writableTo
#undef __callback
#undef __checkReturn
#undef __class_code_content
#undef __control_entrypoint
#undef __data_entrypoint
#undef __deref
#undef __deref_bcount
#undef __deref_bcount_opt
#undef __deref_ecount
#undef __deref_ecount_opt
#undef __deref_in
#undef __deref_in_bcount
#undef __deref_in_bcount_opt
#undef __deref_in_ecount
#undef __deref_in_ecount_opt
#undef __deref_in_opt
#undef __deref_in_range
#undef __deref_in_xcount
#undef __deref_in_xcount_opt
#undef __deref_inout
#undef __deref_inout_bcount
#undef __deref_inout_bcount_full
#undef __deref_inout_bcount_full_opt
#undef __deref_inout_bcount_nz
#undef __deref_inout_bcount_nz_opt
#undef __deref_inout_bcount_opt
#undef __deref_inout_bcount_part
#undef __deref_inout_bcount_part_opt
#undef __deref_inout_bcount_z
#undef __deref_inout_bcount_z_opt
#undef __deref_inout_ecount
#undef __deref_inout_ecount_full
#undef __deref_inout_ecount_full_opt
#undef __deref_inout_ecount_nz
#undef __deref_inout_ecount_nz_opt
#undef __deref_inout_ecount_opt
#undef __deref_inout_ecount_part
#undef __deref_inout_ecount_part_opt
#undef __deref_inout_ecount_z
#undef __deref_inout_ecount_z_opt
#undef __deref_inout_nz
#undef __deref_inout_nz_opt
#undef __deref_inout_opt
#undef __deref_inout_xcount
#undef __deref_inout_xcount_full
#undef __deref_inout_xcount_full_opt
#undef __deref_inout_xcount_opt
#undef __deref_inout_xcount_part
#undef __deref_inout_xcount_part_opt
#undef __deref_inout_z
#undef __deref_inout_z_opt
#undef __deref_nonvolatile
#undef __deref_opt_bcount
#undef __deref_opt_bcount_opt
#undef __deref_opt_ecount
#undef __deref_opt_ecount_opt
#undef __deref_opt_in
#undef __deref_opt_in_bcount
#undef __deref_opt_in_bcount_opt
#undef __deref_opt_in_ecount
#undef __deref_opt_in_ecount_opt
#undef __deref_opt_in_opt
#undef __deref_opt_in_xcount
#undef __deref_opt_in_xcount_opt
#undef __deref_opt_inout
#undef __deref_opt_inout_bcount
#undef __deref_opt_inout_bcount_full
#undef __deref_opt_inout_bcount_full_opt
#undef __deref_opt_inout_bcount_nz
#undef __deref_opt_inout_bcount_nz_opt
#undef __deref_opt_inout_bcount_opt
#undef __deref_opt_inout_bcount_part
#undef __deref_opt_inout_bcount_part_opt
#undef __deref_opt_inout_bcount_z
#undef __deref_opt_inout_bcount_z_opt
#undef __deref_opt_inout_ecount
#undef __deref_opt_inout_ecount_full
#undef __deref_opt_inout_ecount_full_opt
#undef __deref_opt_inout_ecount_nz
#undef __deref_opt_inout_ecount_nz_opt
#undef __deref_opt_inout_ecount_opt
#undef __deref_opt_inout_ecount_part
#undef __deref_opt_inout_ecount_part_opt
#undef __deref_opt_inout_ecount_z
#undef __deref_opt_inout_ecount_z_opt
#undef __deref_opt_inout_nz
#undef __deref_opt_inout_nz_opt
#undef __deref_opt_inout_opt
#undef __deref_opt_inout_xcount
#undef __deref_opt_inout_xcount_full
#undef __deref_opt_inout_xcount_full_opt
#undef __deref_opt_inout_xcount_opt
#undef __deref_opt_inout_xcount_part
#undef __deref_opt_inout_xcount_part_opt
#undef __deref_opt_inout_z
#undef __deref_opt_inout_z_opt
#undef __deref_opt_out
#undef __deref_opt_out_bcount
#undef __deref_opt_out_bcount_full
#undef __deref_opt_out_bcount_full_opt
#undef __deref_opt_out_bcount_nz_opt
#undef __deref_opt_out_bcount_opt
#undef __deref_opt_out_bcount_part
#undef __deref_opt_out_bcount_part_opt
#undef __deref_opt_out_bcount_z_opt
#undef __deref_opt_out_ecount
#undef __deref_opt_out_ecount_full
#undef __deref_opt_out_ecount_full_opt
#undef __deref_opt_out_ecount_nz_opt
#undef __deref_opt_out_ecount_opt
#undef __deref_opt_out_ecount_part
#undef __deref_opt_out_ecount_part_opt
#undef __deref_opt_out_ecount_z_opt
#undef __deref_opt_out_nz_opt
#undef __deref_opt_out_opt
#undef __deref_opt_out_xcount
#undef __deref_opt_out_xcount_full
#undef __deref_opt_out_xcount_full_opt
#undef __deref_opt_out_xcount_opt
#undef __deref_opt_out_xcount_part
#undef __deref_opt_out_xcount_part_opt
#undef __deref_opt_out_z_opt
#undef __deref_opt_xcount
#undef __deref_opt_xcount_opt
#undef __deref_out
#undef __deref_out_bcount
#undef __deref_out_bcount_full
#undef __deref_out_bcount_full_opt
#undef __deref_out_bcount_nz
#undef __deref_out_bcount_nz_opt
#undef __deref_out_bcount_opt
#undef __deref_out_bcount_part
#undef __deref_out_bcount_part_opt
#undef __deref_out_bcount_z
#undef __deref_out_bcount_z_opt
#undef __deref_out_bound
#undef __deref_out_ecount
#undef __deref_out_ecount_full
#undef __deref_out_ecount_full_opt
#undef __deref_out_ecount_nz
#undef __deref_out_ecount_nz_opt
#undef __deref_out_ecount_opt
#undef __deref_out_ecount_part
#undef __deref_out_ecount_part_opt
#undef __deref_out_ecount_z
#undef __deref_out_ecount_z_opt
#undef __deref_out_nz
#undef __deref_out_nz_opt
#undef __deref_out_opt
#undef __deref_out_range
#undef __deref_out_range
#undef __deref_out_xcount
#undef __deref_out_xcount
#undef __deref_out_xcount_full
#undef __deref_out_xcount_full_opt
#undef __deref_out_xcount_opt
#undef __deref_out_xcount_part
#undef __deref_out_xcount_part_opt
#undef __deref_out_z
#undef __deref_out_z_opt
#undef __deref_volatile
#undef __deref_xcount
#undef __deref_xcount_opt
#undef __ecount
#undef __ecount_opt
#undef __elem_readableTo
#undef __elem_writableTo
#undef __encoded_array
#undef __encoded_pointer
#undef __exceptthat
#undef __fallthrough
#undef __field_bcount
#undef __field_bcount_full
#undef __field_bcount_full_opt
#undef __field_bcount_opt
#undef __field_bcount_part
#undef __field_bcount_part_opt
#undef __field_data_source
#undef __field_ecount
#undef __field_ecount_full
#undef __field_ecount_full_opt
#undef __field_ecount_opt
#undef __field_ecount_part
#undef __field_ecount_part_opt
#undef __field_encoded_array
#undef __field_encoded_pointer
#undef __field_range
#undef __field_xcount
#undef __field_xcount_full
#undef __field_xcount_full_opt
#undef __field_xcount_opt
#undef __field_xcount_part
#undef __field_xcount_part_opt
#undef __file_parser
#undef __file_parser_class
#undef __file_parser_library
#undef __format_string
#undef __format_string
#undef __gdi_entry
#undef __in
#undef __in_awcount
#undef __in_bcount
#undef __in_bcount_nz
#undef __in_bcount_nz_opt
#undef __in_bcount_opt
#undef __in_bcount_z
#undef __in_bcount_z_opt
#undef __in_bound
#undef __in_data_source
#undef __in_ecount
#undef __in_ecount_nz
#undef __in_ecount_nz_opt
#undef __in_ecount_opt
#undef __in_ecount_z
#undef __in_ecount_z_opt
#undef __in_nz
#undef __in_nz_opt
#undef __in_opt
#undef __in_range
#undef __in_xcount
#undef __in_xcount_opt
#undef __in_z
#undef __in_z_opt
#undef __inexpressible_readableTo
#undef __inexpressible_writableTo
#undef __inner_assume_bound
#undef __inner_assume_bound_dec
#undef __inner_assume_validated
#undef __inner_assume_validated_dec
#undef __inner_blocksOn
#undef __inner_bound
#undef __inner_callback
#undef __inner_checkReturn
#undef __inner_control_entrypoint
#undef __inner_data_entrypoint
#undef __inner_data_source
#undef __inner_encoded
#undef __inner_fallthrough
#undef __inner_fallthrough_dec
#undef __inner_out_validated
#undef __inner_override
#undef __inner_range
#undef __inner_success
#undef __inner_transfer
#undef __inner_typefix
#undef __inout
#undef __inout_bcount
#undef __inout_bcount_full
#undef __inout_bcount_full_opt
#undef __inout_bcount_nz
#undef __inout_bcount_nz_opt
#undef __inout_bcount_opt
#undef __inout_bcount_part
#undef __inout_bcount_part_opt
#undef __inout_bcount_z
#undef __inout_bcount_z_opt
#undef __inout_ecount
#undef __inout_ecount_full
#undef __inout_ecount_full_opt
#undef __inout_ecount_nz
#undef __inout_ecount_nz_opt
#undef __inout_ecount_opt
#undef __inout_ecount_part
#undef __inout_ecount_part_opt
#undef __inout_ecount_z
#undef __inout_ecount_z_opt
#undef __inout_ecount_z_opt
#undef __inout_nz
#undef __inout_nz_opt
#undef __inout_opt
#undef __inout_xcount
#undef __inout_xcount_full
#undef __inout_xcount_full_opt
#undef __inout_xcount_opt
#undef __inout_xcount_part
#undef __inout_xcount_part_opt
#undef __inout_z
#undef __inout_z_opt
#undef __kernel_entry
#undef __maybenull
#undef __maybereadonly
#undef __maybevalid
#undef __nonvolatile
#undef __notnull
#undef __notreadonly
#undef __notvalid
#undef __null
#undef __nullnullterminated
#undef __nullterminated
#undef __out
#undef __out_awcount
#undef __out_bcount
#undef __out_bcount_full
#undef __out_bcount_full_opt
#undef __out_bcount_nz
#undef __out_bcount_nz_opt
#undef __out_bcount_opt
#undef __out_bcount_part
#undef __out_bcount_part_opt
#undef __out_bcount_z
#undef __out_bcount_z_opt
#undef __out_bound
#undef __out_data_source
#undef __out_ecount
#undef __out_ecount_full
#undef __out_ecount_full_opt
#undef __out_ecount_nz
#undef __out_ecount_nz_opt
#undef __out_ecount_opt
#undef __out_ecount_part
#undef __out_ecount_part_opt
#undef __out_ecount_z
#undef __out_ecount_z_opt
#undef __out_has_adt_prop
#undef __out_has_type_adt_props
#undef __out_not_has_adt_prop
#undef __out_nz
#undef __out_nz_opt
#undef __out_opt
#undef __out_range
#undef __out_transfer_adt_prop
#undef __out_validated
#undef __out_xcount
#undef __out_xcount_full
#undef __out_xcount_full_opt
#undef __out_xcount_opt
#undef __out_xcount_part
#undef __out_xcount_part_opt
#undef __out_z
#undef __override
#undef __possibly_notnulltermiated
#undef __post
#undef __postcond
#undef __pre
#undef __precond
#undef __range
#undef __readableTo
#undef __readonly
#undef __refparam
#undef __reserved
#undef __rpc_entry
#undef __source_code_content
#undef __struct_bcount
#undef __struct_xcount
#undef __success
#undef __this_out_data_source
#undef __this_out_validated
#undef __transfer
#undef __type_has_adt_prop
#undef __typefix
#undef __valid
#undef __volatile
#undef __writableTo
#undef __xcount
#undef __xcount_opt
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\sqlce_oledb.h ===
//=============================================================================
// Microsoft SQL Server Compact (Version 3.5)
//
// Copyright (c)  Microsoft Corporation. All rights reserved.
//
// Component: Programmability (Native)
// 
// File:  sqlce_oledb.h
//
// File Comments:   OLE DB Native Programming Interfaces
//=============================================================================

#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/


#ifndef __SQLCE_OLEDB_H__
#define __SQLCE_OLEDB_H__


#ifndef GUIDS_ONLY

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IAccessor_FWD_DEFINED__
#define __IAccessor_FWD_DEFINED__
typedef interface IAccessor IAccessor;
#endif 	/* __IAccessor_FWD_DEFINED__ */


#ifndef __IRowset_FWD_DEFINED__
#define __IRowset_FWD_DEFINED__
typedef interface IRowset IRowset;
#endif 	/* __IRowset_FWD_DEFINED__ */


#ifndef __IRowsetInfo_FWD_DEFINED__
#define __IRowsetInfo_FWD_DEFINED__
typedef interface IRowsetInfo IRowsetInfo;
#endif 	/* __IRowsetInfo_FWD_DEFINED__ */


#ifndef __IRowsetLocate_FWD_DEFINED__
#define __IRowsetLocate_FWD_DEFINED__
typedef interface IRowsetLocate IRowsetLocate;
#endif 	/* __IRowsetLocate_FWD_DEFINED__ */


#ifndef __IRowsetResynch_FWD_DEFINED__
#define __IRowsetResynch_FWD_DEFINED__
typedef interface IRowsetResynch IRowsetResynch;
#endif 	/* __IRowsetResynch_FWD_DEFINED__ */


#ifndef __IRowsetScroll_FWD_DEFINED__
#define __IRowsetScroll_FWD_DEFINED__
typedef interface IRowsetScroll IRowsetScroll;
#endif 	/* __IRowsetScroll_FWD_DEFINED__ */


#ifndef __IChapteredRowset_FWD_DEFINED__
#define __IChapteredRowset_FWD_DEFINED__
typedef interface IChapteredRowset IChapteredRowset;
#endif 	/* __IChapteredRowset_FWD_DEFINED__ */


#ifndef __IRowsetFind_FWD_DEFINED__
#define __IRowsetFind_FWD_DEFINED__
typedef interface IRowsetFind IRowsetFind;
#endif 	/* __IRowsetFind_FWD_DEFINED__ */


#ifndef __IRowPosition_FWD_DEFINED__
#define __IRowPosition_FWD_DEFINED__
typedef interface IRowPosition IRowPosition;
#endif 	/* __IRowPosition_FWD_DEFINED__ */


#ifndef __IRowPositionChange_FWD_DEFINED__
#define __IRowPositionChange_FWD_DEFINED__
typedef interface IRowPositionChange IRowPositionChange;
#endif 	/* __IRowPositionChange_FWD_DEFINED__ */


#ifndef __IViewRowset_FWD_DEFINED__
#define __IViewRowset_FWD_DEFINED__
typedef interface IViewRowset IViewRowset;
#endif 	/* __IViewRowset_FWD_DEFINED__ */


#ifndef __IViewChapter_FWD_DEFINED__
#define __IViewChapter_FWD_DEFINED__
typedef interface IViewChapter IViewChapter;
#endif 	/* __IViewChapter_FWD_DEFINED__ */


#ifndef __IViewSort_FWD_DEFINED__
#define __IViewSort_FWD_DEFINED__
typedef interface IViewSort IViewSort;
#endif 	/* __IViewSort_FWD_DEFINED__ */


#ifndef __IViewFilter_FWD_DEFINED__
#define __IViewFilter_FWD_DEFINED__
typedef interface IViewFilter IViewFilter;
#endif 	/* __IViewFilter_FWD_DEFINED__ */


#ifndef __IRowsetView_FWD_DEFINED__
#define __IRowsetView_FWD_DEFINED__
typedef interface IRowsetView IRowsetView;
#endif 	/* __IRowsetView_FWD_DEFINED__ */


#ifndef __IRowsetExactScroll_FWD_DEFINED__
#define __IRowsetExactScroll_FWD_DEFINED__
typedef interface IRowsetExactScroll IRowsetExactScroll;
#endif 	/* __IRowsetExactScroll_FWD_DEFINED__ */


#ifndef __IRowsetChange_FWD_DEFINED__
#define __IRowsetChange_FWD_DEFINED__
typedef interface IRowsetChange IRowsetChange;
#endif 	/* __IRowsetChange_FWD_DEFINED__ */


#ifndef __IRowsetUpdate_FWD_DEFINED__
#define __IRowsetUpdate_FWD_DEFINED__
typedef interface IRowsetUpdate IRowsetUpdate;
#endif 	/* __IRowsetUpdate_FWD_DEFINED__ */


#ifndef __IRowsetIdentity_FWD_DEFINED__
#define __IRowsetIdentity_FWD_DEFINED__
typedef interface IRowsetIdentity IRowsetIdentity;
#endif 	/* __IRowsetIdentity_FWD_DEFINED__ */


#ifndef __IRowsetNotify_FWD_DEFINED__
#define __IRowsetNotify_FWD_DEFINED__
typedef interface IRowsetNotify IRowsetNotify;
#endif 	/* __IRowsetNotify_FWD_DEFINED__ */


#ifndef __IRowsetIndex_FWD_DEFINED__
#define __IRowsetIndex_FWD_DEFINED__
typedef interface IRowsetIndex IRowsetIndex;
#endif 	/* __IRowsetIndex_FWD_DEFINED__ */


#ifndef __ICommand_FWD_DEFINED__
#define __ICommand_FWD_DEFINED__
typedef interface ICommand ICommand;
#endif 	/* __ICommand_FWD_DEFINED__ */


#ifndef __IMultipleResults_FWD_DEFINED__
#define __IMultipleResults_FWD_DEFINED__
typedef interface IMultipleResults IMultipleResults;
#endif 	/* __IMultipleResults_FWD_DEFINED__ */


#ifndef __IConvertType_FWD_DEFINED__
#define __IConvertType_FWD_DEFINED__
typedef interface IConvertType IConvertType;
#endif 	/* __IConvertType_FWD_DEFINED__ */


#ifndef __ICommandPrepare_FWD_DEFINED__
#define __ICommandPrepare_FWD_DEFINED__
typedef interface ICommandPrepare ICommandPrepare;
#endif 	/* __ICommandPrepare_FWD_DEFINED__ */


#ifndef __ICommandProperties_FWD_DEFINED__
#define __ICommandProperties_FWD_DEFINED__
typedef interface ICommandProperties ICommandProperties;
#endif 	/* __ICommandProperties_FWD_DEFINED__ */


#ifndef __ICommandText_FWD_DEFINED__
#define __ICommandText_FWD_DEFINED__
typedef interface ICommandText ICommandText;
#endif 	/* __ICommandText_FWD_DEFINED__ */


#ifndef __ICommandWithParameters_FWD_DEFINED__
#define __ICommandWithParameters_FWD_DEFINED__
typedef interface ICommandWithParameters ICommandWithParameters;
#endif 	/* __ICommandWithParameters_FWD_DEFINED__ */


#ifndef __IColumnsRowset_FWD_DEFINED__
#define __IColumnsRowset_FWD_DEFINED__
typedef interface IColumnsRowset IColumnsRowset;
#endif 	/* __IColumnsRowset_FWD_DEFINED__ */


#ifndef __IColumnsInfo_FWD_DEFINED__
#define __IColumnsInfo_FWD_DEFINED__
typedef interface IColumnsInfo IColumnsInfo;
#endif 	/* __IColumnsInfo_FWD_DEFINED__ */


#ifndef __IDBCreateCommand_FWD_DEFINED__
#define __IDBCreateCommand_FWD_DEFINED__
typedef interface IDBCreateCommand IDBCreateCommand;
#endif 	/* __IDBCreateCommand_FWD_DEFINED__ */


#ifndef __IDBCreateSession_FWD_DEFINED__
#define __IDBCreateSession_FWD_DEFINED__
typedef interface IDBCreateSession IDBCreateSession;
#endif 	/* __IDBCreateSession_FWD_DEFINED__ */


#ifndef __ISourcesRowset_FWD_DEFINED__
#define __ISourcesRowset_FWD_DEFINED__
typedef interface ISourcesRowset ISourcesRowset;
#endif 	/* __ISourcesRowset_FWD_DEFINED__ */


#ifndef __IDBProperties_FWD_DEFINED__
#define __IDBProperties_FWD_DEFINED__
typedef interface IDBProperties IDBProperties;
#endif 	/* __IDBProperties_FWD_DEFINED__ */


#ifndef __IDBInitialize_FWD_DEFINED__
#define __IDBInitialize_FWD_DEFINED__
typedef interface IDBInitialize IDBInitialize;
#endif 	/* __IDBInitialize_FWD_DEFINED__ */


#ifndef __IDBInfo_FWD_DEFINED__
#define __IDBInfo_FWD_DEFINED__
typedef interface IDBInfo IDBInfo;
#endif 	/* __IDBInfo_FWD_DEFINED__ */


#ifndef __IDBDataSourceAdmin_FWD_DEFINED__
#define __IDBDataSourceAdmin_FWD_DEFINED__
typedef interface IDBDataSourceAdmin IDBDataSourceAdmin;
#endif 	/* __IDBDataSourceAdmin_FWD_DEFINED__ */


#ifndef __IDBAsynchNotify_FWD_DEFINED__
#define __IDBAsynchNotify_FWD_DEFINED__
typedef interface IDBAsynchNotify IDBAsynchNotify;
#endif 	/* __IDBAsynchNotify_FWD_DEFINED__ */


#ifndef __IDBAsynchStatus_FWD_DEFINED__
#define __IDBAsynchStatus_FWD_DEFINED__
typedef interface IDBAsynchStatus IDBAsynchStatus;
#endif 	/* __IDBAsynchStatus_FWD_DEFINED__ */


#ifndef __ISessionProperties_FWD_DEFINED__
#define __ISessionProperties_FWD_DEFINED__
typedef interface ISessionProperties ISessionProperties;
#endif 	/* __ISessionProperties_FWD_DEFINED__ */


#ifndef __IIndexDefinition_FWD_DEFINED__
#define __IIndexDefinition_FWD_DEFINED__
typedef interface IIndexDefinition IIndexDefinition;
#endif 	/* __IIndexDefinition_FWD_DEFINED__ */


#ifndef __ITableDefinition_FWD_DEFINED__
#define __ITableDefinition_FWD_DEFINED__
typedef interface ITableDefinition ITableDefinition;
#endif 	/* __ITableDefinition_FWD_DEFINED__ */


#ifndef __IOpenRowset_FWD_DEFINED__
#define __IOpenRowset_FWD_DEFINED__
typedef interface IOpenRowset IOpenRowset;
#endif 	/* __IOpenRowset_FWD_DEFINED__ */


#ifndef __IDBSchemaRowset_FWD_DEFINED__
#define __IDBSchemaRowset_FWD_DEFINED__
typedef interface IDBSchemaRowset IDBSchemaRowset;
#endif 	/* __IDBSchemaRowset_FWD_DEFINED__ */


#ifndef __IMDDataset_FWD_DEFINED__
#define __IMDDataset_FWD_DEFINED__
typedef interface IMDDataset IMDDataset;
#endif 	/* __IMDDataset_FWD_DEFINED__ */


#ifndef __IMDFind_FWD_DEFINED__
#define __IMDFind_FWD_DEFINED__
typedef interface IMDFind IMDFind;
#endif 	/* __IMDFind_FWD_DEFINED__ */


#ifndef __IMDRangeRowset_FWD_DEFINED__
#define __IMDRangeRowset_FWD_DEFINED__
typedef interface IMDRangeRowset IMDRangeRowset;
#endif 	/* __IMDRangeRowset_FWD_DEFINED__ */


#ifndef __IAlterTable_FWD_DEFINED__
#define __IAlterTable_FWD_DEFINED__
typedef interface IAlterTable IAlterTable;
#endif 	/* __IAlterTable_FWD_DEFINED__ */


#ifndef __IAlterIndex_FWD_DEFINED__
#define __IAlterIndex_FWD_DEFINED__
typedef interface IAlterIndex IAlterIndex;
#endif 	/* __IAlterIndex_FWD_DEFINED__ */


#ifndef __IRowsetChapterMember_FWD_DEFINED__
#define __IRowsetChapterMember_FWD_DEFINED__
typedef interface IRowsetChapterMember IRowsetChapterMember;
#endif 	/* __IRowsetChapterMember_FWD_DEFINED__ */


#ifndef __ICommandPersist_FWD_DEFINED__
#define __ICommandPersist_FWD_DEFINED__
typedef interface ICommandPersist ICommandPersist;
#endif 	/* __ICommandPersist_FWD_DEFINED__ */


#ifndef __IRowsetRefresh_FWD_DEFINED__
#define __IRowsetRefresh_FWD_DEFINED__
typedef interface IRowsetRefresh IRowsetRefresh;
#endif 	/* __IRowsetRefresh_FWD_DEFINED__ */


#ifndef __IParentRowset_FWD_DEFINED__
#define __IParentRowset_FWD_DEFINED__
typedef interface IParentRowset IParentRowset;
#endif 	/* __IParentRowset_FWD_DEFINED__ */


#ifndef __IErrorRecords_FWD_DEFINED__
#define __IErrorRecords_FWD_DEFINED__
typedef interface IErrorRecords IErrorRecords;
#endif 	/* __IErrorRecords_FWD_DEFINED__ */


#ifndef __IErrorLookup_FWD_DEFINED__
#define __IErrorLookup_FWD_DEFINED__
typedef interface IErrorLookup IErrorLookup;
#endif 	/* __IErrorLookup_FWD_DEFINED__ */


#ifndef __ISQLErrorInfo_FWD_DEFINED__
#define __ISQLErrorInfo_FWD_DEFINED__
typedef interface ISQLErrorInfo ISQLErrorInfo;
#endif 	/* __ISQLErrorInfo_FWD_DEFINED__ */


#ifndef __IGetDataSource_FWD_DEFINED__
#define __IGetDataSource_FWD_DEFINED__
typedef interface IGetDataSource IGetDataSource;
#endif 	/* __IGetDataSource_FWD_DEFINED__ */


#ifndef __ITransactionLocal_FWD_DEFINED__
#define __ITransactionLocal_FWD_DEFINED__
typedef interface ITransactionLocal ITransactionLocal;
#endif 	/* __ITransactionLocal_FWD_DEFINED__ */


#ifndef __ITransactionJoin_FWD_DEFINED__
#define __ITransactionJoin_FWD_DEFINED__
typedef interface ITransactionJoin ITransactionJoin;
#endif 	/* __ITransactionJoin_FWD_DEFINED__ */


#ifndef __ITransactionObject_FWD_DEFINED__
#define __ITransactionObject_FWD_DEFINED__
typedef interface ITransactionObject ITransactionObject;
#endif 	/* __ITransactionObject_FWD_DEFINED__ */


#ifndef __ITrusteeAdmin_FWD_DEFINED__
#define __ITrusteeAdmin_FWD_DEFINED__
typedef interface ITrusteeAdmin ITrusteeAdmin;
#endif 	/* __ITrusteeAdmin_FWD_DEFINED__ */


#ifndef __ITrusteeGroupAdmin_FWD_DEFINED__
#define __ITrusteeGroupAdmin_FWD_DEFINED__
typedef interface ITrusteeGroupAdmin ITrusteeGroupAdmin;
#endif 	/* __ITrusteeGroupAdmin_FWD_DEFINED__ */


#ifndef __IObjectAccessControl_FWD_DEFINED__
#define __IObjectAccessControl_FWD_DEFINED__
typedef interface IObjectAccessControl IObjectAccessControl;
#endif 	/* __IObjectAccessControl_FWD_DEFINED__ */


#ifndef __ISecurityInfo_FWD_DEFINED__
#define __ISecurityInfo_FWD_DEFINED__
typedef interface ISecurityInfo ISecurityInfo;
#endif 	/* __ISecurityInfo_FWD_DEFINED__ */


#ifndef __ITableCreation_FWD_DEFINED__
#define __ITableCreation_FWD_DEFINED__
typedef interface ITableCreation ITableCreation;
#endif 	/* __ITableCreation_FWD_DEFINED__ */


#ifndef __ITableDefinitionWithConstraints_FWD_DEFINED__
#define __ITableDefinitionWithConstraints_FWD_DEFINED__
typedef interface ITableDefinitionWithConstraints ITableDefinitionWithConstraints;
#endif 	/* __ITableDefinitionWithConstraints_FWD_DEFINED__ */


#ifndef __IRow_FWD_DEFINED__
#define __IRow_FWD_DEFINED__
typedef interface IRow IRow;
#endif 	/* __IRow_FWD_DEFINED__ */


#ifndef __IRowChange_FWD_DEFINED__
#define __IRowChange_FWD_DEFINED__
typedef interface IRowChange IRowChange;
#endif 	/* __IRowChange_FWD_DEFINED__ */


#ifndef __IRowSchemaChange_FWD_DEFINED__
#define __IRowSchemaChange_FWD_DEFINED__
typedef interface IRowSchemaChange IRowSchemaChange;
#endif 	/* __IRowSchemaChange_FWD_DEFINED__ */


#ifndef __IGetRow_FWD_DEFINED__
#define __IGetRow_FWD_DEFINED__
typedef interface IGetRow IGetRow;
#endif 	/* __IGetRow_FWD_DEFINED__ */


#ifndef __IBindResource_FWD_DEFINED__
#define __IBindResource_FWD_DEFINED__
typedef interface IBindResource IBindResource;
#endif 	/* __IBindResource_FWD_DEFINED__ */


#ifndef __IScopedOperations_FWD_DEFINED__
#define __IScopedOperations_FWD_DEFINED__
typedef interface IScopedOperations IScopedOperations;
#endif 	/* __IScopedOperations_FWD_DEFINED__ */


#ifndef __ICreateRow_FWD_DEFINED__
#define __ICreateRow_FWD_DEFINED__
typedef interface ICreateRow ICreateRow;
#endif 	/* __ICreateRow_FWD_DEFINED__ */


#ifndef __IDBBinderProperties_FWD_DEFINED__
#define __IDBBinderProperties_FWD_DEFINED__
typedef interface IDBBinderProperties IDBBinderProperties;
#endif 	/* __IDBBinderProperties_FWD_DEFINED__ */


#ifndef __IColumnsInfo2_FWD_DEFINED__
#define __IColumnsInfo2_FWD_DEFINED__
typedef interface IColumnsInfo2 IColumnsInfo2;
#endif 	/* __IColumnsInfo2_FWD_DEFINED__ */


#ifndef __IRegisterProvider_FWD_DEFINED__
#define __IRegisterProvider_FWD_DEFINED__
typedef interface IRegisterProvider IRegisterProvider;
#endif 	/* __IRegisterProvider_FWD_DEFINED__ */


#ifndef __IGetSession_FWD_DEFINED__
#define __IGetSession_FWD_DEFINED__
typedef interface IGetSession IGetSession;
#endif 	/* __IGetSession_FWD_DEFINED__ */


#ifndef __IGetSourceRow_FWD_DEFINED__
#define __IGetSourceRow_FWD_DEFINED__
typedef interface IGetSourceRow IGetSourceRow;
#endif 	/* __IGetSourceRow_FWD_DEFINED__ */


#ifndef __IRowsetCurrentIndex_FWD_DEFINED__
#define __IRowsetCurrentIndex_FWD_DEFINED__
typedef interface IRowsetCurrentIndex IRowsetCurrentIndex;
#endif 	/* __IRowsetCurrentIndex_FWD_DEFINED__ */


/* header files for imported files */
#include "wtypes.h"
#include "oaidl.h"
#include "ocidl.h"
#ifndef UNDER_CE
#include "propidl.h"
#include "urlmon.h"
#endif
#include "transact.h"

void  * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void  * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_oledb_0000
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 


//+---------------------------------------------------------------------------
//
//  Microsoft OLE DB
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//----------------------------------------------------------------------------

#ifdef _WIN64
#include <pshpack8.h>	// 8-byte structure packing
#else
#include <pshpack2.h>	// 2-byte structure packing
#endif

#ifdef _WIN64

// Length of a non-character object, size
typedef ULONGLONG			DBLENGTH;

// Offset within a rowset
typedef LONGLONG			DBROWOFFSET;

// Number of rows
typedef LONGLONG			DBROWCOUNT;

typedef ULONGLONG			DBCOUNTITEM;

// Ordinal (column number, etc.)
typedef ULONGLONG			DBORDINAL;

typedef LONGLONG			DB_LORDINAL;

// Bookmarks
typedef ULONGLONG			DBBKMARK;
// Offset in the buffer

typedef ULONGLONG			DBBYTEOFFSET;
// Reference count of each row/accessor  handle

typedef ULONG				DBREFCOUNT;

// Parameters
typedef ULONGLONG			DB_UPARAMS;

typedef LONGLONG			DB_LPARAMS;

// hash values corresponding to the elements (bookmarks)
typedef DWORDLONG			DBHASHVALUE;

// For reserve
typedef DWORDLONG			DB_DWRESERVE;

typedef LONGLONG			DB_LRESERVE;

typedef ULONGLONG			DB_URESERVE;

#else //_WIN32

// Length of a non-character object, size
typedef ULONG DBLENGTH;

// Offset within a rowset
typedef LONG DBROWOFFSET;

// Number of rows
typedef LONG DBROWCOUNT;

typedef ULONG DBCOUNTITEM;

// Ordinal (column number, etc.)
typedef ULONG DBORDINAL;

typedef LONG DB_LORDINAL;

// Bookmarks
typedef ULONG DBBKMARK;

// Offset in the buffer
typedef ULONG DBBYTEOFFSET;

// Reference count of each row handle
typedef ULONG DBREFCOUNT;

// Parameters
typedef ULONG DB_UPARAMS;

typedef LONG DB_LPARAMS;

// hash values corresponding to the elements (bookmarks)
typedef DWORD DBHASHVALUE;

// For reserve
typedef DWORD DB_DWRESERVE;

typedef LONG DB_LRESERVE;

typedef ULONG DB_URESERVE;

#endif	// _WIN64

extern RPC_IF_HANDLE __MIDL_itf_oledb_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_oledb_0000_v0_0_s_ifspec;

#ifndef __DBStructureDefinitions_INTERFACE_DEFINED__
#define __DBStructureDefinitions_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: DBStructureDefinitions
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [auto_handle][unique][uuid] */ 


#ifndef UNALIGNED
#if defined(_MIPS_) || defined(_ALPHA_) || defined(_PPC_)
#define UNALIGNED __unaligned
#else
#define UNALIGNED
#endif
#endif //UNALIGNED
#undef OLEDBDECLSPEC
#if _MSC_VER >= 1100 && (!defined(SHx) || (defined(SHx) && _MSC_VER >= 1200))
#define OLEDBDECLSPEC __declspec(selectany)
#else
#define OLEDBDECLSPEC 
#endif //_MSC_VER
typedef DWORD DBKIND;


enum DBKINDENUM
    {	DBKIND_GUID_NAME	= 0,
	DBKIND_GUID_PROPID	= DBKIND_GUID_NAME + 1,
	DBKIND_NAME	= DBKIND_GUID_PROPID + 1,
	DBKIND_PGUID_NAME	= DBKIND_NAME + 1,
	DBKIND_PGUID_PROPID	= DBKIND_PGUID_NAME + 1,
	DBKIND_PROPID	= DBKIND_PGUID_PROPID + 1,
	DBKIND_GUID	= DBKIND_PROPID + 1
    };

#if defined(MIPSII_FP) || defined(MIPSIV) || defined(MIPSIV_FP)
#pragma pack(push,8)
#endif

typedef struct  tagDBID
    {
    /* [switch_is][switch_type] */ union 
        {
        /* [case()] */ GUID guid;
        /* [case()] */ GUID  *pguid;
        /* [default] */  /* Empty union arm */ 
        }	uGuid;
    DBKIND eKind;
    /* [switch_is][switch_type] */ union 
        {
        /* [case()] */ LPOLESTR pwszName;
        /* [case()] */ ULONG ulPropid;
        /* [default] */  /* Empty union arm */ 
        }	uName;
    }	DBID;

#if defined(MIPSII_FP) || defined(MIPSIV) || defined(MIPSIV_FP)
#pragma pack(pop)
#endif

typedef struct  tagDB_NUMERIC
    {
    BYTE precision;
    BYTE scale;
    BYTE sign;
    BYTE val[ 16 ];
    }	DB_NUMERIC;

#ifndef _ULONGLONG_
typedef hyper LONGLONG;

typedef MIDL_uhyper ULONGLONG;

typedef LONGLONG __RPC_FAR *PLONGLONG;

typedef ULONGLONG __RPC_FAR *PULONGLONG;

#endif // _ULONGLONG_
#ifndef DECIMAL_NEG
#ifndef DECIMAL_SETZERO
typedef struct tagDEC {
    USHORT wReserved;
    union {
        struct {
            BYTE scale;
            BYTE sign;
        };
        USHORT signscale;
    };
    ULONG Hi32;
    union {
        struct {
#ifdef _MAC
            ULONG Mid32;
            ULONG Lo32;
#else
            ULONG Lo32;
            ULONG Mid32;
#endif
        };
        ULONGLONG Lo64;
    };
} DECIMAL;
#define DECIMAL_NEG ((BYTE)0x80)
#define DECIMAL_SETZERO(dec) {(dec).Lo64 = 0; (dec).Hi32 = 0; (dec).signscale = 0;}
#endif // DECIMAL_SETZERO
#endif // DECIMAL_NEG
typedef struct  tagDBVECTOR
    {
    DBLENGTH size;
    /* [size_is] */ void  *ptr;
    }	DBVECTOR;

typedef struct  tagDBDATE
    {
    SHORT year;
    USHORT month;
    USHORT day;
    }	DBDATE;

typedef struct  tagDBTIME
    {
    USHORT hour;
    USHORT minute;
    USHORT second;
    }	DBTIME;

typedef struct  tagDBTIMESTAMP
    {
    SHORT year;
    USHORT month;
    USHORT day;
    USHORT hour;
    USHORT minute;
    USHORT second;
    ULONG fraction;
    }	DBTIMESTAMP;

#if !defined(_WINBASE_) && !defined(_FILETIME_)
#define _FILETIME_
typedef struct _FILETIME {
		DWORD dwLowDateTime;
		DWORD dwHighDateTime;
     }	FILETIME;
#endif // !_FILETIME
typedef signed char SBYTE;

typedef struct  tagDB_VARNUMERIC
    {
    BYTE precision;
    SBYTE scale;
    BYTE sign;
    BYTE val[ 1 ];
    }	DB_VARNUMERIC;

typedef struct  _SEC_OBJECT_ELEMENT
    {
    GUID guidObjectType;
    DBID ObjectID;
    }	SEC_OBJECT_ELEMENT;

typedef struct  _SEC_OBJECT
    {
    DWORD cObjects;
    /* [size_is] */ SEC_OBJECT_ELEMENT  *prgObjects;
    }	SEC_OBJECT;

typedef struct  tagDBIMPLICITSESSION
    {
    IUnknown  *pUnkOuter;
    IID  *piid;
    IUnknown  *pSession;
    }	DBIMPLICITSESSION;

typedef WORD DBTYPE;


enum DBTYPEENUM
    {	DBTYPE_EMPTY	= 0,
	DBTYPE_NULL	= 1,
	DBTYPE_I2	= 2,
	DBTYPE_I4	= 3,
	DBTYPE_R4	= 4,
	DBTYPE_R8	= 5,
	DBTYPE_CY	= 6,
	DBTYPE_DATE	= 7,
	DBTYPE_BSTR	= 8,
	DBTYPE_IDISPATCH	= 9,
	DBTYPE_ERROR	= 10,
	DBTYPE_BOOL	= 11,
	DBTYPE_VARIANT	= 12,
	DBTYPE_IUNKNOWN	= 13,
	DBTYPE_DECIMAL	= 14,
	DBTYPE_UI1	= 17,
	DBTYPE_ARRAY	= 0x2000,
	DBTYPE_BYREF	= 0x4000,
	DBTYPE_I1	= 16,
	DBTYPE_UI2	= 18,
	DBTYPE_UI4	= 19,
	DBTYPE_I8	= 20,
	DBTYPE_UI8	= 21,
	DBTYPE_GUID	= 72,
	DBTYPE_VECTOR	= 0x1000,
	DBTYPE_RESERVED	= 0x8000,
	DBTYPE_BYTES	= 128,
	DBTYPE_STR	= 129,
	DBTYPE_WSTR	= 130,
	DBTYPE_NUMERIC	= 131,
	DBTYPE_UDT	= 132,
	DBTYPE_DBDATE	= 133,
	DBTYPE_DBTIME	= 134,
	DBTYPE_DBTIMESTAMP	= 135
    };
#ifdef _WIN64
#define	DBTYPEFOR_DBLENGTH		DBTYPE_UI8
#define	DBTYPEFOR_DBROWCOUNT	DBTYPE_I8
#define	DBTYPEFOR_DBORDINAL		DBTYPE_UI8
#else
#define	DBTYPEFOR_DBLENGTH		DBTYPE_UI4
#define	DBTYPEFOR_DBROWCOUNT	DBTYPE_I4
#define	DBTYPEFOR_DBORDINAL		DBTYPE_UI4
#endif

enum DBTYPEENUM15
    {	DBTYPE_HCHAPTER	= 136
    };

enum DBTYPEENUM20
    {	DBTYPE_FILETIME	= 64,
	DBTYPE_PROPVARIANT	= 138,
	DBTYPE_VARNUMERIC	= 139
    };

typedef DWORD DBPART;


enum DBPARTENUM
    {	DBPART_INVALID	= 0,
	DBPART_VALUE	= 0x1,
	DBPART_LENGTH	= 0x2,
	DBPART_STATUS	= 0x4
    };
typedef DWORD DBPARAMIO;


enum DBPARAMIOENUM
    {	DBPARAMIO_NOTPARAM	= 0,
	DBPARAMIO_INPUT	= 0x1,
	DBPARAMIO_OUTPUT	= 0x2
    };

typedef DWORD DBBINDFLAG;

enum DBBINDFLAGENUM
    {	DBBINDFLAG_HTML	= 0x1
    };

typedef DWORD DBMEMOWNER;


enum DBMEMOWNERENUM
    {	DBMEMOWNER_CLIENTOWNED	= 0,
	DBMEMOWNER_PROVIDEROWNED	= 0x1
    };

typedef struct  tagDBOBJECT
    {
    DWORD dwFlags;
    IID iid;
    }	DBOBJECT;

typedef DWORD DBSTATUS;

enum DBSTATUSENUM
    {	DBSTATUS_S_OK	= 0,
	DBSTATUS_E_BADACCESSOR	= 1,
	DBSTATUS_E_CANTCONVERTVALUE	= 2,
	DBSTATUS_S_ISNULL	= 3,
	DBSTATUS_S_TRUNCATED	= 4,
	DBSTATUS_E_SIGNMISMATCH	= 5,
	DBSTATUS_E_DATAOVERFLOW	= 6,
	DBSTATUS_E_CANTCREATE	= 7,
	DBSTATUS_E_UNAVAILABLE	= 8,
	DBSTATUS_E_PERMISSIONDENIED	= 9,
	DBSTATUS_E_INTEGRITYVIOLATION	= 10,
	DBSTATUS_E_SCHEMAVIOLATION	= 11,
	DBSTATUS_E_BADSTATUS	= 12,
	DBSTATUS_S_DEFAULT	= 13
    };

enum DBSTATUSENUM20
    {	MDSTATUS_S_CELLEMPTY	= 14,
	DBSTATUS_S_IGNORE	= 15
    };

enum DBSTATUSENUM21
    {	DBSTATUS_E_DOESNOTEXIST	= 16,
	DBSTATUS_E_INVALIDURL	= 17,
	DBSTATUS_E_RESOURCELOCKED	= 18,
	DBSTATUS_E_RESOURCEEXISTS	= 19,
	DBSTATUS_E_CANNOTCOMPLETE	= 20,
	DBSTATUS_E_VOLUMENOTFOUND	= 21,
	DBSTATUS_E_OUTOFSPACE	= 22,
	DBSTATUS_S_CANNOTDELETESOURCE	= 23,
	DBSTATUS_E_READONLY	= 24,
	DBSTATUS_E_RESOURCEOUTOFSCOPE	= 25,
	DBSTATUS_S_ALREADYEXISTS	= 26
    };
typedef DWORD DBBINDURLFLAG;


enum DBBINDURLFLAGENUM
    {	DBBINDURLFLAG_READ	= 0x1L,
	DBBINDURLFLAG_WRITE	= 0x2L,
	DBBINDURLFLAG_READWRITE	= 0x3L,
	DBBINDURLFLAG_SHARE_DENY_READ	= 0x4L,
	DBBINDURLFLAG_SHARE_DENY_WRITE	= 0x8L,
	DBBINDURLFLAG_SHARE_EXCLUSIVE	= 0xcL,
	DBBINDURLFLAG_SHARE_DENY_NONE	= 0x10L,
	DBBINDURLFLAG_ASYNCHRONOUS	= 0x1000L,
	DBBINDURLFLAG_COLLECTION	= 0x2000L,
	DBBINDURLFLAG_DELAYFETCHSTREAM	= 0x4000L,
	DBBINDURLFLAG_DELAYFETCHCOLUMNS	= 0x8000L,
	DBBINDURLFLAG_RECURSIVE	= 0x400000L,
	DBBINDURLFLAG_OUTPUT	= 0x800000L,
	DBBINDURLFLAG_WAITFORINIT	= 0x1000000L,
	DBBINDURLFLAG_OPENIFEXISTS	= 0x2000000L,
	DBBINDURLFLAG_OVERWRITE	= 0x4000000L,
	DBBINDURLFLAG_ISSTRUCTUREDDOCUMENT	= 0x8000000L
    };
typedef DWORD DBBINDURLSTATUS;


enum DBBINDURLSTATUSENUM
    {	DBBINDURLSTATUS_S_OK	= 0L,
    DBBINDURLSTATUS_S_DENYNOTSUPPORTED	= 0x1L,
	DBBINDURLSTATUS_S_DENYTYPENOTSUPPORTED	= 0x4L,
	DBBINDURLSTATUS_S_REDIRECTED	= 0x8L
    };
typedef struct  tagDBBINDEXT
    {
    /* [size_is] */ BYTE  *pExtension;
    DBCOUNTITEM ulExtension;
    }	DBBINDEXT;

typedef struct  tagDBBINDING
    {
    DBORDINAL iOrdinal;
    DBBYTEOFFSET obValue;
    DBBYTEOFFSET obLength;
    DBBYTEOFFSET obStatus;
    ITypeInfo  *pTypeInfo;
    DBOBJECT  *pObject;
    DBBINDEXT  *pBindExt;
    DBPART dwPart;
    DBMEMOWNER dwMemOwner;
    DBPARAMIO eParamIO;
    DBLENGTH cbMaxLen;
    DWORD dwFlags;
    DBTYPE wType;
    BYTE bPrecision;
    BYTE bScale;
    }	DBBINDING;

typedef DWORD DBROWSTATUS;


enum DBROWSTATUSENUM
    {	DBROWSTATUS_S_OK	= 0,
	DBROWSTATUS_S_MULTIPLECHANGES	= 2,
	DBROWSTATUS_S_PENDINGCHANGES	= 3,
	DBROWSTATUS_E_CANCELED	= 4,
	DBROWSTATUS_E_CANTRELEASE	= 6,
	DBROWSTATUS_E_CONCURRENCYVIOLATION	= 7,
	DBROWSTATUS_E_DELETED	= 8,
	DBROWSTATUS_E_PENDINGINSERT	= 9,
	DBROWSTATUS_E_NEWLYINSERTED	= 10,
	DBROWSTATUS_E_INTEGRITYVIOLATION	= 11,
	DBROWSTATUS_E_INVALID	= 12,
	DBROWSTATUS_E_MAXPENDCHANGESEXCEEDED	= 13,
	DBROWSTATUS_E_OBJECTOPEN	= 14,
	DBROWSTATUS_E_OUTOFMEMORY	= 15,
	DBROWSTATUS_E_PERMISSIONDENIED	= 16,
	DBROWSTATUS_E_LIMITREACHED	= 17,
	DBROWSTATUS_E_SCHEMAVIOLATION	= 18,
	DBROWSTATUS_E_FAIL	= 19
    };

enum DBROWSTATUSENUM20
    {	DBROWSTATUS_S_NOCHANGE	= 20
    };

typedef ULONG_PTR HACCESSOR;

#define DB_NULL_HACCESSOR 0x00 // deprecated; use DB_INVALID_HACCESSOR instead
#define DB_INVALID_HACCESSOR 0x00
typedef ULONG_PTR HROW;

#define DB_NULL_HROW 0x00
typedef ULONG_PTR HWATCHREGION;

#define DBWATCHREGION_NULL NULL
typedef ULONG_PTR HCHAPTER;

#define DB_NULL_HCHAPTER 0x00
#define DB_INVALID_HCHAPTER 0x00	// deprecated; use DB_NULL_HCHAPTER instead
typedef struct  tagDBFAILUREINFO
    {
    HROW hRow;
    DBORDINAL iColumn;
    HRESULT failure;
    }	DBFAILUREINFO;

typedef DWORD DBCOLUMNFLAGS;


enum DBCOLUMNFLAGSENUM
    {	DBCOLUMNFLAGS_ISBOOKMARK	= 0x1,
	DBCOLUMNFLAGS_MAYDEFER	= 0x2,
	DBCOLUMNFLAGS_WRITE	= 0x4,
	DBCOLUMNFLAGS_WRITEUNKNOWN	= 0x8,
	DBCOLUMNFLAGS_ISFIXEDLENGTH	= 0x10,
	DBCOLUMNFLAGS_ISNULLABLE	= 0x20,
	DBCOLUMNFLAGS_MAYBENULL	= 0x40,
	DBCOLUMNFLAGS_ISLONG	= 0x80,
	DBCOLUMNFLAGS_ISROWID	= 0x100,
	DBCOLUMNFLAGS_ISROWVER	= 0x200,
	DBCOLUMNFLAGS_CACHEDEFERRED	= 0x1000
    };

enum DBCOLUMNFLAGSENUM20
    {	DBCOLUMNFLAGS_SCALEISNEGATIVE	= 0x4000,
	DBCOLUMNFLAGS_KEYCOLUMN	= 0x8000
    };

enum DBCOLUMNFLAGS15ENUM
    {	DBCOLUMNFLAGS_ISCHAPTER	= 0x2000
    };

enum DBCOLUMNFLAGSENUM21
    {	DBCOLUMNFLAGS_ISROWURL	= 0x10000,
	DBCOLUMNFLAGS_ISDEFAULTSTREAM	= 0x20000,
	DBCOLUMNFLAGS_ISCOLLECTION	= 0x40000
    };

typedef struct  tagDBCOLUMNINFO
    {
    LPOLESTR pwszName;
    ITypeInfo  *pTypeInfo;
    DBORDINAL iOrdinal;
    DBCOLUMNFLAGS dwFlags;
    DBLENGTH ulColumnSize;
    DBTYPE wType;
    BYTE bPrecision;
    BYTE bScale;
    DBID columnid;
    }	DBCOLUMNINFO;

typedef 
enum tagDBBOOKMARK
    {	DBBMK_INVALID	= 0,
	DBBMK_FIRST	= DBBMK_INVALID + 1,
	DBBMK_LAST	= DBBMK_FIRST + 1
    }	DBBOOKMARK;

#define STD_BOOKMARKLENGTH 1
#ifdef __cplusplus
inline BOOL IsEqualGUIDBase(const GUID &rguid1, const GUID &rguid2)
{ return !memcmp(&(rguid1.Data2), &(rguid2.Data2), sizeof(GUID) - sizeof(rguid1.Data1)); }
#else // !__cplusplus
#define IsEqualGuidBase(rguid1, rguid2) (!memcmp(&((rguid1).Data2), &((rguid2).Data2), sizeof(GUID) - sizeof((rguid1).Data1)))
#endif // __cplusplus
#ifdef _WIN64

#define DB_INVALIDCOLUMN _UI64_MAX

#else
#define DB_INVALIDCOLUMN ULONG_MAX
#endif	// _WIN64
#define DBCIDGUID   {0x0C733A81L,0x2A1C,0x11CE,{0xAD,0xE5,0x00,0xAA,0x00,0x44,0x77,0x3D}}
#define DB_NULLGUID {0x00000000L,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}}

extern const OLEDBDECLSPEC DBID DB_NULLID                      = {DB_NULLGUID, 0, (LPOLESTR)0};
extern const OLEDBDECLSPEC DBID DBCOLUMN_IDNAME                = {DBCIDGUID, DBKIND_GUID_PROPID, (LPOLESTR)2};
extern const OLEDBDECLSPEC DBID DBCOLUMN_NAME                  = {DBCIDGUID, DBKIND_GUID_PROPID, (LPOLESTR)3};
extern const OLEDBDECLSPEC DBID DBCOLUMN_NUMBER                = {DBCIDGUID, DBKIND_GUID_PROPID, (LPOLESTR)4};
extern const OLEDBDECLSPEC DBID DBCOLUMN_TYPE                  = {DBCIDGUID, DBKIND_GUID_PROPID, (LPOLESTR)5};
extern const OLEDBDECLSPEC DBID DBCOLUMN_PRECISION             = {DBCIDGUID, DBKIND_GUID_PROPID, (LPOLESTR)7};
extern const OLEDBDECLSPEC DBID DBCOLUMN_SCALE                 = {DBCIDGUID, DBKIND_GUID_PROPID, (LPOLESTR)8};
extern const OLEDBDECLSPEC DBID DBCOLUMN_FLAGS                 = {DBCIDGUID, DBKIND_GUID_PROPID, (LPOLESTR)9};
extern const OLEDBDECLSPEC DBID DBCOLUMN_BASECOLUMNNAME        = {DBCIDGUID, DBKIND_GUID_PROPID, (LPOLESTR)10};
extern const OLEDBDECLSPEC DBID DBCOLUMN_BASETABLENAME         = {DBCIDGUID, DBKIND_GUID_PROPID, (LPOLESTR)11};
extern const OLEDBDECLSPEC DBID DBCOLUMN_COLLATINGSEQUENCE     = {DBCIDGUID, DBKIND_GUID_PROPID, (LPOLESTR)12};
extern const OLEDBDECLSPEC DBID DBCOLUMN_COMPUTEMODE           = {DBCIDGUID, DBKIND_GUID_PROPID, (LPOLESTR)13};
extern const OLEDBDECLSPEC DBID DBCOLUMN_DEFAULTVALUE          = {DBCIDGUID, DBKIND_GUID_PROPID, (LPOLESTR)14};
extern const OLEDBDECLSPEC DBID DBCOLUMN_DOMAINNAME            = {DBCIDGUID, DBKIND_GUID_PROPID, (LPOLESTR)15};
extern const OLEDBDECLSPEC DBID DBCOLUMN_HASDEFAULT            = {DBCIDGUID, DBKIND_GUID_PROPID, (LPOLESTR)16};
extern const OLEDBDECLSPEC DBID DBCOLUMN_ISAUTOINCREMENT       = {DBCIDGUID, DBKIND_GUID_PROPID, (LPOLESTR)17};
extern const OLEDBDECLSPEC DBID DBCOLUMN_ISCASESENSITIVE       = {DBCIDGUID, DBKIND_GUID_PROPID, (LPOLESTR)18};
extern const OLEDBDECLSPEC DBID DBCOLUMN_ISSEARCHABLE          = {DBCIDGUID, DBKIND_GUID_PROPID, (LPOLESTR)20};
extern const OLEDBDECLSPEC DBID DBCOLUMN_ISUNIQUE              = {DBCIDGUID, DBKIND_GUID_PROPID, (LPOLESTR)21};
extern const OLEDBDECLSPEC DBID DBCOLUMN_BASECATALOGNAME       = {DBCIDGUID, DBKIND_GUID_PROPID, (LPOLESTR)23};
extern const OLEDBDECLSPEC DBID DBCOLUMN_BASESCHEMANAME        = {DBCIDGUID, DBKIND_GUID_PROPID, (LPOLESTR)24};
extern const OLEDBDECLSPEC DBID DBCOLUMN_GUID                  = {DBCIDGUID, DBKIND_GUID_PROPID, (LPOLESTR)29};
extern const OLEDBDECLSPEC DBID DBCOLUMN_PROPID                = {DBCIDGUID, DBKIND_GUID_PROPID, (LPOLESTR)30};
extern const OLEDBDECLSPEC DBID DBCOLUMN_TYPEINFO              = {DBCIDGUID, DBKIND_GUID_PROPID, (LPOLESTR)31};
extern const OLEDBDECLSPEC DBID DBCOLUMN_DOMAINCATALOG         = {DBCIDGUID, DBKIND_GUID_PROPID, (LPOLESTR)32};
extern const OLEDBDECLSPEC DBID DBCOLUMN_DOMAINSCHEMA          = {DBCIDGUID, DBKIND_GUID_PROPID, (LPOLESTR)33};
extern const OLEDBDECLSPEC DBID DBCOLUMN_DATETIMEPRECISION     = {DBCIDGUID, DBKIND_GUID_PROPID, (LPOLESTR)34};
extern const OLEDBDECLSPEC DBID DBCOLUMN_NUMERICPRECISIONRADIX = {DBCIDGUID, DBKIND_GUID_PROPID, (LPOLESTR)35};
extern const OLEDBDECLSPEC DBID DBCOLUMN_OCTETLENGTH           = {DBCIDGUID, DBKIND_GUID_PROPID, (LPOLESTR)36};
extern const OLEDBDECLSPEC DBID DBCOLUMN_COLUMNSIZE            = {DBCIDGUID, DBKIND_GUID_PROPID, (LPOLESTR)37};
extern const OLEDBDECLSPEC DBID DBCOLUMN_CLSID                 = {DBCIDGUID, DBKIND_GUID_PROPID, (LPOLESTR)38};

extern const OLEDBDECLSPEC DBID DBCOLUMN_MAYSORT               = {DBCIDGUID, DBKIND_GUID_PROPID, (LPOLESTR)39};

extern const OLEDBDECLSPEC GUID DBSCHEMA_TABLES_INFO                   = {0xc8b522e0,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID MDGUID_MDX                             = {0xa07cccd0,0x8148,0x11d0,{0x87,0xbb,0x00,0xc0,0x4f,0xc3,0x39,0x42}};
extern const OLEDBDECLSPEC GUID DBGUID_MDX                             = {0xa07cccd0,0x8148,0x11d0,{0x87,0xbb,0x00,0xc0,0x4f,0xc3,0x39,0x42}};
extern const OLEDBDECLSPEC GUID MDSCHEMA_CUBES                         = {0xc8b522d8,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID MDSCHEMA_DIMENSIONS                    = {0xc8b522d9,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID MDSCHEMA_HIERARCHIES                   = {0xc8b522da,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID MDSCHEMA_LEVELS                        = {0xc8b522db,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID MDSCHEMA_MEASURES                      = {0xc8b522dc,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID MDSCHEMA_PROPERTIES                    = {0xc8b522dd,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID MDSCHEMA_MEMBERS                       = {0xc8b522de,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC DBID DBCOLUMN_BASETABLEVERSION				= {DBCIDGUID, DBKIND_GUID_PROPID, (LPOLESTR)40};
extern const OLEDBDECLSPEC DBID DBCOLUMN_KEYCOLUMN						= {DBCIDGUID, DBKIND_GUID_PROPID, (LPOLESTR)41};

#define DBGUID_ROWURL   {0x0C733AB6L,0x2A1C,0x11CE,{0xAD,0xE5,0x00,0xAA,0x00,0x44,0x77,0x3D}}
#define DBGUID_ROWDEFAULTSTREAM   {0x0C733AB7L,0x2A1C,0x11CE,{0xAD,0xE5,0x00,0xAA,0x00,0x44,0x77,0x3D}}
extern const OLEDBDECLSPEC GUID DBPROPSET_TRUSTEE					= {0xc8b522e1,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBOBJECT_TABLE 						= {0xc8b522e2,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBOBJECT_COLUMN 						= {0xc8b522e4,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBOBJECT_DATABASE					= {0xc8b522e5,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBOBJECT_PROCEDURE 					= {0xc8b522e6,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBOBJECT_VIEW	 					= {0xc8b522e7,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBOBJECT_SCHEMA						= {0xc8b522e8,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBOBJECT_DOMAIN	 					= {0xc8b522e9,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBOBJECT_COLLATION 					= {0xc8b522ea,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBOBJECT_TRUSTEE	 					= {0xc8b522eb,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBOBJECT_SCHEMAROWSET				= {0xc8b522ec,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBOBJECT_CHARACTERSET	 			= {0xc8b522ed,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBOBJECT_TRANSLATION 				= {0xc8b522ee,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBSCHEMA_TRUSTEE 					= {0xc8b522ef,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBPROPSET_COLUMNALL 					= {0xc8b522f0,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBPROPSET_INDEXALL 					= {0xc8b522f1,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBPROPSET_TABLEALL 					= {0xc8b522f2,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBPROPSET_TRUSTEEALL					= {0xc8b522f3,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBPROPSET_CONSTRAINTALL				= {0xc8b522fa,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBGUID_DSO							= {0xc8b522f4,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBGUID_SESSION						= {0xc8b522f5,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBGUID_ROWSET						= {0xc8b522f6,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBGUID_ROW							= {0xc8b522f7,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBGUID_COMMAND						= {0xc8b522f8,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBGUID_STREAM						= {0xc8b522f9,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC DBID DBROWCOL_ROWURL		         = {DBGUID_ROWURL, DBKIND_GUID_PROPID, (LPOLESTR)0};
extern const OLEDBDECLSPEC DBID DBROWCOL_PARSENAME            = {DBGUID_ROWURL, DBKIND_GUID_PROPID, (LPOLESTR)2};
extern const OLEDBDECLSPEC DBID DBROWCOL_PARENTNAME           = {DBGUID_ROWURL, DBKIND_GUID_PROPID, (LPOLESTR)3};
extern const OLEDBDECLSPEC DBID DBROWCOL_ABSOLUTEPARSENAME    = {DBGUID_ROWURL, DBKIND_GUID_PROPID, (LPOLESTR)4};
extern const OLEDBDECLSPEC DBID DBROWCOL_ISHIDDEN             = {DBGUID_ROWURL, DBKIND_GUID_PROPID, (LPOLESTR)5};
extern const OLEDBDECLSPEC DBID DBROWCOL_ISREADONLY           = {DBGUID_ROWURL, DBKIND_GUID_PROPID, (LPOLESTR)6};
extern const OLEDBDECLSPEC DBID DBROWCOL_CONTENTTYPE          = {DBGUID_ROWURL, DBKIND_GUID_PROPID, (LPOLESTR)7};
extern const OLEDBDECLSPEC DBID DBROWCOL_CONTENTCLASS         = {DBGUID_ROWURL, DBKIND_GUID_PROPID, (LPOLESTR)8};
extern const OLEDBDECLSPEC DBID DBROWCOL_CONTENTLANGUAGE      = {DBGUID_ROWURL, DBKIND_GUID_PROPID, (LPOLESTR)9};
extern const OLEDBDECLSPEC DBID DBROWCOL_CREATIONTIME         = {DBGUID_ROWURL, DBKIND_GUID_PROPID, (LPOLESTR)10};
extern const OLEDBDECLSPEC DBID DBROWCOL_LASTACCESSTIME       = {DBGUID_ROWURL, DBKIND_GUID_PROPID, (LPOLESTR)11};
extern const OLEDBDECLSPEC DBID DBROWCOL_LASTWRITETIME        = {DBGUID_ROWURL, DBKIND_GUID_PROPID, (LPOLESTR)12};
extern const OLEDBDECLSPEC DBID DBROWCOL_STREAMSIZE           = {DBGUID_ROWURL, DBKIND_GUID_PROPID, (LPOLESTR)13};
extern const OLEDBDECLSPEC DBID DBROWCOL_ISCOLLECTION         = {DBGUID_ROWURL, DBKIND_GUID_PROPID, (LPOLESTR)14};
extern const OLEDBDECLSPEC DBID DBROWCOL_ISSTRUCTUREDDOCUMENT = {DBGUID_ROWURL, DBKIND_GUID_PROPID, (LPOLESTR)15};
extern const OLEDBDECLSPEC DBID DBROWCOL_DEFAULTDOCUMENT      = {DBGUID_ROWURL, DBKIND_GUID_PROPID, (LPOLESTR)16};
extern const OLEDBDECLSPEC DBID DBROWCOL_DISPLAYNAME          = {DBGUID_ROWURL, DBKIND_GUID_PROPID, (LPOLESTR)17};
extern const OLEDBDECLSPEC DBID DBROWCOL_ISROOT               = {DBGUID_ROWURL, DBKIND_GUID_PROPID, (LPOLESTR)18};
extern const OLEDBDECLSPEC DBID DBROWCOL_DEFAULTSTREAM        = {DBGUID_ROWDEFAULTSTREAM, DBKIND_GUID_PROPID, (LPOLESTR)0};
extern const OLEDBDECLSPEC GUID DBGUID_CONTAINEROBJECT        = {0xc8b522fb,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};

extern const OLEDBDECLSPEC GUID DBSCHEMA_ASSERTIONS                    = {0xc8b52210,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBSCHEMA_CATALOGS                      = {0xc8b52211,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBSCHEMA_CHARACTER_SETS                = {0xc8b52212,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBSCHEMA_COLLATIONS                    = {0xc8b52213,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBSCHEMA_COLUMNS                       = {0xc8b52214,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBSCHEMA_CHECK_CONSTRAINTS             = {0xc8b52215,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBSCHEMA_CONSTRAINT_COLUMN_USAGE       = {0xc8b52216,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBSCHEMA_CONSTRAINT_TABLE_USAGE        = {0xc8b52217,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBSCHEMA_KEY_COLUMN_USAGE              = {0xc8b52218,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBSCHEMA_REFERENTIAL_CONSTRAINTS       = {0xc8b52219,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBSCHEMA_TABLE_CONSTRAINTS             = {0xc8b5221a,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBSCHEMA_COLUMN_DOMAIN_USAGE           = {0xc8b5221b,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBSCHEMA_INDEXES                       = {0xc8b5221e,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBSCHEMA_COLUMN_PRIVILEGES             = {0xc8b52221,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBSCHEMA_TABLE_PRIVILEGES              = {0xc8b52222,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBSCHEMA_USAGE_PRIVILEGES              = {0xc8b52223,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBSCHEMA_PROCEDURES                    = {0xc8b52224,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBSCHEMA_SCHEMATA                      = {0xc8b52225,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBSCHEMA_SQL_LANGUAGES                 = {0xc8b52226,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBSCHEMA_STATISTICS                    = {0xc8b52227,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBSCHEMA_TABLES                        = {0xc8b52229,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBSCHEMA_TRANSLATIONS                  = {0xc8b5222a,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBSCHEMA_PROVIDER_TYPES                = {0xc8b5222c,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBSCHEMA_VIEWS                         = {0xc8b5222d,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBSCHEMA_VIEW_COLUMN_USAGE             = {0xc8b5222e,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBSCHEMA_VIEW_TABLE_USAGE              = {0xc8b5222f,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBSCHEMA_PROCEDURE_PARAMETERS          = {0xc8b522b8,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBSCHEMA_FOREIGN_KEYS                  = {0xc8b522c4,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBSCHEMA_PRIMARY_KEYS                  = {0xc8b522c5,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBSCHEMA_PROCEDURE_COLUMNS             = {0xc8b522c9,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBCOL_SELFCOLUMNS                      = {0xc8b52231,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBCOL_SPECIALCOL                       = {0xc8b52232,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID PSGUID_QUERY                           = {0x49691c90,0x7e17,0x101a,{0xa9,0x1c,0x08,0x00,0x2b,0x2e,0xcd,0xa9}};
extern const OLEDBDECLSPEC GUID DBPROPSET_COLUMN                       = {0xc8b522b9,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBPROPSET_DATASOURCE                   = {0xc8b522ba,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBPROPSET_DATASOURCEINFO               = {0xc8b522bb,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBPROPSET_DBINIT                       = {0xc8b522bc,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBPROPSET_INDEX                        = {0xc8b522bd,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBPROPSET_ROWSET                       = {0xc8b522be,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBPROPSET_TABLE                        = {0xc8b522bf,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBPROPSET_DATASOURCEALL                = {0xc8b522c0,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBPROPSET_DATASOURCEINFOALL            = {0xc8b522c1,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBPROPSET_ROWSETALL                    = {0xc8b522c2,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBPROPSET_SESSION                      = {0xc8b522c6,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBPROPSET_SESSIONALL                   = {0xc8b522c7,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBPROPSET_DBINITALL                    = {0xc8b522ca,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBPROPSET_PROPERTIESINERROR            = {0xc8b522d4,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};

extern const OLEDBDECLSPEC GUID DBPROPSET_VIEW                         = {0xc8b522df,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};

// DBGUID_DBSQL is deprecated; use DBGUID_DEFAULT instead
extern const OLEDBDECLSPEC  GUID DBGUID_DBSQL                           = {0xc8b521fb,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBGUID_DEFAULT                         = {0xc8b521fb,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBGUID_SQL                             = {0xc8b522d7,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};

enum DBPROPENUM
    {	DBPROP_ABORTPRESERVE	= 0x2L,
	DBPROP_ACTIVESESSIONS	= 0x3L,
	DBPROP_APPENDONLY	= 0xbbL,
	DBPROP_ASYNCTXNABORT	= 0xa8L,
	DBPROP_ASYNCTXNCOMMIT	= 0x4L,
	DBPROP_AUTH_CACHE_AUTHINFO	= 0x5L,
	DBPROP_AUTH_ENCRYPT_PASSWORD	= 0x6L,
	DBPROP_AUTH_INTEGRATED	= 0x7L,
	DBPROP_AUTH_MASK_PASSWORD	= 0x8L,
	DBPROP_AUTH_PASSWORD	= 0x9L,
	DBPROP_AUTH_PERSIST_ENCRYPTED	= 0xaL,
	DBPROP_AUTH_PERSIST_SENSITIVE_AUTHINFO	= 0xbL,
	DBPROP_AUTH_USERID	= 0xcL,
	DBPROP_BLOCKINGSTORAGEOBJECTS	= 0xdL,
	DBPROP_BOOKMARKS	= 0xeL,
	DBPROP_BOOKMARKSKIPPED	= 0xfL,
	DBPROP_BOOKMARKTYPE	= 0x10L,
	DBPROP_BYREFACCESSORS	= 0x78L,
	DBPROP_CACHEDEFERRED	= 0x11L,
	DBPROP_CANFETCHBACKWARDS	= 0x12L,
	DBPROP_CANHOLDROWS	= 0x13L,
	DBPROP_CANSCROLLBACKWARDS	= 0x15L,
	DBPROP_CATALOGLOCATION	= 0x16L,
	DBPROP_CATALOGTERM	= 0x17L,
	DBPROP_CATALOGUSAGE	= 0x18L,
	DBPROP_CHANGEINSERTEDROWS	= 0xbcL,
	DBPROP_COL_AUTOINCREMENT	= 0x1aL,
	DBPROP_COL_DEFAULT	= 0x1bL,
	DBPROP_COL_DESCRIPTION	= 0x1cL,
	DBPROP_COL_FIXEDLENGTH	= 0xa7L,
	DBPROP_COL_NULLABLE	= 0x1dL,
	DBPROP_COL_PRIMARYKEY	= 0x1eL,
	DBPROP_COL_UNIQUE	= 0x1fL,
	DBPROP_COLUMNDEFINITION	= 0x20L,
	DBPROP_COLUMNRESTRICT	= 0x21L,
	DBPROP_COMMANDTIMEOUT	= 0x22L,
	DBPROP_COMMITPRESERVE	= 0x23L,
	DBPROP_CONCATNULLBEHAVIOR	= 0x24L,
	DBPROP_CURRENTCATALOG	= 0x25L,
	DBPROP_DATASOURCENAME	= 0x26L,
	DBPROP_DATASOURCEREADONLY	= 0x27L,
	DBPROP_DBMSNAME	= 0x28L,
	DBPROP_DBMSVER	= 0x29L,
	DBPROP_DEFERRED	= 0x2aL,
	DBPROP_DELAYSTORAGEOBJECTS	= 0x2bL,
	DBPROP_DSOTHREADMODEL	= 0xa9L,
	DBPROP_GROUPBY	= 0x2cL,
	DBPROP_HETEROGENEOUSTABLES	= 0x2dL,
	DBPROP_IAccessor	= 0x79L,
	DBPROP_IColumnsInfo	= 0x7aL,
	DBPROP_IColumnsRowset	= 0x7bL,
	DBPROP_IConnectionPointContainer	= 0x7cL,
	DBPROP_IConvertType	= 0xc2L,
	DBPROP_IRowset	= 0x7eL,
	DBPROP_IRowsetChange	= 0x7fL,
	DBPROP_IRowsetIdentity	= 0x80L,
	DBPROP_IRowsetIndex	= 0x9fL,
	DBPROP_IRowsetInfo	= 0x81L,
	DBPROP_IRowsetLocate	= 0x82L,
	DBPROP_IRowsetResynch	= 0x84L,
	DBPROP_IRowsetScroll	= 0x85L,
	DBPROP_IRowsetUpdate	= 0x86L,
	DBPROP_ISupportErrorInfo	= 0x87L,
	DBPROP_ILockBytes	= 0x88L,
	DBPROP_ISequentialStream	= 0x89L,
	DBPROP_IStorage	= 0x8aL,
	DBPROP_IStream	= 0x8bL,
	DBPROP_IDENTIFIERCASE	= 0x2eL,
	DBPROP_IMMOBILEROWS	= 0x2fL,
	DBPROP_INDEX_AUTOUPDATE	= 0x30L,
	DBPROP_INDEX_CLUSTERED	= 0x31L,
	DBPROP_INDEX_FILLFACTOR	= 0x32L,
	DBPROP_INDEX_INITIALSIZE	= 0x33L,
	DBPROP_INDEX_NULLCOLLATION	= 0x34L,
	DBPROP_INDEX_NULLS	= 0x35L,
	DBPROP_INDEX_PRIMARYKEY	= 0x36L,
	DBPROP_INDEX_SORTBOOKMARKS	= 0x37L,
	DBPROP_INDEX_TEMPINDEX	= 0xa3L,
	DBPROP_INDEX_TYPE	= 0x38L,
	DBPROP_INDEX_UNIQUE	= 0x39L,
	DBPROP_INIT_DATASOURCE	= 0x3bL,
	DBPROP_INIT_HWND	= 0x3cL,
	DBPROP_INIT_IMPERSONATION_LEVEL	= 0x3dL,
	DBPROP_INIT_LCID	= 0xbaL,
	DBPROP_INIT_LOCATION	= 0x3eL,
	DBPROP_INIT_MODE	= 0x3fL,
	DBPROP_INIT_PROMPT	= 0x40L,
	DBPROP_INIT_PROTECTION_LEVEL	= 0x41L,
	DBPROP_INIT_PROVIDERSTRING	= 0xa0L,
	DBPROP_INIT_TIMEOUT	= 0x42L,
	DBPROP_LITERALBOOKMARKS	= 0x43L,
	DBPROP_LITERALIDENTITY	= 0x44L,
	DBPROP_MARSHALLABLE	= 0xc5L,
	DBPROP_MAXINDEXSIZE	= 0x46L,
	DBPROP_MAXOPENROWS	= 0x47L,
	DBPROP_MAXPENDINGROWS	= 0x48L,
	DBPROP_MAXROWS	= 0x49L,
	DBPROP_MAXROWSIZE	= 0x4aL,
	DBPROP_MAXROWSIZEINCLUDESBLOB	= 0x4bL,
	DBPROP_MAXTABLESINSELECT	= 0x4cL,
	DBPROP_MAYWRITECOLUMN	= 0x4dL,
	DBPROP_MEMORYUSAGE	= 0x4eL,
	DBPROP_MULTIPLEPARAMSETS	= 0xbfL,
	DBPROP_MULTIPLERESULTS	= 0xc4L,
	DBPROP_MULTIPLESTORAGEOBJECTS	= 0x50L,
	DBPROP_MULTITABLEUPDATE	= 0x51L,
	DBPROP_NOTIFICATIONGRANULARITY	= 0xc6L,
	DBPROP_NOTIFICATIONPHASES	= 0x52L,
	DBPROP_NOTIFYCOLUMNSET	= 0xabL,
	DBPROP_NOTIFYROWDELETE	= 0xadL,
	DBPROP_NOTIFYROWFIRSTCHANGE	= 0xaeL,
	DBPROP_NOTIFYROWINSERT	= 0xafL,
	DBPROP_NOTIFYROWRESYNCH	= 0xb1L,
	DBPROP_NOTIFYROWSETCHANGED	= 0xd3L,
	DBPROP_NOTIFYROWSETRELEASE	= 0xb2L,
	DBPROP_NOTIFYROWSETFETCHPOSITIONCHANGE	= 0xb3L,
	DBPROP_NOTIFYROWUNDOCHANGE	= 0xb4L,
	DBPROP_NOTIFYROWUNDODELETE	= 0xb5L,
	DBPROP_NOTIFYROWUNDOINSERT	= 0xb6L,
	DBPROP_NOTIFYROWUPDATE	= 0xb7L,
	DBPROP_NULLCOLLATION	= 0x53L,
	DBPROP_OLEOBJECTS	= 0x54L,
	DBPROP_ORDERBYCOLUMNSINSELECT	= 0x55L,
	DBPROP_ORDEREDBOOKMARKS	= 0x56L,
	DBPROP_OTHERINSERT	= 0x57L,
	DBPROP_OTHERUPDATEDELETE	= 0x58L,
	DBPROP_OUTPUTPARAMETERAVAILABILITY	= 0xb8L,
	DBPROP_OWNINSERT	= 0x59L,
	DBPROP_OWNUPDATEDELETE	= 0x5aL,
	DBPROP_PERSISTENTIDTYPE	= 0xb9L,
	DBPROP_PREPAREABORTBEHAVIOR	= 0x5bL,
	DBPROP_PREPARECOMMITBEHAVIOR	= 0x5cL,
	DBPROP_PROCEDURETERM	= 0x5dL,
	DBPROP_PROVIDERNAME	= 0x60L,
	DBPROP_PROVIDEROLEDBVER	= 0x61L,
	DBPROP_PROVIDERVER	= 0x62L,
	DBPROP_QUICKRESTART	= 0x63L,
	DBPROP_QUOTEDIDENTIFIERCASE	= 0x64L,
	DBPROP_REENTRANTEVENTS	= 0x65L,
	DBPROP_REMOVEDELETED	= 0x66L,
	DBPROP_REPORTMULTIPLECHANGES	= 0x67L,
	DBPROP_RETURNPENDINGINSERTS	= 0xbdL,
	DBPROP_ROWRESTRICT	= 0x68L,
	DBPROP_ROWSETCONVERSIONSONCOMMAND	= 0xc0L,
	DBPROP_ROWTHREADMODEL	= 0x69L,
	DBPROP_SCHEMATERM	= 0x6aL,
	DBPROP_SCHEMAUSAGE	= 0x6bL,
	DBPROP_SERVERCURSOR	= 0x6cL,
	DBPROP_SESS_AUTOCOMMITISOLEVELS	= 0xbeL,
	DBPROP_SQLSUPPORT	= 0x6dL,
	DBPROP_STRONGIDENTITY	= 0x77L,
	DBPROP_STRUCTUREDSTORAGE	= 0x6fL,
	DBPROP_SUBQUERIES	= 0x70L,
	DBPROP_SUPPORTEDTXNDDL	= 0xa1L,
	DBPROP_SUPPORTEDTXNISOLEVELS	= 0x71L,
	DBPROP_SUPPORTEDTXNISORETAIN	= 0x72L,
	DBPROP_TABLETERM	= 0x73L,
	DBPROP_TBL_TEMPTABLE	= 0x8cL,
	DBPROP_TRANSACTEDOBJECT	= 0x74L,
	DBPROP_UPDATABILITY	= 0x75L,
	DBPROP_USERNAME	= 0x76L
    };

enum DBPROPENUM15
    {	DBPROP_FILTEROPS	= 0xd0L,
	DBPROP_FILTERCOMPAREOPS	= 0xd1L,
	DBPROP_FINDCOMPAREOPS	= 0xd2L,
	DBPROP_IChapteredRowset	= 0xcaL,
	DBPROP_IDBAsynchStatus	= 0xcbL,
	DBPROP_IRowsetFind	= 0xccL,
	DBPROP_IRowsetView	= 0xd4L,
	DBPROP_IViewChapter	= 0xd5L,
	DBPROP_IViewFilter	= 0xd6L,
	DBPROP_IViewRowset	= 0xd7L,
	DBPROP_IViewSort	= 0xd8L,
	DBPROP_INIT_ASYNCH	= 0xc8L,
	DBPROP_MAXOPENCHAPTERS	= 0xc7L,
	DBPROP_MAXORSINFILTER	= 0xcdL,
	DBPROP_MAXSORTCOLUMNS	= 0xceL,
	DBPROP_ROWSET_ASYNCH	= 0xc9L,
	DBPROP_SORTONINDEX	= 0xcfL
    };

#define DBPROP_PROVIDERFILENAME DBPROP_PROVIDERNAME
#define DBPROP_SERVER_NAME DBPROP_SERVERNAME

enum DBPROPENUM20
    {	DBPROP_IMultipleResults	= 0xd9L,
	DBPROP_DATASOURCE_TYPE	= 0xfbL,
	MDPROP_AXES	= 0xfcL,
	MDPROP_FLATTENING_SUPPORT	= 0xfdL,
	MDPROP_MDX_JOINCUBES	= 0xfeL,
	MDPROP_NAMED_LEVELS	= 0xffL,
	MDPROP_RANGEROWSET	= 0x100L,
	MDPROP_MDX_SLICER	= 0xdaL,
	MDPROP_MDX_CUBEQUALIFICATION	= 0xdbL,
	MDPROP_MDX_OUTERREFERENCE	= 0xdcL,
	MDPROP_MDX_QUERYBYPROPERTY	= 0xddL,
	MDPROP_MDX_CASESUPPORT	= 0xdeL,
	MDPROP_MDX_STRING_COMPOP	= 0xe0L,
	MDPROP_MDX_DESCFLAGS	= 0xe1L,
	MDPROP_MDX_SET_FUNCTIONS	= 0xe2L,
	MDPROP_MDX_MEMBER_FUNCTIONS	= 0xe3L,
	MDPROP_MDX_NUMERIC_FUNCTIONS	= 0xe4L,
	MDPROP_MDX_FORMULAS	= 0xe5L,
	MDPROP_AGGREGATECELL_UPDATE	= 0xe6L,
	MDPROP_MDX_AGGREGATECELL_UPDATE	= MDPROP_AGGREGATECELL_UPDATE,
	MDPROP_MDX_OBJQUALIFICATION	= 0x105L,
	MDPROP_MDX_NONMEASURE_EXPRESSONS	= 0x106L,
	DBPROP_ACCESSORDER	= 0xe7L,
	DBPROP_BOOKMARKINFO	= 0xe8L,
	DBPROP_INIT_CATALOG	= 0xe9L,
	DBPROP_ROW_BULKOPS	= 0xeaL,
	DBPROP_PROVIDERFRIENDLYNAME	= 0xebL,
	DBPROP_LOCKMODE	= 0xecL,
	DBPROP_MULTIPLECONNECTIONS	= 0xedL,
	DBPROP_UNIQUEROWS	= 0xeeL,
	DBPROP_SERVERDATAONINSERT	= 0xefL,
	DBPROP_STORAGEFLAGS	= 0xf0L,
	DBPROP_CONNECTIONSTATUS	= 0xf4L,
	DBPROP_ALTERCOLUMN	= 0xf5L,
	DBPROP_COLUMNLCID	= 0xf6L,
	DBPROP_RESETDATASOURCE	= 0xf7L,
	DBPROP_INIT_OLEDBSERVICES	= 0xf8L,
	DBPROP_IRowsetRefresh	= 0xf9L,
	DBPROP_SERVERNAME	= 0xfaL,
	DBPROP_IParentRowset	= 0x101L,
	DBPROP_HIDDENCOLUMNS	= 0x102L,
	DBPROP_PROVIDERMEMORY	= 0x103L,
	DBPROP_CLIENTCURSOR	= 0x104L
    };

enum DBPROPENUM21
    {	DBPROP_TRUSTEE_USERNAME	= 0xf1L,
	DBPROP_TRUSTEE_AUTHENTICATION	= 0xf2L,
	DBPROP_TRUSTEE_NEWAUTHENTICATION	= 0xf3L,
	DBPROP_IRow	= 0x107L,
	DBPROP_IRowChange	= 0x108L,
	DBPROP_IRowSchemaChange	= 0x109L,
	DBPROP_IGetRow	= 0x10aL,
	DBPROP_IScopedOperations	= 0x10bL,
	DBPROP_IBindResource	= 0x10cL,
	DBPROP_ICreateRow	= 0x10dL,
	DBPROP_INIT_BINDFLAGS	= 0x10eL,
	DBPROP_INIT_LOCKOWNER	= 0x10fL,
	DBPROP_GENERATEURL	= 0x111L,
	DBPROP_IDBBinderProperties	= 0x112L,
	DBPROP_IColumnsInfo2	= 0x113L,
	DBPROP_IRegisterProvider	= 0x114L,
	DBPROP_IGetSession	= 0x115L,
	DBPROP_IGetSourceRow	= 0x116L,
	DBPROP_IRowsetCurrentIndex	= 0x117L,
	DBPROP_OPENROWSETSUPPORT	= 0x118L,
	DBPROP_COL_ISLONG	= 0x119L
    };

//@@@+ deprecated
#ifdef deprecated

enum DBPROPENUMDEPRECATED
    {	DBPROP_IRowsetExactScroll	= 0x9aL
    };
#endif // deprecated
//@@@- deprecated
#define DBPROPVAL_BMK_NUMERIC							 0x00000001L
#define DBPROPVAL_BMK_KEY								 0x00000002L
#define DBPROPVAL_CL_START                                0x00000001L
#define DBPROPVAL_CL_END                                  0x00000002L
#define DBPROPVAL_CU_DML_STATEMENTS						 0x00000001L
#define DBPROPVAL_CU_TABLE_DEFINITION					 0x00000002L
#define DBPROPVAL_CU_INDEX_DEFINITION					 0x00000004L
#define DBPROPVAL_CU_PRIVILEGE_DEFINITION				 0x00000008L
#define DBPROPVAL_CD_NOTNULL								 0x00000001L
#define DBPROPVAL_CB_NULL								 0x00000001L
#define DBPROPVAL_CB_NON_NULL							 0x00000002L
#define DBPROPVAL_FU_NOT_SUPPORTED						 0x00000001L
#define DBPROPVAL_FU_COLUMN								 0x00000002L
#define DBPROPVAL_FU_TABLE								 0x00000004L
#define DBPROPVAL_FU_CATALOG								 0x00000008L
#define DBPROPVAL_GB_NOT_SUPPORTED						 0x00000001L
#define DBPROPVAL_GB_EQUALS_SELECT						 0x00000002L
#define DBPROPVAL_GB_CONTAINS_SELECT						 0x00000004L
#define DBPROPVAL_GB_NO_RELATION							 0x00000008L
#define DBPROPVAL_HT_DIFFERENT_CATALOGS					 0x00000001L
#define DBPROPVAL_HT_DIFFERENT_PROVIDERS					 0x00000002L
#define DBPROPVAL_IC_UPPER								 0x00000001L
#define DBPROPVAL_IC_LOWER								 0x00000002L
#define DBPROPVAL_IC_SENSITIVE							 0x00000004L
#define DBPROPVAL_IC_MIXED								 0x00000008L
//@@@+ deprecated
#ifdef deprecated
#define DBPROPVAL_LM_NONE								 0x00000001L
#define DBPROPVAL_LM_READ								 0x00000002L
#define DBPROPVAL_LM_INTENT								 0x00000004L
#define DBPROPVAL_LM_RITE								 0x00000008L
#endif // deprecated
//@@@- deprecated
#define DBPROPVAL_NP_OKTODO								 0x00000001L
#define DBPROPVAL_NP_ABOUTTODO							 0x00000002L
#define DBPROPVAL_NP_SYNCHAFTER							 0x00000004L
#define DBPROPVAL_NP_FAILEDTODO							 0x00000008L
#define DBPROPVAL_NP_DIDEVENT							 0x00000010L
#define DBPROPVAL_NC_END									 0x00000001L
#define DBPROPVAL_NC_HIGH								 0x00000002L
#define DBPROPVAL_NC_LOW									 0x00000004L
#define DBPROPVAL_NC_START								 0x00000008L
#define DBPROPVAL_OO_BLOB								 0x00000001L
#define DBPROPVAL_OO_IPERSIST							 0x00000002L
#define DBPROPVAL_CB_DELETE								 0x00000001L
#define DBPROPVAL_CB_PRESERVE							 0x00000002L
#define DBPROPVAL_SU_DML_STATEMENTS						 0x00000001L
#define DBPROPVAL_SU_TABLE_DEFINITION					 0x00000002L
#define DBPROPVAL_SU_INDEX_DEFINITION					 0x00000004L
#define DBPROPVAL_SU_PRIVILEGE_DEFINITION				 0x00000008L
#define DBPROPVAL_SQ_CORRELATEDSUBQUERIES				 0x00000001L
#define DBPROPVAL_SQ_COMPARISON							 0x00000002L
#define DBPROPVAL_SQ_EXISTS								 0x00000004L
#define DBPROPVAL_SQ_IN									 0x00000008L
#define DBPROPVAL_SQ_QUANTIFIED							 0x00000010L
#define DBPROPVAL_SQ_TABLE								 0x00000020L
#define DBPROPVAL_SS_ISEQUENTIALSTREAM					 0x00000001L
#define DBPROPVAL_SS_ISTREAM								 0x00000002L
#define DBPROPVAL_SS_ISTORAGE							 0x00000004L
#define DBPROPVAL_SS_ILOCKBYTES							 0x00000008L
#define DBPROPVAL_TI_CHAOS								 0x00000010L
#define DBPROPVAL_TI_READUNCOMMITTED						 0x00000100L
#define DBPROPVAL_TI_BROWSE								 0x00000100L
#define DBPROPVAL_TI_CURSORSTABILITY						 0x00001000L
#define DBPROPVAL_TI_READCOMMITTED						 0x00001000L
#define DBPROPVAL_TI_REPEATABLEREAD						 0x00010000L
#define DBPROPVAL_TI_SERIALIZABLE						 0x00100000L
#define DBPROPVAL_TI_ISOLATED							 0x00100000L
#define DBPROPVAL_TR_COMMIT_DC							 0x00000001L
#define DBPROPVAL_TR_COMMIT								 0x00000002L
#define DBPROPVAL_TR_COMMIT_NO							 0x00000004L
#define DBPROPVAL_TR_ABORT_DC							 0x00000008L
#define DBPROPVAL_TR_ABORT								 0x00000010L
#define DBPROPVAL_TR_ABORT_NO							 0x00000020L
#define DBPROPVAL_TR_DONTCARE							 0x00000040L
#define DBPROPVAL_TR_BOTH								 0x00000080L
#define DBPROPVAL_TR_NONE								 0x00000100L
#define DBPROPVAL_TR_OPTIMISTIC							 0x00000200L
#define DBPROPVAL_RT_FREETHREAD							 0x00000001L
#define DBPROPVAL_RT_APTMTTHREAD							 0x00000002L
#define DBPROPVAL_RT_SINGLETHREAD						 0x00000004L
#define DBPROPVAL_UP_CHANGE								 0x00000001L
#define DBPROPVAL_UP_DELETE								 0x00000002L
#define DBPROPVAL_UP_INSERT								 0x00000004L
#define DBPROPVAL_SQL_NONE								 0x00000000L
#define DBPROPVAL_SQL_ODBC_MINIMUM						 0x00000001L
#define DBPROPVAL_SQL_ODBC_CORE							 0x00000002L
#define DBPROPVAL_SQL_ODBC_EXTENDED						 0x00000004L
#define DBPROPVAL_SQL_ANSI89_IEF							 0x00000008L
#define DBPROPVAL_SQL_ANSI92_ENTRY						 0x00000010L
#define DBPROPVAL_SQL_FIPS_TRANSITIONAL					 0x00000020L
#define DBPROPVAL_SQL_ANSI92_INTERMEDIATE				 0x00000040L
#define DBPROPVAL_SQL_ANSI92_FULL						 0x00000080L
#define DBPROPVAL_SQL_ESCAPECLAUSES						 0x00000100L
#define DBPROPVAL_IT_BTREE                                0x00000001L
#define DBPROPVAL_IT_HASH                                 0x00000002L
#define DBPROPVAL_IT_CONTENT                              0x00000003L
#define DBPROPVAL_IT_OTHER                                0x00000004L
#define DBPROPVAL_IN_DISALLOWNULL                         0x00000001L
#define DBPROPVAL_IN_IGNORENULL                           0x00000002L
#define DBPROPVAL_IN_IGNOREANYNULL                        0x00000004L
#define DBPROPVAL_TC_NONE                                 0x00000000L
#define DBPROPVAL_TC_DML                                  0x00000001L
#define DBPROPVAL_TC_DDL_COMMIT                           0x00000002L
#define DBPROPVAL_TC_DDL_IGNORE                           0x00000004L
#define DBPROPVAL_TC_ALL                                  0x00000008L
#define DBPROPVAL_NP_OKTODO                               0x00000001L
#define DBPROPVAL_NP_ABOUTTODO                            0x00000002L
#define DBPROPVAL_NP_SYNCHAFTER                           0x00000004L
#define DBPROPVAL_OA_NOTSUPPORTED                         0x00000001L
#define DBPROPVAL_OA_ATEXECUTE                            0x00000002L
#define DBPROPVAL_OA_ATROWRELEASE                         0x00000004L
#define DBPROPVAL_MR_NOTSUPPORTED                         0x00000000L
#define DBPROPVAL_MR_SUPPORTED                            0x00000001L
#define DBPROPVAL_MR_CONCURRENT                           0x00000002L
#define DBPROPVAL_PT_GUID_NAME                            0x00000001L
#define DBPROPVAL_PT_GUID_PROPID                          0x00000002L
#define DBPROPVAL_PT_NAME                                 0x00000004L
#define DBPROPVAL_PT_GUID                                 0x00000008L
#define DBPROPVAL_PT_PROPID								 0x00000010L
#define DBPROPVAL_PT_PGUID_NAME                           0x00000020L
#define DBPROPVAL_PT_PGUID_PROPID						 0x00000040L
#define DBPROPVAL_NT_SINGLEROW                            0x00000001L
#define DBPROPVAL_NT_MULTIPLEROWS                         0x00000002L

#define DBPROPVAL_ASYNCH_INITIALIZE                       0x00000001L
#define DBPROPVAL_ASYNCH_SEQUENTIALPOPULATION             0x00000002L
#define DBPROPVAL_ASYNCH_RANDOMPOPULATION                 0x00000004L
#define DBPROPVAL_OP_EQUAL                                0x00000001L
#define DBPROPVAL_OP_RELATIVE                             0x00000002L
#define DBPROPVAL_OP_STRING                               0x00000004L
#define DBPROPVAL_CO_EQUALITY                             0x00000001L
#define DBPROPVAL_CO_STRING                               0x00000002L
#define DBPROPVAL_CO_CASESENSITIVE                        0x00000004L
#define DBPROPVAL_CO_CASEINSENSITIVE                      0x00000008L

#define DBPROPVAL_CO_CONTAINS		                     0x00000010L
#define DBPROPVAL_CO_BEGINSWITH		                     0x00000020L
#define DBPROPVAL_ASYNCH_BACKGROUNDPOPULATION			0x00000008L
#define DBPROPVAL_ASYNCH_PREPOPULATE						0x00000010L
#define DBPROPVAL_ASYNCH_POPULATEONDEMAND				0x00000020L
#define DBPROPVAL_LM_NONE								 0x00000001L
#define DBPROPVAL_LM_SINGLEROW							 0x00000002L
#define DBPROPVAL_SQL_SUBMINIMUM 						 0x00000200L
#define DBPROPVAL_DST_TDP                                 0x00000001L
#define DBPROPVAL_DST_MDP                                 0x00000002L
#define DBPROPVAL_DST_TDPANDMDP                           0x00000003L
#define MDPROPVAL_AU_UNSUPPORTED                          0x00000000L
#define MDPROPVAL_AU_UNCHANGED                            0x00000001L
#define MDPROPVAL_AU_UNKNOWN                              0x00000002L
#define MDPROPVAL_MF_WITH_CALCMEMBERS                     0x00000001L
#define MDPROPVAL_MF_WITH_NAMEDSETS                       0x00000002L
#define MDPROPVAL_MF_CREATE_CALCMEMBERS                   0x00000004L
#define MDPROPVAL_MF_CREATE_NAMEDSETS                     0x00000008L
#define MDPROPVAL_MF_SCOPE_SESSION						 0x00000010L
#define MDPROPVAL_MF_SCOPE_GLOBAL                         0x00000020L
#define MDPROPVAL_MMF_COUSIN                              0x00000001L
#define MDPROPVAL_MMF_PARALLELPERIOD                      0x00000002L
#define MDPROPVAL_MMF_OPENINGPERIOD                       0x00000004L
#define MDPROPVAL_MMF_CLOSINGPERIOD                       0x00000008L
#define MDPROPVAL_MNF_MEDIAN								0x00000001L
#define MDPROPVAL_MNF_VAR								0x00000002L
#define MDPROPVAL_MNF_STDDEV								0x00000004L
#define MDPROPVAL_MNF_RANK								0x00000008L
#define MDPROPVAL_MNF_AGGREGATE							0x00000010L
#define MDPROPVAL_MNF_COVARIANCE							0x00000020L
#define MDPROPVAL_MNF_CORRELATION						0x00000040L
#define MDPROPVAL_MNF_LINREGSLOPE						0x00000080L
#define MDPROPVAL_MNF_LINREGVARIANCE						0x00000100L
#define MDPROPVAL_MNF_LINREG2							0x00000200L
#define MDPROPVAL_MNF_LINREGPOINT						0x00000400L
#define MDPROPVAL_MNF_DRILLDOWNLEVEL						0x00000800L
#define MDPROPVAL_MNF_DRILLDOWNMEMBERTOP					0x00001000L
#define MDPROPVAL_MNF_DRILLDOWNMEMBERBOTTOM				0x00002000L
#define MDPROPVAL_MNF_DRILLDOWNLEVELTOP					0x00004000L
#define MDPROPVAL_MNF_DRILLDOWNLEVELBOTTOM				0x00008000L
#define MDPROPVAL_MNF_DRILLUPMEMBER						0x00010000L
#define MDPROPVAL_MNF_DRILLUPLEVEL						0x00020000L
#define MDPROPVAL_MMF_COUSIN								0x00000001L
#define MDPROPVAL_MMF_PARALLELPERIOD						0x00000002L
#define MDPROPVAL_MMF_OPENINGPERIOD						0x00000004L
#define MDPROPVAL_MMF_CLOSINGPERIOD						0x00000008L
#define MDPROPVAL_MSF_TOPPERCENT							0x00000001L
#define MDPROPVAL_MSF_BOTTOMPERCENT						0x00000002L
#define MDPROPVAL_MSF_TOPSUM								0x00000004L
#define MDPROPVAL_MSF_BOTTOMSUM							0x00000008L
#define MDPROPVAL_MSF_PERIODSTODATE						0x00000010L
#define MDPROPVAL_MSF_LASTPERIODS						0x00000020L
#define MDPROPVAL_MSF_YTD								0x00000040L
#define MDPROPVAL_MSF_QTD								0x00000080L
#define MDPROPVAL_MSF_MTD								0x00000100L
#define MDPROPVAL_MSF_WTD								0x00000200L
#define MDPROPVAL_MSF_DRILLDOWNMEMBBER					0x00000400L
#define MDPROPVAL_MSF_DRILLDOWNLEVEL						0x00000800L
#define MDPROPVAL_MSF_DRILLDOWNMEMBERTOP					0x00001000L
#define MDPROPVAL_MSF_DRILLDOWNMEMBERBOTTOM				0x00002000L
#define MDPROPVAL_MSF_DRILLDOWNLEVELTOP					0x00004000L
#define MDPROPVAL_MSF_DRILLDOWNLEVELBOTTOM				0x00008000L
#define MDPROPVAL_MSF_DRILLUPMEMBER						0x00010000L
#define MDPROPVAL_MSF_DRILLUPLEVEL						0x00020000L
#define MDPROPVAL_MSF_TOGGLEDRILLSTATE					0x00040000L
// values for MDPROP_MDX_DESCFLAGS
#define MDPROPVAL_MD_SELF								0x00000001L
#define MDPROPVAL_MD_BEFORE								0x00000002L
#define MDPROPVAL_MD_AFTER								0x00000004L
// values for MDPROP_MDX_STRING_COMPOP
#define MDPROPVAL_MSC_LESSTHAN							0x00000001L
#define MDPROPVAL_MSC_GREATERTHAN						0x00000002L
#define MDPROPVAL_MSC_LESSTHANEQUAL						0x00000004L
#define MDPROPVAL_MSC_GREATERTHANEQUAL					0x00000008L
#define MDPROPVAL_MC_SINGLECASE							0x00000001L
#define MDPROPVAL_MC_SEARCHEDCASE						0x00000002L
#define MDPROPVAL_MOQ_OUTERREFERENCE						0x00000001L
#define MDPROPVAL_MOQ_DATASOURCE_CUBE					0x00000001L
#define MDPROPVAL_MOQ_CATALOG_CUBE						0x00000002L
#define MDPROPVAL_MOQ_SCHEMA_CUBE						0x00000004L
#define MDPROPVAL_MOQ_CUBE_DIM							0x00000008L
#define MDPROPVAL_MOQ_DIM_HIER							0x00000010L
#define MDPROPVAL_MOQ_DIMHIER_LEVEL						0x00000020L
#define MDPROPVAL_MOQ_LEVEL_MEMBER						0x00000040L
#define MDPROPVAL_MOQ_MEMBER_MEMBER						0x00000080L
#define MDPROPVAL_MOQ_DIMHIER_MEMBER						0x00000100L
#define MDPROPVAL_FS_FULL_SUPPORT						0x00000001L
#define MDPROPVAL_FS_GENERATED_COLUMN					0x00000002L
#define MDPROPVAL_FS_GENERATED_DIMENSION					0x00000003L
#define MDPROPVAL_FS_NO_SUPPORT							0x00000004L
#define MDPROPVAL_NL_NAMEDLEVELS							0x00000001L
#define MDPROPVAL_NL_NUMBEREDLEVELS						0x00000002L
#define MDPROPVAL_MJC_SINGLECUBE							0x00000001L
#define MDPROPVAL_MJC_MULTICUBES							0x00000002L
#define MDPROPVAL_MJC_IMPLICITCUBE						0x00000004L
#define MDPROPVAL_RR_NORANGEROWSET						0x00000001L
#define MDPROPVAL_RR_READONLY							0x00000002L
#define MDPROPVAL_RR_UPDATE								0x00000004L
#define MDPROPVAL_MS_MULTIPLETUPLES						0x00000001L
#define MDPROPVAL_MS_SINGLETUPLE						0x00000002L
#define MDPROPVAL_NME_ALLDIMENSIONS						0x00000000L
#define MDPROPVAL_NME_MEASURESONLY						0x00000001L
#define DBPROPVAL_AO_SEQUENTIAL							0x00000000L
#define DBPROPVAL_AO_SEQUENTIALSTORAGEOBJECTS			0x00000001L
#define DBPROPVAL_AO_RANDOM								0x00000002L
#define DBPROPVAL_BD_ROWSET								0x00000000L
#define DBPROPVAL_BD_INTRANSACTION						0x00000001L
#define DBPROPVAL_BD_XTRANSACTION						0x00000002L
#define DBPROPVAL_BD_REORGANIZATION						0x00000003L
#define BMK_DURABILITY_ROWSET							DBPROPVAL_BD_ROWSET
#define BMK_DURABILITY_INTRANSACTION						DBPROPVAL_BD_INTRANSACTION
#define BMK_DURABILITY_XTRANSACTION						DBPROPVAL_BD_XTRANSACTION
#define BMK_DURABILITY_REORGANIZATION					DBPROPVAL_BD_REORGANIZATION
#define DBPROPVAL_BO_NOLOG								0x00000000L
#define DBPROPVAL_BO_NOINDEXUPDATE						0x00000001L
#define DBPROPVAL_BO_REFINTEGRITY						0x00000002L
#if !defined(_WINBASE_)
#define OF_READ             0x00000000
#define OF_WRITE            0x00000001
#define OF_READWRITE        0x00000002
#define OF_SHARE_COMPAT     0x00000000
#define OF_SHARE_EXCLUSIVE  0x00000010
#define OF_SHARE_DENY_WRITE 0x00000020
#define OF_SHARE_DENY_READ  0x00000030
#define OF_SHARE_DENY_NONE  0x00000040
#define OF_PARSE            0x00000100
#define OF_DELETE           0x00000200
#define OF_VERIFY           0x00000400
#define OF_CANCEL           0x00000800
#define OF_CREATE           0x00001000
#define OF_PROMPT           0x00002000
#define OF_EXIST            0x00004000
#define OF_REOPEN           0x00008000
#endif // !_WINBASE_
#define DBPROPVAL_STGM_READ					OF_READ
#define DBPROPVAL_STGM_WRITE					OF_WRITE
#define DBPROPVAL_STGM_READWRITE				OF_READWRITE
#define DBPROPVAL_STGM_SHARE_DENY_NONE		OF_SHARE_DENY_NONE
#define DBPROPVAL_STGM_SHARE_DENY_READ		OF_SHARE_DENY_READ
#define DBPROPVAL_STGM_SHARE_DENY_WRITE		OF_SHARE_DENY_WRITE
#define DBPROPVAL_STGM_SHARE_EXCLUSIVE		OF_SHARE_EXCLUSIVE
#define DBPROPVAL_STGM_DIRECT				0x00010000
#define DBPROPVAL_STGM_TRANSACTED			0x00020000
#define DBPROPVAL_STGM_CREATE				OF_CREATE
#define DBPROPVAL_STGM_CONVERT				0x00040000
#define DBPROPVAL_STGM_FAILIFTHERE			0x00080000
#define DBPROPVAL_STGM_PRIORITY				0x00100000
#define DBPROPVAL_STGM_DELETEONRELEASE		0x00200000
#define DBPROPVAL_GB_COLLATE 				0x00000010L
#define DBPROPVAL_CS_UNINITIALIZED			0x00000000L
#define DBPROPVAL_CS_INITIALIZED				0x00000001L
#define DBPROPVAL_CS_COMMUNICATIONFAILURE	0x00000002L
#define DBPROPVAL_RD_RESETALL		0xffffffffL
#define DBPROPVAL_OS_RESOURCEPOOLING	0x00000001L
#define DBPROPVAL_OS_TXNENLISTMENT	0x00000002L
#define DBPROPVAL_OS_CLIENTCURSOR    0x00000004L
#define DBPROPVAL_OS_ENABLEALL		0xffffffffL
#define DBPROPVAL_BI_CROSSROWSET		0x00000001L

#define MDPROPVAL_NL_SCHEMAONLY                          0x00000004L
#define DBPROPVAL_OS_DISABLEALL	0x00000000L
#define DBPROPVAL_OO_ROWOBJECT							0x00000004L
#define DBPROPVAL_OO_SCOPED								0x00000008L
#define DBPROPVAL_OO_DIRECTBIND							0x00000010L
#define DBPROPVAL_DST_DOCSOURCE                          0x00000004L
#define DBPROPVAL_GU_NOTSUPPORTED                         0x00000001L
#define DBPROPVAL_GU_SUFFIX		                         0x00000002L
#define DB_BINDFLAGS_DELAYFETCHCOLUMNS                    0x00000001L
#define DB_BINDFLAGS_DELAYFETCHSTREAM                     0x00000002L
#define DB_BINDFLAGS_RECURSIVE		                     0x00000004L
#define DB_BINDFLAGS_OUTPUT								 0x00000008L
#define DB_BINDFLAGS_COLLECTION							 0x00000010L
#define DB_BINDFLAGS_OPENIFEXISTS						 0x00000020L
#define DB_BINDFLAGS_OVERWRITE							 0x00000040L
#define DB_BINDFLAGS_ISSTRUCTUREDDOCUMENT				 0x00000080L
#define DBPROPVAL_ORS_TABLE								 0x00000000L
#define DBPROPVAL_ORS_INDEX                               0x00000001L
#define DBPROPVAL_ORS_INTEGRATEDINDEX		             0x00000002L
#define DBPROPVAL_TC_DDL_LOCK							 0x00000010L
#define DBPROPVAL_ORS_STOREDPROC							 0x00000004L
#define DBPROPVAL_IN_ALLOWNULL	                         0x00000000L

#define DB_IMP_LEVEL_ANONYMOUS       0x00
#define DB_IMP_LEVEL_IDENTIFY        0x01
#define DB_IMP_LEVEL_IMPERSONATE     0x02
#define DB_IMP_LEVEL_DELEGATE        0x03
#define DBPROMPT_PROMPT              0x01
#define DBPROMPT_COMPLETE            0x02
#define DBPROMPT_COMPLETEREQUIRED    0x03
#define DBPROMPT_NOPROMPT            0x04
#define DB_PROT_LEVEL_NONE           0x00
#define DB_PROT_LEVEL_CONNECT        0x01
#define DB_PROT_LEVEL_CALL           0x02
#define DB_PROT_LEVEL_PKT            0x03
#define DB_PROT_LEVEL_PKT_INTEGRITY  0x04
#define DB_PROT_LEVEL_PKT_PRIVACY    0x05
#define DB_MODE_READ                 0x01
#define DB_MODE_WRITE                0x02
#define DB_MODE_READWRITE            0x03
#define DB_MODE_SHARE_DENY_READ      0x04
#define DB_MODE_SHARE_DENY_WRITE     0x08
#define DB_MODE_SHARE_EXCLUSIVE		0x0c
#define DB_MODE_SHARE_DENY_NONE		0x10
#define DBCOMPUTEMODE_COMPUTED       0x01
#define DBCOMPUTEMODE_DYNAMIC        0x02
#define DBCOMPUTEMODE_NOTCOMPUTED    0x03
#define DBPROPVAL_DF_INITIALLY_DEFERRED      0x01
#define DBPROPVAL_DF_INITIALLY_IMMEDIATE     0x02
#define DBPROPVAL_DF_NOT_DEFERRABLE		    0x03

typedef struct  tagDBPARAMS
    {
    void  *pData;
    DB_UPARAMS cParamSets;
    HACCESSOR hAccessor;
    }	DBPARAMS;

typedef DWORD DBPARAMFLAGS;


enum DBPARAMFLAGSENUM
    {	DBPARAMFLAGS_ISINPUT	= 0x1,
	DBPARAMFLAGS_ISOUTPUT	= 0x2,
	DBPARAMFLAGS_ISSIGNED	= 0x10,
	DBPARAMFLAGS_ISNULLABLE	= 0x40,
	DBPARAMFLAGS_ISLONG	= 0x80
    };

enum DBPARAMFLAGSENUM20
    {	DBPARAMFLAGS_SCALEISNEGATIVE	= 0x100
    };

typedef struct  tagDBPARAMINFO
    {
    DBPARAMFLAGS dwFlags;
    DBORDINAL iOrdinal;
    LPOLESTR pwszName;
    ITypeInfo  *pTypeInfo;
    DBLENGTH ulParamSize;
    DBTYPE wType;
    BYTE bPrecision;
    BYTE bScale;
    }	DBPARAMINFO;

typedef DWORD DBPROPID;

typedef struct  tagDBPROPIDSET
    {
    /* [size_is] */ DBPROPID  *rgPropertyIDs;
    ULONG cPropertyIDs;
    GUID guidPropertySet;
    }	DBPROPIDSET;

typedef DWORD DBPROPFLAGS;


enum DBPROPFLAGSENUM
    {	DBPROPFLAGS_NOTSUPPORTED	= 0,
	DBPROPFLAGS_COLUMN	= 0x1,
	DBPROPFLAGS_DATASOURCE	= 0x2,
	DBPROPFLAGS_DATASOURCECREATE	= 0x4,
	DBPROPFLAGS_DATASOURCEINFO	= 0x8,
	DBPROPFLAGS_DBINIT	= 0x10,
	DBPROPFLAGS_INDEX	= 0x20,
	DBPROPFLAGS_ROWSET	= 0x40,
	DBPROPFLAGS_TABLE	= 0x80,
	DBPROPFLAGS_COLUMNOK	= 0x100,
	DBPROPFLAGS_READ	= 0x200,
	DBPROPFLAGS_WRITE	= 0x400,
	DBPROPFLAGS_REQUIRED	= 0x800,
	DBPROPFLAGS_SESSION	= 0x1000
    };

enum DBPROPFLAGSENUM21
    {	DBPROPFLAGS_TRUSTEE	= 0x2000
    };

#if defined(MIPSII_FP) || defined(MIPSIV) || defined(MIPSIV_FP)
#pragma pack(push,8)
#endif
typedef struct  tagDBPROPINFO
    {
    LPOLESTR pwszDescription;
    DBPROPID dwPropertyID;
    DBPROPFLAGS dwFlags;
    VARTYPE vtType;
    VARIANT vValues;
    }	DBPROPINFO;
#if defined(MIPSII_FP) || defined(MIPSIV) || defined(MIPSIV_FP)
#pragma pack(pop)
#endif

#if 0 
//DBPROPINFO is an unaligned structure. MIDL workaround. 42212352
typedef DBPROPINFO  *PDBPROPINFO;

#else
typedef DBPROPINFO UNALIGNED  * PDBPROPINFO;      //????????????
#endif
typedef struct  tagDBPROPINFOSET
    {
    /* [size_is] */ PDBPROPINFO rgPropertyInfos;
    ULONG cPropertyInfos;
    GUID guidPropertySet;
    }	DBPROPINFOSET;

typedef DWORD DBPROPOPTIONS;

// DBPROPOPTIONS_SETIFCHEAP is deprecated; use DBPROPOPTIONS_OPTIONAL instead.

enum DBPROPOPTIONSENUM
    {	DBPROPOPTIONS_REQUIRED	= 0,
	DBPROPOPTIONS_SETIFCHEAP	= 0x1,
	DBPROPOPTIONS_OPTIONAL	= 0x1
    };
typedef DWORD DBPROPSTATUS;


enum DBPROPSTATUSENUM
    {	DBPROPSTATUS_OK	= 0,
	DBPROPSTATUS_NOTSUPPORTED	= 1,
	DBPROPSTATUS_BADVALUE	= 2,
	DBPROPSTATUS_BADOPTION	= 3,
	DBPROPSTATUS_BADCOLUMN	= 4,
	DBPROPSTATUS_NOTALLSETTABLE	= 5,
	DBPROPSTATUS_NOTSETTABLE	= 6,
	DBPROPSTATUS_NOTSET	= 7,
	DBPROPSTATUS_CONFLICTING	= 8
    };

enum DBPROPSTATUSENUM21
    {	DBPROPSTATUS_NOTAVAILABLE	= 9
    };

#if defined(MIPSII_FP) || defined(MIPSIV) || defined(MIPSIV_FP)
#pragma pack(push,8)
#endif
typedef struct  tagDBPROP
    {
    DBPROPID dwPropertyID;
    DBPROPOPTIONS dwOptions;
    DBPROPSTATUS dwStatus;
    DBID colid;
    VARIANT vValue;
    }	DBPROP;
#if defined(MIPSII_FP) || defined(MIPSIV) || defined(MIPSIV_FP)
#pragma pack(pop)
#endif

typedef struct  tagDBPROPSET
    {
    /* [size_is] */ DBPROP  *rgProperties;
    ULONG cProperties;
    GUID guidPropertySet;
    }	DBPROPSET;

#define DBPARAMTYPE_INPUT			0x01
#define DBPARAMTYPE_INPUTOUTPUT		0x02
#define DBPARAMTYPE_OUTPUT			0x03
#define DBPARAMTYPE_RETURNVALUE		0x04
#define DB_PT_UNKNOWN				0x01
#define DB_PT_PROCEDURE				0x02
#define DB_PT_FUNCTION				0x03
#define DB_REMOTE					0x01
#define DB_LOCAL_SHARED				0x02
#define DB_LOCAL_EXCLUSIVE			0x03
#define DB_COLLATION_ASC				0x01
#define DB_COLLATION_DESC			0x02
#define DB_UNSEARCHABLE				0x01
#define DB_LIKE_ONLY					0x02
#define DB_ALL_EXCEPT_LIKE			0x03
#define DB_SEARCHABLE				0x04

#define MDTREEOP_CHILDREN            0x01
#define MDTREEOP_SIBLINGS            0x02
#define MDTREEOP_PARENT              0x04
#define MDTREEOP_SELF                0x08
#define MDTREEOP_DESCENDANTS         0x10
#define MDTREEOP_ANCESTORS			0x20
#define MD_DIMTYPE_UNKNOWN           0x00
#define MD_DIMTYPE_TIME              0x01
#define MD_DIMTYPE_MEASURE           0x02
#define MD_DIMTYPE_OTHER             0x03
#define MDLEVEL_TYPE_UNKNOWN         0x0000
#define MDLEVEL_TYPE_REGULAR         0x0000
#define MDLEVEL_TYPE_ALL             0x0001
#define MDLEVEL_TYPE_CALCULATED      0x0002
#define MDLEVEL_TYPE_TIME            0x0004
#define MDLEVEL_TYPE_RESERVED1       0x0008
#define MDLEVEL_TYPE_TIME_YEARS      0x0014
#define MDLEVEL_TYPE_TIME_HALF_YEAR  0x0024
#define MDLEVEL_TYPE_TIME_QUARTERS   0x0044
#define MDLEVEL_TYPE_TIME_MONTHS     0x0084
#define MDLEVEL_TYPE_TIME_WEEKS      0x0104
#define MDLEVEL_TYPE_TIME_DAYS       0x0204
#define MDLEVEL_TYPE_TIME_HOURS      0x0304
#define MDLEVEL_TYPE_TIME_MINUTES    0x0404
#define MDLEVEL_TYPE_TIME_SECONDS    0x0804
#define MDLEVEL_TYPE_TIME_UNDEFINED  0x1004
#define MDMEASURE_AGGR_UNKNOWN       0x00
#define MDMEASURE_AGGR_SUM           0x01
#define MDMEASURE_AGGR_COUNT         0x02
#define MDMEASURE_AGGR_MIN           0x03
#define MDMEASURE_AGGR_MAX           0x04
#define MDMEASURE_AGGR_AVG           0x05
#define MDMEASURE_AGGR_VAR           0x06
#define MDMEASURE_AGGR_STD           0x07
#define MDMEASURE_AGGR_CALCULATED    0x7f
#define MDPROP_MEMBER                0x01
#define MDPROP_CELL                  0x02
#define MDMEMBER_TYPE_UNKNOWN        0x00
#define MDMEMBER_TYPE_REGULAR        0x01
#define MDMEMBER_TYPE_ALL            0x02
#define MDMEMBER_TYPE_MEASURE        0x03
#define MDMEMBER_TYPE_FORMULA        0x04
#define MDMEMBER_TYPE_RESERVE1       0x05
#define MDMEMBER_TYPE_RESERVE2       0x06
#define MDMEMBER_TYPE_RESERVE3       0x07
#define MDMEMBER_TYPE_RESERVE4       0x08
#define MDDISPINFO_DRILLED_DOWN				0x00010000
#define MDDISPINFO_PARENT_SAME_AS_PREV		0x00020000

typedef DWORD DBINDEX_COL_ORDER;


enum DBINDEX_COL_ORDERENUM
    {	DBINDEX_COL_ORDER_ASC	= 0,
	DBINDEX_COL_ORDER_DESC	= DBINDEX_COL_ORDER_ASC + 1
    };

typedef struct  tagDBINDEXCOLUMNDESC
    {
    DBID  *pColumnID;
    DBINDEX_COL_ORDER eIndexColOrder;
    }	DBINDEXCOLUMNDESC;

typedef struct  tagDBCOLUMNDESC
    {
    LPOLESTR pwszTypeName;
    ITypeInfo  *pTypeInfo;
    /* [size_is] */ DBPROPSET  *rgPropertySets;
    CLSID  *pclsid;
    ULONG cPropertySets;
    DBLENGTH ulColumnSize;
    DBID dbcid;
    DBTYPE wType;
    BYTE bPrecision;
    BYTE bScale;
    }	DBCOLUMNDESC;

typedef struct  tagDBCOLUMNACCESS
    {
    void  *pData;
    DBID columnid;
    DBLENGTH cbDataLen;
    DBSTATUS dwStatus;
    DBLENGTH cbMaxLen;
    DB_DWRESERVE dwReserved;
    DBTYPE wType;
    BYTE bPrecision;
    BYTE bScale;
    }	DBCOLUMNACCESS;

typedef DWORD DBCOLUMNDESCFLAGS;


enum DBCOLUMNDESCFLAGSENUM
    {	DBCOLUMNDESCFLAGS_TYPENAME	= 0x1,
	DBCOLUMNDESCFLAGS_ITYPEINFO	= 0x2,
	DBCOLUMNDESCFLAGS_PROPERTIES	= 0x4,
	DBCOLUMNDESCFLAGS_CLSID	= 0x8,
	DBCOLUMNDESCFLAGS_COLSIZE	= 0x10,
	DBCOLUMNDESCFLAGS_DBCID	= 0x20,
	DBCOLUMNDESCFLAGS_WTYPE	= 0x40,
	DBCOLUMNDESCFLAGS_PRECISION	= 0x80,
	DBCOLUMNDESCFLAGS_SCALE	= 0x100
    };

typedef DWORD DBEVENTPHASE;


enum DBEVENTPHASEENUM
    {	DBEVENTPHASE_OKTODO	= 0,
	DBEVENTPHASE_ABOUTTODO	= DBEVENTPHASE_OKTODO + 1,
	DBEVENTPHASE_SYNCHAFTER	= DBEVENTPHASE_ABOUTTODO + 1,
	DBEVENTPHASE_FAILEDTODO	= DBEVENTPHASE_SYNCHAFTER + 1,
	DBEVENTPHASE_DIDEVENT	= DBEVENTPHASE_FAILEDTODO + 1
    };
typedef DWORD DBREASON;


enum DBREASONENUM
    {	DBREASON_ROWSET_FETCHPOSITIONCHANGE	= 0,
	DBREASON_ROWSET_RELEASE	= DBREASON_ROWSET_FETCHPOSITIONCHANGE + 1,
	DBREASON_COLUMN_SET	= DBREASON_ROWSET_RELEASE + 1,
	DBREASON_COLUMN_RECALCULATED	= DBREASON_COLUMN_SET + 1,
	DBREASON_ROW_ACTIVATE	= DBREASON_COLUMN_RECALCULATED + 1,
	DBREASON_ROW_RELEASE	= DBREASON_ROW_ACTIVATE + 1,
	DBREASON_ROW_DELETE	= DBREASON_ROW_RELEASE + 1,
	DBREASON_ROW_FIRSTCHANGE	= DBREASON_ROW_DELETE + 1,
	DBREASON_ROW_INSERT	= DBREASON_ROW_FIRSTCHANGE + 1,
	DBREASON_ROW_RESYNCH	= DBREASON_ROW_INSERT + 1,
	DBREASON_ROW_UNDOCHANGE	= DBREASON_ROW_RESYNCH + 1,
	DBREASON_ROW_UNDOINSERT	= DBREASON_ROW_UNDOCHANGE + 1,
	DBREASON_ROW_UNDODELETE	= DBREASON_ROW_UNDOINSERT + 1,
	DBREASON_ROW_UPDATE	= DBREASON_ROW_UNDODELETE + 1,
	DBREASON_ROWSET_CHANGED	= DBREASON_ROW_UPDATE + 1
    };

enum DBREASONENUM15
    {	DBREASON_ROWPOSITION_CHANGED	= DBREASON_ROWSET_CHANGED + 1,
	DBREASON_ROWPOSITION_CHAPTERCHANGED	= DBREASON_ROWPOSITION_CHANGED + 1,
	DBREASON_ROWPOSITION_CLEARED	= DBREASON_ROWPOSITION_CHAPTERCHANGED + 1,
	DBREASON_ROW_ASYNCHINSERT	= DBREASON_ROWPOSITION_CLEARED + 1
    };

typedef DWORD DBCOMPAREOP;


enum DBCOMPAREOPSENUM
    {	DBCOMPAREOPS_LT	= 0,
	DBCOMPAREOPS_LE	= 1,
	DBCOMPAREOPS_EQ	= 2,
	DBCOMPAREOPS_GE	= 3,
	DBCOMPAREOPS_GT	= 4,
	DBCOMPAREOPS_BEGINSWITH	= 5,
	DBCOMPAREOPS_CONTAINS	= 6,
	DBCOMPAREOPS_NE	= 7,
	DBCOMPAREOPS_IGNORE	= 8,
	DBCOMPAREOPS_CASESENSITIVE	= 0x1000,
	DBCOMPAREOPS_CASEINSENSITIVE	= 0x2000
    };

enum DBCOMPAREOPSENUM20
    {	DBCOMPAREOPS_NOTBEGINSWITH	= 9,
	DBCOMPAREOPS_NOTCONTAINS	= 10
    };

typedef DWORD DBASYNCHOP;


enum DBASYNCHOPENUM
    {	DBASYNCHOP_OPEN	= 0
    };
typedef DWORD DBASYNCHPHASE;


enum DBASYNCHPHASEENUM
    {	DBASYNCHPHASE_INITIALIZATION	= 0,
	DBASYNCHPHASE_POPULATION	= DBASYNCHPHASE_INITIALIZATION + 1,
	DBASYNCHPHASE_COMPLETE	= DBASYNCHPHASE_POPULATION + 1,
	DBASYNCHPHASE_CANCELED	= DBASYNCHPHASE_COMPLETE + 1
    };
#define DB_COUNTUNAVAILABLE -1

typedef DWORD DBSORT;


enum DBSORTENUM
    {	DBSORT_ASCENDING	= 0,
	DBSORT_DESCENDING	= DBSORT_ASCENDING + 1
    };

typedef DWORD DBCOMMANDPERSISTFLAG;


enum DBCOMMANDPERSISTFLAGENUM
    {	DBCOMMANDPERSISTFLAG_NOSAVE	= 0x1
    };

enum DBCOMMANDPERSISTFLAGENUM21
    {	DBCOMMANDPERSISTFLAG_DEFAULT	= 0,
	DBCOMMANDPERSISTFLAG_PERSISTVIEW	= 0x2,
	DBCOMMANDPERSISTFLAG_PERSISTPROCEDURE	= 0x4
    };
typedef DWORD DBCONSTRAINTTYPE;


enum DBCONSTRAINTTYPEENUM
    {	DBCONSTRAINTTYPE_UNIQUE	= 0,
	DBCONSTRAINTTYPE_FOREIGNKEY	= 0x1,
	DBCONSTRAINTTYPE_PRIMARYKEY	= 0x2,
	DBCONSTRAINTTYPE_CHECK	= 0x3,
	DBCONSTRAINTTYPE_SSCE_DEFAULT = 0x4
    };
typedef DWORD DBUPDELRULE;


enum DBUPDELRULEENUM
    {	DBUPDELRULE_NOACTION	= 0,
	DBUPDELRULE_CASCADE	= 0x1,
	DBUPDELRULE_SETNULL	= 0x2,
	DBUPDELRULE_SETDEFAULT	= 0x3
    };
typedef DWORD DBMATCHTYPE;


enum DBMATCHTYPEENUM
    {	DBMATCHTYPE_FULL	= 0,
	DBMATCHTYPE_NONE	= 0x1,
	DBMATCHTYPE_PARTIAL	= 0x2
    };
typedef DWORD DBDEFERRABILITY;


enum DBDEFERRABILITYENUM
    {	DBDEFERRABILITY_DEFERRED	= 0x1,
	DBDEFERRABILITY_DEFERRABLE	= 0x2
    };
typedef struct  tagDBCONSTRAINTDESC
    {
    DBID  *pConstraintID;
    DBCONSTRAINTTYPE ConstraintType;
    DBORDINAL cColumns;
    /* [size_is] */ DBID  *rgColumnList;
    DBID  *pReferencedTableID;
    DBORDINAL cForeignKeyColumns;
    /* [size_is] */ DBID  *rgForeignKeyColumnList;
    OLECHAR  *pwszConstraintText;
    DBUPDELRULE UpdateRule;
    DBUPDELRULE DeleteRule;
    DBMATCHTYPE MatchType;
    DBDEFERRABILITY Deferrability;
    DB_URESERVE cReserved;
    /* [size_is] */ DBPROPSET  *rgReserved;
    }	DBCONSTRAINTDESC;

#define MDFF_BOLD                    0x01
#define MDFF_ITALIC                  0x02
#define MDFF_UNDERLINE               0x04
#define MDFF_STRIKEOUT               0x08
typedef struct  tagMDAXISINFO
    {
    DBLENGTH cbSize;
    DBCOUNTITEM iAxis;
    DBCOUNTITEM cDimensions;
    DBCOUNTITEM cCoordinates;
    DBORDINAL *rgcColumns;
    LPOLESTR  *rgpwszDimensionNames;
    }	MDAXISINFO;

#define PMDAXISINFO_GETAT(rgAxisInfo, iAxis) ((MDAXISINFO *)(((BYTE *)(rgAxisInfo)) +((iAxis) * (rgAxisInfo)[0].cbSize)))
#define MDAXISINFO_GETAT(rgAxisInfo, iAxis) (*PMDAXISINFO_GETAT((rgAxisInfo), (iAxis)))
#define MDAXIS_COLUMNS               0x00000000
#define MDAXIS_ROWS                  0x00000001
#define MDAXIS_PAGES                 0x00000002
#define MDAXIS_SECTIONS              0x00000003
#define MDAXIS_CHAPTERS              0x00000004
#define MDAXIS_SLICERS               0xffffffff

extern RPC_IF_HANDLE DBStructureDefinitions_v0_0_c_ifspec;
extern RPC_IF_HANDLE DBStructureDefinitions_v0_0_s_ifspec;
#endif /* __DBStructureDefinitions_INTERFACE_DEFINED__ */

#ifndef __IAccessor_INTERFACE_DEFINED__
#define __IAccessor_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAccessor
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 


typedef DWORD DBACCESSORFLAGS;


enum DBACCESSORFLAGSENUM
    {	DBACCESSOR_INVALID	= 0,
	DBACCESSOR_PASSBYREF	= 0x1,
	DBACCESSOR_ROWDATA	= 0x2,
	DBACCESSOR_PARAMETERDATA	= 0x4,
	DBACCESSOR_OPTIMIZED	= 0x8,
	DBACCESSOR_INHERITED	= 0x10
    };
typedef DWORD DBBINDSTATUS;


enum DBBINDSTATUSENUM
    {	DBBINDSTATUS_OK	= 0,
	DBBINDSTATUS_BADORDINAL	= 1,
	DBBINDSTATUS_UNSUPPORTEDCONVERSION	= 2,
	DBBINDSTATUS_BADBINDINFO	= 3,
	DBBINDSTATUS_BADSTORAGEFLAGS	= 4,
	DBBINDSTATUS_NOINTERFACE	= 5,
	DBBINDSTATUS_MULTIPLESTORAGE	= 6
    };

EXTERN_C const IID IID_IAccessor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a8c-2a1c-11ce-ade5-00aa0044773d")
    IAccessor : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE AddRefAccessor( 
            /* [in] */ HACCESSOR hAccessor,
            /* [unique][out][in] */ DBREFCOUNT *pcRefCount) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CreateAccessor( 
            /* [in] */ DBACCESSORFLAGS dwAccessorFlags,
            /* [in] */ DBCOUNTITEM cBindings,
            /* [size_is][in] */ const DBBINDING  rgBindings[  ],
            /* [in] */ DBLENGTH cbRowSize,
            /* [out] */ HACCESSOR  *phAccessor,
            /* [size_is][out] */ DBBINDSTATUS  rgStatus[  ]) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetBindings( 
            /* [in] */ HACCESSOR hAccessor,
            /* [out] */ DBACCESSORFLAGS  *pdwAccessorFlags,
            /* [out][in] */ DBCOUNTITEM *pcBindings,
            /* [size_is][size_is][out] */ DBBINDING  * *prgBindings) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE ReleaseAccessor( 
            /* [in] */ HACCESSOR hAccessor,
            /* [unique][out][in] */ DBREFCOUNT *pcRefCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAccessorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IAccessor  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IAccessor  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IAccessor  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *AddRefAccessor )( 
            IAccessor  * This,
            /* [in] */ HACCESSOR hAccessor,
            /* [unique][out][in] */ DBREFCOUNT *pcRefCount);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *CreateAccessor )( 
            IAccessor  * This,
            /* [in] */ DBACCESSORFLAGS dwAccessorFlags,
            /* [in] */ DBCOUNTITEM cBindings,
            /* [size_is][in] */ const DBBINDING  rgBindings[  ],
            /* [in] */ DBLENGTH cbRowSize,
            /* [out] */ HACCESSOR  *phAccessor,
            /* [size_is][out] */ DBBINDSTATUS  rgStatus[  ]);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetBindings )( 
            IAccessor  * This,
            /* [in] */ HACCESSOR hAccessor,
            /* [out] */ DBACCESSORFLAGS  *pdwAccessorFlags,
            /* [out][in] */ DBCOUNTITEM *pcBindings,
            /* [size_is][size_is][out] */ DBBINDING  * *prgBindings);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *ReleaseAccessor )( 
            IAccessor  * This,
            /* [in] */ HACCESSOR hAccessor,
            /* [unique][out][in] */ DBREFCOUNT *pcRefCount);
        
        END_INTERFACE
    } IAccessorVtbl;

    interface IAccessor
    {
        CONST_VTBL struct IAccessorVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAccessor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAccessor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAccessor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAccessor_AddRefAccessor(This,hAccessor,pcRefCount)	\
    (This)->lpVtbl -> AddRefAccessor(This,hAccessor,pcRefCount)

#define IAccessor_CreateAccessor(This,dwAccessorFlags,cBindings,rgBindings,cbRowSize,phAccessor,rgStatus)	\
    (This)->lpVtbl -> CreateAccessor(This,dwAccessorFlags,cBindings,rgBindings,cbRowSize,phAccessor,rgStatus)

#define IAccessor_GetBindings(This,hAccessor,pdwAccessorFlags,pcBindings,prgBindings)	\
    (This)->lpVtbl -> GetBindings(This,hAccessor,pdwAccessorFlags,pcBindings,prgBindings)

#define IAccessor_ReleaseAccessor(This,hAccessor,pcRefCount)	\
    (This)->lpVtbl -> ReleaseAccessor(This,hAccessor,pcRefCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IAccessor_RemoteAddRefAccessor_Proxy( 
    IAccessor  * This,
    /* [in] */ HACCESSOR hAccessor,
    /* [unique][out][in] */ DBREFCOUNT *pcRefCount,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IAccessor_RemoteAddRefAccessor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IAccessor_RemoteCreateAccessor_Proxy( 
    IAccessor  * This,
    /* [in] */ DBACCESSORFLAGS dwAccessorFlags,
    /* [in] */ DBCOUNTITEM cBindings,
    /* [size_is][unique][in] */ DBBINDING  *rgBindings,
    /* [in] */ DBLENGTH cbRowSize,
    /* [out] */ HACCESSOR  *phAccessor,
    /* [size_is][unique][out][in] */ DBBINDSTATUS  *rgStatus,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IAccessor_RemoteCreateAccessor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IAccessor_RemoteGetBindings_Proxy( 
    IAccessor  * This,
    /* [in] */ HACCESSOR hAccessor,
    /* [out] */ DBACCESSORFLAGS  *pdwAccessorFlags,
    /* [out][in] */ DBCOUNTITEM *pcBindings,
    /* [size_is][size_is][out] */ DBBINDING  * *prgBindings,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IAccessor_RemoteGetBindings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IAccessor_RemoteReleaseAccessor_Proxy( 
    IAccessor  * This,
    /* [in] */ HACCESSOR hAccessor,
    /* [unique][out][in] */ DBREFCOUNT *pcRefCount,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IAccessor_RemoteReleaseAccessor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAccessor_INTERFACE_DEFINED__ */


#ifndef __IRowset_INTERFACE_DEFINED__
#define __IRowset_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRowset
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object][local] */ 


typedef DWORD DBROWOPTIONS;


EXTERN_C const IID IID_IRowset;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a7c-2a1c-11ce-ade5-00aa0044773d")
    IRowset : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddRefRows( 
            /* [in] */ DBCOUNTITEM cRows,
            /* [size_is][in] */ const HROW  rghRows[  ],
            /* [size_is][out] */ DBREFCOUNT rgRefCounts[  ],
            /* [size_is][out] */ DBROWSTATUS  rgRowStatus[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetData( 
            /* [in] */ HROW hRow,
            /* [in] */ HACCESSOR hAccessor,
            /* [out] */ void  *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextRows( 
            /* [in] */ HCHAPTER hReserved,
            /* [in] */ DBROWOFFSET lRowsOffset,
            /* [in] */ DBROWCOUNT cRows,
            /* [out] */ DBCOUNTITEM *pcRowsObtained,
            /* [size_is][size_is][out] */ HROW  * *prghRows) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseRows( 
            /* [in] */ DBCOUNTITEM cRows,
            /* [size_is][in] */ const HROW  rghRows[  ],
            /* [size_is][in] */ DBROWOPTIONS  rgRowOptions[  ],
            /* [size_is][out] */ DBREFCOUNT rgRefCounts[  ],
            /* [size_is][out] */ DBROWSTATUS  rgRowStatus[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RestartPosition( 
            /* [in] */ HCHAPTER hReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRowsetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IRowset  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IRowset  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IRowset  * This);
        
        HRESULT ( STDMETHODCALLTYPE  *AddRefRows )( 
            IRowset  * This,
            /* [in] */ DBCOUNTITEM cRows,
            /* [size_is][in] */ const HROW  rghRows[  ],
            /* [size_is][out] */ DBREFCOUNT rgRefCounts[  ],
            /* [size_is][out] */ DBROWSTATUS  rgRowStatus[  ]);
        
        HRESULT ( STDMETHODCALLTYPE  *GetData )( 
            IRowset  * This,
            /* [in] */ HROW hRow,
            /* [in] */ HACCESSOR hAccessor,
            /* [out] */ void  *pData);
        
        HRESULT ( STDMETHODCALLTYPE  *GetNextRows )( 
            IRowset  * This,
            /* [in] */ HCHAPTER hReserved,
            /* [in] */ DBROWOFFSET lRowsOffset,
            /* [in] */ DBROWCOUNT cRows,
            /* [out] */ DBCOUNTITEM *pcRowsObtained,
            /* [size_is][size_is][out] */ HROW  * *prghRows);
        
        HRESULT ( STDMETHODCALLTYPE  *ReleaseRows )( 
            IRowset  * This,
            /* [in] */ DBCOUNTITEM cRows,
            /* [size_is][in] */ const HROW  rghRows[  ],
            /* [size_is][in] */ DBROWOPTIONS  rgRowOptions[  ],
            /* [size_is][out] */ DBREFCOUNT rgRefCounts[  ],
            /* [size_is][out] */ DBROWSTATUS  rgRowStatus[  ]);
        
        HRESULT ( STDMETHODCALLTYPE  *RestartPosition )( 
            IRowset  * This,
            /* [in] */ HCHAPTER hReserved);
        
        END_INTERFACE
    } IRowsetVtbl;

    interface IRowset
    {
        CONST_VTBL struct IRowsetVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRowset_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRowset_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRowset_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRowset_AddRefRows(This,cRows,rghRows,rgRefCounts,rgRowStatus)	\
    (This)->lpVtbl -> AddRefRows(This,cRows,rghRows,rgRefCounts,rgRowStatus)

#define IRowset_GetData(This,hRow,hAccessor,pData)	\
    (This)->lpVtbl -> GetData(This,hRow,hAccessor,pData)

#define IRowset_GetNextRows(This,hReserved,lRowsOffset,cRows,pcRowsObtained,prghRows)	\
    (This)->lpVtbl -> GetNextRows(This,hReserved,lRowsOffset,cRows,pcRowsObtained,prghRows)

#define IRowset_ReleaseRows(This,cRows,rghRows,rgRowOptions,rgRefCounts,rgRowStatus)	\
    (This)->lpVtbl -> ReleaseRows(This,cRows,rghRows,rgRowOptions,rgRefCounts,rgRowStatus)

#define IRowset_RestartPosition(This,hReserved)	\
    (This)->lpVtbl -> RestartPosition(This,hReserved)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRowset_AddRefRows_Proxy( 
    IRowset  * This,
    /* [in] */ DBCOUNTITEM cRows,
    /* [size_is][in] */ const HROW  rghRows[  ],
    /* [size_is][out] */ DBREFCOUNT rgRefCounts[  ],
    /* [size_is][out] */ DBROWSTATUS  rgRowStatus[  ]);


void __RPC_STUB IRowset_AddRefRows_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRowset_GetData_Proxy( 
    IRowset  * This,
    /* [in] */ HROW hRow,
    /* [in] */ HACCESSOR hAccessor,
    /* [out] */ void  *pData);


void __RPC_STUB IRowset_GetData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRowset_GetNextRows_Proxy( 
    IRowset  * This,
    /* [in] */ HCHAPTER hReserved,
    /* [in] */ DBROWOFFSET lRowsOffset,
    /* [in] */ DBROWCOUNT cRows,
    /* [out] */ DBCOUNTITEM *pcRowsObtained,
    /* [size_is][size_is][out] */ HROW  * *prghRows);


void __RPC_STUB IRowset_GetNextRows_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRowset_ReleaseRows_Proxy( 
    IRowset  * This,
    /* [in] */ DBCOUNTITEM cRows,
    /* [size_is][in] */ const HROW  rghRows[  ],
    /* [size_is][in] */ DBROWOPTIONS  rgRowOptions[  ],
    /* [size_is][out] */ DBREFCOUNT rgRefCounts[  ],
    /* [size_is][out] */ DBROWSTATUS  rgRowStatus[  ]);


void __RPC_STUB IRowset_ReleaseRows_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRowset_RestartPosition_Proxy( 
    IRowset  * This,
    /* [in] */ HCHAPTER hReserved);


void __RPC_STUB IRowset_RestartPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRowset_INTERFACE_DEFINED__ */


#ifndef __IRowsetInfo_INTERFACE_DEFINED__
#define __IRowsetInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRowsetInfo
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IRowsetInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a55-2a1c-11ce-ade5-00aa0044773d")
    IRowsetInfo : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [in] */ const ULONG cPropertyIDSets,
            /* [size_is][in] */ const DBPROPIDSET  rgPropertyIDSets[  ],
            /* [out][in] */ ULONG  *pcPropertySets,
            /* [size_is][size_is][out] */ DBPROPSET  * *prgPropertySets) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetReferencedRowset( 
            /* [in] */ DBORDINAL iOrdinal,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown  * *ppReferencedRowset) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetSpecification( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown  * *ppSpecification) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRowsetInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IRowsetInfo  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IRowsetInfo  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IRowsetInfo  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetProperties )( 
            IRowsetInfo  * This,
            /* [in] */ const ULONG cPropertyIDSets,
            /* [size_is][in] */ const DBPROPIDSET  rgPropertyIDSets[  ],
            /* [out][in] */ ULONG  *pcPropertySets,
            /* [size_is][size_is][out] */ DBPROPSET  * *prgPropertySets);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetReferencedRowset )( 
            IRowsetInfo  * This,
            /* [in] */ DBORDINAL iOrdinal,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown  * *ppReferencedRowset);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetSpecification )( 
            IRowsetInfo  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown  * *ppSpecification);
        
        END_INTERFACE
    } IRowsetInfoVtbl;

    interface IRowsetInfo
    {
        CONST_VTBL struct IRowsetInfoVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRowsetInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRowsetInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRowsetInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRowsetInfo_GetProperties(This,cPropertyIDSets,rgPropertyIDSets,pcPropertySets,prgPropertySets)	\
    (This)->lpVtbl -> GetProperties(This,cPropertyIDSets,rgPropertyIDSets,pcPropertySets,prgPropertySets)

#define IRowsetInfo_GetReferencedRowset(This,iOrdinal,riid,ppReferencedRowset)	\
    (This)->lpVtbl -> GetReferencedRowset(This,iOrdinal,riid,ppReferencedRowset)

#define IRowsetInfo_GetSpecification(This,riid,ppSpecification)	\
    (This)->lpVtbl -> GetSpecification(This,riid,ppSpecification)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IRowsetInfo_RemoteGetProperties_Proxy( 
    IRowsetInfo  * This,
    /* [in] */ ULONG cPropertyIDSets,
    /* [size_is][unique][in] */ const DBPROPIDSET  *rgPropertyIDSets,
    /* [out][in] */ ULONG  *pcPropertySets,
    /* [size_is][size_is][out] */ DBPROPSET  * *prgPropertySets,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IRowsetInfo_RemoteGetProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IRowsetInfo_RemoteGetReferencedRowset_Proxy( 
    IRowsetInfo  * This,
    /* [in] */ DBORDINAL iOrdinal,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown  * *ppReferencedRowset,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IRowsetInfo_RemoteGetReferencedRowset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IRowsetInfo_RemoteGetSpecification_Proxy( 
    IRowsetInfo  * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown  * *ppSpecification,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IRowsetInfo_RemoteGetSpecification_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRowsetInfo_INTERFACE_DEFINED__ */


#ifndef __IRowsetLocate_INTERFACE_DEFINED__
#define __IRowsetLocate_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRowsetLocate
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object][local] */ 


typedef DWORD DBCOMPARE;


enum DBCOMPAREENUM
    {	DBCOMPARE_LT	= 0,
	DBCOMPARE_EQ	= DBCOMPARE_LT + 1,
	DBCOMPARE_GT	= DBCOMPARE_EQ + 1,
	DBCOMPARE_NE	= DBCOMPARE_GT + 1,
	DBCOMPARE_NOTCOMPARABLE	= DBCOMPARE_NE + 1
    };

EXTERN_C const IID IID_IRowsetLocate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a7d-2a1c-11ce-ade5-00aa0044773d")
    IRowsetLocate : public IRowset
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Compare( 
            /* [in] */ HCHAPTER hReserved,
            /* [in] */ DBBKMARK cbBookmark1,
            /* [size_is][in] */ const BYTE  *pBookmark1,
            /* [in] */ DBBKMARK cbBookmark2,
            /* [size_is][in] */ const BYTE  *pBookmark2,
            /* [out] */ DBCOMPARE  *pComparison) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRowsAt( 
            /* [in] */ HWATCHREGION hReserved1,
            /* [in] */ HCHAPTER hReserved2,
            /* [in] */ DBBKMARK cbBookmark,
            /* [size_is][in] */ const BYTE  *pBookmark,
            /* [in] */ DBROWOFFSET lRowsOffset,
            /* [in] */ DBROWCOUNT cRows,
            /* [out] */ DBCOUNTITEM *pcRowsObtained,
            /* [size_is][size_is][out] */ HROW  * *prghRows) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRowsByBookmark( 
            /* [in] */ HCHAPTER hReserved,
            /* [in] */ DBCOUNTITEM cRows,
            /* [size_is][in] */ const DBBKMARK rgcbBookmarks[  ],
            /* [size_is][in] */ const BYTE  * rgpBookmarks[  ],
            /* [size_is][out] */ HROW  rghRows[  ],
            /* [size_is][out] */ DBROWSTATUS  rgRowStatus[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Hash( 
            /* [in] */ HCHAPTER hReserved,
            /* [in] */ DBBKMARK cBookmarks,
            /* [size_is][in] */ const DBBKMARK rgcbBookmarks[  ],
            /* [size_is][in] */ const BYTE  * rgpBookmarks[  ],
            /* [size_is][out] */ DBHASHVALUE rgHashedValues[  ],
            /* [size_is][out] */ DBROWSTATUS  rgBookmarkStatus[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRowsetLocateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IRowsetLocate  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IRowsetLocate  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IRowsetLocate  * This);
        
        HRESULT ( STDMETHODCALLTYPE  *AddRefRows )( 
            IRowsetLocate  * This,
            /* [in] */ DBCOUNTITEM cRows,
            /* [size_is][in] */ const HROW  rghRows[  ],
            /* [size_is][out] */ DBREFCOUNT rgRefCounts[  ],
            /* [size_is][out] */ DBROWSTATUS  rgRowStatus[  ]);
        
        HRESULT ( STDMETHODCALLTYPE  *GetData )( 
            IRowsetLocate  * This,
            /* [in] */ HROW hRow,
            /* [in] */ HACCESSOR hAccessor,
            /* [out] */ void  *pData);
        
        HRESULT ( STDMETHODCALLTYPE  *GetNextRows )( 
            IRowsetLocate  * This,
            /* [in] */ HCHAPTER hReserved,
            /* [in] */ DBROWOFFSET lRowsOffset,
            /* [in] */ DBROWCOUNT cRows,
            /* [out] */ DBCOUNTITEM *pcRowsObtained,
            /* [size_is][size_is][out] */ HROW  * *prghRows);
        
        HRESULT ( STDMETHODCALLTYPE  *ReleaseRows )( 
            IRowsetLocate  * This,
            /* [in] */ DBCOUNTITEM cRows,
            /* [size_is][in] */ const HROW  rghRows[  ],
            /* [size_is][in] */ DBROWOPTIONS  rgRowOptions[  ],
            /* [size_is][out] */ DBREFCOUNT rgRefCounts[  ],
            /* [size_is][out] */ DBROWSTATUS  rgRowStatus[  ]);
        
        HRESULT ( STDMETHODCALLTYPE  *RestartPosition )( 
            IRowsetLocate  * This,
            /* [in] */ HCHAPTER hReserved);
        
        HRESULT ( STDMETHODCALLTYPE  *Compare )( 
            IRowsetLocate  * This,
            /* [in] */ HCHAPTER hReserved,
            /* [in] */ DBBKMARK cbBookmark1,
            /* [size_is][in] */ const BYTE  *pBookmark1,
            /* [in] */ DBBKMARK cbBookmark2,
            /* [size_is][in] */ const BYTE  *pBookmark2,
            /* [out] */ DBCOMPARE  *pComparison);
        
        HRESULT ( STDMETHODCALLTYPE  *GetRowsAt )( 
            IRowsetLocate  * This,
            /* [in] */ HWATCHREGION hReserved1,
            /* [in] */ HCHAPTER hReserved2,
            /* [in] */ DBBKMARK cbBookmark,
            /* [size_is][in] */ const BYTE  *pBookmark,
            /* [in] */ DBROWOFFSET lRowsOffset,
            /* [in] */ DBROWCOUNT cRows,
            /* [out] */ DBCOUNTITEM *pcRowsObtained,
            /* [size_is][size_is][out] */ HROW  * *prghRows);
        
        HRESULT ( STDMETHODCALLTYPE  *GetRowsByBookmark )( 
            IRowsetLocate  * This,
            /* [in] */ HCHAPTER hReserved,
            /* [in] */ DBCOUNTITEM cRows,
            /* [size_is][in] */ const DBBKMARK rgcbBookmarks[  ],
            /* [size_is][in] */ const BYTE  * rgpBookmarks[  ],
            /* [size_is][out] */ HROW  rghRows[  ],
            /* [size_is][out] */ DBROWSTATUS  rgRowStatus[  ]);
        
        HRESULT ( STDMETHODCALLTYPE  *Hash )( 
            IRowsetLocate  * This,
            /* [in] */ HCHAPTER hReserved,
            /* [in] */ DBBKMARK cBookmarks,
            /* [size_is][in] */ const DBBKMARK rgcbBookmarks[  ],
            /* [size_is][in] */ const BYTE  * rgpBookmarks[  ],
            /* [size_is][out] */ DBHASHVALUE rgHashedValues[  ],
            /* [size_is][out] */ DBROWSTATUS  rgBookmarkStatus[  ]);
        
        END_INTERFACE
    } IRowsetLocateVtbl;

    interface IRowsetLocate
    {
        CONST_VTBL struct IRowsetLocateVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRowsetLocate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRowsetLocate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRowsetLocate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRowsetLocate_AddRefRows(This,cRows,rghRows,rgRefCounts,rgRowStatus)	\
    (This)->lpVtbl -> AddRefRows(This,cRows,rghRows,rgRefCounts,rgRowStatus)

#define IRowsetLocate_GetData(This,hRow,hAccessor,pData)	\
    (This)->lpVtbl -> GetData(This,hRow,hAccessor,pData)

#define IRowsetLocate_GetNextRows(This,hReserved,lRowsOffset,cRows,pcRowsObtained,prghRows)	\
    (This)->lpVtbl -> GetNextRows(This,hReserved,lRowsOffset,cRows,pcRowsObtained,prghRows)

#define IRowsetLocate_ReleaseRows(This,cRows,rghRows,rgRowOptions,rgRefCounts,rgRowStatus)	\
    (This)->lpVtbl -> ReleaseRows(This,cRows,rghRows,rgRowOptions,rgRefCounts,rgRowStatus)

#define IRowsetLocate_RestartPosition(This,hReserved)	\
    (This)->lpVtbl -> RestartPosition(This,hReserved)


#define IRowsetLocate_Compare(This,hReserved,cbBookmark1,pBookmark1,cbBookmark2,pBookmark2,pComparison)	\
    (This)->lpVtbl -> Compare(This,hReserved,cbBookmark1,pBookmark1,cbBookmark2,pBookmark2,pComparison)

#define IRowsetLocate_GetRowsAt(This,hReserved1,hReserved2,cbBookmark,pBookmark,lRowsOffset,cRows,pcRowsObtained,prghRows)	\
    (This)->lpVtbl -> GetRowsAt(This,hReserved1,hReserved2,cbBookmark,pBookmark,lRowsOffset,cRows,pcRowsObtained,prghRows)

#define IRowsetLocate_GetRowsByBookmark(This,hReserved,cRows,rgcbBookmarks,rgpBookmarks,rghRows,rgRowStatus)	\
    (This)->lpVtbl -> GetRowsByBookmark(This,hReserved,cRows,rgcbBookmarks,rgpBookmarks,rghRows,rgRowStatus)

#define IRowsetLocate_Hash(This,hReserved,cBookmarks,rgcbBookmarks,rgpBookmarks,rgHashedValues,rgBookmarkStatus)	\
    (This)->lpVtbl -> Hash(This,hReserved,cBookmarks,rgcbBookmarks,rgpBookmarks,rgHashedValues,rgBookmarkStatus)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRowsetLocate_Compare_Proxy( 
    IRowsetLocate  * This,
    /* [in] */ HCHAPTER hReserved,
    /* [in] */ DBBKMARK cbBookmark1,
    /* [size_is][in] */ const BYTE  *pBookmark1,
    /* [in] */ DBBKMARK cbBookmark2,
    /* [size_is][in] */ const BYTE  *pBookmark2,
    /* [out] */ DBCOMPARE  *pComparison);


void __RPC_STUB IRowsetLocate_Compare_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRowsetLocate_GetRowsAt_Proxy( 
    IRowsetLocate  * This,
    /* [in] */ HWATCHREGION hReserved1,
    /* [in] */ HCHAPTER hReserved2,
    /* [in] */ DBBKMARK cbBookmark,
    /* [size_is][in] */ const BYTE  *pBookmark,
    /* [in] */ DBROWOFFSET lRowsOffset,
    /* [in] */ DBROWCOUNT cRows,
    /* [out] */ DBCOUNTITEM *pcRowsObtained,
    /* [size_is][size_is][out] */ HROW  * *prghRows);


void __RPC_STUB IRowsetLocate_GetRowsAt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRowsetLocate_GetRowsByBookmark_Proxy( 
    IRowsetLocate  * This,
    /* [in] */ HCHAPTER hReserved,
    /* [in] */ DBCOUNTITEM cRows,
    /* [size_is][in] */ const DBBKMARK rgcbBookmarks[  ],
    /* [size_is][in] */ const BYTE  * rgpBookmarks[  ],
    /* [size_is][out] */ HROW  rghRows[  ],
    /* [size_is][out] */ DBROWSTATUS  rgRowStatus[  ]);


void __RPC_STUB IRowsetLocate_GetRowsByBookmark_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRowsetLocate_Hash_Proxy( 
    IRowsetLocate  * This,
    /* [in] */ HCHAPTER hReserved,
    /* [in] */ DBBKMARK cBookmarks,
    /* [size_is][in] */ const DBBKMARK rgcbBookmarks[  ],
    /* [size_is][in] */ const BYTE  * rgpBookmarks[  ],
    /* [size_is][out] */ DBHASHVALUE rgHashedValues[  ],
    /* [size_is][out] */ DBROWSTATUS  rgBookmarkStatus[  ]);


void __RPC_STUB IRowsetLocate_Hash_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRowsetLocate_INTERFACE_DEFINED__ */


#ifndef __IRowsetResynch_INTERFACE_DEFINED__
#define __IRowsetResynch_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRowsetResynch
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object][local] */ 



EXTERN_C const IID IID_IRowsetResynch;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a84-2a1c-11ce-ade5-00aa0044773d")
    IRowsetResynch : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetVisibleData( 
            /* [in] */ HROW hRow,
            /* [in] */ HACCESSOR hAccessor,
            /* [out] */ void  *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResynchRows( 
            /* [in] */ DBCOUNTITEM cRows,
            /* [size_is][in] */ const HROW  rghRows[  ],
            /* [out] */ DBCOUNTITEM *pcRowsResynched,
            /* [size_is][size_is][out] */ HROW  * *prghRowsResynched,
            /* [size_is][size_is][out] */ DBROWSTATUS  * *prgRowStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRowsetResynchVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IRowsetResynch  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IRowsetResynch  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IRowsetResynch  * This);
        
        HRESULT ( STDMETHODCALLTYPE  *GetVisibleData )( 
            IRowsetResynch  * This,
            /* [in] */ HROW hRow,
            /* [in] */ HACCESSOR hAccessor,
            /* [out] */ void  *pData);
        
        HRESULT ( STDMETHODCALLTYPE  *ResynchRows )( 
            IRowsetResynch  * This,
            /* [in] */ DBCOUNTITEM cRows,
            /* [size_is][in] */ const HROW  rghRows[  ],
            /* [out] */ DBCOUNTITEM *pcRowsResynched,
            /* [size_is][size_is][out] */ HROW  * *prghRowsResynched,
            /* [size_is][size_is][out] */ DBROWSTATUS  * *prgRowStatus);
        
        END_INTERFACE
    } IRowsetResynchVtbl;

    interface IRowsetResynch
    {
        CONST_VTBL struct IRowsetResynchVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRowsetResynch_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRowsetResynch_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRowsetResynch_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRowsetResynch_GetVisibleData(This,hRow,hAccessor,pData)	\
    (This)->lpVtbl -> GetVisibleData(This,hRow,hAccessor,pData)

#define IRowsetResynch_ResynchRows(This,cRows,rghRows,pcRowsResynched,prghRowsResynched,prgRowStatus)	\
    (This)->lpVtbl -> ResynchRows(This,cRows,rghRows,pcRowsResynched,prghRowsResynched,prgRowStatus)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRowsetResynch_GetVisibleData_Proxy( 
    IRowsetResynch  * This,
    /* [in] */ HROW hRow,
    /* [in] */ HACCESSOR hAccessor,
    /* [out] */ void  *pData);


void __RPC_STUB IRowsetResynch_GetVisibleData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRowsetResynch_ResynchRows_Proxy( 
    IRowsetResynch  * This,
    /* [in] */ DBCOUNTITEM cRows,
    /* [size_is][in] */ const HROW  rghRows[  ],
    /* [out] */ DBCOUNTITEM *pcRowsResynched,
    /* [size_is][size_is][out] */ HROW  * *prghRowsResynched,
    /* [size_is][size_is][out] */ DBROWSTATUS  * *prgRowStatus);


void __RPC_STUB IRowsetResynch_ResynchRows_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRowsetResynch_INTERFACE_DEFINED__ */


#ifndef __IRowsetScroll_INTERFACE_DEFINED__
#define __IRowsetScroll_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRowsetScroll
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object][local] */ 



EXTERN_C const IID IID_IRowsetScroll;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a7e-2a1c-11ce-ade5-00aa0044773d")
    IRowsetScroll : public IRowsetLocate
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetApproximatePosition( 
            /* [in] */ HCHAPTER hReserved,
            /* [in] */ DBBKMARK cbBookmark,
            /* [size_is][in] */ const BYTE  *pBookmark,
            /* [out] */ DBCOUNTITEM *pulPosition,
            /* [out] */ DBCOUNTITEM *pcRows) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRowsAtRatio( 
            /* [in] */ HWATCHREGION hReserved1,
            /* [in] */ HCHAPTER hReserved2,
            /* [in] */ DBCOUNTITEM ulNumerator,
            /* [in] */ DBCOUNTITEM ulDenominator,
            /* [in] */ DBROWCOUNT cRows,
            /* [out] */ DBCOUNTITEM *pcRowsObtained,
            /* [size_is][size_is][out] */ HROW  * *prghRows) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRowsetScrollVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IRowsetScroll  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IRowsetScroll  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IRowsetScroll  * This);
        
        HRESULT ( STDMETHODCALLTYPE  *AddRefRows )( 
            IRowsetScroll  * This,
            /* [in] */ DBCOUNTITEM cRows,
            /* [size_is][in] */ const HROW  rghRows[  ],
            /* [size_is][out] */ DBREFCOUNT rgRefCounts[  ],
            /* [size_is][out] */ DBROWSTATUS  rgRowStatus[  ]);
        
        HRESULT ( STDMETHODCALLTYPE  *GetData )( 
            IRowsetScroll  * This,
            /* [in] */ HROW hRow,
            /* [in] */ HACCESSOR hAccessor,
            /* [out] */ void  *pData);
        
        HRESULT ( STDMETHODCALLTYPE  *GetNextRows )( 
            IRowsetScroll  * This,
            /* [in] */ HCHAPTER hReserved,
            /* [in] */ DBROWOFFSET lRowsOffset,
            /* [in] */ DBROWCOUNT cRows,
            /* [out] */ DBCOUNTITEM *pcRowsObtained,
            /* [size_is][size_is][out] */ HROW  * *prghRows);
        
        HRESULT ( STDMETHODCALLTYPE  *ReleaseRows )( 
            IRowsetScroll  * This,
            /* [in] */ DBCOUNTITEM cRows,
            /* [size_is][in] */ const HROW  rghRows[  ],
            /* [size_is][in] */ DBROWOPTIONS  rgRowOptions[  ],
            /* [size_is][out] */ DBREFCOUNT rgRefCounts[  ],
            /* [size_is][out] */ DBROWSTATUS  rgRowStatus[  ]);
        
        HRESULT ( STDMETHODCALLTYPE  *RestartPosition )( 
            IRowsetScroll  * This,
            /* [in] */ HCHAPTER hReserved);
        
        HRESULT ( STDMETHODCALLTYPE  *Compare )( 
            IRowsetScroll  * This,
            /* [in] */ HCHAPTER hReserved,
            /* [in] */ DBBKMARK cbBookmark1,
            /* [size_is][in] */ const BYTE  *pBookmark1,
            /* [in] */ DBBKMARK cbBookmark2,
            /* [size_is][in] */ const BYTE  *pBookmark2,
            /* [out] */ DBCOMPARE  *pComparison);
        
        HRESULT ( STDMETHODCALLTYPE  *GetRowsAt )( 
            IRowsetScroll  * This,
            /* [in] */ HWATCHREGION hReserved1,
            /* [in] */ HCHAPTER hReserved2,
            /* [in] */ DBBKMARK cbBookmark,
            /* [size_is][in] */ const BYTE  *pBookmark,
            /* [in] */ DBROWOFFSET lRowsOffset,
            /* [in] */ DBROWCOUNT cRows,
            /* [out] */ DBCOUNTITEM *pcRowsObtained,
            /* [size_is][size_is][out] */ HROW  * *prghRows);
        
        HRESULT ( STDMETHODCALLTYPE  *GetRowsByBookmark )( 
            IRowsetScroll  * This,
            /* [in] */ HCHAPTER hReserved,
            /* [in] */ DBCOUNTITEM cRows,
            /* [size_is][in] */ const DBBKMARK rgcbBookmarks[  ],
            /* [size_is][in] */ const BYTE  * rgpBookmarks[  ],
            /* [size_is][out] */ HROW  rghRows[  ],
            /* [size_is][out] */ DBROWSTATUS  rgRowStatus[  ]);
        
        HRESULT ( STDMETHODCALLTYPE  *Hash )( 
            IRowsetScroll  * This,
            /* [in] */ HCHAPTER hReserved,
            /* [in] */ DBBKMARK cBookmarks,
            /* [size_is][in] */ const DBBKMARK rgcbBookmarks[  ],
            /* [size_is][in] */ const BYTE  * rgpBookmarks[  ],
            /* [size_is][out] */ DBHASHVALUE rgHashedValues[  ],
            /* [size_is][out] */ DBROWSTATUS  rgBookmarkStatus[  ]);
        
        HRESULT ( STDMETHODCALLTYPE  *GetApproximatePosition )( 
            IRowsetScroll  * This,
            /* [in] */ HCHAPTER hReserved,
            /* [in] */ DBBKMARK cbBookmark,
            /* [size_is][in] */ const BYTE  *pBookmark,
            /* [out] */ DBCOUNTITEM *pulPosition,
            /* [out] */ DBCOUNTITEM *pcRows);
        
        HRESULT ( STDMETHODCALLTYPE  *GetRowsAtRatio )( 
            IRowsetScroll  * This,
            /* [in] */ HWATCHREGION hReserved1,
            /* [in] */ HCHAPTER hReserved2,
            /* [in] */ DBCOUNTITEM ulNumerator,
            /* [in] */ DBCOUNTITEM ulDenominator,
            /* [in] */ DBROWCOUNT cRows,
            /* [out] */ DBCOUNTITEM *pcRowsObtained,
            /* [size_is][size_is][out] */ HROW  * *prghRows);
        
        END_INTERFACE
    } IRowsetScrollVtbl;

    interface IRowsetScroll
    {
        CONST_VTBL struct IRowsetScrollVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRowsetScroll_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRowsetScroll_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRowsetScroll_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRowsetScroll_AddRefRows(This,cRows,rghRows,rgRefCounts,rgRowStatus)	\
    (This)->lpVtbl -> AddRefRows(This,cRows,rghRows,rgRefCounts,rgRowStatus)

#define IRowsetScroll_GetData(This,hRow,hAccessor,pData)	\
    (This)->lpVtbl -> GetData(This,hRow,hAccessor,pData)

#define IRowsetScroll_GetNextRows(This,hReserved,lRowsOffset,cRows,pcRowsObtained,prghRows)	\
    (This)->lpVtbl -> GetNextRows(This,hReserved,lRowsOffset,cRows,pcRowsObtained,prghRows)

#define IRowsetScroll_ReleaseRows(This,cRows,rghRows,rgRowOptions,rgRefCounts,rgRowStatus)	\
    (This)->lpVtbl -> ReleaseRows(This,cRows,rghRows,rgRowOptions,rgRefCounts,rgRowStatus)

#define IRowsetScroll_RestartPosition(This,hReserved)	\
    (This)->lpVtbl -> RestartPosition(This,hReserved)


#define IRowsetScroll_Compare(This,hReserved,cbBookmark1,pBookmark1,cbBookmark2,pBookmark2,pComparison)	\
    (This)->lpVtbl -> Compare(This,hReserved,cbBookmark1,pBookmark1,cbBookmark2,pBookmark2,pComparison)

#define IRowsetScroll_GetRowsAt(This,hReserved1,hReserved2,cbBookmark,pBookmark,lRowsOffset,cRows,pcRowsObtained,prghRows)	\
    (This)->lpVtbl -> GetRowsAt(This,hReserved1,hReserved2,cbBookmark,pBookmark,lRowsOffset,cRows,pcRowsObtained,prghRows)

#define IRowsetScroll_GetRowsByBookmark(This,hReserved,cRows,rgcbBookmarks,rgpBookmarks,rghRows,rgRowStatus)	\
    (This)->lpVtbl -> GetRowsByBookmark(This,hReserved,cRows,rgcbBookmarks,rgpBookmarks,rghRows,rgRowStatus)

#define IRowsetScroll_Hash(This,hReserved,cBookmarks,rgcbBookmarks,rgpBookmarks,rgHashedValues,rgBookmarkStatus)	\
    (This)->lpVtbl -> Hash(This,hReserved,cBookmarks,rgcbBookmarks,rgpBookmarks,rgHashedValues,rgBookmarkStatus)


#define IRowsetScroll_GetApproximatePosition(This,hReserved,cbBookmark,pBookmark,pulPosition,pcRows)	\
    (This)->lpVtbl -> GetApproximatePosition(This,hReserved,cbBookmark,pBookmark,pulPosition,pcRows)

#define IRowsetScroll_GetRowsAtRatio(This,hReserved1,hReserved2,ulNumerator,ulDenominator,cRows,pcRowsObtained,prghRows)	\
    (This)->lpVtbl -> GetRowsAtRatio(This,hReserved1,hReserved2,ulNumerator,ulDenominator,cRows,pcRowsObtained,prghRows)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRowsetScroll_GetApproximatePosition_Proxy( 
    IRowsetScroll  * This,
    /* [in] */ HCHAPTER hReserved,
    /* [in] */ DBBKMARK cbBookmark,
    /* [size_is][in] */ const BYTE  *pBookmark,
    /* [out] */ DBCOUNTITEM *pulPosition,
    /* [out] */ DBCOUNTITEM *pcRows);


void __RPC_STUB IRowsetScroll_GetApproximatePosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRowsetScroll_GetRowsAtRatio_Proxy( 
    IRowsetScroll  * This,
    /* [in] */ HWATCHREGION hReserved1,
    /* [in] */ HCHAPTER hReserved2,
    /* [in] */ DBCOUNTITEM ulNumerator,
    /* [in] */ DBCOUNTITEM ulDenominator,
    /* [in] */ DBROWCOUNT cRows,
    /* [out] */ DBCOUNTITEM *pcRowsObtained,
    /* [size_is][size_is][out] */ HROW  * *prghRows);


void __RPC_STUB IRowsetScroll_GetRowsAtRatio_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRowsetScroll_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_oledb_0161
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 



extern RPC_IF_HANDLE __MIDL_itf_oledb_0161_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_oledb_0161_v0_0_s_ifspec;

#ifndef __IChapteredRowset_INTERFACE_DEFINED__
#define __IChapteredRowset_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IChapteredRowset
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IChapteredRowset;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a93-2a1c-11ce-ade5-00aa0044773d")
    IChapteredRowset : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE AddRefChapter( 
            /* [in] */ HCHAPTER hChapter,
            /* [out] */ DBREFCOUNT *pcRefCount) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE ReleaseChapter( 
            /* [in] */ HCHAPTER hChapter,
            /* [out] */ DBREFCOUNT *pcRefCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IChapteredRowsetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IChapteredRowset  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IChapteredRowset  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IChapteredRowset  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *AddRefChapter )( 
            IChapteredRowset  * This,
            /* [in] */ HCHAPTER hChapter,
            /* [out] */ DBREFCOUNT *pcRefCount);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *ReleaseChapter )( 
            IChapteredRowset  * This,
            /* [in] */ HCHAPTER hChapter,
            /* [out] */ DBREFCOUNT *pcRefCount);
        
        END_INTERFACE
    } IChapteredRowsetVtbl;

    interface IChapteredRowset
    {
        CONST_VTBL struct IChapteredRowsetVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IChapteredRowset_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IChapteredRowset_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IChapteredRowset_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IChapteredRowset_AddRefChapter(This,hChapter,pcRefCount)	\
    (This)->lpVtbl -> AddRefChapter(This,hChapter,pcRefCount)

#define IChapteredRowset_ReleaseChapter(This,hChapter,pcRefCount)	\
    (This)->lpVtbl -> ReleaseChapter(This,hChapter,pcRefCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IChapteredRowset_RemoteAddRefChapter_Proxy( 
    IChapteredRowset  * This,
    /* [in] */ HCHAPTER hChapter,
    /* [out] */ DBREFCOUNT *pcRefCount,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IChapteredRowset_RemoteAddRefChapter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IChapteredRowset_RemoteReleaseChapter_Proxy( 
    IChapteredRowset  * This,
    /* [in] */ HCHAPTER hChapter,
    /* [out] */ DBREFCOUNT *pcRefCount,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IChapteredRowset_RemoteReleaseChapter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IChapteredRowset_INTERFACE_DEFINED__ */


#ifndef __IRowsetFind_INTERFACE_DEFINED__
#define __IRowsetFind_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRowsetFind
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object][local] */ 



EXTERN_C const IID IID_IRowsetFind;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a9d-2a1c-11ce-ade5-00aa0044773d")
    IRowsetFind : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FindNextRow( 
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ HACCESSOR hAccessor,
            /* [in] */ void  *pFindValue,
            /* [in] */ DBCOMPAREOP CompareOp,
            /* [in] */ DBBKMARK cbBookmark,
            /* [size_is][in] */ const BYTE  *pBookmark,
            /* [in] */ DBROWOFFSET lRowsOffset,
            /* [in] */ DBROWCOUNT cRows,
            /* [out][in] */ DBCOUNTITEM *pcRowsObtained,
            /* [size_is][size_is][out] */ HROW  * *prghRows) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRowsetFindVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IRowsetFind  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IRowsetFind  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IRowsetFind  * This);
        
        HRESULT ( STDMETHODCALLTYPE  *FindNextRow )( 
            IRowsetFind  * This,
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ HACCESSOR hAccessor,
            /* [in] */ void  *pFindValue,
            /* [in] */ DBCOMPAREOP CompareOp,
            /* [in] */ DBBKMARK cbBookmark,
            /* [size_is][in] */ const BYTE  *pBookmark,
            /* [in] */ DBROWOFFSET lRowsOffset,
            /* [in] */ DBROWCOUNT cRows,
            /* [out][in] */ DBCOUNTITEM *pcRowsObtained,
            /* [size_is][size_is][out] */ HROW  * *prghRows);
        
        END_INTERFACE
    } IRowsetFindVtbl;

    interface IRowsetFind
    {
        CONST_VTBL struct IRowsetFindVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRowsetFind_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRowsetFind_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRowsetFind_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRowsetFind_FindNextRow(This,hChapter,hAccessor,pFindValue,CompareOp,cbBookmark,pBookmark,lRowsOffset,cRows,pcRowsObtained,prghRows)	\
    (This)->lpVtbl -> FindNextRow(This,hChapter,hAccessor,pFindValue,CompareOp,cbBookmark,pBookmark,lRowsOffset,cRows,pcRowsObtained,prghRows)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRowsetFind_FindNextRow_Proxy( 
    IRowsetFind  * This,
    /* [in] */ HCHAPTER hChapter,
    /* [in] */ HACCESSOR hAccessor,
    /* [in] */ void  *pFindValue,
    /* [in] */ DBCOMPAREOP CompareOp,
    /* [in] */ DBBKMARK cbBookmark,
    /* [size_is][in] */ const BYTE  *pBookmark,
    /* [in] */ DBROWOFFSET lRowsOffset,
    /* [in] */ DBROWCOUNT cRows,
    /* [out][in] */ DBCOUNTITEM *pcRowsObtained,
    /* [size_is][size_is][out] */ HROW  * *prghRows);


void __RPC_STUB IRowsetFind_FindNextRow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRowsetFind_INTERFACE_DEFINED__ */


#ifndef __IRowPosition_INTERFACE_DEFINED__
#define __IRowPosition_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRowPosition
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 


typedef DWORD DBPOSITIONFLAGS;


enum DBPOSITIONFLAGSENUM
    {	DBPOSITION_OK	= 0,
	DBPOSITION_NOROW	= DBPOSITION_OK + 1,
	DBPOSITION_BOF	= DBPOSITION_NOROW + 1,
	DBPOSITION_EOF	= DBPOSITION_BOF + 1
    };

EXTERN_C const IID IID_IRowPosition;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a94-2a1c-11ce-ade5-00aa0044773d")
    IRowPosition : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE ClearRowPosition( void) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetRowPosition( 
            /* [out] */ HCHAPTER  *phChapter,
            /* [out] */ HROW  *phRow,
            /* [out] */ DBPOSITIONFLAGS  *pdwPositionFlags) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetRowset( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown  * *ppRowset) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IUnknown  *pRowset) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SetRowPosition( 
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ HROW hRow,
            /* [in] */ DBPOSITIONFLAGS dwPositionFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRowPositionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IRowPosition  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IRowPosition  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IRowPosition  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *ClearRowPosition )( 
            IRowPosition  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetRowPosition )( 
            IRowPosition  * This,
            /* [out] */ HCHAPTER  *phChapter,
            /* [out] */ HROW  *phRow,
            /* [out] */ DBPOSITIONFLAGS  *pdwPositionFlags);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetRowset )( 
            IRowPosition  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown  * *ppRowset);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *Initialize )( 
            IRowPosition  * This,
            /* [in] */ IUnknown  *pRowset);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *SetRowPosition )( 
            IRowPosition  * This,
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ HROW hRow,
            /* [in] */ DBPOSITIONFLAGS dwPositionFlags);
        
        END_INTERFACE
    } IRowPositionVtbl;

    interface IRowPosition
    {
        CONST_VTBL struct IRowPositionVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRowPosition_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRowPosition_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRowPosition_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRowPosition_ClearRowPosition(This)	\
    (This)->lpVtbl -> ClearRowPosition(This)

#define IRowPosition_GetRowPosition(This,phChapter,phRow,pdwPositionFlags)	\
    (This)->lpVtbl -> GetRowPosition(This,phChapter,phRow,pdwPositionFlags)

#define IRowPosition_GetRowset(This,riid,ppRowset)	\
    (This)->lpVtbl -> GetRowset(This,riid,ppRowset)

#define IRowPosition_Initialize(This,pRowset)	\
    (This)->lpVtbl -> Initialize(This,pRowset)

#define IRowPosition_SetRowPosition(This,hChapter,hRow,dwPositionFlags)	\
    (This)->lpVtbl -> SetRowPosition(This,hChapter,hRow,dwPositionFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IRowPosition_RemoteClearRowPosition_Proxy( 
    IRowPosition  * This,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IRowPosition_RemoteClearRowPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IRowPosition_RemoteGetRowPosition_Proxy( 
    IRowPosition  * This,
    /* [out] */ HCHAPTER  *phChapter,
    /* [out] */ HROW  *phRow,
    /* [out] */ DBPOSITIONFLAGS  *pdwPositionFlags,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IRowPosition_RemoteGetRowPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IRowPosition_RemoteGetRowset_Proxy( 
    IRowPosition  * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown  * *ppRowset,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IRowPosition_RemoteGetRowset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IRowPosition_RemoteInitialize_Proxy( 
    IRowPosition  * This,
    /* [in] */ IUnknown  *pRowset,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IRowPosition_RemoteInitialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IRowPosition_RemoteSetRowPosition_Proxy( 
    IRowPosition  * This,
    /* [in] */ HCHAPTER hChapter,
    /* [in] */ HROW hRow,
    /* [in] */ DBPOSITIONFLAGS dwPositionFlags,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IRowPosition_RemoteSetRowPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRowPosition_INTERFACE_DEFINED__ */


#ifndef __IRowPositionChange_INTERFACE_DEFINED__
#define __IRowPositionChange_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRowPositionChange
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IRowPositionChange;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0997a571-126e-11d0-9f8a-00a0c9a0631e")
    IRowPositionChange : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE OnRowPositionChange( 
            /* [in] */ DBREASON eReason,
            /* [in] */ DBEVENTPHASE ePhase,
            /* [in] */ BOOL fCantDeny) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRowPositionChangeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IRowPositionChange  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IRowPositionChange  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IRowPositionChange  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *OnRowPositionChange )( 
            IRowPositionChange  * This,
            /* [in] */ DBREASON eReason,
            /* [in] */ DBEVENTPHASE ePhase,
            /* [in] */ BOOL fCantDeny);
        
        END_INTERFACE
    } IRowPositionChangeVtbl;

    interface IRowPositionChange
    {
        CONST_VTBL struct IRowPositionChangeVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRowPositionChange_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRowPositionChange_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRowPositionChange_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRowPositionChange_OnRowPositionChange(This,eReason,ePhase,fCantDeny)	\
    (This)->lpVtbl -> OnRowPositionChange(This,eReason,ePhase,fCantDeny)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IRowPositionChange_RemoteOnRowPositionChange_Proxy( 
    IRowPositionChange  * This,
    /* [in] */ DBREASON eReason,
    /* [in] */ DBEVENTPHASE ePhase,
    /* [in] */ BOOL fCantDeny,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IRowPositionChange_RemoteOnRowPositionChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRowPositionChange_INTERFACE_DEFINED__ */


#ifndef __IViewRowset_INTERFACE_DEFINED__
#define __IViewRowset_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IViewRowset
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IViewRowset;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a97-2a1c-11ce-ade5-00aa0044773d")
    IViewRowset : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetSpecification( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown  * *ppObject) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE OpenViewRowset( 
            /* [in] */ IUnknown  *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown  * *ppRowset) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IViewRowsetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IViewRowset  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IViewRowset  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IViewRowset  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetSpecification )( 
            IViewRowset  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown  * *ppObject);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *OpenViewRowset )( 
            IViewRowset  * This,
            /* [in] */ IUnknown  *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown  * *ppRowset);
        
        END_INTERFACE
    } IViewRowsetVtbl;

    interface IViewRowset
    {
        CONST_VTBL struct IViewRowsetVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IViewRowset_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IViewRowset_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IViewRowset_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IViewRowset_GetSpecification(This,riid,ppObject)	\
    (This)->lpVtbl -> GetSpecification(This,riid,ppObject)

#define IViewRowset_OpenViewRowset(This,pUnkOuter,riid,ppRowset)	\
    (This)->lpVtbl -> OpenViewRowset(This,pUnkOuter,riid,ppRowset)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IViewRowset_RemoteGetSpecification_Proxy( 
    IViewRowset  * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown  * *ppObject,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IViewRowset_RemoteGetSpecification_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IViewRowset_RemoteOpenViewRowset_Proxy( 
    IViewRowset  * This,
    /* [in] */ IUnknown  *pUnkOuter,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown  * *ppRowset,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IViewRowset_RemoteOpenViewRowset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IViewRowset_INTERFACE_DEFINED__ */


#ifndef __IViewChapter_INTERFACE_DEFINED__
#define __IViewChapter_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IViewChapter
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IViewChapter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a98-2a1c-11ce-ade5-00aa0044773d")
    IViewChapter : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetSpecification( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown  * *ppRowset) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE OpenViewChapter( 
            /* [in] */ HCHAPTER hSource,
            /* [out] */ HCHAPTER  *phViewChapter) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IViewChapterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IViewChapter  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IViewChapter  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IViewChapter  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetSpecification )( 
            IViewChapter  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown  * *ppRowset);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *OpenViewChapter )( 
            IViewChapter  * This,
            /* [in] */ HCHAPTER hSource,
            /* [out] */ HCHAPTER  *phViewChapter);
        
        END_INTERFACE
    } IViewChapterVtbl;

    interface IViewChapter
    {
        CONST_VTBL struct IViewChapterVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IViewChapter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IViewChapter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IViewChapter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IViewChapter_GetSpecification(This,riid,ppRowset)	\
    (This)->lpVtbl -> GetSpecification(This,riid,ppRowset)

#define IViewChapter_OpenViewChapter(This,hSource,phViewChapter)	\
    (This)->lpVtbl -> OpenViewChapter(This,hSource,phViewChapter)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IViewChapter_RemoteGetSpecification_Proxy( 
    IViewChapter  * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown  * *ppRowset,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IViewChapter_RemoteGetSpecification_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IViewChapter_RemoteOpenViewChapter_Proxy( 
    IViewChapter  * This,
    /* [in] */ HCHAPTER hSource,
    /* [out] */ HCHAPTER  *phViewChapter,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IViewChapter_RemoteOpenViewChapter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IViewChapter_INTERFACE_DEFINED__ */


#ifndef __IViewSort_INTERFACE_DEFINED__
#define __IViewSort_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IViewSort
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IViewSort;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a9a-2a1c-11ce-ade5-00aa0044773d")
    IViewSort : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetSortOrder( 
            /* [out] */ DBORDINAL *pcValues,
            /* [out] */ DBORDINAL *prgColumns[  ],
            /* [out] */ DBSORT  * prgOrders[  ]) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SetSortOrder( 
            /* [in] */ DBORDINAL cValues,
            /* [size_is][in] */ const DBORDINAL rgColumns[  ],
            /* [size_is][in] */ const DBSORT  rgOrders[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IViewSortVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IViewSort  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IViewSort  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IViewSort  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetSortOrder )( 
            IViewSort  * This,
            /* [out] */ DBORDINAL *pcValues,
            /* [out] */ DBORDINAL *prgColumns[  ],
            /* [out] */ DBSORT  * prgOrders[  ]);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *SetSortOrder )( 
            IViewSort  * This,
            /* [in] */ DBORDINAL cValues,
            /* [size_is][in] */ const DBORDINAL rgColumns[  ],
            /* [size_is][in] */ const DBSORT  rgOrders[  ]);
        
        END_INTERFACE
    } IViewSortVtbl;

    interface IViewSort
    {
        CONST_VTBL struct IViewSortVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IViewSort_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IViewSort_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IViewSort_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IViewSort_GetSortOrder(This,pcValues,prgColumns,prgOrders)	\
    (This)->lpVtbl -> GetSortOrder(This,pcValues,prgColumns,prgOrders)

#define IViewSort_SetSortOrder(This,cValues,rgColumns,rgOrders)	\
    (This)->lpVtbl -> SetSortOrder(This,cValues,rgColumns,rgOrders)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IViewSort_RemoteGetSortOrder_Proxy( 
    IViewSort  * This,
    /* [out][in] */ DBORDINAL *pcValues,
    /* [size_is][size_is][out] */ DBORDINAL **prgColumns,
    /* [size_is][size_is][out] */ DBSORT **prgOrders,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IViewSort_RemoteGetSortOrder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IViewSort_RemoteSetSortOrder_Proxy( 
    IViewSort  * This,
    /* [in] */ DBORDINAL cValues,
    /* [size_is][in] */ const DBORDINAL *rgColumns,
    /* [size_is][in] */ const DBSORT  *rgOrders,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IViewSort_RemoteSetSortOrder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IViewSort_INTERFACE_DEFINED__ */


#ifndef __IViewFilter_INTERFACE_DEFINED__
#define __IViewFilter_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IViewFilter
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IViewFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a9b-2a1c-11ce-ade5-00aa0044773d")
    IViewFilter : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetFilter( 
            /* [in] */ HACCESSOR hAccessor,
            /* [out] */ DBCOUNTITEM *pcRows,
            /* [out] */ DBCOMPAREOP  * pCompareOps[  ],
            /* [out] */ void  *pCriteriaData) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetFilterBindings( 
            /* [out] */ DBCOUNTITEM *pcBindings,
            /* [out] */ DBBINDING  * *prgBindings) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SetFilter( 
            /* [in] */ HACCESSOR hAccessor,
            /* [in] */ DBCOUNTITEM cRows,
            /* [in] */ DBCOMPAREOP  CompareOps[  ],
            /* [in] */ void  *pCriteriaData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IViewFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IViewFilter  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IViewFilter  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IViewFilter  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetFilter )( 
            IViewFilter  * This,
            /* [in] */ HACCESSOR hAccessor,
            /* [out] */ DBCOUNTITEM *pcRows,
            /* [out] */ DBCOMPAREOP  * pCompareOps[  ],
            /* [out] */ void  *pCriteriaData);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetFilterBindings )( 
            IViewFilter  * This,
            /* [out] */ DBCOUNTITEM *pcBindings,
            /* [out] */ DBBINDING  * *prgBindings);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *SetFilter )( 
            IViewFilter  * This,
            /* [in] */ HACCESSOR hAccessor,
            /* [in] */ DBCOUNTITEM cRows,
            /* [in] */ DBCOMPAREOP  CompareOps[  ],
            /* [in] */ void  *pCriteriaData);
        
        END_INTERFACE
    } IViewFilterVtbl;

    interface IViewFilter
    {
        CONST_VTBL struct IViewFilterVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IViewFilter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IViewFilter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IViewFilter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IViewFilter_GetFilter(This,hAccessor,pcRows,pCompareOps,pCriteriaData)	\
    (This)->lpVtbl -> GetFilter(This,hAccessor,pcRows,pCompareOps,pCriteriaData)

#define IViewFilter_GetFilterBindings(This,pcBindings,prgBindings)	\
    (This)->lpVtbl -> GetFilterBindings(This,pcBindings,prgBindings)

#define IViewFilter_SetFilter(This,hAccessor,cRows,CompareOps,pCriteriaData)	\
    (This)->lpVtbl -> SetFilter(This,hAccessor,cRows,CompareOps,pCriteriaData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [local] */ HRESULT STDMETHODCALLTYPE IViewFilter_GetFilter_Proxy( 
    IViewFilter  * This,
    /* [in] */ HACCESSOR hAccessor,
    /* [out] */ DBCOUNTITEM *pcRows,
    /* [out] */ DBCOMPAREOP  * pCompareOps[  ],
    /* [out] */ void  *pCriteriaData);


void __RPC_STUB IViewFilter_GetFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IViewFilter_RemoteGetFilterBindings_Proxy( 
    IViewFilter  * This,
    /* [out][in] */ DBCOUNTITEM *pcBindings,
    /* [size_is][size_is][out] */ DBBINDING  * *prgBindings,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IViewFilter_RemoteGetFilterBindings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ HRESULT STDMETHODCALLTYPE IViewFilter_SetFilter_Proxy( 
    IViewFilter  * This,
    /* [in] */ HACCESSOR hAccessor,
    /* [in] */ DBCOUNTITEM cRows,
    /* [in] */ DBCOMPAREOP  CompareOps[  ],
    /* [in] */ void  *pCriteriaData);


void __RPC_STUB IViewFilter_SetFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IViewFilter_INTERFACE_DEFINED__ */


#ifndef __IRowsetView_INTERFACE_DEFINED__
#define __IRowsetView_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRowsetView
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IRowsetView;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a99-2a1c-11ce-ade5-00aa0044773d")
    IRowsetView : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CreateView( 
            /* [in] */ IUnknown  *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown  * *ppView) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetView( 
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ REFIID riid,
            /* [out] */ HCHAPTER  *phChapterSource,
            /* [iid_is][out] */ IUnknown  * *ppView) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRowsetViewVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IRowsetView  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IRowsetView  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IRowsetView  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *CreateView )( 
            IRowsetView  * This,
            /* [in] */ IUnknown  *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown  * *ppView);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetView )( 
            IRowsetView  * This,
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ REFIID riid,
            /* [out] */ HCHAPTER  *phChapterSource,
            /* [iid_is][out] */ IUnknown  * *ppView);
        
        END_INTERFACE
    } IRowsetViewVtbl;

    interface IRowsetView
    {
        CONST_VTBL struct IRowsetViewVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRowsetView_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRowsetView_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRowsetView_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRowsetView_CreateView(This,pUnkOuter,riid,ppView)	\
    (This)->lpVtbl -> CreateView(This,pUnkOuter,riid,ppView)

#define IRowsetView_GetView(This,hChapter,riid,phChapterSource,ppView)	\
    (This)->lpVtbl -> GetView(This,hChapter,riid,phChapterSource,ppView)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IRowsetView_RemoteCreateView_Proxy( 
    IRowsetView  * This,
    /* [in] */ IUnknown  *pUnkOuter,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown  * *ppView,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IRowsetView_RemoteCreateView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IRowsetView_RemoteGetView_Proxy( 
    IRowsetView  * This,
    /* [in] */ HCHAPTER hChapter,
    /* [in] */ REFIID riid,
    /* [out] */ HCHAPTER  *phChapterSource,
    /* [iid_is][out] */ IUnknown  * *ppView,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IRowsetView_RemoteGetView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRowsetView_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_oledb_0170
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 


//@@@+ deprecated
#ifdef deprecated


extern RPC_IF_HANDLE __MIDL_itf_oledb_0170_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_oledb_0170_v0_0_s_ifspec;

#ifndef __IRowsetExactScroll_INTERFACE_DEFINED__
#define __IRowsetExactScroll_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRowsetExactScroll
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object][local] */ 



EXTERN_C const IID IID_IRowsetExactScroll;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a7f-2a1c-11ce-ade5-00aa0044773d")
    IRowsetExactScroll : public IRowsetScroll
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetExactPosition( 
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ DBBKMARK cbBookmark,
            /* [size_is][in] */ const BYTE  *pBookmark,
            /* [out] */ DBCOUNTITEM *pulPosition,
            /* [out] */ DBCOUNTITEM *pcRows) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRowsetExactScrollVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IRowsetExactScroll  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IRowsetExactScroll  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IRowsetExactScroll  * This);
        
        HRESULT ( STDMETHODCALLTYPE  *AddRefRows )( 
            IRowsetExactScroll  * This,
            /* [in] */ DBCOUNTITEM cRows,
            /* [size_is][in] */ const HROW  rghRows[  ],
            /* [size_is][out] */ DBREFCOUNT rgRefCounts[  ],
            /* [size_is][out] */ DBROWSTATUS  rgRowStatus[  ]);
        
        HRESULT ( STDMETHODCALLTYPE  *GetData )( 
            IRowsetExactScroll  * This,
            /* [in] */ HROW hRow,
            /* [in] */ HACCESSOR hAccessor,
            /* [out] */ void  *pData);
        
        HRESULT ( STDMETHODCALLTYPE  *GetNextRows )( 
            IRowsetExactScroll  * This,
            /* [in] */ HCHAPTER hReserved,
            /* [in] */ DBROWOFFSET lRowsOffset,
            /* [in] */ DBROWCOUNT cRows,
            /* [out] */ DBCOUNTITEM *pcRowsObtained,
            /* [size_is][size_is][out] */ HROW  * *prghRows);
        
        HRESULT ( STDMETHODCALLTYPE  *ReleaseRows )( 
            IRowsetExactScroll  * This,
            /* [in] */ DBCOUNTITEM cRows,
            /* [size_is][in] */ const HROW  rghRows[  ],
            /* [size_is][in] */ DBROWOPTIONS  rgRowOptions[  ],
            /* [size_is][out] */ DBREFCOUNT rgRefCounts[  ],
            /* [size_is][out] */ DBROWSTATUS  rgRowStatus[  ]);
        
        HRESULT ( STDMETHODCALLTYPE  *RestartPosition )( 
            IRowsetExactScroll  * This,
            /* [in] */ HCHAPTER hReserved);
        
        HRESULT ( STDMETHODCALLTYPE  *Compare )( 
            IRowsetExactScroll  * This,
            /* [in] */ HCHAPTER hReserved,
            /* [in] */ DBBKMARK cbBookmark1,
            /* [size_is][in] */ const BYTE  *pBookmark1,
            /* [in] */ DBBKMARK cbBookmark2,
            /* [size_is][in] */ const BYTE  *pBookmark2,
            /* [out] */ DBCOMPARE  *pComparison);
        
        HRESULT ( STDMETHODCALLTYPE  *GetRowsAt )( 
            IRowsetExactScroll  * This,
            /* [in] */ HWATCHREGION hReserved1,
            /* [in] */ HCHAPTER hReserved2,
            /* [in] */ DBBKMARK cbBookmark,
            /* [size_is][in] */ const BYTE  *pBookmark,
            /* [in] */ DBROWOFFSET lRowsOffset,
            /* [in] */ DBROWCOUNT cRows,
            /* [out] */ DBCOUNTITEM *pcRowsObtained,
            /* [size_is][size_is][out] */ HROW  * *prghRows);
        
        HRESULT ( STDMETHODCALLTYPE  *GetRowsByBookmark )( 
            IRowsetExactScroll  * This,
            /* [in] */ HCHAPTER hReserved,
            /* [in] */ DBCOUNTITEM cRows,
            /* [size_is][in] */ const DBBKMARK rgcbBookmarks[  ],
            /* [size_is][in] */ const BYTE  * rgpBookmarks[  ],
            /* [size_is][out] */ HROW  rghRows[  ],
            /* [size_is][out] */ DBROWSTATUS  rgRowStatus[  ]);
        
        HRESULT ( STDMETHODCALLTYPE  *Hash )( 
            IRowsetExactScroll  * This,
            /* [in] */ HCHAPTER hReserved,
            /* [in] */ DBBKMARK cBookmarks,
            /* [size_is][in] */ const DBBKMARK rgcbBookmarks[  ],
            /* [size_is][in] */ const BYTE  * rgpBookmarks[  ],
            /* [size_is][out] */ DBHASHVALUE rgHashedValues[  ],
            /* [size_is][out] */ DBROWSTATUS  rgBookmarkStatus[  ]);
        
        HRESULT ( STDMETHODCALLTYPE  *GetApproximatePosition )( 
            IRowsetExactScroll  * This,
            /* [in] */ HCHAPTER hReserved,
            /* [in] */ DBBKMARK cbBookmark,
            /* [size_is][in] */ const BYTE  *pBookmark,
            /* [out] */ DBCOUNTITEM *pulPosition,
            /* [out] */ DBCOUNTITEM *pcRows);
        
        HRESULT ( STDMETHODCALLTYPE  *GetRowsAtRatio )( 
            IRowsetExactScroll  * This,
            /* [in] */ HWATCHREGION hReserved1,
            /* [in] */ HCHAPTER hReserved2,
            /* [in] */ DBCOUNTITEM ulNumerator,
            /* [in] */ DBCOUNTITEM ulDenominator,
            /* [in] */ DBROWCOUNT cRows,
            /* [out] */ DBCOUNTITEM *pcRowsObtained,
            /* [size_is][size_is][out] */ HROW  * *prghRows);
        
        HRESULT ( STDMETHODCALLTYPE  *GetExactPosition )( 
            IRowsetExactScroll  * This,
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ DBBKMARK cbBookmark,
            /* [size_is][in] */ const BYTE  *pBookmark,
            /* [out] */ DBCOUNTITEM *pulPosition,
            /* [out] */ DBCOUNTITEM *pcRows);
        
        END_INTERFACE
    } IRowsetExactScrollVtbl;

    interface IRowsetExactScroll
    {
        CONST_VTBL struct IRowsetExactScrollVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRowsetExactScroll_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRowsetExactScroll_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRowsetExactScroll_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRowsetExactScroll_AddRefRows(This,cRows,rghRows,rgRefCounts,rgRowStatus)	\
    (This)->lpVtbl -> AddRefRows(This,cRows,rghRows,rgRefCounts,rgRowStatus)

#define IRowsetExactScroll_GetData(This,hRow,hAccessor,pData)	\
    (This)->lpVtbl -> GetData(This,hRow,hAccessor,pData)

#define IRowsetExactScroll_GetNextRows(This,hReserved,lRowsOffset,cRows,pcRowsObtained,prghRows)	\
    (This)->lpVtbl -> GetNextRows(This,hReserved,lRowsOffset,cRows,pcRowsObtained,prghRows)

#define IRowsetExactScroll_ReleaseRows(This,cRows,rghRows,rgRowOptions,rgRefCounts,rgRowStatus)	\
    (This)->lpVtbl -> ReleaseRows(This,cRows,rghRows,rgRowOptions,rgRefCounts,rgRowStatus)

#define IRowsetExactScroll_RestartPosition(This,hReserved)	\
    (This)->lpVtbl -> RestartPosition(This,hReserved)


#define IRowsetExactScroll_Compare(This,hReserved,cbBookmark1,pBookmark1,cbBookmark2,pBookmark2,pComparison)	\
    (This)->lpVtbl -> Compare(This,hReserved,cbBookmark1,pBookmark1,cbBookmark2,pBookmark2,pComparison)

#define IRowsetExactScroll_GetRowsAt(This,hReserved1,hReserved2,cbBookmark,pBookmark,lRowsOffset,cRows,pcRowsObtained,prghRows)	\
    (This)->lpVtbl -> GetRowsAt(This,hReserved1,hReserved2,cbBookmark,pBookmark,lRowsOffset,cRows,pcRowsObtained,prghRows)

#define IRowsetExactScroll_GetRowsByBookmark(This,hReserved,cRows,rgcbBookmarks,rgpBookmarks,rghRows,rgRowStatus)	\
    (This)->lpVtbl -> GetRowsByBookmark(This,hReserved,cRows,rgcbBookmarks,rgpBookmarks,rghRows,rgRowStatus)

#define IRowsetExactScroll_Hash(This,hReserved,cBookmarks,rgcbBookmarks,rgpBookmarks,rgHashedValues,rgBookmarkStatus)	\
    (This)->lpVtbl -> Hash(This,hReserved,cBookmarks,rgcbBookmarks,rgpBookmarks,rgHashedValues,rgBookmarkStatus)


#define IRowsetExactScroll_GetApproximatePosition(This,hReserved,cbBookmark,pBookmark,pulPosition,pcRows)	\
    (This)->lpVtbl -> GetApproximatePosition(This,hReserved,cbBookmark,pBookmark,pulPosition,pcRows)

#define IRowsetExactScroll_GetRowsAtRatio(This,hReserved1,hReserved2,ulNumerator,ulDenominator,cRows,pcRowsObtained,prghRows)	\
    (This)->lpVtbl -> GetRowsAtRatio(This,hReserved1,hReserved2,ulNumerator,ulDenominator,cRows,pcRowsObtained,prghRows)


#define IRowsetExactScroll_GetExactPosition(This,hChapter,cbBookmark,pBookmark,pulPosition,pcRows)	\
    (This)->lpVtbl -> GetExactPosition(This,hChapter,cbBookmark,pBookmark,pulPosition,pcRows)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRowsetExactScroll_GetExactPosition_Proxy( 
    IRowsetExactScroll  * This,
    /* [in] */ HCHAPTER hChapter,
    /* [in] */ DBBKMARK cbBookmark,
    /* [size_is][in] */ const BYTE  *pBookmark,
    /* [out] */ DBCOUNTITEM *pulPosition,
    /* [out] */ DBCOUNTITEM *pcRows);


void __RPC_STUB IRowsetExactScroll_GetExactPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRowsetExactScroll_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_oledb_0171
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 


#endif // deprecated
//@@@- deprecated


extern RPC_IF_HANDLE __MIDL_itf_oledb_0171_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_oledb_0171_v0_0_s_ifspec;

#ifndef __IRowsetChange_INTERFACE_DEFINED__
#define __IRowsetChange_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRowsetChange
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object][local] */ 



EXTERN_C const IID IID_IRowsetChange;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a05-2a1c-11ce-ade5-00aa0044773d")
    IRowsetChange : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DeleteRows( 
            /* [in] */ HCHAPTER hReserved,
            /* [in] */ DBCOUNTITEM cRows,
            /* [size_is][in] */ const HROW  rghRows[  ],
            /* [size_is][out] */ DBROWSTATUS  rgRowStatus[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetData( 
            /* [in] */ HROW hRow,
            /* [in] */ HACCESSOR hAccessor,
            /* [in] */ void  *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertRow( 
            /* [in] */ HCHAPTER hReserved,
            /* [in] */ HACCESSOR hAccessor,
            /* [in] */ void  *pData,
            /* [out] */ HROW  *phRow) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRowsetChangeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IRowsetChange  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IRowsetChange  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IRowsetChange  * This);
        
        HRESULT ( STDMETHODCALLTYPE  *DeleteRows )( 
            IRowsetChange  * This,
            /* [in] */ HCHAPTER hReserved,
            /* [in] */ DBCOUNTITEM cRows,
            /* [size_is][in] */ const HROW  rghRows[  ],
            /* [size_is][out] */ DBROWSTATUS  rgRowStatus[  ]);
        
        HRESULT ( STDMETHODCALLTYPE  *SetData )( 
            IRowsetChange  * This,
            /* [in] */ HROW hRow,
            /* [in] */ HACCESSOR hAccessor,
            /* [in] */ void  *pData);
        
        HRESULT ( STDMETHODCALLTYPE  *InsertRow )( 
            IRowsetChange  * This,
            /* [in] */ HCHAPTER hReserved,
            /* [in] */ HACCESSOR hAccessor,
            /* [in] */ void  *pData,
            /* [out] */ HROW  *phRow);
        
        END_INTERFACE
    } IRowsetChangeVtbl;

    interface IRowsetChange
    {
        CONST_VTBL struct IRowsetChangeVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRowsetChange_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRowsetChange_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRowsetChange_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRowsetChange_DeleteRows(This,hReserved,cRows,rghRows,rgRowStatus)	\
    (This)->lpVtbl -> DeleteRows(This,hReserved,cRows,rghRows,rgRowStatus)

#define IRowsetChange_SetData(This,hRow,hAccessor,pData)	\
    (This)->lpVtbl -> SetData(This,hRow,hAccessor,pData)

#define IRowsetChange_InsertRow(This,hReserved,hAccessor,pData,phRow)	\
    (This)->lpVtbl -> InsertRow(This,hReserved,hAccessor,pData,phRow)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRowsetChange_DeleteRows_Proxy( 
    IRowsetChange  * This,
    /* [in] */ HCHAPTER hReserved,
    /* [in] */ DBCOUNTITEM cRows,
    /* [size_is][in] */ const HROW  rghRows[  ],
    /* [size_is][out] */ DBROWSTATUS  rgRowStatus[  ]);


void __RPC_STUB IRowsetChange_DeleteRows_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRowsetChange_SetData_Proxy( 
    IRowsetChange  * This,
    /* [in] */ HROW hRow,
    /* [in] */ HACCESSOR hAccessor,
    /* [in] */ void  *pData);


void __RPC_STUB IRowsetChange_SetData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRowsetChange_InsertRow_Proxy( 
    IRowsetChange  * This,
    /* [in] */ HCHAPTER hReserved,
    /* [in] */ HACCESSOR hAccessor,
    /* [in] */ void  *pData,
    /* [out] */ HROW  *phRow);


void __RPC_STUB IRowsetChange_InsertRow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRowsetChange_INTERFACE_DEFINED__ */


#ifndef __IRowsetUpdate_INTERFACE_DEFINED__
#define __IRowsetUpdate_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRowsetUpdate
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object][local] */ 


typedef DWORD DBPENDINGSTATUS;


enum DBPENDINGSTATUSENUM
    {	DBPENDINGSTATUS_NEW	= 0x1,
	DBPENDINGSTATUS_CHANGED	= 0x2,
	DBPENDINGSTATUS_DELETED	= 0x4,
	DBPENDINGSTATUS_UNCHANGED	= 0x8,
	DBPENDINGSTATUS_INVALIDROW	= 0x10
    };

EXTERN_C const IID IID_IRowsetUpdate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a6d-2a1c-11ce-ade5-00aa0044773d")
    IRowsetUpdate : public IRowsetChange
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetOriginalData( 
            /* [in] */ HROW hRow,
            /* [in] */ HACCESSOR hAccessor,
            /* [out] */ void  *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPendingRows( 
            /* [in] */ HCHAPTER hReserved,
            /* [in] */ DBPENDINGSTATUS dwRowStatus,
            /* [out][in] */ DBCOUNTITEM *pcPendingRows,
            /* [size_is][size_is][out] */ HROW  * *prgPendingRows,
            /* [size_is][size_is][out] */ DBPENDINGSTATUS  * *prgPendingStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRowStatus( 
            /* [in] */ HCHAPTER hReserved,
            /* [in] */ DBCOUNTITEM cRows,
            /* [size_is][in] */ const HROW  rghRows[  ],
            /* [size_is][out] */ DBPENDINGSTATUS  rgPendingStatus[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Undo( 
            /* [in] */ HCHAPTER hReserved,
            /* [in] */ DBCOUNTITEM cRows,
            /* [size_is][in] */ const HROW  rghRows[  ],
            /* [out][in] */ DBCOUNTITEM *pcRowsUndone,
            /* [size_is][size_is][out] */ HROW  * *prgRowsUndone,
            /* [size_is][size_is][out] */ DBROWSTATUS  * *prgRowStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Update( 
            /* [in] */ HCHAPTER hReserved,
            /* [in] */ DBCOUNTITEM cRows,
            /* [size_is][in] */ const HROW  rghRows[  ],
            /* [out][in] */ DBCOUNTITEM *pcRows,
            /* [size_is][size_is][out] */ HROW  * *prgRows,
            /* [size_is][size_is][out] */ DBROWSTATUS  * *prgRowStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRowsetUpdateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IRowsetUpdate  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IRowsetUpdate  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IRowsetUpdate  * This);
        
        HRESULT ( STDMETHODCALLTYPE  *DeleteRows )( 
            IRowsetUpdate  * This,
            /* [in] */ HCHAPTER hReserved,
            /* [in] */ DBCOUNTITEM cRows,
            /* [size_is][in] */ const HROW  rghRows[  ],
            /* [size_is][out] */ DBROWSTATUS  rgRowStatus[  ]);
        
        HRESULT ( STDMETHODCALLTYPE  *SetData )( 
            IRowsetUpdate  * This,
            /* [in] */ HROW hRow,
            /* [in] */ HACCESSOR hAccessor,
            /* [in] */ void  *pData);
        
        HRESULT ( STDMETHODCALLTYPE  *InsertRow )( 
            IRowsetUpdate  * This,
            /* [in] */ HCHAPTER hReserved,
            /* [in] */ HACCESSOR hAccessor,
            /* [in] */ void  *pData,
            /* [out] */ HROW  *phRow);
        
        HRESULT ( STDMETHODCALLTYPE  *GetOriginalData )( 
            IRowsetUpdate  * This,
            /* [in] */ HROW hRow,
            /* [in] */ HACCESSOR hAccessor,
            /* [out] */ void  *pData);
        
        HRESULT ( STDMETHODCALLTYPE  *GetPendingRows )( 
            IRowsetUpdate  * This,
            /* [in] */ HCHAPTER hReserved,
            /* [in] */ DBPENDINGSTATUS dwRowStatus,
            /* [out][in] */ DBCOUNTITEM *pcPendingRows,
            /* [size_is][size_is][out] */ HROW  * *prgPendingRows,
            /* [size_is][size_is][out] */ DBPENDINGSTATUS  * *prgPendingStatus);
        
        HRESULT ( STDMETHODCALLTYPE  *GetRowStatus )( 
            IRowsetUpdate  * This,
            /* [in] */ HCHAPTER hReserved,
            /* [in] */ DBCOUNTITEM cRows,
            /* [size_is][in] */ const HROW  rghRows[  ],
            /* [size_is][out] */ DBPENDINGSTATUS  rgPendingStatus[  ]);
        
        HRESULT ( STDMETHODCALLTYPE  *Undo )( 
            IRowsetUpdate  * This,
            /* [in] */ HCHAPTER hReserved,
            /* [in] */ DBCOUNTITEM cRows,
            /* [size_is][in] */ const HROW  rghRows[  ],
            /* [out][in] */ DBCOUNTITEM *pcRowsUndone,
            /* [size_is][size_is][out] */ HROW  * *prgRowsUndone,
            /* [size_is][size_is][out] */ DBROWSTATUS  * *prgRowStatus);
        
        HRESULT ( STDMETHODCALLTYPE  *Update )( 
            IRowsetUpdate  * This,
            /* [in] */ HCHAPTER hReserved,
            /* [in] */ DBCOUNTITEM cRows,
            /* [size_is][in] */ const HROW  rghRows[  ],
            /* [out][in] */ DBCOUNTITEM *pcRows,
            /* [size_is][size_is][out] */ HROW  * *prgRows,
            /* [size_is][size_is][out] */ DBROWSTATUS  * *prgRowStatus);
        
        END_INTERFACE
    } IRowsetUpdateVtbl;

    interface IRowsetUpdate
    {
        CONST_VTBL struct IRowsetUpdateVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRowsetUpdate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRowsetUpdate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRowsetUpdate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRowsetUpdate_DeleteRows(This,hReserved,cRows,rghRows,rgRowStatus)	\
    (This)->lpVtbl -> DeleteRows(This,hReserved,cRows,rghRows,rgRowStatus)

#define IRowsetUpdate_SetData(This,hRow,hAccessor,pData)	\
    (This)->lpVtbl -> SetData(This,hRow,hAccessor,pData)

#define IRowsetUpdate_InsertRow(This,hReserved,hAccessor,pData,phRow)	\
    (This)->lpVtbl -> InsertRow(This,hReserved,hAccessor,pData,phRow)


#define IRowsetUpdate_GetOriginalData(This,hRow,hAccessor,pData)	\
    (This)->lpVtbl -> GetOriginalData(This,hRow,hAccessor,pData)

#define IRowsetUpdate_GetPendingRows(This,hReserved,dwRowStatus,pcPendingRows,prgPendingRows,prgPendingStatus)	\
    (This)->lpVtbl -> GetPendingRows(This,hReserved,dwRowStatus,pcPendingRows,prgPendingRows,prgPendingStatus)

#define IRowsetUpdate_GetRowStatus(This,hReserved,cRows,rghRows,rgPendingStatus)	\
    (This)->lpVtbl -> GetRowStatus(This,hReserved,cRows,rghRows,rgPendingStatus)

#define IRowsetUpdate_Undo(This,hReserved,cRows,rghRows,pcRowsUndone,prgRowsUndone,prgRowStatus)	\
    (This)->lpVtbl -> Undo(This,hReserved,cRows,rghRows,pcRowsUndone,prgRowsUndone,prgRowStatus)

#define IRowsetUpdate_Update(This,hReserved,cRows,rghRows,pcRows,prgRows,prgRowStatus)	\
    (This)->lpVtbl -> Update(This,hReserved,cRows,rghRows,pcRows,prgRows,prgRowStatus)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRowsetUpdate_GetOriginalData_Proxy( 
    IRowsetUpdate  * This,
    /* [in] */ HROW hRow,
    /* [in] */ HACCESSOR hAccessor,
    /* [out] */ void  *pData);


void __RPC_STUB IRowsetUpdate_GetOriginalData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRowsetUpdate_GetPendingRows_Proxy( 
    IRowsetUpdate  * This,
    /* [in] */ HCHAPTER hReserved,
    /* [in] */ DBPENDINGSTATUS dwRowStatus,
    /* [out][in] */ DBCOUNTITEM *pcPendingRows,
    /* [size_is][size_is][out] */ HROW  * *prgPendingRows,
    /* [size_is][size_is][out] */ DBPENDINGSTATUS  * *prgPendingStatus);


void __RPC_STUB IRowsetUpdate_GetPendingRows_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRowsetUpdate_GetRowStatus_Proxy( 
    IRowsetUpdate  * This,
    /* [in] */ HCHAPTER hReserved,
    /* [in] */ DBCOUNTITEM cRows,
    /* [size_is][in] */ const HROW  rghRows[  ],
    /* [size_is][out] */ DBPENDINGSTATUS  rgPendingStatus[  ]);


void __RPC_STUB IRowsetUpdate_GetRowStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRowsetUpdate_Undo_Proxy( 
    IRowsetUpdate  * This,
    /* [in] */ HCHAPTER hReserved,
    /* [in] */ DBCOUNTITEM cRows,
    /* [size_is][in] */ const HROW  rghRows[  ],
    /* [out][in] */ DBCOUNTITEM *pcRowsUndone,
    /* [size_is][size_is][out] */ HROW  * *prgRowsUndone,
    /* [size_is][size_is][out] */ DBROWSTATUS  * *prgRowStatus);


void __RPC_STUB IRowsetUpdate_Undo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRowsetUpdate_Update_Proxy( 
    IRowsetUpdate  * This,
    /* [in] */ HCHAPTER hReserved,
    /* [in] */ DBCOUNTITEM cRows,
    /* [size_is][in] */ const HROW  rghRows[  ],
    /* [out][in] */ DBCOUNTITEM *pcRows,
    /* [size_is][size_is][out] */ HROW  * *prgRows,
    /* [size_is][size_is][out] */ DBROWSTATUS  * *prgRowStatus);


void __RPC_STUB IRowsetUpdate_Update_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRowsetUpdate_INTERFACE_DEFINED__ */


#ifndef __IRowsetIdentity_INTERFACE_DEFINED__
#define __IRowsetIdentity_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRowsetIdentity
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IRowsetIdentity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a09-2a1c-11ce-ade5-00aa0044773d")
    IRowsetIdentity : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE IsSameRow( 
            /* [in] */ HROW hThisRow,
            /* [in] */ HROW hThatRow) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRowsetIdentityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IRowsetIdentity  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IRowsetIdentity  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IRowsetIdentity  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *IsSameRow )( 
            IRowsetIdentity  * This,
            /* [in] */ HROW hThisRow,
            /* [in] */ HROW hThatRow);
        
        END_INTERFACE
    } IRowsetIdentityVtbl;

    interface IRowsetIdentity
    {
        CONST_VTBL struct IRowsetIdentityVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRowsetIdentity_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRowsetIdentity_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRowsetIdentity_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRowsetIdentity_IsSameRow(This,hThisRow,hThatRow)	\
    (This)->lpVtbl -> IsSameRow(This,hThisRow,hThatRow)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IRowsetIdentity_RemoteIsSameRow_Proxy( 
    IRowsetIdentity  * This,
    /* [in] */ HROW hThisRow,
    /* [in] */ HROW hThatRow,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IRowsetIdentity_RemoteIsSameRow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRowsetIdentity_INTERFACE_DEFINED__ */


#ifndef __IRowsetNotify_INTERFACE_DEFINED__
#define __IRowsetNotify_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRowsetNotify
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IRowsetNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a83-2a1c-11ce-ade5-00aa0044773d")
    IRowsetNotify : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE OnFieldChange( 
            /* [in] */ IRowset  *pRowset,
            /* [in] */ HROW hRow,
            /* [in] */ DBORDINAL cColumns,
            /* [size_is][in] */ DBORDINAL rgColumns[  ],
            /* [in] */ DBREASON eReason,
            /* [in] */ DBEVENTPHASE ePhase,
            /* [in] */ BOOL fCantDeny) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE OnRowChange( 
            /* [in] */ IRowset  *pRowset,
            /* [in] */ DBCOUNTITEM cRows,
            /* [size_is][in] */ const HROW  rghRows[  ],
            /* [in] */ DBREASON eReason,
            /* [in] */ DBEVENTPHASE ePhase,
            /* [in] */ BOOL fCantDeny) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE OnRowsetChange( 
            /* [in] */ IRowset  *pRowset,
            /* [in] */ DBREASON eReason,
            /* [in] */ DBEVENTPHASE ePhase,
            /* [in] */ BOOL fCantDeny) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRowsetNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IRowsetNotify  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IRowsetNotify  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IRowsetNotify  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *OnFieldChange )( 
            IRowsetNotify  * This,
            /* [in] */ IRowset  *pRowset,
            /* [in] */ HROW hRow,
            /* [in] */ DBORDINAL cColumns,
            /* [size_is][in] */ DBORDINAL rgColumns[  ],
            /* [in] */ DBREASON eReason,
            /* [in] */ DBEVENTPHASE ePhase,
            /* [in] */ BOOL fCantDeny);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *OnRowChange )( 
            IRowsetNotify  * This,
            /* [in] */ IRowset  *pRowset,
            /* [in] */ DBCOUNTITEM cRows,
            /* [size_is][in] */ const HROW  rghRows[  ],
            /* [in] */ DBREASON eReason,
            /* [in] */ DBEVENTPHASE ePhase,
            /* [in] */ BOOL fCantDeny);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *OnRowsetChange )( 
            IRowsetNotify  * This,
            /* [in] */ IRowset  *pRowset,
            /* [in] */ DBREASON eReason,
            /* [in] */ DBEVENTPHASE ePhase,
            /* [in] */ BOOL fCantDeny);
        
        END_INTERFACE
    } IRowsetNotifyVtbl;

    interface IRowsetNotify
    {
        CONST_VTBL struct IRowsetNotifyVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRowsetNotify_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRowsetNotify_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRowsetNotify_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRowsetNotify_OnFieldChange(This,pRowset,hRow,cColumns,rgColumns,eReason,ePhase,fCantDeny)	\
    (This)->lpVtbl -> OnFieldChange(This,pRowset,hRow,cColumns,rgColumns,eReason,ePhase,fCantDeny)

#define IRowsetNotify_OnRowChange(This,pRowset,cRows,rghRows,eReason,ePhase,fCantDeny)	\
    (This)->lpVtbl -> OnRowChange(This,pRowset,cRows,rghRows,eReason,ePhase,fCantDeny)

#define IRowsetNotify_OnRowsetChange(This,pRowset,eReason,ePhase,fCantDeny)	\
    (This)->lpVtbl -> OnRowsetChange(This,pRowset,eReason,ePhase,fCantDeny)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IRowsetNotify_RemoteOnFieldChange_Proxy( 
    IRowsetNotify  * This,
    /* [in] */ IRowset  *pRowset,
    /* [in] */ HROW hRow,
    /* [in] */ DBORDINAL cColumns,
    /* [size_is][in] */ DBORDINAL *rgColumns,
    /* [in] */ DBREASON eReason,
    /* [in] */ DBEVENTPHASE ePhase,
    /* [in] */ BOOL fCantDeny,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IRowsetNotify_RemoteOnFieldChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IRowsetNotify_RemoteOnRowChange_Proxy( 
    IRowsetNotify  * This,
    /* [in] */ IRowset  *pRowset,
    /* [in] */ DBCOUNTITEM cRows,
    /* [size_is][in] */ const HROW  *rghRows,
    /* [in] */ DBREASON eReason,
    /* [in] */ DBEVENTPHASE ePhase,
    /* [in] */ BOOL fCantDeny,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IRowsetNotify_RemoteOnRowChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IRowsetNotify_RemoteOnRowsetChange_Proxy( 
    IRowsetNotify  * This,
    /* [in] */ IRowset  *pRowset,
    /* [in] */ DBREASON eReason,
    /* [in] */ DBEVENTPHASE ePhase,
    /* [in] */ BOOL fCantDeny,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IRowsetNotify_RemoteOnRowsetChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRowsetNotify_INTERFACE_DEFINED__ */


#ifndef __IRowsetIndex_INTERFACE_DEFINED__
#define __IRowsetIndex_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRowsetIndex
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object][local] */ 


typedef DWORD DBSEEK;


enum DBSEEKENUM
    {	DBSEEK_INVALID	= 0,
	DBSEEK_FIRSTEQ	= 0x1,
	DBSEEK_LASTEQ	= 0x2,
	DBSEEK_AFTEREQ	= 0x4,
	DBSEEK_AFTER	= 0x8,
	DBSEEK_BEFOREEQ	= 0x10,
	DBSEEK_BEFORE	= 0x20
    };
#define	DBSEEK_GE	DBSEEK_AFTEREQ
#define	DBSEEK_GT	DBSEEK_AFTER
#define	DBSEEK_LE	DBSEEK_BEFOREEQ
#define	DBSEEK_LT	DBSEEK_BEFORE
typedef DWORD DBRANGE;


enum DBRANGEENUM
    {	DBRANGE_INCLUSIVESTART	= 0,
	DBRANGE_INCLUSIVEEND	= 0,
	DBRANGE_EXCLUSIVESTART	= 0x1,
	DBRANGE_EXCLUSIVEEND	= 0x2,
	DBRANGE_EXCLUDENULLS	= 0x4,
	DBRANGE_PREFIX	= 0x8,
	DBRANGE_MATCH	= 0x10
    };

enum DBRANGEENUM20
    {	DBRANGE_MATCH_N_SHIFT	= 0x18,
	DBRANGE_MATCH_N_MASK	= 0xff
    };

EXTERN_C const IID IID_IRowsetIndex;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a82-2a1c-11ce-ade5-00aa0044773d")
    IRowsetIndex : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetIndexInfo( 
            /* [out][in] */ DBORDINAL *pcKeyColumns,
            /* [size_is][size_is][out] */ DBINDEXCOLUMNDESC  * *prgIndexColumnDesc,
            /* [out][in] */ ULONG  *pcIndexProperties,
            /* [size_is][size_is][out] */ DBPROPSET  * *prgIndexProperties) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Seek( 
            /* [in] */ HACCESSOR hAccessor,
            /* [in] */ DBORDINAL cKeyValues,
            /* [in] */ void  *pData,
            /* [in] */ DBSEEK dwSeekOptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRange( 
            /* [in] */ HACCESSOR hAccessor,
            /* [in] */ DBORDINAL cStartKeyColumns,
            /* [in] */ void  *pStartData,
            /* [in] */ DBORDINAL cEndKeyColumns,
            /* [in] */ void  *pEndData,
            /* [in] */ DBRANGE dwRangeOptions) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRowsetIndexVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IRowsetIndex  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IRowsetIndex  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IRowsetIndex  * This);
        
        HRESULT ( STDMETHODCALLTYPE  *GetIndexInfo )( 
            IRowsetIndex  * This,
            /* [out][in] */ DBORDINAL *pcKeyColumns,
            /* [size_is][size_is][out] */ DBINDEXCOLUMNDESC  * *prgIndexColumnDesc,
            /* [out][in] */ ULONG  *pcIndexProperties,
            /* [size_is][size_is][out] */ DBPROPSET  * *prgIndexProperties);
        
        HRESULT ( STDMETHODCALLTYPE  *Seek )( 
            IRowsetIndex  * This,
            /* [in] */ HACCESSOR hAccessor,
            /* [in] */ DBORDINAL cKeyValues,
            /* [in] */ void  *pData,
            /* [in] */ DBSEEK dwSeekOptions);
        
        HRESULT ( STDMETHODCALLTYPE  *SetRange )( 
            IRowsetIndex  * This,
            /* [in] */ HACCESSOR hAccessor,
            /* [in] */ DBORDINAL cStartKeyColumns,
            /* [in] */ void  *pStartData,
            /* [in] */ DBORDINAL cEndKeyColumns,
            /* [in] */ void  *pEndData,
            /* [in] */ DBRANGE dwRangeOptions);
        
        END_INTERFACE
    } IRowsetIndexVtbl;

    interface IRowsetIndex
    {
        CONST_VTBL struct IRowsetIndexVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRowsetIndex_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRowsetIndex_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRowsetIndex_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRowsetIndex_GetIndexInfo(This,pcKeyColumns,prgIndexColumnDesc,pcIndexProperties,prgIndexProperties)	\
    (This)->lpVtbl -> GetIndexInfo(This,pcKeyColumns,prgIndexColumnDesc,pcIndexProperties,prgIndexProperties)

#define IRowsetIndex_Seek(This,hAccessor,cKeyValues,pData,dwSeekOptions)	\
    (This)->lpVtbl -> Seek(This,hAccessor,cKeyValues,pData,dwSeekOptions)

#define IRowsetIndex_SetRange(This,hAccessor,cStartKeyColumns,pStartData,cEndKeyColumns,pEndData,dwRangeOptions)	\
    (This)->lpVtbl -> SetRange(This,hAccessor,cStartKeyColumns,pStartData,cEndKeyColumns,pEndData,dwRangeOptions)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRowsetIndex_GetIndexInfo_Proxy( 
    IRowsetIndex  * This,
    /* [out][in] */ DBORDINAL *pcKeyColumns,
    /* [size_is][size_is][out] */ DBINDEXCOLUMNDESC  * *prgIndexColumnDesc,
    /* [out][in] */ ULONG  *pcIndexProperties,
    /* [size_is][size_is][out] */ DBPROPSET  * *prgIndexProperties);


void __RPC_STUB IRowsetIndex_GetIndexInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRowsetIndex_Seek_Proxy( 
    IRowsetIndex  * This,
    /* [in] */ HACCESSOR hAccessor,
    /* [in] */ DBORDINAL cKeyValues,
    /* [in] */ void  *pData,
    /* [in] */ DBSEEK dwSeekOptions);


void __RPC_STUB IRowsetIndex_Seek_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRowsetIndex_SetRange_Proxy( 
    IRowsetIndex  * This,
    /* [in] */ HACCESSOR hAccessor,
    /* [in] */ DBORDINAL cStartKeyColumns,
    /* [in] */ void  *pStartData,
    /* [in] */ DBORDINAL cEndKeyColumns,
    /* [in] */ void  *pEndData,
    /* [in] */ DBRANGE dwRangeOptions);


void __RPC_STUB IRowsetIndex_SetRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRowsetIndex_INTERFACE_DEFINED__ */


#ifndef __ICommand_INTERFACE_DEFINED__
#define __ICommand_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICommand
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_ICommand;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a63-2a1c-11ce-ade5-00aa0044773d")
    ICommand : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Execute( 
            /* [in] */ IUnknown  *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [out][in] */ DBPARAMS  *pParams,
            /* [out] */ DBROWCOUNT *pcRowsAffected,
            /* [iid_is][out] */ IUnknown  * *ppRowset) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetDBSession( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown  * *ppSession) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICommandVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            ICommand  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            ICommand  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            ICommand  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *Cancel )( 
            ICommand  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *Execute )( 
            ICommand  * This,
            /* [in] */ IUnknown  *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [out][in] */ DBPARAMS  *pParams,
            /* [out] */ DBROWCOUNT *pcRowsAffected,
            /* [iid_is][out] */ IUnknown  * *ppRowset);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetDBSession )( 
            ICommand  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown  * *ppSession);
        
        END_INTERFACE
    } ICommandVtbl;

    interface ICommand
    {
        CONST_VTBL struct ICommandVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICommand_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICommand_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICommand_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICommand_Cancel(This)	\
    (This)->lpVtbl -> Cancel(This)

#define ICommand_Execute(This,pUnkOuter,riid,pParams,pcRowsAffected,ppRowset)	\
    (This)->lpVtbl -> Execute(This,pUnkOuter,riid,pParams,pcRowsAffected,ppRowset)

#define ICommand_GetDBSession(This,riid,ppSession)	\
    (This)->lpVtbl -> GetDBSession(This,riid,ppSession)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE ICommand_RemoteCancel_Proxy( 
    ICommand  * This,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB ICommand_RemoteCancel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ICommand_RemoteExecute_Proxy( 
    ICommand  * This,
    /* [in] */ IUnknown  *pUnkOuter,
    /* [in] */ REFIID riid,
    /* [in] */ HACCESSOR hAccessor,
    /* [in] */ DB_UPARAMS cParamSets,
    /* [in] */ ULONG cbData,
    /* [size_is][unique][out][in] */ BYTE  *pbData,
    /* [unique][out][in] */ DBROWCOUNT *pcRowsAffected,
    /* [iid_is][unique][out][in] */ IUnknown  * *ppRowset,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB ICommand_RemoteExecute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ICommand_RemoteGetDBSession_Proxy( 
    ICommand  * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown  * *ppSession,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB ICommand_RemoteGetDBSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICommand_INTERFACE_DEFINED__ */


#ifndef __IMultipleResults_INTERFACE_DEFINED__
#define __IMultipleResults_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMultipleResults
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 

typedef DB_LRESERVE DBRESULTFLAG;


EXTERN_C const IID IID_IMultipleResults;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a90-2a1c-11ce-ade5-00aa0044773d")
    IMultipleResults : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetResult( 
            /* [in] */ IUnknown  *pUnkOuter,
            /* [in] */ DBRESULTFLAG lResultFlag,
            /* [in] */ REFIID riid,
            /* [out] */ DBROWCOUNT *pcRowsAffected,
            /* [iid_is][out] */ IUnknown  * *ppRowset) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMultipleResultsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IMultipleResults  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IMultipleResults  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IMultipleResults  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetResult )( 
            IMultipleResults  * This,
            /* [in] */ IUnknown  *pUnkOuter,
            /* [in] */ DBRESULTFLAG lResultFlag,
            /* [in] */ REFIID riid,
            /* [out] */ DBROWCOUNT *pcRowsAffected,
            /* [iid_is][out] */ IUnknown  * *ppRowset);
        
        END_INTERFACE
    } IMultipleResultsVtbl;

    interface IMultipleResults
    {
        CONST_VTBL struct IMultipleResultsVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMultipleResults_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMultipleResults_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMultipleResults_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMultipleResults_GetResult(This,pUnkOuter,lResultFlag,riid,pcRowsAffected,ppRowset)	\
    (This)->lpVtbl -> GetResult(This,pUnkOuter,lResultFlag,riid,pcRowsAffected,ppRowset)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IMultipleResults_RemoteGetResult_Proxy( 
    IMultipleResults  * This,
    /* [in] */ IUnknown  *pUnkOuter,
    /* [in] */ DBRESULTFLAG lResultFlag,
    /* [in] */ REFIID riid,
    /* [unique][out][in] */ DBROWCOUNT *pcRowsAffected,
    /* [iid_is][unique][out][in] */ IUnknown  * *ppRowset,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IMultipleResults_RemoteGetResult_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMultipleResults_INTERFACE_DEFINED__ */


#ifndef __IConvertType_INTERFACE_DEFINED__
#define __IConvertType_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IConvertType
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 


typedef DWORD DBCONVERTFLAGS;


enum DBCONVERTFLAGSENUM
    {	DBCONVERTFLAGS_COLUMN	= 0,
	DBCONVERTFLAGS_PARAMETER	= 0x1
    };

enum DBCONVERTFLAGSENUM20
    {	DBCONVERTFLAGS_ISLONG	= 0x2,
	DBCONVERTFLAGS_ISFIXEDLENGTH	= 0x4,
	DBCONVERTFLAGS_FROMVARIANT	= 0x8
    };

EXTERN_C const IID IID_IConvertType;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a88-2a1c-11ce-ade5-00aa0044773d")
    IConvertType : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CanConvert( 
            /* [in] */ DBTYPE wFromType,
            /* [in] */ DBTYPE wToType,
            /* [in] */ DBCONVERTFLAGS dwConvertFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IConvertTypeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IConvertType  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IConvertType  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IConvertType  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *CanConvert )( 
            IConvertType  * This,
            /* [in] */ DBTYPE wFromType,
            /* [in] */ DBTYPE wToType,
            /* [in] */ DBCONVERTFLAGS dwConvertFlags);
        
        END_INTERFACE
    } IConvertTypeVtbl;

    interface IConvertType
    {
        CONST_VTBL struct IConvertTypeVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IConvertType_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IConvertType_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IConvertType_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IConvertType_CanConvert(This,wFromType,wToType,dwConvertFlags)	\
    (This)->lpVtbl -> CanConvert(This,wFromType,wToType,dwConvertFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IConvertType_RemoteCanConvert_Proxy( 
    IConvertType  * This,
    /* [in] */ DBTYPE wFromType,
    /* [in] */ DBTYPE wToType,
    /* [in] */ DBCONVERTFLAGS dwConvertFlags,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IConvertType_RemoteCanConvert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IConvertType_INTERFACE_DEFINED__ */


#ifndef __ICommandPrepare_INTERFACE_DEFINED__
#define __ICommandPrepare_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICommandPrepare
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_ICommandPrepare;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a26-2a1c-11ce-ade5-00aa0044773d")
    ICommandPrepare : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Prepare( 
            /* [in] */ ULONG cExpectedRuns) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Unprepare( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICommandPrepareVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            ICommandPrepare  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            ICommandPrepare  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            ICommandPrepare  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *Prepare )( 
            ICommandPrepare  * This,
            /* [in] */ ULONG cExpectedRuns);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *Unprepare )( 
            ICommandPrepare  * This);
        
        END_INTERFACE
    } ICommandPrepareVtbl;

    interface ICommandPrepare
    {
        CONST_VTBL struct ICommandPrepareVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICommandPrepare_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICommandPrepare_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICommandPrepare_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICommandPrepare_Prepare(This,cExpectedRuns)	\
    (This)->lpVtbl -> Prepare(This,cExpectedRuns)

#define ICommandPrepare_Unprepare(This)	\
    (This)->lpVtbl -> Unprepare(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE ICommandPrepare_RemotePrepare_Proxy( 
    ICommandPrepare  * This,
    /* [in] */ ULONG cExpectedRuns,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB ICommandPrepare_RemotePrepare_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ICommandPrepare_RemoteUnprepare_Proxy( 
    ICommandPrepare  * This,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB ICommandPrepare_RemoteUnprepare_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICommandPrepare_INTERFACE_DEFINED__ */


#ifndef __ICommandProperties_INTERFACE_DEFINED__
#define __ICommandProperties_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICommandProperties
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_ICommandProperties;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a79-2a1c-11ce-ade5-00aa0044773d")
    ICommandProperties : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [in] */ const ULONG cPropertyIDSets,
            /* [size_is][in] */ const DBPROPIDSET  rgPropertyIDSets[  ],
            /* [out][in] */ ULONG  *pcPropertySets,
            /* [size_is][size_is][out] */ DBPROPSET  * *prgPropertySets) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SetProperties( 
            /* [in] */ ULONG cPropertySets,
            /* [size_is][unique][out][in] */ DBPROPSET  rgPropertySets[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICommandPropertiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            ICommandProperties  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            ICommandProperties  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            ICommandProperties  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetProperties )( 
            ICommandProperties  * This,
            /* [in] */ const ULONG cPropertyIDSets,
            /* [size_is][in] */ const DBPROPIDSET  rgPropertyIDSets[  ],
            /* [out][in] */ ULONG  *pcPropertySets,
            /* [size_is][size_is][out] */ DBPROPSET  * *prgPropertySets);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *SetProperties )( 
            ICommandProperties  * This,
            /* [in] */ ULONG cPropertySets,
            /* [size_is][unique][out][in] */ DBPROPSET  rgPropertySets[  ]);
        
        END_INTERFACE
    } ICommandPropertiesVtbl;

    interface ICommandProperties
    {
        CONST_VTBL struct ICommandPropertiesVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICommandProperties_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICommandProperties_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICommandProperties_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICommandProperties_GetProperties(This,cPropertyIDSets,rgPropertyIDSets,pcPropertySets,prgPropertySets)	\
    (This)->lpVtbl -> GetProperties(This,cPropertyIDSets,rgPropertyIDSets,pcPropertySets,prgPropertySets)

#define ICommandProperties_SetProperties(This,cPropertySets,rgPropertySets)	\
    (This)->lpVtbl -> SetProperties(This,cPropertySets,rgPropertySets)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE ICommandProperties_RemoteGetProperties_Proxy( 
    ICommandProperties  * This,
    /* [in] */ const ULONG cPropertyIDSets,
    /* [size_is][unique][in] */ const DBPROPIDSET  *rgPropertyIDSets,
    /* [out][in] */ ULONG  *pcPropertySets,
    /* [size_is][size_is][out] */ DBPROPSET  * *prgPropertySets,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB ICommandProperties_RemoteGetProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ICommandProperties_RemoteSetProperties_Proxy( 
    ICommandProperties  * This,
    /* [in] */ ULONG cPropertySets,
    /* [size_is][unique][in] */ DBPROPSET  *rgPropertySets,
    /* [in] */ ULONG cTotalProps,
    /* [size_is][out] */ DBPROPSTATUS  *rgPropStatus,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB ICommandProperties_RemoteSetProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICommandProperties_INTERFACE_DEFINED__ */


#ifndef __ICommandText_INTERFACE_DEFINED__
#define __ICommandText_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICommandText
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_ICommandText;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a27-2a1c-11ce-ade5-00aa0044773d")
    ICommandText : public ICommand
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetCommandText( 
            /* [out][in] */ GUID  *pguidDialect,
            /* [out] */ LPOLESTR  *ppwszCommand) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SetCommandText( 
            /* [in] */ REFGUID rguidDialect,
            /* [unique][in] */ LPCOLESTR pwszCommand) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICommandTextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            ICommandText  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            ICommandText  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            ICommandText  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *Cancel )( 
            ICommandText  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *Execute )( 
            ICommandText  * This,
            /* [in] */ IUnknown  *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [out][in] */ DBPARAMS  *pParams,
            /* [out] */ DBROWCOUNT *pcRowsAffected,
            /* [iid_is][out] */ IUnknown  * *ppRowset);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetDBSession )( 
            ICommandText  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown  * *ppSession);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetCommandText )( 
            ICommandText  * This,
            /* [out][in] */ GUID  *pguidDialect,
            /* [out] */ LPOLESTR  *ppwszCommand);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *SetCommandText )( 
            ICommandText  * This,
            /* [in] */ REFGUID rguidDialect,
            /* [unique][in] */ LPCOLESTR pwszCommand);
        
        END_INTERFACE
    } ICommandTextVtbl;

    interface ICommandText
    {
        CONST_VTBL struct ICommandTextVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICommandText_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICommandText_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICommandText_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICommandText_Cancel(This)	\
    (This)->lpVtbl -> Cancel(This)

#define ICommandText_Execute(This,pUnkOuter,riid,pParams,pcRowsAffected,ppRowset)	\
    (This)->lpVtbl -> Execute(This,pUnkOuter,riid,pParams,pcRowsAffected,ppRowset)

#define ICommandText_GetDBSession(This,riid,ppSession)	\
    (This)->lpVtbl -> GetDBSession(This,riid,ppSession)


#define ICommandText_GetCommandText(This,pguidDialect,ppwszCommand)	\
    (This)->lpVtbl -> GetCommandText(This,pguidDialect,ppwszCommand)

#define ICommandText_SetCommandText(This,rguidDialect,pwszCommand)	\
    (This)->lpVtbl -> SetCommandText(This,rguidDialect,pwszCommand)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE ICommandText_RemoteGetCommandText_Proxy( 
    ICommandText  * This,
    /* [unique][out][in] */ GUID  *pguidDialect,
    /* [out] */ LPOLESTR  *ppwszCommand,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB ICommandText_RemoteGetCommandText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ICommandText_RemoteSetCommandText_Proxy( 
    ICommandText  * This,
    /* [in] */ REFGUID rguidDialect,
    /* [unique][in] */ LPCOLESTR pwszCommand,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB ICommandText_RemoteSetCommandText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICommandText_INTERFACE_DEFINED__ */


#ifndef __ICommandWithParameters_INTERFACE_DEFINED__
#define __ICommandWithParameters_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICommandWithParameters
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 


typedef struct  tagDBPARAMBINDINFO
    {
    LPOLESTR pwszDataSourceType;
    LPOLESTR pwszName;
    DBLENGTH ulParamSize;
    DBPARAMFLAGS dwFlags;
    BYTE bPrecision;
    BYTE bScale;
    }	DBPARAMBINDINFO;


EXTERN_C const IID IID_ICommandWithParameters;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a64-2a1c-11ce-ade5-00aa0044773d")
    ICommandWithParameters : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetParameterInfo( 
            /* [out][in] */ DB_UPARAMS *pcParams,
            /* [size_is][size_is][out] */ DBPARAMINFO  * *prgParamInfo,
            /* [out] */ OLECHAR  * *ppNamesBuffer) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE MapParameterNames( 
            /* [in] */ DB_UPARAMS cParamNames,
            /* [size_is][in] */ const OLECHAR  * rgParamNames[  ],
            /* [size_is][out] */ DB_LPARAMS rgParamOrdinals[  ]) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SetParameterInfo( 
            /* [in] */ DB_UPARAMS cParams,
            /* [size_is][unique][in] */ const DB_UPARAMS rgParamOrdinals[  ],
            /* [size_is][unique][in] */ const DBPARAMBINDINFO  rgParamBindInfo[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICommandWithParametersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            ICommandWithParameters  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            ICommandWithParameters  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            ICommandWithParameters  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetParameterInfo )( 
            ICommandWithParameters  * This,
            /* [out][in] */ DB_UPARAMS *pcParams,
            /* [size_is][size_is][out] */ DBPARAMINFO  * *prgParamInfo,
            /* [out] */ OLECHAR  * *ppNamesBuffer);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *MapParameterNames )( 
            ICommandWithParameters  * This,
            /* [in] */ DB_UPARAMS cParamNames,
            /* [size_is][in] */ const OLECHAR  * rgParamNames[  ],
            /* [size_is][out] */ DB_LPARAMS rgParamOrdinals[  ]);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *SetParameterInfo )( 
            ICommandWithParameters  * This,
            /* [in] */ DB_UPARAMS cParams,
            /* [size_is][unique][in] */ const DB_UPARAMS rgParamOrdinals[  ],
            /* [size_is][unique][in] */ const DBPARAMBINDINFO  rgParamBindInfo[  ]);
        
        END_INTERFACE
    } ICommandWithParametersVtbl;

    interface ICommandWithParameters
    {
        CONST_VTBL struct ICommandWithParametersVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICommandWithParameters_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICommandWithParameters_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICommandWithParameters_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICommandWithParameters_GetParameterInfo(This,pcParams,prgParamInfo,ppNamesBuffer)	\
    (This)->lpVtbl -> GetParameterInfo(This,pcParams,prgParamInfo,ppNamesBuffer)

#define ICommandWithParameters_MapParameterNames(This,cParamNames,rgParamNames,rgParamOrdinals)	\
    (This)->lpVtbl -> MapParameterNames(This,cParamNames,rgParamNames,rgParamOrdinals)

#define ICommandWithParameters_SetParameterInfo(This,cParams,rgParamOrdinals,rgParamBindInfo)	\
    (This)->lpVtbl -> SetParameterInfo(This,cParams,rgParamOrdinals,rgParamBindInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE ICommandWithParameters_RemoteGetParameterInfo_Proxy( 
    ICommandWithParameters  * This,
    /* [out][in] */ DB_UPARAMS *pcParams,
    /* [size_is][size_is][out] */ DBPARAMINFO  * *prgParamInfo,
    /* [size_is][size_is][out] */ DBBYTEOFFSET **prgNameOffsets,
    /* [out][in] */ DBLENGTH *pcbNamesBuffer,
    /* [size_is][size_is][unique][out][in] */ OLECHAR  * *ppNamesBuffer,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB ICommandWithParameters_RemoteGetParameterInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ICommandWithParameters_RemoteMapParameterNames_Proxy( 
    ICommandWithParameters  * This,
    /* [in] */ DB_UPARAMS cParamNames,
    /* [size_is][in] */ LPCOLESTR  *rgParamNames,
    /* [size_is][out] */ DB_LPARAMS *rgParamOrdinals,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB ICommandWithParameters_RemoteMapParameterNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ICommandWithParameters_RemoteSetParameterInfo_Proxy( 
    ICommandWithParameters  * This,
    /* [in] */ DB_UPARAMS cParams,
    /* [size_is][unique][in] */ const DB_UPARAMS *rgParamOrdinals,
    /* [size_is][unique][in] */ const DBPARAMBINDINFO  *rgParamBindInfo,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB ICommandWithParameters_RemoteSetParameterInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICommandWithParameters_INTERFACE_DEFINED__ */


#ifndef __IColumnsRowset_INTERFACE_DEFINED__
#define __IColumnsRowset_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IColumnsRowset
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IColumnsRowset;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a10-2a1c-11ce-ade5-00aa0044773d")
    IColumnsRowset : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetAvailableColumns( 
            /* [out][in] */ DBORDINAL *pcOptColumns,
            /* [size_is][size_is][out] */ DBID  * *prgOptColumns) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetColumnsRowset( 
            /* [in] */ IUnknown  *pUnkOuter,
            /* [in] */ DBORDINAL cOptColumns,
            /* [size_is][in] */ const DBID  rgOptColumns[  ],
            /* [in] */ REFIID riid,
            /* [in] */ ULONG cPropertySets,
            /* [size_is][out][in] */ DBPROPSET  rgPropertySets[  ],
            /* [iid_is][out] */ IUnknown  * *ppColRowset) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IColumnsRowsetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IColumnsRowset  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IColumnsRowset  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IColumnsRowset  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetAvailableColumns )( 
            IColumnsRowset  * This,
            /* [out][in] */ DBORDINAL *pcOptColumns,
            /* [size_is][size_is][out] */ DBID  * *prgOptColumns);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetColumnsRowset )( 
            IColumnsRowset  * This,
            /* [in] */ IUnknown  *pUnkOuter,
            /* [in] */ DBORDINAL cOptColumns,
            /* [size_is][in] */ const DBID  rgOptColumns[  ],
            /* [in] */ REFIID riid,
            /* [in] */ ULONG cPropertySets,
            /* [size_is][out][in] */ DBPROPSET  rgPropertySets[  ],
            /* [iid_is][out] */ IUnknown  * *ppColRowset);
        
        END_INTERFACE
    } IColumnsRowsetVtbl;

    interface IColumnsRowset
    {
        CONST_VTBL struct IColumnsRowsetVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IColumnsRowset_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IColumnsRowset_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IColumnsRowset_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IColumnsRowset_GetAvailableColumns(This,pcOptColumns,prgOptColumns)	\
    (This)->lpVtbl -> GetAvailableColumns(This,pcOptColumns,prgOptColumns)

#define IColumnsRowset_GetColumnsRowset(This,pUnkOuter,cOptColumns,rgOptColumns,riid,cPropertySets,rgPropertySets,ppColRowset)	\
    (This)->lpVtbl -> GetColumnsRowset(This,pUnkOuter,cOptColumns,rgOptColumns,riid,cPropertySets,rgPropertySets,ppColRowset)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IColumnsRowset_RemoteGetAvailableColumns_Proxy( 
    IColumnsRowset  * This,
    /* [out][in] */ DBORDINAL *pcOptColumns,
    /* [size_is][size_is][out] */ DBID  * *prgOptColumns,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IColumnsRowset_RemoteGetAvailableColumns_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IColumnsRowset_RemoteGetColumnsRowset_Proxy( 
    IColumnsRowset  * This,
    /* [in] */ IUnknown  *pUnkOuter,
    /* [in] */ DBORDINAL cOptColumns,
    /* [size_is][unique][in] */ const DBID  *rgOptColumns,
    /* [in] */ REFIID riid,
    /* [in] */ ULONG cPropertySets,
    /* [size_is][unique][in] */ DBPROPSET  *rgPropertySets,
    /* [iid_is][out] */ IUnknown  * *ppColRowset,
    /* [in] */ ULONG cTotalProps,
    /* [size_is][out] */ DBPROPSTATUS  *rgPropStatus,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IColumnsRowset_RemoteGetColumnsRowset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IColumnsRowset_INTERFACE_DEFINED__ */


#ifndef __IColumnsInfo_INTERFACE_DEFINED__
#define __IColumnsInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IColumnsInfo
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IColumnsInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a11-2a1c-11ce-ade5-00aa0044773d")
    IColumnsInfo : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetColumnInfo( 
            /* [out][in] */ DBORDINAL *pcColumns,
            /* [size_is][size_is][out] */ DBCOLUMNINFO  * *prgInfo,
            /* [out] */ OLECHAR  * *ppStringsBuffer) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE MapColumnIDs( 
            /* [in] */ DBORDINAL cColumnIDs,
            /* [size_is][in] */ const DBID  rgColumnIDs[  ],
            /* [size_is][out] */ DBORDINAL rgColumns[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IColumnsInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IColumnsInfo  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IColumnsInfo  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IColumnsInfo  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetColumnInfo )( 
            IColumnsInfo  * This,
            /* [out][in] */ DBORDINAL *pcColumns,
            /* [size_is][size_is][out] */ DBCOLUMNINFO  * *prgInfo,
            /* [out] */ OLECHAR  * *ppStringsBuffer);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *MapColumnIDs )( 
            IColumnsInfo  * This,
            /* [in] */ DBORDINAL cColumnIDs,
            /* [size_is][in] */ const DBID  rgColumnIDs[  ],
            /* [size_is][out] */ DBORDINAL rgColumns[  ]);
        
        END_INTERFACE
    } IColumnsInfoVtbl;

    interface IColumnsInfo
    {
        CONST_VTBL struct IColumnsInfoVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IColumnsInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IColumnsInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IColumnsInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IColumnsInfo_GetColumnInfo(This,pcColumns,prgInfo,ppStringsBuffer)	\
    (This)->lpVtbl -> GetColumnInfo(This,pcColumns,prgInfo,ppStringsBuffer)

#define IColumnsInfo_MapColumnIDs(This,cColumnIDs,rgColumnIDs,rgColumns)	\
    (This)->lpVtbl -> MapColumnIDs(This,cColumnIDs,rgColumnIDs,rgColumns)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IColumnsInfo_RemoteGetColumnInfo_Proxy( 
    IColumnsInfo  * This,
    /* [out][in] */ DBORDINAL *pcColumns,
    /* [size_is][size_is][out] */ DBCOLUMNINFO  * *prgInfo,
    /* [size_is][size_is][out] */ DBBYTEOFFSET **prgNameOffsets,
    /* [size_is][size_is][out] */ DBBYTEOFFSET **prgcolumnidOffsets,
    /* [out][in] */ DBLENGTH *pcbStringsBuffer,
    /* [size_is][size_is][unique][out][in] */ OLECHAR  * *ppStringsBuffer,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IColumnsInfo_RemoteGetColumnInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IColumnsInfo_RemoteMapColumnIDs_Proxy( 
    IColumnsInfo  * This,
    /* [in] */ DBORDINAL cColumnIDs,
    /* [size_is][in] */ const DBID  *rgColumnIDs,
    /* [size_is][out] */ DBORDINAL *rgColumns,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IColumnsInfo_RemoteMapColumnIDs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IColumnsInfo_INTERFACE_DEFINED__ */


#ifndef __IDBCreateCommand_INTERFACE_DEFINED__
#define __IDBCreateCommand_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDBCreateCommand
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IDBCreateCommand;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a1d-2a1c-11ce-ade5-00aa0044773d")
    IDBCreateCommand : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CreateCommand( 
            /* [in] */ IUnknown  *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown  * *ppCommand) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDBCreateCommandVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IDBCreateCommand  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IDBCreateCommand  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IDBCreateCommand  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *CreateCommand )( 
            IDBCreateCommand  * This,
            /* [in] */ IUnknown  *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown  * *ppCommand);
        
        END_INTERFACE
    } IDBCreateCommandVtbl;

    interface IDBCreateCommand
    {
        CONST_VTBL struct IDBCreateCommandVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDBCreateCommand_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDBCreateCommand_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDBCreateCommand_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDBCreateCommand_CreateCommand(This,pUnkOuter,riid,ppCommand)	\
    (This)->lpVtbl -> CreateCommand(This,pUnkOuter,riid,ppCommand)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IDBCreateCommand_RemoteCreateCommand_Proxy( 
    IDBCreateCommand  * This,
    /* [in] */ IUnknown  *pUnkOuter,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown  * *ppCommand,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IDBCreateCommand_RemoteCreateCommand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDBCreateCommand_INTERFACE_DEFINED__ */


#ifndef __IDBCreateSession_INTERFACE_DEFINED__
#define __IDBCreateSession_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDBCreateSession
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IDBCreateSession;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a5d-2a1c-11ce-ade5-00aa0044773d")
    IDBCreateSession : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CreateSession( 
            /* [in] */ IUnknown  *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown  * *ppDBSession) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDBCreateSessionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IDBCreateSession  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IDBCreateSession  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IDBCreateSession  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *CreateSession )( 
            IDBCreateSession  * This,
            /* [in] */ IUnknown  *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown  * *ppDBSession);
        
        END_INTERFACE
    } IDBCreateSessionVtbl;

    interface IDBCreateSession
    {
        CONST_VTBL struct IDBCreateSessionVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDBCreateSession_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDBCreateSession_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDBCreateSession_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDBCreateSession_CreateSession(This,pUnkOuter,riid,ppDBSession)	\
    (This)->lpVtbl -> CreateSession(This,pUnkOuter,riid,ppDBSession)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IDBCreateSession_RemoteCreateSession_Proxy( 
    IDBCreateSession  * This,
    /* [in] */ IUnknown  *pUnkOuter,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown  * *ppDBSession,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IDBCreateSession_RemoteCreateSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDBCreateSession_INTERFACE_DEFINED__ */


#ifndef __ISourcesRowset_INTERFACE_DEFINED__
#define __ISourcesRowset_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISourcesRowset
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 


typedef DWORD DBSOURCETYPE;


enum DBSOURCETYPEENUM
    {	DBSOURCETYPE_DATASOURCE	= 1,
	DBSOURCETYPE_ENUMERATOR	= 2
    };

enum DBSOURCETYPEENUM20
    {	DBSOURCETYPE_DATASOURCE_TDP	= 1,
	DBSOURCETYPE_DATASOURCE_MDP	= 3
    };

EXTERN_C const IID IID_ISourcesRowset;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a1e-2a1c-11ce-ade5-00aa0044773d")
    ISourcesRowset : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetSourcesRowset( 
            /* [in] */ IUnknown  *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [in] */ ULONG cPropertySets,
            /* [size_is][unique][out][in] */ DBPROPSET  rgProperties[  ],
            /* [iid_is][out] */ IUnknown  * *ppSourcesRowset) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISourcesRowsetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            ISourcesRowset  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            ISourcesRowset  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            ISourcesRowset  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetSourcesRowset )( 
            ISourcesRowset  * This,
            /* [in] */ IUnknown  *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [in] */ ULONG cPropertySets,
            /* [size_is][unique][out][in] */ DBPROPSET  rgProperties[  ],
            /* [iid_is][out] */ IUnknown  * *ppSourcesRowset);
        
        END_INTERFACE
    } ISourcesRowsetVtbl;

    interface ISourcesRowset
    {
        CONST_VTBL struct ISourcesRowsetVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISourcesRowset_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISourcesRowset_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISourcesRowset_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISourcesRowset_GetSourcesRowset(This,pUnkOuter,riid,cPropertySets,rgProperties,ppSourcesRowset)	\
    (This)->lpVtbl -> GetSourcesRowset(This,pUnkOuter,riid,cPropertySets,rgProperties,ppSourcesRowset)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE ISourcesRowset_RemoteGetSourcesRowset_Proxy( 
    ISourcesRowset  * This,
    /* [in] */ IUnknown  *pUnkOuter,
    /* [in] */ REFIID riid,
    /* [in] */ ULONG cPropertySets,
    /* [size_is][unique][in] */ DBPROPSET  *rgProperties,
    /* [iid_is][out] */ IUnknown  * *ppSourcesRowset,
    /* [in] */ ULONG cTotalProps,
    /* [size_is][out] */ DBPROPSTATUS  *rgPropStatus,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB ISourcesRowset_RemoteGetSourcesRowset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISourcesRowset_INTERFACE_DEFINED__ */


#ifndef __IDBProperties_INTERFACE_DEFINED__
#define __IDBProperties_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDBProperties
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IDBProperties;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a8a-2a1c-11ce-ade5-00aa0044773d")
    IDBProperties : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [in] */ ULONG cPropertyIDSets,
            /* [size_is][in] */ const DBPROPIDSET  rgPropertyIDSets[  ],
            /* [out][in] */ ULONG  *pcPropertySets,
            /* [size_is][size_is][out] */ DBPROPSET  * *prgPropertySets) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetPropertyInfo( 
            /* [in] */ ULONG cPropertyIDSets,
            /* [size_is][in] */ const DBPROPIDSET  rgPropertyIDSets[  ],
            /* [out][in] */ ULONG  *pcPropertyInfoSets,
            /* [size_is][size_is][out] */ DBPROPINFOSET  * *prgPropertyInfoSets,
            /* [out] */ OLECHAR  * *ppDescBuffer) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SetProperties( 
            /* [in] */ ULONG cPropertySets,
            /* [size_is][out][in] */ DBPROPSET  rgPropertySets[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDBPropertiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IDBProperties  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IDBProperties  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IDBProperties  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetProperties )( 
            IDBProperties  * This,
            /* [in] */ ULONG cPropertyIDSets,
            /* [size_is][in] */ const DBPROPIDSET  rgPropertyIDSets[  ],
            /* [out][in] */ ULONG  *pcPropertySets,
            /* [size_is][size_is][out] */ DBPROPSET  * *prgPropertySets);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetPropertyInfo )( 
            IDBProperties  * This,
            /* [in] */ ULONG cPropertyIDSets,
            /* [size_is][in] */ const DBPROPIDSET  rgPropertyIDSets[  ],
            /* [out][in] */ ULONG  *pcPropertyInfoSets,
            /* [size_is][size_is][out] */ DBPROPINFOSET  * *prgPropertyInfoSets,
            /* [out] */ OLECHAR  * *ppDescBuffer);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *SetProperties )( 
            IDBProperties  * This,
            /* [in] */ ULONG cPropertySets,
            /* [size_is][out][in] */ DBPROPSET  rgPropertySets[  ]);
        
        END_INTERFACE
    } IDBPropertiesVtbl;

    interface IDBProperties
    {
        CONST_VTBL struct IDBPropertiesVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDBProperties_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDBProperties_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDBProperties_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDBProperties_GetProperties(This,cPropertyIDSets,rgPropertyIDSets,pcPropertySets,prgPropertySets)	\
    (This)->lpVtbl -> GetProperties(This,cPropertyIDSets,rgPropertyIDSets,pcPropertySets,prgPropertySets)

#define IDBProperties_GetPropertyInfo(This,cPropertyIDSets,rgPropertyIDSets,pcPropertyInfoSets,prgPropertyInfoSets,ppDescBuffer)	\
    (This)->lpVtbl -> GetPropertyInfo(This,cPropertyIDSets,rgPropertyIDSets,pcPropertyInfoSets,prgPropertyInfoSets,ppDescBuffer)

#define IDBProperties_SetProperties(This,cPropertySets,rgPropertySets)	\
    (This)->lpVtbl -> SetProperties(This,cPropertySets,rgPropertySets)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IDBProperties_RemoteGetProperties_Proxy( 
    IDBProperties  * This,
    /* [in] */ ULONG cPropertyIDSets,
    /* [size_is][unique][in] */ const DBPROPIDSET  *rgPropertyIDSets,
    /* [out][in] */ ULONG  *pcPropertySets,
    /* [size_is][size_is][out] */ DBPROPSET  * *prgPropertySets,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IDBProperties_RemoteGetProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDBProperties_RemoteGetPropertyInfo_Proxy( 
    IDBProperties  * This,
    /* [in] */ ULONG cPropertyIDSets,
    /* [size_is][unique][in] */ const DBPROPIDSET  *rgPropertyIDSets,
    /* [out][in] */ ULONG  *pcPropertyInfoSets,
    /* [size_is][size_is][out] */ DBPROPINFOSET  * *prgPropertyInfoSets,
    /* [out][in] */ ULONG  *pcOffsets,
    /* [size_is][size_is][out] */ DBBYTEOFFSET **prgDescOffsets,
    /* [out][in] */ ULONG  *pcbDescBuffer,
    /* [size_is][size_is][unique][out][in] */ OLECHAR  * *ppDescBuffer,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IDBProperties_RemoteGetPropertyInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDBProperties_RemoteSetProperties_Proxy( 
    IDBProperties  * This,
    /* [in] */ ULONG cPropertySets,
    /* [size_is][unique][in] */ DBPROPSET  *rgPropertySets,
    /* [in] */ ULONG cTotalProps,
    /* [size_is][out] */ DBPROPSTATUS  *rgPropStatus,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IDBProperties_RemoteSetProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDBProperties_INTERFACE_DEFINED__ */


#ifndef __IDBInitialize_INTERFACE_DEFINED__
#define __IDBInitialize_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDBInitialize
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IDBInitialize;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a8b-2a1c-11ce-ade5-00aa0044773d")
    IDBInitialize : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Initialize( void) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Uninitialize( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDBInitializeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IDBInitialize  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IDBInitialize  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IDBInitialize  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *Initialize )( 
            IDBInitialize  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *Uninitialize )( 
            IDBInitialize  * This);
        
        END_INTERFACE
    } IDBInitializeVtbl;

    interface IDBInitialize
    {
        CONST_VTBL struct IDBInitializeVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDBInitialize_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDBInitialize_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDBInitialize_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDBInitialize_Initialize(This)	\
    (This)->lpVtbl -> Initialize(This)

#define IDBInitialize_Uninitialize(This)	\
    (This)->lpVtbl -> Uninitialize(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IDBInitialize_RemoteInitialize_Proxy( 
    IDBInitialize  * This,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IDBInitialize_RemoteInitialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDBInitialize_RemoteUninitialize_Proxy( 
    IDBInitialize  * This,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IDBInitialize_RemoteUninitialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDBInitialize_INTERFACE_DEFINED__ */


#ifndef __IDBInfo_INTERFACE_DEFINED__
#define __IDBInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDBInfo
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 


typedef DWORD DBLITERAL;


enum DBLITERALENUM
    {	DBLITERAL_INVALID	= 0,
	DBLITERAL_BINARY_LITERAL	= 1,
	DBLITERAL_CATALOG_NAME	= 2,
	DBLITERAL_CATALOG_SEPARATOR	= 3,
	DBLITERAL_CHAR_LITERAL	= 4,
	DBLITERAL_COLUMN_ALIAS	= 5,
	DBLITERAL_COLUMN_NAME	= 6,
	DBLITERAL_CORRELATION_NAME	= 7,
	DBLITERAL_CURSOR_NAME	= 8,
	DBLITERAL_ESCAPE_PERCENT	= 9,
	DBLITERAL_ESCAPE_UNDERSCORE	= 10,
	DBLITERAL_INDEX_NAME	= 11,
	DBLITERAL_LIKE_PERCENT	= 12,
	DBLITERAL_LIKE_UNDERSCORE	= 13,
	DBLITERAL_PROCEDURE_NAME	= 14,
	DBLITERAL_QUOTE	= 15,
	DBLITERAL_SCHEMA_NAME	= 16,
	DBLITERAL_TABLE_NAME	= 17,
	DBLITERAL_TEXT_COMMAND	= 18,
	DBLITERAL_USER_NAME	= 19,
	DBLITERAL_VIEW_NAME	= 20
    };

#define DBLITERAL_QUOTE_PREFIX DBLITERAL_QUOTE

enum DBLITERALENUM20
    {	DBLITERAL_CUBE_NAME	= 21,
	DBLITERAL_DIMENSION_NAME	= 22,
	DBLITERAL_HIERARCHY_NAME	= 23,
	DBLITERAL_LEVEL_NAME	= 24,
	DBLITERAL_MEMBER_NAME	= 25,
	DBLITERAL_PROPERTY_NAME	= 26,
	DBLITERAL_SCHEMA_SEPARATOR	= 27,
	DBLITERAL_QUOTE_SUFFIX	= 28
    };

#define DBLITERAL_ESCAPE_PERCENT_PREFIX DBLITERAL_ESCAPE_PERCENT
#define DBLITERAL_ESCAPE_UNDERSCORE_PREFIX DBLITERAL_ESCAPE_UNDERSCORE

enum DBLITERALENUM21
    {	DBLITERAL_ESCAPE_PERCENT_SUFFIX	= 29,
	DBLITERAL_ESCAPE_UNDERSCORE_SUFFIX	= 30
    };

typedef struct  tagDBLITERALINFO
    {
    LPOLESTR pwszLiteralValue;
    LPOLESTR pwszInvalidChars;
    LPOLESTR pwszInvalidStartingChars;
    DBLITERAL lt;
    BOOL fSupported;
    ULONG cchMaxLen;
    }	DBLITERALINFO;


EXTERN_C const IID IID_IDBInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a89-2a1c-11ce-ade5-00aa0044773d")
    IDBInfo : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetKeywords( 
            /* [out] */ LPOLESTR  *ppwszKeywords) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetLiteralInfo( 
            /* [in] */ ULONG cLiterals,
            /* [size_is][in] */ const DBLITERAL  rgLiterals[  ],
            /* [out][in] */ ULONG  *pcLiteralInfo,
            /* [size_is][size_is][out] */ DBLITERALINFO  * *prgLiteralInfo,
            /* [out] */ OLECHAR  * *ppCharBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDBInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IDBInfo  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IDBInfo  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IDBInfo  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetKeywords )( 
            IDBInfo  * This,
            /* [out] */ LPOLESTR  *ppwszKeywords);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetLiteralInfo )( 
            IDBInfo  * This,
            /* [in] */ ULONG cLiterals,
            /* [size_is][in] */ const DBLITERAL  rgLiterals[  ],
            /* [out][in] */ ULONG  *pcLiteralInfo,
            /* [size_is][size_is][out] */ DBLITERALINFO  * *prgLiteralInfo,
            /* [out] */ OLECHAR  * *ppCharBuffer);
        
        END_INTERFACE
    } IDBInfoVtbl;

    interface IDBInfo
    {
        CONST_VTBL struct IDBInfoVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDBInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDBInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDBInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDBInfo_GetKeywords(This,ppwszKeywords)	\
    (This)->lpVtbl -> GetKeywords(This,ppwszKeywords)

#define IDBInfo_GetLiteralInfo(This,cLiterals,rgLiterals,pcLiteralInfo,prgLiteralInfo,ppCharBuffer)	\
    (This)->lpVtbl -> GetLiteralInfo(This,cLiterals,rgLiterals,pcLiteralInfo,prgLiteralInfo,ppCharBuffer)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IDBInfo_RemoteGetKeywords_Proxy( 
    IDBInfo  * This,
    /* [unique][out][in] */ LPOLESTR  *ppwszKeywords,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IDBInfo_RemoteGetKeywords_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDBInfo_RemoteGetLiteralInfo_Proxy( 
    IDBInfo  * This,
    /* [in] */ ULONG cLiterals,
    /* [size_is][unique][in] */ const DBLITERAL  *rgLiterals,
    /* [out][in] */ ULONG  *pcLiteralInfo,
    /* [size_is][size_is][out] */ DBLITERALINFO  * *prgLiteralInfo,
    /* [size_is][size_is][out] */ DB_UPARAMS **prgLVOffsets,
    /* [size_is][size_is][out] */ DB_UPARAMS **prgICOffsets,
    /* [size_is][size_is][out] */ DB_UPARAMS **prgISCOffsets,
    /* [out][in] */ ULONG  *pcbCharBuffer,
    /* [size_is][size_is][unique][out][in] */ OLECHAR  * *ppCharBuffer,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IDBInfo_RemoteGetLiteralInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDBInfo_INTERFACE_DEFINED__ */


#ifndef __IDBDataSourceAdmin_INTERFACE_DEFINED__
#define __IDBDataSourceAdmin_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDBDataSourceAdmin
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IDBDataSourceAdmin;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a7a-2a1c-11ce-ade5-00aa0044773d")
    IDBDataSourceAdmin : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CreateDataSource( 
            /* [in] */ ULONG cPropertySets,
            /* [size_is][out][in] */ DBPROPSET  rgPropertySets[  ],
            /* [in] */ IUnknown  *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown  * *ppDBSession) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE DestroyDataSource( void) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetCreationProperties( 
            /* [in] */ ULONG cPropertyIDSets,
            /* [size_is][in] */ const DBPROPIDSET  rgPropertyIDSets[  ],
            /* [out][in] */ ULONG  *pcPropertyInfoSets,
            /* [size_is][size_is][out] */ DBPROPINFOSET  * *prgPropertyInfoSets,
            /* [out] */ OLECHAR  * *ppDescBuffer) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE ModifyDataSource( 
            /* [in] */ ULONG cPropertySets,
            /* [size_is][in] */ DBPROPSET  rgPropertySets[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDBDataSourceAdminVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IDBDataSourceAdmin  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IDBDataSourceAdmin  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IDBDataSourceAdmin  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *CreateDataSource )( 
            IDBDataSourceAdmin  * This,
            /* [in] */ ULONG cPropertySets,
            /* [size_is][out][in] */ DBPROPSET  rgPropertySets[  ],
            /* [in] */ IUnknown  *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown  * *ppDBSession);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *DestroyDataSource )( 
            IDBDataSourceAdmin  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetCreationProperties )( 
            IDBDataSourceAdmin  * This,
            /* [in] */ ULONG cPropertyIDSets,
            /* [size_is][in] */ const DBPROPIDSET  rgPropertyIDSets[  ],
            /* [out][in] */ ULONG  *pcPropertyInfoSets,
            /* [size_is][size_is][out] */ DBPROPINFOSET  * *prgPropertyInfoSets,
            /* [out] */ OLECHAR  * *ppDescBuffer);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *ModifyDataSource )( 
            IDBDataSourceAdmin  * This,
            /* [in] */ ULONG cPropertySets,
            /* [size_is][in] */ DBPROPSET  rgPropertySets[  ]);
        
        END_INTERFACE
    } IDBDataSourceAdminVtbl;

    interface IDBDataSourceAdmin
    {
        CONST_VTBL struct IDBDataSourceAdminVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDBDataSourceAdmin_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDBDataSourceAdmin_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDBDataSourceAdmin_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDBDataSourceAdmin_CreateDataSource(This,cPropertySets,rgPropertySets,pUnkOuter,riid,ppDBSession)	\
    (This)->lpVtbl -> CreateDataSource(This,cPropertySets,rgPropertySets,pUnkOuter,riid,ppDBSession)

#define IDBDataSourceAdmin_DestroyDataSource(This)	\
    (This)->lpVtbl -> DestroyDataSource(This)

#define IDBDataSourceAdmin_GetCreationProperties(This,cPropertyIDSets,rgPropertyIDSets,pcPropertyInfoSets,prgPropertyInfoSets,ppDescBuffer)	\
    (This)->lpVtbl -> GetCreationProperties(This,cPropertyIDSets,rgPropertyIDSets,pcPropertyInfoSets,prgPropertyInfoSets,ppDescBuffer)

#define IDBDataSourceAdmin_ModifyDataSource(This,cPropertySets,rgPropertySets)	\
    (This)->lpVtbl -> ModifyDataSource(This,cPropertySets,rgPropertySets)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IDBDataSourceAdmin_RemoteCreateDataSource_Proxy( 
    IDBDataSourceAdmin  * This,
    /* [in] */ ULONG cPropertySets,
    /* [size_is][unique][in] */ DBPROPSET  *rgPropertySets,
    /* [in] */ IUnknown  *pUnkOuter,
    /* [in] */ REFIID riid,
    /* [iid_is][unique][out][in] */ IUnknown  * *ppDBSession,
    /* [in] */ ULONG cTotalProps,
    /* [size_is][out] */ DBPROPSTATUS  *rgPropStatus,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IDBDataSourceAdmin_RemoteCreateDataSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDBDataSourceAdmin_RemoteDestroyDataSource_Proxy( 
    IDBDataSourceAdmin  * This,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IDBDataSourceAdmin_RemoteDestroyDataSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDBDataSourceAdmin_RemoteGetCreationProperties_Proxy( 
    IDBDataSourceAdmin  * This,
    /* [in] */ ULONG cPropertyIDSets,
    /* [size_is][unique][in] */ const DBPROPIDSET  *rgPropertyIDSets,
    /* [out][in] */ ULONG  *pcPropertyInfoSets,
    /* [size_is][size_is][out] */ DBPROPINFOSET  * *prgPropertyInfoSets,
    /* [out][in] */ DBCOUNTITEM *pcOffsets,
    /* [size_is][size_is][out] */ DBBYTEOFFSET **prgDescOffsets,
    /* [out][in] */ ULONG  *pcbDescBuffer,
    /* [size_is][size_is][unique][out][in] */ OLECHAR  * *ppDescBuffer,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IDBDataSourceAdmin_RemoteGetCreationProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDBDataSourceAdmin_RemoteModifyDataSource_Proxy( 
    IDBDataSourceAdmin  * This,
    /* [in] */ ULONG cPropertySets,
    /* [size_is][in] */ DBPROPSET  *rgPropertySets,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IDBDataSourceAdmin_RemoteModifyDataSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDBDataSourceAdmin_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_oledb_0192
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 


extern RPC_IF_HANDLE __MIDL_itf_oledb_0192_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_oledb_0192_v0_0_s_ifspec;

#ifndef __IDBAsynchNotify_INTERFACE_DEFINED__
#define __IDBAsynchNotify_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDBAsynchNotify
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IDBAsynchNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a96-2a1c-11ce-ade5-00aa0044773d")
    IDBAsynchNotify : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE OnLowResource( 
            /* [in] */ DB_DWRESERVE dwReserved) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE OnProgress( 
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ DBASYNCHOP eOperation,
            /* [in] */ DBCOUNTITEM ulProgress,
            /* [in] */ DBCOUNTITEM ulProgressMax,
            /* [in] */ DBASYNCHPHASE eAsynchPhase,
            /* [in] */ LPOLESTR pwszStatusText) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE OnStop( 
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ DBASYNCHOP eOperation,
            /* [in] */ HRESULT hrStatus,
            /* [in] */ LPOLESTR pwszStatusText) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDBAsynchNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IDBAsynchNotify  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IDBAsynchNotify  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IDBAsynchNotify  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *OnLowResource )( 
            IDBAsynchNotify  * This,
            /* [in] */ DB_DWRESERVE dwReserved);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *OnProgress )( 
            IDBAsynchNotify  * This,
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ DBASYNCHOP eOperation,
            /* [in] */ DBCOUNTITEM ulProgress,
            /* [in] */ DBCOUNTITEM ulProgressMax,
            /* [in] */ DBASYNCHPHASE eAsynchPhase,
            /* [in] */ LPOLESTR pwszStatusText);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *OnStop )( 
            IDBAsynchNotify  * This,
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ DBASYNCHOP eOperation,
            /* [in] */ HRESULT hrStatus,
            /* [in] */ LPOLESTR pwszStatusText);
        
        END_INTERFACE
    } IDBAsynchNotifyVtbl;

    interface IDBAsynchNotify
    {
        CONST_VTBL struct IDBAsynchNotifyVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDBAsynchNotify_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDBAsynchNotify_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDBAsynchNotify_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDBAsynchNotify_OnLowResource(This,dwReserved)	\
    (This)->lpVtbl -> OnLowResource(This,dwReserved)

#define IDBAsynchNotify_OnProgress(This,hChapter,eOperation,ulProgress,ulProgressMax,eAsynchPhase,pwszStatusText)	\
    (This)->lpVtbl -> OnProgress(This,hChapter,eOperation,ulProgress,ulProgressMax,eAsynchPhase,pwszStatusText)

#define IDBAsynchNotify_OnStop(This,hChapter,eOperation,hrStatus,pwszStatusText)	\
    (This)->lpVtbl -> OnStop(This,hChapter,eOperation,hrStatus,pwszStatusText)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IDBAsynchNotify_RemoteOnLowResource_Proxy( 
    IDBAsynchNotify  * This,
    /* [in] */ DB_DWRESERVE dwReserved,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IDBAsynchNotify_RemoteOnLowResource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDBAsynchNotify_RemoteOnProgress_Proxy( 
    IDBAsynchNotify  * This,
    /* [in] */ HCHAPTER hChapter,
    /* [in] */ DBASYNCHOP eOperation,
    /* [in] */ DBCOUNTITEM ulProgress,
    /* [in] */ DBCOUNTITEM ulProgressMax,
    /* [in] */ DBASYNCHPHASE eAsynchPhase,
    /* [in] */ LPOLESTR pwszStatusText,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IDBAsynchNotify_RemoteOnProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDBAsynchNotify_RemoteOnStop_Proxy( 
    IDBAsynchNotify  * This,
    /* [in] */ HCHAPTER hChapter,
    /* [in] */ DBASYNCHOP eOperation,
    /* [in] */ HRESULT hrStatus,
    /* [in] */ LPOLESTR pwszStatusText,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IDBAsynchNotify_RemoteOnStop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDBAsynchNotify_INTERFACE_DEFINED__ */


#ifndef __IDBAsynchStatus_INTERFACE_DEFINED__
#define __IDBAsynchStatus_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDBAsynchStatus
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IDBAsynchStatus;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a95-2a1c-11ce-ade5-00aa0044773d")
    IDBAsynchStatus : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Abort( 
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ DBASYNCHOP eOperation) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ DBASYNCHOP eOperation,
            /* [out] */ DBCOUNTITEM *pulProgress,
            /* [out] */ DBCOUNTITEM *pulProgressMax,
            /* [out] */ DBASYNCHPHASE  *peAsynchPhase,
            /* [out] */ LPOLESTR  *ppwszStatusText) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDBAsynchStatusVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IDBAsynchStatus  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IDBAsynchStatus  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IDBAsynchStatus  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *Abort )( 
            IDBAsynchStatus  * This,
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ DBASYNCHOP eOperation);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetStatus )( 
            IDBAsynchStatus  * This,
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ DBASYNCHOP eOperation,
            /* [out] */ DBCOUNTITEM *pulProgress,
            /* [out] */ DBCOUNTITEM *pulProgressMax,
            /* [out] */ DBASYNCHPHASE  *peAsynchPhase,
            /* [out] */ LPOLESTR  *ppwszStatusText);
        
        END_INTERFACE
    } IDBAsynchStatusVtbl;

    interface IDBAsynchStatus
    {
        CONST_VTBL struct IDBAsynchStatusVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDBAsynchStatus_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDBAsynchStatus_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDBAsynchStatus_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDBAsynchStatus_Abort(This,hChapter,eOperation)	\
    (This)->lpVtbl -> Abort(This,hChapter,eOperation)

#define IDBAsynchStatus_GetStatus(This,hChapter,eOperation,pulProgress,pulProgressMax,peAsynchPhase,ppwszStatusText)	\
    (This)->lpVtbl -> GetStatus(This,hChapter,eOperation,pulProgress,pulProgressMax,peAsynchPhase,ppwszStatusText)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IDBAsynchStatus_RemoteAbort_Proxy( 
    IDBAsynchStatus  * This,
    /* [in] */ HCHAPTER hChapter,
    /* [in] */ DBASYNCHOP eOperation,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IDBAsynchStatus_RemoteAbort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDBAsynchStatus_RemoteGetStatus_Proxy( 
    IDBAsynchStatus  * This,
    /* [in] */ HCHAPTER hChapter,
    /* [in] */ DBASYNCHOP eOperation,
    /* [unique][out][in] */ DBCOUNTITEM *pulProgress,
    /* [unique][out][in] */ DBCOUNTITEM *pulProgressMax,
    /* [out] */ DBASYNCHPHASE  *peAsynchPhase,
    /* [out] */ LPOLESTR  *ppwszStatusText,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IDBAsynchStatus_RemoteGetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDBAsynchStatus_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_oledb_0194
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 


extern RPC_IF_HANDLE __MIDL_itf_oledb_0194_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_oledb_0194_v0_0_s_ifspec;

#ifndef __ISessionProperties_INTERFACE_DEFINED__
#define __ISessionProperties_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISessionProperties
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_ISessionProperties;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a85-2a1c-11ce-ade5-00aa0044773d")
    ISessionProperties : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [in] */ ULONG cPropertyIDSets,
            /* [size_is][in] */ const DBPROPIDSET  rgPropertyIDSets[  ],
            /* [out][in] */ ULONG  *pcPropertySets,
            /* [size_is][size_is][out] */ DBPROPSET  * *prgPropertySets) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SetProperties( 
            /* [in] */ ULONG cPropertySets,
            /* [size_is][unique][out][in] */ DBPROPSET  rgPropertySets[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISessionPropertiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            ISessionProperties  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            ISessionProperties  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            ISessionProperties  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetProperties )( 
            ISessionProperties  * This,
            /* [in] */ ULONG cPropertyIDSets,
            /* [size_is][in] */ const DBPROPIDSET  rgPropertyIDSets[  ],
            /* [out][in] */ ULONG  *pcPropertySets,
            /* [size_is][size_is][out] */ DBPROPSET  * *prgPropertySets);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *SetProperties )( 
            ISessionProperties  * This,
            /* [in] */ ULONG cPropertySets,
            /* [size_is][unique][out][in] */ DBPROPSET  rgPropertySets[  ]);
        
        END_INTERFACE
    } ISessionPropertiesVtbl;

    interface ISessionProperties
    {
        CONST_VTBL struct ISessionPropertiesVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISessionProperties_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISessionProperties_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISessionProperties_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISessionProperties_GetProperties(This,cPropertyIDSets,rgPropertyIDSets,pcPropertySets,prgPropertySets)	\
    (This)->lpVtbl -> GetProperties(This,cPropertyIDSets,rgPropertyIDSets,pcPropertySets,prgPropertySets)

#define ISessionProperties_SetProperties(This,cPropertySets,rgPropertySets)	\
    (This)->lpVtbl -> SetProperties(This,cPropertySets,rgPropertySets)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE ISessionProperties_RemoteGetProperties_Proxy( 
    ISessionProperties  * This,
    /* [in] */ ULONG cPropertyIDSets,
    /* [size_is][unique][in] */ const DBPROPIDSET  *rgPropertyIDSets,
    /* [out][in] */ ULONG  *pcPropertySets,
    /* [size_is][size_is][out] */ DBPROPSET  * *prgPropertySets,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB ISessionProperties_RemoteGetProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ISessionProperties_RemoteSetProperties_Proxy( 
    ISessionProperties  * This,
    /* [in] */ ULONG cPropertySets,
    /* [size_is][unique][in] */ DBPROPSET  *rgPropertySets,
    /* [in] */ ULONG cTotalProps,
    /* [size_is][out] */ DBPROPSTATUS  *rgPropStatus,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB ISessionProperties_RemoteSetProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISessionProperties_INTERFACE_DEFINED__ */


#ifndef __IIndexDefinition_INTERFACE_DEFINED__
#define __IIndexDefinition_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IIndexDefinition
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IIndexDefinition;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a68-2a1c-11ce-ade5-00aa0044773d")
    IIndexDefinition : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CreateIndex( 
            /* [in] */ DBID  *pTableID,
            /* [in] */ DBID  *pIndexID,
            /* [in] */ DBORDINAL cIndexColumnDescs,
            /* [size_is][in] */ const DBINDEXCOLUMNDESC  rgIndexColumnDescs[  ],
            /* [in] */ ULONG cPropertySets,
            /* [size_is][out][in] */ DBPROPSET  rgPropertySets[  ],
            /* [out] */ DBID  * *ppIndexID) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE DropIndex( 
            /* [unique][in] */ DBID  *pTableID,
            /* [unique][in] */ DBID  *pIndexID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IIndexDefinitionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IIndexDefinition  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IIndexDefinition  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IIndexDefinition  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *CreateIndex )( 
            IIndexDefinition  * This,
            /* [in] */ DBID  *pTableID,
            /* [in] */ DBID  *pIndexID,
            /* [in] */ DBORDINAL cIndexColumnDescs,
            /* [size_is][in] */ const DBINDEXCOLUMNDESC  rgIndexColumnDescs[  ],
            /* [in] */ ULONG cPropertySets,
            /* [size_is][out][in] */ DBPROPSET  rgPropertySets[  ],
            /* [out] */ DBID  * *ppIndexID);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *DropIndex )( 
            IIndexDefinition  * This,
            /* [unique][in] */ DBID  *pTableID,
            /* [unique][in] */ DBID  *pIndexID);
        
        END_INTERFACE
    } IIndexDefinitionVtbl;

    interface IIndexDefinition
    {
        CONST_VTBL struct IIndexDefinitionVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIndexDefinition_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IIndexDefinition_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IIndexDefinition_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IIndexDefinition_CreateIndex(This,pTableID,pIndexID,cIndexColumnDescs,rgIndexColumnDescs,cPropertySets,rgPropertySets,ppIndexID)	\
    (This)->lpVtbl -> CreateIndex(This,pTableID,pIndexID,cIndexColumnDescs,rgIndexColumnDescs,cPropertySets,rgPropertySets,ppIndexID)

#define IIndexDefinition_DropIndex(This,pTableID,pIndexID)	\
    (This)->lpVtbl -> DropIndex(This,pTableID,pIndexID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IIndexDefinition_RemoteCreateIndex_Proxy( 
    IIndexDefinition  * This,
    /* [in] */ DBID  *pTableID,
    /* [unique][in] */ DBID  *pIndexID,
    /* [in] */ DBORDINAL cIndexColumnDescs,
    /* [size_is][in] */ const DBINDEXCOLUMNDESC  *rgIndexColumnDescs,
    /* [in] */ ULONG cPropertySets,
    /* [size_is][unique][in] */ DBPROPSET  *rgPropertySets,
    /* [unique][out][in] */ DBID  * *ppIndexID,
    /* [in] */ ULONG cTotalProps,
    /* [size_is][out] */ DBPROPSTATUS  *rgPropStatus,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IIndexDefinition_RemoteCreateIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IIndexDefinition_RemoteDropIndex_Proxy( 
    IIndexDefinition  * This,
    /* [unique][in] */ DBID  *pTableID,
    /* [unique][in] */ DBID  *pIndexID,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IIndexDefinition_RemoteDropIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IIndexDefinition_INTERFACE_DEFINED__ */


#ifndef __ITableDefinition_INTERFACE_DEFINED__
#define __ITableDefinition_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITableDefinition
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_ITableDefinition;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a86-2a1c-11ce-ade5-00aa0044773d")
    ITableDefinition : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CreateTable( 
            /* [in] */ IUnknown  *pUnkOuter,
            /* [in] */ DBID  *pTableID,
            /* [in] */ DBORDINAL cColumnDescs,
            /* [size_is][in] */ const DBCOLUMNDESC  rgColumnDescs[  ],
            /* [in] */ REFIID riid,
            /* [in] */ ULONG cPropertySets,
            /* [size_is][out][in] */ DBPROPSET  rgPropertySets[  ],
            /* [out] */ DBID  * *ppTableID,
            /* [iid_is][out] */ IUnknown  * *ppRowset) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE DropTable( 
            /* [unique][in] */ DBID  *pTableID) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE AddColumn( 
            /* [in] */ DBID  *pTableID,
            /* [out][in] */ DBCOLUMNDESC  *pColumnDesc,
            /* [out] */ DBID  * *ppColumnID) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE DropColumn( 
            /* [unique][in] */ DBID  *pTableID,
            /* [unique][in] */ DBID  *pColumnID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITableDefinitionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            ITableDefinition  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            ITableDefinition  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            ITableDefinition  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *CreateTable )( 
            ITableDefinition  * This,
            /* [in] */ IUnknown  *pUnkOuter,
            /* [in] */ DBID  *pTableID,
            /* [in] */ DBORDINAL cColumnDescs,
            /* [size_is][in] */ const DBCOLUMNDESC  rgColumnDescs[  ],
            /* [in] */ REFIID riid,
            /* [in] */ ULONG cPropertySets,
            /* [size_is][out][in] */ DBPROPSET  rgPropertySets[  ],
            /* [out] */ DBID  * *ppTableID,
            /* [iid_is][out] */ IUnknown  * *ppRowset);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *DropTable )( 
            ITableDefinition  * This,
            /* [unique][in] */ DBID  *pTableID);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *AddColumn )( 
            ITableDefinition  * This,
            /* [in] */ DBID  *pTableID,
            /* [out][in] */ DBCOLUMNDESC  *pColumnDesc,
            /* [out] */ DBID  * *ppColumnID);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *DropColumn )( 
            ITableDefinition  * This,
            /* [unique][in] */ DBID  *pTableID,
            /* [unique][in] */ DBID  *pColumnID);
        
        END_INTERFACE
    } ITableDefinitionVtbl;

    interface ITableDefinition
    {
        CONST_VTBL struct ITableDefinitionVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITableDefinition_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITableDefinition_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITableDefinition_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITableDefinition_CreateTable(This,pUnkOuter,pTableID,cColumnDescs,rgColumnDescs,riid,cPropertySets,rgPropertySets,ppTableID,ppRowset)	\
    (This)->lpVtbl -> CreateTable(This,pUnkOuter,pTableID,cColumnDescs,rgColumnDescs,riid,cPropertySets,rgPropertySets,ppTableID,ppRowset)

#define ITableDefinition_DropTable(This,pTableID)	\
    (This)->lpVtbl -> DropTable(This,pTableID)

#define ITableDefinition_AddColumn(This,pTableID,pColumnDesc,ppColumnID)	\
    (This)->lpVtbl -> AddColumn(This,pTableID,pColumnDesc,ppColumnID)

#define ITableDefinition_DropColumn(This,pTableID,pColumnID)	\
    (This)->lpVtbl -> DropColumn(This,pTableID,pColumnID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE ITableDefinition_RemoteCreateTable_Proxy( 
    ITableDefinition  * This,
    /* [in] */ IUnknown  *pUnkOuter,
    /* [unique][in] */ DBID  *pTableID,
    /* [in] */ DBORDINAL cColumnDescs,
    /* [size_is][in] */ const DBCOLUMNDESC  *rgColumnDescs,
    /* [in] */ REFIID riid,
    /* [in] */ ULONG cPropertySets,
    /* [size_is][unique][in] */ DBPROPSET  *rgPropertySets,
    /* [unique][out][in] */ DBID  * *ppTableID,
    /* [iid_is][unique][out][in] */ IUnknown  * *ppRowset,
    /* [in] */ ULONG cTotalProps,
    /* [size_is][out] */ DBPROPSTATUS  *rgPropStatus,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB ITableDefinition_RemoteCreateTable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITableDefinition_RemoteDropTable_Proxy( 
    ITableDefinition  * This,
    /* [unique][in] */ DBID  *pTableID,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB ITableDefinition_RemoteDropTable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITableDefinition_RemoteAddColumn_Proxy( 
    ITableDefinition  * This,
    /* [in] */ DBID  *pTableID,
    /* [in] */ DBCOLUMNDESC  *pColumnDesc,
    /* [unique][out][in] */ DBID  * *ppColumnID,
    /* [in] */ ULONG cTotalProps,
    /* [size_is][out] */ DBPROPSTATUS  *rgPropStatus,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB ITableDefinition_RemoteAddColumn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITableDefinition_RemoteDropColumn_Proxy( 
    ITableDefinition  * This,
    /* [unique][in] */ DBID  *pTableID,
    /* [unique][in] */ DBID  *pColumnID,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB ITableDefinition_RemoteDropColumn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITableDefinition_INTERFACE_DEFINED__ */


#ifndef __IOpenRowset_INTERFACE_DEFINED__
#define __IOpenRowset_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IOpenRowset
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IOpenRowset;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a69-2a1c-11ce-ade5-00aa0044773d")
    IOpenRowset : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE OpenRowset( 
            /* [in] */ IUnknown  *pUnkOuter,
            /* [unique][in] */ DBID  *pTableID,
            /* [unique][in] */ DBID  *pIndexID,
            /* [in] */ REFIID riid,
            /* [in] */ ULONG cPropertySets,
            /* [size_is][out][in] */ DBPROPSET  rgPropertySets[  ],
            /* [iid_is][out] */ IUnknown  * *ppRowset) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOpenRowsetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IOpenRowset  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IOpenRowset  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IOpenRowset  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *OpenRowset )( 
            IOpenRowset  * This,
            /* [in] */ IUnknown  *pUnkOuter,
            /* [unique][in] */ DBID  *pTableID,
            /* [unique][in] */ DBID  *pIndexID,
            /* [in] */ REFIID riid,
            /* [in] */ ULONG cPropertySets,
            /* [size_is][out][in] */ DBPROPSET  rgPropertySets[  ],
            /* [iid_is][out] */ IUnknown  * *ppRowset);
        
        END_INTERFACE
    } IOpenRowsetVtbl;

    interface IOpenRowset
    {
        CONST_VTBL struct IOpenRowsetVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOpenRowset_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOpenRowset_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOpenRowset_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOpenRowset_OpenRowset(This,pUnkOuter,pTableID,pIndexID,riid,cPropertySets,rgPropertySets,ppRowset)	\
    (This)->lpVtbl -> OpenRowset(This,pUnkOuter,pTableID,pIndexID,riid,cPropertySets,rgPropertySets,ppRowset)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IOpenRowset_RemoteOpenRowset_Proxy( 
    IOpenRowset  * This,
    /* [in] */ IUnknown  *pUnkOuter,
    /* [unique][in] */ DBID  *pTableID,
    /* [unique][in] */ DBID  *pIndexID,
    /* [in] */ REFIID riid,
    /* [in] */ ULONG cPropertySets,
    /* [size_is][unique][in] */ DBPROPSET  *rgPropertySets,
    /* [iid_is][unique][out][in] */ IUnknown  * *ppRowset,
    /* [in] */ ULONG cTotalProps,
    /* [size_is][out] */ DBPROPSTATUS  *rgPropStatus,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IOpenRowset_RemoteOpenRowset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IOpenRowset_INTERFACE_DEFINED__ */


#ifndef __IDBSchemaRowset_INTERFACE_DEFINED__
#define __IDBSchemaRowset_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDBSchemaRowset
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 


#define CRESTRICTIONS_DBSCHEMA_ASSERTIONS                      3
#define CRESTRICTIONS_DBSCHEMA_CATALOGS                        1
#define CRESTRICTIONS_DBSCHEMA_CHARACTER_SETS                  3
#define CRESTRICTIONS_DBSCHEMA_COLLATIONS                      3
#define CRESTRICTIONS_DBSCHEMA_COLUMNS                         4
#define CRESTRICTIONS_DBSCHEMA_CHECK_CONSTRAINTS               3
#define CRESTRICTIONS_DBSCHEMA_CONSTRAINT_COLUMN_USAGE         4
#define CRESTRICTIONS_DBSCHEMA_CONSTRAINT_TABLE_USAGE          3
#define CRESTRICTIONS_DBSCHEMA_KEY_COLUMN_USAGE                7
#define CRESTRICTIONS_DBSCHEMA_REFERENTIAL_CONSTRAINTS         3
#define CRESTRICTIONS_DBSCHEMA_TABLE_CONSTRAINTS               7
#define CRESTRICTIONS_DBSCHEMA_COLUMN_DOMAIN_USAGE             4
#define CRESTRICTIONS_DBSCHEMA_INDEXES                         5
#define CRESTRICTIONS_DBSCHEMA_OBJECT_ACTIONS                  1
#define CRESTRICTIONS_DBSCHEMA_OBJECTS                         1
#define CRESTRICTIONS_DBSCHEMA_COLUMN_PRIVILEGES               6
#define CRESTRICTIONS_DBSCHEMA_TABLE_PRIVILEGES                5
#define CRESTRICTIONS_DBSCHEMA_USAGE_PRIVILEGES                6
#define CRESTRICTIONS_DBSCHEMA_PROCEDURES                      4
#define CRESTRICTIONS_DBSCHEMA_SCHEMATA                        3
#define CRESTRICTIONS_DBSCHEMA_SQL_LANGUAGES                   0
#define CRESTRICTIONS_DBSCHEMA_STATISTICS                      3
#define CRESTRICTIONS_DBSCHEMA_TABLES                          4
#define CRESTRICTIONS_DBSCHEMA_TRANSLATIONS                    3
#define CRESTRICTIONS_DBSCHEMA_PROVIDER_TYPES                  2
#define CRESTRICTIONS_DBSCHEMA_VIEWS                           3
#define CRESTRICTIONS_DBSCHEMA_VIEW_COLUMN_USAGE               3
#define CRESTRICTIONS_DBSCHEMA_VIEW_TABLE_USAGE                3
#define CRESTRICTIONS_DBSCHEMA_PROCEDURE_PARAMETERS            4
#define CRESTRICTIONS_DBSCHEMA_FOREIGN_KEYS                    6
#define CRESTRICTIONS_DBSCHEMA_PRIMARY_KEYS                    3
#define CRESTRICTIONS_DBSCHEMA_PROCEDURE_COLUMNS               4

#define CRESTRICTIONS_DBSCHEMA_TABLES_INFO                     4
#define CRESTRICTIONS_MDSCHEMA_CUBES                           3
#define CRESTRICTIONS_MDSCHEMA_DIMENSIONS                      5
#define CRESTRICTIONS_MDSCHEMA_HIERARCHIES                     6
#define CRESTRICTIONS_MDSCHEMA_LEVELS                          7
#define CRESTRICTIONS_MDSCHEMA_MEASURES                        5
#define CRESTRICTIONS_MDSCHEMA_PROPERTIES                      9
#define CRESTRICTIONS_MDSCHEMA_MEMBERS                         12

#define CRESTRICTIONS_DBSCHEMA_TRUSTEE		                     4

EXTERN_C const IID IID_IDBSchemaRowset;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a7b-2a1c-11ce-ade5-00aa0044773d")
    IDBSchemaRowset : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetRowset( 
            /* [in] */ IUnknown  *pUnkOuter,
            /* [in] */ REFGUID rguidSchema,
            /* [in] */ ULONG cRestrictions,
            /* [size_is][in] */ const VARIANT  rgRestrictions[  ],
            /* [in] */ REFIID riid,
            /* [in] */ ULONG cPropertySets,
            /* [size_is][unique][out][in] */ DBPROPSET  rgPropertySets[  ],
            /* [iid_is][out] */ IUnknown  * *ppRowset) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetSchemas( 
            /* [out][in] */ ULONG  *pcSchemas,
            /* [size_is][size_is][out] */ GUID  * *prgSchemas,
            /* [size_is][size_is][out] */ ULONG  * *prgRestrictionSupport) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDBSchemaRowsetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IDBSchemaRowset  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IDBSchemaRowset  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IDBSchemaRowset  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetRowset )( 
            IDBSchemaRowset  * This,
            /* [in] */ IUnknown  *pUnkOuter,
            /* [in] */ REFGUID rguidSchema,
            /* [in] */ ULONG cRestrictions,
            /* [size_is][in] */ const VARIANT  rgRestrictions[  ],
            /* [in] */ REFIID riid,
            /* [in] */ ULONG cPropertySets,
            /* [size_is][unique][out][in] */ DBPROPSET  rgPropertySets[  ],
            /* [iid_is][out] */ IUnknown  * *ppRowset);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetSchemas )( 
            IDBSchemaRowset  * This,
            /* [out][in] */ ULONG  *pcSchemas,
            /* [size_is][size_is][out] */ GUID  * *prgSchemas,
            /* [size_is][size_is][out] */ ULONG  * *prgRestrictionSupport);
        
        END_INTERFACE
    } IDBSchemaRowsetVtbl;

    interface IDBSchemaRowset
    {
        CONST_VTBL struct IDBSchemaRowsetVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDBSchemaRowset_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDBSchemaRowset_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDBSchemaRowset_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDBSchemaRowset_GetRowset(This,pUnkOuter,rguidSchema,cRestrictions,rgRestrictions,riid,cPropertySets,rgPropertySets,ppRowset)	\
    (This)->lpVtbl -> GetRowset(This,pUnkOuter,rguidSchema,cRestrictions,rgRestrictions,riid,cPropertySets,rgPropertySets,ppRowset)

#define IDBSchemaRowset_GetSchemas(This,pcSchemas,prgSchemas,prgRestrictionSupport)	\
    (This)->lpVtbl -> GetSchemas(This,pcSchemas,prgSchemas,prgRestrictionSupport)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IDBSchemaRowset_RemoteGetRowset_Proxy( 
    IDBSchemaRowset  * This,
    /* [in] */ IUnknown  *pUnkOuter,
    /* [in] */ REFGUID rguidSchema,
    /* [in] */ ULONG cRestrictions,
    /* [size_is][unique][in] */ const VARIANT  *rgRestrictions,
    /* [in] */ REFIID riid,
    /* [in] */ ULONG cPropertySets,
    /* [size_is][unique][in] */ DBPROPSET  *rgPropertySets,
    /* [iid_is][out] */ IUnknown  * *ppRowset,
    /* [in] */ ULONG cTotalProps,
    /* [size_is][out] */ DBPROPSTATUS  *rgPropStatus,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IDBSchemaRowset_RemoteGetRowset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDBSchemaRowset_RemoteGetSchemas_Proxy( 
    IDBSchemaRowset  * This,
    /* [out][in] */ ULONG  *pcSchemas,
    /* [size_is][size_is][out] */ GUID  * *prgSchemas,
    /* [size_is][size_is][out] */ ULONG  * *prgRestrictionSupport,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IDBSchemaRowset_RemoteGetSchemas_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDBSchemaRowset_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_oledb_0199
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 


extern RPC_IF_HANDLE __MIDL_itf_oledb_0199_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_oledb_0199_v0_0_s_ifspec;

#ifndef __IMDDataset_INTERFACE_DEFINED__
#define __IMDDataset_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMDDataset
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object][local] */ 



EXTERN_C const IID IID_IMDDataset;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("a07cccd1-8148-11d0-87bb-00c04fc33942")
    IMDDataset : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FreeAxisInfo( 
            /* [in] */ DBCOUNTITEM cAxes,
            /* [size_is][in] */ MDAXISINFO  *rgAxisInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAxisInfo( 
            /* [out][in] */ DBCOUNTITEM *pcAxes,
            /* [size_is][size_is][out] */ MDAXISINFO  * *prgAxisInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAxisRowset( 
            /* [in] */ IUnknown  *pUnkOuter,
            /* [in] */ DBCOUNTITEM iAxis,
            /* [in] */ REFIID riid,
            /* [in] */ ULONG cPropertySets,
            /* [size_is][out][in] */ DBPROPSET  rgPropertySets[  ],
            /* [iid_is][out] */ IUnknown  * *ppRowset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCellData( 
            /* [in] */ HACCESSOR hAccessor,
            /* [in] */ DBORDINAL ulStartCell,
            /* [in] */ DBORDINAL ulEndCell,
            /* [out] */ void  *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSpecification( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown  * *ppSpecification) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMDDatasetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IMDDataset  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IMDDataset  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IMDDataset  * This);
        
        HRESULT ( STDMETHODCALLTYPE  *FreeAxisInfo )( 
            IMDDataset  * This,
            /* [in] */ DBCOUNTITEM cAxes,
            /* [size_is][in] */ MDAXISINFO  *rgAxisInfo);
        
        HRESULT ( STDMETHODCALLTYPE  *GetAxisInfo )( 
            IMDDataset  * This,
            /* [out][in] */ DBCOUNTITEM *pcAxes,
            /* [size_is][size_is][out] */ MDAXISINFO  * *prgAxisInfo);
        
        HRESULT ( STDMETHODCALLTYPE  *GetAxisRowset )( 
            IMDDataset  * This,
            /* [in] */ IUnknown  *pUnkOuter,
            /* [in] */ DBCOUNTITEM iAxis,
            /* [in] */ REFIID riid,
            /* [in] */ ULONG cPropertySets,
            /* [size_is][out][in] */ DBPROPSET  rgPropertySets[  ],
            /* [iid_is][out] */ IUnknown  * *ppRowset);
        
        HRESULT ( STDMETHODCALLTYPE  *GetCellData )( 
            IMDDataset  * This,
            /* [in] */ HACCESSOR hAccessor,
            /* [in] */ DBORDINAL ulStartCell,
            /* [in] */ DBORDINAL ulEndCell,
            /* [out] */ void  *pData);
        
        HRESULT ( STDMETHODCALLTYPE  *GetSpecification )( 
            IMDDataset  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown  * *ppSpecification);
        
        END_INTERFACE
    } IMDDatasetVtbl;

    interface IMDDataset
    {
        CONST_VTBL struct IMDDatasetVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMDDataset_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMDDataset_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMDDataset_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMDDataset_FreeAxisInfo(This,cAxes,rgAxisInfo)	\
    (This)->lpVtbl -> FreeAxisInfo(This,cAxes,rgAxisInfo)

#define IMDDataset_GetAxisInfo(This,pcAxes,prgAxisInfo)	\
    (This)->lpVtbl -> GetAxisInfo(This,pcAxes,prgAxisInfo)

#define IMDDataset_GetAxisRowset(This,pUnkOuter,iAxis,riid,cPropertySets,rgPropertySets,ppRowset)	\
    (This)->lpVtbl -> GetAxisRowset(This,pUnkOuter,iAxis,riid,cPropertySets,rgPropertySets,ppRowset)

#define IMDDataset_GetCellData(This,hAccessor,ulStartCell,ulEndCell,pData)	\
    (This)->lpVtbl -> GetCellData(This,hAccessor,ulStartCell,ulEndCell,pData)

#define IMDDataset_GetSpecification(This,riid,ppSpecification)	\
    (This)->lpVtbl -> GetSpecification(This,riid,ppSpecification)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMDDataset_FreeAxisInfo_Proxy( 
    IMDDataset  * This,
    /* [in] */ DBCOUNTITEM cAxes,
    /* [size_is][in] */ MDAXISINFO  *rgAxisInfo);


void __RPC_STUB IMDDataset_FreeAxisInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDDataset_GetAxisInfo_Proxy( 
    IMDDataset  * This,
    /* [out][in] */ DBCOUNTITEM *pcAxes,
    /* [size_is][size_is][out] */ MDAXISINFO  * *prgAxisInfo);


void __RPC_STUB IMDDataset_GetAxisInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDDataset_GetAxisRowset_Proxy( 
    IMDDataset  * This,
    /* [in] */ IUnknown  *pUnkOuter,
    /* [in] */ DBCOUNTITEM iAxis,
    /* [in] */ REFIID riid,
    /* [in] */ ULONG cPropertySets,
    /* [size_is][out][in] */ DBPROPSET  rgPropertySets[  ],
    /* [iid_is][out] */ IUnknown  * *ppRowset);


void __RPC_STUB IMDDataset_GetAxisRowset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDDataset_GetCellData_Proxy( 
    IMDDataset  * This,
    /* [in] */ HACCESSOR hAccessor,
    /* [in] */ DBORDINAL ulStartCell,
    /* [in] */ DBORDINAL ulEndCell,
    /* [out] */ void  *pData);


void __RPC_STUB IMDDataset_GetCellData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDDataset_GetSpecification_Proxy( 
    IMDDataset  * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown  * *ppSpecification);


void __RPC_STUB IMDDataset_GetSpecification_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMDDataset_INTERFACE_DEFINED__ */


#ifndef __IMDFind_INTERFACE_DEFINED__
#define __IMDFind_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMDFind
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object][local] */ 



EXTERN_C const IID IID_IMDFind;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("a07cccd2-8148-11d0-87bb-00c04fc33942")
    IMDFind : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FindCell( 
            /* [in] */ DBORDINAL ulStartingOrdinal,
            /* [in] */ DBCOUNTITEM cMembers,
            /* [size_is][in] */ LPCOLESTR  *rgpwszMember,
            /* [out] */ DBORDINAL *pulCellOrdinal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindTuple( 
            /* [in] */ ULONG ulAxisIdentifier,
            /* [in] */ DBORDINAL ulStartingOrdinal,
            /* [in] */ DBCOUNTITEM cMembers,
            /* [size_is][in] */ LPCOLESTR  *rgpwszMember,
            /* [out] */ ULONG  *pulTupleOrdinal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMDFindVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IMDFind  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IMDFind  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IMDFind  * This);
        
        HRESULT ( STDMETHODCALLTYPE  *FindCell )( 
            IMDFind  * This,
            /* [in] */ DBORDINAL ulStartingOrdinal,
            /* [in] */ DBCOUNTITEM cMembers,
            /* [size_is][in] */ LPCOLESTR  *rgpwszMember,
            /* [out] */ DBORDINAL *pulCellOrdinal);
        
        HRESULT ( STDMETHODCALLTYPE  *FindTuple )( 
            IMDFind  * This,
            /* [in] */ ULONG ulAxisIdentifier,
            /* [in] */ DBORDINAL ulStartingOrdinal,
            /* [in] */ DBCOUNTITEM cMembers,
            /* [size_is][in] */ LPCOLESTR  *rgpwszMember,
            /* [out] */ ULONG  *pulTupleOrdinal);
        
        END_INTERFACE
    } IMDFindVtbl;

    interface IMDFind
    {
        CONST_VTBL struct IMDFindVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMDFind_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMDFind_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMDFind_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMDFind_FindCell(This,ulStartingOrdinal,cMembers,rgpwszMember,pulCellOrdinal)	\
    (This)->lpVtbl -> FindCell(This,ulStartingOrdinal,cMembers,rgpwszMember,pulCellOrdinal)

#define IMDFind_FindTuple(This,ulAxisIdentifier,ulStartingOrdinal,cMembers,rgpwszMember,pulTupleOrdinal)	\
    (This)->lpVtbl -> FindTuple(This,ulAxisIdentifier,ulStartingOrdinal,cMembers,rgpwszMember,pulTupleOrdinal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMDFind_FindCell_Proxy( 
    IMDFind  * This,
    /* [in] */ DBORDINAL ulStartingOrdinal,
    /* [in] */ DBCOUNTITEM cMembers,
    /* [size_is][in] */ LPCOLESTR  *rgpwszMember,
    /* [out] */ DBORDINAL *pulCellOrdinal);


void __RPC_STUB IMDFind_FindCell_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDFind_FindTuple_Proxy( 
    IMDFind  * This,
    /* [in] */ ULONG ulAxisIdentifier,
    /* [in] */ DBORDINAL ulStartingOrdinal,
    /* [in] */ DBCOUNTITEM cMembers,
    /* [size_is][in] */ LPCOLESTR  *rgpwszMember,
    /* [out] */ ULONG  *pulTupleOrdinal);


void __RPC_STUB IMDFind_FindTuple_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMDFind_INTERFACE_DEFINED__ */


#ifndef __IMDRangeRowset_INTERFACE_DEFINED__
#define __IMDRangeRowset_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMDRangeRowset
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object][local] */ 



EXTERN_C const IID IID_IMDRangeRowset;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733aa0-2a1c-11ce-ade5-00aa0044773d")
    IMDRangeRowset : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRangeRowset( 
            /* [in] */ IUnknown  *pUnkOuter,
            /* [in] */ DBORDINAL ulStartCell,
            /* [in] */ DBORDINAL ulEndCell,
            /* [in] */ REFIID riid,
            /* [in] */ ULONG cPropertySets,
            /* [size_is][out][in] */ DBPROPSET  rgPropertySets[  ],
            /* [iid_is][out] */ IUnknown  * *ppRowset) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMDRangeRowsetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IMDRangeRowset  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IMDRangeRowset  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IMDRangeRowset  * This);
        
        HRESULT ( STDMETHODCALLTYPE  *GetRangeRowset )( 
            IMDRangeRowset  * This,
            /* [in] */ IUnknown  *pUnkOuter,
            /* [in] */ DBORDINAL ulStartCell,
            /* [in] */ DBORDINAL ulEndCell,
            /* [in] */ REFIID riid,
            /* [in] */ ULONG cPropertySets,
            /* [size_is][out][in] */ DBPROPSET  rgPropertySets[  ],
            /* [iid_is][out] */ IUnknown  * *ppRowset);
        
        END_INTERFACE
    } IMDRangeRowsetVtbl;

    interface IMDRangeRowset
    {
        CONST_VTBL struct IMDRangeRowsetVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMDRangeRowset_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMDRangeRowset_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMDRangeRowset_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMDRangeRowset_GetRangeRowset(This,pUnkOuter,ulStartCell,ulEndCell,riid,cPropertySets,rgPropertySets,ppRowset)	\
    (This)->lpVtbl -> GetRangeRowset(This,pUnkOuter,ulStartCell,ulEndCell,riid,cPropertySets,rgPropertySets,ppRowset)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMDRangeRowset_GetRangeRowset_Proxy( 
    IMDRangeRowset  * This,
    /* [in] */ IUnknown  *pUnkOuter,
    /* [in] */ DBORDINAL ulStartCell,
    /* [in] */ DBORDINAL ulEndCell,
    /* [in] */ REFIID riid,
    /* [in] */ ULONG cPropertySets,
    /* [size_is][out][in] */ DBPROPSET  rgPropertySets[  ],
    /* [iid_is][out] */ IUnknown  * *ppRowset);


void __RPC_STUB IMDRangeRowset_GetRangeRowset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMDRangeRowset_INTERFACE_DEFINED__ */


#ifndef __IAlterTable_INTERFACE_DEFINED__
#define __IAlterTable_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAlterTable
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object][local] */ 



EXTERN_C const IID IID_IAlterTable;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733aa5-2a1c-11ce-ade5-00aa0044773d")
    IAlterTable : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AlterColumn( 
            /* [in] */ DBID  *pTableId,
            /* [in] */ DBID  *pColumnId,
            /* [in] */ DBCOLUMNDESCFLAGS dwColumnDescFlags,
            /* [in] */ DBCOLUMNDESC  *pColumnDesc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AlterTable( 
            /* [in] */ DBID  *pTableId,
            /* [in] */ DBID  *pNewTableId,
            /* [in] */ ULONG cPropertySets,
            /* [size_is][out][in] */ DBPROPSET  rgPropertySets[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAlterTableVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IAlterTable  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IAlterTable  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IAlterTable  * This);
        
        HRESULT ( STDMETHODCALLTYPE  *AlterColumn )( 
            IAlterTable  * This,
            /* [in] */ DBID  *pTableId,
            /* [in] */ DBID  *pColumnId,
            /* [in] */ DBCOLUMNDESCFLAGS dwColumnDescFlags,
            /* [in] */ DBCOLUMNDESC  *pColumnDesc);
        
        HRESULT ( STDMETHODCALLTYPE  *AlterTable )( 
            IAlterTable  * This,
            /* [in] */ DBID  *pTableId,
            /* [in] */ DBID  *pNewTableId,
            /* [in] */ ULONG cPropertySets,
            /* [size_is][out][in] */ DBPROPSET  rgPropertySets[  ]);
        
        END_INTERFACE
    } IAlterTableVtbl;

    interface IAlterTable
    {
        CONST_VTBL struct IAlterTableVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAlterTable_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAlterTable_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAlterTable_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAlterTable_AlterColumn(This,pTableId,pColumnId,dwColumnDescFlags,pColumnDesc)	\
    (This)->lpVtbl -> AlterColumn(This,pTableId,pColumnId,dwColumnDescFlags,pColumnDesc)

#define IAlterTable_AlterTable(This,pTableId,pNewTableId,cPropertySets,rgPropertySets)	\
    (This)->lpVtbl -> AlterTable(This,pTableId,pNewTableId,cPropertySets,rgPropertySets)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAlterTable_AlterColumn_Proxy( 
    IAlterTable  * This,
    /* [in] */ DBID  *pTableId,
    /* [in] */ DBID  *pColumnId,
    /* [in] */ DBCOLUMNDESCFLAGS dwColumnDescFlags,
    /* [in] */ DBCOLUMNDESC  *pColumnDesc);


void __RPC_STUB IAlterTable_AlterColumn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAlterTable_AlterTable_Proxy( 
    IAlterTable  * This,
    /* [in] */ DBID  *pTableId,
    /* [in] */ DBID  *pNewTableId,
    /* [in] */ ULONG cPropertySets,
    /* [size_is][out][in] */ DBPROPSET  rgPropertySets[  ]);


void __RPC_STUB IAlterTable_AlterTable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAlterTable_INTERFACE_DEFINED__ */


#ifndef __IAlterIndex_INTERFACE_DEFINED__
#define __IAlterIndex_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAlterIndex
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object][local] */ 



EXTERN_C const IID IID_IAlterIndex;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733aa6-2a1c-11ce-ade5-00aa0044773d")
    IAlterIndex : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AlterIndex( 
            /* [in] */ DBID  *pTableId,
            /* [in] */ DBID  *pIndexId,
            /* [in] */ DBID  *pNewIndexId,
            /* [in] */ ULONG cPropertySets,
            /* [size_is][out][in] */ DBPROPSET rgPropertySets[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAlterIndexVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IAlterIndex  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IAlterIndex  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IAlterIndex  * This);
        
        HRESULT ( STDMETHODCALLTYPE  *AlterIndex )( 
            IAlterIndex  * This,
            /* [in] */ DBID  *pTableId,
            /* [in] */ DBID  *pIndexId,
            /* [in] */ DBID  *pNewIndexId,
            /* [in] */ ULONG cPropertySets,
            /* [size_is][out][in] */ DBPROPSET rgPropertySets[  ]);
        
        END_INTERFACE
    } IAlterIndexVtbl;

    interface IAlterIndex
    {
        CONST_VTBL struct IAlterIndexVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAlterIndex_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAlterIndex_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAlterIndex_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAlterIndex_AlterIndex(This,pTableId,pIndexId,pNewIndexId,cPropertySets,rgPropertySets)	\
    (This)->lpVtbl -> AlterIndex(This,pTableId,pIndexId,pNewIndexId,cPropertySets,rgPropertySets)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAlterIndex_AlterIndex_Proxy( 
    IAlterIndex  * This,
    /* [in] */ DBID  *pTableId,
    /* [in] */ DBID  *pIndexId,
    /* [in] */ DBID  *pNewIndexId,
    /* [in] */ ULONG cPropertySets,
    /* [size_is][out][in] */ DBPROPSET rgPropertySets[  ]);


void __RPC_STUB IAlterIndex_AlterIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAlterIndex_INTERFACE_DEFINED__ */


#ifndef __IRowsetChapterMember_INTERFACE_DEFINED__
#define __IRowsetChapterMember_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRowsetChapterMember
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object][local] */ 



EXTERN_C const IID IID_IRowsetChapterMember;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733aa8-2a1c-11ce-ade5-00aa0044773d")
    IRowsetChapterMember : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsRowInChapter( 
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ HROW hRow) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRowsetChapterMemberVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IRowsetChapterMember  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IRowsetChapterMember  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IRowsetChapterMember  * This);
        
        HRESULT ( STDMETHODCALLTYPE  *IsRowInChapter )( 
            IRowsetChapterMember  * This,
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ HROW hRow);
        
        END_INTERFACE
    } IRowsetChapterMemberVtbl;

    interface IRowsetChapterMember
    {
        CONST_VTBL struct IRowsetChapterMemberVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRowsetChapterMember_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRowsetChapterMember_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRowsetChapterMember_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRowsetChapterMember_IsRowInChapter(This,hChapter,hRow)	\
    (This)->lpVtbl -> IsRowInChapter(This,hChapter,hRow)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRowsetChapterMember_IsRowInChapter_Proxy( 
    IRowsetChapterMember  * This,
    /* [in] */ HCHAPTER hChapter,
    /* [in] */ HROW hRow);


void __RPC_STUB IRowsetChapterMember_IsRowInChapter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRowsetChapterMember_INTERFACE_DEFINED__ */


#ifndef __ICommandPersist_INTERFACE_DEFINED__
#define __ICommandPersist_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICommandPersist
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object][local] */ 



EXTERN_C const IID IID_ICommandPersist;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733aa7-2a1c-11ce-ade5-00aa0044773d")
    ICommandPersist : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DeleteCommand( 
            /* [in] */ DBID  *pCommandID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentCommand( 
            /* [out] */ DBID  * *ppCommandID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadCommand( 
            /* [in] */ DBID  *pCommandID,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveCommand( 
            /* [in] */ DBID  *pCommandID,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICommandPersistVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            ICommandPersist  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            ICommandPersist  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            ICommandPersist  * This);
        
        HRESULT ( STDMETHODCALLTYPE  *DeleteCommand )( 
            ICommandPersist  * This,
            /* [in] */ DBID  *pCommandID);
        
        HRESULT ( STDMETHODCALLTYPE  *GetCurrentCommand )( 
            ICommandPersist  * This,
            /* [out] */ DBID  * *ppCommandID);
        
        HRESULT ( STDMETHODCALLTYPE  *LoadCommand )( 
            ICommandPersist  * This,
            /* [in] */ DBID  *pCommandID,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE  *SaveCommand )( 
            ICommandPersist  * This,
            /* [in] */ DBID  *pCommandID,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } ICommandPersistVtbl;

    interface ICommandPersist
    {
        CONST_VTBL struct ICommandPersistVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICommandPersist_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICommandPersist_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICommandPersist_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICommandPersist_DeleteCommand(This,pCommandID)	\
    (This)->lpVtbl -> DeleteCommand(This,pCommandID)

#define ICommandPersist_GetCurrentCommand(This,ppCommandID)	\
    (This)->lpVtbl -> GetCurrentCommand(This,ppCommandID)

#define ICommandPersist_LoadCommand(This,pCommandID,dwFlags)	\
    (This)->lpVtbl -> LoadCommand(This,pCommandID,dwFlags)

#define ICommandPersist_SaveCommand(This,pCommandID,dwFlags)	\
    (This)->lpVtbl -> SaveCommand(This,pCommandID,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICommandPersist_DeleteCommand_Proxy( 
    ICommandPersist  * This,
    /* [in] */ DBID  *pCommandID);


void __RPC_STUB ICommandPersist_DeleteCommand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICommandPersist_GetCurrentCommand_Proxy( 
    ICommandPersist  * This,
    /* [out] */ DBID  * *ppCommandID);


void __RPC_STUB ICommandPersist_GetCurrentCommand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICommandPersist_LoadCommand_Proxy( 
    ICommandPersist  * This,
    /* [in] */ DBID  *pCommandID,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB ICommandPersist_LoadCommand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICommandPersist_SaveCommand_Proxy( 
    ICommandPersist  * This,
    /* [in] */ DBID  *pCommandID,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB ICommandPersist_SaveCommand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICommandPersist_INTERFACE_DEFINED__ */


#ifndef __IRowsetRefresh_INTERFACE_DEFINED__
#define __IRowsetRefresh_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRowsetRefresh
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object][local] */ 



EXTERN_C const IID IID_IRowsetRefresh;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733aa9-2a1c-11ce-ade5-00aa0044773d")
    IRowsetRefresh : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RefreshVisibleData( 
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ DBCOUNTITEM cRows,
            /* [in] */ const HROW  rghRows[  ],
            /* [in] */ BOOL fOverWrite,
            /* [out] */ DBCOUNTITEM *pcRowsRefreshed,
            /* [out] */ HROW  * *prghRowsRefreshed,
            /* [out] */ DBROWSTATUS  * *prgRowStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLastVisibleData( 
            /* [in] */ HROW hRow,
            /* [in] */ HACCESSOR hAccessor,
            /* [out] */ void  *pData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRowsetRefreshVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IRowsetRefresh  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IRowsetRefresh  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IRowsetRefresh  * This);
        
        HRESULT ( STDMETHODCALLTYPE  *RefreshVisibleData )( 
            IRowsetRefresh  * This,
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ DBCOUNTITEM cRows,
            /* [in] */ const HROW  rghRows[  ],
            /* [in] */ BOOL fOverWrite,
            /* [out] */ DBCOUNTITEM *pcRowsRefreshed,
            /* [out] */ HROW  * *prghRowsRefreshed,
            /* [out] */ DBROWSTATUS  * *prgRowStatus);
        
        HRESULT ( STDMETHODCALLTYPE  *GetLastVisibleData )( 
            IRowsetRefresh  * This,
            /* [in] */ HROW hRow,
            /* [in] */ HACCESSOR hAccessor,
            /* [out] */ void  *pData);
        
        END_INTERFACE
    } IRowsetRefreshVtbl;

    interface IRowsetRefresh
    {
        CONST_VTBL struct IRowsetRefreshVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRowsetRefresh_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRowsetRefresh_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRowsetRefresh_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRowsetRefresh_RefreshVisibleData(This,hChapter,cRows,rghRows,fOverWrite,pcRowsRefreshed,prghRowsRefreshed,prgRowStatus)	\
    (This)->lpVtbl -> RefreshVisibleData(This,hChapter,cRows,rghRows,fOverWrite,pcRowsRefreshed,prghRowsRefreshed,prgRowStatus)

#define IRowsetRefresh_GetLastVisibleData(This,hRow,hAccessor,pData)	\
    (This)->lpVtbl -> GetLastVisibleData(This,hRow,hAccessor,pData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRowsetRefresh_RefreshVisibleData_Proxy( 
    IRowsetRefresh  * This,
    /* [in] */ HCHAPTER hChapter,
    /* [in] */ DBCOUNTITEM cRows,
    /* [in] */ const HROW  rghRows[  ],
    /* [in] */ BOOL fOverWrite,
    /* [out] */ DBCOUNTITEM *pcRowsRefreshed,
    /* [out] */ HROW  * *prghRowsRefreshed,
    /* [out] */ DBROWSTATUS  * *prgRowStatus);


void __RPC_STUB IRowsetRefresh_RefreshVisibleData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRowsetRefresh_GetLastVisibleData_Proxy( 
    IRowsetRefresh  * This,
    /* [in] */ HROW hRow,
    /* [in] */ HACCESSOR hAccessor,
    /* [out] */ void  *pData);


void __RPC_STUB IRowsetRefresh_GetLastVisibleData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRowsetRefresh_INTERFACE_DEFINED__ */


#ifndef __IParentRowset_INTERFACE_DEFINED__
#define __IParentRowset_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IParentRowset
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object][local] */ 



EXTERN_C const IID IID_IParentRowset;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733aaa-2a1c-11ce-ade5-00aa0044773d")
    IParentRowset : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetChildRowset( 
            /* [in] */ IUnknown  *pUnkOuter,
            /* [in] */ DBORDINAL iOrdinal,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown  * *ppRowset) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IParentRowsetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IParentRowset  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IParentRowset  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IParentRowset  * This);
        
        HRESULT ( STDMETHODCALLTYPE  *GetChildRowset )( 
            IParentRowset  * This,
            /* [in] */ IUnknown  *pUnkOuter,
            /* [in] */ DBORDINAL iOrdinal,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown  * *ppRowset);
        
        END_INTERFACE
    } IParentRowsetVtbl;

    interface IParentRowset
    {
        CONST_VTBL struct IParentRowsetVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IParentRowset_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IParentRowset_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IParentRowset_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IParentRowset_GetChildRowset(This,pUnkOuter,iOrdinal,riid,ppRowset)	\
    (This)->lpVtbl -> GetChildRowset(This,pUnkOuter,iOrdinal,riid,ppRowset)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IParentRowset_GetChildRowset_Proxy( 
    IParentRowset  * This,
    /* [in] */ IUnknown  *pUnkOuter,
    /* [in] */ DBORDINAL iOrdinal,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown  * *ppRowset);


void __RPC_STUB IParentRowset_GetChildRowset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IParentRowset_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_oledb_0208
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 


extern RPC_IF_HANDLE __MIDL_itf_oledb_0208_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_oledb_0208_v0_0_s_ifspec;

#ifndef __IErrorRecords_INTERFACE_DEFINED__
#define __IErrorRecords_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IErrorRecords
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 


#define IDENTIFIER_SDK_MASK	0xF0000000
#define IDENTIFIER_SDK_ERROR	0x10000000
typedef struct  tagERRORINFO
    {
    HRESULT hrError;
    DWORD dwMinor;
    CLSID clsid;
    IID iid;
    DISPID dispid;
    }	ERRORINFO;


EXTERN_C const IID IID_IErrorRecords;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a67-2a1c-11ce-ade5-00aa0044773d")
    IErrorRecords : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE AddErrorRecord( 
            /* [in] */ ERRORINFO  *pErrorInfo,
            /* [in] */ DWORD dwLookupID,
            /* [in] */ DISPPARAMS  *pdispparams,
            /* [in] */ IUnknown  *punkCustomError,
            /* [in] */ DWORD dwDynamicErrorID) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetBasicErrorInfo( 
            /* [in] */ ULONG ulRecordNum,
            /* [out] */ ERRORINFO  *pErrorInfo) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetCustomErrorObject( 
            /* [in] */ ULONG ulRecordNum,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown  * *ppObject) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetErrorInfo( 
            /* [in] */ ULONG ulRecordNum,
            /* [in] */ LCID lcid,
            /* [out] */ IErrorInfo  * *ppErrorInfo) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetErrorParameters( 
            /* [in] */ ULONG ulRecordNum,
            /* [out] */ DISPPARAMS  *pdispparams) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetRecordCount( 
            /* [out] */ ULONG  *pcRecords) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IErrorRecordsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IErrorRecords  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IErrorRecords  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IErrorRecords  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *AddErrorRecord )( 
            IErrorRecords  * This,
            /* [in] */ ERRORINFO  *pErrorInfo,
            /* [in] */ DWORD dwLookupID,
            /* [in] */ DISPPARAMS  *pdispparams,
            /* [in] */ IUnknown  *punkCustomError,
            /* [in] */ DWORD dwDynamicErrorID);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetBasicErrorInfo )( 
            IErrorRecords  * This,
            /* [in] */ ULONG ulRecordNum,
            /* [out] */ ERRORINFO  *pErrorInfo);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetCustomErrorObject )( 
            IErrorRecords  * This,
            /* [in] */ ULONG ulRecordNum,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown  * *ppObject);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetErrorInfo )( 
            IErrorRecords  * This,
            /* [in] */ ULONG ulRecordNum,
            /* [in] */ LCID lcid,
            /* [out] */ IErrorInfo  * *ppErrorInfo);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetErrorParameters )( 
            IErrorRecords  * This,
            /* [in] */ ULONG ulRecordNum,
            /* [out] */ DISPPARAMS  *pdispparams);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetRecordCount )( 
            IErrorRecords  * This,
            /* [out] */ ULONG  *pcRecords);
        
        END_INTERFACE
    } IErrorRecordsVtbl;

    interface IErrorRecords
    {
        CONST_VTBL struct IErrorRecordsVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IErrorRecords_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IErrorRecords_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IErrorRecords_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IErrorRecords_AddErrorRecord(This,pErrorInfo,dwLookupID,pdispparams,punkCustomError,dwDynamicErrorID)	\
    (This)->lpVtbl -> AddErrorRecord(This,pErrorInfo,dwLookupID,pdispparams,punkCustomError,dwDynamicErrorID)

#define IErrorRecords_GetBasicErrorInfo(This,ulRecordNum,pErrorInfo)	\
    (This)->lpVtbl -> GetBasicErrorInfo(This,ulRecordNum,pErrorInfo)

#define IErrorRecords_GetCustomErrorObject(This,ulRecordNum,riid,ppObject)	\
    (This)->lpVtbl -> GetCustomErrorObject(This,ulRecordNum,riid,ppObject)

#define IErrorRecords_GetErrorInfo(This,ulRecordNum,lcid,ppErrorInfo)	\
    (This)->lpVtbl -> GetErrorInfo(This,ulRecordNum,lcid,ppErrorInfo)

#define IErrorRecords_GetErrorParameters(This,ulRecordNum,pdispparams)	\
    (This)->lpVtbl -> GetErrorParameters(This,ulRecordNum,pdispparams)

#define IErrorRecords_GetRecordCount(This,pcRecords)	\
    (This)->lpVtbl -> GetRecordCount(This,pcRecords)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IErrorRecords_RemoteAddErrorRecord_Proxy( 
    IErrorRecords  * This,
    /* [in] */ ERRORINFO  *pErrorInfo,
    /* [in] */ DWORD dwLookupID,
    /* [in] */ DISPPARAMS  *pdispparams,
    /* [in] */ IUnknown  *punkCustomError,
    /* [in] */ DWORD dwDynamicErrorID,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IErrorRecords_RemoteAddErrorRecord_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IErrorRecords_RemoteGetBasicErrorInfo_Proxy( 
    IErrorRecords  * This,
    /* [in] */ ULONG ulRecordNum,
    /* [out] */ ERRORINFO  *pErrorInfo,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IErrorRecords_RemoteGetBasicErrorInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IErrorRecords_RemoteGetCustomErrorObject_Proxy( 
    IErrorRecords  * This,
    /* [in] */ ULONG ulRecordNum,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown  * *ppObject,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IErrorRecords_RemoteGetCustomErrorObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IErrorRecords_RemoteGetErrorInfo_Proxy( 
    IErrorRecords  * This,
    /* [in] */ ULONG ulRecordNum,
    /* [in] */ LCID lcid,
    /* [out] */ IErrorInfo  * *ppErrorInfo,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IErrorRecords_RemoteGetErrorInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IErrorRecords_RemoteGetErrorParameters_Proxy( 
    IErrorRecords  * This,
    /* [in] */ ULONG ulRecordNum,
    /* [out] */ DISPPARAMS  *pdispparams,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IErrorRecords_RemoteGetErrorParameters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IErrorRecords_RemoteGetRecordCount_Proxy( 
    IErrorRecords  * This,
    /* [out] */ ULONG  *pcRecords,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IErrorRecords_RemoteGetRecordCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IErrorRecords_INTERFACE_DEFINED__ */


#ifndef __IErrorLookup_INTERFACE_DEFINED__
#define __IErrorLookup_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IErrorLookup
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IErrorLookup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a66-2a1c-11ce-ade5-00aa0044773d")
    IErrorLookup : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetErrorDescription( 
            /* [in] */ HRESULT hrError,
            /* [in] */ DWORD dwLookupID,
            /* [in] */ DISPPARAMS  *pdispparams,
            /* [in] */ LCID lcid,
            /* [out] */ BSTR  *pbstrSource,
            /* [out] */ BSTR  *pbstrDescription) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetHelpInfo( 
            /* [in] */ HRESULT hrError,
            /* [in] */ DWORD dwLookupID,
            /* [in] */ LCID lcid,
            /* [out] */ BSTR  *pbstrHelpFile,
            /* [out] */ DWORD  *pdwHelpContext) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE ReleaseErrors( 
            /* [in] */ const DWORD dwDynamicErrorID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IErrorLookupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IErrorLookup  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IErrorLookup  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IErrorLookup  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetErrorDescription )( 
            IErrorLookup  * This,
            /* [in] */ HRESULT hrError,
            /* [in] */ DWORD dwLookupID,
            /* [in] */ DISPPARAMS  *pdispparams,
            /* [in] */ LCID lcid,
            /* [out] */ BSTR  *pbstrSource,
            /* [out] */ BSTR  *pbstrDescription);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetHelpInfo )( 
            IErrorLookup  * This,
            /* [in] */ HRESULT hrError,
            /* [in] */ DWORD dwLookupID,
            /* [in] */ LCID lcid,
            /* [out] */ BSTR  *pbstrHelpFile,
            /* [out] */ DWORD  *pdwHelpContext);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *ReleaseErrors )( 
            IErrorLookup  * This,
            /* [in] */ const DWORD dwDynamicErrorID);
        
        END_INTERFACE
    } IErrorLookupVtbl;

    interface IErrorLookup
    {
        CONST_VTBL struct IErrorLookupVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IErrorLookup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IErrorLookup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IErrorLookup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IErrorLookup_GetErrorDescription(This,hrError,dwLookupID,pdispparams,lcid,pbstrSource,pbstrDescription)	\
    (This)->lpVtbl -> GetErrorDescription(This,hrError,dwLookupID,pdispparams,lcid,pbstrSource,pbstrDescription)

#define IErrorLookup_GetHelpInfo(This,hrError,dwLookupID,lcid,pbstrHelpFile,pdwHelpContext)	\
    (This)->lpVtbl -> GetHelpInfo(This,hrError,dwLookupID,lcid,pbstrHelpFile,pdwHelpContext)

#define IErrorLookup_ReleaseErrors(This,dwDynamicErrorID)	\
    (This)->lpVtbl -> ReleaseErrors(This,dwDynamicErrorID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IErrorLookup_RemoteGetErrorDescription_Proxy( 
    IErrorLookup  * This,
    /* [in] */ HRESULT hrError,
    /* [in] */ DWORD dwLookupID,
    /* [in] */ DISPPARAMS  *pdispparams,
    /* [in] */ LCID lcid,
    /* [out] */ BSTR  *pbstrSource,
    /* [out] */ BSTR  *pbstrDescription,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IErrorLookup_RemoteGetErrorDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IErrorLookup_RemoteGetHelpInfo_Proxy( 
    IErrorLookup  * This,
    /* [in] */ HRESULT hrError,
    /* [in] */ DWORD dwLookupID,
    /* [in] */ LCID lcid,
    /* [out] */ BSTR  *pbstrHelpFile,
    /* [out] */ DWORD  *pdwHelpContext,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IErrorLookup_RemoteGetHelpInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IErrorLookup_RemoteReleaseErrors_Proxy( 
    IErrorLookup  * This,
    /* [in] */ const DWORD dwDynamicErrorID,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IErrorLookup_RemoteReleaseErrors_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IErrorLookup_INTERFACE_DEFINED__ */


#ifndef __ISQLErrorInfo_INTERFACE_DEFINED__
#define __ISQLErrorInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISQLErrorInfo
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_ISQLErrorInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a74-2a1c-11ce-ade5-00aa0044773d")
    ISQLErrorInfo : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetSQLInfo( 
            /* [out] */ BSTR  *pbstrSQLState,
            /* [out] */ LONG  *plNativeError) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISQLErrorInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            ISQLErrorInfo  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            ISQLErrorInfo  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            ISQLErrorInfo  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetSQLInfo )( 
            ISQLErrorInfo  * This,
            /* [out] */ BSTR  *pbstrSQLState,
            /* [out] */ LONG  *plNativeError);
        
        END_INTERFACE
    } ISQLErrorInfoVtbl;

    interface ISQLErrorInfo
    {
        CONST_VTBL struct ISQLErrorInfoVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISQLErrorInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISQLErrorInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISQLErrorInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISQLErrorInfo_GetSQLInfo(This,pbstrSQLState,plNativeError)	\
    (This)->lpVtbl -> GetSQLInfo(This,pbstrSQLState,plNativeError)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE ISQLErrorInfo_RemoteGetSQLInfo_Proxy( 
    ISQLErrorInfo  * This,
    /* [out] */ BSTR  *pbstrSQLState,
    /* [out] */ LONG  *plNativeError,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB ISQLErrorInfo_RemoteGetSQLInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISQLErrorInfo_INTERFACE_DEFINED__ */


#ifndef __IGetDataSource_INTERFACE_DEFINED__
#define __IGetDataSource_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IGetDataSource
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IGetDataSource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a75-2a1c-11ce-ade5-00aa0044773d")
    IGetDataSource : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetDataSource( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown  * *ppDataSource) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGetDataSourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IGetDataSource  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IGetDataSource  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IGetDataSource  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetDataSource )( 
            IGetDataSource  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown  * *ppDataSource);
        
        END_INTERFACE
    } IGetDataSourceVtbl;

    interface IGetDataSource
    {
        CONST_VTBL struct IGetDataSourceVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGetDataSource_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGetDataSource_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGetDataSource_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGetDataSource_GetDataSource(This,riid,ppDataSource)	\
    (This)->lpVtbl -> GetDataSource(This,riid,ppDataSource)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IGetDataSource_RemoteGetDataSource_Proxy( 
    IGetDataSource  * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown  * *ppDataSource,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB IGetDataSource_RemoteGetDataSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGetDataSource_INTERFACE_DEFINED__ */


#ifndef __ITransactionLocal_INTERFACE_DEFINED__
#define __ITransactionLocal_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITransactionLocal
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_ITransactionLocal;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a5f-2a1c-11ce-ade5-00aa0044773d")
    ITransactionLocal : public ITransaction
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetOptionsObject( 
            /* [out] */ ITransactionOptions  * *ppOptions) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE StartTransaction( 
            /* [in] */ ISOLEVEL isoLevel,
            /* [in] */ ULONG isoFlags,
            /* [in] */ ITransactionOptions  *pOtherOptions,
            /* [out] */ ULONG  *pulTransactionLevel) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionLocalVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            ITransactionLocal  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            ITransactionLocal  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            ITransactionLocal  * This);
        
        HRESULT ( STDMETHODCALLTYPE  *Commit )( 
            ITransactionLocal  * This,
            /* [in] */ BOOL fRetaining,
            /* [in] */ DWORD grfTC,
            /* [in] */ DWORD grfRM);
        
        HRESULT ( STDMETHODCALLTYPE  *Abort )( 
            ITransactionLocal  * This,
            /* [unique][in] */ BOID  *pboidReason,
            /* [in] */ BOOL fRetaining,
            /* [in] */ BOOL fAsync);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetTransactionInfo )( 
            ITransactionLocal  * This,
            /* [out] */ XACTTRANSINFO  *pinfo);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetOptionsObject )( 
            ITransactionLocal  * This,
            /* [out] */ ITransactionOptions  * *ppOptions);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *StartTransaction )( 
            ITransactionLocal  * This,
            /* [in] */ ISOLEVEL isoLevel,
            /* [in] */ ULONG isoFlags,
            /* [in] */ ITransactionOptions  *pOtherOptions,
            /* [out] */ ULONG  *pulTransactionLevel);
        
        END_INTERFACE
    } ITransactionLocalVtbl;

    interface ITransactionLocal
    {
        CONST_VTBL struct ITransactionLocalVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionLocal_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITransactionLocal_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITransactionLocal_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITransactionLocal_Commit(This,fRetaining,grfTC,grfRM)	\
    (This)->lpVtbl -> Commit(This,fRetaining,grfTC,grfRM)

#define ITransactionLocal_Abort(This,pboidReason,fRetaining,fAsync)	\
    (This)->lpVtbl -> Abort(This,pboidReason,fRetaining,fAsync)

#define ITransactionLocal_GetTransactionInfo(This,pinfo)	\
    (This)->lpVtbl -> GetTransactionInfo(This,pinfo)


#define ITransactionLocal_GetOptionsObject(This,ppOptions)	\
    (This)->lpVtbl -> GetOptionsObject(This,ppOptions)

#define ITransactionLocal_StartTransaction(This,isoLevel,isoFlags,pOtherOptions,pulTransactionLevel)	\
    (This)->lpVtbl -> StartTransaction(This,isoLevel,isoFlags,pOtherOptions,pulTransactionLevel)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE ITransactionLocal_RemoteGetOptionsObject_Proxy( 
    ITransactionLocal  * This,
    /* [out] */ ITransactionOptions  * *ppOptions,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB ITransactionLocal_RemoteGetOptionsObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITransactionLocal_RemoteStartTransaction_Proxy( 
    ITransactionLocal  * This,
    /* [in] */ ISOLEVEL isoLevel,
    /* [in] */ ULONG isoFlags,
    /* [in] */ ITransactionOptions  *pOtherOptions,
    /* [unique][out][in] */ ULONG  *pulTransactionLevel,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB ITransactionLocal_RemoteStartTransaction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITransactionLocal_INTERFACE_DEFINED__ */


#ifndef __ITransactionJoin_INTERFACE_DEFINED__
#define __ITransactionJoin_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITransactionJoin
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_ITransactionJoin;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a5e-2a1c-11ce-ade5-00aa0044773d")
    ITransactionJoin : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetOptionsObject( 
            /* [out] */ ITransactionOptions  * *ppOptions) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE JoinTransaction( 
            /* [in] */ IUnknown  *punkTransactionCoord,
            /* [in] */ ISOLEVEL isoLevel,
            /* [in] */ ULONG isoFlags,
            /* [in] */ ITransactionOptions  *pOtherOptions) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionJoinVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            ITransactionJoin  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            ITransactionJoin  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            ITransactionJoin  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetOptionsObject )( 
            ITransactionJoin  * This,
            /* [out] */ ITransactionOptions  * *ppOptions);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *JoinTransaction )( 
            ITransactionJoin  * This,
            /* [in] */ IUnknown  *punkTransactionCoord,
            /* [in] */ ISOLEVEL isoLevel,
            /* [in] */ ULONG isoFlags,
            /* [in] */ ITransactionOptions  *pOtherOptions);
        
        END_INTERFACE
    } ITransactionJoinVtbl;

    interface ITransactionJoin
    {
        CONST_VTBL struct ITransactionJoinVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionJoin_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITransactionJoin_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITransactionJoin_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITransactionJoin_GetOptionsObject(This,ppOptions)	\
    (This)->lpVtbl -> GetOptionsObject(This,ppOptions)

#define ITransactionJoin_JoinTransaction(This,punkTransactionCoord,isoLevel,isoFlags,pOtherOptions)	\
    (This)->lpVtbl -> JoinTransaction(This,punkTransactionCoord,isoLevel,isoFlags,pOtherOptions)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE ITransactionJoin_RemoteGetOptionsObject_Proxy( 
    ITransactionJoin  * This,
    /* [out] */ ITransactionOptions  * *ppOptions,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB ITransactionJoin_RemoteGetOptionsObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITransactionJoin_RemoteJoinTransaction_Proxy( 
    ITransactionJoin  * This,
    /* [in] */ IUnknown  *punkTransactionCoord,
    /* [in] */ ISOLEVEL isoLevel,
    /* [in] */ ULONG isoFlags,
    /* [in] */ ITransactionOptions  *pOtherOptions,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB ITransactionJoin_RemoteJoinTransaction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITransactionJoin_INTERFACE_DEFINED__ */


#ifndef __ITransactionObject_INTERFACE_DEFINED__
#define __ITransactionObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITransactionObject
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_ITransactionObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a60-2a1c-11ce-ade5-00aa0044773d")
    ITransactionObject : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetTransactionObject( 
            /* [in] */ ULONG ulTransactionLevel,
            /* [out] */ ITransaction  * *ppTransactionObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            ITransactionObject  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            ITransactionObject  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            ITransactionObject  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetTransactionObject )( 
            ITransactionObject  * This,
            /* [in] */ ULONG ulTransactionLevel,
            /* [out] */ ITransaction  * *ppTransactionObject);
        
        END_INTERFACE
    } ITransactionObjectVtbl;

    interface ITransactionObject
    {
        CONST_VTBL struct ITransactionObjectVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITransactionObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITransactionObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITransactionObject_GetTransactionObject(This,ulTransactionLevel,ppTransactionObject)	\
    (This)->lpVtbl -> GetTransactionObject(This,ulTransactionLevel,ppTransactionObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE ITransactionObject_RemoteGetTransactionObject_Proxy( 
    ITransactionObject  * This,
    /* [in] */ ULONG ulTransactionLevel,
    /* [out] */ ITransaction  * *ppTransactionObject,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);


void __RPC_STUB ITransactionObject_RemoteGetTransactionObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITransactionObject_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_oledb_0223
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 


#ifndef UNDER_CE
#if 0  // to get around a MIDL limitation
typedef 
enum _TRUSTEE_TYPE
    {	TRUSTEE_IS_UNKNOWN	= 0,
	TRUSTEE_IS_USER	= TRUSTEE_IS_UNKNOWN + 1,
	TRUSTEE_IS_GROUP	= TRUSTEE_IS_USER + 1
    }	TRUSTEE_TYPE;

typedef 
enum _TRUSTEE_FORM
    {	TRUSTEE_IS_SID	= 0,
	TRUSTEE_IS_NAME	= TRUSTEE_IS_SID + 1
    }	TRUSTEE_FORM;

typedef 
enum _MULTIPLE_TRUSTEE_OPERATION
    {	NO_MULTIPLE_TRUSTEE	= 0,
	TRUSTEE_IS_IMPERSONATE	= NO_MULTIPLE_TRUSTEE + 1
    }	MULTIPLE_TRUSTEE_OPERATION;

typedef struct _TRUSTEE_A  *PTRUSTEE_A;

typedef struct _TRUSTEE_W  *PTRUSTEE_W;

typedef struct  _TRUSTEE_W
    {
    PTRUSTEE_W pMultipleTrustee;
    MULTIPLE_TRUSTEE_OPERATION MultipleTrusteeOperation;
    TRUSTEE_FORM TrusteeForm;
    TRUSTEE_TYPE TrusteeType;
    LPWSTR ptstrName;
    }	TRUSTEE_W;

typedef struct  _TRUSTEE_A
    {
    PTRUSTEE_A pMultipleTrustee;
    MULTIPLE_TRUSTEE_OPERATION MultipleTrusteeOperation;
    TRUSTEE_FORM TrusteeForm;
    TRUSTEE_TYPE TrusteeType;
    LPSTR ptstrName;
    }	TRUSTEE_A;

typedef 
enum _ACCESS_MODE
    {	NOT_USED_ACCESS	= 0,
	GRANT_ACCESS	= NOT_USED_ACCESS + 1,
	SET_ACCESS	= GRANT_ACCESS + 1,
	DENY_ACCESS	= SET_ACCESS + 1,
	REVOKE_ACCESS	= DENY_ACCESS + 1,
	SET_AUDIT_SUCCESS	= REVOKE_ACCESS + 1,
	SET_AUDIT_FAILURE	= SET_AUDIT_SUCCESS + 1
    }	ACCESS_MODE;

typedef 
enum _SE_OBJECT_TYPE
    {	SE_UNKNOWN_OBJECT_TYPE	= 0,
	SE_FILE_OBJECT	= SE_UNKNOWN_OBJECT_TYPE + 1,
	SE_SERVICE	= SE_FILE_OBJECT + 1,
	SE_PRINTER	= SE_SERVICE + 1,
	SE_REGISTRY_KEY	= SE_PRINTER + 1,
	SE_LMSHARE	= SE_REGISTRY_KEY + 1,
	SE_KERNEL_OBJECT	= SE_LMSHARE + 1,
	SE_WINDOW_OBJECT	= SE_KERNEL_OBJECT + 1
    }	SE_OBJECT_TYPE;

typedef struct  _EXPLICIT_ACCESS_W
    {
    DWORD grfAccessPermissions;
    ACCESS_MODE grfAccessMode;
    DWORD grfInheritance;
    TRUSTEE_W Trustee;
    }	EXPLICIT_ACCESS_W;

typedef struct _EXPLICIT_ACCESS_W  *PEXPLICIT_ACCESS_W;

typedef struct  _EXPLICIT_ACCESS_A
    {
    DWORD grfAccessPermissions;
    ACCESS_MODE grfAccessMode;
    DWORD grfInheritance;
    TRUSTEE_A Trustee;
    }	EXPLICIT_ACCESS_A;

typedef struct _EXPLICIT_ACCESS_A  *PEXPLICIT_ACCESS_A;

#else
#include <accctrl.h>
#endif


extern RPC_IF_HANDLE __MIDL_itf_oledb_0223_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_oledb_0223_v0_0_s_ifspec;

#ifndef __ITrusteeAdmin_INTERFACE_DEFINED__
#define __ITrusteeAdmin_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITrusteeAdmin
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object][local] */ 



EXTERN_C const IID IID_ITrusteeAdmin;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733aa1-2a1c-11ce-ade5-00aa0044773d")
    ITrusteeAdmin : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CompareTrustees( 
            /* [in] */ TRUSTEE_W  *pTrustee1,
            /* [in] */ TRUSTEE_W  *pTrustee2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateTrustee( 
            /* [in] */ TRUSTEE_W  *pTrustee,
            /* [in] */ ULONG cPropertySets,
            /* [size_is][out][in] */ DBPROPSET  rgPropertySets[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteTrustee( 
            /* [in] */ TRUSTEE_W  *pTrustee) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTrusteeProperties( 
            /* [in] */ TRUSTEE_W  *pTrustee,
            /* [in] */ ULONG cPropertySets,
            /* [size_is][out][in] */ DBPROPSET  rgPropertySets[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTrusteeProperties( 
            /* [in] */ TRUSTEE_W  *pTrustee,
            /* [in] */ const ULONG cPropertyIDSets,
            /* [size_is][in] */ const DBPROPIDSET  rgPropertyIDSets[  ],
            /* [out][in] */ ULONG  *pcPropertySets,
            /* [size_is][size_is][out] */ DBPROPSET  * *prgPropertySets) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITrusteeAdminVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            ITrusteeAdmin  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            ITrusteeAdmin  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            ITrusteeAdmin  * This);
        
        HRESULT ( STDMETHODCALLTYPE  *CompareTrustees )( 
            ITrusteeAdmin  * This,
            /* [in] */ TRUSTEE_W  *pTrustee1,
            /* [in] */ TRUSTEE_W  *pTrustee2);
        
        HRESULT ( STDMETHODCALLTYPE  *CreateTrustee )( 
            ITrusteeAdmin  * This,
            /* [in] */ TRUSTEE_W  *pTrustee,
            /* [in] */ ULONG cPropertySets,
            /* [size_is][out][in] */ DBPROPSET  rgPropertySets[  ]);
        
        HRESULT ( STDMETHODCALLTYPE  *DeleteTrustee )( 
            ITrusteeAdmin  * This,
            /* [in] */ TRUSTEE_W  *pTrustee);
        
        HRESULT ( STDMETHODCALLTYPE  *SetTrusteeProperties )( 
            ITrusteeAdmin  * This,
            /* [in] */ TRUSTEE_W  *pTrustee,
            /* [in] */ ULONG cPropertySets,
            /* [size_is][out][in] */ DBPROPSET  rgPropertySets[  ]);
        
        HRESULT ( STDMETHODCALLTYPE  *GetTrusteeProperties )( 
            ITrusteeAdmin  * This,
            /* [in] */ TRUSTEE_W  *pTrustee,
            /* [in] */ const ULONG cPropertyIDSets,
            /* [size_is][in] */ const DBPROPIDSET  rgPropertyIDSets[  ],
            /* [out][in] */ ULONG  *pcPropertySets,
            /* [size_is][size_is][out] */ DBPROPSET  * *prgPropertySets);
        
        END_INTERFACE
    } ITrusteeAdminVtbl;

    interface ITrusteeAdmin
    {
        CONST_VTBL struct ITrusteeAdminVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITrusteeAdmin_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITrusteeAdmin_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITrusteeAdmin_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITrusteeAdmin_CompareTrustees(This,pTrustee1,pTrustee2)	\
    (This)->lpVtbl -> CompareTrustees(This,pTrustee1,pTrustee2)

#define ITrusteeAdmin_CreateTrustee(This,pTrustee,cPropertySets,rgPropertySets)	\
    (This)->lpVtbl -> CreateTrustee(This,pTrustee,cPropertySets,rgPropertySets)

#define ITrusteeAdmin_DeleteTrustee(This,pTrustee)	\
    (This)->lpVtbl -> DeleteTrustee(This,pTrustee)

#define ITrusteeAdmin_SetTrusteeProperties(This,pTrustee,cPropertySets,rgPropertySets)	\
    (This)->lpVtbl -> SetTrusteeProperties(This,pTrustee,cPropertySets,rgPropertySets)

#define ITrusteeAdmin_GetTrusteeProperties(This,pTrustee,cPropertyIDSets,rgPropertyIDSets,pcPropertySets,prgPropertySets)	\
    (This)->lpVtbl -> GetTrusteeProperties(This,pTrustee,cPropertyIDSets,rgPropertyIDSets,pcPropertySets,prgPropertySets)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITrusteeAdmin_CompareTrustees_Proxy( 
    ITrusteeAdmin  * This,
    /* [in] */ TRUSTEE_W  *pTrustee1,
    /* [in] */ TRUSTEE_W  *pTrustee2);


void __RPC_STUB ITrusteeAdmin_CompareTrustees_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITrusteeAdmin_CreateTrustee_Proxy( 
    ITrusteeAdmin  * This,
    /* [in] */ TRUSTEE_W  *pTrustee,
    /* [in] */ ULONG cPropertySets,
    /* [size_is][out][in] */ DBPROPSET  rgPropertySets[  ]);


void __RPC_STUB ITrusteeAdmin_CreateTrustee_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITrusteeAdmin_DeleteTrustee_Proxy( 
    ITrusteeAdmin  * This,
    /* [in] */ TRUSTEE_W  *pTrustee);


void __RPC_STUB ITrusteeAdmin_DeleteTrustee_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITrusteeAdmin_SetTrusteeProperties_Proxy( 
    ITrusteeAdmin  * This,
    /* [in] */ TRUSTEE_W  *pTrustee,
    /* [in] */ ULONG cPropertySets,
    /* [size_is][out][in] */ DBPROPSET  rgPropertySets[  ]);


void __RPC_STUB ITrusteeAdmin_SetTrusteeProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITrusteeAdmin_GetTrusteeProperties_Proxy( 
    ITrusteeAdmin  * This,
    /* [in] */ TRUSTEE_W  *pTrustee,
    /* [in] */ const ULONG cPropertyIDSets,
    /* [size_is][in] */ const DBPROPIDSET  rgPropertyIDSets[  ],
    /* [out][in] */ ULONG  *pcPropertySets,
    /* [size_is][size_is][out] */ DBPROPSET  * *prgPropertySets);


void __RPC_STUB ITrusteeAdmin_GetTrusteeProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITrusteeAdmin_INTERFACE_DEFINED__ */


#ifndef __ITrusteeGroupAdmin_INTERFACE_DEFINED__
#define __ITrusteeGroupAdmin_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITrusteeGroupAdmin
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object][local] */ 



EXTERN_C const IID IID_ITrusteeGroupAdmin;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733aa2-2a1c-11ce-ade5-00aa0044773d")
    ITrusteeGroupAdmin : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddMember( 
            /* [in] */ TRUSTEE_W  *pMembershipTrustee,
            /* [in] */ TRUSTEE_W  *pMemberTrustee) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteMember( 
            /* [in] */ TRUSTEE_W  *pMembershipTrustee,
            /* [in] */ TRUSTEE_W  *pMemberTrustee) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsMember( 
            /* [in] */ TRUSTEE_W  *pMembershipTrustee,
            /* [in] */ TRUSTEE_W  *pMemberTrustee,
            /* [out] */ BOOL  *pfStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMembers( 
            /* [in] */ TRUSTEE_W  *pMembershipTrustee,
            /* [out] */ ULONG  *pcMembers,
            /* [out] */ TRUSTEE_W  * *prgMembers) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMemberships( 
            /* [in] */ TRUSTEE_W  *pTrustee,
            /* [out] */ ULONG  *pcMemberships,
            /* [out] */ TRUSTEE_W  * *prgMemberships) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITrusteeGroupAdminVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            ITrusteeGroupAdmin  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            ITrusteeGroupAdmin  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            ITrusteeGroupAdmin  * This);
        
        HRESULT ( STDMETHODCALLTYPE  *AddMember )( 
            ITrusteeGroupAdmin  * This,
            /* [in] */ TRUSTEE_W  *pMembershipTrustee,
            /* [in] */ TRUSTEE_W  *pMemberTrustee);
        
        HRESULT ( STDMETHODCALLTYPE  *DeleteMember )( 
            ITrusteeGroupAdmin  * This,
            /* [in] */ TRUSTEE_W  *pMembershipTrustee,
            /* [in] */ TRUSTEE_W  *pMemberTrustee);
        
        HRESULT ( STDMETHODCALLTYPE  *IsMember )( 
            ITrusteeGroupAdmin  * This,
            /* [in] */ TRUSTEE_W  *pMembershipTrustee,
            /* [in] */ TRUSTEE_W  *pMemberTrustee,
            /* [out] */ BOOL  *pfStatus);
        
        HRESULT ( STDMETHODCALLTYPE  *GetMembers )( 
            ITrusteeGroupAdmin  * This,
            /* [in] */ TRUSTEE_W  *pMembershipTrustee,
            /* [out] */ ULONG  *pcMembers,
            /* [out] */ TRUSTEE_W  * *prgMembers);
        
        HRESULT ( STDMETHODCALLTYPE  *GetMemberships )( 
            ITrusteeGroupAdmin  * This,
            /* [in] */ TRUSTEE_W  *pTrustee,
            /* [out] */ ULONG  *pcMemberships,
            /* [out] */ TRUSTEE_W  * *prgMemberships);
        
        END_INTERFACE
    } ITrusteeGroupAdminVtbl;

    interface ITrusteeGroupAdmin
    {
        CONST_VTBL struct ITrusteeGroupAdminVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITrusteeGroupAdmin_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITrusteeGroupAdmin_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITrusteeGroupAdmin_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITrusteeGroupAdmin_AddMember(This,pMembershipTrustee,pMemberTrustee)	\
    (This)->lpVtbl -> AddMember(This,pMembershipTrustee,pMemberTrustee)

#define ITrusteeGroupAdmin_DeleteMember(This,pMembershipTrustee,pMemberTrustee)	\
    (This)->lpVtbl -> DeleteMember(This,pMembershipTrustee,pMemberTrustee)

#define ITrusteeGroupAdmin_IsMember(This,pMembershipTrustee,pMemberTrustee,pfStatus)	\
    (This)->lpVtbl -> IsMember(This,pMembershipTrustee,pMemberTrustee,pfStatus)

#define ITrusteeGroupAdmin_GetMembers(This,pMembershipTrustee,pcMembers,prgMembers)	\
    (This)->lpVtbl -> GetMembers(This,pMembershipTrustee,pcMembers,prgMembers)

#define ITrusteeGroupAdmin_GetMemberships(This,pTrustee,pcMemberships,prgMemberships)	\
    (This)->lpVtbl -> GetMemberships(This,pTrustee,pcMemberships,prgMemberships)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITrusteeGroupAdmin_AddMember_Proxy( 
    ITrusteeGroupAdmin  * This,
    /* [in] */ TRUSTEE_W  *pMembershipTrustee,
    /* [in] */ TRUSTEE_W  *pMemberTrustee);


void __RPC_STUB ITrusteeGroupAdmin_AddMember_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITrusteeGroupAdmin_DeleteMember_Proxy( 
    ITrusteeGroupAdmin  * This,
    /* [in] */ TRUSTEE_W  *pMembershipTrustee,
    /* [in] */ TRUSTEE_W  *pMemberTrustee);


void __RPC_STUB ITrusteeGroupAdmin_DeleteMember_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITrusteeGroupAdmin_IsMember_Proxy( 
    ITrusteeGroupAdmin  * This,
    /* [in] */ TRUSTEE_W  *pMembershipTrustee,
    /* [in] */ TRUSTEE_W  *pMemberTrustee,
    /* [out] */ BOOL  *pfStatus);


void __RPC_STUB ITrusteeGroupAdmin_IsMember_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITrusteeGroupAdmin_GetMembers_Proxy( 
    ITrusteeGroupAdmin  * This,
    /* [in] */ TRUSTEE_W  *pMembershipTrustee,
    /* [out] */ ULONG  *pcMembers,
    /* [out] */ TRUSTEE_W  * *prgMembers);


void __RPC_STUB ITrusteeGroupAdmin_GetMembers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITrusteeGroupAdmin_GetMemberships_Proxy( 
    ITrusteeGroupAdmin  * This,
    /* [in] */ TRUSTEE_W  *pTrustee,
    /* [out] */ ULONG  *pcMemberships,
    /* [out] */ TRUSTEE_W  * *prgMemberships);


void __RPC_STUB ITrusteeGroupAdmin_GetMemberships_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITrusteeGroupAdmin_INTERFACE_DEFINED__ */


#ifndef __IObjectAccessControl_INTERFACE_DEFINED__
#define __IObjectAccessControl_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IObjectAccessControl
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object][local] */ 



EXTERN_C const IID IID_IObjectAccessControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733aa3-2a1c-11ce-ade5-00aa0044773d")
    IObjectAccessControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetObjectAccessRights( 
            /* [in] */ SEC_OBJECT  *pObject,
            /* [out][in] */ ULONG  *pcAccessEntries,
            /* [out][in] */ EXPLICIT_ACCESS_W  * *prgAccessEntries) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjectOwner( 
            /* [in] */ SEC_OBJECT  *pObject,
            /* [out] */ TRUSTEE_W  * *ppOwner) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsObjectAccessAllowed( 
            /* [in] */ SEC_OBJECT  *pObject,
            /* [in] */ EXPLICIT_ACCESS_W  *pAccessEntry,
            /* [out] */ BOOL  *pfResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetObjectAccessRights( 
            /* [in] */ SEC_OBJECT  *pObject,
            /* [in] */ ULONG cAccessEntries,
            /* [out][in] */ EXPLICIT_ACCESS_W  *prgAccessEntries) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetObjectOwner( 
            /* [in] */ SEC_OBJECT  *pObject,
            /* [in] */ TRUSTEE_W  *pOwner) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjectAccessControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IObjectAccessControl  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IObjectAccessControl  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IObjectAccessControl  * This);
        
        HRESULT ( STDMETHODCALLTYPE  *GetObjectAccessRights )( 
            IObjectAccessControl  * This,
            /* [in] */ SEC_OBJECT  *pObject,
            /* [out][in] */ ULONG  *pcAccessEntries,
            /* [out][in] */ EXPLICIT_ACCESS_W  * *prgAccessEntries);
        
        HRESULT ( STDMETHODCALLTYPE  *GetObjectOwner )( 
            IObjectAccessControl  * This,
            /* [in] */ SEC_OBJECT  *pObject,
            /* [out] */ TRUSTEE_W  * *ppOwner);
        
        HRESULT ( STDMETHODCALLTYPE  *IsObjectAccessAllowed )( 
            IObjectAccessControl  * This,
            /* [in] */ SEC_OBJECT  *pObject,
            /* [in] */ EXPLICIT_ACCESS_W  *pAccessEntry,
            /* [out] */ BOOL  *pfResult);
        
        HRESULT ( STDMETHODCALLTYPE  *SetObjectAccessRights )( 
            IObjectAccessControl  * This,
            /* [in] */ SEC_OBJECT  *pObject,
            /* [in] */ ULONG cAccessEntries,
            /* [out][in] */ EXPLICIT_ACCESS_W  *prgAccessEntries);
        
        HRESULT ( STDMETHODCALLTYPE  *SetObjectOwner )( 
            IObjectAccessControl  * This,
            /* [in] */ SEC_OBJECT  *pObject,
            /* [in] */ TRUSTEE_W  *pOwner);
        
        END_INTERFACE
    } IObjectAccessControlVtbl;

    interface IObjectAccessControl
    {
        CONST_VTBL struct IObjectAccessControlVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjectAccessControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IObjectAccessControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IObjectAccessControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IObjectAccessControl_GetObjectAccessRights(This,pObject,pcAccessEntries,prgAccessEntries)	\
    (This)->lpVtbl -> GetObjectAccessRights(This,pObject,pcAccessEntries,prgAccessEntries)

#define IObjectAccessControl_GetObjectOwner(This,pObject,ppOwner)	\
    (This)->lpVtbl -> GetObjectOwner(This,pObject,ppOwner)

#define IObjectAccessControl_IsObjectAccessAllowed(This,pObject,pAccessEntry,pfResult)	\
    (This)->lpVtbl -> IsObjectAccessAllowed(This,pObject,pAccessEntry,pfResult)

#define IObjectAccessControl_SetObjectAccessRights(This,pObject,cAccessEntries,prgAccessEntries)	\
    (This)->lpVtbl -> SetObjectAccessRights(This,pObject,cAccessEntries,prgAccessEntries)

#define IObjectAccessControl_SetObjectOwner(This,pObject,pOwner)	\
    (This)->lpVtbl -> SetObjectOwner(This,pObject,pOwner)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IObjectAccessControl_GetObjectAccessRights_Proxy( 
    IObjectAccessControl  * This,
    /* [in] */ SEC_OBJECT  *pObject,
    /* [out][in] */ ULONG  *pcAccessEntries,
    /* [out][in] */ EXPLICIT_ACCESS_W  * *prgAccessEntries);


void __RPC_STUB IObjectAccessControl_GetObjectAccessRights_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectAccessControl_GetObjectOwner_Proxy( 
    IObjectAccessControl  * This,
    /* [in] */ SEC_OBJECT  *pObject,
    /* [out] */ TRUSTEE_W  * *ppOwner);


void __RPC_STUB IObjectAccessControl_GetObjectOwner_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectAccessControl_IsObjectAccessAllowed_Proxy( 
    IObjectAccessControl  * This,
    /* [in] */ SEC_OBJECT  *pObject,
    /* [in] */ EXPLICIT_ACCESS_W  *pAccessEntry,
    /* [out] */ BOOL  *pfResult);


void __RPC_STUB IObjectAccessControl_IsObjectAccessAllowed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectAccessControl_SetObjectAccessRights_Proxy( 
    IObjectAccessControl  * This,
    /* [in] */ SEC_OBJECT  *pObject,
    /* [in] */ ULONG cAccessEntries,
    /* [out][in] */ EXPLICIT_ACCESS_W  *prgAccessEntries);


void __RPC_STUB IObjectAccessControl_SetObjectAccessRights_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectAccessControl_SetObjectOwner_Proxy( 
    IObjectAccessControl  * This,
    /* [in] */ SEC_OBJECT  *pObject,
    /* [in] */ TRUSTEE_W  *pOwner);


void __RPC_STUB IObjectAccessControl_SetObjectOwner_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IObjectAccessControl_INTERFACE_DEFINED__ */


#ifndef __ISecurityInfo_INTERFACE_DEFINED__
#define __ISecurityInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISecurityInfo
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object][local] */ 


typedef DWORD ACCESS_MASK;


enum ACCESS_MASKENUM
    {	PERM_EXCLUSIVE	= 0x200L,
	PERM_READDESIGN	= 0x400L,
	PERM_WRITEDESIGN	= 0x800L,
	PERM_WITHGRANT	= 0x1000L,
	PERM_REFERENCE	= 0x2000L,
	PERM_CREATE	= 0x4000L,
	PERM_INSERT	= 0x8000L,
	PERM_DELETE	= 0x10000L,
	PERM_READCONTROL	= 0x20000L,
	PERM_WRITEPERMISSIONS	= 0x40000L,
	PERM_WRITEOWNER	= 0x80000L,
	PERM_MAXIMUM_ALLOWED	= 0x2000000L,
	PERM_ALL	= 0x10000000L,
	PERM_EXECUTE	= 0x20000000L,
	PERM_READ	= 0x80000000L,
	PERM_UPDATE	= 0x40000000L,
	PERM_DROP	= 0x100L
    };
#define PERM_DESIGN 							PERM_WRITEDESIGN

EXTERN_C const IID IID_ISecurityInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733aa4-2a1c-11ce-ade5-00aa0044773d")
    ISecurityInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCurrentTrustee( 
            /* [out] */ TRUSTEE_W  * *ppTrustee) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjectTypes( 
            /* [out] */ ULONG  *cObjectTypes,
            /* [out] */ GUID  * *rgObjectTypes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPermissions( 
            /* [in] */ GUID ObjectType,
            /* [out] */ ACCESS_MASK  *pPermissions) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISecurityInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            ISecurityInfo  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            ISecurityInfo  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            ISecurityInfo  * This);
        
        HRESULT ( STDMETHODCALLTYPE  *GetCurrentTrustee )( 
            ISecurityInfo  * This,
            /* [out] */ TRUSTEE_W  * *ppTrustee);
        
        HRESULT ( STDMETHODCALLTYPE  *GetObjectTypes )( 
            ISecurityInfo  * This,
            /* [out] */ ULONG  *cObjectTypes,
            /* [out] */ GUID  * *rgObjectTypes);
        
        HRESULT ( STDMETHODCALLTYPE  *GetPermissions )( 
            ISecurityInfo  * This,
            /* [in] */ GUID ObjectType,
            /* [out] */ ACCESS_MASK  *pPermissions);
        
        END_INTERFACE
    } ISecurityInfoVtbl;

    interface ISecurityInfo
    {
        CONST_VTBL struct ISecurityInfoVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISecurityInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISecurityInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISecurityInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISecurityInfo_GetCurrentTrustee(This,ppTrustee)	\
    (This)->lpVtbl -> GetCurrentTrustee(This,ppTrustee)

#define ISecurityInfo_GetObjectTypes(This,cObjectTypes,rgObjectTypes)	\
    (This)->lpVtbl -> GetObjectTypes(This,cObjectTypes,rgObjectTypes)

#define ISecurityInfo_GetPermissions(This,ObjectType,pPermissions)	\
    (This)->lpVtbl -> GetPermissions(This,ObjectType,pPermissions)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISecurityInfo_GetCurrentTrustee_Proxy( 
    ISecurityInfo  * This,
    /* [out] */ TRUSTEE_W  * *ppTrustee);


void __RPC_STUB ISecurityInfo_GetCurrentTrustee_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISecurityInfo_GetObjectTypes_Proxy( 
    ISecurityInfo  * This,
    /* [out] */ ULONG  *cObjectTypes,
    /* [out] */ GUID  * *rgObjectTypes);


void __RPC_STUB ISecurityInfo_GetObjectTypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISecurityInfo_GetPermissions_Proxy( 
    ISecurityInfo  * This,
    /* [in] */ GUID ObjectType,
    /* [out] */ ACCESS_MASK  *pPermissions);


void __RPC_STUB ISecurityInfo_GetPermissions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISecurityInfo_INTERFACE_DEFINED__ */
#endif // (UNDER_CE)

#ifndef __ITableCreation_INTERFACE_DEFINED__
#define __ITableCreation_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITableCreation
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object][local] */ 



EXTERN_C const IID IID_ITableCreation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733abc-2a1c-11ce-ade5-00aa0044773d")
    ITableCreation : public ITableDefinition
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetTableDefinition( 
            /* [in] */ DBID  *pTableID,
            /* [out] */ DBORDINAL *pcColumnDescs,
            /* [size_is][size_is][out] */ DBCOLUMNDESC  * prgColumnDescs[  ],
            /* [out] */ ULONG  *pcPropertySets,
            /* [size_is][size_is][out] */ DBPROPSET  * prgPropertySets[  ],
            /* [out] */ ULONG  *pcConstraintDescs,
            /* [size_is][size_is][out] */ DBCONSTRAINTDESC  * prgConstraintDescs[  ],
            /* [out] */ OLECHAR  * *ppwszStringBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITableCreationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            ITableCreation  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            ITableCreation  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            ITableCreation  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *CreateTable )( 
            ITableCreation  * This,
            /* [in] */ IUnknown  *pUnkOuter,
            /* [in] */ DBID  *pTableID,
            /* [in] */ DBORDINAL cColumnDescs,
            /* [size_is][in] */ const DBCOLUMNDESC  rgColumnDescs[  ],
            /* [in] */ REFIID riid,
            /* [in] */ ULONG cPropertySets,
            /* [size_is][out][in] */ DBPROPSET  rgPropertySets[  ],
            /* [out] */ DBID  * *ppTableID,
            /* [iid_is][out] */ IUnknown  * *ppRowset);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *DropTable )( 
            ITableCreation  * This,
            /* [unique][in] */ DBID  *pTableID);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *AddColumn )( 
            ITableCreation  * This,
            /* [in] */ DBID  *pTableID,
            /* [out][in] */ DBCOLUMNDESC  *pColumnDesc,
            /* [out] */ DBID  * *ppColumnID);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *DropColumn )( 
            ITableCreation  * This,
            /* [unique][in] */ DBID  *pTableID,
            /* [unique][in] */ DBID  *pColumnID);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetTableDefinition )( 
            ITableCreation  * This,
            /* [in] */ DBID  *pTableID,
            /* [out] */ DBORDINAL *pcColumnDescs,
            /* [size_is][size_is][out] */ DBCOLUMNDESC  * prgColumnDescs[  ],
            /* [out] */ ULONG  *pcPropertySets,
            /* [size_is][size_is][out] */ DBPROPSET  * prgPropertySets[  ],
            /* [out] */ ULONG  *pcConstraintDescs,
            /* [size_is][size_is][out] */ DBCONSTRAINTDESC  * prgConstraintDescs[  ],
            /* [out] */ OLECHAR  * *ppwszStringBuffer);
        
        END_INTERFACE
    } ITableCreationVtbl;

    interface ITableCreation
    {
        CONST_VTBL struct ITableCreationVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITableCreation_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITableCreation_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITableCreation_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITableCreation_CreateTable(This,pUnkOuter,pTableID,cColumnDescs,rgColumnDescs,riid,cPropertySets,rgPropertySets,ppTableID,ppRowset)	\
    (This)->lpVtbl -> CreateTable(This,pUnkOuter,pTableID,cColumnDescs,rgColumnDescs,riid,cPropertySets,rgPropertySets,ppTableID,ppRowset)

#define ITableCreation_DropTable(This,pTableID)	\
    (This)->lpVtbl -> DropTable(This,pTableID)

#define ITableCreation_AddColumn(This,pTableID,pColumnDesc,ppColumnID)	\
    (This)->lpVtbl -> AddColumn(This,pTableID,pColumnDesc,ppColumnID)

#define ITableCreation_DropColumn(This,pTableID,pColumnID)	\
    (This)->lpVtbl -> DropColumn(This,pTableID,pColumnID)


#define ITableCreation_GetTableDefinition(This,pTableID,pcColumnDescs,prgColumnDescs,pcPropertySets,prgPropertySets,pcConstraintDescs,prgConstraintDescs,ppwszStringBuffer)	\
    (This)->lpVtbl -> GetTableDefinition(This,pTableID,pcColumnDescs,prgColumnDescs,pcPropertySets,prgPropertySets,pcConstraintDescs,prgConstraintDescs,ppwszStringBuffer)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [local] */ HRESULT STDMETHODCALLTYPE ITableCreation_GetTableDefinition_Proxy( 
    ITableCreation  * This,
    /* [in] */ DBID  *pTableID,
    /* [out] */ DBORDINAL *pcColumnDescs,
    /* [size_is][size_is][out] */ DBCOLUMNDESC  * prgColumnDescs[  ],
    /* [out] */ ULONG  *pcPropertySets,
    /* [size_is][size_is][out] */ DBPROPSET  * prgPropertySets[  ],
    /* [out] */ ULONG  *pcConstraintDescs,
    /* [size_is][size_is][out] */ DBCONSTRAINTDESC  * prgConstraintDescs[  ],
    /* [out] */ OLECHAR  * *ppwszStringBuffer);


void __RPC_STUB ITableCreation_GetTableDefinition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITableCreation_INTERFACE_DEFINED__ */


#ifndef __ITableDefinitionWithConstraints_INTERFACE_DEFINED__
#define __ITableDefinitionWithConstraints_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITableDefinitionWithConstraints
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object][local] */ 



EXTERN_C const IID IID_ITableDefinitionWithConstraints;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733aab-2a1c-11ce-ade5-00aa0044773d")
    ITableDefinitionWithConstraints : public ITableCreation
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddConstraint( 
            /* [in] */ DBID  *pTableID,
            /* [in] */ DBCONSTRAINTDESC  *pConstraintDesc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateTableWithConstraints( 
            /* [in] */ IUnknown  *pUnkOuter,
            /* [in] */ DBID  *pTableID,
            /* [in] */ DBORDINAL cColumnDescs,
            /* [out][size_is][in] */ DBCOLUMNDESC  rgColumnDescs[  ],
            /* [in] */ ULONG cConstraintDescs,
            /* [size_is][in] */ DBCONSTRAINTDESC  rgConstraintDescs[  ],
            /* [in] */ REFIID riid,
            /* [in] */ ULONG cPropertySets,
            /* [out][size_is][in] */ DBPROPSET  rgPropertySets[  ],
            /* [out] */ DBID  * *ppTableID,
            /* [out] */ IUnknown  * *ppRowset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DropConstraint( 
            /* [in] */ DBID  *pTableID,
            /* [in] */ DBID  *pConstraintID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITableDefinitionWithConstraintsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            ITableDefinitionWithConstraints  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            ITableDefinitionWithConstraints  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            ITableDefinitionWithConstraints  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *CreateTable )( 
            ITableDefinitionWithConstraints  * This,
            /* [in] */ IUnknown  *pUnkOuter,
            /* [in] */ DBID  *pTableID,
            /* [in] */ DBORDINAL cColumnDescs,
            /* [size_is][in] */ const DBCOLUMNDESC  rgColumnDescs[  ],
            /* [in] */ REFIID riid,
            /* [in] */ ULONG cPropertySets,
            /* [size_is][out][in] */ DBPROPSET  rgPropertySets[  ],
            /* [out] */ DBID  * *ppTableID,
            /* [iid_is][out] */ IUnknown  * *ppRowset);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *DropTable )( 
            ITableDefinitionWithConstraints  * This,
            /* [unique][in] */ DBID  *pTableID);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *AddColumn )( 
            ITableDefinitionWithConstraints  * This,
            /* [in] */ DBID  *pTableID,
            /* [out][in] */ DBCOLUMNDESC  *pColumnDesc,
            /* [out] */ DBID  * *ppColumnID);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *DropColumn )( 
            ITableDefinitionWithConstraints  * This,
            /* [unique][in] */ DBID  *pTableID,
            /* [unique][in] */ DBID  *pColumnID);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetTableDefinition )( 
            ITableDefinitionWithConstraints  * This,
            /* [in] */ DBID  *pTableID,
            /* [out] */ DBORDINAL *pcColumnDescs,
            /* [size_is][size_is][out] */ DBCOLUMNDESC  * prgColumnDescs[  ],
            /* [out] */ ULONG  *pcPropertySets,
            /* [size_is][size_is][out] */ DBPROPSET  * prgPropertySets[  ],
            /* [out] */ ULONG  *pcConstraintDescs,
            /* [size_is][size_is][out] */ DBCONSTRAINTDESC  * prgConstraintDescs[  ],
            /* [out] */ OLECHAR  * *ppwszStringBuffer);
        
        HRESULT ( STDMETHODCALLTYPE  *AddConstraint )( 
            ITableDefinitionWithConstraints  * This,
            /* [in] */ DBID  *pTableID,
            /* [in] */ DBCONSTRAINTDESC  *pConstraintDesc);
        
        HRESULT ( STDMETHODCALLTYPE  *CreateTableWithConstraints )( 
            ITableDefinitionWithConstraints  * This,
            /* [in] */ IUnknown  *pUnkOuter,
            /* [in] */ DBID  *pTableID,
            /* [in] */ DBORDINAL cColumnDescs,
            /* [out][size_is][in] */ DBCOLUMNDESC  rgColumnDescs[  ],
            /* [in] */ ULONG cConstraintDescs,
            /* [size_is][in] */ DBCONSTRAINTDESC  rgConstraintDescs[  ],
            /* [in] */ REFIID riid,
            /* [in] */ ULONG cPropertySets,
            /* [out][size_is][in] */ DBPROPSET  rgPropertySets[  ],
            /* [out] */ DBID  * *ppTableID,
            /* [out] */ IUnknown  * *ppRowset);
        
        HRESULT ( STDMETHODCALLTYPE  *DropConstraint )( 
            ITableDefinitionWithConstraints  * This,
            /* [in] */ DBID  *pTableID,
            /* [in] */ DBID  *pConstraintID);
        
        END_INTERFACE
    } ITableDefinitionWithConstraintsVtbl;

    interface ITableDefinitionWithConstraints
    {
        CONST_VTBL struct ITableDefinitionWithConstraintsVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITableDefinitionWithConstraints_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITableDefinitionWithConstraints_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITableDefinitionWithConstraints_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITableDefinitionWithConstraints_CreateTable(This,pUnkOuter,pTableID,cColumnDescs,rgColumnDescs,riid,cPropertySets,rgPropertySets,ppTableID,ppRowset)	\
    (This)->lpVtbl -> CreateTable(This,pUnkOuter,pTableID,cColumnDescs,rgColumnDescs,riid,cPropertySets,rgPropertySets,ppTableID,ppRowset)

#define ITableDefinitionWithConstraints_DropTable(This,pTableID)	\
    (This)->lpVtbl -> DropTable(This,pTableID)

#define ITableDefinitionWithConstraints_AddColumn(This,pTableID,pColumnDesc,ppColumnID)	\
    (This)->lpVtbl -> AddColumn(This,pTableID,pColumnDesc,ppColumnID)

#define ITableDefinitionWithConstraints_DropColumn(This,pTableID,pColumnID)	\
    (This)->lpVtbl -> DropColumn(This,pTableID,pColumnID)


#define ITableDefinitionWithConstraints_GetTableDefinition(This,pTableID,pcColumnDescs,prgColumnDescs,pcPropertySets,prgPropertySets,pcConstraintDescs,prgConstraintDescs,ppwszStringBuffer)	\
    (This)->lpVtbl -> GetTableDefinition(This,pTableID,pcColumnDescs,prgColumnDescs,pcPropertySets,prgPropertySets,pcConstraintDescs,prgConstraintDescs,ppwszStringBuffer)


#define ITableDefinitionWithConstraints_AddConstraint(This,pTableID,pConstraintDesc)	\
    (This)->lpVtbl -> AddConstraint(This,pTableID,pConstraintDesc)

#define ITableDefinitionWithConstraints_CreateTableWithConstraints(This,pUnkOuter,pTableID,cColumnDescs,rgColumnDescs,cConstraintDescs,rgConstraintDescs,riid,cPropertySets,rgPropertySets,ppTableID,ppRowset)	\
    (This)->lpVtbl -> CreateTableWithConstraints(This,pUnkOuter,pTableID,cColumnDescs,rgColumnDescs,cConstraintDescs,rgConstraintDescs,riid,cPropertySets,rgPropertySets,ppTableID,ppRowset)

#define ITableDefinitionWithConstraints_DropConstraint(This,pTableID,pConstraintID)	\
    (This)->lpVtbl -> DropConstraint(This,pTableID,pConstraintID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITableDefinitionWithConstraints_AddConstraint_Proxy( 
    ITableDefinitionWithConstraints  * This,
    /* [in] */ DBID  *pTableID,
    /* [in] */ DBCONSTRAINTDESC  *pConstraintDesc);


void __RPC_STUB ITableDefinitionWithConstraints_AddConstraint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITableDefinitionWithConstraints_CreateTableWithConstraints_Proxy( 
    ITableDefinitionWithConstraints  * This,
    /* [in] */ IUnknown  *pUnkOuter,
    /* [in] */ DBID  *pTableID,
    /* [in] */ DBORDINAL cColumnDescs,
    /* [out][size_is][in] */ DBCOLUMNDESC  rgColumnDescs[  ],
    /* [in] */ ULONG cConstraintDescs,
    /* [size_is][in] */ DBCONSTRAINTDESC  rgConstraintDescs[  ],
    /* [in] */ REFIID riid,
    /* [in] */ ULONG cPropertySets,
    /* [out][size_is][in] */ DBPROPSET  rgPropertySets[  ],
    /* [out] */ DBID  * *ppTableID,
    /* [out] */ IUnknown  * *ppRowset);


void __RPC_STUB ITableDefinitionWithConstraints_CreateTableWithConstraints_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITableDefinitionWithConstraints_DropConstraint_Proxy( 
    ITableDefinitionWithConstraints  * This,
    /* [in] */ DBID  *pTableID,
    /* [in] */ DBID  *pConstraintID);


void __RPC_STUB ITableDefinitionWithConstraints_DropConstraint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITableDefinitionWithConstraints_INTERFACE_DEFINED__ */

#ifndef UNDER_CE

#ifndef __IRow_INTERFACE_DEFINED__
#define __IRow_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRow
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object][local] */ 



EXTERN_C const IID IID_IRow;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733ab4-2a1c-11ce-ade5-00aa0044773d")
    IRow : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetColumns( 
            /* [in] */ DBORDINAL cColumns,
            /* [size_is][out][in] */ DBCOLUMNACCESS  rgColumns[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSourceRowset( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown  * *ppRowset,
            /* [out] */ HROW  *phRow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [unique][in] */ IUnknown  *pUnkOuter,
            /* [in] */ DBID  *pColumnID,
            /* [in] */ REFGUID rguidColumnType,
            /* [in] */ DWORD dwBindFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown  * *ppUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRowVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IRow  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IRow  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IRow  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetColumns )( 
            IRow  * This,
            /* [in] */ DBORDINAL cColumns,
            /* [size_is][out][in] */ DBCOLUMNACCESS  rgColumns[  ]);
        
        HRESULT ( STDMETHODCALLTYPE  *GetSourceRowset )( 
            IRow  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown  * *ppRowset,
            /* [out] */ HROW  *phRow);
        
        HRESULT ( STDMETHODCALLTYPE  *Open )( 
            IRow  * This,
            /* [unique][in] */ IUnknown  *pUnkOuter,
            /* [in] */ DBID  *pColumnID,
            /* [in] */ REFGUID rguidColumnType,
            /* [in] */ DWORD dwBindFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown  * *ppUnk);
        
        END_INTERFACE
    } IRowVtbl;

    interface IRow
    {
        CONST_VTBL struct IRowVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRow_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRow_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRow_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRow_GetColumns(This,cColumns,rgColumns)	\
    (This)->lpVtbl -> GetColumns(This,cColumns,rgColumns)

#define IRow_GetSourceRowset(This,riid,ppRowset,phRow)	\
    (This)->lpVtbl -> GetSourceRowset(This,riid,ppRowset,phRow)

#define IRow_Open(This,pUnkOuter,pColumnID,rguidColumnType,dwBindFlags,riid,ppUnk)	\
    (This)->lpVtbl -> Open(This,pUnkOuter,pColumnID,rguidColumnType,dwBindFlags,riid,ppUnk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [local] */ HRESULT STDMETHODCALLTYPE IRow_GetColumns_Proxy( 
    IRow  * This,
    /* [in] */ DBORDINAL cColumns,
    /* [size_is][out][in] */ DBCOLUMNACCESS  rgColumns[  ]);


void __RPC_STUB IRow_GetColumns_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRow_GetSourceRowset_Proxy( 
    IRow  * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown  * *ppRowset,
    /* [out] */ HROW  *phRow);


void __RPC_STUB IRow_GetSourceRowset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRow_Open_Proxy( 
    IRow  * This,
    /* [unique][in] */ IUnknown  *pUnkOuter,
    /* [in] */ DBID  *pColumnID,
    /* [in] */ REFGUID rguidColumnType,
    /* [in] */ DWORD dwBindFlags,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown  * *ppUnk);


void __RPC_STUB IRow_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRow_INTERFACE_DEFINED__ */


#ifndef __IRowChange_INTERFACE_DEFINED__
#define __IRowChange_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRowChange
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object][local] */ 



EXTERN_C const IID IID_IRowChange;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733ab5-2a1c-11ce-ade5-00aa0044773d")
    IRowChange : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SetColumns( 
            /* [in] */ DBORDINAL cColumns,
            /* [size_is][out][in] */ DBCOLUMNACCESS  rgColumns[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRowChangeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IRowChange  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IRowChange  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IRowChange  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *SetColumns )( 
            IRowChange  * This,
            /* [in] */ DBORDINAL cColumns,
            /* [size_is][out][in] */ DBCOLUMNACCESS  rgColumns[  ]);
        
        END_INTERFACE
    } IRowChangeVtbl;

    interface IRowChange
    {
        CONST_VTBL struct IRowChangeVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRowChange_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRowChange_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRowChange_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRowChange_SetColumns(This,cColumns,rgColumns)	\
    (This)->lpVtbl -> SetColumns(This,cColumns,rgColumns)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [local] */ HRESULT STDMETHODCALLTYPE IRowChange_SetColumns_Proxy( 
    IRowChange  * This,
    /* [in] */ DBORDINAL cColumns,
    /* [size_is][out][in] */ DBCOLUMNACCESS  rgColumns[  ]);


void __RPC_STUB IRowChange_SetColumns_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRowChange_INTERFACE_DEFINED__ */


#ifndef __IRowSchemaChange_INTERFACE_DEFINED__
#define __IRowSchemaChange_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRowSchemaChange
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object][local] */ 



EXTERN_C const IID IID_IRowSchemaChange;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733aae-2a1c-11ce-ade5-00aa0044773d")
    IRowSchemaChange : public IRowChange
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DeleteColumns( 
            /* [in] */ DBORDINAL cColumns,
            /* [size_is][in] */ const DBID  rgColumnIDs[  ],
            /* [size_is][out][in] */ DBSTATUS  rgdwStatus[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddColumns( 
            /* [in] */ DBORDINAL cColumns,
            /* [size_is][in] */ const DBCOLUMNINFO  rgNewColumnInfo[  ],
            /* [size_is][out][in] */ DBCOLUMNACCESS  rgColumns[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRowSchemaChangeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IRowSchemaChange  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IRowSchemaChange  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IRowSchemaChange  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *SetColumns )( 
            IRowSchemaChange  * This,
            /* [in] */ DBORDINAL cColumns,
            /* [size_is][out][in] */ DBCOLUMNACCESS  rgColumns[  ]);
        
        HRESULT ( STDMETHODCALLTYPE  *DeleteColumns )( 
            IRowSchemaChange  * This,
            /* [in] */ DBORDINAL cColumns,
            /* [size_is][in] */ const DBID  rgColumnIDs[  ],
            /* [size_is][out][in] */ DBSTATUS  rgdwStatus[  ]);
        
        HRESULT ( STDMETHODCALLTYPE  *AddColumns )( 
            IRowSchemaChange  * This,
            /* [in] */ DBORDINAL cColumns,
            /* [size_is][in] */ const DBCOLUMNINFO  rgNewColumnInfo[  ],
            /* [size_is][out][in] */ DBCOLUMNACCESS  rgColumns[  ]);
        
        END_INTERFACE
    } IRowSchemaChangeVtbl;

    interface IRowSchemaChange
    {
        CONST_VTBL struct IRowSchemaChangeVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRowSchemaChange_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRowSchemaChange_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRowSchemaChange_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRowSchemaChange_SetColumns(This,cColumns,rgColumns)	\
    (This)->lpVtbl -> SetColumns(This,cColumns,rgColumns)


#define IRowSchemaChange_DeleteColumns(This,cColumns,rgColumnIDs,rgdwStatus)	\
    (This)->lpVtbl -> DeleteColumns(This,cColumns,rgColumnIDs,rgdwStatus)

#define IRowSchemaChange_AddColumns(This,cColumns,rgNewColumnInfo,rgColumns)	\
    (This)->lpVtbl -> AddColumns(This,cColumns,rgNewColumnInfo,rgColumns)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRowSchemaChange_DeleteColumns_Proxy( 
    IRowSchemaChange  * This,
    /* [in] */ DBORDINAL cColumns,
    /* [size_is][in] */ const DBID  rgColumnIDs[  ],
    /* [size_is][out][in] */ DBSTATUS  rgdwStatus[  ]);


void __RPC_STUB IRowSchemaChange_DeleteColumns_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRowSchemaChange_AddColumns_Proxy( 
    IRowSchemaChange  * This,
    /* [in] */ DBORDINAL cColumns,
    /* [size_is][in] */ const DBCOLUMNINFO  rgNewColumnInfo[  ],
    /* [size_is][out][in] */ DBCOLUMNACCESS  rgColumns[  ]);


void __RPC_STUB IRowSchemaChange_AddColumns_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRowSchemaChange_INTERFACE_DEFINED__ */


#ifndef __IGetRow_INTERFACE_DEFINED__
#define __IGetRow_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IGetRow
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object][local] */ 



EXTERN_C const IID IID_IGetRow;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733aaf-2a1c-11ce-ade5-00aa0044773d")
    IGetRow : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRowFromHROW( 
            /* [unique][in] */ IUnknown  *pUnkOuter,
            /* [in] */ HROW hRow,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown  * *ppUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetURLFromHROW( 
            /* [in] */ HROW hRow,
            /* [out] */ LPOLESTR  *ppwszURL) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGetRowVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IGetRow  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IGetRow  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IGetRow  * This);
        
        HRESULT ( STDMETHODCALLTYPE  *GetRowFromHROW )( 
            IGetRow  * This,
            /* [unique][in] */ IUnknown  *pUnkOuter,
            /* [in] */ HROW hRow,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown  * *ppUnk);
        
        HRESULT ( STDMETHODCALLTYPE  *GetURLFromHROW )( 
            IGetRow  * This,
            /* [in] */ HROW hRow,
            /* [out] */ LPOLESTR  *ppwszURL);
        
        END_INTERFACE
    } IGetRowVtbl;

    interface IGetRow
    {
        CONST_VTBL struct IGetRowVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGetRow_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGetRow_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGetRow_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGetRow_GetRowFromHROW(This,pUnkOuter,hRow,riid,ppUnk)	\
    (This)->lpVtbl -> GetRowFromHROW(This,pUnkOuter,hRow,riid,ppUnk)

#define IGetRow_GetURLFromHROW(This,hRow,ppwszURL)	\
    (This)->lpVtbl -> GetURLFromHROW(This,hRow,ppwszURL)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IGetRow_GetRowFromHROW_Proxy( 
    IGetRow  * This,
    /* [unique][in] */ IUnknown  *pUnkOuter,
    /* [in] */ HROW hRow,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown  * *ppUnk);


void __RPC_STUB IGetRow_GetRowFromHROW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGetRow_GetURLFromHROW_Proxy( 
    IGetRow  * This,
    /* [in] */ HROW hRow,
    /* [out] */ LPOLESTR  *ppwszURL);


void __RPC_STUB IGetRow_GetURLFromHROW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGetRow_INTERFACE_DEFINED__ */


#ifndef __IBindResource_INTERFACE_DEFINED__
#define __IBindResource_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IBindResource
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IBindResource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733ab1-2a1c-11ce-ade5-00aa0044773d")
    IBindResource : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Bind( 
            /* [in] */ IUnknown  *pUnkOuter,
            /* [in] */ LPCOLESTR pwszURL,
            /* [in] */ DBBINDURLFLAG dwBindURLFlags,
            /* [in] */ REFGUID rguid,
            /* [in] */ REFIID riid,
            /* [in] */ IAuthenticate  *pAuthenticate,
            /* [unique][out][in] */ DBIMPLICITSESSION  *pImplSession,
            /* [out] */ DBBINDURLSTATUS  *pdwBindStatus,
            /* [iid_is][out] */ IUnknown  * *ppUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBindResourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IBindResource  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IBindResource  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IBindResource  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *Bind )( 
            IBindResource  * This,
            /* [in] */ IUnknown  *pUnkOuter,
            /* [in] */ LPCOLESTR pwszURL,
            /* [in] */ DBBINDURLFLAG dwBindURLFlags,
            /* [in] */ REFGUID rguid,
            /* [in] */ REFIID riid,
            /* [in] */ IAuthenticate  *pAuthenticate,
            /* [unique][out][in] */ DBIMPLICITSESSION  *pImplSession,
            /* [out] */ DBBINDURLSTATUS  *pdwBindStatus,
            /* [iid_is][out] */ IUnknown  * *ppUnk);
        
        END_INTERFACE
    } IBindResourceVtbl;

    interface IBindResource
    {
        CONST_VTBL struct IBindResourceVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBindResource_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBindResource_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBindResource_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBindResource_Bind(This,pUnkOuter,pwszURL,dwBindURLFlags,rguid,riid,pAuthenticate,pImplSession,pdwBindStatus,ppUnk)	\
    (This)->lpVtbl -> Bind(This,pUnkOuter,pwszURL,dwBindURLFlags,rguid,riid,pAuthenticate,pImplSession,pdwBindStatus,ppUnk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindResource_RemoteBind_Proxy( 
    IBindResource  * This,
    /* [in] */ IUnknown  *pUnkOuter,
    /* [in] */ LPCOLESTR pwszURL,
    /* [in] */ DBBINDURLFLAG dwBindURLFlags,
    /* [in] */ REFGUID rguid,
    /* [in] */ REFIID riid,
    /* [in] */ IAuthenticate  *pAuthenticate,
    /* [unique][out][in] */ DBIMPLICITSESSION  *pImplSession,
    /* [out] */ DBBINDURLSTATUS  *pdwBindStatus,
    /* [iid_is][out] */ IUnknown  * *ppUnk);


void __RPC_STUB IBindResource_RemoteBind_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBindResource_INTERFACE_DEFINED__ */


#ifndef __IScopedOperations_INTERFACE_DEFINED__
#define __IScopedOperations_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IScopedOperations
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 


typedef DWORD DBCOPYFLAGS;


enum DBCOPYFLAGSENUM
    {	DBCOPY_ASYNC	= 0x100,
	DBCOPY_REPLACE_EXISTING	= 0x200,
	DBCOPY_ALLOW_EMULATION	= 0x400,
	DBCOPY_NON_RECURSIVE	= 0x800,
	DBCOPY_ATOMIC	= 0x1000
    };
typedef DWORD DBMOVEFLAGS;


enum DBMOVEFLAGSENUM
    {	DBMOVE_REPLACE_EXISTING	= 0x1,
	DBMOVE_ASYNC	= 0x100,
	DBMOVE_DONT_UPDATE_LINKS	= 0x200,
	DBMOVE_ALLOW_EMULATION	= 0x400,
	DBMOVE_ATOMIC	= 0x1000
    };
typedef DWORD DBDELETEFLAGS;


enum DBDELETEFLAGSENUM
    {	DBDELETE_ASYNC	= 0x100,
	DBDELETE_ATOMIC	= 0x1000
    };

EXTERN_C const IID IID_IScopedOperations;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733ab0-2a1c-11ce-ade5-00aa0044773d")
    IScopedOperations : public IBindResource
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Copy( 
            /* [in] */ DBCOUNTITEM cRows,
            /* [size_is][in] */ LPCOLESTR  rgpwszSourceURLs[  ],
            /* [size_is][in] */ LPCOLESTR  rgpwszDestURLs[  ],
            /* [in] */ DWORD dwCopyFlags,
            /* [unique][in] */ IAuthenticate  *pAuthenticate,
            /* [size_is][out][in] */ DBSTATUS  rgdwStatus[  ],
            /* [size_is][out] */ LPOLESTR  rgpwszNewURLs[  ],
            /* [out] */ OLECHAR  * *ppStringsBuffer) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Move( 
            /* [in] */ DBCOUNTITEM cRows,
            /* [size_is][in] */ LPCOLESTR  rgpwszSourceURLs[  ],
            /* [size_is][in] */ LPCOLESTR  rgpwszDestURLs[  ],
            /* [in] */ DWORD dwMoveFlags,
            /* [unique][in] */ IAuthenticate  *pAuthenticate,
            /* [size_is][out][in] */ DBSTATUS  rgdwStatus[  ],
            /* [size_is][out] */ LPOLESTR  rgpwszNewURLs[  ],
            /* [out] */ OLECHAR  * *ppStringsBuffer) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ DBCOUNTITEM cRows,
            /* [size_is][in] */ LPCOLESTR  rgpwszURLs[  ],
            /* [in] */ DWORD dwDeleteFlags,
            /* [size_is][out][in] */ DBSTATUS  rgdwStatus[  ]) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE OpenRowset( 
            /* [in] */ IUnknown  *pUnkOuter,
            /* [unique][in] */ DBID  *pTableID,
            /* [unique][in] */ DBID  *pIndexID,
            /* [in] */ REFIID riid,
            /* [in] */ ULONG cPropertySets,
            /* [size_is][out][in] */ DBPROPSET  rgPropertySets[  ],
            /* [iid_is][out] */ IUnknown  * *ppRowset) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IScopedOperationsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IScopedOperations  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IScopedOperations  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IScopedOperations  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *Bind )( 
            IScopedOperations  * This,
            /* [in] */ IUnknown  *pUnkOuter,
            /* [in] */ LPCOLESTR pwszURL,
            /* [in] */ DBBINDURLFLAG dwBindURLFlags,
            /* [in] */ REFGUID rguid,
            /* [in] */ REFIID riid,
            /* [in] */ IAuthenticate  *pAuthenticate,
            /* [unique][out][in] */ DBIMPLICITSESSION  *pImplSession,
            /* [out] */ DBBINDURLSTATUS  *pdwBindStatus,
            /* [iid_is][out] */ IUnknown  * *ppUnk);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *Copy )( 
            IScopedOperations  * This,
            /* [in] */ DBCOUNTITEM cRows,
            /* [size_is][in] */ LPCOLESTR  rgpwszSourceURLs[  ],
            /* [size_is][in] */ LPCOLESTR  rgpwszDestURLs[  ],
            /* [in] */ DWORD dwCopyFlags,
            /* [unique][in] */ IAuthenticate  *pAuthenticate,
            /* [size_is][out][in] */ DBSTATUS  rgdwStatus[  ],
            /* [size_is][out] */ LPOLESTR  rgpwszNewURLs[  ],
            /* [out] */ OLECHAR  * *ppStringsBuffer);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *Move )( 
            IScopedOperations  * This,
            /* [in] */ DBCOUNTITEM cRows,
            /* [size_is][in] */ LPCOLESTR  rgpwszSourceURLs[  ],
            /* [size_is][in] */ LPCOLESTR  rgpwszDestURLs[  ],
            /* [in] */ DWORD dwMoveFlags,
            /* [unique][in] */ IAuthenticate  *pAuthenticate,
            /* [size_is][out][in] */ DBSTATUS  rgdwStatus[  ],
            /* [size_is][out] */ LPOLESTR  rgpwszNewURLs[  ],
            /* [out] */ OLECHAR  * *ppStringsBuffer);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *Delete )( 
            IScopedOperations  * This,
            /* [in] */ DBCOUNTITEM cRows,
            /* [size_is][in] */ LPCOLESTR  rgpwszURLs[  ],
            /* [in] */ DWORD dwDeleteFlags,
            /* [size_is][out][in] */ DBSTATUS  rgdwStatus[  ]);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *OpenRowset )( 
            IScopedOperations  * This,
            /* [in] */ IUnknown  *pUnkOuter,
            /* [unique][in] */ DBID  *pTableID,
            /* [unique][in] */ DBID  *pIndexID,
            /* [in] */ REFIID riid,
            /* [in] */ ULONG cPropertySets,
            /* [size_is][out][in] */ DBPROPSET  rgPropertySets[  ],
            /* [iid_is][out] */ IUnknown  * *ppRowset);
        
        END_INTERFACE
    } IScopedOperationsVtbl;

    interface IScopedOperations
    {
        CONST_VTBL struct IScopedOperationsVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IScopedOperations_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IScopedOperations_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IScopedOperations_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IScopedOperations_Bind(This,pUnkOuter,pwszURL,dwBindURLFlags,rguid,riid,pAuthenticate,pImplSession,pdwBindStatus,ppUnk)	\
    (This)->lpVtbl -> Bind(This,pUnkOuter,pwszURL,dwBindURLFlags,rguid,riid,pAuthenticate,pImplSession,pdwBindStatus,ppUnk)


#define IScopedOperations_Copy(This,cRows,rgpwszSourceURLs,rgpwszDestURLs,dwCopyFlags,pAuthenticate,rgdwStatus,rgpwszNewURLs,ppStringsBuffer)	\
    (This)->lpVtbl -> Copy(This,cRows,rgpwszSourceURLs,rgpwszDestURLs,dwCopyFlags,pAuthenticate,rgdwStatus,rgpwszNewURLs,ppStringsBuffer)

#define IScopedOperations_Move(This,cRows,rgpwszSourceURLs,rgpwszDestURLs,dwMoveFlags,pAuthenticate,rgdwStatus,rgpwszNewURLs,ppStringsBuffer)	\
    (This)->lpVtbl -> Move(This,cRows,rgpwszSourceURLs,rgpwszDestURLs,dwMoveFlags,pAuthenticate,rgdwStatus,rgpwszNewURLs,ppStringsBuffer)

#define IScopedOperations_Delete(This,cRows,rgpwszURLs,dwDeleteFlags,rgdwStatus)	\
    (This)->lpVtbl -> Delete(This,cRows,rgpwszURLs,dwDeleteFlags,rgdwStatus)

#define IScopedOperations_OpenRowset(This,pUnkOuter,pTableID,pIndexID,riid,cPropertySets,rgPropertySets,ppRowset)	\
    (This)->lpVtbl -> OpenRowset(This,pUnkOuter,pTableID,pIndexID,riid,cPropertySets,rgPropertySets,ppRowset)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IScopedOperations_RemoteCopy_Proxy( 
    IScopedOperations  * This,
    /* [in] */ DBCOUNTITEM cRows,
    /* [size_is][in] */ LPCOLESTR  *rgpwszSourceURLs,
    /* [size_is][in] */ LPCOLESTR  *rgpwszDestURLs,
    /* [in] */ DWORD dwCopyFlags,
    /* [in] */ IAuthenticate  *pAuthenticate,
    /* [size_is][out] */ DBSTATUS  *rgdwStatus,
    /* [size_is][size_is][out] */ DBBYTEOFFSET **prgulNewURLOffsets,
    /* [out][in] */ ULONG  *pcbStringsBuffer,
    /* [size_is][size_is][unique][out][in] */ OLECHAR  * *ppStringsBuffer);


void __RPC_STUB IScopedOperations_RemoteCopy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IScopedOperations_RemoteMove_Proxy( 
    IScopedOperations  * This,
    /* [in] */ DBCOUNTITEM cRows,
    /* [size_is][in] */ LPCOLESTR  *rgpwszSourceURLs,
    /* [size_is][in] */ LPCOLESTR  *rgpwszDestURLs,
    /* [in] */ DWORD dwMoveFlags,
    /* [in] */ IAuthenticate  *pAuthenticate,
    /* [size_is][out] */ DBSTATUS  *rgdwStatus,
    /* [size_is][size_is][out] */ DBBYTEOFFSET **prgulNewURLOffsets,
    /* [out][in] */ ULONG  *pcbStringsBuffer,
    /* [size_is][size_is][unique][out][in] */ OLECHAR  * *ppStringsBuffer);


void __RPC_STUB IScopedOperations_RemoteMove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IScopedOperations_RemoteDelete_Proxy( 
    IScopedOperations  * This,
    /* [in] */ DBCOUNTITEM cRows,
    /* [size_is][in] */ LPCOLESTR  *rgpwszURLs,
    /* [in] */ DWORD dwDeleteFlags,
    /* [size_is][out] */ DBSTATUS  *rgdwStatus);


void __RPC_STUB IScopedOperations_RemoteDelete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IScopedOperations_RemoteOpenRowset_Proxy( 
    IScopedOperations  * This,
    /* [in] */ IUnknown  *pUnkOuter,
    /* [unique][in] */ DBID  *pTableID,
    /* [unique][in] */ DBID  *pIndexID,
    /* [in] */ REFIID riid,
    /* [in] */ ULONG cPropertySets,
    /* [size_is][unique][in] */ DBPROPSET  *rgPropertySets,
    /* [iid_is][unique][out][in] */ IUnknown  * *ppRowset,
    /* [in] */ ULONG cTotalProps,
    /* [size_is][out] */ DBPROPSTATUS  *rgPropStatus);


void __RPC_STUB IScopedOperations_RemoteOpenRowset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IScopedOperations_INTERFACE_DEFINED__ */


#ifndef __ICreateRow_INTERFACE_DEFINED__
#define __ICreateRow_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICreateRow
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_ICreateRow;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733ab2-2a1c-11ce-ade5-00aa0044773d")
    ICreateRow : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CreateRow( 
            /* [unique][in] */ IUnknown  *pUnkOuter,
            /* [in] */ LPCOLESTR pwszURL,
            /* [in] */ DBBINDURLFLAG dwBindURLFlags,
            /* [in] */ REFGUID rguid,
            /* [in] */ REFIID riid,
            /* [unique][in] */ IAuthenticate  *pAuthenticate,
            /* [unique][out][in] */ DBIMPLICITSESSION  *pImplSession,
            /* [out][in] */ DBBINDURLSTATUS  *pdwBindStatus,
            /* [out] */ LPOLESTR  *ppwszNewURL,
            /* [iid_is][out] */ IUnknown  * *ppUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICreateRowVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            ICreateRow  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            ICreateRow  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            ICreateRow  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *CreateRow )( 
            ICreateRow  * This,
            /* [unique][in] */ IUnknown  *pUnkOuter,
            /* [in] */ LPCOLESTR pwszURL,
            /* [in] */ DBBINDURLFLAG dwBindURLFlags,
            /* [in] */ REFGUID rguid,
            /* [in] */ REFIID riid,
            /* [unique][in] */ IAuthenticate  *pAuthenticate,
            /* [unique][out][in] */ DBIMPLICITSESSION  *pImplSession,
            /* [out][in] */ DBBINDURLSTATUS  *pdwBindStatus,
            /* [out] */ LPOLESTR  *ppwszNewURL,
            /* [iid_is][out] */ IUnknown  * *ppUnk);
        
        END_INTERFACE
    } ICreateRowVtbl;

    interface ICreateRow
    {
        CONST_VTBL struct ICreateRowVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICreateRow_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICreateRow_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICreateRow_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICreateRow_CreateRow(This,pUnkOuter,pwszURL,dwBindURLFlags,rguid,riid,pAuthenticate,pImplSession,pdwBindStatus,ppwszNewURL,ppUnk)	\
    (This)->lpVtbl -> CreateRow(This,pUnkOuter,pwszURL,dwBindURLFlags,rguid,riid,pAuthenticate,pImplSession,pdwBindStatus,ppwszNewURL,ppUnk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE ICreateRow_RemoteCreateRow_Proxy( 
    ICreateRow  * This,
    /* [in] */ IUnknown  *pUnkOuter,
    /* [in] */ LPCOLESTR pwszURL,
    /* [in] */ DBBINDURLFLAG dwBindURLFlags,
    /* [in] */ REFGUID rguid,
    /* [in] */ REFIID riid,
    /* [in] */ IAuthenticate  *pAuthenticate,
    /* [unique][out][in] */ DBIMPLICITSESSION  *pImplSession,
    /* [out] */ DBBINDURLSTATUS  *pdwBindStatus,
    /* [unique][out][in] */ LPOLESTR  *ppwszNewURL,
    /* [iid_is][out] */ IUnknown  * *ppUnk);


void __RPC_STUB ICreateRow_RemoteCreateRow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICreateRow_INTERFACE_DEFINED__ */


#ifndef __IDBBinderProperties_INTERFACE_DEFINED__
#define __IDBBinderProperties_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDBBinderProperties
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IDBBinderProperties;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733ab3-2a1c-11ce-ade5-00aa0044773d")
    IDBBinderProperties : public IDBProperties
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDBBinderPropertiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IDBBinderProperties  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IDBBinderProperties  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IDBBinderProperties  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetProperties )( 
            IDBBinderProperties  * This,
            /* [in] */ ULONG cPropertyIDSets,
            /* [size_is][in] */ const DBPROPIDSET  rgPropertyIDSets[  ],
            /* [out][in] */ ULONG  *pcPropertySets,
            /* [size_is][size_is][out] */ DBPROPSET  * *prgPropertySets);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetPropertyInfo )( 
            IDBBinderProperties  * This,
            /* [in] */ ULONG cPropertyIDSets,
            /* [size_is][in] */ const DBPROPIDSET  rgPropertyIDSets[  ],
            /* [out][in] */ ULONG  *pcPropertyInfoSets,
            /* [size_is][size_is][out] */ DBPROPINFOSET  * *prgPropertyInfoSets,
            /* [out] */ OLECHAR  * *ppDescBuffer);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *SetProperties )( 
            IDBBinderProperties  * This,
            /* [in] */ ULONG cPropertySets,
            /* [size_is][out][in] */ DBPROPSET  rgPropertySets[  ]);
        
        HRESULT ( STDMETHODCALLTYPE  *Reset )( 
            IDBBinderProperties  * This);
        
        END_INTERFACE
    } IDBBinderPropertiesVtbl;

    interface IDBBinderProperties
    {
        CONST_VTBL struct IDBBinderPropertiesVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDBBinderProperties_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDBBinderProperties_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDBBinderProperties_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDBBinderProperties_GetProperties(This,cPropertyIDSets,rgPropertyIDSets,pcPropertySets,prgPropertySets)	\
    (This)->lpVtbl -> GetProperties(This,cPropertyIDSets,rgPropertyIDSets,pcPropertySets,prgPropertySets)

#define IDBBinderProperties_GetPropertyInfo(This,cPropertyIDSets,rgPropertyIDSets,pcPropertyInfoSets,prgPropertyInfoSets,ppDescBuffer)	\
    (This)->lpVtbl -> GetPropertyInfo(This,cPropertyIDSets,rgPropertyIDSets,pcPropertyInfoSets,prgPropertyInfoSets,ppDescBuffer)

#define IDBBinderProperties_SetProperties(This,cPropertySets,rgPropertySets)	\
    (This)->lpVtbl -> SetProperties(This,cPropertySets,rgPropertySets)


#define IDBBinderProperties_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDBBinderProperties_Reset_Proxy( 
    IDBBinderProperties  * This);


void __RPC_STUB IDBBinderProperties_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDBBinderProperties_INTERFACE_DEFINED__ */


#ifndef __IColumnsInfo2_INTERFACE_DEFINED__
#define __IColumnsInfo2_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IColumnsInfo2
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IColumnsInfo2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733ab8-2a1c-11ce-ade5-00aa0044773d")
    IColumnsInfo2 : public IColumnsInfo
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetRestrictedColumnInfo( 
            /* [in] */ DBORDINAL cColumnIDMasks,
            /* [size_is][in] */ const DBID  rgColumnIDMasks[  ],
            /* [in] */ DWORD dwFlags,
            /* [out][in] */ DBORDINAL *pcColumns,
            /* [size_is][size_is][out] */ DBID  * *prgColumnIDs,
            /* [size_is][size_is][out] */ DBCOLUMNINFO  * *prgColumnInfo,
            /* [out] */ OLECHAR  * *ppStringsBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IColumnsInfo2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IColumnsInfo2  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IColumnsInfo2  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IColumnsInfo2  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetColumnInfo )( 
            IColumnsInfo2  * This,
            /* [out][in] */ DBORDINAL *pcColumns,
            /* [size_is][size_is][out] */ DBCOLUMNINFO  * *prgInfo,
            /* [out] */ OLECHAR  * *ppStringsBuffer);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *MapColumnIDs )( 
            IColumnsInfo2  * This,
            /* [in] */ DBORDINAL cColumnIDs,
            /* [size_is][in] */ const DBID  rgColumnIDs[  ],
            /* [size_is][out] */ DBORDINAL rgColumns[  ]);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetRestrictedColumnInfo )( 
            IColumnsInfo2  * This,
            /* [in] */ DBORDINAL cColumnIDMasks,
            /* [size_is][in] */ const DBID  rgColumnIDMasks[  ],
            /* [in] */ DWORD dwFlags,
            /* [out][in] */ DBORDINAL *pcColumns,
            /* [size_is][size_is][out] */ DBID  * *prgColumnIDs,
            /* [size_is][size_is][out] */ DBCOLUMNINFO  * *prgColumnInfo,
            /* [out] */ OLECHAR  * *ppStringsBuffer);
        
        END_INTERFACE
    } IColumnsInfo2Vtbl;

    interface IColumnsInfo2
    {
        CONST_VTBL struct IColumnsInfo2Vtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IColumnsInfo2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IColumnsInfo2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IColumnsInfo2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IColumnsInfo2_GetColumnInfo(This,pcColumns,prgInfo,ppStringsBuffer)	\
    (This)->lpVtbl -> GetColumnInfo(This,pcColumns,prgInfo,ppStringsBuffer)

#define IColumnsInfo2_MapColumnIDs(This,cColumnIDs,rgColumnIDs,rgColumns)	\
    (This)->lpVtbl -> MapColumnIDs(This,cColumnIDs,rgColumnIDs,rgColumns)


#define IColumnsInfo2_GetRestrictedColumnInfo(This,cColumnIDMasks,rgColumnIDMasks,dwFlags,pcColumns,prgColumnIDs,prgColumnInfo,ppStringsBuffer)	\
    (This)->lpVtbl -> GetRestrictedColumnInfo(This,cColumnIDMasks,rgColumnIDMasks,dwFlags,pcColumns,prgColumnIDs,prgColumnInfo,ppStringsBuffer)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IColumnsInfo2_RemoteGetRestrictedColumnInfo_Proxy( 
    IColumnsInfo2  * This,
    /* [in] */ DBORDINAL cColumnIDMasks,
    /* [size_is][unique][in] */ const DBID  *rgColumnIDMasks,
    /* [in] */ DWORD dwFlags,
    /* [out][in] */ DBORDINAL *pcColumns,
    /* [size_is][size_is][unique][out][in] */ DBID  * *prgColumnIDs,
    /* [size_is][size_is][unique][out][in] */ DBCOLUMNINFO  * *prgColumnInfo,
    /* [size_is][size_is][out] */ DBBYTEOFFSET **prgNameOffsets,
    /* [size_is][size_is][out] */ DBBYTEOFFSET **prgcolumnidOffsets,
    /* [out][in] */ DBLENGTH *pcbStringsBuffer,
    /* [size_is][size_is][unique][out][in] */ OLECHAR  * *ppStringsBuffer);


void __RPC_STUB IColumnsInfo2_RemoteGetRestrictedColumnInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IColumnsInfo2_INTERFACE_DEFINED__ */


#ifndef __IRegisterProvider_INTERFACE_DEFINED__
#define __IRegisterProvider_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRegisterProvider
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IRegisterProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733ab9-2a1c-11ce-ade5-00aa0044773d")
    IRegisterProvider : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetURLMapping( 
            /* [in] */ LPCOLESTR pwszURL,
            /* [in] */ DB_DWRESERVE dwReserved,
            /* [out] */ CLSID  *pclsidProvider) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetURLMapping( 
            /* [unique][in] */ LPCOLESTR pwszURL,
            /* [in] */ DB_DWRESERVE dwReserved,
            /* [unique][in] */ REFCLSID rclsidProvider) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterProvider( 
            /* [unique][in] */ LPCOLESTR pwszURL,
            /* [in] */ DB_DWRESERVE dwReserved,
            /* [unique][in] */ REFCLSID rclsidProvider) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRegisterProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IRegisterProvider  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IRegisterProvider  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IRegisterProvider  * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE  *GetURLMapping )( 
            IRegisterProvider  * This,
            /* [in] */ LPCOLESTR pwszURL,
            /* [in] */ DB_DWRESERVE dwReserved,
            /* [out] */ CLSID  *pclsidProvider);
        
        HRESULT ( STDMETHODCALLTYPE  *SetURLMapping )( 
            IRegisterProvider  * This,
            /* [unique][in] */ LPCOLESTR pwszURL,
            /* [in] */ DB_DWRESERVE dwReserved,
            /* [unique][in] */ REFCLSID rclsidProvider);
        
        HRESULT ( STDMETHODCALLTYPE  *UnregisterProvider )( 
            IRegisterProvider  * This,
            /* [unique][in] */ LPCOLESTR pwszURL,
            /* [in] */ DB_DWRESERVE dwReserved,
            /* [unique][in] */ REFCLSID rclsidProvider);
        
        END_INTERFACE
    } IRegisterProviderVtbl;

    interface IRegisterProvider
    {
        CONST_VTBL struct IRegisterProviderVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRegisterProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRegisterProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRegisterProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRegisterProvider_GetURLMapping(This,pwszURL,dwReserved,pclsidProvider)	\
    (This)->lpVtbl -> GetURLMapping(This,pwszURL,dwReserved,pclsidProvider)

#define IRegisterProvider_SetURLMapping(This,pwszURL,dwReserved,rclsidProvider)	\
    (This)->lpVtbl -> SetURLMapping(This,pwszURL,dwReserved,rclsidProvider)

#define IRegisterProvider_UnregisterProvider(This,pwszURL,dwReserved,rclsidProvider)	\
    (This)->lpVtbl -> UnregisterProvider(This,pwszURL,dwReserved,rclsidProvider)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IRegisterProvider_RemoteGetURLMapping_Proxy( 
    IRegisterProvider  * This,
    /* [in] */ LPCOLESTR pwszURL,
    /* [in] */ DB_DWRESERVE dwReserved,
    /* [out] */ CLSID  *pclsidProvider);


void __RPC_STUB IRegisterProvider_RemoteGetURLMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRegisterProvider_SetURLMapping_Proxy( 
    IRegisterProvider  * This,
    /* [unique][in] */ LPCOLESTR pwszURL,
    /* [in] */ DB_DWRESERVE dwReserved,
    /* [unique][in] */ REFCLSID rclsidProvider);


void __RPC_STUB IRegisterProvider_SetURLMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRegisterProvider_UnregisterProvider_Proxy( 
    IRegisterProvider  * This,
    /* [unique][in] */ LPCOLESTR pwszURL,
    /* [in] */ DB_DWRESERVE dwReserved,
    /* [unique][in] */ REFCLSID rclsidProvider);


void __RPC_STUB IRegisterProvider_UnregisterProvider_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRegisterProvider_INTERFACE_DEFINED__ */
#endif // UNDER_CE

#ifndef __IGetSession_INTERFACE_DEFINED__
#define __IGetSession_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IGetSession
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IGetSession;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733aba-2a1c-11ce-ade5-00aa0044773d")
    IGetSession : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSession( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown  * *ppSession) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGetSessionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IGetSession  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IGetSession  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IGetSession  * This);
        
        HRESULT ( STDMETHODCALLTYPE  *GetSession )( 
            IGetSession  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown  * *ppSession);
        
        END_INTERFACE
    } IGetSessionVtbl;

    interface IGetSession
    {
        CONST_VTBL struct IGetSessionVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGetSession_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGetSession_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGetSession_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGetSession_GetSession(This,riid,ppSession)	\
    (This)->lpVtbl -> GetSession(This,riid,ppSession)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IGetSession_GetSession_Proxy( 
    IGetSession  * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown  * *ppSession);


void __RPC_STUB IGetSession_GetSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGetSession_INTERFACE_DEFINED__ */


#ifndef __IGetSourceRow_INTERFACE_DEFINED__
#define __IGetSourceRow_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IGetSourceRow
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object][local] */ 



EXTERN_C const IID IID_IGetSourceRow;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733abb-2a1c-11ce-ade5-00aa0044773d")
    IGetSourceRow : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSourceRow( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown  * *ppRow) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGetSourceRowVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IGetSourceRow  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IGetSourceRow  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IGetSourceRow  * This);
        
        HRESULT ( STDMETHODCALLTYPE  *GetSourceRow )( 
            IGetSourceRow  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown  * *ppRow);
        
        END_INTERFACE
    } IGetSourceRowVtbl;

    interface IGetSourceRow
    {
        CONST_VTBL struct IGetSourceRowVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGetSourceRow_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGetSourceRow_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGetSourceRow_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGetSourceRow_GetSourceRow(This,riid,ppRow)	\
    (This)->lpVtbl -> GetSourceRow(This,riid,ppRow)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IGetSourceRow_GetSourceRow_Proxy( 
    IGetSourceRow  * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown  * *ppRow);


void __RPC_STUB IGetSourceRow_GetSourceRow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGetSourceRow_INTERFACE_DEFINED__ */


#ifndef __IRowsetCurrentIndex_INTERFACE_DEFINED__
#define __IRowsetCurrentIndex_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRowsetCurrentIndex
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object][local] */ 



EXTERN_C const IID IID_IRowsetCurrentIndex;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733abd-2a1c-11ce-ade5-00aa0044773d")
    IRowsetCurrentIndex : public IRowsetIndex
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetIndex( 
            /* [out] */ DBID  * *ppIndexID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIndex( 
            /* [in] */ DBID  *pIndexID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRowsetCurrentIndexVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE  *QueryInterface )( 
            IRowsetCurrentIndex  * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void  * *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE  *AddRef )( 
            IRowsetCurrentIndex  * This);
        
        ULONG ( STDMETHODCALLTYPE  *Release )( 
            IRowsetCurrentIndex  * This);
        
        HRESULT ( STDMETHODCALLTYPE  *GetIndexInfo )( 
            IRowsetCurrentIndex  * This,
            /* [out][in] */ DBORDINAL *pcKeyColumns,
            /* [size_is][size_is][out] */ DBINDEXCOLUMNDESC  * *prgIndexColumnDesc,
            /* [out][in] */ ULONG *pcIndexPropertySets,
            /* [size_is][size_is][out] */ DBPROPSET **prgIndexPropertySets);
        
        HRESULT ( STDMETHODCALLTYPE  *Seek )( 
            IRowsetCurrentIndex  * This,
            /* [in] */ HACCESSOR hAccessor,
            /* [in] */ DBORDINAL cKeyValues,
            /* [in] */ void  *pData,
            /* [in] */ DBSEEK dwSeekOptions);
        
        HRESULT ( STDMETHODCALLTYPE  *SetRange )( 
            IRowsetCurrentIndex  * This,
            /* [in] */ HACCESSOR hAccessor,
            /* [in] */ DBORDINAL cStartKeyColumns,
            /* [in] */ void  *pStartData,
            /* [in] */ DBORDINAL cEndKeyColumns,
            /* [in] */ void  *pEndData,
            /* [in] */ DBRANGE dwRangeOptions);
        
        HRESULT ( STDMETHODCALLTYPE  *GetIndex )( 
            IRowsetCurrentIndex  * This,
            /* [out] */ DBID  * *ppIndexID);
        
        HRESULT ( STDMETHODCALLTYPE  *SetIndex )( 
            IRowsetCurrentIndex  * This,
            /* [in] */ DBID  *pIndexID);
        
        END_INTERFACE
    } IRowsetCurrentIndexVtbl;

    interface IRowsetCurrentIndex
    {
        CONST_VTBL struct IRowsetCurrentIndexVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRowsetCurrentIndex_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRowsetCurrentIndex_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRowsetCurrentIndex_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRowsetCurrentIndex_GetIndexInfo(This,pcKeyColumns,prgIndexColumnDesc,pcIndexPropertySets,prgIndexPropertySets)	\
    (This)->lpVtbl -> GetIndexInfo(This,pcKeyColumns,prgIndexColumnDesc,pcIndexPropertySets,prgIndexPropertySets)

#define IRowsetCurrentIndex_Seek(This,hAccessor,cKeyValues,pData,dwSeekOptions)	\
    (This)->lpVtbl -> Seek(This,hAccessor,cKeyValues,pData,dwSeekOptions)

#define IRowsetCurrentIndex_SetRange(This,hAccessor,cStartKeyColumns,pStartData,cEndKeyColumns,pEndData,dwRangeOptions)	\
    (This)->lpVtbl -> SetRange(This,hAccessor,cStartKeyColumns,pStartData,cEndKeyColumns,pEndData,dwRangeOptions)


#define IRowsetCurrentIndex_GetIndex(This,ppIndexID)	\
    (This)->lpVtbl -> GetIndex(This,ppIndexID)

#define IRowsetCurrentIndex_SetIndex(This,pIndexID)	\
    (This)->lpVtbl -> SetIndex(This,pIndexID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRowsetCurrentIndex_GetIndex_Proxy( 
    IRowsetCurrentIndex  * This,
    /* [out] */ DBID  * *ppIndexID);


void __RPC_STUB IRowsetCurrentIndex_GetIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRowsetCurrentIndex_SetIndex_Proxy( 
    IRowsetCurrentIndex  * This,
    /* [in] */ DBID  *pIndexID);


void __RPC_STUB IRowsetCurrentIndex_SetIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRowsetCurrentIndex_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_oledb_0242
 * at Thu Nov 12 23:35:28 1998
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 


//
// IID values
//

// IID_IAccessor                 = {0x0c733a8c,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_IRowset                   = {0x0c733a7c,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_IRowsetInfo               = {0x0c733a55,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_IRowsetLocate             = {0x0c733a7d,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_IRowsetResynch            = {0x0c733a84,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_IRowsetScroll             = {0x0c733a7e,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_IRowsetChange             = {0x0c733a05,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_IRowsetUpdate             = {0x0c733a6d,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_IRowsetIdentity           = {0x0c733a09,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_IRowsetNotify             = {0x0c733a83,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_IRowsetIndex              = {0x0c733a82,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_ICommand                  = {0x0c733a63,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_IMultipleResults          = {0x0c733a90,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_IConvertType              = {0x0c733a88,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_ICommandPrepare           = {0x0c733a26,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_ICommandProperties        = {0x0c733a79,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_ICommandText              = {0x0c733a27,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_ICommandWithParameters    = {0x0c733a64,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_IColumnsRowset            = {0x0c733a10,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_IColumnsInfo              = {0x0c733a11,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_IDBCreateCommand          = {0x0c733a1d,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_IDBCreateSession          = {0x0c733a5d,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_ISourcesRowset            = {0x0c733a1e,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_IDBProperties             = {0x0c733a8a,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_IDBInitialize             = {0x0c733a8b,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_IDBInfo                   = {0x0c733a89,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_IDBDataSourceAdmin        = {0x0c733a7a,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_ISessionProperties        = {0x0c733a85,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_IIndexDefinition          = {0x0c733a68,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_ITableDefinition          = {0x0c733a86,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_IOpenRowset               = {0x0c733a69,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_IDBSchemaRowset           = {0x0c733a7b,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_IErrorRecords             = {0x0c733a67,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_IErrorLookup              = {0x0c733a66,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_ISQLErrorInfo             = {0x0c733a74,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_IGetDataSource            = {0x0c733a75,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_ITransactionLocal         = {0x0c733a5f,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_ITransactionJoin          = {0x0c733a5e,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_ITransactionObject        = {0x0c733a60,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}

//IID_IChapteredRowset           = {0x0c733a93,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
//IID_IDBAsynchNotify            = {0x0c733a96,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
//IID_IDBAsynchStatus            = {0x0c733a95,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
//IID_IRowsetFind                = {0x0c733a9d,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
//IID_IRowPosition               = {0x0c733a94,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
//IID_IRowPositionChange         = {0x0997a571,0x126e,0x11d0,{0x9f,0x8a,0x00,0xa0,0xc9,0xa0,0x63,0x1e}}
//IID_IViewRowset                = {0x0c733a97,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
//IID_IViewChapter               = {0x0c733a98,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
//IID_IViewSort                  = {0x0c733a9a,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
//IID_IViewFilter                = {0x0c733a9b,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
//IID_IRowsetView                = {0x0c733a99,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}

// IID_IMDDataset                = {0xa07cccd1,0x8148,0x11d0,{0x87,0xbb,0x00,0xc0,0x4f,0xc3,0x39,0x42}}
// IID_IMDFind                   = {0xa07cccd2,0x8148,0x11d0,{0x87,0xbb,0x00,0xc0,0x4f,0xc3,0x39,0x42}}
// IID_IMDRangeRowset            = {0x0c733aa0,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_IAlterTable               = {0x0c733aa5,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_IAlterIndex               = {0x0c733aa6,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_ICommandPersist           = {0x0c733aa7,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_IRowsetChapterMember      = {0x0c733aa8,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_IRowsetRefresh            = {0x0c733aa9,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_IParentRowset             = {0x0c733aaa,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}

// IID_ITrusteeAdmin				= {0c733aa1,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_ITrusteeGroupAdmin		= {0c733aa2,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_IObjectAccessControl		= {0c733aa3,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_ISecurityInfo				= {0c733aa4,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_IRow						= {0c733ab4,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_IRowChange				= {0c733ab5,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_IRowSchemaChange			= {0c733aae,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_IGetRow					= {0c733aaf,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_IScopedOperations			= {0c733ab0,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_IBindResource				= {0c733ab1,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_ICreateRow				= {0c733ab2,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_IDBResetProperties		= {0c733ab3,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_IColumnsInfo2				= {0c733ab8,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_IRegisterProvider 		= {0c733ab9,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_IGetSession		 		= {0c733aba,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_IGetSourceRow		 		= {0c733abb,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_ITableCreation	 		= {0c733abc,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_IRowsetCurrentIndex 		= {0c733abd,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}

extern const OLEDBDECLSPEC IID IID_IAccessor = {0x0c733a8c,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IRowset = {0x0c733a7c,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IRowsetInfo = {0x0c733a55,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IRowsetLocate = {0x0c733a7d,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IRowsetResynch = {0x0c733a84,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IRowsetScroll = {0x0c733a7e,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IChapteredRowset = {0x0c733a93,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IRowsetFind = {0x0c733a9d,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IRowPosition = {0x0c733a94,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IRowPositionChange = {0x0997a571,0x126e,0x11d0,{0x9f,0x8a,0x00,0xa0,0xc9,0xa0,0x63,0x1e}};
extern const OLEDBDECLSPEC IID IID_IViewRowset = {0x0c733a97,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IViewChapter = {0x0c733a98,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IViewSort = {0x0c733a9a,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IViewFilter = {0x0c733a9b,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IRowsetView = {0x0c733a99,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IRowsetExactScroll = {0x0c733a7f,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IRowsetChange = {0x0c733a05,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IRowsetUpdate = {0x0c733a6d,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IRowsetIdentity = {0x0c733a09,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IRowsetNotify = {0x0c733a83,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IRowsetIndex = {0x0c733a82,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_ICommand = {0x0c733a63,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IMultipleResults = {0x0c733a90,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IConvertType = {0x0c733a88,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_ICommandPrepare = {0x0c733a26,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_ICommandProperties = {0x0c733a79,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_ICommandText = {0x0c733a27,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_ICommandWithParameters = {0x0c733a64,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IColumnsRowset = {0x0c733a10,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IColumnsInfo = {0x0c733a11,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IDBCreateCommand = {0x0c733a1d,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IDBCreateSession = {0x0c733a5d,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_ISourcesRowset = {0x0c733a1e,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IDBProperties = {0x0c733a8a,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IDBInitialize = {0x0c733a8b,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IDBInfo = {0x0c733a89,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IDBDataSourceAdmin = {0x0c733a7a,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IDBAsynchNotify = {0x0c733a96,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IDBAsynchStatus = {0x0c733a95,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_ISessionProperties = {0x0c733a85,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IIndexDefinition = {0x0c733a68,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_ITableDefinition = {0x0c733a86,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IOpenRowset = {0x0c733a69,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IDBSchemaRowset = {0x0c733a7b,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IMDDataset = {0xa07cccd1,0x8148,0x11d0,{0x87,0xbb,0x00,0xc0,0x4f,0xc3,0x39,0x42}};
extern const OLEDBDECLSPEC IID IID_IMDFind = {0xa07cccd2,0x8148,0x11d0,{0x87,0xbb,0x00,0xc0,0x4f,0xc3,0x39,0x42}};
extern const OLEDBDECLSPEC IID IID_IMDRangeRowset = {0x0c733aa0,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IAlterTable = {0x0c733aa5,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IAlterIndex = {0x0c733aa6,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IRowsetChapterMember = {0x0c733aa8,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_ICommandPersist = {0x0c733aa7,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IRowsetRefresh = {0x0c733aa9,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IParentRowset = {0x0c733aaa,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IErrorRecords = {0x0c733a67,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IErrorLookup = {0x0c733a66,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_ISQLErrorInfo = {0x0c733a74,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IGetDataSource = {0x0c733a75,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_ITransactionLocal = {0x0c733a5f,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_ITransactionJoin = {0x0c733a5e,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_ITransactionObject = {0x0c733a60,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_ITrusteeAdmin = {0x0c733aa1,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_ITrusteeGroupAdmin = {0x0c733aa2,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IObjectAccessControl = {0x0c733aa3,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_ISecurityInfo = {0x0c733aa4,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_ITableCreation = {0x0c733abc,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_ITableDefinitionWithConstraints = {0x0c733aab,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IRow = {0x0c733ab4,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IRowChange = {0x0c733ab5,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IRowSchemaChange = {0x0c733aae,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IGetRow = {0x0c733aaf,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IBindResource = {0x0c733ab1,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IScopedOperations = {0x0c733ab0,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_ICreateRow = {0x0c733ab2,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IDBBinderProperties = {0x0c733ab3,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IColumnsInfo2 = {0x0c733ab8,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IRegisterProvider = {0x0c733ab9,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IGetSession = {0x0c733aba,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IGetSourceRow = {0x0c733abb,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC IID IID_IRowsetCurrentIndex = {0x0c733abd,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};

#include <poppack.h>     // restore original structure packing


extern RPC_IF_HANDLE __MIDL_itf_oledb_0242_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_oledb_0242_v0_0_s_ifspec;

#ifdef OLEDBPROXY
/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long  *, unsigned long            , BSTR  * ); 
unsigned char  * __RPC_USER  BSTR_UserMarshal(  unsigned long  *, unsigned char  *, BSTR  * ); 
unsigned char  * __RPC_USER  BSTR_UserUnmarshal(unsigned long  *, unsigned char  *, BSTR  * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long  *, BSTR  * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long  *, unsigned long            , VARIANT  * ); 
unsigned char  * __RPC_USER  VARIANT_UserMarshal(  unsigned long  *, unsigned char  *, VARIANT  * ); 
unsigned char  * __RPC_USER  VARIANT_UserUnmarshal(unsigned long  *, unsigned char  *, VARIANT  * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long  *, VARIANT  * ); 

/* [local] */ HRESULT STDMETHODCALLTYPE IAccessor_AddRefAccessor_Proxy( 
    IAccessor  * This,
    /* [in] */ HACCESSOR hAccessor,
    /* [unique][out][in] */ DBREFCOUNT *pcRefCount);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IAccessor_AddRefAccessor_Stub( 
    IAccessor  * This,
    /* [in] */ HACCESSOR hAccessor,
    /* [unique][out][in] */ DBREFCOUNT *pcRefCount,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IAccessor_CreateAccessor_Proxy( 
    IAccessor  * This,
    /* [in] */ DBACCESSORFLAGS dwAccessorFlags,
    /* [in] */ DBCOUNTITEM cBindings,
    /* [size_is][in] */ const DBBINDING  rgBindings[  ],
    /* [in] */ DBLENGTH cbRowSize,
    /* [out] */ HACCESSOR  *phAccessor,
    /* [size_is][out] */ DBBINDSTATUS  rgStatus[  ]);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IAccessor_CreateAccessor_Stub( 
    IAccessor  * This,
    /* [in] */ DBACCESSORFLAGS dwAccessorFlags,
    /* [in] */ DBCOUNTITEM cBindings,
    /* [size_is][unique][in] */ DBBINDING  *rgBindings,
    /* [in] */ DBLENGTH cbRowSize,
    /* [out] */ HACCESSOR  *phAccessor,
    /* [size_is][unique][out][in] */ DBBINDSTATUS  *rgStatus,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IAccessor_GetBindings_Proxy( 
    IAccessor  * This,
    /* [in] */ HACCESSOR hAccessor,
    /* [out] */ DBACCESSORFLAGS  *pdwAccessorFlags,
    /* [out][in] */ DBCOUNTITEM *pcBindings,
    /* [size_is][size_is][out] */ DBBINDING  * *prgBindings);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IAccessor_GetBindings_Stub( 
    IAccessor  * This,
    /* [in] */ HACCESSOR hAccessor,
    /* [out] */ DBACCESSORFLAGS  *pdwAccessorFlags,
    /* [out][in] */ DBCOUNTITEM *pcBindings,
    /* [size_is][size_is][out] */ DBBINDING  * *prgBindings,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IAccessor_ReleaseAccessor_Proxy( 
    IAccessor  * This,
    /* [in] */ HACCESSOR hAccessor,
    /* [unique][out][in] */ DBREFCOUNT *pcRefCount);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IAccessor_ReleaseAccessor_Stub( 
    IAccessor  * This,
    /* [in] */ HACCESSOR hAccessor,
    /* [unique][out][in] */ DBREFCOUNT *pcRefCount,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IRowsetInfo_GetProperties_Proxy( 
    IRowsetInfo  * This,
    /* [in] */ const ULONG cPropertyIDSets,
    /* [size_is][in] */ const DBPROPIDSET  rgPropertyIDSets[  ],
    /* [out][in] */ ULONG  *pcPropertySets,
    /* [size_is][size_is][out] */ DBPROPSET  * *prgPropertySets);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IRowsetInfo_GetProperties_Stub( 
    IRowsetInfo  * This,
    /* [in] */ ULONG cPropertyIDSets,
    /* [size_is][unique][in] */ const DBPROPIDSET  *rgPropertyIDSets,
    /* [out][in] */ ULONG  *pcPropertySets,
    /* [size_is][size_is][out] */ DBPROPSET  * *prgPropertySets,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IRowsetInfo_GetReferencedRowset_Proxy( 
    IRowsetInfo  * This,
    /* [in] */ DBORDINAL iOrdinal,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown  * *ppReferencedRowset);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IRowsetInfo_GetReferencedRowset_Stub( 
    IRowsetInfo  * This,
    /* [in] */ DBORDINAL iOrdinal,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown  * *ppReferencedRowset,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IRowsetInfo_GetSpecification_Proxy( 
    IRowsetInfo  * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown  * *ppSpecification);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IRowsetInfo_GetSpecification_Stub( 
    IRowsetInfo  * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown  * *ppSpecification,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IChapteredRowset_AddRefChapter_Proxy( 
    IChapteredRowset  * This,
    /* [in] */ HCHAPTER hChapter,
    /* [out] */ DBREFCOUNT *pcRefCount);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IChapteredRowset_AddRefChapter_Stub( 
    IChapteredRowset  * This,
    /* [in] */ HCHAPTER hChapter,
    /* [out] */ DBREFCOUNT *pcRefCount,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IChapteredRowset_ReleaseChapter_Proxy( 
    IChapteredRowset  * This,
    /* [in] */ HCHAPTER hChapter,
    /* [out] */ DBREFCOUNT *pcRefCount);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IChapteredRowset_ReleaseChapter_Stub( 
    IChapteredRowset  * This,
    /* [in] */ HCHAPTER hChapter,
    /* [out] */ DBREFCOUNT *pcRefCount,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IRowPosition_ClearRowPosition_Proxy( 
    IRowPosition  * This);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IRowPosition_ClearRowPosition_Stub( 
    IRowPosition  * This,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IRowPosition_GetRowPosition_Proxy( 
    IRowPosition  * This,
    /* [out] */ HCHAPTER  *phChapter,
    /* [out] */ HROW  *phRow,
    /* [out] */ DBPOSITIONFLAGS  *pdwPositionFlags);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IRowPosition_GetRowPosition_Stub( 
    IRowPosition  * This,
    /* [out] */ HCHAPTER  *phChapter,
    /* [out] */ HROW  *phRow,
    /* [out] */ DBPOSITIONFLAGS  *pdwPositionFlags,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IRowPosition_GetRowset_Proxy( 
    IRowPosition  * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown  * *ppRowset);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IRowPosition_GetRowset_Stub( 
    IRowPosition  * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown  * *ppRowset,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IRowPosition_Initialize_Proxy( 
    IRowPosition  * This,
    /* [in] */ IUnknown  *pRowset);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IRowPosition_Initialize_Stub( 
    IRowPosition  * This,
    /* [in] */ IUnknown  *pRowset,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IRowPosition_SetRowPosition_Proxy( 
    IRowPosition  * This,
    /* [in] */ HCHAPTER hChapter,
    /* [in] */ HROW hRow,
    /* [in] */ DBPOSITIONFLAGS dwPositionFlags);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IRowPosition_SetRowPosition_Stub( 
    IRowPosition  * This,
    /* [in] */ HCHAPTER hChapter,
    /* [in] */ HROW hRow,
    /* [in] */ DBPOSITIONFLAGS dwPositionFlags,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IRowPositionChange_OnRowPositionChange_Proxy( 
    IRowPositionChange  * This,
    /* [in] */ DBREASON eReason,
    /* [in] */ DBEVENTPHASE ePhase,
    /* [in] */ BOOL fCantDeny);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IRowPositionChange_OnRowPositionChange_Stub( 
    IRowPositionChange  * This,
    /* [in] */ DBREASON eReason,
    /* [in] */ DBEVENTPHASE ePhase,
    /* [in] */ BOOL fCantDeny,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IViewRowset_GetSpecification_Proxy( 
    IViewRowset  * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown  * *ppObject);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IViewRowset_GetSpecification_Stub( 
    IViewRowset  * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown  * *ppObject,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IViewRowset_OpenViewRowset_Proxy( 
    IViewRowset  * This,
    /* [in] */ IUnknown  *pUnkOuter,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown  * *ppRowset);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IViewRowset_OpenViewRowset_Stub( 
    IViewRowset  * This,
    /* [in] */ IUnknown  *pUnkOuter,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown  * *ppRowset,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IViewChapter_GetSpecification_Proxy( 
    IViewChapter  * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown  * *ppRowset);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IViewChapter_GetSpecification_Stub( 
    IViewChapter  * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown  * *ppRowset,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IViewChapter_OpenViewChapter_Proxy( 
    IViewChapter  * This,
    /* [in] */ HCHAPTER hSource,
    /* [out] */ HCHAPTER  *phViewChapter);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IViewChapter_OpenViewChapter_Stub( 
    IViewChapter  * This,
    /* [in] */ HCHAPTER hSource,
    /* [out] */ HCHAPTER  *phViewChapter,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IViewSort_GetSortOrder_Proxy( 
    IViewSort  * This,
    /* [out] */ DBORDINAL *pcValues,
    /* [out] */ DBORDINAL *prgColumns[  ],
    /* [out] */ DBSORT  * prgOrders[  ]);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IViewSort_GetSortOrder_Stub( 
    IViewSort  * This,
    /* [out][in] */ DBORDINAL *pcValues,
    /* [size_is][size_is][out] */ DBORDINAL **prgColumns,
    /* [size_is][size_is][out] */ DBSORT **prgOrders,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IViewSort_SetSortOrder_Proxy( 
    IViewSort  * This,
    /* [in] */ DBORDINAL cValues,
    /* [size_is][in] */ const DBORDINAL rgColumns[  ],
    /* [size_is][in] */ const DBSORT  rgOrders[  ]);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IViewSort_SetSortOrder_Stub( 
    IViewSort  * This,
    /* [in] */ DBORDINAL cValues,
    /* [size_is][in] */ const DBORDINAL *rgColumns,
    /* [size_is][in] */ const DBSORT  *rgOrders,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IViewFilter_GetFilterBindings_Proxy( 
    IViewFilter  * This,
    /* [out] */ DBCOUNTITEM *pcBindings,
    /* [out] */ DBBINDING  * *prgBindings);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IViewFilter_GetFilterBindings_Stub( 
    IViewFilter  * This,
    /* [out][in] */ DBCOUNTITEM *pcBindings,
    /* [size_is][size_is][out] */ DBBINDING  * *prgBindings,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IRowsetView_CreateView_Proxy( 
    IRowsetView  * This,
    /* [in] */ IUnknown  *pUnkOuter,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown  * *ppView);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IRowsetView_CreateView_Stub( 
    IRowsetView  * This,
    /* [in] */ IUnknown  *pUnkOuter,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown  * *ppView,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IRowsetView_GetView_Proxy( 
    IRowsetView  * This,
    /* [in] */ HCHAPTER hChapter,
    /* [in] */ REFIID riid,
    /* [out] */ HCHAPTER  *phChapterSource,
    /* [iid_is][out] */ IUnknown  * *ppView);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IRowsetView_GetView_Stub( 
    IRowsetView  * This,
    /* [in] */ HCHAPTER hChapter,
    /* [in] */ REFIID riid,
    /* [out] */ HCHAPTER  *phChapterSource,
    /* [iid_is][out] */ IUnknown  * *ppView,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IRowsetIdentity_IsSameRow_Proxy( 
    IRowsetIdentity  * This,
    /* [in] */ HROW hThisRow,
    /* [in] */ HROW hThatRow);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IRowsetIdentity_IsSameRow_Stub( 
    IRowsetIdentity  * This,
    /* [in] */ HROW hThisRow,
    /* [in] */ HROW hThatRow,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IRowsetNotify_OnFieldChange_Proxy( 
    IRowsetNotify  * This,
    /* [in] */ IRowset  *pRowset,
    /* [in] */ HROW hRow,
    /* [in] */ DBORDINAL cColumns,
    /* [size_is][in] */ DBORDINAL rgColumns[  ],
    /* [in] */ DBREASON eReason,
    /* [in] */ DBEVENTPHASE ePhase,
    /* [in] */ BOOL fCantDeny);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IRowsetNotify_OnFieldChange_Stub( 
    IRowsetNotify  * This,
    /* [in] */ IRowset  *pRowset,
    /* [in] */ HROW hRow,
    /* [in] */ DBORDINAL cColumns,
    /* [size_is][in] */ DBORDINAL *rgColumns,
    /* [in] */ DBREASON eReason,
    /* [in] */ DBEVENTPHASE ePhase,
    /* [in] */ BOOL fCantDeny,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IRowsetNotify_OnRowChange_Proxy( 
    IRowsetNotify  * This,
    /* [in] */ IRowset  *pRowset,
    /* [in] */ DBCOUNTITEM cRows,
    /* [size_is][in] */ const HROW  rghRows[  ],
    /* [in] */ DBREASON eReason,
    /* [in] */ DBEVENTPHASE ePhase,
    /* [in] */ BOOL fCantDeny);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IRowsetNotify_OnRowChange_Stub( 
    IRowsetNotify  * This,
    /* [in] */ IRowset  *pRowset,
    /* [in] */ DBCOUNTITEM cRows,
    /* [size_is][in] */ const HROW  *rghRows,
    /* [in] */ DBREASON eReason,
    /* [in] */ DBEVENTPHASE ePhase,
    /* [in] */ BOOL fCantDeny,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IRowsetNotify_OnRowsetChange_Proxy( 
    IRowsetNotify  * This,
    /* [in] */ IRowset  *pRowset,
    /* [in] */ DBREASON eReason,
    /* [in] */ DBEVENTPHASE ePhase,
    /* [in] */ BOOL fCantDeny);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IRowsetNotify_OnRowsetChange_Stub( 
    IRowsetNotify  * This,
    /* [in] */ IRowset  *pRowset,
    /* [in] */ DBREASON eReason,
    /* [in] */ DBEVENTPHASE ePhase,
    /* [in] */ BOOL fCantDeny,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE ICommand_Cancel_Proxy( 
    ICommand  * This);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ICommand_Cancel_Stub( 
    ICommand  * This,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE ICommand_Execute_Proxy( 
    ICommand  * This,
    /* [in] */ IUnknown  *pUnkOuter,
    /* [in] */ REFIID riid,
    /* [out][in] */ DBPARAMS  *pParams,
    /* [out] */ DBROWCOUNT *pcRowsAffected,
    /* [iid_is][out] */ IUnknown  * *ppRowset);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ICommand_Execute_Stub( 
    ICommand  * This,
    /* [in] */ IUnknown  *pUnkOuter,
    /* [in] */ REFIID riid,
    /* [in] */ HACCESSOR hAccessor,
    /* [in] */ DB_UPARAMS cParamSets,
    /* [in] */ ULONG cbData,
    /* [size_is][unique][out][in] */ BYTE  *pbData,
    /* [unique][out][in] */ DBROWCOUNT *pcRowsAffected,
    /* [iid_is][unique][out][in] */ IUnknown  * *ppRowset,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE ICommand_GetDBSession_Proxy( 
    ICommand  * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown  * *ppSession);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ICommand_GetDBSession_Stub( 
    ICommand  * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown  * *ppSession,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IMultipleResults_GetResult_Proxy( 
    IMultipleResults  * This,
    /* [in] */ IUnknown  *pUnkOuter,
    /* [in] */ DBRESULTFLAG lResultFlag,
    /* [in] */ REFIID riid,
    /* [out] */ DBROWCOUNT *pcRowsAffected,
    /* [iid_is][out] */ IUnknown  * *ppRowset);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IMultipleResults_GetResult_Stub( 
    IMultipleResults  * This,
    /* [in] */ IUnknown  *pUnkOuter,
    /* [in] */ DBRESULTFLAG lResultFlag,
    /* [in] */ REFIID riid,
    /* [unique][out][in] */ DBROWCOUNT *pcRowsAffected,
    /* [iid_is][unique][out][in] */ IUnknown  * *ppRowset,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IConvertType_CanConvert_Proxy( 
    IConvertType  * This,
    /* [in] */ DBTYPE wFromType,
    /* [in] */ DBTYPE wToType,
    /* [in] */ DBCONVERTFLAGS dwConvertFlags);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IConvertType_CanConvert_Stub( 
    IConvertType  * This,
    /* [in] */ DBTYPE wFromType,
    /* [in] */ DBTYPE wToType,
    /* [in] */ DBCONVERTFLAGS dwConvertFlags,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE ICommandPrepare_Prepare_Proxy( 
    ICommandPrepare  * This,
    /* [in] */ ULONG cExpectedRuns);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ICommandPrepare_Prepare_Stub( 
    ICommandPrepare  * This,
    /* [in] */ ULONG cExpectedRuns,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE ICommandPrepare_Unprepare_Proxy( 
    ICommandPrepare  * This);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ICommandPrepare_Unprepare_Stub( 
    ICommandPrepare  * This,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE ICommandProperties_GetProperties_Proxy( 
    ICommandProperties  * This,
    /* [in] */ const ULONG cPropertyIDSets,
    /* [size_is][in] */ const DBPROPIDSET  rgPropertyIDSets[  ],
    /* [out][in] */ ULONG  *pcPropertySets,
    /* [size_is][size_is][out] */ DBPROPSET  * *prgPropertySets);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ICommandProperties_GetProperties_Stub( 
    ICommandProperties  * This,
    /* [in] */ const ULONG cPropertyIDSets,
    /* [size_is][unique][in] */ const DBPROPIDSET  *rgPropertyIDSets,
    /* [out][in] */ ULONG  *pcPropertySets,
    /* [size_is][size_is][out] */ DBPROPSET  * *prgPropertySets,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE ICommandProperties_SetProperties_Proxy( 
    ICommandProperties  * This,
    /* [in] */ ULONG cPropertySets,
    /* [size_is][unique][out][in] */ DBPROPSET  rgPropertySets[  ]);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ICommandProperties_SetProperties_Stub( 
    ICommandProperties  * This,
    /* [in] */ ULONG cPropertySets,
    /* [size_is][unique][in] */ DBPROPSET  *rgPropertySets,
    /* [in] */ ULONG cTotalProps,
    /* [size_is][out] */ DBPROPSTATUS  *rgPropStatus,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE ICommandText_GetCommandText_Proxy( 
    ICommandText  * This,
    /* [out][in] */ GUID  *pguidDialect,
    /* [out] */ LPOLESTR  *ppwszCommand);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ICommandText_GetCommandText_Stub( 
    ICommandText  * This,
    /* [unique][out][in] */ GUID  *pguidDialect,
    /* [out] */ LPOLESTR  *ppwszCommand,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE ICommandText_SetCommandText_Proxy( 
    ICommandText  * This,
    /* [in] */ REFGUID rguidDialect,
    /* [unique][in] */ LPCOLESTR pwszCommand);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ICommandText_SetCommandText_Stub( 
    ICommandText  * This,
    /* [in] */ REFGUID rguidDialect,
    /* [unique][in] */ LPCOLESTR pwszCommand,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE ICommandWithParameters_GetParameterInfo_Proxy( 
    ICommandWithParameters  * This,
    /* [out][in] */ DB_UPARAMS *pcParams,
    /* [size_is][size_is][out] */ DBPARAMINFO  * *prgParamInfo,
    /* [out] */ OLECHAR  * *ppNamesBuffer);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ICommandWithParameters_GetParameterInfo_Stub( 
    ICommandWithParameters  * This,
    /* [out][in] */ DB_UPARAMS *pcParams,
    /* [size_is][size_is][out] */ DBPARAMINFO  * *prgParamInfo,
    /* [size_is][size_is][out] */ DBBYTEOFFSET **prgNameOffsets,
    /* [out][in] */ DBLENGTH *pcbNamesBuffer,
    /* [size_is][size_is][unique][out][in] */ OLECHAR  * *ppNamesBuffer,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE ICommandWithParameters_MapParameterNames_Proxy( 
    ICommandWithParameters  * This,
    /* [in] */ DB_UPARAMS cParamNames,
    /* [size_is][in] */ const OLECHAR  * rgParamNames[  ],
    /* [size_is][out] */ DB_LPARAMS rgParamOrdinals[  ]);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ICommandWithParameters_MapParameterNames_Stub( 
    ICommandWithParameters  * This,
    /* [in] */ DB_UPARAMS cParamNames,
    /* [size_is][in] */ LPCOLESTR  *rgParamNames,
    /* [size_is][out] */ DB_LPARAMS *rgParamOrdinals,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE ICommandWithParameters_SetParameterInfo_Proxy( 
    ICommandWithParameters  * This,
    /* [in] */ DB_UPARAMS cParams,
    /* [size_is][unique][in] */ const DB_UPARAMS rgParamOrdinals[  ],
    /* [size_is][unique][in] */ const DBPARAMBINDINFO  rgParamBindInfo[  ]);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ICommandWithParameters_SetParameterInfo_Stub( 
    ICommandWithParameters  * This,
    /* [in] */ DB_UPARAMS cParams,
    /* [size_is][unique][in] */ const DB_UPARAMS *rgParamOrdinals,
    /* [size_is][unique][in] */ const DBPARAMBINDINFO  *rgParamBindInfo,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IColumnsRowset_GetAvailableColumns_Proxy( 
    IColumnsRowset  * This,
    /* [out][in] */ DBORDINAL *pcOptColumns,
    /* [size_is][size_is][out] */ DBID  * *prgOptColumns);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IColumnsRowset_GetAvailableColumns_Stub( 
    IColumnsRowset  * This,
    /* [out][in] */ DBORDINAL *pcOptColumns,
    /* [size_is][size_is][out] */ DBID  * *prgOptColumns,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IColumnsRowset_GetColumnsRowset_Proxy( 
    IColumnsRowset  * This,
    /* [in] */ IUnknown  *pUnkOuter,
    /* [in] */ DBORDINAL cOptColumns,
    /* [size_is][in] */ const DBID  rgOptColumns[  ],
    /* [in] */ REFIID riid,
    /* [in] */ ULONG cPropertySets,
    /* [size_is][out][in] */ DBPROPSET  rgPropertySets[  ],
    /* [iid_is][out] */ IUnknown  * *ppColRowset);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IColumnsRowset_GetColumnsRowset_Stub( 
    IColumnsRowset  * This,
    /* [in] */ IUnknown  *pUnkOuter,
    /* [in] */ DBORDINAL cOptColumns,
    /* [size_is][unique][in] */ const DBID  *rgOptColumns,
    /* [in] */ REFIID riid,
    /* [in] */ ULONG cPropertySets,
    /* [size_is][unique][in] */ DBPROPSET  *rgPropertySets,
    /* [iid_is][out] */ IUnknown  * *ppColRowset,
    /* [in] */ ULONG cTotalProps,
    /* [size_is][out] */ DBPROPSTATUS  *rgPropStatus,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IColumnsInfo_GetColumnInfo_Proxy( 
    IColumnsInfo  * This,
    /* [out][in] */ DBORDINAL *pcColumns,
    /* [size_is][size_is][out] */ DBCOLUMNINFO  * *prgInfo,
    /* [out] */ OLECHAR  * *ppStringsBuffer);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IColumnsInfo_GetColumnInfo_Stub( 
    IColumnsInfo  * This,
    /* [out][in] */ DBORDINAL *pcColumns,
    /* [size_is][size_is][out] */ DBCOLUMNINFO  * *prgInfo,
    /* [size_is][size_is][out] */ DBBYTEOFFSET **prgNameOffsets,
    /* [size_is][size_is][out] */ DBBYTEOFFSET **prgcolumnidOffsets,
    /* [out][in] */ DBLENGTH *pcbStringsBuffer,
    /* [size_is][size_is][unique][out][in] */ OLECHAR  * *ppStringsBuffer,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IColumnsInfo_MapColumnIDs_Proxy( 
    IColumnsInfo  * This,
    /* [in] */ DBORDINAL cColumnIDs,
    /* [size_is][in] */ const DBID  rgColumnIDs[  ],
    /* [size_is][out] */ DBORDINAL rgColumns[  ]);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IColumnsInfo_MapColumnIDs_Stub( 
    IColumnsInfo  * This,
    /* [in] */ DBORDINAL cColumnIDs,
    /* [size_is][in] */ const DBID  *rgColumnIDs,
    /* [size_is][out] */ DBORDINAL *rgColumns,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IDBCreateCommand_CreateCommand_Proxy( 
    IDBCreateCommand  * This,
    /* [in] */ IUnknown  *pUnkOuter,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown  * *ppCommand);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDBCreateCommand_CreateCommand_Stub( 
    IDBCreateCommand  * This,
    /* [in] */ IUnknown  *pUnkOuter,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown  * *ppCommand,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IDBCreateSession_CreateSession_Proxy( 
    IDBCreateSession  * This,
    /* [in] */ IUnknown  *pUnkOuter,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown  * *ppDBSession);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDBCreateSession_CreateSession_Stub( 
    IDBCreateSession  * This,
    /* [in] */ IUnknown  *pUnkOuter,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown  * *ppDBSession,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE ISourcesRowset_GetSourcesRowset_Proxy( 
    ISourcesRowset  * This,
    /* [in] */ IUnknown  *pUnkOuter,
    /* [in] */ REFIID riid,
    /* [in] */ ULONG cPropertySets,
    /* [size_is][unique][out][in] */ DBPROPSET  rgProperties[  ],
    /* [iid_is][out] */ IUnknown  * *ppSourcesRowset);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ISourcesRowset_GetSourcesRowset_Stub( 
    ISourcesRowset  * This,
    /* [in] */ IUnknown  *pUnkOuter,
    /* [in] */ REFIID riid,
    /* [in] */ ULONG cPropertySets,
    /* [size_is][unique][in] */ DBPROPSET  *rgProperties,
    /* [iid_is][out] */ IUnknown  * *ppSourcesRowset,
    /* [in] */ ULONG cTotalProps,
    /* [size_is][out] */ DBPROPSTATUS  *rgPropStatus,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IDBProperties_GetProperties_Proxy( 
    IDBProperties  * This,
    /* [in] */ ULONG cPropertyIDSets,
    /* [size_is][in] */ const DBPROPIDSET  rgPropertyIDSets[  ],
    /* [out][in] */ ULONG  *pcPropertySets,
    /* [size_is][size_is][out] */ DBPROPSET  * *prgPropertySets);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDBProperties_GetProperties_Stub( 
    IDBProperties  * This,
    /* [in] */ ULONG cPropertyIDSets,
    /* [size_is][unique][in] */ const DBPROPIDSET  *rgPropertyIDSets,
    /* [out][in] */ ULONG  *pcPropertySets,
    /* [size_is][size_is][out] */ DBPROPSET  * *prgPropertySets,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IDBProperties_GetPropertyInfo_Proxy( 
    IDBProperties  * This,
    /* [in] */ ULONG cPropertyIDSets,
    /* [size_is][in] */ const DBPROPIDSET  rgPropertyIDSets[  ],
    /* [out][in] */ ULONG  *pcPropertyInfoSets,
    /* [size_is][size_is][out] */ DBPROPINFOSET  * *prgPropertyInfoSets,
    /* [out] */ OLECHAR  * *ppDescBuffer);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDBProperties_GetPropertyInfo_Stub( 
    IDBProperties  * This,
    /* [in] */ ULONG cPropertyIDSets,
    /* [size_is][unique][in] */ const DBPROPIDSET  *rgPropertyIDSets,
    /* [out][in] */ ULONG  *pcPropertyInfoSets,
    /* [size_is][size_is][out] */ DBPROPINFOSET  * *prgPropertyInfoSets,
    /* [out][in] */ ULONG  *pcOffsets,
    /* [size_is][size_is][out] */ DBBYTEOFFSET **prgDescOffsets,
    /* [out][in] */ ULONG  *pcbDescBuffer,
    /* [size_is][size_is][unique][out][in] */ OLECHAR  * *ppDescBuffer,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IDBProperties_SetProperties_Proxy( 
    IDBProperties  * This,
    /* [in] */ ULONG cPropertySets,
    /* [size_is][out][in] */ DBPROPSET  rgPropertySets[  ]);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDBProperties_SetProperties_Stub( 
    IDBProperties  * This,
    /* [in] */ ULONG cPropertySets,
    /* [size_is][unique][in] */ DBPROPSET  *rgPropertySets,
    /* [in] */ ULONG cTotalProps,
    /* [size_is][out] */ DBPROPSTATUS  *rgPropStatus,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IDBInitialize_Initialize_Proxy( 
    IDBInitialize  * This);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDBInitialize_Initialize_Stub( 
    IDBInitialize  * This,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IDBInitialize_Uninitialize_Proxy( 
    IDBInitialize  * This);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDBInitialize_Uninitialize_Stub( 
    IDBInitialize  * This,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IDBInfo_GetKeywords_Proxy( 
    IDBInfo  * This,
    /* [out] */ LPOLESTR  *ppwszKeywords);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDBInfo_GetKeywords_Stub( 
    IDBInfo  * This,
    /* [unique][out][in] */ LPOLESTR  *ppwszKeywords,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IDBInfo_GetLiteralInfo_Proxy( 
    IDBInfo  * This,
    /* [in] */ ULONG cLiterals,
    /* [size_is][in] */ const DBLITERAL  rgLiterals[  ],
    /* [out][in] */ ULONG  *pcLiteralInfo,
    /* [size_is][size_is][out] */ DBLITERALINFO  * *prgLiteralInfo,
    /* [out] */ OLECHAR  * *ppCharBuffer);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDBInfo_GetLiteralInfo_Stub( 
    IDBInfo  * This,
    /* [in] */ ULONG cLiterals,
    /* [size_is][unique][in] */ const DBLITERAL  *rgLiterals,
    /* [out][in] */ ULONG  *pcLiteralInfo,
    /* [size_is][size_is][out] */ DBLITERALINFO  * *prgLiteralInfo,
    /* [size_is][size_is][out] */ DB_UPARAMS **prgLVOffsets,
    /* [size_is][size_is][out] */ DB_UPARAMS **prgICOffsets,
    /* [size_is][size_is][out] */ DB_UPARAMS **prgISCOffsets,
    /* [out][in] */ ULONG  *pcbCharBuffer,
    /* [size_is][size_is][unique][out][in] */ OLECHAR  * *ppCharBuffer,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IDBDataSourceAdmin_CreateDataSource_Proxy( 
    IDBDataSourceAdmin  * This,
    /* [in] */ ULONG cPropertySets,
    /* [size_is][out][in] */ DBPROPSET  rgPropertySets[  ],
    /* [in] */ IUnknown  *pUnkOuter,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown  * *ppDBSession);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDBDataSourceAdmin_CreateDataSource_Stub( 
    IDBDataSourceAdmin  * This,
    /* [in] */ ULONG cPropertySets,
    /* [size_is][unique][in] */ DBPROPSET  *rgPropertySets,
    /* [in] */ IUnknown  *pUnkOuter,
    /* [in] */ REFIID riid,
    /* [iid_is][unique][out][in] */ IUnknown  * *ppDBSession,
    /* [in] */ ULONG cTotalProps,
    /* [size_is][out] */ DBPROPSTATUS  *rgPropStatus,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IDBDataSourceAdmin_DestroyDataSource_Proxy( 
    IDBDataSourceAdmin  * This);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDBDataSourceAdmin_DestroyDataSource_Stub( 
    IDBDataSourceAdmin  * This,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IDBDataSourceAdmin_GetCreationProperties_Proxy( 
    IDBDataSourceAdmin  * This,
    /* [in] */ ULONG cPropertyIDSets,
    /* [size_is][in] */ const DBPROPIDSET  rgPropertyIDSets[  ],
    /* [out][in] */ ULONG  *pcPropertyInfoSets,
    /* [size_is][size_is][out] */ DBPROPINFOSET  * *prgPropertyInfoSets,
    /* [out] */ OLECHAR  * *ppDescBuffer);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDBDataSourceAdmin_GetCreationProperties_Stub( 
    IDBDataSourceAdmin  * This,
    /* [in] */ ULONG cPropertyIDSets,
    /* [size_is][unique][in] */ const DBPROPIDSET  *rgPropertyIDSets,
    /* [out][in] */ ULONG  *pcPropertyInfoSets,
    /* [size_is][size_is][out] */ DBPROPINFOSET  * *prgPropertyInfoSets,
    /* [out][in] */ DBCOUNTITEM *pcOffsets,
    /* [size_is][size_is][out] */ DBBYTEOFFSET **prgDescOffsets,
    /* [out][in] */ ULONG  *pcbDescBuffer,
    /* [size_is][size_is][unique][out][in] */ OLECHAR  * *ppDescBuffer,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IDBDataSourceAdmin_ModifyDataSource_Proxy( 
    IDBDataSourceAdmin  * This,
    /* [in] */ ULONG cPropertySets,
    /* [size_is][in] */ DBPROPSET  rgPropertySets[  ]);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDBDataSourceAdmin_ModifyDataSource_Stub( 
    IDBDataSourceAdmin  * This,
    /* [in] */ ULONG cPropertySets,
    /* [size_is][in] */ DBPROPSET  *rgPropertySets,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IDBAsynchNotify_OnLowResource_Proxy( 
    IDBAsynchNotify  * This,
    /* [in] */ DB_DWRESERVE dwReserved);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDBAsynchNotify_OnLowResource_Stub( 
    IDBAsynchNotify  * This,
    /* [in] */ DB_DWRESERVE dwReserved);
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IDBAsynchNotify_OnProgress_Proxy( 
    IDBAsynchNotify  * This,
    /* [in] */ HCHAPTER hChapter,
    /* [in] */ DBASYNCHOP eOperation,
    /* [in] */ DBCOUNTITEM ulProgress,
    /* [in] */ DBCOUNTITEM ulProgressMax,
    /* [in] */ DBASYNCHPHASE eAsynchPhase,
    /* [in] */ LPOLESTR pwszStatusText);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDBAsynchNotify_OnProgress_Stub( 
    IDBAsynchNotify  * This,
    /* [in] */ HCHAPTER hChapter,
    /* [in] */ DBASYNCHOP eOperation,
    /* [in] */ DBCOUNTITEM ulProgress,
    /* [in] */ DBCOUNTITEM ulProgressMax,
    /* [in] */ DBASYNCHPHASE eAsynchPhase,
    /* [in] */ LPOLESTR pwszStatusText,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IDBAsynchNotify_OnStop_Proxy( 
    IDBAsynchNotify  * This,
    /* [in] */ HCHAPTER hChapter,
    /* [in] */ DBASYNCHOP eOperation,
    /* [in] */ HRESULT hrStatus,
    /* [in] */ LPOLESTR pwszStatusText);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDBAsynchNotify_OnStop_Stub( 
    IDBAsynchNotify  * This,
    /* [in] */ HCHAPTER hChapter,
    /* [in] */ DBASYNCHOP eOperation,
    /* [in] */ HRESULT hrStatus,
    /* [in] */ LPOLESTR pwszStatusText,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IDBAsynchStatus_Abort_Proxy( 
    IDBAsynchStatus  * This,
    /* [in] */ HCHAPTER hChapter,
    /* [in] */ DBASYNCHOP eOperation);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDBAsynchStatus_Abort_Stub( 
    IDBAsynchStatus  * This,
    /* [in] */ HCHAPTER hChapter,
    /* [in] */ DBASYNCHOP eOperation,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IDBAsynchStatus_GetStatus_Proxy( 
    IDBAsynchStatus  * This,
    /* [in] */ HCHAPTER hChapter,
    /* [in] */ DBASYNCHOP eOperation,
    /* [out] */ DBCOUNTITEM *pulProgress,
    /* [out] */ DBCOUNTITEM *pulProgressMax,
    /* [out] */ DBASYNCHPHASE  *peAsynchPhase,
    /* [out] */ LPOLESTR  *ppwszStatusText);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDBAsynchStatus_GetStatus_Stub( 
    IDBAsynchStatus  * This,
    /* [in] */ HCHAPTER hChapter,
    /* [in] */ DBASYNCHOP eOperation,
    /* [unique][out][in] */ DBCOUNTITEM *pulProgress,
    /* [unique][out][in] */ DBCOUNTITEM *pulProgressMax,
    /* [out] */ DBASYNCHPHASE  *peAsynchPhase,
    /* [out] */ LPOLESTR  *ppwszStatusText,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE ISessionProperties_GetProperties_Proxy( 
    ISessionProperties  * This,
    /* [in] */ ULONG cPropertyIDSets,
    /* [size_is][in] */ const DBPROPIDSET  rgPropertyIDSets[  ],
    /* [out][in] */ ULONG  *pcPropertySets,
    /* [size_is][size_is][out] */ DBPROPSET  * *prgPropertySets);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ISessionProperties_GetProperties_Stub( 
    ISessionProperties  * This,
    /* [in] */ ULONG cPropertyIDSets,
    /* [size_is][unique][in] */ const DBPROPIDSET  *rgPropertyIDSets,
    /* [out][in] */ ULONG  *pcPropertySets,
    /* [size_is][size_is][out] */ DBPROPSET  * *prgPropertySets,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE ISessionProperties_SetProperties_Proxy( 
    ISessionProperties  * This,
    /* [in] */ ULONG cPropertySets,
    /* [size_is][unique][out][in] */ DBPROPSET  rgPropertySets[  ]);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ISessionProperties_SetProperties_Stub( 
    ISessionProperties  * This,
    /* [in] */ ULONG cPropertySets,
    /* [size_is][unique][in] */ DBPROPSET  *rgPropertySets,
    /* [in] */ ULONG cTotalProps,
    /* [size_is][out] */ DBPROPSTATUS  *rgPropStatus,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IIndexDefinition_CreateIndex_Proxy( 
    IIndexDefinition  * This,
    /* [in] */ DBID  *pTableID,
    /* [in] */ DBID  *pIndexID,
    /* [in] */ DBORDINAL cIndexColumnDescs,
    /* [size_is][in] */ const DBINDEXCOLUMNDESC  rgIndexColumnDescs[  ],
    /* [in] */ ULONG cPropertySets,
    /* [size_is][out][in] */ DBPROPSET  rgPropertySets[  ],
    /* [out] */ DBID  * *ppIndexID);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IIndexDefinition_CreateIndex_Stub( 
    IIndexDefinition  * This,
    /* [in] */ DBID  *pTableID,
    /* [unique][in] */ DBID  *pIndexID,
    /* [in] */ DBORDINAL cIndexColumnDescs,
    /* [size_is][in] */ const DBINDEXCOLUMNDESC  *rgIndexColumnDescs,
    /* [in] */ ULONG cPropertySets,
    /* [size_is][unique][in] */ DBPROPSET  *rgPropertySets,
    /* [unique][out][in] */ DBID  * *ppIndexID,
    /* [in] */ ULONG cTotalProps,
    /* [size_is][out] */ DBPROPSTATUS  *rgPropStatus,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IIndexDefinition_DropIndex_Proxy( 
    IIndexDefinition  * This,
    /* [unique][in] */ DBID  *pTableID,
    /* [unique][in] */ DBID  *pIndexID);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IIndexDefinition_DropIndex_Stub( 
    IIndexDefinition  * This,
    /* [unique][in] */ DBID  *pTableID,
    /* [unique][in] */ DBID  *pIndexID,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE ITableDefinition_CreateTable_Proxy( 
    ITableDefinition  * This,
    /* [in] */ IUnknown  *pUnkOuter,
    /* [in] */ DBID  *pTableID,
    /* [in] */ DBORDINAL cColumnDescs,
    /* [size_is][in] */ const DBCOLUMNDESC  rgColumnDescs[  ],
    /* [in] */ REFIID riid,
    /* [in] */ ULONG cPropertySets,
    /* [size_is][out][in] */ DBPROPSET  rgPropertySets[  ],
    /* [out] */ DBID  * *ppTableID,
    /* [iid_is][out] */ IUnknown  * *ppRowset);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITableDefinition_CreateTable_Stub( 
    ITableDefinition  * This,
    /* [in] */ IUnknown  *pUnkOuter,
    /* [unique][in] */ DBID  *pTableID,
    /* [in] */ DBORDINAL cColumnDescs,
    /* [size_is][in] */ const DBCOLUMNDESC  *rgColumnDescs,
    /* [in] */ REFIID riid,
    /* [in] */ ULONG cPropertySets,
    /* [size_is][unique][in] */ DBPROPSET  *rgPropertySets,
    /* [unique][out][in] */ DBID  * *ppTableID,
    /* [iid_is][unique][out][in] */ IUnknown  * *ppRowset,
    /* [in] */ ULONG cTotalProps,
    /* [size_is][out] */ DBPROPSTATUS  *rgPropStatus,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE ITableDefinition_DropTable_Proxy( 
    ITableDefinition  * This,
    /* [unique][in] */ DBID  *pTableID);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITableDefinition_DropTable_Stub( 
    ITableDefinition  * This,
    /* [unique][in] */ DBID  *pTableID,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE ITableDefinition_AddColumn_Proxy( 
    ITableDefinition  * This,
    /* [in] */ DBID  *pTableID,
    /* [out][in] */ DBCOLUMNDESC  *pColumnDesc,
    /* [out] */ DBID  * *ppColumnID);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITableDefinition_AddColumn_Stub( 
    ITableDefinition  * This,
    /* [in] */ DBID  *pTableID,
    /* [in] */ DBCOLUMNDESC  *pColumnDesc,
    /* [unique][out][in] */ DBID  * *ppColumnID,
    /* [in] */ ULONG cTotalProps,
    /* [size_is][out] */ DBPROPSTATUS  *rgPropStatus,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE ITableDefinition_DropColumn_Proxy( 
    ITableDefinition  * This,
    /* [unique][in] */ DBID  *pTableID,
    /* [unique][in] */ DBID  *pColumnID);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITableDefinition_DropColumn_Stub( 
    ITableDefinition  * This,
    /* [unique][in] */ DBID  *pTableID,
    /* [unique][in] */ DBID  *pColumnID,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IOpenRowset_OpenRowset_Proxy( 
    IOpenRowset  * This,
    /* [in] */ IUnknown  *pUnkOuter,
    /* [unique][in] */ DBID  *pTableID,
    /* [unique][in] */ DBID  *pIndexID,
    /* [in] */ REFIID riid,
    /* [in] */ ULONG cPropertySets,
    /* [size_is][out][in] */ DBPROPSET  rgPropertySets[  ],
    /* [iid_is][out] */ IUnknown  * *ppRowset);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IOpenRowset_OpenRowset_Stub( 
    IOpenRowset  * This,
    /* [in] */ IUnknown  *pUnkOuter,
    /* [unique][in] */ DBID  *pTableID,
    /* [unique][in] */ DBID  *pIndexID,
    /* [in] */ REFIID riid,
    /* [in] */ ULONG cPropertySets,
    /* [size_is][unique][in] */ DBPROPSET  *rgPropertySets,
    /* [iid_is][unique][out][in] */ IUnknown  * *ppRowset,
    /* [in] */ ULONG cTotalProps,
    /* [size_is][out] */ DBPROPSTATUS  *rgPropStatus,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IDBSchemaRowset_GetRowset_Proxy( 
    IDBSchemaRowset  * This,
    /* [in] */ IUnknown  *pUnkOuter,
    /* [in] */ REFGUID rguidSchema,
    /* [in] */ ULONG cRestrictions,
    /* [size_is][in] */ const VARIANT  rgRestrictions[  ],
    /* [in] */ REFIID riid,
    /* [in] */ ULONG cPropertySets,
    /* [size_is][unique][out][in] */ DBPROPSET  rgPropertySets[  ],
    /* [iid_is][out] */ IUnknown  * *ppRowset);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDBSchemaRowset_GetRowset_Stub( 
    IDBSchemaRowset  * This,
    /* [in] */ IUnknown  *pUnkOuter,
    /* [in] */ REFGUID rguidSchema,
    /* [in] */ ULONG cRestrictions,
    /* [size_is][unique][in] */ const VARIANT  *rgRestrictions,
    /* [in] */ REFIID riid,
    /* [in] */ ULONG cPropertySets,
    /* [size_is][unique][in] */ DBPROPSET  *rgPropertySets,
    /* [iid_is][out] */ IUnknown  * *ppRowset,
    /* [in] */ ULONG cTotalProps,
    /* [size_is][out] */ DBPROPSTATUS  *rgPropStatus,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IDBSchemaRowset_GetSchemas_Proxy( 
    IDBSchemaRowset  * This,
    /* [out][in] */ ULONG  *pcSchemas,
    /* [size_is][size_is][out] */ GUID  * *prgSchemas,
    /* [size_is][size_is][out] */ ULONG  * *prgRestrictionSupport);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDBSchemaRowset_GetSchemas_Stub( 
    IDBSchemaRowset  * This,
    /* [out][in] */ ULONG  *pcSchemas,
    /* [size_is][size_is][out] */ GUID  * *prgSchemas,
    /* [size_is][size_is][out] */ ULONG  * *prgRestrictionSupport,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IErrorRecords_AddErrorRecord_Proxy( 
    IErrorRecords  * This,
    /* [in] */ ERRORINFO  *pErrorInfo,
    /* [in] */ DWORD dwLookupID,
    /* [in] */ DISPPARAMS  *pdispparams,
    /* [in] */ IUnknown  *punkCustomError,
    /* [in] */ DWORD dwDynamicErrorID);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IErrorRecords_AddErrorRecord_Stub( 
    IErrorRecords  * This,
    /* [in] */ ERRORINFO  *pErrorInfo,
    /* [in] */ DWORD dwLookupID,
    /* [in] */ DISPPARAMS  *pdispparams,
    /* [in] */ IUnknown  *punkCustomError,
    /* [in] */ DWORD dwDynamicErrorID,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IErrorRecords_GetBasicErrorInfo_Proxy( 
    IErrorRecords  * This,
    /* [in] */ ULONG ulRecordNum,
    /* [out] */ ERRORINFO  *pErrorInfo);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IErrorRecords_GetBasicErrorInfo_Stub( 
    IErrorRecords  * This,
    /* [in] */ ULONG ulRecordNum,
    /* [out] */ ERRORINFO  *pErrorInfo,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IErrorRecords_GetCustomErrorObject_Proxy( 
    IErrorRecords  * This,
    /* [in] */ ULONG ulRecordNum,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown  * *ppObject);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IErrorRecords_GetCustomErrorObject_Stub( 
    IErrorRecords  * This,
    /* [in] */ ULONG ulRecordNum,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown  * *ppObject,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IErrorRecords_GetErrorInfo_Proxy( 
    IErrorRecords  * This,
    /* [in] */ ULONG ulRecordNum,
    /* [in] */ LCID lcid,
    /* [out] */ IErrorInfo  * *ppErrorInfo);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IErrorRecords_GetErrorInfo_Stub( 
    IErrorRecords  * This,
    /* [in] */ ULONG ulRecordNum,
    /* [in] */ LCID lcid,
    /* [out] */ IErrorInfo  * *ppErrorInfo,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IErrorRecords_GetErrorParameters_Proxy( 
    IErrorRecords  * This,
    /* [in] */ ULONG ulRecordNum,
    /* [out] */ DISPPARAMS  *pdispparams);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IErrorRecords_GetErrorParameters_Stub( 
    IErrorRecords  * This,
    /* [in] */ ULONG ulRecordNum,
    /* [out] */ DISPPARAMS  *pdispparams,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IErrorRecords_GetRecordCount_Proxy( 
    IErrorRecords  * This,
    /* [out] */ ULONG  *pcRecords);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IErrorRecords_GetRecordCount_Stub( 
    IErrorRecords  * This,
    /* [out] */ ULONG  *pcRecords,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IErrorLookup_GetErrorDescription_Proxy( 
    IErrorLookup  * This,
    /* [in] */ HRESULT hrError,
    /* [in] */ DWORD dwLookupID,
    /* [in] */ DISPPARAMS  *pdispparams,
    /* [in] */ LCID lcid,
    /* [out] */ BSTR  *pbstrSource,
    /* [out] */ BSTR  *pbstrDescription);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IErrorLookup_GetErrorDescription_Stub( 
    IErrorLookup  * This,
    /* [in] */ HRESULT hrError,
    /* [in] */ DWORD dwLookupID,
    /* [in] */ DISPPARAMS  *pdispparams,
    /* [in] */ LCID lcid,
    /* [out] */ BSTR  *pbstrSource,
    /* [out] */ BSTR  *pbstrDescription,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IErrorLookup_GetHelpInfo_Proxy( 
    IErrorLookup  * This,
    /* [in] */ HRESULT hrError,
    /* [in] */ DWORD dwLookupID,
    /* [in] */ LCID lcid,
    /* [out] */ BSTR  *pbstrHelpFile,
    /* [out] */ DWORD  *pdwHelpContext);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IErrorLookup_GetHelpInfo_Stub( 
    IErrorLookup  * This,
    /* [in] */ HRESULT hrError,
    /* [in] */ DWORD dwLookupID,
    /* [in] */ LCID lcid,
    /* [out] */ BSTR  *pbstrHelpFile,
    /* [out] */ DWORD  *pdwHelpContext,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IErrorLookup_ReleaseErrors_Proxy( 
    IErrorLookup  * This,
    /* [in] */ const DWORD dwDynamicErrorID);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IErrorLookup_ReleaseErrors_Stub( 
    IErrorLookup  * This,
    /* [in] */ const DWORD dwDynamicErrorID,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE ISQLErrorInfo_GetSQLInfo_Proxy( 
    ISQLErrorInfo  * This,
    /* [out] */ BSTR  *pbstrSQLState,
    /* [out] */ LONG  *plNativeError);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ISQLErrorInfo_GetSQLInfo_Stub( 
    ISQLErrorInfo  * This,
    /* [out] */ BSTR  *pbstrSQLState,
    /* [out] */ LONG  *plNativeError,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IGetDataSource_GetDataSource_Proxy( 
    IGetDataSource  * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown  * *ppDataSource);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IGetDataSource_GetDataSource_Stub( 
    IGetDataSource  * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown  * *ppDataSource,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE ITransactionLocal_GetOptionsObject_Proxy( 
    ITransactionLocal  * This,
    /* [out] */ ITransactionOptions  * *ppOptions);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITransactionLocal_GetOptionsObject_Stub( 
    ITransactionLocal  * This,
    /* [out] */ ITransactionOptions  * *ppOptions,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE ITransactionLocal_StartTransaction_Proxy( 
    ITransactionLocal  * This,
    /* [in] */ ISOLEVEL isoLevel,
    /* [in] */ ULONG isoFlags,
    /* [in] */ ITransactionOptions  *pOtherOptions,
    /* [out] */ ULONG  *pulTransactionLevel);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITransactionLocal_StartTransaction_Stub( 
    ITransactionLocal  * This,
    /* [in] */ ISOLEVEL isoLevel,
    /* [in] */ ULONG isoFlags,
    /* [in] */ ITransactionOptions  *pOtherOptions,
    /* [unique][out][in] */ ULONG  *pulTransactionLevel,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE ITransactionJoin_GetOptionsObject_Proxy( 
    ITransactionJoin  * This,
    /* [out] */ ITransactionOptions  * *ppOptions);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITransactionJoin_GetOptionsObject_Stub( 
    ITransactionJoin  * This,
    /* [out] */ ITransactionOptions  * *ppOptions,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE ITransactionJoin_JoinTransaction_Proxy( 
    ITransactionJoin  * This,
    /* [in] */ IUnknown  *punkTransactionCoord,
    /* [in] */ ISOLEVEL isoLevel,
    /* [in] */ ULONG isoFlags,
    /* [in] */ ITransactionOptions  *pOtherOptions);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITransactionJoin_JoinTransaction_Stub( 
    ITransactionJoin  * This,
    /* [in] */ IUnknown  *punkTransactionCoord,
    /* [in] */ ISOLEVEL isoLevel,
    /* [in] */ ULONG isoFlags,
    /* [in] */ ITransactionOptions  *pOtherOptions,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE ITransactionObject_GetTransactionObject_Proxy( 
    ITransactionObject  * This,
    /* [in] */ ULONG ulTransactionLevel,
    /* [out] */ ITransaction  * *ppTransactionObject);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITransactionObject_GetTransactionObject_Stub( 
    ITransactionObject  * This,
    /* [in] */ ULONG ulTransactionLevel,
    /* [out] */ ITransaction  * *ppTransactionObject,
    /* [out] */ IErrorInfo  * *ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IScopedOperations_Copy_Proxy( 
    IScopedOperations  * This,
    /* [in] */ DBCOUNTITEM cRows,
    /* [size_is][in] */ LPCOLESTR  rgpwszSourceURLs[  ],
    /* [size_is][in] */ LPCOLESTR  rgpwszDestURLs[  ],
    /* [in] */ DWORD dwCopyFlags,
    /* [unique][in] */ IAuthenticate  *pAuthenticate,
    /* [size_is][out][in] */ DBSTATUS  rgdwStatus[  ],
    /* [size_is][out] */ LPOLESTR  rgpwszNewURLs[  ],
    /* [out] */ OLECHAR  * *ppStringsBuffer);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IScopedOperations_Copy_Stub( 
    IScopedOperations  * This,
    /* [in] */ DBCOUNTITEM cRows,
    /* [size_is][in] */ LPCOLESTR  *rgpwszSourceURLs,
    /* [size_is][in] */ LPCOLESTR  *rgpwszDestURLs,
    /* [in] */ DWORD dwCopyFlags,
    /* [in] */ IAuthenticate  *pAuthenticate,
    /* [size_is][out] */ DBSTATUS  *rgdwStatus,
    /* [size_is][size_is][out] */ DBBYTEOFFSET **prgulNewURLOffsets,
    /* [out][in] */ ULONG  *pcbStringsBuffer,
    /* [size_is][size_is][unique][out][in] */ OLECHAR  * *ppStringsBuffer);

/* [local] */ HRESULT STDMETHODCALLTYPE IScopedOperations_Move_Proxy( 
    IScopedOperations  * This,
    /* [in] */ DBCOUNTITEM cRows,
    /* [size_is][in] */ LPCOLESTR  rgpwszSourceURLs[  ],
    /* [size_is][in] */ LPCOLESTR  rgpwszDestURLs[  ],
    /* [in] */ DWORD dwMoveFlags,
    /* [unique][in] */ IAuthenticate  *pAuthenticate,
    /* [size_is][out][in] */ DBSTATUS  rgdwStatus[  ],
    /* [size_is][out] */ LPOLESTR  rgpwszNewURLs[  ],
    /* [out] */ OLECHAR  * *ppStringsBuffer);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IScopedOperations_Move_Stub( 
    IScopedOperations  * This,
    /* [in] */ DBCOUNTITEM cRows,
    /* [size_is][in] */ LPCOLESTR  *rgpwszSourceURLs,
    /* [size_is][in] */ LPCOLESTR  *rgpwszDestURLs,
    /* [in] */ DWORD dwMoveFlags,
    /* [in] */ IAuthenticate  *pAuthenticate,
    /* [size_is][out] */ DBSTATUS  *rgdwStatus,
    /* [size_is][size_is][out] */ DBBYTEOFFSET **prgulNewURLOffsets,
    /* [out][in] */ ULONG  *pcbStringsBuffer,
    /* [size_is][size_is][unique][out][in] */ OLECHAR  * *ppStringsBuffer);

/* [local] */ HRESULT STDMETHODCALLTYPE IScopedOperations_Delete_Proxy( 
    IScopedOperations  * This,
    /* [in] */ DBCOUNTITEM cRows,
    /* [size_is][in] */ LPCOLESTR  rgpwszURLs[  ],
    /* [in] */ DWORD dwDeleteFlags,
    /* [size_is][out][in] */ DBSTATUS  rgdwStatus[  ]);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IScopedOperations_Delete_Stub( 
    IScopedOperations  * This,
    /* [in] */ DBCOUNTITEM cRows,
    /* [size_is][in] */ LPCOLESTR  *rgpwszURLs,
    /* [in] */ DWORD dwDeleteFlags,
    /* [size_is][out] */ DBSTATUS  *rgdwStatus);

/* [local] */ HRESULT STDMETHODCALLTYPE IScopedOperations_OpenRowset_Proxy( 
    IScopedOperations  * This,
    /* [in] */ IUnknown  *pUnkOuter,
    /* [unique][in] */ DBID  *pTableID,
    /* [unique][in] */ DBID  *pIndexID,
    /* [in] */ REFIID riid,
    /* [in] */ ULONG cPropertySets,
    /* [size_is][out][in] */ DBPROPSET  rgPropertySets[  ],
    /* [iid_is][out] */ IUnknown  * *ppRowset);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IScopedOperations_OpenRowset_Stub( 
    IScopedOperations  * This,
    /* [in] */ IUnknown  *pUnkOuter,
    /* [unique][in] */ DBID  *pTableID,
    /* [unique][in] */ DBID  *pIndexID,
    /* [in] */ REFIID riid,
    /* [in] */ ULONG cPropertySets,
    /* [size_is][unique][in] */ DBPROPSET  *rgPropertySets,
    /* [iid_is][unique][out][in] */ IUnknown  * *ppRowset,
    /* [in] */ ULONG cTotalProps,
    /* [size_is][out] */ DBPROPSTATUS  *rgPropStatus);

/* [local] */ HRESULT STDMETHODCALLTYPE IBindResource_Bind_Proxy( 
    IBindResource  * This,
    /* [in] */ IUnknown  *pUnkOuter,
    /* [in] */ LPCOLESTR pwszURL,
    /* [in] */ DBBINDURLFLAG dwBindURLFlags,
    /* [in] */ REFGUID rguid,
    /* [in] */ REFIID riid,
    /* [in] */ IAuthenticate  *pAuthenticate,
    /* [unique][out][in] */ DBIMPLICITSESSION  *pImplSession,
    /* [out] */ DBBINDURLSTATUS  *pdwBindStatus,
    /* [iid_is][out] */ IUnknown  * *ppUnk);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindResource_Bind_Stub( 
    IBindResource  * This,
    /* [in] */ IUnknown  *pUnkOuter,
    /* [in] */ LPCOLESTR pwszURL,
    /* [in] */ DBBINDURLFLAG dwBindURLFlags,
    /* [in] */ REFGUID rguid,
    /* [in] */ REFIID riid,
    /* [in] */ IAuthenticate  *pAuthenticate,
    /* [unique][out][in] */ DBIMPLICITSESSION  *pImplSession,
    /* [out] */ DBBINDURLSTATUS  *pdwBindStatus,
    /* [iid_is][out] */ IUnknown  * *ppUnk);

/* [local] */ HRESULT STDMETHODCALLTYPE ICreateRow_CreateRow_Proxy( 
    ICreateRow  * This,
    /* [unique][in] */ IUnknown  *pUnkOuter,
    /* [in] */ LPCOLESTR pwszURL,
    /* [in] */ DBBINDURLFLAG dwBindURLFlags,
    /* [in] */ REFGUID rguid,
    /* [in] */ REFIID riid,
    /* [unique][in] */ IAuthenticate  *pAuthenticate,
    /* [unique][out][in] */ DBIMPLICITSESSION  *pImplSession,
    /* [out][in] */ DBBINDURLSTATUS  *pdwBindStatus,
    /* [out] */ LPOLESTR  *ppwszNewURL,
    /* [iid_is][out] */ IUnknown  * *ppUnk);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ICreateRow_CreateRow_Stub( 
    ICreateRow  * This,
    /* [in] */ IUnknown  *pUnkOuter,
    /* [in] */ LPCOLESTR pwszURL,
    /* [in] */ DBBINDURLFLAG dwBindURLFlags,
    /* [in] */ REFGUID rguid,
    /* [in] */ REFIID riid,
    /* [in] */ IAuthenticate  *pAuthenticate,
    /* [unique][out][in] */ DBIMPLICITSESSION  *pImplSession,
    /* [out] */ DBBINDURLSTATUS  *pdwBindStatus,
    /* [unique][out][in] */ LPOLESTR  *ppwszNewURL,
    /* [iid_is][out] */ IUnknown  * *ppUnk);

/* [local] */ HRESULT STDMETHODCALLTYPE IColumnsInfo2_GetRestrictedColumnInfo_Proxy( 
    IColumnsInfo2  * This,
    /* [in] */ DBORDINAL cColumnIDMasks,
    /* [size_is][in] */ const DBID  rgColumnIDMasks[  ],
    /* [in] */ DWORD dwFlags,
    /* [out][in] */ DBORDINAL *pcColumns,
    /* [size_is][size_is][out] */ DBID  * *prgColumnIDs,
    /* [size_is][size_is][out] */ DBCOLUMNINFO  * *prgColumnInfo,
    /* [out] */ OLECHAR  * *ppStringsBuffer);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IColumnsInfo2_GetRestrictedColumnInfo_Stub( 
    IColumnsInfo2  * This,
    /* [in] */ DBORDINAL cColumnIDMasks,
    /* [size_is][unique][in] */ const DBID  *rgColumnIDMasks,
    /* [in] */ DWORD dwFlags,
    /* [out][in] */ DBORDINAL *pcColumns,
    /* [size_is][size_is][unique][out][in] */ DBID  * *prgColumnIDs,
    /* [size_is][size_is][unique][out][in] */ DBCOLUMNINFO  * *prgColumnInfo,
    /* [size_is][size_is][out] */ DBBYTEOFFSET **prgNameOffsets,
    /* [size_is][size_is][out] */ DBBYTEOFFSET **prgcolumnidOffsets,
    /* [out][in] */ DBLENGTH *pcbStringsBuffer,
    /* [size_is][size_is][unique][out][in] */ OLECHAR  * *ppStringsBuffer);

/* [local] */ HRESULT STDMETHODCALLTYPE IRegisterProvider_GetURLMapping_Proxy( 
    IRegisterProvider  * This,
    /* [in] */ LPCOLESTR pwszURL,
    /* [in] */ DB_DWRESERVE dwReserved,
    /* [out] */ CLSID  *pclsidProvider);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IRegisterProvider_GetURLMapping_Stub( 
    IRegisterProvider  * This,
    /* [in] */ LPCOLESTR pwszURL,
    /* [in] */ DB_DWRESERVE dwReserved,
    /* [out] */ CLSID  *pclsidProvider);



#endif // OLEDBPROXY
/* end of Additional Prototypes */

/***************************************************************************
****************************************************************************
        SQL CE specific GUIDS, interfaces and properties
***************************************************************************
***************************************************************************/

#else // GUIDS_ONLY

#ifndef OLEDBDECLSPEC
#define OLEDBDECLSPEC
#endif

#endif //GUIDS_ONLY

/***************************************************************************
****************************************************************************
        SQL CE specific GUIDS
***************************************************************************
***************************************************************************/


// Microsoft SQL Server Compact 3.5 OLEDB Provider (Microsoft.SQLSERVER.CE.OLEDB.3.5)
//
// {F49C559D-E9E5-467C-8C18-3326AAE4EBCC}
//
extern const OLEDBDECLSPEC GUID CLSID_SQLSERVERCE_3_5 = {0xf49c559d, 0xe9e5, 0x467c, {0x8c, 0x18, 0x33, 0x26, 0xaa, 0xe4, 0xeb, 0xcc}};
#define CLSID_SQLSERVERCE  CLSID_SQLSERVERCE_3_5


// PUBLISHED: Provider Specific Property Sets
//
// Provider-Specific DBInit Property Set
// {2B9AB5BA-4F6C-4ddd-BF18-24DD4BD41848}
//
extern const OLEDBDECLSPEC GUID DBPROPSET_SSCE_DBINIT = {0x2b9ab5ba, 0x4f6c, 0x4ddd, {0xbf, 0x18, 0x24, 0xdd, 0x4b, 0xd4, 0x18, 0x48}};

// Provider-Specific Column Property Set
// {352CC8D5-9181-11d3-B27B-00C04F68DBFF}
//
extern const OLEDBDECLSPEC GUID DBPROPSET_SSCE_COLUMN = {0x352cc8d5, 0x9181, 0x11d3, {0xb2, 0x7b, 0x0, 0xc0, 0x4f, 0x68, 0xdb, 0xff}};

// Provider-Specific Rowset Property Set
// {5C17C602-A107-11d3-B27B-00C04F68DBFF}
//
extern const OLEDBDECLSPEC GUID DBPROPSET_SSCE_ROWSET = {0x5c17c602, 0xa107, 0x11d3, {0xb2, 0x7b, 0x0, 0xc0, 0x4f, 0x68, 0xdb, 0xff}};

// Provider-Specific Session Property Set
// {22FE7D33-5E5C-4a45-B723-8BED2374A06B}
//
extern const OLEDBDECLSPEC GUID DBPROPSET_SSCE_SESSION = {0x22fe7d33, 0x5e5c, 0x4a45, {0xb7, 0x23, 0x8b, 0xed, 0x23, 0x74, 0xa0, 0x6b}};

#ifndef GUIDS_ONLY
// PUBLISHED Provider specific properties
//
#define DBPROP_SSCE_COL_ROWGUID                     0x1F9L      // SSCE_COLUMN
#define DBPROP_SSCE_MAXBUFFERSIZE                   0x1FAL      // SSCE_DBINIT
#define DBPROP_SSCE_DBPASSWORD                      0x1FBL      // SSCE_DBINIT
#define DBPROP_SSCE_ENCRYPTDATABASE                 0x1FCL      // SSCE_DBINIT
#define DBPROP_SSCE_DEFAULT_LOCK_ESCALATION         0x1FDL      // SSCE_DBINIT
#define DBPROP_SSCE_TEMPFILE_DIRECTORY              0x1FEL      // SSCE_DBINIT
#define DBPROP_SSCE_DEFAULT_LOCK_TIMEOUT            0x1FFL      // SSCE_DBINIT
#define DBPROP_SSCE_TRANSACTION_COMMIT_MODE         0x200L      // SSCE_SESSION
#define DBPROP_SSCE_LOCK_TIMEOUT                    0x201L      // SSCE_SESSION
#define DBPROP_SSCE_AUTO_SHRINK_THRESHOLD           0x202L      // SSCE_DBINIT
#define DBPROP_SSCE_FLUSH_INTERVAL                  0x206L      // SSCE_DBINIT
#define DBPROP_SSCE_MAX_DATABASE_SIZE               0x20BL      // SSCE_DBINIT
#define DBPROP_SSCE_LOCK_ESCALATION                 0x20CL      // SSCE_SESSION
#define DBPROP_SSCE_LOCK_HINT                       0x20DL      // SSCE_ROWSET
#define DBPROP_SSCE_TEMPFILE_MAX_SIZE               0x20EL      // SSCE_DBINIT
#define DBPROP_SSCE_ENCRYPTIONMODE                  0x20FL      // SSCE_DBINIT
#define DBPROP_SSCE_DBCASESENSITIVE                 0x210L      // SSCE_DBINIT

// Enumeration values for DBPROP_SSCE_LOCK_HINT:
//
#define DBPROPVAL_SSCE_LH_ROWLOCK                   0x0001L     // Row-level locking
#define DBPROPVAL_SSCE_LH_PAGLOCK                   0x0002L     // Page-level locking
#define DBPROPVAL_SSCE_LH_TABLOCK                   0x0004L     // Table-level locking
#define DBPROPVAL_SSCE_LH_DBLOCK                    0x0008L     // Database-level locking
#define DBPROPVAL_SSCE_LH_NOLOCK                    0x0010L     // No lock option
#define DBPROPVAL_SSCE_LH_HOLDLOCK                  0x0020L     // Hold lock option
#define DBPROPVAL_SSCE_LH_UPDLOCK                   0x0040L     // Update lock type
#define DBPROPVAL_SSCE_LH_XLOCK                     0x0080L     // Exclusive lock type

// Enumeration values for DBPROP_SSCE_TRANSACTION_COMMIT_MODE:
//
#define DBPROPVAL_SSCE_TCM_DEFAULT                  0x0000L    // Asynchronously commit transactions to disk
#define DBPROPVAL_SSCE_TCM_FLUSH                    0x0001L    // Synchronously commit transactions to disk

// Enumeration values for DBPROP_SSCE_DBENCRYPTIONMODE
//
#define DBPROPVAL_SSCE_EM_INVALID                   0x0000L
#define DBPROPVAL_SSCE_EM_PLATFORM_DEFAULT          0x0001L    // (Default) Best algorithm available on the platform
#define DBPROPVAL_SSCE_EM_ENGINE_DEFAULT            0x0002L    // AES128/SHA1
#define DBPROPVAL_SSCE_EM_PPC2003_COMPAT            0x0003L    // 3DES/SHA1

// Bit mask specifying which properties in DBPROPSET_SSCE_DBINIT 
// were not honored when creating / opening the data source. This
// bit mask is returned as the first parameter in the error object 
// if the minor error code is SSCE_M_INITPROPCONFLICT
//
#define SSCE_DBINIT_CONFLICT_MAXBUFFERSIZE          (0x00000001)
#define SSCE_DBINIT_CONFLICT_AUTO_SHRINK_THRESHOLD  (0x00000004)
#define SSCE_DBINIT_CONFLICT_FLUSH_INTERVAL         (0x00000008)
#define SSCE_DBINIT_CONFLICT_MAX_DATABASE_SIZE      (0x00000020)
#define SSCE_DBINIT_CONFLICT_TEMPFILE_DIRECTORY     (0x00000040)
#define SSCE_DBINIT_CONFLICT_DEFAULTESCALATION      (0x00000080)
#define SSCE_DBINIT_CONFLICT_DEFAULTTIMEOUT         (0x00000100)
#define SSCE_DBINIT_CONFLICT_MAX_TMPDB_SIZE         (0x00000200)

// PUBLISHED: Provider Specific Interfaces
//
// IID_ISSCECompact
//
// NOTE: removed as per raid 9395
//
#if 0
extern const OLEDBDECLSPEC GUID IID_ISSCECompact     = {0x35437031,0x85a0,0x11d3,{0x88,0xc4,0x00,0xc0,0x4f,0xd9,0x37,0xf0}};
class ISSCECompact : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE Compact( 
        /* [in] */ ULONG cPropertySets,
        /* [size_is][out][in] */ DBPROPSET  rgPropertySets[  ]) = 0;
};
#endif

// PUBLISHED: OLEDB 2.6 Specific Properties
//
#define DBPROP_COL_SEED                             0x11AL  
#define DBPROP_COL_INCREMENT                        0x11BL
#define DBPROP_IRowsetBookmark                      0x124L

// PUBLISHED: OLEDB 2.6 Defined Rowset Interfaces
//
// Interface: IRowsetBookmark
// VS8 changes

#ifndef __IRowsetBookmark_FWD_DEFINED__
#define __IRowsetBookmark_FWD_DEFINED__
#endif 	/* __IRowsetBookmark_FWD_DEFINED__ */

#ifndef __IRowsetBookmark_INTERFACE_DEFINED__
#define __IRowsetBookmark_INTERFACE_DEFINED__


extern const OLEDBDECLSPEC IID IID_IRowsetBookmark = {0x0c733ac2,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
class IRowsetBookmark : public IUnknown
{
public:
    virtual /* [local] */ HRESULT STDMETHODCALLTYPE PositionOnBookmark( 
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ ULONG cbBookmark,
            /* [size_is][in] */ const BYTE  *pBookmark) = 0;
};
#endif /*__IRowsetBookmark_INTERFACE_DEFINED__*/


// Interface: IRowsetPosition
//
extern const OLEDBDECLSPEC IID IID_IRowsetPosition = {0xc19f4b47,0xab5e,0x49a9,{0x9f,0x2e,0xab,0x7a,0xb5,0xc5,0x59,0x14}};
class IRowsetPosition : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE GetRecordCount( 
        /* [in] */ HCHAPTER hChapter,
        /* [out] */ ULONG * pcRows) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetCurrentPosition( 
        /* [in] */ HCHAPTER hChapter,
        /* [out] */ ULONG * pulPosition) = 0;
};

/*********************************************************************/

#ifdef __cplusplus
}
#endif

#endif // GUIDS_ONLY

#endif // of ! __SQLCE_OLEDB_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\sqmclient.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

#ifndef SQMCLIENT_H__
#define SQMCLIENT_H__

#include <basetsd.h> // DWORD64

typedef DWORD HSQMSESSION;
typedef HSQMSESSION *LPHSQMSESSION;

// ----------------------------------------------------------------------------
// 
// Function:    SqmGetSession
// Description: This function creates a new session or retrieves the specified
//              named (shared) session.
//
// Parameters:
//
//     [IN] pszSessionIdentifier
//     Unique session identifier.  If this argument is NULL, then an unnamed
//     session is created.  The unnamed session can only be accessed by the
//     calling process.  To allow an external process to access a session, the
//     session must be created with an identifier.  At most one unnamed session
//     may be created by a process.  If more than one concurrent session is
//     required, then unique session identifiers must be used for all but one
//     session (unnamed).  Unless cross-process (shared) sessions are required,
//     it is recommended that unnamed sessions be used.  The first session
//     created by a process (named or unnamed) is considered the default
//     session of that process.  Passing NULL for the hSession argument of a
//     SQM function will target the default session of the calling process.  If
//     a default session does not exist, then calling a SQM function with a
//     NULL hSession argument fails silently.
//
//     [IN] cbMaxSessionSize
//     If a new session is being created, then this argument specifies the
//     maxmimum amount of memory that the session's data can consume.  Note
//     that the SQM engine is configured with a maximum session size which
//     places an upper-bound on this value.  If this argument is greater than
//     the SQM engine's configured maximum session size, then the session
//     inherits the SQM engine's maximum session size.  If a new session is not
//     being created, then this argument is ignored.
//
//     [IN] dwFlags
//     Session creation flags.  SQM_SESSION_CREATE_NEW specifies that if a
//     session is not presently associated with the specified session
//     identifier, then a new session is to be created.
//     SQM_SESSION_CREATE_NEW_PERSISTENT marks the session as persistent.  A
//     persistent session must be named.  A persistent session remains active
//     while it is not explicitly ended via SqmEndSession.  As suggested by its
//     name, a persistent session persists session data across power cycles.
//
// Return:
//
//     NULL             Failure.
//     (otherwise)      Success.  Handle (HSQMSESSION) to associated SQM
//                      session.
//
// ----------------------------------------------------------------------------
EXTERN_C
HSQMSESSION
SqmGetSession(
    LPWSTR pszSessionIdentifier,
    DWORD  cbMaxSessionSize,
    DWORD  dwFlags
    );

#define SQM_SESSION_CREATE_NEW            0x00000001
#define SQM_SESSION_CREATE_NEW_PERSISTENT 0x80000000

// ----------------------------------------------------------------------------
// 
// Function:    SqmGetManagedSession
// Description: This function retrieves a SQM handle to a managed session. A
//              session is a managed session if it is registered in the 
//              registry under the HKLM\Software\Microsoft\Sessions key and it
//              at-least has a MaxSize value.
//
// Parameters:
//
//     [IN] pszSessionIdentifier
//     Unique session identifier for the managed session. This cannot be NULL.
//
// Return:
//
//     NULL             Failure.
//     (otherwise)      Success.  Handle (HSQMSESSION) to associated SQM
//                      session.
//
// ----------------------------------------------------------------------------
EXTERN_C
HSQMSESSION
SqmGetManagedSession(
    LPWSTR pszSessionIdentifier
    );

#define SQM_REGKEY_SESSIONS L"System\\Sqm\\Sessions"
#define SQM_REGVALUE_SESSIONTIMEOUT L"Timeout"
#define SQM_REGVALUE_SESSIONCOUNT L"SessionCount"
#define SQM_REGVALUE_SESSIONPERSIST L"Persistent"
#define SQM_REGVALUE_SESSIONMAXSIZE L"MaxSize"

// ----------------------------------------------------------------------------
// 
// Function:    SqmEndSession
// Description: This function ends the target session and writes its associated
//              data to the specified file.  SQM employs a rolling session
//              model.  That is, this function does not invalidate the target
//              session (HSQMSESSION).  This function flushes the target
//              session's data and begins a new, empty session.  Moreover, all
//              subsequent SQM functions targeting the target session affect
//              the new session.  Note that a session's session flags and
//              machine and user IDs are copied to the new, empty session.
//
// Parameters:
//
//     [IN] hSession
//     The target session to end.  If this argument is NULL, then the default
//     session of the calling process is targeted.
//
//     [IN] pszPattern
//     Pattern which specifies the path of the file to which to write the
//     session's associated data.  If a fully-qualified path is specified, then
//     session's associated data is written to that file.  If a printf-style
//     format string (pattern) with a single %d specifier is specified, then
//     the session's associated data is written to a queue of files.  For
//     example, "foo%d.sqm" saves session data to foo1.sqm, foo2.sqm, foo3.sqm,
//     etc.  Files targeted by SqmEndSession must be named with a '.sqm'
//     (case-insenstive) extension.
//
//     [IN] dwMaxFilesToQueue
//     If a pattern with a %d specifier is supplied as the pszPattern argument,
//     then dwMaxFilesToQueue specifies the maximum number of files to queue
//     before overwriting existing files in the target directory that match the
//     supplied pattern.  Note that the SQM engine can be configured to enforce
//     an upper-bound on this argument.
//
//     [IN] dwFlags
//     File save flags.  SQM_OVERWRITE_OLDEST_FILE specifies that if the
//     maximum number of files have been queued, then the oldest file in the
//     target directory whose path matches the supplied pattern can be
//     overwritten.  SQM_OVERWRITE_ANY_FILE specifies that if the maximum
//     number of files have been queued, then the SQM engine can use its
//     discretion to select and overwrite any file in the target directory that
//     matches the supplied pattern.
//
// Return:
//
//     None.
//
// ----------------------------------------------------------------------------
EXTERN_C
VOID
SqmEndSession(
    HSQMSESSION hSession,
    LPCWSTR     pszPattern,
    DWORD       dwMaxFilesToQueue,
    DWORD       dwFlags
    );

#define SQM_OVERWRITE_ANY_FILE        0x00000001
#define SQM_OVERWRITE_OLDEST_FILE     0x00000002

// ----------------------------------------------------------------------------
// 
// Function:    SqmEndManagedSession
// Description: This function ends the target managed session, persisting it to
//              the store and uploading it. This is a special purpose function
//              that is typically used just by the SQMMGR directly, but you do
//              want a "normal" SQM session that is stored in the same place 
//              and following the same rules as other time-managed sessions,
//              then you can use SqmGetSession and SqmEndManagedSession.
//
// Parameters:
//
//     [IN] hSession
//     The target session to end.  This cannot be NULL.
//
//     [IN] dwFlags
//     0 or SQM_UPLOAD_LATER
//
// Return:
//
//     None.
//
// ----------------------------------------------------------------------------
EXTERN_C
VOID
SqmEndManagedSession(
    HSQMSESSION hSession,
    DWORD       dwFlags
    );

#define SQM_REGVALUE_TRANSIENTDIR L"TransientDir"
#define SQM_REGVALUE_TRANSIENTSIGNATURE L"TransientSignature"
#define SQM_REGVALUE_MAXTRANSIENT L"MaxTransient"
#define SQM_REGVALUE_TRANSIENTFLAGS L"TransientFlags"
#define SQM_UPLOAD_LATER 0x00000001

// ----------------------------------------------------------------------------
// 
// Function:    SqmStartSession
// Description: This function sets the start time of the target session.
//
// Parameters:
//
//     [IN] hSession
//     The target session.  If this argument is NULL, then the default session
//     of the calling process is targeted.
//
// Return:
//
//     None.
//
// ----------------------------------------------------------------------------
EXTERN_C
VOID
SqmStartSession(
    HSQMSESSION hSession
    );

// ----------------------------------------------------------------------------
// 
// Function:    SqmGetSessionStartTime
// Description: This function returns the start time of the target session.
//
// Parameters:
//
//     [IN] hSession
//     The target session.  If this argument is NULL, then the default session
//     of the calling process is targeted.
//
// Return:
//
//     0                Failure.
//     > 0              Success.  UTC time at which target session was started.
//
// ----------------------------------------------------------------------------
EXTERN_C
FILETIME
SqmGetSessionStartTime(
    HSQMSESSION hSession
    );

// ----------------------------------------------------------------------------
// 
// Function:    SqmGetEnabled
// Description: This function returns the logical AND of the target session's
//              enabled state and the SQM engine's enabled state.  If this
//              function returns FALSE, then the target session is considered
//              disabled.  As such, SQM functions targeting the target session
//              have no affect.
//
// Parameters:
//
//     [IN] hSession
//     The target session.  If this argument is NULL, then the default session
//     of the calling process is targeted.
//
// Return:
//
//     FALSE            The target session is disabled.
//     TRUE             The target session is enabled.
//
// ----------------------------------------------------------------------------
EXTERN_C
BOOL
SqmGetEnabled(
    HSQMSESSION hSession
    );

// ----------------------------------------------------------------------------
// 
// Function:    SqmSetEnabled
// Description: This function sets the target session's enabled state.  Setting
//              the target session's enabled state to TRUE does not necessarily
//              enabled the session.  See SqmGetEnabled.
//
// Parameters:
//
//     [IN] hSession
//     The target session.  If this argument is NULL, then the default session
//     of the calling process is targeted.
//
//     [IN[ fEnabled
//     The value to assign to the target session's enabled state.
//
// Return:
//
//     None.
//
// ----------------------------------------------------------------------------
EXTERN_C
VOID
SqmSetEnabled(
    HSQMSESSION hSession,
    BOOL        fEnabled
    );

// ----------------------------------------------------------------------------
//
// Function:    SqmGetFlags
// Description: This function returns the target session's session flags.
//
// Parameters:
//
//     [IN] hSession
//     The target session.  If this argument is NULL, then the default session
//     of the calling process is targeted.
//
//     [OUT] pdwFlags
//     The address to write the value of the target session's session flags
//     to.
//
// Return:
//
//     None.
//
// ----------------------------------------------------------------------------
EXTERN_C
VOID
SqmGetFlags(
    HSQMSESSION hSession,
    LPDWORD     pdwFlags
    );

// ----------------------------------------------------------------------------
//
// Function:    SqmSetFlags
// Description: This function sets the specified session flags of the target
//              session.
//
// Parameters:
//
//     [IN] hSession
//     The target session.  If this argument is NULL, then the default session
//     of the calling process is targeted.
//
//     [IN] dwFlags
//     The flags to set as the target session's session flags.  SQM_FLAG_DEBUG
//     marks the target session as a debug session and specifies that its data
//     is to be discarded at the server.  SQM_FLAG_NEVER_THROTTLE specifies
//     that the target session is immune to sampling at the server
//     SQM_SECURE_UPLOAD specifies that the target session requires a secure
//     (HTTPS) transfer to the server.  SQM_DO_NOT_UPLOAD specifies that the
//     target session is to be deleted and not uploaded if targeted with
//     SqmStartUpload.
//
// Return:
//
//     None.
//
// ----------------------------------------------------------------------------
EXTERN_C
VOID
SqmSetFlags(
    HSQMSESSION hSession,
    DWORD       dwFlags
    );

enum
{
    SQM_FLAG_DEBUG          = (1 << 0),
    SQM_FLAG_NEVER_THROTTLE = (1 << 1),
    SQM_SECURE_UPLOAD       = (1 << 2),
    SQM_DO_NOT_UPLOAD       = (1 << 3)
};

// ----------------------------------------------------------------------------
//
// Function:    SqmClearFlags
// Description: This function clears the specified session flags of the target
//              session.
//
// Parameters:
//
//     [IN] hSession
//     The target session.  If this argument is NULL, then the default session
//     of the calling process is targeted.
//
//     [IN] dwFlags
//     The flags to remove from the target session's session flags.
//
// Return:
//
//     None.
//
// ----------------------------------------------------------------------------
EXTERN_C
VOID
SqmClearFlags(
    HSQMSESSION hSession,
    DWORD       dwFlags
    );

// ----------------------------------------------------------------------------
//
// Function:    SqmGetMachineId
// Description: This function returns the machine ID associated with the target
//              session.
//
// Parameters:
//
//     [IN] hSession
//     The target session.  If this argument is NULL, then the default session
//     of the calling process is targeted.
//
//     [OUT] pguid
//     The address to write the machine ID associated with the target session
//     to.  0 indicates that a machine ID is not associated with the
//     target session.
//
// Return:
//
//     None.
//
// ----------------------------------------------------------------------------
EXTERN_C
VOID
SqmGetMachineId(
    HSQMSESSION hSession,
    LPGUID      pguid
    );

// ----------------------------------------------------------------------------
//
// Function:    SqmGetUserId
// Description: This function returns the user ID associated with the target
//              session.
//
// Parameters:
//
//     [IN] hSession
//     The target session.  If this argument is NULL, then the default session
//     of the calling process is targeted.
//
//     [OUT] pguid
//     The address to write the user ID associated with the target session to.
//     0 indicates that a user ID is not associated with the target session.
//
// Return:
//
//     None.
//
// ----------------------------------------------------------------------------
EXTERN_C
VOID
SqmGetUserId(
    HSQMSESSION hSession,
    LPGUID      pguid
    );

// ----------------------------------------------------------------------------
//
// Function:    SqmSetMachineId
// Description: This function associates a machine ID with the target session.
//
// Parameters:
//
//     [IN] hSession
//     The target session.  If this argument is NULL, then the default session
//     of the calling process is targeted.
//
//     [IN] pguid
//     The address containing the machine ID to associate with the target
//     session.
//
// Return:
//
//     None.
//
// ----------------------------------------------------------------------------
EXTERN_C
VOID
SqmSetMachineId(
    HSQMSESSION hSession,
    LPGUID      pguid
    );

// ----------------------------------------------------------------------------
//
// Function:    SqmSetUserId
// Description: This function associates a user ID with the target session.
//
// Parameters:
//
//     [IN] hSession
//     The target session.  If this argument is NULL, then the default session
//     of the calling process is targeted.
//
//     [IN] pguid
//     The address containing the user ID to associate with the target session.
//
// Return:
//
//     None.
//
// ----------------------------------------------------------------------------
EXTERN_C
VOID
SqmSetUserId(
    HSQMSESSION hSession,
    LPGUID      pguid
    );

// ----------------------------------------------------------------------------
//
// Function:    SqmCreateNewId
// Description: This function generates an ID that can be used as a session's
//              machine or user ID.
//
// Parameters:
//
//     [OUT] pguid
//     The address to write the generated ID to.
//
// Return:
//
//     FALSE            Failure.
//     TRUE             Success.
//
// ----------------------------------------------------------------------------
EXTERN_C
BOOL
SqmCreateNewId(
    LPGUID pguid
    );

// ----------------------------------------------------------------------------
//
// Function:    SqmReadSharedMachineId
// Description: This function returns the SQM engine's shared machine ID.  The
//              SQM engine's shared machine ID is stored in the registry at
//              HKLM\System\SQM\Engine\MachineId.  Any application which uses
//              SQM may use this ID as the machine ID for its sessions.  If
//              this value does not exist in the registry, then any application
//              may create it using SqmWriteSharedMachineId.
//
// Parameters:
//
//     [OUT] pguid
//     The address to write the SQM engine's shared machine ID to.
//
// Return:
//
//     FALSE            Failure.  HKLM\System\SQM\Engine\MachineId does not
//                      exist.
//     TRUE             Success.
//
// ----------------------------------------------------------------------------
EXTERN_C
BOOL
SqmReadSharedMachineId(
    LPGUID pguid
    );

// ----------------------------------------------------------------------------
//
// Function:    SqmReadSharedUserId
// Description: This function returns the SQM engine's shared user ID.  The
//              SQM engine's shared user ID is stored in the registry at
//              HKLM\System\SQM\Engine\UserId.  Any application which uses
//              SQM may use this ID as the user ID for its sessions.  If
//              this value does not exist in the registry, then any application
//              may create it using SqmWriteSharedUserId.
//
// Parameters:
//
//     [OUT] pguid
//     The address to write the SQM engine's shared user ID to.
//
// Return:
//
//     FALSE            Failure.  HKLM\System\SQM\Engine\UserId does not exist.
//     TRUE             Success.
//
// ----------------------------------------------------------------------------
EXTERN_C
BOOL
SqmReadSharedUserId(
    LPGUID pguid
    );

// ----------------------------------------------------------------------------
//
// Function:    SqmWriteSharedMachineId
// Description: This function sets the SQM engine's shared machine ID.  The
//              SQM engine's shared machine ID is stored in the registry at
//              HKLM\System\SQM\Engine\MachineId.
//
// Parameters:
//
//     [IN] pguid
//     The address containing the machine ID to set as the SQM engine's shared
//     machine ID.
//
// Return:
//
//     FALSE            Failure.
//     TRUE             Success.
//
// ----------------------------------------------------------------------------
EXTERN_C
BOOL
SqmWriteSharedMachineId(
    LPGUID pguid
    );

// ----------------------------------------------------------------------------
//
// Function:    SqmWriteSharedUserId
// Description: This function sets the SQM engine's shared user ID.  The SQM
//              engine's shared user ID is stored in the registry at
//              HKLM\System\SQM\Engine\UserId.
//
// Parameters:
//
//     [OUT] pguid
//     The address containing the user ID to set as the SQM engine's shared
//     user ID.
//
// Return:
//
//     FALSE            Failure.
//     TRUE             Success.
//
// ----------------------------------------------------------------------------
EXTERN_C
BOOL
SqmWriteSharedUserId(
    LPGUID pguid
    );

// ----------------------------------------------------------------------------
//
// Function:    SqmSet
// Description: This function sets the value of the target datapoint to the
//              specified value.  If the target datapoint is not in the target
//              session, then it is added to the target session.
//
// Parameters:
//
//     [IN] hSession
//     The target session.  If this argument is NULL, then the default session
//     of the calling process is targeted.
//
//     [IN] dwId
//     The target datapoint.
//
//     [IN] dwVal
//     The value to set the value of the target datapoint to.
//
// Return:
//
//     None.
//
// ----------------------------------------------------------------------------
EXTERN_C
VOID
SqmSet(
    HSQMSESSION hSession,
    DWORD       dwId,
    DWORD       dwVal
    );

// ----------------------------------------------------------------------------
//
// Function:    SqmSetStringW
// Description: 
//	  Sets a single datapoint to the given Unicode string value
// Parameters:
//
//     [IN] hSession
//     The target session.  If this argument is NULL, then the default session
//     of the calling process is targeted.
//
//     [IN] dwId
//     The target datapoint
//
//     [IN] pwszVal
//     A unicode string value to add to the stream
//
// Return:
//
//     TRUE on success, FALSE on failure.  
//
// ----------------------------------------------------------------------------
EXTERN_C
BOOL
SqmSetStringW(
    HSQMSESSION hSession,
    DWORD       dwId,
    LPCWSTR		pwszVal
    );

// ----------------------------------------------------------------------------
//
// Function:    SqmIncrement
// Description: This function increments the value of the target datapoint by
//              the specified value.  If the target datapoint is not in the
//              target session, then it is added to the target session with an
//              initial value equal to that of the specified value.
//
// Parameters:
//
//     [IN] hSession
//     The target session.  If this argument is NULL, then the default session
//     of the calling process is targeted.
//
//     [IN] dwId
//     The target datapoint.
//
//     [IN] dwInc
//     The value by which to increment the value of the target datapoint.
//
// Return:
//
//     None.
//
// ----------------------------------------------------------------------------
EXTERN_C
VOID
SqmIncrement(
    HSQMSESSION hSession,
    DWORD       dwId,
    DWORD       dwInc
    );

// ----------------------------------------------------------------------------
//
// Function:    SqmSetBits
// Description: This function sets the value of the target datapoint to the
//              logical OR of the specified value and the value of the target
//              datapoint.  If the target datapoint is not in the target
//              session, then it is added to the target session with an initial
//              value equal to that of the specified value.
//
// Parameters:
//
//     [IN] hSession
//     The target session.  If this argument is NULL, then the default session
//     of the calling process is targeted.
//
//     [IN] dwId
//     The target datapoint.
//
//     [IN] dwOrBits
//     The value to logical OR with the value of the target datapoint.
//
// Return:
//
//     None.
//
// ----------------------------------------------------------------------------
EXTERN_C
VOID
SqmSetBits(
    HSQMSESSION hSession,
    DWORD       dwId,
    DWORD       dwOrBits
    );

// ----------------------------------------------------------------------------
//
// Function:    SqmSetIfMax
// Description: This function sets the value of the target datapoint to the
//              specified value if the specified value is greater than the
//              value of the target datapoint.  If the target datapoint is not
//              in the target session, then it is added to the target session
//              with an initial value equal to that of the specified value.
//
// Parameters:
//
//     [IN] hSession
//     The target session.  If this argument is NULL, then the default session
//     of the calling process is targeted.
//
//     [IN] dwId
//     The target datapoint.
//
//     [IN] dwVal
//     The value to set the value of the target datapoint to if it is greater
//     than the value of the target datapoint.
//
// Return:
//
//     None.
//
// ----------------------------------------------------------------------------
EXTERN_C
VOID
SqmSetIfMax(
    HSQMSESSION hSession,
    DWORD       dwId,
    DWORD       dwVal
    );

// ----------------------------------------------------------------------------
//
// Function:    SqmSetIfMin
// Description: This function sets the value of the target datapoint to the
//              specified value if the specified value is less than the value
//              of the target datapoint.  If the target datapoint is not in the
//              target session, then it is added to the target session with an
//              initial value equal to that of the specified value.
//
// Parameters:
//
//     [IN] hSession
//     The target session.  If this argument is NULL, then the default session
//     of the calling process is targeted.
//
//     [IN] dwId
//     The target datapoint.
//
//     [IN] dwVal
//     The value to set the value of the target datapoint to if it is less
//     than the value of the target datapoint.
//
// Return:
//
//     None.
//
// ----------------------------------------------------------------------------
EXTERN_C
VOID
SqmSetIfMin(
    HSQMSESSION hSession,
    DWORD       dwId,
    DWORD       dwVal
    );

// ----------------------------------------------------------------------------
//
// Function:    SqmAddToAverage
// Description: This function adds the specified value to the target datapoint
//              and increments the sample size of the target datapoint.
//              Moreover, this function marks the target datapoint as a
//              running-average datapoint.  If a target datapoint is marked as
//              a running-average datapoint, no other SQM functions should
//              target it.  Modifying the value of a datapoint marked as a
//              running-average datapoint with other SQM functions marks the
//              datapoint as a standard datapoint and resets its sample size.
//              If the target datapoint is not in the target session, then it
//              is added to the target session with an initial value equal to
//              that of the specified value.
//
// Parameters:
//
//     [IN] hSession
//     The target session.  If this argument is NULL, then the default session
//     of the calling process is targeted.
//
//     [IN] dwId
//     The target datapoint.
//
//     [IN] dwVal
//     The value to add to the value of the datapoint.
//
// Return:
//
//     None.
//
// ----------------------------------------------------------------------------
EXTERN_C
VOID
SqmAddToAverage(
    HSQMSESSION hSession,
    DWORD       dwId,
    DWORD       dwVal
    );

// ----------------------------------------------------------------------------
//
// Function:    SqmAddToStream
// Description: This function adds an entry to the target stream datapoint.  A
//              stream datapoint is an ordered list of DWORD n-tuples.  A
//              stream datapoint has a fixed width.  For example, a stream
//              datapoint of 3-tuples has a width of 3.  In general, a stream
//              datapoint of n-tuples has a width of n.  If the target stream
//              datapoint is not in the target session, then it is added to the
//              target session and its width is set to the value of the nArgs
//              argument and its first entry is populated with the supplied
//              arguments.  This function adds one entry to the target stream
//              datapoint.  This function fails silently if the specified
//              width does not match that of the target stream datapoint.
//
// Parameters:
//
//     [IN] hSession
//     The target session.  If this argument is NULL, then the default session
//     of the calling process is targeted.
//
//     [IN] dwId
//     The target datapoint.
//
//     [IN] nArgs
//     The width of the entry (i.e., the width of the stream datapoint).
//
//     [IN] ...
//
//     Arguments/entry.  nArgs DWORDs.
//
// Return:
//
//     None.
//
// ----------------------------------------------------------------------------
EXTERN_C
VOID
SqmAddToStream(
    HSQMSESSION hSession,
    DWORD       dwId,
    DWORD       nArgs,
    ...
    );

// ----------------------------------------------------------------------------
//
// Function:    SqmAddToStreamStringW
// Description: 
//	  Adds an Unicode String entry to a tuple in a stream datapoint
// Parameters:
//
//     [IN] hSession
//     The target session.  If this argument is NULL, then the default session
//     of the calling process is targeted.
//
//     [IN] dwId
//     The target stream ID
//
//     [IN] cTuple
//     The tuple to be operated on
//
//     [IN] pwszVal
//     A unicode string value to add to the stream
//
// Return:
//
//     TRUE on success, FALSE on failure.  
//
// ----------------------------------------------------------------------------
EXTERN_C
BOOL
SqmAddToStreamStringW(
    HSQMSESSION hSession,
    DWORD       dwId,
    DWORD       cTuple,
    LPCWSTR		pwszVal
    );


EXTERN_C
BOOL
SqmAddToStreamDWORD(
    HSQMSESSION hSession,
    DWORD       dwId,
    DWORD       cTuple,
    DWORD		dwVal
    );

// ----------------------------------------------------------------------------
//
// Function:    SqmGet
// Description: This function returns the value of the target datapoint.  If
//              the target datapoint is not in the target session, then it is
//              added to the target session with an initial value of 0.
//
// Parameters:
//
//     [IN] hSession
//     The target session.  If this argument is NULL, then the default session
//     of the calling process is targeted.
//
//     [IN] dwId
//     The target datapoint.
//
//     [OUT] pdwVal
//     The address to write the value of the target datapoint to.
//
// Return:
//
//     FALSE            Failure.  The target datapoint is not in the target
//                      session.  The target datapoint was added to the target
//                      session with an initial value of 0.
//     TRUE             Success.
//
// ----------------------------------------------------------------------------
EXTERN_C
BOOL
SqmGet(
    HSQMSESSION hSession,
    DWORD       dwId,
    LPDWORD     pdwVal
    );

// ----------------------------------------------------------------------------
//
// Function:    SqmSetAppVersion
// Description: This function sets the application version of the target
//              session.
//
// Parameters:
//
//     [IN] hSession
//     The target session.  If this argument is NULL, then the default session
//     of the calling process is targeted.
//
//     [IN] dwVersionHigh
//     High 32 bits of 64-bit application version number.
//
//     [IN] dwVersionLow
//     Low 32 bits of 64-bit application version number.
//
// Return:
//
//     None.
//
// ----------------------------------------------------------------------------
EXTERN_C
VOID
SqmSetAppVersion(
    HSQMSESSION hSession,
    DWORD       dwVersionHigh,
    DWORD       dwVersionLow
    );

// ----------------------------------------------------------------------------
//
// Function:    SqmTimerStart
// Description: This function starts the timer associated with the target
//              datapoint.  Each datapoint in a session is associated with a
//              timer.  SqmTimerRecord, SqmTimerAccumulate, and
//              SqmTimerAddToAverage are used to stop the timer and set its
//              duration as the value of the target datapoint.  Calling this
//              function again before calling SqmTimerRecord,
//              SqmTimerAccumulate or SqmTimerAddToAverage resets the timer.
//              If the target datapoint is not in the target session, then this
//              function fails silently.  The timer measures milliseconds.
//
// Parameters:
//
//     [IN] hSession
//     The target session.  If this argument is NULL, then the default session
//     of the calling process is targeted.
//
//     [IN] dwId
//     The target datapoint.
//
// Return:
//
//     None.
//
// ----------------------------------------------------------------------------
EXTERN_C
VOID
SqmTimerStart(
    HSQMSESSION hSession,
    DWORD       dwId
    );

// ----------------------------------------------------------------------------
//
// Function:    SqmTimerRecord
// Description: This function ends the timer associated with the target
//              datapoint and sets its duration as the value of the target
//              datapoint.  If the target datapoint is not in the target
//              session, then this function fails silently.  The timer
//              measures milliseconds.
//
// Parameters:
//
//     [IN] hSession
//     The target session.  If this argument is NULL, then the default session
//     of the calling process is targeted.
//
//     [IN] dwId
//     The target datapoint.
//
// Return:
//
//     None.
//
// ----------------------------------------------------------------------------
EXTERN_C
VOID
SqmTimerRecord(
    HSQMSESSION hSession,
    DWORD       dwId
    );

// ----------------------------------------------------------------------------
//
// Function:    SqmTimerAccumulate
// Description: This function ends the timer associated with the target
//              datapoint and adds its duration to the value of the target
//              datapoint.  If the target datapoint is not in the target
//              session, then this function fails silently.  The timer
//              measures milliseconds.
//
// Parameters:
//
//     [IN] hSession
//     The target session.  If this argument is NULL, then the default session
//     of the calling process is targeted.
//
//     [IN] dwId
//     The target datapoint.
//
// Return:
//
//     None.
//
// ----------------------------------------------------------------------------
EXTERN_C
VOID
SqmTimerAccumulate(
    HSQMSESSION hSession,
    DWORD       dwId
    );

// ----------------------------------------------------------------------------
//
// Function:    SqmTimerAddToAverage
// Description: This function ends the timer associated with the target
//              datapoint and adds its value to the value of the target
//              datapoint and increments the sample size of the target
//              datapoint.  Moreover, this function marks the target datapoint
//              as a running-average datapoint.  If the target datapoint is not
//              in the target session, then this function fails silently.  The
//              timer measures milliseconds.
//
// Parameters:
//
//     [IN] hSession
//     The target session.  If this argument is NULL, then the default session
//     of the calling process is targeted.
//
//     [IN] dwId
//     The target datapoint.
//
// Return:
//
//     None.
//
// ----------------------------------------------------------------------------
EXTERN_C
VOID
SqmTimerAddToAverage(
    HSQMSESSION hSession,
    DWORD       dwId
    );

// ----------------------------------------------------------------------------
//
// Function:    SqmSet64
// Description: This function sets the value of the target datapoint to the
//              specified value.  If the target datapoint is not in the target
//              session, then it is added to the target session.
//
// Parameters:
//
//     [IN] hSession
//     The target session.  If this argument is NULL, then the default session
//     of the calling process is targeted.
//
//     [IN] dwId
//     The target datapoint.
//
//     [IN] qwVal
//     The value to set the value of the target datapoint to.
//
// Return:
//
//     None.
//
// ----------------------------------------------------------------------------
EXTERN_C
VOID
SqmSet64(
    HSQMSESSION hSession,
    DWORD       dwId,
    DWORD64     qwVal
    );

// ----------------------------------------------------------------------------
//
// Function:    SqmSetBool
// Description: This function sets the value of the target datapoint to the
//              specified value.  If the target datapoint is not in the target
//              session, then it is added to the target session.
//
// Parameters:
//
//     [IN] hSession
//     The target session.  If this argument is NULL, then the default session
//     of the calling process is targeted.
//
//     [IN] dwId
//     The target datapoint.
//
//     [IN] dwVal
//     The value to set the value of the target datapoint to.
//
// Return:
//
//     None.
//
// ----------------------------------------------------------------------------

EXTERN_C
VOID
SqmSetBool(
    HSQMSESSION hSession,
    DWORD       dwId,
    DWORD       dwVal
    );

// ----------------------------------------------------------------------------
//
// Function:    SqmAddToStreamV
// Description: This function adds an entry to the target stream datapoint.  A
//              stream datapoint is an ordered list of DWORD n-tuples.  A
//              stream datapoint has a fixed width.  For example, a stream
//              datapoint of 3-tuples has a width of 3.  In general, a stream
//              datapoint of n-tuples has a width of n.  If the target stream
//              datapoint is not in the target session, then it is added to the
//              target session and its width is set to the value of the nArgs
//              argument and its first entry is populated with the supplied
//              arguments.  This function adds one entry to the target stream
//              datapoint.  This function fails silently if the specified
//              width does not match that of the target stream datapoint.
//
// Parameters:
//
//     [IN] hSession
//     The target session.  If this argument is NULL, then the default session
//     of the calling process is targeted.
//
//     [IN] dwId
//     The target datapoint.
//
//     [IN] nArgs
//     The width of the entry (i.e., the width of the stream datapoint).
//
//     [IN] argList
//
//     Arguments/entry.  nArgs DWORDs.
//
// Return:
//
//     None.
//
// ----------------------------------------------------------------------------
EXTERN_C
VOID
SqmAddToStreamV(
    HSQMSESSION hSession,
    DWORD       dwId,
    DWORD       nArgs,
    va_list     argList
    );

// ----------------------------------------------------------------------------
//
// Function:    SqmGet64
// Description: This function returns the value of the target datapoint.  If
//              the target datapoint is not in the target session, then it is
//              added to the target session with an initial value of 0.
//
// Parameters:
//
//     [IN] hSession
//     The target session.  If this argument is NULL, then the default session
//     of the calling process is targeted.
//
//     [IN] dwId
//     The target datapoint.
//
//     [OUT] pqwVal
//     The address to write the value of the target datapoint to.
//
// Return:
//
//     FALSE            Failure.  The target datapoint is not in the target
//                      session.  The target datapoint was added to the target
//                      session with an initial value of 0.
//     TRUE             Success.
//
// ----------------------------------------------------------------------------
EXTERN_C
BOOL
SqmGet64(
    HSQMSESSION hSession,
    DWORD       dwId,
    PDWORD64    pqwVal
    );

// Not supported.
typedef
BOOL
(WINAPI * SQMUPLOADCALLBACK)(
    HRESULT hr,
    LPCWSTR szFilePath,
    DWORD   dwHttpResponse
    );

// ----------------------------------------------------------------------------
//
// Function:    SqmStartUpload
// Description: This function initiates the uploading of the specified file
//              or set of files.
//
// Parameters:
//
//     [IN] pszPattern
//     The file path or set of files to upload.  If this value specifies a
//     fully-qualified path, then this function initiates the uploading of that
//     particular file.  If this value specifies a set of files, then it is
//     required to conform to the pattern specification defined by
//     SqmEndSession.
//
//     [IN] szUrl
//     The target (unsecure) URL.
//
//     [IN] szSecureUrl
//     The target secure URL.
//
//     [IN] dwFlags
//     Upload flags.  SQM_UPLOAD_SINGLE_FILE specifies that only the first file
//     that matches the supplied pattern is to be uploaded to the server.
//     SQM_UPLOAD_ALL_FILES specifies that all files that match the supplied
//     pattern are to be uploaded to the server.  SQM_UPLOAD_WHEN_CONVENIENT
//     specifies that the that the files that match the supplied pattern are
//     not required to be uploaded immediately.
//
//     [IN] pfnCallback
//     Not supported.  Ignore.
//
// Return:
//
//     The number of files queued for upload.
//
// ----------------------------------------------------------------------------
EXTERN_C
DWORD
SqmStartUpload(
    LPCWSTR           szPattern,
    LPCWSTR           szUrl,
    LPCWSTR           szSecureUrl,
    DWORD             dwFlags,
    SQMUPLOADCALLBACK pfnCallback
    );

#define SQM_UPLOAD_SINGLE_FILE     0x00000001
#define SQM_UPLOAD_ALL_FILES       0x00000002
#define SQM_UPLOAD_WHEN_CONVENIENT 0x80000000

// Not supported.
EXTERN_C
VOID
SqmAbortUpload(
    DWORD dwTimeoutMilliseconds
    );

// ----------------------------------------------------------------------------
//
// Function:    SqmSaveSession
// Description: This function saves the session data of the target persisent
//              session to non-volatile storage.
//
// Parameters:
//
//     [IN] hSession
//     The target session.  If this argument is NULL, then the default session
//     of the calling process is targeted.  If the target session or the
//     default session is not a persistent session, then this function has no
//     effect.
//
// Return:
//
//     None.
//
// ----------------------------------------------------------------------------
EXTERN_C
VOID
SqmSaveSession(
    HSQMSESSION hSession
    );

// ----------------------------------------------------------------------------
//
// Function:    SqmProxyCleanup
// Description: This function releases dynamically allocated resources within SqmProxy.lib.  If 
// this function is not called, the system will be forced to clean up the resources on process exit.
// The dynamically allocated resources will appear as a leak to AppVerifier if left to the system to 
// cleanup; calling SqmProxyCleanup() before exit will eliminate the leak.
//
// NOTE:  It is not safe to call SqmProxyCleanup() while there are other threads that may 
// concurrently make SQM API calls.
//
// Parameters:
//	 None.
//
// Return:
//     None.
//
// ----------------------------------------------------------------------------     
VOID 
SqmProxyCleanup();

#endif // SQMCLIENT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\sslsock.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++


Module Name:

    sslsock.h

Abstract:

    WinSock SSL external function prototypes and data declarations.

--*/

#ifndef __SSLSOCK_H__
#define __SSLSOCK_H__

#ifdef __cplusplus
extern "C" {
#endif


/*
 * Options and option values for creating a secure socket.
 */
#define SO_SECURE       0x2001          /* add security to socket */
#define SO_SEC_NONE     0x2002          /* security not used on socket */
#define SO_SEC_SSL      0x2004          /* use unified SSL/PCT for security */


//
// SSL PROVIDER_INFO security protocol tag
//

#define PROTOCOL_TLS           0xA1

//
// SSL WSAIoctl control code tags
//

#define SO_SSL_FAMILY                   0x00730000
#define SO_SSL_FAMILY_MASK              0x07ff0000

#define _SO_SSL                         ((2L << 27) | SO_SSL_FAMILY)

// Base SSL WSAIoctl tags
#define _SO_SSL_CAPABILITIES            0x01
#define _SO_SSL_FLAGS                   0x02
#define _SO_SSL_PROTOCOLS               0x03
#define _SO_SSL_CIPHERS                 0x04
#define _SO_SSL_CLIENT_OPTS             0x05
#define _SO_SSL_SERVER_OPTS             0x06
#define _SO_SSL_CLIENT_AUTH_OPTS        0x07
#define _SO_SSL_VALIDATE_CERT_HOOK      0x08
#define _SO_SSL_AUTH_REQUEST_HOOK       0x09
#define _SO_SSL_KEY_EXCH_HOOK           0x0a
#define _SO_SSL_SIGNATURE_HOOK          0x0b
#define _SO_SSL_PERFORM_HANDSHAKE       0x0d
#define _SO_SSL_CONNECTION_INFO         0x0e
#define _SO_SSL_PEERNAME                0x0f

// Actual SSL WSAIoctl commands
#define SO_SSL_GET_CAPABILITIES         (IOC_OUT | _SO_SSL | _SO_SSL_CAPABILITIES)
#define SO_SSL_SET_FLAGS                (IOC_IN  | _SO_SSL | _SO_SSL_FLAGS)
#define SO_SSL_GET_FLAGS                (IOC_OUT | _SO_SSL | _SO_SSL_FLAGS)
#define SO_SSL_SET_PROTOCOLS            (IOC_IN  | _SO_SSL | _SO_SSL_PROTOCOLS)
#define SO_SSL_GET_PROTOCOLS            (IOC_OUT | _SO_SSL | _SO_SSL_PROTOCOLS)
#define SO_SSL_SET_CIPHERS              (IOC_IN  | _SO_SSL | _SO_SSL_CIPHERS)
#define SO_SSL_GET_CIPHERS              (IOC_OUT | IOC_IN | _SO_SSL | _SO_SSL_CIPHERS)
#define SO_SSL_SET_CLIENT_OPTS          (IOC_IN  | _SO_SSL | _SO_SSL_CLIENT_OPTS)
#define SO_SSL_GET_CLIENT_OPTS          (IOC_OUT | _SO_SSL | _SO_SSL_CLIENT_OPTS)
#define SO_SSL_SET_SERVER_OPTS          (IOC_IN  | _SO_SSL | _SO_SSL_SERVER_OPTS)
#define SO_SSL_GET_SERVER_OPTS          (IOC_OUT | _SO_SSL | _SO_SSL_SERVER_OPTS)
#define SO_SSL_SET_CLIENT_AUTH_OPTS     (IOC_IN  | _SO_SSL | _SO_SSL_CLIENT_AUTH_OPTS)
#define SO_SSL_GET_CLIENT_AUTH_OPTS     (IOC_OUT | _SO_SSL | _SO_SSL_CLIENT_AUTH_OPTS)
#define SO_SSL_SET_VALIDATE_CERT_HOOK   (IOC_IN  | _SO_SSL | _SO_SSL_VALIDATE_CERT_HOOK)
#define SO_SSL_GET_VALIDATE_CERT_HOOK   (IOC_OUT | _SO_SSL | _SO_SSL_VALIDATE_CERT_HOOK)
#define SO_SSL_SET_AUTH_REQUEST_HOOK    (IOC_IN  | _SO_SSL | _SO_SSL_AUTH_REQUEST_HOOK)
#define SO_SSL_GET_AUTH_REQUEST_HOOK    (IOC_OUT | _SO_SSL | _SO_SSL_AUTH_REQUEST_HOOK)
#define SO_SSL_SET_KEY_EXCH_HOOK        (IOC_IN  | _SO_SSL | _SO_SSL_KEY_EXCH_HOOK)
#define SO_SSL_GET_KEY_EXCH_HOOK        (IOC_OUT | _SO_SSL | _SO_SSL_KEY_EXCH_HOOK)
#define SO_SSL_SET_SIGNATURE_HOOK       (IOC_IN  | _SO_SSL | _SO_SSL_SIGNATURE_HOOK)
#define SO_SSL_GET_SIGNATURE_HOOK       (IOC_OUT | _SO_SSL | _SO_SSL_SIGNATURE_HOOK)
#define SO_SSL_PERFORM_HANDSHAKE        (          _SO_SSL | _SO_SSL_PERFORM_HANDSHAKE)
#define SO_SSL_GET_CONNECTION_INFO      (IOC_OUT | _SO_SSL | _SO_SSL_CONNECTION_INFO)
#define SO_SSL_SET_PEERNAME             (IOC_OUT | _SO_SSL | _SO_SSL_PEERNAME)

//
// Error codes to be returned by the hook functions.
//

#define SSL_ERR_OKAY            0
#define SSL_ERR_FAILED          2
#define SSL_ERR_BAD_LEN         3
#define SSL_ERR_BAD_TYPE        4
#define SSL_ERR_BAD_DATA        5
#define SSL_ERR_NO_CERT         6
#define SSL_ERR_BAD_SIG         7
#define SSL_ERR_CERT_EXPIRED    8
#define SSL_ERR_CERT_REVOKED    9
#define SSL_ERR_CERT_UNKNOWN    10
#define SSL_ERR_SIGNATURE       11

//
// Definition copied from <winsock2.h>.
//

#ifndef _tagBLOB_DEFINED
#define _tagBLOB_DEFINED
#define _BLOB_DEFINED
#define _LPBLOB_DEFINED
typedef struct _BLOB {
    ULONG cbSize ;
#ifdef MIDL_PASS
    [size_is(cbSize)] BYTE *pBlobData;
#else  /* MIDL_PASS */
    BYTE *pBlobData ;
#endif /* MIDL_PASS */
} BLOB, *LPBLOB ;
#endif

//
// Declarations for _SO_SSL_CAPABILITIES
//

#define SSL_CAP_CLIENT          0x0001
#define SSL_CAP_SERVER          0x0002
#define SSL_CAP_CLIENT_AUTH     0x0004
#define SSL_CAP_CRYPTOAPI       0x0008

//
// Declarations for _SO_SSL_FLAGS
//

// Provider option flags.
#define SSL_FLAG_SERVER          0x0002
#define SSL_FLAG_AUTH_CLIENT     0x0004
#define SSL_FLAG_DEFER_HANDSHAKE 0x0008

//
// Declarations for _SO_SSL_PROTOCOLS
//

#define SSL_PROTOCOL_PCT1       1
#define SSL_PROTOCOL_SSL2       2
#define SSL_PROTOCOL_SSL3       3
#define SSL_PROTOCOL_TLS1       4

typedef struct _SSLPROTOCOL {
    DWORD dwProtocol;
    DWORD dwVersion;
    DWORD dwFlags;
} SSLPROTOCOL, FAR *LPSSLPROTOCOL;

typedef struct _SSLPROTOCOLS {
    DWORD dwCount;
    SSLPROTOCOL ProtocolList[1];   // array of 'count' structures
} SSLPROTOCOLS, FAR *LPSSLPROTOCOLS;

//
// Declarations for _SO_SSL_CIPHERS
//

typedef struct _SSLCIPHERS {
    DWORD dwProtocol;
    DWORD dwCount;
    DWORD CipherList[1];             // array of 'count' integers
} SSLCIPHERS, FAR *LPSSLCIPHERS;

//
// Declarations for _SO_SSL_CLIENT_OPTS
//

typedef struct _SSLCLIENTOPTS {
    __time32_t CacheTimeout;
    DWORD  dwCacheEntries;
    DWORD  dwFlags;
} SSLCLIENTOPTS, FAR *LPSSLCLIENTOPTS;

//
// Declarations for _SO_SSL_SERVER_OPTS
//

typedef struct _SSLSERVEROPTS {
    __time32_t CacheTimeout;
    DWORD  dwCacheEntries;
    DWORD  dwFlags;
} SSLSERVEROPTS, FAR *LPSSLSERVEROPTS;

//
// Declarations for _SO_SSL_CLIENT_AUTH_OPTS
//

typedef struct _SSLCLIENTAUTHOPTS {
    DWORD  dwRequestClientAuth;
    DWORD  dwRedoHandshake;
    DWORD  dwType;
    DWORD  dwIssuerCount;
    LPBLOB pIssuerList;
    DWORD  dwFlags;
} SSLCLIENTAUTHOPTS, FAR *LPSSLCLIENTAUTHOPTS;

//
// Declarations for _SO_SSL_VALIDATE_CERT_HOOK
//

#define SSL_CERT_X509       0x0001
#define SSL_CERT_FLAG_ISSUER_UNKNOWN 0x0001

typedef int (CALLBACK FAR *SSLVALIDATECERTFUNC)(
    DWORD  dwType,          // in
    LPVOID pvArg,           // in
    DWORD  dwChainLen,      // in
    LPBLOB pCertChain,      // in
    DWORD dwFlags);         // in

typedef struct _SSLVALIDATECERTHOOK {
    SSLVALIDATECERTFUNC HookFunc;
    LPVOID pvArg;
} SSLVALIDATECERTHOOK, FAR *LPSSLVALIDATECERTHOOK;

//
// Declarations for _SO_SSL_AUTH_REQUEST_HOOK
//

typedef int (CALLBACK FAR *SSLAUTHREQUESTFUNC)(
    DWORD         dwType,           // in
    LPVOID        pvArg,            // in
    DWORD         dwIssuerCount,    // in
    LPBLOB        pIssuerList,      // in
    DWORD         dwFlags,          // in
    LPDWORD       pdwChainLen,      // out
    LPBLOB        *ppCertChain);    // out

typedef struct _SSLAUTHREQUESTHOOK {
    SSLAUTHREQUESTFUNC HookFunc;
    LPVOID pvArg;
} SSLAUTHREQUESTHOOK, FAR *LPSSLAUTHREQUESTHOOK;

//
// Declarations for _SO_SSL_KEY_EXCH_HOOK
//

#define SSL_EXCH_RSAENCRYPT   1
#define SSL_EXCH_RSADECRYPT   2

typedef int (CALLBACK FAR *SSLKEYEXCHANGEFUNC)(
    DWORD   dwType,           // in
    LPVOID  pvArg,            // in
    LPBYTE  pSource,          // in
    DWORD   dwSourceLen,      // in
    DWORD   dwFlags,          // in
    LPBYTE  pDest,            // out
    LPDWORD pdwDestLen);      // in, out

typedef struct _SSLKEYEXCHANGEHOOK {
    SSLKEYEXCHANGEFUNC HookFunc;
    LPVOID pvArg;
} SSLKEYEXCHANGEHOOK, FAR *LPSSLKEYEXCHANGEHOOK;

//
// Declarations for _SO_SSL_SIGNATURE_HOOK
//

// Values for 'dwType'.
#define SSL_SIGN_RSA_MD2    1
#define SSL_SIGN_RSA_MD5    2
#define SSL_SIGN_RSA_SHA    3
#define SSL_SIGN_RSA_SHAMD5 4

// Values for 'dwFlags'.
#define SSL_SIGN_VERIFY_SIGNATURE   0x00000001
#define SSL_SIGN_PERFORM_HASH       0x00000002

typedef int (CALLBACK FAR *SSLSIGNATUREFUNC)(
    DWORD   dwType,           // in
    LPVOID  pvArg,            // in
    LPBYTE  pSource,          // in
    DWORD   dwSourceLen,      // in
    DWORD   dwFlags,          // in
    LPBYTE  pDest,            // out
    LPDWORD pdwDestLen);      // in, out

typedef struct _SSLSIGNATUREHOOK {
    SSLSIGNATUREFUNC HookFunc;
    LPVOID pvArg;
} SSLSIGNATUREHOOK, FAR *LPSSLSIGNATUREHOOK;

//
// ALG_ID definitions.
//

#ifndef ALGIDDEF

#define ALGIDDEF
typedef unsigned int ALG_ID;

// ALG_ID crackers
#define GET_ALG_CLASS(x)                (x & (7 << 13))
#define GET_ALG_TYPE(x)                 (x & (15 << 9))
#define GET_ALG_SID(x)                  (x & (511))

// Algorithm classes
#define ALG_CLASS_ANY                   (0)
#define ALG_CLASS_SIGNATURE             (1 << 13)
#define ALG_CLASS_MSG_ENCRYPT           (2 << 13)
#define ALG_CLASS_DATA_ENCRYPT          (3 << 13)
#define ALG_CLASS_HASH                  (4 << 13)
#define ALG_CLASS_KEY_EXCHANGE          (5 << 13)

// Algorithm types
#define ALG_TYPE_ANY                    (0)
#define ALG_TYPE_DSS                    (1 << 9)
#define ALG_TYPE_RSA                    (2 << 9)
#define ALG_TYPE_BLOCK                  (3 << 9)
#define ALG_TYPE_STREAM                 (4 << 9)
#define ALG_TYPE_DH                     (5 << 9)
#define ALG_TYPE_SECURECHANNEL          (6 << 9)

// Generic sub-ids
#define ALG_SID_ANY                     (0)

// Some RSA sub-ids
#define ALG_SID_RSA_ANY                 0
#define ALG_SID_RSA_PKCS                1
#define ALG_SID_RSA_MSATWORK            2
#define ALG_SID_RSA_ENTRUST             3
#define ALG_SID_RSA_PGP                 4

// Some DSS sub-ids
//
#define ALG_SID_DSS_ANY                 0
#define ALG_SID_DSS_PKCS                1
#define ALG_SID_DSS_DMS                 2

// Block cipher sub ids
// DES sub_ids
#define ALG_SID_DES                     1
#define ALG_SID_3DES                    3
#define ALG_SID_DESX                    4
#define ALG_SID_IDEA                    5
#define ALG_SID_CAST                    6
#define ALG_SID_SAFERSK64               7
#define ALD_SID_SAFERSK128              8
#define ALG_SID_3DES_112                9
#define ALG_SID_CYLINK_MEK              12

// Fortezza sub-ids
#define ALG_SID_SKIPJACK                10
#define ALG_SID_TEK                     11

// RC2 sub-ids
#define ALG_SID_RC2                     2

// Stream cipher sub-ids
#define ALG_SID_RC4                     1
#define ALG_SID_SEAL                    2

// Diffie-Hellman sub-ids
#define ALG_SID_DH_SANDF                1
#define ALG_SID_DH_EPHEM                2
#define ALG_SID_AGREED_KEY_ANY          3
#define ALG_SID_KEA                     4

// Hash sub ids
#define ALG_SID_MD2                     1
#define ALG_SID_MD4                     2
#define ALG_SID_MD5                     3
#define ALG_SID_SHA                     4
#define ALG_SID_SHA1                    4
#define ALG_SID_MAC                     5
#define ALG_SID_RIPEMD                  6
#define ALG_SID_RIPEMD160               7
#define ALG_SID_SSL3SHAMD5              8

// secure channel sub ids
#define ALG_SID_SSL3_MASTER             1
#define ALG_SID_SCHANNEL_MASTER_HASH    2
#define ALG_SID_SCHANNEL_MAC_KEY        3
#define ALG_SID_PCT1_MASTER             4
#define ALG_SID_SSL2_MASTER             5
#define ALG_SID_TLS1_MASTER             6
#define ALG_SID_SCHANNEL_ENC_KEY        7

// Our example sub-id
#define ALG_SID_EXAMPLE                 80

// algorithm identifier definitions
#define CALG_MD2                (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_MD2)
#define CALG_MD4                (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_MD4)
#define CALG_MD5                (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_MD5)
#define CALG_SHA                (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_SHA)
#define CALG_SHA1               (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_SHA1)
#define CALG_MAC                (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_MAC)
#define CALG_RSA_SIGN           (ALG_CLASS_SIGNATURE | ALG_TYPE_RSA | ALG_SID_RSA_ANY)
#define CALG_DSS_SIGN           (ALG_CLASS_SIGNATURE | ALG_TYPE_DSS | ALG_SID_DSS_ANY)
#define CALG_RSA_KEYX           (ALG_CLASS_KEY_EXCHANGE|ALG_TYPE_RSA|ALG_SID_RSA_ANY)
#define CALG_DES                (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_DES)
#define CALG_3DES_112           (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_3DES_112)
#define CALG_3DES               (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_3DES)
#define CALG_RC2                (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_RC2)
#define CALG_RC4                (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_STREAM|ALG_SID_RC4)
#define CALG_SEAL               (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_STREAM|ALG_SID_SEAL)
#define CALG_DH_SF              (ALG_CLASS_KEY_EXCHANGE|ALG_TYPE_DH|ALG_SID_DH_SANDF)
#define CALG_DH_EPHEM           (ALG_CLASS_KEY_EXCHANGE|ALG_TYPE_DH|ALG_SID_DH_EPHEM)
#define CALG_AGREEDKEY_ANY      (ALG_CLASS_KEY_EXCHANGE|ALG_TYPE_DH|ALG_SID_AGREED_KEY_ANY)
#define CALG_KEA_KEYX           (ALG_CLASS_KEY_EXCHANGE|ALG_TYPE_DH|ALG_SID_KEA)
#define CALG_HUGHES_MD5         (ALG_CLASS_KEY_EXCHANGE|ALG_TYPE_ANY|ALG_SID_MD5)
#define CALG_SKIPJACK           (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_SKIPJACK)
#define CALG_TEK                (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_TEK)
#define CALG_CYLINK_MEK         (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_CYLINK_MEK)
#define CALG_SSL3_SHAMD5        (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_SSL3SHAMD5)
#define CALG_SSL3_MASTER        (ALG_CLASS_MSG_ENCRYPT|ALG_TYPE_SECURECHANNEL|ALG_SID_SSL3_MASTER)
#define CALG_SCHANNEL_MASTER_HASH   (ALG_CLASS_MSG_ENCRYPT|ALG_TYPE_SECURECHANNEL|ALG_SID_SCHANNEL_MASTER_HASH)
#define CALG_SCHANNEL_MAC_KEY   (ALG_CLASS_MSG_ENCRYPT|ALG_TYPE_SECURECHANNEL|ALG_SID_SCHANNEL_MAC_KEY)
#define CALG_SCHANNEL_ENC_KEY   (ALG_CLASS_MSG_ENCRYPT|ALG_TYPE_SECURECHANNEL|ALG_SID_SCHANNEL_ENC_KEY)
#define CALG_PCT1_MASTER        (ALG_CLASS_MSG_ENCRYPT|ALG_TYPE_SECURECHANNEL|ALG_SID_PCT1_MASTER)
#define CALG_SSL2_MASTER        (ALG_CLASS_MSG_ENCRYPT|ALG_TYPE_SECURECHANNEL|ALG_SID_SSL2_MASTER)
#define CALG_TLS1_MASTER        (ALG_CLASS_MSG_ENCRYPT|ALG_TYPE_SECURECHANNEL|ALG_SID_TLS1_MASTER)

#endif // !ALGIDDEF

//
// Declarations for _SO_SSL_GET_CONNECTION_INFO
//

typedef struct _SSLCONNECTIONINFO
{
    DWORD   dwProtocol;
    ALG_ID  aiCipher;
    DWORD   dwCipherStrength;
    ALG_ID  aiHash;
    DWORD   dwHashStrength;
    ALG_ID  aiExch;
    DWORD   dwExchStrength;
} SSLCONNECTIONINFO, FAR *PSSLCONNECTIONINFO;

//
// dwProtocol bit array values. These are identical to the SP_PROT_xxx values in schnlsp.h
//

#define SSL_PROT_PCT1_SERVER        0x00000001		// obsolete
#define SSL_PROT_PCT1_CLIENT        0x00000002		// obsolete
#define SSL_PROT_SSL2_SERVER        0x00000004
#define SSL_PROT_SSL2_CLIENT        0x00000008
#define SSL_PROT_SSL3_SERVER        0x00000010
#define SSL_PROT_SSL3_CLIENT        0x00000020
#define SSL_PROT_TLS1_SERVER        0x00000040
#define SSL_PROT_TLS1_CLIENT        0x00000080

#ifdef __cplusplus
}
#endif

#endif //__SSLSOCK_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\sslprovider.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++

Module Name:

    sslprovider.h

Abstract:

    SSL protocol provider API prototypes and definitions 

Author:

    John Banes (jbanes)     October 6, 2004

Revision History:

--*/

#ifndef __SSL_PROVIDER_H__
#define __SSL_PROVIDER_H__

#include <wincrypt.h>

#ifdef __cplusplus
extern "C" 
{
#endif

//
// Microsoft built-in providers.
//

#define MS_SCHANNEL_PROVIDER            L"Microsoft SSL Protocol Provider"


#define NCRYPT_SSL_CLIENT_FLAG  0x00000001
#define NCRYPT_SSL_SERVER_FLAG  0x00000002


//
// SSL Protocols and Cipher Suites
//

// Protocols
#define SSL2_PROTOCOL_VERSION       0x0002
#define SSL3_PROTOCOL_VERSION       0x0300
#define TLS1_PROTOCOL_VERSION       0x0301

// Cipher suites
#define TLS_RSA_WITH_NULL_MD5                       0x0001
#define TLS_RSA_WITH_NULL_SHA                       0x0002
#define TLS_RSA_EXPORT_WITH_RC4_40_MD5              0x0003
#define TLS_RSA_WITH_RC4_128_MD5                    0x0004
#define TLS_RSA_WITH_RC4_128_SHA                    0x0005
#define TLS_RSA_WITH_DES_CBC_SHA                    0x0009
#define TLS_RSA_WITH_3DES_EDE_CBC_SHA               0x000A
#define TLS_DHE_DSS_WITH_DES_CBC_SHA                0x0012
#define TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA           0x0013
#define TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA           0x0016
#define TLS_RSA_WITH_AES_128_CBC_SHA                0x002F
#define TLS_DHE_DSS_WITH_AES_128_CBC_SHA            0x0032
#define TLS_DHE_RSA_WITH_AES_128_CBC_SHA            0x0033
#define TLS_RSA_WITH_AES_256_CBC_SHA                0x0035
#define TLS_DHE_DSS_WITH_AES_256_CBC_SHA            0x0038
#define TLS_DHE_RSA_WITH_AES_256_CBC_SHA            0x0039
#define TLS_RSA_EXPORT1024_WITH_DES_CBC_SHA         0x0062
#define TLS_DHE_DSS_EXPORT1024_WITH_DES_CBC_SHA     0x0063
#define TLS_RSA_EXPORT1024_WITH_RC4_56_SHA          0x0064

// TODO: vrobbins 10/16/05 update these once ECC TLS ietf has them
#define TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA        0xc009
#define TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA          0xc013
#define TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA        0xc00a
#define TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA          0xc014
 

// SSL2 cipher suites
#define SSL_CK_RC4_128_WITH_MD5                     0x010080
#define SSL_CK_RC4_128_EXPORT40_WITH_MD5            0x020080
#define SSL_CK_RC2_128_CBC_WITH_MD5                 0x030080
#define SSL_CK_RC2_128_CBC_EXPORT40_WITH_MD5        0x040080
#define SSL_CK_IDEA_128_CBC_WITH_MD5                0x050080
#define SSL_CK_DES_64_CBC_WITH_MD5                  0x060040
#define SSL_CK_DES_192_EDE3_CBC_WITH_MD5            0x0700C0

// Key Types
// ECC curve types
#define TLS_ECC_P256_CURVE_KEY_TYPE                 23
#define TLS_ECC_P384_CURVE_KEY_TYPE                 24
#define TLS_ECC_P521_CURVE_KEY_TYPE                 25

// definition for algorithms used by ssl provider
#define SSL_ECDSA_ALGORITHM                    L"ECDSA"

#define NCRYPT_SSL_MAX_NAME_SIZE            64


typedef struct _NCRYPT_SSL_CIPHER_SUITE
{
    DWORD dwProtocol;
    DWORD dwCipherSuite;
    DWORD dwBaseCipherSuite;
    WCHAR szCipherSuite[NCRYPT_SSL_MAX_NAME_SIZE];
    WCHAR szCipher[NCRYPT_SSL_MAX_NAME_SIZE];
    DWORD dwCipherLen;
    DWORD dwCipherBlockLen;    // in bytes
    WCHAR szHash[NCRYPT_SSL_MAX_NAME_SIZE];
    DWORD dwHashLen;
    WCHAR szExchange[NCRYPT_SSL_MAX_NAME_SIZE];
    DWORD dwMinExchangeLen;
    DWORD dwMaxExchangeLen;
    WCHAR szCertificate[NCRYPT_SSL_MAX_NAME_SIZE];
    DWORD dwKeyType;
} NCRYPT_SSL_CIPHER_SUITE;


//+-------------------------------------------------------------------------
// SslChangeNotify
//
// This function is used to register for changes to the SSL protocol 
// provider configuration settings. 
//--------------------------------------------------------------------------
SECURITY_STATUS
WINAPI
SslChangeNotify(
    IN     HANDLE   hEvent,
    IN     DWORD    dwFlags);


//+-------------------------------------------------------------------------
// SslComputeClientAuthHash
//
// Computes the hashes that are sent in the CertificateVerify handshake 
// message. 
//--------------------------------------------------------------------------
SECURITY_STATUS
WINAPI
SslComputeClientAuthHash(
    __in    NCRYPT_PROV_HANDLE hSslProvider,
    __in    NCRYPT_KEY_HANDLE hMasterKey,
    __in    NCRYPT_HASH_HANDLE hHandshakeHash,
    __in    LPCWSTR pszAlgId,
    __out_bcount_part_opt(cbOutput, *pcbResult) PBYTE pbOutput,
    __in    DWORD   cbOutput,
    __out   DWORD * pcbResult,
    __in    DWORD   dwFlags);

typedef SECURITY_STATUS
(WINAPI * SslComputeClientAuthHashFn)(
    __in    NCRYPT_PROV_HANDLE hSslProvider,
    __in    NCRYPT_KEY_HANDLE hMasterKey,
    __in    NCRYPT_HASH_HANDLE hHandshakeHash,
    __in    LPCWSTR pszAlgId,
    __out_bcount_part_opt(cbOutput, *pcbResult) PBYTE pbOutput,
    __in    DWORD   cbOutput,
    __out   DWORD * pcbResult,
    __in    DWORD   dwFlags);

//+-------------------------------------------------------------------------
// SslComputeEapKeyBlock
//
// Computes the key block used by EAP
//     pbRandoms must be client_random + server_random (client random
//     concatenated with the server random).
//--------------------------------------------------------------------------
SECURITY_STATUS
WINAPI
SslComputeEapKeyBlock(
    __in    NCRYPT_PROV_HANDLE hSslProvider,
    __in    NCRYPT_KEY_HANDLE hMasterKey,
    __in_bcount(cbRandoms) PBYTE pbRandoms,
    __in    DWORD   cbRandoms,
    __out_bcount_part_opt(cbOutput, *pcbResult) PBYTE pbOutput,
    __in    DWORD   cbOutput,
    __out   DWORD * pcbResult,
    __in    DWORD   dwFlags);

typedef SECURITY_STATUS
(WINAPI * SslComputeEapKeyBlockFn)(
    __in    NCRYPT_PROV_HANDLE hSslProvider,
    __in    NCRYPT_KEY_HANDLE hMasterKey,
    __in_bcount(cbRandoms) PBYTE pbRandoms,
    __in    DWORD   cbRandoms,
    __out_bcount_part_opt(cbOutput, *pcbResult) PBYTE pbOutput,
    __in    DWORD   cbOutput,
    __out   DWORD * pcbResult,
    __in    DWORD   dwFlags);

//
//  SslComputeEapKeyBlock flags
//

#define NCRYPT_SSL_EAP_PRF_FIELD    0x000000ff
#define NCRYPT_SSL_EAP_ID           0x00000000
#define NCRYPT_SSL_EAP_TTLSV0_ID    0x00000001
#define NCRYPT_SSL_EAP_TTLSV0_CHLNG_ID  0x00000002
#define NCRYPT_SSL_EAP_FAST_ID      0x00000003

//+-------------------------------------------------------------------------
// SslComputeFinishedHash
//
// Computes the hashes that are sent in the Finished handshake message. 
//--------------------------------------------------------------------------
SECURITY_STATUS
WINAPI
SslComputeFinishedHash(
    __in    NCRYPT_PROV_HANDLE hSslProvider,
    __in    NCRYPT_KEY_HANDLE hMasterKey,
    __in    NCRYPT_HASH_HANDLE hHandshakeHash,
    __out_bcount_full(cbOutput) PBYTE pbOutput,
    __in    DWORD   cbOutput,
    __in    DWORD   dwFlags);

typedef SECURITY_STATUS
(WINAPI * SslComputeFinishedHashFn)(
    __in    NCRYPT_PROV_HANDLE hSslProvider,
    __in    NCRYPT_KEY_HANDLE hMasterKey,
    __in    NCRYPT_HASH_HANDLE hHandshakeHash,
    __out_bcount_full(cbOutput) PBYTE pbOutput,
    __in    DWORD   cbOutput,
    __in    DWORD   dwFlags);

//+-------------------------------------------------------------------------
// SslCreateEphemeralKey
//
// Creates an ephemeral key. 
//--------------------------------------------------------------------------
SECURITY_STATUS
WINAPI
SslCreateEphemeralKey(
    __in    NCRYPT_PROV_HANDLE hSslProvider,
    __out   NCRYPT_KEY_HANDLE *phEphemeralKey,
    __in    DWORD   dwProtocol,
    __in    DWORD   dwCipherSuite,
    __in    DWORD   dwKeyType,
    __in    DWORD   dwKeyBitLen,
    __in_bcount_opt(cbParams) PBYTE pbParams,
    __in    DWORD   cbParams,
    __in    DWORD   dwFlags);

typedef SECURITY_STATUS
(WINAPI * SslCreateEphemeralKeyFn)(
    __in    NCRYPT_PROV_HANDLE hSslProvider,
    __out   NCRYPT_KEY_HANDLE *phEphemeralKey,
    __in    DWORD   dwProtocol,
    __in    DWORD   dwCipherSuite,
    __in    DWORD   dwKeyType,
    __in    DWORD   dwKeyBitLen,
    __in_bcount(cbParams) PBYTE pbParams,
    __in    DWORD   cbParams,
    __in    DWORD   dwFlags);


//+-------------------------------------------------------------------------
// SslCreateHandshakeHash
//
// Creates a compound hash object used to hash handshake messages. 
//--------------------------------------------------------------------------
SECURITY_STATUS
WINAPI
SslCreateHandshakeHash(
    __in    NCRYPT_PROV_HANDLE hSslProvider,
    __out   NCRYPT_HASH_HANDLE *phHandshakeHash,
    __in    DWORD   dwProtocol,
    __in    DWORD   dwCipherSuite,
    __in    DWORD   dwFlags);

typedef SECURITY_STATUS
(WINAPI * SslCreateHandshakeHashFn)(
    __in    NCRYPT_PROV_HANDLE hSslProvider,
    __out   NCRYPT_HASH_HANDLE *phHandshakeHash,
    __in    DWORD   dwProtocol,
    __in    DWORD   dwCipherSuite,
    __in    DWORD   dwFlags);


//+-------------------------------------------------------------------------
// SslDecryptPacket
//
// Decrypts a single SSL packet.
//--------------------------------------------------------------------------
SECURITY_STATUS
WINAPI
SslDecryptPacket(
    __in    NCRYPT_PROV_HANDLE hSslProvider,
    __inout NCRYPT_KEY_HANDLE hKey,
    __in_bcount(cbInput) PBYTE pbInput,
    __in    DWORD   cbInput,
    __out_bcount_part_opt(cbOutput, *pcbResult) PBYTE pbOutput,
    __in    DWORD   cbOutput,
    __out   DWORD * pcbResult,
    __in    ULONGLONG SequenceNumber,
    __in    DWORD   dwFlags);

typedef SECURITY_STATUS
(WINAPI * SslDecryptPacketFn)(
    __in    NCRYPT_PROV_HANDLE hSslProvider,
    __inout NCRYPT_KEY_HANDLE hKey,
    __in_bcount(cbInput) PBYTE pbInput,
    __in    DWORD   cbInput,
    __out_bcount_part_opt(cbOutput, *pcbResult) PBYTE pbOutput,
    __in    DWORD   cbOutput,
    __out   DWORD * pcbResult,
    __in    ULONGLONG SequenceNumber,
    __in    DWORD   dwFlags);


//+-------------------------------------------------------------------------
// SslEncryptPacket
//
// Encrypts a single SSL packet.
//--------------------------------------------------------------------------
SECURITY_STATUS
WINAPI
SslEncryptPacket(
    __in    NCRYPT_PROV_HANDLE hSslProvider,
    __inout NCRYPT_KEY_HANDLE hKey,
    __in_bcount(cbInput) PBYTE pbInput,
    __in    DWORD   cbInput,
    __out_bcount_part_opt(cbOutput, *pcbResult) PBYTE pbOutput,
    __in    DWORD   cbOutput,
    __out   DWORD * pcbResult,
    __in    ULONGLONG SequenceNumber,
    __in    DWORD   dwContentType, 
    __in    DWORD   dwFlags);

typedef SECURITY_STATUS
(WINAPI * SslEncryptPacketFn)(
    __in    NCRYPT_PROV_HANDLE hSslProvider,
    __inout NCRYPT_KEY_HANDLE hKey,
    __in_bcount(cbInput) PBYTE pbInput,
    __in    DWORD   cbInput,
    __out_bcount_part_opt(cbOutput, *pcbResult) PBYTE pbOutput,
    __in    DWORD   cbOutput,
    __out   DWORD * pcbResult,
    __in    ULONGLONG SequenceNumber,
    __in    DWORD   dwContentType, 
    __in    DWORD   dwFlags);


//+-------------------------------------------------------------------------
// SslEnumCipherSuites
//
// This function is used to enumerate the list of cipher suites supported 
// by an SSL protocol provider. If a private key handle is specified, then
// this function will only return cipher suites that are compatible with
// the private key.
//--------------------------------------------------------------------------
SECURITY_STATUS
WINAPI
SslEnumCipherSuites(
    __in    NCRYPT_PROV_HANDLE hSslProvider,
    __in_opt NCRYPT_KEY_HANDLE hPrivateKey,
    __deref_out NCRYPT_SSL_CIPHER_SUITE **ppCipherSuite,
    __inout PVOID * ppEnumState,
    __in    DWORD   dwFlags);

typedef SECURITY_STATUS
(WINAPI * SslEnumCipherSuitesFn)(
    __in    NCRYPT_PROV_HANDLE hSslProvider,
    __in_opt NCRYPT_KEY_HANDLE hPrivateKey,
    __deref_out NCRYPT_SSL_CIPHER_SUITE **ppCipherSuite,
    __inout PVOID * ppEnumState,
    __in    DWORD   dwFlags);

    
//+-------------------------------------------------------------------------
// SslEnumProtocolProviders
//
// Returns a list of all the SSL protocol providers that are currently 
// installed on the system.
//--------------------------------------------------------------------------
SECURITY_STATUS
WINAPI
SslEnumProtocolProviders(
    __out   DWORD * pdwProviderCount,
    __deref_out NCryptProviderName **ppProviderList,
    __in    DWORD   dwFlags);


//+-------------------------------------------------------------------------
// SslExportKey
// 
// Exports an SSL session key into a serialized blob.
//--------------------------------------------------------------------------
SECURITY_STATUS
WINAPI
SslExportKey(
    __in    NCRYPT_PROV_HANDLE hSslProvider,
    __in    NCRYPT_KEY_HANDLE hKey,
    __in    LPCWSTR pszBlobType,
    __out_bcount_part_opt(cbOutput, *pcbResult) PBYTE pbOutput,
    __in    DWORD   cbOutput,
    __out   DWORD * pcbResult,
    __in    DWORD   dwFlags);

typedef SECURITY_STATUS
(WINAPI * SslExportKeyFn)(
    __in    NCRYPT_PROV_HANDLE hSslProvider,
    __in    NCRYPT_KEY_HANDLE hKey,
    __in    LPCWSTR pszBlobType,
    __out_bcount_part_opt(cbOutput, *pcbResult) PBYTE pbOutput,
    __in    DWORD   cbOutput,
    __out   DWORD * pcbResult,
    __in    DWORD   dwFlags);


//+-------------------------------------------------------------------------
// SslFreeBuffer
//
// Frees a memory buffer that was allocated by one of the other SSL protocol
// provider functions.
//--------------------------------------------------------------------------
SECURITY_STATUS
WINAPI
SslFreeBuffer(
    __deref PVOID   pvInput);

typedef SECURITY_STATUS
(WINAPI * SslFreeBufferFn)(
    __deref PVOID   pvInput);


//+-------------------------------------------------------------------------
// SslFreeObject
//
// Frees a key, hash, or provider object that was created using one of the
// other SSL protocol provider functions.
//--------------------------------------------------------------------------
SECURITY_STATUS
WINAPI
SslFreeObject(
    __deref NCRYPT_HANDLE hObject,
    __in    DWORD   dwFlags);

typedef SECURITY_STATUS
(WINAPI * SslFreeObjectFn)(
    __deref NCRYPT_HANDLE hObject,
    __in    DWORD   dwFlags);


//+-------------------------------------------------------------------------
// SslGenerateMasterKey
//
// Perform an SSL key exchange operations. This function computes the SSL
// master secret, and returns a handle to this object to the caller. This 
// master key can then be used to derive the SSL session keys and finish
// the SSL handshake.
//
// When RSA key exchange is being performed, the client-side of schannel
// calls SslGenerateMasterKey and the server-side of schannel calls 
// SslImportMasterKey. When DH key exchange is being performed, schannel
// calls SslGenerateMasterKey on both the client-side and the server-side.
//--------------------------------------------------------------------------
SECURITY_STATUS
WINAPI
SslGenerateMasterKey(
    __in    NCRYPT_PROV_HANDLE hSslProvider,
    __in_opt NCRYPT_KEY_HANDLE hPrivateKey,
    __in    NCRYPT_KEY_HANDLE hPublicKey,
    __out   NCRYPT_KEY_HANDLE *phMasterKey,
    __in    DWORD   dwProtocol,
    __in    DWORD   dwCipherSuite,
    __in    PNCryptBufferDesc pParameterList,
    __out_bcount_part_opt(cbOutput, *pcbResult) PBYTE pbOutput,
    __in    DWORD   cbOutput,
    __out   DWORD * pcbResult,
    __in    DWORD   dwFlags);

typedef SECURITY_STATUS
(WINAPI * SslGenerateMasterKeyFn)(
    __in    NCRYPT_PROV_HANDLE hSslProvider,
    __in_opt NCRYPT_KEY_HANDLE hPrivateKey,
    __in    NCRYPT_KEY_HANDLE hPublicKey,
    __out   NCRYPT_KEY_HANDLE *phMasterKey,
    __in    DWORD   dwProtocol,
    __in    DWORD   dwCipherSuite,
    __in    PNCryptBufferDesc pParameterList,
    __out_bcount_part_opt(cbOutput, *pcbResult) PBYTE pbOutput,
    __in    DWORD   cbOutput,
    __out   DWORD * pcbResult,
    __in    DWORD   dwFlags);


//+-------------------------------------------------------------------------
// SslGenerateSessionKeys
//
// Generates a set of session keys, based on a supplied master secret and
// one or more additional parameters.
//--------------------------------------------------------------------------
SECURITY_STATUS
WINAPI
SslGenerateSessionKeys(
    __in    NCRYPT_PROV_HANDLE hSslProvider,
    __in    NCRYPT_KEY_HANDLE hMasterKey,
    __out   NCRYPT_KEY_HANDLE *phReadKey,
    __out   NCRYPT_KEY_HANDLE *phWriteKey,
    __in    PNCryptBufferDesc pParameterList,
    __in    DWORD   dwFlags);

typedef SECURITY_STATUS
(WINAPI * SslGenerateSessionKeysFn)(
    __in    NCRYPT_PROV_HANDLE hSslProvider,
    __in    NCRYPT_KEY_HANDLE hMasterKey,
    __out   NCRYPT_KEY_HANDLE *phReadKey,
    __out   NCRYPT_KEY_HANDLE *phWriteKey,
    __in    PNCryptBufferDesc pParameterList,
    __in    DWORD   dwFlags);

// SSL provider property names.
#define SSL_KEY_TYPE_PROPERTY                L"KEYTYPE"

//+-------------------------------------------------------------------------
// SslGetKeyProperty
//
// Queries information from the key.
//--------------------------------------------------------------------------
SECURITY_STATUS
WINAPI
SslGetKeyProperty(
    __in    NCRYPT_KEY_HANDLE hKey,
    __in    LPCWSTR pszProperty,
    __deref_out_bcount(*pcbOutput) PBYTE *ppbOutput,
    __out   DWORD * pcbOutput,
    __in    DWORD   dwFlags);
    
typedef SECURITY_STATUS
(WINAPI * SslGetKeyPropertyFn)(
    __in    NCRYPT_KEY_HANDLE hKey,
    __in    LPCWSTR pszProperty,
    __deref_out_bcount(*pcbOutput) PBYTE *ppbOutput,
    __out   DWORD * pcbOutput,
    __in    DWORD   dwFlags);


//+-------------------------------------------------------------------------
// SslGetProviderProperty
//
// Queries information from the protocol provider.
//--------------------------------------------------------------------------
SECURITY_STATUS
WINAPI
SslGetProviderProperty(
    __in    NCRYPT_PROV_HANDLE hSslProvider,
    __in    LPCWSTR pszProperty,
    __deref_out_bcount(*pcbOutput) PBYTE *ppbOutput,
    __out   DWORD * pcbOutput,
    __inout_opt PVOID *ppEnumState,
    __in    DWORD   dwFlags);
    
typedef SECURITY_STATUS
(WINAPI * SslGetProviderPropertyFn)(
    __in    NCRYPT_PROV_HANDLE hSslProvider,
    __in    LPCWSTR pszProperty,
    __deref_out_bcount(*pcbOutput) PBYTE *ppbOutput,
    __out   DWORD * pcbOutput,
    __inout_opt PVOID *ppEnumState,
    __in    DWORD   dwFlags);


//+-------------------------------------------------------------------------
// SslHashHandshake
//
// Adds a handshake message to the cumulative handshake hash object. This
// handshake hash is used when generating or processing Finished and 
// CertificateVerify messages.
//--------------------------------------------------------------------------
SECURITY_STATUS
WINAPI
SslHashHandshake(
    __in    NCRYPT_PROV_HANDLE hSslProvider,
    __inout NCRYPT_HASH_HANDLE hHandshakeHash,
    __in_bcount(cbInput) PBYTE pbInput,
    __in    DWORD   cbInput,
    __in    DWORD   dwFlags);

typedef SECURITY_STATUS
(WINAPI * SslHashHandshakeFn)(
    __in    NCRYPT_PROV_HANDLE hSslProvider,
    __inout NCRYPT_HASH_HANDLE hHandshakeHash,
    __in_bcount(cbInput) PBYTE pbInput,
    __in    DWORD   cbInput,
    __in    DWORD   dwFlags);


//+-------------------------------------------------------------------------
// SslImportKey
//
// Imports a public key into the protocol provider, as part of a key 
// exchange operation. This function is also used to import session keys, 
// when transferring them from one process to another.
//--------------------------------------------------------------------------
SECURITY_STATUS
WINAPI
SslImportKey(
    __in    NCRYPT_PROV_HANDLE hSslProvider,
    __out   NCRYPT_KEY_HANDLE *phKey,
    __in    LPCWSTR pszBlobType,
    __in_bcount(cbKeyBlob) PBYTE pbKeyBlob,
    __in    DWORD   cbKeyBlob,
    __in    DWORD   dwFlags);

typedef SECURITY_STATUS
(WINAPI * SslImportKeyFn)(
    __in    NCRYPT_PROV_HANDLE hSslProvider,
    __out   NCRYPT_KEY_HANDLE *phKey,
    __in    LPCWSTR pszBlobType,
    __in_bcount(cbKeyBlob) PBYTE pbKeyBlob,
    __in    DWORD   cbKeyBlob,
    __in    DWORD   dwFlags);


//+-------------------------------------------------------------------------
// SslImportMasterKey
//
// This function is used when performing a server-side SSL key exchange 
// operation. This function decrypts the pre-master secret, computes the 
// SSL master secret, and returns a handle to this object to the caller. 
// This master key can then be used to derive the SSL session keys, and 
// finish the SSL handshake.
//
// Note that this function is only used when the RSA key exchange algorithm
// is being used. When DH is used, then the server-side of schannel calls 
// SslGenerateMasterKey instead.
//--------------------------------------------------------------------------
SECURITY_STATUS
WINAPI
SslImportMasterKey(
    __in    NCRYPT_PROV_HANDLE hSslProvider,
    __in    NCRYPT_KEY_HANDLE hPrivateKey,
    __out   NCRYPT_KEY_HANDLE *phMasterKey,
    __in    DWORD   dwProtocol,
    __in    DWORD   dwCipherSuite,
    __in    NCryptBufferDesc *pParameterList,
    __in_bcount(cbEncryptedKey) PBYTE pbEncryptedKey,
    __in    DWORD   cbEncryptedKey,
    __in    DWORD   dwFlags);

typedef SECURITY_STATUS
(WINAPI * SslImportMasterKeyFn)(
    __in    NCRYPT_PROV_HANDLE hSslProvider,
    __in    NCRYPT_KEY_HANDLE hPrivateKey,
    __out   NCRYPT_KEY_HANDLE *phMasterKey,
    __in    DWORD   dwProtocol,
    __in    DWORD   dwCipherSuite,
    __in    NCryptBufferDesc *pParameterList,
    __in_bcount(cbEncryptedKey) PBYTE pbEncryptedKey,
    __in    DWORD   cbEncryptedKey,
    __in    DWORD   dwFlags);

//+-------------------------------------------------------------------------
// SslLookupCipherSuiteInfo
//
// Looks up cipher suite information given the suite number and a key type.
//--------------------------------------------------------------------------
SECURITY_STATUS
WINAPI
SslLookupCipherSuiteInfo(
    __in    NCRYPT_PROV_HANDLE hSslProvider,
    __in    DWORD dwProtocol,
    __in    DWORD dwCipherSuite,
    __in    DWORD dwKeyType,
    __out   NCRYPT_SSL_CIPHER_SUITE *pCipherSuite,
    __in    DWORD   dwFlags);

typedef SECURITY_STATUS
(WINAPI * SslLookupCipherSuiteInfoFn)(
    __in    NCRYPT_PROV_HANDLE hSslProvider,
    __in    DWORD dwProtocol,
    __in    DWORD dwCipherSuite,
    __in    DWORD dwKeyType,
    __out   NCRYPT_SSL_CIPHER_SUITE *pCipherSuite,
    __in    DWORD   dwFlags);

//+-------------------------------------------------------------------------
// SslOpenPrivateKey
//
// This function is used to obtain a handle to the private key that 
// corresponds to the passed in server certificate. This handle will be used
// by the server-side of Schannel when performing key exchange operations.
//--------------------------------------------------------------------------
SECURITY_STATUS
WINAPI
SslOpenPrivateKey(
    __in   NCRYPT_PROV_HANDLE hSslProvider,
    __out  NCRYPT_KEY_HANDLE *phPrivateKey,
    __in   PCCERT_CONTEXT pCertContext,
    __in   DWORD dwFlags);

typedef SECURITY_STATUS
(WINAPI * SslOpenPrivateKeyFn)(
    __in   NCRYPT_PROV_HANDLE hSslProvider,
    __out  NCRYPT_KEY_HANDLE *phPrivateKey,
    __in   PCCERT_CONTEXT pCertContext,
    __in   DWORD dwFlags);

//+-------------------------------------------------------------------------
// SslOpenProvider
//
// Returns a handle to the specified protocol provider.
//--------------------------------------------------------------------------
SECURITY_STATUS
WINAPI
SslOpenProvider(
    __out   NCRYPT_PROV_HANDLE *phSslProvider,
    __in    LPCWSTR pszProviderName,
    __in    DWORD   dwFlags);

typedef SECURITY_STATUS
(WINAPI * SslOpenProviderFn)(
    __out   NCRYPT_PROV_HANDLE *phSslProvider,
    __in    LPCWSTR pszProviderName,
    __in    DWORD   dwFlags);

//+-------------------------------------------------------------------------
// SslSignHash
//
// Signs the passed in hash with the private key specified by the passed
// in key handle.
//--------------------------------------------------------------------------
SECURITY_STATUS
WINAPI
SslSignHash(
    __in    NCRYPT_PROV_HANDLE hSslProvider,
    __in    NCRYPT_KEY_HANDLE hPrivateKey,
    __in_bcount(cbHashValue) PBYTE pbHashValue,
    __in    DWORD   cbHashValue,
    __out_bcount_part_opt(cbSignature, *pcbResult) PBYTE pbSignature,
    __in    DWORD   cbSignature,
    __out   DWORD * pcbResult,
    __in    DWORD   dwFlags);

typedef SECURITY_STATUS
(WINAPI * SslSignHashFn)(
    __in    NCRYPT_PROV_HANDLE hSslProvider,
    __in    NCRYPT_KEY_HANDLE hPrivateKey,
    __in_bcount(cbHashValue) PBYTE pbHashValue,
    __in    DWORD   cbHashValue,
    __out_bcount_part_opt(cbSignature, *pcbResult) PBYTE pbSignature,
    __in    DWORD   cbSignature,
    __out   DWORD * pcbResult,
    __in    DWORD   dwFlags);

//+-------------------------------------------------------------------------
// SslVerifySignature
//
// Verifies the passed in signature with the passed in hash and the
// passed in public key.
//--------------------------------------------------------------------------
SECURITY_STATUS
WINAPI
SslVerifySignature(
    __in    NCRYPT_PROV_HANDLE hSslProvider,
    __in    NCRYPT_KEY_HANDLE hPublicKey,
    __in_bcount(cbHashValue) PBYTE pbHashValue,
    __in    DWORD   cbHashValue,
    __in_bcount(cbSignature) PBYTE pbSignature,
    __in    DWORD   cbSignature,
    __in    DWORD   dwFlags);

typedef SECURITY_STATUS
(WINAPI * SslVerifySignatureFn)(
    __in    NCRYPT_PROV_HANDLE hSslProvider,
    __in    NCRYPT_KEY_HANDLE hPublicKey,
    __in_bcount(cbHashValue) PBYTE pbHashValue,
    __in    DWORD   cbHashValue,
    __in_bcount(cbSignature) PBYTE pbSignature,
    __in    DWORD   cbSignature,
    __in    DWORD   dwFlags);


//+-------------------------------------------------------------------------
// SslInitializeInterface
//
// This function is implemented by the SSL protocol provider, and provides
// the protocol router with a dispatch table of functions implemented by 
// the provider. 
//--------------------------------------------------------------------------
#define NCRYPT_SSL_INTERFACE_VERSION    BCRYPT_MAKE_INTERFACE_VERSION(1,0)

typedef struct _NCRYPT_SSL_FUNCTION_TABLE 
{
    BCRYPT_INTERFACE_VERSION    Version;
    SslComputeClientAuthHashFn  ComputeClientAuthHash;
    SslComputeEapKeyBlockFn     ComputeEapKeyBlock;
    SslComputeFinishedHashFn    ComputeFinishedHash;
    SslCreateEphemeralKeyFn     CreateEphemeralKey;
    SslCreateHandshakeHashFn    CreateHandshakeHash;
    SslDecryptPacketFn          DecryptPacket;
    SslEncryptPacketFn          EncryptPacket;
    SslEnumCipherSuitesFn       EnumCipherSuites;
    SslExportKeyFn              ExportKey;
    SslFreeBufferFn             FreeBuffer;
    SslFreeObjectFn             FreeObject;
    SslGenerateMasterKeyFn      GenerateMasterKey;
    SslGenerateSessionKeysFn    GenerateSessionKeys;
    SslGetKeyPropertyFn         GetKeyProperty;
    SslGetProviderPropertyFn    GetProviderProperty;
    SslHashHandshakeFn          HashHandshake;
    SslImportMasterKeyFn        ImportMasterKey;
    SslImportKeyFn              ImportKey;
    SslLookupCipherSuiteInfoFn  LookupCipherSuiteInfo;
    SslOpenPrivateKeyFn         OpenPrivateKey;
    SslOpenProviderFn           OpenProvider;
    SslSignHashFn               SignHash;
    SslVerifySignatureFn        VerifySignature;
} NCRYPT_SSL_FUNCTION_TABLE;

NTSTATUS
WINAPI
GetSChannelInterface(
    __in   LPCWSTR pszProviderName,
    __out  NCRYPT_SSL_FUNCTION_TABLE **ppFunctionTable,
    __in   DWORD dwFlags);

typedef NTSTATUS
(WINAPI * GetSChannelInterfaceFn)(
    __in    LPCWSTR pszProviderName,
    __out   NCRYPT_SSL_FUNCTION_TABLE **ppFunctionTable,
    __in    ULONG dwFlags);

#ifdef KERNEL_MODE_CNG
#define CRYPT_PROVIDER_IOCTL__GET_SCHANNEL_INTERFACE \
    CTL_CODE(FILE_DEVICE_CRYPT_PROVIDER, 0x0007, METHOD_BUFFERED, FILE_READ_ACCESS)
#endif

SECURITY_STATUS
WINAPI
SslInitializeInterface(
    __in    LPCWSTR pszProviderName,
    __out   NCRYPT_SSL_FUNCTION_TABLE *pFunctionTable,
    __in    DWORD    dwFlags);

typedef SECURITY_STATUS
(WINAPI * SslInitializeInterfaceFn)(
    __in    LPCWSTR pszProviderName,
    __out   NCRYPT_SSL_FUNCTION_TABLE *pFunctionTable,
    __in    DWORD    dwFlags);


SECURITY_STATUS
WINAPI
SslIncrementProviderReferenceCount(
    __in    NCRYPT_PROV_HANDLE hSslProvider);
    
SECURITY_STATUS
WINAPI
SslDecrementProviderReferenceCount(
    __in    NCRYPT_PROV_HANDLE hSslProvider);

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif // __SSL_PROVIDER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\stdarg.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
#pragma once

#include "stdlib.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\sspi.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-1999.
//
//  File:       sspi.h
//
//  Contents:   Security Support Provider Interface
//              Prototypes and structure definitions
//
//  Functions:  Security Support Provider API
//
//
//----------------------------------------------------------------------------

#include <sdkddkver.h>

// begin_ntifs
#ifndef __SSPI_H__
#define __SSPI_H__
// end_ntifs

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Determine environment:
//

#ifdef UNDER_CE
#if !defined(SECURITY_WIN32) && !defined(SECURITY_KERNEL)
#define SECURITY_WIN32 1
#endif
#endif // UNDER_CE

#ifdef SECURITY_WIN32
#define ISSP_LEVEL  32
#define ISSP_MODE   1
#endif // SECURITY_WIN32

#ifdef SECURITY_KERNEL
#define ISSP_LEVEL  32          // ntifs

//
// SECURITY_KERNEL trumps SECURITY_WIN32.  Undefine ISSP_MODE so that
// we don't get redefine errors.
//
#ifdef ISSP_MODE
#undef ISSP_MODE
#endif
#define ISSP_MODE   0           // ntifs
#endif // SECURITY_KERNEL

#ifdef SECURITY_MAC
#define ISSP_LEVEL  32
#define ISSP_MODE   1
#endif // SECURITY_MAC


#ifndef ISSP_LEVEL
#error  You must define one of SECURITY_WIN32, SECURITY_KERNEL, or
#error  SECURITY_MAC
#endif // !ISSP_LEVEL


//
// Now, define platform specific mappings:
//


// begin_ntifs

#if defined(_NO_KSECDD_IMPORT_)

#define KSECDDDECLSPEC

#else

#define KSECDDDECLSPEC __declspec(dllimport)

#endif

typedef WCHAR SEC_WCHAR;
typedef CHAR SEC_CHAR;

#ifndef __SECSTATUS_DEFINED__
typedef LONG SECURITY_STATUS;
#define __SECSTATUS_DEFINED__
#endif

#define SEC_TEXT TEXT
#define SEC_FAR
#ifdef UNDER_CE
#define SEC_ENTRY WINAPI
#else
#define SEC_ENTRY __stdcall
#endif

// end_ntifs

//
// Decide what a string - 32 bits only since for 16 bits it is clear.
//


#ifdef UNICODE
typedef SEC_WCHAR * SECURITY_PSTR;
typedef CONST SEC_WCHAR * SECURITY_PCSTR;
#else // UNICODE
typedef SEC_CHAR * SECURITY_PSTR;
typedef CONST SEC_CHAR * SECURITY_PCSTR;
#endif // UNICODE



//
// Equivalent string for rpcrt:
//

#define __SEC_FAR SEC_FAR


//
// Okay, security specific types:
//


// begin_ntifs

#ifndef __SECHANDLE_DEFINED__
typedef struct _SecHandle
{
    ULONG_PTR dwLower ;
    ULONG_PTR dwUpper ;
} SecHandle, * PSecHandle ;

#define __SECHANDLE_DEFINED__
#endif // __SECHANDLE_DEFINED__

#define SecInvalidateHandle( x )    \
            ((PSecHandle) (x))->dwLower = ((PSecHandle) (x))->dwUpper = ((ULONG_PTR) ((INT_PTR)-1)) ;

#define SecIsValidHandle( x ) \
            ( ( ((PSecHandle) (x))->dwLower != ((ULONG_PTR) ((INT_PTR) -1 ))) && \
              ( ((PSecHandle) (x))->dwUpper != ((ULONG_PTR) ((INT_PTR) -1 ))) )

//
// pseudo handle value: the handle has already been deleted
//

#define SEC_DELETED_HANDLE  ((ULONG_PTR) (-2))

typedef SecHandle CredHandle;
typedef PSecHandle PCredHandle;

typedef SecHandle CtxtHandle;
typedef PSecHandle PCtxtHandle;

// end_ntifs


#ifdef UNDER_CE
typedef LARGE_INTEGER _SECURITY_INTEGER, SECURITY_INTEGER, *PSECURITY_INTEGER; // ntifs
#else
#  ifdef WIN32_CHICAGO

typedef unsigned __int64 QWORD;
typedef QWORD SECURITY_INTEGER, *PSECURITY_INTEGER;
#define SEC_SUCCESS(Status) ((Status) >= 0)

#  elif defined(_NTDEF_) || defined(_WINNT_)

typedef LARGE_INTEGER _SECURITY_INTEGER, SECURITY_INTEGER, *PSECURITY_INTEGER; // ntifs

#  else // _NTDEF_ || _WINNT_

typedef struct _SECURITY_INTEGER
{
    unsigned long LowPart;
    long HighPart;
} SECURITY_INTEGER, *PSECURITY_INTEGER;

#  endif // _NTDEF_ || _WINNT_
#endif // UNDER_CE

#  ifndef SECURITY_MAC

typedef SECURITY_INTEGER TimeStamp;                 // ntifs
typedef SECURITY_INTEGER * PTimeStamp;      // ntifs

#  else // SECURITY_MAC
typedef unsigned long TimeStamp;
typedef unsigned long * PTimeStamp;
#  endif // SECUIRT_MAC



//
// If we are in 32 bit mode, define the SECURITY_STRING structure,
// as a clone of the base UNICODE_STRING structure.  This is used
// internally in security components, an as the string interface
// for kernel components (e.g. FSPs)
//

#  ifndef _NTDEF_
typedef struct _SECURITY_STRING {
    unsigned short      Length;
    unsigned short      MaximumLength;
#    ifdef MIDL_PASS
    [size_is(MaximumLength / 2), length_is(Length / 2)]
#    endif // MIDL_PASS
    unsigned short *    Buffer;
} SECURITY_STRING, * PSECURITY_STRING;
#  else // _NTDEF_
typedef UNICODE_STRING SECURITY_STRING, *PSECURITY_STRING;  // ntifs
#  endif // _NTDEF_


// begin_ntifs

//
// SecPkgInfo structure
//
//  Provides general information about a security provider
//

typedef struct _SecPkgInfoW
{
    unsigned long fCapabilities;        // Capability bitmask
    unsigned short wVersion;            // Version of driver
    unsigned short wRPCID;              // ID for RPC Runtime
    unsigned long cbMaxToken;           // Size of authentication token (max)
#ifdef MIDL_PASS
    [string]
#endif
    SEC_WCHAR * Name;           // Text name

#ifdef MIDL_PASS
    [string]
#endif
    SEC_WCHAR * Comment;        // Comment
} SecPkgInfoW, * PSecPkgInfoW;

// end_ntifs

typedef struct _SecPkgInfoA
{
    unsigned long fCapabilities;        // Capability bitmask
    unsigned short wVersion;            // Version of driver
    unsigned short wRPCID;              // ID for RPC Runtime
    unsigned long cbMaxToken;           // Size of authentication token (max)
#ifdef MIDL_PASS
    [string]
#endif
    SEC_CHAR * Name;            // Text name

#ifdef MIDL_PASS
    [string]
#endif
    SEC_CHAR * Comment;         // Comment
} SecPkgInfoA, * PSecPkgInfoA;

#ifdef UNICODE
#  define SecPkgInfo SecPkgInfoW        // ntifs
#  define PSecPkgInfo PSecPkgInfoW      // ntifs
#else
#  define SecPkgInfo SecPkgInfoA
#  define PSecPkgInfo PSecPkgInfoA
#endif // !UNICODE

// begin_ntifs

//
//  Security Package Capabilities
//
#define SECPKG_FLAG_INTEGRITY                   0x00000001  // Supports integrity on messages
#define SECPKG_FLAG_PRIVACY                     0x00000002  // Supports privacy (confidentiality)
#define SECPKG_FLAG_TOKEN_ONLY                  0x00000004  // Only security token needed
#define SECPKG_FLAG_DATAGRAM                    0x00000008  // Datagram RPC support
#define SECPKG_FLAG_CONNECTION                  0x00000010  // Connection oriented RPC support
#define SECPKG_FLAG_MULTI_REQUIRED              0x00000020  // Full 3-leg required for re-auth.
#define SECPKG_FLAG_CLIENT_ONLY                 0x00000040  // Server side functionality not available
#define SECPKG_FLAG_EXTENDED_ERROR              0x00000080  // Supports extended error msgs
#define SECPKG_FLAG_IMPERSONATION               0x00000100  // Supports impersonation
#define SECPKG_FLAG_ACCEPT_WIN32_NAME           0x00000200  // Accepts Win32 names
#define SECPKG_FLAG_STREAM                      0x00000400  // Supports stream semantics
#define SECPKG_FLAG_NEGOTIABLE                  0x00000800  // Can be used by the negotiate package
#define SECPKG_FLAG_GSS_COMPATIBLE              0x00001000  // GSS Compatibility Available
#define SECPKG_FLAG_LOGON                       0x00002000  // Supports common LsaLogonUser
#define SECPKG_FLAG_ASCII_BUFFERS               0x00004000  // Token Buffers are in ASCII
#define SECPKG_FLAG_FRAGMENT                    0x00008000  // Package can fragment to fit
#define SECPKG_FLAG_MUTUAL_AUTH                 0x00010000  // Package can perform mutual authentication
#define SECPKG_FLAG_DELEGATION                  0x00020000  // Package can delegate
#define SECPKG_FLAG_READONLY_WITH_CHECKSUM      0x00040000  // Package can delegate
#define SECPKG_FLAG_RESTRICTED_TOKENS           0x00080000  // Package supports restricted callers

#define SECPKG_ID_NONE      0xFFFF


//
// SecBuffer
//
//  Generic memory descriptors for buffers passed in to the security
//  API
//

typedef struct _SecBuffer {
    unsigned long cbBuffer;             // Size of the buffer, in bytes
    unsigned long BufferType;           // Type of the buffer (below)
    __field_bcount(cbBuffer) void SEC_FAR * pvBuffer;            // Pointer to the buffer
} SecBuffer, * PSecBuffer;

typedef struct _SecBufferDesc {
    unsigned long ulVersion;            // Version number
    unsigned long cBuffers;             // Number of buffers
#ifdef MIDL_PASS
    [size_is(cBuffers)]
#endif
    __field_ecount(cBuffers) PSecBuffer pBuffers;                // Pointer to array of buffers
} SecBufferDesc, SEC_FAR * PSecBufferDesc;

#define SECBUFFER_VERSION           0

#define SECBUFFER_EMPTY             0   // Undefined, replaced by provider
#define SECBUFFER_DATA              1   // Packet data
#define SECBUFFER_TOKEN             2   // Security token
#define SECBUFFER_PKG_PARAMS        3   // Package specific parameters
#define SECBUFFER_MISSING           4   // Missing Data indicator
#define SECBUFFER_EXTRA             5   // Extra data
#define SECBUFFER_STREAM_TRAILER    6   // Security Trailer
#define SECBUFFER_STREAM_HEADER     7   // Security Header
#define SECBUFFER_NEGOTIATION_INFO  8   // Hints from the negotiation pkg
#define SECBUFFER_PADDING           9   // non-data padding
#define SECBUFFER_STREAM            10  // whole encrypted message
#define SECBUFFER_MECHLIST          11
#define SECBUFFER_MECHLIST_SIGNATURE 12
#define SECBUFFER_TARGET            13  // obsolete
#define SECBUFFER_CHANNEL_BINDINGS  14
#define SECBUFFER_CHANGE_PASS_RESPONSE 15

#define SECBUFFER_ATTRMASK                      0xF0000000
#define SECBUFFER_READONLY                      0x80000000  // Buffer is read-only, no checksum
#define SECBUFFER_READONLY_WITH_CHECKSUM        0x10000000  // Buffer is read-only, and checksummed
#define SECBUFFER_RESERVED                      0x60000000  // Flags reserved to security system


typedef struct _SEC_NEGOTIATION_INFO {
    unsigned long       Size;           // Size of this structure
    unsigned long       NameLength;     // Length of name hint
    SEC_WCHAR * Name;           // Name hint
    void *      Reserved;       // Reserved
} SEC_NEGOTIATION_INFO, * PSEC_NEGOTIATION_INFO ;

typedef struct _SEC_CHANNEL_BINDINGS {
    unsigned long  dwInitiatorAddrType;
    unsigned long  cbInitiatorLength;
    unsigned long  dwInitiatorOffset;
    unsigned long  dwAcceptorAddrType;
    unsigned long  cbAcceptorLength;
    unsigned long  dwAcceptorOffset;
    unsigned long  cbApplicationDataLength;
    unsigned long  dwApplicationDataOffset;
} SEC_CHANNEL_BINDINGS, * PSEC_CHANNEL_BINDINGS ;


//
//  Data Representation Constant:
//
#define SECURITY_NATIVE_DREP        0x00000010
#define SECURITY_NETWORK_DREP       0x00000000

//
//  Credential Use Flags
//
#define SECPKG_CRED_INBOUND         0x00000001
#define SECPKG_CRED_OUTBOUND        0x00000002
#define SECPKG_CRED_BOTH            0x00000003
#define SECPKG_CRED_DEFAULT         0x00000004
#define SECPKG_CRED_RESERVED        0xF0000000

//
//  InitializeSecurityContext Requirement and return flags:
//

#define ISC_REQ_DELEGATE                0x00000001
#define ISC_REQ_MUTUAL_AUTH             0x00000002
#define ISC_REQ_REPLAY_DETECT           0x00000004
#define ISC_REQ_SEQUENCE_DETECT         0x00000008
#define ISC_REQ_CONFIDENTIALITY         0x00000010
#define ISC_REQ_USE_SESSION_KEY         0x00000020
#define ISC_REQ_PROMPT_FOR_CREDS        0x00000040
#define ISC_REQ_USE_SUPPLIED_CREDS      0x00000080
#define ISC_REQ_ALLOCATE_MEMORY         0x00000100
#define ISC_REQ_USE_DCE_STYLE           0x00000200
#define ISC_REQ_DATAGRAM                0x00000400
#define ISC_REQ_CONNECTION              0x00000800
#define ISC_REQ_CALL_LEVEL              0x00001000
#define ISC_REQ_FRAGMENT_SUPPLIED       0x00002000
#define ISC_REQ_EXTENDED_ERROR          0x00004000
#define ISC_REQ_STREAM                  0x00008000
#define ISC_REQ_INTEGRITY               0x00010000
#define ISC_REQ_IDENTIFY                0x00020000
#define ISC_REQ_NULL_SESSION            0x00040000
#define ISC_REQ_MANUAL_CRED_VALIDATION  0x00080000
#define ISC_REQ_RESERVED1               0x00100000
#define ISC_REQ_FRAGMENT_TO_FIT         0x00200000
// This exists only in Longhorn and greater
#define ISC_REQ_FORWARD_CREDENTIALS     0x00400000
#define ISC_REQ_NO_INTEGRITY            0x00800000 // honored only by SPNEGO

#define ISC_RET_DELEGATE                0x00000001
#define ISC_RET_MUTUAL_AUTH             0x00000002
#define ISC_RET_REPLAY_DETECT           0x00000004
#define ISC_RET_SEQUENCE_DETECT         0x00000008
#define ISC_RET_CONFIDENTIALITY         0x00000010
#define ISC_RET_USE_SESSION_KEY         0x00000020
#define ISC_RET_USED_COLLECTED_CREDS    0x00000040
#define ISC_RET_USED_SUPPLIED_CREDS     0x00000080
#define ISC_RET_ALLOCATED_MEMORY        0x00000100
#define ISC_RET_USED_DCE_STYLE          0x00000200
#define ISC_RET_DATAGRAM                0x00000400
#define ISC_RET_CONNECTION              0x00000800
#define ISC_RET_INTERMEDIATE_RETURN     0x00001000
#define ISC_RET_CALL_LEVEL              0x00002000
#define ISC_RET_EXTENDED_ERROR          0x00004000
#define ISC_RET_STREAM                  0x00008000
#define ISC_RET_INTEGRITY               0x00010000
#define ISC_RET_IDENTIFY                0x00020000
#define ISC_RET_NULL_SESSION            0x00040000
#define ISC_RET_MANUAL_CRED_VALIDATION  0x00080000
#define ISC_RET_RESERVED1               0x00100000
#define ISC_RET_FRAGMENT_ONLY           0x00200000
// This exists only in Longhorn and greater
#define ISC_RET_FORWARD_CREDENTIALS     0x00400000
#define ISC_RET_NO_ADDITIONAL_TOKEN     0x02000000  // *INTERNAL*

#define ASC_REQ_DELEGATE                0x00000001
#define ASC_REQ_MUTUAL_AUTH             0x00000002
#define ASC_REQ_REPLAY_DETECT           0x00000004
#define ASC_REQ_SEQUENCE_DETECT         0x00000008
#define ASC_REQ_CONFIDENTIALITY         0x00000010
#define ASC_REQ_USE_SESSION_KEY         0x00000020
#define ASC_REQ_ALLOCATE_MEMORY         0x00000100
#define ASC_REQ_USE_DCE_STYLE           0x00000200
#define ASC_REQ_DATAGRAM                0x00000400
#define ASC_REQ_CONNECTION              0x00000800
#define ASC_REQ_CALL_LEVEL              0x00001000
#define ASC_REQ_EXTENDED_ERROR          0x00008000
#define ASC_REQ_STREAM                  0x00010000
#define ASC_REQ_INTEGRITY               0x00020000
#define ASC_REQ_LICENSING               0x00040000
#define ASC_REQ_IDENTIFY                0x00080000
#define ASC_REQ_ALLOW_NULL_SESSION      0x00100000
#define ASC_REQ_ALLOW_NON_USER_LOGONS   0x00200000
#define ASC_REQ_ALLOW_CONTEXT_REPLAY    0x00400000
#define ASC_REQ_FRAGMENT_TO_FIT         0x00800000
#define ASC_REQ_FRAGMENT_SUPPLIED       0x00002000
#define ASC_REQ_NO_TOKEN                0x01000000

#define ASC_RET_DELEGATE                0x00000001
#define ASC_RET_MUTUAL_AUTH             0x00000002
#define ASC_RET_REPLAY_DETECT           0x00000004
#define ASC_RET_SEQUENCE_DETECT         0x00000008
#define ASC_RET_CONFIDENTIALITY         0x00000010
#define ASC_RET_USE_SESSION_KEY         0x00000020
#define ASC_RET_ALLOCATED_MEMORY        0x00000100
#define ASC_RET_USED_DCE_STYLE          0x00000200
#define ASC_RET_DATAGRAM                0x00000400
#define ASC_RET_CONNECTION              0x00000800
#define ASC_RET_CALL_LEVEL              0x00002000 // skipped 1000 to be like ISC_
#define ASC_RET_THIRD_LEG_FAILED        0x00004000
#define ASC_RET_EXTENDED_ERROR          0x00008000
#define ASC_RET_STREAM                  0x00010000
#define ASC_RET_INTEGRITY               0x00020000
#define ASC_RET_LICENSING               0x00040000
#define ASC_RET_IDENTIFY                0x00080000
#define ASC_RET_NULL_SESSION            0x00100000
#define ASC_RET_ALLOW_NON_USER_LOGONS   0x00200000
#define ASC_RET_ALLOW_CONTEXT_REPLAY    0x00400000  // deprecated - don't use this flag!!!
#define ASC_RET_FRAGMENT_ONLY           0x00800000
#define ASC_RET_NO_TOKEN                0x01000000
#define ASC_RET_NO_ADDITIONAL_TOKEN     0x02000000  // *INTERNAL*

#pragma deprecated("ASC_RET_ALLOW_CONTEXT_REPLAY")

//
//  Security Credentials Attributes:
//

#define SECPKG_CRED_ATTR_NAMES        1
#define SECPKG_CRED_ATTR_SSI_PROVIDER 2

typedef struct _SecPkgCredentials_NamesW
{
    SEC_WCHAR * sUserName;
} SecPkgCredentials_NamesW, * PSecPkgCredentials_NamesW;

// end_ntifs

typedef struct _SecPkgCredentials_NamesA
{
    SEC_CHAR * sUserName;
} SecPkgCredentials_NamesA, * PSecPkgCredentials_NamesA;

#ifdef UNICODE
#  define SecPkgCredentials_Names SecPkgCredentials_NamesW      // ntifs
#  define PSecPkgCredentials_Names PSecPkgCredentials_NamesW    // ntifs
#else
#  define SecPkgCredentials_Names SecPkgCredentials_NamesA
#  define PSecPkgCredentials_Names PSecPkgCredentials_NamesA
#endif // !UNICODE

// begin_ntifs

#if NTDDI_VERSION > NTDDI_WS03
typedef struct _SecPkgCredentials_SSIProviderW
{
    SEC_WCHAR * sProviderName;
    unsigned long       ProviderInfoLength;
    char *      ProviderInfo;
} SecPkgCredentials_SSIProviderW, * PSecPkgCredentials_SSIProviderW;
#endif // End W2k3SP1 and greater
// end_ntifs

typedef struct _SecPkgCredentials_SSIProviderA
{
    SEC_CHAR  * sProviderName;
    unsigned long       ProviderInfoLength;
    char *      ProviderInfo;
} SecPkgCredentials_SSIProviderA, * PSecPkgCredentials_SSIProviderA;

#ifdef UNICODE
#  define SecPkgCredentials_SSIProvider SecPkgCredentials_SSIProviderW      // ntifs
#  define PSecPkgCredentials_SSIProvider PSecPkgCredentials_SSIProviderW    // ntifs
#else
#  define SecPkgCredentials_SSIProvider SecPkgCredentials_SSIProviderA
#  define PSecPkgCredentials_SSIProvider PSecPkgCredentials_SSIProviderA
#endif // !UNICODE

// begin_ntifs

//
//  Security Context Attributes:
//

#define SECPKG_ATTR_SIZES           0
#define SECPKG_ATTR_NAMES           1
#define SECPKG_ATTR_LIFESPAN        2
#define SECPKG_ATTR_DCE_INFO        3
#define SECPKG_ATTR_STREAM_SIZES    4
#define SECPKG_ATTR_KEY_INFO        5
#define SECPKG_ATTR_AUTHORITY       6
#define SECPKG_ATTR_PROTO_INFO      7
#define SECPKG_ATTR_PASSWORD_EXPIRY 8
#define SECPKG_ATTR_SESSION_KEY     9
#define SECPKG_ATTR_PACKAGE_INFO    10
#define SECPKG_ATTR_USER_FLAGS      11
#define SECPKG_ATTR_NEGOTIATION_INFO 12
#define SECPKG_ATTR_NATIVE_NAMES    13
#define SECPKG_ATTR_FLAGS           14
// These attributes exist only in Win XP and greater
#define SECPKG_ATTR_USE_VALIDATED   15
#define SECPKG_ATTR_CREDENTIAL_NAME 16
#define SECPKG_ATTR_TARGET_INFORMATION 17
#define SECPKG_ATTR_ACCESS_TOKEN    18
// These attributes exist only in Win2K3 and greater
#define SECPKG_ATTR_TARGET          19
#define SECPKG_ATTR_AUTHENTICATION_ID  20
// These attributes exist only in Win2K3SP1 and greater
#define SECPKG_ATTR_LOGOFF_TIME     21

#ifdef UNDER_CE // SECPKG_ATTR_GROUP_NAMES is WinCE only
#ifndef SECPKG_ATTR_GROUP_NAMES
#define SECPKG_ATTR_GROUP_NAMES     30
typedef struct _SecPkgContext_GroupNamesW
{
    SEC_WCHAR SEC_FAR * msGroupNames;  // multi-string list of groups
} SecPkgContext_GroupNamesW, SEC_FAR * PSecPkgContext_GroupNamesW;

#ifdef UNICODE
#define SecPkgContext_GroupNames SecPkgContext_GroupNamesW
#define PSecPkgContext_GroupNames PSecPkgContext_GroupNamesW
#endif
#endif
#endif // UNDER_CE

typedef struct _SecPkgContext_Sizes
{
    unsigned long cbMaxToken;
    unsigned long cbMaxSignature;
    unsigned long cbBlockSize;
    unsigned long cbSecurityTrailer;
} SecPkgContext_Sizes, * PSecPkgContext_Sizes;

typedef struct _SecPkgContext_StreamSizes
{
    unsigned long   cbHeader;
    unsigned long   cbTrailer;
    unsigned long   cbMaximumMessage;
    unsigned long   cBuffers;
    unsigned long   cbBlockSize;
} SecPkgContext_StreamSizes, * PSecPkgContext_StreamSizes;

typedef struct _SecPkgContext_NamesW
{
    SEC_WCHAR * sUserName;
} SecPkgContext_NamesW, * PSecPkgContext_NamesW;

// end_ntifs

typedef struct _SecPkgContext_NamesA
{
    SEC_CHAR * sUserName;
} SecPkgContext_NamesA, * PSecPkgContext_NamesA;

#ifdef UNICODE
#  define SecPkgContext_Names SecPkgContext_NamesW          // ntifs
#  define PSecPkgContext_Names PSecPkgContext_NamesW        // ntifs
#else
#  define SecPkgContext_Names SecPkgContext_NamesA
#  define PSecPkgContext_Names PSecPkgContext_NamesA
#endif // !UNICODE

// begin_ntifs

typedef struct _SecPkgContext_Lifespan
{
    TimeStamp tsStart;
    TimeStamp tsExpiry;
} SecPkgContext_Lifespan, * PSecPkgContext_Lifespan;

typedef struct _SecPkgContext_DceInfo
{
    unsigned long AuthzSvc;
    void * pPac;
} SecPkgContext_DceInfo, * PSecPkgContext_DceInfo;

// end_ntifs

typedef struct _SecPkgContext_KeyInfoA
{
    SEC_CHAR *  sSignatureAlgorithmName;
    SEC_CHAR *  sEncryptAlgorithmName;
    unsigned long       KeySize;
    unsigned long       SignatureAlgorithm;
    unsigned long       EncryptAlgorithm;
} SecPkgContext_KeyInfoA, * PSecPkgContext_KeyInfoA;

// begin_ntifs

typedef struct _SecPkgContext_KeyInfoW
{
    SEC_WCHAR * sSignatureAlgorithmName;
    SEC_WCHAR * sEncryptAlgorithmName;
    unsigned long       KeySize;
    unsigned long       SignatureAlgorithm;
    unsigned long       EncryptAlgorithm;
} SecPkgContext_KeyInfoW, * PSecPkgContext_KeyInfoW;

// end_ntifs

#ifdef UNICODE
#define SecPkgContext_KeyInfo   SecPkgContext_KeyInfoW      // ntifs
#define PSecPkgContext_KeyInfo  PSecPkgContext_KeyInfoW     // ntifs
#else
#define SecPkgContext_KeyInfo   SecPkgContext_KeyInfoA
#define PSecPkgContext_KeyInfo  PSecPkgContext_KeyInfoA
#endif

typedef struct _SecPkgContext_AuthorityA
{
    SEC_CHAR *  sAuthorityName;
} SecPkgContext_AuthorityA, * PSecPkgContext_AuthorityA;

// begin_ntifs

typedef struct _SecPkgContext_AuthorityW
{
    SEC_WCHAR * sAuthorityName;
} SecPkgContext_AuthorityW, * PSecPkgContext_AuthorityW;

// end_ntifs

#ifdef UNICODE
#define SecPkgContext_Authority SecPkgContext_AuthorityW        // ntifs
#define PSecPkgContext_Authority    PSecPkgContext_AuthorityW   // ntifs
#else
#define SecPkgContext_Authority SecPkgContext_AuthorityA
#define PSecPkgContext_Authority    PSecPkgContext_AuthorityA
#endif

typedef struct _SecPkgContext_ProtoInfoA
{
    SEC_CHAR *  sProtocolName;
    unsigned long       majorVersion;
    unsigned long       minorVersion;
} SecPkgContext_ProtoInfoA, * PSecPkgContext_ProtoInfoA;

// begin_ntifs

typedef struct _SecPkgContext_ProtoInfoW
{
    SEC_WCHAR * sProtocolName;
    unsigned long       majorVersion;
    unsigned long       minorVersion;
} SecPkgContext_ProtoInfoW, * PSecPkgContext_ProtoInfoW;

// end_ntifs

#ifdef UNICODE
#define SecPkgContext_ProtoInfo   SecPkgContext_ProtoInfoW      // ntifs
#define PSecPkgContext_ProtoInfo  PSecPkgContext_ProtoInfoW     // ntifs
#else
#define SecPkgContext_ProtoInfo   SecPkgContext_ProtoInfoA
#define PSecPkgContext_ProtoInfo  PSecPkgContext_ProtoInfoA
#endif

// begin_ntifs

typedef struct _SecPkgContext_PasswordExpiry
{
    TimeStamp tsPasswordExpires;
} SecPkgContext_PasswordExpiry, * PSecPkgContext_PasswordExpiry;

#if NTDDI_VERSION > NTDDI_WS03
typedef struct _SecPkgContext_LogoffTime
{
    TimeStamp tsLogoffTime;
} SecPkgContext_LogoffTime, * PSecPkgContext_LogoffTime;
#endif // Greater than Windows Server 2003 RTM (SP1 and greater contains this)

typedef struct _SecPkgContext_SessionKey
{
    unsigned long SessionKeyLength;
    __field_bcount(SessionKeyLength) unsigned char * SessionKey;
} SecPkgContext_SessionKey, *PSecPkgContext_SessionKey;


typedef struct _SecPkgContext_PackageInfoW
{
    PSecPkgInfoW PackageInfo;
} SecPkgContext_PackageInfoW, * PSecPkgContext_PackageInfoW;

// end_ntifs

typedef struct _SecPkgContext_PackageInfoA
{
    PSecPkgInfoA PackageInfo;
} SecPkgContext_PackageInfoA, * PSecPkgContext_PackageInfoA;

// begin_ntifs

typedef struct _SecPkgContext_UserFlags
{
    unsigned long UserFlags;
} SecPkgContext_UserFlags, * PSecPkgContext_UserFlags;

typedef struct _SecPkgContext_Flags
{
    unsigned long Flags;
} SecPkgContext_Flags, * PSecPkgContext_Flags;

// end_ntifs

#ifdef UNICODE
#define SecPkgContext_PackageInfo   SecPkgContext_PackageInfoW      // ntifs
#define PSecPkgContext_PackageInfo  PSecPkgContext_PackageInfoW     // ntifs
#else
#define SecPkgContext_PackageInfo   SecPkgContext_PackageInfoA
#define PSecPkgContext_PackageInfo  PSecPkgContext_PackageInfoA
#endif


typedef struct _SecPkgContext_NegotiationInfoA
{
    PSecPkgInfoA    PackageInfo ;
    unsigned long   NegotiationState ;
} SecPkgContext_NegotiationInfoA, * PSecPkgContext_NegotiationInfoA ;

// begin_ntifs
typedef struct _SecPkgContext_NegotiationInfoW
{
    PSecPkgInfoW    PackageInfo ;
    unsigned long   NegotiationState ;
} SecPkgContext_NegotiationInfoW, * PSecPkgContext_NegotiationInfoW ;

// end_ntifs

#ifdef UNICODE
#define SecPkgContext_NegotiationInfo   SecPkgContext_NegotiationInfoW
#define PSecPkgContext_NegotiationInfo  PSecPkgContext_NegotiationInfoW
#else
#define SecPkgContext_NegotiationInfo   SecPkgContext_NegotiationInfoA
#define PSecPkgContext_NegotiationInfo  PSecPkgContext_NegotiationInfoA
#endif

#define SECPKG_NEGOTIATION_COMPLETE             0
#define SECPKG_NEGOTIATION_OPTIMISTIC           1
#define SECPKG_NEGOTIATION_IN_PROGRESS          2
#define SECPKG_NEGOTIATION_DIRECT               3
#define SECPKG_NEGOTIATION_TRY_MULTICRED        4


typedef struct _SecPkgContext_NativeNamesW
{
    SEC_WCHAR * sClientName;
    SEC_WCHAR * sServerName;
} SecPkgContext_NativeNamesW, * PSecPkgContext_NativeNamesW;

typedef struct _SecPkgContext_NativeNamesA
{
    SEC_CHAR * sClientName;
    SEC_CHAR * sServerName;
} SecPkgContext_NativeNamesA, * PSecPkgContext_NativeNamesA;


#ifdef UNICODE
#  define SecPkgContext_NativeNames SecPkgContext_NativeNamesW          // ntifs
#  define PSecPkgContext_NativeNames PSecPkgContext_NativeNamesW        // ntifs
#else
#  define SecPkgContext_NativeNames SecPkgContext_NativeNamesA
#  define PSecPkgContext_NativeNames PSecPkgContext_NativeNamesA
#endif // !UNICODE

// begin_ntifs

#if OSVER(NTDDI_VERSION) > NTDDI_WIN2K

typedef struct _SecPkgContext_CredentialNameW
{
    unsigned long CredentialType;
    SEC_WCHAR *sCredentialName;
} SecPkgContext_CredentialNameW, * PSecPkgContext_CredentialNameW;

#endif // Later than win2k
// end_ntifs

typedef struct _SecPkgContext_CredentialNameA
{
    unsigned long CredentialType;
    SEC_CHAR *sCredentialName;
} SecPkgContext_CredentialNameA, * PSecPkgContext_CredentialNameA;

#ifdef UNICODE
#  define SecPkgContext_CredentialName SecPkgContext_CredentialNameW          // ntifs
#  define PSecPkgContext_CredentialName PSecPkgContext_CredentialNameW        // ntifs
#else
#  define SecPkgContext_CredentialName SecPkgContext_CredentialNameA
#  define PSecPkgContext_CredentialName PSecPkgContext_CredentialNameA
#endif // !UNICODE

typedef struct _SecPkgContext_AccessToken
{
    void * AccessToken;
} SecPkgContext_AccessToken, * PSecPkgContext_AccessToken;

typedef struct _SecPkgContext_TargetInformation
{
    unsigned long MarshalledTargetInfoLength;
    unsigned char * MarshalledTargetInfo;

} SecPkgContext_TargetInformation, * PSecPkgContext_TargetInformation;

typedef struct _SecPkgContext_AuthzID
{
    unsigned long AuthzIDLength;
    char * AuthzID;

} SecPkgContext_AuthzID, * PSecPkgContext_AuthzID;

typedef struct _SecPkgContext_Target
{
    unsigned long TargetLength;
    char * Target;

} SecPkgContext_Target, * PSecPkgContext_Target;


// begin_ntifs

typedef void
(SEC_ENTRY * SEC_GET_KEY_FN) (
    void * Arg,                 // Argument passed in
    void * Principal,           // Principal ID
    unsigned long KeyVer,               // Key Version
    void * * Key,       // Returned ptr to key
    SECURITY_STATUS * Status    // returned status
    );

//
// Flags for ExportSecurityContext
//

#define SECPKG_CONTEXT_EXPORT_RESET_NEW         0x00000001      // New context is reset to initial state
#define SECPKG_CONTEXT_EXPORT_DELETE_OLD        0x00000002      // Old context is deleted during export
// This is only valid in W2K3SP1 and greater
#define SECPKG_CONTEXT_EXPORT_TO_KERNEL         0x00000004      // Context is to be transferred to the kernel


KSECDDDECLSPEC
SECURITY_STATUS SEC_ENTRY
AcquireCredentialsHandleW(
#if ISSP_MODE == 0     // For Kernel mode
    __in_opt  PSECURITY_STRING pPrincipal,
    __in      PSECURITY_STRING pPackage,
#else
    __in_opt  SEC_WCHAR * pszPrincipal,   // Name of principal
    __in      SEC_WCHAR * pszPackageName,     // Name of package
#endif
    __in      unsigned long fCredentialUse,       // Flags indicating use
    __in_opt  void * pvLogonId,           // Pointer to logon ID
    __in_opt  void * pAuthData,           // Package specific data
    __in_opt  SEC_GET_KEY_FN pGetKeyFn,           // Pointer to GetKey() func
    __in_opt  void * pvGetKeyArgument,    // Value to pass to GetKey()
    __out     PCredHandle phCredential,           // (out) Cred Handle
    __out_opt PTimeStamp ptsExpiry                // (out) Lifetime (optional)
    );

typedef SECURITY_STATUS
(SEC_ENTRY * ACQUIRE_CREDENTIALS_HANDLE_FN_W)(
#if ISSP_MODE == 0
    PSECURITY_STRING,
    PSECURITY_STRING,
#else
    SEC_WCHAR *,
    SEC_WCHAR *,
#endif
    unsigned long,
    void *,
    void *,
    SEC_GET_KEY_FN,
    void *,
    PCredHandle,
    PTimeStamp);

// end_ntifs

SECURITY_STATUS SEC_ENTRY
AcquireCredentialsHandleA(
    __in_opt  SEC_CHAR * pszPrincipal,    // Name of principal
    __in      SEC_CHAR * pszPackage,      // Name of package
    __in      unsigned long fCredentialUse,       // Flags indicating use
    __in_opt  void * pvLogonId,           // Pointer to logon ID
    __in_opt  void * pAuthData,           // Package specific data
    __in_opt  SEC_GET_KEY_FN pGetKeyFn,           // Pointer to GetKey() func
    __in_opt  void * pvGetKeyArgument,    // Value to pass to GetKey()
    __out     PCredHandle phCredential,           // (out) Cred Handle
    __out_opt PTimeStamp ptsExpiry                // (out) Lifetime (optional)
    );

typedef SECURITY_STATUS
(SEC_ENTRY * ACQUIRE_CREDENTIALS_HANDLE_FN_A)(
    SEC_CHAR *,
    SEC_CHAR *,
    unsigned long,
    void *,
    void *,
    SEC_GET_KEY_FN,
    void *,
    PCredHandle,
    PTimeStamp);

#ifdef UNICODE
#  define AcquireCredentialsHandle AcquireCredentialsHandleW            // ntifs
#  define ACQUIRE_CREDENTIALS_HANDLE_FN ACQUIRE_CREDENTIALS_HANDLE_FN_W // ntifs
#else
#  define AcquireCredentialsHandle AcquireCredentialsHandleA
#  define ACQUIRE_CREDENTIALS_HANDLE_FN ACQUIRE_CREDENTIALS_HANDLE_FN_A
#endif // !UNICODE

// begin_ntifs

KSECDDDECLSPEC
SECURITY_STATUS SEC_ENTRY
FreeCredentialsHandle(
    __in PCredHandle phCredential            // Handle to free
    );

typedef SECURITY_STATUS
(SEC_ENTRY * FREE_CREDENTIALS_HANDLE_FN)(
    PCredHandle );

KSECDDDECLSPEC
SECURITY_STATUS SEC_ENTRY
AddCredentialsW(
    __in      PCredHandle hCredentials,
#if ISSP_MODE == 0      // For Kernel mode
    __in_opt  PSECURITY_STRING pPrincipal,
    __in      PSECURITY_STRING pPackage,
#else
    __in_opt  SEC_WCHAR * pszPrincipal,   // Name of principal
    __in      SEC_WCHAR * pszPackage,     // Name of package
#endif
    __in      unsigned long fCredentialUse,       // Flags indicating use
    __in_opt  void * pAuthData,           // Package specific data
    __in_opt  SEC_GET_KEY_FN pGetKeyFn,           // Pointer to GetKey() func
    __in_opt  void * pvGetKeyArgument,    // Value to pass to GetKey()
    __out_opt PTimeStamp ptsExpiry                // (out) Lifetime (optional)
    );

typedef SECURITY_STATUS
(SEC_ENTRY * ADD_CREDENTIALS_FN_W)(
    PCredHandle,
#if ISSP_MODE == 0
    PSECURITY_STRING,
    PSECURITY_STRING,
#else
    SEC_WCHAR *,
    SEC_WCHAR *,
#endif
    unsigned long,
    void *,
    SEC_GET_KEY_FN,
    void *,
    PTimeStamp);

SECURITY_STATUS SEC_ENTRY
AddCredentialsA(
    __in PCredHandle hCredentials,
    __in_opt SEC_CHAR * pszPrincipal,   // Name of principal
    __in SEC_CHAR * pszPackage,     // Name of package
    __in unsigned long fCredentialUse,       // Flags indicating use
    __in_opt void * pAuthData,           // Package specific data
    __in_opt SEC_GET_KEY_FN pGetKeyFn,           // Pointer to GetKey() func
    __in_opt void * pvGetKeyArgument,    // Value to pass to GetKey()
    __out_opt PTimeStamp ptsExpiry                // (out) Lifetime (optional)
    );

typedef SECURITY_STATUS
(SEC_ENTRY * ADD_CREDENTIALS_FN_A)(
    PCredHandle,
    SEC_CHAR *,
    SEC_CHAR *,
    unsigned long,
    void *,
    SEC_GET_KEY_FN,
    void *,
    PTimeStamp);

#ifdef UNICODE
#define AddCredentials  AddCredentialsW
#define ADD_CREDENTIALS_FN  ADD_CREDENTIALS_FN_W
#else
#define AddCredentials  AddCredentialsA
#define ADD_CREDENTIALS_FN ADD_CREDENTIALS_FN_A
#endif

////////////////////////////////////////////////////////////////////////
///
/// Password Change Functions
///
////////////////////////////////////////////////////////////////////////

#if ISSP_MODE != 0

SECURITY_STATUS SEC_ENTRY
ChangeAccountPasswordW(
    __in    SEC_WCHAR *  pszPackageName,
    __in    SEC_WCHAR *  pszDomainName,
    __in    SEC_WCHAR *  pszAccountName,
    __in    SEC_WCHAR *  pszOldPassword,
    __in    SEC_WCHAR *  pszNewPassword,
    __in    BOOLEAN              bImpersonating,
    __in    unsigned long        dwReserved,
    __inout PSecBufferDesc       pOutput
    );

typedef SECURITY_STATUS
(SEC_ENTRY * CHANGE_PASSWORD_FN_W)(
    SEC_WCHAR *,
    SEC_WCHAR *,
    SEC_WCHAR *,
    SEC_WCHAR *,
    SEC_WCHAR *,
    BOOLEAN,
    unsigned long,
    PSecBufferDesc
    );



SECURITY_STATUS SEC_ENTRY
ChangeAccountPasswordA(
    __in    SEC_CHAR *  pszPackageName,
    __in    SEC_CHAR *  pszDomainName,
    __in    SEC_CHAR *  pszAccountName,
    __in    SEC_CHAR *  pszOldPassword,
    __in    SEC_CHAR *  pszNewPassword,
    __in    BOOLEAN             bImpersonating,
    __in    unsigned long       dwReserved,
    __inout PSecBufferDesc      pOutput
    );

typedef SECURITY_STATUS
(SEC_ENTRY * CHANGE_PASSWORD_FN_A)(
    SEC_CHAR *,
    SEC_CHAR *,
    SEC_CHAR *,
    SEC_CHAR *,
    SEC_CHAR *,
    BOOLEAN,
    unsigned long,
    PSecBufferDesc
    );

#ifdef UNICODE
#  define ChangeAccountPassword ChangeAccountPasswordW
#  define CHANGE_PASSWORD_FN CHANGE_PASSWORD_FN_W
#else
#  define ChangeAccountPassword ChangeAccountPasswordA
#  define CHANGE_PASSWORD_FN CHANGE_PASSWORD_FN_A
#endif // !UNICODE

#endif // ISSP_MODE


////////////////////////////////////////////////////////////////////////
///
/// Context Management Functions
///
////////////////////////////////////////////////////////////////////////

KSECDDDECLSPEC
SECURITY_STATUS SEC_ENTRY
InitializeSecurityContextW(
    __in_opt    PCredHandle phCredential,               // Cred to base context
    __in_opt    PCtxtHandle phContext,                  // Existing context (OPT)
#if ISSP_MODE == 0
    __in_opt PSECURITY_STRING pTargetName,
#else
    __in_opt SEC_WCHAR * pszTargetName,         // Name of target
#endif
    __in        unsigned long fContextReq,              // Context Requirements
    __in        unsigned long Reserved1,                // Reserved, MBZ
    __in        unsigned long TargetDataRep,            // Data rep of target
    __in_opt    PSecBufferDesc pInput,                  // Input Buffers
    __in        unsigned long Reserved2,                // Reserved, MBZ
    __inout_opt PCtxtHandle phNewContext,               // (out) New Context handle
    __inout_opt PSecBufferDesc pOutput,                 // (inout) Output Buffers
    __out       unsigned long * pfContextAttr,  // (out) Context attrs
    __out_opt   PTimeStamp ptsExpiry                    // (out) Life span (OPT)
    );

typedef SECURITY_STATUS
(SEC_ENTRY * INITIALIZE_SECURITY_CONTEXT_FN_W)(
    PCredHandle,
    PCtxtHandle,
#if ISSP_MODE == 0
    PSECURITY_STRING,
#else
    SEC_WCHAR *,
#endif
    unsigned long,
    unsigned long,
    unsigned long,
    PSecBufferDesc,
    unsigned long,
    PCtxtHandle,
    PSecBufferDesc,
    unsigned long *,
    PTimeStamp);

// end_ntifs

SECURITY_STATUS SEC_ENTRY
InitializeSecurityContextA(
    __in_opt    PCredHandle phCredential,               // Cred to base context
    __in_opt    PCtxtHandle phContext,                  // Existing context (OPT)
    __in_opt    SEC_CHAR * pszTargetName,       // Name of target
    __in        unsigned long fContextReq,              // Context Requirements
    __in        unsigned long Reserved1,                // Reserved, MBZ
    __in        unsigned long TargetDataRep,            // Data rep of target
    __in_opt    PSecBufferDesc pInput,                  // Input Buffers
    __in        unsigned long Reserved2,                // Reserved, MBZ
    __inout_opt PCtxtHandle phNewContext,               // (out) New Context handle
    __inout_opt PSecBufferDesc pOutput,                 // (inout) Output Buffers
    __out       unsigned long * pfContextAttr,  // (out) Context attrs
    __out_opt   PTimeStamp ptsExpiry                    // (out) Life span (OPT)
    );

typedef SECURITY_STATUS
(SEC_ENTRY * INITIALIZE_SECURITY_CONTEXT_FN_A)(
    PCredHandle,
    PCtxtHandle,
    SEC_CHAR *,
    unsigned long,
    unsigned long,
    unsigned long,
    PSecBufferDesc,
    unsigned long,
    PCtxtHandle,
    PSecBufferDesc,
    unsigned long *,
    PTimeStamp);

#ifdef UNICODE
#  define InitializeSecurityContext InitializeSecurityContextW              // ntifs
#  define INITIALIZE_SECURITY_CONTEXT_FN INITIALIZE_SECURITY_CONTEXT_FN_W   // ntifs
#else
#  define InitializeSecurityContext InitializeSecurityContextA
#  define INITIALIZE_SECURITY_CONTEXT_FN INITIALIZE_SECURITY_CONTEXT_FN_A
#endif // !UNICODE

// begin_ntifs

KSECDDDECLSPEC
SECURITY_STATUS SEC_ENTRY
AcceptSecurityContext(
    __in_opt  PCredHandle phCredential,               // Cred to base context
    __in_opt  PCtxtHandle phContext,                  // Existing context (OPT)
    __in_opt  PSecBufferDesc pInput,                  // Input buffer
    __in      unsigned long fContextReq,              // Context Requirements
    __in      unsigned long TargetDataRep,            // Target Data Rep
    __in_opt  PCtxtHandle phNewContext,               // (out) New context handle
    __in_opt  PSecBufferDesc pOutput,                 // (inout) Output buffers
    __out     unsigned long * pfContextAttr,  // (out) Context attributes
    __out_opt PTimeStamp ptsExpiry                    // (out) Life span (OPT)
    );

typedef SECURITY_STATUS
(SEC_ENTRY * ACCEPT_SECURITY_CONTEXT_FN)(
    PCredHandle,
    PCtxtHandle,
    PSecBufferDesc,
    unsigned long,
    unsigned long,
    PCtxtHandle,
    PSecBufferDesc,
    unsigned long *,
    PTimeStamp);



SECURITY_STATUS SEC_ENTRY
CompleteAuthToken(
    __in PCtxtHandle phContext,              // Context to complete
    __in PSecBufferDesc pToken               // Token to complete
    );

typedef SECURITY_STATUS
(SEC_ENTRY * COMPLETE_AUTH_TOKEN_FN)(
    PCtxtHandle,
    PSecBufferDesc);

KSECDDDECLSPEC
SECURITY_STATUS SEC_ENTRY
ImpersonateSecurityContext(
    __in PCtxtHandle phContext               // Context to impersonate
    );

typedef SECURITY_STATUS
(SEC_ENTRY * IMPERSONATE_SECURITY_CONTEXT_FN)(
    PCtxtHandle);


KSECDDDECLSPEC
SECURITY_STATUS SEC_ENTRY
RevertSecurityContext(
    __in PCtxtHandle phContext               // Context from which to re
    );

typedef SECURITY_STATUS
(SEC_ENTRY * REVERT_SECURITY_CONTEXT_FN)(
    PCtxtHandle);


KSECDDDECLSPEC
SECURITY_STATUS SEC_ENTRY
QuerySecurityContextToken(
    __in  PCtxtHandle phContext,
    __out void * * Token
    );

typedef SECURITY_STATUS
(SEC_ENTRY * QUERY_SECURITY_CONTEXT_TOKEN_FN)(
    PCtxtHandle, void * *);


KSECDDDECLSPEC
SECURITY_STATUS SEC_ENTRY
DeleteSecurityContext(
    __in PCtxtHandle phContext               // Context to delete
    );

typedef SECURITY_STATUS
(SEC_ENTRY * DELETE_SECURITY_CONTEXT_FN)(
    PCtxtHandle);


KSECDDDECLSPEC
SECURITY_STATUS SEC_ENTRY
ApplyControlToken(
    __in PCtxtHandle phContext,              // Context to modify
    __in PSecBufferDesc pInput               // Input token to apply
    );

typedef SECURITY_STATUS
(SEC_ENTRY * APPLY_CONTROL_TOKEN_FN)(
    PCtxtHandle, PSecBufferDesc);


KSECDDDECLSPEC
SECURITY_STATUS SEC_ENTRY
QueryContextAttributesW(
    __in  PCtxtHandle phContext,              // Context to query
    __in  unsigned long ulAttribute,          // Attribute to query
    __out void * pBuffer              // Buffer for attributes
    );

typedef SECURITY_STATUS
(SEC_ENTRY * QUERY_CONTEXT_ATTRIBUTES_FN_W)(
    PCtxtHandle,
    unsigned long,
    void *);

// end_ntifs

SECURITY_STATUS SEC_ENTRY
QueryContextAttributesA(
    __in  PCtxtHandle phContext,              // Context to query
    __in  unsigned long ulAttribute,          // Attribute to query
    __out void * pBuffer              // Buffer for attributes
    );

typedef SECURITY_STATUS
(SEC_ENTRY * QUERY_CONTEXT_ATTRIBUTES_FN_A)(
    PCtxtHandle,
    unsigned long,
    void *);

#ifdef UNICODE
#  define QueryContextAttributes QueryContextAttributesW            // ntifs
#  define QUERY_CONTEXT_ATTRIBUTES_FN QUERY_CONTEXT_ATTRIBUTES_FN_W // ntifs
#else
#  define QueryContextAttributes QueryContextAttributesA
#  define QUERY_CONTEXT_ATTRIBUTES_FN QUERY_CONTEXT_ATTRIBUTES_FN_A
#endif // !UNICODE

// begin_ntifs

#if (OSVER(NTDDI_VERSION) > NTDDI_WIN2K)

SECURITY_STATUS SEC_ENTRY
SetContextAttributesW(
    __in PCtxtHandle phContext,                   // Context to Set
    __in unsigned long ulAttribute,               // Attribute to Set
    __in_bcount(cbBuffer) void * pBuffer, // Buffer for attributes
    __in unsigned long cbBuffer                   // Size (in bytes) of Buffer
    );

typedef SECURITY_STATUS
(SEC_ENTRY * SET_CONTEXT_ATTRIBUTES_FN_W)(
    PCtxtHandle,
    unsigned long,
    void *,
    unsigned long );

#endif // Greater than w2k

// end_ntifs

SECURITY_STATUS SEC_ENTRY
SetContextAttributesA(
    __in PCtxtHandle phContext,                   // Context to Set
    __in unsigned long ulAttribute,               // Attribute to Set
    __in_bcount(cbBuffer) void * pBuffer, // Buffer for attributes
    __in unsigned long cbBuffer                   // Size (in bytes) of Buffer
    );

typedef SECURITY_STATUS
(SEC_ENTRY * SET_CONTEXT_ATTRIBUTES_FN_A)(
    PCtxtHandle,
    unsigned long,
    void *,
    unsigned long );

#ifdef UNICODE
#  define SetContextAttributes SetContextAttributesW            // ntifs
#  define SET_CONTEXT_ATTRIBUTES_FN SET_CONTEXT_ATTRIBUTES_FN_W // ntifs
#else
#  define SetContextAttributes SetContextAttributesA
#  define SET_CONTEXT_ATTRIBUTES_FN SET_CONTEXT_ATTRIBUTES_FN_A
#endif // !UNICODE

// begin_ntifs

KSECDDDECLSPEC
SECURITY_STATUS SEC_ENTRY
QueryCredentialsAttributesW(
    __in    PCredHandle phCredential,           // Credential to query
    __in    unsigned long ulAttribute,          // Attribute to query
    __inout void * pBuffer              // Buffer for attributes
    );

typedef SECURITY_STATUS
(SEC_ENTRY * QUERY_CREDENTIALS_ATTRIBUTES_FN_W)(
    PCredHandle,
    unsigned long,
    void *);

// end_ntifs

SECURITY_STATUS SEC_ENTRY
QueryCredentialsAttributesA(
    __in    PCredHandle phCredential,           // Credential to query
    __in    unsigned long ulAttribute,          // Attribute to query
    __inout void * pBuffer              // Buffer for attributes
    );

typedef SECURITY_STATUS
(SEC_ENTRY * QUERY_CREDENTIALS_ATTRIBUTES_FN_A)(
    PCredHandle,
    unsigned long,
    void *);

#ifdef UNICODE
#  define QueryCredentialsAttributes QueryCredentialsAttributesW            // ntifs
#  define QUERY_CREDENTIALS_ATTRIBUTES_FN QUERY_CREDENTIALS_ATTRIBUTES_FN_W // ntifs
#else
#  define QueryCredentialsAttributes QueryCredentialsAttributesA
#  define QUERY_CREDENTIALS_ATTRIBUTES_FN QUERY_CREDENTIALS_ATTRIBUTES_FN_A
#endif // !UNICODE

// begin_ntifs

#if NTDDI_VERSION > NTDDI_WS03

KSECDDDECLSPEC
SECURITY_STATUS SEC_ENTRY
SetCredentialsAttributesW(
    __in PCredHandle phCredential,                // Credential to Set
    __in unsigned long ulAttribute,               // Attribute to Set
    __in_bcount(cbBuffer) void * pBuffer, // Buffer for attributes
    __in unsigned long cbBuffer                   // Size (in bytes) of Buffer
    );

typedef SECURITY_STATUS
(SEC_ENTRY * SET_CREDENTIALS_ATTRIBUTES_FN_W)(
    PCredHandle,
    unsigned long,
    void *,
    unsigned long );

#endif // For W2k3SP1 and greater

// end_ntifs

SECURITY_STATUS SEC_ENTRY
SetCredentialsAttributesA(
    __in PCredHandle phCredential,                // Credential to Set
    __in unsigned long ulAttribute,               // Attribute to Set
    __in_bcount(cbBuffer) void * pBuffer, // Buffer for attributes
    __in unsigned long cbBuffer                   // Size (in bytes) of Buffer
    );

typedef SECURITY_STATUS
(SEC_ENTRY * SET_CREDENTIALS_ATTRIBUTES_FN_A)(
    PCredHandle,
    unsigned long,
    void *,
    unsigned long );

#ifdef UNICODE
#  define SetCredentialsAttributes SetCredentialsAttributesW            // ntifs
#  define SET_CREDENTIALS_ATTRIBUTES_FN SET_CREDENTIALS_ATTRIBUTES_FN_W // ntifs
#else
#  define SetCredentialsAttributes SetCredentialsAttributesA
#  define SET_CREDENTIALS_ATTRIBUTES_FN SET_CREDENTIALS_ATTRIBUTES_FN_A
#endif // !UNICODE

// begin_ntifs

SECURITY_STATUS SEC_ENTRY
FreeContextBuffer(
    __inout PVOID pvContextBuffer      // buffer to free
    );

typedef SECURITY_STATUS
(SEC_ENTRY * FREE_CONTEXT_BUFFER_FN)(
    __inout PVOID
    );

// end_ntifs

// begin_ntifs
///////////////////////////////////////////////////////////////////
////
////    Message Support API
////
//////////////////////////////////////////////////////////////////

KSECDDDECLSPEC
SECURITY_STATUS SEC_ENTRY
MakeSignature(
    __in PCtxtHandle phContext,              // Context to use
    __in unsigned long fQOP,                 // Quality of Protection
    __in PSecBufferDesc pMessage,            // Message to sign
    __in unsigned long MessageSeqNo          // Message Sequence Num.
    );

typedef SECURITY_STATUS
(SEC_ENTRY * MAKE_SIGNATURE_FN)(
    PCtxtHandle,
    unsigned long,
    PSecBufferDesc,
    unsigned long);


KSECDDDECLSPEC
SECURITY_STATUS SEC_ENTRY
VerifySignature(
    __in  PCtxtHandle phContext,              // Context to use
    __in  PSecBufferDesc pMessage,            // Message to verify
    __in  unsigned long MessageSeqNo,         // Sequence Num.
    __out unsigned long * pfQOP       // QOP used
    );

typedef SECURITY_STATUS
(SEC_ENTRY * VERIFY_SIGNATURE_FN)(
    PCtxtHandle,
    PSecBufferDesc,
    unsigned long,
    unsigned long *);

// This only exists win Win2k3 and Greater
#define SECQOP_WRAP_NO_ENCRYPT      0x80000001
#define SECQOP_WRAP_OOB_DATA        0x40000000

SECURITY_STATUS SEC_ENTRY
EncryptMessage( __in    PCtxtHandle         phContext,
                __in    unsigned long       fQOP,
                __inout PSecBufferDesc      pMessage,
                __in    unsigned long       MessageSeqNo);

typedef SECURITY_STATUS
(SEC_ENTRY * ENCRYPT_MESSAGE_FN)(
    PCtxtHandle, unsigned long, PSecBufferDesc, unsigned long);


SECURITY_STATUS SEC_ENTRY
DecryptMessage( __in      PCtxtHandle         phContext,
                __inout   PSecBufferDesc      pMessage,
                __in      unsigned long       MessageSeqNo,
                __out_opt unsigned long *     pfQOP);


typedef SECURITY_STATUS
(SEC_ENTRY * DECRYPT_MESSAGE_FN)(
    PCtxtHandle, PSecBufferDesc, unsigned long,
    unsigned long *);


// end_ntifs

// begin_ntifs
///////////////////////////////////////////////////////////////////////////
////
////    Misc.
////
///////////////////////////////////////////////////////////////////////////

KSECDDDECLSPEC
SECURITY_STATUS SEC_ENTRY
EnumerateSecurityPackagesW(
    __out       unsigned long * pcPackages,     // Receives num. packages
    __deref_out PSecPkgInfoW  * ppPackageInfo    // Receives array of info
    );

typedef SECURITY_STATUS
(SEC_ENTRY * ENUMERATE_SECURITY_PACKAGES_FN_W)(
    unsigned long *,
    PSecPkgInfoW *);

// end_ntifs

SECURITY_STATUS SEC_ENTRY
EnumerateSecurityPackagesA(
    __out       unsigned long * pcPackages,     // Receives num. packages
    __deref_out PSecPkgInfoA  * ppPackageInfo    // Receives array of info
    );

typedef SECURITY_STATUS
(SEC_ENTRY * ENUMERATE_SECURITY_PACKAGES_FN_A)(
    unsigned long *,
    PSecPkgInfoA *);

#ifdef UNICODE
#  define EnumerateSecurityPackages EnumerateSecurityPackagesW              // ntifs
#  define ENUMERATE_SECURITY_PACKAGES_FN ENUMERATE_SECURITY_PACKAGES_FN_W   // ntifs
#else
#  define EnumerateSecurityPackages EnumerateSecurityPackagesA
#  define ENUMERATE_SECURITY_PACKAGES_FN ENUMERATE_SECURITY_PACKAGES_FN_A
#endif // !UNICODE

// begin_ntifs

KSECDDDECLSPEC
SECURITY_STATUS SEC_ENTRY
QuerySecurityPackageInfoW(
#if ISSP_MODE == 0
    __in        PSECURITY_STRING pPackageName,
#else
    __in        SEC_WCHAR * pszPackageName,     // Name of package
#endif
    __deref_out PSecPkgInfoW *ppPackageInfo     // Receives package info
    );

typedef SECURITY_STATUS
(SEC_ENTRY * QUERY_SECURITY_PACKAGE_INFO_FN_W)(
#if ISSP_MODE == 0
    PSECURITY_STRING,
#else
    SEC_WCHAR *,
#endif
    PSecPkgInfoW *);

// end_ntifs

SECURITY_STATUS SEC_ENTRY
QuerySecurityPackageInfoA(
    __in        SEC_CHAR * pszPackageName,      // Name of package
    __deref_out PSecPkgInfoA *ppPackageInfo     // Receives package info
    );

typedef SECURITY_STATUS
(SEC_ENTRY * QUERY_SECURITY_PACKAGE_INFO_FN_A)(
    SEC_CHAR *,
    PSecPkgInfoA *);

#ifdef UNICODE
#  define QuerySecurityPackageInfo QuerySecurityPackageInfoW                // ntifs
#  define QUERY_SECURITY_PACKAGE_INFO_FN QUERY_SECURITY_PACKAGE_INFO_FN_W   // ntifs
#else
#  define QuerySecurityPackageInfo QuerySecurityPackageInfoA
#  define QUERY_SECURITY_PACKAGE_INFO_FN QUERY_SECURITY_PACKAGE_INFO_FN_A
#endif // !UNICODE


typedef enum _SecDelegationType {
    SecFull,
    SecService,
    SecTree,
    SecDirectory,
    SecObject
} SecDelegationType, * PSecDelegationType;

SECURITY_STATUS SEC_ENTRY
DelegateSecurityContext(
    PCtxtHandle         phContext,          // IN Active context to delegate
#if ISSP_MODE == 0
    PSECURITY_STRING    pTarget,            // IN Target path
#else
    SEC_CHAR *  pszTarget,
#endif
    SecDelegationType   DelegationType,     // IN Type of delegation
    PTimeStamp          pExpiry,            // IN OPTIONAL time limit
    PSecBuffer          pPackageParameters, // IN OPTIONAL package specific
    PSecBufferDesc      pOutput);           // OUT Token for applycontroltoken.


///////////////////////////////////////////////////////////////////////////
////
////    Proxies
////
///////////////////////////////////////////////////////////////////////////


//
// Proxies are only available on NT platforms
//

// begin_ntifs

///////////////////////////////////////////////////////////////////////////
////
////    Context export/import
////
///////////////////////////////////////////////////////////////////////////


KSECDDDECLSPEC
SECURITY_STATUS SEC_ENTRY
ExportSecurityContext(
    __in  PCtxtHandle          phContext,             // (in) context to export
    __in  ULONG                fFlags,                // (in) option flags
    __out PSecBuffer           pPackedContext,        // (out) marshalled context
    __out void * * pToken             // (out, optional) token handle for impersonation
    );

typedef SECURITY_STATUS
(SEC_ENTRY * EXPORT_SECURITY_CONTEXT_FN)(
    PCtxtHandle,
    ULONG,
    PSecBuffer,
    void * *
    );

KSECDDDECLSPEC
SECURITY_STATUS SEC_ENTRY
ImportSecurityContextW(
#if ISSP_MODE == 0
    __in  PSECURITY_STRING     pszPackage,
#else
    __in  SEC_WCHAR * pszPackage,
#endif
    __in  PSecBuffer           pPackedContext,        // (in) marshalled context
    __in  void *       Token,                 // (in, optional) handle to token for context
    __out PCtxtHandle          phContext              // (out) new context handle
    );

typedef SECURITY_STATUS
(SEC_ENTRY * IMPORT_SECURITY_CONTEXT_FN_W)(
#if ISSP_MODE == 0
    PSECURITY_STRING,
#else
    SEC_WCHAR *,
#endif
    PSecBuffer,
    VOID *,
    PCtxtHandle
    );

// end_ntifs
SECURITY_STATUS SEC_ENTRY
ImportSecurityContextA(
    __in  SEC_CHAR * pszPackage,
    __in  PSecBuffer           pPackedContext,        // (in) marshalled context
    __in  VOID *       Token,                 // (in, optional) handle to token for context
    __out PCtxtHandle          phContext              // (out) new context handle
    );

typedef SECURITY_STATUS
(SEC_ENTRY * IMPORT_SECURITY_CONTEXT_FN_A)(
    SEC_CHAR *,
    PSecBuffer,
    void *,
    PCtxtHandle
    );

#ifdef UNICODE
#  define ImportSecurityContext ImportSecurityContextW              // ntifs
#  define IMPORT_SECURITY_CONTEXT_FN IMPORT_SECURITY_CONTEXT_FN_W   // ntifs
#else
#  define ImportSecurityContext ImportSecurityContextA
#  define IMPORT_SECURITY_CONTEXT_FN IMPORT_SECURITY_CONTEXT_FN_A
#endif // !UNICODE

// begin_ntifs

#if ISSP_MODE == 0

#include <wdm.h> // For PUNICODE_STRING

KSECDDDECLSPEC
NTSTATUS
NTAPI
SecMakeSPN(
    IN PUNICODE_STRING ServiceClass,
    IN PUNICODE_STRING ServiceName,
    IN PUNICODE_STRING InstanceName OPTIONAL,
    IN USHORT InstancePort OPTIONAL,
    IN PUNICODE_STRING Referrer OPTIONAL,
    IN OUT PUNICODE_STRING Spn,
    OUT PULONG Length OPTIONAL,
    IN BOOLEAN Allocate
    );

#if OSVER(NTDDI_VERSION) > NTDD_WIN2K

KSECDDDECLSPEC
NTSTATUS
NTAPI
SecMakeSPNEx(
    IN PUNICODE_STRING ServiceClass,
    IN PUNICODE_STRING ServiceName,
    IN PUNICODE_STRING InstanceName OPTIONAL,
    IN USHORT InstancePort OPTIONAL,
    IN PUNICODE_STRING Referrer OPTIONAL,
    IN PUNICODE_STRING TargetInfo OPTIONAL,
    IN OUT PUNICODE_STRING Spn,
    OUT PULONG Length OPTIONAL,
    IN BOOLEAN Allocate
    );

#if OSVER(NTDDI_VERSION) > NTDDI_WS03

KSECDDDECLSPEC
NTSTATUS
NTAPI
SecMakeSPNEx2(
    IN PUNICODE_STRING ServiceClass,
    IN PUNICODE_STRING ServiceName,
    IN PUNICODE_STRING InstanceName OPTIONAL,
    IN USHORT InstancePort OPTIONAL,
    IN PUNICODE_STRING Referrer OPTIONAL,
    IN PUNICODE_STRING InTargetInfo OPTIONAL,
    IN OUT PUNICODE_STRING Spn,
    OUT PULONG TotalSize OPTIONAL,
    IN BOOLEAN Allocate,
    IN BOOLEAN IsTargetInfoMarshaled
    );

#endif // Longhorn and greater

KSECDDDECLSPEC
NTSTATUS
SEC_ENTRY
SecLookupAccountSid(
    __in      PSID Sid,
    __out     PULONG NameSize,
    __inout   PUNICODE_STRING NameBuffer,
    __out     PULONG DomainSize OPTIONAL,
    __out_opt PUNICODE_STRING DomainBuffer OPTIONAL,
    __out     PSID_NAME_USE NameUse
    );

KSECDDDECLSPEC
NTSTATUS
SEC_ENTRY
SecLookupAccountName(
    __in        PUNICODE_STRING Name,
    __inout     PULONG SidSize,
    __out       PSID Sid,
    __out       PSID_NAME_USE NameUse,
    __out       PULONG DomainSize OPTIONAL,
    __inout_opt PUNICODE_STRING ReferencedDomain OPTIONAL
    );

#endif // Greater than W2k

#ifndef UNDER_CE

#if OSVER(NTDDI_VERSION) > NTDDI_WINXP

KSECDDDECLSPEC
NTSTATUS
SEC_ENTRY
SecLookupWellKnownSid(
    __in        WELL_KNOWN_SID_TYPE SidType,
    __out       PSID Sid,
    __in        ULONG SidBufferSize,
    __inout_opt PULONG SidSize OPTIONAL
    );

#endif // Greater than XP

#endif // UNDER_CE

#endif

// end_ntifs

///////////////////////////////////////////////////////////////////////////////
////
////  Fast access for RPC:
////
///////////////////////////////////////////////////////////////////////////////

#define SECURITY_ENTRYPOINT_ANSIW "InitSecurityInterfaceW"
#define SECURITY_ENTRYPOINT_ANSIA "InitSecurityInterfaceA"
#define SECURITY_ENTRYPOINTW SEC_TEXT("InitSecurityInterfaceW")     // ntifs
#define SECURITY_ENTRYPOINTA SEC_TEXT("InitSecurityInterfaceA")
#define SECURITY_ENTRYPOINT16 "INITSECURITYINTERFACEA"

#ifdef SECURITY_WIN32
#  ifdef UNICODE
#    define SECURITY_ENTRYPOINT SECURITY_ENTRYPOINTW                // ntifs
#    define SECURITY_ENTRYPOINT_ANSI SECURITY_ENTRYPOINT_ANSIW
#  else // UNICODE
#    define SECURITY_ENTRYPOINT SECURITY_ENTRYPOINTA
#    define SECURITY_ENTRYPOINT_ANSI SECURITY_ENTRYPOINT_ANSIA
#  endif // UNICODE
#else // SECURITY_WIN32
#  define SECURITY_ENTRYPOINT SECURITY_ENTRYPOINT16
#  define SECURITY_ENTRYPOINT_ANSI SECURITY_ENTRYPOINT16
#endif // SECURITY_WIN32

// begin_ntifs

#define FreeCredentialHandle FreeCredentialsHandle

typedef struct _SECURITY_FUNCTION_TABLE_W {
    unsigned long                       dwVersion;
    ENUMERATE_SECURITY_PACKAGES_FN_W    EnumerateSecurityPackagesW;
    QUERY_CREDENTIALS_ATTRIBUTES_FN_W   QueryCredentialsAttributesW;
    ACQUIRE_CREDENTIALS_HANDLE_FN_W     AcquireCredentialsHandleW;
    FREE_CREDENTIALS_HANDLE_FN          FreeCredentialsHandle;
    void *                      Reserved2;
    INITIALIZE_SECURITY_CONTEXT_FN_W    InitializeSecurityContextW;
    ACCEPT_SECURITY_CONTEXT_FN          AcceptSecurityContext;
    COMPLETE_AUTH_TOKEN_FN              CompleteAuthToken;
    DELETE_SECURITY_CONTEXT_FN          DeleteSecurityContext;
    APPLY_CONTROL_TOKEN_FN              ApplyControlToken;
    QUERY_CONTEXT_ATTRIBUTES_FN_W       QueryContextAttributesW;
    IMPERSONATE_SECURITY_CONTEXT_FN     ImpersonateSecurityContext;
    REVERT_SECURITY_CONTEXT_FN          RevertSecurityContext;
    MAKE_SIGNATURE_FN                   MakeSignature;
    VERIFY_SIGNATURE_FN                 VerifySignature;
    FREE_CONTEXT_BUFFER_FN              FreeContextBuffer;
    QUERY_SECURITY_PACKAGE_INFO_FN_W    QuerySecurityPackageInfoW;
    void *                      Reserved3;
    void *                      Reserved4;
    EXPORT_SECURITY_CONTEXT_FN          ExportSecurityContext;
    IMPORT_SECURITY_CONTEXT_FN_W        ImportSecurityContextW;
    ADD_CREDENTIALS_FN_W                AddCredentialsW ;
    void *                      Reserved8;
    QUERY_SECURITY_CONTEXT_TOKEN_FN     QuerySecurityContextToken;
    ENCRYPT_MESSAGE_FN                  EncryptMessage;
    DECRYPT_MESSAGE_FN                  DecryptMessage;
#if OSVER(NTDDI_VERSION) > NTDDI_WIN2K
    // Fields below this are available in OSes after w2k
    SET_CONTEXT_ATTRIBUTES_FN_W         SetContextAttributesW;
#endif // greater thean 2K

#if NTDDI_VERSION > NTDDI_WS03SP1
    // Fields below this are available in OSes after W2k3SP1
    SET_CREDENTIALS_ATTRIBUTES_FN_W     SetCredentialsAttributesW;
#endif
#if ISSP_MODE != 0
    CHANGE_PASSWORD_FN_W                ChangeAccountPasswordW;
#else
    void *                      Reserved9;
#endif
} SecurityFunctionTableW, * PSecurityFunctionTableW;

// end_ntifs

typedef struct _SECURITY_FUNCTION_TABLE_A {
    unsigned long                       dwVersion;
    ENUMERATE_SECURITY_PACKAGES_FN_A    EnumerateSecurityPackagesA;
    QUERY_CREDENTIALS_ATTRIBUTES_FN_A   QueryCredentialsAttributesA;
    ACQUIRE_CREDENTIALS_HANDLE_FN_A     AcquireCredentialsHandleA;
    FREE_CREDENTIALS_HANDLE_FN          FreeCredentialHandle;
    void *                      Reserved2;
    INITIALIZE_SECURITY_CONTEXT_FN_A    InitializeSecurityContextA;
    ACCEPT_SECURITY_CONTEXT_FN          AcceptSecurityContext;
    COMPLETE_AUTH_TOKEN_FN              CompleteAuthToken;
    DELETE_SECURITY_CONTEXT_FN          DeleteSecurityContext;
    APPLY_CONTROL_TOKEN_FN              ApplyControlToken;
    QUERY_CONTEXT_ATTRIBUTES_FN_A       QueryContextAttributesA;
    IMPERSONATE_SECURITY_CONTEXT_FN     ImpersonateSecurityContext;
    REVERT_SECURITY_CONTEXT_FN          RevertSecurityContext;
    MAKE_SIGNATURE_FN                   MakeSignature;
    VERIFY_SIGNATURE_FN                 VerifySignature;
    FREE_CONTEXT_BUFFER_FN              FreeContextBuffer;
    QUERY_SECURITY_PACKAGE_INFO_FN_A    QuerySecurityPackageInfoA;
    void *                      Reserved3;
    void *                      Reserved4;
    EXPORT_SECURITY_CONTEXT_FN          ExportSecurityContext;
    IMPORT_SECURITY_CONTEXT_FN_A        ImportSecurityContextA;
    ADD_CREDENTIALS_FN_A                AddCredentialsA ;
    void *                      Reserved8;
    QUERY_SECURITY_CONTEXT_TOKEN_FN     QuerySecurityContextToken;
    ENCRYPT_MESSAGE_FN                  EncryptMessage;
    DECRYPT_MESSAGE_FN                  DecryptMessage;
    SET_CONTEXT_ATTRIBUTES_FN_A         SetContextAttributesA;
    SET_CREDENTIALS_ATTRIBUTES_FN_A     SetCredentialsAttributesA;
#if ISSP_MODE != 0
    CHANGE_PASSWORD_FN_A                ChangeAccountPasswordA;
#else
    void *                      Reserved9;
#endif
} SecurityFunctionTableA, * PSecurityFunctionTableA;

#ifdef UNICODE
#  define SecurityFunctionTable SecurityFunctionTableW      // ntifs
#  define PSecurityFunctionTable PSecurityFunctionTableW    // ntifs
#else
#  define SecurityFunctionTable SecurityFunctionTableA
#  define PSecurityFunctionTable PSecurityFunctionTableA
#endif // !UNICODE

#define SECURITY_

// Function table has all routines through DecryptMessage
#define SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION     1   // ntifs

// Function table has all routines through SetContextAttributes
#define SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION_2   2   // ntifs

// Function table has all routines through SetCredentialsAttributes
#define SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION_3   3   // ntifs

// Function table has all routines through ChangeAccountPassword
#define SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION_4   4   // ntifs

PSecurityFunctionTableA SEC_ENTRY
InitSecurityInterfaceA(
    void
    );

typedef PSecurityFunctionTableA
(SEC_ENTRY * INIT_SECURITY_INTERFACE_A)(void);

// begin_ntifs

PSecurityFunctionTableW SEC_ENTRY
InitSecurityInterfaceW(
    void
    );

typedef PSecurityFunctionTableW
(SEC_ENTRY * INIT_SECURITY_INTERFACE_W)(void);

// end_ntifs

#ifdef UNICODE
#  define InitSecurityInterface InitSecurityInterfaceW          // ntifs
#  define INIT_SECURITY_INTERFACE INIT_SECURITY_INTERFACE_W     // ntifs
#else
#  define InitSecurityInterface InitSecurityInterfaceA
#  define INIT_SECURITY_INTERFACE INIT_SECURITY_INTERFACE_A
#endif // !UNICODE


#ifdef SECURITY_WIN32

//
// SASL Profile Support
//


SECURITY_STATUS
SEC_ENTRY
SaslEnumerateProfilesA(
    __deref_out LPSTR * ProfileList,
    __out       ULONG * ProfileCount
    );

SECURITY_STATUS
SEC_ENTRY
SaslEnumerateProfilesW(
    OUT LPWSTR * ProfileList,
    OUT ULONG * ProfileCount
    );

#ifdef UNICODE
#define SaslEnumerateProfiles   SaslEnumerateProfilesW
#else
#define SaslEnumerateProfiles   SaslEnumerateProfilesA
#endif


SECURITY_STATUS
SEC_ENTRY
SaslGetProfilePackageA(
    __in        LPSTR ProfileName,
    __deref_out PSecPkgInfoA * PackageInfo
    );


SECURITY_STATUS
SEC_ENTRY
SaslGetProfilePackageW(
    __in        LPWSTR ProfileName,
    __deref_out PSecPkgInfoW * PackageInfo
    );

#ifdef UNICODE
#define SaslGetProfilePackage   SaslGetProfilePackageW
#else
#define SaslGetProfilePackage   SaslGetProfilePackageA
#endif

SECURITY_STATUS
SEC_ENTRY
SaslIdentifyPackageA(
    __in        PSecBufferDesc pInput,
    __deref_out PSecPkgInfoA * PackageInfo
    );

SECURITY_STATUS
SEC_ENTRY
SaslIdentifyPackageW(
    __in        PSecBufferDesc pInput,
    __deref_out PSecPkgInfoW * PackageInfo
    );

#ifdef UNICODE
#define SaslIdentifyPackage SaslIdentifyPackageW
#else
#define SaslIdentifyPackage SaslIdentifyPackageA
#endif

SECURITY_STATUS
SEC_ENTRY
SaslInitializeSecurityContextW(
    __in_opt    PCredHandle                 phCredential,       // Cred to base context
    __in_opt    PCtxtHandle                 phContext,          // Existing context (OPT)
    __in_opt    LPWSTR                      pszTargetName,      // Name of target
    __in        unsigned long               fContextReq,        // Context Requirements
    __in        unsigned long               Reserved1,          // Reserved, MBZ
    __in        unsigned long               TargetDataRep,      // Data rep of target
    __in_opt    PSecBufferDesc              pInput,             // Input Buffers
    __in        unsigned long               Reserved2,          // Reserved, MBZ
    __inout_opt PCtxtHandle                 phNewContext,       // (out) New Context handle
    __inout_opt PSecBufferDesc              pOutput,            // (inout) Output Buffers
    __out       unsigned long *     pfContextAttr,      // (out) Context attrs
    __out_opt   PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    );

SECURITY_STATUS
SEC_ENTRY
SaslInitializeSecurityContextA(
    __in_opt    PCredHandle                 phCredential,       // Cred to base context
    __in_opt    PCtxtHandle                 phContext,          // Existing context (OPT)
    __in_opt    LPSTR                       pszTargetName,      // Name of target
    __in        unsigned long               fContextReq,        // Context Requirements
    __in        unsigned long               Reserved1,          // Reserved, MBZ
    __in        unsigned long               TargetDataRep,      // Data rep of target
    __in_opt    PSecBufferDesc              pInput,             // Input Buffers
    __in        unsigned long               Reserved2,          // Reserved, MBZ
    __inout_opt PCtxtHandle                 phNewContext,       // (out) New Context handle
    __inout_opt PSecBufferDesc              pOutput,            // (inout) Output Buffers
    __out       unsigned long *     pfContextAttr,      // (out) Context attrs
    __out_opt   PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    );

#ifdef UNICODE
#define SaslInitializeSecurityContext   SaslInitializeSecurityContextW
#else
#define SaslInitializeSecurityContext   SaslInitializeSecurityContextA
#endif


SECURITY_STATUS
SEC_ENTRY
SaslAcceptSecurityContext(
    __in_opt    PCredHandle                 phCredential,       // Cred to base context
    __in_opt    PCtxtHandle                 phContext,          // Existing context (OPT)
    __in_opt    PSecBufferDesc              pInput,             // Input buffer
    __in        unsigned long               fContextReq,        // Context Requirements
    __in        unsigned long               TargetDataRep,      // Target Data Rep
    __inout_opt PCtxtHandle                 phNewContext,       // (out) New context handle
    __inout_opt PSecBufferDesc              pOutput,            // (inout) Output buffers
    __out       unsigned long *     pfContextAttr,      // (out) Context attributes
    __out_opt   PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    );


#define SASL_OPTION_SEND_SIZE       1       // Maximum size to send to peer
#define SASL_OPTION_RECV_SIZE       2       // Maximum size willing to receive
#define SASL_OPTION_AUTHZ_STRING    3       // Authorization string
#define SASL_OPTION_AUTHZ_PROCESSING    4       // Authorization string processing

typedef enum _SASL_AUTHZID_STATE {
    Sasl_AuthZIDForbidden,             // allow no AuthZID strings to be specified - error out (default)
    Sasl_AuthZIDProcessed             // AuthZID Strings processed by Application or SSP
} SASL_AUTHZID_STATE ;

SECURITY_STATUS
SEC_ENTRY
SaslSetContextOption(
    __in PCtxtHandle ContextHandle,
    __in ULONG Option,
    __in PVOID Value,
    __in ULONG Size
    );


SECURITY_STATUS
SEC_ENTRY
SaslGetContextOption(
    __in      PCtxtHandle ContextHandle,
    __in      ULONG Option,
    __out     PVOID Value,
    __in      ULONG Size,
    __out_opt PULONG Needed OPTIONAL
    );

#endif

#ifdef SECURITY_DOS
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4147)
#endif
#endif

//
// This is the legacy credentials structure.
// The EX version below is preferred.

// begin_ntifs

#ifndef _AUTH_IDENTITY_DEFINED
#define _AUTH_IDENTITY_DEFINED

//
// This was not defined in NTIFS.h for windows 2000 however
// this struct has always been there and are safe to use
// in windows 2000 and above.
//

#define SEC_WINNT_AUTH_IDENTITY_ANSI    0x1
#define SEC_WINNT_AUTH_IDENTITY_UNICODE 0x2

typedef struct _SEC_WINNT_AUTH_IDENTITY_W {
  unsigned short *User;
  unsigned long UserLength;
  unsigned short *Domain;
  unsigned long DomainLength;
  unsigned short *Password;
  unsigned long PasswordLength;
  unsigned long Flags;
} SEC_WINNT_AUTH_IDENTITY_W, *PSEC_WINNT_AUTH_IDENTITY_W;

// end_ntifs

#define _AUTH_IDENTITY_A_DEFINED

typedef struct _SEC_WINNT_AUTH_IDENTITY_A {
  unsigned char *User;
  unsigned long UserLength;
  unsigned char *Domain;
  unsigned long DomainLength;
  unsigned char *Password;
  unsigned long PasswordLength;
  unsigned long Flags;
} SEC_WINNT_AUTH_IDENTITY_A, *PSEC_WINNT_AUTH_IDENTITY_A;


#ifdef UNICODE
#define SEC_WINNT_AUTH_IDENTITY SEC_WINNT_AUTH_IDENTITY_W       // ntifs
#define PSEC_WINNT_AUTH_IDENTITY PSEC_WINNT_AUTH_IDENTITY_W     // ntifs
#define _SEC_WINNT_AUTH_IDENTITY _SEC_WINNT_AUTH_IDENTITY_W     // ntifs
#else // UNICODE
#define SEC_WINNT_AUTH_IDENTITY SEC_WINNT_AUTH_IDENTITY_A
#define PSEC_WINNT_AUTH_IDENTITY PSEC_WINNT_AUTH_IDENTITY_A
#define _SEC_WINNT_AUTH_IDENTITY _SEC_WINNT_AUTH_IDENTITY_A
#endif // UNICODE

// begin_ntifs

#endif //_AUTH_IDENTITY_DEFINED                                 // ntifs

//
// This is the combined authentication identity structure that may be
// used with the negotiate package, NTLM, Kerberos, or SCHANNEL
//

#ifndef SEC_WINNT_AUTH_IDENTITY_VERSION
#define SEC_WINNT_AUTH_IDENTITY_VERSION 0x200

typedef struct _SEC_WINNT_AUTH_IDENTITY_EXW {
    unsigned long Version;
    unsigned long Length;
    unsigned short *User;
    unsigned long UserLength;
    unsigned short *Domain;
    unsigned long DomainLength;
    unsigned short *Password;
    unsigned long PasswordLength;
    unsigned long Flags;
    unsigned short * PackageList;
    unsigned long PackageListLength;
} SEC_WINNT_AUTH_IDENTITY_EXW, *PSEC_WINNT_AUTH_IDENTITY_EXW;

// end_ntifs

typedef struct _SEC_WINNT_AUTH_IDENTITY_EXA {
    unsigned long Version;
    unsigned long Length;
    unsigned char *User;
    unsigned long UserLength;
    unsigned char *Domain;
    unsigned long DomainLength;
    unsigned char *Password;
    unsigned long PasswordLength;
    unsigned long Flags;
    unsigned char * PackageList;
    unsigned long PackageListLength;
} SEC_WINNT_AUTH_IDENTITY_EXA, *PSEC_WINNT_AUTH_IDENTITY_EXA;

#ifdef UNICODE
#define SEC_WINNT_AUTH_IDENTITY_EX  SEC_WINNT_AUTH_IDENTITY_EXW    // ntifs
#define PSEC_WINNT_AUTH_IDENTITY_EX PSEC_WINNT_AUTH_IDENTITY_EXW   // ntifs
#else
#define SEC_WINNT_AUTH_IDENTITY_EX  SEC_WINNT_AUTH_IDENTITY_EXA
#endif

// begin_ntifs
#endif // SEC_WINNT_AUTH_IDENTITY_VERSION


//
// Common types used by negotiable security packages
//
// These are defined after W2K
//

#define SEC_WINNT_AUTH_IDENTITY_MARSHALLED      0x4     // all data is in one buffer
#define SEC_WINNT_AUTH_IDENTITY_ONLY            0x8     // these credentials are for identity only - no PAC needed

// end_ntifs

//
// Routines for manipulating packages
//

typedef struct _SECURITY_PACKAGE_OPTIONS {
    unsigned long   Size;
    unsigned long   Type;
    unsigned long   Flags;
    unsigned long   SignatureSize;
    void *  Signature;
} SECURITY_PACKAGE_OPTIONS, * PSECURITY_PACKAGE_OPTIONS;

#define SECPKG_OPTIONS_TYPE_UNKNOWN 0
#define SECPKG_OPTIONS_TYPE_LSA     1
#define SECPKG_OPTIONS_TYPE_SSPI    2

#define SECPKG_OPTIONS_PERMANENT    0x00000001

SECURITY_STATUS
SEC_ENTRY
AddSecurityPackageA(
    __in     LPSTR                     pszPackageName,
    __in_opt PSECURITY_PACKAGE_OPTIONS pOptions
    );

SECURITY_STATUS
SEC_ENTRY
AddSecurityPackageW(
    __in     LPWSTR                    pszPackageName,
    __in_opt PSECURITY_PACKAGE_OPTIONS pOptions
    );

#ifdef UNICODE
#define AddSecurityPackage  AddSecurityPackageW
#else
#define AddSecurityPackage  AddSecurityPackageA
#endif

SECURITY_STATUS
SEC_ENTRY
DeleteSecurityPackageA(
    __in LPSTR pszPackageName
    );

SECURITY_STATUS
SEC_ENTRY
DeleteSecurityPackageW(
    __in LPWSTR pszPackageName
    );

#ifdef UNICODE
#define DeleteSecurityPackage   DeleteSecurityPackageW
#else
#define DeleteSecurityPackage   DeleteSecurityPackageA
#endif


#ifdef __cplusplus
}  // extern "C"
#endif

// begin_ntifs
#endif // __SSPI_H__
// end_ntifs
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\stddef.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

#pragma once

#include "stdlib.h"

#ifdef __cplusplus
extern "C" {
#endif

#ifndef offsetof
#define offsetof(s,m)   (size_t)&(((s *)0)->m)
#endif

#ifndef _PTRDIFF_T_DEFINED
typedef int ptrdiff_t;
#define _PTRDIFF_T_DEFINED
#endif

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\storagecard.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

#pragma once

#ifdef __cplusplus
extern "C" {
#endif


/// <summary>
///    This helper function is created to abstract the details for finding
///     removable storage cards. It is designed to mimic the behavior of
///     FindFirstFile and FindNextFile except that no path is necessary
///     in the call to FindFirstStorageCard. A valid handle returned from
///     this function must be closed using FindClose. These functions also
///     rely on the OS functions for error handling, such as checking for
///     invalid handles and pointers.
/// </summary>
/// <param name="lpFindData">
///    [in] a pointer to a WIN32_FIND_DATA structure.  Filled in with the details
///    of the storage card if found
/// </param>
/// <returns>
///      a handle that can be used for subsequent calls to FindNextStorageCard
///      INVALID_HANDLE_VALUE indicates that no storage cards were found
/// </returns>
HANDLE FindFirstStorageCard(LPWIN32_FIND_DATA lpFindData);


//  *************************************************************************
//  FindNextStorageCard
//
//  Purpose:
//      This function continues a search for a storage card.
//
//  Details:
//      This helper function is created to abstract the details for finding
//      removable storage cards. It is designed to mimic the behavior of
//      FindFirstFile and FindNextFile except that no path is necessary
//      in the call to FindFirstStorageCard.
//
//  Parameters:
//      hFind       [in]    a handle returned from a call to FindFirstStorageCard
//      lpFindData  [in]    a pointer to a WIN32_FIND_DATA structure
//
//  Returns:
//      TRUE if another storage card has been found
//      FALSE if no more storage cards could be found
//
//  Side Effects:
//      none
//  *************************************************************************
/// <summary>
///     This helper function is created to abstract the details for finding
///      removable storage cards. It is designed to mimic the behavior of
///      FindFirstFile and FindNextFile except that no path is necessary
///      in the call to FindFirstStorageCard.
/// </summary>
/// <param name="hFind">
///    [in] a handle returned from a call to FindFirstStorageCard
/// </param>
/// <param name="lpFindData">
///    [in] a pointer to a WIN32_FIND_DATA structure.  Filled in with the details
///    of the next storage card if found
/// </param>
/// <returns>
///      TRUE if another storage card has been found
///      FALSE if no more storage cards could be found
/// </returns>
BOOL FindNextStorageCard(HANDLE hFind, LPWIN32_FIND_DATA lpFindData);


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\streams.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//
//--------------------------------------------------------------------------;

// Streams architecture overall header file, January 1995

#ifndef __STREAMS__
#define __STREAMS__

#ifdef	_MSC_VER
// disable some level-4 warnings, use #pragma warning(enable:###) to re-enable
#pragma warning(disable:4100) // warning C4100: unreferenced formal parameter
#pragma warning(disable:4201) // warning C4201: nonstandard extension used : nameless struct/union
#pragma warning(disable:4511) // warning C4511: copy constructor could not be generated
#pragma warning(disable:4512) // warning C4512: assignment operator could not be generated
#pragma warning(disable:4514) // warning C4514: "unreferenced inline function has been removed"

#if _MSC_VER>=1100
#define AM_NOVTABLE __declspec(novtable)
#else
#define AM_NOVTABLE
#endif
#endif	// MSC_VER

#include <windows.h>
#include <windowsx.h>
#include <olectl.h>
#include <ddraw.h>
#include <mmsystem.h>

#ifdef UNDER_CE
#include <winx.h>
#endif 

#ifndef NUMELMS
   #define NUMELMS(aa) (sizeof(aa)/sizeof((aa)[0]))
#endif

#include <strmif.h>     // Generated IDL header file for streams interfaces

#include <reftime.h>    // Helper class for REFERENCE_TIME management
#include <wxdebug.h>    // Debug support for logging and ASSERTs
#include <amvideo.h>    // ActiveMovie video interfaces and definitions
//include amaudio.h explicitly if you need it.  it requires the DX SDK.
//#include <amaudio.h>    // ActiveMovie audio interfaces and definitions
#include <wxutil.h>     // General helper classes for threads etc
#include <combase.h>    // Base COM classes to support IUnknown
#include <dllsetup.h>   // Filter registration support functions
#include <measure.h>    // Performance measurement
#include <comlite.h>    // Light weight com function prototypes

#include <cache.h>      // Simple cache container class
#include <wxlist.h>     // Non MFC generic list class
#include <msgthrd.h>	// CMsgThread
#include <mtype.h>      // Helper class for managing media types
#include <fourcc.h>     // conversions between FOURCCs and GUIDs
#include <control.h>    // generated from control.odl
#include <ctlutil.h>    // control interface utility classes
#include <evcode.h>     // event code definitions
#include <amfilter.h>   // Main streams architecture class hierachy
#include <transfrm.h>   // Generic transform filter
#include <transip.h>    // Generic transform-in-place filter
#include <uuids.h>      // declaration of type GUIDs and well-known clsids
#include <source.h>	    // Generic source filter
#include <outputq.h>    // Output pin queueing
#include <errors.h>     // HRESULT status and error definitions
#include <renbase.h>    // Base class for writing ActiveX renderers
#include <renbaseasync.h>    // Base class for writing ActiveX asynchronous renderers
#include <winutil.h>    // Helps with filters that manage windows
#include <winctrl.h>    // Implements the IVideoWindow interface
#include <videoctl.h>   // Specifically video related classes
#include <refclock.h>	// Base clock class
#include <sysclock.h>	// System clock
#include <pstream.h>    // IPersistStream helper class
#include <vtrans.h>     // Video Transform Filter base class
#ifndef UNDER_CE
#include <amextra.h>
#include <cprop.h>      // Base property page class
#endif // UNDER_CE
#include <strmctl.h>    // IAMStreamControl support
#include <edevdefs.h>   // External device control interface defines
#include <dvdevcod.h>   // DVD error code definitions

#else
    #ifdef DEBUG
    #pragma message("STREAMS.H included TWICE")
    #endif
#endif // __STREAMS__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\stdio.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/***
*stdio.h - definitions/declarations for standard I/O routines
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the structures, values, macros, and functions
*       used by the level 2 I/O ("standard I/O") routines.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STDIO
#define _INC_STDIO

/*
 * STDLIB is included for legacy reasons.  It contains the "old" function
 * declarations.
 */
#include <stdlib.h>

#include <crtdefs.h>
#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,_CRT_PACKING)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif

/* Define NULL pointer value */
#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif

/* Function prototypes */

#if __STDC_WANT_SECURE_LIB__
_CRTIMP_ALTERNATIVE int __cdecl swprintf_s(__out_ecount_z(_SizeInWords) wchar_t * _Dst, __in size_t _SizeInWords, __in_z __format_string const wchar_t * _Format, ...);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(int, swprintf_s, vswprintf_s, wchar_t, _Dest, __in_z __format_string const wchar_t *, _Format)
_CRTIMP_ALTERNATIVE int __cdecl vswprintf_s(__out_ecount_z(_SizeInWords) wchar_t * _Dst, __in size_t _SizeInWords, __in_z __format_string const wchar_t * _Format, va_list _ArgList);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(int, vswprintf_s, wchar_t, _Dest, __in_z __format_string const wchar_t *, _Format, va_list, _Args)
_CRTIMP_ALTERNATIVE __checkReturn_opt int __cdecl _snwprintf_s(__out_ecount_z(_DstSizeInWords) wchar_t * _DstBuf, __in size_t _DstSizeInWords, __in size_t _MaxCount, __in_z __format_string const wchar_t * _Format, ...);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2_ARGLIST(int, _snwprintf_s, _vsnwprintf_s, wchar_t, _Dest, __in size_t, _Count, __in_z __format_string const wchar_t *, _Format)
_CRTIMP_ALTERNATIVE __checkReturn_opt int __cdecl _vsnwprintf_s(__out_ecount_z(_DstSizeInWords) wchar_t * _DstBuf, __in size_t _DstSizeInWords, __in size_t _MaxCount, __in_z __format_string const wchar_t * _Format, va_list _ArgList);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(int, _vsnwprintf_s, wchar_t, _Dest, __in size_t, _Count, __in_z __format_string const wchar_t *, _Format, va_list, _Args)
#endif

// @CESYSGEN IF COREDLL_CORESTRA
#if __STDC_WANT_SECURE_LIB__
_CRTIMP_ALTERNATIVE __checkReturn_opt int __cdecl sscanf_s(__in_z const char * _Src, __in_z __format_string const char * _Format, ...);
_CRTIMP_ALTERNATIVE __checkReturn_opt int __cdecl sprintf_s(__out_bcount_z(_DstSize) char * _DstBuf, __in size_t _DstSize, __in_z __format_string const char * _Format, ...);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(int, sprintf_s, vsprintf_s, char, _Dest, __in_z __format_string const char *, _Format)
_CRTIMP_ALTERNATIVE __checkReturn_opt int __cdecl _snprintf_s(__out_bcount_z(_DstSize) char * _DstBuf, __in size_t _DstSize, __in size_t _MaxCount, __in_z __format_string const char * _Format, ...);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2_ARGLIST(int, _snprintf_s, _vsnprintf_s, char, _Dest, __in size_t, _Count, __in_z __format_string const char *,_Format)
_CRTIMP_ALTERNATIVE __checkReturn_opt int __cdecl _vsnprintf_s(__out_ecount_z(_DstSize) char * _DstBuf, __in size_t _DstSize, __in size_t _MaxCount, __in_z __format_string const char * _Format, va_list _ArgList);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(int, _vsnprintf_s, char, _Dest, __in size_t, _Count, __in_z __format_string const char *, _Format, va_list, _Args)
_CRTIMP_ALTERNATIVE                   int __cdecl vsprintf_s(__out_ecount_z(_Size) char * _DstBuf, __in size_t _Size, __in_z __format_string const char * _Format, va_list _ArgList);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(int, vsprintf_s, char, _Dest, __in_z __format_string const char *, _Format, va_list, _Args)
#endif

_CRTIMP __checkReturn int __cdecl _scprintf(__in_z __format_string const char * _Format, ...);
_CRTIMP __checkReturn int __cdecl _vscprintf(__in_z __format_string const char * _Format, va_list _ArgList);
// @CESYSGEN ENDIF

_CRTIMP int __cdecl _set_printf_count_output(__in int _Value);
_CRTIMP int __cdecl _get_printf_count_output();

// @CESYSGEN IF COREDLL_CORESTRW
#if __STDC_WANT_SECURE_LIB__
_CRTIMP_ALTERNATIVE __checkReturn_opt int __cdecl swscanf_s(__in_z const wchar_t *_Src, __in_z __format_string const wchar_t * _Format, ...);
#endif
// @CESYSGEN ENDIF

// @CESYSGEN IF COREDLL_CORESIOA
#if __STDC_WANT_SECURE_LIB__
_CRTIMP __checkReturn_wat errno_t __cdecl fopen_s(__deref_out_opt FILE ** _File, __in_z const char * _Filename, __in_z const char * _Mode);
_CRTIMP __checkReturn_opt int __cdecl fprintf_s(__inout FILE * _File, __in_z __format_string const char * _Format, ...);
_CRTIMP __checkReturn_opt int __cdecl fscanf_s(__inout FILE * _File, __in_z __format_string const char * _Format, ...);
_CRTIMP char * __cdecl gets_s(__out_ecount_z(_Size) char * _Buf, __in rsize_t _Size);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(char *, gets_s, char, _Buffer)
_CRTIMP __checkReturn_opt int __cdecl printf_s(__in_z __format_string const char * _Format, ...);
_CRTIMP_ALTERNATIVE __checkReturn_opt int __cdecl scanf_s(__in_z __format_string const char * _Format, ...);
_CRTIMP __checkReturn_opt int __cdecl vfprintf_s(__inout FILE * _File, __in_z __format_string const char * _Format, va_list _ArgList);
_CRTIMP __checkReturn_opt int __cdecl vprintf_s(__in_z __format_string const char * _Format, va_list _ArgList);
#endif
// @CESYSGEN ENDIF

// @CESYSGEN IF COREDLL_CORESIOW
#if __STDC_WANT_SECURE_LIB__
_CRTIMP __checkReturn_opt wchar_t * __cdecl _getws_s(__out_ecount_z(_SizeInWords) wchar_t * _Str, __in size_t _SizeInWords);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(wchar_t *, _getws_s, wchar_t, _String)
_CRTIMP __checkReturn_opt int __cdecl fwprintf_s(__inout FILE * _File, __in_z __format_string const wchar_t * _Format, ...);
_CRTIMP __checkReturn_opt int __cdecl wprintf_s(__in_z __format_string const wchar_t * _Format, ...);
_CRTIMP __checkReturn_opt int __cdecl vfwprintf_s(__inout FILE * _File, __in_z __format_string const wchar_t * _Format, va_list _ArgList);
_CRTIMP __checkReturn_opt int __cdecl vwprintf_s(__in_z __format_string const wchar_t * _Format, va_list _ArgList);
_CRTIMP __checkReturn_opt int __cdecl fwscanf_s(__inout FILE * _File, __in_z __format_string const wchar_t * _Format, ...);
_CRTIMP_ALTERNATIVE __checkReturn_opt int __cdecl wscanf_s(__in_z __format_string const wchar_t * _Format, ...);
_CRTIMP __checkReturn_wat errno_t __cdecl _wfopen_s(__deref_out_opt FILE ** _File, __in_z const wchar_t * _Filename, __in_z const wchar_t * _Mode);
#endif

_CRTIMP __checkReturn int __cdecl _scwprintf(__in_z __format_string const wchar_t * _Format, ...);
_CRTIMP __checkReturn int __cdecl _vscwprintf(__in_z __format_string const wchar_t * _Format, va_list _ArgList);
// @CESYSGEN ENDIF

// @CESYSGEN IF COREDLL_CORESIOA || COREDLL_CORESIOW
#if __STDC_WANT_SECURE_LIB__
_CRTIMP __checkReturn_wat errno_t __cdecl clearerr_s(__inout FILE * _File );
_CRTIMP __checkReturn_opt size_t __cdecl fread_s(__out_bcount(_ElementSize*_Count) void * _DstBuf, __in size_t _DstSize, __in size_t _ElementSize, __in size_t _Count, __inout FILE * _File);
_CRTIMP __checkReturn_wat errno_t __cdecl _wfreopen_s(__deref_out_opt FILE ** _File, __in_z const wchar_t * _Filename, __in_z const wchar_t * _Mode, __inout FILE * _OldFile);
#endif
// @CESYSGEN ENDIF

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_STDIO */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\stdlib.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/***
*stdlib.h - declarations/definitions for *ALL* CORELIBC functions
*
*
*Purpose:
*    This include file contains the function declarations for
*    ALL CORELIBC functions
*
****/
#pragma once

#ifndef _INC_STDLIB
#define _INC_STDLIB

#include <crtdefs.h>


/*******************************
 * The following definitions should come from crtdefs.h, but we might
 * pick up the wrong one from the Visual C++ SDK.
 */

/* Define _INTRIMP for functions which are always intrinsics */
#ifndef _INTRIMP
#define _INTRIMP
#endif

/* Define _INTRIMP2 for functions which are intrinsic for RISC, but not x86 */
#ifndef _INTRIMP2
#define _INTRIMP2
#endif

#if !defined(UNALIGNED)
#if defined(_M_IX86)
#define UNALIGNED
#else
#define UNALIGNED __unaligned
#endif
#endif

#ifndef _CRTNORETURN
#if (_MSC_VER >= 1400) && !defined(__midl) && !defined(MIDL_PASS)
#define _CRTNORETURN __declspec(noreturn)
#else
#define _CRTNORETURN
#endif
#endif  /* _CRTNORETURN */

#if !defined(_CRTAPI1)
#define _CRTAPI1 __cdecl
#endif

/*******************************/


#define COREDLL_CRT 1

#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,_CRT_PACKING)
#endif  /* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif

#ifndef _CRTIMP_DATA
#define _CRTIMP_DATA __declspec(dllimport)
#endif

#ifndef _NLSCMP_DEFINED
#define _NLSCMPERROR    2147483647  /* currently == INT_MAX */
#define _NLSCMP_DEFINED
#endif

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif

extern int __argc;          /* count of cmd line args */
extern char ** __argv;      /* pointer to table of cmd line args */
extern wchar_t ** __wargv;  /* pointer to table of wide cmd line args */

#ifndef _VA_LIST_DEFINED
typedef char * va_list;
#define _VA_LIST_DEFINED
#endif

/*
 * definition of _exception struct - this struct is passed to the matherr
 * routine when a floating point exception is detected
 */
struct _exception {
    int type;        /* exception type - see below */
    char *name;      /* name of function where error occured */
    double arg1;     /* first argument to function */
    double arg2;     /* second argument (if any) to function */
    double retval;   /* value to be returned by function */
    } ;

/* _countof helper */
#if !defined(_countof)
#if !defined(__cplusplus)
#define _countof(_Array) (sizeof(_Array) / sizeof(_Array[0]))
#else
extern "C++"
{
template <typename _CountofType, size_t _SizeOfArray>
char (*__countof_helper(UNALIGNED _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];
#define _countof(_Array) sizeof(*__countof_helper(_Array))
}
#endif
#endif

/****************** MALLOC.H ************************/

#ifndef _CRT_ALLOCATION_DEFINED
#define _CRT_ALLOCATION_DEFINED
_CRTIMP   _CRTNOALIAS _CRTRESTRICT __checkReturn __bcount_opt(_NumOfElements* _SizeOfElements) void * __cdecl calloc(__in size_t _NumOfElements, __in size_t _SizeOfElements);
_CRTIMP   _CRTNOALIAS                                                                          void   __cdecl free(__inout_opt void * _Memory);
_CRTIMP   _CRTNOALIAS _CRTRESTRICT __checkReturn __bcount_opt(_Size)                           void * __cdecl malloc(__in size_t _Size);
_CRTIMP   _CRTNOALIAS _CRTRESTRICT __checkReturn __bcount_opt(_NewSize)                        void * __cdecl realloc(__in_opt void * _Memory, __in size_t _NewSize);
#endif

_CRTIMP   __checkReturn size_t  __cdecl _msize(__in void * _Memory);
          __checkReturn __bcount(_Size) void * __cdecl _alloca(__in size_t _Size);

#if !__STDC__
/* Non-ANSI names for compatibility */
#define alloca  _alloca
#endif /* __STDC__ */


/****************** PROCESS.H ***********************/

_CRTNORETURN void __cdecl exit(__in int _Code);
_CRTNORETURN void __cdecl _exit(__in int _Code);
void __cdecl _cexit(void);
void __cdecl _c_exit (void);

/*
 * Security check initialization used by /GS security checks.
 */
void __cdecl __security_init_cookie(void);

/****************** STRING.H ************************/

/* WIDE string functions */
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1(wchar_t *, __RETURN_POLICY_DST, _INTRIMP, wcscat, __inout_z wchar_t, _Dest, __in_z const wchar_t *, _Source)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1(wchar_t *, __RETURN_POLICY_DST, _INTRIMP, wcscpy, __out_z wchar_t, _Dest, __in_z const wchar_t *, _Source)

_CRTIMP   __checkReturn _CONST_RETURN wchar_t * __cdecl wcschr(__in_z const wchar_t * _Str, wchar_t _Ch);
_INTRIMP  __checkReturn int __cdecl wcscmp(__in_z const wchar_t * _Str1, __in_z const wchar_t * _Str2);
_CRTIMP   __checkReturn size_t __cdecl wcscspn(__in_z const wchar_t * _Str, __in_z const wchar_t * _Control);
_INTRIMP  __checkReturn size_t __cdecl wcslen(__in_z const wchar_t * _Str);
__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(wchar_t *, __RETURN_POLICY_DST, _CRTIMP, wcsncat, wcsncat_s, __in_z __out_ecount(_Count) wchar_t, __inout wchar_t, _Dest, __in_z const wchar_t *, _Source, __in size_t, _Count)
_INTRIMP2 __checkReturn int __cdecl wcsncmp(__in_z const wchar_t * _Str1, __in_z const wchar_t * _Str2, __in size_t _MaxCount);
__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(wchar_t *, __RETURN_POLICY_DST, _INTRIMP2, wcsncpy, wcsncpy_s, __out_z wchar_t, __out_ecount(_Count) wchar_t, _Dest, __in_z const wchar_t *, _Source, __in size_t, _Count)
_CRTIMP   __checkReturn _CONST_RETURN wchar_t * __cdecl wcspbrk(__in_z const wchar_t * _Str, __in_z const wchar_t * _Control);
_CRTIMP   __checkReturn _CONST_RETURN wchar_t * __cdecl wcsrchr(__in_z const wchar_t * _Str, __in wchar_t _Ch);
_CRTIMP   __checkReturn size_t __cdecl wcsspn(__in_z const wchar_t * _Str, __in_z const wchar_t * _Control);
_CRTIMP   __checkReturn _CONST_RETURN wchar_t * __cdecl wcsstr(__in_z const wchar_t * _Str, __in_z const wchar_t * _SubStr);
_CRT_INSECURE_DEPRECATE(wcstok_s) _CRTIMP __checkReturn wchar_t * __cdecl wcstok(__inout_z_opt wchar_t * _Str, __in_z const wchar_t * _Delim);
_CRTIMP   __checkReturn wchar_t * __cdecl _wcsdup(__in_z const wchar_t * _Str);
_CRTIMP   __checkReturn int __cdecl _wcsicmp(__in_z const wchar_t * _Str1, __in_z const wchar_t * _Str2);
_CRTIMP   __checkReturn int __cdecl _wcsnicmp(__in_z const wchar_t * _Str1, __in_z const wchar_t * _Str2, __in size_t _MaxCount);
_CRT_INSECURE_DEPRECATE(_wcsnset_s) _CRTIMP wchar_t * __cdecl _wcsnset(__inout_z wchar_t * _Str, __in_z wchar_t _Val, __in size_t _MaxCount);
_CRTIMP   wchar_t * __cdecl _wcsrev(__inout_z wchar_t * _Str);
_CRT_INSECURE_DEPRECATE(_wcsset_s) _INTRIMP wchar_t * __cdecl _wcsset(__inout_z wchar_t * _Str, wchar_t _Val);
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(wchar_t *, __RETURN_POLICY_DST, _CRTIMP, _wcslwr, __inout_z wchar_t, _String)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(wchar_t *, __RETURN_POLICY_DST, _CRTIMP, _wcsupr, __inout_z wchar_t, _String)

#ifdef  __cplusplus
extern "C++" {
inline __checkReturn wchar_t * __CRTDECL wcschr(__in_z wchar_t *_Str, wchar_t _Ch)
        {return ((wchar_t *)wcschr((const wchar_t *)_Str, _Ch)); }
inline __checkReturn wchar_t * __CRTDECL wcspbrk(__in_z wchar_t *_Str, __in_z const wchar_t *_Control)
        {return ((wchar_t *)wcspbrk((const wchar_t *)_Str, _Control)); }
inline __checkReturn wchar_t * __CRTDECL wcsrchr(__in_z wchar_t *_Str, __in wchar_t _Ch)
        {return ((wchar_t *)wcsrchr((const wchar_t *)_Str, _Ch)); }
inline __checkReturn wchar_t * __CRTDECL wcsstr(__in_z wchar_t *_Str, __in_z const wchar_t *_SubStr)
        {return ((wchar_t *)wcsstr((const wchar_t *)_Str, _SubStr)); }
}
#endif

#if !__STDC__
/* Non-ANSI names for compatibility */
#define wcsdup    _wcsdup
#define wcsicmp   _wcsicmp
#define wcsnicmp  _wcsnicmp
#define wcsnset   _wcsnset
#define wcsrev    _wcsrev
#define wcsset    _wcsset
#define wcslwr    _wcslwr
#define wcsupr    _wcsupr
#endif /* __STDC__ */

/* NARROW ("ANSI") string functions */
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1(char *, __RETURN_POLICY_DST, _INTRIMP, strcpy, __out_z char, _Dest, __in_z const char *, _Source)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1(char *, __RETURN_POLICY_DST, _INTRIMP, strcat, __inout_z char, _Dest, __in_z const char *, _Source)
_INTRIMP  __checkReturn int     __cdecl strcmp(__in_z const char * _Str1, __in_z const char * _Str2);
_INTRIMP  __checkReturn size_t  __cdecl strlen(__in_z  const char * _Str);

_CRTIMP   __checkReturn _CONST_RETURN char *  __cdecl strchr(__in_z const char * _Str, __in int _Val);
_CRTIMP __checkReturn size_t  __cdecl strcspn(__in_z  const char * _Str, __in_z  const char * _Control);
__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(char *, __RETURN_POLICY_DST, _CRTIMP, strncat, strncat_s, __deref_inout_ecount_z(_Size) char, __inout_ecount_z(_Count) char, _Dest, __in_z const char *, _Source, __in size_t, _Count)
_INTRIMP2 __checkReturn int     __cdecl strncmp(__in_z const char * _Str1, __in_z const char * _Str2, __in size_t _MaxCount);
__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(char *, __RETURN_POLICY_DST, _INTRIMP2, strncpy, strncpy_s, __out_z char, __out_ecount(_Count) char, _Dest, __in_z const char *, _Source, __in size_t, _Count)
_CRTIMP __checkReturn _CONST_RETURN char *  __cdecl strstr(__in_z const char * _Str, __in_z const char * _SubStr);
_CRT_INSECURE_DEPRECATE(strtok_s) _CRTIMP __checkReturn char *  __cdecl strtok(__inout_z_opt char * _Str, __in_z const char * _Delim);

_CRTIMP __checkReturn int     __cdecl _stricmp(__in_z  const char * _Str1, __in_z  const char * _Str2);
_CRTIMP __checkReturn int     __cdecl _strnicmp(__in_z const char * _Str1, __in_z const char * _Str2, __in size_t _MaxCount);
_CRTIMP __checkReturn _CONST_RETURN char *  __cdecl strpbrk(__in_z const char * _Str, __in_z const char * _Control);
_CRTIMP __checkReturn _CONST_RETURN char *  __cdecl strrchr(__in_z const char * _Str, __in int _Ch);
_CRTIMP __checkReturn size_t  __cdecl strspn(__in_z const char * _Str, __in_z const char * _Control);
_CRTIMP   __checkReturn char *  __cdecl _strdup(__in_z_opt const char * _Src);
_CRT_INSECURE_DEPRECATE(_strnset_s) _CRTIMP char *  __cdecl _strnset(__inout_z char * _Str, __in int _Val, __in size_t _MaxCount);
_CRTIMP char *  __cdecl _strrev(__inout_z char * _Str);
_INTRIMP  _CRT_INSECURE_DEPRECATE(_strset_s) char *  __cdecl _strset(__inout_z char * _Str, __in int _Val);
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(char *, __RETURN_POLICY_DST, _CRTIMP, _strlwr, __inout_z char, _String)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(char *, __RETURN_POLICY_DST, _CRTIMP, _strupr, __inout_z char, _String)

#ifdef __cplusplus
extern "C++" {
inline __checkReturn char * __CRTDECL strchr(__in_z char * _Str, __in int _Ch)
    { return (char*)strchr((const char*)_Str, _Ch); }
inline __checkReturn char * __CRTDECL strpbrk(__in_z char * _Str, __in_z const char * _Control)
    { return (char*)strpbrk((const char*)_Str, _Control); }
inline __checkReturn char * __CRTDECL strrchr(__in_z char * _Str, __in int _Ch)
    { return (char*)strrchr((const char*)_Str, _Ch); }
inline __checkReturn char * __CRTDECL strstr(__in_z char * _Str, __in_z const char * _SubStr)
    { return (char*)strstr((const char*)_Str, _SubStr); }
}
#endif


/****************** MEMORY.H ************************/

_CRTIMP   void *  __cdecl _memccpy( __out_bcount_opt(_MaxCount) void * _Dst, __in const void * _Src, __in int _Val, __in size_t _MaxCount);
_INTRIMP2 __checkReturn _CONST_RETURN void *  __cdecl memchr( __in_bcount_opt(_MaxCount) const void * _Buf , __in int _Val, __in size_t _MaxCount);
_CRTIMP   __checkReturn int     __cdecl _memicmp(__in_bcount_opt(_Size) const void * _Buf1, __in_bcount_opt(_Size) const void * _Buf2, __in size_t _Size);
_INTRIMP  __checkReturn int     __cdecl memcmp(__in_bcount_opt(_Size) const void * _Buf1, __in_bcount_opt(_Size) const void * _Buf2, __in size_t _Size);
_INTRIMP  _CRT_INSECURE_DEPRECATE_MEMORY(memcpy_s) void *  __cdecl memcpy(__out_bcount_full_opt(_Size) void * _Dst, __in_bcount_opt(_Size) const void * _Src, __in size_t _Size);
_INTRIMP  void * __cdecl memset(__out_bcount_full_opt(_Size) void * _Dst, __in int _Val, __in size_t _Size);
_CRTIMP   _CRT_INSECURE_DEPRECATE_MEMORY(memmove_s) void *  __cdecl memmove(__out_bcount_full_opt(_Size) void * _Dst, __in_bcount_opt(_Size) const void * _Src, __in size_t _Size);

#ifdef __cplusplus
extern "C++" {
inline __checkReturn void * __CRTDECL memchr(__in_bcount_opt(_N) void * _Pv, __in int _C, __in size_t _N)
    { return (void*)memchr((const void*)_Pv, _C, _N); }
}
#endif


/****************** CTYPE.H *************************/

// Bit masks used by iswXXX macros
#define _UPPER      0x1     /* upper case letter */
#define _LOWER      0x2     /* lower case letter */
#define _DIGIT      0x4     /* digit[0-9] */
#define _SPACE      0x8     /* tab, carriage return, newline, */
                            /* vertical tab or form feed */
#define _PUNCT      0x10    /* punctuation character */
#define _CONTROL    0x20    /* control character */
#define _BLANK      0x40    /* space char */
#define _HEX        0x80    /* hexadecimal digit */

#define _ALPHA      (0x0100|_UPPER|_LOWER)    /* alphabetic character */

// character classification function prototypes
_CRTIMP __checkReturn int __cdecl iswctype(__in wint_t _C, __in wctype_t _Type);
_CRTIMP __checkReturn wint_t __cdecl towupper(__in wint_t _C);
_CRTIMP __checkReturn wint_t __cdecl towlower(__in wint_t _C);
_CRTIMP __checkReturn int __cdecl toupper(__in int _C);
_CRTIMP __checkReturn int __cdecl tolower(__in int _C);
#define _tolower tolower
#define _toupper toupper

#ifndef MB_CUR_MAX
#define MB_CUR_MAX 1
#endif  /* MB_CUR_MAX */


// the character classification macro definitions, CTYPE.H
_CRTIMP __checkReturn int __cdecl _isctype(__in int _C, __in int _Type);
#define isalpha(_c)      ( _isctype(_c,_ALPHA) )
#define isupper(_c)      ( _isctype(_c,_UPPER) )
#define islower(_c)      ( _isctype(_c,_LOWER) )
#define isdigit(_c)      ( _isctype(_c,_DIGIT) )
#define isxdigit(_c)     ( _isctype(_c,_HEX) )
#define isspace(_c)      ( _isctype(_c,_SPACE) )
#define ispunct(_c)      ( _isctype(_c,_PUNCT) )
#define isalnum(_c)      ( _isctype(_c,_ALPHA|_DIGIT) )
#define isprint(_c)      ( _isctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) )
#define isgraph(_c)      ( _isctype(_c,_PUNCT|_ALPHA|_DIGIT) )
#define iscntrl(_c)      ( _isctype(_c,_CONTROL) )
#define __isascii(_c)    ((unsigned)(_c) < 0x80)
#define isascii          __isascii

#define iswalpha(_c)     ( iswctype(_c,_ALPHA) )
#define iswupper(_c)     ( iswctype(_c,_UPPER) )
#define iswlower(_c)     ( iswctype(_c,_LOWER) )
#define iswdigit(_c)     ( iswctype(_c,_DIGIT) )
#define iswxdigit(_c)    ( iswctype(_c,_HEX) )
#define iswspace(_c)     ( iswctype(_c,_SPACE) )
#define iswpunct(_c)     ( iswctype(_c,_PUNCT) )
#define iswalnum(_c)     ( iswctype(_c,_ALPHA|_DIGIT) )
#define iswprint(_c)     ( iswctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) )
#define iswgraph(_c)     ( iswctype(_c,_PUNCT|_ALPHA|_DIGIT) )
#define iswcntrl(_c)     ( iswctype(_c,_CONTROL) )
#define iswascii(_c)     ( (unsigned)(_c) < 0x80 )
#define isleadbyte(_c)   ( IsDBCSLeadByte(_c))


/****************** STDIO.H *************************/

#ifndef MAX_PATH
#define MAX_PATH 260
#endif
#define _MAX_PATH    MAX_PATH

#define EOF  (-1)
#define WEOF (wint_t)(0xFFFF)

/* seek method constants for fseek */
#define SEEK_CUR    1
#define SEEK_END    2
#define SEEK_SET    0

/* mode constants for _setmode */
#define _O_TEXT     0x4000  /* file mode is text (translated) */
#define _O_BINARY   0x8000  /* file mode is binary (untranslated) */

/* FILE is an opaque handle in Win CE. Users have no access to the internals */
#ifndef _FILE_DEFINED
typedef void FILE;
#define _FILE_DEFINED
#endif

/* Define file position type */

#ifndef _FPOS_T_DEFINED
typedef __int64 fpos_t;
#define _FPOS_T_DEFINED
#endif

// Std handle defns
#define stdin  _getstdfilex(0)
#define stdout _getstdfilex(1)
#define stderr _getstdfilex(2)

// @CESYSGEN IF COREDLL_CORESTRA
// ANSI String formatting functions
_CRTIMP __checkReturn_opt int __cdecl setvbuf(__inout FILE * _File, __inout_bcount_z_opt(_Size) char * _Buf, __in int _Mode, __in size_t _Size);
_CRT_INSECURE_DEPRECATE(sscanf_s) _CRTIMP __checkReturn_opt int __cdecl sscanf(__in_z const char * _Src, __in_z __format_string const char * _Format, ...);
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST(int, __RETURN_POLICY_SAME, _CRTIMP, sprintf, vsprintf, __out_z char, _Dest, __in_z __format_string const char *, _Format)
__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_ARGLIST_EX(int, __RETURN_POLICY_SAME, _CRTIMP, _snprintf, _vsnprintf, __out_z char, __out_ecount(_Count) char, _Dest, __in size_t, _Count, __in_z __format_string const char *, _Format)
// @CESYSGEN ENDIF

// Always present since wsprintfW (used by kernel) redirects to these
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST_EX(int, __RETURN_POLICY_SAME, _CRTIMP, swprintf, swprintf_s, vswprintf, vswprintf_s, __out_z wchar_t, _Dest, __in_z __format_string const wchar_t *, _Format)
__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_ARGLIST_EX(int, __RETURN_POLICY_SAME, _CRTIMP, _snwprintf, _vsnwprintf, __out_z wchar_t, __out_ecount(_Count) wchar_t, _Dest, __in size_t, _Count, __in_z __format_string const wchar_t *, _Format)

// @CESYSGEN IF COREDLL_CORESTRW
// WIDE String formatting functions
_CRT_INSECURE_DEPRECATE(swscanf_s) _CRTIMP __checkReturn_opt int __cdecl swscanf(__in_z const wchar_t * _Src, __in_z __format_string const wchar_t * _Format, ...);
// @CESYSGEN ENDIF

// @CESYSGEN IF COREDLL_CORESIOA

// ANSI Stdin/Out functions & macros
_CRT_INSECURE_DEPRECATE(scanf_s) _CRTIMP __checkReturn_opt int __cdecl scanf(__in_z __format_string const char * _Format, ...);
_CRTIMP __checkReturn_opt int __cdecl printf(__in_z __format_string const char * _Format, ...);
_CRTIMP __checkReturn_opt int __cdecl vprintf(__in_z __format_string const char * _Format, va_list _ArgList);
_CRTIMP __checkReturn int __cdecl getchar(void);
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(char *, __RETURN_POLICY_SAME, _CRTIMP, gets, __out_z char, _Buffer)
_CRTIMP __checkReturn_opt int __cdecl putchar(__in int _Ch);
_CRTIMP __checkReturn_opt int __cdecl puts(__in_z const char * _Str);

// ANSI functions for Stdin/out and/or general buffered file handling
_CRTIMP __checkReturn_opt int __cdecl fgetc(__inout FILE * _File);
_CRTIMP __checkReturn_opt char * __cdecl fgets(__out_ecount_z(_MaxCount) char * _Buf, __in int _MaxCount, __inout FILE * _File);
_CRTIMP __checkReturn_opt int __cdecl fputc(__in int _Ch, __inout FILE * _File);
_CRTIMP __checkReturn_opt int __cdecl fputs(__in_z const char * _Str, __inout FILE * _File);
_CRTIMP __checkReturn_opt int __cdecl ungetc(__in int _Ch, __inout FILE * _File);

// ANSI functions for general buffered file handling
_CRT_INSECURE_DEPRECATE(fopen_s) _CRTIMP __checkReturn FILE * __cdecl fopen(__in_z const char * _Filename, __in_z const char * _Mode);
_CRT_INSECURE_DEPRECATE(fscanf_s) _CRTIMP __checkReturn_opt int __cdecl fscanf(__inout FILE * _File, __in_z __format_string const char * _Format, ...);
_CRTIMP __checkReturn_opt int __cdecl fprintf(__inout FILE * _File, __in_z __format_string const char * _Format, ...);
_CRTIMP __checkReturn_opt int __cdecl vfprintf(__inout FILE * _File, __in_z __format_string const char * _Format, va_list _ArgList);

#define getc(_stream)     fgetc(_stream)
#define putc(_i, _stream) fputc(_i, _stream)

// @CESYSGEN ENDIF

// @CESYSGEN IF COREDLL_CORESIOA || COREDLL_CORESIOW

// functions for general buffered file handling in either ANSI or Wide
_CRTIMP __checkReturn FILE*  __cdecl _getstdfilex(int _FileHandle);
_CRTIMP __checkReturn_opt int __cdecl fclose(__inout FILE * _File);
_CRTIMP __checkReturn_opt int __cdecl _fcloseall(void);
_CRTIMP __checkReturn_opt size_t __cdecl fread(__out_bcount(_ElementSize*_Count) void * _DstBuf, __in size_t _ElementSize, __in size_t _Count, __inout FILE * _File);
_CRTIMP __checkReturn_opt size_t __cdecl fwrite(__in_ecount(_Size*_Count) const void * _Str, __in size_t _Size, __in size_t _Count, __inout FILE * _File);
_CRTIMP __checkReturn_opt int __cdecl fflush(__inout_opt FILE * _File);
_CRTIMP __checkReturn_opt int __cdecl _flushall(void);
_CRTIMP __checkReturn int __cdecl feof(__in FILE * _File);
_CRTIMP __checkReturn int __cdecl ferror(__in FILE * _File);
_CRTIMP void __cdecl clearerr(__inout FILE * _File);
_CRTIMP __checkReturn_opt int __cdecl fgetpos(__inout FILE * _File , __out fpos_t * _Pos);
_CRTIMP __checkReturn_opt int __cdecl fsetpos(__inout FILE * _File, __in const fpos_t * _Pos);
_CRTIMP __checkReturn_opt int __cdecl fseek(__inout FILE * _File, __in long _Offset, __in int _Origin);
_CRTIMP __checkReturn long __cdecl ftell(__inout FILE * _File);
_CRTIMP __checkReturn void * __cdecl _fileno(__in FILE * _File);
_CRTIMP __checkReturn FILE * __cdecl _wfdopen(__in void * _FileHandle , __in_z const wchar_t * _Mode);
_CRT_INSECURE_DEPRECATE(_wfreopen_s) _CRTIMP __checkReturn FILE * __cdecl _wfreopen(__in_z const wchar_t * _Filename, __in_z const wchar_t * _Mode, __inout FILE * _OldFile);

#if !__STDC__
/* Non-ANSI names for compatibility */
#define fcloseall _fcloseall
#define fileno    _fileno
#define flushall  _flushall
#endif /* !__STDC__ */

// @CESYSGEN ENDIF

// @CESYSGEN IF COREDLL_CORESIOW

// WIDE Stdin/Out functions & macros
_CRT_INSECURE_DEPRECATE(wscanf_s) _CRTIMP __checkReturn_opt int __cdecl wscanf(__in_z __format_string const wchar_t * _Format, ...);
_CRTIMP __checkReturn_opt int __cdecl wprintf(__in_z __format_string const wchar_t * _Format, ...);
_CRTIMP __checkReturn_opt int __cdecl vwprintf(__in_z __format_string const wchar_t * _Format, va_list _ArgList);
_CRTIMP __checkReturn wint_t __cdecl getwchar(void);
_CRTIMP __checkReturn_opt wint_t __cdecl putwchar(__in_z wchar_t _Ch);
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(wchar_t *, __RETURN_POLICY_SAME, _CRTIMP, _getws, __out_z wchar_t, _String)
_CRTIMP __checkReturn_opt int __cdecl _putws(__in_z const wchar_t * _Str);

// WIDE functions for Stdin/out and/or general buffered file handling
_CRTIMP __checkReturn_opt wint_t __cdecl fgetwc(__inout FILE * _File);
_CRTIMP __checkReturn_opt wint_t __cdecl fputwc(__in_z wchar_t _Ch, __inout FILE * _File);
_CRTIMP __checkReturn_opt wint_t __cdecl ungetwc(__in wint_t _Ch, __inout FILE * _File);
_CRTIMP __checkReturn_opt wchar_t * __cdecl fgetws(__out_ecount_z(_SizeInWords) wchar_t * _Dst, __in int _SizeInWords, __inout FILE * _File);
_CRTIMP __checkReturn_opt int __cdecl fputws(__in_z const wchar_t * _Str, __inout FILE * _File);

#define getwc(_stm)             fgetwc(_stm)
#define putwc(_c,_stm)          fputwc(_c,_stm)

// WIDE functions for general buffered file handling
_CRT_INSECURE_DEPRECATE(_wfopen_s) _CRTIMP __checkReturn FILE * __cdecl _wfopen(__in_z const wchar_t * _Filename, __in_z const wchar_t * _Mode);
_CRT_INSECURE_DEPRECATE(fwscanf_s) _CRTIMP __checkReturn_opt int __cdecl fwscanf(__inout FILE * _File, __in_z __format_string const wchar_t * _Format, ...);
_CRTIMP __checkReturn_opt int __cdecl fwprintf(__inout FILE * _File, __in_z __format_string const wchar_t * _Format, ...);
_CRTIMP __checkReturn_opt int __cdecl vfwprintf(__inout FILE * _File, __in_z __format_string const wchar_t * _Format, va_list _ArgList);

// @CESYSGEN ENDIF


/****************** IO.H ****************************/

_CRTIMP __checkReturn int __cdecl _setmode(__in FILE * _File, __in int _Mode);


/****************** STDLIB.H ************************/

#if __STDC_WANT_SECURE_LIB__
_CRTIMP   __checkReturn_opt errno_t __cdecl mbstowcs_s(__out_opt size_t * _PtNumOfCharConverted, __out_ecount_part_opt(_SizeInWords, *_PtNumOfCharConverted) wchar_t * _DstBuf, __in size_t _SizeInWords, __in_ecount_z(_MaxCount) const char * _SrcBuf, __in size_t _MaxCount);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_2(errno_t, mbstowcs_s, __out_opt size_t *, _PtNumOfCharConverted, __deref_out_z wchar_t, _Dest, __in_z const char *, _Source, __in size_t, _MaxCount)
#endif
__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_SIZE(_CRTIMP, mbstowcs, __out_z_opt wchar_t, _Dest, __in_z const char *, _Source, __in size_t, _MaxCount)
#if __STDC_WANT_SECURE_LIB__
_CRTIMP   __checkReturn_wat errno_t __cdecl wcstombs_s(__out_opt size_t * _PtNumOfCharConverted, __out_bcount_part_opt(_DstSizeInBytes, *_PtNumOfCharConverted) char * _Dst, __in size_t _DstSizeInBytes, __in_z const wchar_t * _Src, __in size_t _MaxCountInBytes);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_2(errno_t, wcstombs_s, __out_opt size_t *, _PtNumOfCharConverted, __out_bcount_opt(_Size) char, _Dest, __in_z const wchar_t *, _Source, __in size_t, _MaxCount)
#endif
__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_SIZE(_CRTIMP, wcstombs, __out_z_opt char, _Dest, __in_z const wchar_t *, _Source, __in size_t, _MaxCount)

// __min and max macros
#define   __max(a,b)    (((a) > (b)) ? (a) : (b))
#define   __min(a,b)    (((a) < (b)) ? (a) : (b))

/* Conversion functions */

_CRTIMP   __checkReturn double __cdecl strtod(__in_z const char * _Str, __deref_opt_out_z char ** _EndPtr);
_CRTIMP   __checkReturn long   __cdecl strtol(__in_z const char * _Str, __deref_opt_out_z char ** _EndPtr, __in int _Radix);
_CRTIMP   __checkReturn unsigned long __cdecl strtoul(__in_z const char * _Str, __deref_opt_out_z char ** _EndPtr, __in int _Radix);
_CRTIMP   __checkReturn __int64 __cdecl _atoi64(__in_z const char * _String);
_CRTIMP   __checkReturn int    __cdecl atoi(__in_z const char *_Str);
_CRTIMP   double  __cdecl atof(__in_z const char *_String);
_CRTIMP   __checkReturn long   __cdecl atol(__in_z const char *_Str);
_INTRIMP  __checkReturn unsigned short __cdecl _byteswap_ushort(__in unsigned short _Short);
_INTRIMP  __checkReturn unsigned long  __cdecl _byteswap_ulong (__in unsigned long _Long);
_INTRIMP  __checkReturn unsigned __int64 __cdecl _byteswap_uint64(unsigned __int64 _Int64);
_CRTIMP   __checkReturn_opt errno_t __cdecl _itoa_s(__in int _Value, __out_ecount_z(_Size) char * _DstBuf, __in size_t _Size, __in int _Radix);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(errno_t, _itoa_s, __in int, _Value, char, _Dest, __in int, _Radix)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1(char *, __RETURN_POLICY_DST, _CRTIMP, _itoa, __in int, _Value, __out_z char, _Dest, __in int, _Radix)
_CRTIMP   __checkReturn_opt errno_t __cdecl _ltoa_s(__in long _Val, __out_ecount_z(_Size) char * _DstBuf, __in size_t _Size, __in int _Radix);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(errno_t, _ltoa_s, __in long, _Value, char, _Dest, __in int, _Radix)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1(char *, __RETURN_POLICY_DST, _CRTIMP, _ltoa, __in long, _Value, __out_z char, _Dest, __in int, _Radix)
_CRTIMP   __checkReturn_opt errno_t __cdecl _ultoa_s(__in unsigned long _Val, __out_ecount_z(_Size) char * _DstBuf, __in size_t _Size, __in int _Radix);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(errno_t, _ultoa_s, __in unsigned long, _Value, char, _Dest, __in int, _Radix)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1(char *, __RETURN_POLICY_DST, _CRTIMP, _ultoa, __in unsigned long, _Value, __out_z char, _Dest, __in int, _Radix)
_CRTIMP   __checkReturn_wat errno_t __cdecl _ecvt_s(__out_ecount_z(_Size) char * _DstBuf, __in size_t _Size, __in double _Val, __in int _NumOfDights, __out int * _PtDec, __out int * _PtSign);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_4(errno_t, _ecvt_s, char, _Dest, __in double, _Value, __in int, _NumOfDigits, __out int *, _PtDec, __out int *, _PtSign)
_CRTIMP _CRT_INSECURE_DEPRECATE(_ecvt_s) __checkReturn char * __cdecl _ecvt(__in double _Val, __in int _NumOfDigits, __out int * _PtDec, __out int * _PtSign);
_CRTIMP   __checkReturn_wat errno_t __cdecl _fcvt_s(__out_ecount_z(_Size) char * _DstBuf, __in size_t _Size, __in double _Val, __in int _NumOfDec, __out int * _PtDec, __out int * _PtSign);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_4(errno_t, _fcvt_s, char, _Dest, __in double, _Value, __in int, _NumOfDigits, __out int *, _PtDec, __out int *, _PtSign)
_CRTIMP   _CRT_INSECURE_DEPRECATE(_fcvt_s) __checkReturn char * __cdecl _fcvt(__in double _Val, __in int _NumOfDec, __out int * _PtDec, __out int * _PtSign);
_CRTIMP   errno_t __cdecl _gcvt_s(__out_ecount_z(_Size) char * _DstBuf, __in size_t _Size, __in double _Val, __in int _NumOfDigits);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, _gcvt_s, char, _Dest, __in double, _Value, __in int, _NumOfDigits)
_CRTIMP   _CRT_INSECURE_DEPRECATE(_gcvt_s) char * __cdecl _gcvt(__in double _Val, __in int _NumOfDigits, __out_z char * _DstBuf);
_CRTIMP   __checkReturn double __cdecl wcstod(__in_z const wchar_t * _Str, __deref_opt_out_z wchar_t ** _EndPtr);
_CRTIMP   __checkReturn long   __cdecl wcstol(__in_z const wchar_t *_Str, __deref_opt_out_z wchar_t ** _EndPtr, int _Radix);
_CRTIMP   __checkReturn_wat errno_t __cdecl _itow_s (__in int _Val, __out_ecount_z(_SizeInWords) wchar_t * _DstBuf, __in size_t _SizeInWords, __in int _Radix);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(errno_t, _itow_s, __in int, _Value, wchar_t, _Dest, __in int, _Radix)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1(wchar_t *, __RETURN_POLICY_DST, _CRTIMP, _itow, __in int, _Value, __out_z wchar_t, _Dest, __in int, _Radix)
_CRTIMP   __checkReturn_wat errno_t __cdecl _ltow_s (__in long _Val, __out_ecount_z(_SizeInWords) wchar_t * _DstBuf, __in size_t _SizeInWords, __in int _Radix);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(errno_t, _ltow_s, __in long, _Value, wchar_t, _Dest, __in int, _Radix)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1(wchar_t *, __RETURN_POLICY_DST, _CRTIMP, _ltow, __in long, _Value, __out_z wchar_t, _Dest, __in int, _Radix)
_CRTIMP   __checkReturn_wat errno_t __cdecl _ultow_s (__in unsigned long _Val, __out_ecount_z(_SizeInWords) wchar_t * _DstBuf, __in size_t _SizeInWords, __in int _Radix);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(errno_t, _ultow_s, __in unsigned long, _Value, wchar_t, _Dest, __in int, _Radix)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1(wchar_t *, __RETURN_POLICY_DST, _CRTIMP, _ultow, __in unsigned long, _Value, __out_z wchar_t, _Dest, __in int, _Radix)
_CRTIMP __checkReturn long __cdecl _wtol(__in_z const wchar_t *_Str);
_CRTIMP __checkReturn __int64   __cdecl _wtoll(__in_z const wchar_t *_Str);
_CRTIMP __checkReturn unsigned long __cdecl wcstoul(__in_z const wchar_t *_Str, __deref_opt_out_z wchar_t ** _EndPtr, int _Radix);
#define _wtoi   _wtol
#define _wtoi64 _wtoll

/* Extended logical Ops functions */

_INTRIMP  __checkReturn unsigned long __cdecl _lrotl(__in unsigned long _Val, __in int _Shift);
_INTRIMP  __checkReturn unsigned long __cdecl _lrotr(__in unsigned long _Val, __in int _Shift);
_INTRIMP  __checkReturn unsigned int __cdecl _rotl(__in unsigned int _Val, __in int _Shift);
_INTRIMP  __checkReturn unsigned int __cdecl _rotr(__in unsigned int _Val, __in int _Shift);
_INTRIMP  __checkReturn unsigned __int64 __cdecl _rotl64(__in unsigned __int64 _Val, __in int _Shift);
_INTRIMP  __checkReturn unsigned __int64 __cdecl _rotr64(__in unsigned __int64 _Val, __in int _Shift);

/* Other misc functions */

_CRTIMP void   __cdecl _swab(__inout_ecount_full(_SizeInBytes) char * _Buf1, __inout_ecount_full(_SizeInBytes) char * _Buf2, int _SizeInBytes);
_CRTIMP __checkReturn int    __cdecl rand(void);
// @CESYSGEN IF CE_MODULES_FILESYS
/* rand_s is only available if CeGenRandom is available */
_CRTIMP errno_t __cdecl rand_s ( __out unsigned int *_RandomValue);
// @CESYSGEN ENDIF
_CRTIMP void   __cdecl srand(__in unsigned int _Seed);

#define _CRT_BSEARCH_DEFINED_ 1

#if __STDC_WANT_SECURE_LIB__
__checkReturn _CRTIMP void * __cdecl bsearch_s(__in const void * _Key, __in_bcount(_NumOfElements * _SizeOfElements) const void * _Base,
        __in rsize_t _NumOfElements, __in rsize_t _SizeOfElements,
        __in int (__cdecl * _PtFuncCompare)(void *, const void *, const void *), void * _Context);
#endif
__checkReturn _CRTIMP void * __cdecl bsearch(__in const void * _Key, __in_bcount(_NumOfElements * _SizeOfElements) const void * _Base,
        __in size_t _NumOfElements, __in size_t _SizeOfElements,
        __in int (__cdecl * _PtFuncCompare)(const void *, const void *));

#if __STDC_WANT_SECURE_LIB__
_CRTIMP void __cdecl qsort_s(__inout_bcount(_NumOfElements* _SizeOfElements) void * _Base,
        __in rsize_t _NumOfElements, __in rsize_t _SizeOfElements,
        __in int (__cdecl * _PtFuncCompare)(void *, const void *, const void *), void *_Context);
#endif
_CRTIMP void __cdecl qsort(__inout_bcount(_NumOfElements * _SizeOfElements) void * _Base,
        __in size_t _NumOfElements, __in size_t _SizeOfElements,
        __in int (__cdecl * _PtFuncCompare)(const void *, const void *));

_CRTIMP double __cdecl difftime(__in __time32_t _Time1, __in __time32_t _Time2);
        int    __cdecl atexit(void (__cdecl *)(void));

/* Maximum value that can be returned by the rand function. */
#define RAND_MAX 0x7fff

/* Definition of the argument values for the exit() function */

#define EXIT_SUCCESS    0
#define EXIT_FAILURE    1

/* onexit() defns */

typedef int (__cdecl * _onexit_t)(void);
#if !__STDC__
#define onexit_t _onexit_t
#endif

/* Data structure definitions for div and ldiv routines */

typedef struct _div_t {
    int quot;
    int rem;
} div_t;

typedef struct _ldiv_t {
    long quot;
    long rem;
} ldiv_t;

_CRTIMP __checkReturn div_t  __cdecl div(__in int _Numerator, __in int _Denominator);
_CRTIMP __checkReturn ldiv_t __cdecl ldiv(__in long _Numerator, __in long _Denominator);

/* an invalid parameter handler procedure. */
typedef void (__cdecl *_invalid_parameter_handler)(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t);

/* establishes a invalid_arg handler for the process */
_CRTIMP _invalid_parameter_handler __cdecl _set_invalid_parameter_handler(__in_opt _invalid_parameter_handler _Handler);
_CRTIMP _invalid_parameter_handler __cdecl _get_invalid_parameter_handler(void);

/****************** LIMITS.H ************************/

#define CHAR_BIT      8                   /* number of bits in a char */
#define SCHAR_MIN   (-128)                /* minimum signed char value */
#define SCHAR_MAX     127                 /* maximum signed char value */
#define UCHAR_MAX     0xff                /* maximum unsigned char value */

#ifndef _CHAR_UNSIGNED
#define CHAR_MIN    SCHAR_MIN             /* mimimum char value */
#define CHAR_MAX    SCHAR_MAX             /* maximum char value */
#else
#define CHAR_MIN      0
#define CHAR_MAX    UCHAR_MAX
#endif    /* _CHAR_UNSIGNED */

#define MB_LEN_MAX    5                   /* max. # bytes in multibyte char */
#define SHRT_MIN    (-32768)              /* minimum (signed) short value */
#define SHRT_MAX      32767               /* maximum (signed) short value */
#define USHRT_MAX     0xffff              /* maximum unsigned short value */
#define INT_MIN     (-2147483647 - 1)     /* minimum (signed) int value */
#define INT_MAX       2147483647          /* maximum (signed) int value */
#define UINT_MAX      0xffffffff          /* maximum unsigned int value */
#define LONG_MIN    (-2147483647L - 1)    /* minimum (signed) long value */
#define LONG_MAX      2147483647L         /* maximum (signed) long value */
#define ULONG_MAX     0xffffffffUL        /* maximum unsigned long value */
#define LLONG_MAX     9223372036854775807i64       /* maximum signed long long int value */
#define LLONG_MIN   (-9223372036854775807i64 - 1)  /* minimum signed long long int value */
#define ULLONG_MAX    0xffffffffffffffffui64       /* maximum unsigned long long int value */

#if    _INTEGRAL_MAX_BITS >= 8
#define _I8_MIN     (-127i8 - 1)          /* minimum signed 8 bit value */
#define _I8_MAX       127i8               /* maximum signed 8 bit value */
#define _UI8_MAX      0xffui8             /* maximum unsigned 8 bit value */
#endif

#if    _INTEGRAL_MAX_BITS >= 16
#define _I16_MIN    (-32767i16 - 1)       /* minimum signed 16 bit value */
#define _I16_MAX      32767i16            /* maximum signed 16 bit value */
#define _UI16_MAX     0xffffui16          /* maximum unsigned 16 bit value */
#endif

#if    _INTEGRAL_MAX_BITS >= 32
#define _I32_MIN    (-2147483647i32 - 1)  /* minimum signed 32 bit value */
#define _I32_MAX      2147483647i32       /* maximum signed 32 bit value */
#define _UI32_MAX     0xffffffffui32      /* maximum unsigned 32 bit value */
#endif

#if    _INTEGRAL_MAX_BITS >= 64
/* minimum signed 64 bit value */
#define _I64_MIN    (-9223372036854775807i64 - 1)
/* maximum signed 64 bit value */
#define _I64_MAX      9223372036854775807i64
/* maximum unsigned 64 bit value */
#define _UI64_MAX     0xffffffffffffffffui64
#endif

#if    _INTEGRAL_MAX_BITS >= 128
/* minimum signed 128 bit value */
#define _I128_MIN    (-170141183460469231731687303715884105727i128 - 1)
/* maximum signed 128 bit value */
#define _I128_MAX      170141183460469231731687303715884105727i128
/* maximum unsigned 128 bit value */
#define _UI128_MAX     0xffffffffffffffffffffffffffffffffui128
#endif


/****************** FLOAT.H *************************/

#define DBL_DIG        15                 /* # of decimal digits of precision */
#define DBL_EPSILON    2.2204460492503131e-016 /* smallest such that 1.0+DBL_EPSILON != 1.0 */
#define DBL_MANT_DIG   53                 /* # of bits in mantissa */
#define DBL_MAX        1.7976931348623158e+308 /* max value */
#define DBL_MAX_10_EXP 308                /* max decimal exponent */
#define DBL_MAX_EXP    1024               /* max binary exponent */
#define DBL_MIN        2.2250738585072014e-308 /* min positive value */
#define DBL_MIN_10_EXP (-307)             /* min decimal exponent */
#define DBL_MIN_EXP    (-1021)            /* min binary exponent */
#define _DBL_RADIX     2                  /* exponent radix */
#define _DBL_ROUNDS    1                  /* addition rounding: near */

#define FLT_DIG        6                  /* # of decimal digits of precision */
#define FLT_EPSILON    1.192092896e-07F   /* smallest such that 1.0+FLT_EPSILON != 1.0 */
#define FLT_GUARD      0
#define FLT_MANT_DIG   24                 /* # of bits in mantissa */
#define FLT_MAX        3.402823466e+38F   /* max value */
#define FLT_MAX_10_EXP 38                 /* max decimal exponent */
#define FLT_MAX_EXP    128                /* max binary exponent */
#define FLT_MIN        1.175494351e-38F   /* min positive value */
#define FLT_MIN_10_EXP (-37)              /* min decimal exponent */
#define FLT_MIN_EXP    (-125)             /* min binary exponent */
#define FLT_NORMALIZE  0
#define FLT_RADIX      2                  /* exponent radix */
#define FLT_ROUNDS     1                  /* addition rounding: near */

#define LDBL_DIG        DBL_DIG           /* # of decimal digits of precision */
#define LDBL_EPSILON    DBL_EPSILON       /* smallest such that 1.0+LDBL_EPSILON != 1.0 */
#define LDBL_MANT_DIG   DBL_MANT_DIG      /* # of bits in mantissa */
#define LDBL_MAX        DBL_MAX           /* max value */
#define LDBL_MAX_10_EXP DBL_MAX_10_EXP    /* max decimal exponent */
#define LDBL_MAX_EXP    DBL_MAX_EXP       /* max binary exponent */
#define LDBL_MIN        DBL_MIN           /* min positive value */
#define LDBL_MIN_10_EXP DBL_MIN_10_EXP    /* min decimal exponent */
#define LDBL_MIN_EXP    DBL_MIN_EXP       /* min binary exponent */
#define _LDBL_RADIX     DBL_RADIX         /* exponent radix */
#define _LDBL_ROUNDS    DBL_ROUNDS        /* addition rounding: near */

/* Abstract User Control Word Mask and bit definitions */

#define _MCW_EM         0x0008001f        /* interrupt Exception Masks */
#define _EM_INEXACT     0x00000001        /*   inexact (precision) */
#define _EM_UNDERFLOW   0x00000002        /*   underflow */
#define _EM_OVERFLOW    0x00000004        /*   overflow */
#define _EM_ZERODIVIDE  0x00000008        /*   zero divide */
#define _EM_INVALID     0x00000010        /*   invalid */
#define _MCW_RC         0x00000300        /* Rounding Control */
#define _RC_NEAR        0x00000000        /*   near */
#define _RC_DOWN        0x00000100        /*   down */
#define _RC_UP          0x00000200        /*   up */
#define _RC_CHOP        0x00000300        /*   chop */

/* Abstract User Status Word bit definitions */

#define _SW_INEXACT     0x00000001        /* inexact (precision) */
#define _SW_UNDERFLOW   0x00000002        /* underflow */
#define _SW_OVERFLOW    0x00000004        /* overflow */
#define _SW_ZERODIVIDE  0x00000008        /* zero divide */
#define _SW_INVALID     0x00000010        /* invalid */

/* i386 specific definitions */

#define _MCW_PC         0x00030000        /* Precision Control */
#define _PC_64          0x00000000        /*    64 bits */
#define _PC_53          0x00010000        /*    53 bits */
#define _PC_24          0x00020000        /*    24 bits */
#define _MCW_IC         0x00040000        /* Infinity Control */
#define _IC_AFFINE      0x00040000        /*   affine */
#define _IC_PROJECTIVE  0x00000000        /*   projective */
#define _EM_DENORMAL    0x00080000        /* denormal exception mask (_control87 only) */
#define _SW_DENORMAL    0x00080000        /* denormal status bit */

/* MIPS R4000 and SH4 specific definitions */

#ifdef  _M_SH
#define _MCW_DN     0x00040000            /* Denormal Control (SH4) */
#define _DN_FLUSH   0x00040000            /*   flush to zero  (SH4) */
#else
#define _MCW_DN     0x01000000            /* Denormal Control (R4000) */
#define _DN_FLUSH   0x01000000            /*   flush to zero  (R4000) */
#endif
#define _DN_SAVE    0x00000000            /*   save */

/* initial Control Word value */

#ifdef    _M_IX86
#define _CW_DEFAULT ( _RC_NEAR + _PC_64 + _EM_INVALID + _EM_ZERODIVIDE + _EM_OVERFLOW + _EM_UNDERFLOW + _EM_INEXACT )
#else
#define _CW_DEFAULT ( _RC_NEAR + _PC_53 + _EM_INVALID + _EM_ZERODIVIDE + _EM_OVERFLOW + _EM_UNDERFLOW + _EM_INEXACT )
#endif

/* invalid subconditions (_SW_INVALID also set) */

#define _SW_UNEMULATED      0x0040    /* unemulated instruction */
#define _SW_SQRTNEG         0x0080    /* square root of a neg number */
#define _SW_STACKOVERFLOW   0x0200    /* FP stack overflow */
#define _SW_STACKUNDERFLOW  0x0400    /* FP stack underflow */

/* Floating point error signals and return codes */

#define _FPE_INVALID        0x81
#define _FPE_DENORMAL       0x82
#define _FPE_ZERODIVIDE     0x83
#define _FPE_OVERFLOW       0x84
#define _FPE_UNDERFLOW      0x85
#define _FPE_INEXACT        0x86
#define _FPE_UNEMULATED     0x87
#define _FPE_SQRTNEG        0x88
#define _FPE_STACKOVERFLOW  0x8a
#define _FPE_STACKUNDERFLOW 0x8b
#define _FPE_EXPLICITGEN    0x8c    /* raise( SIGFPE ); */

/* Floating point function prototypes */

_CRTIMP unsigned int __cdecl _clearfp(void);
_CRT_INSECURE_DEPRECATE(_controlfp_s) _CRTIMP unsigned int __cdecl _controlfp(__in unsigned int _NewValue,__in unsigned int _Mask);
_CRTIMP unsigned int __cdecl _statusfp(void);
_CRTIMP void __cdecl _fpreset(void);
#define _clear87    _clearfp
#define _status87   _statusfp

/* IEEE recommended functions */

_CRTIMP __checkReturn double __cdecl _copysign (__in double _Number, __in double _Sign);
_CRTIMP __checkReturn double __cdecl _chgsign (__in double _X);
_CRTIMP __checkReturn double __cdecl _scalb(__in double _X, __in long _Y);
_CRTIMP __checkReturn double __cdecl _logb(__in double _X);
_CRTIMP __checkReturn double __cdecl _nextafter(__in double _X, __in double _Y);
_CRTIMP __checkReturn int    __cdecl _finite(__in double _X);
_CRTIMP __checkReturn int    __cdecl _isnan(__in double _X);
_CRTIMP __checkReturn int    __cdecl _fpclass(__in double _X);

#define _FPCLASS_SNAN   0x0001  /* signaling NaN */
#define _FPCLASS_QNAN   0x0002  /* quiet NaN */
#define _FPCLASS_NINF   0x0004  /* negative infinity */
#define _FPCLASS_NN     0x0008  /* negative normal */
#define _FPCLASS_ND     0x0010  /* negative denormal */
#define _FPCLASS_NZ     0x0020  /* -0 */
#define _FPCLASS_PZ     0x0040  /* +0 */
#define _FPCLASS_PD     0x0080  /* positive denormal */
#define _FPCLASS_PN     0x0100  /* positive normal */
#define _FPCLASS_PINF   0x0200  /* positive infinity */

typedef float           _FP32;
typedef double          _FP64;
typedef short           _I16;
typedef int             _I32;
typedef unsigned short  _U16;
typedef unsigned int    _U32;

typedef struct {
    unsigned long W[4];
} _U32ARRAY;

typedef struct {
    unsigned short W[5];
} _FP80;

typedef struct {
    unsigned long W[4];
} _FP128;

typedef struct {
    unsigned long W[2];
} _I64;

typedef struct {
    unsigned long W[2];
} _U64;

typedef struct {
    unsigned short W[5];
} _BCD80;

typedef struct {
    union {
        _FP32        Fp32Value;
        _FP64        Fp64Value;
#ifndef _FP_NO_EXTENDED_PRECISION
        _FP80        Fp80Value;
        _FP128       Fp128Value;
#endif
        _I16         I16Value;
        _I32         I32Value;
        _I64         I64Value;
        _U16         U16Value;
        _U32         U32Value;
        _U64         U64Value;
#ifndef _FP_NO_EXTENDED_PRECISION
        _BCD80       Bcd80Value;
#endif
        char         *StringValue;
        int      CompareValue;
        _U32ARRAY    U32ArrayValue;
    } Value;
    unsigned int OperandValid : 1;
    unsigned int Format : 4;
} _FPIEEE_VALUE;

typedef struct {
    unsigned int Inexact : 1;
    unsigned int Underflow : 1;
    unsigned int Overflow : 1;
    unsigned int ZeroDivide : 1;
    unsigned int InvalidOperation : 1;
} _FPIEEE_EXCEPTION_FLAGS;

typedef struct {
    unsigned int RoundingMode : 2;
    unsigned int Precision : 3;
    unsigned int Operation :12;
    _FPIEEE_EXCEPTION_FLAGS Cause;
    _FPIEEE_EXCEPTION_FLAGS Enable;
    _FPIEEE_EXCEPTION_FLAGS Status;
    _FPIEEE_VALUE Operand1;
    _FPIEEE_VALUE Operand2;
    _FPIEEE_VALUE Result;
} _FPIEEE_RECORD;


struct _EXCEPTION_POINTERS;

/*
 * Floating point IEEE exception filter routine
 */

_CRTIMP int __cdecl _fpieee_flt(
        __in unsigned long _ExceptionCode,
        __in struct _EXCEPTION_POINTERS * _PtExceptionPtr,
        __in int (__cdecl * _Handler)(_FPIEEE_RECORD *)
        );

#if !__STDC__
// Non-ANSI names for compatibility
#define DBL_RADIX           _DBL_RADIX
#define DBL_ROUNDS          _DBL_ROUNDS
#define LDBL_RADIX          _LDBL_RADIX
#define LDBL_ROUNDS         _LDBL_ROUNDS
#define MCW_EM              _MCW_EM
#define EM_INVALID          _EM_INVALID
#define EM_ZERODIVIDE       _EM_ZERODIVIDE
#define EM_OVERFLOW         _EM_OVERFLOW
#define EM_UNDERFLOW        _EM_UNDERFLOW
#define EM_INEXACT          _EM_INEXACT

#define EM_DENORMAL         _EM_DENORMAL
#define SW_DENORMAL         _SW_DENORMAL
#define MCW_IC              _MCW_IC
#define IC_AFFINE           _IC_AFFINE
#define IC_PROJECTIVE       _IC_PROJECTIVE
#define MCW_PC              _MCW_PC
#define PC_24               _PC_24
#define PC_53               _PC_53
#define PC_64               _PC_64

#define MCW_RC              _MCW_RC
#define RC_CHOP             _RC_CHOP
#define RC_UP               _RC_UP
#define RC_DOWN             _RC_DOWN
#define RC_NEAR             _RC_NEAR
#define CW_DEFAULT          _CW_DEFAULT
#define SW_INVALID          _SW_INVALID
#define SW_ZERODIVIDE       _SW_ZERODIVIDE
#define SW_OVERFLOW         _SW_OVERFLOW
#define SW_UNDERFLOW        _SW_UNDERFLOW
#define SW_INEXACT          _SW_INEXACT
#define SW_UNEMULATED       _SW_UNEMULATED
#define SW_SQRTNEG          _SW_SQRTNEG
#define SW_STACKOVERFLOW    _SW_STACKOVERFLOW
#define SW_STACKUNDERFLOW   _SW_STACKUNDERFLOW
#define FPE_INVALID         _FPE_INVALID
#define FPE_DENORMAL        _FPE_DENORMAL
#define FPE_ZERODIVIDE      _FPE_ZERODIVIDE
#define FPE_OVERFLOW        _FPE_OVERFLOW
#define FPE_UNDERFLOW       _FPE_UNDERFLOW
#define FPE_INEXACT         _FPE_INEXACT
#define FPE_UNEMULATED      _FPE_UNEMULATED
#define FPE_SQRTNEG         _FPE_SQRTNEG
#define FPE_STACKOVERFLOW   _FPE_STACKOVERFLOW
#define FPE_STACKUNDERFLOW  _FPE_STACKUNDERFLOW
#define FPE_EXPLICITGEN     _FPE_EXPLICITGEN
#endif /* !__STDC__ */


/****************** MATH.H **************************/

_CRTIMP double _frnd(__in double _X);
_CRTIMP double _fsqrt(__in double _X);

/*
 * definition of a _complex struct to be used by those who use cabs and
 * want type checking on their argument
 */
struct _complex {
    double x,y;    /* real and imaginary parts */
    } ;

#if !__STDC__ && !defined(__cplusplus)
// Non-ANSI name for compatibility
#define complex _complex
#endif /* !__STDC__ */

// definitions of _HUGE and HUGE_VAL - respectively the XENIX and ANSI names
// for a value returned in case of error by a number of the floating point
// math routines
// @CESYSGEN IF !REMOVE_DRAGON
_CRTIMP_DATA
// @CESYSGEN ENDIF
extern double _HUGE;
#define HUGE_VAL _HUGE

// MATH.H func defns
#if !defined(__assembler)
_INTRIMP  int       __cdecl abs(__in int _X);
_INTRIMP  long      __cdecl labs(__in long _X);
#endif
_INTRIMP  __int64   __cdecl _abs64(__in __int64 _X);
_INTRIMP2 float     __cdecl ceilf(__in float _X);
_INTRIMP2 float     __cdecl fabsf(__in float _X);
_INTRIMP2 float     __cdecl floorf(__in float _X);
_INTRIMP2 float     __cdecl fmodf(__in float _X, __in float _Y);
_INTRIMP2 float     __cdecl sqrtf(__in float _X);
_INTRIMP  double    __cdecl acos(__in double _X);
_INTRIMP  double    __cdecl asin(__in double _X);
_INTRIMP  double    __cdecl atan(__in double _X);
_INTRIMP  double    __cdecl atan2(__in double _Y, __in double _X);
_INTRIMP  double    __cdecl cos(__in double _X);
_INTRIMP  double    __cdecl cosh(__in double _X);
_INTRIMP  double    __cdecl exp(__in double _X);
_INTRIMP  double    __cdecl fabs(__in double _X);
_INTRIMP  double    __cdecl fmod(__in double _X, __in double _Y);
_INTRIMP  double    __cdecl log(__in double _X);
_INTRIMP  double    __cdecl log10(__in double _X);
_INTRIMP  double    __cdecl pow(__in double _X, __in double _Y);
_INTRIMP  double    __cdecl sin(__in double _X);
_INTRIMP  double    __cdecl sinh(__in double _X);
_INTRIMP  double    __cdecl sqrt(__in double _X);
_INTRIMP  double    __cdecl tan(__in double _X);
_INTRIMP  double    __cdecl tanh(__in double _X);
_CRTIMP   double    __cdecl _cabs(__in struct _complex _Complex);
_INTRIMP2 double    __cdecl ceil(__in double _X);
_INTRIMP  double    __cdecl floor(__in double _X);
_CRTIMP   double    __cdecl frexp(__in double _X, __out int * _Y);
_CRTIMP   double    __cdecl _hypot(__in double _X, __in double _Y);
_CRTIMP   double    __cdecl _j0(__in double _X);
_CRTIMP   double    __cdecl _j1(__in double _X);
_CRTIMP   double    __cdecl _jn(__in int _X, __in double _Y);
_CRTIMP   double    __cdecl ldexp(__in double _X, __in int _Y);
_CRTIMP   int       __cdecl _matherr(__inout struct _exception * _Except);
_CRTIMP   double    __cdecl modf(__in double _X, __out double * _Y);
_CRTIMP   double    __cdecl _y0(__in double _X);
_CRTIMP   double    __cdecl _y1(__in double _X);
_CRTIMP   double    __cdecl _yn(__in int _X, __in double _Y);

#if defined(_M_MRX000) // MIPS
#pragma function(floor, floorf, ceil, ceilf)
#pragma intrinsic(sqrtf) // for MIPSII-FP and MIPSIV-FP, ignored otherwise
#endif

#if defined(_M_SH) // SH4
#pragma intrinsic(fabsf, sqrtf)
#endif

// MATH.H macros -- oldnames
#define acosl(x)    ((long double)acos((double)(x)))
#define asinl(x)    ((long double)asin((double)(x)))
#define atanl(x)    ((long double)atan((double)(x)))
#define atan2l(x,y) ((long double)atan2((double)(x), (double)(y)))
#define ceill(x)    ((long double)ceil((double)(x)))
#define cosl(x)     ((long double)cos((double)(x)))
#define coshl(x)    ((long double)cosh((double)(x)))
#define expl(x)     ((long double)exp((double)(x)))
#define fabsl(x)    ((long double)fabs((double)(x)))
#define floorl(x)   ((long double)floor((double)(x)))
#define fmodl(x,y)  ((long double)fmod((double)(x), (double)(y)))
#define frexpl(x,y) ((long double)frexp((double)(x), (y)))
#define hypotl(x,y) ((long double)hypot((double)(x), (double)(y)))
#define ldexpl(x,y) ((long double)ldexp((double)(x), (y)))
#define logl(x)     ((long double)log((double)(x)))
#define log10l(x)   ((long double)log10((double)(x)))
#define _matherrl   _matherr
#define modfl(x,y)  ((long double)modf((double)(x), (double *)(y)))
#define powl(x,y)   ((long double)pow((double)(x), (double)(y)))
#define sinl(x)     ((long double)sin((double)(x)))
#define sinhl(x)    ((long double)sinh((double)(x)))
#define sqrtl(x)    ((long double)sqrt((double)(x)))
#define tanl(x)     ((long double)tan((double)(x)))
#define tanhl(x)    ((long double)tanh((double)(x)))


/****************** STDARG.H ************************/

#if defined(_M_MRX000)

#if _MSC_VER > 1200

#ifdef __cplusplus
extern "C" int __cdecl __regsize (void);
#else
int __cdecl __regsize (void);
#endif

#define SIZE_OF_INT_REG   (__regsize())

#else

#define SIZE_OF_INT_REG   (4)

#endif

#define _ARGSIZE(n)  ((__builtin_alignof(n) > SIZE_OF_INT_REG) ? __builtin_alignof(n) : SIZE_OF_INT_REG)

#if _MSC_VER > 1200

#ifdef __cplusplus

extern "C" void __cdecl __va_start(va_list*, ...);
#define _crt_va_start(ap,v) (__va_start(&ap, &v, sizeof(v)))

#else // __cplusplus

#define _crt_va_start(ap,v) ap  = (va_list)&v + sizeof(v)

#endif // __cplusplus

#else // _MSC_VER > 1200

#define _crt_va_start(ap,v) ap  = (va_list)&v + sizeof(v)

#endif // _MSC_VER > 1200

#define _crt_va_end(list) ( list = (va_list)0 )
#define _crt_va_arg(list, mode) ((mode *)(list =\
 (char *) ((((int)list + (_ARGSIZE(mode) - 1)) &\
 ~(_ARGSIZE(mode) - 1))+sizeof(mode))))[-1]

#elif defined(_M_SH)

#define _INTSIZEOF(n) ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#ifdef __cplusplus

extern  "C" void __cdecl __va_start(va_list*, ...);
#define _crt_va_start(ap,v) (__va_start(&ap, &v, _INTSIZEOF(v)))

#else // __cplusplus

#define _crt_va_start(ap,v) ap  = (va_list)&v + _INTSIZEOF(v)

#endif // __cplusplus

#define _crt_va_arg(ap,t)    ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define _crt_va_end(ap)      ( ap = (va_list)0 )

#else // defined(_M_MRX000)

#define _INTSIZEOF(n)   ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )
#define _crt_va_start(ap,v)  ( ap = (va_list)&v + _INTSIZEOF(v) )
#define _crt_va_arg(ap,t)    ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define _crt_va_end(ap)      ( ap = (va_list)0 )

#endif // defined(_M_MRX000)

#define va_start _crt_va_start
#define va_arg _crt_va_arg
#define va_end _crt_va_end

/****************** SETJMP.H ************************/

#ifdef _M_IX86
#define _JBLEN    16
#elif defined(_M_SH) || defined(_M_MRX000)
#define _JBLEN    32
#elif defined(_M_ARM)
#define _JBLEN    11
#endif

#define _JBTYPE int

/* Define the buffer type for holding the state information */
typedef _JBTYPE jmp_buf[_JBLEN];

#define setjmp _setjmp  /* redirect to the intrinsic */
int __cdecl setjmp(__out jmp_buf _Buf);
#ifdef  __cplusplus
_CRTIMP _CRTNORETURN void __cdecl longjmp(__in jmp_buf _Buf, __in int _Value) throw(...);
#else
_CRTIMP _CRTNORETURN void __cdecl longjmp(__in jmp_buf _Buf, __in int _Value);
#endif

#ifdef __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif    /* _INC_STDLIB */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\storemgr.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
#ifndef __STORAGEMGR__
#define __STORAGEMGR__


#include <windows.h>


// {A4E7EDDA-E575-4252-9D6B-4195D48BB865}
static const GUID BLOCK_DRIVER_GUID = { 0xa4e7edda, 0xe575, 0x4252, { 0x9d, 0x6b, 0x41, 0x95, 0xd4, 0x8b, 0xb8, 0x65 } };
// {C1115848-46FD-4976-BDE9-D79448457004}
static const GUID STORE_MOUNT_GUID  = { 0xc1115848, 0x46fd, 0x4976, { 0xbd, 0xe9, 0xd7, 0x94, 0x48, 0x45, 0x70, 0x4 } };
// {169E1941-04CE-4690-97AC-776187EB67CC}
static const GUID FATFS_MOUNT_GUID = { 0x169e1941, 0x4ce, 0x4690, { 0x97, 0xac, 0x77, 0x61, 0x87, 0xeb, 0x67, 0xcc } };
// {72D75746-D54A-4487-B7A1-940C9A3F259A}
static const GUID CDFS_MOUNT_GUID =  { 0x72d75746, 0xd54a, 0x4487, { 0xb7, 0xa1, 0x94, 0xc, 0x9a, 0x3f, 0x25, 0x9a } };
// {462FEDA9-D478-4b00-86BB-51A8E3D10890}
static const GUID UDFS_MOUNT_GUID = { 0x462feda9, 0xd478, 0x4b00, { 0x86, 0xbb, 0x51, 0xa8, 0xe3, 0xd1, 0x8, 0x90 } };
// {BA6B1343-7980-4d0c-9290-762D527B33AB}
static const GUID CDDA_MOUNT_GUID = { 0xba6b1343, 0x7980, 0x4d0c, { 0x92, 0x90, 0x76, 0x2d, 0x52, 0x7b, 0x33, 0xab } };
// {8C77EDE8-47B9-45ae-8BC9-86E7B8D00EDD}
static const GUID FSD_MOUNT_GUID = { 0x8c77ede8, 0x47b9, 0x45ae, { 0x8b, 0xc9, 0x86, 0xe7, 0xb8, 0xd0, 0xe, 0xdd } };
// {9A1E75E9-B24A-4838-B448-C026CA01323C}
static const GUID BOOTFS_MOUNT_GUID = { 0x9a1e75e9, 0xb24a, 0x4838, { 0xb4, 0x48, 0xc0, 0x26, 0xca, 0x1, 0x32, 0x3c } };
// {0473DD50-D4CA-4ae2-BF5C-F09FD611C1CF}
static const GUID ROOTFS_MOUNT_GUID = { 0x473dd50, 0xd4ca, 0x4ae2, { 0xbf, 0x5c, 0xf0, 0x9f, 0xd6, 0x11, 0xc1, 0xcf } };
// {945E7231-17C0-4753-AD4E-BEFCA2FA6AE2}
static const GUID ROMFS_MOUNT_GUID = { 0x945e7231, 0x17c0, 0x4753, { 0xad, 0x4e, 0xbe, 0xfc, 0xa2, 0xfa, 0x6a, 0xe2 } };
// {54CA35ED-CAF3-4b34-BC6B-6DFC7F22E6A9}
static const GUID STORAGE_MEDIA_GUID = { 0x54ca35ed, 0xcaf3, 0x4b34, { 0xbc, 0x6b, 0x6d, 0xfc, 0x7f, 0x22, 0xe6, 0xa9 } };



#define BLOCK_DRIVER_GUID_STRING  L"{A4E7EDDA-E575-4252-9D6B-4195D48BB865}"
#define STORE_MOUNT_GUID_STRING   L"{C1115848-46FD-4976-BDE9-D79448457004}"
#define FATFS_MOUNT_GUID_STRING   L"{169E1941-04CE-4690-97AC-776187EB67CC}"
#define CDFS_MOUNT_GUID_STRING    L"{72D75746-D54A-4487-B7A1-940C9A3F259A}"
#define UDFS_MOUNT_GUID_STRING    L"{462FEDA9-D478-4b00-86BB-51A8E3D10890}"
#define CDDA_MOUNT_GUID_STRING    L"{BA6B1343-7980-4d0c-9290-762D527B33AB}"
#define FSD_MOUNT_GUID_STRING     L"{8C77EDE8-47B9-45ae-8BC9-86E7B8D00EDD}"
#define BOOTFS_MOUNT_GUID_STRING  L"{9A1E75E9-B24A-4838-B448-C026CA01323C}"
#define ROOTFS_MOUNT_GUID_STRING  L"{0473DD50-D4CA-4ae2-BF5C-F09FD611C1CF}"
#define ROMFS_MOUNT_GUID_STRING   L"{945E7231-17C0-4753-AD4E-BEFCA2FA6AE2}"

// {14ACDEE6-5CF3-496b-B39D-8954C96DF002}
static const GUID STOREMGR_DRIVER_GUID = { 0x14acdee6, 0x5cf3, 0x496b, { 0xb3, 0x9d, 0x89, 0x54, 0xc9, 0x6d, 0xf0, 0x2 } };
#define STOREMGR_DRIVER_GUID_STRING = L"{14ACDEE6-5CF3-496b-B39D-8954C96DF002}"


/*****************************************************************************/
/* attributes of a store */
#define STORE_ATTRIBUTE_READONLY    0x00000001
#define STORE_ATTRIBUTE_REMOVABLE   0x00000002
#define STORE_ATTRIBUTE_UNFORMATTED 0x00000004
#define STORE_ATTRIBUTE_AUTOFORMAT  0x00000008
#define STORE_ATTRIBUTE_AUTOPART    0x00000010
#define STORE_ATTRIBUTE_AUTOMOUNT   0x00000020

/* attributes for a partition */
#define PARTITION_ATTRIBUTE_EXPENDABLE 0x00000001  // partition may be trashed 
#define PARTITION_ATTRIBUTE_READONLY   0x00000002  // partition is read-only   
#define PARTITION_ATTRIBUTE_AUTOFORMAT 0x00000004  
#define PARTITION_ATTRIBUTE_ACTIVE     0x00000008
#define PARTITION_ATTRIBUTE_BOOT       0x00000008  // Active(DOS) == Boot(CE)
#define PARTITION_ATTRIBUTE_MOUNTED    0x00000010

/* some basic constants */
#define DEVICENAMESIZE    8
#define STORENAMESIZE     32
#define FILESYSNAMESIZE   32
#define FORMATNAMESIZE    32
#define PARTITIONNAMESIZE 32
#define PROFILENAMESIZE   32
#define FOLDERNAMESIZE    32
#define VOLUMENAMESIZE    64
#define FSDDESCSIZE       32

/* definition used to represent a sector number or sector range */
typedef ULONGLONG SECTORNUM;

//****************************************************************************
typedef struct tagSTORAGEDEVICEINFO
{
    DWORD cbSize;
    TCHAR szProfile[PROFILENAMESIZE];
    DWORD dwDeviceClass;
    DWORD dwDeviceType;
    DWORD dwDeviceFlags;
} STORAGEDEVICEINFO, *PSTORAGEDEVICEINFO;

#define STORAGE_DEVICE_CLASS_BLOCK         0x1
#define STORAGE_DEVICE_CLASS_MULTIMEDIA    0x2

#define STORAGE_DEVICE_TYPE_PCIIDE               (1 << 0)
#define STORAGE_DEVICE_TYPE_FLASH                (1 << 1)
#define STORAGE_DEVICE_TYPE_ATA                  (1 << 2)
#define STORAGE_DEVICE_TYPE_ATAPI                (1 << 4)
#define STORAGE_DEVICE_TYPE_PCCARD               (1 << 5)
#define STORAGE_DEVICE_TYPE_CFCARD               (1 << 6)
#define STORAGE_DEVICE_TYPE_SRAM                 (1 << 7)
#define STORAGE_DEVICE_TYPE_DVD                  (1 << 8)
#define STORAGE_DEVICE_TYPE_CDROM                (1 << 9)
#define STORAGE_DEVICE_TYPE_USB                  (1 << 10)
#define STORAGE_DEVICE_TYPE_1394                 (1 << 11)
#define STORAGE_DEVICE_TYPE_DOC                  (1 << 12)
#define STORAGE_DEVICE_TYPE_UNKNOWN              (1 << 29)
#define STORAGE_DEVICE_TYPE_REMOVABLE_DRIVE      (1 << 30) // Drive itself is removable
#define STORAGE_DEVICE_TYPE_REMOVABLE_MEDIA      (1 << 31) // Just the media is removable ex. CDROM, FLOPPY

#define STORAGE_DEVICE_FLAG_READWRITE      (1 << 0)
#define STORAGE_DEVICE_FLAG_READONLY       (1 << 1)
#define STORAGE_DEVICE_FLAG_TRANSACTED     (1 << 2)
#define STORAGE_DEVICE_FLAG_MEDIASENSE     (1 << 3)  // Device requires media sense calls
#define STORAGE_DEVICE_FLAG_XIP            (1 << 4)

/*****************************************************************************/
// information about a store */
typedef struct tagSTOREINFO
{
    DWORD      cbSize;                  // sizeof(PD_STOREINFO)                   
    TCHAR      szDeviceName[DEVICENAMESIZE];
    TCHAR      szStoreName[STORENAMESIZE];
    DWORD      dwDeviceClass;
    DWORD      dwDeviceType;
    STORAGEDEVICEINFO sdi;
    DWORD      dwDeviceFlags;
    SECTORNUM  snNumSectors;            // number of sectors on store             
    DWORD      dwBytesPerSector;        // number of bytes per sector             
    SECTORNUM  snFreeSectors;           // number of unallocated sectors          
    SECTORNUM  snBiggestPartCreatable;  // biggest partition currently creatable  
    FILETIME   ftCreated;               // last time store was formatted          
    FILETIME   ftLastModified;          // last time partition table was modified 
    DWORD      dwAttributes;            // store attributes, see below            
    DWORD      dwPartitionCount;        // Number of Partitions 
    DWORD      dwMountCount;            // Number of partitions that have been mounted
} STOREINFO, *PSTOREINFO;


//***************************************************************************
// information about a partition 

typedef struct tagPARTINFO
{
    DWORD     cbSize;                               // sizeof(PD_PARTINFO)             
    TCHAR     szPartitionName[PARTITIONNAMESIZE];   // name of partition                 
    TCHAR     szFileSys[FILESYSNAMESIZE];
    TCHAR     szVolumeName[VOLUMENAMESIZE];
    SECTORNUM snNumSectors;                         // number of sectors in partition    
    FILETIME  ftCreated;                            // creation time of partition        
    FILETIME  ftLastModified;                       // last time partition was modified  
    DWORD     dwAttributes;                         // partition attributes, see below   
    BYTE      bPartType;                  
} PARTINFO, *PPARTINFO;

//****************************************************************************/

typedef struct tagSTORAGECONTEXT
{
    DWORD cbSize;
    STOREINFO StoreInfo;
    PARTINFO PartInfo;
    DWORD dwFlags;
} STORAGECONTEXT, *PSTORAGECONTEXT;


#ifdef __cplusplus
extern "C" {
#endif


BOOL IsStorageManagerRunning();
// Storage Management API's
HANDLE WINAPI OpenStore(LPCTSTR szDeviceName);
BOOL   WINAPI DismountStore(HANDLE hStore);
BOOL   WINAPI FormatStore(HANDLE hStore);
HANDLE WINAPI FindFirstStore(PSTOREINFO pStoreInfo);
BOOL   WINAPI FindNextStore(HANDLE hSearch, PSTOREINFO pStoreInfo);
BOOL   WINAPI FindCloseStore(HANDLE hSearch);
BOOL   WINAPI GetStoreInfo(HANDLE hStore, PSTOREINFO pStoreInfo);
// Partition Management API's
BOOL   WINAPI CreatePartition(HANDLE hStore, LPCTSTR szPartitionName, SECTORNUM snNumSectors);
BOOL   WINAPI CreatePartitionEx(HANDLE hStore, LPCTSTR szPartitionName, BYTE bPartType, SECTORNUM snNumSectors);
BOOL   WINAPI DeletePartition(HANDLE hStore, LPCTSTR szPartitionName);
HANDLE WINAPI OpenPartition( HANDLE hStore, LPCTSTR szPartitionName);
BOOL   WINAPI MountPartition(HANDLE hPartition);
BOOL   WINAPI DismountPartition(HANDLE hPartition);
BOOL   WINAPI RenamePartition(HANDLE hPartition, LPCTSTR szNewName);
BOOL   WINAPI SetPartitionAttributes(HANDLE hPartition, DWORD dwAttrs);
BOOL   WINAPI GetPartitionInfo(HANDLE hPartition, PPARTINFO pPartInfo);
BOOL   WINAPI FormatPartition(HANDLE hPartition);
BOOL   WINAPI FormatPartitionEx(HANDLE hPartition, BYTE bPartType, BOOL bAuto);
HANDLE WINAPI FindFirstPartition(HANDLE hStore, PPARTINFO pPartInfo);
BOOL   WINAPI FindNextPartition(HANDLE hSearch, PPARTINFO pPartInfo);
BOOL   WINAPI FindClosePartition(HANDLE hSearch);

#ifdef __cplusplus
}
#endif


#define CE_VOLUME_ATTRIBUTE_READONLY                0x1
#define CE_VOLUME_ATTRIBUTE_HIDDEN                  0x2
#define CE_VOLUME_ATTRIBUTE_REMOVABLE               0x4
#define CE_VOLUME_ATTRIBUTE_SYSTEM                  0x8
#define CE_VOLUME_ATTRIBUTE_BOOT                    0x10

#define CE_VOLUME_TRANSACTION_SAFE                  0x1     // Performs transaction safe operations
#define CE_VOLUME_FLAG_TRANSACT_WRITE               0x2
#define CE_VOLUME_FLAG_WFSC_SUPPORTED               0x4
#define CE_VOLUME_FLAG_LOCKFILE_SUPPORTED           0x8
#define CE_VOLUME_FLAG_NETWORK                      0x10
#define CE_VOLUME_FLAG_STORE                        0x20
#define CE_VOLUME_FLAG_RAMFS                        0x40
#define CE_VOLUME_FLAG_FILE_SECURITY_SUPPORTED      0x80    // Persistent file and directory security descriptors
#define CE_VOLUME_FLAG_64BIT_FILES_SUPPORTED        0x100   // 64-bit file sizes and offsets

typedef struct _CE_VOLUME_INFO {
    DWORD cbSize;
    DWORD dwAttributes;
    DWORD dwFlags;
    DWORD dwBlockSize;
    TCHAR szStoreName[STORENAMESIZE];
    TCHAR szPartitionName[PARTITIONNAMESIZE];
} CE_VOLUME_INFO, *PCE_VOLUME_INFO, *LPCE_VOLUME_INFO;

// Supported flags for the CE_VOLUME_SECURITY_INFO structure.
#define CE_VOLUME_SECURITY_FLAG_SKIP_SECURITY_CHECKS    0x00000001

#define SECURITYCLASSNAMESIZE   64

// output structure for CeVolumeGetInfo when CeVolumeInfoLevelSecurity is specified
typedef struct _CE_VOLUME_SECURITY_INFO {
    DWORD cbSize;
    DWORD dwSecurityFlags;
    TCHAR szSecurityClassName[SECURITYCLASSNAMESIZE];
} CE_VOLUME_SECURITY_INFO, *PCE_VOLUME_SECURITY_INFO, *LPCE_VOLUME_SECURITY_INFO;

typedef enum _CE_VOLUME_INFO_LEVEL {
    CeVolumeInfoLevelStandard,
    CeVolumeInfoLevelSecurity,
} CE_VOLUME_INFO_LEVEL;

#ifdef __cplusplus
extern "C" {
#endif


WINBASEAPI
BOOL
CeGetVolumeInfoW(
    IN LPCWSTR pszRootPath,
    IN CE_VOLUME_INFO_LEVEL InfoLevel,
    OUT LPCE_VOLUME_INFO lpVolumeInfo
    );

#define CeGetVolumeInfo CeGetVolumeInfoW    

#ifdef __cplusplus
}
#endif


/*****************************************************************************/
#define IOCTL_STORE_FINDFIRST         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_STORE_OPEN              CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 2, METHOD_BUFFERED, FILE_ANY_ACCESS)

#ifdef WINCEOEM
#ifdef WINCEMACRO
#include <mstoremgr.h>    // internal defines 
#endif
#endif

#endif /* __STORAGEMGR__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\string.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

/***
*string.h - declarations for string manipulation functions
*
*Purpose:
*       This file contains the function declarations for the string
*       manipulation functions.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STRING
#define _INC_STRING

#include <stdlib.h> // STDLIB is included for legacy reasons.  It contains the "old" function declarations.

#include <crtdefs.h>

#ifdef  __cplusplus
extern "C" {
#endif

#ifndef _NLSCMP_DEFINED
#define _NLSCMPERROR    2147483647  /* currently == INT_MAX */
#define _NLSCMP_DEFINED
#endif

/* Define NULL pointer value */
#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif

/* For backwards compatibility */
#define _WConst_return _CONST_RETURN

/* Function prototypes */

#if __STDC_WANT_SECURE_LIB__
_CRTIMP   errno_t  __cdecl memcpy_s(__out_bcount_part_opt(_DstSize, _MaxCount) void * _Dst, __in rsize_t _DstSize, __in_bcount_opt(_MaxCount) const void * _Src, __in rsize_t _MaxCount);
#endif

_CRTIMP_ALTERNATIVE __checkReturn_wat errno_t __cdecl _strset_s(__inout_ecount_z(_DstSize) char * _Dst, __in size_t _DstSize, __in int _Value);
#if __STDC_WANT_SECURE_LIB__
_CRTIMP_ALTERNATIVE __checkReturn_wat errno_t __cdecl strcpy_s(__out_ecount_z(_DstSize) char * _Dst, __in rsize_t _DstSize, __in_z const char * _Src);
#endif
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, strcpy_s, __deref_out_z char, _Dest, __in_z const char *, _Source)
#if __STDC_WANT_SECURE_LIB__
_CRTIMP_ALTERNATIVE __checkReturn_wat errno_t __cdecl strcat_s(__inout_ecount_z(_DstSize) char * _Dst, __in rsize_t _DstSize, __in_z const char * _Src);
#endif
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, strcat_s, __deref_inout_z char, _Dest, __in_z const char *, _Source)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1(char *, __RETURN_POLICY_DST, __EMPTY_DECLSPEC, strcat, __inout_z char, _Dest, __in_z const char *, _Source)
_CRTIMP __checkReturn size_t  __cdecl strnlen(__in_ecount_z(_MaxCount)  const char * _Str, __in size_t _MaxCount);
#if __STDC_WANT_SECURE_LIB__ && !defined (__midl)
static __inline __checkReturn size_t __CRTDECL strnlen_s(__in_ecount_z(_MaxCount) const char * _Str, __in size_t _MaxCount)
{
    return (_Str == NULL) ? 0 : strnlen(_Str, _MaxCount);
}
#endif
#if __STDC_WANT_SECURE_LIB__
_CRTIMP __checkReturn_wat errno_t __cdecl memmove_s(__out_bcount_part_opt(_DstSize,_MaxCount) void * _Dst, __in rsize_t _DstSize, __in_bcount_opt(_MaxCount) const void * _Src, __in rsize_t _MaxCount);
#endif

_CRTIMP __checkReturn_wat errno_t __cdecl _strlwr_s(__inout_ecount_z(_Size) char * _Str, __in size_t _Size);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(errno_t, _strlwr_s, __deref_inout_z char, _String)
#if __STDC_WANT_SECURE_LIB__
_CRTIMP_ALTERNATIVE __checkReturn_wat errno_t __cdecl strncat_s(__inout_ecount_z(_DstSize) char * _Dst, __in rsize_t _DstSize, __in_z const char * _Src, __in rsize_t _MaxCount);
#endif
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, strncat_s, __deref_inout_z char, _Dest, __in_z const char *, _Source, __in size_t, _Count)
#if __STDC_WANT_SECURE_LIB__
_CRTIMP_ALTERNATIVE __checkReturn_wat errno_t __cdecl strncpy_s(__out_ecount_z(_DstSize) char * _Dst, __in rsize_t _DstSize, __in_z_opt const char * _Src, __in rsize_t _MaxCount);
#endif
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, strncpy_s, char, _Dest, __in_z const char *, _Source, __in size_t, _Count)
_CRTIMP_ALTERNATIVE __checkReturn_wat errno_t __cdecl _strnset_s(__inout_ecount_z(_Size) char * _Str, __in size_t _Size, __in int _Val, __in size_t _MaxCount);
#if __STDC_WANT_SECURE_LIB__
_CRTIMP_ALTERNATIVE __checkReturn char *  __cdecl strtok_s(__inout_z_opt char * _Str, __in_z const char * _Delim, __deref_inout_z_opt char ** _Context);
#endif
_CRTIMP __checkReturn_wat errno_t __cdecl _strupr_s(__inout_ecount_z(_Size) char * _Str, __in size_t _Size);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(errno_t, _strupr_s, __deref_inout_z char, _String)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(char *, __RETURN_POLICY_DST, _CRTIMP, _strupr, __inout_z char, _String)

/* wide function prototypes */

#if __STDC_WANT_SECURE_LIB__
_CRTIMP_ALTERNATIVE __checkReturn_wat errno_t __cdecl wcscat_s(__inout_ecount_z(_DstSize) wchar_t * _Dst, __in rsize_t _DstSize, const wchar_t * _Src);
#endif
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, wcscat_s, __deref_inout_z wchar_t, _Dest, __in_z const wchar_t *, _Source)
#if __STDC_WANT_SECURE_LIB__
_CRTIMP_ALTERNATIVE __checkReturn_wat errno_t __cdecl wcscpy_s(__out_ecount_z(_DstSize) wchar_t * _Dst, __in rsize_t _DstSize, __in_z const wchar_t * _Src);
#endif
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, wcscpy_s, wchar_t, _Dest, __in_z const wchar_t *, _Source)
_CRTIMP __checkReturn size_t __cdecl wcsnlen(__in_ecount_z(_MaxCount) const wchar_t * _Src, __in size_t _MaxCount);
#if __STDC_WANT_SECURE_LIB__ && !defined (__midl)
static __inline __checkReturn size_t __CRTDECL wcsnlen_s(__in_ecount_z(_MaxCount) const wchar_t * _Src, __in size_t _MaxCount)
{
    return (_Src == NULL) ? 0 : wcsnlen(_Src, _MaxCount);
}
#endif
#if __STDC_WANT_SECURE_LIB__
_CRTIMP_ALTERNATIVE __checkReturn_wat errno_t __cdecl wcsncat_s(__inout_ecount_z(_DstSize) wchar_t * _Dst, __in rsize_t _DstSize, __in_z const wchar_t * _Src, __in rsize_t _MaxCount);
#endif
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, wcsncat_s, __deref_inout_z wchar_t, _Dest, __in_z const wchar_t *, _Source, __in size_t, _Count)
#if __STDC_WANT_SECURE_LIB__
_CRTIMP_ALTERNATIVE __checkReturn_wat errno_t __cdecl wcsncpy_s(__out_ecount_z(_DstSize) wchar_t * _Dst, __in rsize_t _DstSize, __in_z const wchar_t * _Src, __in rsize_t _MaxCount);
#endif
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, wcsncpy_s, wchar_t, _Dest, __in_z const wchar_t *, _Source, __in size_t, _Count)
#if __STDC_WANT_SECURE_LIB__
_CRTIMP_ALTERNATIVE __checkReturn wchar_t * __cdecl wcstok_s(__inout_z_opt wchar_t * _Str, __in_z const wchar_t * _Delim, __deref_inout_z_opt wchar_t ** _Context);
#endif

_CRTIMP_ALTERNATIVE __checkReturn_wat errno_t __cdecl _wcsnset_s(__inout_ecount_z(_DstSizeInWords) wchar_t * _Dst, __in size_t _DstSizeInWords, wchar_t _Val, __in size_t _MaxCount);
_CRTIMP_ALTERNATIVE __checkReturn_wat errno_t __cdecl _wcsset_s(__inout_ecount_z(_SizeInWords) wchar_t * _Str, __in size_t _SizeInWords, wchar_t _Val);

_CRTIMP __checkReturn_wat errno_t __cdecl _wcslwr_s(__inout_ecount_z(_SizeInWords) wchar_t * _Str, __in size_t _SizeInWords);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(errno_t, _wcslwr_s, __deref_inout_z wchar_t, _String)
_CRTIMP __checkReturn_wat errno_t __cdecl _wcsupr_s(__inout_ecount_z(_Size) wchar_t * _Str, __in size_t _Size);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(errno_t, _wcsupr_s, __deref_inout_z wchar_t, _String)

#ifdef  __cplusplus
}
#endif

#endif  /* _INC_STRING */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\strmif.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0543 */
/* Compiler settings for strmif.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __strmif_h__
#define __strmif_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IPin_FWD_DEFINED__
#define __IPin_FWD_DEFINED__
typedef interface IPin IPin;
#endif 	/* __IPin_FWD_DEFINED__ */


#ifndef __IEnumPins_FWD_DEFINED__
#define __IEnumPins_FWD_DEFINED__
typedef interface IEnumPins IEnumPins;
#endif 	/* __IEnumPins_FWD_DEFINED__ */


#ifndef __IEnumMediaTypes_FWD_DEFINED__
#define __IEnumMediaTypes_FWD_DEFINED__
typedef interface IEnumMediaTypes IEnumMediaTypes;
#endif 	/* __IEnumMediaTypes_FWD_DEFINED__ */


#ifndef __IFilterGraph_FWD_DEFINED__
#define __IFilterGraph_FWD_DEFINED__
typedef interface IFilterGraph IFilterGraph;
#endif 	/* __IFilterGraph_FWD_DEFINED__ */


#ifndef __IEnumFilters_FWD_DEFINED__
#define __IEnumFilters_FWD_DEFINED__
typedef interface IEnumFilters IEnumFilters;
#endif 	/* __IEnumFilters_FWD_DEFINED__ */


#ifndef __IEnumFilterInterfaces_FWD_DEFINED__
#define __IEnumFilterInterfaces_FWD_DEFINED__
typedef interface IEnumFilterInterfaces IEnumFilterInterfaces;
#endif 	/* __IEnumFilterInterfaces_FWD_DEFINED__ */


#ifndef __IMediaFilter_FWD_DEFINED__
#define __IMediaFilter_FWD_DEFINED__
typedef interface IMediaFilter IMediaFilter;
#endif 	/* __IMediaFilter_FWD_DEFINED__ */


#ifndef __IBaseFilter_FWD_DEFINED__
#define __IBaseFilter_FWD_DEFINED__
typedef interface IBaseFilter IBaseFilter;
#endif 	/* __IBaseFilter_FWD_DEFINED__ */


#ifndef __IReferenceClock_FWD_DEFINED__
#define __IReferenceClock_FWD_DEFINED__
typedef interface IReferenceClock IReferenceClock;
#endif 	/* __IReferenceClock_FWD_DEFINED__ */


#ifndef __IReferenceClock2_FWD_DEFINED__
#define __IReferenceClock2_FWD_DEFINED__
typedef interface IReferenceClock2 IReferenceClock2;
#endif 	/* __IReferenceClock2_FWD_DEFINED__ */


#ifndef __IMediaSample_FWD_DEFINED__
#define __IMediaSample_FWD_DEFINED__
typedef interface IMediaSample IMediaSample;
#endif 	/* __IMediaSample_FWD_DEFINED__ */


#ifndef __IMediaSample2_FWD_DEFINED__
#define __IMediaSample2_FWD_DEFINED__
typedef interface IMediaSample2 IMediaSample2;
#endif 	/* __IMediaSample2_FWD_DEFINED__ */


#ifndef __IMemAllocator_FWD_DEFINED__
#define __IMemAllocator_FWD_DEFINED__
typedef interface IMemAllocator IMemAllocator;
#endif 	/* __IMemAllocator_FWD_DEFINED__ */


#ifndef __IMemAllocator2_FWD_DEFINED__
#define __IMemAllocator2_FWD_DEFINED__
typedef interface IMemAllocator2 IMemAllocator2;
#endif 	/* __IMemAllocator2_FWD_DEFINED__ */


#ifndef __IMemInputPin_FWD_DEFINED__
#define __IMemInputPin_FWD_DEFINED__
typedef interface IMemInputPin IMemInputPin;
#endif 	/* __IMemInputPin_FWD_DEFINED__ */


#ifndef __IAMovieSetup_FWD_DEFINED__
#define __IAMovieSetup_FWD_DEFINED__
typedef interface IAMovieSetup IAMovieSetup;
#endif 	/* __IAMovieSetup_FWD_DEFINED__ */


#ifndef __IMediaSeeking_FWD_DEFINED__
#define __IMediaSeeking_FWD_DEFINED__
typedef interface IMediaSeeking IMediaSeeking;
#endif 	/* __IMediaSeeking_FWD_DEFINED__ */


#ifndef __IAudioRenderer_FWD_DEFINED__
#define __IAudioRenderer_FWD_DEFINED__
typedef interface IAudioRenderer IAudioRenderer;
#endif 	/* __IAudioRenderer_FWD_DEFINED__ */


#ifndef __IAudioRendererWaveOut_FWD_DEFINED__
#define __IAudioRendererWaveOut_FWD_DEFINED__
typedef interface IAudioRendererWaveOut IAudioRendererWaveOut;
#endif 	/* __IAudioRendererWaveOut_FWD_DEFINED__ */


#ifndef __IFilterGraphCache_FWD_DEFINED__
#define __IFilterGraphCache_FWD_DEFINED__
typedef interface IFilterGraphCache IFilterGraphCache;
#endif 	/* __IFilterGraphCache_FWD_DEFINED__ */


#ifndef __IEnumRegFilters_FWD_DEFINED__
#define __IEnumRegFilters_FWD_DEFINED__
typedef interface IEnumRegFilters IEnumRegFilters;
#endif 	/* __IEnumRegFilters_FWD_DEFINED__ */


#ifndef __IFilterMapper_FWD_DEFINED__
#define __IFilterMapper_FWD_DEFINED__
typedef interface IFilterMapper IFilterMapper;
#endif 	/* __IFilterMapper_FWD_DEFINED__ */


#ifndef __IQualityControl_FWD_DEFINED__
#define __IQualityControl_FWD_DEFINED__
typedef interface IQualityControl IQualityControl;
#endif 	/* __IQualityControl_FWD_DEFINED__ */


#ifndef __IOverlayNotify_FWD_DEFINED__
#define __IOverlayNotify_FWD_DEFINED__
typedef interface IOverlayNotify IOverlayNotify;
#endif 	/* __IOverlayNotify_FWD_DEFINED__ */


#ifndef __IOverlay_FWD_DEFINED__
#define __IOverlay_FWD_DEFINED__
typedef interface IOverlay IOverlay;
#endif 	/* __IOverlay_FWD_DEFINED__ */


#ifndef __IMediaEventSink_FWD_DEFINED__
#define __IMediaEventSink_FWD_DEFINED__
typedef interface IMediaEventSink IMediaEventSink;
#endif 	/* __IMediaEventSink_FWD_DEFINED__ */


#ifndef __IFileSourceFilter_FWD_DEFINED__
#define __IFileSourceFilter_FWD_DEFINED__
typedef interface IFileSourceFilter IFileSourceFilter;
#endif 	/* __IFileSourceFilter_FWD_DEFINED__ */


#ifndef __IFileSinkFilter_FWD_DEFINED__
#define __IFileSinkFilter_FWD_DEFINED__
typedef interface IFileSinkFilter IFileSinkFilter;
#endif 	/* __IFileSinkFilter_FWD_DEFINED__ */


#ifndef __IFileSinkFilter2_FWD_DEFINED__
#define __IFileSinkFilter2_FWD_DEFINED__
typedef interface IFileSinkFilter2 IFileSinkFilter2;
#endif 	/* __IFileSinkFilter2_FWD_DEFINED__ */


#ifndef __IFileAsyncIO_FWD_DEFINED__
#define __IFileAsyncIO_FWD_DEFINED__
typedef interface IFileAsyncIO IFileAsyncIO;
#endif 	/* __IFileAsyncIO_FWD_DEFINED__ */


#ifndef __IGraphBuilder_FWD_DEFINED__
#define __IGraphBuilder_FWD_DEFINED__
typedef interface IGraphBuilder IGraphBuilder;
#endif 	/* __IGraphBuilder_FWD_DEFINED__ */


#ifndef __IGraphBuilder2_FWD_DEFINED__
#define __IGraphBuilder2_FWD_DEFINED__
typedef interface IGraphBuilder2 IGraphBuilder2;
#endif 	/* __IGraphBuilder2_FWD_DEFINED__ */


#ifndef __IFilterGraphHelper_FWD_DEFINED__
#define __IFilterGraphHelper_FWD_DEFINED__
typedef interface IFilterGraphHelper IFilterGraphHelper;
#endif 	/* __IFilterGraphHelper_FWD_DEFINED__ */


#ifndef __IAudioControl_FWD_DEFINED__
#define __IAudioControl_FWD_DEFINED__
typedef interface IAudioControl IAudioControl;
#endif 	/* __IAudioControl_FWD_DEFINED__ */


#ifndef __ICaptureGraphBuilder_FWD_DEFINED__
#define __ICaptureGraphBuilder_FWD_DEFINED__
typedef interface ICaptureGraphBuilder ICaptureGraphBuilder;
#endif 	/* __ICaptureGraphBuilder_FWD_DEFINED__ */


#ifndef __IAMCopyCaptureFileProgress_FWD_DEFINED__
#define __IAMCopyCaptureFileProgress_FWD_DEFINED__
typedef interface IAMCopyCaptureFileProgress IAMCopyCaptureFileProgress;
#endif 	/* __IAMCopyCaptureFileProgress_FWD_DEFINED__ */


#ifndef __ICaptureGraphBuilder2_FWD_DEFINED__
#define __ICaptureGraphBuilder2_FWD_DEFINED__
typedef interface ICaptureGraphBuilder2 ICaptureGraphBuilder2;
#endif 	/* __ICaptureGraphBuilder2_FWD_DEFINED__ */


#ifndef __IFilterGraph2_FWD_DEFINED__
#define __IFilterGraph2_FWD_DEFINED__
typedef interface IFilterGraph2 IFilterGraph2;
#endif 	/* __IFilterGraph2_FWD_DEFINED__ */


#ifndef __IStreamBuilder_FWD_DEFINED__
#define __IStreamBuilder_FWD_DEFINED__
typedef interface IStreamBuilder IStreamBuilder;
#endif 	/* __IStreamBuilder_FWD_DEFINED__ */


#ifndef __IAsyncReader_FWD_DEFINED__
#define __IAsyncReader_FWD_DEFINED__
typedef interface IAsyncReader IAsyncReader;
#endif 	/* __IAsyncReader_FWD_DEFINED__ */


#ifndef __IGraphVersion_FWD_DEFINED__
#define __IGraphVersion_FWD_DEFINED__
typedef interface IGraphVersion IGraphVersion;
#endif 	/* __IGraphVersion_FWD_DEFINED__ */


#ifndef __IResourceConsumer_FWD_DEFINED__
#define __IResourceConsumer_FWD_DEFINED__
typedef interface IResourceConsumer IResourceConsumer;
#endif 	/* __IResourceConsumer_FWD_DEFINED__ */


#ifndef __IResourceManager_FWD_DEFINED__
#define __IResourceManager_FWD_DEFINED__
typedef interface IResourceManager IResourceManager;
#endif 	/* __IResourceManager_FWD_DEFINED__ */


#ifndef __IDistributorNotify_FWD_DEFINED__
#define __IDistributorNotify_FWD_DEFINED__
typedef interface IDistributorNotify IDistributorNotify;
#endif 	/* __IDistributorNotify_FWD_DEFINED__ */


#ifndef __IAMStreamControl_FWD_DEFINED__
#define __IAMStreamControl_FWD_DEFINED__
typedef interface IAMStreamControl IAMStreamControl;
#endif 	/* __IAMStreamControl_FWD_DEFINED__ */


#ifndef __ISeekingPassThru_FWD_DEFINED__
#define __ISeekingPassThru_FWD_DEFINED__
typedef interface ISeekingPassThru ISeekingPassThru;
#endif 	/* __ISeekingPassThru_FWD_DEFINED__ */


#ifndef __IAMStreamConfig_FWD_DEFINED__
#define __IAMStreamConfig_FWD_DEFINED__
typedef interface IAMStreamConfig IAMStreamConfig;
#endif 	/* __IAMStreamConfig_FWD_DEFINED__ */


#ifndef __IConfigInterleaving_FWD_DEFINED__
#define __IConfigInterleaving_FWD_DEFINED__
typedef interface IConfigInterleaving IConfigInterleaving;
#endif 	/* __IConfigInterleaving_FWD_DEFINED__ */


#ifndef __IConfigAviMux_FWD_DEFINED__
#define __IConfigAviMux_FWD_DEFINED__
typedef interface IConfigAviMux IConfigAviMux;
#endif 	/* __IConfigAviMux_FWD_DEFINED__ */


#ifndef __IAMVideoCompression_FWD_DEFINED__
#define __IAMVideoCompression_FWD_DEFINED__
typedef interface IAMVideoCompression IAMVideoCompression;
#endif 	/* __IAMVideoCompression_FWD_DEFINED__ */


#ifndef __IAMDroppedFrames_FWD_DEFINED__
#define __IAMDroppedFrames_FWD_DEFINED__
typedef interface IAMDroppedFrames IAMDroppedFrames;
#endif 	/* __IAMDroppedFrames_FWD_DEFINED__ */


#ifndef __IAMBufferNegotiation_FWD_DEFINED__
#define __IAMBufferNegotiation_FWD_DEFINED__
typedef interface IAMBufferNegotiation IAMBufferNegotiation;
#endif 	/* __IAMBufferNegotiation_FWD_DEFINED__ */


#ifndef __IAMVideoProcAmp_FWD_DEFINED__
#define __IAMVideoProcAmp_FWD_DEFINED__
typedef interface IAMVideoProcAmp IAMVideoProcAmp;
#endif 	/* __IAMVideoProcAmp_FWD_DEFINED__ */


#ifndef __IAMCameraControl_FWD_DEFINED__
#define __IAMCameraControl_FWD_DEFINED__
typedef interface IAMCameraControl IAMCameraControl;
#endif 	/* __IAMCameraControl_FWD_DEFINED__ */


#ifndef __IAMVideoControl_FWD_DEFINED__
#define __IAMVideoControl_FWD_DEFINED__
typedef interface IAMVideoControl IAMVideoControl;
#endif 	/* __IAMVideoControl_FWD_DEFINED__ */


#ifndef __IAMCrossbar_FWD_DEFINED__
#define __IAMCrossbar_FWD_DEFINED__
typedef interface IAMCrossbar IAMCrossbar;
#endif 	/* __IAMCrossbar_FWD_DEFINED__ */


#ifndef __IAMTuner_FWD_DEFINED__
#define __IAMTuner_FWD_DEFINED__
typedef interface IAMTuner IAMTuner;
#endif 	/* __IAMTuner_FWD_DEFINED__ */


#ifndef __IAMTunerNotification_FWD_DEFINED__
#define __IAMTunerNotification_FWD_DEFINED__
typedef interface IAMTunerNotification IAMTunerNotification;
#endif 	/* __IAMTunerNotification_FWD_DEFINED__ */


#ifndef __IAMTVTuner_FWD_DEFINED__
#define __IAMTVTuner_FWD_DEFINED__
typedef interface IAMTVTuner IAMTVTuner;
#endif 	/* __IAMTVTuner_FWD_DEFINED__ */


#ifndef __IKsPropertySet_FWD_DEFINED__
#define __IKsPropertySet_FWD_DEFINED__
typedef interface IKsPropertySet IKsPropertySet;
#endif 	/* __IKsPropertySet_FWD_DEFINED__ */


#ifndef __IMediaPropertyBag_FWD_DEFINED__
#define __IMediaPropertyBag_FWD_DEFINED__
typedef interface IMediaPropertyBag IMediaPropertyBag;
#endif 	/* __IMediaPropertyBag_FWD_DEFINED__ */


#ifndef __IPersistMediaPropertyBag_FWD_DEFINED__
#define __IPersistMediaPropertyBag_FWD_DEFINED__
typedef interface IPersistMediaPropertyBag IPersistMediaPropertyBag;
#endif 	/* __IPersistMediaPropertyBag_FWD_DEFINED__ */


#ifndef __IAMPhysicalPinInfo_FWD_DEFINED__
#define __IAMPhysicalPinInfo_FWD_DEFINED__
typedef interface IAMPhysicalPinInfo IAMPhysicalPinInfo;
#endif 	/* __IAMPhysicalPinInfo_FWD_DEFINED__ */


#ifndef __IAMExtDevice_FWD_DEFINED__
#define __IAMExtDevice_FWD_DEFINED__
typedef interface IAMExtDevice IAMExtDevice;
#endif 	/* __IAMExtDevice_FWD_DEFINED__ */


#ifndef __IAMExtTransport_FWD_DEFINED__
#define __IAMExtTransport_FWD_DEFINED__
typedef interface IAMExtTransport IAMExtTransport;
#endif 	/* __IAMExtTransport_FWD_DEFINED__ */


#ifndef __IAMTimecodeReader_FWD_DEFINED__
#define __IAMTimecodeReader_FWD_DEFINED__
typedef interface IAMTimecodeReader IAMTimecodeReader;
#endif 	/* __IAMTimecodeReader_FWD_DEFINED__ */


#ifndef __IAMTimecodeGenerator_FWD_DEFINED__
#define __IAMTimecodeGenerator_FWD_DEFINED__
typedef interface IAMTimecodeGenerator IAMTimecodeGenerator;
#endif 	/* __IAMTimecodeGenerator_FWD_DEFINED__ */


#ifndef __IAMTimecodeDisplay_FWD_DEFINED__
#define __IAMTimecodeDisplay_FWD_DEFINED__
typedef interface IAMTimecodeDisplay IAMTimecodeDisplay;
#endif 	/* __IAMTimecodeDisplay_FWD_DEFINED__ */


#ifndef __IAMDevMemoryAllocator_FWD_DEFINED__
#define __IAMDevMemoryAllocator_FWD_DEFINED__
typedef interface IAMDevMemoryAllocator IAMDevMemoryAllocator;
#endif 	/* __IAMDevMemoryAllocator_FWD_DEFINED__ */


#ifndef __IAMDevMemoryControl_FWD_DEFINED__
#define __IAMDevMemoryControl_FWD_DEFINED__
typedef interface IAMDevMemoryControl IAMDevMemoryControl;
#endif 	/* __IAMDevMemoryControl_FWD_DEFINED__ */


#ifndef __IAMStreamSelect_FWD_DEFINED__
#define __IAMStreamSelect_FWD_DEFINED__
typedef interface IAMStreamSelect IAMStreamSelect;
#endif 	/* __IAMStreamSelect_FWD_DEFINED__ */


#ifndef __IAMResourceControl_FWD_DEFINED__
#define __IAMResourceControl_FWD_DEFINED__
typedef interface IAMResourceControl IAMResourceControl;
#endif 	/* __IAMResourceControl_FWD_DEFINED__ */


#ifndef __IAMClockAdjust_FWD_DEFINED__
#define __IAMClockAdjust_FWD_DEFINED__
typedef interface IAMClockAdjust IAMClockAdjust;
#endif 	/* __IAMClockAdjust_FWD_DEFINED__ */


#ifndef __IAMFilterMiscFlags_FWD_DEFINED__
#define __IAMFilterMiscFlags_FWD_DEFINED__
typedef interface IAMFilterMiscFlags IAMFilterMiscFlags;
#endif 	/* __IAMFilterMiscFlags_FWD_DEFINED__ */


#ifndef __IDecimateVideoImage_FWD_DEFINED__
#define __IDecimateVideoImage_FWD_DEFINED__
typedef interface IDecimateVideoImage IDecimateVideoImage;
#endif 	/* __IDecimateVideoImage_FWD_DEFINED__ */


#ifndef __IAMVideoDecimationProperties_FWD_DEFINED__
#define __IAMVideoDecimationProperties_FWD_DEFINED__
typedef interface IAMVideoDecimationProperties IAMVideoDecimationProperties;
#endif 	/* __IAMVideoDecimationProperties_FWD_DEFINED__ */


#ifndef __IAMAudioRendererStats_FWD_DEFINED__
#define __IAMAudioRendererStats_FWD_DEFINED__
typedef interface IAMAudioRendererStats IAMAudioRendererStats;
#endif 	/* __IAMAudioRendererStats_FWD_DEFINED__ */


#ifndef __IAMVideoRendererNotificationCallback_FWD_DEFINED__
#define __IAMVideoRendererNotificationCallback_FWD_DEFINED__
typedef interface IAMVideoRendererNotificationCallback IAMVideoRendererNotificationCallback;
#endif 	/* __IAMVideoRendererNotificationCallback_FWD_DEFINED__ */


#ifndef __IAMVideoRendererNotification_FWD_DEFINED__
#define __IAMVideoRendererNotification_FWD_DEFINED__
typedef interface IAMVideoRendererNotification IAMVideoRendererNotification;
#endif 	/* __IAMVideoRendererNotification_FWD_DEFINED__ */


#ifndef __IAMVideoRendererMode_FWD_DEFINED__
#define __IAMVideoRendererMode_FWD_DEFINED__
typedef interface IAMVideoRendererMode IAMVideoRendererMode;
#endif 	/* __IAMVideoRendererMode_FWD_DEFINED__ */


#ifndef __IImageSinkFilter_FWD_DEFINED__
#define __IImageSinkFilter_FWD_DEFINED__
typedef interface IImageSinkFilter IImageSinkFilter;
#endif 	/* __IImageSinkFilter_FWD_DEFINED__ */


#ifndef __ISmartTee_FWD_DEFINED__
#define __ISmartTee_FWD_DEFINED__
typedef interface ISmartTee ISmartTee;
#endif 	/* __ISmartTee_FWD_DEFINED__ */


#ifndef __IBuffering_FWD_DEFINED__
#define __IBuffering_FWD_DEFINED__
typedef interface IBuffering IBuffering;
#endif 	/* __IBuffering_FWD_DEFINED__ */


#ifndef __IAMCertifiedOutputProtection_FWD_DEFINED__
#define __IAMCertifiedOutputProtection_FWD_DEFINED__
typedef interface IAMCertifiedOutputProtection IAMCertifiedOutputProtection;
#endif 	/* __IAMCertifiedOutputProtection_FWD_DEFINED__ */


#ifndef __IVideoFrameStep_FWD_DEFINED__
#define __IVideoFrameStep_FWD_DEFINED__
typedef interface IVideoFrameStep IVideoFrameStep;
#endif 	/* __IVideoFrameStep_FWD_DEFINED__ */


#ifndef __IAMVideoTransform_FWD_DEFINED__
#define __IAMVideoTransform_FWD_DEFINED__
typedef interface IAMVideoTransform IAMVideoTransform;
#endif 	/* __IAMVideoTransform_FWD_DEFINED__ */


#ifndef __IAMVideoTransformComponent_FWD_DEFINED__
#define __IAMVideoTransformComponent_FWD_DEFINED__
typedef interface IAMVideoTransformComponent IAMVideoTransformComponent;
#endif 	/* __IAMVideoTransformComponent_FWD_DEFINED__ */


#ifndef __ICaptureMetadata_FWD_DEFINED__
#define __ICaptureMetadata_FWD_DEFINED__
typedef interface ICaptureMetadata ICaptureMetadata;
#endif 	/* __ICaptureMetadata_FWD_DEFINED__ */


#ifndef __IImageMetadata_FWD_DEFINED__
#define __IImageMetadata_FWD_DEFINED__
typedef interface IImageMetadata IImageMetadata;
#endif 	/* __IImageMetadata_FWD_DEFINED__ */


#ifndef __IDvdControl_FWD_DEFINED__
#define __IDvdControl_FWD_DEFINED__
typedef interface IDvdControl IDvdControl;
#endif 	/* __IDvdControl_FWD_DEFINED__ */


#ifndef __IDvdInfo_FWD_DEFINED__
#define __IDvdInfo_FWD_DEFINED__
typedef interface IDvdInfo IDvdInfo;
#endif 	/* __IDvdInfo_FWD_DEFINED__ */


#ifndef __IDvdCmd_FWD_DEFINED__
#define __IDvdCmd_FWD_DEFINED__
typedef interface IDvdCmd IDvdCmd;
#endif 	/* __IDvdCmd_FWD_DEFINED__ */


#ifndef __IDvdState_FWD_DEFINED__
#define __IDvdState_FWD_DEFINED__
typedef interface IDvdState IDvdState;
#endif 	/* __IDvdState_FWD_DEFINED__ */


#ifndef __IDvdControl2_FWD_DEFINED__
#define __IDvdControl2_FWD_DEFINED__
typedef interface IDvdControl2 IDvdControl2;
#endif 	/* __IDvdControl2_FWD_DEFINED__ */


#ifndef __IDvdInfo2_FWD_DEFINED__
#define __IDvdInfo2_FWD_DEFINED__
typedef interface IDvdInfo2 IDvdInfo2;
#endif 	/* __IDvdInfo2_FWD_DEFINED__ */


#ifndef __IDvdGraphBuilder_FWD_DEFINED__
#define __IDvdGraphBuilder_FWD_DEFINED__
typedef interface IDvdGraphBuilder IDvdGraphBuilder;
#endif 	/* __IDvdGraphBuilder_FWD_DEFINED__ */


#ifndef __IDDrawExclModeVideo_FWD_DEFINED__
#define __IDDrawExclModeVideo_FWD_DEFINED__
typedef interface IDDrawExclModeVideo IDDrawExclModeVideo;
#endif 	/* __IDDrawExclModeVideo_FWD_DEFINED__ */


#ifndef __IDDrawExclModeVideoCallback_FWD_DEFINED__
#define __IDDrawExclModeVideoCallback_FWD_DEFINED__
typedef interface IDDrawExclModeVideoCallback IDDrawExclModeVideoCallback;
#endif 	/* __IDDrawExclModeVideoCallback_FWD_DEFINED__ */


#ifndef __IVMRImagePresenter_FWD_DEFINED__
#define __IVMRImagePresenter_FWD_DEFINED__
typedef interface IVMRImagePresenter IVMRImagePresenter;
#endif 	/* __IVMRImagePresenter_FWD_DEFINED__ */


#ifndef __IVMRSurfaceAllocator_FWD_DEFINED__
#define __IVMRSurfaceAllocator_FWD_DEFINED__
typedef interface IVMRSurfaceAllocator IVMRSurfaceAllocator;
#endif 	/* __IVMRSurfaceAllocator_FWD_DEFINED__ */


#ifndef __IVMRSurfaceAllocatorNotify_FWD_DEFINED__
#define __IVMRSurfaceAllocatorNotify_FWD_DEFINED__
typedef interface IVMRSurfaceAllocatorNotify IVMRSurfaceAllocatorNotify;
#endif 	/* __IVMRSurfaceAllocatorNotify_FWD_DEFINED__ */


#ifndef __IVMRWindowlessControl_FWD_DEFINED__
#define __IVMRWindowlessControl_FWD_DEFINED__
typedef interface IVMRWindowlessControl IVMRWindowlessControl;
#endif 	/* __IVMRWindowlessControl_FWD_DEFINED__ */


#ifndef __IVMRMixerControl_FWD_DEFINED__
#define __IVMRMixerControl_FWD_DEFINED__
typedef interface IVMRMixerControl IVMRMixerControl;
#endif 	/* __IVMRMixerControl_FWD_DEFINED__ */


#ifndef __IVMRMixerControl2_FWD_DEFINED__
#define __IVMRMixerControl2_FWD_DEFINED__
typedef interface IVMRMixerControl2 IVMRMixerControl2;
#endif 	/* __IVMRMixerControl2_FWD_DEFINED__ */


#ifndef __IVMRMonitorConfig_FWD_DEFINED__
#define __IVMRMonitorConfig_FWD_DEFINED__
typedef interface IVMRMonitorConfig IVMRMonitorConfig;
#endif 	/* __IVMRMonitorConfig_FWD_DEFINED__ */


#ifndef __IVMRFilterConfig_FWD_DEFINED__
#define __IVMRFilterConfig_FWD_DEFINED__
typedef interface IVMRFilterConfig IVMRFilterConfig;
#endif 	/* __IVMRFilterConfig_FWD_DEFINED__ */


#ifndef __IVMRAspectRatioControl_FWD_DEFINED__
#define __IVMRAspectRatioControl_FWD_DEFINED__
typedef interface IVMRAspectRatioControl IVMRAspectRatioControl;
#endif 	/* __IVMRAspectRatioControl_FWD_DEFINED__ */


#ifndef __IVMRMixerBitmap_FWD_DEFINED__
#define __IVMRMixerBitmap_FWD_DEFINED__
typedef interface IVMRMixerBitmap IVMRMixerBitmap;
#endif 	/* __IVMRMixerBitmap_FWD_DEFINED__ */


#ifndef __IVMRImageCompositor_FWD_DEFINED__
#define __IVMRImageCompositor_FWD_DEFINED__
typedef interface IVMRImageCompositor IVMRImageCompositor;
#endif 	/* __IVMRImageCompositor_FWD_DEFINED__ */


#ifndef __IVMRImageCompositor2_FWD_DEFINED__
#define __IVMRImageCompositor2_FWD_DEFINED__
typedef interface IVMRImageCompositor2 IVMRImageCompositor2;
#endif 	/* __IVMRImageCompositor2_FWD_DEFINED__ */


#ifndef __IVMRVideoStreamControl_FWD_DEFINED__
#define __IVMRVideoStreamControl_FWD_DEFINED__
typedef interface IVMRVideoStreamControl IVMRVideoStreamControl;
#endif 	/* __IVMRVideoStreamControl_FWD_DEFINED__ */


#ifndef __IVMRSurface_FWD_DEFINED__
#define __IVMRSurface_FWD_DEFINED__
typedef interface IVMRSurface IVMRSurface;
#endif 	/* __IVMRSurface_FWD_DEFINED__ */


#ifndef __IVMRImagePresenterConfig_FWD_DEFINED__
#define __IVMRImagePresenterConfig_FWD_DEFINED__
typedef interface IVMRImagePresenterConfig IVMRImagePresenterConfig;
#endif 	/* __IVMRImagePresenterConfig_FWD_DEFINED__ */


#ifndef __IVMRImagePresenterExclModeConfig_FWD_DEFINED__
#define __IVMRImagePresenterExclModeConfig_FWD_DEFINED__
typedef interface IVMRImagePresenterExclModeConfig IVMRImagePresenterExclModeConfig;
#endif 	/* __IVMRImagePresenterExclModeConfig_FWD_DEFINED__ */


#ifndef __IVPManager_FWD_DEFINED__
#define __IVPManager_FWD_DEFINED__
typedef interface IVPManager IVPManager;
#endif 	/* __IVPManager_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "objidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_strmif_0000_0000 */
/* [local] */ 

#ifndef NO_FILTERMAPPER2
#define NO_FILTERMAPPER2
#endif
#ifndef NO_PROPERTYPAGES
#define NO_PROPERTYPAGES
#endif
typedef DWORD DWORD_PTR;

typedef LONG LONG_PTR;

#define CHARS_IN_GUID     39
typedef struct _AMMediaType
    {
    GUID majortype;
    GUID subtype;
    BOOL bFixedSizeSamples;
    BOOL bTemporalCompression;
    ULONG lSampleSize;
    GUID formattype;
    IUnknown *pUnk;
    ULONG cbFormat;
    BYTE *pbFormat;
    } 	AM_MEDIA_TYPE;

typedef 
enum _PinDirection
    {	PINDIR_INPUT	= 0,
	PINDIR_OUTPUT	= ( PINDIR_INPUT + 1 ) 
    } 	PIN_DIRECTION;

#define MAX_PIN_NAME     128
#define MAX_FILTER_NAME  128
typedef LONGLONG REFERENCE_TIME;

typedef double REFTIME;

typedef DWORD_PTR HSEMAPHORE;

typedef DWORD_PTR HEVENT;

typedef struct _AllocatorProperties
    {
    long cBuffers;
    long cbBuffer;
    long cbAlign;
    long cbPrefix;
    } 	ALLOCATOR_PROPERTIES;















extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0000_v0_0_s_ifspec;

#ifndef __IPin_INTERFACE_DEFINED__
#define __IPin_INTERFACE_DEFINED__

/* interface IPin */
/* [unique][uuid][object] */ 

typedef struct _PinInfo
    {
    IBaseFilter *pFilter;
    PIN_DIRECTION dir;
    WCHAR achName[ 128 ];
    } 	PIN_INFO;


EXTERN_C const IID IID_IPin;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a86891-0ad4-11ce-b03a-0020af0ba770")
    IPin : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ IPin *pReceivePin,
            /* [in] */ const AM_MEDIA_TYPE *pmt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReceiveConnection( 
            /* [in] */ IPin *pConnector,
            /* [in] */ const AM_MEDIA_TYPE *pmt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConnectedTo( 
            /* [out] */ IPin **pPin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConnectionMediaType( 
            /* [out] */ AM_MEDIA_TYPE *pmt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryPinInfo( 
            /* [out] */ PIN_INFO *pInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryDirection( 
            /* [out] */ PIN_DIRECTION *pPinDir) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryId( 
            /* [out] */ LPWSTR *Id) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryAccept( 
            /* [in] */ const AM_MEDIA_TYPE *pmt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumMediaTypes( 
            /* [out] */ IEnumMediaTypes **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryInternalConnections( 
            /* [out] */ IPin **apPin,
            /* [out][in] */ ULONG *nPin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndOfStream( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginFlush( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndFlush( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NewSegment( 
            /* [in] */ REFERENCE_TIME tStart,
            /* [in] */ REFERENCE_TIME tStop,
            /* [in] */ double dRate) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPinVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPin * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPin * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPin * This);
        
        HRESULT ( STDMETHODCALLTYPE *Connect )( 
            IPin * This,
            /* [in] */ IPin *pReceivePin,
            /* [in] */ const AM_MEDIA_TYPE *pmt);
        
        HRESULT ( STDMETHODCALLTYPE *ReceiveConnection )( 
            IPin * This,
            /* [in] */ IPin *pConnector,
            /* [in] */ const AM_MEDIA_TYPE *pmt);
        
        HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            IPin * This);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectedTo )( 
            IPin * This,
            /* [out] */ IPin **pPin);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectionMediaType )( 
            IPin * This,
            /* [out] */ AM_MEDIA_TYPE *pmt);
        
        HRESULT ( STDMETHODCALLTYPE *QueryPinInfo )( 
            IPin * This,
            /* [out] */ PIN_INFO *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE *QueryDirection )( 
            IPin * This,
            /* [out] */ PIN_DIRECTION *pPinDir);
        
        HRESULT ( STDMETHODCALLTYPE *QueryId )( 
            IPin * This,
            /* [out] */ LPWSTR *Id);
        
        HRESULT ( STDMETHODCALLTYPE *QueryAccept )( 
            IPin * This,
            /* [in] */ const AM_MEDIA_TYPE *pmt);
        
        HRESULT ( STDMETHODCALLTYPE *EnumMediaTypes )( 
            IPin * This,
            /* [out] */ IEnumMediaTypes **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *QueryInternalConnections )( 
            IPin * This,
            /* [out] */ IPin **apPin,
            /* [out][in] */ ULONG *nPin);
        
        HRESULT ( STDMETHODCALLTYPE *EndOfStream )( 
            IPin * This);
        
        HRESULT ( STDMETHODCALLTYPE *BeginFlush )( 
            IPin * This);
        
        HRESULT ( STDMETHODCALLTYPE *EndFlush )( 
            IPin * This);
        
        HRESULT ( STDMETHODCALLTYPE *NewSegment )( 
            IPin * This,
            /* [in] */ REFERENCE_TIME tStart,
            /* [in] */ REFERENCE_TIME tStop,
            /* [in] */ double dRate);
        
        END_INTERFACE
    } IPinVtbl;

    interface IPin
    {
        CONST_VTBL struct IPinVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPin_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPin_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPin_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPin_Connect(This,pReceivePin,pmt)	\
    ( (This)->lpVtbl -> Connect(This,pReceivePin,pmt) ) 

#define IPin_ReceiveConnection(This,pConnector,pmt)	\
    ( (This)->lpVtbl -> ReceiveConnection(This,pConnector,pmt) ) 

#define IPin_Disconnect(This)	\
    ( (This)->lpVtbl -> Disconnect(This) ) 

#define IPin_ConnectedTo(This,pPin)	\
    ( (This)->lpVtbl -> ConnectedTo(This,pPin) ) 

#define IPin_ConnectionMediaType(This,pmt)	\
    ( (This)->lpVtbl -> ConnectionMediaType(This,pmt) ) 

#define IPin_QueryPinInfo(This,pInfo)	\
    ( (This)->lpVtbl -> QueryPinInfo(This,pInfo) ) 

#define IPin_QueryDirection(This,pPinDir)	\
    ( (This)->lpVtbl -> QueryDirection(This,pPinDir) ) 

#define IPin_QueryId(This,Id)	\
    ( (This)->lpVtbl -> QueryId(This,Id) ) 

#define IPin_QueryAccept(This,pmt)	\
    ( (This)->lpVtbl -> QueryAccept(This,pmt) ) 

#define IPin_EnumMediaTypes(This,ppEnum)	\
    ( (This)->lpVtbl -> EnumMediaTypes(This,ppEnum) ) 

#define IPin_QueryInternalConnections(This,apPin,nPin)	\
    ( (This)->lpVtbl -> QueryInternalConnections(This,apPin,nPin) ) 

#define IPin_EndOfStream(This)	\
    ( (This)->lpVtbl -> EndOfStream(This) ) 

#define IPin_BeginFlush(This)	\
    ( (This)->lpVtbl -> BeginFlush(This) ) 

#define IPin_EndFlush(This)	\
    ( (This)->lpVtbl -> EndFlush(This) ) 

#define IPin_NewSegment(This,tStart,tStop,dRate)	\
    ( (This)->lpVtbl -> NewSegment(This,tStart,tStop,dRate) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPin_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0001 */
/* [local] */ 

typedef IPin *PPIN;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0001_v0_0_s_ifspec;

#ifndef __IEnumPins_INTERFACE_DEFINED__
#define __IEnumPins_INTERFACE_DEFINED__

/* interface IEnumPins */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumPins;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a86892-0ad4-11ce-b03a-0020af0ba770")
    IEnumPins : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cPins,
            /* [size_is][out] */ IPin **ppPins,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cPins) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumPins **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumPinsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumPins * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumPins * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumPins * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumPins * This,
            /* [in] */ ULONG cPins,
            /* [size_is][out] */ IPin **ppPins,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumPins * This,
            /* [in] */ ULONG cPins);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumPins * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumPins * This,
            /* [out] */ IEnumPins **ppEnum);
        
        END_INTERFACE
    } IEnumPinsVtbl;

    interface IEnumPins
    {
        CONST_VTBL struct IEnumPinsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumPins_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumPins_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumPins_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumPins_Next(This,cPins,ppPins,pcFetched)	\
    ( (This)->lpVtbl -> Next(This,cPins,ppPins,pcFetched) ) 

#define IEnumPins_Skip(This,cPins)	\
    ( (This)->lpVtbl -> Skip(This,cPins) ) 

#define IEnumPins_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumPins_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumPins_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0002 */
/* [local] */ 

typedef IEnumPins *PENUMPINS;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0002_v0_0_s_ifspec;

#ifndef __IEnumMediaTypes_INTERFACE_DEFINED__
#define __IEnumMediaTypes_INTERFACE_DEFINED__

/* interface IEnumMediaTypes */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumMediaTypes;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("89c31040-846b-11ce-97d3-00aa0055595a")
    IEnumMediaTypes : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cMediaTypes,
            /* [size_is][out] */ AM_MEDIA_TYPE **ppMediaTypes,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cMediaTypes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumMediaTypes **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumMediaTypesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumMediaTypes * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumMediaTypes * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumMediaTypes * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumMediaTypes * This,
            /* [in] */ ULONG cMediaTypes,
            /* [size_is][out] */ AM_MEDIA_TYPE **ppMediaTypes,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumMediaTypes * This,
            /* [in] */ ULONG cMediaTypes);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumMediaTypes * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumMediaTypes * This,
            /* [out] */ IEnumMediaTypes **ppEnum);
        
        END_INTERFACE
    } IEnumMediaTypesVtbl;

    interface IEnumMediaTypes
    {
        CONST_VTBL struct IEnumMediaTypesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumMediaTypes_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumMediaTypes_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumMediaTypes_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumMediaTypes_Next(This,cMediaTypes,ppMediaTypes,pcFetched)	\
    ( (This)->lpVtbl -> Next(This,cMediaTypes,ppMediaTypes,pcFetched) ) 

#define IEnumMediaTypes_Skip(This,cMediaTypes)	\
    ( (This)->lpVtbl -> Skip(This,cMediaTypes) ) 

#define IEnumMediaTypes_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumMediaTypes_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumMediaTypes_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0003 */
/* [local] */ 

typedef IEnumMediaTypes *PENUMMEDIATYPES;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0003_v0_0_s_ifspec;

#ifndef __IFilterGraph_INTERFACE_DEFINED__
#define __IFilterGraph_INTERFACE_DEFINED__

/* interface IFilterGraph */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IFilterGraph;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a8689f-0ad4-11ce-b03a-0020af0ba770")
    IFilterGraph : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddFilter( 
            /* [in] */ IBaseFilter *pFilter,
            /* [string][in] */ LPCWSTR pName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveFilter( 
            /* [in] */ IBaseFilter *pFilter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumFilters( 
            /* [out] */ IEnumFilters **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindFilterByName( 
            /* [string][in] */ LPCWSTR pName,
            /* [out] */ IBaseFilter **ppFilter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConnectDirect( 
            /* [in] */ IPin *ppinOut,
            /* [in] */ IPin *ppinIn,
            /* [in] */ const AM_MEDIA_TYPE *pmt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reconnect( 
            /* [in] */ IPin *ppin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Disconnect( 
            /* [in] */ IPin *ppin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultSyncSource( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFilterGraphVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFilterGraph * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFilterGraph * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFilterGraph * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddFilter )( 
            IFilterGraph * This,
            /* [in] */ IBaseFilter *pFilter,
            /* [string][in] */ LPCWSTR pName);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveFilter )( 
            IFilterGraph * This,
            /* [in] */ IBaseFilter *pFilter);
        
        HRESULT ( STDMETHODCALLTYPE *EnumFilters )( 
            IFilterGraph * This,
            /* [out] */ IEnumFilters **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *FindFilterByName )( 
            IFilterGraph * This,
            /* [string][in] */ LPCWSTR pName,
            /* [out] */ IBaseFilter **ppFilter);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectDirect )( 
            IFilterGraph * This,
            /* [in] */ IPin *ppinOut,
            /* [in] */ IPin *ppinIn,
            /* [in] */ const AM_MEDIA_TYPE *pmt);
        
        HRESULT ( STDMETHODCALLTYPE *Reconnect )( 
            IFilterGraph * This,
            /* [in] */ IPin *ppin);
        
        HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            IFilterGraph * This,
            /* [in] */ IPin *ppin);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultSyncSource )( 
            IFilterGraph * This);
        
        END_INTERFACE
    } IFilterGraphVtbl;

    interface IFilterGraph
    {
        CONST_VTBL struct IFilterGraphVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFilterGraph_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFilterGraph_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFilterGraph_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFilterGraph_AddFilter(This,pFilter,pName)	\
    ( (This)->lpVtbl -> AddFilter(This,pFilter,pName) ) 

#define IFilterGraph_RemoveFilter(This,pFilter)	\
    ( (This)->lpVtbl -> RemoveFilter(This,pFilter) ) 

#define IFilterGraph_EnumFilters(This,ppEnum)	\
    ( (This)->lpVtbl -> EnumFilters(This,ppEnum) ) 

#define IFilterGraph_FindFilterByName(This,pName,ppFilter)	\
    ( (This)->lpVtbl -> FindFilterByName(This,pName,ppFilter) ) 

#define IFilterGraph_ConnectDirect(This,ppinOut,ppinIn,pmt)	\
    ( (This)->lpVtbl -> ConnectDirect(This,ppinOut,ppinIn,pmt) ) 

#define IFilterGraph_Reconnect(This,ppin)	\
    ( (This)->lpVtbl -> Reconnect(This,ppin) ) 

#define IFilterGraph_Disconnect(This,ppin)	\
    ( (This)->lpVtbl -> Disconnect(This,ppin) ) 

#define IFilterGraph_SetDefaultSyncSource(This)	\
    ( (This)->lpVtbl -> SetDefaultSyncSource(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFilterGraph_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0004 */
/* [local] */ 

typedef IFilterGraph *PFILTERGRAPH;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0004_v0_0_s_ifspec;

#ifndef __IEnumFilters_INTERFACE_DEFINED__
#define __IEnumFilters_INTERFACE_DEFINED__

/* interface IEnumFilters */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumFilters;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a86893-0ad4-11ce-b03a-0020af0ba770")
    IEnumFilters : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cFilters,
            /* [out] */ IBaseFilter **ppFilter,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cFilters) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumFilters **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumFiltersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumFilters * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumFilters * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumFilters * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumFilters * This,
            /* [in] */ ULONG cFilters,
            /* [out] */ IBaseFilter **ppFilter,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumFilters * This,
            /* [in] */ ULONG cFilters);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumFilters * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumFilters * This,
            /* [out] */ IEnumFilters **ppEnum);
        
        END_INTERFACE
    } IEnumFiltersVtbl;

    interface IEnumFilters
    {
        CONST_VTBL struct IEnumFiltersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumFilters_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumFilters_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumFilters_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumFilters_Next(This,cFilters,ppFilter,pcFetched)	\
    ( (This)->lpVtbl -> Next(This,cFilters,ppFilter,pcFetched) ) 

#define IEnumFilters_Skip(This,cFilters)	\
    ( (This)->lpVtbl -> Skip(This,cFilters) ) 

#define IEnumFilters_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumFilters_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumFilters_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0005 */
/* [local] */ 

typedef IEnumFilters *PENUMFILTERS;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0005_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0005_v0_0_s_ifspec;

#ifndef __IEnumFilterInterfaces_INTERFACE_DEFINED__
#define __IEnumFilterInterfaces_INTERFACE_DEFINED__

/* interface IEnumFilterInterfaces */
/* [unique][helpstring][uuid][local][object][local] */ 


EXTERN_C const IID IID_IEnumFilterInterfaces;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F845653C-2777-4d84-A50D-26D3397D5C75")
    IEnumFilterInterfaces : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [out] */ IUnknown **ppUnknown,
            /* [in] */ UINT32 cchFilterName,
            /* [size_is][string][out][in] */ wchar_t *pwszFilterName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumFilterInterfacesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumFilterInterfaces * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumFilterInterfaces * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumFilterInterfaces * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumFilterInterfaces * This,
            /* [out] */ IUnknown **ppUnknown,
            /* [in] */ UINT32 cchFilterName,
            /* [size_is][string][out][in] */ wchar_t *pwszFilterName);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumFilterInterfaces * This);
        
        END_INTERFACE
    } IEnumFilterInterfacesVtbl;

    interface IEnumFilterInterfaces
    {
        CONST_VTBL struct IEnumFilterInterfacesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumFilterInterfaces_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumFilterInterfaces_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumFilterInterfaces_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumFilterInterfaces_Next(This,ppUnknown,cchFilterName,pwszFilterName)	\
    ( (This)->lpVtbl -> Next(This,ppUnknown,cchFilterName,pwszFilterName) ) 

#define IEnumFilterInterfaces_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumFilterInterfaces_INTERFACE_DEFINED__ */


#ifndef __IMediaFilter_INTERFACE_DEFINED__
#define __IMediaFilter_INTERFACE_DEFINED__

/* interface IMediaFilter */
/* [unique][uuid][object] */ 

typedef 
enum _FilterState
    {	State_Stopped	= 0,
	State_Paused	= ( State_Stopped + 1 ) ,
	State_Running	= ( State_Paused + 1 ) 
    } 	FILTER_STATE;


EXTERN_C const IID IID_IMediaFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a86899-0ad4-11ce-b03a-0020af0ba770")
    IMediaFilter : public IPersist
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Run( 
            REFERENCE_TIME tStart) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetState( 
            /* [in] */ DWORD dwMilliSecsTimeout,
            /* [out] */ FILTER_STATE *State) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSyncSource( 
            /* [in] */ IReferenceClock *pClock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSyncSource( 
            /* [out] */ IReferenceClock **pClock) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaFilter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaFilter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassID )( 
            IMediaFilter * This,
            /* [out] */ CLSID *pClassID);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IMediaFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IMediaFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *Run )( 
            IMediaFilter * This,
            REFERENCE_TIME tStart);
        
        HRESULT ( STDMETHODCALLTYPE *GetState )( 
            IMediaFilter * This,
            /* [in] */ DWORD dwMilliSecsTimeout,
            /* [out] */ FILTER_STATE *State);
        
        HRESULT ( STDMETHODCALLTYPE *SetSyncSource )( 
            IMediaFilter * This,
            /* [in] */ IReferenceClock *pClock);
        
        HRESULT ( STDMETHODCALLTYPE *GetSyncSource )( 
            IMediaFilter * This,
            /* [out] */ IReferenceClock **pClock);
        
        END_INTERFACE
    } IMediaFilterVtbl;

    interface IMediaFilter
    {
        CONST_VTBL struct IMediaFilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaFilter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMediaFilter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMediaFilter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMediaFilter_GetClassID(This,pClassID)	\
    ( (This)->lpVtbl -> GetClassID(This,pClassID) ) 


#define IMediaFilter_Stop(This)	\
    ( (This)->lpVtbl -> Stop(This) ) 

#define IMediaFilter_Pause(This)	\
    ( (This)->lpVtbl -> Pause(This) ) 

#define IMediaFilter_Run(This,tStart)	\
    ( (This)->lpVtbl -> Run(This,tStart) ) 

#define IMediaFilter_GetState(This,dwMilliSecsTimeout,State)	\
    ( (This)->lpVtbl -> GetState(This,dwMilliSecsTimeout,State) ) 

#define IMediaFilter_SetSyncSource(This,pClock)	\
    ( (This)->lpVtbl -> SetSyncSource(This,pClock) ) 

#define IMediaFilter_GetSyncSource(This,pClock)	\
    ( (This)->lpVtbl -> GetSyncSource(This,pClock) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMediaFilter_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0007 */
/* [local] */ 

typedef IMediaFilter *PMEDIAFILTER;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0007_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0007_v0_0_s_ifspec;

#ifndef __IBaseFilter_INTERFACE_DEFINED__
#define __IBaseFilter_INTERFACE_DEFINED__

/* interface IBaseFilter */
/* [unique][uuid][object] */ 

typedef struct _FilterInfo
    {
    WCHAR achName[ 128 ];
    IFilterGraph *pGraph;
    } 	FILTER_INFO;


EXTERN_C const IID IID_IBaseFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a86895-0ad4-11ce-b03a-0020af0ba770")
    IBaseFilter : public IMediaFilter
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumPins( 
            /* [out] */ IEnumPins **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindPin( 
            /* [string][in] */ LPCWSTR Id,
            /* [out] */ IPin **ppPin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryFilterInfo( 
            /* [out] */ FILTER_INFO *pInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE JoinFilterGraph( 
            /* [in] */ IFilterGraph *pGraph,
            /* [string][in] */ LPCWSTR pName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryVendorInfo( 
            /* [string][out] */ LPWSTR *pVendorInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBaseFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBaseFilter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBaseFilter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBaseFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassID )( 
            IBaseFilter * This,
            /* [out] */ CLSID *pClassID);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IBaseFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IBaseFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *Run )( 
            IBaseFilter * This,
            REFERENCE_TIME tStart);
        
        HRESULT ( STDMETHODCALLTYPE *GetState )( 
            IBaseFilter * This,
            /* [in] */ DWORD dwMilliSecsTimeout,
            /* [out] */ FILTER_STATE *State);
        
        HRESULT ( STDMETHODCALLTYPE *SetSyncSource )( 
            IBaseFilter * This,
            /* [in] */ IReferenceClock *pClock);
        
        HRESULT ( STDMETHODCALLTYPE *GetSyncSource )( 
            IBaseFilter * This,
            /* [out] */ IReferenceClock **pClock);
        
        HRESULT ( STDMETHODCALLTYPE *EnumPins )( 
            IBaseFilter * This,
            /* [out] */ IEnumPins **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *FindPin )( 
            IBaseFilter * This,
            /* [string][in] */ LPCWSTR Id,
            /* [out] */ IPin **ppPin);
        
        HRESULT ( STDMETHODCALLTYPE *QueryFilterInfo )( 
            IBaseFilter * This,
            /* [out] */ FILTER_INFO *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE *JoinFilterGraph )( 
            IBaseFilter * This,
            /* [in] */ IFilterGraph *pGraph,
            /* [string][in] */ LPCWSTR pName);
        
        HRESULT ( STDMETHODCALLTYPE *QueryVendorInfo )( 
            IBaseFilter * This,
            /* [string][out] */ LPWSTR *pVendorInfo);
        
        END_INTERFACE
    } IBaseFilterVtbl;

    interface IBaseFilter
    {
        CONST_VTBL struct IBaseFilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBaseFilter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBaseFilter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBaseFilter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBaseFilter_GetClassID(This,pClassID)	\
    ( (This)->lpVtbl -> GetClassID(This,pClassID) ) 


#define IBaseFilter_Stop(This)	\
    ( (This)->lpVtbl -> Stop(This) ) 

#define IBaseFilter_Pause(This)	\
    ( (This)->lpVtbl -> Pause(This) ) 

#define IBaseFilter_Run(This,tStart)	\
    ( (This)->lpVtbl -> Run(This,tStart) ) 

#define IBaseFilter_GetState(This,dwMilliSecsTimeout,State)	\
    ( (This)->lpVtbl -> GetState(This,dwMilliSecsTimeout,State) ) 

#define IBaseFilter_SetSyncSource(This,pClock)	\
    ( (This)->lpVtbl -> SetSyncSource(This,pClock) ) 

#define IBaseFilter_GetSyncSource(This,pClock)	\
    ( (This)->lpVtbl -> GetSyncSource(This,pClock) ) 


#define IBaseFilter_EnumPins(This,ppEnum)	\
    ( (This)->lpVtbl -> EnumPins(This,ppEnum) ) 

#define IBaseFilter_FindPin(This,Id,ppPin)	\
    ( (This)->lpVtbl -> FindPin(This,Id,ppPin) ) 

#define IBaseFilter_QueryFilterInfo(This,pInfo)	\
    ( (This)->lpVtbl -> QueryFilterInfo(This,pInfo) ) 

#define IBaseFilter_JoinFilterGraph(This,pGraph,pName)	\
    ( (This)->lpVtbl -> JoinFilterGraph(This,pGraph,pName) ) 

#define IBaseFilter_QueryVendorInfo(This,pVendorInfo)	\
    ( (This)->lpVtbl -> QueryVendorInfo(This,pVendorInfo) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IBaseFilter_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0008 */
/* [local] */ 

typedef IBaseFilter *PFILTER;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0008_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0008_v0_0_s_ifspec;

#ifndef __IReferenceClock_INTERFACE_DEFINED__
#define __IReferenceClock_INTERFACE_DEFINED__

/* interface IReferenceClock */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IReferenceClock;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a86897-0ad4-11ce-b03a-0020af0ba770")
    IReferenceClock : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTime( 
            /* [out] */ REFERENCE_TIME *pTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AdviseTime( 
            /* [in] */ REFERENCE_TIME baseTime,
            /* [in] */ REFERENCE_TIME streamTime,
            /* [in] */ HEVENT hEvent,
            /* [out] */ DWORD_PTR *pdwAdviseCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AdvisePeriodic( 
            /* [in] */ REFERENCE_TIME startTime,
            /* [in] */ REFERENCE_TIME periodTime,
            /* [in] */ HSEMAPHORE hSemaphore,
            /* [out] */ DWORD_PTR *pdwAdviseCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unadvise( 
            /* [in] */ DWORD_PTR dwAdviseCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IReferenceClockVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IReferenceClock * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IReferenceClock * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IReferenceClock * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTime )( 
            IReferenceClock * This,
            /* [out] */ REFERENCE_TIME *pTime);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseTime )( 
            IReferenceClock * This,
            /* [in] */ REFERENCE_TIME baseTime,
            /* [in] */ REFERENCE_TIME streamTime,
            /* [in] */ HEVENT hEvent,
            /* [out] */ DWORD_PTR *pdwAdviseCookie);
        
        HRESULT ( STDMETHODCALLTYPE *AdvisePeriodic )( 
            IReferenceClock * This,
            /* [in] */ REFERENCE_TIME startTime,
            /* [in] */ REFERENCE_TIME periodTime,
            /* [in] */ HSEMAPHORE hSemaphore,
            /* [out] */ DWORD_PTR *pdwAdviseCookie);
        
        HRESULT ( STDMETHODCALLTYPE *Unadvise )( 
            IReferenceClock * This,
            /* [in] */ DWORD_PTR dwAdviseCookie);
        
        END_INTERFACE
    } IReferenceClockVtbl;

    interface IReferenceClock
    {
        CONST_VTBL struct IReferenceClockVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IReferenceClock_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IReferenceClock_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IReferenceClock_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IReferenceClock_GetTime(This,pTime)	\
    ( (This)->lpVtbl -> GetTime(This,pTime) ) 

#define IReferenceClock_AdviseTime(This,baseTime,streamTime,hEvent,pdwAdviseCookie)	\
    ( (This)->lpVtbl -> AdviseTime(This,baseTime,streamTime,hEvent,pdwAdviseCookie) ) 

#define IReferenceClock_AdvisePeriodic(This,startTime,periodTime,hSemaphore,pdwAdviseCookie)	\
    ( (This)->lpVtbl -> AdvisePeriodic(This,startTime,periodTime,hSemaphore,pdwAdviseCookie) ) 

#define IReferenceClock_Unadvise(This,dwAdviseCookie)	\
    ( (This)->lpVtbl -> Unadvise(This,dwAdviseCookie) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IReferenceClock_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0009 */
/* [local] */ 

typedef IReferenceClock *PREFERENCECLOCK;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0009_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0009_v0_0_s_ifspec;

#ifndef __IReferenceClock2_INTERFACE_DEFINED__
#define __IReferenceClock2_INTERFACE_DEFINED__

/* interface IReferenceClock2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IReferenceClock2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("36b73885-c2c8-11cf-8b46-00805f6cef60")
    IReferenceClock2 : public IReferenceClock
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IReferenceClock2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IReferenceClock2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IReferenceClock2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IReferenceClock2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTime )( 
            IReferenceClock2 * This,
            /* [out] */ REFERENCE_TIME *pTime);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseTime )( 
            IReferenceClock2 * This,
            /* [in] */ REFERENCE_TIME baseTime,
            /* [in] */ REFERENCE_TIME streamTime,
            /* [in] */ HEVENT hEvent,
            /* [out] */ DWORD_PTR *pdwAdviseCookie);
        
        HRESULT ( STDMETHODCALLTYPE *AdvisePeriodic )( 
            IReferenceClock2 * This,
            /* [in] */ REFERENCE_TIME startTime,
            /* [in] */ REFERENCE_TIME periodTime,
            /* [in] */ HSEMAPHORE hSemaphore,
            /* [out] */ DWORD_PTR *pdwAdviseCookie);
        
        HRESULT ( STDMETHODCALLTYPE *Unadvise )( 
            IReferenceClock2 * This,
            /* [in] */ DWORD_PTR dwAdviseCookie);
        
        END_INTERFACE
    } IReferenceClock2Vtbl;

    interface IReferenceClock2
    {
        CONST_VTBL struct IReferenceClock2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IReferenceClock2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IReferenceClock2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IReferenceClock2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IReferenceClock2_GetTime(This,pTime)	\
    ( (This)->lpVtbl -> GetTime(This,pTime) ) 

#define IReferenceClock2_AdviseTime(This,baseTime,streamTime,hEvent,pdwAdviseCookie)	\
    ( (This)->lpVtbl -> AdviseTime(This,baseTime,streamTime,hEvent,pdwAdviseCookie) ) 

#define IReferenceClock2_AdvisePeriodic(This,startTime,periodTime,hSemaphore,pdwAdviseCookie)	\
    ( (This)->lpVtbl -> AdvisePeriodic(This,startTime,periodTime,hSemaphore,pdwAdviseCookie) ) 

#define IReferenceClock2_Unadvise(This,dwAdviseCookie)	\
    ( (This)->lpVtbl -> Unadvise(This,dwAdviseCookie) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IReferenceClock2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0010 */
/* [local] */ 

typedef IReferenceClock2 *PREFERENCECLOCK2;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0010_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0010_v0_0_s_ifspec;

#ifndef __IMediaSample_INTERFACE_DEFINED__
#define __IMediaSample_INTERFACE_DEFINED__

/* interface IMediaSample */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IMediaSample;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a8689a-0ad4-11ce-b03a-0020af0ba770")
    IMediaSample : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPointer( 
            /* [out] */ BYTE **ppBuffer) = 0;
        
        virtual long STDMETHODCALLTYPE GetSize( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTime( 
            /* [out] */ REFERENCE_TIME *pTimeStart,
            /* [out] */ REFERENCE_TIME *pTimeEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTime( 
            /* [in] */ REFERENCE_TIME *pTimeStart,
            /* [in] */ REFERENCE_TIME *pTimeEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsSyncPoint( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSyncPoint( 
            BOOL bIsSyncPoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsPreroll( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPreroll( 
            BOOL bIsPreroll) = 0;
        
        virtual long STDMETHODCALLTYPE GetActualDataLength( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetActualDataLength( 
            long __MIDL__IMediaSample0000) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMediaType( 
            AM_MEDIA_TYPE **ppMediaType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMediaType( 
            AM_MEDIA_TYPE *pMediaType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsDiscontinuity( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDiscontinuity( 
            BOOL bDiscontinuity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMediaTime( 
            /* [out] */ LONGLONG *pTimeStart,
            /* [out] */ LONGLONG *pTimeEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMediaTime( 
            /* [in] */ LONGLONG *pTimeStart,
            /* [in] */ LONGLONG *pTimeEnd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaSampleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaSample * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaSample * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaSample * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPointer )( 
            IMediaSample * This,
            /* [out] */ BYTE **ppBuffer);
        
        long ( STDMETHODCALLTYPE *GetSize )( 
            IMediaSample * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTime )( 
            IMediaSample * This,
            /* [out] */ REFERENCE_TIME *pTimeStart,
            /* [out] */ REFERENCE_TIME *pTimeEnd);
        
        HRESULT ( STDMETHODCALLTYPE *SetTime )( 
            IMediaSample * This,
            /* [in] */ REFERENCE_TIME *pTimeStart,
            /* [in] */ REFERENCE_TIME *pTimeEnd);
        
        HRESULT ( STDMETHODCALLTYPE *IsSyncPoint )( 
            IMediaSample * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetSyncPoint )( 
            IMediaSample * This,
            BOOL bIsSyncPoint);
        
        HRESULT ( STDMETHODCALLTYPE *IsPreroll )( 
            IMediaSample * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPreroll )( 
            IMediaSample * This,
            BOOL bIsPreroll);
        
        long ( STDMETHODCALLTYPE *GetActualDataLength )( 
            IMediaSample * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetActualDataLength )( 
            IMediaSample * This,
            long __MIDL__IMediaSample0000);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaType )( 
            IMediaSample * This,
            AM_MEDIA_TYPE **ppMediaType);
        
        HRESULT ( STDMETHODCALLTYPE *SetMediaType )( 
            IMediaSample * This,
            AM_MEDIA_TYPE *pMediaType);
        
        HRESULT ( STDMETHODCALLTYPE *IsDiscontinuity )( 
            IMediaSample * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDiscontinuity )( 
            IMediaSample * This,
            BOOL bDiscontinuity);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaTime )( 
            IMediaSample * This,
            /* [out] */ LONGLONG *pTimeStart,
            /* [out] */ LONGLONG *pTimeEnd);
        
        HRESULT ( STDMETHODCALLTYPE *SetMediaTime )( 
            IMediaSample * This,
            /* [in] */ LONGLONG *pTimeStart,
            /* [in] */ LONGLONG *pTimeEnd);
        
        END_INTERFACE
    } IMediaSampleVtbl;

    interface IMediaSample
    {
        CONST_VTBL struct IMediaSampleVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaSample_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMediaSample_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMediaSample_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMediaSample_GetPointer(This,ppBuffer)	\
    ( (This)->lpVtbl -> GetPointer(This,ppBuffer) ) 

#define IMediaSample_GetSize(This)	\
    ( (This)->lpVtbl -> GetSize(This) ) 

#define IMediaSample_GetTime(This,pTimeStart,pTimeEnd)	\
    ( (This)->lpVtbl -> GetTime(This,pTimeStart,pTimeEnd) ) 

#define IMediaSample_SetTime(This,pTimeStart,pTimeEnd)	\
    ( (This)->lpVtbl -> SetTime(This,pTimeStart,pTimeEnd) ) 

#define IMediaSample_IsSyncPoint(This)	\
    ( (This)->lpVtbl -> IsSyncPoint(This) ) 

#define IMediaSample_SetSyncPoint(This,bIsSyncPoint)	\
    ( (This)->lpVtbl -> SetSyncPoint(This,bIsSyncPoint) ) 

#define IMediaSample_IsPreroll(This)	\
    ( (This)->lpVtbl -> IsPreroll(This) ) 

#define IMediaSample_SetPreroll(This,bIsPreroll)	\
    ( (This)->lpVtbl -> SetPreroll(This,bIsPreroll) ) 

#define IMediaSample_GetActualDataLength(This)	\
    ( (This)->lpVtbl -> GetActualDataLength(This) ) 

#define IMediaSample_SetActualDataLength(This,__MIDL__IMediaSample0000)	\
    ( (This)->lpVtbl -> SetActualDataLength(This,__MIDL__IMediaSample0000) ) 

#define IMediaSample_GetMediaType(This,ppMediaType)	\
    ( (This)->lpVtbl -> GetMediaType(This,ppMediaType) ) 

#define IMediaSample_SetMediaType(This,pMediaType)	\
    ( (This)->lpVtbl -> SetMediaType(This,pMediaType) ) 

#define IMediaSample_IsDiscontinuity(This)	\
    ( (This)->lpVtbl -> IsDiscontinuity(This) ) 

#define IMediaSample_SetDiscontinuity(This,bDiscontinuity)	\
    ( (This)->lpVtbl -> SetDiscontinuity(This,bDiscontinuity) ) 

#define IMediaSample_GetMediaTime(This,pTimeStart,pTimeEnd)	\
    ( (This)->lpVtbl -> GetMediaTime(This,pTimeStart,pTimeEnd) ) 

#define IMediaSample_SetMediaTime(This,pTimeStart,pTimeEnd)	\
    ( (This)->lpVtbl -> SetMediaTime(This,pTimeStart,pTimeEnd) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMediaSample_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0011 */
/* [local] */ 

typedef IMediaSample *PMEDIASAMPLE;


enum tagAM_SAMPLE_PROPERTY_FLAGS
    {	AM_SAMPLE_SPLICEPOINT	= 0x1,
	AM_SAMPLE_PREROLL	= 0x2,
	AM_SAMPLE_DATADISCONTINUITY	= 0x4,
	AM_SAMPLE_TYPECHANGED	= 0x8,
	AM_SAMPLE_TIMEVALID	= 0x10,
	AM_SAMPLE_TIMEDISCONTINUITY	= 0x40,
	AM_SAMPLE_FLUSH_ON_PAUSE	= 0x80,
	AM_SAMPLE_STOPVALID	= 0x100,
	AM_SAMPLE_ENDOFSTREAM	= 0x200,
	AM_STREAM_MEDIA	= 0,
	AM_STREAM_CONTROL	= 1
    } ;
typedef struct tagAM_SAMPLE2_PROPERTIES
    {
    DWORD cbData;
    DWORD dwTypeSpecificFlags;
    DWORD dwSampleFlags;
    LONG lActual;
    REFERENCE_TIME tStart;
    REFERENCE_TIME tStop;
    DWORD dwStreamId;
    AM_MEDIA_TYPE *pMediaType;
    BYTE *pbBuffer;
    LONG cbBuffer;
    } 	AM_SAMPLE2_PROPERTIES;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0011_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0011_v0_0_s_ifspec;

#ifndef __IMediaSample2_INTERFACE_DEFINED__
#define __IMediaSample2_INTERFACE_DEFINED__

/* interface IMediaSample2 */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IMediaSample2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("36b73884-c2c8-11cf-8b46-00805f6cef60")
    IMediaSample2 : public IMediaSample
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [in] */ DWORD cbProperties,
            /* [size_is][out] */ BYTE *pbProperties) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProperties( 
            /* [in] */ DWORD cbProperties,
            /* [size_is][in] */ const BYTE *pbProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaSample2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaSample2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaSample2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaSample2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPointer )( 
            IMediaSample2 * This,
            /* [out] */ BYTE **ppBuffer);
        
        long ( STDMETHODCALLTYPE *GetSize )( 
            IMediaSample2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTime )( 
            IMediaSample2 * This,
            /* [out] */ REFERENCE_TIME *pTimeStart,
            /* [out] */ REFERENCE_TIME *pTimeEnd);
        
        HRESULT ( STDMETHODCALLTYPE *SetTime )( 
            IMediaSample2 * This,
            /* [in] */ REFERENCE_TIME *pTimeStart,
            /* [in] */ REFERENCE_TIME *pTimeEnd);
        
        HRESULT ( STDMETHODCALLTYPE *IsSyncPoint )( 
            IMediaSample2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetSyncPoint )( 
            IMediaSample2 * This,
            BOOL bIsSyncPoint);
        
        HRESULT ( STDMETHODCALLTYPE *IsPreroll )( 
            IMediaSample2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPreroll )( 
            IMediaSample2 * This,
            BOOL bIsPreroll);
        
        long ( STDMETHODCALLTYPE *GetActualDataLength )( 
            IMediaSample2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetActualDataLength )( 
            IMediaSample2 * This,
            long __MIDL__IMediaSample0000);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaType )( 
            IMediaSample2 * This,
            AM_MEDIA_TYPE **ppMediaType);
        
        HRESULT ( STDMETHODCALLTYPE *SetMediaType )( 
            IMediaSample2 * This,
            AM_MEDIA_TYPE *pMediaType);
        
        HRESULT ( STDMETHODCALLTYPE *IsDiscontinuity )( 
            IMediaSample2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDiscontinuity )( 
            IMediaSample2 * This,
            BOOL bDiscontinuity);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaTime )( 
            IMediaSample2 * This,
            /* [out] */ LONGLONG *pTimeStart,
            /* [out] */ LONGLONG *pTimeEnd);
        
        HRESULT ( STDMETHODCALLTYPE *SetMediaTime )( 
            IMediaSample2 * This,
            /* [in] */ LONGLONG *pTimeStart,
            /* [in] */ LONGLONG *pTimeEnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            IMediaSample2 * This,
            /* [in] */ DWORD cbProperties,
            /* [size_is][out] */ BYTE *pbProperties);
        
        HRESULT ( STDMETHODCALLTYPE *SetProperties )( 
            IMediaSample2 * This,
            /* [in] */ DWORD cbProperties,
            /* [size_is][in] */ const BYTE *pbProperties);
        
        END_INTERFACE
    } IMediaSample2Vtbl;

    interface IMediaSample2
    {
        CONST_VTBL struct IMediaSample2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaSample2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMediaSample2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMediaSample2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMediaSample2_GetPointer(This,ppBuffer)	\
    ( (This)->lpVtbl -> GetPointer(This,ppBuffer) ) 

#define IMediaSample2_GetSize(This)	\
    ( (This)->lpVtbl -> GetSize(This) ) 

#define IMediaSample2_GetTime(This,pTimeStart,pTimeEnd)	\
    ( (This)->lpVtbl -> GetTime(This,pTimeStart,pTimeEnd) ) 

#define IMediaSample2_SetTime(This,pTimeStart,pTimeEnd)	\
    ( (This)->lpVtbl -> SetTime(This,pTimeStart,pTimeEnd) ) 

#define IMediaSample2_IsSyncPoint(This)	\
    ( (This)->lpVtbl -> IsSyncPoint(This) ) 

#define IMediaSample2_SetSyncPoint(This,bIsSyncPoint)	\
    ( (This)->lpVtbl -> SetSyncPoint(This,bIsSyncPoint) ) 

#define IMediaSample2_IsPreroll(This)	\
    ( (This)->lpVtbl -> IsPreroll(This) ) 

#define IMediaSample2_SetPreroll(This,bIsPreroll)	\
    ( (This)->lpVtbl -> SetPreroll(This,bIsPreroll) ) 

#define IMediaSample2_GetActualDataLength(This)	\
    ( (This)->lpVtbl -> GetActualDataLength(This) ) 

#define IMediaSample2_SetActualDataLength(This,__MIDL__IMediaSample0000)	\
    ( (This)->lpVtbl -> SetActualDataLength(This,__MIDL__IMediaSample0000) ) 

#define IMediaSample2_GetMediaType(This,ppMediaType)	\
    ( (This)->lpVtbl -> GetMediaType(This,ppMediaType) ) 

#define IMediaSample2_SetMediaType(This,pMediaType)	\
    ( (This)->lpVtbl -> SetMediaType(This,pMediaType) ) 

#define IMediaSample2_IsDiscontinuity(This)	\
    ( (This)->lpVtbl -> IsDiscontinuity(This) ) 

#define IMediaSample2_SetDiscontinuity(This,bDiscontinuity)	\
    ( (This)->lpVtbl -> SetDiscontinuity(This,bDiscontinuity) ) 

#define IMediaSample2_GetMediaTime(This,pTimeStart,pTimeEnd)	\
    ( (This)->lpVtbl -> GetMediaTime(This,pTimeStart,pTimeEnd) ) 

#define IMediaSample2_SetMediaTime(This,pTimeStart,pTimeEnd)	\
    ( (This)->lpVtbl -> SetMediaTime(This,pTimeStart,pTimeEnd) ) 


#define IMediaSample2_GetProperties(This,cbProperties,pbProperties)	\
    ( (This)->lpVtbl -> GetProperties(This,cbProperties,pbProperties) ) 

#define IMediaSample2_SetProperties(This,cbProperties,pbProperties)	\
    ( (This)->lpVtbl -> SetProperties(This,cbProperties,pbProperties) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMediaSample2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0012 */
/* [local] */ 

typedef IMediaSample2 *PMEDIASAMPLE2;

#define AM_GBF_PREVFRAMESKIPPED 1
#define AM_GBF_NOTASYNCPOINT 2
#define AM_GBF_NOWAIT 4
#define AM_GBF_NODDSURFACELOCK 8


extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0012_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0012_v0_0_s_ifspec;

#ifndef __IMemAllocator_INTERFACE_DEFINED__
#define __IMemAllocator_INTERFACE_DEFINED__

/* interface IMemAllocator */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IMemAllocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a8689c-0ad4-11ce-b03a-0020af0ba770")
    IMemAllocator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetProperties( 
            /* [in] */ ALLOCATOR_PROPERTIES *pRequest,
            /* [out] */ ALLOCATOR_PROPERTIES *pActual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ ALLOCATOR_PROPERTIES *pProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Commit( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Decommit( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBuffer( 
            /* [out] */ IMediaSample **ppBuffer,
            /* [in] */ REFERENCE_TIME *pStartTime,
            /* [in] */ REFERENCE_TIME *pEndTime,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseBuffer( 
            /* [in] */ IMediaSample *pBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMemAllocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMemAllocator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMemAllocator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMemAllocator * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetProperties )( 
            IMemAllocator * This,
            /* [in] */ ALLOCATOR_PROPERTIES *pRequest,
            /* [out] */ ALLOCATOR_PROPERTIES *pActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            IMemAllocator * This,
            /* [out] */ ALLOCATOR_PROPERTIES *pProps);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            IMemAllocator * This);
        
        HRESULT ( STDMETHODCALLTYPE *Decommit )( 
            IMemAllocator * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetBuffer )( 
            IMemAllocator * This,
            /* [out] */ IMediaSample **ppBuffer,
            /* [in] */ REFERENCE_TIME *pStartTime,
            /* [in] */ REFERENCE_TIME *pEndTime,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseBuffer )( 
            IMemAllocator * This,
            /* [in] */ IMediaSample *pBuffer);
        
        END_INTERFACE
    } IMemAllocatorVtbl;

    interface IMemAllocator
    {
        CONST_VTBL struct IMemAllocatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMemAllocator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMemAllocator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMemAllocator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMemAllocator_SetProperties(This,pRequest,pActual)	\
    ( (This)->lpVtbl -> SetProperties(This,pRequest,pActual) ) 

#define IMemAllocator_GetProperties(This,pProps)	\
    ( (This)->lpVtbl -> GetProperties(This,pProps) ) 

#define IMemAllocator_Commit(This)	\
    ( (This)->lpVtbl -> Commit(This) ) 

#define IMemAllocator_Decommit(This)	\
    ( (This)->lpVtbl -> Decommit(This) ) 

#define IMemAllocator_GetBuffer(This,ppBuffer,pStartTime,pEndTime,dwFlags)	\
    ( (This)->lpVtbl -> GetBuffer(This,ppBuffer,pStartTime,pEndTime,dwFlags) ) 

#define IMemAllocator_ReleaseBuffer(This,pBuffer)	\
    ( (This)->lpVtbl -> ReleaseBuffer(This,pBuffer) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMemAllocator_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0013 */
/* [local] */ 

typedef IMemAllocator *PMEMALLOCATOR;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0013_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0013_v0_0_s_ifspec;

#ifndef __IMemAllocator2_INTERFACE_DEFINED__
#define __IMemAllocator2_INTERFACE_DEFINED__

/* interface IMemAllocator2 */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IMemAllocator2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fa04cdc8-cb49-11d1-a4ef-00c04fb6fa12")
    IMemAllocator2 : public IMemAllocator
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetBusyCount( 
            DWORD *pdwBusyCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFreeCount( 
            DWORD *pdwFreeCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMemAllocator2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMemAllocator2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMemAllocator2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMemAllocator2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetProperties )( 
            IMemAllocator2 * This,
            /* [in] */ ALLOCATOR_PROPERTIES *pRequest,
            /* [out] */ ALLOCATOR_PROPERTIES *pActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            IMemAllocator2 * This,
            /* [out] */ ALLOCATOR_PROPERTIES *pProps);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            IMemAllocator2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Decommit )( 
            IMemAllocator2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetBuffer )( 
            IMemAllocator2 * This,
            /* [out] */ IMediaSample **ppBuffer,
            /* [in] */ REFERENCE_TIME *pStartTime,
            /* [in] */ REFERENCE_TIME *pEndTime,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseBuffer )( 
            IMemAllocator2 * This,
            /* [in] */ IMediaSample *pBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *GetBusyCount )( 
            IMemAllocator2 * This,
            DWORD *pdwBusyCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetFreeCount )( 
            IMemAllocator2 * This,
            DWORD *pdwFreeCount);
        
        END_INTERFACE
    } IMemAllocator2Vtbl;

    interface IMemAllocator2
    {
        CONST_VTBL struct IMemAllocator2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMemAllocator2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMemAllocator2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMemAllocator2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMemAllocator2_SetProperties(This,pRequest,pActual)	\
    ( (This)->lpVtbl -> SetProperties(This,pRequest,pActual) ) 

#define IMemAllocator2_GetProperties(This,pProps)	\
    ( (This)->lpVtbl -> GetProperties(This,pProps) ) 

#define IMemAllocator2_Commit(This)	\
    ( (This)->lpVtbl -> Commit(This) ) 

#define IMemAllocator2_Decommit(This)	\
    ( (This)->lpVtbl -> Decommit(This) ) 

#define IMemAllocator2_GetBuffer(This,ppBuffer,pStartTime,pEndTime,dwFlags)	\
    ( (This)->lpVtbl -> GetBuffer(This,ppBuffer,pStartTime,pEndTime,dwFlags) ) 

#define IMemAllocator2_ReleaseBuffer(This,pBuffer)	\
    ( (This)->lpVtbl -> ReleaseBuffer(This,pBuffer) ) 


#define IMemAllocator2_GetBusyCount(This,pdwBusyCount)	\
    ( (This)->lpVtbl -> GetBusyCount(This,pdwBusyCount) ) 

#define IMemAllocator2_GetFreeCount(This,pdwFreeCount)	\
    ( (This)->lpVtbl -> GetFreeCount(This,pdwFreeCount) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMemAllocator2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0014 */
/* [local] */ 

typedef IMemAllocator2 *PMEMALLOCATOR2;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0014_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0014_v0_0_s_ifspec;

#ifndef __IMemInputPin_INTERFACE_DEFINED__
#define __IMemInputPin_INTERFACE_DEFINED__

/* interface IMemInputPin */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IMemInputPin;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a8689d-0ad4-11ce-b03a-0020af0ba770")
    IMemInputPin : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAllocator( 
            /* [out] */ IMemAllocator **ppAllocator) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyAllocator( 
            /* [in] */ IMemAllocator *pAllocator,
            /* [in] */ BOOL bReadOnly) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllocatorRequirements( 
            /* [out] */ ALLOCATOR_PROPERTIES *pProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Receive( 
            /* [in] */ IMediaSample *pSample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReceiveMultiple( 
            /* [size_is][in] */ IMediaSample **pSamples,
            /* [in] */ long nSamples,
            /* [out] */ long *nSamplesProcessed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReceiveCanBlock( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMemInputPinVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMemInputPin * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMemInputPin * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMemInputPin * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocator )( 
            IMemInputPin * This,
            /* [out] */ IMemAllocator **ppAllocator);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyAllocator )( 
            IMemInputPin * This,
            /* [in] */ IMemAllocator *pAllocator,
            /* [in] */ BOOL bReadOnly);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocatorRequirements )( 
            IMemInputPin * This,
            /* [out] */ ALLOCATOR_PROPERTIES *pProps);
        
        HRESULT ( STDMETHODCALLTYPE *Receive )( 
            IMemInputPin * This,
            /* [in] */ IMediaSample *pSample);
        
        HRESULT ( STDMETHODCALLTYPE *ReceiveMultiple )( 
            IMemInputPin * This,
            /* [size_is][in] */ IMediaSample **pSamples,
            /* [in] */ long nSamples,
            /* [out] */ long *nSamplesProcessed);
        
        HRESULT ( STDMETHODCALLTYPE *ReceiveCanBlock )( 
            IMemInputPin * This);
        
        END_INTERFACE
    } IMemInputPinVtbl;

    interface IMemInputPin
    {
        CONST_VTBL struct IMemInputPinVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMemInputPin_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMemInputPin_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMemInputPin_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMemInputPin_GetAllocator(This,ppAllocator)	\
    ( (This)->lpVtbl -> GetAllocator(This,ppAllocator) ) 

#define IMemInputPin_NotifyAllocator(This,pAllocator,bReadOnly)	\
    ( (This)->lpVtbl -> NotifyAllocator(This,pAllocator,bReadOnly) ) 

#define IMemInputPin_GetAllocatorRequirements(This,pProps)	\
    ( (This)->lpVtbl -> GetAllocatorRequirements(This,pProps) ) 

#define IMemInputPin_Receive(This,pSample)	\
    ( (This)->lpVtbl -> Receive(This,pSample) ) 

#define IMemInputPin_ReceiveMultiple(This,pSamples,nSamples,nSamplesProcessed)	\
    ( (This)->lpVtbl -> ReceiveMultiple(This,pSamples,nSamples,nSamplesProcessed) ) 

#define IMemInputPin_ReceiveCanBlock(This)	\
    ( (This)->lpVtbl -> ReceiveCanBlock(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMemInputPin_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0015 */
/* [local] */ 

typedef IMemInputPin *PMEMINPUTPIN;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0015_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0015_v0_0_s_ifspec;

#ifndef __IAMovieSetup_INTERFACE_DEFINED__
#define __IAMovieSetup_INTERFACE_DEFINED__

/* interface IAMovieSetup */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMovieSetup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a3d8cec0-7e5a-11cf-bbc5-00805f6cef20")
    IAMovieSetup : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Register( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unregister( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMovieSetupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMovieSetup * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMovieSetup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMovieSetup * This);
        
        HRESULT ( STDMETHODCALLTYPE *Register )( 
            IAMovieSetup * This);
        
        HRESULT ( STDMETHODCALLTYPE *Unregister )( 
            IAMovieSetup * This);
        
        END_INTERFACE
    } IAMovieSetupVtbl;

    interface IAMovieSetup
    {
        CONST_VTBL struct IAMovieSetupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMovieSetup_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMovieSetup_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMovieSetup_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMovieSetup_Register(This)	\
    ( (This)->lpVtbl -> Register(This) ) 

#define IAMovieSetup_Unregister(This)	\
    ( (This)->lpVtbl -> Unregister(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMovieSetup_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0016 */
/* [local] */ 

typedef IAMovieSetup *PAMOVIESETUP;

typedef 
enum AM_SEEKING_SeekingFlags
    {	AM_SEEKING_NoPositioning	= 0,
	AM_SEEKING_AbsolutePositioning	= 0x1,
	AM_SEEKING_RelativePositioning	= 0x2,
	AM_SEEKING_IncrementalPositioning	= 0x3,
	AM_SEEKING_PositioningBitsMask	= 0x3,
	AM_SEEKING_SeekToKeyFrame	= 0x4,
	AM_SEEKING_ReturnTime	= 0x8,
	AM_SEEKING_Segment	= 0x10,
	AM_SEEKING_NoFlush	= 0x20
    } 	AM_SEEKING_SEEKING_FLAGS;

typedef 
enum AM_SEEKING_SeekingCapabilities
    {	AM_SEEKING_CanSeekAbsolute	= 0x1,
	AM_SEEKING_CanSeekForwards	= 0x2,
	AM_SEEKING_CanSeekBackwards	= 0x4,
	AM_SEEKING_CanGetCurrentPos	= 0x8,
	AM_SEEKING_CanGetStopPos	= 0x10,
	AM_SEEKING_CanGetDuration	= 0x20,
	AM_SEEKING_CanPlayBackwards	= 0x40,
	AM_SEEKING_CanDoSegments	= 0x80,
	AM_SEEKING_Source	= 0x100
    } 	AM_SEEKING_SEEKING_CAPABILITIES;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0016_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0016_v0_0_s_ifspec;

#ifndef __IMediaSeeking_INTERFACE_DEFINED__
#define __IMediaSeeking_INTERFACE_DEFINED__

/* interface IMediaSeeking */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IMediaSeeking;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("36b73880-c2c8-11cf-8b46-00805f6cef60")
    IMediaSeeking : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCapabilities( 
            /* [out] */ DWORD *pCapabilities) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CheckCapabilities( 
            /* [out][in] */ DWORD *pCapabilities) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsFormatSupported( 
            /* [in] */ const GUID *pFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryPreferredFormat( 
            /* [out] */ GUID *pFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTimeFormat( 
            /* [out] */ GUID *pFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUsingTimeFormat( 
            /* [in] */ const GUID *pFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTimeFormat( 
            /* [in] */ const GUID *pFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDuration( 
            /* [out] */ LONGLONG *pDuration) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStopPosition( 
            /* [out] */ LONGLONG *pStop) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentPosition( 
            /* [out] */ LONGLONG *pCurrent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConvertTimeFormat( 
            /* [out] */ LONGLONG *pTarget,
            /* [in] */ const GUID *pTargetFormat,
            /* [in] */ LONGLONG Source,
            /* [in] */ const GUID *pSourceFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPositions( 
            /* [out][in] */ LONGLONG *pCurrent,
            /* [in] */ DWORD dwCurrentFlags,
            /* [out][in] */ LONGLONG *pStop,
            /* [in] */ DWORD dwStopFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPositions( 
            /* [out] */ LONGLONG *pCurrent,
            /* [out] */ LONGLONG *pStop) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAvailable( 
            /* [out] */ LONGLONG *pEarliest,
            /* [out] */ LONGLONG *pLatest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRate( 
            /* [in] */ double dRate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRate( 
            /* [out] */ double *pdRate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPreroll( 
            /* [out] */ LONGLONG *pllPreroll) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaSeekingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaSeeking * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaSeeking * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaSeeking * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCapabilities )( 
            IMediaSeeking * This,
            /* [out] */ DWORD *pCapabilities);
        
        HRESULT ( STDMETHODCALLTYPE *CheckCapabilities )( 
            IMediaSeeking * This,
            /* [out][in] */ DWORD *pCapabilities);
        
        HRESULT ( STDMETHODCALLTYPE *IsFormatSupported )( 
            IMediaSeeking * This,
            /* [in] */ const GUID *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE *QueryPreferredFormat )( 
            IMediaSeeking * This,
            /* [out] */ GUID *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetTimeFormat )( 
            IMediaSeeking * This,
            /* [out] */ GUID *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE *IsUsingTimeFormat )( 
            IMediaSeeking * This,
            /* [in] */ const GUID *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE *SetTimeFormat )( 
            IMediaSeeking * This,
            /* [in] */ const GUID *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetDuration )( 
            IMediaSeeking * This,
            /* [out] */ LONGLONG *pDuration);
        
        HRESULT ( STDMETHODCALLTYPE *GetStopPosition )( 
            IMediaSeeking * This,
            /* [out] */ LONGLONG *pStop);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentPosition )( 
            IMediaSeeking * This,
            /* [out] */ LONGLONG *pCurrent);
        
        HRESULT ( STDMETHODCALLTYPE *ConvertTimeFormat )( 
            IMediaSeeking * This,
            /* [out] */ LONGLONG *pTarget,
            /* [in] */ const GUID *pTargetFormat,
            /* [in] */ LONGLONG Source,
            /* [in] */ const GUID *pSourceFormat);
        
        HRESULT ( STDMETHODCALLTYPE *SetPositions )( 
            IMediaSeeking * This,
            /* [out][in] */ LONGLONG *pCurrent,
            /* [in] */ DWORD dwCurrentFlags,
            /* [out][in] */ LONGLONG *pStop,
            /* [in] */ DWORD dwStopFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetPositions )( 
            IMediaSeeking * This,
            /* [out] */ LONGLONG *pCurrent,
            /* [out] */ LONGLONG *pStop);
        
        HRESULT ( STDMETHODCALLTYPE *GetAvailable )( 
            IMediaSeeking * This,
            /* [out] */ LONGLONG *pEarliest,
            /* [out] */ LONGLONG *pLatest);
        
        HRESULT ( STDMETHODCALLTYPE *SetRate )( 
            IMediaSeeking * This,
            /* [in] */ double dRate);
        
        HRESULT ( STDMETHODCALLTYPE *GetRate )( 
            IMediaSeeking * This,
            /* [out] */ double *pdRate);
        
        HRESULT ( STDMETHODCALLTYPE *GetPreroll )( 
            IMediaSeeking * This,
            /* [out] */ LONGLONG *pllPreroll);
        
        END_INTERFACE
    } IMediaSeekingVtbl;

    interface IMediaSeeking
    {
        CONST_VTBL struct IMediaSeekingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaSeeking_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMediaSeeking_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMediaSeeking_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMediaSeeking_GetCapabilities(This,pCapabilities)	\
    ( (This)->lpVtbl -> GetCapabilities(This,pCapabilities) ) 

#define IMediaSeeking_CheckCapabilities(This,pCapabilities)	\
    ( (This)->lpVtbl -> CheckCapabilities(This,pCapabilities) ) 

#define IMediaSeeking_IsFormatSupported(This,pFormat)	\
    ( (This)->lpVtbl -> IsFormatSupported(This,pFormat) ) 

#define IMediaSeeking_QueryPreferredFormat(This,pFormat)	\
    ( (This)->lpVtbl -> QueryPreferredFormat(This,pFormat) ) 

#define IMediaSeeking_GetTimeFormat(This,pFormat)	\
    ( (This)->lpVtbl -> GetTimeFormat(This,pFormat) ) 

#define IMediaSeeking_IsUsingTimeFormat(This,pFormat)	\
    ( (This)->lpVtbl -> IsUsingTimeFormat(This,pFormat) ) 

#define IMediaSeeking_SetTimeFormat(This,pFormat)	\
    ( (This)->lpVtbl -> SetTimeFormat(This,pFormat) ) 

#define IMediaSeeking_GetDuration(This,pDuration)	\
    ( (This)->lpVtbl -> GetDuration(This,pDuration) ) 

#define IMediaSeeking_GetStopPosition(This,pStop)	\
    ( (This)->lpVtbl -> GetStopPosition(This,pStop) ) 

#define IMediaSeeking_GetCurrentPosition(This,pCurrent)	\
    ( (This)->lpVtbl -> GetCurrentPosition(This,pCurrent) ) 

#define IMediaSeeking_ConvertTimeFormat(This,pTarget,pTargetFormat,Source,pSourceFormat)	\
    ( (This)->lpVtbl -> ConvertTimeFormat(This,pTarget,pTargetFormat,Source,pSourceFormat) ) 

#define IMediaSeeking_SetPositions(This,pCurrent,dwCurrentFlags,pStop,dwStopFlags)	\
    ( (This)->lpVtbl -> SetPositions(This,pCurrent,dwCurrentFlags,pStop,dwStopFlags) ) 

#define IMediaSeeking_GetPositions(This,pCurrent,pStop)	\
    ( (This)->lpVtbl -> GetPositions(This,pCurrent,pStop) ) 

#define IMediaSeeking_GetAvailable(This,pEarliest,pLatest)	\
    ( (This)->lpVtbl -> GetAvailable(This,pEarliest,pLatest) ) 

#define IMediaSeeking_SetRate(This,dRate)	\
    ( (This)->lpVtbl -> SetRate(This,dRate) ) 

#define IMediaSeeking_GetRate(This,pdRate)	\
    ( (This)->lpVtbl -> GetRate(This,pdRate) ) 

#define IMediaSeeking_GetPreroll(This,pllPreroll)	\
    ( (This)->lpVtbl -> GetPreroll(This,pllPreroll) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMediaSeeking_INTERFACE_DEFINED__ */


#ifndef __IAudioRenderer_INTERFACE_DEFINED__
#define __IAudioRenderer_INTERFACE_DEFINED__

/* interface IAudioRenderer */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAudioRenderer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("86612576-6b0a-4033-8374-edbdc59ac25c")
    IAudioRenderer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetDriftRate( 
            /* [in] */ DOUBLE dwRate) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAudioRendererVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAudioRenderer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAudioRenderer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAudioRenderer * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDriftRate )( 
            IAudioRenderer * This,
            /* [in] */ DOUBLE dwRate);
        
        END_INTERFACE
    } IAudioRendererVtbl;

    interface IAudioRenderer
    {
        CONST_VTBL struct IAudioRendererVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAudioRenderer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAudioRenderer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAudioRenderer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAudioRenderer_SetDriftRate(This,dwRate)	\
    ( (This)->lpVtbl -> SetDriftRate(This,dwRate) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAudioRenderer_INTERFACE_DEFINED__ */


#ifndef __IAudioRendererWaveOut_INTERFACE_DEFINED__
#define __IAudioRendererWaveOut_INTERFACE_DEFINED__

/* interface IAudioRendererWaveOut */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAudioRendererWaveOut;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8244a79e-9986-4187-abcb-3a69542f7cc7")
    IAudioRendererWaveOut : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SendMessage( 
            /* [in] */ UINT uMsg,
            /* [in] */ DWORD dw1,
            /* [in] */ DWORD dw2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAudioRendererWaveOutVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAudioRendererWaveOut * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAudioRendererWaveOut * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAudioRendererWaveOut * This);
        
        HRESULT ( STDMETHODCALLTYPE *SendMessage )( 
            IAudioRendererWaveOut * This,
            /* [in] */ UINT uMsg,
            /* [in] */ DWORD dw1,
            /* [in] */ DWORD dw2);
        
        END_INTERFACE
    } IAudioRendererWaveOutVtbl;

    interface IAudioRendererWaveOut
    {
        CONST_VTBL struct IAudioRendererWaveOutVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAudioRendererWaveOut_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAudioRendererWaveOut_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAudioRendererWaveOut_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAudioRendererWaveOut_SendMessage(This,uMsg,dw1,dw2)	\
    ( (This)->lpVtbl -> SendMessage(This,uMsg,dw1,dw2) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAudioRendererWaveOut_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0019 */
/* [local] */ 

typedef IMediaSeeking *PMEDIASEEKING;

enum tagAM_MEDIAEVENT_FLAGS
{
    AM_MEDIAEVENT_NONOTIFY = 0x01
};
typedef /* [public][public] */ struct __MIDL___MIDL_itf_strmif_0000_0019_0001
    {
    CLSID clsid;
    WCHAR achName[ 128 ];
    BOOL bDMO;
    } 	FilterCreationInfo;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0019_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0019_v0_0_s_ifspec;

#ifndef __IFilterGraphCache_INTERFACE_DEFINED__
#define __IFilterGraphCache_INTERFACE_DEFINED__

/* interface IFilterGraphCache */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IFilterGraphCache;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1D8C7CBF-F1D4-461b-B737-7384EA690710")
    IFilterGraphCache : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ClearGraphCache( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddFiltersToGraphCache( 
            /* [in] */ IBaseFilter *pSourceFilter,
            /* [in] */ WCHAR *pExtension) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFiltersFromGraphCache( 
            /* [in] */ GUID *pType,
            /* [in] */ GUID *pSubtype,
            /* [in] */ WCHAR *pExtension,
            /* [out] */ FilterCreationInfo *pFilterInfo,
            /* [out][in] */ DWORD *pcFilterInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFilterGraphCacheVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFilterGraphCache * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFilterGraphCache * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFilterGraphCache * This);
        
        HRESULT ( STDMETHODCALLTYPE *ClearGraphCache )( 
            IFilterGraphCache * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddFiltersToGraphCache )( 
            IFilterGraphCache * This,
            /* [in] */ IBaseFilter *pSourceFilter,
            /* [in] */ WCHAR *pExtension);
        
        HRESULT ( STDMETHODCALLTYPE *GetFiltersFromGraphCache )( 
            IFilterGraphCache * This,
            /* [in] */ GUID *pType,
            /* [in] */ GUID *pSubtype,
            /* [in] */ WCHAR *pExtension,
            /* [out] */ FilterCreationInfo *pFilterInfo,
            /* [out][in] */ DWORD *pcFilterInfo);
        
        END_INTERFACE
    } IFilterGraphCacheVtbl;

    interface IFilterGraphCache
    {
        CONST_VTBL struct IFilterGraphCacheVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFilterGraphCache_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFilterGraphCache_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFilterGraphCache_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFilterGraphCache_ClearGraphCache(This)	\
    ( (This)->lpVtbl -> ClearGraphCache(This) ) 

#define IFilterGraphCache_AddFiltersToGraphCache(This,pSourceFilter,pExtension)	\
    ( (This)->lpVtbl -> AddFiltersToGraphCache(This,pSourceFilter,pExtension) ) 

#define IFilterGraphCache_GetFiltersFromGraphCache(This,pType,pSubtype,pExtension,pFilterInfo,pcFilterInfo)	\
    ( (This)->lpVtbl -> GetFiltersFromGraphCache(This,pType,pSubtype,pExtension,pFilterInfo,pcFilterInfo) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFilterGraphCache_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0020 */
/* [local] */ 











































typedef /* [public][public] */ struct __MIDL___MIDL_itf_strmif_0000_0020_0001
    {
    CLSID Clsid;
    LPWSTR Name;
    } 	REGFILTER;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0020_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0020_v0_0_s_ifspec;

#ifndef __IEnumRegFilters_INTERFACE_DEFINED__
#define __IEnumRegFilters_INTERFACE_DEFINED__

/* interface IEnumRegFilters */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumRegFilters;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868a4-0ad4-11ce-b03a-0020af0ba770")
    IEnumRegFilters : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cFilters,
            /* [out] */ REGFILTER **apRegFilter,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cFilters) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumRegFilters **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRegFiltersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumRegFilters * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumRegFilters * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumRegFilters * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumRegFilters * This,
            /* [in] */ ULONG cFilters,
            /* [out] */ REGFILTER **apRegFilter,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumRegFilters * This,
            /* [in] */ ULONG cFilters);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumRegFilters * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumRegFilters * This,
            /* [out] */ IEnumRegFilters **ppEnum);
        
        END_INTERFACE
    } IEnumRegFiltersVtbl;

    interface IEnumRegFilters
    {
        CONST_VTBL struct IEnumRegFiltersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRegFilters_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumRegFilters_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumRegFilters_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumRegFilters_Next(This,cFilters,apRegFilter,pcFetched)	\
    ( (This)->lpVtbl -> Next(This,cFilters,apRegFilter,pcFetched) ) 

#define IEnumRegFilters_Skip(This,cFilters)	\
    ( (This)->lpVtbl -> Skip(This,cFilters) ) 

#define IEnumRegFilters_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumRegFilters_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumRegFilters_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0021 */
/* [local] */ 

typedef IEnumRegFilters *PENUMREGFILTERS;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0021_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0021_v0_0_s_ifspec;

#ifndef __IFilterMapper_INTERFACE_DEFINED__
#define __IFilterMapper_INTERFACE_DEFINED__

/* interface IFilterMapper */
/* [unique][uuid][object] */ 


enum __MIDL_IFilterMapper_0001
    {	MERIT_PREFERRED	= 0x800000,
	MERIT_NORMAL	= 0x600000,
	MERIT_UNLIKELY	= 0x400000,
	MERIT_DO_NOT_USE	= 0x200000,
	MERIT_SW_COMPRESSOR	= 0x100000,
	MERIT_HW_COMPRESSOR	= 0x100050
    } ;

EXTERN_C const IID IID_IFilterMapper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868a3-0ad4-11ce-b03a-0020af0ba770")
    IFilterMapper : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterFilter( 
            /* [in] */ CLSID clsid,
            /* [in] */ LPCWSTR Name,
            /* [in] */ DWORD dwMerit) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterFilterInstance( 
            /* [in] */ CLSID clsid,
            /* [in] */ LPCWSTR Name,
            /* [out] */ CLSID *MRId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterPin( 
            /* [in] */ CLSID Filter,
            /* [in] */ LPCWSTR Name,
            /* [in] */ BOOL bRendered,
            /* [in] */ BOOL bOutput,
            /* [in] */ BOOL bZero,
            /* [in] */ BOOL bMany,
            /* [in] */ CLSID ConnectsToFilter,
            /* [in] */ LPCWSTR ConnectsToPin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterPinType( 
            /* [in] */ CLSID clsFilter,
            /* [in] */ LPCWSTR strName,
            /* [in] */ CLSID clsMajorType,
            /* [in] */ CLSID clsSubType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterFilter( 
            /* [in] */ CLSID Filter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterFilterInstance( 
            /* [in] */ CLSID MRId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterPin( 
            /* [in] */ CLSID Filter,
            /* [in] */ LPCWSTR Name) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumMatchingFilters( 
            /* [out] */ IEnumRegFilters **ppEnum,
            /* [in] */ DWORD dwMerit,
            /* [in] */ BOOL bInputNeeded,
            /* [in] */ CLSID clsInMaj,
            /* [in] */ CLSID clsInSub,
            /* [in] */ BOOL bRender,
            /* [in] */ BOOL bOututNeeded,
            /* [in] */ CLSID clsOutMaj,
            /* [in] */ CLSID clsOutSub) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFilterMapperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFilterMapper * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFilterMapper * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFilterMapper * This);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterFilter )( 
            IFilterMapper * This,
            /* [in] */ CLSID clsid,
            /* [in] */ LPCWSTR Name,
            /* [in] */ DWORD dwMerit);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterFilterInstance )( 
            IFilterMapper * This,
            /* [in] */ CLSID clsid,
            /* [in] */ LPCWSTR Name,
            /* [out] */ CLSID *MRId);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterPin )( 
            IFilterMapper * This,
            /* [in] */ CLSID Filter,
            /* [in] */ LPCWSTR Name,
            /* [in] */ BOOL bRendered,
            /* [in] */ BOOL bOutput,
            /* [in] */ BOOL bZero,
            /* [in] */ BOOL bMany,
            /* [in] */ CLSID ConnectsToFilter,
            /* [in] */ LPCWSTR ConnectsToPin);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterPinType )( 
            IFilterMapper * This,
            /* [in] */ CLSID clsFilter,
            /* [in] */ LPCWSTR strName,
            /* [in] */ CLSID clsMajorType,
            /* [in] */ CLSID clsSubType);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterFilter )( 
            IFilterMapper * This,
            /* [in] */ CLSID Filter);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterFilterInstance )( 
            IFilterMapper * This,
            /* [in] */ CLSID MRId);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterPin )( 
            IFilterMapper * This,
            /* [in] */ CLSID Filter,
            /* [in] */ LPCWSTR Name);
        
        HRESULT ( STDMETHODCALLTYPE *EnumMatchingFilters )( 
            IFilterMapper * This,
            /* [out] */ IEnumRegFilters **ppEnum,
            /* [in] */ DWORD dwMerit,
            /* [in] */ BOOL bInputNeeded,
            /* [in] */ CLSID clsInMaj,
            /* [in] */ CLSID clsInSub,
            /* [in] */ BOOL bRender,
            /* [in] */ BOOL bOututNeeded,
            /* [in] */ CLSID clsOutMaj,
            /* [in] */ CLSID clsOutSub);
        
        END_INTERFACE
    } IFilterMapperVtbl;

    interface IFilterMapper
    {
        CONST_VTBL struct IFilterMapperVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFilterMapper_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFilterMapper_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFilterMapper_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFilterMapper_RegisterFilter(This,clsid,Name,dwMerit)	\
    ( (This)->lpVtbl -> RegisterFilter(This,clsid,Name,dwMerit) ) 

#define IFilterMapper_RegisterFilterInstance(This,clsid,Name,MRId)	\
    ( (This)->lpVtbl -> RegisterFilterInstance(This,clsid,Name,MRId) ) 

#define IFilterMapper_RegisterPin(This,Filter,Name,bRendered,bOutput,bZero,bMany,ConnectsToFilter,ConnectsToPin)	\
    ( (This)->lpVtbl -> RegisterPin(This,Filter,Name,bRendered,bOutput,bZero,bMany,ConnectsToFilter,ConnectsToPin) ) 

#define IFilterMapper_RegisterPinType(This,clsFilter,strName,clsMajorType,clsSubType)	\
    ( (This)->lpVtbl -> RegisterPinType(This,clsFilter,strName,clsMajorType,clsSubType) ) 

#define IFilterMapper_UnregisterFilter(This,Filter)	\
    ( (This)->lpVtbl -> UnregisterFilter(This,Filter) ) 

#define IFilterMapper_UnregisterFilterInstance(This,MRId)	\
    ( (This)->lpVtbl -> UnregisterFilterInstance(This,MRId) ) 

#define IFilterMapper_UnregisterPin(This,Filter,Name)	\
    ( (This)->lpVtbl -> UnregisterPin(This,Filter,Name) ) 

#define IFilterMapper_EnumMatchingFilters(This,ppEnum,dwMerit,bInputNeeded,clsInMaj,clsInSub,bRender,bOututNeeded,clsOutMaj,clsOutSub)	\
    ( (This)->lpVtbl -> EnumMatchingFilters(This,ppEnum,dwMerit,bInputNeeded,clsInMaj,clsInSub,bRender,bOututNeeded,clsOutMaj,clsOutSub) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFilterMapper_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0022 */
/* [local] */ 

typedef /* [public][public] */ struct __MIDL___MIDL_itf_strmif_0000_0022_0001
    {
    const CLSID *clsMajorType;
    const CLSID *clsMinorType;
    } 	REGPINTYPES;

typedef /* [public] */ struct __MIDL___MIDL_itf_strmif_0000_0022_0002
    {
    LPWSTR strName;
    BOOL bRendered;
    BOOL bOutput;
    BOOL bZero;
    BOOL bMany;
    const CLSID *clsConnectsToFilter;
    const WCHAR *strConnectsToPin;
    UINT nMediaTypes;
    const REGPINTYPES *lpMediaType;
    } 	REGFILTERPINS;

typedef 
enum tagQualityMessageType
    {	Famine	= 0,
	Flood	= ( Famine + 1 ) 
    } 	QualityMessageType;

typedef struct tagQuality
    {
    QualityMessageType Type;
    long Proportion;
    REFERENCE_TIME Late;
    REFERENCE_TIME TimeStamp;
    } 	Quality;

typedef IQualityControl *PQUALITYCONTROL;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0022_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0022_v0_0_s_ifspec;

#ifndef __IQualityControl_INTERFACE_DEFINED__
#define __IQualityControl_INTERFACE_DEFINED__

/* interface IQualityControl */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IQualityControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868a5-0ad4-11ce-b03a-0020af0ba770")
    IQualityControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ IBaseFilter *pSelf,
            /* [in] */ Quality q) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSink( 
            /* [in] */ IQualityControl *piqc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IQualityControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IQualityControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IQualityControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IQualityControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *Notify )( 
            IQualityControl * This,
            /* [in] */ IBaseFilter *pSelf,
            /* [in] */ Quality q);
        
        HRESULT ( STDMETHODCALLTYPE *SetSink )( 
            IQualityControl * This,
            /* [in] */ IQualityControl *piqc);
        
        END_INTERFACE
    } IQualityControlVtbl;

    interface IQualityControl
    {
        CONST_VTBL struct IQualityControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IQualityControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IQualityControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IQualityControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IQualityControl_Notify(This,pSelf,q)	\
    ( (This)->lpVtbl -> Notify(This,pSelf,q) ) 

#define IQualityControl_SetSink(This,piqc)	\
    ( (This)->lpVtbl -> SetSink(This,piqc) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IQualityControl_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0023 */
/* [local] */ 


enum __MIDL___MIDL_itf_strmif_0000_0023_0001
    {	CK_NOCOLORKEY	= 0,
	CK_INDEX	= 0x1,
	CK_RGB	= 0x2
    } ;
typedef struct tagCOLORKEY
    {
    DWORD KeyType;
    DWORD PaletteIndex;
    COLORREF LowColorValue;
    COLORREF HighColorValue;
    } 	COLORKEY;


enum __MIDL___MIDL_itf_strmif_0000_0023_0002
    {	ADVISE_NONE	= 0,
	ADVISE_CLIPPING	= 0x1,
	ADVISE_PALETTE	= 0x2,
	ADVISE_COLORKEY	= 0x4,
	ADVISE_POSITION	= 0x8,
	ADVISE_DISPLAY_CHANGE	= 0x10
    } ;
#define	ADVISE_ALL	( ( ( ( ADVISE_CLIPPING | ADVISE_PALETTE )  | ADVISE_COLORKEY )  | ADVISE_POSITION )  )

#define	ADVISE_ALL2	( ( ADVISE_ALL | ADVISE_DISPLAY_CHANGE )  )

#if !defined(_WINGDI_) && !defined(_WINGDI_H_)
typedef struct _RGNDATAHEADER
    {
    DWORD dwSize;
    DWORD iType;
    DWORD nCount;
    DWORD nRgnSize;
    RECT rcBound;
    } 	RGNDATAHEADER;

typedef struct _RGNDATA
    {
    RGNDATAHEADER rdh;
    char Buffer[ 1 ];
    } 	RGNDATA;

#endif


extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0023_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0023_v0_0_s_ifspec;

#ifndef __IOverlayNotify_INTERFACE_DEFINED__
#define __IOverlayNotify_INTERFACE_DEFINED__

/* interface IOverlayNotify */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IOverlayNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868a0-0ad4-11ce-b03a-0020af0ba770")
    IOverlayNotify : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnPaletteChange( 
            /* [in] */ DWORD dwColors,
            /* [in] */ const PALETTEENTRY *pPalette) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnClipChange( 
            /* [in] */ const RECT *pSourceRect,
            /* [in] */ const RECT *pDestinationRect,
            /* [in] */ const RGNDATA *pRgnData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnColorKeyChange( 
            /* [in] */ const COLORKEY *pColorKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnPositionChange( 
            /* [in] */ const RECT *pSourceRect,
            /* [in] */ const RECT *pDestinationRect) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOverlayNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IOverlayNotify * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IOverlayNotify * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IOverlayNotify * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnPaletteChange )( 
            IOverlayNotify * This,
            /* [in] */ DWORD dwColors,
            /* [in] */ const PALETTEENTRY *pPalette);
        
        HRESULT ( STDMETHODCALLTYPE *OnClipChange )( 
            IOverlayNotify * This,
            /* [in] */ const RECT *pSourceRect,
            /* [in] */ const RECT *pDestinationRect,
            /* [in] */ const RGNDATA *pRgnData);
        
        HRESULT ( STDMETHODCALLTYPE *OnColorKeyChange )( 
            IOverlayNotify * This,
            /* [in] */ const COLORKEY *pColorKey);
        
        HRESULT ( STDMETHODCALLTYPE *OnPositionChange )( 
            IOverlayNotify * This,
            /* [in] */ const RECT *pSourceRect,
            /* [in] */ const RECT *pDestinationRect);
        
        END_INTERFACE
    } IOverlayNotifyVtbl;

    interface IOverlayNotify
    {
        CONST_VTBL struct IOverlayNotifyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOverlayNotify_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IOverlayNotify_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IOverlayNotify_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IOverlayNotify_OnPaletteChange(This,dwColors,pPalette)	\
    ( (This)->lpVtbl -> OnPaletteChange(This,dwColors,pPalette) ) 

#define IOverlayNotify_OnClipChange(This,pSourceRect,pDestinationRect,pRgnData)	\
    ( (This)->lpVtbl -> OnClipChange(This,pSourceRect,pDestinationRect,pRgnData) ) 

#define IOverlayNotify_OnColorKeyChange(This,pColorKey)	\
    ( (This)->lpVtbl -> OnColorKeyChange(This,pColorKey) ) 

#define IOverlayNotify_OnPositionChange(This,pSourceRect,pDestinationRect)	\
    ( (This)->lpVtbl -> OnPositionChange(This,pSourceRect,pDestinationRect) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IOverlayNotify_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0024 */
/* [local] */ 

typedef IOverlayNotify *POVERLAYNOTIFY;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0024_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0024_v0_0_s_ifspec;

#ifndef __IOverlay_INTERFACE_DEFINED__
#define __IOverlay_INTERFACE_DEFINED__

/* interface IOverlay */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IOverlay;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868a1-0ad4-11ce-b03a-0020af0ba770")
    IOverlay : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPalette( 
            /* [out] */ DWORD *pdwColors,
            /* [out] */ PALETTEENTRY **ppPalette) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPalette( 
            /* [in] */ DWORD dwColors,
            /* [in] */ PALETTEENTRY *pPalette) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultColorKey( 
            /* [out] */ COLORKEY *pColorKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColorKey( 
            /* [out] */ COLORKEY *pColorKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetColorKey( 
            /* [out][in] */ COLORKEY *pColorKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWindowHandle( 
            /* [out] */ HWND *pHwnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClipList( 
            /* [out] */ RECT *pSourceRect,
            /* [out] */ RECT *pDestinationRect,
            /* [out] */ RGNDATA **ppRgnData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVideoPosition( 
            /* [out] */ RECT *pSourceRect,
            /* [out] */ RECT *pDestinationRect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Advise( 
            /* [in] */ IOverlayNotify *pOverlayNotify,
            /* [in] */ DWORD dwInterests) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unadvise( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOverlayVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IOverlay * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IOverlay * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IOverlay * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPalette )( 
            IOverlay * This,
            /* [out] */ DWORD *pdwColors,
            /* [out] */ PALETTEENTRY **ppPalette);
        
        HRESULT ( STDMETHODCALLTYPE *SetPalette )( 
            IOverlay * This,
            /* [in] */ DWORD dwColors,
            /* [in] */ PALETTEENTRY *pPalette);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultColorKey )( 
            IOverlay * This,
            /* [out] */ COLORKEY *pColorKey);
        
        HRESULT ( STDMETHODCALLTYPE *GetColorKey )( 
            IOverlay * This,
            /* [out] */ COLORKEY *pColorKey);
        
        HRESULT ( STDMETHODCALLTYPE *SetColorKey )( 
            IOverlay * This,
            /* [out][in] */ COLORKEY *pColorKey);
        
        HRESULT ( STDMETHODCALLTYPE *GetWindowHandle )( 
            IOverlay * This,
            /* [out] */ HWND *pHwnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetClipList )( 
            IOverlay * This,
            /* [out] */ RECT *pSourceRect,
            /* [out] */ RECT *pDestinationRect,
            /* [out] */ RGNDATA **ppRgnData);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoPosition )( 
            IOverlay * This,
            /* [out] */ RECT *pSourceRect,
            /* [out] */ RECT *pDestinationRect);
        
        HRESULT ( STDMETHODCALLTYPE *Advise )( 
            IOverlay * This,
            /* [in] */ IOverlayNotify *pOverlayNotify,
            /* [in] */ DWORD dwInterests);
        
        HRESULT ( STDMETHODCALLTYPE *Unadvise )( 
            IOverlay * This);
        
        END_INTERFACE
    } IOverlayVtbl;

    interface IOverlay
    {
        CONST_VTBL struct IOverlayVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOverlay_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IOverlay_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IOverlay_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IOverlay_GetPalette(This,pdwColors,ppPalette)	\
    ( (This)->lpVtbl -> GetPalette(This,pdwColors,ppPalette) ) 

#define IOverlay_SetPalette(This,dwColors,pPalette)	\
    ( (This)->lpVtbl -> SetPalette(This,dwColors,pPalette) ) 

#define IOverlay_GetDefaultColorKey(This,pColorKey)	\
    ( (This)->lpVtbl -> GetDefaultColorKey(This,pColorKey) ) 

#define IOverlay_GetColorKey(This,pColorKey)	\
    ( (This)->lpVtbl -> GetColorKey(This,pColorKey) ) 

#define IOverlay_SetColorKey(This,pColorKey)	\
    ( (This)->lpVtbl -> SetColorKey(This,pColorKey) ) 

#define IOverlay_GetWindowHandle(This,pHwnd)	\
    ( (This)->lpVtbl -> GetWindowHandle(This,pHwnd) ) 

#define IOverlay_GetClipList(This,pSourceRect,pDestinationRect,ppRgnData)	\
    ( (This)->lpVtbl -> GetClipList(This,pSourceRect,pDestinationRect,ppRgnData) ) 

#define IOverlay_GetVideoPosition(This,pSourceRect,pDestinationRect)	\
    ( (This)->lpVtbl -> GetVideoPosition(This,pSourceRect,pDestinationRect) ) 

#define IOverlay_Advise(This,pOverlayNotify,dwInterests)	\
    ( (This)->lpVtbl -> Advise(This,pOverlayNotify,dwInterests) ) 

#define IOverlay_Unadvise(This)	\
    ( (This)->lpVtbl -> Unadvise(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IOverlay_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0025 */
/* [local] */ 

typedef IOverlay *POVERLAY;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0025_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0025_v0_0_s_ifspec;

#ifndef __IMediaEventSink_INTERFACE_DEFINED__
#define __IMediaEventSink_INTERFACE_DEFINED__

/* interface IMediaEventSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IMediaEventSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868a2-0ad4-11ce-b03a-0020af0ba770")
    IMediaEventSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ long EventCode,
            /* [in] */ LONG_PTR EventParam1,
            /* [in] */ LONG_PTR EventParam2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaEventSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaEventSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaEventSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaEventSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *Notify )( 
            IMediaEventSink * This,
            /* [in] */ long EventCode,
            /* [in] */ LONG_PTR EventParam1,
            /* [in] */ LONG_PTR EventParam2);
        
        END_INTERFACE
    } IMediaEventSinkVtbl;

    interface IMediaEventSink
    {
        CONST_VTBL struct IMediaEventSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaEventSink_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMediaEventSink_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMediaEventSink_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMediaEventSink_Notify(This,EventCode,EventParam1,EventParam2)	\
    ( (This)->lpVtbl -> Notify(This,EventCode,EventParam1,EventParam2) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMediaEventSink_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0026 */
/* [local] */ 

typedef IMediaEventSink *PMEDIAEVENTSINK;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0026_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0026_v0_0_s_ifspec;

#ifndef __IFileSourceFilter_INTERFACE_DEFINED__
#define __IFileSourceFilter_INTERFACE_DEFINED__

/* interface IFileSourceFilter */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IFileSourceFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868a6-0ad4-11ce-b03a-0020af0ba770")
    IFileSourceFilter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Load( 
            /* [in] */ LPCOLESTR pszFileName,
            /* [in] */ const AM_MEDIA_TYPE *pmt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurFile( 
            /* [out] */ LPOLESTR *ppszFileName,
            /* [out] */ AM_MEDIA_TYPE *pmt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFileSourceFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFileSourceFilter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFileSourceFilter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFileSourceFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *Load )( 
            IFileSourceFilter * This,
            /* [in] */ LPCOLESTR pszFileName,
            /* [in] */ const AM_MEDIA_TYPE *pmt);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurFile )( 
            IFileSourceFilter * This,
            /* [out] */ LPOLESTR *ppszFileName,
            /* [out] */ AM_MEDIA_TYPE *pmt);
        
        END_INTERFACE
    } IFileSourceFilterVtbl;

    interface IFileSourceFilter
    {
        CONST_VTBL struct IFileSourceFilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFileSourceFilter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFileSourceFilter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFileSourceFilter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFileSourceFilter_Load(This,pszFileName,pmt)	\
    ( (This)->lpVtbl -> Load(This,pszFileName,pmt) ) 

#define IFileSourceFilter_GetCurFile(This,ppszFileName,pmt)	\
    ( (This)->lpVtbl -> GetCurFile(This,ppszFileName,pmt) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFileSourceFilter_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0027 */
/* [local] */ 

typedef IFileSourceFilter *PFILTERFILESOURCE;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0027_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0027_v0_0_s_ifspec;

#ifndef __IFileSinkFilter_INTERFACE_DEFINED__
#define __IFileSinkFilter_INTERFACE_DEFINED__

/* interface IFileSinkFilter */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IFileSinkFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a2104830-7c70-11cf-8bce-00aa00a3f1a6")
    IFileSinkFilter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFileName( 
            /* [in] */ LPCOLESTR pszFileName,
            /* [in] */ const AM_MEDIA_TYPE *pmt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurFile( 
            /* [out] */ LPOLESTR *ppszFileName,
            /* [out] */ AM_MEDIA_TYPE *pmt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFileSinkFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFileSinkFilter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFileSinkFilter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFileSinkFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFileName )( 
            IFileSinkFilter * This,
            /* [in] */ LPCOLESTR pszFileName,
            /* [in] */ const AM_MEDIA_TYPE *pmt);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurFile )( 
            IFileSinkFilter * This,
            /* [out] */ LPOLESTR *ppszFileName,
            /* [out] */ AM_MEDIA_TYPE *pmt);
        
        END_INTERFACE
    } IFileSinkFilterVtbl;

    interface IFileSinkFilter
    {
        CONST_VTBL struct IFileSinkFilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFileSinkFilter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFileSinkFilter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFileSinkFilter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFileSinkFilter_SetFileName(This,pszFileName,pmt)	\
    ( (This)->lpVtbl -> SetFileName(This,pszFileName,pmt) ) 

#define IFileSinkFilter_GetCurFile(This,ppszFileName,pmt)	\
    ( (This)->lpVtbl -> GetCurFile(This,ppszFileName,pmt) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFileSinkFilter_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0028 */
/* [local] */ 

typedef IFileSinkFilter *PFILTERFILESINK;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0028_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0028_v0_0_s_ifspec;

#ifndef __IFileSinkFilter2_INTERFACE_DEFINED__
#define __IFileSinkFilter2_INTERFACE_DEFINED__

/* interface IFileSinkFilter2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IFileSinkFilter2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00855B90-CE1B-11d0-BD4F-00A0C911CE86")
    IFileSinkFilter2 : public IFileSinkFilter
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetMode( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMode( 
            /* [out] */ DWORD *pdwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFileSinkFilter2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFileSinkFilter2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFileSinkFilter2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFileSinkFilter2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFileName )( 
            IFileSinkFilter2 * This,
            /* [in] */ LPCOLESTR pszFileName,
            /* [in] */ const AM_MEDIA_TYPE *pmt);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurFile )( 
            IFileSinkFilter2 * This,
            /* [out] */ LPOLESTR *ppszFileName,
            /* [out] */ AM_MEDIA_TYPE *pmt);
        
        HRESULT ( STDMETHODCALLTYPE *SetMode )( 
            IFileSinkFilter2 * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetMode )( 
            IFileSinkFilter2 * This,
            /* [out] */ DWORD *pdwFlags);
        
        END_INTERFACE
    } IFileSinkFilter2Vtbl;

    interface IFileSinkFilter2
    {
        CONST_VTBL struct IFileSinkFilter2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFileSinkFilter2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFileSinkFilter2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFileSinkFilter2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFileSinkFilter2_SetFileName(This,pszFileName,pmt)	\
    ( (This)->lpVtbl -> SetFileName(This,pszFileName,pmt) ) 

#define IFileSinkFilter2_GetCurFile(This,ppszFileName,pmt)	\
    ( (This)->lpVtbl -> GetCurFile(This,ppszFileName,pmt) ) 


#define IFileSinkFilter2_SetMode(This,dwFlags)	\
    ( (This)->lpVtbl -> SetMode(This,dwFlags) ) 

#define IFileSinkFilter2_GetMode(This,pdwFlags)	\
    ( (This)->lpVtbl -> GetMode(This,pdwFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFileSinkFilter2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0029 */
/* [local] */ 

typedef IFileSinkFilter2 *PFILESINKFILTER2;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_strmif_0000_0029_0001
    {	AM_FILE_OVERWRITE	= 0x1,
	AM_FILE_TEMPLATE	= 0x2
    } 	AM_FILESINK_FLAGS;

typedef struct _AsyncIOReq
    {
    DWORD engine[ 4 ];
    BYTE *lpv;
    DWORD cb;
    DWORD dwError;
    DWORD cbDone;
    LARGE_INTEGER liPos;
    DWORD hEvent;
    DWORD_PTR dwUser;
    } 	AsyncIOReq;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0029_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0029_v0_0_s_ifspec;

#ifndef __IFileAsyncIO_INTERFACE_DEFINED__
#define __IFileAsyncIO_INTERFACE_DEFINED__

/* interface IFileAsyncIO */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IFileAsyncIO;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868a7-0ad4-11ce-b03a-0020af0ba770")
    IFileAsyncIO : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryAlignment( 
            /* [out] */ LPDWORD pdwAlign) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Read( 
            /* [in] */ AsyncIOReq *pReq) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Write( 
            /* [in] */ AsyncIOReq *pReq) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WaitForNext( 
            /* [out] */ AsyncIOReq **ppReq,
            /* [in] */ DWORD dwTimeout) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WaitForSpecific( 
            /* [out] */ AsyncIOReq *pReq,
            /* [in] */ DWORD dwTimeout) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DiscardPending( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Flush( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFileAsyncIOVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFileAsyncIO * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFileAsyncIO * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFileAsyncIO * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryAlignment )( 
            IFileAsyncIO * This,
            /* [out] */ LPDWORD pdwAlign);
        
        HRESULT ( STDMETHODCALLTYPE *Read )( 
            IFileAsyncIO * This,
            /* [in] */ AsyncIOReq *pReq);
        
        HRESULT ( STDMETHODCALLTYPE *Write )( 
            IFileAsyncIO * This,
            /* [in] */ AsyncIOReq *pReq);
        
        HRESULT ( STDMETHODCALLTYPE *WaitForNext )( 
            IFileAsyncIO * This,
            /* [out] */ AsyncIOReq **ppReq,
            /* [in] */ DWORD dwTimeout);
        
        HRESULT ( STDMETHODCALLTYPE *WaitForSpecific )( 
            IFileAsyncIO * This,
            /* [out] */ AsyncIOReq *pReq,
            /* [in] */ DWORD dwTimeout);
        
        HRESULT ( STDMETHODCALLTYPE *DiscardPending )( 
            IFileAsyncIO * This);
        
        HRESULT ( STDMETHODCALLTYPE *Flush )( 
            IFileAsyncIO * This);
        
        END_INTERFACE
    } IFileAsyncIOVtbl;

    interface IFileAsyncIO
    {
        CONST_VTBL struct IFileAsyncIOVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFileAsyncIO_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFileAsyncIO_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFileAsyncIO_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFileAsyncIO_QueryAlignment(This,pdwAlign)	\
    ( (This)->lpVtbl -> QueryAlignment(This,pdwAlign) ) 

#define IFileAsyncIO_Read(This,pReq)	\
    ( (This)->lpVtbl -> Read(This,pReq) ) 

#define IFileAsyncIO_Write(This,pReq)	\
    ( (This)->lpVtbl -> Write(This,pReq) ) 

#define IFileAsyncIO_WaitForNext(This,ppReq,dwTimeout)	\
    ( (This)->lpVtbl -> WaitForNext(This,ppReq,dwTimeout) ) 

#define IFileAsyncIO_WaitForSpecific(This,pReq,dwTimeout)	\
    ( (This)->lpVtbl -> WaitForSpecific(This,pReq,dwTimeout) ) 

#define IFileAsyncIO_DiscardPending(This)	\
    ( (This)->lpVtbl -> DiscardPending(This) ) 

#define IFileAsyncIO_Flush(This)	\
    ( (This)->lpVtbl -> Flush(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFileAsyncIO_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0030 */
/* [local] */ 

typedef IFileAsyncIO *PFILEASYNCIO;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0030_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0030_v0_0_s_ifspec;

#ifndef __IGraphBuilder_INTERFACE_DEFINED__
#define __IGraphBuilder_INTERFACE_DEFINED__

/* interface IGraphBuilder */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IGraphBuilder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868a9-0ad4-11ce-b03a-0020af0ba770")
    IGraphBuilder : public IFilterGraph
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ IPin *ppinOut,
            /* [in] */ IPin *ppinIn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Render( 
            /* [in] */ IPin *ppinOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RenderFile( 
            /* [in] */ LPCWSTR lpcwstrFile,
            /* [in] */ LPCWSTR lpcwstrPlayList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddSourceFilter( 
            /* [in] */ LPCWSTR lpcwstrFileName,
            /* [in] */ LPCWSTR lpcwstrFilterName,
            /* [out] */ IBaseFilter **ppFilter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLogFile( 
            /* [in] */ HANDLE hFile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Abort( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShouldOperationContinue( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGraphBuilderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGraphBuilder * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGraphBuilder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGraphBuilder * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddFilter )( 
            IGraphBuilder * This,
            /* [in] */ IBaseFilter *pFilter,
            /* [string][in] */ LPCWSTR pName);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveFilter )( 
            IGraphBuilder * This,
            /* [in] */ IBaseFilter *pFilter);
        
        HRESULT ( STDMETHODCALLTYPE *EnumFilters )( 
            IGraphBuilder * This,
            /* [out] */ IEnumFilters **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *FindFilterByName )( 
            IGraphBuilder * This,
            /* [string][in] */ LPCWSTR pName,
            /* [out] */ IBaseFilter **ppFilter);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectDirect )( 
            IGraphBuilder * This,
            /* [in] */ IPin *ppinOut,
            /* [in] */ IPin *ppinIn,
            /* [in] */ const AM_MEDIA_TYPE *pmt);
        
        HRESULT ( STDMETHODCALLTYPE *Reconnect )( 
            IGraphBuilder * This,
            /* [in] */ IPin *ppin);
        
        HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            IGraphBuilder * This,
            /* [in] */ IPin *ppin);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultSyncSource )( 
            IGraphBuilder * This);
        
        HRESULT ( STDMETHODCALLTYPE *Connect )( 
            IGraphBuilder * This,
            /* [in] */ IPin *ppinOut,
            /* [in] */ IPin *ppinIn);
        
        HRESULT ( STDMETHODCALLTYPE *Render )( 
            IGraphBuilder * This,
            /* [in] */ IPin *ppinOut);
        
        HRESULT ( STDMETHODCALLTYPE *RenderFile )( 
            IGraphBuilder * This,
            /* [in] */ LPCWSTR lpcwstrFile,
            /* [in] */ LPCWSTR lpcwstrPlayList);
        
        HRESULT ( STDMETHODCALLTYPE *AddSourceFilter )( 
            IGraphBuilder * This,
            /* [in] */ LPCWSTR lpcwstrFileName,
            /* [in] */ LPCWSTR lpcwstrFilterName,
            /* [out] */ IBaseFilter **ppFilter);
        
        HRESULT ( STDMETHODCALLTYPE *SetLogFile )( 
            IGraphBuilder * This,
            /* [in] */ HANDLE hFile);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            IGraphBuilder * This);
        
        HRESULT ( STDMETHODCALLTYPE *ShouldOperationContinue )( 
            IGraphBuilder * This);
        
        END_INTERFACE
    } IGraphBuilderVtbl;

    interface IGraphBuilder
    {
        CONST_VTBL struct IGraphBuilderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGraphBuilder_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IGraphBuilder_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IGraphBuilder_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IGraphBuilder_AddFilter(This,pFilter,pName)	\
    ( (This)->lpVtbl -> AddFilter(This,pFilter,pName) ) 

#define IGraphBuilder_RemoveFilter(This,pFilter)	\
    ( (This)->lpVtbl -> RemoveFilter(This,pFilter) ) 

#define IGraphBuilder_EnumFilters(This,ppEnum)	\
    ( (This)->lpVtbl -> EnumFilters(This,ppEnum) ) 

#define IGraphBuilder_FindFilterByName(This,pName,ppFilter)	\
    ( (This)->lpVtbl -> FindFilterByName(This,pName,ppFilter) ) 

#define IGraphBuilder_ConnectDirect(This,ppinOut,ppinIn,pmt)	\
    ( (This)->lpVtbl -> ConnectDirect(This,ppinOut,ppinIn,pmt) ) 

#define IGraphBuilder_Reconnect(This,ppin)	\
    ( (This)->lpVtbl -> Reconnect(This,ppin) ) 

#define IGraphBuilder_Disconnect(This,ppin)	\
    ( (This)->lpVtbl -> Disconnect(This,ppin) ) 

#define IGraphBuilder_SetDefaultSyncSource(This)	\
    ( (This)->lpVtbl -> SetDefaultSyncSource(This) ) 


#define IGraphBuilder_Connect(This,ppinOut,ppinIn)	\
    ( (This)->lpVtbl -> Connect(This,ppinOut,ppinIn) ) 

#define IGraphBuilder_Render(This,ppinOut)	\
    ( (This)->lpVtbl -> Render(This,ppinOut) ) 

#define IGraphBuilder_RenderFile(This,lpcwstrFile,lpcwstrPlayList)	\
    ( (This)->lpVtbl -> RenderFile(This,lpcwstrFile,lpcwstrPlayList) ) 

#define IGraphBuilder_AddSourceFilter(This,lpcwstrFileName,lpcwstrFilterName,ppFilter)	\
    ( (This)->lpVtbl -> AddSourceFilter(This,lpcwstrFileName,lpcwstrFilterName,ppFilter) ) 

#define IGraphBuilder_SetLogFile(This,hFile)	\
    ( (This)->lpVtbl -> SetLogFile(This,hFile) ) 

#define IGraphBuilder_Abort(This)	\
    ( (This)->lpVtbl -> Abort(This) ) 

#define IGraphBuilder_ShouldOperationContinue(This)	\
    ( (This)->lpVtbl -> ShouldOperationContinue(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IGraphBuilder_INTERFACE_DEFINED__ */


#ifndef __IGraphBuilder2_INTERFACE_DEFINED__
#define __IGraphBuilder2_INTERFACE_DEFINED__

/* interface IGraphBuilder2 */
/* [unique][helpstring][uuid][local][object][local] */ 


EXTERN_C const IID IID_IGraphBuilder2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EC375955-317F-4b48-B206-C32AE2A37737")
    IGraphBuilder2 : public IGraphBuilder
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddFilterByCLSID( 
            /* [in] */ CLSID rclsid,
            /* [string][in] */ wchar_t *pwszFilterName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindInterfacesOnGraph( 
            /* [in] */ IID riid,
            /* [out] */ IEnumFilterInterfaces **ppEnumerator) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGraphBuilder2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGraphBuilder2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGraphBuilder2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGraphBuilder2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddFilter )( 
            IGraphBuilder2 * This,
            /* [in] */ IBaseFilter *pFilter,
            /* [string][in] */ LPCWSTR pName);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveFilter )( 
            IGraphBuilder2 * This,
            /* [in] */ IBaseFilter *pFilter);
        
        HRESULT ( STDMETHODCALLTYPE *EnumFilters )( 
            IGraphBuilder2 * This,
            /* [out] */ IEnumFilters **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *FindFilterByName )( 
            IGraphBuilder2 * This,
            /* [string][in] */ LPCWSTR pName,
            /* [out] */ IBaseFilter **ppFilter);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectDirect )( 
            IGraphBuilder2 * This,
            /* [in] */ IPin *ppinOut,
            /* [in] */ IPin *ppinIn,
            /* [in] */ const AM_MEDIA_TYPE *pmt);
        
        HRESULT ( STDMETHODCALLTYPE *Reconnect )( 
            IGraphBuilder2 * This,
            /* [in] */ IPin *ppin);
        
        HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            IGraphBuilder2 * This,
            /* [in] */ IPin *ppin);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultSyncSource )( 
            IGraphBuilder2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Connect )( 
            IGraphBuilder2 * This,
            /* [in] */ IPin *ppinOut,
            /* [in] */ IPin *ppinIn);
        
        HRESULT ( STDMETHODCALLTYPE *Render )( 
            IGraphBuilder2 * This,
            /* [in] */ IPin *ppinOut);
        
        HRESULT ( STDMETHODCALLTYPE *RenderFile )( 
            IGraphBuilder2 * This,
            /* [in] */ LPCWSTR lpcwstrFile,
            /* [in] */ LPCWSTR lpcwstrPlayList);
        
        HRESULT ( STDMETHODCALLTYPE *AddSourceFilter )( 
            IGraphBuilder2 * This,
            /* [in] */ LPCWSTR lpcwstrFileName,
            /* [in] */ LPCWSTR lpcwstrFilterName,
            /* [out] */ IBaseFilter **ppFilter);
        
        HRESULT ( STDMETHODCALLTYPE *SetLogFile )( 
            IGraphBuilder2 * This,
            /* [in] */ HANDLE hFile);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            IGraphBuilder2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ShouldOperationContinue )( 
            IGraphBuilder2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddFilterByCLSID )( 
            IGraphBuilder2 * This,
            /* [in] */ CLSID rclsid,
            /* [string][in] */ wchar_t *pwszFilterName);
        
        HRESULT ( STDMETHODCALLTYPE *FindInterfacesOnGraph )( 
            IGraphBuilder2 * This,
            /* [in] */ IID riid,
            /* [out] */ IEnumFilterInterfaces **ppEnumerator);
        
        END_INTERFACE
    } IGraphBuilder2Vtbl;

    interface IGraphBuilder2
    {
        CONST_VTBL struct IGraphBuilder2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGraphBuilder2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IGraphBuilder2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IGraphBuilder2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IGraphBuilder2_AddFilter(This,pFilter,pName)	\
    ( (This)->lpVtbl -> AddFilter(This,pFilter,pName) ) 

#define IGraphBuilder2_RemoveFilter(This,pFilter)	\
    ( (This)->lpVtbl -> RemoveFilter(This,pFilter) ) 

#define IGraphBuilder2_EnumFilters(This,ppEnum)	\
    ( (This)->lpVtbl -> EnumFilters(This,ppEnum) ) 

#define IGraphBuilder2_FindFilterByName(This,pName,ppFilter)	\
    ( (This)->lpVtbl -> FindFilterByName(This,pName,ppFilter) ) 

#define IGraphBuilder2_ConnectDirect(This,ppinOut,ppinIn,pmt)	\
    ( (This)->lpVtbl -> ConnectDirect(This,ppinOut,ppinIn,pmt) ) 

#define IGraphBuilder2_Reconnect(This,ppin)	\
    ( (This)->lpVtbl -> Reconnect(This,ppin) ) 

#define IGraphBuilder2_Disconnect(This,ppin)	\
    ( (This)->lpVtbl -> Disconnect(This,ppin) ) 

#define IGraphBuilder2_SetDefaultSyncSource(This)	\
    ( (This)->lpVtbl -> SetDefaultSyncSource(This) ) 


#define IGraphBuilder2_Connect(This,ppinOut,ppinIn)	\
    ( (This)->lpVtbl -> Connect(This,ppinOut,ppinIn) ) 

#define IGraphBuilder2_Render(This,ppinOut)	\
    ( (This)->lpVtbl -> Render(This,ppinOut) ) 

#define IGraphBuilder2_RenderFile(This,lpcwstrFile,lpcwstrPlayList)	\
    ( (This)->lpVtbl -> RenderFile(This,lpcwstrFile,lpcwstrPlayList) ) 

#define IGraphBuilder2_AddSourceFilter(This,lpcwstrFileName,lpcwstrFilterName,ppFilter)	\
    ( (This)->lpVtbl -> AddSourceFilter(This,lpcwstrFileName,lpcwstrFilterName,ppFilter) ) 

#define IGraphBuilder2_SetLogFile(This,hFile)	\
    ( (This)->lpVtbl -> SetLogFile(This,hFile) ) 

#define IGraphBuilder2_Abort(This)	\
    ( (This)->lpVtbl -> Abort(This) ) 

#define IGraphBuilder2_ShouldOperationContinue(This)	\
    ( (This)->lpVtbl -> ShouldOperationContinue(This) ) 


#define IGraphBuilder2_AddFilterByCLSID(This,rclsid,pwszFilterName)	\
    ( (This)->lpVtbl -> AddFilterByCLSID(This,rclsid,pwszFilterName) ) 

#define IGraphBuilder2_FindInterfacesOnGraph(This,riid,ppEnumerator)	\
    ( (This)->lpVtbl -> FindInterfacesOnGraph(This,riid,ppEnumerator) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IGraphBuilder2_INTERFACE_DEFINED__ */


#ifndef __IFilterGraphHelper_INTERFACE_DEFINED__
#define __IFilterGraphHelper_INTERFACE_DEFINED__

/* interface IFilterGraphHelper */
/* [unique][helpstring][uuid][local][object][local] */ 


EXTERN_C const IID IID_IFilterGraphHelper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EB1B88D4-CAD6-4caf-8133-DA12DD132D50")
    IFilterGraphHelper : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAction( 
            /* [in] */ UINT *puiAction) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFilterGraphHelperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFilterGraphHelper * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFilterGraphHelper * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFilterGraphHelper * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAction )( 
            IFilterGraphHelper * This,
            /* [in] */ UINT *puiAction);
        
        END_INTERFACE
    } IFilterGraphHelperVtbl;

    interface IFilterGraphHelper
    {
        CONST_VTBL struct IFilterGraphHelperVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFilterGraphHelper_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFilterGraphHelper_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFilterGraphHelper_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFilterGraphHelper_GetAction(This,puiAction)	\
    ( (This)->lpVtbl -> GetAction(This,puiAction) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFilterGraphHelper_INTERFACE_DEFINED__ */


#ifndef __IAudioControl_INTERFACE_DEFINED__
#define __IAudioControl_INTERFACE_DEFINED__

/* interface IAudioControl */
/* [unique][helpstring][uuid][local][object][local] */ 

static LPCWSTR DEFAULT_WAVE_OUT_DEVICE_ID	=	L"DEFAULT_WAVE_OUT_DEVICE_ID";

static LPCWSTR DEFAULT_WAVE_IN_DEVICE_ID	=	L"DEFAULT_WAVE_IN_DEVICE_ID";


EXTERN_C const IID IID_IAudioControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3DD42B49-2747-40d9-8C1F-B31566C97B30")
    IAudioControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDeviceId( 
            /* [string][in] */ LPCWSTR pwszFilterName,
            /* [out] */ DWORD *pdwDeviceId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDeviceId( 
            /* [string][in] */ LPCWSTR pwszFilterName,
            /* [in] */ DWORD dwDeviceId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAudioControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAudioControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAudioControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAudioControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDeviceId )( 
            IAudioControl * This,
            /* [string][in] */ LPCWSTR pwszFilterName,
            /* [out] */ DWORD *pdwDeviceId);
        
        HRESULT ( STDMETHODCALLTYPE *SetDeviceId )( 
            IAudioControl * This,
            /* [string][in] */ LPCWSTR pwszFilterName,
            /* [in] */ DWORD dwDeviceId);
        
        END_INTERFACE
    } IAudioControlVtbl;

    interface IAudioControl
    {
        CONST_VTBL struct IAudioControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAudioControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAudioControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAudioControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAudioControl_GetDeviceId(This,pwszFilterName,pdwDeviceId)	\
    ( (This)->lpVtbl -> GetDeviceId(This,pwszFilterName,pdwDeviceId) ) 

#define IAudioControl_SetDeviceId(This,pwszFilterName,dwDeviceId)	\
    ( (This)->lpVtbl -> SetDeviceId(This,pwszFilterName,dwDeviceId) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAudioControl_INTERFACE_DEFINED__ */


#ifndef __ICaptureGraphBuilder_INTERFACE_DEFINED__
#define __ICaptureGraphBuilder_INTERFACE_DEFINED__

/* interface ICaptureGraphBuilder */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ICaptureGraphBuilder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("bf87b6e0-8c27-11d0-b3f0-00aa003761c5")
    ICaptureGraphBuilder : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFiltergraph( 
            /* [in] */ IGraphBuilder *pfg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFiltergraph( 
            /* [out] */ IGraphBuilder **ppfg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOutputFileName( 
            /* [in] */ const GUID *pType,
            /* [in] */ LPCOLESTR lpstrFile,
            /* [out] */ IBaseFilter **ppf,
            /* [out] */ IFileSinkFilter **ppSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindInterface( 
            /* [in] */ const GUID *pCategory,
            /* [in] */ IBaseFilter *pf,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RenderStream( 
            /* [in] */ const GUID *pCategory,
            /* [in] */ IUnknown *pSource,
            /* [in] */ IBaseFilter *pfCompressor,
            /* [in] */ IBaseFilter *pfRenderer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ControlStream( 
            /* [in] */ const GUID *pCategory,
            /* [in] */ IBaseFilter *pFilter,
            /* [in] */ REFERENCE_TIME *pstart,
            /* [in] */ REFERENCE_TIME *pstop,
            /* [in] */ WORD wStartCookie,
            /* [in] */ WORD wStopCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocCapFile( 
            /* [in] */ LPCOLESTR lpstr,
            /* [in] */ DWORDLONG dwlSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CopyCaptureFile( 
            /* [in] */ LPOLESTR lpwstrOld,
            /* [in] */ LPOLESTR lpwstrNew,
            /* [in] */ int fAllowEscAbort,
            /* [in] */ IAMCopyCaptureFileProgress *pCallback) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICaptureGraphBuilderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICaptureGraphBuilder * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICaptureGraphBuilder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICaptureGraphBuilder * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFiltergraph )( 
            ICaptureGraphBuilder * This,
            /* [in] */ IGraphBuilder *pfg);
        
        HRESULT ( STDMETHODCALLTYPE *GetFiltergraph )( 
            ICaptureGraphBuilder * This,
            /* [out] */ IGraphBuilder **ppfg);
        
        HRESULT ( STDMETHODCALLTYPE *SetOutputFileName )( 
            ICaptureGraphBuilder * This,
            /* [in] */ const GUID *pType,
            /* [in] */ LPCOLESTR lpstrFile,
            /* [out] */ IBaseFilter **ppf,
            /* [out] */ IFileSinkFilter **ppSink);
        
        HRESULT ( STDMETHODCALLTYPE *FindInterface )( 
            ICaptureGraphBuilder * This,
            /* [in] */ const GUID *pCategory,
            /* [in] */ IBaseFilter *pf,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppint);
        
        HRESULT ( STDMETHODCALLTYPE *RenderStream )( 
            ICaptureGraphBuilder * This,
            /* [in] */ const GUID *pCategory,
            /* [in] */ IUnknown *pSource,
            /* [in] */ IBaseFilter *pfCompressor,
            /* [in] */ IBaseFilter *pfRenderer);
        
        HRESULT ( STDMETHODCALLTYPE *ControlStream )( 
            ICaptureGraphBuilder * This,
            /* [in] */ const GUID *pCategory,
            /* [in] */ IBaseFilter *pFilter,
            /* [in] */ REFERENCE_TIME *pstart,
            /* [in] */ REFERENCE_TIME *pstop,
            /* [in] */ WORD wStartCookie,
            /* [in] */ WORD wStopCookie);
        
        HRESULT ( STDMETHODCALLTYPE *AllocCapFile )( 
            ICaptureGraphBuilder * This,
            /* [in] */ LPCOLESTR lpstr,
            /* [in] */ DWORDLONG dwlSize);
        
        HRESULT ( STDMETHODCALLTYPE *CopyCaptureFile )( 
            ICaptureGraphBuilder * This,
            /* [in] */ LPOLESTR lpwstrOld,
            /* [in] */ LPOLESTR lpwstrNew,
            /* [in] */ int fAllowEscAbort,
            /* [in] */ IAMCopyCaptureFileProgress *pCallback);
        
        END_INTERFACE
    } ICaptureGraphBuilderVtbl;

    interface ICaptureGraphBuilder
    {
        CONST_VTBL struct ICaptureGraphBuilderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICaptureGraphBuilder_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICaptureGraphBuilder_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICaptureGraphBuilder_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICaptureGraphBuilder_SetFiltergraph(This,pfg)	\
    ( (This)->lpVtbl -> SetFiltergraph(This,pfg) ) 

#define ICaptureGraphBuilder_GetFiltergraph(This,ppfg)	\
    ( (This)->lpVtbl -> GetFiltergraph(This,ppfg) ) 

#define ICaptureGraphBuilder_SetOutputFileName(This,pType,lpstrFile,ppf,ppSink)	\
    ( (This)->lpVtbl -> SetOutputFileName(This,pType,lpstrFile,ppf,ppSink) ) 

#define ICaptureGraphBuilder_FindInterface(This,pCategory,pf,riid,ppint)	\
    ( (This)->lpVtbl -> FindInterface(This,pCategory,pf,riid,ppint) ) 

#define ICaptureGraphBuilder_RenderStream(This,pCategory,pSource,pfCompressor,pfRenderer)	\
    ( (This)->lpVtbl -> RenderStream(This,pCategory,pSource,pfCompressor,pfRenderer) ) 

#define ICaptureGraphBuilder_ControlStream(This,pCategory,pFilter,pstart,pstop,wStartCookie,wStopCookie)	\
    ( (This)->lpVtbl -> ControlStream(This,pCategory,pFilter,pstart,pstop,wStartCookie,wStopCookie) ) 

#define ICaptureGraphBuilder_AllocCapFile(This,lpstr,dwlSize)	\
    ( (This)->lpVtbl -> AllocCapFile(This,lpstr,dwlSize) ) 

#define ICaptureGraphBuilder_CopyCaptureFile(This,lpwstrOld,lpwstrNew,fAllowEscAbort,pCallback)	\
    ( (This)->lpVtbl -> CopyCaptureFile(This,lpwstrOld,lpwstrNew,fAllowEscAbort,pCallback) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICaptureGraphBuilder_INTERFACE_DEFINED__ */


#ifndef __IAMCopyCaptureFileProgress_INTERFACE_DEFINED__
#define __IAMCopyCaptureFileProgress_INTERFACE_DEFINED__

/* interface IAMCopyCaptureFileProgress */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMCopyCaptureFileProgress;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("670d1d20-a068-11d0-b3f0-00aa003761c5")
    IAMCopyCaptureFileProgress : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Progress( 
            /* [in] */ int iProgress) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMCopyCaptureFileProgressVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMCopyCaptureFileProgress * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMCopyCaptureFileProgress * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMCopyCaptureFileProgress * This);
        
        HRESULT ( STDMETHODCALLTYPE *Progress )( 
            IAMCopyCaptureFileProgress * This,
            /* [in] */ int iProgress);
        
        END_INTERFACE
    } IAMCopyCaptureFileProgressVtbl;

    interface IAMCopyCaptureFileProgress
    {
        CONST_VTBL struct IAMCopyCaptureFileProgressVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMCopyCaptureFileProgress_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMCopyCaptureFileProgress_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMCopyCaptureFileProgress_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMCopyCaptureFileProgress_Progress(This,iProgress)	\
    ( (This)->lpVtbl -> Progress(This,iProgress) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMCopyCaptureFileProgress_INTERFACE_DEFINED__ */


#ifndef __ICaptureGraphBuilder2_INTERFACE_DEFINED__
#define __ICaptureGraphBuilder2_INTERFACE_DEFINED__

/* interface ICaptureGraphBuilder2 */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ICaptureGraphBuilder2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("93E5A4E0-2D50-11d2-ABFA-00A0C9C6E38D")
    ICaptureGraphBuilder2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFiltergraph( 
            /* [in] */ IGraphBuilder *pfg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFiltergraph( 
            /* [out] */ IGraphBuilder **ppfg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOutputFileName( 
            /* [in] */ const GUID *pType,
            /* [in] */ LPCOLESTR lpstrFile,
            /* [out] */ IBaseFilter **ppf,
            /* [out] */ IFileSinkFilter **ppSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindInterface( 
            /* [in] */ const GUID *pCategory,
            /* [in] */ const GUID *pType,
            /* [in] */ IBaseFilter *pf,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RenderStream( 
            /* [in] */ const GUID *pCategory,
            /* [in] */ const GUID *pType,
            /* [in] */ IUnknown *pSource,
            /* [in] */ IBaseFilter *pfCompressor,
            /* [in] */ IBaseFilter *pfRenderer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ControlStream( 
            /* [in] */ const GUID *pCategory,
            /* [in] */ const GUID *pType,
            /* [in] */ IBaseFilter *pFilter,
            /* [in] */ REFERENCE_TIME *pstart,
            /* [in] */ REFERENCE_TIME *pstop,
            /* [in] */ WORD wStartCookie,
            /* [in] */ WORD wStopCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocCapFile( 
            /* [in] */ LPCOLESTR lpstr,
            /* [in] */ DWORDLONG dwlSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CopyCaptureFile( 
            /* [in] */ LPOLESTR lpwstrOld,
            /* [in] */ LPOLESTR lpwstrNew,
            /* [in] */ int fAllowEscAbort,
            /* [in] */ IAMCopyCaptureFileProgress *pCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindPin( 
            /* [in] */ IUnknown *pSource,
            /* [in] */ PIN_DIRECTION pindir,
            /* [in] */ const GUID *pCategory,
            /* [in] */ const GUID *pType,
            /* [in] */ BOOL fUnconnected,
            /* [in] */ int num,
            /* [out] */ IPin **ppPin) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICaptureGraphBuilder2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICaptureGraphBuilder2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICaptureGraphBuilder2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICaptureGraphBuilder2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFiltergraph )( 
            ICaptureGraphBuilder2 * This,
            /* [in] */ IGraphBuilder *pfg);
        
        HRESULT ( STDMETHODCALLTYPE *GetFiltergraph )( 
            ICaptureGraphBuilder2 * This,
            /* [out] */ IGraphBuilder **ppfg);
        
        HRESULT ( STDMETHODCALLTYPE *SetOutputFileName )( 
            ICaptureGraphBuilder2 * This,
            /* [in] */ const GUID *pType,
            /* [in] */ LPCOLESTR lpstrFile,
            /* [out] */ IBaseFilter **ppf,
            /* [out] */ IFileSinkFilter **ppSink);
        
        HRESULT ( STDMETHODCALLTYPE *FindInterface )( 
            ICaptureGraphBuilder2 * This,
            /* [in] */ const GUID *pCategory,
            /* [in] */ const GUID *pType,
            /* [in] */ IBaseFilter *pf,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppint);
        
        HRESULT ( STDMETHODCALLTYPE *RenderStream )( 
            ICaptureGraphBuilder2 * This,
            /* [in] */ const GUID *pCategory,
            /* [in] */ const GUID *pType,
            /* [in] */ IUnknown *pSource,
            /* [in] */ IBaseFilter *pfCompressor,
            /* [in] */ IBaseFilter *pfRenderer);
        
        HRESULT ( STDMETHODCALLTYPE *ControlStream )( 
            ICaptureGraphBuilder2 * This,
            /* [in] */ const GUID *pCategory,
            /* [in] */ const GUID *pType,
            /* [in] */ IBaseFilter *pFilter,
            /* [in] */ REFERENCE_TIME *pstart,
            /* [in] */ REFERENCE_TIME *pstop,
            /* [in] */ WORD wStartCookie,
            /* [in] */ WORD wStopCookie);
        
        HRESULT ( STDMETHODCALLTYPE *AllocCapFile )( 
            ICaptureGraphBuilder2 * This,
            /* [in] */ LPCOLESTR lpstr,
            /* [in] */ DWORDLONG dwlSize);
        
        HRESULT ( STDMETHODCALLTYPE *CopyCaptureFile )( 
            ICaptureGraphBuilder2 * This,
            /* [in] */ LPOLESTR lpwstrOld,
            /* [in] */ LPOLESTR lpwstrNew,
            /* [in] */ int fAllowEscAbort,
            /* [in] */ IAMCopyCaptureFileProgress *pCallback);
        
        HRESULT ( STDMETHODCALLTYPE *FindPin )( 
            ICaptureGraphBuilder2 * This,
            /* [in] */ IUnknown *pSource,
            /* [in] */ PIN_DIRECTION pindir,
            /* [in] */ const GUID *pCategory,
            /* [in] */ const GUID *pType,
            /* [in] */ BOOL fUnconnected,
            /* [in] */ int num,
            /* [out] */ IPin **ppPin);
        
        END_INTERFACE
    } ICaptureGraphBuilder2Vtbl;

    interface ICaptureGraphBuilder2
    {
        CONST_VTBL struct ICaptureGraphBuilder2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICaptureGraphBuilder2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICaptureGraphBuilder2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICaptureGraphBuilder2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICaptureGraphBuilder2_SetFiltergraph(This,pfg)	\
    ( (This)->lpVtbl -> SetFiltergraph(This,pfg) ) 

#define ICaptureGraphBuilder2_GetFiltergraph(This,ppfg)	\
    ( (This)->lpVtbl -> GetFiltergraph(This,ppfg) ) 

#define ICaptureGraphBuilder2_SetOutputFileName(This,pType,lpstrFile,ppf,ppSink)	\
    ( (This)->lpVtbl -> SetOutputFileName(This,pType,lpstrFile,ppf,ppSink) ) 

#define ICaptureGraphBuilder2_FindInterface(This,pCategory,pType,pf,riid,ppint)	\
    ( (This)->lpVtbl -> FindInterface(This,pCategory,pType,pf,riid,ppint) ) 

#define ICaptureGraphBuilder2_RenderStream(This,pCategory,pType,pSource,pfCompressor,pfRenderer)	\
    ( (This)->lpVtbl -> RenderStream(This,pCategory,pType,pSource,pfCompressor,pfRenderer) ) 

#define ICaptureGraphBuilder2_ControlStream(This,pCategory,pType,pFilter,pstart,pstop,wStartCookie,wStopCookie)	\
    ( (This)->lpVtbl -> ControlStream(This,pCategory,pType,pFilter,pstart,pstop,wStartCookie,wStopCookie) ) 

#define ICaptureGraphBuilder2_AllocCapFile(This,lpstr,dwlSize)	\
    ( (This)->lpVtbl -> AllocCapFile(This,lpstr,dwlSize) ) 

#define ICaptureGraphBuilder2_CopyCaptureFile(This,lpwstrOld,lpwstrNew,fAllowEscAbort,pCallback)	\
    ( (This)->lpVtbl -> CopyCaptureFile(This,lpwstrOld,lpwstrNew,fAllowEscAbort,pCallback) ) 

#define ICaptureGraphBuilder2_FindPin(This,pSource,pindir,pCategory,pType,fUnconnected,num,ppPin)	\
    ( (This)->lpVtbl -> FindPin(This,pSource,pindir,pCategory,pType,fUnconnected,num,ppPin) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICaptureGraphBuilder2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0037 */
/* [local] */ 


enum _AM_RENSDEREXFLAGS
    {	AM_RENDEREX_RENDERTOEXISTINGRENDERERS	= 0x1
    } ;


extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0037_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0037_v0_0_s_ifspec;

#ifndef __IFilterGraph2_INTERFACE_DEFINED__
#define __IFilterGraph2_INTERFACE_DEFINED__

/* interface IFilterGraph2 */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IFilterGraph2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("36b73882-c2c8-11cf-8b46-00805f6cef60")
    IFilterGraph2 : public IGraphBuilder2
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddSourceFilterForMoniker( 
            /* [in] */ IMoniker *pMoniker,
            /* [in] */ IBindCtx *pCtx,
            /* [in] */ LPCWSTR lpcwstrFilterName,
            /* [out] */ IBaseFilter **ppFilter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReconnectEx( 
            /* [in] */ IPin *ppin,
            /* [in] */ const AM_MEDIA_TYPE *pmt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RenderEx( 
            /* [in] */ IPin *pPinOut,
            /* [in] */ DWORD dwFlags,
            /* [out][in] */ LPVOID pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFilterGraph2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFilterGraph2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFilterGraph2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFilterGraph2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddFilter )( 
            IFilterGraph2 * This,
            /* [in] */ IBaseFilter *pFilter,
            /* [string][in] */ LPCWSTR pName);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveFilter )( 
            IFilterGraph2 * This,
            /* [in] */ IBaseFilter *pFilter);
        
        HRESULT ( STDMETHODCALLTYPE *EnumFilters )( 
            IFilterGraph2 * This,
            /* [out] */ IEnumFilters **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *FindFilterByName )( 
            IFilterGraph2 * This,
            /* [string][in] */ LPCWSTR pName,
            /* [out] */ IBaseFilter **ppFilter);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectDirect )( 
            IFilterGraph2 * This,
            /* [in] */ IPin *ppinOut,
            /* [in] */ IPin *ppinIn,
            /* [in] */ const AM_MEDIA_TYPE *pmt);
        
        HRESULT ( STDMETHODCALLTYPE *Reconnect )( 
            IFilterGraph2 * This,
            /* [in] */ IPin *ppin);
        
        HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            IFilterGraph2 * This,
            /* [in] */ IPin *ppin);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultSyncSource )( 
            IFilterGraph2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Connect )( 
            IFilterGraph2 * This,
            /* [in] */ IPin *ppinOut,
            /* [in] */ IPin *ppinIn);
        
        HRESULT ( STDMETHODCALLTYPE *Render )( 
            IFilterGraph2 * This,
            /* [in] */ IPin *ppinOut);
        
        HRESULT ( STDMETHODCALLTYPE *RenderFile )( 
            IFilterGraph2 * This,
            /* [in] */ LPCWSTR lpcwstrFile,
            /* [in] */ LPCWSTR lpcwstrPlayList);
        
        HRESULT ( STDMETHODCALLTYPE *AddSourceFilter )( 
            IFilterGraph2 * This,
            /* [in] */ LPCWSTR lpcwstrFileName,
            /* [in] */ LPCWSTR lpcwstrFilterName,
            /* [out] */ IBaseFilter **ppFilter);
        
        HRESULT ( STDMETHODCALLTYPE *SetLogFile )( 
            IFilterGraph2 * This,
            /* [in] */ HANDLE hFile);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            IFilterGraph2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ShouldOperationContinue )( 
            IFilterGraph2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddFilterByCLSID )( 
            IFilterGraph2 * This,
            /* [in] */ CLSID rclsid,
            /* [string][in] */ wchar_t *pwszFilterName);
        
        HRESULT ( STDMETHODCALLTYPE *FindInterfacesOnGraph )( 
            IFilterGraph2 * This,
            /* [in] */ IID riid,
            /* [out] */ IEnumFilterInterfaces **ppEnumerator);
        
        HRESULT ( STDMETHODCALLTYPE *AddSourceFilterForMoniker )( 
            IFilterGraph2 * This,
            /* [in] */ IMoniker *pMoniker,
            /* [in] */ IBindCtx *pCtx,
            /* [in] */ LPCWSTR lpcwstrFilterName,
            /* [out] */ IBaseFilter **ppFilter);
        
        HRESULT ( STDMETHODCALLTYPE *ReconnectEx )( 
            IFilterGraph2 * This,
            /* [in] */ IPin *ppin,
            /* [in] */ const AM_MEDIA_TYPE *pmt);
        
        HRESULT ( STDMETHODCALLTYPE *RenderEx )( 
            IFilterGraph2 * This,
            /* [in] */ IPin *pPinOut,
            /* [in] */ DWORD dwFlags,
            /* [out][in] */ LPVOID pvContext);
        
        END_INTERFACE
    } IFilterGraph2Vtbl;

    interface IFilterGraph2
    {
        CONST_VTBL struct IFilterGraph2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFilterGraph2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFilterGraph2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFilterGraph2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFilterGraph2_AddFilter(This,pFilter,pName)	\
    ( (This)->lpVtbl -> AddFilter(This,pFilter,pName) ) 

#define IFilterGraph2_RemoveFilter(This,pFilter)	\
    ( (This)->lpVtbl -> RemoveFilter(This,pFilter) ) 

#define IFilterGraph2_EnumFilters(This,ppEnum)	\
    ( (This)->lpVtbl -> EnumFilters(This,ppEnum) ) 

#define IFilterGraph2_FindFilterByName(This,pName,ppFilter)	\
    ( (This)->lpVtbl -> FindFilterByName(This,pName,ppFilter) ) 

#define IFilterGraph2_ConnectDirect(This,ppinOut,ppinIn,pmt)	\
    ( (This)->lpVtbl -> ConnectDirect(This,ppinOut,ppinIn,pmt) ) 

#define IFilterGraph2_Reconnect(This,ppin)	\
    ( (This)->lpVtbl -> Reconnect(This,ppin) ) 

#define IFilterGraph2_Disconnect(This,ppin)	\
    ( (This)->lpVtbl -> Disconnect(This,ppin) ) 

#define IFilterGraph2_SetDefaultSyncSource(This)	\
    ( (This)->lpVtbl -> SetDefaultSyncSource(This) ) 


#define IFilterGraph2_Connect(This,ppinOut,ppinIn)	\
    ( (This)->lpVtbl -> Connect(This,ppinOut,ppinIn) ) 

#define IFilterGraph2_Render(This,ppinOut)	\
    ( (This)->lpVtbl -> Render(This,ppinOut) ) 

#define IFilterGraph2_RenderFile(This,lpcwstrFile,lpcwstrPlayList)	\
    ( (This)->lpVtbl -> RenderFile(This,lpcwstrFile,lpcwstrPlayList) ) 

#define IFilterGraph2_AddSourceFilter(This,lpcwstrFileName,lpcwstrFilterName,ppFilter)	\
    ( (This)->lpVtbl -> AddSourceFilter(This,lpcwstrFileName,lpcwstrFilterName,ppFilter) ) 

#define IFilterGraph2_SetLogFile(This,hFile)	\
    ( (This)->lpVtbl -> SetLogFile(This,hFile) ) 

#define IFilterGraph2_Abort(This)	\
    ( (This)->lpVtbl -> Abort(This) ) 

#define IFilterGraph2_ShouldOperationContinue(This)	\
    ( (This)->lpVtbl -> ShouldOperationContinue(This) ) 


#define IFilterGraph2_AddFilterByCLSID(This,rclsid,pwszFilterName)	\
    ( (This)->lpVtbl -> AddFilterByCLSID(This,rclsid,pwszFilterName) ) 

#define IFilterGraph2_FindInterfacesOnGraph(This,riid,ppEnumerator)	\
    ( (This)->lpVtbl -> FindInterfacesOnGraph(This,riid,ppEnumerator) ) 


#define IFilterGraph2_AddSourceFilterForMoniker(This,pMoniker,pCtx,lpcwstrFilterName,ppFilter)	\
    ( (This)->lpVtbl -> AddSourceFilterForMoniker(This,pMoniker,pCtx,lpcwstrFilterName,ppFilter) ) 

#define IFilterGraph2_ReconnectEx(This,ppin,pmt)	\
    ( (This)->lpVtbl -> ReconnectEx(This,ppin,pmt) ) 

#define IFilterGraph2_RenderEx(This,pPinOut,dwFlags,pvContext)	\
    ( (This)->lpVtbl -> RenderEx(This,pPinOut,dwFlags,pvContext) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFilterGraph2_INTERFACE_DEFINED__ */


#ifndef __IStreamBuilder_INTERFACE_DEFINED__
#define __IStreamBuilder_INTERFACE_DEFINED__

/* interface IStreamBuilder */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IStreamBuilder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868bf-0ad4-11ce-b03a-0020af0ba770")
    IStreamBuilder : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Render( 
            /* [in] */ IPin *ppinOut,
            /* [in] */ IGraphBuilder *pGraph) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Backout( 
            /* [in] */ IPin *ppinOut,
            /* [in] */ IGraphBuilder *pGraph) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStreamBuilderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IStreamBuilder * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IStreamBuilder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IStreamBuilder * This);
        
        HRESULT ( STDMETHODCALLTYPE *Render )( 
            IStreamBuilder * This,
            /* [in] */ IPin *ppinOut,
            /* [in] */ IGraphBuilder *pGraph);
        
        HRESULT ( STDMETHODCALLTYPE *Backout )( 
            IStreamBuilder * This,
            /* [in] */ IPin *ppinOut,
            /* [in] */ IGraphBuilder *pGraph);
        
        END_INTERFACE
    } IStreamBuilderVtbl;

    interface IStreamBuilder
    {
        CONST_VTBL struct IStreamBuilderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStreamBuilder_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IStreamBuilder_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IStreamBuilder_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IStreamBuilder_Render(This,ppinOut,pGraph)	\
    ( (This)->lpVtbl -> Render(This,ppinOut,pGraph) ) 

#define IStreamBuilder_Backout(This,ppinOut,pGraph)	\
    ( (This)->lpVtbl -> Backout(This,ppinOut,pGraph) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IStreamBuilder_INTERFACE_DEFINED__ */


#ifndef __IAsyncReader_INTERFACE_DEFINED__
#define __IAsyncReader_INTERFACE_DEFINED__

/* interface IAsyncReader */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAsyncReader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868aa-0ad4-11ce-b03a-0020af0ba770")
    IAsyncReader : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RequestAllocator( 
            /* [in] */ IMemAllocator *pPreferred,
            /* [in] */ ALLOCATOR_PROPERTIES *pProps,
            /* [out] */ IMemAllocator **ppActual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Request( 
            /* [in] */ IMediaSample *pSample,
            /* [in] */ DWORD_PTR dwUser) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WaitForNext( 
            /* [in] */ DWORD dwTimeout,
            /* [out] */ IMediaSample **ppSample,
            /* [out] */ DWORD_PTR *pdwUser) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SyncReadAligned( 
            /* [in] */ IMediaSample *pSample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SyncRead( 
            /* [in] */ LONGLONG llPosition,
            /* [in] */ LONG lLength,
            /* [size_is][out] */ BYTE *pBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Length( 
            /* [out] */ LONGLONG *pTotal,
            /* [out] */ LONGLONG *pAvailable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginFlush( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndFlush( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAsyncReaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAsyncReader * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAsyncReader * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAsyncReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *RequestAllocator )( 
            IAsyncReader * This,
            /* [in] */ IMemAllocator *pPreferred,
            /* [in] */ ALLOCATOR_PROPERTIES *pProps,
            /* [out] */ IMemAllocator **ppActual);
        
        HRESULT ( STDMETHODCALLTYPE *Request )( 
            IAsyncReader * This,
            /* [in] */ IMediaSample *pSample,
            /* [in] */ DWORD_PTR dwUser);
        
        HRESULT ( STDMETHODCALLTYPE *WaitForNext )( 
            IAsyncReader * This,
            /* [in] */ DWORD dwTimeout,
            /* [out] */ IMediaSample **ppSample,
            /* [out] */ DWORD_PTR *pdwUser);
        
        HRESULT ( STDMETHODCALLTYPE *SyncReadAligned )( 
            IAsyncReader * This,
            /* [in] */ IMediaSample *pSample);
        
        HRESULT ( STDMETHODCALLTYPE *SyncRead )( 
            IAsyncReader * This,
            /* [in] */ LONGLONG llPosition,
            /* [in] */ LONG lLength,
            /* [size_is][out] */ BYTE *pBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *Length )( 
            IAsyncReader * This,
            /* [out] */ LONGLONG *pTotal,
            /* [out] */ LONGLONG *pAvailable);
        
        HRESULT ( STDMETHODCALLTYPE *BeginFlush )( 
            IAsyncReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *EndFlush )( 
            IAsyncReader * This);
        
        END_INTERFACE
    } IAsyncReaderVtbl;

    interface IAsyncReader
    {
        CONST_VTBL struct IAsyncReaderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAsyncReader_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAsyncReader_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAsyncReader_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAsyncReader_RequestAllocator(This,pPreferred,pProps,ppActual)	\
    ( (This)->lpVtbl -> RequestAllocator(This,pPreferred,pProps,ppActual) ) 

#define IAsyncReader_Request(This,pSample,dwUser)	\
    ( (This)->lpVtbl -> Request(This,pSample,dwUser) ) 

#define IAsyncReader_WaitForNext(This,dwTimeout,ppSample,pdwUser)	\
    ( (This)->lpVtbl -> WaitForNext(This,dwTimeout,ppSample,pdwUser) ) 

#define IAsyncReader_SyncReadAligned(This,pSample)	\
    ( (This)->lpVtbl -> SyncReadAligned(This,pSample) ) 

#define IAsyncReader_SyncRead(This,llPosition,lLength,pBuffer)	\
    ( (This)->lpVtbl -> SyncRead(This,llPosition,lLength,pBuffer) ) 

#define IAsyncReader_Length(This,pTotal,pAvailable)	\
    ( (This)->lpVtbl -> Length(This,pTotal,pAvailable) ) 

#define IAsyncReader_BeginFlush(This)	\
    ( (This)->lpVtbl -> BeginFlush(This) ) 

#define IAsyncReader_EndFlush(This)	\
    ( (This)->lpVtbl -> EndFlush(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAsyncReader_INTERFACE_DEFINED__ */


#ifndef __IGraphVersion_INTERFACE_DEFINED__
#define __IGraphVersion_INTERFACE_DEFINED__

/* interface IGraphVersion */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IGraphVersion;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868ab-0ad4-11ce-b03a-0020af0ba770")
    IGraphVersion : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryVersion( 
            LONG *pVersion) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGraphVersionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGraphVersion * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGraphVersion * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGraphVersion * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryVersion )( 
            IGraphVersion * This,
            LONG *pVersion);
        
        END_INTERFACE
    } IGraphVersionVtbl;

    interface IGraphVersion
    {
        CONST_VTBL struct IGraphVersionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGraphVersion_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IGraphVersion_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IGraphVersion_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IGraphVersion_QueryVersion(This,pVersion)	\
    ( (This)->lpVtbl -> QueryVersion(This,pVersion) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IGraphVersion_INTERFACE_DEFINED__ */


#ifndef __IResourceConsumer_INTERFACE_DEFINED__
#define __IResourceConsumer_INTERFACE_DEFINED__

/* interface IResourceConsumer */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IResourceConsumer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868ad-0ad4-11ce-b03a-0020af0ba770")
    IResourceConsumer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AcquireResource( 
            /* [in] */ LONG idResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseResource( 
            /* [in] */ LONG idResource) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IResourceConsumerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IResourceConsumer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IResourceConsumer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IResourceConsumer * This);
        
        HRESULT ( STDMETHODCALLTYPE *AcquireResource )( 
            IResourceConsumer * This,
            /* [in] */ LONG idResource);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseResource )( 
            IResourceConsumer * This,
            /* [in] */ LONG idResource);
        
        END_INTERFACE
    } IResourceConsumerVtbl;

    interface IResourceConsumer
    {
        CONST_VTBL struct IResourceConsumerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IResourceConsumer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IResourceConsumer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IResourceConsumer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IResourceConsumer_AcquireResource(This,idResource)	\
    ( (This)->lpVtbl -> AcquireResource(This,idResource) ) 

#define IResourceConsumer_ReleaseResource(This,idResource)	\
    ( (This)->lpVtbl -> ReleaseResource(This,idResource) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IResourceConsumer_INTERFACE_DEFINED__ */


#ifndef __IResourceManager_INTERFACE_DEFINED__
#define __IResourceManager_INTERFACE_DEFINED__

/* interface IResourceManager */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IResourceManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868ac-0ad4-11ce-b03a-0020af0ba770")
    IResourceManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Register( 
            /* [in] */ LPCWSTR pName,
            /* [in] */ LONG cResource,
            /* [out] */ LONG *plToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterGroup( 
            /* [in] */ LPCWSTR pName,
            /* [in] */ LONG cResource,
            /* [size_is][in] */ LONG *palTokens,
            /* [out] */ LONG *plToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestResource( 
            /* [in] */ LONG idResource,
            /* [in] */ IUnknown *pFocusObject,
            /* [in] */ IResourceConsumer *pConsumer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyAcquire( 
            /* [in] */ LONG idResource,
            /* [in] */ IResourceConsumer *pConsumer,
            /* [in] */ HRESULT hr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyRelease( 
            /* [in] */ LONG idResource,
            /* [in] */ IResourceConsumer *pConsumer,
            /* [in] */ BOOL bStillWant) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelRequest( 
            /* [in] */ LONG idResource,
            /* [in] */ IResourceConsumer *pConsumer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFocus( 
            /* [in] */ IUnknown *pFocusObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseFocus( 
            /* [in] */ IUnknown *pFocusObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IResourceManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IResourceManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IResourceManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IResourceManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *Register )( 
            IResourceManager * This,
            /* [in] */ LPCWSTR pName,
            /* [in] */ LONG cResource,
            /* [out] */ LONG *plToken);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterGroup )( 
            IResourceManager * This,
            /* [in] */ LPCWSTR pName,
            /* [in] */ LONG cResource,
            /* [size_is][in] */ LONG *palTokens,
            /* [out] */ LONG *plToken);
        
        HRESULT ( STDMETHODCALLTYPE *RequestResource )( 
            IResourceManager * This,
            /* [in] */ LONG idResource,
            /* [in] */ IUnknown *pFocusObject,
            /* [in] */ IResourceConsumer *pConsumer);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyAcquire )( 
            IResourceManager * This,
            /* [in] */ LONG idResource,
            /* [in] */ IResourceConsumer *pConsumer,
            /* [in] */ HRESULT hr);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyRelease )( 
            IResourceManager * This,
            /* [in] */ LONG idResource,
            /* [in] */ IResourceConsumer *pConsumer,
            /* [in] */ BOOL bStillWant);
        
        HRESULT ( STDMETHODCALLTYPE *CancelRequest )( 
            IResourceManager * This,
            /* [in] */ LONG idResource,
            /* [in] */ IResourceConsumer *pConsumer);
        
        HRESULT ( STDMETHODCALLTYPE *SetFocus )( 
            IResourceManager * This,
            /* [in] */ IUnknown *pFocusObject);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseFocus )( 
            IResourceManager * This,
            /* [in] */ IUnknown *pFocusObject);
        
        END_INTERFACE
    } IResourceManagerVtbl;

    interface IResourceManager
    {
        CONST_VTBL struct IResourceManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IResourceManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IResourceManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IResourceManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IResourceManager_Register(This,pName,cResource,plToken)	\
    ( (This)->lpVtbl -> Register(This,pName,cResource,plToken) ) 

#define IResourceManager_RegisterGroup(This,pName,cResource,palTokens,plToken)	\
    ( (This)->lpVtbl -> RegisterGroup(This,pName,cResource,palTokens,plToken) ) 

#define IResourceManager_RequestResource(This,idResource,pFocusObject,pConsumer)	\
    ( (This)->lpVtbl -> RequestResource(This,idResource,pFocusObject,pConsumer) ) 

#define IResourceManager_NotifyAcquire(This,idResource,pConsumer,hr)	\
    ( (This)->lpVtbl -> NotifyAcquire(This,idResource,pConsumer,hr) ) 

#define IResourceManager_NotifyRelease(This,idResource,pConsumer,bStillWant)	\
    ( (This)->lpVtbl -> NotifyRelease(This,idResource,pConsumer,bStillWant) ) 

#define IResourceManager_CancelRequest(This,idResource,pConsumer)	\
    ( (This)->lpVtbl -> CancelRequest(This,idResource,pConsumer) ) 

#define IResourceManager_SetFocus(This,pFocusObject)	\
    ( (This)->lpVtbl -> SetFocus(This,pFocusObject) ) 

#define IResourceManager_ReleaseFocus(This,pFocusObject)	\
    ( (This)->lpVtbl -> ReleaseFocus(This,pFocusObject) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IResourceManager_INTERFACE_DEFINED__ */


#ifndef __IDistributorNotify_INTERFACE_DEFINED__
#define __IDistributorNotify_INTERFACE_DEFINED__

/* interface IDistributorNotify */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDistributorNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868af-0ad4-11ce-b03a-0020af0ba770")
    IDistributorNotify : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Run( 
            REFERENCE_TIME tStart) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSyncSource( 
            /* [in] */ IReferenceClock *pClock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyGraphChange( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDistributorNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDistributorNotify * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDistributorNotify * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDistributorNotify * This);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IDistributorNotify * This);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IDistributorNotify * This);
        
        HRESULT ( STDMETHODCALLTYPE *Run )( 
            IDistributorNotify * This,
            REFERENCE_TIME tStart);
        
        HRESULT ( STDMETHODCALLTYPE *SetSyncSource )( 
            IDistributorNotify * This,
            /* [in] */ IReferenceClock *pClock);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyGraphChange )( 
            IDistributorNotify * This);
        
        END_INTERFACE
    } IDistributorNotifyVtbl;

    interface IDistributorNotify
    {
        CONST_VTBL struct IDistributorNotifyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDistributorNotify_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDistributorNotify_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDistributorNotify_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDistributorNotify_Stop(This)	\
    ( (This)->lpVtbl -> Stop(This) ) 

#define IDistributorNotify_Pause(This)	\
    ( (This)->lpVtbl -> Pause(This) ) 

#define IDistributorNotify_Run(This,tStart)	\
    ( (This)->lpVtbl -> Run(This,tStart) ) 

#define IDistributorNotify_SetSyncSource(This,pClock)	\
    ( (This)->lpVtbl -> SetSyncSource(This,pClock) ) 

#define IDistributorNotify_NotifyGraphChange(This)	\
    ( (This)->lpVtbl -> NotifyGraphChange(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDistributorNotify_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0044 */
/* [local] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_strmif_0000_0044_0001
    {	AM_STREAM_INFO_START_DEFINED	= 0x1,
	AM_STREAM_INFO_STOP_DEFINED	= 0x2,
	AM_STREAM_INFO_DISCARDING	= 0x4,
	AM_STREAM_INFO_STOP_SEND_EXTRA	= 0x10
    } 	AM_STREAM_INFO_FLAGS;

typedef /* [public][public] */ struct __MIDL___MIDL_itf_strmif_0000_0044_0002
    {
    REFERENCE_TIME tStart;
    REFERENCE_TIME tStop;
    DWORD dwStartCookie;
    DWORD dwStopCookie;
    DWORD dwFlags;
    } 	AM_STREAM_INFO;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0044_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0044_v0_0_s_ifspec;

#ifndef __IAMStreamControl_INTERFACE_DEFINED__
#define __IAMStreamControl_INTERFACE_DEFINED__

/* interface IAMStreamControl */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMStreamControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("36b73881-c2c8-11cf-8b46-00805f6cef60")
    IAMStreamControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StartAt( 
            /* [in] */ const REFERENCE_TIME *ptStart,
            /* [in] */ DWORD dwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopAt( 
            /* [in] */ const REFERENCE_TIME *ptStop,
            /* [in] */ BOOL bSendExtra,
            /* [in] */ DWORD dwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInfo( 
            /* [out] */ AM_STREAM_INFO *pInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMStreamControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMStreamControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMStreamControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMStreamControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartAt )( 
            IAMStreamControl * This,
            /* [in] */ const REFERENCE_TIME *ptStart,
            /* [in] */ DWORD dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *StopAt )( 
            IAMStreamControl * This,
            /* [in] */ const REFERENCE_TIME *ptStop,
            /* [in] */ BOOL bSendExtra,
            /* [in] */ DWORD dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            IAMStreamControl * This,
            /* [out] */ AM_STREAM_INFO *pInfo);
        
        END_INTERFACE
    } IAMStreamControlVtbl;

    interface IAMStreamControl
    {
        CONST_VTBL struct IAMStreamControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMStreamControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMStreamControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMStreamControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMStreamControl_StartAt(This,ptStart,dwCookie)	\
    ( (This)->lpVtbl -> StartAt(This,ptStart,dwCookie) ) 

#define IAMStreamControl_StopAt(This,ptStop,bSendExtra,dwCookie)	\
    ( (This)->lpVtbl -> StopAt(This,ptStop,bSendExtra,dwCookie) ) 

#define IAMStreamControl_GetInfo(This,pInfo)	\
    ( (This)->lpVtbl -> GetInfo(This,pInfo) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMStreamControl_INTERFACE_DEFINED__ */


#ifndef __ISeekingPassThru_INTERFACE_DEFINED__
#define __ISeekingPassThru_INTERFACE_DEFINED__

/* interface ISeekingPassThru */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISeekingPassThru;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("36b73883-c2c8-11cf-8b46-00805f6cef60")
    ISeekingPassThru : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Init( 
            /* [in] */ BOOL bSupportRendering,
            /* [in] */ IPin *pPin) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISeekingPassThruVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISeekingPassThru * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISeekingPassThru * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISeekingPassThru * This);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            ISeekingPassThru * This,
            /* [in] */ BOOL bSupportRendering,
            /* [in] */ IPin *pPin);
        
        END_INTERFACE
    } ISeekingPassThruVtbl;

    interface ISeekingPassThru
    {
        CONST_VTBL struct ISeekingPassThruVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISeekingPassThru_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISeekingPassThru_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISeekingPassThru_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISeekingPassThru_Init(This,bSupportRendering,pPin)	\
    ( (This)->lpVtbl -> Init(This,bSupportRendering,pPin) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISeekingPassThru_INTERFACE_DEFINED__ */


#ifndef __IAMStreamConfig_INTERFACE_DEFINED__
#define __IAMStreamConfig_INTERFACE_DEFINED__

/* interface IAMStreamConfig */
/* [unique][uuid][object] */ 

typedef struct _VIDEO_STREAM_CONFIG_CAPS
    {
    GUID guid;
    ULONG VideoStandard;
    SIZE InputSize;
    SIZE MinCroppingSize;
    SIZE MaxCroppingSize;
    int CropGranularityX;
    int CropGranularityY;
    int CropAlignX;
    int CropAlignY;
    SIZE MinOutputSize;
    SIZE MaxOutputSize;
    int OutputGranularityX;
    int OutputGranularityY;
    int StretchTapsX;
    int StretchTapsY;
    int ShrinkTapsX;
    int ShrinkTapsY;
    LONGLONG MinFrameInterval;
    LONGLONG MaxFrameInterval;
    LONG MinBitsPerSecond;
    LONG MaxBitsPerSecond;
    } 	VIDEO_STREAM_CONFIG_CAPS;

typedef struct _AUDIO_STREAM_CONFIG_CAPS
    {
    GUID guid;
    ULONG MinimumChannels;
    ULONG MaximumChannels;
    ULONG ChannelsGranularity;
    ULONG MinimumBitsPerSample;
    ULONG MaximumBitsPerSample;
    ULONG BitsPerSampleGranularity;
    ULONG MinimumSampleFrequency;
    ULONG MaximumSampleFrequency;
    ULONG SampleFrequencyGranularity;
    } 	AUDIO_STREAM_CONFIG_CAPS;


EXTERN_C const IID IID_IAMStreamConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C6E13340-30AC-11d0-A18C-00A0C9118956")
    IAMStreamConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFormat( 
            /* [in] */ AM_MEDIA_TYPE *pmt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFormat( 
            /* [out] */ AM_MEDIA_TYPE **ppmt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNumberOfCapabilities( 
            /* [out] */ int *piCount,
            /* [out] */ int *piSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamCaps( 
            /* [in] */ int iIndex,
            /* [out] */ AM_MEDIA_TYPE **ppmt,
            /* [out] */ BYTE *pSCC) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMStreamConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMStreamConfig * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMStreamConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMStreamConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFormat )( 
            IAMStreamConfig * This,
            /* [in] */ AM_MEDIA_TYPE *pmt);
        
        HRESULT ( STDMETHODCALLTYPE *GetFormat )( 
            IAMStreamConfig * This,
            /* [out] */ AM_MEDIA_TYPE **ppmt);
        
        HRESULT ( STDMETHODCALLTYPE *GetNumberOfCapabilities )( 
            IAMStreamConfig * This,
            /* [out] */ int *piCount,
            /* [out] */ int *piSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamCaps )( 
            IAMStreamConfig * This,
            /* [in] */ int iIndex,
            /* [out] */ AM_MEDIA_TYPE **ppmt,
            /* [out] */ BYTE *pSCC);
        
        END_INTERFACE
    } IAMStreamConfigVtbl;

    interface IAMStreamConfig
    {
        CONST_VTBL struct IAMStreamConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMStreamConfig_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMStreamConfig_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMStreamConfig_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMStreamConfig_SetFormat(This,pmt)	\
    ( (This)->lpVtbl -> SetFormat(This,pmt) ) 

#define IAMStreamConfig_GetFormat(This,ppmt)	\
    ( (This)->lpVtbl -> GetFormat(This,ppmt) ) 

#define IAMStreamConfig_GetNumberOfCapabilities(This,piCount,piSize)	\
    ( (This)->lpVtbl -> GetNumberOfCapabilities(This,piCount,piSize) ) 

#define IAMStreamConfig_GetStreamCaps(This,iIndex,ppmt,pSCC)	\
    ( (This)->lpVtbl -> GetStreamCaps(This,iIndex,ppmt,pSCC) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMStreamConfig_INTERFACE_DEFINED__ */


#ifndef __IConfigInterleaving_INTERFACE_DEFINED__
#define __IConfigInterleaving_INTERFACE_DEFINED__

/* interface IConfigInterleaving */
/* [unique][uuid][object] */ 

typedef /* [public][public][public] */ 
enum __MIDL_IConfigInterleaving_0001
    {	INTERLEAVE_NONE	= 0,
	INTERLEAVE_CAPTURE	= ( INTERLEAVE_NONE + 1 ) ,
	INTERLEAVE_FULL	= ( INTERLEAVE_CAPTURE + 1 ) 
    } 	InterleavingMode;


EXTERN_C const IID IID_IConfigInterleaving;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BEE3D220-157B-11d0-BD23-00A0C911CE86")
    IConfigInterleaving : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE put_Mode( 
            /* [in] */ InterleavingMode mode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Mode( 
            /* [out] */ InterleavingMode *pMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_Interleaving( 
            /* [in] */ const REFERENCE_TIME *prtInterleave,
            /* [in] */ const REFERENCE_TIME *prtPreroll) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Interleaving( 
            /* [out] */ REFERENCE_TIME *prtInterleave,
            /* [out] */ REFERENCE_TIME *prtPreroll) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IConfigInterleavingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IConfigInterleaving * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IConfigInterleaving * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IConfigInterleaving * This);
        
        HRESULT ( STDMETHODCALLTYPE *put_Mode )( 
            IConfigInterleaving * This,
            /* [in] */ InterleavingMode mode);
        
        HRESULT ( STDMETHODCALLTYPE *get_Mode )( 
            IConfigInterleaving * This,
            /* [out] */ InterleavingMode *pMode);
        
        HRESULT ( STDMETHODCALLTYPE *put_Interleaving )( 
            IConfigInterleaving * This,
            /* [in] */ const REFERENCE_TIME *prtInterleave,
            /* [in] */ const REFERENCE_TIME *prtPreroll);
        
        HRESULT ( STDMETHODCALLTYPE *get_Interleaving )( 
            IConfigInterleaving * This,
            /* [out] */ REFERENCE_TIME *prtInterleave,
            /* [out] */ REFERENCE_TIME *prtPreroll);
        
        END_INTERFACE
    } IConfigInterleavingVtbl;

    interface IConfigInterleaving
    {
        CONST_VTBL struct IConfigInterleavingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IConfigInterleaving_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IConfigInterleaving_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IConfigInterleaving_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IConfigInterleaving_put_Mode(This,mode)	\
    ( (This)->lpVtbl -> put_Mode(This,mode) ) 

#define IConfigInterleaving_get_Mode(This,pMode)	\
    ( (This)->lpVtbl -> get_Mode(This,pMode) ) 

#define IConfigInterleaving_put_Interleaving(This,prtInterleave,prtPreroll)	\
    ( (This)->lpVtbl -> put_Interleaving(This,prtInterleave,prtPreroll) ) 

#define IConfigInterleaving_get_Interleaving(This,prtInterleave,prtPreroll)	\
    ( (This)->lpVtbl -> get_Interleaving(This,prtInterleave,prtPreroll) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IConfigInterleaving_INTERFACE_DEFINED__ */


#ifndef __IConfigAviMux_INTERFACE_DEFINED__
#define __IConfigAviMux_INTERFACE_DEFINED__

/* interface IConfigAviMux */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IConfigAviMux;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5ACD6AA0-F482-11ce-8B67-00AA00A3F1A6")
    IConfigAviMux : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetMasterStream( 
            /* [in] */ LONG iStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMasterStream( 
            /* [out] */ LONG *pStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOutputCompatibilityIndex( 
            /* [in] */ BOOL fOldIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputCompatibilityIndex( 
            /* [out] */ BOOL *pfOldIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IConfigAviMuxVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IConfigAviMux * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IConfigAviMux * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IConfigAviMux * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetMasterStream )( 
            IConfigAviMux * This,
            /* [in] */ LONG iStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetMasterStream )( 
            IConfigAviMux * This,
            /* [out] */ LONG *pStream);
        
        HRESULT ( STDMETHODCALLTYPE *SetOutputCompatibilityIndex )( 
            IConfigAviMux * This,
            /* [in] */ BOOL fOldIndex);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputCompatibilityIndex )( 
            IConfigAviMux * This,
            /* [out] */ BOOL *pfOldIndex);
        
        END_INTERFACE
    } IConfigAviMuxVtbl;

    interface IConfigAviMux
    {
        CONST_VTBL struct IConfigAviMuxVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IConfigAviMux_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IConfigAviMux_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IConfigAviMux_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IConfigAviMux_SetMasterStream(This,iStream)	\
    ( (This)->lpVtbl -> SetMasterStream(This,iStream) ) 

#define IConfigAviMux_GetMasterStream(This,pStream)	\
    ( (This)->lpVtbl -> GetMasterStream(This,pStream) ) 

#define IConfigAviMux_SetOutputCompatibilityIndex(This,fOldIndex)	\
    ( (This)->lpVtbl -> SetOutputCompatibilityIndex(This,fOldIndex) ) 

#define IConfigAviMux_GetOutputCompatibilityIndex(This,pfOldIndex)	\
    ( (This)->lpVtbl -> GetOutputCompatibilityIndex(This,pfOldIndex) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IConfigAviMux_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0049 */
/* [local] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_strmif_0000_0049_0001
    {	CompressionCaps_CanQuality	= 0x1,
	CompressionCaps_CanCrunch	= 0x2,
	CompressionCaps_CanKeyFrame	= 0x4,
	CompressionCaps_CanBFrame	= 0x8,
	CompressionCaps_CanWindow	= 0x10
    } 	CompressionCaps;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0049_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0049_v0_0_s_ifspec;

#ifndef __IAMVideoCompression_INTERFACE_DEFINED__
#define __IAMVideoCompression_INTERFACE_DEFINED__

/* interface IAMVideoCompression */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMVideoCompression;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C6E13343-30AC-11d0-A18C-00A0C9118956")
    IAMVideoCompression : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE put_KeyFrameRate( 
            /* [in] */ long KeyFrameRate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_KeyFrameRate( 
            /* [out] */ long *pKeyFrameRate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_PFramesPerKeyFrame( 
            /* [in] */ long PFramesPerKeyFrame) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_PFramesPerKeyFrame( 
            /* [out] */ long *pPFramesPerKeyFrame) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_Quality( 
            /* [in] */ double Quality) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Quality( 
            /* [out] */ double *pQuality) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_WindowSize( 
            /* [in] */ DWORDLONG WindowSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_WindowSize( 
            /* [out] */ DWORDLONG *pWindowSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInfo( 
            /* [size_is][out] */ WCHAR *pszVersion,
            /* [out][in] */ int *pcbVersion,
            /* [size_is][out] */ LPWSTR pszDescription,
            /* [out][in] */ int *pcbDescription,
            /* [out] */ long *pDefaultKeyFrameRate,
            /* [out] */ long *pDefaultPFramesPerKey,
            /* [out] */ double *pDefaultQuality,
            /* [out] */ long *pCapabilities) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OverrideKeyFrame( 
            /* [in] */ long FrameNumber) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OverrideFrameSize( 
            /* [in] */ long FrameNumber,
            /* [in] */ long Size) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMVideoCompressionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMVideoCompression * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMVideoCompression * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMVideoCompression * This);
        
        HRESULT ( STDMETHODCALLTYPE *put_KeyFrameRate )( 
            IAMVideoCompression * This,
            /* [in] */ long KeyFrameRate);
        
        HRESULT ( STDMETHODCALLTYPE *get_KeyFrameRate )( 
            IAMVideoCompression * This,
            /* [out] */ long *pKeyFrameRate);
        
        HRESULT ( STDMETHODCALLTYPE *put_PFramesPerKeyFrame )( 
            IAMVideoCompression * This,
            /* [in] */ long PFramesPerKeyFrame);
        
        HRESULT ( STDMETHODCALLTYPE *get_PFramesPerKeyFrame )( 
            IAMVideoCompression * This,
            /* [out] */ long *pPFramesPerKeyFrame);
        
        HRESULT ( STDMETHODCALLTYPE *put_Quality )( 
            IAMVideoCompression * This,
            /* [in] */ double Quality);
        
        HRESULT ( STDMETHODCALLTYPE *get_Quality )( 
            IAMVideoCompression * This,
            /* [out] */ double *pQuality);
        
        HRESULT ( STDMETHODCALLTYPE *put_WindowSize )( 
            IAMVideoCompression * This,
            /* [in] */ DWORDLONG WindowSize);
        
        HRESULT ( STDMETHODCALLTYPE *get_WindowSize )( 
            IAMVideoCompression * This,
            /* [out] */ DWORDLONG *pWindowSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            IAMVideoCompression * This,
            /* [size_is][out] */ WCHAR *pszVersion,
            /* [out][in] */ int *pcbVersion,
            /* [size_is][out] */ LPWSTR pszDescription,
            /* [out][in] */ int *pcbDescription,
            /* [out] */ long *pDefaultKeyFrameRate,
            /* [out] */ long *pDefaultPFramesPerKey,
            /* [out] */ double *pDefaultQuality,
            /* [out] */ long *pCapabilities);
        
        HRESULT ( STDMETHODCALLTYPE *OverrideKeyFrame )( 
            IAMVideoCompression * This,
            /* [in] */ long FrameNumber);
        
        HRESULT ( STDMETHODCALLTYPE *OverrideFrameSize )( 
            IAMVideoCompression * This,
            /* [in] */ long FrameNumber,
            /* [in] */ long Size);
        
        END_INTERFACE
    } IAMVideoCompressionVtbl;

    interface IAMVideoCompression
    {
        CONST_VTBL struct IAMVideoCompressionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMVideoCompression_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMVideoCompression_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMVideoCompression_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMVideoCompression_put_KeyFrameRate(This,KeyFrameRate)	\
    ( (This)->lpVtbl -> put_KeyFrameRate(This,KeyFrameRate) ) 

#define IAMVideoCompression_get_KeyFrameRate(This,pKeyFrameRate)	\
    ( (This)->lpVtbl -> get_KeyFrameRate(This,pKeyFrameRate) ) 

#define IAMVideoCompression_put_PFramesPerKeyFrame(This,PFramesPerKeyFrame)	\
    ( (This)->lpVtbl -> put_PFramesPerKeyFrame(This,PFramesPerKeyFrame) ) 

#define IAMVideoCompression_get_PFramesPerKeyFrame(This,pPFramesPerKeyFrame)	\
    ( (This)->lpVtbl -> get_PFramesPerKeyFrame(This,pPFramesPerKeyFrame) ) 

#define IAMVideoCompression_put_Quality(This,Quality)	\
    ( (This)->lpVtbl -> put_Quality(This,Quality) ) 

#define IAMVideoCompression_get_Quality(This,pQuality)	\
    ( (This)->lpVtbl -> get_Quality(This,pQuality) ) 

#define IAMVideoCompression_put_WindowSize(This,WindowSize)	\
    ( (This)->lpVtbl -> put_WindowSize(This,WindowSize) ) 

#define IAMVideoCompression_get_WindowSize(This,pWindowSize)	\
    ( (This)->lpVtbl -> get_WindowSize(This,pWindowSize) ) 

#define IAMVideoCompression_GetInfo(This,pszVersion,pcbVersion,pszDescription,pcbDescription,pDefaultKeyFrameRate,pDefaultPFramesPerKey,pDefaultQuality,pCapabilities)	\
    ( (This)->lpVtbl -> GetInfo(This,pszVersion,pcbVersion,pszDescription,pcbDescription,pDefaultKeyFrameRate,pDefaultPFramesPerKey,pDefaultQuality,pCapabilities) ) 

#define IAMVideoCompression_OverrideKeyFrame(This,FrameNumber)	\
    ( (This)->lpVtbl -> OverrideKeyFrame(This,FrameNumber) ) 

#define IAMVideoCompression_OverrideFrameSize(This,FrameNumber,Size)	\
    ( (This)->lpVtbl -> OverrideFrameSize(This,FrameNumber,Size) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMVideoCompression_INTERFACE_DEFINED__ */


#ifndef __IAMDroppedFrames_INTERFACE_DEFINED__
#define __IAMDroppedFrames_INTERFACE_DEFINED__

/* interface IAMDroppedFrames */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMDroppedFrames;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C6E13344-30AC-11d0-A18C-00A0C9118956")
    IAMDroppedFrames : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNumDropped( 
            /* [out] */ long *plDropped) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNumNotDropped( 
            /* [out] */ long *plNotDropped) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDroppedInfo( 
            /* [in] */ long lSize,
            /* [out] */ long *plArray,
            /* [out] */ long *plNumCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAverageFrameSize( 
            /* [out] */ long *plAverageSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMDroppedFramesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMDroppedFrames * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMDroppedFrames * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMDroppedFrames * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetNumDropped )( 
            IAMDroppedFrames * This,
            /* [out] */ long *plDropped);
        
        HRESULT ( STDMETHODCALLTYPE *GetNumNotDropped )( 
            IAMDroppedFrames * This,
            /* [out] */ long *plNotDropped);
        
        HRESULT ( STDMETHODCALLTYPE *GetDroppedInfo )( 
            IAMDroppedFrames * This,
            /* [in] */ long lSize,
            /* [out] */ long *plArray,
            /* [out] */ long *plNumCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetAverageFrameSize )( 
            IAMDroppedFrames * This,
            /* [out] */ long *plAverageSize);
        
        END_INTERFACE
    } IAMDroppedFramesVtbl;

    interface IAMDroppedFrames
    {
        CONST_VTBL struct IAMDroppedFramesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMDroppedFrames_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMDroppedFrames_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMDroppedFrames_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMDroppedFrames_GetNumDropped(This,plDropped)	\
    ( (This)->lpVtbl -> GetNumDropped(This,plDropped) ) 

#define IAMDroppedFrames_GetNumNotDropped(This,plNotDropped)	\
    ( (This)->lpVtbl -> GetNumNotDropped(This,plNotDropped) ) 

#define IAMDroppedFrames_GetDroppedInfo(This,lSize,plArray,plNumCopied)	\
    ( (This)->lpVtbl -> GetDroppedInfo(This,lSize,plArray,plNumCopied) ) 

#define IAMDroppedFrames_GetAverageFrameSize(This,plAverageSize)	\
    ( (This)->lpVtbl -> GetAverageFrameSize(This,plAverageSize) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMDroppedFrames_INTERFACE_DEFINED__ */


#ifndef __IAMBufferNegotiation_INTERFACE_DEFINED__
#define __IAMBufferNegotiation_INTERFACE_DEFINED__

/* interface IAMBufferNegotiation */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMBufferNegotiation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56ED71A0-AF5F-11D0-B3F0-00AA003761C5")
    IAMBufferNegotiation : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SuggestAllocatorProperties( 
            /* [in] */ const ALLOCATOR_PROPERTIES *pprop) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllocatorProperties( 
            /* [out] */ ALLOCATOR_PROPERTIES *pprop) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMBufferNegotiationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMBufferNegotiation * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMBufferNegotiation * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMBufferNegotiation * This);
        
        HRESULT ( STDMETHODCALLTYPE *SuggestAllocatorProperties )( 
            IAMBufferNegotiation * This,
            /* [in] */ const ALLOCATOR_PROPERTIES *pprop);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocatorProperties )( 
            IAMBufferNegotiation * This,
            /* [out] */ ALLOCATOR_PROPERTIES *pprop);
        
        END_INTERFACE
    } IAMBufferNegotiationVtbl;

    interface IAMBufferNegotiation
    {
        CONST_VTBL struct IAMBufferNegotiationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMBufferNegotiation_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMBufferNegotiation_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMBufferNegotiation_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMBufferNegotiation_SuggestAllocatorProperties(This,pprop)	\
    ( (This)->lpVtbl -> SuggestAllocatorProperties(This,pprop) ) 

#define IAMBufferNegotiation_GetAllocatorProperties(This,pprop)	\
    ( (This)->lpVtbl -> GetAllocatorProperties(This,pprop) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMBufferNegotiation_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0052 */
/* [local] */ 

typedef 
enum tagAnalogVideoStandard
    {	AnalogVideo_None	= 0,
	AnalogVideo_NTSC_M	= 0x1,
	AnalogVideo_NTSC_M_J	= 0x2,
	AnalogVideo_NTSC_433	= 0x4,
	AnalogVideo_PAL_B	= 0x10,
	AnalogVideo_PAL_D	= 0x20,
	AnalogVideo_PAL_G	= 0x40,
	AnalogVideo_PAL_H	= 0x80,
	AnalogVideo_PAL_I	= 0x100,
	AnalogVideo_PAL_M	= 0x200,
	AnalogVideo_PAL_N	= 0x400,
	AnalogVideo_PAL_60	= 0x800,
	AnalogVideo_SECAM_B	= 0x1000,
	AnalogVideo_SECAM_D	= 0x2000,
	AnalogVideo_SECAM_G	= 0x4000,
	AnalogVideo_SECAM_H	= 0x8000,
	AnalogVideo_SECAM_K	= 0x10000,
	AnalogVideo_SECAM_K1	= 0x20000,
	AnalogVideo_SECAM_L	= 0x40000,
	AnalogVideo_SECAM_L1	= 0x80000
    } 	AnalogVideoStandard;

#define AnalogVideo_NTSC_Mask  0x00000007
#define AnalogVideo_PAL_Mask   0x00000FF0
#define AnalogVideo_SECAM_Mask 0x000FF000
typedef 
enum tagTunerInputType
    {	TunerInputCable	= 0,
	TunerInputAntenna	= ( TunerInputCable + 1 ) 
    } 	TunerInputType;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_strmif_0000_0052_0001
    {	VideoCopyProtectionMacrovisionBasic	= 0,
	VideoCopyProtectionMacrovisionCBI	= ( VideoCopyProtectionMacrovisionBasic + 1 ) 
    } 	VideoCopyProtectionType;

typedef 
enum tagPhysicalConnectorType
    {	PhysConn_Video_Tuner	= 1,
	PhysConn_Video_Composite	= ( PhysConn_Video_Tuner + 1 ) ,
	PhysConn_Video_SVideo	= ( PhysConn_Video_Composite + 1 ) ,
	PhysConn_Video_RGB	= ( PhysConn_Video_SVideo + 1 ) ,
	PhysConn_Video_YRYBY	= ( PhysConn_Video_RGB + 1 ) ,
	PhysConn_Video_SerialDigital	= ( PhysConn_Video_YRYBY + 1 ) ,
	PhysConn_Video_ParallelDigital	= ( PhysConn_Video_SerialDigital + 1 ) ,
	PhysConn_Video_SCSI	= ( PhysConn_Video_ParallelDigital + 1 ) ,
	PhysConn_Video_AUX	= ( PhysConn_Video_SCSI + 1 ) ,
	PhysConn_Video_1394	= ( PhysConn_Video_AUX + 1 ) ,
	PhysConn_Video_USB	= ( PhysConn_Video_1394 + 1 ) ,
	PhysConn_Video_VideoDecoder	= ( PhysConn_Video_USB + 1 ) ,
	PhysConn_Video_VideoEncoder	= ( PhysConn_Video_VideoDecoder + 1 ) ,
	PhysConn_Video_SCART	= ( PhysConn_Video_VideoEncoder + 1 ) ,
	PhysConn_Video_Black	= ( PhysConn_Video_SCART + 1 ) ,
	PhysConn_Audio_Tuner	= 0x1000,
	PhysConn_Audio_Line	= ( PhysConn_Audio_Tuner + 1 ) ,
	PhysConn_Audio_Mic	= ( PhysConn_Audio_Line + 1 ) ,
	PhysConn_Audio_AESDigital	= ( PhysConn_Audio_Mic + 1 ) ,
	PhysConn_Audio_SPDIFDigital	= ( PhysConn_Audio_AESDigital + 1 ) ,
	PhysConn_Audio_SCSI	= ( PhysConn_Audio_SPDIFDigital + 1 ) ,
	PhysConn_Audio_AUX	= ( PhysConn_Audio_SCSI + 1 ) ,
	PhysConn_Audio_1394	= ( PhysConn_Audio_AUX + 1 ) ,
	PhysConn_Audio_USB	= ( PhysConn_Audio_1394 + 1 ) ,
	PhysConn_Audio_AudioDecoder	= ( PhysConn_Audio_USB + 1 ) 
    } 	PhysicalConnectorType;

typedef 
enum tagVideoProcAmpProperty
    {	VideoProcAmp_Brightness	= 0,
	VideoProcAmp_Contrast	= ( VideoProcAmp_Brightness + 1 ) ,
	VideoProcAmp_Hue	= ( VideoProcAmp_Contrast + 1 ) ,
	VideoProcAmp_Saturation	= ( VideoProcAmp_Hue + 1 ) ,
	VideoProcAmp_Sharpness	= ( VideoProcAmp_Saturation + 1 ) ,
	VideoProcAmp_Gamma	= ( VideoProcAmp_Sharpness + 1 ) ,
	VideoProcAmp_ColorEnable	= ( VideoProcAmp_Gamma + 1 ) ,
	VideoProcAmp_WhiteBalance	= ( VideoProcAmp_ColorEnable + 1 ) ,
	VideoProcAmp_BacklightCompensation	= ( VideoProcAmp_WhiteBalance + 1 ) 
    } 	VideoProcAmpProperty;

typedef 
enum tagVideoProcAmpFlags
    {	VideoProcAmp_Flags_Auto	= 0x1,
	VideoProcAmp_Flags_Manual	= 0x2
    } 	VideoProcAmpFlags;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0052_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0052_v0_0_s_ifspec;

#ifndef __IAMVideoProcAmp_INTERFACE_DEFINED__
#define __IAMVideoProcAmp_INTERFACE_DEFINED__

/* interface IAMVideoProcAmp */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMVideoProcAmp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C6E13360-30AC-11d0-A18C-00A0C9118956")
    IAMVideoProcAmp : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRange( 
            /* [in] */ long Property,
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Set( 
            /* [in] */ long Property,
            /* [in] */ long lValue,
            /* [in] */ long Flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Get( 
            /* [in] */ long Property,
            /* [out] */ long *lValue,
            /* [out] */ long *Flags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMVideoProcAmpVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMVideoProcAmp * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMVideoProcAmp * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMVideoProcAmp * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRange )( 
            IAMVideoProcAmp * This,
            /* [in] */ long Property,
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Set )( 
            IAMVideoProcAmp * This,
            /* [in] */ long Property,
            /* [in] */ long lValue,
            /* [in] */ long Flags);
        
        HRESULT ( STDMETHODCALLTYPE *Get )( 
            IAMVideoProcAmp * This,
            /* [in] */ long Property,
            /* [out] */ long *lValue,
            /* [out] */ long *Flags);
        
        END_INTERFACE
    } IAMVideoProcAmpVtbl;

    interface IAMVideoProcAmp
    {
        CONST_VTBL struct IAMVideoProcAmpVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMVideoProcAmp_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMVideoProcAmp_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMVideoProcAmp_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMVideoProcAmp_GetRange(This,Property,pMin,pMax,pSteppingDelta,pDefault,pCapsFlags)	\
    ( (This)->lpVtbl -> GetRange(This,Property,pMin,pMax,pSteppingDelta,pDefault,pCapsFlags) ) 

#define IAMVideoProcAmp_Set(This,Property,lValue,Flags)	\
    ( (This)->lpVtbl -> Set(This,Property,lValue,Flags) ) 

#define IAMVideoProcAmp_Get(This,Property,lValue,Flags)	\
    ( (This)->lpVtbl -> Get(This,Property,lValue,Flags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMVideoProcAmp_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0053 */
/* [local] */ 

typedef 
enum tagCameraControlProperty
    {	CameraControl_Pan	= 0,
	CameraControl_Tilt	= ( CameraControl_Pan + 1 ) ,
	CameraControl_Roll	= ( CameraControl_Tilt + 1 ) ,
	CameraControl_Zoom	= ( CameraControl_Roll + 1 ) ,
	CameraControl_Exposure	= ( CameraControl_Zoom + 1 ) ,
	CameraControl_Iris	= ( CameraControl_Exposure + 1 ) ,
	CameraControl_Focus	= ( CameraControl_Iris + 1 ) ,
	CameraControl_Flash	= ( CameraControl_Focus + 1 ) 
    } 	CameraControlProperty;

typedef 
enum tagCameraControlFlags
    {	CameraControl_Flags_Auto	= 0x1,
	CameraControl_Flags_Manual	= 0x2,
	CameraControl_Flags_Asynchronous_Auto	= 0x4
    } 	CameraControlFlags;

typedef 
enum tagCameraAsyncActionStatus
    {	ACTION_NORMAL_COMPLETION	= 0,
	ACTION_CANCELLED	= ( ACTION_NORMAL_COMPLETION + 1 ) 
    } 	CameraAsyncActionStatus;

typedef 
enum tagCameraControlAsyncAction
    {	CAMERACONTROL_START	= 0x1,
	CAMERACONTROL_STOP	= 0x2
    } 	CameraControlAsyncAction;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0053_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0053_v0_0_s_ifspec;

#ifndef __IAMCameraControl_INTERFACE_DEFINED__
#define __IAMCameraControl_INTERFACE_DEFINED__

/* interface IAMCameraControl */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMCameraControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C6E13370-30AC-11d0-A18C-00A0C9118956")
    IAMCameraControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRange( 
            /* [in] */ long Property,
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Set( 
            /* [in] */ long Property,
            /* [in] */ long lValue,
            /* [in] */ long Flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Get( 
            /* [in] */ long Property,
            /* [out] */ long *lValue,
            /* [out] */ long *Flags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMCameraControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMCameraControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMCameraControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMCameraControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRange )( 
            IAMCameraControl * This,
            /* [in] */ long Property,
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Set )( 
            IAMCameraControl * This,
            /* [in] */ long Property,
            /* [in] */ long lValue,
            /* [in] */ long Flags);
        
        HRESULT ( STDMETHODCALLTYPE *Get )( 
            IAMCameraControl * This,
            /* [in] */ long Property,
            /* [out] */ long *lValue,
            /* [out] */ long *Flags);
        
        END_INTERFACE
    } IAMCameraControlVtbl;

    interface IAMCameraControl
    {
        CONST_VTBL struct IAMCameraControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMCameraControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMCameraControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMCameraControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMCameraControl_GetRange(This,Property,pMin,pMax,pSteppingDelta,pDefault,pCapsFlags)	\
    ( (This)->lpVtbl -> GetRange(This,Property,pMin,pMax,pSteppingDelta,pDefault,pCapsFlags) ) 

#define IAMCameraControl_Set(This,Property,lValue,Flags)	\
    ( (This)->lpVtbl -> Set(This,Property,lValue,Flags) ) 

#define IAMCameraControl_Get(This,Property,lValue,Flags)	\
    ( (This)->lpVtbl -> Get(This,Property,lValue,Flags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMCameraControl_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0054 */
/* [local] */ 

typedef 
enum tagVideoControlFlags
    {	VideoControlFlag_FlipHorizontal	= 0x1,
	VideoControlFlag_FlipVertical	= 0x2,
	VideoControlFlag_ExternalTriggerEnable	= 0x4,
	VideoControlFlag_Trigger	= 0x8,
	VideoControlFlag_Sample_Scanned_Notification	= 0x40
    } 	VideoControlFlags;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0054_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0054_v0_0_s_ifspec;

#ifndef __IAMVideoControl_INTERFACE_DEFINED__
#define __IAMVideoControl_INTERFACE_DEFINED__

/* interface IAMVideoControl */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMVideoControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6a2e0670-28e4-11d0-a18c-00a0c9118956")
    IAMVideoControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCaps( 
            /* [in] */ IPin *pPin,
            /* [out] */ long *pCapsFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMode( 
            /* [in] */ IPin *pPin,
            /* [in] */ long Mode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMode( 
            /* [in] */ IPin *pPin,
            /* [out] */ long *Mode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentActualFrameRate( 
            /* [in] */ IPin *pPin,
            /* [out] */ LONGLONG *ActualFrameRate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxAvailableFrameRate( 
            /* [in] */ IPin *pPin,
            /* [in] */ long iIndex,
            /* [in] */ SIZE Dimensions,
            /* [out] */ LONGLONG *MaxAvailableFrameRate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFrameRateList( 
            /* [in] */ IPin *pPin,
            /* [in] */ long iIndex,
            /* [in] */ SIZE Dimensions,
            /* [out] */ long *ListSize,
            /* [out] */ LONGLONG **FrameRates) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMVideoControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMVideoControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMVideoControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMVideoControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCaps )( 
            IAMVideoControl * This,
            /* [in] */ IPin *pPin,
            /* [out] */ long *pCapsFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetMode )( 
            IAMVideoControl * This,
            /* [in] */ IPin *pPin,
            /* [in] */ long Mode);
        
        HRESULT ( STDMETHODCALLTYPE *GetMode )( 
            IAMVideoControl * This,
            /* [in] */ IPin *pPin,
            /* [out] */ long *Mode);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentActualFrameRate )( 
            IAMVideoControl * This,
            /* [in] */ IPin *pPin,
            /* [out] */ LONGLONG *ActualFrameRate);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxAvailableFrameRate )( 
            IAMVideoControl * This,
            /* [in] */ IPin *pPin,
            /* [in] */ long iIndex,
            /* [in] */ SIZE Dimensions,
            /* [out] */ LONGLONG *MaxAvailableFrameRate);
        
        HRESULT ( STDMETHODCALLTYPE *GetFrameRateList )( 
            IAMVideoControl * This,
            /* [in] */ IPin *pPin,
            /* [in] */ long iIndex,
            /* [in] */ SIZE Dimensions,
            /* [out] */ long *ListSize,
            /* [out] */ LONGLONG **FrameRates);
        
        END_INTERFACE
    } IAMVideoControlVtbl;

    interface IAMVideoControl
    {
        CONST_VTBL struct IAMVideoControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMVideoControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMVideoControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMVideoControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMVideoControl_GetCaps(This,pPin,pCapsFlags)	\
    ( (This)->lpVtbl -> GetCaps(This,pPin,pCapsFlags) ) 

#define IAMVideoControl_SetMode(This,pPin,Mode)	\
    ( (This)->lpVtbl -> SetMode(This,pPin,Mode) ) 

#define IAMVideoControl_GetMode(This,pPin,Mode)	\
    ( (This)->lpVtbl -> GetMode(This,pPin,Mode) ) 

#define IAMVideoControl_GetCurrentActualFrameRate(This,pPin,ActualFrameRate)	\
    ( (This)->lpVtbl -> GetCurrentActualFrameRate(This,pPin,ActualFrameRate) ) 

#define IAMVideoControl_GetMaxAvailableFrameRate(This,pPin,iIndex,Dimensions,MaxAvailableFrameRate)	\
    ( (This)->lpVtbl -> GetMaxAvailableFrameRate(This,pPin,iIndex,Dimensions,MaxAvailableFrameRate) ) 

#define IAMVideoControl_GetFrameRateList(This,pPin,iIndex,Dimensions,ListSize,FrameRates)	\
    ( (This)->lpVtbl -> GetFrameRateList(This,pPin,iIndex,Dimensions,ListSize,FrameRates) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMVideoControl_INTERFACE_DEFINED__ */


#ifndef __IAMCrossbar_INTERFACE_DEFINED__
#define __IAMCrossbar_INTERFACE_DEFINED__

/* interface IAMCrossbar */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMCrossbar;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C6E13380-30AC-11d0-A18C-00A0C9118956")
    IAMCrossbar : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE get_PinCounts( 
            /* [out] */ long *OutputPinCount,
            /* [out] */ long *InputPinCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanRoute( 
            /* [in] */ long OutputPinIndex,
            /* [in] */ long InputPinIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Route( 
            /* [in] */ long OutputPinIndex,
            /* [in] */ long InputPinIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_IsRoutedTo( 
            /* [in] */ long OutputPinIndex,
            /* [out] */ long *InputPinIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_CrossbarPinInfo( 
            /* [in] */ BOOL IsInputPin,
            /* [in] */ long PinIndex,
            /* [out] */ long *PinIndexRelated,
            /* [out] */ long *PhysicalType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMCrossbarVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMCrossbar * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMCrossbar * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMCrossbar * This);
        
        HRESULT ( STDMETHODCALLTYPE *get_PinCounts )( 
            IAMCrossbar * This,
            /* [out] */ long *OutputPinCount,
            /* [out] */ long *InputPinCount);
        
        HRESULT ( STDMETHODCALLTYPE *CanRoute )( 
            IAMCrossbar * This,
            /* [in] */ long OutputPinIndex,
            /* [in] */ long InputPinIndex);
        
        HRESULT ( STDMETHODCALLTYPE *Route )( 
            IAMCrossbar * This,
            /* [in] */ long OutputPinIndex,
            /* [in] */ long InputPinIndex);
        
        HRESULT ( STDMETHODCALLTYPE *get_IsRoutedTo )( 
            IAMCrossbar * This,
            /* [in] */ long OutputPinIndex,
            /* [out] */ long *InputPinIndex);
        
        HRESULT ( STDMETHODCALLTYPE *get_CrossbarPinInfo )( 
            IAMCrossbar * This,
            /* [in] */ BOOL IsInputPin,
            /* [in] */ long PinIndex,
            /* [out] */ long *PinIndexRelated,
            /* [out] */ long *PhysicalType);
        
        END_INTERFACE
    } IAMCrossbarVtbl;

    interface IAMCrossbar
    {
        CONST_VTBL struct IAMCrossbarVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMCrossbar_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMCrossbar_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMCrossbar_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMCrossbar_get_PinCounts(This,OutputPinCount,InputPinCount)	\
    ( (This)->lpVtbl -> get_PinCounts(This,OutputPinCount,InputPinCount) ) 

#define IAMCrossbar_CanRoute(This,OutputPinIndex,InputPinIndex)	\
    ( (This)->lpVtbl -> CanRoute(This,OutputPinIndex,InputPinIndex) ) 

#define IAMCrossbar_Route(This,OutputPinIndex,InputPinIndex)	\
    ( (This)->lpVtbl -> Route(This,OutputPinIndex,InputPinIndex) ) 

#define IAMCrossbar_get_IsRoutedTo(This,OutputPinIndex,InputPinIndex)	\
    ( (This)->lpVtbl -> get_IsRoutedTo(This,OutputPinIndex,InputPinIndex) ) 

#define IAMCrossbar_get_CrossbarPinInfo(This,IsInputPin,PinIndex,PinIndexRelated,PhysicalType)	\
    ( (This)->lpVtbl -> get_CrossbarPinInfo(This,IsInputPin,PinIndex,PinIndexRelated,PhysicalType) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMCrossbar_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0056 */
/* [local] */ 

typedef 
enum tagAMTunerSubChannel
    {	AMTUNER_SUBCHAN_NO_TUNE	= -2,
	AMTUNER_SUBCHAN_DEFAULT	= -1
    } 	AMTunerSubChannel;

typedef 
enum tagAMTunerSignalStrength
    {	AMTUNER_HASNOSIGNALSTRENGTH	= -1,
	AMTUNER_NOSIGNAL	= 0,
	AMTUNER_SIGNALPRESENT	= 1
    } 	AMTunerSignalStrength;

typedef 
enum tagAMTunerModeType
    {	AMTUNER_MODE_DEFAULT	= 0,
	AMTUNER_MODE_TV	= 0x1,
	AMTUNER_MODE_FM_RADIO	= 0x2,
	AMTUNER_MODE_AM_RADIO	= 0x4,
	AMTUNER_MODE_DSS	= 0x8
    } 	AMTunerModeType;

typedef 
enum tagAMTunerEventType
    {	AMTUNER_EVENT_CHANGED	= 0x1
    } 	AMTunerEventType;




extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0056_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0056_v0_0_s_ifspec;

#ifndef __IAMTuner_INTERFACE_DEFINED__
#define __IAMTuner_INTERFACE_DEFINED__

/* interface IAMTuner */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IAMTuner;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("211A8761-03AC-11d1-8D13-00AA00BD8339")
    IAMTuner : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE put_Channel( 
            /* [in] */ long lChannel,
            /* [in] */ long lVideoSubChannel,
            /* [in] */ long lAudioSubChannel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Channel( 
            /* [out] */ long *plChannel,
            /* [out] */ long *plVideoSubChannel,
            /* [out] */ long *plAudioSubChannel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChannelMinMax( 
            /* [out] */ long *lChannelMin,
            /* [out] */ long *lChannelMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_CountryCode( 
            /* [in] */ long lCountryCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_CountryCode( 
            /* [out] */ long *plCountryCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_TuningSpace( 
            /* [in] */ long lTuningSpace) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_TuningSpace( 
            /* [out] */ long *plTuningSpace) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Logon( 
            /* [in] */ HANDLE hCurrentUser) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Logout( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SignalPresent( 
            /* [out] */ long *plSignalStrength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_Mode( 
            /* [in] */ AMTunerModeType lMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Mode( 
            /* [out] */ AMTunerModeType *plMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAvailableModes( 
            /* [out] */ long *plModes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterNotificationCallBack( 
            /* [in] */ IAMTunerNotification *pNotify,
            /* [in] */ long lEvents) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnRegisterNotificationCallBack( 
            IAMTunerNotification *pNotify) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMTunerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMTuner * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMTuner * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMTuner * This);
        
        HRESULT ( STDMETHODCALLTYPE *put_Channel )( 
            IAMTuner * This,
            /* [in] */ long lChannel,
            /* [in] */ long lVideoSubChannel,
            /* [in] */ long lAudioSubChannel);
        
        HRESULT ( STDMETHODCALLTYPE *get_Channel )( 
            IAMTuner * This,
            /* [out] */ long *plChannel,
            /* [out] */ long *plVideoSubChannel,
            /* [out] */ long *plAudioSubChannel);
        
        HRESULT ( STDMETHODCALLTYPE *ChannelMinMax )( 
            IAMTuner * This,
            /* [out] */ long *lChannelMin,
            /* [out] */ long *lChannelMax);
        
        HRESULT ( STDMETHODCALLTYPE *put_CountryCode )( 
            IAMTuner * This,
            /* [in] */ long lCountryCode);
        
        HRESULT ( STDMETHODCALLTYPE *get_CountryCode )( 
            IAMTuner * This,
            /* [out] */ long *plCountryCode);
        
        HRESULT ( STDMETHODCALLTYPE *put_TuningSpace )( 
            IAMTuner * This,
            /* [in] */ long lTuningSpace);
        
        HRESULT ( STDMETHODCALLTYPE *get_TuningSpace )( 
            IAMTuner * This,
            /* [out] */ long *plTuningSpace);
        
        HRESULT ( STDMETHODCALLTYPE *Logon )( 
            IAMTuner * This,
            /* [in] */ HANDLE hCurrentUser);
        
        HRESULT ( STDMETHODCALLTYPE *Logout )( 
            IAMTuner * This);
        
        HRESULT ( STDMETHODCALLTYPE *SignalPresent )( 
            IAMTuner * This,
            /* [out] */ long *plSignalStrength);
        
        HRESULT ( STDMETHODCALLTYPE *put_Mode )( 
            IAMTuner * This,
            /* [in] */ AMTunerModeType lMode);
        
        HRESULT ( STDMETHODCALLTYPE *get_Mode )( 
            IAMTuner * This,
            /* [out] */ AMTunerModeType *plMode);
        
        HRESULT ( STDMETHODCALLTYPE *GetAvailableModes )( 
            IAMTuner * This,
            /* [out] */ long *plModes);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterNotificationCallBack )( 
            IAMTuner * This,
            /* [in] */ IAMTunerNotification *pNotify,
            /* [in] */ long lEvents);
        
        HRESULT ( STDMETHODCALLTYPE *UnRegisterNotificationCallBack )( 
            IAMTuner * This,
            IAMTunerNotification *pNotify);
        
        END_INTERFACE
    } IAMTunerVtbl;

    interface IAMTuner
    {
        CONST_VTBL struct IAMTunerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMTuner_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMTuner_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMTuner_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMTuner_put_Channel(This,lChannel,lVideoSubChannel,lAudioSubChannel)	\
    ( (This)->lpVtbl -> put_Channel(This,lChannel,lVideoSubChannel,lAudioSubChannel) ) 

#define IAMTuner_get_Channel(This,plChannel,plVideoSubChannel,plAudioSubChannel)	\
    ( (This)->lpVtbl -> get_Channel(This,plChannel,plVideoSubChannel,plAudioSubChannel) ) 

#define IAMTuner_ChannelMinMax(This,lChannelMin,lChannelMax)	\
    ( (This)->lpVtbl -> ChannelMinMax(This,lChannelMin,lChannelMax) ) 

#define IAMTuner_put_CountryCode(This,lCountryCode)	\
    ( (This)->lpVtbl -> put_CountryCode(This,lCountryCode) ) 

#define IAMTuner_get_CountryCode(This,plCountryCode)	\
    ( (This)->lpVtbl -> get_CountryCode(This,plCountryCode) ) 

#define IAMTuner_put_TuningSpace(This,lTuningSpace)	\
    ( (This)->lpVtbl -> put_TuningSpace(This,lTuningSpace) ) 

#define IAMTuner_get_TuningSpace(This,plTuningSpace)	\
    ( (This)->lpVtbl -> get_TuningSpace(This,plTuningSpace) ) 

#define IAMTuner_Logon(This,hCurrentUser)	\
    ( (This)->lpVtbl -> Logon(This,hCurrentUser) ) 

#define IAMTuner_Logout(This)	\
    ( (This)->lpVtbl -> Logout(This) ) 

#define IAMTuner_SignalPresent(This,plSignalStrength)	\
    ( (This)->lpVtbl -> SignalPresent(This,plSignalStrength) ) 

#define IAMTuner_put_Mode(This,lMode)	\
    ( (This)->lpVtbl -> put_Mode(This,lMode) ) 

#define IAMTuner_get_Mode(This,plMode)	\
    ( (This)->lpVtbl -> get_Mode(This,plMode) ) 

#define IAMTuner_GetAvailableModes(This,plModes)	\
    ( (This)->lpVtbl -> GetAvailableModes(This,plModes) ) 

#define IAMTuner_RegisterNotificationCallBack(This,pNotify,lEvents)	\
    ( (This)->lpVtbl -> RegisterNotificationCallBack(This,pNotify,lEvents) ) 

#define IAMTuner_UnRegisterNotificationCallBack(This,pNotify)	\
    ( (This)->lpVtbl -> UnRegisterNotificationCallBack(This,pNotify) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMTuner_INTERFACE_DEFINED__ */


#ifndef __IAMTunerNotification_INTERFACE_DEFINED__
#define __IAMTunerNotification_INTERFACE_DEFINED__

/* interface IAMTunerNotification */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IAMTunerNotification;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("211A8760-03AC-11d1-8D13-00AA00BD8339")
    IAMTunerNotification : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnEvent( 
            /* [in] */ AMTunerEventType Event) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMTunerNotificationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMTunerNotification * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMTunerNotification * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMTunerNotification * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnEvent )( 
            IAMTunerNotification * This,
            /* [in] */ AMTunerEventType Event);
        
        END_INTERFACE
    } IAMTunerNotificationVtbl;

    interface IAMTunerNotification
    {
        CONST_VTBL struct IAMTunerNotificationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMTunerNotification_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMTunerNotification_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMTunerNotification_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMTunerNotification_OnEvent(This,Event)	\
    ( (This)->lpVtbl -> OnEvent(This,Event) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMTunerNotification_INTERFACE_DEFINED__ */


#ifndef __IAMTVTuner_INTERFACE_DEFINED__
#define __IAMTVTuner_INTERFACE_DEFINED__

/* interface IAMTVTuner */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IAMTVTuner;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("211A8766-03AC-11d1-8D13-00AA00BD8339")
    IAMTVTuner : public IAMTuner
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE get_AvailableTVFormats( 
            /* [out] */ long *lAnalogVideoStandard) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_TVFormat( 
            /* [out] */ long *plAnalogVideoStandard) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AutoTune( 
            /* [in] */ long lChannel,
            /* [out] */ long *plFoundSignal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StoreAutoTune( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_NumInputConnections( 
            /* [out] */ long *plNumInputConnections) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_InputType( 
            /* [in] */ long lIndex,
            /* [in] */ TunerInputType InputType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_InputType( 
            /* [in] */ long lIndex,
            /* [out] */ TunerInputType *pInputType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_ConnectInput( 
            /* [in] */ long lIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_ConnectInput( 
            /* [out] */ long *plIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_VideoFrequency( 
            /* [out] */ long *lFreq) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_AudioFrequency( 
            /* [out] */ long *lFreq) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMTVTunerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMTVTuner * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMTVTuner * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMTVTuner * This);
        
        HRESULT ( STDMETHODCALLTYPE *put_Channel )( 
            IAMTVTuner * This,
            /* [in] */ long lChannel,
            /* [in] */ long lVideoSubChannel,
            /* [in] */ long lAudioSubChannel);
        
        HRESULT ( STDMETHODCALLTYPE *get_Channel )( 
            IAMTVTuner * This,
            /* [out] */ long *plChannel,
            /* [out] */ long *plVideoSubChannel,
            /* [out] */ long *plAudioSubChannel);
        
        HRESULT ( STDMETHODCALLTYPE *ChannelMinMax )( 
            IAMTVTuner * This,
            /* [out] */ long *lChannelMin,
            /* [out] */ long *lChannelMax);
        
        HRESULT ( STDMETHODCALLTYPE *put_CountryCode )( 
            IAMTVTuner * This,
            /* [in] */ long lCountryCode);
        
        HRESULT ( STDMETHODCALLTYPE *get_CountryCode )( 
            IAMTVTuner * This,
            /* [out] */ long *plCountryCode);
        
        HRESULT ( STDMETHODCALLTYPE *put_TuningSpace )( 
            IAMTVTuner * This,
            /* [in] */ long lTuningSpace);
        
        HRESULT ( STDMETHODCALLTYPE *get_TuningSpace )( 
            IAMTVTuner * This,
            /* [out] */ long *plTuningSpace);
        
        HRESULT ( STDMETHODCALLTYPE *Logon )( 
            IAMTVTuner * This,
            /* [in] */ HANDLE hCurrentUser);
        
        HRESULT ( STDMETHODCALLTYPE *Logout )( 
            IAMTVTuner * This);
        
        HRESULT ( STDMETHODCALLTYPE *SignalPresent )( 
            IAMTVTuner * This,
            /* [out] */ long *plSignalStrength);
        
        HRESULT ( STDMETHODCALLTYPE *put_Mode )( 
            IAMTVTuner * This,
            /* [in] */ AMTunerModeType lMode);
        
        HRESULT ( STDMETHODCALLTYPE *get_Mode )( 
            IAMTVTuner * This,
            /* [out] */ AMTunerModeType *plMode);
        
        HRESULT ( STDMETHODCALLTYPE *GetAvailableModes )( 
            IAMTVTuner * This,
            /* [out] */ long *plModes);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterNotificationCallBack )( 
            IAMTVTuner * This,
            /* [in] */ IAMTunerNotification *pNotify,
            /* [in] */ long lEvents);
        
        HRESULT ( STDMETHODCALLTYPE *UnRegisterNotificationCallBack )( 
            IAMTVTuner * This,
            IAMTunerNotification *pNotify);
        
        HRESULT ( STDMETHODCALLTYPE *get_AvailableTVFormats )( 
            IAMTVTuner * This,
            /* [out] */ long *lAnalogVideoStandard);
        
        HRESULT ( STDMETHODCALLTYPE *get_TVFormat )( 
            IAMTVTuner * This,
            /* [out] */ long *plAnalogVideoStandard);
        
        HRESULT ( STDMETHODCALLTYPE *AutoTune )( 
            IAMTVTuner * This,
            /* [in] */ long lChannel,
            /* [out] */ long *plFoundSignal);
        
        HRESULT ( STDMETHODCALLTYPE *StoreAutoTune )( 
            IAMTVTuner * This);
        
        HRESULT ( STDMETHODCALLTYPE *get_NumInputConnections )( 
            IAMTVTuner * This,
            /* [out] */ long *plNumInputConnections);
        
        HRESULT ( STDMETHODCALLTYPE *put_InputType )( 
            IAMTVTuner * This,
            /* [in] */ long lIndex,
            /* [in] */ TunerInputType InputType);
        
        HRESULT ( STDMETHODCALLTYPE *get_InputType )( 
            IAMTVTuner * This,
            /* [in] */ long lIndex,
            /* [out] */ TunerInputType *pInputType);
        
        HRESULT ( STDMETHODCALLTYPE *put_ConnectInput )( 
            IAMTVTuner * This,
            /* [in] */ long lIndex);
        
        HRESULT ( STDMETHODCALLTYPE *get_ConnectInput )( 
            IAMTVTuner * This,
            /* [out] */ long *plIndex);
        
        HRESULT ( STDMETHODCALLTYPE *get_VideoFrequency )( 
            IAMTVTuner * This,
            /* [out] */ long *lFreq);
        
        HRESULT ( STDMETHODCALLTYPE *get_AudioFrequency )( 
            IAMTVTuner * This,
            /* [out] */ long *lFreq);
        
        END_INTERFACE
    } IAMTVTunerVtbl;

    interface IAMTVTuner
    {
        CONST_VTBL struct IAMTVTunerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMTVTuner_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMTVTuner_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMTVTuner_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMTVTuner_put_Channel(This,lChannel,lVideoSubChannel,lAudioSubChannel)	\
    ( (This)->lpVtbl -> put_Channel(This,lChannel,lVideoSubChannel,lAudioSubChannel) ) 

#define IAMTVTuner_get_Channel(This,plChannel,plVideoSubChannel,plAudioSubChannel)	\
    ( (This)->lpVtbl -> get_Channel(This,plChannel,plVideoSubChannel,plAudioSubChannel) ) 

#define IAMTVTuner_ChannelMinMax(This,lChannelMin,lChannelMax)	\
    ( (This)->lpVtbl -> ChannelMinMax(This,lChannelMin,lChannelMax) ) 

#define IAMTVTuner_put_CountryCode(This,lCountryCode)	\
    ( (This)->lpVtbl -> put_CountryCode(This,lCountryCode) ) 

#define IAMTVTuner_get_CountryCode(This,plCountryCode)	\
    ( (This)->lpVtbl -> get_CountryCode(This,plCountryCode) ) 

#define IAMTVTuner_put_TuningSpace(This,lTuningSpace)	\
    ( (This)->lpVtbl -> put_TuningSpace(This,lTuningSpace) ) 

#define IAMTVTuner_get_TuningSpace(This,plTuningSpace)	\
    ( (This)->lpVtbl -> get_TuningSpace(This,plTuningSpace) ) 

#define IAMTVTuner_Logon(This,hCurrentUser)	\
    ( (This)->lpVtbl -> Logon(This,hCurrentUser) ) 

#define IAMTVTuner_Logout(This)	\
    ( (This)->lpVtbl -> Logout(This) ) 

#define IAMTVTuner_SignalPresent(This,plSignalStrength)	\
    ( (This)->lpVtbl -> SignalPresent(This,plSignalStrength) ) 

#define IAMTVTuner_put_Mode(This,lMode)	\
    ( (This)->lpVtbl -> put_Mode(This,lMode) ) 

#define IAMTVTuner_get_Mode(This,plMode)	\
    ( (This)->lpVtbl -> get_Mode(This,plMode) ) 

#define IAMTVTuner_GetAvailableModes(This,plModes)	\
    ( (This)->lpVtbl -> GetAvailableModes(This,plModes) ) 

#define IAMTVTuner_RegisterNotificationCallBack(This,pNotify,lEvents)	\
    ( (This)->lpVtbl -> RegisterNotificationCallBack(This,pNotify,lEvents) ) 

#define IAMTVTuner_UnRegisterNotificationCallBack(This,pNotify)	\
    ( (This)->lpVtbl -> UnRegisterNotificationCallBack(This,pNotify) ) 


#define IAMTVTuner_get_AvailableTVFormats(This,lAnalogVideoStandard)	\
    ( (This)->lpVtbl -> get_AvailableTVFormats(This,lAnalogVideoStandard) ) 

#define IAMTVTuner_get_TVFormat(This,plAnalogVideoStandard)	\
    ( (This)->lpVtbl -> get_TVFormat(This,plAnalogVideoStandard) ) 

#define IAMTVTuner_AutoTune(This,lChannel,plFoundSignal)	\
    ( (This)->lpVtbl -> AutoTune(This,lChannel,plFoundSignal) ) 

#define IAMTVTuner_StoreAutoTune(This)	\
    ( (This)->lpVtbl -> StoreAutoTune(This) ) 

#define IAMTVTuner_get_NumInputConnections(This,plNumInputConnections)	\
    ( (This)->lpVtbl -> get_NumInputConnections(This,plNumInputConnections) ) 

#define IAMTVTuner_put_InputType(This,lIndex,InputType)	\
    ( (This)->lpVtbl -> put_InputType(This,lIndex,InputType) ) 

#define IAMTVTuner_get_InputType(This,lIndex,pInputType)	\
    ( (This)->lpVtbl -> get_InputType(This,lIndex,pInputType) ) 

#define IAMTVTuner_put_ConnectInput(This,lIndex)	\
    ( (This)->lpVtbl -> put_ConnectInput(This,lIndex) ) 

#define IAMTVTuner_get_ConnectInput(This,plIndex)	\
    ( (This)->lpVtbl -> get_ConnectInput(This,plIndex) ) 

#define IAMTVTuner_get_VideoFrequency(This,lFreq)	\
    ( (This)->lpVtbl -> get_VideoFrequency(This,lFreq) ) 

#define IAMTVTuner_get_AudioFrequency(This,lFreq)	\
    ( (This)->lpVtbl -> get_AudioFrequency(This,lFreq) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMTVTuner_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0059 */
/* [local] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_strmif_0000_0059_0001
    {	AMPROPERTY_PIN_CATEGORY	= 0,
	AMPROPERTY_PIN_MEDIUM	= ( AMPROPERTY_PIN_CATEGORY + 1 ) 
    } 	AMPROPERTY_PIN;

#ifndef _IKsPropertySet_
#define _IKsPropertySet_
#define KSPROPERTY_SUPPORT_GET  1
#define KSPROPERTY_SUPPORT_SET  2


extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0059_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0059_v0_0_s_ifspec;

#ifndef __IKsPropertySet_INTERFACE_DEFINED__
#define __IKsPropertySet_INTERFACE_DEFINED__

/* interface IKsPropertySet */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IKsPropertySet;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("31EFAC30-515C-11d0-A9AA-00AA0061BE93")
    IKsPropertySet : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Set( 
            /* [in] */ REFGUID guidPropSet,
            /* [in] */ DWORD dwPropID,
            /* [size_is][out] */ LPVOID pInstanceData,
            /* [in] */ DWORD cbInstanceData,
            /* [size_is][out] */ LPVOID pPropData,
            /* [in] */ DWORD cbPropData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Get( 
            /* [in] */ REFGUID guidPropSet,
            /* [in] */ DWORD dwPropID,
            /* [size_is][out] */ LPVOID pInstanceData,
            /* [in] */ DWORD cbInstanceData,
            /* [size_is][out] */ LPVOID pPropData,
            /* [in] */ DWORD cbPropData,
            /* [out] */ DWORD *pcbReturned) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QuerySupported( 
            /* [in] */ REFGUID guidPropSet,
            /* [in] */ DWORD dwPropID,
            /* [out] */ DWORD *pTypeSupport) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IKsPropertySetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IKsPropertySet * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IKsPropertySet * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IKsPropertySet * This);
        
        HRESULT ( STDMETHODCALLTYPE *Set )( 
            IKsPropertySet * This,
            /* [in] */ REFGUID guidPropSet,
            /* [in] */ DWORD dwPropID,
            /* [size_is][out] */ LPVOID pInstanceData,
            /* [in] */ DWORD cbInstanceData,
            /* [size_is][out] */ LPVOID pPropData,
            /* [in] */ DWORD cbPropData);
        
        HRESULT ( STDMETHODCALLTYPE *Get )( 
            IKsPropertySet * This,
            /* [in] */ REFGUID guidPropSet,
            /* [in] */ DWORD dwPropID,
            /* [size_is][out] */ LPVOID pInstanceData,
            /* [in] */ DWORD cbInstanceData,
            /* [size_is][out] */ LPVOID pPropData,
            /* [in] */ DWORD cbPropData,
            /* [out] */ DWORD *pcbReturned);
        
        HRESULT ( STDMETHODCALLTYPE *QuerySupported )( 
            IKsPropertySet * This,
            /* [in] */ REFGUID guidPropSet,
            /* [in] */ DWORD dwPropID,
            /* [out] */ DWORD *pTypeSupport);
        
        END_INTERFACE
    } IKsPropertySetVtbl;

    interface IKsPropertySet
    {
        CONST_VTBL struct IKsPropertySetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IKsPropertySet_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IKsPropertySet_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IKsPropertySet_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IKsPropertySet_Set(This,guidPropSet,dwPropID,pInstanceData,cbInstanceData,pPropData,cbPropData)	\
    ( (This)->lpVtbl -> Set(This,guidPropSet,dwPropID,pInstanceData,cbInstanceData,pPropData,cbPropData) ) 

#define IKsPropertySet_Get(This,guidPropSet,dwPropID,pInstanceData,cbInstanceData,pPropData,cbPropData,pcbReturned)	\
    ( (This)->lpVtbl -> Get(This,guidPropSet,dwPropID,pInstanceData,cbInstanceData,pPropData,cbPropData,pcbReturned) ) 

#define IKsPropertySet_QuerySupported(This,guidPropSet,dwPropID,pTypeSupport)	\
    ( (This)->lpVtbl -> QuerySupported(This,guidPropSet,dwPropID,pTypeSupport) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IKsPropertySet_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0060 */
/* [local] */ 

#endif // _IKsPropertySet_


extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0060_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0060_v0_0_s_ifspec;

#ifndef __IMediaPropertyBag_INTERFACE_DEFINED__
#define __IMediaPropertyBag_INTERFACE_DEFINED__

/* interface IMediaPropertyBag */
/* [unique][uuid][object] */ 

typedef IMediaPropertyBag *LPMEDIAPROPERTYBAG;


EXTERN_C const IID IID_IMediaPropertyBag;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6025A880-C0D5-11d0-BD4E-00A0C911CE86")
    IMediaPropertyBag : public IPropertyBag
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE EnumProperty( 
            /* [in] */ ULONG iProperty,
            /* [out][in] */ VARIANT *pvarPropertyName,
            /* [out][in] */ VARIANT *pvarPropertyValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaPropertyBagVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaPropertyBag * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaPropertyBag * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaPropertyBag * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Read )( 
            IMediaPropertyBag * This,
            /* [in] */ LPCOLESTR pszPropName,
            /* [out][in] */ VARIANT *pVar,
            /* [in] */ IErrorLog *pErrorLog);
        
        HRESULT ( STDMETHODCALLTYPE *Write )( 
            IMediaPropertyBag * This,
            /* [in] */ LPCOLESTR pszPropName,
            /* [in] */ VARIANT *pVar);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *EnumProperty )( 
            IMediaPropertyBag * This,
            /* [in] */ ULONG iProperty,
            /* [out][in] */ VARIANT *pvarPropertyName,
            /* [out][in] */ VARIANT *pvarPropertyValue);
        
        END_INTERFACE
    } IMediaPropertyBagVtbl;

    interface IMediaPropertyBag
    {
        CONST_VTBL struct IMediaPropertyBagVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaPropertyBag_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMediaPropertyBag_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMediaPropertyBag_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMediaPropertyBag_Read(This,pszPropName,pVar,pErrorLog)	\
    ( (This)->lpVtbl -> Read(This,pszPropName,pVar,pErrorLog) ) 

#define IMediaPropertyBag_Write(This,pszPropName,pVar)	\
    ( (This)->lpVtbl -> Write(This,pszPropName,pVar) ) 


#define IMediaPropertyBag_EnumProperty(This,iProperty,pvarPropertyName,pvarPropertyValue)	\
    ( (This)->lpVtbl -> EnumProperty(This,iProperty,pvarPropertyName,pvarPropertyValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMediaPropertyBag_INTERFACE_DEFINED__ */


#ifndef __IPersistMediaPropertyBag_INTERFACE_DEFINED__
#define __IPersistMediaPropertyBag_INTERFACE_DEFINED__

/* interface IPersistMediaPropertyBag */
/* [unique][uuid][object] */ 

typedef IPersistMediaPropertyBag *LPPERSISTMEDIAPROPERTYBAG;


EXTERN_C const IID IID_IPersistMediaPropertyBag;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5738E040-B67F-11d0-BD4D-00A0C911CE86")
    IPersistMediaPropertyBag : public IPersist
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitNew( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Load( 
            /* [in] */ IMediaPropertyBag *pPropBag,
            /* [in] */ IErrorLog *pErrorLog) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Save( 
            /* [in] */ IMediaPropertyBag *pPropBag,
            /* [in] */ BOOL fClearDirty,
            /* [in] */ BOOL fSaveAllProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPersistMediaPropertyBagVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPersistMediaPropertyBag * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPersistMediaPropertyBag * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPersistMediaPropertyBag * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassID )( 
            IPersistMediaPropertyBag * This,
            /* [out] */ CLSID *pClassID);
        
        HRESULT ( STDMETHODCALLTYPE *InitNew )( 
            IPersistMediaPropertyBag * This);
        
        HRESULT ( STDMETHODCALLTYPE *Load )( 
            IPersistMediaPropertyBag * This,
            /* [in] */ IMediaPropertyBag *pPropBag,
            /* [in] */ IErrorLog *pErrorLog);
        
        HRESULT ( STDMETHODCALLTYPE *Save )( 
            IPersistMediaPropertyBag * This,
            /* [in] */ IMediaPropertyBag *pPropBag,
            /* [in] */ BOOL fClearDirty,
            /* [in] */ BOOL fSaveAllProperties);
        
        END_INTERFACE
    } IPersistMediaPropertyBagVtbl;

    interface IPersistMediaPropertyBag
    {
        CONST_VTBL struct IPersistMediaPropertyBagVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPersistMediaPropertyBag_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPersistMediaPropertyBag_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPersistMediaPropertyBag_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPersistMediaPropertyBag_GetClassID(This,pClassID)	\
    ( (This)->lpVtbl -> GetClassID(This,pClassID) ) 


#define IPersistMediaPropertyBag_InitNew(This)	\
    ( (This)->lpVtbl -> InitNew(This) ) 

#define IPersistMediaPropertyBag_Load(This,pPropBag,pErrorLog)	\
    ( (This)->lpVtbl -> Load(This,pPropBag,pErrorLog) ) 

#define IPersistMediaPropertyBag_Save(This,pPropBag,fClearDirty,fSaveAllProperties)	\
    ( (This)->lpVtbl -> Save(This,pPropBag,fClearDirty,fSaveAllProperties) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPersistMediaPropertyBag_INTERFACE_DEFINED__ */


#ifndef __IAMPhysicalPinInfo_INTERFACE_DEFINED__
#define __IAMPhysicalPinInfo_INTERFACE_DEFINED__

/* interface IAMPhysicalPinInfo */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMPhysicalPinInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F938C991-3029-11cf-8C44-00AA006B6814")
    IAMPhysicalPinInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPhysicalType( 
            /* [out] */ long *pType,
            /* [out] */ LPOLESTR *ppszType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMPhysicalPinInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMPhysicalPinInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMPhysicalPinInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMPhysicalPinInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPhysicalType )( 
            IAMPhysicalPinInfo * This,
            /* [out] */ long *pType,
            /* [out] */ LPOLESTR *ppszType);
        
        END_INTERFACE
    } IAMPhysicalPinInfoVtbl;

    interface IAMPhysicalPinInfo
    {
        CONST_VTBL struct IAMPhysicalPinInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMPhysicalPinInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMPhysicalPinInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMPhysicalPinInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMPhysicalPinInfo_GetPhysicalType(This,pType,ppszType)	\
    ( (This)->lpVtbl -> GetPhysicalType(This,pType,ppszType) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMPhysicalPinInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0063 */
/* [local] */ 

typedef IAMPhysicalPinInfo *PAMPHYSICALPININFO;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0063_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0063_v0_0_s_ifspec;

#ifndef __IAMExtDevice_INTERFACE_DEFINED__
#define __IAMExtDevice_INTERFACE_DEFINED__

/* interface IAMExtDevice */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMExtDevice;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B5730A90-1A2C-11cf-8C23-00AA006B6814")
    IAMExtDevice : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCapability( 
            /* [in] */ long Capability,
            /* [out] */ long *pValue,
            /* [out] */ double *pdblValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_ExternalDeviceID( 
            /* [out] */ LPOLESTR *ppszData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_ExternalDeviceVersion( 
            /* [out] */ LPOLESTR *ppszData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_DevicePower( 
            /* [in] */ long PowerMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_DevicePower( 
            /* [out] */ long *pPowerMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Calibrate( 
            /* [in] */ HEVENT hEvent,
            /* [in] */ long Mode,
            /* [out] */ long *pStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_DevicePort( 
            /* [in] */ long DevicePort) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_DevicePort( 
            /* [out] */ long *pDevicePort) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMExtDeviceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMExtDevice * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMExtDevice * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMExtDevice * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCapability )( 
            IAMExtDevice * This,
            /* [in] */ long Capability,
            /* [out] */ long *pValue,
            /* [out] */ double *pdblValue);
        
        HRESULT ( STDMETHODCALLTYPE *get_ExternalDeviceID )( 
            IAMExtDevice * This,
            /* [out] */ LPOLESTR *ppszData);
        
        HRESULT ( STDMETHODCALLTYPE *get_ExternalDeviceVersion )( 
            IAMExtDevice * This,
            /* [out] */ LPOLESTR *ppszData);
        
        HRESULT ( STDMETHODCALLTYPE *put_DevicePower )( 
            IAMExtDevice * This,
            /* [in] */ long PowerMode);
        
        HRESULT ( STDMETHODCALLTYPE *get_DevicePower )( 
            IAMExtDevice * This,
            /* [out] */ long *pPowerMode);
        
        HRESULT ( STDMETHODCALLTYPE *Calibrate )( 
            IAMExtDevice * This,
            /* [in] */ HEVENT hEvent,
            /* [in] */ long Mode,
            /* [out] */ long *pStatus);
        
        HRESULT ( STDMETHODCALLTYPE *put_DevicePort )( 
            IAMExtDevice * This,
            /* [in] */ long DevicePort);
        
        HRESULT ( STDMETHODCALLTYPE *get_DevicePort )( 
            IAMExtDevice * This,
            /* [out] */ long *pDevicePort);
        
        END_INTERFACE
    } IAMExtDeviceVtbl;

    interface IAMExtDevice
    {
        CONST_VTBL struct IAMExtDeviceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMExtDevice_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMExtDevice_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMExtDevice_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMExtDevice_GetCapability(This,Capability,pValue,pdblValue)	\
    ( (This)->lpVtbl -> GetCapability(This,Capability,pValue,pdblValue) ) 

#define IAMExtDevice_get_ExternalDeviceID(This,ppszData)	\
    ( (This)->lpVtbl -> get_ExternalDeviceID(This,ppszData) ) 

#define IAMExtDevice_get_ExternalDeviceVersion(This,ppszData)	\
    ( (This)->lpVtbl -> get_ExternalDeviceVersion(This,ppszData) ) 

#define IAMExtDevice_put_DevicePower(This,PowerMode)	\
    ( (This)->lpVtbl -> put_DevicePower(This,PowerMode) ) 

#define IAMExtDevice_get_DevicePower(This,pPowerMode)	\
    ( (This)->lpVtbl -> get_DevicePower(This,pPowerMode) ) 

#define IAMExtDevice_Calibrate(This,hEvent,Mode,pStatus)	\
    ( (This)->lpVtbl -> Calibrate(This,hEvent,Mode,pStatus) ) 

#define IAMExtDevice_put_DevicePort(This,DevicePort)	\
    ( (This)->lpVtbl -> put_DevicePort(This,DevicePort) ) 

#define IAMExtDevice_get_DevicePort(This,pDevicePort)	\
    ( (This)->lpVtbl -> get_DevicePort(This,pDevicePort) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMExtDevice_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0064 */
/* [local] */ 

typedef IAMExtDevice *PEXTDEVICE;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0064_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0064_v0_0_s_ifspec;

#ifndef __IAMExtTransport_INTERFACE_DEFINED__
#define __IAMExtTransport_INTERFACE_DEFINED__

/* interface IAMExtTransport */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMExtTransport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A03CD5F0-3045-11cf-8C44-00AA006B6814")
    IAMExtTransport : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCapability( 
            /* [in] */ long Capability,
            /* [out] */ long *pValue,
            /* [out] */ double *pdblValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_MediaState( 
            /* [in] */ long State) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_MediaState( 
            /* [out] */ long *pState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_LocalControl( 
            /* [in] */ long State) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_LocalControl( 
            /* [out] */ long *pState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [in] */ long StatusItem,
            /* [out] */ long *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransportBasicParameters( 
            /* [in] */ long Param,
            /* [out] */ long *pValue,
            /* [out] */ LPOLESTR *ppszData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTransportBasicParameters( 
            /* [in] */ long Param,
            /* [in] */ long Value,
            /* [in] */ LPCOLESTR pszData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransportVideoParameters( 
            /* [in] */ long Param,
            /* [out] */ long *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTransportVideoParameters( 
            /* [in] */ long Param,
            /* [in] */ long Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransportAudioParameters( 
            /* [in] */ long Param,
            /* [out] */ long *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTransportAudioParameters( 
            /* [in] */ long Param,
            /* [in] */ long Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_Mode( 
            /* [in] */ long Mode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Mode( 
            /* [out] */ long *pMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_Rate( 
            /* [in] */ double dblRate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Rate( 
            /* [out] */ double *pdblRate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetChase( 
            /* [out] */ long *pEnabled,
            /* [out] */ long *pOffset,
            /* [out] */ HEVENT *phEvent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetChase( 
            /* [in] */ long Enable,
            /* [in] */ long Offset,
            /* [in] */ HEVENT hEvent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBump( 
            /* [out] */ long *pSpeed,
            /* [out] */ long *pDuration) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBump( 
            /* [in] */ long Speed,
            /* [in] */ long Duration) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_AntiClogControl( 
            /* [out] */ long *pEnabled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_AntiClogControl( 
            /* [in] */ long Enable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEditPropertySet( 
            /* [in] */ long EditID,
            /* [out] */ long *pState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEditPropertySet( 
            /* [out][in] */ long *pEditID,
            /* [in] */ long State) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEditProperty( 
            /* [in] */ long EditID,
            /* [in] */ long Param,
            /* [out] */ long *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEditProperty( 
            /* [in] */ long EditID,
            /* [in] */ long Param,
            /* [in] */ long Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_EditStart( 
            /* [out] */ long *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_EditStart( 
            /* [in] */ long Value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMExtTransportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMExtTransport * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMExtTransport * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMExtTransport * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCapability )( 
            IAMExtTransport * This,
            /* [in] */ long Capability,
            /* [out] */ long *pValue,
            /* [out] */ double *pdblValue);
        
        HRESULT ( STDMETHODCALLTYPE *put_MediaState )( 
            IAMExtTransport * This,
            /* [in] */ long State);
        
        HRESULT ( STDMETHODCALLTYPE *get_MediaState )( 
            IAMExtTransport * This,
            /* [out] */ long *pState);
        
        HRESULT ( STDMETHODCALLTYPE *put_LocalControl )( 
            IAMExtTransport * This,
            /* [in] */ long State);
        
        HRESULT ( STDMETHODCALLTYPE *get_LocalControl )( 
            IAMExtTransport * This,
            /* [out] */ long *pState);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            IAMExtTransport * This,
            /* [in] */ long StatusItem,
            /* [out] */ long *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransportBasicParameters )( 
            IAMExtTransport * This,
            /* [in] */ long Param,
            /* [out] */ long *pValue,
            /* [out] */ LPOLESTR *ppszData);
        
        HRESULT ( STDMETHODCALLTYPE *SetTransportBasicParameters )( 
            IAMExtTransport * This,
            /* [in] */ long Param,
            /* [in] */ long Value,
            /* [in] */ LPCOLESTR pszData);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransportVideoParameters )( 
            IAMExtTransport * This,
            /* [in] */ long Param,
            /* [out] */ long *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetTransportVideoParameters )( 
            IAMExtTransport * This,
            /* [in] */ long Param,
            /* [in] */ long Value);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransportAudioParameters )( 
            IAMExtTransport * This,
            /* [in] */ long Param,
            /* [out] */ long *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetTransportAudioParameters )( 
            IAMExtTransport * This,
            /* [in] */ long Param,
            /* [in] */ long Value);
        
        HRESULT ( STDMETHODCALLTYPE *put_Mode )( 
            IAMExtTransport * This,
            /* [in] */ long Mode);
        
        HRESULT ( STDMETHODCALLTYPE *get_Mode )( 
            IAMExtTransport * This,
            /* [out] */ long *pMode);
        
        HRESULT ( STDMETHODCALLTYPE *put_Rate )( 
            IAMExtTransport * This,
            /* [in] */ double dblRate);
        
        HRESULT ( STDMETHODCALLTYPE *get_Rate )( 
            IAMExtTransport * This,
            /* [out] */ double *pdblRate);
        
        HRESULT ( STDMETHODCALLTYPE *GetChase )( 
            IAMExtTransport * This,
            /* [out] */ long *pEnabled,
            /* [out] */ long *pOffset,
            /* [out] */ HEVENT *phEvent);
        
        HRESULT ( STDMETHODCALLTYPE *SetChase )( 
            IAMExtTransport * This,
            /* [in] */ long Enable,
            /* [in] */ long Offset,
            /* [in] */ HEVENT hEvent);
        
        HRESULT ( STDMETHODCALLTYPE *GetBump )( 
            IAMExtTransport * This,
            /* [out] */ long *pSpeed,
            /* [out] */ long *pDuration);
        
        HRESULT ( STDMETHODCALLTYPE *SetBump )( 
            IAMExtTransport * This,
            /* [in] */ long Speed,
            /* [in] */ long Duration);
        
        HRESULT ( STDMETHODCALLTYPE *get_AntiClogControl )( 
            IAMExtTransport * This,
            /* [out] */ long *pEnabled);
        
        HRESULT ( STDMETHODCALLTYPE *put_AntiClogControl )( 
            IAMExtTransport * This,
            /* [in] */ long Enable);
        
        HRESULT ( STDMETHODCALLTYPE *GetEditPropertySet )( 
            IAMExtTransport * This,
            /* [in] */ long EditID,
            /* [out] */ long *pState);
        
        HRESULT ( STDMETHODCALLTYPE *SetEditPropertySet )( 
            IAMExtTransport * This,
            /* [out][in] */ long *pEditID,
            /* [in] */ long State);
        
        HRESULT ( STDMETHODCALLTYPE *GetEditProperty )( 
            IAMExtTransport * This,
            /* [in] */ long EditID,
            /* [in] */ long Param,
            /* [out] */ long *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetEditProperty )( 
            IAMExtTransport * This,
            /* [in] */ long EditID,
            /* [in] */ long Param,
            /* [in] */ long Value);
        
        HRESULT ( STDMETHODCALLTYPE *get_EditStart )( 
            IAMExtTransport * This,
            /* [out] */ long *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *put_EditStart )( 
            IAMExtTransport * This,
            /* [in] */ long Value);
        
        END_INTERFACE
    } IAMExtTransportVtbl;

    interface IAMExtTransport
    {
        CONST_VTBL struct IAMExtTransportVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMExtTransport_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMExtTransport_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMExtTransport_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMExtTransport_GetCapability(This,Capability,pValue,pdblValue)	\
    ( (This)->lpVtbl -> GetCapability(This,Capability,pValue,pdblValue) ) 

#define IAMExtTransport_put_MediaState(This,State)	\
    ( (This)->lpVtbl -> put_MediaState(This,State) ) 

#define IAMExtTransport_get_MediaState(This,pState)	\
    ( (This)->lpVtbl -> get_MediaState(This,pState) ) 

#define IAMExtTransport_put_LocalControl(This,State)	\
    ( (This)->lpVtbl -> put_LocalControl(This,State) ) 

#define IAMExtTransport_get_LocalControl(This,pState)	\
    ( (This)->lpVtbl -> get_LocalControl(This,pState) ) 

#define IAMExtTransport_GetStatus(This,StatusItem,pValue)	\
    ( (This)->lpVtbl -> GetStatus(This,StatusItem,pValue) ) 

#define IAMExtTransport_GetTransportBasicParameters(This,Param,pValue,ppszData)	\
    ( (This)->lpVtbl -> GetTransportBasicParameters(This,Param,pValue,ppszData) ) 

#define IAMExtTransport_SetTransportBasicParameters(This,Param,Value,pszData)	\
    ( (This)->lpVtbl -> SetTransportBasicParameters(This,Param,Value,pszData) ) 

#define IAMExtTransport_GetTransportVideoParameters(This,Param,pValue)	\
    ( (This)->lpVtbl -> GetTransportVideoParameters(This,Param,pValue) ) 

#define IAMExtTransport_SetTransportVideoParameters(This,Param,Value)	\
    ( (This)->lpVtbl -> SetTransportVideoParameters(This,Param,Value) ) 

#define IAMExtTransport_GetTransportAudioParameters(This,Param,pValue)	\
    ( (This)->lpVtbl -> GetTransportAudioParameters(This,Param,pValue) ) 

#define IAMExtTransport_SetTransportAudioParameters(This,Param,Value)	\
    ( (This)->lpVtbl -> SetTransportAudioParameters(This,Param,Value) ) 

#define IAMExtTransport_put_Mode(This,Mode)	\
    ( (This)->lpVtbl -> put_Mode(This,Mode) ) 

#define IAMExtTransport_get_Mode(This,pMode)	\
    ( (This)->lpVtbl -> get_Mode(This,pMode) ) 

#define IAMExtTransport_put_Rate(This,dblRate)	\
    ( (This)->lpVtbl -> put_Rate(This,dblRate) ) 

#define IAMExtTransport_get_Rate(This,pdblRate)	\
    ( (This)->lpVtbl -> get_Rate(This,pdblRate) ) 

#define IAMExtTransport_GetChase(This,pEnabled,pOffset,phEvent)	\
    ( (This)->lpVtbl -> GetChase(This,pEnabled,pOffset,phEvent) ) 

#define IAMExtTransport_SetChase(This,Enable,Offset,hEvent)	\
    ( (This)->lpVtbl -> SetChase(This,Enable,Offset,hEvent) ) 

#define IAMExtTransport_GetBump(This,pSpeed,pDuration)	\
    ( (This)->lpVtbl -> GetBump(This,pSpeed,pDuration) ) 

#define IAMExtTransport_SetBump(This,Speed,Duration)	\
    ( (This)->lpVtbl -> SetBump(This,Speed,Duration) ) 

#define IAMExtTransport_get_AntiClogControl(This,pEnabled)	\
    ( (This)->lpVtbl -> get_AntiClogControl(This,pEnabled) ) 

#define IAMExtTransport_put_AntiClogControl(This,Enable)	\
    ( (This)->lpVtbl -> put_AntiClogControl(This,Enable) ) 

#define IAMExtTransport_GetEditPropertySet(This,EditID,pState)	\
    ( (This)->lpVtbl -> GetEditPropertySet(This,EditID,pState) ) 

#define IAMExtTransport_SetEditPropertySet(This,pEditID,State)	\
    ( (This)->lpVtbl -> SetEditPropertySet(This,pEditID,State) ) 

#define IAMExtTransport_GetEditProperty(This,EditID,Param,pValue)	\
    ( (This)->lpVtbl -> GetEditProperty(This,EditID,Param,pValue) ) 

#define IAMExtTransport_SetEditProperty(This,EditID,Param,Value)	\
    ( (This)->lpVtbl -> SetEditProperty(This,EditID,Param,Value) ) 

#define IAMExtTransport_get_EditStart(This,pValue)	\
    ( (This)->lpVtbl -> get_EditStart(This,pValue) ) 

#define IAMExtTransport_put_EditStart(This,Value)	\
    ( (This)->lpVtbl -> put_EditStart(This,Value) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMExtTransport_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0065 */
/* [local] */ 

typedef IAMExtTransport *PIAMEXTTRANSPORT;

#if 0
/* the following is what MIDL knows how to remote */
typedef struct tagTIMECODE
    {
    WORD wFrameRate;
    WORD wFrameFract;
    DWORD dwFrames;
    } 	TIMECODE;

#else /* 0 */
#ifndef TIMECODE_DEFINED
#define TIMECODE_DEFINED
typedef union _timecode {
   struct {
  WORD   wFrameRate;
  WORD   wFrameFract;
  DWORD  dwFrames;
  };
   DWORDLONG  qw;
   } TIMECODE;

#endif /* TIMECODE_DEFINED */
#endif /* 0 */
typedef TIMECODE *PTIMECODE;

typedef struct tagTIMECODE_SAMPLE
    {
    LONGLONG qwTick;
    TIMECODE timecode;
    DWORD dwUser;
    DWORD dwFlags;
    } 	TIMECODE_SAMPLE;

typedef TIMECODE_SAMPLE *PTIMECODE_SAMPLE;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0065_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0065_v0_0_s_ifspec;

#ifndef __IAMTimecodeReader_INTERFACE_DEFINED__
#define __IAMTimecodeReader_INTERFACE_DEFINED__

/* interface IAMTimecodeReader */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMTimecodeReader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9B496CE1-811B-11cf-8C77-00AA006B6814")
    IAMTimecodeReader : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTCRMode( 
            /* [in] */ long Param,
            /* [out] */ long *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTCRMode( 
            /* [in] */ long Param,
            /* [in] */ long Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_VITCLine( 
            /* [in] */ long Line) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_VITCLine( 
            /* [out] */ long *pLine) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTimecode( 
            /* [out] */ PTIMECODE_SAMPLE pTimecodeSample) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMTimecodeReaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMTimecodeReader * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMTimecodeReader * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMTimecodeReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTCRMode )( 
            IAMTimecodeReader * This,
            /* [in] */ long Param,
            /* [out] */ long *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetTCRMode )( 
            IAMTimecodeReader * This,
            /* [in] */ long Param,
            /* [in] */ long Value);
        
        HRESULT ( STDMETHODCALLTYPE *put_VITCLine )( 
            IAMTimecodeReader * This,
            /* [in] */ long Line);
        
        HRESULT ( STDMETHODCALLTYPE *get_VITCLine )( 
            IAMTimecodeReader * This,
            /* [out] */ long *pLine);
        
        HRESULT ( STDMETHODCALLTYPE *GetTimecode )( 
            IAMTimecodeReader * This,
            /* [out] */ PTIMECODE_SAMPLE pTimecodeSample);
        
        END_INTERFACE
    } IAMTimecodeReaderVtbl;

    interface IAMTimecodeReader
    {
        CONST_VTBL struct IAMTimecodeReaderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMTimecodeReader_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMTimecodeReader_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMTimecodeReader_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMTimecodeReader_GetTCRMode(This,Param,pValue)	\
    ( (This)->lpVtbl -> GetTCRMode(This,Param,pValue) ) 

#define IAMTimecodeReader_SetTCRMode(This,Param,Value)	\
    ( (This)->lpVtbl -> SetTCRMode(This,Param,Value) ) 

#define IAMTimecodeReader_put_VITCLine(This,Line)	\
    ( (This)->lpVtbl -> put_VITCLine(This,Line) ) 

#define IAMTimecodeReader_get_VITCLine(This,pLine)	\
    ( (This)->lpVtbl -> get_VITCLine(This,pLine) ) 

#define IAMTimecodeReader_GetTimecode(This,pTimecodeSample)	\
    ( (This)->lpVtbl -> GetTimecode(This,pTimecodeSample) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMTimecodeReader_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0066 */
/* [local] */ 

typedef IAMTimecodeReader *PIAMTIMECODEREADER;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0066_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0066_v0_0_s_ifspec;

#ifndef __IAMTimecodeGenerator_INTERFACE_DEFINED__
#define __IAMTimecodeGenerator_INTERFACE_DEFINED__

/* interface IAMTimecodeGenerator */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMTimecodeGenerator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9B496CE0-811B-11cf-8C77-00AA006B6814")
    IAMTimecodeGenerator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTCGMode( 
            /* [in] */ long Param,
            /* [out] */ long *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTCGMode( 
            /* [in] */ long Param,
            /* [in] */ long Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_VITCLine( 
            /* [in] */ long Line) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_VITCLine( 
            /* [out] */ long *pLine) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTimecode( 
            /* [in] */ PTIMECODE_SAMPLE pTimecodeSample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTimecode( 
            /* [out] */ PTIMECODE_SAMPLE pTimecodeSample) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMTimecodeGeneratorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMTimecodeGenerator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMTimecodeGenerator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMTimecodeGenerator * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTCGMode )( 
            IAMTimecodeGenerator * This,
            /* [in] */ long Param,
            /* [out] */ long *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetTCGMode )( 
            IAMTimecodeGenerator * This,
            /* [in] */ long Param,
            /* [in] */ long Value);
        
        HRESULT ( STDMETHODCALLTYPE *put_VITCLine )( 
            IAMTimecodeGenerator * This,
            /* [in] */ long Line);
        
        HRESULT ( STDMETHODCALLTYPE *get_VITCLine )( 
            IAMTimecodeGenerator * This,
            /* [out] */ long *pLine);
        
        HRESULT ( STDMETHODCALLTYPE *SetTimecode )( 
            IAMTimecodeGenerator * This,
            /* [in] */ PTIMECODE_SAMPLE pTimecodeSample);
        
        HRESULT ( STDMETHODCALLTYPE *GetTimecode )( 
            IAMTimecodeGenerator * This,
            /* [out] */ PTIMECODE_SAMPLE pTimecodeSample);
        
        END_INTERFACE
    } IAMTimecodeGeneratorVtbl;

    interface IAMTimecodeGenerator
    {
        CONST_VTBL struct IAMTimecodeGeneratorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMTimecodeGenerator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMTimecodeGenerator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMTimecodeGenerator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMTimecodeGenerator_GetTCGMode(This,Param,pValue)	\
    ( (This)->lpVtbl -> GetTCGMode(This,Param,pValue) ) 

#define IAMTimecodeGenerator_SetTCGMode(This,Param,Value)	\
    ( (This)->lpVtbl -> SetTCGMode(This,Param,Value) ) 

#define IAMTimecodeGenerator_put_VITCLine(This,Line)	\
    ( (This)->lpVtbl -> put_VITCLine(This,Line) ) 

#define IAMTimecodeGenerator_get_VITCLine(This,pLine)	\
    ( (This)->lpVtbl -> get_VITCLine(This,pLine) ) 

#define IAMTimecodeGenerator_SetTimecode(This,pTimecodeSample)	\
    ( (This)->lpVtbl -> SetTimecode(This,pTimecodeSample) ) 

#define IAMTimecodeGenerator_GetTimecode(This,pTimecodeSample)	\
    ( (This)->lpVtbl -> GetTimecode(This,pTimecodeSample) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMTimecodeGenerator_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0067 */
/* [local] */ 

typedef IAMTimecodeGenerator *PIAMTIMECODEGENERATOR;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0067_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0067_v0_0_s_ifspec;

#ifndef __IAMTimecodeDisplay_INTERFACE_DEFINED__
#define __IAMTimecodeDisplay_INTERFACE_DEFINED__

/* interface IAMTimecodeDisplay */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMTimecodeDisplay;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9B496CE2-811B-11cf-8C77-00AA006B6814")
    IAMTimecodeDisplay : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTCDisplayEnable( 
            /* [out] */ long *pState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTCDisplayEnable( 
            /* [in] */ long State) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTCDisplay( 
            /* [in] */ long Param,
            /* [out] */ long *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTCDisplay( 
            /* [in] */ long Param,
            /* [in] */ long Value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMTimecodeDisplayVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMTimecodeDisplay * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMTimecodeDisplay * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMTimecodeDisplay * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTCDisplayEnable )( 
            IAMTimecodeDisplay * This,
            /* [out] */ long *pState);
        
        HRESULT ( STDMETHODCALLTYPE *SetTCDisplayEnable )( 
            IAMTimecodeDisplay * This,
            /* [in] */ long State);
        
        HRESULT ( STDMETHODCALLTYPE *GetTCDisplay )( 
            IAMTimecodeDisplay * This,
            /* [in] */ long Param,
            /* [out] */ long *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetTCDisplay )( 
            IAMTimecodeDisplay * This,
            /* [in] */ long Param,
            /* [in] */ long Value);
        
        END_INTERFACE
    } IAMTimecodeDisplayVtbl;

    interface IAMTimecodeDisplay
    {
        CONST_VTBL struct IAMTimecodeDisplayVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMTimecodeDisplay_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMTimecodeDisplay_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMTimecodeDisplay_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMTimecodeDisplay_GetTCDisplayEnable(This,pState)	\
    ( (This)->lpVtbl -> GetTCDisplayEnable(This,pState) ) 

#define IAMTimecodeDisplay_SetTCDisplayEnable(This,State)	\
    ( (This)->lpVtbl -> SetTCDisplayEnable(This,State) ) 

#define IAMTimecodeDisplay_GetTCDisplay(This,Param,pValue)	\
    ( (This)->lpVtbl -> GetTCDisplay(This,Param,pValue) ) 

#define IAMTimecodeDisplay_SetTCDisplay(This,Param,Value)	\
    ( (This)->lpVtbl -> SetTCDisplay(This,Param,Value) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMTimecodeDisplay_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0068 */
/* [local] */ 

typedef IAMTimecodeDisplay *PIAMTIMECODEDISPLAY;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0068_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0068_v0_0_s_ifspec;

#ifndef __IAMDevMemoryAllocator_INTERFACE_DEFINED__
#define __IAMDevMemoryAllocator_INTERFACE_DEFINED__

/* interface IAMDevMemoryAllocator */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMDevMemoryAllocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c6545bf0-e76b-11d0-bd52-00a0c911ce86")
    IAMDevMemoryAllocator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetInfo( 
            /* [out] */ DWORD *pdwcbTotalFree,
            /* [out] */ DWORD *pdwcbLargestFree,
            /* [out] */ DWORD *pdwcbTotalMemory,
            /* [out] */ DWORD *pdwcbMinimumChunk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CheckMemory( 
            /* [in] */ const BYTE *pBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Alloc( 
            /* [out] */ BYTE **ppBuffer,
            /* [out][in] */ DWORD *pdwcbBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Free( 
            /* [in] */ BYTE *pBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDevMemoryObject( 
            /* [out] */ IUnknown **ppUnkInnner,
            /* [in] */ IUnknown *pUnkOuter) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMDevMemoryAllocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMDevMemoryAllocator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMDevMemoryAllocator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMDevMemoryAllocator * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            IAMDevMemoryAllocator * This,
            /* [out] */ DWORD *pdwcbTotalFree,
            /* [out] */ DWORD *pdwcbLargestFree,
            /* [out] */ DWORD *pdwcbTotalMemory,
            /* [out] */ DWORD *pdwcbMinimumChunk);
        
        HRESULT ( STDMETHODCALLTYPE *CheckMemory )( 
            IAMDevMemoryAllocator * This,
            /* [in] */ const BYTE *pBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *Alloc )( 
            IAMDevMemoryAllocator * This,
            /* [out] */ BYTE **ppBuffer,
            /* [out][in] */ DWORD *pdwcbBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *Free )( 
            IAMDevMemoryAllocator * This,
            /* [in] */ BYTE *pBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *GetDevMemoryObject )( 
            IAMDevMemoryAllocator * This,
            /* [out] */ IUnknown **ppUnkInnner,
            /* [in] */ IUnknown *pUnkOuter);
        
        END_INTERFACE
    } IAMDevMemoryAllocatorVtbl;

    interface IAMDevMemoryAllocator
    {
        CONST_VTBL struct IAMDevMemoryAllocatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMDevMemoryAllocator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMDevMemoryAllocator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMDevMemoryAllocator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMDevMemoryAllocator_GetInfo(This,pdwcbTotalFree,pdwcbLargestFree,pdwcbTotalMemory,pdwcbMinimumChunk)	\
    ( (This)->lpVtbl -> GetInfo(This,pdwcbTotalFree,pdwcbLargestFree,pdwcbTotalMemory,pdwcbMinimumChunk) ) 

#define IAMDevMemoryAllocator_CheckMemory(This,pBuffer)	\
    ( (This)->lpVtbl -> CheckMemory(This,pBuffer) ) 

#define IAMDevMemoryAllocator_Alloc(This,ppBuffer,pdwcbBuffer)	\
    ( (This)->lpVtbl -> Alloc(This,ppBuffer,pdwcbBuffer) ) 

#define IAMDevMemoryAllocator_Free(This,pBuffer)	\
    ( (This)->lpVtbl -> Free(This,pBuffer) ) 

#define IAMDevMemoryAllocator_GetDevMemoryObject(This,ppUnkInnner,pUnkOuter)	\
    ( (This)->lpVtbl -> GetDevMemoryObject(This,ppUnkInnner,pUnkOuter) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMDevMemoryAllocator_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0069 */
/* [local] */ 

typedef IAMDevMemoryAllocator *PAMDEVMEMORYALLOCATOR;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0069_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0069_v0_0_s_ifspec;

#ifndef __IAMDevMemoryControl_INTERFACE_DEFINED__
#define __IAMDevMemoryControl_INTERFACE_DEFINED__

/* interface IAMDevMemoryControl */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMDevMemoryControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c6545bf1-e76b-11d0-bd52-00a0c911ce86")
    IAMDevMemoryControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryWriteSync( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteSync( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDevId( 
            /* [out] */ DWORD *pdwDevId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMDevMemoryControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMDevMemoryControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMDevMemoryControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMDevMemoryControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryWriteSync )( 
            IAMDevMemoryControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *WriteSync )( 
            IAMDevMemoryControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDevId )( 
            IAMDevMemoryControl * This,
            /* [out] */ DWORD *pdwDevId);
        
        END_INTERFACE
    } IAMDevMemoryControlVtbl;

    interface IAMDevMemoryControl
    {
        CONST_VTBL struct IAMDevMemoryControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMDevMemoryControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMDevMemoryControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMDevMemoryControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMDevMemoryControl_QueryWriteSync(This)	\
    ( (This)->lpVtbl -> QueryWriteSync(This) ) 

#define IAMDevMemoryControl_WriteSync(This)	\
    ( (This)->lpVtbl -> WriteSync(This) ) 

#define IAMDevMemoryControl_GetDevId(This,pdwDevId)	\
    ( (This)->lpVtbl -> GetDevId(This,pdwDevId) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMDevMemoryControl_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0070 */
/* [local] */ 

typedef IAMDevMemoryControl *PAMDEVMEMORYCONTROL;


enum _AMSTREAMSELECTINFOFLAGS
    {	AMSTREAMSELECTINFO_ENABLED	= 0x1,
	AMSTREAMSELECTINFO_EXCLUSIVE	= 0x2
    } ;

enum _AMSTREAMSELECTENABLEFLAGS
    {	AMSTREAMSELECTENABLE_ENABLE	= 0x1,
	AMSTREAMSELECTENABLE_ENABLEALL	= 0x2
    } ;


extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0070_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0070_v0_0_s_ifspec;

#ifndef __IAMStreamSelect_INTERFACE_DEFINED__
#define __IAMStreamSelect_INTERFACE_DEFINED__

/* interface IAMStreamSelect */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMStreamSelect;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c1960960-17f5-11d1-abe1-00a0c905f375")
    IAMStreamSelect : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Count( 
            /* [out] */ DWORD *pcStreams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Info( 
            /* [in] */ long lIndex,
            /* [out] */ AM_MEDIA_TYPE **ppmt,
            /* [out] */ DWORD *pdwFlags,
            /* [out] */ LCID *plcid,
            /* [out] */ DWORD *pdwGroup,
            /* [out] */ WCHAR **ppszName,
            /* [out] */ IUnknown **ppObject,
            /* [out] */ IUnknown **ppUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Enable( 
            /* [in] */ long lIndex,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMStreamSelectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMStreamSelect * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMStreamSelect * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMStreamSelect * This);
        
        HRESULT ( STDMETHODCALLTYPE *Count )( 
            IAMStreamSelect * This,
            /* [out] */ DWORD *pcStreams);
        
        HRESULT ( STDMETHODCALLTYPE *Info )( 
            IAMStreamSelect * This,
            /* [in] */ long lIndex,
            /* [out] */ AM_MEDIA_TYPE **ppmt,
            /* [out] */ DWORD *pdwFlags,
            /* [out] */ LCID *plcid,
            /* [out] */ DWORD *pdwGroup,
            /* [out] */ WCHAR **ppszName,
            /* [out] */ IUnknown **ppObject,
            /* [out] */ IUnknown **ppUnk);
        
        HRESULT ( STDMETHODCALLTYPE *Enable )( 
            IAMStreamSelect * This,
            /* [in] */ long lIndex,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IAMStreamSelectVtbl;

    interface IAMStreamSelect
    {
        CONST_VTBL struct IAMStreamSelectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMStreamSelect_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMStreamSelect_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMStreamSelect_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMStreamSelect_Count(This,pcStreams)	\
    ( (This)->lpVtbl -> Count(This,pcStreams) ) 

#define IAMStreamSelect_Info(This,lIndex,ppmt,pdwFlags,plcid,pdwGroup,ppszName,ppObject,ppUnk)	\
    ( (This)->lpVtbl -> Info(This,lIndex,ppmt,pdwFlags,plcid,pdwGroup,ppszName,ppObject,ppUnk) ) 

#define IAMStreamSelect_Enable(This,lIndex,dwFlags)	\
    ( (This)->lpVtbl -> Enable(This,lIndex,dwFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMStreamSelect_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0071 */
/* [local] */ 

typedef IAMStreamSelect *PAMSTREAMSELECT;


enum _AMRESCTL_RESERVEFLAGS
    {	AMRESCTL_RESERVEFLAGS_RESERVE	= 0,
	AMRESCTL_RESERVEFLAGS_UNRESERVE	= 0x1
    } ;


extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0071_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0071_v0_0_s_ifspec;

#ifndef __IAMResourceControl_INTERFACE_DEFINED__
#define __IAMResourceControl_INTERFACE_DEFINED__

/* interface IAMResourceControl */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IAMResourceControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8389d2d0-77d7-11d1-abe6-00a0c905f375")
    IAMResourceControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Reserve( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ PVOID pvReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMResourceControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMResourceControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMResourceControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMResourceControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *Reserve )( 
            IAMResourceControl * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ PVOID pvReserved);
        
        END_INTERFACE
    } IAMResourceControlVtbl;

    interface IAMResourceControl
    {
        CONST_VTBL struct IAMResourceControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMResourceControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMResourceControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMResourceControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMResourceControl_Reserve(This,dwFlags,pvReserved)	\
    ( (This)->lpVtbl -> Reserve(This,dwFlags,pvReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMResourceControl_INTERFACE_DEFINED__ */


#ifndef __IAMClockAdjust_INTERFACE_DEFINED__
#define __IAMClockAdjust_INTERFACE_DEFINED__

/* interface IAMClockAdjust */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IAMClockAdjust;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4d5466b0-a49c-11d1-abe8-00a0c905f375")
    IAMClockAdjust : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetClockDelta( 
            /* [in] */ REFERENCE_TIME rtDelta) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMClockAdjustVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMClockAdjust * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMClockAdjust * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMClockAdjust * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetClockDelta )( 
            IAMClockAdjust * This,
            /* [in] */ REFERENCE_TIME rtDelta);
        
        END_INTERFACE
    } IAMClockAdjustVtbl;

    interface IAMClockAdjust
    {
        CONST_VTBL struct IAMClockAdjustVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMClockAdjust_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMClockAdjust_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMClockAdjust_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMClockAdjust_SetClockDelta(This,rtDelta)	\
    ( (This)->lpVtbl -> SetClockDelta(This,rtDelta) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMClockAdjust_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0073 */
/* [local] */ 


enum _AM_FILTER_MISC_FLAGS
    {	AM_FILTER_MISC_FLAGS_IS_RENDERER	= 0x1,
	AM_FILTER_MISC_FLAGS_IS_SOURCE	= 0x2,
	AM_FILTER_MISC_FLAG_NO_CAPTURE_PAUSE	= 0x4
    } ;


extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0073_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0073_v0_0_s_ifspec;

#ifndef __IAMFilterMiscFlags_INTERFACE_DEFINED__
#define __IAMFilterMiscFlags_INTERFACE_DEFINED__

/* interface IAMFilterMiscFlags */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IAMFilterMiscFlags;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2dd74950-a890-11d1-abe8-00a0c905f375")
    IAMFilterMiscFlags : public IUnknown
    {
    public:
        virtual ULONG STDMETHODCALLTYPE GetMiscFlags( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMFilterMiscFlagsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMFilterMiscFlags * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMFilterMiscFlags * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMFilterMiscFlags * This);
        
        ULONG ( STDMETHODCALLTYPE *GetMiscFlags )( 
            IAMFilterMiscFlags * This);
        
        END_INTERFACE
    } IAMFilterMiscFlagsVtbl;

    interface IAMFilterMiscFlags
    {
        CONST_VTBL struct IAMFilterMiscFlagsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMFilterMiscFlags_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMFilterMiscFlags_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMFilterMiscFlags_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMFilterMiscFlags_GetMiscFlags(This)	\
    ( (This)->lpVtbl -> GetMiscFlags(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMFilterMiscFlags_INTERFACE_DEFINED__ */


#ifndef __IDecimateVideoImage_INTERFACE_DEFINED__
#define __IDecimateVideoImage_INTERFACE_DEFINED__

/* interface IDecimateVideoImage */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IDecimateVideoImage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2e5ea3e0-e924-11d2-b6da-00a0c995e8df")
    IDecimateVideoImage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetDecimationImageSize( 
            /* [in] */ long lWidth,
            /* [in] */ long lHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResetDecimationImageSize( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDecimateVideoImageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDecimateVideoImage * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDecimateVideoImage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDecimateVideoImage * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDecimationImageSize )( 
            IDecimateVideoImage * This,
            /* [in] */ long lWidth,
            /* [in] */ long lHeight);
        
        HRESULT ( STDMETHODCALLTYPE *ResetDecimationImageSize )( 
            IDecimateVideoImage * This);
        
        END_INTERFACE
    } IDecimateVideoImageVtbl;

    interface IDecimateVideoImage
    {
        CONST_VTBL struct IDecimateVideoImageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDecimateVideoImage_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDecimateVideoImage_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDecimateVideoImage_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDecimateVideoImage_SetDecimationImageSize(This,lWidth,lHeight)	\
    ( (This)->lpVtbl -> SetDecimationImageSize(This,lWidth,lHeight) ) 

#define IDecimateVideoImage_ResetDecimationImageSize(This)	\
    ( (This)->lpVtbl -> ResetDecimationImageSize(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDecimateVideoImage_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0075 */
/* [local] */ 

typedef 
enum _DECIMATION_USAGE
    {	DECIMATION_LEGACY	= 0,
	DECIMATION_USE_DECODER_ONLY	= ( DECIMATION_LEGACY + 1 ) ,
	DECIMATION_USE_VIDEOPORT_ONLY	= ( DECIMATION_USE_DECODER_ONLY + 1 ) ,
	DECIMATION_USE_OVERLAY_ONLY	= ( DECIMATION_USE_VIDEOPORT_ONLY + 1 ) ,
	DECIMATION_DEFAULT	= ( DECIMATION_USE_OVERLAY_ONLY + 1 ) 
    } 	DECIMATION_USAGE;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0075_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0075_v0_0_s_ifspec;

#ifndef __IAMVideoDecimationProperties_INTERFACE_DEFINED__
#define __IAMVideoDecimationProperties_INTERFACE_DEFINED__

/* interface IAMVideoDecimationProperties */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IAMVideoDecimationProperties;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("60d32930-13da-11d3-9ec6-c4fcaef5c7be")
    IAMVideoDecimationProperties : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryDecimationUsage( 
            /* [out] */ DECIMATION_USAGE *lpUsage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDecimationUsage( 
            /* [in] */ DECIMATION_USAGE Usage) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMVideoDecimationPropertiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMVideoDecimationProperties * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMVideoDecimationProperties * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMVideoDecimationProperties * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryDecimationUsage )( 
            IAMVideoDecimationProperties * This,
            /* [out] */ DECIMATION_USAGE *lpUsage);
        
        HRESULT ( STDMETHODCALLTYPE *SetDecimationUsage )( 
            IAMVideoDecimationProperties * This,
            /* [in] */ DECIMATION_USAGE Usage);
        
        END_INTERFACE
    } IAMVideoDecimationPropertiesVtbl;

    interface IAMVideoDecimationProperties
    {
        CONST_VTBL struct IAMVideoDecimationPropertiesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMVideoDecimationProperties_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMVideoDecimationProperties_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMVideoDecimationProperties_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMVideoDecimationProperties_QueryDecimationUsage(This,lpUsage)	\
    ( (This)->lpVtbl -> QueryDecimationUsage(This,lpUsage) ) 

#define IAMVideoDecimationProperties_SetDecimationUsage(This,Usage)	\
    ( (This)->lpVtbl -> SetDecimationUsage(This,Usage) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMVideoDecimationProperties_INTERFACE_DEFINED__ */


#ifndef __IAMAudioRendererStats_INTERFACE_DEFINED__
#define __IAMAudioRendererStats_INTERFACE_DEFINED__

/* interface IAMAudioRendererStats */
/* [local][unique][uuid][object] */ 


enum _AM_AUDIO_RENDERER_STAT_PARAM
    {	AM_AUDREND_STAT_PARAM_BREAK_COUNT	= 1,
	AM_AUDREND_STAT_PARAM_SLAVE_MODE	= ( AM_AUDREND_STAT_PARAM_BREAK_COUNT + 1 ) ,
	AM_AUDREND_STAT_PARAM_SILENCE_DUR	= ( AM_AUDREND_STAT_PARAM_SLAVE_MODE + 1 ) ,
	AM_AUDREND_STAT_PARAM_LAST_BUFFER_DUR	= ( AM_AUDREND_STAT_PARAM_SILENCE_DUR + 1 ) ,
	AM_AUDREND_STAT_PARAM_DISCONTINUITIES	= ( AM_AUDREND_STAT_PARAM_LAST_BUFFER_DUR + 1 ) ,
	AM_AUDREND_STAT_PARAM_SLAVE_RATE	= ( AM_AUDREND_STAT_PARAM_DISCONTINUITIES + 1 ) ,
	AM_AUDREND_STAT_PARAM_SLAVE_DROPWRITE_DUR	= ( AM_AUDREND_STAT_PARAM_SLAVE_RATE + 1 ) ,
	AM_AUDREND_STAT_PARAM_SLAVE_HIGHLOWERROR	= ( AM_AUDREND_STAT_PARAM_SLAVE_DROPWRITE_DUR + 1 ) ,
	AM_AUDREND_STAT_PARAM_SLAVE_LASTHIGHLOWERROR	= ( AM_AUDREND_STAT_PARAM_SLAVE_HIGHLOWERROR + 1 ) ,
	AM_AUDREND_STAT_PARAM_SLAVE_ACCUMERROR	= ( AM_AUDREND_STAT_PARAM_SLAVE_LASTHIGHLOWERROR + 1 ) ,
	AM_AUDREND_STAT_PARAM_BUFFERFULLNESS	= ( AM_AUDREND_STAT_PARAM_SLAVE_ACCUMERROR + 1 ) ,
	AM_AUDREND_STAT_PARAM_JITTER	= ( AM_AUDREND_STAT_PARAM_BUFFERFULLNESS + 1 ) 
    } ;

EXTERN_C const IID IID_IAMAudioRendererStats;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f6467d6d-9ce6-4b52-8dfd-63ba1322f90a")
    IAMAudioRendererStats : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStatParam( 
            DWORD dwParam,
            DWORD *pdwParam1,
            DWORD *pdwParam2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMAudioRendererStatsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMAudioRendererStats * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMAudioRendererStats * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMAudioRendererStats * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatParam )( 
            IAMAudioRendererStats * This,
            DWORD dwParam,
            DWORD *pdwParam1,
            DWORD *pdwParam2);
        
        END_INTERFACE
    } IAMAudioRendererStatsVtbl;

    interface IAMAudioRendererStats
    {
        CONST_VTBL struct IAMAudioRendererStatsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMAudioRendererStats_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMAudioRendererStats_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMAudioRendererStats_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMAudioRendererStats_GetStatParam(This,dwParam,pdwParam1,pdwParam2)	\
    ( (This)->lpVtbl -> GetStatParam(This,dwParam,pdwParam1,pdwParam2) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMAudioRendererStats_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0077 */
/* [local] */ 

#define RENDERER_NOTIFICATION_ENABLED 1


extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0077_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0077_v0_0_s_ifspec;

#ifndef __IAMVideoRendererNotificationCallback_INTERFACE_DEFINED__
#define __IAMVideoRendererNotificationCallback_INTERFACE_DEFINED__

/* interface IAMVideoRendererNotificationCallback */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IAMVideoRendererNotificationCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5423D74D-F847-4c77-A54C-3A5826C64D83")
    IAMVideoRendererNotificationCallback : public IUnknown
    {
    public:
        virtual void STDMETHODCALLTYPE OnSampleReceived( 
            IMediaSample *pMediaSample) = 0;
        
        virtual void STDMETHODCALLTYPE OnRenderSample( 
            IMediaSample *pMediaSample,
            RECT *pSourceRect,
            RECT *pDestRect) = 0;
        
        virtual void STDMETHODCALLTYPE OnSampleRendered( 
            IMediaSample *pMediaSample,
            BOOL bSuccess) = 0;
        
        virtual void STDMETHODCALLTYPE OnSampleDropped( 
            IMediaSample *pMediaSample) = 0;
        
        virtual void STDMETHODCALLTYPE OnSampleScheduled( 
            IMediaSample *pMediaSample) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMVideoRendererNotificationCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMVideoRendererNotificationCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMVideoRendererNotificationCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMVideoRendererNotificationCallback * This);
        
        void ( STDMETHODCALLTYPE *OnSampleReceived )( 
            IAMVideoRendererNotificationCallback * This,
            IMediaSample *pMediaSample);
        
        void ( STDMETHODCALLTYPE *OnRenderSample )( 
            IAMVideoRendererNotificationCallback * This,
            IMediaSample *pMediaSample,
            RECT *pSourceRect,
            RECT *pDestRect);
        
        void ( STDMETHODCALLTYPE *OnSampleRendered )( 
            IAMVideoRendererNotificationCallback * This,
            IMediaSample *pMediaSample,
            BOOL bSuccess);
        
        void ( STDMETHODCALLTYPE *OnSampleDropped )( 
            IAMVideoRendererNotificationCallback * This,
            IMediaSample *pMediaSample);
        
        void ( STDMETHODCALLTYPE *OnSampleScheduled )( 
            IAMVideoRendererNotificationCallback * This,
            IMediaSample *pMediaSample);
        
        END_INTERFACE
    } IAMVideoRendererNotificationCallbackVtbl;

    interface IAMVideoRendererNotificationCallback
    {
        CONST_VTBL struct IAMVideoRendererNotificationCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMVideoRendererNotificationCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMVideoRendererNotificationCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMVideoRendererNotificationCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMVideoRendererNotificationCallback_OnSampleReceived(This,pMediaSample)	\
    ( (This)->lpVtbl -> OnSampleReceived(This,pMediaSample) ) 

#define IAMVideoRendererNotificationCallback_OnRenderSample(This,pMediaSample,pSourceRect,pDestRect)	\
    ( (This)->lpVtbl -> OnRenderSample(This,pMediaSample,pSourceRect,pDestRect) ) 

#define IAMVideoRendererNotificationCallback_OnSampleRendered(This,pMediaSample,bSuccess)	\
    ( (This)->lpVtbl -> OnSampleRendered(This,pMediaSample,bSuccess) ) 

#define IAMVideoRendererNotificationCallback_OnSampleDropped(This,pMediaSample)	\
    ( (This)->lpVtbl -> OnSampleDropped(This,pMediaSample) ) 

#define IAMVideoRendererNotificationCallback_OnSampleScheduled(This,pMediaSample)	\
    ( (This)->lpVtbl -> OnSampleScheduled(This,pMediaSample) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMVideoRendererNotificationCallback_INTERFACE_DEFINED__ */


#ifndef __IAMVideoRendererNotification_INTERFACE_DEFINED__
#define __IAMVideoRendererNotification_INTERFACE_DEFINED__

/* interface IAMVideoRendererNotification */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IAMVideoRendererNotification;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("025F94BB-A37D-4d8e-89A0-0BD06F26F77B")
    IAMVideoRendererNotification : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetCallbackInterface( 
            /* [in] */ IAMVideoRendererNotificationCallback *pCallback) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMVideoRendererNotificationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMVideoRendererNotification * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMVideoRendererNotification * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMVideoRendererNotification * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetCallbackInterface )( 
            IAMVideoRendererNotification * This,
            /* [in] */ IAMVideoRendererNotificationCallback *pCallback);
        
        END_INTERFACE
    } IAMVideoRendererNotificationVtbl;

    interface IAMVideoRendererNotification
    {
        CONST_VTBL struct IAMVideoRendererNotificationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMVideoRendererNotification_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMVideoRendererNotification_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMVideoRendererNotification_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMVideoRendererNotification_SetCallbackInterface(This,pCallback)	\
    ( (This)->lpVtbl -> SetCallbackInterface(This,pCallback) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMVideoRendererNotification_INTERFACE_DEFINED__ */


#ifndef __IAMVideoRendererMode_INTERFACE_DEFINED__
#define __IAMVideoRendererMode_INTERFACE_DEFINED__

/* interface IAMVideoRendererMode */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IAMVideoRendererMode;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E95AD8E0-993D-4817-B629-16B3E05F2520")
    IAMVideoRendererMode : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetMode( 
            /* [in] */ DWORD dwMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMode( 
            /* [out] */ DWORD *pdwMode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMVideoRendererModeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMVideoRendererMode * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMVideoRendererMode * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMVideoRendererMode * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetMode )( 
            IAMVideoRendererMode * This,
            /* [in] */ DWORD dwMode);
        
        HRESULT ( STDMETHODCALLTYPE *GetMode )( 
            IAMVideoRendererMode * This,
            /* [out] */ DWORD *pdwMode);
        
        END_INTERFACE
    } IAMVideoRendererModeVtbl;

    interface IAMVideoRendererMode
    {
        CONST_VTBL struct IAMVideoRendererModeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMVideoRendererMode_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMVideoRendererMode_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMVideoRendererMode_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMVideoRendererMode_SetMode(This,dwMode)	\
    ( (This)->lpVtbl -> SetMode(This,dwMode) ) 

#define IAMVideoRendererMode_GetMode(This,pdwMode)	\
    ( (This)->lpVtbl -> GetMode(This,pdwMode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMVideoRendererMode_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0080 */
/* [local] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_strmif_0000_0080_0001
    {	AM_VIDEO_RENDERER_MODE_DDRAW	= 0,
	AM_VIDEO_RENDERER_MODE_GDI	= ( AM_VIDEO_RENDERER_MODE_DDRAW + 1 ) 
    } 	AM_VIDEO_RENDERER_MODE;

typedef /* [public][public] */ struct __MIDL___MIDL_itf_strmif_0000_0080_0002
    {
    GUID Guid;
    ULONG NumberOfValues;
    ULONG Type;
    void *Value;
    } 	StructEncoderParameter;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0080_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0080_v0_0_s_ifspec;

#ifndef __IImageSinkFilter_INTERFACE_DEFINED__
#define __IImageSinkFilter_INTERFACE_DEFINED__

/* interface IImageSinkFilter */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IImageSinkFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7f12e45f-b224-449e-907a-a18fca14a579")
    IImageSinkFilter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetQuality( 
            /* [in] */ DWORD dwQuality) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEncoderParameters( 
            /* [in] */ DWORD dwCount,
            /* [in] */ StructEncoderParameter *Parameter) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImageSinkFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IImageSinkFilter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IImageSinkFilter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IImageSinkFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetQuality )( 
            IImageSinkFilter * This,
            /* [in] */ DWORD dwQuality);
        
        HRESULT ( STDMETHODCALLTYPE *SetEncoderParameters )( 
            IImageSinkFilter * This,
            /* [in] */ DWORD dwCount,
            /* [in] */ StructEncoderParameter *Parameter);
        
        END_INTERFACE
    } IImageSinkFilterVtbl;

    interface IImageSinkFilter
    {
        CONST_VTBL struct IImageSinkFilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImageSinkFilter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IImageSinkFilter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IImageSinkFilter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IImageSinkFilter_SetQuality(This,dwQuality)	\
    ( (This)->lpVtbl -> SetQuality(This,dwQuality) ) 

#define IImageSinkFilter_SetEncoderParameters(This,dwCount,Parameter)	\
    ( (This)->lpVtbl -> SetEncoderParameters(This,dwCount,Parameter) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IImageSinkFilter_INTERFACE_DEFINED__ */


#ifndef __ISmartTee_INTERFACE_DEFINED__
#define __ISmartTee_INTERFACE_DEFINED__

/* interface ISmartTee */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_ISmartTee;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("25547a74-22a6-4e1e-9525-004dfa37c31c")
    ISmartTee : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct ISmartTeeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISmartTee * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISmartTee * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISmartTee * This);
        
        END_INTERFACE
    } ISmartTeeVtbl;

    interface ISmartTee
    {
        CONST_VTBL struct ISmartTeeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISmartTee_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISmartTee_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISmartTee_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISmartTee_INTERFACE_DEFINED__ */


#ifndef __IBuffering_INTERFACE_DEFINED__
#define __IBuffering_INTERFACE_DEFINED__

/* interface IBuffering */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IBuffering;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6ddbdd08-d2d4-4cdf-82b3-f61e29c14996")
    IBuffering : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetBufferingDepth( 
            const REFERENCE_TIME *ptStop) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBufferingDepth( 
            REFERENCE_TIME *ptStop) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBufferingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBuffering * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBuffering * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBuffering * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetBufferingDepth )( 
            IBuffering * This,
            const REFERENCE_TIME *ptStop);
        
        HRESULT ( STDMETHODCALLTYPE *GetBufferingDepth )( 
            IBuffering * This,
            REFERENCE_TIME *ptStop);
        
        END_INTERFACE
    } IBufferingVtbl;

    interface IBuffering
    {
        CONST_VTBL struct IBufferingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBuffering_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBuffering_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBuffering_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBuffering_SetBufferingDepth(This,ptStop)	\
    ( (This)->lpVtbl -> SetBufferingDepth(This,ptStop) ) 

#define IBuffering_GetBufferingDepth(This,ptStop)	\
    ( (This)->lpVtbl -> GetBufferingDepth(This,ptStop) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IBuffering_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0083 */
/* [local] */ 

typedef 
enum tagBufferingFullType
    {	VideoBufferFull	= 1,
	AudioBufferFull	= 2
    } 	BufferFullType;

typedef struct _AMCOPPSignature
    {
    BYTE Signature[ 256 ];
    } 	AMCOPPSignature;

typedef struct _AMCOPPCommand
    {
    GUID macKDI;
    GUID guidCommandID;
    DWORD dwSequence;
    DWORD cbSizeData;
    BYTE CommandData[ 4056 ];
    } 	AMCOPPCommand;

typedef struct _AMCOPPCommand *LPAMCOPPCommand;

typedef struct _AMCOPPStatusInput
    {
    GUID rApp;
    GUID guidStatusRequestID;
    DWORD dwSequence;
    DWORD cbSizeData;
    BYTE StatusData[ 4056 ];
    } 	AMCOPPStatusInput;

typedef struct _AMCOPPStatusInput *LPAMCOPPStatusInput;

typedef struct _AMCOPPStatusOutput
    {
    GUID macKDI;
    DWORD cbSizeData;
    BYTE COPPStatus[ 4076 ];
    } 	AMCOPPStatusOutput;

typedef struct _AMCOPPStatusOutput *LPAMCOPPStatusOutput;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0083_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0083_v0_0_s_ifspec;

#ifndef __IAMCertifiedOutputProtection_INTERFACE_DEFINED__
#define __IAMCertifiedOutputProtection_INTERFACE_DEFINED__

/* interface IAMCertifiedOutputProtection */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IAMCertifiedOutputProtection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6feded3e-0ff1-4901-a2f1-43f7012c8515")
    IAMCertifiedOutputProtection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE KeyExchange( 
            /* [out] */ GUID *pRandom,
            /* [out] */ BYTE **VarLenCertGH,
            /* [out] */ DWORD *pdwLengthCertGH) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SessionSequenceStart( 
            /* [in] */ AMCOPPSignature *pSig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProtectionCommand( 
            /* [in] */ const AMCOPPCommand *cmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProtectionStatus( 
            /* [in] */ const AMCOPPStatusInput *pStatusInput,
            /* [out] */ AMCOPPStatusOutput *pStatusOutput) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMCertifiedOutputProtectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMCertifiedOutputProtection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMCertifiedOutputProtection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMCertifiedOutputProtection * This);
        
        HRESULT ( STDMETHODCALLTYPE *KeyExchange )( 
            IAMCertifiedOutputProtection * This,
            /* [out] */ GUID *pRandom,
            /* [out] */ BYTE **VarLenCertGH,
            /* [out] */ DWORD *pdwLengthCertGH);
        
        HRESULT ( STDMETHODCALLTYPE *SessionSequenceStart )( 
            IAMCertifiedOutputProtection * This,
            /* [in] */ AMCOPPSignature *pSig);
        
        HRESULT ( STDMETHODCALLTYPE *ProtectionCommand )( 
            IAMCertifiedOutputProtection * This,
            /* [in] */ const AMCOPPCommand *cmd);
        
        HRESULT ( STDMETHODCALLTYPE *ProtectionStatus )( 
            IAMCertifiedOutputProtection * This,
            /* [in] */ const AMCOPPStatusInput *pStatusInput,
            /* [out] */ AMCOPPStatusOutput *pStatusOutput);
        
        END_INTERFACE
    } IAMCertifiedOutputProtectionVtbl;

    interface IAMCertifiedOutputProtection
    {
        CONST_VTBL struct IAMCertifiedOutputProtectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMCertifiedOutputProtection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMCertifiedOutputProtection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMCertifiedOutputProtection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMCertifiedOutputProtection_KeyExchange(This,pRandom,VarLenCertGH,pdwLengthCertGH)	\
    ( (This)->lpVtbl -> KeyExchange(This,pRandom,VarLenCertGH,pdwLengthCertGH) ) 

#define IAMCertifiedOutputProtection_SessionSequenceStart(This,pSig)	\
    ( (This)->lpVtbl -> SessionSequenceStart(This,pSig) ) 

#define IAMCertifiedOutputProtection_ProtectionCommand(This,cmd)	\
    ( (This)->lpVtbl -> ProtectionCommand(This,cmd) ) 

#define IAMCertifiedOutputProtection_ProtectionStatus(This,pStatusInput,pStatusOutput)	\
    ( (This)->lpVtbl -> ProtectionStatus(This,pStatusInput,pStatusOutput) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMCertifiedOutputProtection_INTERFACE_DEFINED__ */


#ifndef __IVideoFrameStep_INTERFACE_DEFINED__
#define __IVideoFrameStep_INTERFACE_DEFINED__

/* interface IVideoFrameStep */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVideoFrameStep;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e46a9787-2b71-444d-a4b5-1fab7b708d6a")
    IVideoFrameStep : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Step( 
            DWORD dwFrames,
            /* [unique] */ IUnknown *pStepObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanStep( 
            long bMultiple,
            /* [unique] */ IUnknown *pStepObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelStep( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVideoFrameStepVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVideoFrameStep * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVideoFrameStep * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVideoFrameStep * This);
        
        HRESULT ( STDMETHODCALLTYPE *Step )( 
            IVideoFrameStep * This,
            DWORD dwFrames,
            /* [unique] */ IUnknown *pStepObject);
        
        HRESULT ( STDMETHODCALLTYPE *CanStep )( 
            IVideoFrameStep * This,
            long bMultiple,
            /* [unique] */ IUnknown *pStepObject);
        
        HRESULT ( STDMETHODCALLTYPE *CancelStep )( 
            IVideoFrameStep * This);
        
        END_INTERFACE
    } IVideoFrameStepVtbl;

    interface IVideoFrameStep
    {
        CONST_VTBL struct IVideoFrameStepVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVideoFrameStep_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVideoFrameStep_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVideoFrameStep_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVideoFrameStep_Step(This,dwFrames,pStepObject)	\
    ( (This)->lpVtbl -> Step(This,dwFrames,pStepObject) ) 

#define IVideoFrameStep_CanStep(This,bMultiple,pStepObject)	\
    ( (This)->lpVtbl -> CanStep(This,bMultiple,pStepObject) ) 

#define IVideoFrameStep_CancelStep(This)	\
    ( (This)->lpVtbl -> CancelStep(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVideoFrameStep_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0085 */
/* [local] */ 

typedef /* [public][public][public][public][public] */ 
enum __MIDL___MIDL_itf_strmif_0000_0085_0001
    {	AM_ROTATION_ANGLE_0	= 0,
	AM_ROTATION_ANGLE_90	= ( AM_ROTATION_ANGLE_0 + 1 ) ,
	AM_ROTATION_ANGLE_180	= ( AM_ROTATION_ANGLE_90 + 1 ) ,
	AM_ROTATION_ANGLE_270	= ( AM_ROTATION_ANGLE_180 + 1 ) 
    } 	AM_ROTATION_ANGLE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_strmif_0000_0085_0002
    {	AM_TRANSFORM_SCALING_LIMITED	= 0x1,
	AM_TRANSFORM_SCALING_ARBITRARY	= 0x2
    } 	AM_TRANSFORM_SCALING_CAPS;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_strmif_0000_0085_0003
    {	AM_TRANSFORM_ROTATION_CARDINAL	= 0x1
    } 	AM_TRANSFORM_ROTATION_CAPS;

typedef /* [public][public][public][public][public] */ 
enum __MIDL___MIDL_itf_strmif_0000_0085_0004
    {	AM_TRANSFORM_SCALING_NEAREST	= 0x1,
	AM_TRANSFORM_SCALING_BILINEAR	= 0x2,
	AM_TRANSFORM_SCALING_BICUBIC	= 0x4
    } 	AM_TRANSFORM_SCALING_MODE;

typedef /* [public][public][public] */ struct __MIDL___MIDL_itf_strmif_0000_0085_0005
    {
    ULONG x;
    ULONG y;
    } 	AMScalingRatio;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0085_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0085_v0_0_s_ifspec;

#ifndef __IAMVideoTransform_INTERFACE_DEFINED__
#define __IAMVideoTransform_INTERFACE_DEFINED__

/* interface IAMVideoTransform */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_IAMVideoTransform;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f68cd101-5e69-49b4-a9e1-5c62ef78d0ad")
    IAMVideoTransform : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetDestinationRotation( 
            /* [in] */ AM_ROTATION_ANGLE rotation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDestinationRotation( 
            /* [out] */ AM_ROTATION_ANGLE *pRotation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetScalingMode( 
            /* [in] */ AM_TRANSFORM_SCALING_MODE scalingMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScalingMode( 
            /* [out] */ AM_TRANSFORM_SCALING_MODE *pScalingMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRotationCaps( 
            /* [out] */ DWORD *pdwRotationCapsMask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScalingModeCaps( 
            /* [out] */ DWORD *pdwScalingModeCapsMask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScalingCaps( 
            /* [in] */ BOOL bDirectDraw,
            /* [out] */ DWORD *pdwScalingCapsMask,
            /* [out] */ AMScalingRatio **ppRatios,
            /* [out] */ ULONG *pCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMVideoTransformVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMVideoTransform * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMVideoTransform * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMVideoTransform * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDestinationRotation )( 
            IAMVideoTransform * This,
            /* [in] */ AM_ROTATION_ANGLE rotation);
        
        HRESULT ( STDMETHODCALLTYPE *GetDestinationRotation )( 
            IAMVideoTransform * This,
            /* [out] */ AM_ROTATION_ANGLE *pRotation);
        
        HRESULT ( STDMETHODCALLTYPE *SetScalingMode )( 
            IAMVideoTransform * This,
            /* [in] */ AM_TRANSFORM_SCALING_MODE scalingMode);
        
        HRESULT ( STDMETHODCALLTYPE *GetScalingMode )( 
            IAMVideoTransform * This,
            /* [out] */ AM_TRANSFORM_SCALING_MODE *pScalingMode);
        
        HRESULT ( STDMETHODCALLTYPE *GetRotationCaps )( 
            IAMVideoTransform * This,
            /* [out] */ DWORD *pdwRotationCapsMask);
        
        HRESULT ( STDMETHODCALLTYPE *GetScalingModeCaps )( 
            IAMVideoTransform * This,
            /* [out] */ DWORD *pdwScalingModeCapsMask);
        
        HRESULT ( STDMETHODCALLTYPE *GetScalingCaps )( 
            IAMVideoTransform * This,
            /* [in] */ BOOL bDirectDraw,
            /* [out] */ DWORD *pdwScalingCapsMask,
            /* [out] */ AMScalingRatio **ppRatios,
            /* [out] */ ULONG *pCount);
        
        END_INTERFACE
    } IAMVideoTransformVtbl;

    interface IAMVideoTransform
    {
        CONST_VTBL struct IAMVideoTransformVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMVideoTransform_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMVideoTransform_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMVideoTransform_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMVideoTransform_SetDestinationRotation(This,rotation)	\
    ( (This)->lpVtbl -> SetDestinationRotation(This,rotation) ) 

#define IAMVideoTransform_GetDestinationRotation(This,pRotation)	\
    ( (This)->lpVtbl -> GetDestinationRotation(This,pRotation) ) 

#define IAMVideoTransform_SetScalingMode(This,scalingMode)	\
    ( (This)->lpVtbl -> SetScalingMode(This,scalingMode) ) 

#define IAMVideoTransform_GetScalingMode(This,pScalingMode)	\
    ( (This)->lpVtbl -> GetScalingMode(This,pScalingMode) ) 

#define IAMVideoTransform_GetRotationCaps(This,pdwRotationCapsMask)	\
    ( (This)->lpVtbl -> GetRotationCaps(This,pdwRotationCapsMask) ) 

#define IAMVideoTransform_GetScalingModeCaps(This,pdwScalingModeCapsMask)	\
    ( (This)->lpVtbl -> GetScalingModeCaps(This,pdwScalingModeCapsMask) ) 

#define IAMVideoTransform_GetScalingCaps(This,bDirectDraw,pdwScalingCapsMask,ppRatios,pCount)	\
    ( (This)->lpVtbl -> GetScalingCaps(This,bDirectDraw,pdwScalingCapsMask,ppRatios,pCount) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMVideoTransform_INTERFACE_DEFINED__ */


#ifndef __IAMVideoTransformComponent_INTERFACE_DEFINED__
#define __IAMVideoTransformComponent_INTERFACE_DEFINED__

/* interface IAMVideoTransformComponent */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMVideoTransformComponent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d8802068-891f-4c7f-b0c6-275c09a03260")
    IAMVideoTransformComponent : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetBufferParams( 
            /* [in] */ AM_ROTATION_ANGLE SurfaceAngle,
            /* [in] */ int XPitch,
            /* [in] */ int YPitch,
            /* [in] */ const AM_MEDIA_TYPE *pmt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBufferParams( 
            /* [out] */ AM_ROTATION_ANGLE *pSurfaceAngle,
            /* [out] */ int *pXPitch,
            /* [out] */ int *pYPitch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetScalingMode( 
            /* [in] */ AM_TRANSFORM_SCALING_MODE scalingMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScalingMode( 
            /* [out] */ AM_TRANSFORM_SCALING_MODE *pScalingMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRotationCaps( 
            /* [in] */ const AM_MEDIA_TYPE *pmt,
            /* [out] */ DWORD *pdwRotationCapsMask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScalingModeCaps( 
            /* [in] */ const AM_MEDIA_TYPE *pmt,
            /* [out] */ DWORD *pdwScalingModeCapsMask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScalingCaps( 
            /* [in] */ const AM_MEDIA_TYPE *pmt,
            /* [out] */ DWORD *pdwScalingCapsMask,
            /* [out] */ AMScalingRatio **ppRatios,
            /* [out] */ ULONG *pCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMVideoTransformComponentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMVideoTransformComponent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMVideoTransformComponent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMVideoTransformComponent * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetBufferParams )( 
            IAMVideoTransformComponent * This,
            /* [in] */ AM_ROTATION_ANGLE SurfaceAngle,
            /* [in] */ int XPitch,
            /* [in] */ int YPitch,
            /* [in] */ const AM_MEDIA_TYPE *pmt);
        
        HRESULT ( STDMETHODCALLTYPE *GetBufferParams )( 
            IAMVideoTransformComponent * This,
            /* [out] */ AM_ROTATION_ANGLE *pSurfaceAngle,
            /* [out] */ int *pXPitch,
            /* [out] */ int *pYPitch);
        
        HRESULT ( STDMETHODCALLTYPE *SetScalingMode )( 
            IAMVideoTransformComponent * This,
            /* [in] */ AM_TRANSFORM_SCALING_MODE scalingMode);
        
        HRESULT ( STDMETHODCALLTYPE *GetScalingMode )( 
            IAMVideoTransformComponent * This,
            /* [out] */ AM_TRANSFORM_SCALING_MODE *pScalingMode);
        
        HRESULT ( STDMETHODCALLTYPE *GetRotationCaps )( 
            IAMVideoTransformComponent * This,
            /* [in] */ const AM_MEDIA_TYPE *pmt,
            /* [out] */ DWORD *pdwRotationCapsMask);
        
        HRESULT ( STDMETHODCALLTYPE *GetScalingModeCaps )( 
            IAMVideoTransformComponent * This,
            /* [in] */ const AM_MEDIA_TYPE *pmt,
            /* [out] */ DWORD *pdwScalingModeCapsMask);
        
        HRESULT ( STDMETHODCALLTYPE *GetScalingCaps )( 
            IAMVideoTransformComponent * This,
            /* [in] */ const AM_MEDIA_TYPE *pmt,
            /* [out] */ DWORD *pdwScalingCapsMask,
            /* [out] */ AMScalingRatio **ppRatios,
            /* [out] */ ULONG *pCount);
        
        END_INTERFACE
    } IAMVideoTransformComponentVtbl;

    interface IAMVideoTransformComponent
    {
        CONST_VTBL struct IAMVideoTransformComponentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMVideoTransformComponent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMVideoTransformComponent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMVideoTransformComponent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMVideoTransformComponent_SetBufferParams(This,SurfaceAngle,XPitch,YPitch,pmt)	\
    ( (This)->lpVtbl -> SetBufferParams(This,SurfaceAngle,XPitch,YPitch,pmt) ) 

#define IAMVideoTransformComponent_GetBufferParams(This,pSurfaceAngle,pXPitch,pYPitch)	\
    ( (This)->lpVtbl -> GetBufferParams(This,pSurfaceAngle,pXPitch,pYPitch) ) 

#define IAMVideoTransformComponent_SetScalingMode(This,scalingMode)	\
    ( (This)->lpVtbl -> SetScalingMode(This,scalingMode) ) 

#define IAMVideoTransformComponent_GetScalingMode(This,pScalingMode)	\
    ( (This)->lpVtbl -> GetScalingMode(This,pScalingMode) ) 

#define IAMVideoTransformComponent_GetRotationCaps(This,pmt,pdwRotationCapsMask)	\
    ( (This)->lpVtbl -> GetRotationCaps(This,pmt,pdwRotationCapsMask) ) 

#define IAMVideoTransformComponent_GetScalingModeCaps(This,pmt,pdwScalingModeCapsMask)	\
    ( (This)->lpVtbl -> GetScalingModeCaps(This,pmt,pdwScalingModeCapsMask) ) 

#define IAMVideoTransformComponent_GetScalingCaps(This,pmt,pdwScalingCapsMask,ppRatios,pCount)	\
    ( (This)->lpVtbl -> GetScalingCaps(This,pmt,pdwScalingCapsMask,ppRatios,pCount) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMVideoTransformComponent_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0087 */
/* [local] */ 

#if 0
typedef void PropertyItem;

#endif
#define IMAGE_METADATA_DATE_TIME     0x00000001
#if defined(__cplusplus) && !defined(CINTERFACE)
#include <GdiplusPixelFormats.h>
#include <GdiplusImaging.h>
#else
typedef struct
{
    PROPID  id;                 // ID of this property
    ULONG   length;             // Length of the property value, in bytes
    WORD    type;               // Type of the value, as one of TAG_TYPE_XXX
                                // defined above
    UNALIGNED VOID *value;      // property value
} PropertyItem;
#endif // __cplusplus && !CINTERFACE
typedef /* [public] */ struct __MIDL___MIDL_itf_strmif_0000_0087_0001
    {
    DWORD dwCount;
    PropertyItem rgitemMetadata[ 1 ];
    } 	MetadataBuffer;

typedef struct __MIDL___MIDL_itf_strmif_0000_0087_0001 *PMetadataBuffer;

typedef /* [public][public][public][public][public] */ 
enum __MIDL___MIDL_itf_strmif_0000_0087_0002
    {	IMAGEMETADATA_PERSISTENCE_STATIC	= 1,
	IMAGEMETADATA_PERSISTENCE_DYNAMIC	= ( IMAGEMETADATA_PERSISTENCE_STATIC + 1 ) ,
	IMAGEMETADATA_PERSISTENCE_ALL	= ( IMAGEMETADATA_PERSISTENCE_DYNAMIC + 1 ) 
    } 	IMAGEMETADATA_PERSISTENCE;

typedef enum __MIDL___MIDL_itf_strmif_0000_0087_0002 *PIMAGEMETADATA_PERSISTENCE;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0087_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0087_v0_0_s_ifspec;

#ifndef __ICaptureMetadata_INTERFACE_DEFINED__
#define __ICaptureMetadata_INTERFACE_DEFINED__

/* interface ICaptureMetadata */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_ICaptureMetadata;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F86124BE-B79F-40eb-B81A-A15E5C8EFEA6")
    ICaptureMetadata : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAllPropertyItems( 
            /* [out][in] */ DWORD *pdwSize,
            /* [out][in] */ PMetadataBuffer pBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICaptureMetadataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICaptureMetadata * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICaptureMetadata * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICaptureMetadata * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllPropertyItems )( 
            ICaptureMetadata * This,
            /* [out][in] */ DWORD *pdwSize,
            /* [out][in] */ PMetadataBuffer pBuffer);
        
        END_INTERFACE
    } ICaptureMetadataVtbl;

    interface ICaptureMetadata
    {
        CONST_VTBL struct ICaptureMetadataVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICaptureMetadata_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICaptureMetadata_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICaptureMetadata_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICaptureMetadata_GetAllPropertyItems(This,pdwSize,pBuffer)	\
    ( (This)->lpVtbl -> GetAllPropertyItems(This,pdwSize,pBuffer) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICaptureMetadata_INTERFACE_DEFINED__ */


#ifndef __IImageMetadata_INTERFACE_DEFINED__
#define __IImageMetadata_INTERFACE_DEFINED__

/* interface IImageMetadata */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IImageMetadata;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B3B2F1A4-5E97-45f2-92F7-5728A4736165")
    IImageMetadata : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetPropertyItems( 
            /* [in] */ DWORD dwSize,
            /* [in] */ const PMetadataBuffer pBuffer,
            /* [in] */ IMAGEMETADATA_PERSISTENCE persistenceCache) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyItem( 
            /* [in] */ PROPID propId,
            /* [out][in] */ DWORD *pdwSize,
            /* [out][in] */ PropertyItem *pBuffer,
            /* [in] */ IMAGEMETADATA_PERSISTENCE persistenceCache) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllPropertyItems( 
            /* [out][in] */ DWORD *pdwSize,
            /* [out][in] */ PMetadataBuffer pBuffer,
            /* [in] */ IMAGEMETADATA_PERSISTENCE persistenceCache) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearCache( 
            /* [in] */ IMAGEMETADATA_PERSISTENCE persistenceCache) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAutoMode( 
            /* [in] */ DWORD dwMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAutoMode( 
            /* [out] */ DWORD *pdwMode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImageMetadataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IImageMetadata * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IImageMetadata * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IImageMetadata * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPropertyItems )( 
            IImageMetadata * This,
            /* [in] */ DWORD dwSize,
            /* [in] */ const PMetadataBuffer pBuffer,
            /* [in] */ IMAGEMETADATA_PERSISTENCE persistenceCache);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyItem )( 
            IImageMetadata * This,
            /* [in] */ PROPID propId,
            /* [out][in] */ DWORD *pdwSize,
            /* [out][in] */ PropertyItem *pBuffer,
            /* [in] */ IMAGEMETADATA_PERSISTENCE persistenceCache);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllPropertyItems )( 
            IImageMetadata * This,
            /* [out][in] */ DWORD *pdwSize,
            /* [out][in] */ PMetadataBuffer pBuffer,
            /* [in] */ IMAGEMETADATA_PERSISTENCE persistenceCache);
        
        HRESULT ( STDMETHODCALLTYPE *ClearCache )( 
            IImageMetadata * This,
            /* [in] */ IMAGEMETADATA_PERSISTENCE persistenceCache);
        
        HRESULT ( STDMETHODCALLTYPE *SetAutoMode )( 
            IImageMetadata * This,
            /* [in] */ DWORD dwMode);
        
        HRESULT ( STDMETHODCALLTYPE *GetAutoMode )( 
            IImageMetadata * This,
            /* [out] */ DWORD *pdwMode);
        
        END_INTERFACE
    } IImageMetadataVtbl;

    interface IImageMetadata
    {
        CONST_VTBL struct IImageMetadataVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImageMetadata_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IImageMetadata_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IImageMetadata_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IImageMetadata_SetPropertyItems(This,dwSize,pBuffer,persistenceCache)	\
    ( (This)->lpVtbl -> SetPropertyItems(This,dwSize,pBuffer,persistenceCache) ) 

#define IImageMetadata_GetPropertyItem(This,propId,pdwSize,pBuffer,persistenceCache)	\
    ( (This)->lpVtbl -> GetPropertyItem(This,propId,pdwSize,pBuffer,persistenceCache) ) 

#define IImageMetadata_GetAllPropertyItems(This,pdwSize,pBuffer,persistenceCache)	\
    ( (This)->lpVtbl -> GetAllPropertyItems(This,pdwSize,pBuffer,persistenceCache) ) 

#define IImageMetadata_ClearCache(This,persistenceCache)	\
    ( (This)->lpVtbl -> ClearCache(This,persistenceCache) ) 

#define IImageMetadata_SetAutoMode(This,dwMode)	\
    ( (This)->lpVtbl -> SetAutoMode(This,dwMode) ) 

#define IImageMetadata_GetAutoMode(This,pdwMode)	\
    ( (This)->lpVtbl -> GetAutoMode(This,pdwMode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IImageMetadata_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0089 */
/* [local] */ 

#include <ddraw.h>







typedef 
enum tagDVD_DOMAIN
    {	DVD_DOMAIN_FirstPlay	= 1,
	DVD_DOMAIN_VideoManagerMenu	= ( DVD_DOMAIN_FirstPlay + 1 ) ,
	DVD_DOMAIN_VideoTitleSetMenu	= ( DVD_DOMAIN_VideoManagerMenu + 1 ) ,
	DVD_DOMAIN_Title	= ( DVD_DOMAIN_VideoTitleSetMenu + 1 ) ,
	DVD_DOMAIN_Stop	= ( DVD_DOMAIN_Title + 1 ) 
    } 	DVD_DOMAIN;

typedef 
enum tagDVD_MENU_ID
    {	DVD_MENU_Title	= 2,
	DVD_MENU_Root	= 3,
	DVD_MENU_Subpicture	= 4,
	DVD_MENU_Audio	= 5,
	DVD_MENU_Angle	= 6,
	DVD_MENU_Chapter	= 7
    } 	DVD_MENU_ID;

typedef 
enum tagDVD_DISC_SIDE
    {	DVD_SIDE_A	= 1,
	DVD_SIDE_B	= 2
    } 	DVD_DISC_SIDE;

typedef 
enum tagDVD_PREFERRED_DISPLAY_MODE
    {	DISPLAY_CONTENT_DEFAULT	= 0,
	DISPLAY_16x9	= 1,
	DISPLAY_4x3_PANSCAN_PREFERRED	= 2,
	DISPLAY_4x3_LETTERBOX_PREFERRED	= 3
    } 	DVD_PREFERRED_DISPLAY_MODE;

typedef WORD DVD_REGISTER;

typedef DVD_REGISTER GPRMARRAY[ 16 ];

typedef DVD_REGISTER SPRMARRAY[ 24 ];

typedef struct tagDVD_ATR
    {
    ULONG ulCAT;
    BYTE pbATRI[ 768 ];
    } 	DVD_ATR;

typedef BYTE DVD_VideoATR[ 2 ];

typedef BYTE DVD_AudioATR[ 8 ];

typedef BYTE DVD_SubpictureATR[ 6 ];

typedef 
enum tagDVD_FRAMERATE
    {	DVD_FPS_25	= 1,
	DVD_FPS_30NonDrop	= 3
    } 	DVD_FRAMERATE;

typedef struct tagDVD_TIMECODE
{
   ULONG Hours1    :4; // Hours
   ULONG Hours10  :4; // Tens of Hours 

   ULONG Minutes1  :4; // Minutes 
   ULONG Minutes10:4; // Tens of Minutes 

   ULONG Seconds1  :4; // Seconds 
   ULONG Seconds10:4; // Tens of Seconds 

   ULONG Frames1   :4; // Frames 
   ULONG Frames10 :2; // Tens of Frames 

   ULONG FrameRateCode: 2; // use DVD_FRAMERATE to indicate frames/sec and drop/non-drop
} DVD_TIMECODE;
typedef 
enum tagDVD_TIMECODE_FLAGS
    {	DVD_TC_FLAG_25fps	= 0x1,
	DVD_TC_FLAG_30fps	= 0x2,
	DVD_TC_FLAG_DropFrame	= 0x4,
	DVD_TC_FLAG_Interpolated	= 0x8
    } 	DVD_TIMECODE_FLAGS;

typedef struct tagDVD_HMSF_TIMECODE
    {
    BYTE bHours;
    BYTE bMinutes;
    BYTE bSeconds;
    BYTE bFrames;
    } 	DVD_HMSF_TIMECODE;

typedef struct tagDVD_PLAYBACK_LOCATION2
    {
    ULONG TitleNum;
    ULONG ChapterNum;
    DVD_HMSF_TIMECODE TimeCode;
    ULONG TimeCodeFlags;
    } 	DVD_PLAYBACK_LOCATION2;

typedef struct tagDVD_PLAYBACK_LOCATION
    {
    ULONG TitleNum;
    ULONG ChapterNum;
    ULONG TimeCode;
    } 	DVD_PLAYBACK_LOCATION;

typedef DWORD VALID_UOP_SOMTHING_OR_OTHER;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_strmif_0000_0089_0001
    {	UOP_FLAG_Play_Title_Or_AtTime	= 0x1,
	UOP_FLAG_Play_Chapter	= 0x2,
	UOP_FLAG_Play_Title	= 0x4,
	UOP_FLAG_Stop	= 0x8,
	UOP_FLAG_ReturnFromSubMenu	= 0x10,
	UOP_FLAG_Play_Chapter_Or_AtTime	= 0x20,
	UOP_FLAG_PlayPrev_Or_Replay_Chapter	= 0x40,
	UOP_FLAG_PlayNext_Chapter	= 0x80,
	UOP_FLAG_Play_Forwards	= 0x100,
	UOP_FLAG_Play_Backwards	= 0x200,
	UOP_FLAG_ShowMenu_Title	= 0x400,
	UOP_FLAG_ShowMenu_Root	= 0x800,
	UOP_FLAG_ShowMenu_SubPic	= 0x1000,
	UOP_FLAG_ShowMenu_Audio	= 0x2000,
	UOP_FLAG_ShowMenu_Angle	= 0x4000,
	UOP_FLAG_ShowMenu_Chapter	= 0x8000,
	UOP_FLAG_Resume	= 0x10000,
	UOP_FLAG_Select_Or_Activate_Button	= 0x20000,
	UOP_FLAG_Still_Off	= 0x40000,
	UOP_FLAG_Pause_On	= 0x80000,
	UOP_FLAG_Select_Audio_Stream	= 0x100000,
	UOP_FLAG_Select_SubPic_Stream	= 0x200000,
	UOP_FLAG_Select_Angle	= 0x400000,
	UOP_FLAG_Select_Karaoke_Audio_Presentation_Mode	= 0x800000,
	UOP_FLAG_Select_Video_Mode_Preference	= 0x1000000
    } 	VALID_UOP_FLAG;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_strmif_0000_0089_0002
    {	DVD_CMD_FLAG_None	= 0,
	DVD_CMD_FLAG_Flush	= 0x1,
	DVD_CMD_FLAG_SendEvents	= 0x2,
	DVD_CMD_FLAG_Block	= 0x4,
	DVD_CMD_FLAG_StartWhenRendered	= 0x8,
	DVD_CMD_FLAG_EndAfterRendered	= 0x10
    } 	DVD_CMD_FLAGS;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_strmif_0000_0089_0003
    {	DVD_ResetOnStop	= 1,
	DVD_NotifyParentalLevelChange	= 2,
	DVD_HMSF_TimeCodeEvents	= 3
    } 	DVD_OPTION_FLAG;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_strmif_0000_0089_0004
    {	DVD_Relative_Upper	= 1,
	DVD_Relative_Lower	= 2,
	DVD_Relative_Left	= 3,
	DVD_Relative_Right	= 4
    } 	DVD_RELATIVE_BUTTON;

typedef 
enum tagDVD_PARENTAL_LEVEL
    {	DVD_PARENTAL_LEVEL_8	= 0x8000,
	DVD_PARENTAL_LEVEL_7	= 0x4000,
	DVD_PARENTAL_LEVEL_6	= 0x2000,
	DVD_PARENTAL_LEVEL_5	= 0x1000,
	DVD_PARENTAL_LEVEL_4	= 0x800,
	DVD_PARENTAL_LEVEL_3	= 0x400,
	DVD_PARENTAL_LEVEL_2	= 0x200,
	DVD_PARENTAL_LEVEL_1	= 0x100
    } 	DVD_PARENTAL_LEVEL;

typedef 
enum tagDVD_AUDIO_LANG_EXT
    {	DVD_AUD_EXT_NotSpecified	= 0,
	DVD_AUD_EXT_Captions	= 1,
	DVD_AUD_EXT_VisuallyImpaired	= 2,
	DVD_AUD_EXT_DirectorComments1	= 3,
	DVD_AUD_EXT_DirectorComments2	= 4
    } 	DVD_AUDIO_LANG_EXT;

typedef 
enum tagDVD_SUBPICTURE_LANG_EXT
    {	DVD_SP_EXT_NotSpecified	= 0,
	DVD_SP_EXT_Caption_Normal	= 1,
	DVD_SP_EXT_Caption_Big	= 2,
	DVD_SP_EXT_Caption_Children	= 3,
	DVD_SP_EXT_CC_Normal	= 5,
	DVD_SP_EXT_CC_Big	= 6,
	DVD_SP_EXT_CC_Children	= 7,
	DVD_SP_EXT_Forced	= 9,
	DVD_SP_EXT_DirectorComments_Normal	= 13,
	DVD_SP_EXT_DirectorComments_Big	= 14,
	DVD_SP_EXT_DirectorComments_Children	= 15
    } 	DVD_SUBPICTURE_LANG_EXT;

typedef 
enum tagDVD_AUDIO_APPMODE
    {	DVD_AudioMode_None	= 0,
	DVD_AudioMode_Karaoke	= 1,
	DVD_AudioMode_Surround	= 2,
	DVD_AudioMode_Other	= 3
    } 	DVD_AUDIO_APPMODE;

typedef 
enum tagDVD_AUDIO_FORMAT
    {	DVD_AudioFormat_AC3	= 0,
	DVD_AudioFormat_MPEG1	= 1,
	DVD_AudioFormat_MPEG1_DRC	= 2,
	DVD_AudioFormat_MPEG2	= 3,
	DVD_AudioFormat_MPEG2_DRC	= 4,
	DVD_AudioFormat_LPCM	= 5,
	DVD_AudioFormat_DTS	= 6,
	DVD_AudioFormat_SDDS	= 7,
	DVD_AudioFormat_Other	= 8
    } 	DVD_AUDIO_FORMAT;

typedef 
enum tagDVD_KARAOKE_DOWNMIX
    {	DVD_Mix_0to0	= 0x1,
	DVD_Mix_1to0	= 0x2,
	DVD_Mix_2to0	= 0x4,
	DVD_Mix_3to0	= 0x8,
	DVD_Mix_4to0	= 0x10,
	DVD_Mix_Lto0	= 0x20,
	DVD_Mix_Rto0	= 0x40,
	DVD_Mix_0to1	= 0x100,
	DVD_Mix_1to1	= 0x200,
	DVD_Mix_2to1	= 0x400,
	DVD_Mix_3to1	= 0x800,
	DVD_Mix_4to1	= 0x1000,
	DVD_Mix_Lto1	= 0x2000,
	DVD_Mix_Rto1	= 0x4000
    } 	DVD_KARAOKE_DOWNMIX;

typedef struct tagDVD_AudioAttributes
    {
    DVD_AUDIO_APPMODE AppMode;
    BYTE AppModeData;
    DVD_AUDIO_FORMAT AudioFormat;
    LCID Language;
    DVD_AUDIO_LANG_EXT LanguageExtension;
    BOOL fHasMultichannelInfo;
    DWORD dwFrequency;
    BYTE bQuantization;
    BYTE bNumberOfChannels;
    DWORD dwReserved[ 2 ];
    } 	DVD_AudioAttributes;

typedef struct tagDVD_MUA_MixingInfo
    {
    BOOL fMixTo0;
    BOOL fMixTo1;
    BOOL fMix0InPhase;
    BOOL fMix1InPhase;
    DWORD dwSpeakerPosition;
    } 	DVD_MUA_MixingInfo;

typedef struct tagDVD_MUA_Coeff
    {
    double log2_alpha;
    double log2_beta;
    } 	DVD_MUA_Coeff;

typedef struct tagDVD_MultichannelAudioAttributes
    {
    DVD_MUA_MixingInfo Info[ 8 ];
    DVD_MUA_Coeff Coeff[ 8 ];
    } 	DVD_MultichannelAudioAttributes;

typedef 
enum tagDVD_KARAOKE_CONTENTS
    {	DVD_Karaoke_GuideVocal1	= 0x1,
	DVD_Karaoke_GuideVocal2	= 0x2,
	DVD_Karaoke_GuideMelody1	= 0x4,
	DVD_Karaoke_GuideMelody2	= 0x8,
	DVD_Karaoke_GuideMelodyA	= 0x10,
	DVD_Karaoke_GuideMelodyB	= 0x20,
	DVD_Karaoke_SoundEffectA	= 0x40,
	DVD_Karaoke_SoundEffectB	= 0x80
    } 	DVD_KARAOKE_CONTENTS;

typedef 
enum tagDVD_KARAOKE_ASSIGNMENT
    {	DVD_Assignment_reserved0	= 0,
	DVD_Assignment_reserved1	= 1,
	DVD_Assignment_LR	= 2,
	DVD_Assignment_LRM	= 3,
	DVD_Assignment_LR1	= 4,
	DVD_Assignment_LRM1	= 5,
	DVD_Assignment_LR12	= 6,
	DVD_Assignment_LRM12	= 7
    } 	DVD_KARAOKE_ASSIGNMENT;

typedef struct tagDVD_KaraokeAttributes
    {
    BYTE bVersion;
    BOOL fMasterOfCeremoniesInGuideVocal1;
    BOOL fDuet;
    DVD_KARAOKE_ASSIGNMENT ChannelAssignment;
    WORD wChannelContents[ 8 ];
    } 	DVD_KaraokeAttributes;

typedef 
enum tagDVD_VIDEO_COMPRESSION
    {	DVD_VideoCompression_Other	= 0,
	DVD_VideoCompression_MPEG1	= 1,
	DVD_VideoCompression_MPEG2	= 2
    } 	DVD_VIDEO_COMPRESSION;

typedef struct tagDVD_VideoAttributes
    {
    BOOL fPanscanPermitted;
    BOOL fLetterboxPermitted;
    ULONG ulAspectX;
    ULONG ulAspectY;
    ULONG ulFrameRate;
    ULONG ulFrameHeight;
    DVD_VIDEO_COMPRESSION Compression;
    BOOL fLine21Field1InGOP;
    BOOL fLine21Field2InGOP;
    ULONG ulSourceResolutionX;
    ULONG ulSourceResolutionY;
    BOOL fIsSourceLetterboxed;
    BOOL fIsFilmMode;
    } 	DVD_VideoAttributes;

typedef 
enum tagDVD_SUBPICTURE_TYPE
    {	DVD_SPType_NotSpecified	= 0,
	DVD_SPType_Language	= 1,
	DVD_SPType_Other	= 2
    } 	DVD_SUBPICTURE_TYPE;

typedef 
enum tagDVD_SUBPICTURE_CODING
    {	DVD_SPCoding_RunLength	= 0,
	DVD_SPCoding_Extended	= 1,
	DVD_SPCoding_Other	= 2
    } 	DVD_SUBPICTURE_CODING;

typedef struct tagDVD_SubpictureAttributes
    {
    DVD_SUBPICTURE_TYPE Type;
    DVD_SUBPICTURE_CODING CodingMode;
    LCID Language;
    DVD_SUBPICTURE_LANG_EXT LanguageExtension;
    } 	DVD_SubpictureAttributes;

typedef 
enum tagDVD_TITLE_APPMODE
    {	DVD_AppMode_Not_Specified	= 0,
	DVD_AppMode_Karaoke	= 1,
	DVD_AppMode_Other	= 3
    } 	DVD_TITLE_APPMODE;

typedef struct tagDVD_TitleMainAttributes
    {
    DVD_TITLE_APPMODE AppMode;
    DVD_VideoAttributes VideoAttributes;
    ULONG ulNumberOfAudioStreams;
    DVD_AudioAttributes AudioAttributes[ 8 ];
    DVD_MultichannelAudioAttributes MultichannelAudioAttributes[ 8 ];
    ULONG ulNumberOfSubpictureStreams;
    DVD_SubpictureAttributes SubpictureAttributes[ 32 ];
    } 	DVD_TitleAttributes;

typedef struct tagDVD_MenuAttributes
    {
    BOOL fCompatibleRegion[ 8 ];
    DVD_VideoAttributes VideoAttributes;
    BOOL fAudioPresent;
    DVD_AudioAttributes AudioAttributes;
    BOOL fSubpicturePresent;
    DVD_SubpictureAttributes SubpictureAttributes;
    } 	DVD_MenuAttributes;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0089_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0089_v0_0_s_ifspec;

#ifndef __IDvdControl_INTERFACE_DEFINED__
#define __IDvdControl_INTERFACE_DEFINED__

/* interface IDvdControl */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDvdControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A70EFE61-E2A3-11d0-A9BE-00AA0061BE93")
    IDvdControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE TitlePlay( 
            /* [in] */ ULONG uiTitle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChapterPlay( 
            /* [in] */ ULONG uiTitle,
            /* [in] */ ULONG uiChapter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TimePlay( 
            /* [in] */ ULONG uiTitle,
            /* [in] */ ULONG bcdTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopForResume( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GoUp( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TimeSearch( 
            /* [in] */ ULONG bcdTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChapterSearch( 
            /* [in] */ ULONG Chapter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PrevPGSearch( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TopPGSearch( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NextPGSearch( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ForwardScan( 
            /* [in] */ double dwSpeed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BackwardScan( 
            /* [in] */ double dwSpeed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MenuCall( 
            /* [in] */ DVD_MENU_ID MenuID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpperButtonSelect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LowerButtonSelect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LeftButtonSelect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RightButtonSelect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ButtonActivate( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ButtonSelectAndActivate( 
            /* [in] */ ULONG uiButton) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StillOff( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PauseOn( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PauseOff( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MenuLanguageSelect( 
            /* [in] */ LCID Language) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AudioStreamChange( 
            /* [in] */ ULONG nAudio) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SubpictureStreamChange( 
            /* [in] */ ULONG nSubPicture,
            /* [in] */ BOOL bDisplay) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AngleChange( 
            /* [in] */ ULONG ulAngle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ParentalLevelSelect( 
            /* [in] */ ULONG ulParentalLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ParentalCountrySelect( 
            /* [in] */ WORD wCountry) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE KaraokeAudioPresentationModeChange( 
            /* [in] */ ULONG ulMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE VideoModePreferrence( 
            /* [in] */ ULONG ulPreferredDisplayMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRoot( 
            /* [in] */ LPCWSTR pszPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MouseActivate( 
            /* [in] */ POINT point) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MouseSelect( 
            /* [in] */ POINT point) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChapterPlayAutoStop( 
            /* [in] */ ULONG ulTitle,
            /* [in] */ ULONG ulChapter,
            /* [in] */ ULONG ulChaptersToPlay) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvdControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvdControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvdControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvdControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *TitlePlay )( 
            IDvdControl * This,
            /* [in] */ ULONG uiTitle);
        
        HRESULT ( STDMETHODCALLTYPE *ChapterPlay )( 
            IDvdControl * This,
            /* [in] */ ULONG uiTitle,
            /* [in] */ ULONG uiChapter);
        
        HRESULT ( STDMETHODCALLTYPE *TimePlay )( 
            IDvdControl * This,
            /* [in] */ ULONG uiTitle,
            /* [in] */ ULONG bcdTime);
        
        HRESULT ( STDMETHODCALLTYPE *StopForResume )( 
            IDvdControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GoUp )( 
            IDvdControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *TimeSearch )( 
            IDvdControl * This,
            /* [in] */ ULONG bcdTime);
        
        HRESULT ( STDMETHODCALLTYPE *ChapterSearch )( 
            IDvdControl * This,
            /* [in] */ ULONG Chapter);
        
        HRESULT ( STDMETHODCALLTYPE *PrevPGSearch )( 
            IDvdControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *TopPGSearch )( 
            IDvdControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *NextPGSearch )( 
            IDvdControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *ForwardScan )( 
            IDvdControl * This,
            /* [in] */ double dwSpeed);
        
        HRESULT ( STDMETHODCALLTYPE *BackwardScan )( 
            IDvdControl * This,
            /* [in] */ double dwSpeed);
        
        HRESULT ( STDMETHODCALLTYPE *MenuCall )( 
            IDvdControl * This,
            /* [in] */ DVD_MENU_ID MenuID);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IDvdControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *UpperButtonSelect )( 
            IDvdControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *LowerButtonSelect )( 
            IDvdControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *LeftButtonSelect )( 
            IDvdControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *RightButtonSelect )( 
            IDvdControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *ButtonActivate )( 
            IDvdControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *ButtonSelectAndActivate )( 
            IDvdControl * This,
            /* [in] */ ULONG uiButton);
        
        HRESULT ( STDMETHODCALLTYPE *StillOff )( 
            IDvdControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *PauseOn )( 
            IDvdControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *PauseOff )( 
            IDvdControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *MenuLanguageSelect )( 
            IDvdControl * This,
            /* [in] */ LCID Language);
        
        HRESULT ( STDMETHODCALLTYPE *AudioStreamChange )( 
            IDvdControl * This,
            /* [in] */ ULONG nAudio);
        
        HRESULT ( STDMETHODCALLTYPE *SubpictureStreamChange )( 
            IDvdControl * This,
            /* [in] */ ULONG nSubPicture,
            /* [in] */ BOOL bDisplay);
        
        HRESULT ( STDMETHODCALLTYPE *AngleChange )( 
            IDvdControl * This,
            /* [in] */ ULONG ulAngle);
        
        HRESULT ( STDMETHODCALLTYPE *ParentalLevelSelect )( 
            IDvdControl * This,
            /* [in] */ ULONG ulParentalLevel);
        
        HRESULT ( STDMETHODCALLTYPE *ParentalCountrySelect )( 
            IDvdControl * This,
            /* [in] */ WORD wCountry);
        
        HRESULT ( STDMETHODCALLTYPE *KaraokeAudioPresentationModeChange )( 
            IDvdControl * This,
            /* [in] */ ULONG ulMode);
        
        HRESULT ( STDMETHODCALLTYPE *VideoModePreferrence )( 
            IDvdControl * This,
            /* [in] */ ULONG ulPreferredDisplayMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetRoot )( 
            IDvdControl * This,
            /* [in] */ LPCWSTR pszPath);
        
        HRESULT ( STDMETHODCALLTYPE *MouseActivate )( 
            IDvdControl * This,
            /* [in] */ POINT point);
        
        HRESULT ( STDMETHODCALLTYPE *MouseSelect )( 
            IDvdControl * This,
            /* [in] */ POINT point);
        
        HRESULT ( STDMETHODCALLTYPE *ChapterPlayAutoStop )( 
            IDvdControl * This,
            /* [in] */ ULONG ulTitle,
            /* [in] */ ULONG ulChapter,
            /* [in] */ ULONG ulChaptersToPlay);
        
        END_INTERFACE
    } IDvdControlVtbl;

    interface IDvdControl
    {
        CONST_VTBL struct IDvdControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvdControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvdControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvdControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvdControl_TitlePlay(This,uiTitle)	\
    ( (This)->lpVtbl -> TitlePlay(This,uiTitle) ) 

#define IDvdControl_ChapterPlay(This,uiTitle,uiChapter)	\
    ( (This)->lpVtbl -> ChapterPlay(This,uiTitle,uiChapter) ) 

#define IDvdControl_TimePlay(This,uiTitle,bcdTime)	\
    ( (This)->lpVtbl -> TimePlay(This,uiTitle,bcdTime) ) 

#define IDvdControl_StopForResume(This)	\
    ( (This)->lpVtbl -> StopForResume(This) ) 

#define IDvdControl_GoUp(This)	\
    ( (This)->lpVtbl -> GoUp(This) ) 

#define IDvdControl_TimeSearch(This,bcdTime)	\
    ( (This)->lpVtbl -> TimeSearch(This,bcdTime) ) 

#define IDvdControl_ChapterSearch(This,Chapter)	\
    ( (This)->lpVtbl -> ChapterSearch(This,Chapter) ) 

#define IDvdControl_PrevPGSearch(This)	\
    ( (This)->lpVtbl -> PrevPGSearch(This) ) 

#define IDvdControl_TopPGSearch(This)	\
    ( (This)->lpVtbl -> TopPGSearch(This) ) 

#define IDvdControl_NextPGSearch(This)	\
    ( (This)->lpVtbl -> NextPGSearch(This) ) 

#define IDvdControl_ForwardScan(This,dwSpeed)	\
    ( (This)->lpVtbl -> ForwardScan(This,dwSpeed) ) 

#define IDvdControl_BackwardScan(This,dwSpeed)	\
    ( (This)->lpVtbl -> BackwardScan(This,dwSpeed) ) 

#define IDvdControl_MenuCall(This,MenuID)	\
    ( (This)->lpVtbl -> MenuCall(This,MenuID) ) 

#define IDvdControl_Resume(This)	\
    ( (This)->lpVtbl -> Resume(This) ) 

#define IDvdControl_UpperButtonSelect(This)	\
    ( (This)->lpVtbl -> UpperButtonSelect(This) ) 

#define IDvdControl_LowerButtonSelect(This)	\
    ( (This)->lpVtbl -> LowerButtonSelect(This) ) 

#define IDvdControl_LeftButtonSelect(This)	\
    ( (This)->lpVtbl -> LeftButtonSelect(This) ) 

#define IDvdControl_RightButtonSelect(This)	\
    ( (This)->lpVtbl -> RightButtonSelect(This) ) 

#define IDvdControl_ButtonActivate(This)	\
    ( (This)->lpVtbl -> ButtonActivate(This) ) 

#define IDvdControl_ButtonSelectAndActivate(This,uiButton)	\
    ( (This)->lpVtbl -> ButtonSelectAndActivate(This,uiButton) ) 

#define IDvdControl_StillOff(This)	\
    ( (This)->lpVtbl -> StillOff(This) ) 

#define IDvdControl_PauseOn(This)	\
    ( (This)->lpVtbl -> PauseOn(This) ) 

#define IDvdControl_PauseOff(This)	\
    ( (This)->lpVtbl -> PauseOff(This) ) 

#define IDvdControl_MenuLanguageSelect(This,Language)	\
    ( (This)->lpVtbl -> MenuLanguageSelect(This,Language) ) 

#define IDvdControl_AudioStreamChange(This,nAudio)	\
    ( (This)->lpVtbl -> AudioStreamChange(This,nAudio) ) 

#define IDvdControl_SubpictureStreamChange(This,nSubPicture,bDisplay)	\
    ( (This)->lpVtbl -> SubpictureStreamChange(This,nSubPicture,bDisplay) ) 

#define IDvdControl_AngleChange(This,ulAngle)	\
    ( (This)->lpVtbl -> AngleChange(This,ulAngle) ) 

#define IDvdControl_ParentalLevelSelect(This,ulParentalLevel)	\
    ( (This)->lpVtbl -> ParentalLevelSelect(This,ulParentalLevel) ) 

#define IDvdControl_ParentalCountrySelect(This,wCountry)	\
    ( (This)->lpVtbl -> ParentalCountrySelect(This,wCountry) ) 

#define IDvdControl_KaraokeAudioPresentationModeChange(This,ulMode)	\
    ( (This)->lpVtbl -> KaraokeAudioPresentationModeChange(This,ulMode) ) 

#define IDvdControl_VideoModePreferrence(This,ulPreferredDisplayMode)	\
    ( (This)->lpVtbl -> VideoModePreferrence(This,ulPreferredDisplayMode) ) 

#define IDvdControl_SetRoot(This,pszPath)	\
    ( (This)->lpVtbl -> SetRoot(This,pszPath) ) 

#define IDvdControl_MouseActivate(This,point)	\
    ( (This)->lpVtbl -> MouseActivate(This,point) ) 

#define IDvdControl_MouseSelect(This,point)	\
    ( (This)->lpVtbl -> MouseSelect(This,point) ) 

#define IDvdControl_ChapterPlayAutoStop(This,ulTitle,ulChapter,ulChaptersToPlay)	\
    ( (This)->lpVtbl -> ChapterPlayAutoStop(This,ulTitle,ulChapter,ulChaptersToPlay) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvdControl_INTERFACE_DEFINED__ */


#ifndef __IDvdInfo_INTERFACE_DEFINED__
#define __IDvdInfo_INTERFACE_DEFINED__

/* interface IDvdInfo */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDvdInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A70EFE60-E2A3-11d0-A9BE-00AA0061BE93")
    IDvdInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCurrentDomain( 
            /* [out] */ DVD_DOMAIN *pDomain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentLocation( 
            /* [out] */ DVD_PLAYBACK_LOCATION *pLocation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTotalTitleTime( 
            /* [out] */ ULONG *pTotalTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentButton( 
            /* [out] */ ULONG *pnButtonsAvailable,
            /* [out] */ ULONG *pnCurrentButton) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentAngle( 
            /* [out] */ ULONG *pnAnglesAvailable,
            /* [out] */ ULONG *pnCurrentAngle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentAudio( 
            /* [out] */ ULONG *pnStreamsAvailable,
            /* [out] */ ULONG *pnCurrentStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentSubpicture( 
            /* [out] */ ULONG *pnStreamsAvailable,
            /* [out] */ ULONG *pnCurrentStream,
            /* [out] */ BOOL *pIsDisabled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentUOPS( 
            /* [out] */ VALID_UOP_SOMTHING_OR_OTHER *pUOP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllSPRMs( 
            /* [out] */ SPRMARRAY *pRegisterArray) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllGPRMs( 
            /* [out] */ GPRMARRAY *pRegisterArray) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAudioLanguage( 
            /* [in] */ ULONG nStream,
            /* [out] */ LCID *pLanguage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSubpictureLanguage( 
            /* [in] */ ULONG nStream,
            /* [out] */ LCID *pLanguage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTitleAttributes( 
            /* [in] */ ULONG nTitle,
            /* [out] */ DVD_ATR *pATR) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVMGAttributes( 
            /* [out] */ DVD_ATR *pATR) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentVideoAttributes( 
            /* [out] */ DVD_VideoATR *pATR) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentAudioAttributes( 
            /* [out] */ DVD_AudioATR *pATR) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentSubpictureAttributes( 
            /* [out] */ DVD_SubpictureATR *pATR) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentVolumeInfo( 
            /* [out] */ ULONG *pNumOfVol,
            /* [out] */ ULONG *pThisVolNum,
            /* [out] */ DVD_DISC_SIDE *pSide,
            /* [out] */ ULONG *pNumOfTitles) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDVDTextInfo( 
            /* [size_is][out] */ BYTE *pTextManager,
            /* [in] */ ULONG cbBufSize,
            /* [out] */ ULONG *pcbActualSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPlayerParentalLevel( 
            /* [out] */ ULONG *pParentalLevel,
            /* [out] */ ULONG *pCountryCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNumberOfChapters( 
            /* [in] */ ULONG ulTitle,
            /* [out] */ ULONG *pNumberOfChapters) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTitleParentalLevels( 
            /* [in] */ ULONG ulTitle,
            /* [out] */ ULONG *pParentalLevels) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRoot( 
            /* [size_is][out] */ LPSTR pRoot,
            /* [in] */ ULONG cbBufSize,
            /* [out] */ ULONG *pcbActualSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvdInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvdInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvdInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvdInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentDomain )( 
            IDvdInfo * This,
            /* [out] */ DVD_DOMAIN *pDomain);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentLocation )( 
            IDvdInfo * This,
            /* [out] */ DVD_PLAYBACK_LOCATION *pLocation);
        
        HRESULT ( STDMETHODCALLTYPE *GetTotalTitleTime )( 
            IDvdInfo * This,
            /* [out] */ ULONG *pTotalTime);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentButton )( 
            IDvdInfo * This,
            /* [out] */ ULONG *pnButtonsAvailable,
            /* [out] */ ULONG *pnCurrentButton);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentAngle )( 
            IDvdInfo * This,
            /* [out] */ ULONG *pnAnglesAvailable,
            /* [out] */ ULONG *pnCurrentAngle);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentAudio )( 
            IDvdInfo * This,
            /* [out] */ ULONG *pnStreamsAvailable,
            /* [out] */ ULONG *pnCurrentStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentSubpicture )( 
            IDvdInfo * This,
            /* [out] */ ULONG *pnStreamsAvailable,
            /* [out] */ ULONG *pnCurrentStream,
            /* [out] */ BOOL *pIsDisabled);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentUOPS )( 
            IDvdInfo * This,
            /* [out] */ VALID_UOP_SOMTHING_OR_OTHER *pUOP);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllSPRMs )( 
            IDvdInfo * This,
            /* [out] */ SPRMARRAY *pRegisterArray);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllGPRMs )( 
            IDvdInfo * This,
            /* [out] */ GPRMARRAY *pRegisterArray);
        
        HRESULT ( STDMETHODCALLTYPE *GetAudioLanguage )( 
            IDvdInfo * This,
            /* [in] */ ULONG nStream,
            /* [out] */ LCID *pLanguage);
        
        HRESULT ( STDMETHODCALLTYPE *GetSubpictureLanguage )( 
            IDvdInfo * This,
            /* [in] */ ULONG nStream,
            /* [out] */ LCID *pLanguage);
        
        HRESULT ( STDMETHODCALLTYPE *GetTitleAttributes )( 
            IDvdInfo * This,
            /* [in] */ ULONG nTitle,
            /* [out] */ DVD_ATR *pATR);
        
        HRESULT ( STDMETHODCALLTYPE *GetVMGAttributes )( 
            IDvdInfo * This,
            /* [out] */ DVD_ATR *pATR);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentVideoAttributes )( 
            IDvdInfo * This,
            /* [out] */ DVD_VideoATR *pATR);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentAudioAttributes )( 
            IDvdInfo * This,
            /* [out] */ DVD_AudioATR *pATR);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentSubpictureAttributes )( 
            IDvdInfo * This,
            /* [out] */ DVD_SubpictureATR *pATR);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentVolumeInfo )( 
            IDvdInfo * This,
            /* [out] */ ULONG *pNumOfVol,
            /* [out] */ ULONG *pThisVolNum,
            /* [out] */ DVD_DISC_SIDE *pSide,
            /* [out] */ ULONG *pNumOfTitles);
        
        HRESULT ( STDMETHODCALLTYPE *GetDVDTextInfo )( 
            IDvdInfo * This,
            /* [size_is][out] */ BYTE *pTextManager,
            /* [in] */ ULONG cbBufSize,
            /* [out] */ ULONG *pcbActualSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetPlayerParentalLevel )( 
            IDvdInfo * This,
            /* [out] */ ULONG *pParentalLevel,
            /* [out] */ ULONG *pCountryCode);
        
        HRESULT ( STDMETHODCALLTYPE *GetNumberOfChapters )( 
            IDvdInfo * This,
            /* [in] */ ULONG ulTitle,
            /* [out] */ ULONG *pNumberOfChapters);
        
        HRESULT ( STDMETHODCALLTYPE *GetTitleParentalLevels )( 
            IDvdInfo * This,
            /* [in] */ ULONG ulTitle,
            /* [out] */ ULONG *pParentalLevels);
        
        HRESULT ( STDMETHODCALLTYPE *GetRoot )( 
            IDvdInfo * This,
            /* [size_is][out] */ LPSTR pRoot,
            /* [in] */ ULONG cbBufSize,
            /* [out] */ ULONG *pcbActualSize);
        
        END_INTERFACE
    } IDvdInfoVtbl;

    interface IDvdInfo
    {
        CONST_VTBL struct IDvdInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvdInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvdInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvdInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvdInfo_GetCurrentDomain(This,pDomain)	\
    ( (This)->lpVtbl -> GetCurrentDomain(This,pDomain) ) 

#define IDvdInfo_GetCurrentLocation(This,pLocation)	\
    ( (This)->lpVtbl -> GetCurrentLocation(This,pLocation) ) 

#define IDvdInfo_GetTotalTitleTime(This,pTotalTime)	\
    ( (This)->lpVtbl -> GetTotalTitleTime(This,pTotalTime) ) 

#define IDvdInfo_GetCurrentButton(This,pnButtonsAvailable,pnCurrentButton)	\
    ( (This)->lpVtbl -> GetCurrentButton(This,pnButtonsAvailable,pnCurrentButton) ) 

#define IDvdInfo_GetCurrentAngle(This,pnAnglesAvailable,pnCurrentAngle)	\
    ( (This)->lpVtbl -> GetCurrentAngle(This,pnAnglesAvailable,pnCurrentAngle) ) 

#define IDvdInfo_GetCurrentAudio(This,pnStreamsAvailable,pnCurrentStream)	\
    ( (This)->lpVtbl -> GetCurrentAudio(This,pnStreamsAvailable,pnCurrentStream) ) 

#define IDvdInfo_GetCurrentSubpicture(This,pnStreamsAvailable,pnCurrentStream,pIsDisabled)	\
    ( (This)->lpVtbl -> GetCurrentSubpicture(This,pnStreamsAvailable,pnCurrentStream,pIsDisabled) ) 

#define IDvdInfo_GetCurrentUOPS(This,pUOP)	\
    ( (This)->lpVtbl -> GetCurrentUOPS(This,pUOP) ) 

#define IDvdInfo_GetAllSPRMs(This,pRegisterArray)	\
    ( (This)->lpVtbl -> GetAllSPRMs(This,pRegisterArray) ) 

#define IDvdInfo_GetAllGPRMs(This,pRegisterArray)	\
    ( (This)->lpVtbl -> GetAllGPRMs(This,pRegisterArray) ) 

#define IDvdInfo_GetAudioLanguage(This,nStream,pLanguage)	\
    ( (This)->lpVtbl -> GetAudioLanguage(This,nStream,pLanguage) ) 

#define IDvdInfo_GetSubpictureLanguage(This,nStream,pLanguage)	\
    ( (This)->lpVtbl -> GetSubpictureLanguage(This,nStream,pLanguage) ) 

#define IDvdInfo_GetTitleAttributes(This,nTitle,pATR)	\
    ( (This)->lpVtbl -> GetTitleAttributes(This,nTitle,pATR) ) 

#define IDvdInfo_GetVMGAttributes(This,pATR)	\
    ( (This)->lpVtbl -> GetVMGAttributes(This,pATR) ) 

#define IDvdInfo_GetCurrentVideoAttributes(This,pATR)	\
    ( (This)->lpVtbl -> GetCurrentVideoAttributes(This,pATR) ) 

#define IDvdInfo_GetCurrentAudioAttributes(This,pATR)	\
    ( (This)->lpVtbl -> GetCurrentAudioAttributes(This,pATR) ) 

#define IDvdInfo_GetCurrentSubpictureAttributes(This,pATR)	\
    ( (This)->lpVtbl -> GetCurrentSubpictureAttributes(This,pATR) ) 

#define IDvdInfo_GetCurrentVolumeInfo(This,pNumOfVol,pThisVolNum,pSide,pNumOfTitles)	\
    ( (This)->lpVtbl -> GetCurrentVolumeInfo(This,pNumOfVol,pThisVolNum,pSide,pNumOfTitles) ) 

#define IDvdInfo_GetDVDTextInfo(This,pTextManager,cbBufSize,pcbActualSize)	\
    ( (This)->lpVtbl -> GetDVDTextInfo(This,pTextManager,cbBufSize,pcbActualSize) ) 

#define IDvdInfo_GetPlayerParentalLevel(This,pParentalLevel,pCountryCode)	\
    ( (This)->lpVtbl -> GetPlayerParentalLevel(This,pParentalLevel,pCountryCode) ) 

#define IDvdInfo_GetNumberOfChapters(This,ulTitle,pNumberOfChapters)	\
    ( (This)->lpVtbl -> GetNumberOfChapters(This,ulTitle,pNumberOfChapters) ) 

#define IDvdInfo_GetTitleParentalLevels(This,ulTitle,pParentalLevels)	\
    ( (This)->lpVtbl -> GetTitleParentalLevels(This,ulTitle,pParentalLevels) ) 

#define IDvdInfo_GetRoot(This,pRoot,cbBufSize,pcbActualSize)	\
    ( (This)->lpVtbl -> GetRoot(This,pRoot,cbBufSize,pcbActualSize) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvdInfo_INTERFACE_DEFINED__ */


#ifndef __IDvdCmd_INTERFACE_DEFINED__
#define __IDvdCmd_INTERFACE_DEFINED__

/* interface IDvdCmd */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDvdCmd;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5a4a97e4-94ee-4a55-9751-74b5643aa27d")
    IDvdCmd : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE WaitForStart( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WaitForEnd( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvdCmdVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvdCmd * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvdCmd * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvdCmd * This);
        
        HRESULT ( STDMETHODCALLTYPE *WaitForStart )( 
            IDvdCmd * This);
        
        HRESULT ( STDMETHODCALLTYPE *WaitForEnd )( 
            IDvdCmd * This);
        
        END_INTERFACE
    } IDvdCmdVtbl;

    interface IDvdCmd
    {
        CONST_VTBL struct IDvdCmdVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvdCmd_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvdCmd_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvdCmd_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvdCmd_WaitForStart(This)	\
    ( (This)->lpVtbl -> WaitForStart(This) ) 

#define IDvdCmd_WaitForEnd(This)	\
    ( (This)->lpVtbl -> WaitForEnd(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvdCmd_INTERFACE_DEFINED__ */


#ifndef __IDvdState_INTERFACE_DEFINED__
#define __IDvdState_INTERFACE_DEFINED__

/* interface IDvdState */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDvdState;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("86303d6d-1c4a-4087-ab42-f711167048ef")
    IDvdState : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDiscID( 
            /* [out] */ ULONGLONG *pullUniqueID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParentalLevel( 
            /* [out] */ ULONG *pulParentalLevel) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvdStateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvdState * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvdState * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvdState * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDiscID )( 
            IDvdState * This,
            /* [out] */ ULONGLONG *pullUniqueID);
        
        HRESULT ( STDMETHODCALLTYPE *GetParentalLevel )( 
            IDvdState * This,
            /* [out] */ ULONG *pulParentalLevel);
        
        END_INTERFACE
    } IDvdStateVtbl;

    interface IDvdState
    {
        CONST_VTBL struct IDvdStateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvdState_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvdState_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvdState_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvdState_GetDiscID(This,pullUniqueID)	\
    ( (This)->lpVtbl -> GetDiscID(This,pullUniqueID) ) 

#define IDvdState_GetParentalLevel(This,pulParentalLevel)	\
    ( (This)->lpVtbl -> GetParentalLevel(This,pulParentalLevel) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvdState_INTERFACE_DEFINED__ */


#ifndef __IDvdControl2_INTERFACE_DEFINED__
#define __IDvdControl2_INTERFACE_DEFINED__

/* interface IDvdControl2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDvdControl2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("33BC7430-EEC0-11D2-8201-00A0C9D74842")
    IDvdControl2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PlayTitle( 
            /* [in] */ ULONG ulTitle,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PlayChapterInTitle( 
            /* [in] */ ULONG ulTitle,
            /* [in] */ ULONG ulChapter,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PlayAtTimeInTitle( 
            /* [in] */ ULONG ulTitle,
            /* [in] */ DVD_HMSF_TIMECODE *pStartTime,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReturnFromSubmenu( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PlayAtTime( 
            /* [in] */ DVD_HMSF_TIMECODE *pTime,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PlayChapter( 
            /* [in] */ ULONG ulChapter,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PlayPrevChapter( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReplayChapter( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PlayNextChapter( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PlayForwards( 
            /* [in] */ double dSpeed,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PlayBackwards( 
            /* [in] */ double dSpeed,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShowMenu( 
            /* [in] */ DVD_MENU_ID MenuID,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectRelativeButton( 
            DVD_RELATIVE_BUTTON buttonDir) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ActivateButton( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectButton( 
            /* [in] */ ULONG ulButton) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectAndActivateButton( 
            /* [in] */ ULONG ulButton) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StillOff( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( 
            /* [in] */ BOOL bState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectAudioStream( 
            /* [in] */ ULONG ulAudio,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectSubpictureStream( 
            /* [in] */ ULONG ulSubPicture,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSubpictureState( 
            /* [in] */ BOOL bState,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectAngle( 
            /* [in] */ ULONG ulAngle,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectParentalLevel( 
            /* [in] */ ULONG ulParentalLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectParentalCountry( 
            /* [in] */ BYTE bCountry[ 2 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectKaraokeAudioPresentationMode( 
            /* [in] */ ULONG ulMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectVideoModePreference( 
            /* [in] */ ULONG ulPreferredDisplayMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDVDDirectory( 
            /* [in] */ LPCWSTR pszwPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ActivateAtPosition( 
            /* [in] */ POINT point) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectAtPosition( 
            /* [in] */ POINT point) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PlayChaptersAutoStop( 
            /* [in] */ ULONG ulTitle,
            /* [in] */ ULONG ulChapter,
            /* [in] */ ULONG ulChaptersToPlay,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AcceptParentalLevelChange( 
            /* [in] */ BOOL bAccept) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOption( 
            /* [in] */ DVD_OPTION_FLAG flag,
            /* [in] */ BOOL fState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetState( 
            /* [in] */ IDvdState *pState,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PlayPeriodInTitleAutoStop( 
            /* [in] */ ULONG ulTitle,
            /* [in] */ DVD_HMSF_TIMECODE *pStartTime,
            /* [in] */ DVD_HMSF_TIMECODE *pEndTime,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetGPRM( 
            /* [in] */ ULONG ulIndex,
            /* [in] */ WORD wValue,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectDefaultMenuLanguage( 
            /* [in] */ LCID Language) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectDefaultAudioLanguage( 
            /* [in] */ LCID Language,
            /* [in] */ DVD_AUDIO_LANG_EXT audioExtension) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectDefaultSubpictureLanguage( 
            /* [in] */ LCID Language,
            /* [in] */ DVD_SUBPICTURE_LANG_EXT subpictureExtension) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvdControl2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvdControl2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvdControl2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvdControl2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *PlayTitle )( 
            IDvdControl2 * This,
            /* [in] */ ULONG ulTitle,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *PlayChapterInTitle )( 
            IDvdControl2 * This,
            /* [in] */ ULONG ulTitle,
            /* [in] */ ULONG ulChapter,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *PlayAtTimeInTitle )( 
            IDvdControl2 * This,
            /* [in] */ ULONG ulTitle,
            /* [in] */ DVD_HMSF_TIMECODE *pStartTime,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IDvdControl2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ReturnFromSubmenu )( 
            IDvdControl2 * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *PlayAtTime )( 
            IDvdControl2 * This,
            /* [in] */ DVD_HMSF_TIMECODE *pTime,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *PlayChapter )( 
            IDvdControl2 * This,
            /* [in] */ ULONG ulChapter,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *PlayPrevChapter )( 
            IDvdControl2 * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *ReplayChapter )( 
            IDvdControl2 * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *PlayNextChapter )( 
            IDvdControl2 * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *PlayForwards )( 
            IDvdControl2 * This,
            /* [in] */ double dSpeed,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *PlayBackwards )( 
            IDvdControl2 * This,
            /* [in] */ double dSpeed,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *ShowMenu )( 
            IDvdControl2 * This,
            /* [in] */ DVD_MENU_ID MenuID,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IDvdControl2 * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *SelectRelativeButton )( 
            IDvdControl2 * This,
            DVD_RELATIVE_BUTTON buttonDir);
        
        HRESULT ( STDMETHODCALLTYPE *ActivateButton )( 
            IDvdControl2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SelectButton )( 
            IDvdControl2 * This,
            /* [in] */ ULONG ulButton);
        
        HRESULT ( STDMETHODCALLTYPE *SelectAndActivateButton )( 
            IDvdControl2 * This,
            /* [in] */ ULONG ulButton);
        
        HRESULT ( STDMETHODCALLTYPE *StillOff )( 
            IDvdControl2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IDvdControl2 * This,
            /* [in] */ BOOL bState);
        
        HRESULT ( STDMETHODCALLTYPE *SelectAudioStream )( 
            IDvdControl2 * This,
            /* [in] */ ULONG ulAudio,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *SelectSubpictureStream )( 
            IDvdControl2 * This,
            /* [in] */ ULONG ulSubPicture,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *SetSubpictureState )( 
            IDvdControl2 * This,
            /* [in] */ BOOL bState,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *SelectAngle )( 
            IDvdControl2 * This,
            /* [in] */ ULONG ulAngle,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *SelectParentalLevel )( 
            IDvdControl2 * This,
            /* [in] */ ULONG ulParentalLevel);
        
        HRESULT ( STDMETHODCALLTYPE *SelectParentalCountry )( 
            IDvdControl2 * This,
            /* [in] */ BYTE bCountry[ 2 ]);
        
        HRESULT ( STDMETHODCALLTYPE *SelectKaraokeAudioPresentationMode )( 
            IDvdControl2 * This,
            /* [in] */ ULONG ulMode);
        
        HRESULT ( STDMETHODCALLTYPE *SelectVideoModePreference )( 
            IDvdControl2 * This,
            /* [in] */ ULONG ulPreferredDisplayMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetDVDDirectory )( 
            IDvdControl2 * This,
            /* [in] */ LPCWSTR pszwPath);
        
        HRESULT ( STDMETHODCALLTYPE *ActivateAtPosition )( 
            IDvdControl2 * This,
            /* [in] */ POINT point);
        
        HRESULT ( STDMETHODCALLTYPE *SelectAtPosition )( 
            IDvdControl2 * This,
            /* [in] */ POINT point);
        
        HRESULT ( STDMETHODCALLTYPE *PlayChaptersAutoStop )( 
            IDvdControl2 * This,
            /* [in] */ ULONG ulTitle,
            /* [in] */ ULONG ulChapter,
            /* [in] */ ULONG ulChaptersToPlay,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *AcceptParentalLevelChange )( 
            IDvdControl2 * This,
            /* [in] */ BOOL bAccept);
        
        HRESULT ( STDMETHODCALLTYPE *SetOption )( 
            IDvdControl2 * This,
            /* [in] */ DVD_OPTION_FLAG flag,
            /* [in] */ BOOL fState);
        
        HRESULT ( STDMETHODCALLTYPE *SetState )( 
            IDvdControl2 * This,
            /* [in] */ IDvdState *pState,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *PlayPeriodInTitleAutoStop )( 
            IDvdControl2 * This,
            /* [in] */ ULONG ulTitle,
            /* [in] */ DVD_HMSF_TIMECODE *pStartTime,
            /* [in] */ DVD_HMSF_TIMECODE *pEndTime,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *SetGPRM )( 
            IDvdControl2 * This,
            /* [in] */ ULONG ulIndex,
            /* [in] */ WORD wValue,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *SelectDefaultMenuLanguage )( 
            IDvdControl2 * This,
            /* [in] */ LCID Language);
        
        HRESULT ( STDMETHODCALLTYPE *SelectDefaultAudioLanguage )( 
            IDvdControl2 * This,
            /* [in] */ LCID Language,
            /* [in] */ DVD_AUDIO_LANG_EXT audioExtension);
        
        HRESULT ( STDMETHODCALLTYPE *SelectDefaultSubpictureLanguage )( 
            IDvdControl2 * This,
            /* [in] */ LCID Language,
            /* [in] */ DVD_SUBPICTURE_LANG_EXT subpictureExtension);
        
        END_INTERFACE
    } IDvdControl2Vtbl;

    interface IDvdControl2
    {
        CONST_VTBL struct IDvdControl2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvdControl2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvdControl2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvdControl2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvdControl2_PlayTitle(This,ulTitle,dwFlags,ppCmd)	\
    ( (This)->lpVtbl -> PlayTitle(This,ulTitle,dwFlags,ppCmd) ) 

#define IDvdControl2_PlayChapterInTitle(This,ulTitle,ulChapter,dwFlags,ppCmd)	\
    ( (This)->lpVtbl -> PlayChapterInTitle(This,ulTitle,ulChapter,dwFlags,ppCmd) ) 

#define IDvdControl2_PlayAtTimeInTitle(This,ulTitle,pStartTime,dwFlags,ppCmd)	\
    ( (This)->lpVtbl -> PlayAtTimeInTitle(This,ulTitle,pStartTime,dwFlags,ppCmd) ) 

#define IDvdControl2_Stop(This)	\
    ( (This)->lpVtbl -> Stop(This) ) 

#define IDvdControl2_ReturnFromSubmenu(This,dwFlags,ppCmd)	\
    ( (This)->lpVtbl -> ReturnFromSubmenu(This,dwFlags,ppCmd) ) 

#define IDvdControl2_PlayAtTime(This,pTime,dwFlags,ppCmd)	\
    ( (This)->lpVtbl -> PlayAtTime(This,pTime,dwFlags,ppCmd) ) 

#define IDvdControl2_PlayChapter(This,ulChapter,dwFlags,ppCmd)	\
    ( (This)->lpVtbl -> PlayChapter(This,ulChapter,dwFlags,ppCmd) ) 

#define IDvdControl2_PlayPrevChapter(This,dwFlags,ppCmd)	\
    ( (This)->lpVtbl -> PlayPrevChapter(This,dwFlags,ppCmd) ) 

#define IDvdControl2_ReplayChapter(This,dwFlags,ppCmd)	\
    ( (This)->lpVtbl -> ReplayChapter(This,dwFlags,ppCmd) ) 

#define IDvdControl2_PlayNextChapter(This,dwFlags,ppCmd)	\
    ( (This)->lpVtbl -> PlayNextChapter(This,dwFlags,ppCmd) ) 

#define IDvdControl2_PlayForwards(This,dSpeed,dwFlags,ppCmd)	\
    ( (This)->lpVtbl -> PlayForwards(This,dSpeed,dwFlags,ppCmd) ) 

#define IDvdControl2_PlayBackwards(This,dSpeed,dwFlags,ppCmd)	\
    ( (This)->lpVtbl -> PlayBackwards(This,dSpeed,dwFlags,ppCmd) ) 

#define IDvdControl2_ShowMenu(This,MenuID,dwFlags,ppCmd)	\
    ( (This)->lpVtbl -> ShowMenu(This,MenuID,dwFlags,ppCmd) ) 

#define IDvdControl2_Resume(This,dwFlags,ppCmd)	\
    ( (This)->lpVtbl -> Resume(This,dwFlags,ppCmd) ) 

#define IDvdControl2_SelectRelativeButton(This,buttonDir)	\
    ( (This)->lpVtbl -> SelectRelativeButton(This,buttonDir) ) 

#define IDvdControl2_ActivateButton(This)	\
    ( (This)->lpVtbl -> ActivateButton(This) ) 

#define IDvdControl2_SelectButton(This,ulButton)	\
    ( (This)->lpVtbl -> SelectButton(This,ulButton) ) 

#define IDvdControl2_SelectAndActivateButton(This,ulButton)	\
    ( (This)->lpVtbl -> SelectAndActivateButton(This,ulButton) ) 

#define IDvdControl2_StillOff(This)	\
    ( (This)->lpVtbl -> StillOff(This) ) 

#define IDvdControl2_Pause(This,bState)	\
    ( (This)->lpVtbl -> Pause(This,bState) ) 

#define IDvdControl2_SelectAudioStream(This,ulAudio,dwFlags,ppCmd)	\
    ( (This)->lpVtbl -> SelectAudioStream(This,ulAudio,dwFlags,ppCmd) ) 

#define IDvdControl2_SelectSubpictureStream(This,ulSubPicture,dwFlags,ppCmd)	\
    ( (This)->lpVtbl -> SelectSubpictureStream(This,ulSubPicture,dwFlags,ppCmd) ) 

#define IDvdControl2_SetSubpictureState(This,bState,dwFlags,ppCmd)	\
    ( (This)->lpVtbl -> SetSubpictureState(This,bState,dwFlags,ppCmd) ) 

#define IDvdControl2_SelectAngle(This,ulAngle,dwFlags,ppCmd)	\
    ( (This)->lpVtbl -> SelectAngle(This,ulAngle,dwFlags,ppCmd) ) 

#define IDvdControl2_SelectParentalLevel(This,ulParentalLevel)	\
    ( (This)->lpVtbl -> SelectParentalLevel(This,ulParentalLevel) ) 

#define IDvdControl2_SelectParentalCountry(This,bCountry)	\
    ( (This)->lpVtbl -> SelectParentalCountry(This,bCountry) ) 

#define IDvdControl2_SelectKaraokeAudioPresentationMode(This,ulMode)	\
    ( (This)->lpVtbl -> SelectKaraokeAudioPresentationMode(This,ulMode) ) 

#define IDvdControl2_SelectVideoModePreference(This,ulPreferredDisplayMode)	\
    ( (This)->lpVtbl -> SelectVideoModePreference(This,ulPreferredDisplayMode) ) 

#define IDvdControl2_SetDVDDirectory(This,pszwPath)	\
    ( (This)->lpVtbl -> SetDVDDirectory(This,pszwPath) ) 

#define IDvdControl2_ActivateAtPosition(This,point)	\
    ( (This)->lpVtbl -> ActivateAtPosition(This,point) ) 

#define IDvdControl2_SelectAtPosition(This,point)	\
    ( (This)->lpVtbl -> SelectAtPosition(This,point) ) 

#define IDvdControl2_PlayChaptersAutoStop(This,ulTitle,ulChapter,ulChaptersToPlay,dwFlags,ppCmd)	\
    ( (This)->lpVtbl -> PlayChaptersAutoStop(This,ulTitle,ulChapter,ulChaptersToPlay,dwFlags,ppCmd) ) 

#define IDvdControl2_AcceptParentalLevelChange(This,bAccept)	\
    ( (This)->lpVtbl -> AcceptParentalLevelChange(This,bAccept) ) 

#define IDvdControl2_SetOption(This,flag,fState)	\
    ( (This)->lpVtbl -> SetOption(This,flag,fState) ) 

#define IDvdControl2_SetState(This,pState,dwFlags,ppCmd)	\
    ( (This)->lpVtbl -> SetState(This,pState,dwFlags,ppCmd) ) 

#define IDvdControl2_PlayPeriodInTitleAutoStop(This,ulTitle,pStartTime,pEndTime,dwFlags,ppCmd)	\
    ( (This)->lpVtbl -> PlayPeriodInTitleAutoStop(This,ulTitle,pStartTime,pEndTime,dwFlags,ppCmd) ) 

#define IDvdControl2_SetGPRM(This,ulIndex,wValue,dwFlags,ppCmd)	\
    ( (This)->lpVtbl -> SetGPRM(This,ulIndex,wValue,dwFlags,ppCmd) ) 

#define IDvdControl2_SelectDefaultMenuLanguage(This,Language)	\
    ( (This)->lpVtbl -> SelectDefaultMenuLanguage(This,Language) ) 

#define IDvdControl2_SelectDefaultAudioLanguage(This,Language,audioExtension)	\
    ( (This)->lpVtbl -> SelectDefaultAudioLanguage(This,Language,audioExtension) ) 

#define IDvdControl2_SelectDefaultSubpictureLanguage(This,Language,subpictureExtension)	\
    ( (This)->lpVtbl -> SelectDefaultSubpictureLanguage(This,Language,subpictureExtension) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvdControl2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0094 */
/* [local] */ 


enum DVD_TextStringType
    {	DVD_Struct_Volume	= 0x1,
	DVD_Struct_Title	= 0x2,
	DVD_Struct_ParentalID	= 0x3,
	DVD_Struct_PartOfTitle	= 0x4,
	DVD_Struct_Cell	= 0x5,
	DVD_Stream_Audio	= 0x10,
	DVD_Stream_Subpicture	= 0x11,
	DVD_Stream_Angle	= 0x12,
	DVD_Channel_Audio	= 0x20,
	DVD_General_Name	= 0x30,
	DVD_General_Comments	= 0x31,
	DVD_Title_Series	= 0x38,
	DVD_Title_Movie	= 0x39,
	DVD_Title_Video	= 0x3a,
	DVD_Title_Album	= 0x3b,
	DVD_Title_Song	= 0x3c,
	DVD_Title_Other	= 0x3f,
	DVD_Title_Sub_Series	= 0x40,
	DVD_Title_Sub_Movie	= 0x41,
	DVD_Title_Sub_Video	= 0x42,
	DVD_Title_Sub_Album	= 0x43,
	DVD_Title_Sub_Song	= 0x44,
	DVD_Title_Sub_Other	= 0x47,
	DVD_Title_Orig_Series	= 0x48,
	DVD_Title_Orig_Movie	= 0x49,
	DVD_Title_Orig_Video	= 0x4a,
	DVD_Title_Orig_Album	= 0x4b,
	DVD_Title_Orig_Song	= 0x4c,
	DVD_Title_Orig_Other	= 0x4f,
	DVD_Other_Scene	= 0x50,
	DVD_Other_Cut	= 0x51,
	DVD_Other_Take	= 0x52
    } ;

enum DVD_TextCharSet
    {	DVD_CharSet_Unicode	= 0,
	DVD_CharSet_ISO646	= 1,
	DVD_CharSet_JIS_Roman_Kanji	= 2,
	DVD_CharSet_ISO8859_1	= 3,
	DVD_CharSet_ShiftJIS_Kanji_Roman_Katakana	= 4
    } ;
#define DVD_TITLE_MENU				0x000
#define DVD_STREAM_DATA_CURRENT     0x800
#define DVD_STREAM_DATA_VMGM        0x400
#define DVD_STREAM_DATA_VTSM        0x401
#define DVD_DEFAULT_AUDIO_STREAM	0x0f
typedef struct tagDVD_DECODER_CAPS
    {
    DWORD dwSize;
    DWORD dwAudioCaps;
    double dFwdMaxRateVideo;
    double dFwdMaxRateAudio;
    double dFwdMaxRateSP;
    double dBwdMaxRateVideo;
    double dBwdMaxRateAudio;
    double dBwdMaxRateSP;
    DWORD dwRes1;
    DWORD dwRes2;
    DWORD dwRes3;
    DWORD dwRes4;
    } 	DVD_DECODER_CAPS;

#define DVD_AUDIO_CAPS_AC3		0x00000001
#define DVD_AUDIO_CAPS_MPEG2	0x00000002
#define DVD_AUDIO_CAPS_LPCM		0x00000004
#define DVD_AUDIO_CAPS_DTS		0x00000008
#define DVD_AUDIO_CAPS_SDDS		0x00000010


extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0094_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0094_v0_0_s_ifspec;

#ifndef __IDvdInfo2_INTERFACE_DEFINED__
#define __IDvdInfo2_INTERFACE_DEFINED__

/* interface IDvdInfo2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDvdInfo2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("34151510-EEC0-11D2-8201-00A0C9D74842")
    IDvdInfo2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCurrentDomain( 
            /* [out] */ DVD_DOMAIN *pDomain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentLocation( 
            /* [out] */ DVD_PLAYBACK_LOCATION2 *pLocation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTotalTitleTime( 
            /* [out] */ DVD_HMSF_TIMECODE *pTotalTime,
            /* [out] */ ULONG *ulTimeCodeFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentButton( 
            /* [out] */ ULONG *pulButtonsAvailable,
            /* [out] */ ULONG *pulCurrentButton) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentAngle( 
            /* [out] */ ULONG *pulAnglesAvailable,
            /* [out] */ ULONG *pulCurrentAngle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentAudio( 
            /* [out] */ ULONG *pulStreamsAvailable,
            /* [out] */ ULONG *pulCurrentStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentSubpicture( 
            /* [out] */ ULONG *pulStreamsAvailable,
            /* [out] */ ULONG *pulCurrentStream,
            /* [out] */ BOOL *pbIsDisabled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentUOPS( 
            /* [out] */ ULONG *pulUOPs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllSPRMs( 
            /* [out] */ SPRMARRAY *pRegisterArray) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllGPRMs( 
            /* [out] */ GPRMARRAY *pRegisterArray) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAudioLanguage( 
            /* [in] */ ULONG ulStream,
            /* [out] */ LCID *pLanguage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSubpictureLanguage( 
            /* [in] */ ULONG ulStream,
            /* [out] */ LCID *pLanguage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTitleAttributes( 
            /* [in] */ ULONG ulTitle,
            /* [out] */ DVD_MenuAttributes *pMenu,
            /* [out] */ DVD_TitleAttributes *pTitle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVMGAttributes( 
            /* [out] */ DVD_MenuAttributes *pATR) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentVideoAttributes( 
            /* [out] */ DVD_VideoAttributes *pATR) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAudioAttributes( 
            /* [in] */ ULONG ulStream,
            /* [out] */ DVD_AudioAttributes *pATR) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetKaraokeAttributes( 
            /* [in] */ ULONG ulStream,
            /* [out] */ DVD_KaraokeAttributes *pAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSubpictureAttributes( 
            /* [in] */ ULONG ulStream,
            /* [out] */ DVD_SubpictureAttributes *pATR) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDVDVolumeInfo( 
            /* [out] */ ULONG *pulNumOfVolumes,
            /* [out] */ ULONG *pulVolume,
            /* [out] */ DVD_DISC_SIDE *pSide,
            /* [out] */ ULONG *pulNumOfTitles) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDVDTextNumberOfLanguages( 
            /* [out] */ ULONG *pulNumOfLangs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDVDTextLanguageInfo( 
            /* [in] */ ULONG ulLangIndex,
            /* [out] */ ULONG *pulNumOfStrings,
            /* [out] */ LCID *pLangCode,
            /* [out] */ enum DVD_TextCharSet *pbCharacterSet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDVDTextStringAsNative( 
            /* [in] */ ULONG ulLangIndex,
            /* [in] */ ULONG ulStringIndex,
            /* [out] */ BYTE *pbBuffer,
            /* [in] */ ULONG ulMaxBufferSize,
            /* [out] */ ULONG *pulActualSize,
            /* [out] */ enum DVD_TextStringType *pType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDVDTextStringAsUnicode( 
            /* [in] */ ULONG ulLangIndex,
            /* [in] */ ULONG ulStringIndex,
            /* [out] */ WCHAR *pchwBuffer,
            /* [in] */ ULONG ulMaxBufferSize,
            /* [out] */ ULONG *pulActualSize,
            /* [out] */ enum DVD_TextStringType *pType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPlayerParentalLevel( 
            /* [out] */ ULONG *pulParentalLevel,
            /* [out] */ BYTE pbCountryCode[ 2 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNumberOfChapters( 
            /* [in] */ ULONG ulTitle,
            /* [out] */ ULONG *pulNumOfChapters) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTitleParentalLevels( 
            /* [in] */ ULONG ulTitle,
            /* [out] */ ULONG *pulParentalLevels) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDVDDirectory( 
            /* [size_is][out] */ LPWSTR pszwPath,
            /* [in] */ ULONG ulMaxSize,
            /* [out] */ ULONG *pulActualSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsAudioStreamEnabled( 
            /* [in] */ ULONG ulStreamNum,
            /* [out] */ BOOL *pbEnabled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDiscID( 
            /* [in] */ LPCWSTR pszwPath,
            /* [out] */ ULONGLONG *pullDiscID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetState( 
            /* [out] */ IDvdState **pStateData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMenuLanguages( 
            /* [out] */ LCID *pLanguages,
            /* [in] */ ULONG ulMaxLanguages,
            /* [out] */ ULONG *pulActualLanguages) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetButtonAtPosition( 
            /* [in] */ POINT point,
            /* [out] */ ULONG *pulButtonIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCmdFromEvent( 
            /* [in] */ LONG_PTR lParam1,
            /* [out] */ IDvdCmd **pCmdObj) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultMenuLanguage( 
            /* [out] */ LCID *pLanguage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultAudioLanguage( 
            /* [out] */ LCID *pLanguage,
            /* [out] */ DVD_AUDIO_LANG_EXT *pAudioExtension) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultSubpictureLanguage( 
            /* [out] */ LCID *pLanguage,
            /* [out] */ DVD_SUBPICTURE_LANG_EXT *pSubpictureExtension) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDecoderCaps( 
            /* [out] */ DVD_DECODER_CAPS *pCaps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetButtonRect( 
            /* [in] */ ULONG ulButton,
            /* [out] */ RECT *pRect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsSubpictureStreamEnabled( 
            /* [in] */ ULONG ulStreamNum,
            /* [out] */ BOOL *pbEnabled) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvdInfo2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvdInfo2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvdInfo2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvdInfo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentDomain )( 
            IDvdInfo2 * This,
            /* [out] */ DVD_DOMAIN *pDomain);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentLocation )( 
            IDvdInfo2 * This,
            /* [out] */ DVD_PLAYBACK_LOCATION2 *pLocation);
        
        HRESULT ( STDMETHODCALLTYPE *GetTotalTitleTime )( 
            IDvdInfo2 * This,
            /* [out] */ DVD_HMSF_TIMECODE *pTotalTime,
            /* [out] */ ULONG *ulTimeCodeFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentButton )( 
            IDvdInfo2 * This,
            /* [out] */ ULONG *pulButtonsAvailable,
            /* [out] */ ULONG *pulCurrentButton);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentAngle )( 
            IDvdInfo2 * This,
            /* [out] */ ULONG *pulAnglesAvailable,
            /* [out] */ ULONG *pulCurrentAngle);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentAudio )( 
            IDvdInfo2 * This,
            /* [out] */ ULONG *pulStreamsAvailable,
            /* [out] */ ULONG *pulCurrentStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentSubpicture )( 
            IDvdInfo2 * This,
            /* [out] */ ULONG *pulStreamsAvailable,
            /* [out] */ ULONG *pulCurrentStream,
            /* [out] */ BOOL *pbIsDisabled);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentUOPS )( 
            IDvdInfo2 * This,
            /* [out] */ ULONG *pulUOPs);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllSPRMs )( 
            IDvdInfo2 * This,
            /* [out] */ SPRMARRAY *pRegisterArray);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllGPRMs )( 
            IDvdInfo2 * This,
            /* [out] */ GPRMARRAY *pRegisterArray);
        
        HRESULT ( STDMETHODCALLTYPE *GetAudioLanguage )( 
            IDvdInfo2 * This,
            /* [in] */ ULONG ulStream,
            /* [out] */ LCID *pLanguage);
        
        HRESULT ( STDMETHODCALLTYPE *GetSubpictureLanguage )( 
            IDvdInfo2 * This,
            /* [in] */ ULONG ulStream,
            /* [out] */ LCID *pLanguage);
        
        HRESULT ( STDMETHODCALLTYPE *GetTitleAttributes )( 
            IDvdInfo2 * This,
            /* [in] */ ULONG ulTitle,
            /* [out] */ DVD_MenuAttributes *pMenu,
            /* [out] */ DVD_TitleAttributes *pTitle);
        
        HRESULT ( STDMETHODCALLTYPE *GetVMGAttributes )( 
            IDvdInfo2 * This,
            /* [out] */ DVD_MenuAttributes *pATR);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentVideoAttributes )( 
            IDvdInfo2 * This,
            /* [out] */ DVD_VideoAttributes *pATR);
        
        HRESULT ( STDMETHODCALLTYPE *GetAudioAttributes )( 
            IDvdInfo2 * This,
            /* [in] */ ULONG ulStream,
            /* [out] */ DVD_AudioAttributes *pATR);
        
        HRESULT ( STDMETHODCALLTYPE *GetKaraokeAttributes )( 
            IDvdInfo2 * This,
            /* [in] */ ULONG ulStream,
            /* [out] */ DVD_KaraokeAttributes *pAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *GetSubpictureAttributes )( 
            IDvdInfo2 * This,
            /* [in] */ ULONG ulStream,
            /* [out] */ DVD_SubpictureAttributes *pATR);
        
        HRESULT ( STDMETHODCALLTYPE *GetDVDVolumeInfo )( 
            IDvdInfo2 * This,
            /* [out] */ ULONG *pulNumOfVolumes,
            /* [out] */ ULONG *pulVolume,
            /* [out] */ DVD_DISC_SIDE *pSide,
            /* [out] */ ULONG *pulNumOfTitles);
        
        HRESULT ( STDMETHODCALLTYPE *GetDVDTextNumberOfLanguages )( 
            IDvdInfo2 * This,
            /* [out] */ ULONG *pulNumOfLangs);
        
        HRESULT ( STDMETHODCALLTYPE *GetDVDTextLanguageInfo )( 
            IDvdInfo2 * This,
            /* [in] */ ULONG ulLangIndex,
            /* [out] */ ULONG *pulNumOfStrings,
            /* [out] */ LCID *pLangCode,
            /* [out] */ enum DVD_TextCharSet *pbCharacterSet);
        
        HRESULT ( STDMETHODCALLTYPE *GetDVDTextStringAsNative )( 
            IDvdInfo2 * This,
            /* [in] */ ULONG ulLangIndex,
            /* [in] */ ULONG ulStringIndex,
            /* [out] */ BYTE *pbBuffer,
            /* [in] */ ULONG ulMaxBufferSize,
            /* [out] */ ULONG *pulActualSize,
            /* [out] */ enum DVD_TextStringType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetDVDTextStringAsUnicode )( 
            IDvdInfo2 * This,
            /* [in] */ ULONG ulLangIndex,
            /* [in] */ ULONG ulStringIndex,
            /* [out] */ WCHAR *pchwBuffer,
            /* [in] */ ULONG ulMaxBufferSize,
            /* [out] */ ULONG *pulActualSize,
            /* [out] */ enum DVD_TextStringType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetPlayerParentalLevel )( 
            IDvdInfo2 * This,
            /* [out] */ ULONG *pulParentalLevel,
            /* [out] */ BYTE pbCountryCode[ 2 ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetNumberOfChapters )( 
            IDvdInfo2 * This,
            /* [in] */ ULONG ulTitle,
            /* [out] */ ULONG *pulNumOfChapters);
        
        HRESULT ( STDMETHODCALLTYPE *GetTitleParentalLevels )( 
            IDvdInfo2 * This,
            /* [in] */ ULONG ulTitle,
            /* [out] */ ULONG *pulParentalLevels);
        
        HRESULT ( STDMETHODCALLTYPE *GetDVDDirectory )( 
            IDvdInfo2 * This,
            /* [size_is][out] */ LPWSTR pszwPath,
            /* [in] */ ULONG ulMaxSize,
            /* [out] */ ULONG *pulActualSize);
        
        HRESULT ( STDMETHODCALLTYPE *IsAudioStreamEnabled )( 
            IDvdInfo2 * This,
            /* [in] */ ULONG ulStreamNum,
            /* [out] */ BOOL *pbEnabled);
        
        HRESULT ( STDMETHODCALLTYPE *GetDiscID )( 
            IDvdInfo2 * This,
            /* [in] */ LPCWSTR pszwPath,
            /* [out] */ ULONGLONG *pullDiscID);
        
        HRESULT ( STDMETHODCALLTYPE *GetState )( 
            IDvdInfo2 * This,
            /* [out] */ IDvdState **pStateData);
        
        HRESULT ( STDMETHODCALLTYPE *GetMenuLanguages )( 
            IDvdInfo2 * This,
            /* [out] */ LCID *pLanguages,
            /* [in] */ ULONG ulMaxLanguages,
            /* [out] */ ULONG *pulActualLanguages);
        
        HRESULT ( STDMETHODCALLTYPE *GetButtonAtPosition )( 
            IDvdInfo2 * This,
            /* [in] */ POINT point,
            /* [out] */ ULONG *pulButtonIndex);
        
        HRESULT ( STDMETHODCALLTYPE *GetCmdFromEvent )( 
            IDvdInfo2 * This,
            /* [in] */ LONG_PTR lParam1,
            /* [out] */ IDvdCmd **pCmdObj);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultMenuLanguage )( 
            IDvdInfo2 * This,
            /* [out] */ LCID *pLanguage);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultAudioLanguage )( 
            IDvdInfo2 * This,
            /* [out] */ LCID *pLanguage,
            /* [out] */ DVD_AUDIO_LANG_EXT *pAudioExtension);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultSubpictureLanguage )( 
            IDvdInfo2 * This,
            /* [out] */ LCID *pLanguage,
            /* [out] */ DVD_SUBPICTURE_LANG_EXT *pSubpictureExtension);
        
        HRESULT ( STDMETHODCALLTYPE *GetDecoderCaps )( 
            IDvdInfo2 * This,
            /* [out] */ DVD_DECODER_CAPS *pCaps);
        
        HRESULT ( STDMETHODCALLTYPE *GetButtonRect )( 
            IDvdInfo2 * This,
            /* [in] */ ULONG ulButton,
            /* [out] */ RECT *pRect);
        
        HRESULT ( STDMETHODCALLTYPE *IsSubpictureStreamEnabled )( 
            IDvdInfo2 * This,
            /* [in] */ ULONG ulStreamNum,
            /* [out] */ BOOL *pbEnabled);
        
        END_INTERFACE
    } IDvdInfo2Vtbl;

    interface IDvdInfo2
    {
        CONST_VTBL struct IDvdInfo2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvdInfo2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvdInfo2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvdInfo2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvdInfo2_GetCurrentDomain(This,pDomain)	\
    ( (This)->lpVtbl -> GetCurrentDomain(This,pDomain) ) 

#define IDvdInfo2_GetCurrentLocation(This,pLocation)	\
    ( (This)->lpVtbl -> GetCurrentLocation(This,pLocation) ) 

#define IDvdInfo2_GetTotalTitleTime(This,pTotalTime,ulTimeCodeFlags)	\
    ( (This)->lpVtbl -> GetTotalTitleTime(This,pTotalTime,ulTimeCodeFlags) ) 

#define IDvdInfo2_GetCurrentButton(This,pulButtonsAvailable,pulCurrentButton)	\
    ( (This)->lpVtbl -> GetCurrentButton(This,pulButtonsAvailable,pulCurrentButton) ) 

#define IDvdInfo2_GetCurrentAngle(This,pulAnglesAvailable,pulCurrentAngle)	\
    ( (This)->lpVtbl -> GetCurrentAngle(This,pulAnglesAvailable,pulCurrentAngle) ) 

#define IDvdInfo2_GetCurrentAudio(This,pulStreamsAvailable,pulCurrentStream)	\
    ( (This)->lpVtbl -> GetCurrentAudio(This,pulStreamsAvailable,pulCurrentStream) ) 

#define IDvdInfo2_GetCurrentSubpicture(This,pulStreamsAvailable,pulCurrentStream,pbIsDisabled)	\
    ( (This)->lpVtbl -> GetCurrentSubpicture(This,pulStreamsAvailable,pulCurrentStream,pbIsDisabled) ) 

#define IDvdInfo2_GetCurrentUOPS(This,pulUOPs)	\
    ( (This)->lpVtbl -> GetCurrentUOPS(This,pulUOPs) ) 

#define IDvdInfo2_GetAllSPRMs(This,pRegisterArray)	\
    ( (This)->lpVtbl -> GetAllSPRMs(This,pRegisterArray) ) 

#define IDvdInfo2_GetAllGPRMs(This,pRegisterArray)	\
    ( (This)->lpVtbl -> GetAllGPRMs(This,pRegisterArray) ) 

#define IDvdInfo2_GetAudioLanguage(This,ulStream,pLanguage)	\
    ( (This)->lpVtbl -> GetAudioLanguage(This,ulStream,pLanguage) ) 

#define IDvdInfo2_GetSubpictureLanguage(This,ulStream,pLanguage)	\
    ( (This)->lpVtbl -> GetSubpictureLanguage(This,ulStream,pLanguage) ) 

#define IDvdInfo2_GetTitleAttributes(This,ulTitle,pMenu,pTitle)	\
    ( (This)->lpVtbl -> GetTitleAttributes(This,ulTitle,pMenu,pTitle) ) 

#define IDvdInfo2_GetVMGAttributes(This,pATR)	\
    ( (This)->lpVtbl -> GetVMGAttributes(This,pATR) ) 

#define IDvdInfo2_GetCurrentVideoAttributes(This,pATR)	\
    ( (This)->lpVtbl -> GetCurrentVideoAttributes(This,pATR) ) 

#define IDvdInfo2_GetAudioAttributes(This,ulStream,pATR)	\
    ( (This)->lpVtbl -> GetAudioAttributes(This,ulStream,pATR) ) 

#define IDvdInfo2_GetKaraokeAttributes(This,ulStream,pAttributes)	\
    ( (This)->lpVtbl -> GetKaraokeAttributes(This,ulStream,pAttributes) ) 

#define IDvdInfo2_GetSubpictureAttributes(This,ulStream,pATR)	\
    ( (This)->lpVtbl -> GetSubpictureAttributes(This,ulStream,pATR) ) 

#define IDvdInfo2_GetDVDVolumeInfo(This,pulNumOfVolumes,pulVolume,pSide,pulNumOfTitles)	\
    ( (This)->lpVtbl -> GetDVDVolumeInfo(This,pulNumOfVolumes,pulVolume,pSide,pulNumOfTitles) ) 

#define IDvdInfo2_GetDVDTextNumberOfLanguages(This,pulNumOfLangs)	\
    ( (This)->lpVtbl -> GetDVDTextNumberOfLanguages(This,pulNumOfLangs) ) 

#define IDvdInfo2_GetDVDTextLanguageInfo(This,ulLangIndex,pulNumOfStrings,pLangCode,pbCharacterSet)	\
    ( (This)->lpVtbl -> GetDVDTextLanguageInfo(This,ulLangIndex,pulNumOfStrings,pLangCode,pbCharacterSet) ) 

#define IDvdInfo2_GetDVDTextStringAsNative(This,ulLangIndex,ulStringIndex,pbBuffer,ulMaxBufferSize,pulActualSize,pType)	\
    ( (This)->lpVtbl -> GetDVDTextStringAsNative(This,ulLangIndex,ulStringIndex,pbBuffer,ulMaxBufferSize,pulActualSize,pType) ) 

#define IDvdInfo2_GetDVDTextStringAsUnicode(This,ulLangIndex,ulStringIndex,pchwBuffer,ulMaxBufferSize,pulActualSize,pType)	\
    ( (This)->lpVtbl -> GetDVDTextStringAsUnicode(This,ulLangIndex,ulStringIndex,pchwBuffer,ulMaxBufferSize,pulActualSize,pType) ) 

#define IDvdInfo2_GetPlayerParentalLevel(This,pulParentalLevel,pbCountryCode)	\
    ( (This)->lpVtbl -> GetPlayerParentalLevel(This,pulParentalLevel,pbCountryCode) ) 

#define IDvdInfo2_GetNumberOfChapters(This,ulTitle,pulNumOfChapters)	\
    ( (This)->lpVtbl -> GetNumberOfChapters(This,ulTitle,pulNumOfChapters) ) 

#define IDvdInfo2_GetTitleParentalLevels(This,ulTitle,pulParentalLevels)	\
    ( (This)->lpVtbl -> GetTitleParentalLevels(This,ulTitle,pulParentalLevels) ) 

#define IDvdInfo2_GetDVDDirectory(This,pszwPath,ulMaxSize,pulActualSize)	\
    ( (This)->lpVtbl -> GetDVDDirectory(This,pszwPath,ulMaxSize,pulActualSize) ) 

#define IDvdInfo2_IsAudioStreamEnabled(This,ulStreamNum,pbEnabled)	\
    ( (This)->lpVtbl -> IsAudioStreamEnabled(This,ulStreamNum,pbEnabled) ) 

#define IDvdInfo2_GetDiscID(This,pszwPath,pullDiscID)	\
    ( (This)->lpVtbl -> GetDiscID(This,pszwPath,pullDiscID) ) 

#define IDvdInfo2_GetState(This,pStateData)	\
    ( (This)->lpVtbl -> GetState(This,pStateData) ) 

#define IDvdInfo2_GetMenuLanguages(This,pLanguages,ulMaxLanguages,pulActualLanguages)	\
    ( (This)->lpVtbl -> GetMenuLanguages(This,pLanguages,ulMaxLanguages,pulActualLanguages) ) 

#define IDvdInfo2_GetButtonAtPosition(This,point,pulButtonIndex)	\
    ( (This)->lpVtbl -> GetButtonAtPosition(This,point,pulButtonIndex) ) 

#define IDvdInfo2_GetCmdFromEvent(This,lParam1,pCmdObj)	\
    ( (This)->lpVtbl -> GetCmdFromEvent(This,lParam1,pCmdObj) ) 

#define IDvdInfo2_GetDefaultMenuLanguage(This,pLanguage)	\
    ( (This)->lpVtbl -> GetDefaultMenuLanguage(This,pLanguage) ) 

#define IDvdInfo2_GetDefaultAudioLanguage(This,pLanguage,pAudioExtension)	\
    ( (This)->lpVtbl -> GetDefaultAudioLanguage(This,pLanguage,pAudioExtension) ) 

#define IDvdInfo2_GetDefaultSubpictureLanguage(This,pLanguage,pSubpictureExtension)	\
    ( (This)->lpVtbl -> GetDefaultSubpictureLanguage(This,pLanguage,pSubpictureExtension) ) 

#define IDvdInfo2_GetDecoderCaps(This,pCaps)	\
    ( (This)->lpVtbl -> GetDecoderCaps(This,pCaps) ) 

#define IDvdInfo2_GetButtonRect(This,ulButton,pRect)	\
    ( (This)->lpVtbl -> GetButtonRect(This,ulButton,pRect) ) 

#define IDvdInfo2_IsSubpictureStreamEnabled(This,ulStreamNum,pbEnabled)	\
    ( (This)->lpVtbl -> IsSubpictureStreamEnabled(This,ulStreamNum,pbEnabled) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvdInfo2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0095 */
/* [local] */ 

typedef 
enum _AM_DVD_GRAPH_FLAGS
    {	AM_DVD_HWDEC_PREFER	= 0x1,
	AM_DVD_HWDEC_ONLY	= 0x2,
	AM_DVD_SWDEC_PREFER	= 0x4,
	AM_DVD_SWDEC_ONLY	= 0x8,
	AM_DVD_NOVPE	= 0x100
    } 	AM_DVD_GRAPH_FLAGS;

typedef 
enum _AM_DVD_STREAM_FLAGS
    {	AM_DVD_STREAM_VIDEO	= 0x1,
	AM_DVD_STREAM_AUDIO	= 0x2,
	AM_DVD_STREAM_SUBPIC	= 0x4
    } 	AM_DVD_STREAM_FLAGS;

typedef /* [public][public] */ struct __MIDL___MIDL_itf_strmif_0000_0095_0001
    {
    HRESULT hrVPEStatus;
    BOOL bDvdVolInvalid;
    BOOL bDvdVolUnknown;
    BOOL bNoLine21In;
    BOOL bNoLine21Out;
    int iNumStreams;
    int iNumStreamsFailed;
    DWORD dwFailedStreamsFlag;
    } 	AM_DVD_RENDERSTATUS;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0095_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0095_v0_0_s_ifspec;

#ifndef __IDvdGraphBuilder_INTERFACE_DEFINED__
#define __IDvdGraphBuilder_INTERFACE_DEFINED__

/* interface IDvdGraphBuilder */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IDvdGraphBuilder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FCC152B6-F372-11d0-8E00-00C04FD7C08B")
    IDvdGraphBuilder : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFiltergraph( 
            /* [out] */ IGraphBuilder **ppGB) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDvdInterface( 
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvIF) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RenderDvdVideoVolume( 
            /* [in] */ LPCWSTR lpcwszPathName,
            /* [in] */ DWORD dwFlags,
            /* [out] */ AM_DVD_RENDERSTATUS *pStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvdGraphBuilderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvdGraphBuilder * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvdGraphBuilder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvdGraphBuilder * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetFiltergraph )( 
            IDvdGraphBuilder * This,
            /* [out] */ IGraphBuilder **ppGB);
        
        HRESULT ( STDMETHODCALLTYPE *GetDvdInterface )( 
            IDvdGraphBuilder * This,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvIF);
        
        HRESULT ( STDMETHODCALLTYPE *RenderDvdVideoVolume )( 
            IDvdGraphBuilder * This,
            /* [in] */ LPCWSTR lpcwszPathName,
            /* [in] */ DWORD dwFlags,
            /* [out] */ AM_DVD_RENDERSTATUS *pStatus);
        
        END_INTERFACE
    } IDvdGraphBuilderVtbl;

    interface IDvdGraphBuilder
    {
        CONST_VTBL struct IDvdGraphBuilderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvdGraphBuilder_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvdGraphBuilder_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvdGraphBuilder_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvdGraphBuilder_GetFiltergraph(This,ppGB)	\
    ( (This)->lpVtbl -> GetFiltergraph(This,ppGB) ) 

#define IDvdGraphBuilder_GetDvdInterface(This,riid,ppvIF)	\
    ( (This)->lpVtbl -> GetDvdInterface(This,riid,ppvIF) ) 

#define IDvdGraphBuilder_RenderDvdVideoVolume(This,lpcwszPathName,dwFlags,pStatus)	\
    ( (This)->lpVtbl -> RenderDvdVideoVolume(This,lpcwszPathName,dwFlags,pStatus) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvdGraphBuilder_INTERFACE_DEFINED__ */


#ifndef __IDDrawExclModeVideo_INTERFACE_DEFINED__
#define __IDDrawExclModeVideo_INTERFACE_DEFINED__

/* interface IDDrawExclModeVideo */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IDDrawExclModeVideo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("153ACC21-D83B-11d1-82BF-00A0C9696C8F")
    IDDrawExclModeVideo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetDDrawObject( 
            /* [in] */ IDirectDraw *pDDrawObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDDrawObject( 
            /* [out] */ IDirectDraw **ppDDrawObject,
            /* [out] */ BOOL *pbUsingExternal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDDrawSurface( 
            /* [in] */ IDirectDrawSurface *pDDrawSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDDrawSurface( 
            /* [out] */ IDirectDrawSurface **ppDDrawSurface,
            /* [out] */ BOOL *pbUsingExternal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDrawParameters( 
            /* [in] */ const RECT *prcSource,
            /* [in] */ const RECT *prcTarget) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNativeVideoProps( 
            /* [out] */ DWORD *pdwVideoWidth,
            /* [out] */ DWORD *pdwVideoHeight,
            /* [out] */ DWORD *pdwPictAspectRatioX,
            /* [out] */ DWORD *pdwPictAspectRatioY) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCallbackInterface( 
            /* [in] */ IDDrawExclModeVideoCallback *pCallback,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDDrawExclModeVideoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDDrawExclModeVideo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDDrawExclModeVideo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDDrawExclModeVideo * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDDrawObject )( 
            IDDrawExclModeVideo * This,
            /* [in] */ IDirectDraw *pDDrawObject);
        
        HRESULT ( STDMETHODCALLTYPE *GetDDrawObject )( 
            IDDrawExclModeVideo * This,
            /* [out] */ IDirectDraw **ppDDrawObject,
            /* [out] */ BOOL *pbUsingExternal);
        
        HRESULT ( STDMETHODCALLTYPE *SetDDrawSurface )( 
            IDDrawExclModeVideo * This,
            /* [in] */ IDirectDrawSurface *pDDrawSurface);
        
        HRESULT ( STDMETHODCALLTYPE *GetDDrawSurface )( 
            IDDrawExclModeVideo * This,
            /* [out] */ IDirectDrawSurface **ppDDrawSurface,
            /* [out] */ BOOL *pbUsingExternal);
        
        HRESULT ( STDMETHODCALLTYPE *SetDrawParameters )( 
            IDDrawExclModeVideo * This,
            /* [in] */ const RECT *prcSource,
            /* [in] */ const RECT *prcTarget);
        
        HRESULT ( STDMETHODCALLTYPE *GetNativeVideoProps )( 
            IDDrawExclModeVideo * This,
            /* [out] */ DWORD *pdwVideoWidth,
            /* [out] */ DWORD *pdwVideoHeight,
            /* [out] */ DWORD *pdwPictAspectRatioX,
            /* [out] */ DWORD *pdwPictAspectRatioY);
        
        HRESULT ( STDMETHODCALLTYPE *SetCallbackInterface )( 
            IDDrawExclModeVideo * This,
            /* [in] */ IDDrawExclModeVideoCallback *pCallback,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IDDrawExclModeVideoVtbl;

    interface IDDrawExclModeVideo
    {
        CONST_VTBL struct IDDrawExclModeVideoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDDrawExclModeVideo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDDrawExclModeVideo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDDrawExclModeVideo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDDrawExclModeVideo_SetDDrawObject(This,pDDrawObject)	\
    ( (This)->lpVtbl -> SetDDrawObject(This,pDDrawObject) ) 

#define IDDrawExclModeVideo_GetDDrawObject(This,ppDDrawObject,pbUsingExternal)	\
    ( (This)->lpVtbl -> GetDDrawObject(This,ppDDrawObject,pbUsingExternal) ) 

#define IDDrawExclModeVideo_SetDDrawSurface(This,pDDrawSurface)	\
    ( (This)->lpVtbl -> SetDDrawSurface(This,pDDrawSurface) ) 

#define IDDrawExclModeVideo_GetDDrawSurface(This,ppDDrawSurface,pbUsingExternal)	\
    ( (This)->lpVtbl -> GetDDrawSurface(This,ppDDrawSurface,pbUsingExternal) ) 

#define IDDrawExclModeVideo_SetDrawParameters(This,prcSource,prcTarget)	\
    ( (This)->lpVtbl -> SetDrawParameters(This,prcSource,prcTarget) ) 

#define IDDrawExclModeVideo_GetNativeVideoProps(This,pdwVideoWidth,pdwVideoHeight,pdwPictAspectRatioX,pdwPictAspectRatioY)	\
    ( (This)->lpVtbl -> GetNativeVideoProps(This,pdwVideoWidth,pdwVideoHeight,pdwPictAspectRatioX,pdwPictAspectRatioY) ) 

#define IDDrawExclModeVideo_SetCallbackInterface(This,pCallback,dwFlags)	\
    ( (This)->lpVtbl -> SetCallbackInterface(This,pCallback,dwFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDDrawExclModeVideo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0097 */
/* [local] */ 


enum _AM_OVERLAY_NOTIFY_FLAGS
    {	AM_OVERLAY_NOTIFY_VISIBLE_CHANGE	= 0x1,
	AM_OVERLAY_NOTIFY_SOURCE_CHANGE	= 0x2,
	AM_OVERLAY_NOTIFY_DEST_CHANGE	= 0x4
    } ;


extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0097_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0097_v0_0_s_ifspec;

#ifndef __IDDrawExclModeVideoCallback_INTERFACE_DEFINED__
#define __IDDrawExclModeVideoCallback_INTERFACE_DEFINED__

/* interface IDDrawExclModeVideoCallback */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IDDrawExclModeVideoCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("913c24a0-20ab-11d2-9038-00a0c9697298")
    IDDrawExclModeVideoCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnUpdateOverlay( 
            /* [in] */ BOOL bBefore,
            /* [in] */ DWORD dwFlags,
            /* [in] */ BOOL bOldVisible,
            /* [in] */ const RECT *prcOldSrc,
            /* [in] */ const RECT *prcOldDest,
            /* [in] */ BOOL bNewVisible,
            /* [in] */ const RECT *prcNewSrc,
            /* [in] */ const RECT *prcNewDest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnUpdateColorKey( 
            /* [in] */ const COLORKEY *pKey,
            /* [in] */ DWORD dwColor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnUpdateSize( 
            /* [in] */ DWORD dwWidth,
            /* [in] */ DWORD dwHeight,
            /* [in] */ DWORD dwARWidth,
            /* [in] */ DWORD dwARHeight) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDDrawExclModeVideoCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDDrawExclModeVideoCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDDrawExclModeVideoCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDDrawExclModeVideoCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnUpdateOverlay )( 
            IDDrawExclModeVideoCallback * This,
            /* [in] */ BOOL bBefore,
            /* [in] */ DWORD dwFlags,
            /* [in] */ BOOL bOldVisible,
            /* [in] */ const RECT *prcOldSrc,
            /* [in] */ const RECT *prcOldDest,
            /* [in] */ BOOL bNewVisible,
            /* [in] */ const RECT *prcNewSrc,
            /* [in] */ const RECT *prcNewDest);
        
        HRESULT ( STDMETHODCALLTYPE *OnUpdateColorKey )( 
            IDDrawExclModeVideoCallback * This,
            /* [in] */ const COLORKEY *pKey,
            /* [in] */ DWORD dwColor);
        
        HRESULT ( STDMETHODCALLTYPE *OnUpdateSize )( 
            IDDrawExclModeVideoCallback * This,
            /* [in] */ DWORD dwWidth,
            /* [in] */ DWORD dwHeight,
            /* [in] */ DWORD dwARWidth,
            /* [in] */ DWORD dwARHeight);
        
        END_INTERFACE
    } IDDrawExclModeVideoCallbackVtbl;

    interface IDDrawExclModeVideoCallback
    {
        CONST_VTBL struct IDDrawExclModeVideoCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDDrawExclModeVideoCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDDrawExclModeVideoCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDDrawExclModeVideoCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDDrawExclModeVideoCallback_OnUpdateOverlay(This,bBefore,dwFlags,bOldVisible,prcOldSrc,prcOldDest,bNewVisible,prcNewSrc,prcNewDest)	\
    ( (This)->lpVtbl -> OnUpdateOverlay(This,bBefore,dwFlags,bOldVisible,prcOldSrc,prcOldDest,bNewVisible,prcNewSrc,prcNewDest) ) 

#define IDDrawExclModeVideoCallback_OnUpdateColorKey(This,pKey,dwColor)	\
    ( (This)->lpVtbl -> OnUpdateColorKey(This,pKey,dwColor) ) 

#define IDDrawExclModeVideoCallback_OnUpdateSize(This,dwWidth,dwHeight,dwARWidth,dwARHeight)	\
    ( (This)->lpVtbl -> OnUpdateSize(This,dwWidth,dwHeight,dwARWidth,dwARHeight) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDDrawExclModeVideoCallback_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0098 */
/* [local] */ 

#if 0
typedef DWORD *LPDIRECTDRAW;

typedef DWORD *LPDIRECTDRAWSURFACE;

typedef DWORD *LPDDPIXELFORMAT;

typedef DWORD *LPBITMAPINFOHEADER;

typedef /* [public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_strmif_0000_0098_0001
    {
    DWORD dw1;
    DWORD dw2;
    } 	DDCOLORKEY;

typedef DDCOLORKEY *LPDDCOLORKEY;

#endif
#include <ddraw.h>
#if !defined(HMONITOR_DECLARED) && !defined(HMONITOR) && (WINVER < 0x0500)
#define HMONITOR_DECLARED
#if 0
typedef HANDLE HMONITOR;

#endif
DECLARE_HANDLE(HMONITOR);
#endif













typedef /* [public][public][public][public][public] */ 
enum __MIDL___MIDL_itf_strmif_0000_0098_0002
    {	VMRSample_SyncPoint	= 0x1,
	VMRSample_Preroll	= 0x2,
	VMRSample_Discontinuity	= 0x4,
	VMRSample_TimeValid	= 0x8,
	VMRSample_SrcDstRectsValid	= 0x10,
	VMRSample_PresentAsync	= 0x1000000,
	VMRSample_Prerotated90	= 0x2000000,
	VMRSample_Prerotated180	= 0x4000000,
	VMRSample_Prerotated270	= 0x8000000,
	VMRSample_Prerotated	= 0xe000000
    } 	VMRPresentationFlags;

typedef struct tagVMRPRESENTATIONINFO
    {
    DWORD dwFlags;
    LPDIRECTDRAWSURFACE lpSurf;
    REFERENCE_TIME rtStart;
    REFERENCE_TIME rtEnd;
    SIZE szAspectRatio;
    RECT rcSrc;
    RECT rcDst;
    DWORD dwTypeSpecificFlags;
    DWORD dwInterlaceFlags;
    IMediaSample *pMediaSample;
    DWORD dwFrameNo;
    } 	VMRPRESENTATIONINFO;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0098_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0098_v0_0_s_ifspec;

#ifndef __IVMRImagePresenter_INTERFACE_DEFINED__
#define __IVMRImagePresenter_INTERFACE_DEFINED__

/* interface IVMRImagePresenter */
/* [unique][helpstring][uuid][local][object][local] */ 


EXTERN_C const IID IID_IVMRImagePresenter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CE704FE7-E71E-41fb-BAA2-C4403E1182F5")
    IVMRImagePresenter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StartPresenting( 
            /* [in] */ DWORD_PTR dwUserID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopPresenting( 
            /* [in] */ DWORD_PTR dwUserID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PresentImage( 
            /* [in] */ DWORD_PTR dwUserID,
            /* [in] */ VMRPRESENTATIONINFO *lpPresInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRImagePresenterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRImagePresenter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRImagePresenter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRImagePresenter * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartPresenting )( 
            IVMRImagePresenter * This,
            /* [in] */ DWORD_PTR dwUserID);
        
        HRESULT ( STDMETHODCALLTYPE *StopPresenting )( 
            IVMRImagePresenter * This,
            /* [in] */ DWORD_PTR dwUserID);
        
        HRESULT ( STDMETHODCALLTYPE *PresentImage )( 
            IVMRImagePresenter * This,
            /* [in] */ DWORD_PTR dwUserID,
            /* [in] */ VMRPRESENTATIONINFO *lpPresInfo);
        
        END_INTERFACE
    } IVMRImagePresenterVtbl;

    interface IVMRImagePresenter
    {
        CONST_VTBL struct IVMRImagePresenterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRImagePresenter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMRImagePresenter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMRImagePresenter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMRImagePresenter_StartPresenting(This,dwUserID)	\
    ( (This)->lpVtbl -> StartPresenting(This,dwUserID) ) 

#define IVMRImagePresenter_StopPresenting(This,dwUserID)	\
    ( (This)->lpVtbl -> StopPresenting(This,dwUserID) ) 

#define IVMRImagePresenter_PresentImage(This,dwUserID,lpPresInfo)	\
    ( (This)->lpVtbl -> PresentImage(This,dwUserID,lpPresInfo) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMRImagePresenter_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0099 */
/* [local] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_strmif_0000_0099_0001
    {	AMAP_PIXELFORMAT_VALID	= 0x1,
	AMAP_3D_TARGET	= 0x2,
	AMAP_ALLOW_SYSMEM	= 0x4,
	AMAP_FORCE_SYSMEM	= 0x8,
	AMAP_DIRECTED_FLIP	= 0x10,
	AMAP_FORCE_OVERLAY	= 0x20,
	AMAP_DISABLE_OVERLAY	= 0x40
    } 	VMRSurfaceAllocationFlags;

typedef struct tagVMRALLOCATIONINFO
    {
    DWORD dwFlags;
    LPBITMAPINFOHEADER lpHdr;
    LPDDPIXELFORMAT lpPixFmt;
    SIZE szAspectRatio;
    DWORD dwMinBuffers;
    DWORD dwMaxBuffers;
    DWORD dwInterlaceFlags;
    SIZE szNativeSize;
    } 	VMRALLOCATIONINFO;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0099_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0099_v0_0_s_ifspec;

#ifndef __IVMRSurfaceAllocator_INTERFACE_DEFINED__
#define __IVMRSurfaceAllocator_INTERFACE_DEFINED__

/* interface IVMRSurfaceAllocator */
/* [unique][helpstring][uuid][local][object][local] */ 


EXTERN_C const IID IID_IVMRSurfaceAllocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("31ce832e-4484-458b-8cca-f4d7e3db0b52")
    IVMRSurfaceAllocator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AllocateSurface( 
            /* [in] */ DWORD_PTR dwUserID,
            /* [in] */ VMRALLOCATIONINFO *lpAllocInfo,
            /* [out][in] */ DWORD *lpdwActualBuffers,
            /* [out] */ LPDIRECTDRAWSURFACE *lplpSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FreeSurface( 
            /* [in] */ DWORD_PTR dwID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PrepareSurface( 
            /* [in] */ DWORD_PTR dwUserID,
            /* [in] */ LPDIRECTDRAWSURFACE lpSurface,
            /* [in] */ DWORD dwSurfaceFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AdviseNotify( 
            /* [in] */ IVMRSurfaceAllocatorNotify *lpIVMRSurfAllocNotify) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRSurfaceAllocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRSurfaceAllocator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRSurfaceAllocator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRSurfaceAllocator * This);
        
        HRESULT ( STDMETHODCALLTYPE *AllocateSurface )( 
            IVMRSurfaceAllocator * This,
            /* [in] */ DWORD_PTR dwUserID,
            /* [in] */ VMRALLOCATIONINFO *lpAllocInfo,
            /* [out][in] */ DWORD *lpdwActualBuffers,
            /* [out] */ LPDIRECTDRAWSURFACE *lplpSurface);
        
        HRESULT ( STDMETHODCALLTYPE *FreeSurface )( 
            IVMRSurfaceAllocator * This,
            /* [in] */ DWORD_PTR dwID);
        
        HRESULT ( STDMETHODCALLTYPE *PrepareSurface )( 
            IVMRSurfaceAllocator * This,
            /* [in] */ DWORD_PTR dwUserID,
            /* [in] */ LPDIRECTDRAWSURFACE lpSurface,
            /* [in] */ DWORD dwSurfaceFlags);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseNotify )( 
            IVMRSurfaceAllocator * This,
            /* [in] */ IVMRSurfaceAllocatorNotify *lpIVMRSurfAllocNotify);
        
        END_INTERFACE
    } IVMRSurfaceAllocatorVtbl;

    interface IVMRSurfaceAllocator
    {
        CONST_VTBL struct IVMRSurfaceAllocatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRSurfaceAllocator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMRSurfaceAllocator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMRSurfaceAllocator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMRSurfaceAllocator_AllocateSurface(This,dwUserID,lpAllocInfo,lpdwActualBuffers,lplpSurface)	\
    ( (This)->lpVtbl -> AllocateSurface(This,dwUserID,lpAllocInfo,lpdwActualBuffers,lplpSurface) ) 

#define IVMRSurfaceAllocator_FreeSurface(This,dwID)	\
    ( (This)->lpVtbl -> FreeSurface(This,dwID) ) 

#define IVMRSurfaceAllocator_PrepareSurface(This,dwUserID,lpSurface,dwSurfaceFlags)	\
    ( (This)->lpVtbl -> PrepareSurface(This,dwUserID,lpSurface,dwSurfaceFlags) ) 

#define IVMRSurfaceAllocator_AdviseNotify(This,lpIVMRSurfAllocNotify)	\
    ( (This)->lpVtbl -> AdviseNotify(This,lpIVMRSurfAllocNotify) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMRSurfaceAllocator_INTERFACE_DEFINED__ */


#ifndef __IVMRSurfaceAllocatorNotify_INTERFACE_DEFINED__
#define __IVMRSurfaceAllocatorNotify_INTERFACE_DEFINED__

/* interface IVMRSurfaceAllocatorNotify */
/* [unique][helpstring][uuid][local][object][local] */ 


EXTERN_C const IID IID_IVMRSurfaceAllocatorNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aada05a8-5a4e-4729-af0b-cea27aed51e2")
    IVMRSurfaceAllocatorNotify : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AdviseSurfaceAllocator( 
            /* [in] */ DWORD_PTR dwUserID,
            /* [in] */ IVMRSurfaceAllocator *lpIVRMSurfaceAllocator) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDDrawDevice( 
            /* [in] */ LPDIRECTDRAW lpDDrawDevice,
            /* [in] */ HMONITOR hMonitor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChangeDDrawDevice( 
            /* [in] */ LPDIRECTDRAW lpDDrawDevice,
            /* [in] */ HMONITOR hMonitor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RestoreDDrawSurfaces( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyEvent( 
            /* [in] */ LONG EventCode,
            /* [in] */ LONG_PTR Param1,
            /* [in] */ LONG_PTR Param2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBorderColor( 
            /* [in] */ COLORREF clrBorder) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRSurfaceAllocatorNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRSurfaceAllocatorNotify * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRSurfaceAllocatorNotify * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRSurfaceAllocatorNotify * This);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseSurfaceAllocator )( 
            IVMRSurfaceAllocatorNotify * This,
            /* [in] */ DWORD_PTR dwUserID,
            /* [in] */ IVMRSurfaceAllocator *lpIVRMSurfaceAllocator);
        
        HRESULT ( STDMETHODCALLTYPE *SetDDrawDevice )( 
            IVMRSurfaceAllocatorNotify * This,
            /* [in] */ LPDIRECTDRAW lpDDrawDevice,
            /* [in] */ HMONITOR hMonitor);
        
        HRESULT ( STDMETHODCALLTYPE *ChangeDDrawDevice )( 
            IVMRSurfaceAllocatorNotify * This,
            /* [in] */ LPDIRECTDRAW lpDDrawDevice,
            /* [in] */ HMONITOR hMonitor);
        
        HRESULT ( STDMETHODCALLTYPE *RestoreDDrawSurfaces )( 
            IVMRSurfaceAllocatorNotify * This);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyEvent )( 
            IVMRSurfaceAllocatorNotify * This,
            /* [in] */ LONG EventCode,
            /* [in] */ LONG_PTR Param1,
            /* [in] */ LONG_PTR Param2);
        
        HRESULT ( STDMETHODCALLTYPE *SetBorderColor )( 
            IVMRSurfaceAllocatorNotify * This,
            /* [in] */ COLORREF clrBorder);
        
        END_INTERFACE
    } IVMRSurfaceAllocatorNotifyVtbl;

    interface IVMRSurfaceAllocatorNotify
    {
        CONST_VTBL struct IVMRSurfaceAllocatorNotifyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRSurfaceAllocatorNotify_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMRSurfaceAllocatorNotify_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMRSurfaceAllocatorNotify_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMRSurfaceAllocatorNotify_AdviseSurfaceAllocator(This,dwUserID,lpIVRMSurfaceAllocator)	\
    ( (This)->lpVtbl -> AdviseSurfaceAllocator(This,dwUserID,lpIVRMSurfaceAllocator) ) 

#define IVMRSurfaceAllocatorNotify_SetDDrawDevice(This,lpDDrawDevice,hMonitor)	\
    ( (This)->lpVtbl -> SetDDrawDevice(This,lpDDrawDevice,hMonitor) ) 

#define IVMRSurfaceAllocatorNotify_ChangeDDrawDevice(This,lpDDrawDevice,hMonitor)	\
    ( (This)->lpVtbl -> ChangeDDrawDevice(This,lpDDrawDevice,hMonitor) ) 

#define IVMRSurfaceAllocatorNotify_RestoreDDrawSurfaces(This)	\
    ( (This)->lpVtbl -> RestoreDDrawSurfaces(This) ) 

#define IVMRSurfaceAllocatorNotify_NotifyEvent(This,EventCode,Param1,Param2)	\
    ( (This)->lpVtbl -> NotifyEvent(This,EventCode,Param1,Param2) ) 

#define IVMRSurfaceAllocatorNotify_SetBorderColor(This,clrBorder)	\
    ( (This)->lpVtbl -> SetBorderColor(This,clrBorder) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMRSurfaceAllocatorNotify_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0101 */
/* [local] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_strmif_0000_0101_0001
    {	VMR_ARMODE_NONE	= 0,
	VMR_ARMODE_LETTER_BOX	= ( VMR_ARMODE_NONE + 1 ) 
    } 	VMR_ASPECT_RATIO_MODE;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0101_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0101_v0_0_s_ifspec;

#ifndef __IVMRWindowlessControl_INTERFACE_DEFINED__
#define __IVMRWindowlessControl_INTERFACE_DEFINED__

/* interface IVMRWindowlessControl */
/* [unique][helpstring][uuid][local][object][local] */ 


EXTERN_C const IID IID_IVMRWindowlessControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0eb1088c-4dcd-46f0-878f-39dae86a51b7")
    IVMRWindowlessControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNativeVideoSize( 
            /* [out] */ LONG *lpWidth,
            /* [out] */ LONG *lpHeight,
            /* [out] */ LONG *lpARWidth,
            /* [out] */ LONG *lpARHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMinIdealVideoSize( 
            /* [out] */ LONG *lpWidth,
            /* [out] */ LONG *lpHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxIdealVideoSize( 
            /* [out] */ LONG *lpWidth,
            /* [out] */ LONG *lpHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetVideoPosition( 
            /* [in] */ const LPRECT lpSRCRect,
            /* [in] */ const LPRECT lpDSTRect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVideoPosition( 
            /* [out] */ LPRECT lpSRCRect,
            /* [out] */ LPRECT lpDSTRect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAspectRatioMode( 
            /* [out] */ DWORD *lpAspectRatioMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAspectRatioMode( 
            /* [in] */ DWORD AspectRatioMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetVideoClippingWindow( 
            /* [in] */ HWND hwnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RepaintVideo( 
            /* [in] */ HWND hwnd,
            /* [in] */ HDC hdc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisplayModeChanged( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentImage( 
            /* [out] */ BYTE **lpDib) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBorderColor( 
            /* [in] */ COLORREF Clr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBorderColor( 
            /* [out] */ COLORREF *lpClr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetColorKey( 
            /* [in] */ COLORREF Clr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColorKey( 
            /* [out] */ COLORREF *lpClr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRWindowlessControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRWindowlessControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRWindowlessControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRWindowlessControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetNativeVideoSize )( 
            IVMRWindowlessControl * This,
            /* [out] */ LONG *lpWidth,
            /* [out] */ LONG *lpHeight,
            /* [out] */ LONG *lpARWidth,
            /* [out] */ LONG *lpARHeight);
        
        HRESULT ( STDMETHODCALLTYPE *GetMinIdealVideoSize )( 
            IVMRWindowlessControl * This,
            /* [out] */ LONG *lpWidth,
            /* [out] */ LONG *lpHeight);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxIdealVideoSize )( 
            IVMRWindowlessControl * This,
            /* [out] */ LONG *lpWidth,
            /* [out] */ LONG *lpHeight);
        
        HRESULT ( STDMETHODCALLTYPE *SetVideoPosition )( 
            IVMRWindowlessControl * This,
            /* [in] */ const LPRECT lpSRCRect,
            /* [in] */ const LPRECT lpDSTRect);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoPosition )( 
            IVMRWindowlessControl * This,
            /* [out] */ LPRECT lpSRCRect,
            /* [out] */ LPRECT lpDSTRect);
        
        HRESULT ( STDMETHODCALLTYPE *GetAspectRatioMode )( 
            IVMRWindowlessControl * This,
            /* [out] */ DWORD *lpAspectRatioMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetAspectRatioMode )( 
            IVMRWindowlessControl * This,
            /* [in] */ DWORD AspectRatioMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetVideoClippingWindow )( 
            IVMRWindowlessControl * This,
            /* [in] */ HWND hwnd);
        
        HRESULT ( STDMETHODCALLTYPE *RepaintVideo )( 
            IVMRWindowlessControl * This,
            /* [in] */ HWND hwnd,
            /* [in] */ HDC hdc);
        
        HRESULT ( STDMETHODCALLTYPE *DisplayModeChanged )( 
            IVMRWindowlessControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentImage )( 
            IVMRWindowlessControl * This,
            /* [out] */ BYTE **lpDib);
        
        HRESULT ( STDMETHODCALLTYPE *SetBorderColor )( 
            IVMRWindowlessControl * This,
            /* [in] */ COLORREF Clr);
        
        HRESULT ( STDMETHODCALLTYPE *GetBorderColor )( 
            IVMRWindowlessControl * This,
            /* [out] */ COLORREF *lpClr);
        
        HRESULT ( STDMETHODCALLTYPE *SetColorKey )( 
            IVMRWindowlessControl * This,
            /* [in] */ COLORREF Clr);
        
        HRESULT ( STDMETHODCALLTYPE *GetColorKey )( 
            IVMRWindowlessControl * This,
            /* [out] */ COLORREF *lpClr);
        
        END_INTERFACE
    } IVMRWindowlessControlVtbl;

    interface IVMRWindowlessControl
    {
        CONST_VTBL struct IVMRWindowlessControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRWindowlessControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMRWindowlessControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMRWindowlessControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMRWindowlessControl_GetNativeVideoSize(This,lpWidth,lpHeight,lpARWidth,lpARHeight)	\
    ( (This)->lpVtbl -> GetNativeVideoSize(This,lpWidth,lpHeight,lpARWidth,lpARHeight) ) 

#define IVMRWindowlessControl_GetMinIdealVideoSize(This,lpWidth,lpHeight)	\
    ( (This)->lpVtbl -> GetMinIdealVideoSize(This,lpWidth,lpHeight) ) 

#define IVMRWindowlessControl_GetMaxIdealVideoSize(This,lpWidth,lpHeight)	\
    ( (This)->lpVtbl -> GetMaxIdealVideoSize(This,lpWidth,lpHeight) ) 

#define IVMRWindowlessControl_SetVideoPosition(This,lpSRCRect,lpDSTRect)	\
    ( (This)->lpVtbl -> SetVideoPosition(This,lpSRCRect,lpDSTRect) ) 

#define IVMRWindowlessControl_GetVideoPosition(This,lpSRCRect,lpDSTRect)	\
    ( (This)->lpVtbl -> GetVideoPosition(This,lpSRCRect,lpDSTRect) ) 

#define IVMRWindowlessControl_GetAspectRatioMode(This,lpAspectRatioMode)	\
    ( (This)->lpVtbl -> GetAspectRatioMode(This,lpAspectRatioMode) ) 

#define IVMRWindowlessControl_SetAspectRatioMode(This,AspectRatioMode)	\
    ( (This)->lpVtbl -> SetAspectRatioMode(This,AspectRatioMode) ) 

#define IVMRWindowlessControl_SetVideoClippingWindow(This,hwnd)	\
    ( (This)->lpVtbl -> SetVideoClippingWindow(This,hwnd) ) 

#define IVMRWindowlessControl_RepaintVideo(This,hwnd,hdc)	\
    ( (This)->lpVtbl -> RepaintVideo(This,hwnd,hdc) ) 

#define IVMRWindowlessControl_DisplayModeChanged(This)	\
    ( (This)->lpVtbl -> DisplayModeChanged(This) ) 

#define IVMRWindowlessControl_GetCurrentImage(This,lpDib)	\
    ( (This)->lpVtbl -> GetCurrentImage(This,lpDib) ) 

#define IVMRWindowlessControl_SetBorderColor(This,Clr)	\
    ( (This)->lpVtbl -> SetBorderColor(This,Clr) ) 

#define IVMRWindowlessControl_GetBorderColor(This,lpClr)	\
    ( (This)->lpVtbl -> GetBorderColor(This,lpClr) ) 

#define IVMRWindowlessControl_SetColorKey(This,Clr)	\
    ( (This)->lpVtbl -> SetColorKey(This,Clr) ) 

#define IVMRWindowlessControl_GetColorKey(This,lpClr)	\
    ( (This)->lpVtbl -> GetColorKey(This,lpClr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMRWindowlessControl_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0102 */
/* [local] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_strmif_0000_0102_0001
    {	MixerPref_NoDecimation	= 0x1,
	MixerPref_DecimateOutput	= 0x2,
	MixerPref_ARAdjustXorY	= 0x4,
	MixerPref_DecimationReserved	= 0x8,
	MixerPref_DecimateMask	= 0xf,
	MixerPref_BiLinearFiltering	= 0x10,
	MixerPref_PointFiltering	= 0x20,
	MixerPref_FilteringMask	= 0xf0,
	MixerPref_RenderTargetRGB	= 0x100,
	MixerPref_RenderTargetYUV	= 0x1000,
	MixerPref_RenderTargetYUV420	= 0x200,
	MixerPref_RenderTargetYUV422	= 0x400,
	MixerPref_RenderTargetYUV444	= 0x800,
	MixerPref_RenderTargetReserved	= 0xe000,
	MixerPref_RenderTargetMask	= 0xff00,
	MixerPref_DynamicSwitchToBOB	= 0x10000,
	MixerPref_DynamicDecimateBy2	= 0x20000,
	MixerPref_DynamicReserved	= 0xc0000,
	MixerPref_DynamicMask	= 0xf0000
    } 	VMRMixerPrefs;

typedef struct _NORMALIZEDRECT
    {
    float left;
    float top;
    float right;
    float bottom;
    } 	NORMALIZEDRECT;

typedef struct _NORMALIZEDRECT *PNORMALIZEDRECT;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0102_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0102_v0_0_s_ifspec;

#ifndef __IVMRMixerControl_INTERFACE_DEFINED__
#define __IVMRMixerControl_INTERFACE_DEFINED__

/* interface IVMRMixerControl */
/* [unique][helpstring][uuid][local][object][local] */ 


EXTERN_C const IID IID_IVMRMixerControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1c1a17b0-bed0-415d-974b-dc6696131599")
    IVMRMixerControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetAlpha( 
            /* [in] */ DWORD dwStreamID,
            /* [in] */ float Alpha) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAlpha( 
            /* [in] */ DWORD dwStreamID,
            /* [out] */ float *pAlpha) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetZOrder( 
            /* [in] */ DWORD dwStreamID,
            /* [in] */ DWORD dwZ) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetZOrder( 
            /* [in] */ DWORD dwStreamID,
            /* [out] */ DWORD *pZ) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOutputRect( 
            /* [in] */ DWORD dwStreamID,
            /* [in] */ const NORMALIZEDRECT *pRect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputRect( 
            /* [in] */ DWORD dwStreamID,
            /* [out] */ NORMALIZEDRECT *pRect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBackgroundClr( 
            /* [in] */ COLORREF ClrBkg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBackgroundClr( 
            /* [in] */ COLORREF *lpClrBkg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMixingPrefs( 
            /* [in] */ DWORD dwMixerPrefs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMixingPrefs( 
            /* [out] */ DWORD *pdwMixerPrefs) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRMixerControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRMixerControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRMixerControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRMixerControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetAlpha )( 
            IVMRMixerControl * This,
            /* [in] */ DWORD dwStreamID,
            /* [in] */ float Alpha);
        
        HRESULT ( STDMETHODCALLTYPE *GetAlpha )( 
            IVMRMixerControl * This,
            /* [in] */ DWORD dwStreamID,
            /* [out] */ float *pAlpha);
        
        HRESULT ( STDMETHODCALLTYPE *SetZOrder )( 
            IVMRMixerControl * This,
            /* [in] */ DWORD dwStreamID,
            /* [in] */ DWORD dwZ);
        
        HRESULT ( STDMETHODCALLTYPE *GetZOrder )( 
            IVMRMixerControl * This,
            /* [in] */ DWORD dwStreamID,
            /* [out] */ DWORD *pZ);
        
        HRESULT ( STDMETHODCALLTYPE *SetOutputRect )( 
            IVMRMixerControl * This,
            /* [in] */ DWORD dwStreamID,
            /* [in] */ const NORMALIZEDRECT *pRect);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputRect )( 
            IVMRMixerControl * This,
            /* [in] */ DWORD dwStreamID,
            /* [out] */ NORMALIZEDRECT *pRect);
        
        HRESULT ( STDMETHODCALLTYPE *SetBackgroundClr )( 
            IVMRMixerControl * This,
            /* [in] */ COLORREF ClrBkg);
        
        HRESULT ( STDMETHODCALLTYPE *GetBackgroundClr )( 
            IVMRMixerControl * This,
            /* [in] */ COLORREF *lpClrBkg);
        
        HRESULT ( STDMETHODCALLTYPE *SetMixingPrefs )( 
            IVMRMixerControl * This,
            /* [in] */ DWORD dwMixerPrefs);
        
        HRESULT ( STDMETHODCALLTYPE *GetMixingPrefs )( 
            IVMRMixerControl * This,
            /* [out] */ DWORD *pdwMixerPrefs);
        
        END_INTERFACE
    } IVMRMixerControlVtbl;

    interface IVMRMixerControl
    {
        CONST_VTBL struct IVMRMixerControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRMixerControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMRMixerControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMRMixerControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMRMixerControl_SetAlpha(This,dwStreamID,Alpha)	\
    ( (This)->lpVtbl -> SetAlpha(This,dwStreamID,Alpha) ) 

#define IVMRMixerControl_GetAlpha(This,dwStreamID,pAlpha)	\
    ( (This)->lpVtbl -> GetAlpha(This,dwStreamID,pAlpha) ) 

#define IVMRMixerControl_SetZOrder(This,dwStreamID,dwZ)	\
    ( (This)->lpVtbl -> SetZOrder(This,dwStreamID,dwZ) ) 

#define IVMRMixerControl_GetZOrder(This,dwStreamID,pZ)	\
    ( (This)->lpVtbl -> GetZOrder(This,dwStreamID,pZ) ) 

#define IVMRMixerControl_SetOutputRect(This,dwStreamID,pRect)	\
    ( (This)->lpVtbl -> SetOutputRect(This,dwStreamID,pRect) ) 

#define IVMRMixerControl_GetOutputRect(This,dwStreamID,pRect)	\
    ( (This)->lpVtbl -> GetOutputRect(This,dwStreamID,pRect) ) 

#define IVMRMixerControl_SetBackgroundClr(This,ClrBkg)	\
    ( (This)->lpVtbl -> SetBackgroundClr(This,ClrBkg) ) 

#define IVMRMixerControl_GetBackgroundClr(This,lpClrBkg)	\
    ( (This)->lpVtbl -> GetBackgroundClr(This,lpClrBkg) ) 

#define IVMRMixerControl_SetMixingPrefs(This,dwMixerPrefs)	\
    ( (This)->lpVtbl -> SetMixingPrefs(This,dwMixerPrefs) ) 

#define IVMRMixerControl_GetMixingPrefs(This,pdwMixerPrefs)	\
    ( (This)->lpVtbl -> GetMixingPrefs(This,pdwMixerPrefs) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMRMixerControl_INTERFACE_DEFINED__ */


#ifndef __IVMRMixerControl2_INTERFACE_DEFINED__
#define __IVMRMixerControl2_INTERFACE_DEFINED__

/* interface IVMRMixerControl2 */
/* [unique][helpstring][uuid][local][object][local] */ 


EXTERN_C const IID IID_IVMRMixerControl2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("af6129d9-261c-46ea-8c32-06a5658ad77d")
    IVMRMixerControl2 : public IVMRMixerControl
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStreamNativeVideoSize( 
            /* [in] */ DWORD dwStreamID,
            /* [out] */ LONG *lpWidth,
            /* [out] */ LONG *lpHeight) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRMixerControl2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRMixerControl2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRMixerControl2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRMixerControl2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetAlpha )( 
            IVMRMixerControl2 * This,
            /* [in] */ DWORD dwStreamID,
            /* [in] */ float Alpha);
        
        HRESULT ( STDMETHODCALLTYPE *GetAlpha )( 
            IVMRMixerControl2 * This,
            /* [in] */ DWORD dwStreamID,
            /* [out] */ float *pAlpha);
        
        HRESULT ( STDMETHODCALLTYPE *SetZOrder )( 
            IVMRMixerControl2 * This,
            /* [in] */ DWORD dwStreamID,
            /* [in] */ DWORD dwZ);
        
        HRESULT ( STDMETHODCALLTYPE *GetZOrder )( 
            IVMRMixerControl2 * This,
            /* [in] */ DWORD dwStreamID,
            /* [out] */ DWORD *pZ);
        
        HRESULT ( STDMETHODCALLTYPE *SetOutputRect )( 
            IVMRMixerControl2 * This,
            /* [in] */ DWORD dwStreamID,
            /* [in] */ const NORMALIZEDRECT *pRect);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputRect )( 
            IVMRMixerControl2 * This,
            /* [in] */ DWORD dwStreamID,
            /* [out] */ NORMALIZEDRECT *pRect);
        
        HRESULT ( STDMETHODCALLTYPE *SetBackgroundClr )( 
            IVMRMixerControl2 * This,
            /* [in] */ COLORREF ClrBkg);
        
        HRESULT ( STDMETHODCALLTYPE *GetBackgroundClr )( 
            IVMRMixerControl2 * This,
            /* [in] */ COLORREF *lpClrBkg);
        
        HRESULT ( STDMETHODCALLTYPE *SetMixingPrefs )( 
            IVMRMixerControl2 * This,
            /* [in] */ DWORD dwMixerPrefs);
        
        HRESULT ( STDMETHODCALLTYPE *GetMixingPrefs )( 
            IVMRMixerControl2 * This,
            /* [out] */ DWORD *pdwMixerPrefs);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamNativeVideoSize )( 
            IVMRMixerControl2 * This,
            /* [in] */ DWORD dwStreamID,
            /* [out] */ LONG *lpWidth,
            /* [out] */ LONG *lpHeight);
        
        END_INTERFACE
    } IVMRMixerControl2Vtbl;

    interface IVMRMixerControl2
    {
        CONST_VTBL struct IVMRMixerControl2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRMixerControl2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMRMixerControl2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMRMixerControl2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMRMixerControl2_SetAlpha(This,dwStreamID,Alpha)	\
    ( (This)->lpVtbl -> SetAlpha(This,dwStreamID,Alpha) ) 

#define IVMRMixerControl2_GetAlpha(This,dwStreamID,pAlpha)	\
    ( (This)->lpVtbl -> GetAlpha(This,dwStreamID,pAlpha) ) 

#define IVMRMixerControl2_SetZOrder(This,dwStreamID,dwZ)	\
    ( (This)->lpVtbl -> SetZOrder(This,dwStreamID,dwZ) ) 

#define IVMRMixerControl2_GetZOrder(This,dwStreamID,pZ)	\
    ( (This)->lpVtbl -> GetZOrder(This,dwStreamID,pZ) ) 

#define IVMRMixerControl2_SetOutputRect(This,dwStreamID,pRect)	\
    ( (This)->lpVtbl -> SetOutputRect(This,dwStreamID,pRect) ) 

#define IVMRMixerControl2_GetOutputRect(This,dwStreamID,pRect)	\
    ( (This)->lpVtbl -> GetOutputRect(This,dwStreamID,pRect) ) 

#define IVMRMixerControl2_SetBackgroundClr(This,ClrBkg)	\
    ( (This)->lpVtbl -> SetBackgroundClr(This,ClrBkg) ) 

#define IVMRMixerControl2_GetBackgroundClr(This,lpClrBkg)	\
    ( (This)->lpVtbl -> GetBackgroundClr(This,lpClrBkg) ) 

#define IVMRMixerControl2_SetMixingPrefs(This,dwMixerPrefs)	\
    ( (This)->lpVtbl -> SetMixingPrefs(This,dwMixerPrefs) ) 

#define IVMRMixerControl2_GetMixingPrefs(This,pdwMixerPrefs)	\
    ( (This)->lpVtbl -> GetMixingPrefs(This,pdwMixerPrefs) ) 


#define IVMRMixerControl2_GetStreamNativeVideoSize(This,dwStreamID,lpWidth,lpHeight)	\
    ( (This)->lpVtbl -> GetStreamNativeVideoSize(This,dwStreamID,lpWidth,lpHeight) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMRMixerControl2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0104 */
/* [local] */ 

typedef struct tagVMRGUID
    {
    GUID *pGUID;
    GUID GUID;
    } 	VMRGUID;

typedef struct tagVMRMONITORINFO
    {
    VMRGUID guid;
    RECT rcMonitor;
    HMONITOR hMon;
    DWORD dwFlags;
    wchar_t szDevice[ 32 ];
    wchar_t szDescription[ 256 ];
    LARGE_INTEGER liDriverVersion;
    DWORD dwVendorId;
    DWORD dwDeviceId;
    DWORD dwSubSysId;
    DWORD dwRevision;
    } 	VMRMONITORINFO;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0104_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0104_v0_0_s_ifspec;

#ifndef __IVMRMonitorConfig_INTERFACE_DEFINED__
#define __IVMRMonitorConfig_INTERFACE_DEFINED__

/* interface IVMRMonitorConfig */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IVMRMonitorConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9cf0b1b6-fbaa-4b7f-88cf-cf1f130a0dce")
    IVMRMonitorConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetMonitor( 
            /* [in] */ const VMRGUID *pGUID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMonitor( 
            /* [out] */ VMRGUID *pGUID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultMonitor( 
            /* [in] */ const VMRGUID *pGUID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultMonitor( 
            /* [out] */ VMRGUID *pGUID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAvailableMonitors( 
            /* [size_is][out] */ VMRMONITORINFO *pInfo,
            /* [in] */ DWORD dwMaxInfoArraySize,
            /* [out] */ DWORD *pdwNumDevices) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRMonitorConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRMonitorConfig * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRMonitorConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRMonitorConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetMonitor )( 
            IVMRMonitorConfig * This,
            /* [in] */ const VMRGUID *pGUID);
        
        HRESULT ( STDMETHODCALLTYPE *GetMonitor )( 
            IVMRMonitorConfig * This,
            /* [out] */ VMRGUID *pGUID);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultMonitor )( 
            IVMRMonitorConfig * This,
            /* [in] */ const VMRGUID *pGUID);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultMonitor )( 
            IVMRMonitorConfig * This,
            /* [out] */ VMRGUID *pGUID);
        
        HRESULT ( STDMETHODCALLTYPE *GetAvailableMonitors )( 
            IVMRMonitorConfig * This,
            /* [size_is][out] */ VMRMONITORINFO *pInfo,
            /* [in] */ DWORD dwMaxInfoArraySize,
            /* [out] */ DWORD *pdwNumDevices);
        
        END_INTERFACE
    } IVMRMonitorConfigVtbl;

    interface IVMRMonitorConfig
    {
        CONST_VTBL struct IVMRMonitorConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRMonitorConfig_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMRMonitorConfig_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMRMonitorConfig_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMRMonitorConfig_SetMonitor(This,pGUID)	\
    ( (This)->lpVtbl -> SetMonitor(This,pGUID) ) 

#define IVMRMonitorConfig_GetMonitor(This,pGUID)	\
    ( (This)->lpVtbl -> GetMonitor(This,pGUID) ) 

#define IVMRMonitorConfig_SetDefaultMonitor(This,pGUID)	\
    ( (This)->lpVtbl -> SetDefaultMonitor(This,pGUID) ) 

#define IVMRMonitorConfig_GetDefaultMonitor(This,pGUID)	\
    ( (This)->lpVtbl -> GetDefaultMonitor(This,pGUID) ) 

#define IVMRMonitorConfig_GetAvailableMonitors(This,pInfo,dwMaxInfoArraySize,pdwNumDevices)	\
    ( (This)->lpVtbl -> GetAvailableMonitors(This,pInfo,dwMaxInfoArraySize,pdwNumDevices) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMRMonitorConfig_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0105 */
/* [local] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_strmif_0000_0105_0001
    {	RenderPrefs_RestrictToInitialMonitor	= 0,
	RenderPrefs_ForceOffscreen	= 0x1,
	RenderPrefs_ForceOverlays	= 0x2,
	RenderPrefs_AllowOverlays	= 0,
	RenderPrefs_AllowOffscreen	= 0,
	RenderPrefs_DoNotRenderColorKeyAndBorder	= 0x8,
	RenderPrefs_Reserved	= 0x10,
	RenderPrefs_PreferAGPMemWhenMixing	= 0x20,
	RenderPrefs_RenderTargetRGB	= 0x1000000,
	RenderPrefs_RenderTargetYUV	= 0x2000000,
	RenderPrefs_Mask	= 0x300003f
    } 	VMRRenderPrefs;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_strmif_0000_0105_0002
    {	VMRMode_Windowed	= 0x1,
	VMRMode_Windowless	= 0x2,
	VMRMode_Renderless	= 0x4,
	VMRMode_Mask	= 0x7
    } 	VMRMode;


enum __MIDL___MIDL_itf_strmif_0000_0105_0003
    {	MAX_NUMBER_OF_STREAMS	= 16
    } ;


extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0105_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0105_v0_0_s_ifspec;

#ifndef __IVMRFilterConfig_INTERFACE_DEFINED__
#define __IVMRFilterConfig_INTERFACE_DEFINED__

/* interface IVMRFilterConfig */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IVMRFilterConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9e5530c5-7034-48b4-bb46-0b8a6efc8e36")
    IVMRFilterConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetImageCompositor( 
            /* [in] */ IVMRImageCompositor *lpVMRImgCompositor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNumberOfStreams( 
            /* [in] */ DWORD dwMaxStreams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNumberOfStreams( 
            /* [out] */ DWORD *pdwMaxStreams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRenderingPrefs( 
            /* [in] */ DWORD dwRenderFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRenderingPrefs( 
            /* [out] */ DWORD *pdwRenderFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRenderingMode( 
            /* [in] */ DWORD Mode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRenderingMode( 
            /* [out] */ DWORD *pMode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRFilterConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRFilterConfig * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRFilterConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRFilterConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetImageCompositor )( 
            IVMRFilterConfig * This,
            /* [in] */ IVMRImageCompositor *lpVMRImgCompositor);
        
        HRESULT ( STDMETHODCALLTYPE *SetNumberOfStreams )( 
            IVMRFilterConfig * This,
            /* [in] */ DWORD dwMaxStreams);
        
        HRESULT ( STDMETHODCALLTYPE *GetNumberOfStreams )( 
            IVMRFilterConfig * This,
            /* [out] */ DWORD *pdwMaxStreams);
        
        HRESULT ( STDMETHODCALLTYPE *SetRenderingPrefs )( 
            IVMRFilterConfig * This,
            /* [in] */ DWORD dwRenderFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetRenderingPrefs )( 
            IVMRFilterConfig * This,
            /* [out] */ DWORD *pdwRenderFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetRenderingMode )( 
            IVMRFilterConfig * This,
            /* [in] */ DWORD Mode);
        
        HRESULT ( STDMETHODCALLTYPE *GetRenderingMode )( 
            IVMRFilterConfig * This,
            /* [out] */ DWORD *pMode);
        
        END_INTERFACE
    } IVMRFilterConfigVtbl;

    interface IVMRFilterConfig
    {
        CONST_VTBL struct IVMRFilterConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRFilterConfig_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMRFilterConfig_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMRFilterConfig_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMRFilterConfig_SetImageCompositor(This,lpVMRImgCompositor)	\
    ( (This)->lpVtbl -> SetImageCompositor(This,lpVMRImgCompositor) ) 

#define IVMRFilterConfig_SetNumberOfStreams(This,dwMaxStreams)	\
    ( (This)->lpVtbl -> SetNumberOfStreams(This,dwMaxStreams) ) 

#define IVMRFilterConfig_GetNumberOfStreams(This,pdwMaxStreams)	\
    ( (This)->lpVtbl -> GetNumberOfStreams(This,pdwMaxStreams) ) 

#define IVMRFilterConfig_SetRenderingPrefs(This,dwRenderFlags)	\
    ( (This)->lpVtbl -> SetRenderingPrefs(This,dwRenderFlags) ) 

#define IVMRFilterConfig_GetRenderingPrefs(This,pdwRenderFlags)	\
    ( (This)->lpVtbl -> GetRenderingPrefs(This,pdwRenderFlags) ) 

#define IVMRFilterConfig_SetRenderingMode(This,Mode)	\
    ( (This)->lpVtbl -> SetRenderingMode(This,Mode) ) 

#define IVMRFilterConfig_GetRenderingMode(This,pMode)	\
    ( (This)->lpVtbl -> GetRenderingMode(This,pMode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMRFilterConfig_INTERFACE_DEFINED__ */


#ifndef __IVMRAspectRatioControl_INTERFACE_DEFINED__
#define __IVMRAspectRatioControl_INTERFACE_DEFINED__

/* interface IVMRAspectRatioControl */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IVMRAspectRatioControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ede80b5c-bad6-4623-b537-65586c9f8dfd")
    IVMRAspectRatioControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAspectRatioMode( 
            /* [out] */ LPDWORD lpdwARMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAspectRatioMode( 
            /* [in] */ DWORD dwARMode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRAspectRatioControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRAspectRatioControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRAspectRatioControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRAspectRatioControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAspectRatioMode )( 
            IVMRAspectRatioControl * This,
            /* [out] */ LPDWORD lpdwARMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetAspectRatioMode )( 
            IVMRAspectRatioControl * This,
            /* [in] */ DWORD dwARMode);
        
        END_INTERFACE
    } IVMRAspectRatioControlVtbl;

    interface IVMRAspectRatioControl
    {
        CONST_VTBL struct IVMRAspectRatioControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRAspectRatioControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMRAspectRatioControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMRAspectRatioControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMRAspectRatioControl_GetAspectRatioMode(This,lpdwARMode)	\
    ( (This)->lpVtbl -> GetAspectRatioMode(This,lpdwARMode) ) 

#define IVMRAspectRatioControl_SetAspectRatioMode(This,dwARMode)	\
    ( (This)->lpVtbl -> SetAspectRatioMode(This,dwARMode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMRAspectRatioControl_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0107 */
/* [local] */ 

typedef struct _VMRALPHABITMAP
    {
    DWORD dwFlags;
    HDC hdc;
    LPDIRECTDRAWSURFACE pDDS;
    RECT rSrc;
    NORMALIZEDRECT rDest;
    FLOAT fAlpha;
    COLORREF clrSrcKey;
    } 	VMRALPHABITMAP;

typedef struct _VMRALPHABITMAP *PVMRALPHABITMAP;

#define VMRBITMAP_DISABLE            0x00000001
#define VMRBITMAP_HDC                0x00000002
#define VMRBITMAP_ENTIREDDS          0x00000004
#define VMRBITMAP_SRCCOLORKEY        0x00000008
#define VMRBITMAP_SRCRECT            0x00000010


extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0107_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0107_v0_0_s_ifspec;

#ifndef __IVMRMixerBitmap_INTERFACE_DEFINED__
#define __IVMRMixerBitmap_INTERFACE_DEFINED__

/* interface IVMRMixerBitmap */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IVMRMixerBitmap;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1E673275-0257-40aa-AF20-7C608D4A0428")
    IVMRMixerBitmap : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetAlphaBitmap( 
            /* [in] */ const VMRALPHABITMAP *pBmpParms) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateAlphaBitmapParameters( 
            /* [in] */ PVMRALPHABITMAP pBmpParms) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAlphaBitmapParameters( 
            /* [out] */ PVMRALPHABITMAP pBmpParms) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRMixerBitmapVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRMixerBitmap * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRMixerBitmap * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRMixerBitmap * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetAlphaBitmap )( 
            IVMRMixerBitmap * This,
            /* [in] */ const VMRALPHABITMAP *pBmpParms);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateAlphaBitmapParameters )( 
            IVMRMixerBitmap * This,
            /* [in] */ PVMRALPHABITMAP pBmpParms);
        
        HRESULT ( STDMETHODCALLTYPE *GetAlphaBitmapParameters )( 
            IVMRMixerBitmap * This,
            /* [out] */ PVMRALPHABITMAP pBmpParms);
        
        END_INTERFACE
    } IVMRMixerBitmapVtbl;

    interface IVMRMixerBitmap
    {
        CONST_VTBL struct IVMRMixerBitmapVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRMixerBitmap_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMRMixerBitmap_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMRMixerBitmap_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMRMixerBitmap_SetAlphaBitmap(This,pBmpParms)	\
    ( (This)->lpVtbl -> SetAlphaBitmap(This,pBmpParms) ) 

#define IVMRMixerBitmap_UpdateAlphaBitmapParameters(This,pBmpParms)	\
    ( (This)->lpVtbl -> UpdateAlphaBitmapParameters(This,pBmpParms) ) 

#define IVMRMixerBitmap_GetAlphaBitmapParameters(This,pBmpParms)	\
    ( (This)->lpVtbl -> GetAlphaBitmapParameters(This,pBmpParms) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMRMixerBitmap_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0108 */
/* [local] */ 

typedef struct _VMRVIDEOSTREAMINFO
    {
    LPDIRECTDRAWSURFACE pddsVideoSurface;
    DWORD dwWidth;
    DWORD dwHeight;
    DWORD dwStrmID;
    FLOAT fAlpha;
    DDCOLORKEY ddClrKey;
    NORMALIZEDRECT rNormal;
    VMRPresentationFlags rotationFlags;
    } 	VMRVIDEOSTREAMINFO;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0108_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0108_v0_0_s_ifspec;

#ifndef __IVMRImageCompositor_INTERFACE_DEFINED__
#define __IVMRImageCompositor_INTERFACE_DEFINED__

/* interface IVMRImageCompositor */
/* [unique][helpstring][uuid][local][object][local] */ 


EXTERN_C const IID IID_IVMRImageCompositor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7a4fb5af-479f-4074-bb40-ce6722e43c82")
    IVMRImageCompositor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitCompositionTarget( 
            /* [in] */ IUnknown *pD3DDevice,
            /* [in] */ LPDIRECTDRAWSURFACE pddsRenderTarget) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TermCompositionTarget( 
            /* [in] */ IUnknown *pD3DDevice,
            /* [in] */ LPDIRECTDRAWSURFACE pddsRenderTarget) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStreamMediaType( 
            /* [in] */ DWORD dwStrmID,
            /* [in] */ AM_MEDIA_TYPE *pmt,
            /* [in] */ BOOL fTexture) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CompositeImage( 
            /* [in] */ IUnknown *pD3DDevice,
            /* [in] */ LPDIRECTDRAWSURFACE pddsRenderTarget,
            /* [in] */ AM_MEDIA_TYPE *pmtRenderTarget,
            /* [in] */ REFERENCE_TIME rtStart,
            /* [in] */ REFERENCE_TIME rtEnd,
            /* [in] */ DWORD dwClrBkGnd,
            /* [in] */ VMRVIDEOSTREAMINFO *pVideoStreamInfo,
            /* [in] */ UINT cStreams) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRImageCompositorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRImageCompositor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRImageCompositor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRImageCompositor * This);
        
        HRESULT ( STDMETHODCALLTYPE *InitCompositionTarget )( 
            IVMRImageCompositor * This,
            /* [in] */ IUnknown *pD3DDevice,
            /* [in] */ LPDIRECTDRAWSURFACE pddsRenderTarget);
        
        HRESULT ( STDMETHODCALLTYPE *TermCompositionTarget )( 
            IVMRImageCompositor * This,
            /* [in] */ IUnknown *pD3DDevice,
            /* [in] */ LPDIRECTDRAWSURFACE pddsRenderTarget);
        
        HRESULT ( STDMETHODCALLTYPE *SetStreamMediaType )( 
            IVMRImageCompositor * This,
            /* [in] */ DWORD dwStrmID,
            /* [in] */ AM_MEDIA_TYPE *pmt,
            /* [in] */ BOOL fTexture);
        
        HRESULT ( STDMETHODCALLTYPE *CompositeImage )( 
            IVMRImageCompositor * This,
            /* [in] */ IUnknown *pD3DDevice,
            /* [in] */ LPDIRECTDRAWSURFACE pddsRenderTarget,
            /* [in] */ AM_MEDIA_TYPE *pmtRenderTarget,
            /* [in] */ REFERENCE_TIME rtStart,
            /* [in] */ REFERENCE_TIME rtEnd,
            /* [in] */ DWORD dwClrBkGnd,
            /* [in] */ VMRVIDEOSTREAMINFO *pVideoStreamInfo,
            /* [in] */ UINT cStreams);
        
        END_INTERFACE
    } IVMRImageCompositorVtbl;

    interface IVMRImageCompositor
    {
        CONST_VTBL struct IVMRImageCompositorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRImageCompositor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMRImageCompositor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMRImageCompositor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMRImageCompositor_InitCompositionTarget(This,pD3DDevice,pddsRenderTarget)	\
    ( (This)->lpVtbl -> InitCompositionTarget(This,pD3DDevice,pddsRenderTarget) ) 

#define IVMRImageCompositor_TermCompositionTarget(This,pD3DDevice,pddsRenderTarget)	\
    ( (This)->lpVtbl -> TermCompositionTarget(This,pD3DDevice,pddsRenderTarget) ) 

#define IVMRImageCompositor_SetStreamMediaType(This,dwStrmID,pmt,fTexture)	\
    ( (This)->lpVtbl -> SetStreamMediaType(This,dwStrmID,pmt,fTexture) ) 

#define IVMRImageCompositor_CompositeImage(This,pD3DDevice,pddsRenderTarget,pmtRenderTarget,rtStart,rtEnd,dwClrBkGnd,pVideoStreamInfo,cStreams)	\
    ( (This)->lpVtbl -> CompositeImage(This,pD3DDevice,pddsRenderTarget,pmtRenderTarget,rtStart,rtEnd,dwClrBkGnd,pVideoStreamInfo,cStreams) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMRImageCompositor_INTERFACE_DEFINED__ */


#ifndef __IVMRImageCompositor2_INTERFACE_DEFINED__
#define __IVMRImageCompositor2_INTERFACE_DEFINED__

/* interface IVMRImageCompositor2 */
/* [unique][helpstring][uuid][local][object][local] */ 


EXTERN_C const IID IID_IVMRImageCompositor2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("65293563-9b51-4c61-b5e0-c9d8b94e9afc")
    IVMRImageCompositor2 : public IVMRImageCompositor
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetCompositionTargetFlags( 
            /* [in] */ VMRPresentationFlags presentationFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionTargetFlags( 
            /* [out] */ VMRPresentationFlags *pPresentationFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRImageCompositor2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRImageCompositor2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRImageCompositor2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRImageCompositor2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *InitCompositionTarget )( 
            IVMRImageCompositor2 * This,
            /* [in] */ IUnknown *pD3DDevice,
            /* [in] */ LPDIRECTDRAWSURFACE pddsRenderTarget);
        
        HRESULT ( STDMETHODCALLTYPE *TermCompositionTarget )( 
            IVMRImageCompositor2 * This,
            /* [in] */ IUnknown *pD3DDevice,
            /* [in] */ LPDIRECTDRAWSURFACE pddsRenderTarget);
        
        HRESULT ( STDMETHODCALLTYPE *SetStreamMediaType )( 
            IVMRImageCompositor2 * This,
            /* [in] */ DWORD dwStrmID,
            /* [in] */ AM_MEDIA_TYPE *pmt,
            /* [in] */ BOOL fTexture);
        
        HRESULT ( STDMETHODCALLTYPE *CompositeImage )( 
            IVMRImageCompositor2 * This,
            /* [in] */ IUnknown *pD3DDevice,
            /* [in] */ LPDIRECTDRAWSURFACE pddsRenderTarget,
            /* [in] */ AM_MEDIA_TYPE *pmtRenderTarget,
            /* [in] */ REFERENCE_TIME rtStart,
            /* [in] */ REFERENCE_TIME rtEnd,
            /* [in] */ DWORD dwClrBkGnd,
            /* [in] */ VMRVIDEOSTREAMINFO *pVideoStreamInfo,
            /* [in] */ UINT cStreams);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionTargetFlags )( 
            IVMRImageCompositor2 * This,
            /* [in] */ VMRPresentationFlags presentationFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionTargetFlags )( 
            IVMRImageCompositor2 * This,
            /* [out] */ VMRPresentationFlags *pPresentationFlags);
        
        END_INTERFACE
    } IVMRImageCompositor2Vtbl;

    interface IVMRImageCompositor2
    {
        CONST_VTBL struct IVMRImageCompositor2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRImageCompositor2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMRImageCompositor2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMRImageCompositor2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMRImageCompositor2_InitCompositionTarget(This,pD3DDevice,pddsRenderTarget)	\
    ( (This)->lpVtbl -> InitCompositionTarget(This,pD3DDevice,pddsRenderTarget) ) 

#define IVMRImageCompositor2_TermCompositionTarget(This,pD3DDevice,pddsRenderTarget)	\
    ( (This)->lpVtbl -> TermCompositionTarget(This,pD3DDevice,pddsRenderTarget) ) 

#define IVMRImageCompositor2_SetStreamMediaType(This,dwStrmID,pmt,fTexture)	\
    ( (This)->lpVtbl -> SetStreamMediaType(This,dwStrmID,pmt,fTexture) ) 

#define IVMRImageCompositor2_CompositeImage(This,pD3DDevice,pddsRenderTarget,pmtRenderTarget,rtStart,rtEnd,dwClrBkGnd,pVideoStreamInfo,cStreams)	\
    ( (This)->lpVtbl -> CompositeImage(This,pD3DDevice,pddsRenderTarget,pmtRenderTarget,rtStart,rtEnd,dwClrBkGnd,pVideoStreamInfo,cStreams) ) 


#define IVMRImageCompositor2_SetCompositionTargetFlags(This,presentationFlags)	\
    ( (This)->lpVtbl -> SetCompositionTargetFlags(This,presentationFlags) ) 

#define IVMRImageCompositor2_GetCompositionTargetFlags(This,pPresentationFlags)	\
    ( (This)->lpVtbl -> GetCompositionTargetFlags(This,pPresentationFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMRImageCompositor2_INTERFACE_DEFINED__ */


#ifndef __IVMRVideoStreamControl_INTERFACE_DEFINED__
#define __IVMRVideoStreamControl_INTERFACE_DEFINED__

/* interface IVMRVideoStreamControl */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IVMRVideoStreamControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("058d1f11-2a54-4bef-bd54-df706626b727")
    IVMRVideoStreamControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetColorKey( 
            /* [in] */ LPDDCOLORKEY lpClrKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColorKey( 
            /* [out] */ LPDDCOLORKEY lpClrKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStreamActiveState( 
            /* [in] */ BOOL fActive) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamActiveState( 
            /* [out] */ BOOL *lpfActive) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRVideoStreamControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRVideoStreamControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRVideoStreamControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRVideoStreamControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetColorKey )( 
            IVMRVideoStreamControl * This,
            /* [in] */ LPDDCOLORKEY lpClrKey);
        
        HRESULT ( STDMETHODCALLTYPE *GetColorKey )( 
            IVMRVideoStreamControl * This,
            /* [out] */ LPDDCOLORKEY lpClrKey);
        
        HRESULT ( STDMETHODCALLTYPE *SetStreamActiveState )( 
            IVMRVideoStreamControl * This,
            /* [in] */ BOOL fActive);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamActiveState )( 
            IVMRVideoStreamControl * This,
            /* [out] */ BOOL *lpfActive);
        
        END_INTERFACE
    } IVMRVideoStreamControlVtbl;

    interface IVMRVideoStreamControl
    {
        CONST_VTBL struct IVMRVideoStreamControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRVideoStreamControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMRVideoStreamControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMRVideoStreamControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMRVideoStreamControl_SetColorKey(This,lpClrKey)	\
    ( (This)->lpVtbl -> SetColorKey(This,lpClrKey) ) 

#define IVMRVideoStreamControl_GetColorKey(This,lpClrKey)	\
    ( (This)->lpVtbl -> GetColorKey(This,lpClrKey) ) 

#define IVMRVideoStreamControl_SetStreamActiveState(This,fActive)	\
    ( (This)->lpVtbl -> SetStreamActiveState(This,fActive) ) 

#define IVMRVideoStreamControl_GetStreamActiveState(This,lpfActive)	\
    ( (This)->lpVtbl -> GetStreamActiveState(This,lpfActive) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMRVideoStreamControl_INTERFACE_DEFINED__ */


#ifndef __IVMRSurface_INTERFACE_DEFINED__
#define __IVMRSurface_INTERFACE_DEFINED__

/* interface IVMRSurface */
/* [unique][helpstring][uuid][local][object][local] */ 


EXTERN_C const IID IID_IVMRSurface;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a9849bbe-9ec8-4263-b764-62730f0d15d0")
    IVMRSurface : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsSurfaceLocked( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockSurface( 
            /* [out] */ BYTE **lpSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlockSurface( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSurface( 
            /* [out] */ LPDIRECTDRAWSURFACE *lplpSurface) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRSurfaceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRSurface * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRSurface * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRSurface * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsSurfaceLocked )( 
            IVMRSurface * This);
        
        HRESULT ( STDMETHODCALLTYPE *LockSurface )( 
            IVMRSurface * This,
            /* [out] */ BYTE **lpSurface);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockSurface )( 
            IVMRSurface * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSurface )( 
            IVMRSurface * This,
            /* [out] */ LPDIRECTDRAWSURFACE *lplpSurface);
        
        END_INTERFACE
    } IVMRSurfaceVtbl;

    interface IVMRSurface
    {
        CONST_VTBL struct IVMRSurfaceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRSurface_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMRSurface_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMRSurface_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMRSurface_IsSurfaceLocked(This)	\
    ( (This)->lpVtbl -> IsSurfaceLocked(This) ) 

#define IVMRSurface_LockSurface(This,lpSurface)	\
    ( (This)->lpVtbl -> LockSurface(This,lpSurface) ) 

#define IVMRSurface_UnlockSurface(This)	\
    ( (This)->lpVtbl -> UnlockSurface(This) ) 

#define IVMRSurface_GetSurface(This,lplpSurface)	\
    ( (This)->lpVtbl -> GetSurface(This,lplpSurface) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMRSurface_INTERFACE_DEFINED__ */


#ifndef __IVMRImagePresenterConfig_INTERFACE_DEFINED__
#define __IVMRImagePresenterConfig_INTERFACE_DEFINED__

/* interface IVMRImagePresenterConfig */
/* [unique][helpstring][uuid][local][object][local] */ 


EXTERN_C const IID IID_IVMRImagePresenterConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9f3a1c85-8555-49ba-935f-be5b5b29d178")
    IVMRImagePresenterConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetRenderingPrefs( 
            /* [in] */ DWORD dwRenderFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRenderingPrefs( 
            /* [out] */ DWORD *dwRenderFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRImagePresenterConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRImagePresenterConfig * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRImagePresenterConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRImagePresenterConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetRenderingPrefs )( 
            IVMRImagePresenterConfig * This,
            /* [in] */ DWORD dwRenderFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetRenderingPrefs )( 
            IVMRImagePresenterConfig * This,
            /* [out] */ DWORD *dwRenderFlags);
        
        END_INTERFACE
    } IVMRImagePresenterConfigVtbl;

    interface IVMRImagePresenterConfig
    {
        CONST_VTBL struct IVMRImagePresenterConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRImagePresenterConfig_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMRImagePresenterConfig_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMRImagePresenterConfig_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMRImagePresenterConfig_SetRenderingPrefs(This,dwRenderFlags)	\
    ( (This)->lpVtbl -> SetRenderingPrefs(This,dwRenderFlags) ) 

#define IVMRImagePresenterConfig_GetRenderingPrefs(This,dwRenderFlags)	\
    ( (This)->lpVtbl -> GetRenderingPrefs(This,dwRenderFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMRImagePresenterConfig_INTERFACE_DEFINED__ */


#ifndef __IVMRImagePresenterExclModeConfig_INTERFACE_DEFINED__
#define __IVMRImagePresenterExclModeConfig_INTERFACE_DEFINED__

/* interface IVMRImagePresenterExclModeConfig */
/* [unique][helpstring][uuid][local][object][local] */ 


EXTERN_C const IID IID_IVMRImagePresenterExclModeConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e6f7ce40-4673-44f1-8f77-5499d68cb4ea")
    IVMRImagePresenterExclModeConfig : public IVMRImagePresenterConfig
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetXlcModeDDObjAndPrimarySurface( 
            /* [in] */ LPDIRECTDRAW lpDDObj,
            /* [in] */ LPDIRECTDRAWSURFACE lpPrimarySurf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetXlcModeDDObjAndPrimarySurface( 
            /* [out] */ LPDIRECTDRAW *lpDDObj,
            /* [out] */ LPDIRECTDRAWSURFACE *lpPrimarySurf) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRImagePresenterExclModeConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRImagePresenterExclModeConfig * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRImagePresenterExclModeConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRImagePresenterExclModeConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetRenderingPrefs )( 
            IVMRImagePresenterExclModeConfig * This,
            /* [in] */ DWORD dwRenderFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetRenderingPrefs )( 
            IVMRImagePresenterExclModeConfig * This,
            /* [out] */ DWORD *dwRenderFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetXlcModeDDObjAndPrimarySurface )( 
            IVMRImagePresenterExclModeConfig * This,
            /* [in] */ LPDIRECTDRAW lpDDObj,
            /* [in] */ LPDIRECTDRAWSURFACE lpPrimarySurf);
        
        HRESULT ( STDMETHODCALLTYPE *GetXlcModeDDObjAndPrimarySurface )( 
            IVMRImagePresenterExclModeConfig * This,
            /* [out] */ LPDIRECTDRAW *lpDDObj,
            /* [out] */ LPDIRECTDRAWSURFACE *lpPrimarySurf);
        
        END_INTERFACE
    } IVMRImagePresenterExclModeConfigVtbl;

    interface IVMRImagePresenterExclModeConfig
    {
        CONST_VTBL struct IVMRImagePresenterExclModeConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRImagePresenterExclModeConfig_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMRImagePresenterExclModeConfig_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMRImagePresenterExclModeConfig_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMRImagePresenterExclModeConfig_SetRenderingPrefs(This,dwRenderFlags)	\
    ( (This)->lpVtbl -> SetRenderingPrefs(This,dwRenderFlags) ) 

#define IVMRImagePresenterExclModeConfig_GetRenderingPrefs(This,dwRenderFlags)	\
    ( (This)->lpVtbl -> GetRenderingPrefs(This,dwRenderFlags) ) 


#define IVMRImagePresenterExclModeConfig_SetXlcModeDDObjAndPrimarySurface(This,lpDDObj,lpPrimarySurf)	\
    ( (This)->lpVtbl -> SetXlcModeDDObjAndPrimarySurface(This,lpDDObj,lpPrimarySurf) ) 

#define IVMRImagePresenterExclModeConfig_GetXlcModeDDObjAndPrimarySurface(This,lpDDObj,lpPrimarySurf)	\
    ( (This)->lpVtbl -> GetXlcModeDDObjAndPrimarySurface(This,lpDDObj,lpPrimarySurf) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMRImagePresenterExclModeConfig_INTERFACE_DEFINED__ */


#ifndef __IVPManager_INTERFACE_DEFINED__
#define __IVPManager_INTERFACE_DEFINED__

/* interface IVPManager */
/* [unique][helpstring][uuid][local][object][local] */ 


EXTERN_C const IID IID_IVPManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aac18c18-e186-46d2-825d-a1f8dc8e395a")
    IVPManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetVideoPortIndex( 
            /* [in] */ DWORD dwVideoPortIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVideoPortIndex( 
            /* [out] */ DWORD *pdwVideoPortIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVPManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVPManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVPManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVPManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetVideoPortIndex )( 
            IVPManager * This,
            /* [in] */ DWORD dwVideoPortIndex);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoPortIndex )( 
            IVPManager * This,
            /* [out] */ DWORD *pdwVideoPortIndex);
        
        END_INTERFACE
    } IVPManagerVtbl;

    interface IVPManager
    {
        CONST_VTBL struct IVPManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVPManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVPManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVPManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVPManager_SetVideoPortIndex(This,dwVideoPortIndex)	\
    ( (This)->lpVtbl -> SetVideoPortIndex(This,dwVideoPortIndex) ) 

#define IVPManager_GetVideoPortIndex(This,pdwVideoPortIndex)	\
    ( (This)->lpVtbl -> GetVideoPortIndex(This,pdwVideoPortIndex) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVPManager_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\strmctl.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//
//--------------------------------------------------------------------------;

#ifndef __strmctl_h__
#define __strmctl_h__

class CBaseStreamControl : public IAMStreamControl
{
public:
    // Used by the implementation
    enum StreamControlState
    { STREAM_FLOWING = 0x1000,
      STREAM_DISCARDING
    };

protected:
    enum StreamControlState	m_StreamState;		// Current stream state
    enum StreamControlState	m_StreamStateOnStop;	// State after next stop
						// (i.e.Blocking or Discarding)

    REFERENCE_TIME	m_tStartTime;	    // MAX_TIME implies none
    REFERENCE_TIME	m_tStopTime;	    // MAX_TIME implies none
    REFERENCE_TIME	m_tLastBufferStop;  // MAX_TIME implies none
    DWORD		m_dwStartCookie;    // Cookie for notification to app
    DWORD		m_dwStopCookie;	    // Cookie for notification to app
    volatile BOOL       m_bIsFlushing;        // No optimization pls!
    volatile BOOL	m_bStopSendExtra;   // bSendExtra was set
    volatile BOOL	m_bStopExtraSent;   // the extra one was sent

    CCritSec		m_CritSec;	    // CritSec to guard above attributes

    // Event to fire when we can come
    // out of blocking, or to come out of waiting
    // to discard if we change our minds.
    //
    CAMEvent			m_StreamEvent;

    // All of these methods execute immediately.  Helpers for others.
    //
    virtual void ExecuteStop();
    void ExecuteStart();
    void CancelStop();
    void CancelStart();

    // Some things we need to be told by our owning filter
    // Your pin must also expose IAMStreamControl when QI'd for it!
    //
    IReferenceClock *	m_pRefClock;	    // Need it to set advises
					    // Filter must tell us via
					    // SetSyncSource
    IMediaEventSink *   m_pSink;            // Event sink
					    // Filter must tell us after it
					    // creates it in JoinFilterGraph()
    FILTER_STATE	m_FilterState;	    // Just need it!
					    // Filter must tell us via
					    // NotifyFilterState
    REFERENCE_TIME	m_tRunStart;	    // Per the Run call to the filter

    // This guy will return one of the three StreamControlState's.  Here's what
    // the caller should do for each one:
    //
    // STREAM_FLOWING:		Proceed as usual (render or pass the sample on)
    // STREAM_DISCARDING:	Calculate the time 'til *pSampleStop and wait
    //				that long for the event handle
    //				(GetStreamEventHandle()).  If the wait
    //				expires, throw the sample away.  If the event
    //				fires, call me back - I've changed my mind.
    //
    virtual enum StreamControlState CheckSampleTimes( const REFERENCE_TIME * pSampleStart,
					      const REFERENCE_TIME * pSampleStop );

public:
    // You don't have to tell us much when we're created, but there are other
    // obligations that must be met.  See SetSyncSource & NotifyFilterState
    // below.
    //
    CBaseStreamControl();
    ~CBaseStreamControl();

    // If you want this class to work properly, there are thing you need to
    // (keep) telling it.  Filters with pins that use this class
    // should ensure that they pass through to this method any calls they
    // receive on their SetSyncSource.

    // We need a clock to see what time it is.  This is for the
    // "discard in a timely fashion" logic.  If we discard everything as
    // quick as possible, a whole 60 minute file could get discarded in the
    // first 10 seconds, and if somebody wants to turn streaming on at 30 
    // minutes into the file, and they make the call more than a few seconds
    // after the graph is run, it may be too late!  That would be silly.
    // So we hold every sample until it's time has gone, then we discard it.
    // The filter should call this when it gets a SetSyncSource
    //
    void SetSyncSource( IReferenceClock * pRefClock )
    {
	CAutoLock lck(&m_CritSec);
	if (m_pRefClock) m_pRefClock->Release();
	m_pRefClock = pRefClock;
	if (m_pRefClock) m_pRefClock->AddRef();
    }

    // Set event sink for notifications
    // The filter should call this in its JoinFilterGraph after it creates the
    // IMediaEventSink
    //
    void SetFilterGraph( IMediaEventSink *pSink ) {
        m_pSink = pSink;
    }

    // Since we schedule in stream time, we need the tStart and must track the
    // state of our owning filter.
    // The app should call this ever state change
    //
    void NotifyFilterState( FILTER_STATE new_state, REFERENCE_TIME tStart = 0 );

    // Filter should call Flushing(TRUE) in BeginFlush,
    // and Flushing(FALSE) in EndFlush.
    //
    void Flushing( BOOL bInProgress );


    // The two main methods of IAMStreamControl

    // Class adds default values suitable for immediate
    // muting and unmuting of the stream.

    STDMETHOD( StopAt )( const REFERENCE_TIME * ptStop = NULL,
			 BOOL bSendExtra = FALSE,
			 DWORD dwCookie = 0 );
    STDMETHOD( StartAt )( const REFERENCE_TIME * ptStart = NULL,
		    	  DWORD dwCookie = 0 );
    STDMETHODIMP GetInfo( AM_STREAM_INFO *pInfo);

    // Helper function for pin's receive method.  Call this with
    // the sample and we'll tell you what to do with it.  We'll do a
    // WaitForSingleObject within this call if one is required.  This is
    // a "What should I do with this sample?" kind of call. We'll tell the
    // caller to either flow it or discard it.
    // If pSample is NULL we evaluate based on the current state
    // settings
    enum StreamControlState CheckStreamState( IMediaSample * pSample );

protected:
    // These don't require locking, but we are relying on the fact that
    // m_StreamState can be retrieved with integrity, and is a snap shot that
    // may have just been, or may be just about to be, changed.
    HANDLE GetStreamEventHandle() const { return m_StreamEvent; }
    enum StreamControlState GetStreamState() const { return m_StreamState; }
    BOOL IsStreaming() const { return m_StreamState == STREAM_FLOWING; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\sysclock.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//
//--------------------------------------------------------------------------;
// System Clock implementation of IReferenceClock
// SYSCLOCK.H

#ifndef __SYSTEMCLOCK__
#define __SYSTEMCLOCK__

//
// Base clock.  Uses timeGetTime ONLY
// Uses most of the code in the base reference clock.
// Provides GetTime
//

class CSystemClock : public CBaseReferenceClock, public IAMClockAdjust, public IPersist
{
public:
    // We must be able to create an instance of ourselves
    static CUnknown * WINAPI CreateInstance(LPUNKNOWN pUnk, HRESULT *phr);
    CSystemClock(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr);

    DECLARE_IUNKNOWN

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void ** ppv);

    // Yield up our class id so that we can be persisted
    // Implement required Ipersist method
    STDMETHODIMP GetClassID(CLSID *pClsID);

    //  IAMClockAdjust methods
    STDMETHODIMP SetClockDelta(REFERENCE_TIME rtDelta);
}; //CSystemClock

#endif /* __SYSTEMCLOCK__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\taskscheduler.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

#ifndef __TASKSCHEDULER_H__
#define __TASKSCHEDULER_H__

#include <windows.h>
#include <notify.h>
#include <regext.h>
#include <cmnet.h>


#include <winerror.h>

#define MAKE_TSKSCH_SCODE(sev,fac,code) \
    ((SCODE) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )

#define MAKE_TSKSCH_E( err )  (MAKE_TSKSCH_SCODE( 1, FACILITY_ITF, err ))
#define MAKE_TSKSCH_S( warn ) (MAKE_TSKSCH_SCODE( 0, FACILITY_ITF, warn ))

#define E_TSKSCH_NOT_INITIALIZED                                MAKE_TSKSCH_E(0x100)
#define E_TSKSCH_SCHEDULE_NOT_FOUND                             MAKE_TSKSCH_E(0x101)
#define E_TSKSCH_GROUP_NOT_FOUND                                MAKE_TSKSCH_E(0x102)
#define E_TSKSCH_SCHEDULE_MISMATCH                              MAKE_TSKSCH_E(0x103)
#define E_TSKSCH_SCHEDULE_PRIORITY_NOT_UNIQUE                   MAKE_TSKSCH_E(0x104)

#define E_TSKSCH_API_NOT_READY                                  MAKE_TSKSCH_E(0x200)
#define E_TSKSCH_SERVICE_ERROR                                  MAKE_TSKSCH_E(0x201)

#define E_TSKSCH_INVALID_STRUCT_SIZE                            MAKE_TSKSCH_E(0x400)
#define E_TSKSCH_INVALID_SCHEDULE_ID                            MAKE_TSKSCH_E(0x401)
#define E_TSKSCH_INVALID_RECURRENCE_TYPE                        MAKE_TSKSCH_E(0x402)
#define E_TSKSCH_INVALID_PROGRESSION_TYPE                       MAKE_TSKSCH_E(0x403)
#define E_TSKSCH_INVALID_CONDITIONS                             MAKE_TSKSCH_E(0x404)
#define E_TSKSCH_INVALID_ACTIONS                                MAKE_TSKSCH_E(0x405)
#define E_TSKSCH_INVALID_STARTTIME_RELATIVESTARTTIME            MAKE_TSKSCH_E(0x406)
#define E_TSKSCH_INVALID_STARTTIME_LATER_ENDTIME                MAKE_TSKSCH_E(0x407)
                                                             // MAKE_TSKSCH_E(0x408)
#define E_TSKSCH_INVALID_BOOTUP_SCHEDULE_PROPERTY               MAKE_TSKSCH_E(0x409)
#define E_TSKSCH_INVALID_RUN_EARLY_TIME                         MAKE_TSKSCH_E(0x40A)
#define E_TSKSCH_INVALID_GROUP_ID                               MAKE_TSKSCH_E(0x40B)
#define E_TSKSCH_INVALID_INTERVAL_DURATION                      MAKE_TSKSCH_E(0x40C)
#define E_TSKSCH_INVALID_ACTUAL_RUN_COUNT                       MAKE_TSKSCH_E(0x40D)
#define E_TSKSCH_INVALID_MAX_INTERVAL                           MAKE_TSKSCH_E(0x40E)
#define E_TSKSCH_INVALID_NEXT_RUN_TIME                          MAKE_TSKSCH_E(0x40F)
#define E_TSKSCH_INVALID_LAST_RUN_TIME                          MAKE_TSKSCH_E(0x410)

#define E_TSKSCH_DB_ERROR_ACTIONS                               MAKE_TSKSCH_E(0x500)
#define E_TSKSCH_DB_ERROR_CONDITIONS                            MAKE_TSKSCH_E(0x501)

#define E_TSKSCH_GROUP_HAS_NO_ACTIVE_SCHEDULE                   MAKE_TSKSCH_E(0x600)

#define S_TSKSCH_GROUP_HAS_NO_SCHEDULES                         MAKE_TSKSCH_S(0x800)

#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

typedef enum
{
    CE_TASK_SCHEDULE_RECURRENCE_INTERVAL = 0,
    CE_TASK_SCHEDULE_RECURRENCE_ON_BOOT,
    CE_TASK_SCHEDULE_RECURRENCE_AVERAGE
} CE_TASK_SCHEDULE_RECURRENCE_TYPE;

typedef enum
{
    CE_TASK_SCHEDULE_PROGRESSION_NONE = 0,
    CE_TASK_SCHEDULE_PROGRESSION_LINEAR,
    CE_TASK_SCHEDULE_PROGRESSION_EXPONENTIAL
} CE_TASK_SCHEDULE_PROGRESSION_TYPE;

#define MAX_PATH_LEN MAX_PATH

typedef struct
{
    DWORD cbSize;
    WCHAR szId[ MAX_PATH_LEN ];
    WCHAR szApplication[ NAMED_EVENT_PREFIX_LEN+MAX_PATH_LEN ];
    LPWSTR pszCommandLine;
} CETASKSCHEDULEACTION;

typedef struct
{
    DWORD cbSize;
    WCHAR szId[ MAX_PATH_LEN ];
    HKEY hKey;
    LPWSTR pszSubkey;
    LPWSTR pszValueName;
    NOTIFICATIONCONDITION NotificationCondition;
} CETASKSCHEDULECONDITION;

typedef struct
{
    DWORD cbSize;
    GUID guidGroupId;
    WCHAR szScheduleId[ MAX_PATH_LEN ];
    CE_TASK_SCHEDULE_RECURRENCE_TYPE eRecurrenceType;
    CE_TASK_SCHEDULE_PROGRESSION_TYPE eProgressionType;
    DWORD dwIntervalDuration;
    SYSTEMTIME stStartTime;
    SYSTEMTIME stEndTime;
    DWORD dwRelativeStartTime;
    BOOL fDeleteWhenExpired;
    BOOL fPersist;
    DWORD dwMaximumRunCount;
    DWORD dwActualRunCount;
    DWORD dwRunEarlyTime;
    DWORD cConditionCount;
    CETASKSCHEDULECONDITION *pConditions;
    DWORD dwSchedulePriority;
    DWORD cActionCount;
    CETASKSCHEDULEACTION *pActions;
    DWORD dwMaxInterval;
    CM_SESSION_HANDLE hCmSession;
    BOOL fUsingNetwork;
    SYSTEMTIME stNextRunTime;
    SYSTEMTIME stLastRunTime;
    BOOL fSpecifyRunEarlyTime;
    BOOL fScheduleActive;
    BOOL fScheduleEnabled;
} CETASKSCHEDULE;

typedef void *HCETASKSCHEDULE;

HRESULT CeTaskSchedulerInit();

HRESULT CeTaskSchedulerCleanup();

HRESULT CeTaskSchedulerCreateSchedule(__in const CETASKSCHEDULE* pSchedule);

HRESULT CeTaskSchedulerDeleteSchedule(__in REFGUID guidScheduleGroupId,
                                        __in_opt const WCHAR* const wszScheduleId);

HRESULT CeTaskSchedulerGetSchedule(__in REFGUID guidScheduleGroupId,
                                        __in const WCHAR* const wszScheduleId,
                                        __deref_out CETASKSCHEDULE** ppSchedule);

void CeTaskSchedulerFreeSchedule(__in CETASKSCHEDULE* pSchedule);

HRESULT CeTaskSchedulerFirstSchedule(__in REFGUID guidScheduleGroupId,
                                        __out HCETASKSCHEDULE *phSchedule,
                                        __deref_out CETASKSCHEDULE **ppSchedule);

HRESULT CeTaskSchedulerNextSchedule(__in HCETASKSCHEDULE hSchedule,
                                        __deref_out CETASKSCHEDULE **ppSchedule);

void CeTaskSchedulerCloseHandle(__in HCETASKSCHEDULE hSchedule);

HRESULT CeTaskSchedulerEnableSchedule(__in REFGUID guidScheduleGroupId,
                                        __in_opt const WCHAR* const wszScheduleId,
                                        __in BOOL fEnable);

HRESULT CeTaskSchedulerExecuteSchedule(__in REFGUID guidScheduleGroupId,
                                        __in BOOL fAdvanceSchedule);

HRESULT CeTaskSchedulerAdvanceSchedule(__in REFGUID guidScheduleGroupId);


#ifdef __cplusplus
}   // extern "C"
#endif  // __cplusplus

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\structuredquery.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* at Thu Apr 19 12:01:46 2007
 */
/* Compiler settings for ..\structuredquery.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __structuredquery_h__
#define __structuredquery_h__

/* Forward Declarations */ 

#ifndef __IQueryParser_FWD_DEFINED__
#define __IQueryParser_FWD_DEFINED__
typedef interface IQueryParser IQueryParser;
#endif 	/* __IQueryParser_FWD_DEFINED__ */


#ifndef __IConditionFactory_FWD_DEFINED__
#define __IConditionFactory_FWD_DEFINED__
typedef interface IConditionFactory IConditionFactory;
#endif 	/* __IConditionFactory_FWD_DEFINED__ */


#ifndef __IQuerySolution_FWD_DEFINED__
#define __IQuerySolution_FWD_DEFINED__
typedef interface IQuerySolution IQuerySolution;
#endif 	/* __IQuerySolution_FWD_DEFINED__ */


#ifndef __ICondition_FWD_DEFINED__
#define __ICondition_FWD_DEFINED__
typedef interface ICondition ICondition;
#endif 	/* __ICondition_FWD_DEFINED__ */


#ifndef __IConditionGenerator_FWD_DEFINED__
#define __IConditionGenerator_FWD_DEFINED__
typedef interface IConditionGenerator IConditionGenerator;
#endif 	/* __IConditionGenerator_FWD_DEFINED__ */


#ifndef __IRichChunk_FWD_DEFINED__
#define __IRichChunk_FWD_DEFINED__
typedef interface IRichChunk IRichChunk;
#endif 	/* __IRichChunk_FWD_DEFINED__ */


#ifndef __IInterval_FWD_DEFINED__
#define __IInterval_FWD_DEFINED__
typedef interface IInterval IInterval;
#endif 	/* __IInterval_FWD_DEFINED__ */


#ifndef __IMetaData_FWD_DEFINED__
#define __IMetaData_FWD_DEFINED__
typedef interface IMetaData IMetaData;
#endif 	/* __IMetaData_FWD_DEFINED__ */


#ifndef __IEntity_FWD_DEFINED__
#define __IEntity_FWD_DEFINED__
typedef interface IEntity IEntity;
#endif 	/* __IEntity_FWD_DEFINED__ */


#ifndef __IRelationship_FWD_DEFINED__
#define __IRelationship_FWD_DEFINED__
typedef interface IRelationship IRelationship;
#endif 	/* __IRelationship_FWD_DEFINED__ */


#ifndef __INamedEntity_FWD_DEFINED__
#define __INamedEntity_FWD_DEFINED__
typedef interface INamedEntity INamedEntity;
#endif 	/* __INamedEntity_FWD_DEFINED__ */


#ifndef __ISchemaProvider_FWD_DEFINED__
#define __ISchemaProvider_FWD_DEFINED__
typedef interface ISchemaProvider ISchemaProvider;
#endif 	/* __ISchemaProvider_FWD_DEFINED__ */


#ifndef __ITokenCollection_FWD_DEFINED__
#define __ITokenCollection_FWD_DEFINED__
typedef interface ITokenCollection ITokenCollection;
#endif 	/* __ITokenCollection_FWD_DEFINED__ */


#ifndef __INamedEntityCollector_FWD_DEFINED__
#define __INamedEntityCollector_FWD_DEFINED__
typedef interface INamedEntityCollector INamedEntityCollector;
#endif 	/* __INamedEntityCollector_FWD_DEFINED__ */


#ifndef __ISchemaLocalizerSupport_FWD_DEFINED__
#define __ISchemaLocalizerSupport_FWD_DEFINED__
typedef interface ISchemaLocalizerSupport ISchemaLocalizerSupport;
#endif 	/* __ISchemaLocalizerSupport_FWD_DEFINED__ */


#ifndef __IQueryParserManager_FWD_DEFINED__
#define __IQueryParserManager_FWD_DEFINED__
typedef interface IQueryParserManager IQueryParserManager;
#endif 	/* __IQueryParserManager_FWD_DEFINED__ */


#ifndef __QueryParser_FWD_DEFINED__
#define __QueryParser_FWD_DEFINED__

#ifdef __cplusplus
typedef class QueryParser QueryParser;
#else
typedef struct QueryParser QueryParser;
#endif /* __cplusplus */

#endif 	/* __QueryParser_FWD_DEFINED__ */


#ifndef __NegationCondition_FWD_DEFINED__
#define __NegationCondition_FWD_DEFINED__

#ifdef __cplusplus
typedef class NegationCondition NegationCondition;
#else
typedef struct NegationCondition NegationCondition;
#endif /* __cplusplus */

#endif 	/* __NegationCondition_FWD_DEFINED__ */


#ifndef __CompoundCondition_FWD_DEFINED__
#define __CompoundCondition_FWD_DEFINED__

#ifdef __cplusplus
typedef class CompoundCondition CompoundCondition;
#else
typedef struct CompoundCondition CompoundCondition;
#endif /* __cplusplus */

#endif 	/* __CompoundCondition_FWD_DEFINED__ */


#ifndef __LeafCondition_FWD_DEFINED__
#define __LeafCondition_FWD_DEFINED__

#ifdef __cplusplus
typedef class LeafCondition LeafCondition;
#else
typedef struct LeafCondition LeafCondition;
#endif /* __cplusplus */

#endif 	/* __LeafCondition_FWD_DEFINED__ */


#ifndef __ConditionFactory_FWD_DEFINED__
#define __ConditionFactory_FWD_DEFINED__

#ifdef __cplusplus
typedef class ConditionFactory ConditionFactory;
#else
typedef struct ConditionFactory ConditionFactory;
#endif /* __cplusplus */

#endif 	/* __ConditionFactory_FWD_DEFINED__ */


#ifndef __QueryParserManager_FWD_DEFINED__
#define __QueryParserManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class QueryParserManager QueryParserManager;
#else
typedef struct QueryParserManager QueryParserManager;
#endif /* __cplusplus */

#endif 	/* __QueryParserManager_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_structuredquery_0000 */
/* [local] */ 











typedef /* [v1_enum] */ 
enum tagCONDITION_TYPE
    {	CT_AND_CONDITION	= 0,
	CT_OR_CONDITION	= CT_AND_CONDITION + 1,
	CT_NOT_CONDITION	= CT_OR_CONDITION + 1,
	CT_LEAF_CONDITION	= CT_NOT_CONDITION + 1
    }	CONDITION_TYPE;

typedef /* [v1_enum] */ 
enum tagCONDITION_OPERATION
    {	COP_IMPLICIT	= 0,
	COP_EQUAL	= COP_IMPLICIT + 1,
	COP_NOTEQUAL	= COP_EQUAL + 1,
	COP_LESSTHAN	= COP_NOTEQUAL + 1,
	COP_GREATERTHAN	= COP_LESSTHAN + 1,
	COP_LESSTHANOREQUAL	= COP_GREATERTHAN + 1,
	COP_GREATERTHANOREQUAL	= COP_LESSTHANOREQUAL + 1,
	COP_VALUE_STARTSWITH	= COP_GREATERTHANOREQUAL + 1,
	COP_VALUE_ENDSWITH	= COP_VALUE_STARTSWITH + 1,
	COP_VALUE_CONTAINS	= COP_VALUE_ENDSWITH + 1,
	COP_VALUE_NOTCONTAINS	= COP_VALUE_CONTAINS + 1,
	COP_DOSWILDCARDS	= COP_VALUE_NOTCONTAINS + 1,
	COP_WORD_EQUAL	= COP_DOSWILDCARDS + 1,
	COP_WORD_STARTSWITH	= COP_WORD_EQUAL + 1,
	COP_APPLICATION_SPECIFIC	= COP_WORD_STARTSWITH + 1
    }	CONDITION_OPERATION;

typedef /* [v1_enum] */ 
enum tagSTRUCTURED_QUERY_SINGLE_OPTION
    {	SQSO_SCHEMA	= 0,
	SQSO_LOCALE_WORD_BREAKING	= SQSO_SCHEMA + 1,
	SQSO_WORD_BREAKER	= SQSO_LOCALE_WORD_BREAKING + 1,
	SQSO_NATURAL_SYNTAX	= SQSO_WORD_BREAKER + 1,
	SQSO_AUTOMATIC_WILDCARD	= SQSO_NATURAL_SYNTAX + 1,
	SQSO_TRACE_LEVEL	= SQSO_AUTOMATIC_WILDCARD + 1,
	SQSO_LANGUAGE_KEYWORDS	= SQSO_TRACE_LEVEL + 1
    }	STRUCTURED_QUERY_SINGLE_OPTION;

typedef /* [v1_enum] */ 
enum tagSTRUCTURED_QUERY_MULTIOPTION
    {	SQMO_VIRTUAL_PROPERTY	= 0,
	SQMO_DEFAULT_PROPERTY	= SQMO_VIRTUAL_PROPERTY + 1,
	SQMO_GENERATOR_FOR_TYPE	= SQMO_DEFAULT_PROPERTY + 1
    }	STRUCTURED_QUERY_MULTIOPTION;

typedef /* [v1_enum] */ 
enum tagSTRUCTURED_QUERY_PARSE_ERROR
    {	SQPE_NONE	= 0,
	SQPE_EXTRA_OPENING_PARENTHESIS	= SQPE_NONE + 1,
	SQPE_EXTRA_CLOSING_PARENTHESIS	= SQPE_EXTRA_OPENING_PARENTHESIS + 1,
	SQPE_IGNORED_MODIFIER	= SQPE_EXTRA_CLOSING_PARENTHESIS + 1,
	SQPE_IGNORED_CONNECTOR	= SQPE_IGNORED_MODIFIER + 1,
	SQPE_IGNORED_KEYWORD	= SQPE_IGNORED_CONNECTOR + 1,
	SQPE_UNHANDLED	= SQPE_IGNORED_KEYWORD + 1
    }	STRUCTURED_QUERY_PARSE_ERROR;

/* [v1_enum] */ 
enum tagSTRUCTURED_QUERY_RESOLVE_OPTION
    {	SQRO_DONT_RESOLVE_DATETIME	= 0x1,
	SQRO_ALWAYS_ONE_INTERVAL	= 0x2,
	SQRO_DONT_SIMPLIFY_CONDITION_TREES	= 0x4,
	SQRO_DONT_MAP_RELATIONS	= 0x8,
	SQRO_DONT_RESOLVE_RANGES	= 0x10,
	SQRO_DONT_REMOVE_UNRESTRICTED_KEYWORDS	= 0x20,
	SQRO_DONT_SPLIT_WORDS	= 0x40,
	SQRO_IGNORE_PHRASE_ORDER	= 0x80
    };
typedef int STRUCTURED_QUERY_RESOLVE_OPTION;

typedef /* [v1_enum] */ 
enum tagINTERVAL_LIMIT_KIND
    {	ILK_EXPLICIT_INCLUDED	= 0,
	ILK_EXPLICIT_EXCLUDED	= ILK_EXPLICIT_INCLUDED + 1,
	ILK_NEGATIVE_INFINITY	= ILK_EXPLICIT_EXCLUDED + 1,
	ILK_POSITIVE_INFINITY	= ILK_NEGATIVE_INFINITY + 1
    }	INTERVAL_LIMIT_KIND;

typedef /* [v1_enum] */ 
enum tagQUERY_PARSER_MANAGER_OPTION
    {	QPMO_SCHEMA_BINARY_NAME	= 0,
	QPMO_PRELOCALIZED_SCHEMA_BINARY_PATH	= QPMO_SCHEMA_BINARY_NAME + 1,
	QPMO_UNLOCALIZED_SCHEMA_BINARY_PATH	= QPMO_PRELOCALIZED_SCHEMA_BINARY_PATH + 1,
	QPMO_LOCALIZED_SCHEMA_BINARY_PATH	= QPMO_UNLOCALIZED_SCHEMA_BINARY_PATH + 1,
	QPMO_APPEND_LCID_TO_LOCALIZED_PATH	= QPMO_LOCALIZED_SCHEMA_BINARY_PATH + 1,
	QPMO_LOCALIZER_SUPPORT	= QPMO_APPEND_LCID_TO_LOCALIZED_PATH + 1
    }	QUERY_PARSER_MANAGER_OPTION;



extern RPC_IF_HANDLE __MIDL_itf_structuredquery_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_structuredquery_0000_v0_0_s_ifspec;

#ifndef __IQueryParser_INTERFACE_DEFINED__
#define __IQueryParser_INTERFACE_DEFINED__

/* interface IQueryParser */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IQueryParser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2EBDEE67-3505-43f8-9946-EA44ABC8E5B0")
    IQueryParser : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Parse( 
            /* [in] */ LPCWSTR pszInputString,
            /* [in] */ IEnumUnknown __RPC_FAR *pCustomProperties,
            /* [retval][out] */ IQuerySolution __RPC_FAR *__RPC_FAR *ppSolution) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOption( 
            /* [in] */ STRUCTURED_QUERY_SINGLE_OPTION option,
            /* [in] */ const PROPVARIANT __RPC_FAR *pOptionValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOption( 
            /* [in] */ STRUCTURED_QUERY_SINGLE_OPTION option,
            /* [retval][out] */ PROPVARIANT __RPC_FAR *pOptionValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMultiOption( 
            /* [in] */ STRUCTURED_QUERY_MULTIOPTION option,
            /* [in] */ LPCWSTR pszOptionKey,
            /* [in] */ const PROPVARIANT __RPC_FAR *pOptionValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSchemaProvider( 
            /* [retval][out] */ ISchemaProvider __RPC_FAR *__RPC_FAR *ppSchemaProvider) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RestateToString( 
            /* [in] */ ICondition __RPC_FAR *pCondition,
            /* [in] */ BOOL fUseEnglish,
            /* [out] */ LPWSTR __RPC_FAR *ppszQueryString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ParsePropertyValue( 
            /* [in] */ LPCWSTR pszPropertyName,
            /* [in] */ LPCWSTR pszInputString,
            /* [retval][out] */ IQuerySolution __RPC_FAR *__RPC_FAR *ppSolution) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RestatePropertyValueToString( 
            /* [in] */ ICondition __RPC_FAR *pCondition,
            /* [in] */ BOOL fUseEnglish,
            /* [out] */ LPWSTR __RPC_FAR *ppszPropertyName,
            /* [out] */ LPWSTR __RPC_FAR *ppszQueryString) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IQueryParserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IQueryParser __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IQueryParser __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IQueryParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Parse )( 
            IQueryParser __RPC_FAR * This,
            /* [in] */ LPCWSTR pszInputString,
            /* [in] */ IEnumUnknown __RPC_FAR *pCustomProperties,
            /* [retval][out] */ IQuerySolution __RPC_FAR *__RPC_FAR *ppSolution);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOption )( 
            IQueryParser __RPC_FAR * This,
            /* [in] */ STRUCTURED_QUERY_SINGLE_OPTION option,
            /* [in] */ const PROPVARIANT __RPC_FAR *pOptionValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOption )( 
            IQueryParser __RPC_FAR * This,
            /* [in] */ STRUCTURED_QUERY_SINGLE_OPTION option,
            /* [retval][out] */ PROPVARIANT __RPC_FAR *pOptionValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMultiOption )( 
            IQueryParser __RPC_FAR * This,
            /* [in] */ STRUCTURED_QUERY_MULTIOPTION option,
            /* [in] */ LPCWSTR pszOptionKey,
            /* [in] */ const PROPVARIANT __RPC_FAR *pOptionValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSchemaProvider )( 
            IQueryParser __RPC_FAR * This,
            /* [retval][out] */ ISchemaProvider __RPC_FAR *__RPC_FAR *ppSchemaProvider);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RestateToString )( 
            IQueryParser __RPC_FAR * This,
            /* [in] */ ICondition __RPC_FAR *pCondition,
            /* [in] */ BOOL fUseEnglish,
            /* [out] */ LPWSTR __RPC_FAR *ppszQueryString);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ParsePropertyValue )( 
            IQueryParser __RPC_FAR * This,
            /* [in] */ LPCWSTR pszPropertyName,
            /* [in] */ LPCWSTR pszInputString,
            /* [retval][out] */ IQuerySolution __RPC_FAR *__RPC_FAR *ppSolution);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RestatePropertyValueToString )( 
            IQueryParser __RPC_FAR * This,
            /* [in] */ ICondition __RPC_FAR *pCondition,
            /* [in] */ BOOL fUseEnglish,
            /* [out] */ LPWSTR __RPC_FAR *ppszPropertyName,
            /* [out] */ LPWSTR __RPC_FAR *ppszQueryString);
        
        END_INTERFACE
    } IQueryParserVtbl;

    interface IQueryParser
    {
        CONST_VTBL struct IQueryParserVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IQueryParser_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IQueryParser_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IQueryParser_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IQueryParser_Parse(This,pszInputString,pCustomProperties,ppSolution)	\
    (This)->lpVtbl -> Parse(This,pszInputString,pCustomProperties,ppSolution)

#define IQueryParser_SetOption(This,option,pOptionValue)	\
    (This)->lpVtbl -> SetOption(This,option,pOptionValue)

#define IQueryParser_GetOption(This,option,pOptionValue)	\
    (This)->lpVtbl -> GetOption(This,option,pOptionValue)

#define IQueryParser_SetMultiOption(This,option,pszOptionKey,pOptionValue)	\
    (This)->lpVtbl -> SetMultiOption(This,option,pszOptionKey,pOptionValue)

#define IQueryParser_GetSchemaProvider(This,ppSchemaProvider)	\
    (This)->lpVtbl -> GetSchemaProvider(This,ppSchemaProvider)

#define IQueryParser_RestateToString(This,pCondition,fUseEnglish,ppszQueryString)	\
    (This)->lpVtbl -> RestateToString(This,pCondition,fUseEnglish,ppszQueryString)

#define IQueryParser_ParsePropertyValue(This,pszPropertyName,pszInputString,ppSolution)	\
    (This)->lpVtbl -> ParsePropertyValue(This,pszPropertyName,pszInputString,ppSolution)

#define IQueryParser_RestatePropertyValueToString(This,pCondition,fUseEnglish,ppszPropertyName,ppszQueryString)	\
    (This)->lpVtbl -> RestatePropertyValueToString(This,pCondition,fUseEnglish,ppszPropertyName,ppszQueryString)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IQueryParser_Parse_Proxy( 
    IQueryParser __RPC_FAR * This,
    /* [in] */ LPCWSTR pszInputString,
    /* [in] */ IEnumUnknown __RPC_FAR *pCustomProperties,
    /* [retval][out] */ IQuerySolution __RPC_FAR *__RPC_FAR *ppSolution);


void __RPC_STUB IQueryParser_Parse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IQueryParser_SetOption_Proxy( 
    IQueryParser __RPC_FAR * This,
    /* [in] */ STRUCTURED_QUERY_SINGLE_OPTION option,
    /* [in] */ const PROPVARIANT __RPC_FAR *pOptionValue);


void __RPC_STUB IQueryParser_SetOption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IQueryParser_GetOption_Proxy( 
    IQueryParser __RPC_FAR * This,
    /* [in] */ STRUCTURED_QUERY_SINGLE_OPTION option,
    /* [retval][out] */ PROPVARIANT __RPC_FAR *pOptionValue);


void __RPC_STUB IQueryParser_GetOption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IQueryParser_SetMultiOption_Proxy( 
    IQueryParser __RPC_FAR * This,
    /* [in] */ STRUCTURED_QUERY_MULTIOPTION option,
    /* [in] */ LPCWSTR pszOptionKey,
    /* [in] */ const PROPVARIANT __RPC_FAR *pOptionValue);


void __RPC_STUB IQueryParser_SetMultiOption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IQueryParser_GetSchemaProvider_Proxy( 
    IQueryParser __RPC_FAR * This,
    /* [retval][out] */ ISchemaProvider __RPC_FAR *__RPC_FAR *ppSchemaProvider);


void __RPC_STUB IQueryParser_GetSchemaProvider_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IQueryParser_RestateToString_Proxy( 
    IQueryParser __RPC_FAR * This,
    /* [in] */ ICondition __RPC_FAR *pCondition,
    /* [in] */ BOOL fUseEnglish,
    /* [out] */ LPWSTR __RPC_FAR *ppszQueryString);


void __RPC_STUB IQueryParser_RestateToString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IQueryParser_ParsePropertyValue_Proxy( 
    IQueryParser __RPC_FAR * This,
    /* [in] */ LPCWSTR pszPropertyName,
    /* [in] */ LPCWSTR pszInputString,
    /* [retval][out] */ IQuerySolution __RPC_FAR *__RPC_FAR *ppSolution);


void __RPC_STUB IQueryParser_ParsePropertyValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IQueryParser_RestatePropertyValueToString_Proxy( 
    IQueryParser __RPC_FAR * This,
    /* [in] */ ICondition __RPC_FAR *pCondition,
    /* [in] */ BOOL fUseEnglish,
    /* [out] */ LPWSTR __RPC_FAR *ppszPropertyName,
    /* [out] */ LPWSTR __RPC_FAR *ppszQueryString);


void __RPC_STUB IQueryParser_RestatePropertyValueToString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IQueryParser_INTERFACE_DEFINED__ */


#ifndef __IConditionFactory_INTERFACE_DEFINED__
#define __IConditionFactory_INTERFACE_DEFINED__

/* interface IConditionFactory */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IConditionFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A5EFE073-B16F-474f-9F3E-9F8B497A3E08")
    IConditionFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE MakeNot( 
            /* [in] */ ICondition __RPC_FAR *pSubCondition,
            /* [in] */ BOOL simplify,
            /* [retval][out] */ ICondition __RPC_FAR *__RPC_FAR *ppResultQuery) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MakeAndOr( 
            /* [in] */ CONDITION_TYPE nodeType,
            /* [in] */ IEnumUnknown __RPC_FAR *pSubConditions,
            /* [in] */ BOOL simplify,
            /* [retval][out] */ ICondition __RPC_FAR *__RPC_FAR *ppResultQuery) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MakeLeaf( 
            /* [unique][in] */ LPCWSTR pszPropertyName,
            /* [in] */ CONDITION_OPERATION op,
            /* [unique][in] */ LPCWSTR pszValueType,
            /* [in] */ const PROPVARIANT __RPC_FAR *pValue,
            /* [in] */ IRichChunk __RPC_FAR *pPropertyNameTerm,
            /* [in] */ IRichChunk __RPC_FAR *pOperationTerm,
            /* [in] */ IRichChunk __RPC_FAR *pValueTerm,
            /* [in] */ BOOL expand,
            /* [retval][out] */ ICondition __RPC_FAR *__RPC_FAR *ppResultQuery) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Resolve( 
            /* [in] */ ICondition __RPC_FAR *pConditionTree,
            /* [in] */ STRUCTURED_QUERY_RESOLVE_OPTION sqro,
            /* [ref][in] */ const SYSTEMTIME __RPC_FAR *pstReferenceTime,
            /* [retval][out] */ ICondition __RPC_FAR *__RPC_FAR *ppResolvedConditionTree) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IConditionFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IConditionFactory __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IConditionFactory __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IConditionFactory __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MakeNot )( 
            IConditionFactory __RPC_FAR * This,
            /* [in] */ ICondition __RPC_FAR *pSubCondition,
            /* [in] */ BOOL simplify,
            /* [retval][out] */ ICondition __RPC_FAR *__RPC_FAR *ppResultQuery);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MakeAndOr )( 
            IConditionFactory __RPC_FAR * This,
            /* [in] */ CONDITION_TYPE nodeType,
            /* [in] */ IEnumUnknown __RPC_FAR *pSubConditions,
            /* [in] */ BOOL simplify,
            /* [retval][out] */ ICondition __RPC_FAR *__RPC_FAR *ppResultQuery);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MakeLeaf )( 
            IConditionFactory __RPC_FAR * This,
            /* [unique][in] */ LPCWSTR pszPropertyName,
            /* [in] */ CONDITION_OPERATION op,
            /* [unique][in] */ LPCWSTR pszValueType,
            /* [in] */ const PROPVARIANT __RPC_FAR *pValue,
            /* [in] */ IRichChunk __RPC_FAR *pPropertyNameTerm,
            /* [in] */ IRichChunk __RPC_FAR *pOperationTerm,
            /* [in] */ IRichChunk __RPC_FAR *pValueTerm,
            /* [in] */ BOOL expand,
            /* [retval][out] */ ICondition __RPC_FAR *__RPC_FAR *ppResultQuery);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Resolve )( 
            IConditionFactory __RPC_FAR * This,
            /* [in] */ ICondition __RPC_FAR *pConditionTree,
            /* [in] */ STRUCTURED_QUERY_RESOLVE_OPTION sqro,
            /* [ref][in] */ const SYSTEMTIME __RPC_FAR *pstReferenceTime,
            /* [retval][out] */ ICondition __RPC_FAR *__RPC_FAR *ppResolvedConditionTree);
        
        END_INTERFACE
    } IConditionFactoryVtbl;

    interface IConditionFactory
    {
        CONST_VTBL struct IConditionFactoryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IConditionFactory_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IConditionFactory_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IConditionFactory_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IConditionFactory_MakeNot(This,pSubCondition,simplify,ppResultQuery)	\
    (This)->lpVtbl -> MakeNot(This,pSubCondition,simplify,ppResultQuery)

#define IConditionFactory_MakeAndOr(This,nodeType,pSubConditions,simplify,ppResultQuery)	\
    (This)->lpVtbl -> MakeAndOr(This,nodeType,pSubConditions,simplify,ppResultQuery)

#define IConditionFactory_MakeLeaf(This,pszPropertyName,op,pszValueType,pValue,pPropertyNameTerm,pOperationTerm,pValueTerm,expand,ppResultQuery)	\
    (This)->lpVtbl -> MakeLeaf(This,pszPropertyName,op,pszValueType,pValue,pPropertyNameTerm,pOperationTerm,pValueTerm,expand,ppResultQuery)

#define IConditionFactory_Resolve(This,pConditionTree,sqro,pstReferenceTime,ppResolvedConditionTree)	\
    (This)->lpVtbl -> Resolve(This,pConditionTree,sqro,pstReferenceTime,ppResolvedConditionTree)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IConditionFactory_MakeNot_Proxy( 
    IConditionFactory __RPC_FAR * This,
    /* [in] */ ICondition __RPC_FAR *pSubCondition,
    /* [in] */ BOOL simplify,
    /* [retval][out] */ ICondition __RPC_FAR *__RPC_FAR *ppResultQuery);


void __RPC_STUB IConditionFactory_MakeNot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IConditionFactory_MakeAndOr_Proxy( 
    IConditionFactory __RPC_FAR * This,
    /* [in] */ CONDITION_TYPE nodeType,
    /* [in] */ IEnumUnknown __RPC_FAR *pSubConditions,
    /* [in] */ BOOL simplify,
    /* [retval][out] */ ICondition __RPC_FAR *__RPC_FAR *ppResultQuery);


void __RPC_STUB IConditionFactory_MakeAndOr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IConditionFactory_MakeLeaf_Proxy( 
    IConditionFactory __RPC_FAR * This,
    /* [unique][in] */ LPCWSTR pszPropertyName,
    /* [in] */ CONDITION_OPERATION op,
    /* [unique][in] */ LPCWSTR pszValueType,
    /* [in] */ const PROPVARIANT __RPC_FAR *pValue,
    /* [in] */ IRichChunk __RPC_FAR *pPropertyNameTerm,
    /* [in] */ IRichChunk __RPC_FAR *pOperationTerm,
    /* [in] */ IRichChunk __RPC_FAR *pValueTerm,
    /* [in] */ BOOL expand,
    /* [retval][out] */ ICondition __RPC_FAR *__RPC_FAR *ppResultQuery);


void __RPC_STUB IConditionFactory_MakeLeaf_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ HRESULT STDMETHODCALLTYPE IConditionFactory_Resolve_Proxy( 
    IConditionFactory __RPC_FAR * This,
    /* [in] */ ICondition __RPC_FAR *pConditionTree,
    /* [in] */ STRUCTURED_QUERY_RESOLVE_OPTION sqro,
    /* [ref][in] */ const SYSTEMTIME __RPC_FAR *pstReferenceTime,
    /* [retval][out] */ ICondition __RPC_FAR *__RPC_FAR *ppResolvedConditionTree);


void __RPC_STUB IConditionFactory_Resolve_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IConditionFactory_INTERFACE_DEFINED__ */


#ifndef __IQuerySolution_INTERFACE_DEFINED__
#define __IQuerySolution_INTERFACE_DEFINED__

/* interface IQuerySolution */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IQuerySolution;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D6EBC66B-8921-4193-AFDD-A1789FB7FF57")
    IQuerySolution : public IConditionFactory
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetQuery( 
            /* [out] */ ICondition __RPC_FAR *__RPC_FAR *ppQueryNode,
            /* [out] */ IEntity __RPC_FAR *__RPC_FAR *ppMainType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetErrors( 
            /* [in] */ REFIID riid,
            /* [iid_is][retval][out] */ void __RPC_FAR *__RPC_FAR *ppParseErrors) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetLexicalData( 
            /* [out] */ LPWSTR __RPC_FAR *ppszInputString,
            /* [out] */ ITokenCollection __RPC_FAR *__RPC_FAR *ppTokens,
            /* [out] */ LCID __RPC_FAR *pLocale,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppWordBreaker) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IQuerySolutionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IQuerySolution __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IQuerySolution __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IQuerySolution __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MakeNot )( 
            IQuerySolution __RPC_FAR * This,
            /* [in] */ ICondition __RPC_FAR *pSubCondition,
            /* [in] */ BOOL simplify,
            /* [retval][out] */ ICondition __RPC_FAR *__RPC_FAR *ppResultQuery);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MakeAndOr )( 
            IQuerySolution __RPC_FAR * This,
            /* [in] */ CONDITION_TYPE nodeType,
            /* [in] */ IEnumUnknown __RPC_FAR *pSubConditions,
            /* [in] */ BOOL simplify,
            /* [retval][out] */ ICondition __RPC_FAR *__RPC_FAR *ppResultQuery);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MakeLeaf )( 
            IQuerySolution __RPC_FAR * This,
            /* [unique][in] */ LPCWSTR pszPropertyName,
            /* [in] */ CONDITION_OPERATION op,
            /* [unique][in] */ LPCWSTR pszValueType,
            /* [in] */ const PROPVARIANT __RPC_FAR *pValue,
            /* [in] */ IRichChunk __RPC_FAR *pPropertyNameTerm,
            /* [in] */ IRichChunk __RPC_FAR *pOperationTerm,
            /* [in] */ IRichChunk __RPC_FAR *pValueTerm,
            /* [in] */ BOOL expand,
            /* [retval][out] */ ICondition __RPC_FAR *__RPC_FAR *ppResultQuery);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Resolve )( 
            IQuerySolution __RPC_FAR * This,
            /* [in] */ ICondition __RPC_FAR *pConditionTree,
            /* [in] */ STRUCTURED_QUERY_RESOLVE_OPTION sqro,
            /* [ref][in] */ const SYSTEMTIME __RPC_FAR *pstReferenceTime,
            /* [retval][out] */ ICondition __RPC_FAR *__RPC_FAR *ppResolvedConditionTree);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetQuery )( 
            IQuerySolution __RPC_FAR * This,
            /* [out] */ ICondition __RPC_FAR *__RPC_FAR *ppQueryNode,
            /* [out] */ IEntity __RPC_FAR *__RPC_FAR *ppMainType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetErrors )( 
            IQuerySolution __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][retval][out] */ void __RPC_FAR *__RPC_FAR *ppParseErrors);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLexicalData )( 
            IQuerySolution __RPC_FAR * This,
            /* [out] */ LPWSTR __RPC_FAR *ppszInputString,
            /* [out] */ ITokenCollection __RPC_FAR *__RPC_FAR *ppTokens,
            /* [out] */ LCID __RPC_FAR *pLocale,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppWordBreaker);
        
        END_INTERFACE
    } IQuerySolutionVtbl;

    interface IQuerySolution
    {
        CONST_VTBL struct IQuerySolutionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IQuerySolution_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IQuerySolution_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IQuerySolution_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IQuerySolution_MakeNot(This,pSubCondition,simplify,ppResultQuery)	\
    (This)->lpVtbl -> MakeNot(This,pSubCondition,simplify,ppResultQuery)

#define IQuerySolution_MakeAndOr(This,nodeType,pSubConditions,simplify,ppResultQuery)	\
    (This)->lpVtbl -> MakeAndOr(This,nodeType,pSubConditions,simplify,ppResultQuery)

#define IQuerySolution_MakeLeaf(This,pszPropertyName,op,pszValueType,pValue,pPropertyNameTerm,pOperationTerm,pValueTerm,expand,ppResultQuery)	\
    (This)->lpVtbl -> MakeLeaf(This,pszPropertyName,op,pszValueType,pValue,pPropertyNameTerm,pOperationTerm,pValueTerm,expand,ppResultQuery)

#define IQuerySolution_Resolve(This,pConditionTree,sqro,pstReferenceTime,ppResolvedConditionTree)	\
    (This)->lpVtbl -> Resolve(This,pConditionTree,sqro,pstReferenceTime,ppResolvedConditionTree)


#define IQuerySolution_GetQuery(This,ppQueryNode,ppMainType)	\
    (This)->lpVtbl -> GetQuery(This,ppQueryNode,ppMainType)

#define IQuerySolution_GetErrors(This,riid,ppParseErrors)	\
    (This)->lpVtbl -> GetErrors(This,riid,ppParseErrors)

#define IQuerySolution_GetLexicalData(This,ppszInputString,ppTokens,pLocale,ppWordBreaker)	\
    (This)->lpVtbl -> GetLexicalData(This,ppszInputString,ppTokens,pLocale,ppWordBreaker)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [local] */ HRESULT STDMETHODCALLTYPE IQuerySolution_GetQuery_Proxy( 
    IQuerySolution __RPC_FAR * This,
    /* [out] */ ICondition __RPC_FAR *__RPC_FAR *ppQueryNode,
    /* [out] */ IEntity __RPC_FAR *__RPC_FAR *ppMainType);


void __RPC_STUB IQuerySolution_GetQuery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IQuerySolution_GetErrors_Proxy( 
    IQuerySolution __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][retval][out] */ void __RPC_FAR *__RPC_FAR *ppParseErrors);


void __RPC_STUB IQuerySolution_GetErrors_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ HRESULT STDMETHODCALLTYPE IQuerySolution_GetLexicalData_Proxy( 
    IQuerySolution __RPC_FAR * This,
    /* [out] */ LPWSTR __RPC_FAR *ppszInputString,
    /* [out] */ ITokenCollection __RPC_FAR *__RPC_FAR *ppTokens,
    /* [out] */ LCID __RPC_FAR *pLocale,
    /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppWordBreaker);


void __RPC_STUB IQuerySolution_GetLexicalData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IQuerySolution_INTERFACE_DEFINED__ */


#ifndef __ICondition_INTERFACE_DEFINED__
#define __ICondition_INTERFACE_DEFINED__

/* interface ICondition */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICondition;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0FC988D4-C935-4b97-A973-46282EA175C8")
    ICondition : public IPersistStream
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetConditionType( 
            /* [retval][out] */ CONDITION_TYPE __RPC_FAR *pNodeType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSubConditions( 
            /* [in] */ REFIID riid,
            /* [iid_is][retval][out] */ void __RPC_FAR *__RPC_FAR *ppv) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetComparisonInfo( 
            /* [out] */ LPWSTR __RPC_FAR *ppszPropertyName,
            /* [out] */ CONDITION_OPERATION __RPC_FAR *pOperation,
            /* [out] */ PROPVARIANT __RPC_FAR *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValueType( 
            /* [retval][out] */ LPWSTR __RPC_FAR *ppszValueTypeName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValueNormalization( 
            /* [retval][out] */ LPWSTR __RPC_FAR *ppszNormalization) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetInputTerms( 
            /* [out] */ IRichChunk __RPC_FAR *__RPC_FAR *ppPropertyTerm,
            /* [out] */ IRichChunk __RPC_FAR *__RPC_FAR *ppOperationTerm,
            /* [out] */ IRichChunk __RPC_FAR *__RPC_FAR *ppValueTerm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ ICondition __RPC_FAR *__RPC_FAR *ppc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IConditionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICondition __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICondition __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICondition __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClassID )( 
            ICondition __RPC_FAR * This,
            /* [out] */ CLSID __RPC_FAR *pClassID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsDirty )( 
            ICondition __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Load )( 
            ICondition __RPC_FAR * This,
            /* [unique][in] */ IStream __RPC_FAR *pStm);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Save )( 
            ICondition __RPC_FAR * This,
            /* [unique][in] */ IStream __RPC_FAR *pStm,
            /* [in] */ BOOL fClearDirty);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSizeMax )( 
            ICondition __RPC_FAR * This,
            /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConditionType )( 
            ICondition __RPC_FAR * This,
            /* [retval][out] */ CONDITION_TYPE __RPC_FAR *pNodeType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSubConditions )( 
            ICondition __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][retval][out] */ void __RPC_FAR *__RPC_FAR *ppv);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetComparisonInfo )( 
            ICondition __RPC_FAR * This,
            /* [out] */ LPWSTR __RPC_FAR *ppszPropertyName,
            /* [out] */ CONDITION_OPERATION __RPC_FAR *pOperation,
            /* [out] */ PROPVARIANT __RPC_FAR *pValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetValueType )( 
            ICondition __RPC_FAR * This,
            /* [retval][out] */ LPWSTR __RPC_FAR *ppszValueTypeName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetValueNormalization )( 
            ICondition __RPC_FAR * This,
            /* [retval][out] */ LPWSTR __RPC_FAR *ppszNormalization);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInputTerms )( 
            ICondition __RPC_FAR * This,
            /* [out] */ IRichChunk __RPC_FAR *__RPC_FAR *ppPropertyTerm,
            /* [out] */ IRichChunk __RPC_FAR *__RPC_FAR *ppOperationTerm,
            /* [out] */ IRichChunk __RPC_FAR *__RPC_FAR *ppValueTerm);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            ICondition __RPC_FAR * This,
            /* [retval][out] */ ICondition __RPC_FAR *__RPC_FAR *ppc);
        
        END_INTERFACE
    } IConditionVtbl;

    interface ICondition
    {
        CONST_VTBL struct IConditionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICondition_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICondition_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICondition_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICondition_GetClassID(This,pClassID)	\
    (This)->lpVtbl -> GetClassID(This,pClassID)


#define ICondition_IsDirty(This)	\
    (This)->lpVtbl -> IsDirty(This)

#define ICondition_Load(This,pStm)	\
    (This)->lpVtbl -> Load(This,pStm)

#define ICondition_Save(This,pStm,fClearDirty)	\
    (This)->lpVtbl -> Save(This,pStm,fClearDirty)

#define ICondition_GetSizeMax(This,pcbSize)	\
    (This)->lpVtbl -> GetSizeMax(This,pcbSize)


#define ICondition_GetConditionType(This,pNodeType)	\
    (This)->lpVtbl -> GetConditionType(This,pNodeType)

#define ICondition_GetSubConditions(This,riid,ppv)	\
    (This)->lpVtbl -> GetSubConditions(This,riid,ppv)

#define ICondition_GetComparisonInfo(This,ppszPropertyName,pOperation,pValue)	\
    (This)->lpVtbl -> GetComparisonInfo(This,ppszPropertyName,pOperation,pValue)

#define ICondition_GetValueType(This,ppszValueTypeName)	\
    (This)->lpVtbl -> GetValueType(This,ppszValueTypeName)

#define ICondition_GetValueNormalization(This,ppszNormalization)	\
    (This)->lpVtbl -> GetValueNormalization(This,ppszNormalization)

#define ICondition_GetInputTerms(This,ppPropertyTerm,ppOperationTerm,ppValueTerm)	\
    (This)->lpVtbl -> GetInputTerms(This,ppPropertyTerm,ppOperationTerm,ppValueTerm)

#define ICondition_Clone(This,ppc)	\
    (This)->lpVtbl -> Clone(This,ppc)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICondition_GetConditionType_Proxy( 
    ICondition __RPC_FAR * This,
    /* [retval][out] */ CONDITION_TYPE __RPC_FAR *pNodeType);


void __RPC_STUB ICondition_GetConditionType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICondition_GetSubConditions_Proxy( 
    ICondition __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][retval][out] */ void __RPC_FAR *__RPC_FAR *ppv);


void __RPC_STUB ICondition_GetSubConditions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ HRESULT STDMETHODCALLTYPE ICondition_GetComparisonInfo_Proxy( 
    ICondition __RPC_FAR * This,
    /* [out] */ LPWSTR __RPC_FAR *ppszPropertyName,
    /* [out] */ CONDITION_OPERATION __RPC_FAR *pOperation,
    /* [out] */ PROPVARIANT __RPC_FAR *pValue);


void __RPC_STUB ICondition_GetComparisonInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICondition_GetValueType_Proxy( 
    ICondition __RPC_FAR * This,
    /* [retval][out] */ LPWSTR __RPC_FAR *ppszValueTypeName);


void __RPC_STUB ICondition_GetValueType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICondition_GetValueNormalization_Proxy( 
    ICondition __RPC_FAR * This,
    /* [retval][out] */ LPWSTR __RPC_FAR *ppszNormalization);


void __RPC_STUB ICondition_GetValueNormalization_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ HRESULT STDMETHODCALLTYPE ICondition_GetInputTerms_Proxy( 
    ICondition __RPC_FAR * This,
    /* [out] */ IRichChunk __RPC_FAR *__RPC_FAR *ppPropertyTerm,
    /* [out] */ IRichChunk __RPC_FAR *__RPC_FAR *ppOperationTerm,
    /* [out] */ IRichChunk __RPC_FAR *__RPC_FAR *ppValueTerm);


void __RPC_STUB ICondition_GetInputTerms_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICondition_Clone_Proxy( 
    ICondition __RPC_FAR * This,
    /* [retval][out] */ ICondition __RPC_FAR *__RPC_FAR *ppc);


void __RPC_STUB ICondition_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICondition_INTERFACE_DEFINED__ */


#ifndef __IConditionGenerator_INTERFACE_DEFINED__
#define __IConditionGenerator_INTERFACE_DEFINED__

/* interface IConditionGenerator */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IConditionGenerator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("92D2CC58-4386-45a3-B98C-7E0CE64A4117")
    IConditionGenerator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ ISchemaProvider __RPC_FAR *pSchemaProvider) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RecognizeNamedEntities( 
            /* [in] */ LPCWSTR pszInputString,
            /* [in] */ LCID lcid,
            /* [in] */ ITokenCollection __RPC_FAR *pTokenCollection,
            /* [out][in] */ INamedEntityCollector __RPC_FAR *pNamedEntities) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GenerateForLeaf( 
            /* [in] */ IConditionFactory __RPC_FAR *pConditionFactory,
            /* [unique][in] */ LPCWSTR pszPropertyName,
            /* [in] */ CONDITION_OPERATION op,
            /* [unique][in] */ LPCWSTR pszValueType,
            /* [in] */ LPCWSTR pszValue,
            /* [unique][in] */ LPCWSTR pszValue2,
            /* [in] */ IRichChunk __RPC_FAR *pPropertyNameTerm,
            /* [in] */ IRichChunk __RPC_FAR *pOperationTerm,
            /* [in] */ IRichChunk __RPC_FAR *pValueTerm,
            /* [in] */ BOOL automaticWildcard,
            /* [out] */ BOOL __RPC_FAR *pNoStringQuery,
            /* [retval][out] */ ICondition __RPC_FAR *__RPC_FAR *ppQueryExpression) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE DefaultPhrase( 
            /* [unique][in] */ LPCWSTR pszValueType,
            /* [in] */ const PROPVARIANT __RPC_FAR *ppropvar,
            /* [in] */ BOOL fUseEnglish,
            /* [retval][out] */ LPWSTR __RPC_FAR *ppszPhrase) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IConditionGeneratorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IConditionGenerator __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IConditionGenerator __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IConditionGenerator __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IConditionGenerator __RPC_FAR * This,
            /* [in] */ ISchemaProvider __RPC_FAR *pSchemaProvider);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RecognizeNamedEntities )( 
            IConditionGenerator __RPC_FAR * This,
            /* [in] */ LPCWSTR pszInputString,
            /* [in] */ LCID lcid,
            /* [in] */ ITokenCollection __RPC_FAR *pTokenCollection,
            /* [out][in] */ INamedEntityCollector __RPC_FAR *pNamedEntities);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GenerateForLeaf )( 
            IConditionGenerator __RPC_FAR * This,
            /* [in] */ IConditionFactory __RPC_FAR *pConditionFactory,
            /* [unique][in] */ LPCWSTR pszPropertyName,
            /* [in] */ CONDITION_OPERATION op,
            /* [unique][in] */ LPCWSTR pszValueType,
            /* [in] */ LPCWSTR pszValue,
            /* [unique][in] */ LPCWSTR pszValue2,
            /* [in] */ IRichChunk __RPC_FAR *pPropertyNameTerm,
            /* [in] */ IRichChunk __RPC_FAR *pOperationTerm,
            /* [in] */ IRichChunk __RPC_FAR *pValueTerm,
            /* [in] */ BOOL automaticWildcard,
            /* [out] */ BOOL __RPC_FAR *pNoStringQuery,
            /* [retval][out] */ ICondition __RPC_FAR *__RPC_FAR *ppQueryExpression);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DefaultPhrase )( 
            IConditionGenerator __RPC_FAR * This,
            /* [unique][in] */ LPCWSTR pszValueType,
            /* [in] */ const PROPVARIANT __RPC_FAR *ppropvar,
            /* [in] */ BOOL fUseEnglish,
            /* [retval][out] */ LPWSTR __RPC_FAR *ppszPhrase);
        
        END_INTERFACE
    } IConditionGeneratorVtbl;

    interface IConditionGenerator
    {
        CONST_VTBL struct IConditionGeneratorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IConditionGenerator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IConditionGenerator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IConditionGenerator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IConditionGenerator_Initialize(This,pSchemaProvider)	\
    (This)->lpVtbl -> Initialize(This,pSchemaProvider)

#define IConditionGenerator_RecognizeNamedEntities(This,pszInputString,lcid,pTokenCollection,pNamedEntities)	\
    (This)->lpVtbl -> RecognizeNamedEntities(This,pszInputString,lcid,pTokenCollection,pNamedEntities)

#define IConditionGenerator_GenerateForLeaf(This,pConditionFactory,pszPropertyName,op,pszValueType,pszValue,pszValue2,pPropertyNameTerm,pOperationTerm,pValueTerm,automaticWildcard,pNoStringQuery,ppQueryExpression)	\
    (This)->lpVtbl -> GenerateForLeaf(This,pConditionFactory,pszPropertyName,op,pszValueType,pszValue,pszValue2,pPropertyNameTerm,pOperationTerm,pValueTerm,automaticWildcard,pNoStringQuery,ppQueryExpression)

#define IConditionGenerator_DefaultPhrase(This,pszValueType,ppropvar,fUseEnglish,ppszPhrase)	\
    (This)->lpVtbl -> DefaultPhrase(This,pszValueType,ppropvar,fUseEnglish,ppszPhrase)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IConditionGenerator_Initialize_Proxy( 
    IConditionGenerator __RPC_FAR * This,
    /* [in] */ ISchemaProvider __RPC_FAR *pSchemaProvider);


void __RPC_STUB IConditionGenerator_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IConditionGenerator_RecognizeNamedEntities_Proxy( 
    IConditionGenerator __RPC_FAR * This,
    /* [in] */ LPCWSTR pszInputString,
    /* [in] */ LCID lcid,
    /* [in] */ ITokenCollection __RPC_FAR *pTokenCollection,
    /* [out][in] */ INamedEntityCollector __RPC_FAR *pNamedEntities);


void __RPC_STUB IConditionGenerator_RecognizeNamedEntities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IConditionGenerator_GenerateForLeaf_Proxy( 
    IConditionGenerator __RPC_FAR * This,
    /* [in] */ IConditionFactory __RPC_FAR *pConditionFactory,
    /* [unique][in] */ LPCWSTR pszPropertyName,
    /* [in] */ CONDITION_OPERATION op,
    /* [unique][in] */ LPCWSTR pszValueType,
    /* [in] */ LPCWSTR pszValue,
    /* [unique][in] */ LPCWSTR pszValue2,
    /* [in] */ IRichChunk __RPC_FAR *pPropertyNameTerm,
    /* [in] */ IRichChunk __RPC_FAR *pOperationTerm,
    /* [in] */ IRichChunk __RPC_FAR *pValueTerm,
    /* [in] */ BOOL automaticWildcard,
    /* [out] */ BOOL __RPC_FAR *pNoStringQuery,
    /* [retval][out] */ ICondition __RPC_FAR *__RPC_FAR *ppQueryExpression);


void __RPC_STUB IConditionGenerator_GenerateForLeaf_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ HRESULT STDMETHODCALLTYPE IConditionGenerator_DefaultPhrase_Proxy( 
    IConditionGenerator __RPC_FAR * This,
    /* [unique][in] */ LPCWSTR pszValueType,
    /* [in] */ const PROPVARIANT __RPC_FAR *ppropvar,
    /* [in] */ BOOL fUseEnglish,
    /* [retval][out] */ LPWSTR __RPC_FAR *ppszPhrase);


void __RPC_STUB IConditionGenerator_DefaultPhrase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IConditionGenerator_INTERFACE_DEFINED__ */


#ifndef __IRichChunk_INTERFACE_DEFINED__
#define __IRichChunk_INTERFACE_DEFINED__

/* interface IRichChunk */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IRichChunk;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4FDEF69C-DBC9-454e-9910-B34F3C64B510")
    IRichChunk : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetData( 
            /* [out] */ ULONG __RPC_FAR *pFirstPos,
            /* [out] */ ULONG __RPC_FAR *pLength,
            /* [out] */ LPWSTR __RPC_FAR *ppsz,
            /* [out] */ PROPVARIANT __RPC_FAR *pValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRichChunkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRichChunk __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRichChunk __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRichChunk __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetData )( 
            IRichChunk __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pFirstPos,
            /* [out] */ ULONG __RPC_FAR *pLength,
            /* [out] */ LPWSTR __RPC_FAR *ppsz,
            /* [out] */ PROPVARIANT __RPC_FAR *pValue);
        
        END_INTERFACE
    } IRichChunkVtbl;

    interface IRichChunk
    {
        CONST_VTBL struct IRichChunkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRichChunk_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRichChunk_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRichChunk_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRichChunk_GetData(This,pFirstPos,pLength,ppsz,pValue)	\
    (This)->lpVtbl -> GetData(This,pFirstPos,pLength,ppsz,pValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [local] */ HRESULT STDMETHODCALLTYPE IRichChunk_GetData_Proxy( 
    IRichChunk __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pFirstPos,
    /* [out] */ ULONG __RPC_FAR *pLength,
    /* [out] */ LPWSTR __RPC_FAR *ppsz,
    /* [out] */ PROPVARIANT __RPC_FAR *pValue);


void __RPC_STUB IRichChunk_GetData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRichChunk_INTERFACE_DEFINED__ */


#ifndef __IInterval_INTERFACE_DEFINED__
#define __IInterval_INTERFACE_DEFINED__

/* interface IInterval */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IInterval;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6BF0A714-3C18-430b-8B5D-83B1C234D3DB")
    IInterval : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetLimits( 
            /* [out] */ INTERVAL_LIMIT_KIND __RPC_FAR *pilkLower,
            /* [out] */ PROPVARIANT __RPC_FAR *ppropvarLower,
            /* [out] */ INTERVAL_LIMIT_KIND __RPC_FAR *pilkUpper,
            /* [out] */ PROPVARIANT __RPC_FAR *ppropvarUpper) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IIntervalVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IInterval __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IInterval __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IInterval __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLimits )( 
            IInterval __RPC_FAR * This,
            /* [out] */ INTERVAL_LIMIT_KIND __RPC_FAR *pilkLower,
            /* [out] */ PROPVARIANT __RPC_FAR *ppropvarLower,
            /* [out] */ INTERVAL_LIMIT_KIND __RPC_FAR *pilkUpper,
            /* [out] */ PROPVARIANT __RPC_FAR *ppropvarUpper);
        
        END_INTERFACE
    } IIntervalVtbl;

    interface IInterval
    {
        CONST_VTBL struct IIntervalVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInterval_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInterval_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInterval_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInterval_GetLimits(This,pilkLower,ppropvarLower,pilkUpper,ppropvarUpper)	\
    (This)->lpVtbl -> GetLimits(This,pilkLower,ppropvarLower,pilkUpper,ppropvarUpper)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IInterval_GetLimits_Proxy( 
    IInterval __RPC_FAR * This,
    /* [out] */ INTERVAL_LIMIT_KIND __RPC_FAR *pilkLower,
    /* [out] */ PROPVARIANT __RPC_FAR *ppropvarLower,
    /* [out] */ INTERVAL_LIMIT_KIND __RPC_FAR *pilkUpper,
    /* [out] */ PROPVARIANT __RPC_FAR *ppropvarUpper);


void __RPC_STUB IInterval_GetLimits_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IInterval_INTERFACE_DEFINED__ */


#ifndef __IMetaData_INTERFACE_DEFINED__
#define __IMetaData_INTERFACE_DEFINED__

/* interface IMetaData */
/* [unique][uuid][object][helpstring] */ 


EXTERN_C const IID IID_IMetaData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("780102B0-C43B-4876-BC7B-5E9BA5C88794")
    IMetaData : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetData( 
            /* [out] */ LPWSTR __RPC_FAR *ppszKey,
            /* [out] */ LPWSTR __RPC_FAR *ppszValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMetaDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMetaData __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMetaData __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMetaData __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetData )( 
            IMetaData __RPC_FAR * This,
            /* [out] */ LPWSTR __RPC_FAR *ppszKey,
            /* [out] */ LPWSTR __RPC_FAR *ppszValue);
        
        END_INTERFACE
    } IMetaDataVtbl;

    interface IMetaData
    {
        CONST_VTBL struct IMetaDataVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMetaData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMetaData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMetaData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMetaData_GetData(This,ppszKey,ppszValue)	\
    (This)->lpVtbl -> GetData(This,ppszKey,ppszValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [local] */ HRESULT STDMETHODCALLTYPE IMetaData_GetData_Proxy( 
    IMetaData __RPC_FAR * This,
    /* [out] */ LPWSTR __RPC_FAR *ppszKey,
    /* [out] */ LPWSTR __RPC_FAR *ppszValue);


void __RPC_STUB IMetaData_GetData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMetaData_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_structuredquery_0164 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_structuredquery_0164_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_structuredquery_0164_v0_0_s_ifspec;

#ifndef __IEntity_INTERFACE_DEFINED__
#define __IEntity_INTERFACE_DEFINED__

/* interface IEntity */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IEntity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("24264891-E80B-4fd3-B7CE-4FF2FAE8931F")
    IEntity : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Name( 
            /* [retval][out] */ LPWSTR __RPC_FAR *ppszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Base( 
            /* [retval][out] */ IEntity __RPC_FAR *__RPC_FAR *pBaseEntity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Relationships( 
            /* [in] */ REFIID riid,
            /* [iid_is][retval][out] */ void __RPC_FAR *__RPC_FAR *pRelationships) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRelationship( 
            /* [in] */ LPCWSTR pszRelationName,
            /* [retval][out] */ IRelationship __RPC_FAR *__RPC_FAR *pRelationship) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MetaData( 
            /* [in] */ REFIID riid,
            /* [iid_is][retval][out] */ void __RPC_FAR *__RPC_FAR *pMetaData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NamedEntities( 
            /* [in] */ REFIID riid,
            /* [iid_is][retval][out] */ void __RPC_FAR *__RPC_FAR *pNamedEntities) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNamedEntity( 
            /* [in] */ LPCWSTR pszValue,
            /* [retval][out] */ INamedEntity __RPC_FAR *__RPC_FAR *ppNamedEntity) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE DefaultPhrase( 
            /* [retval][out] */ LPWSTR __RPC_FAR *ppszPhrase) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEntityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEntity __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEntity __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEntity __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Name )( 
            IEntity __RPC_FAR * This,
            /* [retval][out] */ LPWSTR __RPC_FAR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Base )( 
            IEntity __RPC_FAR * This,
            /* [retval][out] */ IEntity __RPC_FAR *__RPC_FAR *pBaseEntity);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Relationships )( 
            IEntity __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][retval][out] */ void __RPC_FAR *__RPC_FAR *pRelationships);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRelationship )( 
            IEntity __RPC_FAR * This,
            /* [in] */ LPCWSTR pszRelationName,
            /* [retval][out] */ IRelationship __RPC_FAR *__RPC_FAR *pRelationship);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MetaData )( 
            IEntity __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][retval][out] */ void __RPC_FAR *__RPC_FAR *pMetaData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NamedEntities )( 
            IEntity __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][retval][out] */ void __RPC_FAR *__RPC_FAR *pNamedEntities);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNamedEntity )( 
            IEntity __RPC_FAR * This,
            /* [in] */ LPCWSTR pszValue,
            /* [retval][out] */ INamedEntity __RPC_FAR *__RPC_FAR *ppNamedEntity);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DefaultPhrase )( 
            IEntity __RPC_FAR * This,
            /* [retval][out] */ LPWSTR __RPC_FAR *ppszPhrase);
        
        END_INTERFACE
    } IEntityVtbl;

    interface IEntity
    {
        CONST_VTBL struct IEntityVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEntity_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEntity_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEntity_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEntity_Name(This,ppszName)	\
    (This)->lpVtbl -> Name(This,ppszName)

#define IEntity_Base(This,pBaseEntity)	\
    (This)->lpVtbl -> Base(This,pBaseEntity)

#define IEntity_Relationships(This,riid,pRelationships)	\
    (This)->lpVtbl -> Relationships(This,riid,pRelationships)

#define IEntity_GetRelationship(This,pszRelationName,pRelationship)	\
    (This)->lpVtbl -> GetRelationship(This,pszRelationName,pRelationship)

#define IEntity_MetaData(This,riid,pMetaData)	\
    (This)->lpVtbl -> MetaData(This,riid,pMetaData)

#define IEntity_NamedEntities(This,riid,pNamedEntities)	\
    (This)->lpVtbl -> NamedEntities(This,riid,pNamedEntities)

#define IEntity_GetNamedEntity(This,pszValue,ppNamedEntity)	\
    (This)->lpVtbl -> GetNamedEntity(This,pszValue,ppNamedEntity)

#define IEntity_DefaultPhrase(This,ppszPhrase)	\
    (This)->lpVtbl -> DefaultPhrase(This,ppszPhrase)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [local] */ HRESULT STDMETHODCALLTYPE IEntity_Name_Proxy( 
    IEntity __RPC_FAR * This,
    /* [retval][out] */ LPWSTR __RPC_FAR *ppszName);


void __RPC_STUB IEntity_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEntity_Base_Proxy( 
    IEntity __RPC_FAR * This,
    /* [retval][out] */ IEntity __RPC_FAR *__RPC_FAR *pBaseEntity);


void __RPC_STUB IEntity_Base_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEntity_Relationships_Proxy( 
    IEntity __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][retval][out] */ void __RPC_FAR *__RPC_FAR *pRelationships);


void __RPC_STUB IEntity_Relationships_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEntity_GetRelationship_Proxy( 
    IEntity __RPC_FAR * This,
    /* [in] */ LPCWSTR pszRelationName,
    /* [retval][out] */ IRelationship __RPC_FAR *__RPC_FAR *pRelationship);


void __RPC_STUB IEntity_GetRelationship_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEntity_MetaData_Proxy( 
    IEntity __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][retval][out] */ void __RPC_FAR *__RPC_FAR *pMetaData);


void __RPC_STUB IEntity_MetaData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEntity_NamedEntities_Proxy( 
    IEntity __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][retval][out] */ void __RPC_FAR *__RPC_FAR *pNamedEntities);


void __RPC_STUB IEntity_NamedEntities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEntity_GetNamedEntity_Proxy( 
    IEntity __RPC_FAR * This,
    /* [in] */ LPCWSTR pszValue,
    /* [retval][out] */ INamedEntity __RPC_FAR *__RPC_FAR *ppNamedEntity);


void __RPC_STUB IEntity_GetNamedEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ HRESULT STDMETHODCALLTYPE IEntity_DefaultPhrase_Proxy( 
    IEntity __RPC_FAR * This,
    /* [retval][out] */ LPWSTR __RPC_FAR *ppszPhrase);


void __RPC_STUB IEntity_DefaultPhrase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEntity_INTERFACE_DEFINED__ */


#ifndef __IRelationship_INTERFACE_DEFINED__
#define __IRelationship_INTERFACE_DEFINED__

/* interface IRelationship */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IRelationship;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2769280B-5108-498c-9C7F-A51239B63147")
    IRelationship : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Name( 
            /* [retval][out] */ LPWSTR __RPC_FAR *ppszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsReal( 
            /* [retval][out] */ BOOL __RPC_FAR *pIsReal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Destination( 
            /* [retval][out] */ IEntity __RPC_FAR *__RPC_FAR *pDestinationEntity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MetaData( 
            /* [in] */ REFIID riid,
            /* [iid_is][retval][out] */ void __RPC_FAR *__RPC_FAR *pMetaData) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE DefaultPhrase( 
            /* [retval][out] */ LPWSTR __RPC_FAR *ppszPhrase) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRelationshipVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRelationship __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRelationship __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRelationship __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Name )( 
            IRelationship __RPC_FAR * This,
            /* [retval][out] */ LPWSTR __RPC_FAR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsReal )( 
            IRelationship __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pIsReal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Destination )( 
            IRelationship __RPC_FAR * This,
            /* [retval][out] */ IEntity __RPC_FAR *__RPC_FAR *pDestinationEntity);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MetaData )( 
            IRelationship __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][retval][out] */ void __RPC_FAR *__RPC_FAR *pMetaData);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DefaultPhrase )( 
            IRelationship __RPC_FAR * This,
            /* [retval][out] */ LPWSTR __RPC_FAR *ppszPhrase);
        
        END_INTERFACE
    } IRelationshipVtbl;

    interface IRelationship
    {
        CONST_VTBL struct IRelationshipVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRelationship_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRelationship_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRelationship_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRelationship_Name(This,ppszName)	\
    (This)->lpVtbl -> Name(This,ppszName)

#define IRelationship_IsReal(This,pIsReal)	\
    (This)->lpVtbl -> IsReal(This,pIsReal)

#define IRelationship_Destination(This,pDestinationEntity)	\
    (This)->lpVtbl -> Destination(This,pDestinationEntity)

#define IRelationship_MetaData(This,riid,pMetaData)	\
    (This)->lpVtbl -> MetaData(This,riid,pMetaData)

#define IRelationship_DefaultPhrase(This,ppszPhrase)	\
    (This)->lpVtbl -> DefaultPhrase(This,ppszPhrase)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [local] */ HRESULT STDMETHODCALLTYPE IRelationship_Name_Proxy( 
    IRelationship __RPC_FAR * This,
    /* [retval][out] */ LPWSTR __RPC_FAR *ppszName);


void __RPC_STUB IRelationship_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRelationship_IsReal_Proxy( 
    IRelationship __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pIsReal);


void __RPC_STUB IRelationship_IsReal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRelationship_Destination_Proxy( 
    IRelationship __RPC_FAR * This,
    /* [retval][out] */ IEntity __RPC_FAR *__RPC_FAR *pDestinationEntity);


void __RPC_STUB IRelationship_Destination_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRelationship_MetaData_Proxy( 
    IRelationship __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][retval][out] */ void __RPC_FAR *__RPC_FAR *pMetaData);


void __RPC_STUB IRelationship_MetaData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ HRESULT STDMETHODCALLTYPE IRelationship_DefaultPhrase_Proxy( 
    IRelationship __RPC_FAR * This,
    /* [retval][out] */ LPWSTR __RPC_FAR *ppszPhrase);


void __RPC_STUB IRelationship_DefaultPhrase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRelationship_INTERFACE_DEFINED__ */


#ifndef __INamedEntity_INTERFACE_DEFINED__
#define __INamedEntity_INTERFACE_DEFINED__

/* interface INamedEntity */
/* [unique][uuid][object][helpstring] */ 


EXTERN_C const IID IID_INamedEntity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ABDBD0B1-7D54-49fb-AB5C-BFF4130004CD")
    INamedEntity : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [retval][out] */ LPWSTR __RPC_FAR *ppszValue) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE DefaultPhrase( 
            /* [retval][out] */ LPWSTR __RPC_FAR *ppszPhrase) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INamedEntityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INamedEntity __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INamedEntity __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INamedEntity __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetValue )( 
            INamedEntity __RPC_FAR * This,
            /* [retval][out] */ LPWSTR __RPC_FAR *ppszValue);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DefaultPhrase )( 
            INamedEntity __RPC_FAR * This,
            /* [retval][out] */ LPWSTR __RPC_FAR *ppszPhrase);
        
        END_INTERFACE
    } INamedEntityVtbl;

    interface INamedEntity
    {
        CONST_VTBL struct INamedEntityVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INamedEntity_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INamedEntity_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INamedEntity_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INamedEntity_GetValue(This,ppszValue)	\
    (This)->lpVtbl -> GetValue(This,ppszValue)

#define INamedEntity_DefaultPhrase(This,ppszPhrase)	\
    (This)->lpVtbl -> DefaultPhrase(This,ppszPhrase)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INamedEntity_GetValue_Proxy( 
    INamedEntity __RPC_FAR * This,
    /* [retval][out] */ LPWSTR __RPC_FAR *ppszValue);


void __RPC_STUB INamedEntity_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ HRESULT STDMETHODCALLTYPE INamedEntity_DefaultPhrase_Proxy( 
    INamedEntity __RPC_FAR * This,
    /* [retval][out] */ LPWSTR __RPC_FAR *ppszPhrase);


void __RPC_STUB INamedEntity_DefaultPhrase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INamedEntity_INTERFACE_DEFINED__ */


#ifndef __ISchemaProvider_INTERFACE_DEFINED__
#define __ISchemaProvider_INTERFACE_DEFINED__

/* interface ISchemaProvider */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_ISchemaProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8CF89BCB-394C-49b2-AE28-A59DD4ED7F68")
    ISchemaProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Entities( 
            /* [in] */ REFIID riid,
            /* [iid_is][retval][out] */ void __RPC_FAR *__RPC_FAR *pEntities) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RootEntity( 
            /* [retval][out] */ IEntity __RPC_FAR *__RPC_FAR *pRootEntity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEntity( 
            /* [in] */ LPCWSTR pszEntityName,
            /* [retval][out] */ IEntity __RPC_FAR *__RPC_FAR *pEntity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MetaData( 
            /* [in] */ REFIID riid,
            /* [iid_is][retval][out] */ void __RPC_FAR *__RPC_FAR *pMetaData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Localize( 
            /* [in] */ LCID lcid,
            /* [in] */ ISchemaLocalizerSupport __RPC_FAR *pSchemaLocalizerSupport) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveBinary( 
            /* [in] */ LPCWSTR pszSchemaBinaryPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LookupAuthoredNamedEntity( 
            /* [in] */ IEntity __RPC_FAR *pEntity,
            /* [in] */ LPCWSTR pszInputString,
            /* [in] */ ITokenCollection __RPC_FAR *pTokenCollection,
            /* [in] */ ULONG cTokensBegin,
            /* [out] */ ULONG __RPC_FAR *pcTokensLength,
            /* [out] */ LPWSTR __RPC_FAR *ppszValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISchemaProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISchemaProvider __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISchemaProvider __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISchemaProvider __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Entities )( 
            ISchemaProvider __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][retval][out] */ void __RPC_FAR *__RPC_FAR *pEntities);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RootEntity )( 
            ISchemaProvider __RPC_FAR * This,
            /* [retval][out] */ IEntity __RPC_FAR *__RPC_FAR *pRootEntity);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEntity )( 
            ISchemaProvider __RPC_FAR * This,
            /* [in] */ LPCWSTR pszEntityName,
            /* [retval][out] */ IEntity __RPC_FAR *__RPC_FAR *pEntity);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MetaData )( 
            ISchemaProvider __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][retval][out] */ void __RPC_FAR *__RPC_FAR *pMetaData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Localize )( 
            ISchemaProvider __RPC_FAR * This,
            /* [in] */ LCID lcid,
            /* [in] */ ISchemaLocalizerSupport __RPC_FAR *pSchemaLocalizerSupport);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveBinary )( 
            ISchemaProvider __RPC_FAR * This,
            /* [in] */ LPCWSTR pszSchemaBinaryPath);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LookupAuthoredNamedEntity )( 
            ISchemaProvider __RPC_FAR * This,
            /* [in] */ IEntity __RPC_FAR *pEntity,
            /* [in] */ LPCWSTR pszInputString,
            /* [in] */ ITokenCollection __RPC_FAR *pTokenCollection,
            /* [in] */ ULONG cTokensBegin,
            /* [out] */ ULONG __RPC_FAR *pcTokensLength,
            /* [out] */ LPWSTR __RPC_FAR *ppszValue);
        
        END_INTERFACE
    } ISchemaProviderVtbl;

    interface ISchemaProvider
    {
        CONST_VTBL struct ISchemaProviderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISchemaProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISchemaProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISchemaProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISchemaProvider_Entities(This,riid,pEntities)	\
    (This)->lpVtbl -> Entities(This,riid,pEntities)

#define ISchemaProvider_RootEntity(This,pRootEntity)	\
    (This)->lpVtbl -> RootEntity(This,pRootEntity)

#define ISchemaProvider_GetEntity(This,pszEntityName,pEntity)	\
    (This)->lpVtbl -> GetEntity(This,pszEntityName,pEntity)

#define ISchemaProvider_MetaData(This,riid,pMetaData)	\
    (This)->lpVtbl -> MetaData(This,riid,pMetaData)

#define ISchemaProvider_Localize(This,lcid,pSchemaLocalizerSupport)	\
    (This)->lpVtbl -> Localize(This,lcid,pSchemaLocalizerSupport)

#define ISchemaProvider_SaveBinary(This,pszSchemaBinaryPath)	\
    (This)->lpVtbl -> SaveBinary(This,pszSchemaBinaryPath)

#define ISchemaProvider_LookupAuthoredNamedEntity(This,pEntity,pszInputString,pTokenCollection,cTokensBegin,pcTokensLength,ppszValue)	\
    (This)->lpVtbl -> LookupAuthoredNamedEntity(This,pEntity,pszInputString,pTokenCollection,cTokensBegin,pcTokensLength,ppszValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISchemaProvider_Entities_Proxy( 
    ISchemaProvider __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][retval][out] */ void __RPC_FAR *__RPC_FAR *pEntities);


void __RPC_STUB ISchemaProvider_Entities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISchemaProvider_RootEntity_Proxy( 
    ISchemaProvider __RPC_FAR * This,
    /* [retval][out] */ IEntity __RPC_FAR *__RPC_FAR *pRootEntity);


void __RPC_STUB ISchemaProvider_RootEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISchemaProvider_GetEntity_Proxy( 
    ISchemaProvider __RPC_FAR * This,
    /* [in] */ LPCWSTR pszEntityName,
    /* [retval][out] */ IEntity __RPC_FAR *__RPC_FAR *pEntity);


void __RPC_STUB ISchemaProvider_GetEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISchemaProvider_MetaData_Proxy( 
    ISchemaProvider __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][retval][out] */ void __RPC_FAR *__RPC_FAR *pMetaData);


void __RPC_STUB ISchemaProvider_MetaData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISchemaProvider_Localize_Proxy( 
    ISchemaProvider __RPC_FAR * This,
    /* [in] */ LCID lcid,
    /* [in] */ ISchemaLocalizerSupport __RPC_FAR *pSchemaLocalizerSupport);


void __RPC_STUB ISchemaProvider_Localize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISchemaProvider_SaveBinary_Proxy( 
    ISchemaProvider __RPC_FAR * This,
    /* [in] */ LPCWSTR pszSchemaBinaryPath);


void __RPC_STUB ISchemaProvider_SaveBinary_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISchemaProvider_LookupAuthoredNamedEntity_Proxy( 
    ISchemaProvider __RPC_FAR * This,
    /* [in] */ IEntity __RPC_FAR *pEntity,
    /* [in] */ LPCWSTR pszInputString,
    /* [in] */ ITokenCollection __RPC_FAR *pTokenCollection,
    /* [in] */ ULONG cTokensBegin,
    /* [out] */ ULONG __RPC_FAR *pcTokensLength,
    /* [out] */ LPWSTR __RPC_FAR *ppszValue);


void __RPC_STUB ISchemaProvider_LookupAuthoredNamedEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISchemaProvider_INTERFACE_DEFINED__ */


#ifndef __ITokenCollection_INTERFACE_DEFINED__
#define __ITokenCollection_INTERFACE_DEFINED__

/* interface ITokenCollection */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_ITokenCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("22D8B4F2-F577-4adb-A335-C2AE88416FAB")
    ITokenCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE NumberOfTokens( 
            ULONG __RPC_FAR *pCount) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetToken( 
            /* [in] */ ULONG i,
            /* [out] */ ULONG __RPC_FAR *pBegin,
            /* [out] */ ULONG __RPC_FAR *pLength,
            /* [out] */ LPWSTR __RPC_FAR *ppsz) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITokenCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITokenCollection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITokenCollection __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITokenCollection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NumberOfTokens )( 
            ITokenCollection __RPC_FAR * This,
            ULONG __RPC_FAR *pCount);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetToken )( 
            ITokenCollection __RPC_FAR * This,
            /* [in] */ ULONG i,
            /* [out] */ ULONG __RPC_FAR *pBegin,
            /* [out] */ ULONG __RPC_FAR *pLength,
            /* [out] */ LPWSTR __RPC_FAR *ppsz);
        
        END_INTERFACE
    } ITokenCollectionVtbl;

    interface ITokenCollection
    {
        CONST_VTBL struct ITokenCollectionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITokenCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITokenCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITokenCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITokenCollection_NumberOfTokens(This,pCount)	\
    (This)->lpVtbl -> NumberOfTokens(This,pCount)

#define ITokenCollection_GetToken(This,i,pBegin,pLength,ppsz)	\
    (This)->lpVtbl -> GetToken(This,i,pBegin,pLength,ppsz)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITokenCollection_NumberOfTokens_Proxy( 
    ITokenCollection __RPC_FAR * This,
    ULONG __RPC_FAR *pCount);


void __RPC_STUB ITokenCollection_NumberOfTokens_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ HRESULT STDMETHODCALLTYPE ITokenCollection_GetToken_Proxy( 
    ITokenCollection __RPC_FAR * This,
    /* [in] */ ULONG i,
    /* [out] */ ULONG __RPC_FAR *pBegin,
    /* [out] */ ULONG __RPC_FAR *pLength,
    /* [out] */ LPWSTR __RPC_FAR *ppsz);


void __RPC_STUB ITokenCollection_GetToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITokenCollection_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_structuredquery_0169 */
/* [local] */ 

typedef /* [public][public][v1_enum] */ 
enum __MIDL___MIDL_itf_structuredquery_0169_0001
    {	NEC_LOW	= 0,
	NEC_MEDIUM	= NEC_LOW + 1,
	NEC_HIGH	= NEC_MEDIUM + 1
    }	NAMED_ENTITY_CERTAINTY;



extern RPC_IF_HANDLE __MIDL_itf_structuredquery_0169_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_structuredquery_0169_v0_0_s_ifspec;

#ifndef __INamedEntityCollector_INTERFACE_DEFINED__
#define __INamedEntityCollector_INTERFACE_DEFINED__

/* interface INamedEntityCollector */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_INamedEntityCollector;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AF2440F6-8AFC-47d0-9A7F-396A0ACFB43D")
    INamedEntityCollector : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ ULONG beginSpan,
            /* [in] */ ULONG endSpan,
            /* [in] */ ULONG beginActual,
            /* [in] */ ULONG endActual,
            /* [in] */ IEntity __RPC_FAR *pType,
            /* [in] */ LPCWSTR pszValue,
            /* [in] */ NAMED_ENTITY_CERTAINTY certainty) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INamedEntityCollectorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INamedEntityCollector __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INamedEntityCollector __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INamedEntityCollector __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Add )( 
            INamedEntityCollector __RPC_FAR * This,
            /* [in] */ ULONG beginSpan,
            /* [in] */ ULONG endSpan,
            /* [in] */ ULONG beginActual,
            /* [in] */ ULONG endActual,
            /* [in] */ IEntity __RPC_FAR *pType,
            /* [in] */ LPCWSTR pszValue,
            /* [in] */ NAMED_ENTITY_CERTAINTY certainty);
        
        END_INTERFACE
    } INamedEntityCollectorVtbl;

    interface INamedEntityCollector
    {
        CONST_VTBL struct INamedEntityCollectorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INamedEntityCollector_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INamedEntityCollector_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INamedEntityCollector_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INamedEntityCollector_Add(This,beginSpan,endSpan,beginActual,endActual,pType,pszValue,certainty)	\
    (This)->lpVtbl -> Add(This,beginSpan,endSpan,beginActual,endActual,pType,pszValue,certainty)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INamedEntityCollector_Add_Proxy( 
    INamedEntityCollector __RPC_FAR * This,
    /* [in] */ ULONG beginSpan,
    /* [in] */ ULONG endSpan,
    /* [in] */ ULONG beginActual,
    /* [in] */ ULONG endActual,
    /* [in] */ IEntity __RPC_FAR *pType,
    /* [in] */ LPCWSTR pszValue,
    /* [in] */ NAMED_ENTITY_CERTAINTY certainty);


void __RPC_STUB INamedEntityCollector_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INamedEntityCollector_INTERFACE_DEFINED__ */


#ifndef __ISchemaLocalizerSupport_INTERFACE_DEFINED__
#define __ISchemaLocalizerSupport_INTERFACE_DEFINED__

/* interface ISchemaLocalizerSupport */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_ISchemaLocalizerSupport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CA3FDCA2-BFBE-4eed-90D7-0CAEF0A1BDA1")
    ISchemaLocalizerSupport : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Localize( 
            /* [in] */ LPCWSTR pszGlobalString,
            /* [retval][out] */ LPWSTR __RPC_FAR *ppszLocalString) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISchemaLocalizerSupportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISchemaLocalizerSupport __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISchemaLocalizerSupport __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISchemaLocalizerSupport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Localize )( 
            ISchemaLocalizerSupport __RPC_FAR * This,
            /* [in] */ LPCWSTR pszGlobalString,
            /* [retval][out] */ LPWSTR __RPC_FAR *ppszLocalString);
        
        END_INTERFACE
    } ISchemaLocalizerSupportVtbl;

    interface ISchemaLocalizerSupport
    {
        CONST_VTBL struct ISchemaLocalizerSupportVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISchemaLocalizerSupport_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISchemaLocalizerSupport_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISchemaLocalizerSupport_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISchemaLocalizerSupport_Localize(This,pszGlobalString,ppszLocalString)	\
    (This)->lpVtbl -> Localize(This,pszGlobalString,ppszLocalString)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISchemaLocalizerSupport_Localize_Proxy( 
    ISchemaLocalizerSupport __RPC_FAR * This,
    /* [in] */ LPCWSTR pszGlobalString,
    /* [retval][out] */ LPWSTR __RPC_FAR *ppszLocalString);


void __RPC_STUB ISchemaLocalizerSupport_Localize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISchemaLocalizerSupport_INTERFACE_DEFINED__ */


#ifndef __IQueryParserManager_INTERFACE_DEFINED__
#define __IQueryParserManager_INTERFACE_DEFINED__

/* interface IQueryParserManager */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IQueryParserManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A879E3C4-AF77-44fb-8F37-EBD1487CF920")
    IQueryParserManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateLoadedParser( 
            /* [in] */ LPCWSTR pszCatalog,
            /* [in] */ LANGID langidForKeywords,
            /* [in] */ REFIID riid,
            /* [iid_is][retval][out] */ void __RPC_FAR *__RPC_FAR *ppQueryParser) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitializeOptions( 
            /* [in] */ BOOL fUnderstandNQS,
            /* [in] */ BOOL fAutoWildCard,
            /* [in] */ IQueryParser __RPC_FAR *pQueryParser) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOption( 
            /* [in] */ QUERY_PARSER_MANAGER_OPTION option,
            /* [in] */ const PROPVARIANT __RPC_FAR *pOptionValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IQueryParserManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IQueryParserManager __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IQueryParserManager __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IQueryParserManager __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateLoadedParser )( 
            IQueryParserManager __RPC_FAR * This,
            /* [in] */ LPCWSTR pszCatalog,
            /* [in] */ LANGID langidForKeywords,
            /* [in] */ REFIID riid,
            /* [iid_is][retval][out] */ void __RPC_FAR *__RPC_FAR *ppQueryParser);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitializeOptions )( 
            IQueryParserManager __RPC_FAR * This,
            /* [in] */ BOOL fUnderstandNQS,
            /* [in] */ BOOL fAutoWildCard,
            /* [in] */ IQueryParser __RPC_FAR *pQueryParser);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOption )( 
            IQueryParserManager __RPC_FAR * This,
            /* [in] */ QUERY_PARSER_MANAGER_OPTION option,
            /* [in] */ const PROPVARIANT __RPC_FAR *pOptionValue);
        
        END_INTERFACE
    } IQueryParserManagerVtbl;

    interface IQueryParserManager
    {
        CONST_VTBL struct IQueryParserManagerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IQueryParserManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IQueryParserManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IQueryParserManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IQueryParserManager_CreateLoadedParser(This,pszCatalog,langidForKeywords,riid,ppQueryParser)	\
    (This)->lpVtbl -> CreateLoadedParser(This,pszCatalog,langidForKeywords,riid,ppQueryParser)

#define IQueryParserManager_InitializeOptions(This,fUnderstandNQS,fAutoWildCard,pQueryParser)	\
    (This)->lpVtbl -> InitializeOptions(This,fUnderstandNQS,fAutoWildCard,pQueryParser)

#define IQueryParserManager_SetOption(This,option,pOptionValue)	\
    (This)->lpVtbl -> SetOption(This,option,pOptionValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IQueryParserManager_CreateLoadedParser_Proxy( 
    IQueryParserManager __RPC_FAR * This,
    /* [in] */ LPCWSTR pszCatalog,
    /* [in] */ LANGID langidForKeywords,
    /* [in] */ REFIID riid,
    /* [iid_is][retval][out] */ void __RPC_FAR *__RPC_FAR *ppQueryParser);


void __RPC_STUB IQueryParserManager_CreateLoadedParser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IQueryParserManager_InitializeOptions_Proxy( 
    IQueryParserManager __RPC_FAR * This,
    /* [in] */ BOOL fUnderstandNQS,
    /* [in] */ BOOL fAutoWildCard,
    /* [in] */ IQueryParser __RPC_FAR *pQueryParser);


void __RPC_STUB IQueryParserManager_InitializeOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IQueryParserManager_SetOption_Proxy( 
    IQueryParserManager __RPC_FAR * This,
    /* [in] */ QUERY_PARSER_MANAGER_OPTION option,
    /* [in] */ const PROPVARIANT __RPC_FAR *pOptionValue);


void __RPC_STUB IQueryParserManager_SetOption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IQueryParserManager_INTERFACE_DEFINED__ */



#ifndef __StructuredQuery1_LIBRARY_DEFINED__
#define __StructuredQuery1_LIBRARY_DEFINED__

/* library StructuredQuery1 */
/* [version][uuid] */ 


EXTERN_C const IID LIBID_StructuredQuery1;

EXTERN_C const CLSID CLSID_QueryParser;

#ifdef __cplusplus

class DECLSPEC_UUID("B72F8FD8-0FAB-4dd9-BDBF-245A6CE1485B")
QueryParser;
#endif

EXTERN_C const CLSID CLSID_NegationCondition;

#ifdef __cplusplus

class DECLSPEC_UUID("8DE9C74C-605A-4acd-BEE3-2B222AA2D23D")
NegationCondition;
#endif

EXTERN_C const CLSID CLSID_CompoundCondition;

#ifdef __cplusplus

class DECLSPEC_UUID("116F8D13-101E-4fa5-84D4-FF8279381935")
CompoundCondition;
#endif

EXTERN_C const CLSID CLSID_LeafCondition;

#ifdef __cplusplus

class DECLSPEC_UUID("52F15C89-5A17-48e1-BBCD-46A3F89C7CC2")
LeafCondition;
#endif

EXTERN_C const CLSID CLSID_ConditionFactory;

#ifdef __cplusplus

class DECLSPEC_UUID("E03E85B0-7BE3-4000-BA98-6C13DE9FA486")
ConditionFactory;
#endif

EXTERN_C const CLSID CLSID_QueryParserManager;

#ifdef __cplusplus

class DECLSPEC_UUID("5088B39A-29B4-4d9d-8245-4EE289222F66")
QueryParserManager;
#endif
#endif /* __StructuredQuery1_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long __RPC_FAR *, unsigned long            , LPSAFEARRAY __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, LPSAFEARRAY __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, LPSAFEARRAY __RPC_FAR * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long __RPC_FAR *, LPSAFEARRAY __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\strsafe.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/******************************************************************
*                                                                 *
*  strsafe.h -- This module defines safer C library string        *
*               routine replacements. These are meant to make C   *
*               a bit more safe in reference to security and      *
*               robustness                                        *
*                                                                 *
******************************************************************/
#ifndef _STRSAFE_H_INCLUDED_
#define _STRSAFE_H_INCLUDED_
#pragma once

#include <stdio.h>          // for _vsnprintf, _vsnwprintf, getc, getwc
#include <string.h>         // for memset
#include <stdarg.h>         // for va_start, etc.
#include <specstrings.h>    // for __in, etc.


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef __w64 unsigned int  size_t;
#endif  // !_WIN64
#define _SIZE_T_DEFINED
#endif  // !_SIZE_T_DEFINED

#if !defined(_WCHAR_T_DEFINED) && !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _HRESULT_DEFINED
#define _HRESULT_DEFINED
typedef long HRESULT;
#endif // !_HRESULT_DEFINED

#ifndef SUCCEEDED
#define SUCCEEDED(hr)  ((HRESULT)(hr) >= 0)
#endif

#ifndef FAILED
#define FAILED(hr)  ((HRESULT)(hr) < 0)
#endif

#ifndef S_OK
#define S_OK  ((HRESULT)0x00000000L)
#endif

// compiletime asserts (failure results in error C2118: negative subscript)
#ifndef C_ASSERT
#define C_ASSERT(e) typedef char __C_ASSERT__[(e)?1:-1]
#endif

#ifdef __cplusplus
#define _STRSAFE_EXTERN_C    extern "C"
#else
#define _STRSAFE_EXTERN_C    extern
#endif

#ifndef _STRSAFE_USE_SECURE_CRT
#if defined(__GOT_SECURE_LIB__) && (__GOT_SECURE_LIB__ >= 200402L)
#define _STRSAFE_USE_SECURE_CRT 1
#else
#define _STRSAFE_USE_SECURE_CRT 0
#endif
#endif

#ifdef UNDER_CE
#define _STRSAFE_CALL_CONVENTION
#else
#define _STRSAFE_CALL_CONVENTION    __stdcall
#endif

// If you do not want to use these functions inline (and instead want to link w/ strsafe.lib), then
// #define STRSAFE_LIB before including this header file.
#if defined(STRSAFE_LIB)
#define STRSAFEAPI  _STRSAFE_EXTERN_C HRESULT _STRSAFE_CALL_CONVENTION
#ifndef UNDER_CE
#pragma comment(lib, "strsafe.lib")
#endif
#elif defined(STRSAFE_LIB_IMPL)
#define STRSAFEAPI  _STRSAFE_EXTERN_C HRESULT _STRSAFE_CALL_CONVENTION
#else
#define STRSAFEAPI  __inline HRESULT _STRSAFE_CALL_CONVENTION
#define STRSAFE_INLINE
#endif

// _vsnprintf isn't necessarily present on CE, so when creating the StrSafe
// library, we need the ability to place StrSafe functions that reference
// _vsnprintf into a separate library to prevent artificial link dependencies.
#if defined(STRSAFE_ONLY_SPRINTF_FUNCTIONS) && defined(STRSAFE_NO_SPRINTF_FUNCTIONS)
#error cannot specify both STRSAFE_ONLY_SPRINTF_FUNCTIONS and STRSAFE_NO_SPRINTF_FUNCTIONS !!
#endif

// Some functions we want to force inline because we want compiletime differences based on #defines, or they use
// stdin and we want to avoid building multiple versions of strsafe lib (depending on what #define or if
// you use msvcrt, libcmt, etc..)
#define STRSAFE_INLINE_API  __inline HRESULT _STRSAFE_CALL_CONVENTION

// The user can request no "Cb" or no "Cch" fuctions, but not both!
#if defined(STRSAFE_NO_CB_FUNCTIONS) && defined(STRSAFE_NO_CCH_FUNCTIONS)
#error cannot specify both STRSAFE_NO_CB_FUNCTIONS and STRSAFE_NO_CCH_FUNCTIONS !!
#endif

// The user can request no "A" (ASCII) or no "W" (Wide) functions, but not both!
#if defined(STRSAFE_NO_A_FUNCTIONS) && defined(STRSAFE_NO_W_FUNCTIONS)
#error cannot specify both STRSAFE_NO_A_FUNCTIONS and STRSAFE_NO_W_FUNCTIONS !!
#endif

// This should only be defined when we are building strsafe.lib
#ifdef STRSAFE_LIB_IMPL
#define STRSAFE_INLINE
#endif

#define STRSAFE_MAX_CCH     2147483647 // max # of characters we support (same as INT_MAX)

// Flags for controling the Ex functions
//
//      STRSAFE_FILL_BYTE(0xFF)                         0x000000FF  // bottom byte specifies fill pattern
#define STRSAFE_IGNORE_NULLS                            0x00000100  // treat null string pointers as TEXT("") -- don't fault on NULL buffers
#define STRSAFE_FILL_BEHIND_NULL                        0x00000200  // fill in extra space behind the null terminator
#define STRSAFE_FILL_ON_FAILURE                         0x00000400  // on failure, overwrite pszDest with fill pattern and null terminate it
#define STRSAFE_NULL_ON_FAILURE                         0x00000800  // on failure, set *pszDest = TEXT('\0')
#define STRSAFE_NO_TRUNCATION                           0x00001000  // instead of returning a truncated result, copy/append nothing to pszDest and null terminate it
#define STRSAFE_IGNORE_NULL_UNICODE_STRINGS             0x00010000  // don't crash on null UNICODE_STRING pointers (STRSAFE_IGNORE_NULLS implies this flag)
#define STRSAFE_UNICODE_STRING_DEST_NULL_TERMINATED     0x00020000  // we will fail if the Dest PUNICODE_STRING's Buffer cannot be null terminated

#define STRSAFE_VALID_FLAGS                     (0x000000FF | STRSAFE_IGNORE_NULLS | STRSAFE_FILL_BEHIND_NULL | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE | STRSAFE_NO_TRUNCATION)
#define STRSAFE_UNICODE_STRING_VALID_FLAGS      (STRSAFE_VALID_FLAGS | STRSAFE_IGNORE_NULL_UNICODE_STRINGS | STRSAFE_UNICODE_STRING_DEST_NULL_TERMINATED)

// helper macro to set the fill character and specify buffer filling
#define STRSAFE_FILL_BYTE(x)                    ((unsigned long)((x & 0x000000FF) | STRSAFE_FILL_BEHIND_NULL))
#define STRSAFE_FAILURE_BYTE(x)                 ((unsigned long)((x & 0x000000FF) | STRSAFE_FILL_ON_FAILURE))

#define STRSAFE_GET_FILL_PATTERN(dwFlags)       ((int)(dwFlags & 0x000000FF))

// STRSAFE error return codes
//
#define STRSAFE_E_INSUFFICIENT_BUFFER       ((HRESULT)0x8007007AL)  // 0x7A = 122L = ERROR_INSUFFICIENT_BUFFER
#define STRSAFE_E_INVALID_PARAMETER         ((HRESULT)0x80070057L)  // 0x57 =  87L = ERROR_INVALID_PARAMETER
#define STRSAFE_E_END_OF_FILE               ((HRESULT)0x80070026L)  // 0x26 =  38L = ERROR_HANDLE_EOF

//
// These typedefs are used in places where the string is guaranteed to
// be null terminated.
//
typedef __nullterminated char* STRSAFE_LPSTR;
typedef __nullterminated const char* STRSAFE_LPCSTR;
typedef __nullterminated wchar_t* STRSAFE_LPWSTR;
typedef __nullterminated const wchar_t* STRSAFE_LPCWSTR;


// prototypes for the worker functions
#ifdef STRSAFE_INLINE

STRSAFEAPI
StringCopyWorkerA(
    __out_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in STRSAFE_LPCSTR pszSrc);

STRSAFEAPI
StringCopyWorkerW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in STRSAFE_LPCWSTR pszSrc);

STRSAFEAPI
StringCopyExWorkerA(
    __out_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in size_t cbDest,
    __in STRSAFE_LPCSTR pszSrc,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags);

STRSAFEAPI
StringCopyExWorkerW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in size_t cbDest,
    __in STRSAFE_LPCWSTR pszSrc,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags);

STRSAFEAPI
StringCopyNWorkerA(
    __out_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in_ecount(cchToCopy) STRSAFE_LPCSTR pszSrc,
    __in size_t cchToCopy);

STRSAFEAPI
StringCopyNWorkerW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in_ecount(cchToCopy) STRSAFE_LPCWSTR pszSrc,
    __in size_t cchToCopy);

STRSAFEAPI
StringCopyNExWorkerA(
    __out_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in size_t cbDest,
    __in_ecount(cchToCopy) STRSAFE_LPCSTR pszSrc,
    __in size_t cchToCopy,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags);

STRSAFEAPI
StringCopyNExWorkerW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in size_t cbDest,
    __in_ecount(cchToCopy) STRSAFE_LPCWSTR pszSrc,
    __in size_t cchToCopy,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags);

STRSAFEAPI
StringCatWorkerA(
    __inout_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in STRSAFE_LPCSTR pszSrc);

STRSAFEAPI
StringCatWorkerW(
    __inout_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in STRSAFE_LPCWSTR pszSrc);

STRSAFEAPI
StringCatExWorkerA(
    __inout_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in size_t cbDest,
    __in STRSAFE_LPCSTR pszSrc,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags);

STRSAFEAPI
StringCatExWorkerW(
    __inout_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in size_t cbDest,
    __in STRSAFE_LPCWSTR pszSrc,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags);

STRSAFEAPI
StringCatNWorkerA(
    __inout_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in_ecount(cchToAppend) STRSAFE_LPCSTR pszSrc,
    __in size_t cchToAppend);

STRSAFEAPI
StringCatNWorkerW(
    __inout_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in_ecount(cchToAppend) STRSAFE_LPCWSTR pszSrc,
    __in size_t cchToAppend);

STRSAFEAPI
StringCatNExWorkerA(
    __inout_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in size_t cbDest,
    __in_ecount(cchToAppend) STRSAFE_LPCSTR pszSrc,
    __in size_t cchToAppend,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags);

STRSAFEAPI
StringCatNExWorkerW(
    __inout_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in size_t cbDest,
    __in_ecount(cchToAppend) STRSAFE_LPCWSTR pszSrc,
    __in size_t cchToAppend,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags);

STRSAFEAPI
StringVPrintfWorkerA(
    __out_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in __format_string STRSAFE_LPCSTR pszFormat,
    __in va_list argList);

STRSAFEAPI
StringVPrintfWorkerW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in __format_string STRSAFE_LPCWSTR pszFormat,
    __in va_list argList);

STRSAFEAPI
StringVPrintfExWorkerA(
    __out_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in size_t cbDest,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags,
    __in __format_string STRSAFE_LPCSTR pszFormat,
    __in va_list argList);

STRSAFEAPI
StringVPrintfExWorkerW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in size_t cbDest,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags,
    __in __format_string STRSAFE_LPCWSTR pszFormat,
    __in va_list argList);

STRSAFEAPI
StringLengthWorkerA(
    __in STRSAFE_LPCSTR psz,
    __in size_t cchMax,
    __out_opt size_t* pcchLength);

STRSAFEAPI
StringLengthWorkerW(
    __in STRSAFE_LPCWSTR psz,
    __in size_t cchMax,
    __out_opt size_t* pcchLength);

#endif  // STRSAFE_INLINE

#ifdef STRSAFE_WITH_GETS
// these worker functions are always run inline
#ifndef STRSAFE_LIB_IMPL

STRSAFE_INLINE_API
StringGetsExWorkerA(
    __out_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in size_t cbDest,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags);

STRSAFE_INLINE_API
StringGetsExWorkerW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in size_t cbDest,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags);

#endif  //!STRSAFE_LIB_IMPL
#endif  //STRSAFE_WITH_GETS


#ifndef STRSAFE_ONLY_SPRINTF_FUNCTIONS

#ifndef STRSAFE_NO_CCH_FUNCTIONS
/*++

STDAPI
StringCchCopy(
    OUT LPTSTR  pszDest,
    IN  size_t  cchDest,
    IN  LPCTSTR pszSrc
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strcpy'.
    The size of the destination buffer (in characters) is a parameter and
    this function will not write past the end of this buffer and it will
    ALWAYS null terminate the destination buffer (unless it is zero length).

    This routine is not a replacement for strncpy.  That function will pad the
    destination string with extra null termination characters if the count is
    greater than the length of the source string, and it will fail to null
    terminate the destination string if the source string length is greater
    than or equal to the count. You can not blindly use this instead of strncpy:
    it is common for code to use it to "patch" strings and you would introduce
    errors if the code started null terminating in the middle of the string.

    This function returns a hresult, and not a pointer.  It returns
    S_OK if the string was copied without truncation and null terminated,
    otherwise it will return a failure code. In failure cases as much of
    pszSrc will be copied to pszDest as possible, and pszDest will be null
    terminated.

Arguments:

    pszDest        -   destination string

    cchDest        -   size of destination buffer in characters.
                       length must be = (_tcslen(src) + 1) to hold all of the
                       source including the null terminator

    pszSrc         -   source string which must be null terminated

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL. See StringCchCopyEx if you require
    the handling of NULL values.

Return Value:

    S_OK           -   if there was source data and it was all copied and the
                       resultant dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the copy
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function.

--*/

STRSAFEAPI
StringCchCopyA(
    __out_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in STRSAFE_LPCSTR pszSrc);

STRSAFEAPI
StringCchCopyW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in STRSAFE_LPCWSTR pszSrc);
#ifdef UNICODE
#define StringCchCopy  StringCchCopyW
#else
#define StringCchCopy  StringCchCopyA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
#ifndef STRSAFE_NO_A_FUNCTIONS
STRSAFEAPI
StringCchCopyA(
    __out_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in STRSAFE_LPCSTR pszSrc)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringCopyWorkerA(pszDest, cchDest, pszSrc);
    }

    return hr;
}
#endif  // !STRSAFE_NO_A_FUNCTIONS

#ifndef STRSAFE_NO_W_FUNCTIONS
STRSAFEAPI
StringCchCopyW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in STRSAFE_LPCWSTR pszSrc)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringCopyWorkerW(pszDest, cchDest, pszSrc);
    }

    return hr;
}
#endif  // !STRSAFE_NO_W_FUNCTIONS
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CCH_FUNCTIONS


#ifndef STRSAFE_NO_CB_FUNCTIONS
/*++

STDAPI
StringCbCopy(
    OUT LPTSTR pszDest,
    IN  size_t cbDest,
    IN  LPCTSTR pszSrc
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strcpy'.
    The size of the destination buffer (in bytes) is a parameter and this
    function will not write past the end of this buffer and it will ALWAYS
    null terminate the destination buffer (unless it is zero length).

    This routine is not a replacement for strncpy.  That function will pad the
    destination string with extra null termination characters if the count is
    greater than the length of the source string, and it will fail to null
    terminate the destination string if the source string length is greater
    than or equal to the count. You can not blindly use this instead of strncpy:
    it is common for code to use it to "patch" strings and you would introduce
    errors if the code started null terminating in the middle of the string.

    This function returns a hresult, and not a pointer.  It returns
    S_OK if the string was copied without truncation and null terminated,
    otherwise it will return a failure code. In failure cases as much of pszSrc
    will be copied to pszDest as possible, and pszDest will be null terminated.

Arguments:

    pszDest        -   destination string

    cbDest         -   size of destination buffer in bytes.
                       length must be = ((_tcslen(src) + 1) * sizeof(TCHAR)) to
                       hold all of the source including the null terminator

    pszSrc         -   source string which must be null terminated

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL.  See StringCbCopyEx if you require
    the handling of NULL values.

Return Value:

    S_OK           -   if there was source data and it was all copied and the
                       resultant dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the copy
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function.

--*/

STRSAFEAPI
StringCbCopyA(
    __out_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cbDest,
    __in STRSAFE_LPCSTR pszSrc);

STRSAFEAPI
StringCbCopyW(
    __out_bcount(cbDest) STRSAFE_LPWSTR pszDest,
    __in size_t cbDest,
    __in STRSAFE_LPCWSTR pszSrc);
#ifdef UNICODE
#define StringCbCopy  StringCbCopyW
#else
#define StringCbCopy  StringCbCopyA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
#ifndef STRSAFE_NO_A_FUNCTIONS
STRSAFEAPI
StringCbCopyA(
    __out_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cbDest,
    __in STRSAFE_LPCSTR pszSrc)
{
    HRESULT hr;
    size_t cchDest;

    // convert to count of characters
    cchDest = cbDest / sizeof(char);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringCopyWorkerA(pszDest, cchDest, pszSrc);
    }

    return hr;
}
#endif  // !STRSAFE_NO_A_FUNCTIONS
#ifndef STRSAFE_NO_W_FUNCTIONS

STRSAFEAPI
StringCbCopyW(
    __out_bcount(cbDest) STRSAFE_LPWSTR pszDest,
    __in size_t cbDest,
    __in STRSAFE_LPCWSTR pszSrc)
{
    HRESULT hr;
    size_t cchDest;

    // convert to count of characters
    cchDest = cbDest / sizeof(wchar_t);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringCopyWorkerW(pszDest, cchDest, pszSrc);
    }

    return hr;
}
#endif  // !STRSAFE_NO_W_FUNCTIONS
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CB_FUNCTIONS


#ifndef STRSAFE_NO_CCH_FUNCTIONS
/*++

STDAPI
StringCchCopyEx(
    OUT LPTSTR  pszDest         OPTIONAL,
    IN  size_t  cchDest,
    IN  LPCTSTR pszSrc          OPTIONAL,
    OUT LPTSTR* ppszDestEnd     OPTIONAL,
    OUT size_t* pcchRemaining   OPTIONAL,
    IN  DWORD   dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strcpy' with
    some additional parameters.  In addition to functionality provided by
    StringCchCopy, this routine also returns a pointer to the end of the
    destination string and the number of characters left in the destination string
    including the null terminator. The flags parameter allows additional controls.

Arguments:

    pszDest         -   destination string

    cchDest         -   size of destination buffer in characters.
                        length must be = (_tcslen(pszSrc) + 1) to hold all of
                        the source including the null terminator

    pszSrc          -   source string which must be null terminated

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function copied any data, the result will point to the
                        null termination character

    pcchRemaining   -   if pcchRemaining is non-null, the function will return the
                        number of characters left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT("")).
                    this flag is useful for emulating functions like lstrcpy

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any truncated
                    string returned when the failure is
                    STRSAFE_E_INSUFFICIENT_BUFFER

        STRSAFE_NO_TRUNCATION /
        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any truncated string
                    returned when the failure is STRSAFE_E_INSUFFICIENT_BUFFER.

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL unless the STRSAFE_IGNORE_NULLS flag
    is specified.  If STRSAFE_IGNORE_NULLS is passed, both pszDest and pszSrc
    may be NULL.  An error may still be returned even though NULLS are ignored
    due to insufficient space.

Return Value:

    S_OK           -   if there was source data and it was all copied and the
                       resultant dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the copy
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/

STRSAFEAPI
StringCchCopyExA(
    __out_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in STRSAFE_LPCSTR pszSrc,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags);

STRSAFEAPI
StringCchCopyExW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in STRSAFE_LPCWSTR pszSrc,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags);
#ifdef UNICODE
#define StringCchCopyEx  StringCchCopyExW
#else
#define StringCchCopyEx  StringCchCopyExA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
#ifndef STRSAFE_NO_A_FUNCTIONS
STRSAFEAPI
StringCchCopyExA(
    __out_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in STRSAFE_LPCSTR pszSrc,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        size_t cbDest;

        // safe to multiply cchDest * sizeof(char) since cchDest < STRSAFE_MAX_CCH and sizeof(char) is 1
        cbDest = cchDest * sizeof(char);

        hr = StringCopyExWorkerA(pszDest, cchDest, cbDest, pszSrc, ppszDestEnd, pcchRemaining, dwFlags);
    }

    return hr;
}
#endif  // !STRSAFE_NO_A_FUNCTIONS
#ifndef STRSAFE_NO_W_FUNCTIONS

STRSAFEAPI
StringCchCopyExW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in STRSAFE_LPCWSTR pszSrc,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        size_t cbDest;

        // safe to multiply cchDest * sizeof(wchar_t) since cchDest < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
        cbDest = cchDest * sizeof(wchar_t);

        hr = StringCopyExWorkerW(pszDest, cchDest, cbDest, pszSrc, ppszDestEnd, pcchRemaining, dwFlags);
    }

    return hr;
}
#endif  // !STRSAFE_NO_W_FUNCTIONS
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CCH_FUNCTIONS


#ifndef STRSAFE_NO_CB_FUNCTIONS
/*++

STDAPI
StringCbCopyEx(
    OUT LPTSTR  pszDest         OPTIONAL,
    IN  size_t  cbDest,
    IN  LPCTSTR pszSrc          OPTIONAL,
    OUT LPTSTR* ppszDestEnd     OPTIONAL,
    OUT size_t* pcbRemaining    OPTIONAL,
    IN  DWORD   dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strcpy' with
    some additional parameters.  In addition to functionality provided by
    StringCbCopy, this routine also returns a pointer to the end of the
    destination string and the number of bytes left in the destination string
    including the null terminator. The flags parameter allows additional controls.

Arguments:

    pszDest         -   destination string

    cbDest          -   size of destination buffer in bytes.
                        length must be ((_tcslen(pszSrc) + 1) * sizeof(TCHAR)) to
                        hold all of the source including the null terminator

    pszSrc          -   source string which must be null terminated

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function copied any data, the result will point to the
                        null termination character

    pcbRemaining    -   pcbRemaining is non-null,the function will return the
                        number of bytes left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT("")).
                    this flag is useful for emulating functions like lstrcpy

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any truncated
                    string returned when the failure is
                    STRSAFE_E_INSUFFICIENT_BUFFER

        STRSAFE_NO_TRUNCATION /
        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any truncated string
                    returned when the failure is STRSAFE_E_INSUFFICIENT_BUFFER.

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL unless the STRSAFE_IGNORE_NULLS flag
    is specified.  If STRSAFE_IGNORE_NULLS is passed, both pszDest and pszSrc
    may be NULL.  An error may still be returned even though NULLS are ignored
    due to insufficient space.

Return Value:

    S_OK           -   if there was source data and it was all copied and the
                       resultant dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the copy
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/

STRSAFEAPI
StringCbCopyExA(
    __out_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cbDest,
    __in STRSAFE_LPCSTR pszSrc,
    __deref_opt_out_bcount(*pcbRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in unsigned long dwFlags);

STRSAFEAPI
StringCbCopyExW(
    __out_bcount(cbDest) STRSAFE_LPWSTR pszDest,
    __in size_t cbDest,
    __in STRSAFE_LPCWSTR pszSrc,
    __deref_opt_out_bcount(*pcbRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in unsigned long dwFlags);
#ifdef UNICODE
#define StringCbCopyEx  StringCbCopyExW
#else
#define StringCbCopyEx  StringCbCopyExA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
#ifndef STRSAFE_NO_A_FUNCTIONS
STRSAFEAPI
StringCbCopyExA(
    __out_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cbDest,
    __in STRSAFE_LPCSTR pszSrc,
    __deref_opt_out_bcount(*pcbRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in unsigned long dwFlags)
{
    HRESULT hr;
    size_t cchDest;
    size_t cchRemaining = 0;

    // convert to count of characters
    cchDest = cbDest / sizeof(char);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringCopyExWorkerA(pszDest, cchDest, cbDest, pszSrc, ppszDestEnd, &cchRemaining, dwFlags);
    }

    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
    {
        if (pcbRemaining)
        {
            // safe to multiply cchRemaining * sizeof(char) since cchRemaining < STRSAFE_MAX_CCH and sizeof(char) is 1
            *pcbRemaining = (cchRemaining * sizeof(char)) + (cbDest % sizeof(char));
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_A_FUNCTIONS
#ifndef STRSAFE_NO_W_FUNCTIONS

STRSAFEAPI
StringCbCopyExW(
    __out_bcount(cbDest) STRSAFE_LPWSTR pszDest,
    __in size_t cbDest,
    __in STRSAFE_LPCWSTR pszSrc,
    __deref_opt_out_bcount(*pcbRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in unsigned long dwFlags)
{
    HRESULT hr;
    size_t cchDest;
    size_t cchRemaining = 0;

    // convert to count of characters
    cchDest = cbDest / sizeof(wchar_t);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringCopyExWorkerW(pszDest, cchDest, cbDest, pszSrc, ppszDestEnd, &cchRemaining, dwFlags);
    }

    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
    {
        if (pcbRemaining)
        {
            // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
            *pcbRemaining = (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_W_FUNCTIONS
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CB_FUNCTIONS


#ifndef STRSAFE_NO_CCH_FUNCTIONS
/*++

STDAPI
StringCchCopyN(
    OUT LPTSTR  pszDest,
    IN  size_t  cchDest,
    IN  LPCTSTR pszSrc,
    IN  size_t  cchToCopy
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strncpy'.
    The size of the destination buffer (in characters) is a parameter and
    this function will not write past the end of this buffer and it will
    ALWAYS null terminate the destination buffer (unless it is zero length).

    This routine is meant as a replacement for strncpy, but it does behave
    differently. This function will not pad the destination buffer with extra
    null termination characters if cchToCopy is greater than the length of pszSrc.

    This function returns a hresult, and not a pointer.  It returns
    S_OK if the entire string or the first cchToCopy characters were copied
    without truncation and the resultant destination string was null terminated,
    otherwise it will return a failure code. In failure cases as much of pszSrc
    will be copied to pszDest as possible, and pszDest will be null terminated.

Arguments:

    pszDest        -   destination string

    cchDest        -   size of destination buffer in characters.
                       length must be = (_tcslen(src) + 1) to hold all of the
                       source including the null terminator

    pszSrc         -   source string

    cchToCopy      -   maximum number of characters to copy from source string,
                       not including the null terminator.

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL. See StringCchCopyNEx if you require
    the handling of NULL values.

Return Value:

    S_OK           -   if there was source data and it was all copied and the
                       resultant dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the copy
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function.

--*/

STRSAFEAPI
StringCchCopyNA(
    __out_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in_ecount(cchToCopy) STRSAFE_LPCSTR pszSrc,
    __in size_t cchToCopy);

STRSAFEAPI
StringCchCopyNW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in_ecount(cchToCopy) STRSAFE_LPCWSTR pszSrc,
    __in size_t cchToCopy);
#ifdef UNICODE
#define StringCchCopyN  StringCchCopyNW
#else
#define StringCchCopyN  StringCchCopyNA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
#ifndef STRSAFE_NO_A_FUNCTIONS
STRSAFEAPI
StringCchCopyNA(
    __out_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in_ecount(cchToCopy) STRSAFE_LPCSTR pszSrc,
    __in size_t cchToCopy)
{
    HRESULT hr;

    if ((cchDest > STRSAFE_MAX_CCH) ||
        (cchToCopy > STRSAFE_MAX_CCH))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringCopyNWorkerA(pszDest, cchDest, pszSrc, cchToCopy);
    }

    return hr;
}
#endif  // !STRSAFE_NO_A_FUNCTIONS
#ifndef STRSAFE_NO_W_FUNCTIONS

STRSAFEAPI
StringCchCopyNW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in_ecount(cchToCopy) STRSAFE_LPCWSTR pszSrc,
    __in size_t cchToCopy)
{
    HRESULT hr;

    if ((cchDest > STRSAFE_MAX_CCH) ||
        (cchToCopy > STRSAFE_MAX_CCH))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringCopyNWorkerW(pszDest, cchDest, pszSrc, cchToCopy);
    }

    return hr;
}
#endif  // !STRSAFE_NO_W_FUNCTIONS
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CCH_FUNCTIONS


#ifndef STRSAFE_NO_CB_FUNCTIONS
/*++

STDAPI
StringCbCopyN(
    OUT LPTSTR  pszDest,
    IN  size_t  cbDest,
    IN  LPCTSTR pszSrc,
    IN  size_t  cbToCopy
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strncpy'.
    The size of the destination buffer (in bytes) is a parameter and this
    function will not write past the end of this buffer and it will ALWAYS
    null terminate the destination buffer (unless it is zero length).

    This routine is meant as a replacement for strncpy, but it does behave
    differently. This function will not pad the destination buffer with extra
    null termination characters if cbToCopy is greater than the size of pszSrc.

    This function returns a hresult, and not a pointer.  It returns
    S_OK if the entire string or the first cbToCopy characters were
    copied without truncation and the resultant destination string was null
    terminated, otherwise it will return a failure code. In failure cases as
    much of pszSrc will be copied to pszDest as possible, and pszDest will be
    null terminated.

Arguments:

    pszDest        -   destination string

    cbDest         -   size of destination buffer in bytes.
                       length must be = ((_tcslen(src) + 1) * sizeof(TCHAR)) to
                       hold all of the source including the null terminator

    pszSrc         -   source string

    cbToCopy       -   maximum number of bytes to copy from source string,
                       not including the null terminator.

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL.  See StringCbCopyEx if you require
    the handling of NULL values.

Return Value:

    S_OK           -   if there was source data and it was all copied and the
                       resultant dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the copy
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function.

--*/

STRSAFEAPI
StringCbCopyNA(
    __out_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cbDest,
    __in_bcount(cbToCopy) STRSAFE_LPCSTR pszSrc,
    __in size_t cbToCopy);

STRSAFEAPI
StringCbCopyNW(
    __out_bcount(cbDest) STRSAFE_LPWSTR pszDest,
    __in size_t cbDest,
    __in_bcount(cbToCopy) STRSAFE_LPCWSTR pszSrc,
    __in size_t cbToCopy);
#ifdef UNICODE
#define StringCbCopyN  StringCbCopyNW
#else
#define StringCbCopyN  StringCbCopyNA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
#ifndef STRSAFE_NO_A_FUNCTIONS
STRSAFEAPI
StringCbCopyNA(
    __out_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cbDest,
    __in_bcount(cbToCopy) STRSAFE_LPCSTR pszSrc,
    __in size_t cbToCopy)
{
    HRESULT hr;
    size_t cchDest;
    size_t cchToCopy;

    // convert to count of characters
    cchDest = cbDest / sizeof(char);
    cchToCopy = cbToCopy / sizeof(char);

    if ((cchDest > STRSAFE_MAX_CCH) ||
        (cchToCopy > STRSAFE_MAX_CCH))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringCopyNWorkerA(pszDest, cchDest, pszSrc, cchToCopy);
    }

    return hr;
}
#endif  // !STRSAFE_NO_A_FUNCTIONS
#ifndef STRSAFE_NO_W_FUNCTIONS

STRSAFEAPI
StringCbCopyNW(
    __out_bcount(cbDest) STRSAFE_LPWSTR pszDest,
    __in size_t cbDest,
    __in_bcount(cbToCopy) STRSAFE_LPCWSTR pszSrc,
    __in size_t cbToCopy)
{
    HRESULT hr;
    size_t cchDest;
    size_t cchToCopy;

    // convert to count of characters
    cchDest = cbDest / sizeof(wchar_t);
    cchToCopy = cbToCopy / sizeof(wchar_t);

    if ((cchDest > STRSAFE_MAX_CCH) ||
        (cchToCopy > STRSAFE_MAX_CCH))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringCopyNWorkerW(pszDest, cchDest, pszSrc, cchToCopy);
    }

    return hr;
}
#endif  // !STRSAFE_NO_W_FUNCTIONS
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CB_FUNCTIONS


#ifndef STRSAFE_NO_CCH_FUNCTIONS
/*++

STDAPI
StringCchCopyNEx(
    OUT LPTSTR  pszDest         OPTIONAL,
    IN  size_t  cchDest,
    IN  LPCTSTR pszSrc          OPTIONAL,
    IN  size_t  cchToCopy,
    OUT LPTSTR* ppszDestEnd     OPTIONAL,
    OUT size_t* pcchRemaining   OPTIONAL,
    IN  DWORD   dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strncpy' with
    some additional parameters.  In addition to functionality provided by
    StringCchCopyN, this routine also returns a pointer to the end of the
    destination string and the number of characters left in the destination
    string including the null terminator. The flags parameter allows
    additional controls.

    This routine is meant as a replacement for strncpy, but it does behave
    differently. This function will not pad the destination buffer with extra
    null termination characters if cchToCopy is greater than the length of pszSrc.

Arguments:

    pszDest         -   destination string

    cchDest         -   size of destination buffer in characters.
                        length must be = (_tcslen(pszSrc) + 1) to hold all of
                        the source including the null terminator

    pszSrc          -   source string

    cchToCopy       -   maximum number of characters to copy from the source
                        string

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function copied any data, the result will point to the
                        null termination character

    pcchRemaining   -   if pcchRemaining is non-null, the function will return the
                        number of characters left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT("")).
                    this flag is useful for emulating functions like lstrcpy

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any truncated
                    string returned when the failure is
                    STRSAFE_E_INSUFFICIENT_BUFFER

        STRSAFE_NO_TRUNCATION /
        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any truncated string
                    returned when the failure is STRSAFE_E_INSUFFICIENT_BUFFER.

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL unless the STRSAFE_IGNORE_NULLS flag
    is specified. If STRSAFE_IGNORE_NULLS is passed, both pszDest and pszSrc
    may be NULL. An error may still be returned even though NULLS are ignored
    due to insufficient space.

Return Value:

    S_OK           -   if there was source data and it was all copied and the
                       resultant dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the copy
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/

STRSAFEAPI
StringCchCopyNExA(
    __in_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in_ecount(cchToCopy) STRSAFE_LPCSTR pszSrc,
    __in size_t cchToCopy,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags);

STRSAFEAPI
StringCchCopyNExW(
    __in_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in_ecount(cchToCopy) STRSAFE_LPCWSTR pszSrc,
    __in size_t cchToCopy,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags);
#ifdef UNICODE
#define StringCchCopyNEx  StringCchCopyNExW
#else
#define StringCchCopyNEx  StringCchCopyNExA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
#ifndef STRSAFE_NO_A_FUNCTIONS
STRSAFEAPI
StringCchCopyNExA(
    __in_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in_ecount(cchToCopy) STRSAFE_LPCSTR pszSrc,
    __in size_t cchToCopy,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        size_t cbDest;

        // safe to multiply cchDest * sizeof(char) since cchDest < STRSAFE_MAX_CCH and sizeof(char) is 1
        cbDest = cchDest * sizeof(char);

        hr = StringCopyNExWorkerA(pszDest, cchDest, cbDest, pszSrc, cchToCopy, ppszDestEnd, pcchRemaining, dwFlags);
    }

    return hr;
}
#endif  // !STRSAFE_NO_A_FUNCTIONS
#ifndef STRSAFE_NO_W_FUNCTIONS

STRSAFEAPI
StringCchCopyNExW(
    __in_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in_ecount(cchToCopy) STRSAFE_LPCWSTR pszSrc,
    __in size_t cchToCopy,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        size_t cbDest;

        // safe to multiply cchDest * sizeof(wchar_t) since cchDest < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
        cbDest = cchDest * sizeof(wchar_t);

        hr = StringCopyNExWorkerW(pszDest, cchDest, cbDest, pszSrc, cchToCopy, ppszDestEnd, pcchRemaining, dwFlags);
    }

    return hr;
}
#endif  // !STRSAFE_NO_W_FUNCTIONS
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CCH_FUNCTIONS


#ifndef STRSAFE_NO_CB_FUNCTIONS
/*++

STDAPI
StringCbCopyNEx(
    OUT LPTSTR  pszDest         OPTIONAL,
    IN  size_t  cbDest,
    IN  LPCTSTR pszSrc          OPTIONAL,
    IN  size_t  cbToCopy,
    OUT LPTSTR* ppszDestEnd     OPTIONAL,
    OUT size_t* pcbRemaining    OPTIONAL,
    IN  DWORD   dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strncpy' with
    some additional parameters.  In addition to functionality provided by
    StringCbCopyN, this routine also returns a pointer to the end of the
    destination string and the number of bytes left in the destination string
    including the null terminator. The flags parameter allows additional controls.

    This routine is meant as a replacement for strncpy, but it does behave
    differently. This function will not pad the destination buffer with extra
    null termination characters if cbToCopy is greater than the size of pszSrc.

Arguments:

    pszDest         -   destination string

    cbDest          -   size of destination buffer in bytes.
                        length must be ((_tcslen(pszSrc) + 1) * sizeof(TCHAR)) to
                        hold all of the source including the null terminator

    pszSrc          -   source string

    cbToCopy        -   maximum number of bytes to copy from source string

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function copied any data, the result will point to the
                        null termination character

    pcbRemaining    -   pcbRemaining is non-null,the function will return the
                        number of bytes left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT("")).
                    this flag is useful for emulating functions like lstrcpy

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any truncated
                    string returned when the failure is
                    STRSAFE_E_INSUFFICIENT_BUFFER

        STRSAFE_NO_TRUNCATION /
        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any truncated string
                    returned when the failure is STRSAFE_E_INSUFFICIENT_BUFFER.

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL unless the STRSAFE_IGNORE_NULLS flag
    is specified.  If STRSAFE_IGNORE_NULLS is passed, both pszDest and pszSrc
    may be NULL.  An error may still be returned even though NULLS are ignored
    due to insufficient space.

Return Value:

    S_OK           -   if there was source data and it was all copied and the
                       resultant dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the copy
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/

STRSAFEAPI
StringCbCopyNExA(
    __out_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cbDest,
    __in_bcount(cbToCopy) STRSAFE_LPCSTR pszSrc,
    __in size_t cbToCopy,
    __deref_opt_out_bcount(*pcbRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in unsigned long dwFlags);

STRSAFEAPI
StringCbCopyNExW(
    __out_bcount(cbDest) STRSAFE_LPWSTR pszDest,
    __in size_t cbDest,
    __in_bcount(cbToCopy) STRSAFE_LPCWSTR pszSrc,
    __in size_t cbToCopy,
    __deref_opt_out_bcount(*pcbRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in unsigned long dwFlags);
#ifdef UNICODE
#define StringCbCopyNEx  StringCbCopyNExW
#else
#define StringCbCopyNEx  StringCbCopyNExA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
#ifndef STRSAFE_NO_A_FUNCTIONS
STRSAFEAPI
StringCbCopyNExA(
    __out_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cbDest,
    __in_bcount(cbToCopy) STRSAFE_LPCSTR pszSrc,
    __in size_t cbToCopy,
    __deref_opt_out_bcount(*pcbRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in unsigned long dwFlags)
{
    HRESULT hr;
    size_t cchDest;
    size_t cchToCopy;
    size_t cchRemaining = 0;

    // convert to count of characters
    cchDest = cbDest / sizeof(char);
    cchToCopy = cbToCopy / sizeof(char);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringCopyNExWorkerA(pszDest, cchDest, cbDest, pszSrc, cchToCopy, ppszDestEnd, &cchRemaining, dwFlags);
    }

    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
    {
        if (pcbRemaining)
        {
            // safe to multiply cchRemaining * sizeof(char) since cchRemaining < STRSAFE_MAX_CCH and sizeof(char) is 1
            *pcbRemaining = (cchRemaining * sizeof(char)) + (cbDest % sizeof(char));
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_A_FUNCTIONS
#ifndef STRSAFE_NO_W_FUNCTIONS

STRSAFEAPI
StringCbCopyNExW(
    __out_bcount(cbDest) STRSAFE_LPWSTR pszDest,
    __in size_t cbDest,
    __in_bcount(cbToCopy) STRSAFE_LPCWSTR pszSrc,
    __in size_t cbToCopy,
    __deref_opt_out_bcount(*pcbRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in unsigned long dwFlags)
{
    HRESULT hr;
    size_t cchDest;
    size_t cchToCopy;
    size_t cchRemaining = 0;

    // convert to count of characters
    cchDest = cbDest / sizeof(wchar_t);
    cchToCopy = cbToCopy / sizeof(wchar_t);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringCopyNExWorkerW(pszDest, cchDest, cbDest, pszSrc, cchToCopy, ppszDestEnd, &cchRemaining, dwFlags);
    }

    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
    {
        if (pcbRemaining)
        {
            // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
            *pcbRemaining = (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_W_FUNCTIONS
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CB_FUNCTIONS


#ifndef STRSAFE_NO_CCH_FUNCTIONS
/*++

STDAPI
StringCchCat(
    IN OUT LPTSTR  pszDest,
    IN     size_t  cchDest,
    IN     LPCTSTR pszSrc
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strcat'.
    The size of the destination buffer (in characters) is a parameter and this
    function will not write past the end of this buffer and it will ALWAYS
    null terminate the destination buffer (unless it is zero length).

    This function returns a hresult, and not a pointer.  It returns
    S_OK if the string was concatenated without truncation and null terminated,
    otherwise it will return a failure code. In failure cases as much of pszSrc
    will be appended to pszDest as possible, and pszDest will be null
    terminated.

Arguments:

    pszDest     -  destination string which must be null terminated

    cchDest     -  size of destination buffer in characters.
                   length must be = (_tcslen(pszDest) + _tcslen(pszSrc) + 1)
                   to hold all of the combine string plus the null
                   terminator

    pszSrc      -  source string which must be null terminated

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL.  See StringCchCatEx if you require
    the handling of NULL values.

Return Value:

    S_OK           -   if there was source data and it was all concatenated and
                       the resultant dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the operation
                       failed due to insufficient space. When this error occurs,
                       the destination buffer is modified to contain a truncated
                       version of the ideal result and is null terminated. This
                       is useful for situations where truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/

STRSAFEAPI
StringCchCatA(
    __inout_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in STRSAFE_LPCSTR pszSrc);

STRSAFEAPI
StringCchCatW(
    __inout_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in STRSAFE_LPCWSTR pszSrc);
#ifdef UNICODE
#define StringCchCat  StringCchCatW
#else
#define StringCchCat  StringCchCatA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
#ifndef STRSAFE_NO_A_FUNCTIONS
STRSAFEAPI
StringCchCatA(
    __inout_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in STRSAFE_LPCSTR pszSrc)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringCatWorkerA(pszDest, cchDest, pszSrc);
    }

    return hr;
}
#endif  // !STRSAFE_NO_A_FUNCTIONS
#ifndef STRSAFE_NO_W_FUNCTIONS

STRSAFEAPI
StringCchCatW(
    __inout_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in STRSAFE_LPCWSTR pszSrc)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringCatWorkerW(pszDest, cchDest, pszSrc);
    }

    return hr;
}
#endif  // !STRSAFE_NO_W_FUNCTIONS
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CCH_FUNCTIONS


#ifndef STRSAFE_NO_CB_FUNCTIONS
/*++

STDAPI
StringCbCat(
    IN OUT LPTSTR  pszDest,
    IN     size_t  cbDest,
    IN     LPCTSTR pszSrc
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strcat'.
    The size of the destination buffer (in bytes) is a parameter and this
    function will not write past the end of this buffer and it will ALWAYS
    null terminate the destination buffer (unless it is zero length).

    This function returns a hresult, and not a pointer.  It returns
    S_OK if the string was concatenated without truncation and null terminated,
    otherwise it will return a failure code. In failure cases as much of pszSrc
    will be appended to pszDest as possible, and pszDest will be null
    terminated.

Arguments:

    pszDest     -  destination string which must be null terminated

    cbDest      -  size of destination buffer in bytes.
                   length must be = ((_tcslen(pszDest) + _tcslen(pszSrc) + 1) * sizeof(TCHAR)
                   to hold all of the combine string plus the null
                   terminator

    pszSrc      -  source string which must be null terminated

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL.  See StringCbCatEx if you require
    the handling of NULL values.

Return Value:

    S_OK           -   if there was source data and it was all concatenated and
                       the resultant dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the operation
                       failed due to insufficient space. When this error occurs,
                       the destination buffer is modified to contain a truncated
                       version of the ideal result and is null terminated. This
                       is useful for situations where truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/

STRSAFEAPI
StringCbCatA(
    __inout_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cbDest,
    __in STRSAFE_LPCSTR pszSrc);

STRSAFEAPI
StringCbCatW(
    __inout_bcount(cbDest) STRSAFE_LPWSTR pszDest,
    __in size_t cbDest,
    __in STRSAFE_LPCWSTR pszSrc);
#ifdef UNICODE
#define StringCbCat  StringCbCatW
#else
#define StringCbCat  StringCbCatA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
#ifndef STRSAFE_NO_A_FUNCTIONS
STRSAFEAPI
StringCbCatA(
    __inout_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cbDest,
    __in STRSAFE_LPCSTR pszSrc)
{
    HRESULT hr;
    size_t cchDest;

    // convert to count of characters
    cchDest = cbDest / sizeof(char);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringCatWorkerA(pszDest, cchDest, pszSrc);
    }

    return hr;
}

#endif  // !STRSAFE_NO_A_FUNCTIONS
#ifndef STRSAFE_NO_W_FUNCTIONS
STRSAFEAPI
StringCbCatW(
    __inout_bcount(cbDest) STRSAFE_LPWSTR pszDest,
    __in size_t cbDest,
    __in STRSAFE_LPCWSTR pszSrc)
{
    HRESULT hr;
    size_t cchDest;

    // convert to count of characters
    cchDest = cbDest / sizeof(wchar_t);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringCatWorkerW(pszDest, cchDest, pszSrc);
    }

    return hr;
}
#endif  // !STRSAFE_NO_W_FUNCTIONS
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CB_FUNCTIONS


#ifndef STRSAFE_NO_CCH_FUNCTIONS
/*++

STDAPI
StringCchCatEx(
    IN OUT LPTSTR  pszDest         OPTIONAL,
    IN     size_t  cchDest,
    IN     LPCTSTR pszSrc          OPTIONAL,
    OUT    LPTSTR* ppszDestEnd     OPTIONAL,
    OUT    size_t* pcchRemaining   OPTIONAL,
    IN     DWORD   dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strcat' with
    some additional parameters.  In addition to functionality provided by
    StringCchCat, this routine also returns a pointer to the end of the
    destination string and the number of characters left in the destination string
    including the null terminator. The flags parameter allows additional controls.

Arguments:

    pszDest         -   destination string which must be null terminated

    cchDest         -   size of destination buffer in characters
                        length must be (_tcslen(pszDest) + _tcslen(pszSrc) + 1)
                        to hold all of the combine string plus the null
                        terminator.

    pszSrc          -   source string which must be null terminated

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function appended any data, the result will point to the
                        null termination character

    pcchRemaining   -   if pcchRemaining is non-null, the function will return the
                        number of characters left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT("")).
                    this flag is useful for emulating functions like lstrcat

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any pre-existing
                    or truncated string

        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any pre-existing or
                    truncated string

        STRSAFE_NO_TRUNCATION
                    if the function returns STRSAFE_E_INSUFFICIENT_BUFFER, pszDest
                    will not contain a truncated string, it will remain unchanged.

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL unless the STRSAFE_IGNORE_NULLS flag
    is specified.  If STRSAFE_IGNORE_NULLS is passed, both pszDest and pszSrc
    may be NULL.  An error may still be returned even though NULLS are ignored
    due to insufficient space.

Return Value:

    S_OK           -   if there was source data and it was all concatenated and
                       the resultant dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the operation
                       failed due to insufficient space. When this error
                       occurs, the destination buffer is modified to contain
                       a truncated version of the ideal result and is null
                       terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/

STRSAFEAPI
StringCchCatExA(
    __inout_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in STRSAFE_LPCSTR pszSrc,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags);

STRSAFEAPI
StringCchCatExW(
    __inout_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in STRSAFE_LPCWSTR pszSrc,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags);
#ifdef UNICODE
#define StringCchCatEx  StringCchCatExW
#else
#define StringCchCatEx  StringCchCatExA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
#ifndef STRSAFE_NO_A_FUNCTIONS
STRSAFEAPI
StringCchCatExA(
    __inout_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in STRSAFE_LPCSTR pszSrc,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        size_t cbDest;

        // safe to multiply cchDest * sizeof(char) since cchDest < STRSAFE_MAX_CCH and sizeof(char) is 1
        cbDest = cchDest * sizeof(char);

        hr = StringCatExWorkerA(pszDest, cchDest, cbDest, pszSrc, ppszDestEnd, pcchRemaining, dwFlags);
    }

    return hr;
}

#endif  // !STRSAFE_NO_A_FUNCTIONS
#ifndef STRSAFE_NO_W_FUNCTIONS
STRSAFEAPI
StringCchCatExW(
    __inout_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in STRSAFE_LPCWSTR pszSrc,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        size_t cbDest;

        // safe to multiply cchDest * sizeof(wchar_t) since cchDest < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
        cbDest = cchDest * sizeof(wchar_t);

        hr = StringCatExWorkerW(pszDest, cchDest, cbDest, pszSrc, ppszDestEnd, pcchRemaining, dwFlags);
    }

    return hr;
}
#endif  // !STRSAFE_NO_W_FUNCTIONS
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CCH_FUNCTIONS


#ifndef STRSAFE_NO_CB_FUNCTIONS
/*++

STDAPI
StringCbCatEx(
    IN OUT LPTSTR  pszDest         OPTIONAL,
    IN     size_t  cbDest,
    IN     LPCTSTR pszSrc          OPTIONAL,
    OUT    LPTSTR* ppszDestEnd     OPTIONAL,
    OUT    size_t* pcbRemaining    OPTIONAL,
    IN     DWORD   dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strcat' with
    some additional parameters.  In addition to functionality provided by
    StringCbCat, this routine also returns a pointer to the end of the
    destination string and the number of bytes left in the destination string
    including the null terminator. The flags parameter allows additional controls.

Arguments:

    pszDest         -   destination string which must be null terminated

    cbDest          -   size of destination buffer in bytes.
                        length must be ((_tcslen(pszDest) + _tcslen(pszSrc) + 1) * sizeof(TCHAR)
                        to hold all of the combine string plus the null
                        terminator.

    pszSrc          -   source string which must be null terminated

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function appended any data, the result will point to the
                        null termination character

    pcbRemaining    -   if pcbRemaining is non-null, the function will return
                        the number of bytes left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT("")).
                    this flag is useful for emulating functions like lstrcat

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any pre-existing
                    or truncated string

        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any pre-existing or
                    truncated string

        STRSAFE_NO_TRUNCATION
                    if the function returns STRSAFE_E_INSUFFICIENT_BUFFER, pszDest
                    will not contain a truncated string, it will remain unchanged.

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL unless the STRSAFE_IGNORE_NULLS flag
    is specified.  If STRSAFE_IGNORE_NULLS is passed, both pszDest and pszSrc
    may be NULL.  An error may still be returned even though NULLS are ignored
    due to insufficient space.

Return Value:

    S_OK           -   if there was source data and it was all concatenated
                       and the resultant dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the operation
                       failed due to insufficient space. When this error
                       occurs, the destination buffer is modified to contain
                       a truncated version of the ideal result and is null
                       terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/

STRSAFEAPI
StringCbCatExA(
    __inout_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cbDest,
    __in STRSAFE_LPCSTR pszSrc,
    __deref_opt_out_bcount(*pcbRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in unsigned long dwFlags);

STRSAFEAPI
StringCbCatExW(
    __inout_bcount(cbDest) STRSAFE_LPWSTR pszDest,
    __in size_t cbDest,
    __in STRSAFE_LPCWSTR pszSrc,
    __deref_opt_out_bcount(*pcbRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in unsigned long dwFlags);
#ifdef UNICODE
#define StringCbCatEx  StringCbCatExW
#else
#define StringCbCatEx  StringCbCatExA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
#ifndef STRSAFE_NO_A_FUNCTIONS
STRSAFEAPI
StringCbCatExA(
    __inout_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cbDest,
    __in STRSAFE_LPCSTR pszSrc,
    __deref_opt_out_bcount(*pcbRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in unsigned long dwFlags)
{
    HRESULT hr;
    size_t cchDest;
    size_t cchRemaining = 0;

    // convert to count of characters
    cchDest = cbDest / sizeof(char);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringCatExWorkerA(pszDest, cchDest, cbDest, pszSrc, ppszDestEnd, &cchRemaining, dwFlags);
    }

    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
    {
        if (pcbRemaining)
        {
            // safe to multiply cchRemaining * sizeof(char) since cchRemaining < STRSAFE_MAX_CCH and sizeof(char) is 1
            *pcbRemaining = (cchRemaining * sizeof(char)) + (cbDest % sizeof(char));
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_A_FUNCTIONS
#ifndef STRSAFE_NO_W_FUNCTIONS
STRSAFEAPI
StringCbCatExW(
    __inout_bcount(cbDest) STRSAFE_LPWSTR pszDest,
    __in size_t cbDest,
    __in STRSAFE_LPCWSTR pszSrc,
    __deref_opt_out_bcount(*pcbRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in unsigned long dwFlags)
{
    HRESULT hr;
    size_t cchDest;
    size_t cchRemaining = 0;

    // convert to count of characters
    cchDest = cbDest / sizeof(wchar_t);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringCatExWorkerW(pszDest, cchDest, cbDest, pszSrc, ppszDestEnd, &cchRemaining, dwFlags);
    }

    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
    {
        if (pcbRemaining)
        {
            // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
            *pcbRemaining = (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_W_FUNCTIONS
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CB_FUNCTIONS


#ifndef STRSAFE_NO_CCH_FUNCTIONS
/*++

STDAPI
StringCchCatN(
    IN OUT LPTSTR  pszDest,
    IN     size_t  cchDest,
    IN     LPCTSTR pszSrc,
    IN     size_t  cchToAppend
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strncat'.
    The size of the destination buffer (in characters) is a parameter as well as
    the maximum number of characters to append, excluding the null terminator.
    This function will not write past the end of the destination buffer and it will
    ALWAYS null terminate pszDest (unless it is zero length).

    This function returns a hresult, and not a pointer.  It returns
    S_OK if all of pszSrc or the first cchToAppend characters were appended
    to the destination string and it was null terminated, otherwise it will
    return a failure code. In failure cases as much of pszSrc will be appended
    to pszDest as possible, and pszDest will be null terminated.

Arguments:

    pszDest         -   destination string which must be null terminated

    cchDest         -   size of destination buffer in characters.
                        length must be (_tcslen(pszDest) + min(cchToAppend, _tcslen(pszSrc)) + 1)
                        to hold all of the combine string plus the null
                        terminator.

    pszSrc          -   source string

    cchToAppend     -   maximum number of characters to append

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL. See StringCchCatNEx if you require
    the handling of NULL values.

Return Value:

    S_OK           -   if all of pszSrc or the first cchToAppend characters
                       were concatenated to pszDest and the resultant dest
                       string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the operation
                       failed due to insufficient space. When this error
                       occurs, the destination buffer is modified to contain
                       a truncated version of the ideal result and is null
                       terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/

STRSAFEAPI
StringCchCatNA(
    __inout_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in_ecount(cchToAppend) STRSAFE_LPCSTR pszSrc,
    __in size_t cchToAppend);

STRSAFEAPI
StringCchCatNW(
    __inout_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in_ecount(cchToAppend) STRSAFE_LPCWSTR pszSrc,
    __in size_t cchToAppend);
#ifdef UNICODE
#define StringCchCatN  StringCchCatNW
#else
#define StringCchCatN  StringCchCatNA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
#ifndef STRSAFE_NO_A_FUNCTIONS
STRSAFEAPI
StringCchCatNA(
    __inout_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in_ecount(cchToAppend) STRSAFE_LPCSTR pszSrc,
    __in size_t cchToAppend)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringCatNWorkerA(pszDest, cchDest, pszSrc, cchToAppend);
    }

    return hr;
}
#endif  // !STRSAFE_NO_A_FUNCTIONS
#ifndef STRSAFE_NO_W_FUNCTIONS
STRSAFEAPI
StringCchCatNW(
    __inout_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in_ecount(cchToAppend) STRSAFE_LPCWSTR pszSrc,
    __in size_t cchToAppend)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringCatNWorkerW(pszDest, cchDest, pszSrc, cchToAppend);
    }

    return hr;
}
#endif  // !STRSAFE_NO_W_FUNCTIONS
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CCH_FUNCTIONS


#ifndef STRSAFE_NO_CB_FUNCTIONS
/*++

STDAPI
StringCbCatN(
    IN OUT LPTSTR  pszDest,
    IN     size_t  cbDest,
    IN     LPCTSTR pszSrc,
    IN     size_t  cbToAppend
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strncat'.
    The size of the destination buffer (in bytes) is a parameter as well as
    the maximum number of bytes to append, excluding the null terminator.
    This function will not write past the end of the destination buffer and it will
    ALWAYS null terminate pszDest (unless it is zero length).

    This function returns a hresult, and not a pointer.  It returns
    S_OK if all of pszSrc or the first cbToAppend bytes were appended
    to the destination string and it was null terminated, otherwise it will
    return a failure code. In failure cases as much of pszSrc will be appended
    to pszDest as possible, and pszDest will be null terminated.

Arguments:

    pszDest         -   destination string which must be null terminated

    cbDest          -   size of destination buffer in bytes.
                        length must be ((_tcslen(pszDest) + min(cbToAppend / sizeof(TCHAR), _tcslen(pszSrc)) + 1) * sizeof(TCHAR)
                        to hold all of the combine string plus the null
                        terminator.

    pszSrc          -   source string

    cbToAppend      -   maximum number of bytes to append

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL. See StringCbCatNEx if you require
    the handling of NULL values.

Return Value:

    S_OK           -   if all of pszSrc or the first cbToAppend bytes were
                       concatenated to pszDest and the resultant dest string
                       was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the operation
                       failed due to insufficient space. When this error
                       occurs, the destination buffer is modified to contain
                       a truncated version of the ideal result and is null
                       terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/

STRSAFEAPI
StringCbCatNA(
    __inout_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cbDest,
    __in_bcount(cbToAppend) STRSAFE_LPCSTR pszSrc,
    __in size_t cbToAppend);

STRSAFEAPI
StringCbCatNW(
    __inout_bcount(cbDest) STRSAFE_LPWSTR pszDest,
    __in size_t cbDest,
    __in_bcount(cbToAppend) STRSAFE_LPCWSTR pszSrc,
    __in size_t cbToAppend);
#ifdef UNICODE
#define StringCbCatN  StringCbCatNW
#else
#define StringCbCatN  StringCbCatNA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
#ifndef STRSAFE_NO_A_FUNCTIONS
STRSAFEAPI
StringCbCatNA(
    __inout_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cbDest,
    __in_bcount(cbToAppend) STRSAFE_LPCSTR pszSrc,
    __in size_t cbToAppend)
{
    HRESULT hr;
    size_t cchDest;
    size_t cchToAppend;

    // convert to count of characters
    cchDest = cbDest / sizeof(char);
    cchToAppend = cbToAppend / sizeof(char);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringCatNWorkerA(pszDest, cchDest, pszSrc, cchToAppend);
    }

    return hr;
}
#endif  // !STRSAFE_NO_A_FUNCTIONS
#ifndef STRSAFE_NO_W_FUNCTIONS
STRSAFEAPI
StringCbCatNW(
    __inout_bcount(cbDest) STRSAFE_LPWSTR pszDest,
    __in size_t cbDest,
    __in_bcount(cbToAppend) STRSAFE_LPCWSTR pszSrc,
    __in size_t cbToAppend)
{
    HRESULT hr;
    size_t cchDest;
    size_t cchToAppend;

    // convert to count of characters
    cchDest = cbDest / sizeof(wchar_t);
    cchToAppend = cbToAppend / sizeof(wchar_t);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringCatNWorkerW(pszDest, cchDest, pszSrc, cchToAppend);
    }

    return hr;
}
#endif  // !STRSAFE_NO_W_FUNCTIONS
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CB_FUNCTIONS


#ifndef STRSAFE_NO_CCH_FUNCTIONS
/*++

STDAPI
StringCchCatNEx(
    IN OUT LPTSTR  pszDest         OPTIONAL,
    IN     size_t  cchDest,
    IN     LPCTSTR pszSrc          OPTIONAL,
    IN     size_t  cchToAppend,
    OUT    LPTSTR* ppszDestEnd     OPTIONAL,
    OUT    size_t* pcchRemaining   OPTIONAL,
    IN     DWORD   dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strncat', with
    some additional parameters.  In addition to functionality provided by
    StringCchCatN, this routine also returns a pointer to the end of the
    destination string and the number of characters left in the destination string
    including the null terminator. The flags parameter allows additional controls.

Arguments:

    pszDest         -   destination string which must be null terminated

    cchDest         -   size of destination buffer in characters.
                        length must be (_tcslen(pszDest) + min(cchToAppend, _tcslen(pszSrc)) + 1)
                        to hold all of the combine string plus the null
                        terminator.

    pszSrc          -   source string

    cchToAppend     -   maximum number of characters to append

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function appended any data, the result will point to the
                        null termination character

    pcchRemaining   -   if pcchRemaining is non-null, the function will return the
                        number of characters left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT(""))

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any pre-existing
                    or truncated string

        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any pre-existing or
                    truncated string

        STRSAFE_NO_TRUNCATION
                    if the function returns STRSAFE_E_INSUFFICIENT_BUFFER, pszDest
                    will not contain a truncated string, it will remain unchanged.

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL unless the STRSAFE_IGNORE_NULLS flag
    is specified.  If STRSAFE_IGNORE_NULLS is passed, both pszDest and pszSrc
    may be NULL.  An error may still be returned even though NULLS are ignored
    due to insufficient space.

Return Value:

    S_OK           -   if all of pszSrc or the first cchToAppend characters
                       were concatenated to pszDest and the resultant dest
                       string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the operation
                       failed due to insufficient space. When this error
                       occurs, the destination buffer is modified to contain
                       a truncated version of the ideal result and is null
                       terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/

STRSAFEAPI
StringCchCatNExA(
    __inout_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in_ecount(cchToAppend) STRSAFE_LPCSTR pszSrc,
    __in size_t cchToAppend,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags);

STRSAFEAPI
StringCchCatNExW(
    __inout_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in_ecount(cchToAppend) STRSAFE_LPCWSTR pszSrc,
    __in size_t cchToAppend,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags);
#ifdef UNICODE
#define StringCchCatNEx  StringCchCatNExW
#else
#define StringCchCatNEx  StringCchCatNExA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
#ifndef STRSAFE_NO_A_FUNCTIONS
STRSAFEAPI
StringCchCatNExA(
    __inout_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in_ecount(cchToAppend) STRSAFE_LPCSTR pszSrc,
    __in size_t cchToAppend,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        size_t cbDest;

        // safe to multiply cchDest * sizeof(char) since cchDest < STRSAFE_MAX_CCH and sizeof(char) is 1
        cbDest = cchDest * sizeof(char);

        hr = StringCatNExWorkerA(pszDest, cchDest, cbDest, pszSrc, cchToAppend, ppszDestEnd, pcchRemaining, dwFlags);
    }

    return hr;
}

#endif  // !STRSAFE_NO_A_FUNCTIONS
#ifndef STRSAFE_NO_W_FUNCTIONS
STRSAFEAPI
StringCchCatNExW(
    __inout_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in_ecount(cchToAppend) STRSAFE_LPCWSTR pszSrc,
    __in size_t cchToAppend,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        size_t cbDest;

        // safe to multiply cchDest * sizeof(wchar_t) since cchDest < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
        cbDest = cchDest * sizeof(wchar_t);

        hr = StringCatNExWorkerW(pszDest, cchDest, cbDest, pszSrc, cchToAppend, ppszDestEnd, pcchRemaining, dwFlags);
    }

    return hr;
}
#endif  // !STRSAFE_NO_W_FUNCTIONS
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CCH_FUNCTIONS


#ifndef STRSAFE_NO_CB_FUNCTIONS
/*++

STDAPI
StringCbCatNEx(
    IN OUT LPTSTR  pszDest         OPTIONAL,
    IN     size_t  cbDest,
    IN     LPCTSTR pszSrc          OPTIONAL,
    IN     size_t  cbToAppend,
    OUT    LPTSTR* ppszDestEnd     OPTIONAL,
    OUT    size_t* pcchRemaining   OPTIONAL,
    IN     DWORD   dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strncat', with
    some additional parameters.  In addition to functionality provided by
    StringCbCatN, this routine also returns a pointer to the end of the
    destination string and the number of bytes left in the destination string
    including the null terminator. The flags parameter allows additional controls.

Arguments:

    pszDest         -   destination string which must be null terminated

    cbDest          -   size of destination buffer in bytes.
                        length must be ((_tcslen(pszDest) + min(cbToAppend / sizeof(TCHAR), _tcslen(pszSrc)) + 1) * sizeof(TCHAR)
                        to hold all of the combine string plus the null
                        terminator.

    pszSrc          -   source string

    cbToAppend      -   maximum number of bytes to append

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function appended any data, the result will point to the
                        null termination character

    pcbRemaining    -   if pcbRemaining is non-null, the function will return the
                        number of bytes left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT(""))

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any pre-existing
                    or truncated string

        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any pre-existing or
                    truncated string

        STRSAFE_NO_TRUNCATION
                    if the function returns STRSAFE_E_INSUFFICIENT_BUFFER, pszDest
                    will not contain a truncated string, it will remain unchanged.

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL unless the STRSAFE_IGNORE_NULLS flag
    is specified.  If STRSAFE_IGNORE_NULLS is passed, both pszDest and pszSrc
    may be NULL.  An error may still be returned even though NULLS are ignored
    due to insufficient space.

Return Value:

    S_OK           -   if all of pszSrc or the first cbToAppend bytes were
                       concatenated to pszDest and the resultant dest string
                       was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the operation
                       failed due to insufficient space. When this error
                       occurs, the destination buffer is modified to contain
                       a truncated version of the ideal result and is null
                       terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/

STRSAFEAPI
StringCbCatNExA(
    __inout_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cbDest,
    __in_bcount(cbToAppend) STRSAFE_LPCSTR pszSrc,
    __in size_t cbToAppend,
    __deref_opt_out_bcount(*pcbRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in unsigned long dwFlags);

STRSAFEAPI
StringCbCatNExW(
    __inout_bcount(cbDest) STRSAFE_LPWSTR pszDest,
    __in size_t cbDest,
    __in_bcount(cbToAppend) STRSAFE_LPCWSTR pszSrc,
    __in size_t cbToAppend,
    __deref_opt_out_bcount(*pcbRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in unsigned long dwFlags);
#ifdef UNICODE
#define StringCbCatNEx  StringCbCatNExW
#else
#define StringCbCatNEx  StringCbCatNExA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
#ifndef STRSAFE_NO_A_FUNCTIONS
STRSAFEAPI
StringCbCatNExA(
    __inout_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cbDest,
    __in_bcount(cbToAppend) STRSAFE_LPCSTR pszSrc,
    __in size_t cbToAppend,
    __deref_opt_out_bcount(*pcbRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in unsigned long dwFlags)
{
    HRESULT hr;
    size_t cchDest;
    size_t cchToAppend;
    size_t cchRemaining = 0;

    // convert to count of characters
    cchDest = cbDest / sizeof(char);
    cchToAppend = cbToAppend / sizeof(char);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringCatNExWorkerA(pszDest, cchDest, cbDest, pszSrc, cchToAppend, ppszDestEnd, &cchRemaining, dwFlags);
    }

    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
    {
        if (pcbRemaining)
        {
            // safe to multiply cchRemaining * sizeof(char) since cchRemaining < STRSAFE_MAX_CCH and sizeof(char) is 1
            *pcbRemaining = (cchRemaining * sizeof(char)) + (cbDest % sizeof(char));
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_A_FUNCTIONS
#ifndef STRSAFE_NO_W_FUNCTIONS
STRSAFEAPI
StringCbCatNExW(
    __inout_bcount(cbDest) STRSAFE_LPWSTR pszDest,
    __in size_t cbDest,
    __in_bcount(cbToAppend) STRSAFE_LPCWSTR pszSrc,
    __in size_t cbToAppend,
    __deref_opt_out_bcount(*pcbRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in unsigned long dwFlags)
{
    HRESULT hr;
    size_t cchDest;
    size_t cchToAppend;
    size_t cchRemaining = 0;

    // convert to count of characters
    cchDest = cbDest / sizeof(wchar_t);
    cchToAppend = cbToAppend / sizeof(wchar_t);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringCatNExWorkerW(pszDest, cchDest, cbDest, pszSrc, cchToAppend, ppszDestEnd, &cchRemaining, dwFlags);
    }

    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
    {
        if (pcbRemaining)
        {
            // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
            *pcbRemaining = (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_W_FUNCTIONS
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CB_FUNCTIONS

#endif  // !STRSAFE_ONLY_SPRINTF_FUNCTIONS

#ifndef STRSAFE_NO_SPRINTF_FUNCTIONS

#ifndef STRSAFE_NO_CCH_FUNCTIONS
/*++

STDAPI
StringCchVPrintf(
    OUT LPTSTR  pszDest,
    IN  size_t  cchDest,
    IN  LPCTSTR pszFormat,
    IN  va_list argList
    );

Routine Description:

    This routine is a safer version of the C built-in function 'vsprintf'.
    The size of the destination buffer (in characters) is a parameter and
    this function will not write past the end of this buffer and it will
    ALWAYS null terminate the destination buffer (unless it is zero length).

    This function returns a hresult, and not a pointer.  It returns
    S_OK if the string was printed without truncation and null terminated,
    otherwise it will return a failure code. In failure cases it will return
    a truncated version of the ideal result.

Arguments:

    pszDest     -  destination string

    cchDest     -  size of destination buffer in characters
                   length must be sufficient to hold the resulting formatted
                   string, including the null terminator.

    pszFormat   -  format string which must be null terminated

    argList     -  va_list from the variable arguments according to the
                   stdarg.h convention

Notes:
    Behavior is undefined if destination, format strings or any arguments
    strings overlap.

    pszDest and pszFormat should not be NULL.  See StringCchVPrintfEx if you
    require the handling of NULL values.

Return Value:

    S_OK           -   if there was sufficient space in the dest buffer for
                       the resultant string and it was null terminated.

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the print
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/

STRSAFEAPI
StringCchVPrintfA(
    __out_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in __format_string STRSAFE_LPCSTR pszFormat,
    va_list argList);

STRSAFEAPI
StringCchVPrintfW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in __format_string STRSAFE_LPCWSTR pszFormat,
    __in va_list argList);
#ifdef UNICODE
#define StringCchVPrintf  StringCchVPrintfW
#else
#define StringCchVPrintf  StringCchVPrintfA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
#ifndef STRSAFE_NO_A_FUNCTIONS
STRSAFEAPI
StringCchVPrintfA(
    __out_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in __format_string STRSAFE_LPCSTR pszFormat,
    __in va_list argList)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringVPrintfWorkerA(pszDest, cchDest, pszFormat, argList);
    }

    return hr;
}
#endif  // !STRSAFE_NO_A_FUNCTIONS
#ifndef STRSAFE_NO_W_FUNCTIONS
STRSAFEAPI
StringCchVPrintfW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in __format_string STRSAFE_LPCWSTR pszFormat,
    __in va_list argList)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringVPrintfWorkerW(pszDest, cchDest, pszFormat, argList);
    }

    return hr;
}
#endif  // !STRSAFE_NO_W_FUNCTIONS
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CCH_FUNCTIONS


#ifndef STRSAFE_NO_CB_FUNCTIONS
/*++

STDAPI
StringCbVPrintf(
    OUT LPTSTR  pszDest,
    IN  size_t  cbDest,
    IN  LPCTSTR pszFormat,
    IN  va_list argList
    );

Routine Description:

    This routine is a safer version of the C built-in function 'vsprintf'.
    The size of the destination buffer (in bytes) is a parameter and
    this function will not write past the end of this buffer and it will
    ALWAYS null terminate the destination buffer (unless it is zero length).

    This function returns a hresult, and not a pointer.  It returns
    S_OK if the string was printed without truncation and null terminated,
    otherwise it will return a failure code. In failure cases it will return
    a truncated version of the ideal result.

Arguments:

    pszDest     -  destination string

    cbDest      -  size of destination buffer in bytes
                   length must be sufficient to hold the resulting formatted
                   string, including the null terminator.

    pszFormat   -  format string which must be null terminated

    argList     -  va_list from the variable arguments according to the
                   stdarg.h convention

Notes:
    Behavior is undefined if destination, format strings or any arguments
    strings overlap.

    pszDest and pszFormat should not be NULL.  See StringCbVPrintfEx if you
    require the handling of NULL values.


Return Value:

    S_OK           -   if there was sufficient space in the dest buffer for
                       the resultant string and it was null terminated.

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the print
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/

STRSAFEAPI
StringCbVPrintfA(
    __out_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cbDest,
    __in __format_string STRSAFE_LPCSTR pszFormat,
    __in va_list argList);

STRSAFEAPI
StringCbVPrintfW(
    __out_bcount(cbDest) STRSAFE_LPWSTR pszDest,
    __in size_t cbDest,
    __in __format_string STRSAFE_LPCWSTR pszFormat,
    __in va_list argList);
#ifdef UNICODE
#define StringCbVPrintf  StringCbVPrintfW
#else
#define StringCbVPrintf  StringCbVPrintfA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
#ifndef STRSAFE_NO_A_FUNCTIONS
STRSAFEAPI
StringCbVPrintfA(
    __out_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cbDest,
    __in __format_string STRSAFE_LPCSTR pszFormat,
    __in va_list argList)
{
    HRESULT hr;
    size_t cchDest;

    // convert to count of characters
    cchDest = cbDest / sizeof(char);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringVPrintfWorkerA(pszDest, cchDest, pszFormat, argList);
    }

    return hr;
}
#endif  // !STRSAFE_NO_A_FUNCTIONS
#ifndef STRSAFE_NO_W_FUNCTIONS
STRSAFEAPI
StringCbVPrintfW(
    __out_bcount(cbDest) STRSAFE_LPWSTR pszDest,
    __in size_t cbDest,
    __in __format_string STRSAFE_LPCWSTR pszFormat,
    __in va_list argList)

{
    HRESULT hr;
    size_t cchDest;

    // convert to count of characters
    cchDest = cbDest / sizeof(wchar_t);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringVPrintfWorkerW(pszDest, cchDest, pszFormat, argList);
    }

    return hr;
}
#endif  // !STRSAFE_NO_W_FUNCTIONS
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CB_FUNCTIONS

#ifndef STRSAFE_NO_CCH_FUNCTIONS
/*++

STDAPI
StringCchPrintf(
    OUT LPTSTR  pszDest,
    IN  size_t  cchDest,
    IN  LPCTSTR pszFormat,
    ...
    );

Routine Description:

    This routine is a safer version of the C built-in function 'sprintf'.
    The size of the destination buffer (in characters) is a parameter and
    this function will not write past the end of this buffer and it will
    ALWAYS null terminate the destination buffer (unless it is zero length).

    This function returns a hresult, and not a pointer.  It returns
    S_OK if the string was printed without truncation and null terminated,
    otherwise it will return a failure code. In failure cases it will return
    a truncated version of the ideal result.

Arguments:

    pszDest     -  destination string

    cchDest     -  size of destination buffer in characters
                   length must be sufficient to hold the resulting formatted
                   string, including the null terminator.

    pszFormat   -  format string which must be null terminated

    ...         -  additional parameters to be formatted according to
                   the format string

Notes:
    Behavior is undefined if destination, format strings or any arguments
    strings overlap.

    pszDest and pszFormat should not be NULL.  See StringCchPrintfEx if you
    require the handling of NULL values.

Return Value:

    S_OK           -   if there was sufficient space in the dest buffer for
                       the resultant string and it was null terminated.

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the print
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/

STRSAFEAPI
StringCchPrintfA(
    __out_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in __format_string STRSAFE_LPCSTR pszFormat,
    ...);

STRSAFEAPI
StringCchPrintfW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in __format_string STRSAFE_LPCWSTR pszFormat,
    ...);
#ifdef UNICODE
#define StringCchPrintf  StringCchPrintfW
#else
#define StringCchPrintf  StringCchPrintfA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
#pragma warning( push )
#pragma warning( disable : 4793 )
#ifndef STRSAFE_NO_A_FUNCTIONS
STRSAFEAPI
StringCchPrintfA(
    __out_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in __format_string STRSAFE_LPCSTR pszFormat,
    ...)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        va_list argList;

        va_start(argList, pszFormat);

        hr = StringVPrintfWorkerA(pszDest, cchDest, pszFormat, argList);

        va_end(argList);
    }

    return hr;
}
#endif  // !STRSAFE_NO_A_FUNCTIONS
#ifndef STRSAFE_NO_W_FUNCTIONS
STRSAFEAPI
StringCchPrintfW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in __format_string STRSAFE_LPCWSTR pszFormat,
    ...)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        va_list argList;

        va_start(argList, pszFormat);

        hr = StringVPrintfWorkerW(pszDest, cchDest, pszFormat, argList);

        va_end(argList);
    }

    return hr;
}
#endif  // !STRSAFE_NO_W_FUNCTIONS
#pragma warning( pop )
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CCH_FUNCTIONS


#ifndef STRSAFE_NO_CB_FUNCTIONS
/*++

STDAPI
StringCbPrintf(
    OUT LPTSTR  pszDest,
    IN  size_t  cbDest,
    IN  LPCTSTR pszFormat,
    ...
    );

Routine Description:

    This routine is a safer version of the C built-in function 'sprintf'.
    The size of the destination buffer (in bytes) is a parameter and
    this function will not write past the end of this buffer and it will
    ALWAYS null terminate the destination buffer (unless it is zero length).

    This function returns a hresult, and not a pointer.  It returns
    S_OK if the string was printed without truncation and null terminated,
    otherwise it will return a failure code. In failure cases it will return
    a truncated version of the ideal result.

Arguments:

    pszDest     -  destination string

    cbDest      -  size of destination buffer in bytes
                   length must be sufficient to hold the resulting formatted
                   string, including the null terminator.

    pszFormat   -  format string which must be null terminated

    ...         -  additional parameters to be formatted according to
                   the format string

Notes:
    Behavior is undefined if destination, format strings or any arguments
    strings overlap.

    pszDest and pszFormat should not be NULL.  See StringCbPrintfEx if you
    require the handling of NULL values.


Return Value:

    S_OK           -   if there was sufficient space in the dest buffer for
                       the resultant string and it was null terminated.

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the print
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/

STRSAFEAPI
StringCbPrintfA(
    __out_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cbDest,
    __in __format_string STRSAFE_LPCSTR pszFormat,
    ...);

STRSAFEAPI
StringCbPrintfW(
    __out_bcount(cbDest) STRSAFE_LPWSTR pszDest,
    __in size_t cbDest,
    __in __format_string STRSAFE_LPCWSTR pszFormat,
    ...);
#ifdef UNICODE
#define StringCbPrintf  StringCbPrintfW
#else
#define StringCbPrintf  StringCbPrintfA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
#pragma warning( push )
#pragma warning( disable : 4793 )
#ifndef STRSAFE_NO_A_FUNCTIONS
STRSAFEAPI
StringCbPrintfA(
    __out_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cbDest,
    __in __format_string STRSAFE_LPCSTR pszFormat,
    ...)
{
    HRESULT hr;
    size_t cchDest;

    // convert to count of characters
    cchDest = cbDest / sizeof(char);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        va_list argList;

        va_start(argList, pszFormat);

        hr = StringVPrintfWorkerA(pszDest, cchDest, pszFormat, argList);

        va_end(argList);
    }

    return hr;
}
#endif  // !STRSAFE_NO_A_FUNCTIONS
#ifndef STRSAFE_NO_W_FUNCTIONS
STRSAFEAPI
StringCbPrintfW(
    __out_bcount(cbDest) STRSAFE_LPWSTR pszDest,
    __in size_t cbDest,
    __in __format_string STRSAFE_LPCWSTR pszFormat,
    ...)
{
    HRESULT hr;
    size_t cchDest;

    // convert to count of characters
    cchDest = cbDest / sizeof(wchar_t);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        va_list argList;

        va_start(argList, pszFormat);

        hr = StringVPrintfWorkerW(pszDest, cchDest, pszFormat, argList);

        va_end(argList);
    }

    return hr;
}
#endif  // !STRSAFE_NO_W_FUNCTIONS
#pragma warning ( pop )
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CB_FUNCTIONS


#ifndef STRSAFE_NO_CCH_FUNCTIONS
/*++

STDAPI
StringCchPrintfEx(
    OUT LPTSTR  pszDest         OPTIONAL,
    IN  size_t  cchDest,
    OUT LPTSTR* ppszDestEnd     OPTIONAL,
    OUT size_t* pcchRemaining   OPTIONAL,
    IN  DWORD   dwFlags,
    IN  LPCTSTR pszFormat       OPTIONAL,
    ...
    );

Routine Description:

    This routine is a safer version of the C built-in function 'sprintf' with
    some additional parameters.  In addition to functionality provided by
    StringCchPrintf, this routine also returns a pointer to the end of the
    destination string and the number of characters left in the destination string
    including the null terminator. The flags parameter allows additional controls.

Arguments:

    pszDest         -   destination string

    cchDest         -   size of destination buffer in characters.
                        length must be sufficient to contain the resulting
                        formatted string plus the null terminator.

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function printed any data, the result will point to the
                        null termination character

    pcchRemaining   -   if pcchRemaining is non-null, the function will return
                        the number of characters left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT(""))

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any truncated
                    string returned when the failure is
                    STRSAFE_E_INSUFFICIENT_BUFFER

        STRSAFE_NO_TRUNCATION /
        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any truncated string
                    returned when the failure is STRSAFE_E_INSUFFICIENT_BUFFER.

    pszFormat       -   format string which must be null terminated

    ...             -   additional parameters to be formatted according to
                        the format string

Notes:
    Behavior is undefined if destination, format strings or any arguments
    strings overlap.

    pszDest and pszFormat should not be NULL unless the STRSAFE_IGNORE_NULLS
    flag is specified.  If STRSAFE_IGNORE_NULLS is passed, both pszDest and
    pszFormat may be NULL.  An error may still be returned even though NULLS
    are ignored due to insufficient space.

Return Value:

    S_OK           -   if there was source data and it was all concatenated and
                       the resultant dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the print
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/

STRSAFEAPI
StringCchPrintfExA(
    __out_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags,
    __in __format_string STRSAFE_LPCSTR pszFormat,
    ...);

STRSAFEAPI
StringCchPrintfExW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags,
    __in __format_string STRSAFE_LPCWSTR pszFormat,
    ...);
#ifdef UNICODE
#define StringCchPrintfEx  StringCchPrintfExW
#else
#define StringCchPrintfEx  StringCchPrintfExA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
#pragma warning( push )
#pragma warning( disable : 4793 )
#ifndef STRSAFE_NO_A_FUNCTIONS
STRSAFEAPI
StringCchPrintfExA(
    __out_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags,
    __in __format_string STRSAFE_LPCSTR pszFormat,
    ...)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        size_t cbDest;
        va_list argList;

        // safe to multiply cchDest * sizeof(char) since cchDest < STRSAFE_MAX_CCH and sizeof(char) is 1
        cbDest = cchDest * sizeof(char);
        va_start(argList, pszFormat);

        hr = StringVPrintfExWorkerA(pszDest, cchDest, cbDest, ppszDestEnd, pcchRemaining, dwFlags, pszFormat, argList);

        va_end(argList);
    }

    return hr;
}
#endif  // !STRSAFE_NO_A_FUNCTIONS
#ifndef STRSAFE_NO_W_FUNCTIONS
STRSAFEAPI
StringCchPrintfExW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags,
    __in __format_string STRSAFE_LPCWSTR pszFormat,
    ...)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        size_t cbDest;
        va_list argList;

        // safe to multiply cchDest * sizeof(wchar_t) since cchDest < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
        cbDest = cchDest * sizeof(wchar_t);
        va_start(argList, pszFormat);

        hr = StringVPrintfExWorkerW(pszDest, cchDest, cbDest, ppszDestEnd, pcchRemaining, dwFlags, pszFormat, argList);

        va_end(argList);
    }

    return hr;
}
#endif  // !STRSAFE_NO_W_FUNCTIONS
#pragma warning( pop )
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CCH_FUNCTIONS


#ifndef STRSAFE_NO_CB_FUNCTIONS
/*++

STDAPI
StringCbPrintfEx(
    OUT LPTSTR  pszDest         OPTIONAL,
    IN  size_t  cbDest,
    OUT LPTSTR* ppszDestEnd     OPTIONAL,
    OUT size_t* pcbRemaining    OPTIONAL,
    IN  DWORD   dwFlags,
    IN  LPCTSTR pszFormat       OPTIONAL,
    ...
    );

Routine Description:

    This routine is a safer version of the C built-in function 'sprintf' with
    some additional parameters.  In addition to functionality provided by
    StringCbPrintf, this routine also returns a pointer to the end of the
    destination string and the number of bytes left in the destination string
    including the null terminator. The flags parameter allows additional controls.

Arguments:

    pszDest         -   destination string

    cbDest          -   size of destination buffer in bytes.
                        length must be sufficient to contain the resulting
                        formatted string plus the null terminator.

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function printed any data, the result will point to the
                        null termination character

    pcbRemaining    -   if pcbRemaining is non-null, the function will return
                        the number of bytes left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT(""))

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any truncated
                    string returned when the failure is
                    STRSAFE_E_INSUFFICIENT_BUFFER

        STRSAFE_NO_TRUNCATION /
        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any truncated string
                    returned when the failure is STRSAFE_E_INSUFFICIENT_BUFFER.

    pszFormat       -   format string which must be null terminated

    ...             -   additional parameters to be formatted according to
                        the format string

Notes:
    Behavior is undefined if destination, format strings or any arguments
    strings overlap.

    pszDest and pszFormat should not be NULL unless the STRSAFE_IGNORE_NULLS
    flag is specified.  If STRSAFE_IGNORE_NULLS is passed, both pszDest and
    pszFormat may be NULL.  An error may still be returned even though NULLS
    are ignored due to insufficient space.

Return Value:

    S_OK           -   if there was source data and it was all concatenated and
                       the resultant dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the print
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/

STRSAFEAPI
StringCbPrintfExA(
    __out_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cbDest,
    __deref_opt_out_bcount(*pcbRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in unsigned long dwFlags,
    __in __format_string STRSAFE_LPCSTR pszFormat,
    ...);

STRSAFEAPI
StringCbPrintfExW(
    __out_bcount(cbDest) STRSAFE_LPWSTR pszDest,
    __in size_t cbDest,
    __deref_opt_out_bcount(*pcbRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in unsigned long dwFlags,
    __in __format_string STRSAFE_LPCWSTR pszFormat,
    ...);
#ifdef UNICODE
#define StringCbPrintfEx  StringCbPrintfExW
#else
#define StringCbPrintfEx  StringCbPrintfExA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
#pragma warning( push )
#pragma warning( disable : 4793 )
#ifndef STRSAFE_NO_A_FUNCTIONS
STRSAFEAPI
StringCbPrintfExA(
    __out_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cbDest,
    __deref_opt_out_bcount(*pcbRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in unsigned long dwFlags,
    __in __format_string STRSAFE_LPCSTR pszFormat,
    ...)
{
    HRESULT hr;
    size_t cchDest;
    size_t cchRemaining = 0;

    // convert to count of characters
    cchDest = cbDest / sizeof(char);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        va_list argList;

        va_start(argList, pszFormat);

        hr = StringVPrintfExWorkerA(pszDest, cchDest, cbDest, ppszDestEnd, &cchRemaining, dwFlags, pszFormat, argList);

        va_end(argList);
    }

    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
    {
        if (pcbRemaining)
        {
            // safe to multiply cchRemaining * sizeof(char) since cchRemaining < STRSAFE_MAX_CCH and sizeof(char) is 1
            *pcbRemaining = (cchRemaining * sizeof(char)) + (cbDest % sizeof(char));
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_A_FUNCTIONS
#ifndef STRSAFE_NO_W_FUNCTIONS
STRSAFEAPI
StringCbPrintfExW(
    __out_bcount(cbDest) STRSAFE_LPWSTR pszDest,
    __in size_t cbDest,
    __deref_opt_out_bcount(*pcbRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in unsigned long dwFlags,
    __in __format_string STRSAFE_LPCWSTR pszFormat,
    ...)
{
    HRESULT hr;
    size_t cchDest;
    size_t cchRemaining = 0;

    // convert to count of characters
    cchDest = cbDest / sizeof(wchar_t);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        va_list argList;

        va_start(argList, pszFormat);

        hr = StringVPrintfExWorkerW(pszDest, cchDest, cbDest, ppszDestEnd, &cchRemaining, dwFlags, pszFormat, argList);

        va_end(argList);
    }

    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
    {
        if (pcbRemaining)
        {
            // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
            *pcbRemaining = (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_W_FUNCTIONS
#pragma warning( pop )
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CB_FUNCTIONS

#ifndef STRSAFE_NO_CCH_FUNCTIONS
/*++

STDAPI
StringCchVPrintfEx(
    OUT LPTSTR  pszDest         OPTIONAL,
    IN  size_t  cchDest,
    OUT LPTSTR* ppszDestEnd     OPTIONAL,
    OUT size_t* pcchRemaining   OPTIONAL,
    IN  DWORD   dwFlags,
    IN  LPCTSTR pszFormat       OPTIONAL,
    IN  va_list argList
    );

Routine Description:

    This routine is a safer version of the C built-in function 'vsprintf' with
    some additional parameters.  In addition to functionality provided by
    StringCchVPrintf, this routine also returns a pointer to the end of the
    destination string and the number of characters left in the destination string
    including the null terminator. The flags parameter allows additional controls.

Arguments:

    pszDest         -   destination string

    cchDest         -   size of destination buffer in characters.
                        length must be sufficient to contain the resulting
                        formatted string plus the null terminator.

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function printed any data, the result will point to the
                        null termination character

    pcchRemaining   -   if pcchRemaining is non-null, the function will return
                        the number of characters left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT(""))

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any truncated
                    string returned when the failure is
                    STRSAFE_E_INSUFFICIENT_BUFFER

        STRSAFE_NO_TRUNCATION /
        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any truncated string
                    returned when the failure is STRSAFE_E_INSUFFICIENT_BUFFER.

    pszFormat       -   format string which must be null terminated

    argList         -   va_list from the variable arguments according to the
                        stdarg.h convention

Notes:
    Behavior is undefined if destination, format strings or any arguments
    strings overlap.

    pszDest and pszFormat should not be NULL unless the STRSAFE_IGNORE_NULLS
    flag is specified.  If STRSAFE_IGNORE_NULLS is passed, both pszDest and
    pszFormat may be NULL.  An error may still be returned even though NULLS
    are ignored due to insufficient space.

Return Value:

    S_OK           -   if there was source data and it was all concatenated and
                       the resultant dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the print
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/

STRSAFEAPI
StringCchVPrintfExA(
    __out_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags,
    __in __format_string STRSAFE_LPCSTR pszFormat,
    __in va_list argList);

STRSAFEAPI
StringCchVPrintfExW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags,
    __in __format_string STRSAFE_LPCWSTR pszFormat,
    __in va_list argList);
#ifdef UNICODE
#define StringCchVPrintfEx  StringCchVPrintfExW
#else
#define StringCchVPrintfEx  StringCchVPrintfExA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
#ifndef STRSAFE_NO_A_FUNCTIONS
STRSAFEAPI
StringCchVPrintfExA(
    __out_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags,
    __in __format_string STRSAFE_LPCSTR pszFormat,
    __in va_list argList)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        size_t cbDest;

        // safe to multiply cchDest * sizeof(char) since cchDest < STRSAFE_MAX_CCH and sizeof(char) is 1
        cbDest = cchDest * sizeof(char);

        hr = StringVPrintfExWorkerA(pszDest, cchDest, cbDest, ppszDestEnd, pcchRemaining, dwFlags, pszFormat, argList);
    }

    return hr;
}
#endif  // !STRSAFE_NO_A_FUNCTIONS
#ifndef STRSAFE_NO_W_FUNCTIONS
STRSAFEAPI
StringCchVPrintfExW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags,
    __in __format_string STRSAFE_LPCWSTR pszFormat,
    __in va_list argList)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        size_t cbDest;

        // safe to multiply cchDest * sizeof(wchar_t) since cchDest < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
        cbDest = cchDest * sizeof(wchar_t);

        hr = StringVPrintfExWorkerW(pszDest, cchDest, cbDest, ppszDestEnd, pcchRemaining, dwFlags, pszFormat, argList);
    }

    return hr;
}
#endif  // !STRSAFE_NO_W_FUNCTIONS
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CCH_FUNCTIONS


#ifndef STRSAFE_NO_CB_FUNCTIONS
/*++

STDAPI
StringCbVPrintfEx(
    OUT LPTSTR  pszDest         OPTIONAL,
    IN  size_t  cbDest,
    OUT LPTSTR* ppszDestEnd     OPTIONAL,
    OUT size_t* pcbRemaining    OPTIONAL,
    IN  DWORD   dwFlags,
    IN  LPCTSTR pszFormat       OPTIONAL,
    IN  va_list argList
    );

Routine Description:

    This routine is a safer version of the C built-in function 'vsprintf' with
    some additional parameters.  In addition to functionality provided by
    StringCbVPrintf, this routine also returns a pointer to the end of the
    destination string and the number of characters left in the destination string
    including the null terminator. The flags parameter allows additional controls.

Arguments:

    pszDest         -   destination string

    cbDest          -   size of destination buffer in bytes.
                        length must be sufficient to contain the resulting
                        formatted string plus the null terminator.

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return
                        a pointer to the end of the destination string.  If the
                        function printed any data, the result will point to the
                        null termination character

    pcbRemaining    -   if pcbRemaining is non-null, the function will return
                        the number of bytes left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT(""))

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any truncated
                    string returned when the failure is
                    STRSAFE_E_INSUFFICIENT_BUFFER

        STRSAFE_NO_TRUNCATION /
        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any truncated string
                    returned when the failure is STRSAFE_E_INSUFFICIENT_BUFFER.

    pszFormat       -   format string which must be null terminated

    argList         -   va_list from the variable arguments according to the
                        stdarg.h convention

Notes:
    Behavior is undefined if destination, format strings or any arguments
    strings overlap.

    pszDest and pszFormat should not be NULL unless the STRSAFE_IGNORE_NULLS
    flag is specified.  If STRSAFE_IGNORE_NULLS is passed, both pszDest and
    pszFormat may be NULL.  An error may still be returned even though NULLS
    are ignored due to insufficient space.

Return Value:

    S_OK           -   if there was source data and it was all concatenated and
                       the resultant dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the print
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/

STRSAFEAPI
StringCbVPrintfExA(
    __out_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cbDest,
    __deref_opt_out_bcount(*pcbRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in unsigned long dwFlags,
    __in __format_string STRSAFE_LPCSTR pszFormat,
    __in va_list argList);

STRSAFEAPI
StringCbVPrintfExW(
    __out_bcount(cbDest) STRSAFE_LPWSTR pszDest,
    __in size_t cbDest,
    __deref_opt_out_bcount(*pcbRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in unsigned long dwFlags,
    __in __format_string STRSAFE_LPCWSTR pszFormat,
    __in va_list argList);
#ifdef UNICODE
#define StringCbVPrintfEx  StringCbVPrintfExW
#else
#define StringCbVPrintfEx  StringCbVPrintfExA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
#ifndef STRSAFE_NO_A_FUNCTIONS
STRSAFEAPI
StringCbVPrintfExA(
    __out_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cbDest,
    __deref_opt_out_bcount(*pcbRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in unsigned long dwFlags,
    __in __format_string STRSAFE_LPCSTR pszFormat,
    __in va_list argList)
{
    HRESULT hr;
    size_t cchDest;
    size_t cchRemaining = 0;

    // convert to count of characters
    cchDest = cbDest / sizeof(char);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringVPrintfExWorkerA(pszDest, cchDest, cbDest, ppszDestEnd, &cchRemaining, dwFlags, pszFormat, argList);
    }

    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
    {
        if (pcbRemaining)
        {
            // safe to multiply cchRemaining * sizeof(char) since cchRemaining < STRSAFE_MAX_CCH and sizeof(char) is 1
            *pcbRemaining = (cchRemaining * sizeof(char)) + (cbDest % sizeof(char));
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_A_FUNCTIONS
#ifndef STRSAFE_NO_W_FUNCTIONS
STRSAFEAPI
StringCbVPrintfExW(
    __out_bcount(cbDest) STRSAFE_LPWSTR pszDest,
    __in size_t cbDest,
    __deref_opt_out_bcount(*pcbRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in unsigned long dwFlags,
    __in __format_string STRSAFE_LPCWSTR pszFormat,
    __in va_list argList)
{
    HRESULT hr;
    size_t cchDest;
    size_t cchRemaining = 0;

    // convert to count of characters
    cchDest = cbDest / sizeof(wchar_t);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringVPrintfExWorkerW(pszDest, cchDest, cbDest, ppszDestEnd, &cchRemaining, dwFlags, pszFormat, argList);
    }

    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
    {
        if (pcbRemaining)
        {
            // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
            *pcbRemaining = (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_W_FUNCTIONS
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CB_FUNCTIONS

#endif  // !STRSAFE_NO_SPRINTF_FUNCTIONS

#ifndef STRSAFE_ONLY_SPRINTF_FUNCTIONS

#ifndef STRSAFE_NO_CCH_FUNCTIONS
/*++

STDAPI
StringCchGets(
    OUT LPTSTR  pszDest,
    IN  size_t  cchDest
    );

Routine Description:

    This routine is a safer version of the C built-in function 'gets'.
    The size of the destination buffer (in characters) is a parameter and
    this function will not write past the end of this buffer and it will
    ALWAYS null terminate the destination buffer (unless it is zero length).

    This routine is not a replacement for fgets.  That function does not replace
    newline characters with a null terminator.

    This function returns a hresult, and not a pointer.  It returns
    S_OK if any characters were read from stdin and copied to pszDest and
    pszDest was null terminated, otherwise it will return a failure code.

Arguments:

    pszDest     -   destination string

    cchDest     -   size of destination buffer in characters.

Notes:
    pszDest should not be NULL. See StringCchGetsEx if you require the handling
    of NULL values.

    cchDest must be > 1 for this function to succeed.

Return Value:

    S_OK           -   data was read from stdin and copied, and the resultant
                       dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_END_OF_FILE /
      HRESULT_CODE(hr) == ERROR_HANDLE_EOF
                   -   this return value indicates an error or end-of-file
                       condition, use feof or ferror to determine which one has
                       occured.

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that there was
                       insufficient space in the destination buffer to copy any
                       data

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function.

--*/

#ifdef STRSAFE_WITH_GETS
#ifndef STRSAFE_LIB_IMPL
STRSAFE_INLINE_API
StringCchGetsA(
    __out_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest);

STRSAFE_INLINE_API
StringCchGetsW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest);
#ifdef UNICODE
#define StringCchGets  StringCchGetsW
#else
#define StringCchGets  StringCchGetsA
#endif // !UNICODE

#ifndef STRSAFE_NO_A_FUNCTIONS
STRSAFE_INLINE_API
StringCchGetsA(
    __out_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        size_t cbDest;

        // safe to multiply cchDest * sizeof(char) since cchDest < STRSAFE_MAX_CCH and sizeof(char) is 1
        cbDest = cchDest * sizeof(char);

        hr = StringGetsExWorkerA(pszDest, cchDest, cbDest, NULL, NULL, 0);
    }

    return hr;
}
#endif  // !STRSAFE_NO_A_FUNCTIONS
#ifndef STRSAFE_NO_W_FUNCTIONS
STRSAFE_INLINE_API
StringCchGetsW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        size_t cbDest;

        // safe to multiply cchDest * sizeof(wchar_t) since cchDest < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
        cbDest = cchDest * sizeof(wchar_t);

        hr = StringGetsExWorkerW(pszDest, cchDest, cbDest, NULL, NULL, 0);
    }

    return hr;
}
#endif  // !STRSAFE_NO_W_FUNCTIONS
#endif  // !STRSAFE_LIB_IMPL
#endif  // STRSAFE_WITH_GETS
#endif  // !STRSAFE_NO_CCH_FUNCTIONS

#ifndef STRSAFE_NO_CB_FUNCTIONS
/*++

STDAPI
StringCbGets(
    OUT LPTSTR  pszDest,
    IN  size_t  cbDest
    );

Routine Description:

    This routine is a safer version of the C built-in function 'gets'.
    The size of the destination buffer (in bytes) is a parameter and
    this function will not write past the end of this buffer and it will
    ALWAYS null terminate the destination buffer (unless it is zero length).

    This routine is not a replacement for fgets.  That function does not replace
    newline characters with a null terminator.

    This function returns a hresult, and not a pointer.  It returns
    S_OK if any characters were read from stdin and copied to pszDest
    and pszDest was null terminated, otherwise it will return a failure code.

Arguments:

    pszDest     -   destination string

    cbDest      -   size of destination buffer in bytes.

Notes:
    pszDest should not be NULL. See StringCbGetsEx if you require the handling
    of NULL values.

    cbDest must be > sizeof(TCHAR) for this function to succeed.

Return Value:

    S_OK           -   data was read from stdin and copied, and the resultant
                       dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_END_OF_FILE /
      HRESULT_CODE(hr) == ERROR_HANDLE_EOF
                   -   this return value indicates an error or end-of-file
                       condition, use feof or ferror to determine which one has
                       occured.

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that there was
                       insufficient space in the destination buffer to copy any
                       data

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function.

--*/

#ifdef STRSAFE_WITH_GETS
#ifndef STRSAFE_LIB_IMPL
STRSAFE_INLINE_API
StringCbGetsA(
    __out_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cbDest);

STRSAFE_INLINE_API
StringCbGetsW(
    __out_bcount(cbDest) STRSAFE_LPWSTR pszDest,
    __in size_t cbDest);

#ifdef UNICODE
#define StringCbGets  StringCbGetsW
#else
#define StringCbGets  StringCbGetsA
#endif // !UNICODE

#ifndef STRSAFE_NO_A_FUNCTIONS
STRSAFE_INLINE_API
StringCbGetsA(
    __out_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cbDest)
{
    HRESULT hr;
    size_t cchDest;

    // convert to count of characters
    cchDest = cbDest / sizeof(char);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringGetsExWorkerA(pszDest, cchDest, cbDest, NULL, NULL, 0);
    }

    return hr;
}
#endif  // !STRSAFE_NO_A_FUNCTIONS
#ifndef STRSAFE_NO_W_FUNCTIONS
STRSAFE_INLINE_API
StringCbGetsW(
    __out_bcount(cbDest) STRSAFE_LPWSTR pszDest,
    __in size_t cbDest)
{
    HRESULT hr;
    size_t cchDest;

    // convert to count of characters
    cchDest = cbDest / sizeof(wchar_t);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringGetsExWorkerW(pszDest, cchDest, cbDest, NULL, NULL, 0);
    }

    return hr;
}
#endif  // !STRSAFE_NO_W_FUNCTIONS
#endif  // !STRSAFE_LIB_IMPL
#endif  // STRSAFE_WITH_GETS
#endif  // !STRSAFE_NO_CB_FUNCTIONS

#ifndef STRSAFE_NO_CCH_FUNCTIONS
/*++

STDAPI
StringCchGetsEx(
    OUT LPTSTR  pszDest         OPTIONAL,
    IN  size_t  cchDest,
    OUT LPTSTR* ppszDestEnd     OPTIONAL,
    OUT size_t* pcchRemaining   OPTIONAL,
    IN  DWORD   dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'gets' with
    some additional parameters. In addition to functionality provided by
    StringCchGets, this routine also returns a pointer to the end of the
    destination string and the number of characters left in the destination string
    including the null terminator. The flags parameter allows additional controls.

Arguments:

    pszDest         -   destination string

    cchDest         -   size of destination buffer in characters.

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function copied any data, the result will point to the
                        null termination character

    pcchRemaining   -   if pcchRemaining is non-null, the function will return the
                        number of characters left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT("")).

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated.

        STRSAFE_NO_TRUNCATION /
        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string.

Notes:
    pszDest should not be NULL unless the STRSAFE_IGNORE_NULLS flag is specified.
    If STRSAFE_IGNORE_NULLS is passed and pszDest is NULL, an error may still be
    returned even though NULLS are ignored

    cchDest must be > 1 for this function to succeed.

Return Value:

    S_OK           -   data was read from stdin and copied, and the resultant
                       dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_END_OF_FILE /
      HRESULT_CODE(hr) == ERROR_HANDLE_EOF
                   -   this return value indicates an error or end-of-file
                       condition, use feof or ferror to determine which one has
                       occured.

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that there was
                       insufficient space in the destination buffer to copy any
                       data

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function.

--*/

#ifdef STRSAFE_WITH_GETS
#ifndef STRSAFE_LIB_IMPL
STRSAFE_INLINE_API
StringCchGetsExA(
    __out_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags);

STRSAFE_INLINE_API
StringCchGetsExW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags);
#ifdef UNICODE
#define StringCchGetsEx  StringCchGetsExW
#else
#define StringCchGetsEx  StringCchGetsExA
#endif // !UNICODE

#ifndef STRSAFE_NO_A_FUNCTIONS
STRSAFE_INLINE_API
StringCchGetsExA(
    __out_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        size_t cbDest;

        // safe to multiply cchDest * sizeof(char) since cchDest < STRSAFE_MAX_CCH and sizeof(char) is 1
        cbDest = cchDest * sizeof(char);

        hr = StringGetsExWorkerA(pszDest, cchDest, cbDest, ppszDestEnd, pcchRemaining, dwFlags);
    }

    return hr;
}
#endif  // !STRSAFE_NO_A_FUNCTIONS
#ifndef STRSAFE_NO_W_FUNCTIONS
STRSAFE_INLINE_API
StringCchGetsExW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        size_t cbDest;

        // safe to multiply cchDest * sizeof(wchar_t) since cchDest < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
        cbDest = cchDest * sizeof(wchar_t);

        hr = StringGetsExWorkerW(pszDest, cchDest, cbDest, ppszDestEnd, pcchRemaining, dwFlags);
    }

    return hr;
}
#endif  // !STRSAFE_NO_W_FUNCTIONS
#endif  // !STRSAFE_LIB_IMPL
#endif  // STRSAFE_WITH_GETS
#endif  // !STRSAFE_NO_CCH_FUNCTIONS

#ifndef STRSAFE_NO_CB_FUNCTIONS
/*++

STDAPI
StringCbGetsEx(
    OUT LPTSTR  pszDest         OPTIONAL,
    IN  size_t  cbDest,
    OUT LPTSTR* ppszDestEnd     OPTIONAL,
    OUT size_t* pcbRemaining    OPTIONAL,
    IN  DWORD   dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'gets' with
    some additional parameters. In addition to functionality provided by
    StringCbGets, this routine also returns a pointer to the end of the
    destination string and the number of characters left in the destination string
    including the null terminator. The flags parameter allows additional controls.

Arguments:

    pszDest         -   destination string

    cbDest          -   size of destination buffer in bytes.

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function copied any data, the result will point to the
                        null termination character

    pcbRemaining    -   if pcbRemaining is non-null, the function will return the
                        number of bytes left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT("")).

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated.

        STRSAFE_NO_TRUNCATION /
        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string.

Notes:
    pszDest should not be NULL unless the STRSAFE_IGNORE_NULLS flag is specified.
    If STRSAFE_IGNORE_NULLS is passed and pszDest is NULL, an error may still be
    returned even though NULLS are ignored

    cbDest must be > sizeof(TCHAR) for this function to succeed

Return Value:

    S_OK           -   data was read from stdin and copied, and the resultant
                       dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_END_OF_FILE /
      HRESULT_CODE(hr) == ERROR_HANDLE_EOF
                   -   this return value indicates an error or end-of-file
                       condition, use feof or ferror to determine which one has
                       occured.

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that there was
                       insufficient space in the destination buffer to copy any
                       data

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function.

--*/

#ifdef STRSAFE_WITH_GETS
#ifndef STRSAFE_LIB_IMPL
STRSAFE_INLINE_API
StringCbGetsExA(
    __out_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cbDest,
    __deref_opt_out_bcount(*pcbRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in unsigned long dwFlags);

STRSAFE_INLINE_API
StringCbGetsExW(
    __out_bcount(cbDest) STRSAFE_LPWSTR pszDest,
    __in size_t cbDest,
    __deref_opt_out_bcount(*pcbRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in unsigned long dwFlags);
#ifdef UNICODE
#define StringCbGetsEx  StringCbGetsExW
#else
#define StringCbGetsEx  StringCbGetsExA
#endif // !UNICODE

#ifndef STRSAFE_NO_A_FUNCTIONS
STRSAFE_INLINE_API
StringCbGetsExA(
    __out_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cbDest,
    __deref_opt_out_bcount(*pcbRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in unsigned long dwFlags)
{
    HRESULT hr;
    size_t cchDest;
    size_t cchRemaining = 0;

    // convert to count of characters
    cchDest = cbDest / sizeof(char);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringGetsExWorkerA(pszDest, cchDest, cbDest, ppszDestEnd, &cchRemaining, dwFlags);
    }

    if (SUCCEEDED(hr) ||
        (hr == STRSAFE_E_INSUFFICIENT_BUFFER) ||
        (hr == STRSAFE_E_END_OF_FILE))
    {
        if (pcbRemaining)
        {
            // safe to multiply cchRemaining * sizeof(char) since cchRemaining < STRSAFE_MAX_CCH and sizeof(char) is 1
            *pcbRemaining = (cchRemaining * sizeof(char)) + (cbDest % sizeof(char));
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_A_FUNCTIONS
#ifndef STRSAFE_NO_W_FUNCTIONS
STRSAFE_INLINE_API
StringCbGetsExW(
    __out_bcount(cbDest) STRSAFE_LPWSTR pszDest,
    __in size_t cbDest,
    __deref_opt_out_bcount(*pcbRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in unsigned long dwFlags)
{
    HRESULT hr;
    size_t cchDest;
    size_t cchRemaining = 0;

    // convert to count of characters
    cchDest = cbDest / sizeof(wchar_t);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringGetsExWorkerW(pszDest, cchDest, cbDest, ppszDestEnd, &cchRemaining, dwFlags);
    }

    if (SUCCEEDED(hr) ||
        (hr == STRSAFE_E_INSUFFICIENT_BUFFER) ||
        (hr == STRSAFE_E_END_OF_FILE))
    {
        if (pcbRemaining)
        {
            // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
            *pcbRemaining = (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_W_FUNCTIONS
#endif  // !STRSAFE_LIB_IMPL
#endif  // STRSAFE_WITH_GETS
#endif  // !STRSAFE_NO_CB_FUNCTIONS

#ifndef STRSAFE_NO_CCH_FUNCTIONS
/*++

STDAPI
StringCchLength(
    IN  LPCTSTR psz,
    IN  size_t  cchMax,
    OUT size_t* pcchLength  OPTIONAL
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strlen'.
    It is used to make sure a string is not larger than a given length, and
    it optionally returns the current length in characters not including
    the null terminator.

    This function returns a hresult, and not a pointer.  It returns
    S_OK if the string is non-null and the length including the null
    terminator is less than or equal to cchMax characters.

Arguments:

    psz         -   string to check the length of

    cchMax      -   maximum number of characters including the null terminator
                    that psz is allowed to contain

    pcch        -   if the function succeeds and pcch is non-null, the current length
                    in characters of psz excluding the null terminator will be returned.
                    This out parameter is equivalent to the return value of strlen(psz)

Notes:
    psz can be null but the function will fail

    cchMax should be greater than zero or the function will fail

Return Value:

    S_OK           -   psz is non-null and the length including the null
                       terminator is less than or equal to cchMax characters

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function.

--*/

STRSAFEAPI
StringCchLengthA(
    __in STRSAFE_LPCSTR psz,
    __in size_t cchMax,
    __out_opt size_t* pcchLength);

STRSAFEAPI
StringCchLengthW(
    __in STRSAFE_LPCWSTR psz,
    __in size_t cchMax,
    __out_opt size_t* pcchLength);
#ifdef UNICODE
#define StringCchLength  StringCchLengthW
#else
#define StringCchLength  StringCchLengthA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
#ifndef STRSAFE_NO_A_FUNCTIONS
STRSAFEAPI
StringCchLengthA(
    __in STRSAFE_LPCSTR psz,
    __in size_t cchMax,
    __out_opt size_t* pcchLength)
{
    HRESULT hr;

    if ((psz == NULL) || (cchMax > STRSAFE_MAX_CCH))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringLengthWorkerA(psz, cchMax, pcchLength);
    }

    if (FAILED(hr) && pcchLength)
    {
        *pcchLength = 0;
    }

    return hr;
}
#endif  // !STRSAFE_NO_A_FUNCTIONS
#ifndef STRSAFE_NO_W_FUNCTIONS
STRSAFEAPI
StringCchLengthW(
    __in STRSAFE_LPCWSTR psz,
    __in size_t cchMax,
    __out_opt size_t* pcchLength)
{
    HRESULT hr;

    if ((psz == NULL) || (cchMax > STRSAFE_MAX_CCH))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringLengthWorkerW(psz, cchMax, pcchLength);
    }

    if (FAILED(hr) && pcchLength)
    {
        *pcchLength = 0;
    }

    return hr;
}
#endif  // !STRSAFE_NO_W_FUNCTIONS
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CCH_FUNCTIONS


#ifndef STRSAFE_NO_CB_FUNCTIONS
/*++

STDAPI
StringCbLength(
    IN  LPCTSTR psz,
    IN  size_t  cbMax,
    OUT size_t* pcbLength   OPTIONAL
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strlen'.
    It is used to make sure a string is not larger than a given length, and
    it optionally returns the current length in bytes not including
    the null terminator.

    This function returns a hresult, and not a pointer.  It returns
    S_OK if the string is non-null and the length including the null
    terminator is less than or equal to cbMax bytes.

Arguments:

    psz         -   string to check the length of

    cbMax       -   maximum number of bytes including the null terminator
                    that psz is allowed to contain

    pcb         -   if the function succeeds and pcb is non-null, the current length
                    in bytes of psz excluding the null terminator will be returned.
                    This out parameter is equivalent to the return value of strlen(psz) * sizeof(TCHAR)

Notes:
    psz can be null but the function will fail

    cbMax should be greater than or equal to sizeof(TCHAR) or the function will fail

Return Value:

    S_OK           -   psz is non-null and the length including the null
                       terminator is less than or equal to cbMax bytes

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function.

--*/

STRSAFEAPI
StringCbLengthA(
    __in STRSAFE_LPCSTR psz,
    __in size_t cbMax,
    __out_opt size_t* pcbLength);

STRSAFEAPI
StringCbLengthW(
    __in STRSAFE_LPCWSTR psz,
    __in size_t cbMax,
    __out_opt size_t* pcbLength);
#ifdef UNICODE
#define StringCbLength  StringCbLengthW
#else
#define StringCbLength  StringCbLengthA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
#ifndef STRSAFE_NO_A_FUNCTIONS
STRSAFEAPI
StringCbLengthA(
    __in STRSAFE_LPCSTR psz,
    __in size_t cbMax,
    __out_opt size_t* pcbLength)
{
    HRESULT hr;
    size_t cchMax;
    size_t cchLength = 0;

    // convert to count of characters
    cchMax = cbMax / sizeof(char);

    if ((psz == NULL) || (cchMax > STRSAFE_MAX_CCH))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringLengthWorkerA(psz, cchMax, &cchLength);
    }

    if (pcbLength)
    {
        if (SUCCEEDED(hr))
        {
            // safe to multiply cch * sizeof(char) since cch < STRSAFE_MAX_CCH and sizeof(char) is 1
            *pcbLength = cchLength * sizeof(char);
        }
        else
        {
            *pcbLength = 0;
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_A_FUNCTIONS
#ifndef STRSAFE_NO_W_FUNCTIONS
STRSAFEAPI
StringCbLengthW(
    __in STRSAFE_LPCWSTR psz,
    __in size_t cbMax,
    __out_opt size_t* pcbLength)
{
    HRESULT hr;
    size_t cchMax;
    size_t cchLength = 0;

    // convert to count of characters
    cchMax = cbMax / sizeof(wchar_t);

    if ((psz == NULL) || (cchMax > STRSAFE_MAX_CCH))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringLengthWorkerW(psz, cchMax, &cchLength);
    }

    if (pcbLength)
    {
        if (SUCCEEDED(hr))
        {
            // safe to multiply cch * sizeof(wchar_t) since cch < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
            *pcbLength = cchLength * sizeof(wchar_t);
        }
        else
        {
            *pcbLength = 0;
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_W_FUNCTIONS
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CB_FUNCTIONS

#endif  // !STRSAFE_ONLY_SPRINTF_FUNCTIONS

// Below here are the worker functions that actually do the work
#ifdef STRSAFE_INLINE

#ifndef STRSAFE_ONLY_SPRINTF_FUNCTIONS

#ifndef STRSAFE_NO_A_FUNCTIONS
STRSAFEAPI
StringCopyWorkerA(
    __out_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in STRSAFE_LPCSTR pszSrc)
{
    HRESULT hr = S_OK;

    if (cchDest == 0)
    {
        // can not null terminate a zero-byte dest buffer
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        while (cchDest && (*pszSrc != '\0'))
        {
            *pszDest++ = *pszSrc++;
            cchDest--;
        }

        if (cchDest == 0)
        {
            // we are going to truncate pszDest
            pszDest--;
            hr = STRSAFE_E_INSUFFICIENT_BUFFER;
        }

        *pszDest= '\0';
    }

    return hr;
}
#endif  // !STRSAFE_NO_A_FUNCTIONS
#ifndef STRSAFE_NO_W_FUNCTIONS
STRSAFEAPI
StringCopyWorkerW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in STRSAFE_LPCWSTR pszSrc)
{
    HRESULT hr = S_OK;

    if (cchDest == 0)
    {
        // can not null terminate a zero-byte dest buffer
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        while (cchDest && (*pszSrc != L'\0'))
        {
            *pszDest++ = *pszSrc++;
            cchDest--;
        }

        if (cchDest == 0)
        {
            // we are going to truncate pszDest
            pszDest--;
            hr = STRSAFE_E_INSUFFICIENT_BUFFER;
        }

        *pszDest= L'\0';
    }

    return hr;
}
#endif  // !STRSAFE_NO_W_FUNCTIONS

#ifndef STRSAFE_NO_A_FUNCTIONS
STRSAFEAPI
StringCopyExWorkerA(
    __out_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in size_t cbDest,
    __in STRSAFE_LPCSTR pszSrc,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags)
{
    HRESULT hr = S_OK;
    STRSAFE_LPSTR pszDestEnd = pszDest;
    size_t cchRemaining = 0;

    // ASSERT(cbDest == (cchDest * sizeof(char))    ||
    //        cbDest == (cchDest * sizeof(char)) + (cbDest % sizeof(char)));

    // only accept valid flags
    if (dwFlags & (~STRSAFE_VALID_FLAGS))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        if (dwFlags & STRSAFE_IGNORE_NULLS)
        {
            if (pszDest == NULL)
            {
                if ((cchDest != 0) || (cbDest != 0))
                {
                    // NULL pszDest and non-zero cchDest/cbDest is invalid
                    hr = STRSAFE_E_INVALID_PARAMETER;
                }
            }

            if (pszSrc == NULL)
            {
                pszSrc = "";
            }
        }

        if (SUCCEEDED(hr))
        {
            if (cchDest == 0)
            {
                pszDestEnd = pszDest;
                cchRemaining = 0;

                // only fail if there was actually src data to copy
                if (*pszSrc != '\0')
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                pszDestEnd = pszDest;
                cchRemaining = cchDest;

                while (cchRemaining && (*pszSrc != '\0'))
                {
                    *pszDestEnd++ = *pszSrc++;
                    cchRemaining--;
                }

                if (cchRemaining > 0)
                {
                    if (dwFlags & STRSAFE_FILL_BEHIND_NULL)
                    {
                        memset(pszDestEnd + 1, STRSAFE_GET_FILL_PATTERN(dwFlags), ((cchRemaining - 1) * sizeof(char)) + (cbDest % sizeof(char)));
                    }
                }
                else
                {
                    // we are going to truncate pszDest
                    pszDestEnd--;
                    cchRemaining++;

                    hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                }

                *pszDestEnd = '\0';
            }
        }
    }

    if (FAILED(hr))
    {
        if (pszDest)
        {
            if (dwFlags & STRSAFE_FILL_ON_FAILURE)
            {
                memset(pszDest, STRSAFE_GET_FILL_PATTERN(dwFlags), cbDest);

                if (STRSAFE_GET_FILL_PATTERN(dwFlags) == 0)
                {
                    pszDestEnd = pszDest;
                    cchRemaining = cchDest;
                }
                else if (cchDest > 0)
                {
                    pszDestEnd = pszDest + cchDest - 1;
                    cchRemaining = 1;

                    // null terminate the end of the string
                    *pszDestEnd = '\0';
                }
            }

            if (dwFlags & (STRSAFE_NULL_ON_FAILURE | STRSAFE_NO_TRUNCATION))
            {
                if (cchDest > 0)
                {
                    pszDestEnd = pszDest;
                    cchRemaining = cchDest;

                    // null terminate the beginning of the string
                    *pszDestEnd = '\0';
                }
            }
        }
    }

    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
    {
        if (ppszDestEnd)
        {
            *ppszDestEnd = pszDestEnd;
        }

        if (pcchRemaining)
        {
            *pcchRemaining = cchRemaining;
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_A_FUNCTIONS
#ifndef STRSAFE_NO_W_FUNCTIONS
STRSAFEAPI
StringCopyExWorkerW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in size_t cbDest,
    __in STRSAFE_LPCWSTR pszSrc,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags)
{
    HRESULT hr = S_OK;
    STRSAFE_LPWSTR pszDestEnd = pszDest;
    size_t cchRemaining = 0;

    // ASSERT(cbDest == (cchDest * sizeof(wchar_t)) ||
    //        cbDest == (cchDest * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t)));

    // only accept valid flags
    if (dwFlags & (~STRSAFE_VALID_FLAGS))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        if (dwFlags & STRSAFE_IGNORE_NULLS)
        {
            if (pszDest == NULL)
            {
                if ((cchDest != 0) || (cbDest != 0))
                {
                    // NULL pszDest and non-zero cchDest/cbDest is invalid
                    hr = STRSAFE_E_INVALID_PARAMETER;
                }
            }

            if (pszSrc == NULL)
            {
                pszSrc = L"";
            }
        }

        if (SUCCEEDED(hr))
        {
            if (cchDest == 0)
            {
                pszDestEnd = pszDest;
                cchRemaining = 0;

                // only fail if there was actually src data to copy
                if (*pszSrc != L'\0')
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                pszDestEnd = pszDest;
                cchRemaining = cchDest;

                while (cchRemaining && (*pszSrc != L'\0'))
                {
                    *pszDestEnd++ = *pszSrc++;
                    cchRemaining--;
                }

                if (cchRemaining > 0)
                {
                    if (dwFlags & STRSAFE_FILL_BEHIND_NULL)
                    {
                        memset(pszDestEnd + 1, STRSAFE_GET_FILL_PATTERN(dwFlags), ((cchRemaining - 1) * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t)));
                    }
                }
                else
                {
                    // we are going to truncate pszDest
                    pszDestEnd--;
                    cchRemaining++;

                    hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                }

                *pszDestEnd = L'\0';
            }
        }
    }

    if (FAILED(hr))
    {
        if (pszDest)
        {
            if (dwFlags & STRSAFE_FILL_ON_FAILURE)
            {
                memset(pszDest, STRSAFE_GET_FILL_PATTERN(dwFlags), cbDest);

                if (STRSAFE_GET_FILL_PATTERN(dwFlags) == 0)
                {
                    pszDestEnd = pszDest;
                    cchRemaining = cchDest;
                }
                else if (cchDest > 0)
                {
                    pszDestEnd = pszDest + cchDest - 1;
                    cchRemaining = 1;

                    // null terminate the end of the string
                    *pszDestEnd = L'\0';
                }
            }

            if (dwFlags & (STRSAFE_NULL_ON_FAILURE | STRSAFE_NO_TRUNCATION))
            {
                if (cchDest > 0)
                {
                    pszDestEnd = pszDest;
                    cchRemaining = cchDest;

                    // null terminate the beginning of the string
                    *pszDestEnd = L'\0';
                }
            }
        }
    }

    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
    {
        if (ppszDestEnd)
        {
            *ppszDestEnd = pszDestEnd;
        }

        if (pcchRemaining)
        {
            *pcchRemaining = cchRemaining;
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_W_FUNCTIONS

#ifndef STRSAFE_NO_A_FUNCTIONS
STRSAFEAPI
StringCopyNWorkerA(
    __out_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in_ecount(cchSrc) STRSAFE_LPCSTR pszSrc,
    __in size_t cchSrc)
{
    HRESULT hr = S_OK;

    if (cchDest == 0)
    {
        // can not null terminate a zero-byte dest buffer
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        while (cchDest && cchSrc && (*pszSrc != '\0'))
        {
            *pszDest++ = *pszSrc++;
            cchDest--;
            cchSrc--;
        }

        if (cchDest == 0)
        {
            // we are going to truncate pszDest
            pszDest--;
            hr = STRSAFE_E_INSUFFICIENT_BUFFER;
        }

        *pszDest= '\0';
    }

    return hr;
}
#endif  // !STRSAFE_NO_A_FUNCTIONS
#ifndef STRSAFE_NO_W_FUNCTIONS
STRSAFEAPI
StringCopyNWorkerW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in_ecount(cchToCopy) STRSAFE_LPCWSTR pszSrc,
    __in size_t cchToCopy)
{
    HRESULT hr = S_OK;

    if (cchDest == 0)
    {
        // can not null terminate a zero-byte dest buffer
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        while (cchDest && cchToCopy && (*pszSrc != L'\0'))
        {
            *pszDest++ = *pszSrc++;
            cchDest--;
            cchToCopy--;
        }

        if (cchDest == 0)
        {
            // we are going to truncate pszDest
            pszDest--;
            hr = STRSAFE_E_INSUFFICIENT_BUFFER;
        }

        *pszDest= L'\0';
    }

    return hr;
}
#endif  // !STRSAFE_NO_W_FUNCTIONS

#ifndef STRSAFE_NO_A_FUNCTIONS
STRSAFEAPI
StringCopyNExWorkerA(
    __out_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in size_t cbDest,
    __in_ecount(cchToCopy) STRSAFE_LPCSTR pszSrc,
    __in size_t cchToCopy,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags)
{
    HRESULT hr = S_OK;
    STRSAFE_LPSTR pszDestEnd = pszDest;
    size_t cchRemaining = 0;

    // ASSERT(cbDest == (cchDest * sizeof(char))    ||
    //        cbDest == (cchDest * sizeof(char)) + (cbDest % sizeof(char)));

    // only accept valid flags
    if (dwFlags & (~STRSAFE_VALID_FLAGS))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else if (cchToCopy > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        if (dwFlags & STRSAFE_IGNORE_NULLS)
        {
            if (pszDest == NULL)
            {
                if ((cchDest != 0) || (cbDest != 0))
                {
                    // NULL pszDest and non-zero cchDest/cbDest is invalid
                    hr = STRSAFE_E_INVALID_PARAMETER;
                }
            }

            if (pszSrc == NULL)
            {
                pszSrc = "";
            }
        }

        if (SUCCEEDED(hr))
        {
            if (cchDest == 0)
            {
                pszDestEnd = pszDest;
                cchRemaining = 0;

                // only fail if there was actually src data to copy
                if ((cchToCopy != 0) && (*pszSrc != '\0'))
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                pszDestEnd = pszDest;
                cchRemaining = cchDest;

                while (cchRemaining && cchToCopy && (*pszSrc != '\0'))
                {
                    *pszDestEnd++ = *pszSrc++;
                    cchRemaining--;
                    cchToCopy--;
                }

                if (cchRemaining > 0)
                {
                    if (dwFlags & STRSAFE_FILL_BEHIND_NULL)
                    {
                        memset(pszDestEnd + 1, STRSAFE_GET_FILL_PATTERN(dwFlags), ((cchRemaining - 1) * sizeof(char)) + (cbDest % sizeof(char)));
                    }
                }
                else
                {
                    // we are going to truncate pszDest
                    pszDestEnd--;
                    cchRemaining++;

                    hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                }

                *pszDestEnd = '\0';
            }
        }
    }

    if (FAILED(hr))
    {
        if (pszDest)
        {
            if (dwFlags & STRSAFE_FILL_ON_FAILURE)
            {
                memset(pszDest, STRSAFE_GET_FILL_PATTERN(dwFlags), cbDest);

                if (STRSAFE_GET_FILL_PATTERN(dwFlags) == 0)
                {
                    pszDestEnd = pszDest;
                    cchRemaining = cchDest;
                }
                else if (cchDest > 0)
                {
                    pszDestEnd = pszDest + cchDest - 1;
                    cchRemaining = 1;

                    // null terminate the end of the string
                    *pszDestEnd = '\0';
                }
            }

            if (dwFlags & (STRSAFE_NULL_ON_FAILURE | STRSAFE_NO_TRUNCATION))
            {
                if (cchDest > 0)
                {
                    pszDestEnd = pszDest;
                    cchRemaining = cchDest;

                    // null terminate the beginning of the string
                    *pszDestEnd = '\0';
                }
            }
        }
    }

    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
    {
        if (ppszDestEnd)
        {
            *ppszDestEnd = pszDestEnd;
        }

        if (pcchRemaining)
        {
            *pcchRemaining = cchRemaining;
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_A_FUNCTIONS
#ifndef STRSAFE_NO_W_FUNCTIONS
STRSAFEAPI
StringCopyNExWorkerW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in size_t cbDest,
    __in_ecount(cchToCopy) STRSAFE_LPCWSTR pszSrc,
    __in size_t cchToCopy,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags)
{
    HRESULT hr = S_OK;
    STRSAFE_LPWSTR pszDestEnd = pszDest;
    size_t cchRemaining = 0;

    // ASSERT(cbDest == (cchDest * sizeof(wchar_t)) ||
    //        cbDest == (cchDest * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t)));

    // only accept valid flags
    if (dwFlags & (~STRSAFE_VALID_FLAGS))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else if (cchToCopy > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        if (dwFlags & STRSAFE_IGNORE_NULLS)
        {
            if (pszDest == NULL)
            {
                if ((cchDest != 0) || (cbDest != 0))
                {
                    // NULL pszDest and non-zero cchDest/cbDest is invalid
                    hr = STRSAFE_E_INVALID_PARAMETER;
                }
            }

            if (pszSrc == NULL)
            {
                pszSrc = L"";
            }
        }

        if (SUCCEEDED(hr))
        {
            if (cchDest == 0)
            {
                pszDestEnd = pszDest;
                cchRemaining = 0;

                // only fail if there was actually src data to copy
                if ((cchToCopy != 0) && (*pszSrc != L'\0'))
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                pszDestEnd = pszDest;
                cchRemaining = cchDest;

                while (cchRemaining && cchToCopy && (*pszSrc != L'\0'))
                {
                    *pszDestEnd++ = *pszSrc++;
                    cchRemaining--;
                    cchToCopy--;
                }

                if (cchRemaining > 0)
                {
                    if (dwFlags & STRSAFE_FILL_BEHIND_NULL)
                    {
                        memset(pszDestEnd + 1, STRSAFE_GET_FILL_PATTERN(dwFlags), ((cchRemaining - 1) * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t)));
                    }
                }
                else
                {
                    // we are going to truncate pszDest
                    pszDestEnd--;
                    cchRemaining++;

                    hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                }

                *pszDestEnd = L'\0';
            }
        }
    }

    if (FAILED(hr))
    {
        if (pszDest)
        {
            if (dwFlags & STRSAFE_FILL_ON_FAILURE)
            {
                memset(pszDest, STRSAFE_GET_FILL_PATTERN(dwFlags), cbDest);

                if (STRSAFE_GET_FILL_PATTERN(dwFlags) == 0)
                {
                    pszDestEnd = pszDest;
                    cchRemaining = cchDest;
                }
                else if (cchDest > 0)
                {
                    pszDestEnd = pszDest + cchDest - 1;
                    cchRemaining = 1;

                    // null terminate the end of the string
                    *pszDestEnd = L'\0';
                }
            }

            if (dwFlags & (STRSAFE_NULL_ON_FAILURE | STRSAFE_NO_TRUNCATION))
            {
                if (cchDest > 0)
                {
                    pszDestEnd = pszDest;
                    cchRemaining = cchDest;

                    // null terminate the beginning of the string
                    *pszDestEnd = L'\0';
                }
            }
        }
    }

    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
    {
        if (ppszDestEnd)
        {
            *ppszDestEnd = pszDestEnd;
        }

        if (pcchRemaining)
        {
            *pcchRemaining = cchRemaining;
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_W_FUNCTIONS

#ifndef STRSAFE_NO_A_FUNCTIONS
STRSAFEAPI
StringCatWorkerA(
    __inout_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in STRSAFE_LPCSTR pszSrc)
{
   HRESULT hr;
   size_t cchDestLength;

   hr = StringLengthWorkerA(pszDest, cchDest, &cchDestLength);

   if (SUCCEEDED(hr))
   {
       hr = StringCopyWorkerA(pszDest + cchDestLength,
                              cchDest - cchDestLength,
                              pszSrc);
   }

   return hr;
}
#endif  // !STRSAFE_NO_A_FUNCTIONS
#ifndef STRSAFE_NO_W_FUNCTIONS
STRSAFEAPI
StringCatWorkerW(
    __inout_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in STRSAFE_LPCWSTR pszSrc)
{
   HRESULT hr;
   size_t cchDestLength;

   hr = StringLengthWorkerW(pszDest, cchDest, &cchDestLength);

   if (SUCCEEDED(hr))
   {
       hr = StringCopyWorkerW(pszDest + cchDestLength,
                              cchDest - cchDestLength,
                              pszSrc);
   }

   return hr;
}
#endif  // !STRSAFE_NO_W_FUNCTIONS

#ifndef STRSAFE_NO_A_FUNCTIONS
STRSAFEAPI
StringCatExWorkerA(
    __inout_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in size_t cbDest,
    __in STRSAFE_LPCSTR pszSrc,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags)
{
    HRESULT hr = S_OK;
    STRSAFE_LPSTR pszDestEnd = pszDest;
    size_t cchRemaining = 0;

    // ASSERT(cbDest == (cchDest * sizeof(char))    ||
    //        cbDest == (cchDest * sizeof(char)) + (cbDest % sizeof(char)));

    // only accept valid flags
    if (dwFlags & (~STRSAFE_VALID_FLAGS))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        size_t cchDestLength;

        if (dwFlags & STRSAFE_IGNORE_NULLS)
        {
            if (pszDest == NULL)
            {
                if ((cchDest == 0) && (cbDest == 0))
                {
                    cchDestLength = 0;
                }
                else
                {
                    // NULL pszDest and non-zero cchDest/cbDest is invalid
                    hr = STRSAFE_E_INVALID_PARAMETER;
                }
            }
            else
            {
                hr = StringLengthWorkerA(pszDest, cchDest, &cchDestLength);

                if (SUCCEEDED(hr))
                {
                    pszDestEnd = pszDest + cchDestLength;
                    cchRemaining = cchDest - cchDestLength;
                }
            }

            if (pszSrc == NULL)
            {
                pszSrc = "";
            }
        }
        else
        {
            hr = StringLengthWorkerA(pszDest, cchDest, &cchDestLength);

            if (SUCCEEDED(hr))
            {
                pszDestEnd = pszDest + cchDestLength;
                cchRemaining = cchDest - cchDestLength;
            }
        }

        if (SUCCEEDED(hr))
        {
            if (cchDest == 0)
            {
                // only fail if there was actually src data to append
                if (*pszSrc != '\0')
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                // we handle the STRSAFE_FILL_ON_FAILURE and STRSAFE_NULL_ON_FAILURE cases below, so do not pass
                // those flags through
                hr = StringCopyExWorkerA(pszDestEnd,
                                         cchRemaining,
                                         (cchRemaining * sizeof(char)) + (cbDest % sizeof(char)),
                                         pszSrc,
                                         &pszDestEnd,
                                         &cchRemaining,
                                         dwFlags & (~(STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)));
            }
        }
    }

    if (FAILED(hr))
    {
        if (pszDest)
        {
            // STRSAFE_NO_TRUNCATION is taken care of by StringCopyExWorkerA()

            if (dwFlags & STRSAFE_FILL_ON_FAILURE)
            {
                memset(pszDest, STRSAFE_GET_FILL_PATTERN(dwFlags), cbDest);

                if (STRSAFE_GET_FILL_PATTERN(dwFlags) == 0)
                {
                    pszDestEnd = pszDest;
                    cchRemaining = cchDest;
                }
                else
                if (cchDest > 0)
                {
                    pszDestEnd = pszDest + cchDest - 1;
                    cchRemaining = 1;

                    // null terminate the end of the string
                    *pszDestEnd = '\0';
                }
            }

            if (dwFlags & STRSAFE_NULL_ON_FAILURE)
            {
                if (cchDest > 0)
                {
                    pszDestEnd = pszDest;
                    cchRemaining = cchDest;

                    // null terminate the beginning of the string
                    *pszDestEnd = '\0';
                }
            }
        }
    }

    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
    {
        if (ppszDestEnd)
        {
            *ppszDestEnd = pszDestEnd;
        }

        if (pcchRemaining)
        {
            *pcchRemaining = cchRemaining;
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_A_FUNCTIONS
#ifndef STRSAFE_NO_W_FUNCTIONS
STRSAFEAPI
StringCatExWorkerW(
    __inout_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in size_t cbDest,
    __in STRSAFE_LPCWSTR pszSrc,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags)
{
    HRESULT hr = S_OK;
    STRSAFE_LPWSTR pszDestEnd = pszDest;
    size_t cchRemaining = 0;

    // ASSERT(cbDest == (cchDest * sizeof(wchar_t)) ||
    //        cbDest == (cchDest * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t)));

    // only accept valid flags
    if (dwFlags & (~STRSAFE_VALID_FLAGS))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        size_t cchDestLength;

        if (dwFlags & STRSAFE_IGNORE_NULLS)
        {
            if (pszDest == NULL)
            {
                if ((cchDest == 0) && (cbDest == 0))
                {
                    cchDestLength = 0;
                }
                else
                {
                    // NULL pszDest and non-zero cchDest/cbDest is invalid
                    hr = STRSAFE_E_INVALID_PARAMETER;
                }
            }
            else
            {
                hr = StringLengthWorkerW(pszDest, cchDest, &cchDestLength);

                if (SUCCEEDED(hr))
                {
                    pszDestEnd = pszDest + cchDestLength;
                    cchRemaining = cchDest - cchDestLength;
                }
            }

            if (pszSrc == NULL)
            {
                pszSrc = L"";
            }
        }
        else
        {
            hr = StringLengthWorkerW(pszDest, cchDest, &cchDestLength);

            if (SUCCEEDED(hr))
            {
                pszDestEnd = pszDest + cchDestLength;
                cchRemaining = cchDest - cchDestLength;
            }
        }

        if (SUCCEEDED(hr))
        {
            if (cchDest == 0)
            {
                // only fail if there was actually src data to append
                if (*pszSrc != L'\0')
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                // we handle the STRSAFE_FILL_ON_FAILURE and STRSAFE_NULL_ON_FAILURE cases below, so do not pass
                // those flags through
                hr = StringCopyExWorkerW(pszDestEnd,
                                         cchRemaining,
                                         (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t)),
                                         pszSrc,
                                         &pszDestEnd,
                                         &cchRemaining,
                                         dwFlags & (~(STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)));
            }
        }
    }

    if (FAILED(hr))
    {
        if (pszDest)
        {
            // STRSAFE_NO_TRUNCATION is taken care of by StringCopyExWorkerW()

            if (dwFlags & STRSAFE_FILL_ON_FAILURE)
            {
                memset(pszDest, STRSAFE_GET_FILL_PATTERN(dwFlags), cbDest);

                if (STRSAFE_GET_FILL_PATTERN(dwFlags) == 0)
                {
                    pszDestEnd = pszDest;
                    cchRemaining = cchDest;
                }
                else if (cchDest > 0)
                {
                    pszDestEnd = pszDest + cchDest - 1;
                    cchRemaining = 1;

                    // null terminate the end of the string
                    *pszDestEnd = L'\0';
                }
            }

            if (dwFlags & STRSAFE_NULL_ON_FAILURE)
            {
                if (cchDest > 0)
                {
                    pszDestEnd = pszDest;
                    cchRemaining = cchDest;

                    // null terminate the beginning of the string
                    *pszDestEnd = L'\0';
                }
            }
        }
    }

    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
    {
        if (ppszDestEnd)
        {
            *ppszDestEnd = pszDestEnd;
        }

        if (pcchRemaining)
        {
            *pcchRemaining = cchRemaining;
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_W_FUNCTIONS

#ifndef STRSAFE_NO_A_FUNCTIONS
STRSAFEAPI
StringCatNWorkerA(
    __inout_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in_ecount(cchToAppend) STRSAFE_LPCSTR pszSrc,
    __in size_t cchToAppend)
{
    HRESULT hr;
    size_t cchDestLength;

    hr = StringLengthWorkerA(pszDest, cchDest, &cchDestLength);

    if (SUCCEEDED(hr))
    {
        hr = StringCopyNWorkerA(pszDest + cchDestLength,
                                cchDest - cchDestLength,
                                pszSrc,
                                cchToAppend);
    }

    return hr;
}
#endif  // !STRSAFE_NO_A_FUNCTIONS
#ifndef STRSAFE_NO_W_FUNCTIONS
STRSAFEAPI
StringCatNWorkerW(
    __inout_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in_ecount(cchToAppend) STRSAFE_LPCWSTR pszSrc,
    __in size_t cchToAppend)
{
    HRESULT hr;
    size_t cchDestLength;

    hr = StringLengthWorkerW(pszDest, cchDest, &cchDestLength);

    if (SUCCEEDED(hr))
    {
        hr = StringCopyNWorkerW(pszDest + cchDestLength,
                                cchDest - cchDestLength,
                                pszSrc,
                                cchToAppend);
    }

    return hr;
}
#endif  // !STRSAFE_NO_W_FUNCTIONS

#ifndef STRSAFE_NO_A_FUNCTIONS
STRSAFEAPI
StringCatNExWorkerA(
    __inout_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in size_t cbDest,
    __in_ecount(cchToAppend) STRSAFE_LPCSTR pszSrc,
    __in size_t cchToAppend,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags)
{
    HRESULT hr = S_OK;
    STRSAFE_LPSTR pszDestEnd = pszDest;
    size_t cchRemaining = 0;
    size_t cchDestLength = 0;

    // ASSERT(cbDest == (cchDest * sizeof(char))    ||
    //        cbDest == (cchDest * sizeof(char)) + (cbDest % sizeof(char)));

    // only accept valid flags
    if (dwFlags & (~STRSAFE_VALID_FLAGS))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else if (cchToAppend > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        if (dwFlags & STRSAFE_IGNORE_NULLS)
        {
            if (pszDest == NULL)
            {
                if ((cchDest == 0) && (cbDest == 0))
                {
                    cchDestLength = 0;
                }
                else
                {
                    // NULL pszDest and non-zero cchDest/cbDest is invalid
                    hr = STRSAFE_E_INVALID_PARAMETER;
                }
            }
            else
            {
                hr = StringLengthWorkerA(pszDest, cchDest, &cchDestLength);

                if (SUCCEEDED(hr))
                {
                    pszDestEnd = pszDest + cchDestLength;
                    cchRemaining = cchDest - cchDestLength;
                }
            }

            if (pszSrc == NULL)
            {
                pszSrc = "";
            }
        }
        else
        {
            hr = StringLengthWorkerA(pszDest, cchDest, &cchDestLength);

            if (SUCCEEDED(hr))
            {
                pszDestEnd = pszDest + cchDestLength;
                cchRemaining = cchDest - cchDestLength;
            }
        }

        if (SUCCEEDED(hr))
        {
            if (cchDest == 0)
            {
                // only fail if there was actually src data to append
                if ((cchToAppend != 0) && (*pszSrc != '\0'))
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                // we handle the STRSAFE_FILL_ON_FAILURE and STRSAFE_NULL_ON_FAILURE cases below, so do not pass
                // those flags through
                hr = StringCopyNExWorkerA(pszDestEnd,
                                          cchRemaining,
                                          (cchRemaining * sizeof(char)) + (cbDest % sizeof(char)),
                                          pszSrc,
                                          cchToAppend,
                                          &pszDestEnd,
                                          &cchRemaining,
                                          dwFlags & (~(STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)));
            }
        }
    }

    if (FAILED(hr))
    {
        if (pszDest)
        {
            // STRSAFE_NO_TRUNCATION is taken care of by StringCopyNExWorkerA()

            if (dwFlags & STRSAFE_FILL_ON_FAILURE)
            {
                memset(pszDest, STRSAFE_GET_FILL_PATTERN(dwFlags), cbDest);

                if (STRSAFE_GET_FILL_PATTERN(dwFlags) == 0)
                {
                    pszDestEnd = pszDest;
                    cchRemaining = cchDest;
                }
                else if (cchDest > 0)
                {
                    pszDestEnd = pszDest + cchDest - 1;
                    cchRemaining = 1;

                    // null terminate the end of the string
                    *pszDestEnd = '\0';
                }
            }

            if (dwFlags & (STRSAFE_NULL_ON_FAILURE))
            {
                if (cchDest > 0)
                {
                    pszDestEnd = pszDest;
                    cchRemaining = cchDest;

                    // null terminate the beginning of the string
                    *pszDestEnd = '\0';
                }
            }
        }
    }

    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
    {
        if (ppszDestEnd)
        {
            *ppszDestEnd = pszDestEnd;
        }

        if (pcchRemaining)
        {
            *pcchRemaining = cchRemaining;
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_A_FUNCTIONS
#ifndef STRSAFE_NO_W_FUNCTIONS
STRSAFEAPI
StringCatNExWorkerW(
    __inout_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in size_t cbDest,
    __in_ecount(cchToAppend) STRSAFE_LPCWSTR pszSrc,
    __in size_t cchToAppend,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags)
{
    HRESULT hr = S_OK;
    STRSAFE_LPWSTR pszDestEnd = pszDest;
    size_t cchRemaining = 0;
    size_t cchDestLength = 0;


    // ASSERT(cbDest == (cchDest * sizeof(wchar_t)) ||
    //        cbDest == (cchDest * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t)));

    // only accept valid flags
    if (dwFlags & (~STRSAFE_VALID_FLAGS))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else if (cchToAppend > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        if (dwFlags & STRSAFE_IGNORE_NULLS)
        {
            if (pszDest == NULL)
            {
                if ((cchDest == 0) && (cbDest == 0))
                {
                    cchDestLength = 0;
                }
                else
                {
                    // NULL pszDest and non-zero cchDest/cbDest is invalid
                    hr = STRSAFE_E_INVALID_PARAMETER;
                }
            }
            else
            {
                hr = StringLengthWorkerW(pszDest, cchDest, &cchDestLength);

                if (SUCCEEDED(hr))
                {
                    pszDestEnd = pszDest + cchDestLength;
                    cchRemaining = cchDest - cchDestLength;
                }
            }

            if (pszSrc == NULL)
            {
                pszSrc = L"";
            }
        }
        else
        {
            hr = StringLengthWorkerW(pszDest, cchDest, &cchDestLength);

            if (SUCCEEDED(hr))
            {
                pszDestEnd = pszDest + cchDestLength;
                cchRemaining = cchDest - cchDestLength;
            }
        }

        if (SUCCEEDED(hr))
        {
            if (cchDest == 0)
            {
                // only fail if there was actually src data to append
                if ((cchToAppend != 0) && (*pszSrc != L'\0'))
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                // we handle the STRSAFE_FILL_ON_FAILURE and STRSAFE_NULL_ON_FAILURE cases below, so do not pass
                // those flags through
                hr = StringCopyNExWorkerW(pszDestEnd,
                                          cchRemaining,
                                          (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t)),
                                          pszSrc,
                                          cchToAppend,
                                          &pszDestEnd,
                                          &cchRemaining,
                                          dwFlags & (~(STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)));
            }
        }
    }

    if (FAILED(hr))
    {
        if (pszDest)
        {
            // STRSAFE_NO_TRUNCATION is taken care of by StringCopyNExWorkerW()

            if (dwFlags & STRSAFE_FILL_ON_FAILURE)
            {
                memset(pszDest, STRSAFE_GET_FILL_PATTERN(dwFlags), cbDest);

                if (STRSAFE_GET_FILL_PATTERN(dwFlags) == 0)
                {
                    pszDestEnd = pszDest;
                    cchRemaining = cchDest;
                }
                else if (cchDest > 0)
                {
                    pszDestEnd = pszDest + cchDest - 1;
                    cchRemaining = 1;

                    // null terminate the end of the string
                    *pszDestEnd = L'\0';
                }
            }

            if (dwFlags & (STRSAFE_NULL_ON_FAILURE))
            {
                if (cchDest > 0)
                {
                    pszDestEnd = pszDest;
                    cchRemaining = cchDest;

                    // null terminate the beginning of the string
                    *pszDestEnd = L'\0';
                }
            }
        }
    }

    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
    {
        if (ppszDestEnd)
        {
            *ppszDestEnd = pszDestEnd;
        }

        if (pcchRemaining)
        {
            *pcchRemaining = cchRemaining;
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_W_FUNCTIONS

#endif  // !STRSAFE_ONLY_SPRINTF_FUNCTIONS

#ifndef STRSAFE_NO_SPRINTF_FUNCTIONS

#ifndef STRSAFE_NO_A_FUNCTIONS
STRSAFEAPI
StringVPrintfWorkerA(
    __out_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in __format_string STRSAFE_LPCSTR pszFormat,
    __in va_list argList)
{
    HRESULT hr = S_OK;

    if (cchDest == 0)
    {
        // can not null terminate a zero-byte dest buffer
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        int iRet;
        size_t cchMax;

        // leave the last space for the null terminator
        cchMax = cchDest - 1;

#if (_STRSAFE_USE_SECURE_CRT == 1) && !defined(STRSAFE_LIB_IMPL)
        iRet = _vsnprintf_s(pszDest, cchDest, cchMax, pszFormat, argList);
#else
        iRet = _vsnprintf(pszDest, cchMax, pszFormat, argList);
#endif
        // ASSERT((iRet < 0) || (((size_t)iRet) <= cchMax));

        if ((iRet < 0) || (((size_t)iRet) > cchMax))
        {
            // need to null terminate the string
            pszDest += cchMax;
            *pszDest = '\0';

            // we have truncated pszDest
            hr = STRSAFE_E_INSUFFICIENT_BUFFER;
        }
        else if (((size_t)iRet) == cchMax)
        {
            // need to null terminate the string
            pszDest += cchMax;
            *pszDest = '\0';
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_A_FUNCTIONS
#ifndef STRSAFE_NO_W_FUNCTIONS
STRSAFEAPI
StringVPrintfWorkerW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in __format_string STRSAFE_LPCWSTR pszFormat,
    __in va_list argList)
{
    HRESULT hr = S_OK;

    if (cchDest == 0)
    {
        // can not null terminate a zero-byte dest buffer
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        int iRet;
        size_t cchMax;

        // leave the last space for the null terminator
        cchMax = cchDest - 1;

#if (_STRSAFE_USE_SECURE_CRT == 1) && !defined(STRSAFE_LIB_IMPL)
        iRet = _vsnwprintf_s(pszDest, cchDest, cchMax, pszFormat, argList);
#else
        iRet = _vsnwprintf(pszDest, cchMax, pszFormat, argList);
#endif
        // ASSERT((iRet < 0) || (((size_t)iRet) <= cchMax));

        if ((iRet < 0) || (((size_t)iRet) > cchMax))
        {
            // need to null terminate the string
            pszDest += cchMax;
            *pszDest = L'\0';

            // we have truncated pszDest
            hr = STRSAFE_E_INSUFFICIENT_BUFFER;
        }
        else if (((size_t)iRet) == cchMax)
        {
            // need to null terminate the string
            pszDest += cchMax;
            *pszDest = L'\0';
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_W_FUNCTIONS

#ifndef STRSAFE_NO_A_FUNCTIONS
STRSAFEAPI
StringVPrintfExWorkerA(
    __out_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in size_t cbDest,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags,
    __in __format_string STRSAFE_LPCSTR pszFormat,
    __in va_list argList)
{
    HRESULT hr = S_OK;
    STRSAFE_LPSTR pszDestEnd = pszDest;
    size_t cchRemaining = 0;

    // ASSERT(cbDest == (cchDest * sizeof(char))    ||
    //        cbDest == (cchDest * sizeof(char)) + (cbDest % sizeof(char)));

    // only accept valid flags
    if (dwFlags & (~STRSAFE_VALID_FLAGS))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        if (dwFlags & STRSAFE_IGNORE_NULLS)
        {
            if (pszDest == NULL)
            {
                if ((cchDest != 0) || (cbDest != 0))
                {
                    // NULL pszDest and non-zero cchDest/cbDest is invalid
                    hr = STRSAFE_E_INVALID_PARAMETER;
                }
            }

            if (pszFormat == NULL)
            {
                pszFormat = "";
            }
        }

        if (SUCCEEDED(hr))
        {
            if (cchDest == 0)
            {
                pszDestEnd = pszDest;
                cchRemaining = 0;

                // only fail if there was actually a non-empty format string
                if (*pszFormat != '\0')
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                int iRet;
                size_t cchMax;

                // leave the last space for the null terminator
                cchMax = cchDest - 1;

#if (_STRSAFE_USE_SECURE_CRT == 1) && !defined(STRSAFE_LIB_IMPL)
                iRet = _vsnprintf_s(pszDest, cchDest, cchMax, pszFormat, argList);
#else
                iRet = _vsnprintf(pszDest, cchMax, pszFormat, argList);
#endif
                // ASSERT((iRet < 0) || (((size_t)iRet) <= cchMax));

                if ((iRet < 0) || (((size_t)iRet) > cchMax))
                {
                    // we have truncated pszDest
                    pszDestEnd = pszDest + cchMax;
                    cchRemaining = 1;

                    // need to null terminate the string
                    *pszDestEnd = '\0';

                    hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                }
                else if (((size_t)iRet) == cchMax)
                {
                    // string fit perfectly
                    pszDestEnd = pszDest + cchMax;
                    cchRemaining = 1;

                    // need to null terminate the string
                    *pszDestEnd = '\0';
                }
                else if (((size_t)iRet) < cchMax)
                {
                    // there is extra room
                    pszDestEnd = pszDest + iRet;
                    cchRemaining = cchDest - iRet;

                    if (dwFlags & STRSAFE_FILL_BEHIND_NULL)
                    {
                        memset(pszDestEnd + 1, STRSAFE_GET_FILL_PATTERN(dwFlags), ((cchRemaining - 1) * sizeof(char)) + (cbDest % sizeof(char)));
                    }
                }
            }
        }
    }

    if (FAILED(hr))
    {
        if (pszDest)
        {
            if (dwFlags & STRSAFE_FILL_ON_FAILURE)
            {
                memset(pszDest, STRSAFE_GET_FILL_PATTERN(dwFlags), cbDest);

                if (STRSAFE_GET_FILL_PATTERN(dwFlags) == 0)
                {
                    pszDestEnd = pszDest;
                    cchRemaining = cchDest;
                }
                else if (cchDest > 0)
                {
                    pszDestEnd = pszDest + cchDest - 1;
                    cchRemaining = 1;

                    // null terminate the end of the string
                    *pszDestEnd = '\0';
                }
            }

            if (dwFlags & (STRSAFE_NULL_ON_FAILURE | STRSAFE_NO_TRUNCATION))
            {
                if (cchDest > 0)
                {
                    pszDestEnd = pszDest;
                    cchRemaining = cchDest;

                    // null terminate the beginning of the string
                    *pszDestEnd = '\0';
                }
            }
        }
    }

    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
    {
        if (ppszDestEnd)
        {
            *ppszDestEnd = pszDestEnd;
        }

        if (pcchRemaining)
        {
            *pcchRemaining = cchRemaining;
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_A_FUNCTIONS
#ifndef STRSAFE_NO_W_FUNCTIONS
STRSAFEAPI
StringVPrintfExWorkerW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in size_t cbDest,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags,
    __in __format_string STRSAFE_LPCWSTR pszFormat,
    __in va_list argList)
{
    HRESULT hr = S_OK;
    STRSAFE_LPWSTR pszDestEnd = pszDest;
    size_t cchRemaining = 0;

    // ASSERT(cbDest == (cchDest * sizeof(wchar_t)) ||
    //        cbDest == (cchDest * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t)));

    // only accept valid flags
    if (dwFlags & (~STRSAFE_VALID_FLAGS))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        if (dwFlags & STRSAFE_IGNORE_NULLS)
        {
            if (pszDest == NULL)
            {
                if ((cchDest != 0) || (cbDest != 0))
                {
                    // NULL pszDest and non-zero cchDest/cbDest is invalid
                    hr = STRSAFE_E_INVALID_PARAMETER;
                }
            }

            if (pszFormat == NULL)
            {
                pszFormat = L"";
            }
        }

        if (SUCCEEDED(hr))
        {
            if (cchDest == 0)
            {
                pszDestEnd = pszDest;
                cchRemaining = 0;

                // only fail if there was actually a non-empty format string
                if (*pszFormat != L'\0')
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                int iRet;
                size_t cchMax;

                // leave the last space for the null terminator
                cchMax = cchDest - 1;

#if (_STRSAFE_USE_SECURE_CRT == 1) && !defined(STRSAFE_LIB_IMPL)
                iRet = _vsnwprintf_s(pszDest, cchDest, cchMax, pszFormat, argList);
#else
                iRet = _vsnwprintf(pszDest, cchMax, pszFormat, argList);
#endif
                // ASSERT((iRet < 0) || (((size_t)iRet) <= cchMax));

                if ((iRet < 0) || (((size_t)iRet) > cchMax))
                {
                    // we have truncated pszDest
                    pszDestEnd = pszDest + cchMax;
                    cchRemaining = 1;

                    // need to null terminate the string
                    *pszDestEnd = L'\0';

                    hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                }
                else if (((size_t)iRet) == cchMax)
                {
                    // string fit perfectly
                    pszDestEnd = pszDest + cchMax;
                    cchRemaining = 1;

                    // need to null terminate the string
                    *pszDestEnd = L'\0';
                }
                else if (((size_t)iRet) < cchMax)
                {
                    // there is extra room
                    pszDestEnd = pszDest + iRet;
                    cchRemaining = cchDest - iRet;

                    if (dwFlags & STRSAFE_FILL_BEHIND_NULL)
                    {
                        memset(pszDestEnd + 1, STRSAFE_GET_FILL_PATTERN(dwFlags), ((cchRemaining - 1) * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t)));
                    }
                }
            }
        }
    }

    if (FAILED(hr))
    {
        if (pszDest)
        {
            if (dwFlags & STRSAFE_FILL_ON_FAILURE)
            {
                memset(pszDest, STRSAFE_GET_FILL_PATTERN(dwFlags), cbDest);

                if (STRSAFE_GET_FILL_PATTERN(dwFlags) == 0)
                {
                    pszDestEnd = pszDest;
                    cchRemaining = cchDest;
                }
                else if (cchDest > 0)
                {
                    pszDestEnd = pszDest + cchDest - 1;
                    cchRemaining = 1;

                    // null terminate the end of the string
                    *pszDestEnd = L'\0';
                }
            }

            if (dwFlags & (STRSAFE_NULL_ON_FAILURE | STRSAFE_NO_TRUNCATION))
            {
                if (cchDest > 0)
                {
                    pszDestEnd = pszDest;
                    cchRemaining = cchDest;

                    // null terminate the beginning of the string
                    *pszDestEnd = L'\0';
                }
            }
        }
    }

    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
    {
        if (ppszDestEnd)
        {
            *ppszDestEnd = pszDestEnd;
        }

        if (pcchRemaining)
        {
            *pcchRemaining = cchRemaining;
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_W_FUNCTIONS

#endif  // !STRSAFE_NO_SPRINTF_FUNCTIONS

#ifndef STRSAFE_ONLY_SPRINTF_FUNCTIONS

#ifndef STRSAFE_NO_A_FUNCTIONS
STRSAFEAPI
StringLengthWorkerA(
    __in STRSAFE_LPCSTR psz,
    __in size_t cchMax,
    __out_opt size_t* pcchLength)
{
    HRESULT hr = S_OK;
    size_t cchMaxPrev = cchMax;

    while (cchMax && (*psz != '\0'))
    {
        psz++;
        cchMax--;
    }

    if (cchMax == 0)
    {
        // the string is longer than cchMax
        hr = STRSAFE_E_INVALID_PARAMETER;
    }

    if (pcchLength)
    {
        if (SUCCEEDED(hr))
        {
            *pcchLength = cchMaxPrev - cchMax;
        }
        else
        {
            *pcchLength = 0;
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_A_FUNCTIONS
#ifndef STRSAFE_NO_W_FUNCTIONS
STRSAFEAPI
StringLengthWorkerW(
    __in STRSAFE_LPCWSTR psz,
    __in size_t cchMax,
    __out_opt size_t* pcchLength)
{
    HRESULT hr = S_OK;
    size_t cchMaxPrev = cchMax;

    while (cchMax && (*psz != L'\0'))
    {
        psz++;
        cchMax--;
    }

    if (cchMax == 0)
    {
        // the string is longer than cchMax
        hr = STRSAFE_E_INVALID_PARAMETER;
    }

    if (pcchLength)
    {
        if (SUCCEEDED(hr))
        {
            *pcchLength = cchMaxPrev - cchMax;
        }
        else
        {
            *pcchLength = 0;
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_W_FUNCTIONS

#endif  // !STRSAFE_ONLY_SPRINTF_FUNCTIONS

#endif  // STRSAFE_INLINE

#ifndef STRSAFE_ONLY_SPRINTF_FUNCTIONS

#ifdef STRSAFE_WITH_GETS
#ifndef STRSAFE_LIB_IMPL
#ifndef STRSAFE_NO_A_FUNCTIONS
STRSAFE_INLINE_API
StringGetsExWorkerA(
    __out_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in size_t cbDest,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags)
{
    HRESULT hr = S_OK;
    STRSAFE_LPSTR pszDestEnd = pszDest;
    size_t cchRemaining = 0;

    // ASSERT(cbDest == (cchDest * sizeof(char))    ||
    //        cbDest == (cchDest * sizeof(char)) + (cbDest % sizeof(char)));

    // only accept valid flags
    if (dwFlags & (~STRSAFE_VALID_FLAGS))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        if (dwFlags & STRSAFE_IGNORE_NULLS)
        {
            if (pszDest == NULL)
            {
                if ((cchDest != 0) || (cbDest != 0))
                {
                    // NULL pszDest and non-zero cchDest/cbDest is invalid
                    hr = STRSAFE_E_INVALID_PARAMETER;
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            if (cchDest <= 1)
            {
                pszDestEnd = pszDest;
                cchRemaining = cchDest;

                if (cchDest == 1)
                {
                    *pszDestEnd = '\0';
                }

                hr = STRSAFE_E_INSUFFICIENT_BUFFER;
            }
            else
            {
                pszDestEnd = pszDest;
                cchRemaining = cchDest;

                while (cchRemaining > 1)
                {
                    char ch;
                    int i = getc(stdin);

                    if (i == EOF)
                    {
                        if (pszDestEnd == pszDest)
                        {
                            // we failed to read anything from stdin
                            hr = STRSAFE_E_END_OF_FILE;
                        }
                        break;
                    }

                    ch = (char)i;

                    if (ch == '\n')
                    {
                        break;
                    }

                    *pszDestEnd = ch;

                    pszDestEnd++;
                    cchRemaining--;
                }

                if (cchRemaining > 0)
                {
                    // there is extra room
                    if (dwFlags & STRSAFE_FILL_BEHIND_NULL)
                    {
                        memset(pszDestEnd + 1, STRSAFE_GET_FILL_PATTERN(dwFlags), ((cchRemaining - 1) * sizeof(char)) + (cbDest % sizeof(char)));
                    }
                }

                *pszDestEnd = '\0';
            }
        }
    }

    if (FAILED(hr))
    {
        if (pszDest)
        {
            if (dwFlags & STRSAFE_FILL_ON_FAILURE)
            {
                memset(pszDest, STRSAFE_GET_FILL_PATTERN(dwFlags), cbDest);

                if (STRSAFE_GET_FILL_PATTERN(dwFlags) == 0)
                {
                    pszDestEnd = pszDest;
                    cchRemaining = cchDest;
                }
                else if (cchDest > 0)
                {
                    pszDestEnd = pszDest + cchDest - 1;
                    cchRemaining = 1;

                    // null terminate the end of the string
                    *pszDestEnd = '\0';
                }
            }

            if (dwFlags & (STRSAFE_NULL_ON_FAILURE | STRSAFE_NO_TRUNCATION))
            {
                if (cchDest > 0)
                {
                    pszDestEnd = pszDest;
                    cchRemaining = cchDest;

                    // null terminate the beginning of the string
                    *pszDestEnd = '\0';
                }
            }
        }
    }

    if (SUCCEEDED(hr) ||
        (hr == STRSAFE_E_INSUFFICIENT_BUFFER) ||
        (hr == STRSAFE_E_END_OF_FILE))
    {
        if (ppszDestEnd)
        {
            *ppszDestEnd = pszDestEnd;
        }

        if (pcchRemaining)
        {
            *pcchRemaining = cchRemaining;
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_A_FUNCTIONS
#ifndef STRSAFE_NO_W_FUNCTIONS

STRSAFE_INLINE_API
StringGetsExWorkerW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in size_t cbDest,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in unsigned long dwFlags)
{
    HRESULT hr = S_OK;
    STRSAFE_LPWSTR pszDestEnd = pszDest;
    size_t cchRemaining = 0;

    // ASSERT(cbDest == (cchDest * sizeof(char))    ||
    //        cbDest == (cchDest * sizeof(char)) + (cbDest % sizeof(char)));

    // only accept valid flags
    if (dwFlags & (~STRSAFE_VALID_FLAGS))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        if (dwFlags & STRSAFE_IGNORE_NULLS)
        {
            if (pszDest == NULL)
            {
                if ((cchDest != 0) || (cbDest != 0))
                {
                    // NULL pszDest and non-zero cchDest/cbDest is invalid
                    hr = STRSAFE_E_INVALID_PARAMETER;
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            if (cchDest <= 1)
            {
                pszDestEnd = pszDest;
                cchRemaining = cchDest;

                if (cchDest == 1)
                {
                    *pszDestEnd = L'\0';
                }

                hr = STRSAFE_E_INSUFFICIENT_BUFFER;
            }
            else
            {
                pszDestEnd = pszDest;
                cchRemaining = cchDest;

                while (cchRemaining > 1)
                {
                    wchar_t ch = getwc(stdin);
                    // ASSERT(sizeof(wchar_t) == sizeof(wint_t));

                    if (ch == WEOF)
                    {
                        if (pszDestEnd == pszDest)
                        {
                            // we failed to read anything from stdin
                            hr = STRSAFE_E_END_OF_FILE;
                        }
                        break;
                    }

                    if (ch == L'\n')
                    {
                        break;
                    }

                    *pszDestEnd = ch;

                    pszDestEnd++;
                    cchRemaining--;
                }

                if (cchRemaining > 0)
                {
                    // there is extra room
                    if (dwFlags & STRSAFE_FILL_BEHIND_NULL)
                    {
                        memset(pszDestEnd + 1, STRSAFE_GET_FILL_PATTERN(dwFlags), ((cchRemaining - 1) * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t)));
                    }
                }

                *pszDestEnd = L'\0';
            }
        }
    }

    if (FAILED(hr))
    {
        if (pszDest)
        {
            if (dwFlags & STRSAFE_FILL_ON_FAILURE)
            {
                memset(pszDest, STRSAFE_GET_FILL_PATTERN(dwFlags), cbDest);

                if (STRSAFE_GET_FILL_PATTERN(dwFlags) == 0)
                {
                    pszDestEnd = pszDest;
                    cchRemaining = cchDest;
                }
                else if (cchDest > 0)
                {
                    pszDestEnd = pszDest + cchDest - 1;
                    cchRemaining = 1;

                    // null terminate the end of the string
                    *pszDestEnd = L'\0';
                }
            }

            if (dwFlags & (STRSAFE_NULL_ON_FAILURE | STRSAFE_NO_TRUNCATION))
            {
                if (cchDest > 0)
                {
                    pszDestEnd = pszDest;
                    cchRemaining = cchDest;

                    // null terminate the beginning of the string
                    *pszDestEnd = L'\0';
                }
            }
        }
    }

    if (SUCCEEDED(hr) ||
        (hr == STRSAFE_E_INSUFFICIENT_BUFFER) ||
        (hr == STRSAFE_E_END_OF_FILE))
    {
        if (ppszDestEnd)
        {
            *ppszDestEnd = pszDestEnd;
        }

        if (pcchRemaining)
        {
            *pcchRemaining = cchRemaining;
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_W_FUNCTIONS
#endif  // !STRSAFE_LIB_IMPL
#endif  // STRSAFE_WITH_GETS

#endif  // !STRSAFE_ONLY_SPRINTF_FUNCTIONS


// Do not call these functions, they are worker functions for internal use within this file
#ifdef DEPRECATE_SUPPORTED
#pragma deprecated(StringCopyWorkerA)
#pragma deprecated(StringCopyWorkerW)
#pragma deprecated(StringCopyExWorkerA)
#pragma deprecated(StringCopyExWorkerW)
#pragma deprecated(StringCatWorkerA)
#pragma deprecated(StringCatWorkerW)
#pragma deprecated(StringCatExWorkerA)
#pragma deprecated(StringCatExWorkerW)
#pragma deprecated(StringCatNWorkerA)
#pragma deprecated(StringCatNWorkerW)
#pragma deprecated(StringCatNExWorkerA)
#pragma deprecated(StringCatNExWorkerW)
#pragma deprecated(StringVPrintfWorkerA)
#pragma deprecated(StringVPrintfWorkerW)
#pragma deprecated(StringVPrintfExWorkerA)
#pragma deprecated(StringVPrintfExWorkerW)
#pragma deprecated(StringLengthWorkerA)
#pragma deprecated(StringLengthWorkerW)
#pragma deprecated(StringGetsExWorkerA)
#pragma deprecated(StringGetsExWorkerW)
#else
#define StringCopyWorkerA       StringCopyWorkerA_instead_use_StringCchCopyA_or_StringCchCopyExA;
#define StringCopyWorkerW       StringCopyWorkerW_instead_use_StringCchCopyW_or_StringCchCopyExW;
#define StringCopyExWorkerA     StringCopyExWorkerA_instead_use_StringCchCopyA_or_StringCchCopyExA;
#define StringCopyExWorkerW     StringCopyExWorkerW_instead_use_StringCchCopyW_or_StringCchCopyExW;
#define StringCatWorkerA        StringCatWorkerA_instead_use_StringCchCatA_or_StringCchCatExA;
#define StringCatWorkerW        StringCatWorkerW_instead_use_StringCchCatW_or_StringCchCatExW;
#define StringCatExWorkerA      StringCatExWorkerA_instead_use_StringCchCatA_or_StringCchCatExA;
#define StringCatExWorkerW      StringCatExWorkerW_instead_use_StringCchCatW_or_StringCchCatExW;
#define StringCatNWorkerA       StringCatNWorkerA_instead_use_StringCchCatNA_or_StrincCbCatNA;
#define StringCatNWorkerW       StringCatNWorkerW_instead_use_StringCchCatNW_or_StringCbCatNW;
#define StringCatNExWorkerA     StringCatNExWorkerA_instead_use_StringCchCatNExA_or_StringCbCatNExA;
#define StringCatNExWorkerW     StringCatNExWorkerW_instead_use_StringCchCatNExW_or_StringCbCatNExW;
#define StringVPrintfWorkerA    StringVPrintfWorkerA_instead_use_StringCchVPrintfA_or_StringCchVPrintfExA;
#define StringVPrintfWorkerW    StringVPrintfWorkerW_instead_use_StringCchVPrintfW_or_StringCchVPrintfExW;
#define StringVPrintfExWorkerA  StringVPrintfExWorkerA_instead_use_StringCchVPrintfA_or_StringCchVPrintfExA;
#define StringVPrintfExWorkerW  StringVPrintfExWorkerW_instead_use_StringCchVPrintfW_or_StringCchVPrintfExW;
#define StringLengthWorkerA     StringLengthWorkerA_instead_use_StringCchLengthA_or_StringCbLengthA;
#define StringLengthWorkerW     StringLengthWorkerW_instead_use_StringCchLengthW_or_StringCbLengthW;
#define StringGetsExWorkerA     StringGetsExWorkerA_instead_use_StringCchGetsA_or_StringCbGetsA
#define StringGetsExWorkerW     StringGetsExWorkerW_instead_use_StringCchGetsW_or_StringCbGetsW
#endif // !DEPRECATE_SUPPORTED


#ifndef STRSAFE_NO_DEPRECATE
// Deprecate all of the unsafe functions to generate compiletime errors. If you do not want
// this then you can #define STRSAFE_NO_DEPRECATE before including this file.
#ifdef DEPRECATE_SUPPORTED

// First all the names that are a/w variants (or shouldn't be #defined by now anyway).
#pragma deprecated(lstrcpyA)
#pragma deprecated(lstrcpyW)
#pragma deprecated(lstrcatA)
#pragma deprecated(lstrcatW)
#pragma deprecated(wsprintfA)
#pragma deprecated(wsprintfW)

#pragma deprecated(StrCpyW)
#pragma deprecated(StrCatW)
#pragma deprecated(StrNCatA)
#pragma deprecated(StrNCatW)
#pragma deprecated(StrCatNA)
#pragma deprecated(StrCatNW)
#pragma deprecated(wvsprintfA)
#pragma deprecated(wvsprintfW)

#pragma deprecated(strcpy)
#pragma deprecated(wcscpy)
#pragma deprecated(strcat)
#pragma deprecated(wcscat)
#pragma deprecated(sprintf)
#pragma deprecated(swprintf)
#pragma deprecated(vsprintf)
#pragma deprecated(vswprintf)
#pragma deprecated(_snprintf)
#pragma deprecated(_snwprintf)
#pragma deprecated(_vsnprintf)
#pragma deprecated(_vsnwprintf)
#pragma deprecated(gets)
#pragma deprecated(_getws)

// Then all the windows.h names - we need to undef and redef based on UNICODE setting
#undef lstrcpy
#undef lstrcat
#undef wsprintf
#undef wvsprintf
#pragma deprecated(lstrcpy)
#pragma deprecated(lstrcat)
#pragma deprecated(wsprintf)
#pragma deprecated(wvsprintf)
#ifdef UNICODE
#define lstrcpy    lstrcpyW
#define lstrcat    lstrcatW
#define wsprintf   wsprintfW
#define wvsprintf  wvsprintfW
#else
#define lstrcpy    lstrcpyA
#define lstrcat    lstrcatA
#define wsprintf   wsprintfA
#define wvsprintf  wvsprintfA
#endif

// Then the shlwapi names - they key off UNICODE also.
#undef StrCpyA
#undef StrCpy
#undef StrCatA
#undef StrCat
#undef StrNCat
#undef StrCatN
#pragma deprecated(StrCpyA)
#pragma deprecated(StrCatA)
#pragma deprecated(StrCatN)
#pragma deprecated(StrCpy)
#pragma deprecated(StrCat)
#pragma deprecated(StrNCat)
#define StrCpyA lstrcpyA
#define StrCatA lstrcatA
#define StrCatN StrNCat
#ifdef UNICODE
#define StrCpy  StrCpyW
#define StrCat  StrCatW
#define StrNCat StrNCatW
#else
#define StrCpy  lstrcpyA
#define StrCat  lstrcatA
#define StrNCat StrNCatA
#endif

// Then all the CRT names - we need to undef/redef based on UNICODE value.
#undef _tcscpy
#undef _ftcscpy
#undef _tcscat
#undef _ftcscat
#undef _stprintf
#undef _sntprintf
#undef _vstprintf
#undef _vsntprintf
#undef _getts
#pragma deprecated(_tcscpy)
#pragma deprecated(_ftcscpy)
#pragma deprecated(_tcscat)
#pragma deprecated(_ftcscat)
#pragma deprecated(_stprintf)
#pragma deprecated(_sntprintf)
#pragma deprecated(_vstprintf)
#pragma deprecated(_vsntprintf)
#pragma deprecated(_getts)
#ifdef UNICODE
#define _tcscpy     wcscpy
#define _ftcscpy    wcscpy
#define _tcscat     wcscat
#define _ftcscat    wcscat
#define _stprintf   swprintf
#define _sntprintf  _snwprintf
#define _vstprintf  vswprintf
#define _vsntprintf _vsnwprintf
#define _getts      _getws
#else
#define _tcscpy     strcpy
#define _ftcscpy    strcpy
#define _tcscat     strcat
#define _ftcscat    strcat
#define _stprintf   sprintf
#define _sntprintf  _snprintf
#define _vstprintf  vsprintf
#define _vsntprintf _vsnprintf
#define _getts      gets
#endif

#else // DEPRECATE_SUPPORTED

#undef strcpy
#define strcpy      strcpy_instead_use_StringCbCopyA_or_StringCchCopyA;

#undef wcscpy
#define wcscpy      wcscpy_instead_use_StringCbCopyW_or_StringCchCopyW;

#undef strcat
#define strcat      strcat_instead_use_StringCbCatA_or_StringCchCatA;

#undef wcscat
#define wcscat      wcscat_instead_use_StringCbCatW_or_StringCchCatW;

#undef sprintf
#define sprintf     sprintf_instead_use_StringCbPrintfA_or_StringCchPrintfA;

#undef swprintf
#define swprintf    swprintf_instead_use_StringCbPrintfW_or_StringCchPrintfW;

#undef vsprintf
#define vsprintf    vsprintf_instead_use_StringCbVPrintfA_or_StringCchVPrintfA;

#undef vswprintf
#define vswprintf   vswprintf_instead_use_StringCbVPrintfW_or_StringCchVPrintfW;

#undef _snprintf
#define _snprintf   _snprintf_instead_use_StringCbPrintfA_or_StringCchPrintfA;

#undef _snwprintf
#define _snwprintf  _snwprintf_instead_use_StringCbPrintfW_or_StringCchPrintfW;

#undef _vsnprintf
#define _vsnprintf  _vsnprintf_instead_use_StringCbVPrintfA_or_StringCchVPrintfA;

#undef _vsnwprintf
#define _vsnwprintf _vsnwprintf_instead_use_StringCbVPrintfW_or_StringCchVPrintfW;

#undef strcpyA
#define strcpyA     strcpyA_instead_use_StringCbCopyA_or_StringCchCopyA;

#undef strcpyW
#define strcpyW     strcpyW_instead_use_StringCbCopyW_or_StringCchCopyW;

#undef lstrcpy
#define lstrcpy     lstrcpy_instead_use_StringCbCopy_or_StringCchCopy;

#undef lstrcpyA
#define lstrcpyA    lstrcpyA_instead_use_StringCbCopyA_or_StringCchCopyA;

#undef lstrcpyW
#define lstrcpyW    lstrcpyW_instead_use_StringCbCopyW_or_StringCchCopyW;

#undef StrCpy
#define StrCpy      StrCpy_instead_use_StringCbCopy_or_StringCchCopy;

#undef StrCpyA
#define StrCpyA     StrCpyA_instead_use_StringCbCopyA_or_StringCchCopyA;

#undef StrCpyW
#define StrCpyW     StrCpyW_instead_use_StringCbCopyW_or_StringCchCopyW;

#undef _tcscpy
#define _tcscpy     _tcscpy_instead_use_StringCbCopy_or_StringCchCopy;

#undef _ftcscpy
#define _ftcscpy    _ftcscpy_instead_use_StringCbCopy_or_StringCchCopy;

#undef lstrcat
#define lstrcat     lstrcat_instead_use_StringCbCat_or_StringCchCat;

#undef lstrcatA
#define lstrcatA    lstrcatA_instead_use_StringCbCatA_or_StringCchCatA;

#undef lstrcatW
#define lstrcatW    lstrcatW_instead_use_StringCbCatW_or_StringCchCatW;

#undef StrCat
#define StrCat      StrCat_instead_use_StringCbCat_or_StringCchCat;

#undef StrCatA
#define StrCatA     StrCatA_instead_use_StringCbCatA_or_StringCchCatA;

#undef StrCatW
#define StrCatW     StrCatW_instead_use_StringCbCatW_or_StringCchCatW;

#undef StrNCat
#define StrNCat     StrNCat_instead_use_StringCbCatN_or_StringCchCatN;

#undef StrNCatA
#define StrNCatA    StrNCatA_instead_use_StringCbCatNA_or_StringCchCatNA;

#undef StrNCatW
#define StrNCatW    StrNCatW_instead_use_StringCbCatNW_or_StringCchCatNW;

#undef StrCatN
#define StrCatN     StrCatN_instead_use_StringCbCatN_or_StringCchCatN;

#undef StrCatNA
#define StrCatNA    StrCatNA_instead_use_StringCbCatNA_or_StringCchCatNA;

#undef StrCatNW
#define StrCatNW    StrCatNW_instead_use_StringCbCatNW_or_StringCchCatNW;

#undef _tcscat
#define _tcscat     _tcscat_instead_use_StringCbCat_or_StringCchCat;

#undef _ftcscat
#define _ftcscat    _ftcscat_instead_use_StringCbCat_or_StringCchCat;

#undef wsprintf
#define wsprintf    wsprintf_instead_use_StringCbPrintf_or_StringCchPrintf;

#undef wsprintfA
#define wsprintfA   wsprintfA_instead_use_StringCbPrintfA_or_StringCchPrintfA;

#undef wsprintfW
#define wsprintfW   wsprintfW_instead_use_StringCbPrintfW_or_StringCchPrintfW;

#undef wvsprintf
#define wvsprintf   wvsprintf_instead_use_StringCbVPrintf_or_StringCchVPrintf;

#undef wvsprintfA
#define wvsprintfA  wvsprintfA_instead_use_StringCbVPrintfA_or_StringCchVPrintfA;

#undef wvsprintfW
#define wvsprintfW  wvsprintfW_instead_use_StringCbVPrintfW_or_StringCchVPrintfW;

#undef _vstprintf
#define _vstprintf  _vstprintf_instead_use_StringCbVPrintf_or_StringCchVPrintf;

#undef _vsntprintf
#define _vsntprintf _vsntprintf_instead_use_StringCbVPrintf_or_StringCchVPrintf;

#undef _stprintf
#define _stprintf   _stprintf_instead_use_StringCbPrintf_or_StringCchPrintf;

#undef _sntprintf
#define _sntprintf  _sntprintf_instead_use_StringCbPrintf_or_StringCchPrintf;

#undef _getts
#define _getts      _getts_instead_use_StringCbGets_or_StringCchGets;

#undef gets
#define gets        _gets_instead_use_StringCbGetsA_or_StringCchGetsA;

#undef _getws
#define _getws      _getws_instead_use_StringCbGetsW_or_StringCchGetsW;

#endif  // !DEPRECATE_SUPPORTED
#endif  // !STRSAFE_NO_DEPRECATE

#endif  // _STRSAFE_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\svcguid.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++ BUILD Version: 0001    // Increment this if a change has global effects


Module Name:

    svcguid.h

Abstract:

    Defines GUIDs for well-known services including:

        HOSTNAME
        RFC 1060 (Assigned Numbers) from IANA (All TCP/IP Services)
        NetWare services

Created:

    May 8, 1994

Revision History:

--*/

#ifndef _SVCGUID_
#define _SVCGUID_

#if _MSC_VER > 1000
#pragma once
#endif

#include  <basetyps.h>

//
// HOSTNAME--special GUID which refers to the name of a host as opposed
// to any particular service on that host.
//

#define SVCID_HOSTNAME { 0x0002a800, 0, 0, { 0xC0,0,0,0,0,0,0,0x46 } }

//
// GUIDs for dealing with AF_INET address spaces alone. These are
// intended to be used when fetching hostent or servent information
// from such a provider. These are not general-purpose types and
// should be used only when the intent is getting at down-level
// information.
//

#define SVCID_INET_HOSTADDRBYINETSTRING \
              { 0x0002a801, 0, 0, { 0xC0,0,0,0,0,0,0,0x46 } }
#define SVCID_INET_SERVICEBYNAME \
                  { 0x0002a802, 0, 0, { 0xC0,0,0,0,0,0,0,0x46 } }
#define SVCID_INET_HOSTADDRBYNAME \
                  { 0x0002a803, 0, 0, { 0xC0,0,0,0,0,0,0,0x46 } }

//
// Macros for defining and testing TCP and UDP GUIDs from a well-known
// port.
//

#define SVCID_TCP_RR(_Port, _RR) \
             { (0x0009 << 16) | (_Port), 0, _RR, { 0xC0,0,0,0,0,0,0,0x46 } }

#define SVCID_TCP(_Port)       SVCID_TCP_RR(_Port, 0)

#define SVCID_DNS(_RecordType) SVCID_TCP_RR(53, _RecordType)

#define IS_SVCID_DNS(_g) \
             ( (((_g)->Data1) == 0x00090035) && \
               (((_g)->Data2) == 0) &&          \
               (((_g)->Data4[0]) == 0xC0) &&    \
               (((_g)->Data4[1]) == 0) &&       \
               (((_g)->Data4[2]) == 0) &&       \
               (((_g)->Data4[3]) == 0) &&       \
               (((_g)->Data4[4]) == 0) &&       \
               (((_g)->Data4[5]) == 0) &&       \
               (((_g)->Data4[6]) == 0) &&       \
               (((_g)->Data4[7]) == 0x46) )

#define IS_SVCID_TCP(_g) \
             ( ((((_g)->Data1) & 0xFFFF0000) == 0x00090000) && \
               (((_g)->Data2) == 0) &&                       \
               (((_g)->Data4[0]) == 0xC0) &&                 \
               (((_g)->Data4[1]) == 0) &&                    \
               (((_g)->Data4[2]) == 0) &&                    \
               (((_g)->Data4[3]) == 0) &&                    \
               (((_g)->Data4[4]) == 0) &&                    \
               (((_g)->Data4[5]) == 0) &&                    \
               (((_g)->Data4[6]) == 0) &&                    \
               (((_g)->Data4[7]) == 0x46) )

#define PORT_FROM_SVCID_TCP(_g) \
               ((WORD)(_g->Data1 & 0xFFFF))

#define RR_FROM_SVCID(_RR) (_RR->Data3)


#define SET_TCP_SVCID_RR(_g,_Port, _RR) {                    \
               (_g)->Data1 = (0x0009 << 16 ) | (_Port);      \
               (_g)->Data2 = 0;                              \
               (_g)->Data3 = _RR;                            \
               (_g)->Data4[0] = 0xC0;                        \
               (_g)->Data4[1] = 0x0;                         \
               (_g)->Data4[2] = 0x0;                         \
               (_g)->Data4[3] = 0x0;                         \
               (_g)->Data4[4] = 0x0;                         \
               (_g)->Data4[5] = 0x0;                         \
               (_g)->Data4[6] = 0x0;                         \
               (_g)->Data4[7] = 0x46; }

#define SET_TCP_SVCID(_g,_Port) SET_TCP_SVCID_RR(_g, _Port, 0)

#define SVCID_UDP_RR(_Port, _RR) \
             { (0x000A << 16) | (_Port), 0, _RR, { 0xC0,0,0,0,0,0,0,0x46 } }

#define SVCID_UDP(_Port) SVCID_UDP_RR(_Port, 0)

#define IS_SVCID_UDP(_g) \
             ( ((((_g)->Data1) & 0xFFFF0000) == 0x000A0000) && \
               (((_g)->Data2) == 0) &&                       \
               (((_g)->Data4[0]) == 0xC0) &&                 \
               (((_g)->Data4[1]) == 0) &&                    \
               (((_g)->Data4[2]) == 0) &&                    \
               (((_g)->Data4[3]) == 0) &&                    \
               (((_g)->Data4[4]) == 0) &&                    \
               (((_g)->Data4[5]) == 0) &&                    \
               (((_g)->Data4[6]) == 0) &&                    \
               (((_g)->Data4[7]) == 0x46) )

#define PORT_FROM_SVCID_UDP(_g) \
               ((WORD)(_g->Data1 & 0xFFFF))

#define SET_UDP_SVCID_RR(_g,_Port, _RR) {                    \
               (_g)->Data1 = (0x000A << 16 ) | (_Port);      \
               (_g)->Data2 = 0;                              \
               (_g)->Data3 = _RR;                            \
               (_g)->Data4[0] = 0xC0;                        \
               (_g)->Data4[1] = 0x0;                         \
               (_g)->Data4[2] = 0x0;                         \
               (_g)->Data4[3] = 0x0;                         \
               (_g)->Data4[4] = 0x0;                         \
               (_g)->Data4[5] = 0x0;                         \
               (_g)->Data4[6] = 0x0;                         \
               (_g)->Data4[7] = 0x46; }

#define SET_UDP_SVCID(_g, _Port) SET_UDP_SVCID_RR(_g, _Port, 0)

//
// Macros for defining and testing Netware (SAP) services based on the
// SAP ID.
//

#define SVCID_NETWARE(_SapId) \
             { (0x000B << 16) | (_SapId), 0, 0, { 0xC0,0,0,0,0,0,0,0x46 } }

#define IS_SVCID_NETWARE(_g) \
             ( ((((_g)->Data1) & 0xFFFF0000) == 0x000B0000) && \
               (((_g)->Data2) == 0) &&                       \
               (((_g)->Data3) == 0) &&                       \
               (((_g)->Data4[0]) == 0xC0) &&                 \
               (((_g)->Data4[1]) == 0) &&                    \
               (((_g)->Data4[2]) == 0) &&                    \
               (((_g)->Data4[3]) == 0) &&                    \
               (((_g)->Data4[4]) == 0) &&                    \
               (((_g)->Data4[5]) == 0) &&                    \
               (((_g)->Data4[6]) == 0) &&                    \
               (((_g)->Data4[7]) == 0x46) )

#define SAPID_FROM_SVCID_NETWARE(_g) \
               ((WORD)(_g->Data1 & 0xFFFF))

#define SET_NETWARE_SVCID(_g,_SapId) {                       \
               (_g)->Data1 = (0x000B << 16 ) | (_SapId);     \
               (_g)->Data2 = 0;                              \
               (_g)->Data3 = 0;                              \
               (_g)->Data4[0] = 0xC0;                        \
               (_g)->Data4[1] = 0x0;                         \
               (_g)->Data4[2] = 0x0;                         \
               (_g)->Data4[3] = 0x0;                         \
               (_g)->Data4[4] = 0x0;                         \
               (_g)->Data4[5] = 0x0;                         \
               (_g)->Data4[6] = 0x0;                         \
               (_g)->Data4[7] = 0x46; }

//
// RFC 1060 services as defined by the IANA
// GUID block = 0009xxxx-0000-0000-C0000-000000000046
//

#define SVCID_ECHO_TCP                SVCID_TCP( 7 )
#define SVCID_DISCARD_TCP             SVCID_TCP( 9 )
#define SVCID_SYSTAT_TCP              SVCID_TCP( 11 )
#define SVCID_SYSTAT_TCP              SVCID_TCP( 11 )
#define SVCID_DAYTIME_TCP             SVCID_TCP( 13 )
#define SVCID_NETSTAT_TCP             SVCID_TCP( 15 )
#define SVCID_QOTD_TCP                SVCID_TCP( 17 )
#define SVCID_CHARGEN_TCP             SVCID_TCP( 19 )
#define SVCID_FTP_DATA_TCP            SVCID_TCP( 20 )
#define SVCID_FTP_TCP                 SVCID_TCP( 21 )
#define SVCID_TELNET_TCP              SVCID_TCP( 23 )
#define SVCID_SMTP_TCP                SVCID_TCP( 25 )
#define SVCID_TIME_TCP                SVCID_TCP( 37 )
#define SVCID_NAME_TCP                SVCID_TCP( 42 )
#define SVCID_WHOIS_TCP               SVCID_TCP( 43 )
#define SVCID_DOMAIN_TCP              SVCID_TCP( 53 )
#define SVCID_NAMESERVER_TCP          SVCID_TCP( 53 )
#define SVCID_MTP_TCP                 SVCID_TCP( 57 )
#define SVCID_RJE_TCP                 SVCID_TCP( 77 )
#define SVCID_FINGER_TCP              SVCID_TCP( 79 )
#define SVCID_LINK_TCP                SVCID_TCP( 87 )
#define SVCID_SUPDUP_TCP              SVCID_TCP( 95 )
#define SVCID_HOSTNAMES_TCP           SVCID_TCP( 101 )
#define SVCID_ISO_TSAP_TCP            SVCID_TCP( 102 )
#define SVCID_DICTIONARY_TCP          SVCID_TCP( 103 )
#define SVCID_X400_TCP                SVCID_TCP( 103 )
#define SVCID_X400_SND_TCP            SVCID_TCP( 104 )
#define SVCID_CSNET_NS_TCP            SVCID_TCP( 105 )
#define SVCID_POP_TCP                 SVCID_TCP( 109 )
#define SVCID_POP2_TCP                SVCID_TCP( 109 )
#define SVCID_POP3_TCP                SVCID_TCP( 110 )
#define SVCID_PORTMAP_TCP             SVCID_TCP( 111 )
#define SVCID_SUNRPC_TCP              SVCID_TCP( 111 )
#define SVCID_AUTH_TCP                SVCID_TCP( 113 )
#define SVCID_SFTP_TCP                SVCID_TCP( 115 )
#define SVCID_PATH_TCP                SVCID_TCP( 117 )
#define SVCID_UUCP_PATH_TCP           SVCID_TCP( 117 )
#define SVCID_NNTP_TCP                SVCID_TCP( 119 )
#define SVCID_NBSESSION_TCP           SVCID_TCP( 139 )
#define SVCID_NEWS_TCP                SVCID_TCP( 144 )
#define SVCID_TCPREPO_TCP             SVCID_TCP( 158 )
#define SVCID_PRINT_SRV_TCP           SVCID_TCP( 170 )
#define SVCID_VMNET_TCP               SVCID_TCP( 175 )
#define SVCID_VMNET0_TCP              SVCID_TCP( 400 )
#define SVCID_EXEC_TCP                SVCID_TCP( 512 )
#define SVCID_LOGIN_TCP               SVCID_TCP( 513 )
#define SVCID_SHELL_TCP               SVCID_TCP( 514 )
#define SVCID_PRINTER_TCP             SVCID_TCP( 515 )
#define SVCID_EFS_TCP                 SVCID_TCP( 520 )
#define SVCID_TEMPO_TCP               SVCID_TCP( 526 )
#define SVCID_COURIER_TCP             SVCID_TCP( 530 )
#define SVCID_CONFERENCE_TCP          SVCID_TCP( 531 )
#define SVCID_NETNEWS_TCP             SVCID_TCP( 532 )
#define SVCID_UUCP_TCP                SVCID_TCP( 540 )
#define SVCID_KLOGIN_TCP              SVCID_TCP( 543 )
#define SVCID_KSHELL_TCP              SVCID_TCP( 544 )
#define SVCID_REMOTEFS_TCP            SVCID_TCP( 556 )
#define SVCID_GARCON_TCP              SVCID_TCP( 600 )
#define SVCID_MAITRD_TCP              SVCID_TCP( 601 )
#define SVCID_BUSBOY_TCP              SVCID_TCP( 602 )
#define SVCID_KERBEROS_TCP            SVCID_TCP( 750 )
#define SVCID_KERBEROS_MASTER_TCP     SVCID_TCP( 751 )
#define SVCID_KRB_PROP_TCP            SVCID_TCP( 754 )
#define SVCID_ERLOGIN_TCP             SVCID_TCP( 888 )
#define SVCID_KPOP_TCP                SVCID_TCP( 1109 )
#define SVCID_INGRESLOCK_TCP          SVCID_TCP( 1524 )
#define SVCID_KNETD_TCP               SVCID_TCP( 2053 )
#define SVCID_EKLOGIN_TCP             SVCID_TCP( 2105 )
#define SVCID_RMT_TCP                 SVCID_TCP( 5555 )
#define SVCID_MTB_TCP                 SVCID_TCP( 5556 )
#define SVCID_MAN_TCP                 SVCID_TCP( 9535 )
#define SVCID_W_TCP                   SVCID_TCP( 9536 )
#define SVCID_MANTST_TCP              SVCID_TCP( 9537 )
#define SVCID_BNEWS_TCP               SVCID_TCP( 10000 )
#define SVCID_QUEUE_TCP               SVCID_TCP( 10001 )
#define SVCID_POKER_TCP               SVCID_TCP( 10002 )
#define SVCID_GATEWAY_TCP             SVCID_TCP( 10003 )
#define SVCID_REMP_TCP                SVCID_TCP( 10004 )
#define SVCID_QMASTER_TCP             SVCID_TCP( 10012 )

#define SVCID_ECHO_UDP                SVCID_UDP( 7 )
#define SVCID_DISCARD_UDP             SVCID_UDP( 9 )
#define SVCID_DAYTIME_UDP             SVCID_UDP( 13 )
#define SVCID_QOTD_UDP                SVCID_UDP( 17 )
#define SVCID_CHARGEN_UDP             SVCID_UDP( 19 )
#define SVCID_TIME_UDP                SVCID_UDP( 37 )
#define SVCID_RLP_UDP                 SVCID_UDP( 39 )
#define SVCID_NAME_UDP                SVCID_UDP( 42 )
#define SVCID_DOMAIN_UDP              SVCID_UDP( 53 )
#define SVCID_NAMESERVER_UDP          SVCID_UDP( 53 )
#define SVCID_BOOTP_UDP               SVCID_UDP( 67 )
#define SVCID_TFTP_UDP                SVCID_UDP( 69 )
#define SVCID_PORTMAP_UDP             SVCID_UDP( 111 )
#define SVCID_SUNRPC_UDP              SVCID_UDP( 111 )
#define SVCID_NTP_UDP                 SVCID_UDP( 123 )
#define SVCID_NBNAME_UDP              SVCID_UDP( 137 )
#define SVCID_NBDATAGRAM_UDP          SVCID_UDP( 138 )
#define SVCID_SGMP_UDP                SVCID_UDP( 153 )
#define SVCID_SNMP_UDP                SVCID_UDP( 161 )
#define SVCID_SNMP_TRAP_UDP           SVCID_UDP( 162 )
#define SVCID_LOAD_UDP                SVCID_UDP( 315 )
#define SVCID_SYTEK_UDP               SVCID_UDP( 500 )
#define SVCID_BIFF_UDP                SVCID_UDP( 512 )
#define SVCID_WHO_UDP                 SVCID_UDP( 513 )
#define SVCID_SYSLOG_UDP              SVCID_UDP( 514 )
#define SVCID_TALK_UDP                SVCID_UDP( 517 )
#define SVCID_NTALK_UDP               SVCID_UDP( 518 )
#define SVCID_ROUTE_UDP               SVCID_UDP( 520 )
#define SVCID_TIMED_UDP               SVCID_UDP( 525 )
#define SVCID_RVD_CONTROL_UDP         SVCID_UDP( 531 )
#define SVCID_NETWALL_UDP             SVCID_UDP( 533 )
#define SVCID_NEW_RWHO_UDP            SVCID_UDP( 550 )
#define SVCID_RMONITOR_UDP            SVCID_UDP( 560 )
#define SVCID_MONITOR_UDP             SVCID_UDP( 561 )
#define SVCID_ACCTMASTER_UDP          SVCID_UDP( 700 )
#define SVCID_ACCTSLAVE_UDP           SVCID_UDP( 701 )
#define SVCID_ACCT_UDP                SVCID_UDP( 702 )
#define SVCID_ACCTLOGIN_UDP           SVCID_UDP( 703 )
#define SVCID_ACCTPRINTER_UDP         SVCID_UDP( 704 )
#define SVCID_ELCSD_UDP               SVCID_UDP( 704 )
#define SVCID_ACCTINFO_UDP            SVCID_UDP( 705 )
#define SVCID_ACCTSLAVE2_UDP          SVCID_UDP( 706 )
#define SVCID_ACCTDISK_UDP            SVCID_UDP( 707 )
#define SVCID_KERBEROS_UDP            SVCID_UDP( 750 )
#define SVCID_KERBEROS_MASTER_UDP     SVCID_UDP( 751 )
#define SVCID_PASSWD_SERVER_UDP       SVCID_UDP( 752 )
#define SVCID_USERREG_SERVER_UDP      SVCID_UDP( 753 )
#define SVCID_PHONE_UDP               SVCID_UDP( 1167 )
#define SVCID_MAZE_UDP                SVCID_UDP( 1666 )
#define SVCID_NFS_UDP                 SVCID_UDP( 2049 )
#define SVCID_RSCS0_UDP               SVCID_UDP( 10000 )
#define SVCID_RSCS1_UDP               SVCID_UDP( 10001 )
#define SVCID_RSCS2_UDP               SVCID_UDP( 10002 )
#define SVCID_RSCS3_UDP               SVCID_UDP( 10003 )
#define SVCID_RSCS4_UDP               SVCID_UDP( 10004 )
#define SVCID_RSCS5_UDP               SVCID_UDP( 10005 )
#define SVCID_RSCS6_UDP               SVCID_UDP( 10006 )
#define SVCID_RSCS7_UDP               SVCID_UDP( 10007 )
#define SVCID_RSCS8_UDP               SVCID_UDP( 10008 )
#define SVCID_RSCS9_UDP               SVCID_UDP( 10009 )
#define SVCID_RSCSA_UDP               SVCID_UDP( 10010 )
#define SVCID_RSCSB_UDP               SVCID_UDP( 10011 )
#define SVCID_QMASTER_UDP             SVCID_UDP( 10012 )

//
// NetWare services
// GUID block = 000axxxx-0000-0000-C0000-000000000046
//

#define SVCID_PRINT_QUEUE                 SVCID_NETWARE( 0x3 )
#define SVCID_FILE_SERVER                 SVCID_NETWARE( 0x4 )
#define SVCID_JOB_SERVER                  SVCID_NETWARE( 0x5 )
#define SVCID_GATEWAY                     SVCID_NETWARE( 0x6 )
#define SVCID_PRINT_SERVER                SVCID_NETWARE( 0x7 )
#define SVCID_ARCHIVE_QUEUE               SVCID_NETWARE( 0x8 )
#define SVCID_ARCHIVE_SERVER              SVCID_NETWARE( 0x9 )
#define SVCID_JOB_QUEUE                   SVCID_NETWARE( 0xA )
#define SVCID_ADMINISTRATION              SVCID_NETWARE( 0xB )
#define SVCID_NAS_SNA_GATEWAY             SVCID_NETWARE( 0x21 )
#define SVCID_REMOTE_BRIDGE_SERVER        SVCID_NETWARE( 0x24 )
#define SVCID_TIME_SYNCHRONIZATION_SERVER SVCID_NETWARE( 0x2D )
#define SVCID_ARCHIVE_SERVER_DYNAMIC_SAP  SVCID_NETWARE( 0x2E )
#define SVCID_ADVERTISING_PRINT_SERVER    SVCID_NETWARE( 0x47 )
#define SVCID_BTRIEVE_VAP                 SVCID_NETWARE( 0x4B )
#define SVCID_DIRECTORY_SERVER            SVCID_NETWARE( 0x278 )
#define SVCID_NETWARE_386                 SVCID_NETWARE( 0x107 )
#define SVCID_HP_PRINT_SERVER             SVCID_NETWARE( 0x30C )
#define SVCID_SNA_SERVER                  SVCID_NETWARE( 0x444 )
#define SVCID_SAA_SERVER                  SVCID_NETWARE( 0x130 )

//
// DNS services by record type
// GUID block = 00090035-0000-xxxx-C0000-000000000046
//

#define SVCID_DNS_TYPE_A                  SVCID_DNS( 0x0001 )
#define SVCID_DNS_TYPE_NS                 SVCID_DNS( 0x0002 )
#define SVCID_DNS_TYPE_MD                 SVCID_DNS( 0x0003 )
#define SVCID_DNS_TYPE_MF                 SVCID_DNS( 0x0004 )
#define SVCID_DNS_TYPE_CNAME              SVCID_DNS( 0x0005 )
#define SVCID_DNS_TYPE_SOA                SVCID_DNS( 0x0006 )
#define SVCID_DNS_TYPE_MB                 SVCID_DNS( 0x0007 )
#define SVCID_DNS_TYPE_MG                 SVCID_DNS( 0x0008 )
#define SVCID_DNS_TYPE_MR                 SVCID_DNS( 0x0009 )
#define SVCID_DNS_TYPE_NULL               SVCID_DNS( 0x000a )
#define SVCID_DNS_TYPE_WKS                SVCID_DNS( 0x000b )
#define SVCID_DNS_TYPE_PTR                SVCID_DNS( 0x000c )
#define SVCID_DNS_TYPE_HINFO              SVCID_DNS( 0x000d )
#define SVCID_DNS_TYPE_MINFO              SVCID_DNS( 0x000e )
#define SVCID_DNS_TYPE_MX                 SVCID_DNS( 0x000f )
#define SVCID_DNS_TYPE_TEXT               SVCID_DNS( 0x0010 )
#define SVCID_DNS_TYPE_RP                 SVCID_DNS( 0x0011 )
#define SVCID_DNS_TYPE_AFSDB              SVCID_DNS( 0x0012 )
#define SVCID_DNS_TYPE_X25                SVCID_DNS( 0x0013 )
#define SVCID_DNS_TYPE_ISDN               SVCID_DNS( 0x0014 )
#define SVCID_DNS_TYPE_RT                 SVCID_DNS( 0x0015 )
#define SVCID_DNS_TYPE_NSAP               SVCID_DNS( 0x0016 )
#define SVCID_DNS_TYPE_NSAPPTR            SVCID_DNS( 0x0017 )
#define SVCID_DNS_TYPE_SIG                SVCID_DNS( 0x0018 )
#define SVCID_DNS_TYPE_KEY                SVCID_DNS( 0x0019 )
#define SVCID_DNS_TYPE_PX                 SVCID_DNS( 0x001a )
#define SVCID_DNS_TYPE_GPOS               SVCID_DNS( 0x001b )
#define SVCID_DNS_TYPE_AAAA               SVCID_DNS( 0x001c )
#define SVCID_DNS_TYPE_LOC                SVCID_DNS( 0x001d )
#define SVCID_DNS_TYPE_NXT                SVCID_DNS( 0x001e )
#define SVCID_DNS_TYPE_SRV                SVCID_DNS( 0x0021 )
#define SVCID_DNS_TYPE_ATMA               SVCID_DNS( 0x0022 )

#endif // _SVCGUID_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\tapi.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++

The  Telephony  API  is jointly copyrighted by Intel and Microsoft.  You are
granted  a royalty free worldwide, unlimited license to make copies, and use
the   API/SPI  for  making  applications/drivers  that  interface  with  the
specification provided that this paragraph and the Intel/Microsoft copyright
statement is maintained as is in the text and source code files.

Portions copyright 1992, 1993 Intel/Microsoft, all rights reserved.

Module Name:

    tapi.h

Notes:

    Additions to the Telephony Application Programming Interface (TAPI) since
    version 1.0 are noted by version number (e.g. "TAPI v1.4").

--*/

#pragma once

#ifndef TAPI_H
#define TAPI_H



//
//  -- TAPI VERSION INFO -- TAPI VERSION INFO -- TAPI VERSION INFO --
//  -- TAPI VERSION INFO -- TAPI VERSION INFO -- TAPI VERSION INFO --
//  -- TAPI VERSION INFO -- TAPI VERSION INFO -- TAPI VERSION INFO --
//
// To build  a TAPI 1.4 application put a define as below in your source
// file before you include TAPI.H:
//
// #define TAPI_CURRENT_VERSION 0x00010004
//
//
#ifndef TAPI_CURRENT_VERSION
#define TAPI_CURRENT_VERSION 0x00020000
#endif

#include <windows.h>

// Type definitions of the data types used in tapi

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */


//
// TAPI type definitions
//

#define DECLARE_OPAQUE32(name)  struct name##__ { int unused; }; \
                typedef const struct name##__ FAR* name

DECLARE_OPAQUE32(HCALL);
typedef HCALL FAR * LPHCALL;

DECLARE_OPAQUE32(HLINE);
typedef HLINE FAR * LPHLINE;

DECLARE_OPAQUE32(HPHONE);
typedef HPHONE FAR * LPHPHONE;

DECLARE_OPAQUE32(HLINEAPP);
typedef HLINEAPP FAR * LPHLINEAPP;

DECLARE_OPAQUE32(HPHONEAPP);
typedef HPHONEAPP FAR * LPHPHONEAPP;

typedef HICON FAR * LPHICON;

typedef void (CALLBACK * LINECALLBACK)(
    DWORD               hDevice,
    DWORD               dwMessage,
    DWORD               dwInstance,
    DWORD               dwParam1,
    DWORD               dwParam2,
    DWORD               dwParam3
    );

typedef void (CALLBACK * PHONECALLBACK)(
    DWORD               hDevice,
    DWORD               dwMessage,
    DWORD               dwInstance,
    DWORD               dwParam1,
    DWORD               dwParam2,
    DWORD               dwParam3
    );


// Messages for Phones and Lines

#define LINE_ADDRESSSTATE                       0L
#define LINE_CALLINFO                           1L
#define LINE_CALLSTATE                          2L
#define LINE_CLOSE                              3L
#define LINE_DEVSPECIFIC                        4L
#define LINE_DEVSPECIFICFEATURE                 5L
#define LINE_GATHERDIGITS                       6L
#define LINE_GENERATE                           7L
#define LINE_LINEDEVSTATE                       8L
#define LINE_MONITORDIGITS                      9L
#define LINE_MONITORMEDIA                       10L
#define LINE_MONITORTONE                        11L
#define LINE_REPLY                              12L
#define LINE_REQUEST                            13L
#define PHONE_BUTTON                            14L
#define PHONE_CLOSE                             15L
#define PHONE_DEVSPECIFIC                       16L
#define PHONE_REPLY                             17L
#define PHONE_STATE                             18L
#define LINE_CREATE                             19L             // TAPI v1.4
#define PHONE_CREATE                            20L             // TAPI v1.4

#define LINE_AGENTSPECIFIC                      21L             // TAPI v2.0
#define LINE_AGENTSTATUS                        22L             // TAPI v2.0
#define LINE_APPNEWCALL                         23L             // TAPI v2.0
#define LINE_PROXYREQUEST                       24L             // TAPI v2.0
#define LINE_REMOVE                             25L             // TAPI v2.0
#define PHONE_REMOVE                            26L             // TAPI v2.0

#define INITIALIZE_NEGOTIATION                  0xFFFFFFFFL

#define LINEADDRCAPFLAGS_FWDNUMRINGS            0x00000001
#define LINEADDRCAPFLAGS_PICKUPGROUPID          0x00000002
#define LINEADDRCAPFLAGS_SECURE                 0x00000004
#define LINEADDRCAPFLAGS_BLOCKIDDEFAULT         0x00000008
#define LINEADDRCAPFLAGS_BLOCKIDOVERRIDE        0x00000010
#define LINEADDRCAPFLAGS_DIALED                 0x00000020
#define LINEADDRCAPFLAGS_ORIGOFFHOOK            0x00000040
#define LINEADDRCAPFLAGS_DESTOFFHOOK            0x00000080
#define LINEADDRCAPFLAGS_FWDCONSULT             0x00000100
#define LINEADDRCAPFLAGS_SETUPCONFNULL          0x00000200
#define LINEADDRCAPFLAGS_AUTORECONNECT          0x00000400
#define LINEADDRCAPFLAGS_COMPLETIONID           0x00000800
#define LINEADDRCAPFLAGS_TRANSFERHELD           0x00001000
#define LINEADDRCAPFLAGS_TRANSFERMAKE           0x00002000
#define LINEADDRCAPFLAGS_CONFERENCEHELD         0x00004000
#define LINEADDRCAPFLAGS_CONFERENCEMAKE         0x00008000
#define LINEADDRCAPFLAGS_PARTIALDIAL            0x00010000
#define LINEADDRCAPFLAGS_FWDSTATUSVALID         0x00020000
#define LINEADDRCAPFLAGS_FWDINTEXTADDR          0x00040000
#define LINEADDRCAPFLAGS_FWDBUSYNAADDR          0x00080000
#define LINEADDRCAPFLAGS_ACCEPTTOALERT          0x00100000
#define LINEADDRCAPFLAGS_CONFDROP               0x00200000
#define LINEADDRCAPFLAGS_PICKUPCALLWAIT         0x00400000

#define LINEADDRCAPFLAGS_PREDICTIVEDIALER       0x00800000      // TAPI v2.0
#define LINEADDRCAPFLAGS_QUEUE                  0x01000000      // TAPI v2.0
#define LINEADDRCAPFLAGS_ROUTEPOINT             0x02000000      // TAPI v2.0
#define LINEADDRCAPFLAGS_HOLDMAKESNEW           0x04000000      // TAPI v2.0
#define LINEADDRCAPFLAGS_NOINTERNALCALLS        0x08000000      // TAPI v2.0
#define LINEADDRCAPFLAGS_NOEXTERNALCALLS        0x10000000      // TAPI v2.0
#define LINEADDRCAPFLAGS_SETCALLINGID           0x20000000      // TAPI v2.0


#define LINEADDRESSMODE_ADDRESSID               0x00000001
#define LINEADDRESSMODE_DIALABLEADDR            0x00000002

#define LINEADDRESSSHARING_PRIVATE              0x00000001
#define LINEADDRESSSHARING_BRIDGEDEXCL          0x00000002
#define LINEADDRESSSHARING_BRIDGEDNEW           0x00000004
#define LINEADDRESSSHARING_BRIDGEDSHARED        0x00000008
#define LINEADDRESSSHARING_MONITORED            0x00000010

#define LINEADDRESSSTATE_OTHER                  0x00000001
#define LINEADDRESSSTATE_DEVSPECIFIC            0x00000002
#define LINEADDRESSSTATE_INUSEZERO              0x00000004
#define LINEADDRESSSTATE_INUSEONE               0x00000008
#define LINEADDRESSSTATE_INUSEMANY              0x00000010
#define LINEADDRESSSTATE_NUMCALLS               0x00000020
#define LINEADDRESSSTATE_FORWARD                0x00000040
#define LINEADDRESSSTATE_TERMINALS              0x00000080
#define LINEADDRESSSTATE_CAPSCHANGE             0x00000100      // TAPI v1.4

#define LINEADDRESSTYPE_PHONENUMBER             0x00000001
#define LINEADDRESSTYPE_SDP                     0x00000002
#define LINEADDRESSTYPE_EMAILNAME               0x00000004
#define LINEADDRESSTYPE_DOMAINNAME              0x00000008
#define LINEADDRESSTYPE_IPADDRESS               0x00000010


#define LINEADDRFEATURE_FORWARD                 0x00000001
#define LINEADDRFEATURE_MAKECALL                0x00000002
#define LINEADDRFEATURE_PICKUP                  0x00000004
#define LINEADDRFEATURE_SETMEDIACONTROL         0x00000008
#define LINEADDRFEATURE_SETTERMINAL             0x00000010
#define LINEADDRFEATURE_SETUPCONF               0x00000020
#define LINEADDRFEATURE_UNCOMPLETECALL          0x00000040
#define LINEADDRFEATURE_UNPARK                  0x00000080

#define LINEADDRFEATURE_PICKUPHELD              0x00000100      // TAPI v2.0
#define LINEADDRFEATURE_PICKUPGROUP             0x00000200      // TAPI v2.0
#define LINEADDRFEATURE_PICKUPDIRECT            0x00000400      // TAPI v2.0
#define LINEADDRFEATURE_PICKUPWAITING           0x00000800      // TAPI v2.0
#define LINEADDRFEATURE_FORWARDFWD              0x00001000      // TAPI v2.0
#define LINEADDRFEATURE_FORWARDDND              0x00002000      // TAPI v2.0



#define LINEAGENTFEATURE_SETAGENTGROUP          0x00000001      // TAPI v2.0
#define LINEAGENTFEATURE_SETAGENTSTATE          0x00000002      // TAPI v2.0
#define LINEAGENTFEATURE_SETAGENTACTIVITY       0x00000004      // TAPI v2.0
#define LINEAGENTFEATURE_AGENTSPECIFIC          0x00000008      // TAPI v2.0
#define LINEAGENTFEATURE_GETAGENTACTIVITYLIST   0x00000010      // TAPI v2.0
#define LINEAGENTFEATURE_GETAGENTGROUP          0x00000020      // TAPI v2.0

#define LINEAGENTSTATE_LOGGEDOFF                0x00000001      // TAPI v2.0
#define LINEAGENTSTATE_NOTREADY                 0x00000002      // TAPI v2.0
#define LINEAGENTSTATE_READY                    0x00000004      // TAPI v2.0
#define LINEAGENTSTATE_BUSYACD                  0x00000008      // TAPI v2.0
#define LINEAGENTSTATE_BUSYINCOMING             0x00000010      // TAPI v2.0
#define LINEAGENTSTATE_BUSYOUTBOUND             0x00000020      // TAPI v2.0
#define LINEAGENTSTATE_BUSYOTHER                0x00000040      // TAPI v2.0
#define LINEAGENTSTATE_WORKINGAFTERCALL         0x00000080      // TAPI v2.0
#define LINEAGENTSTATE_UNKNOWN                  0x00000100      // TAPI v2.0
#define LINEAGENTSTATE_UNAVAIL                  0x00000200      // TAPI v2.0

#define LINEAGENTSTATUS_GROUP                   0x00000001      // TAPI v2.0
#define LINEAGENTSTATUS_STATE                   0x00000002      // TAPI v2.0
#define LINEAGENTSTATUS_NEXTSTATE               0x00000004      // TAPI v2.0
#define LINEAGENTSTATUS_ACTIVITY                0x00000008      // TAPI v2.0
#define LINEAGENTSTATUS_ACTIVITYLIST            0x00000010      // TAPI v2.0
#define LINEAGENTSTATUS_GROUPLIST               0x00000020      // TAPI v2.0
#define LINEAGENTSTATUS_CAPSCHANGE              0x00000040      // TAPI v2.0
#define LINEAGENTSTATUS_VALIDSTATES             0x00000080      // TAPI v2.0
#define LINEAGENTSTATUS_VALIDNEXTSTATES         0x00000100      // TAPI v2.0



#define LINEANSWERMODE_NONE                     0x00000001
#define LINEANSWERMODE_DROP                     0x00000002
#define LINEANSWERMODE_HOLD                     0x00000004

#define LINEBEARERMODE_VOICE                    0x00000001
#define LINEBEARERMODE_SPEECH                   0x00000002
#define LINEBEARERMODE_MULTIUSE                 0x00000004
#define LINEBEARERMODE_DATA                     0x00000008
#define LINEBEARERMODE_ALTSPEECHDATA            0x00000010
#define LINEBEARERMODE_NONCALLSIGNALING         0x00000020
#define LINEBEARERMODE_PASSTHROUGH              0x00000040      // TAPI v1.4

#define LINEBEARERMODE_RESTRICTEDDATA           0x00000080      // TAPI v2.0


#define LINEBUSYMODE_STATION                    0x00000001
#define LINEBUSYMODE_TRUNK                      0x00000002
#define LINEBUSYMODE_UNKNOWN                    0x00000004
#define LINEBUSYMODE_UNAVAIL                    0x00000008

#define LINECALLCOMPLCOND_BUSY                  0x00000001
#define LINECALLCOMPLCOND_NOANSWER              0x00000002

#define LINECALLCOMPLMODE_CAMPON                0x00000001
#define LINECALLCOMPLMODE_CALLBACK              0x00000002
#define LINECALLCOMPLMODE_INTRUDE               0x00000004
#define LINECALLCOMPLMODE_MESSAGE               0x00000008

#define LINECALLFEATURE_ACCEPT                  0x00000001
#define LINECALLFEATURE_ADDTOCONF               0x00000002
#define LINECALLFEATURE_ANSWER                  0x00000004
#define LINECALLFEATURE_BLINDTRANSFER           0x00000008
#define LINECALLFEATURE_COMPLETECALL            0x00000010
#define LINECALLFEATURE_COMPLETETRANSF          0x00000020
#define LINECALLFEATURE_DIAL                    0x00000040
#define LINECALLFEATURE_DROP                    0x00000080
#define LINECALLFEATURE_GATHERDIGITS            0x00000100
#define LINECALLFEATURE_GENERATEDIGITS          0x00000200
#define LINECALLFEATURE_GENERATETONE            0x00000400
#define LINECALLFEATURE_HOLD                    0x00000800
#define LINECALLFEATURE_MONITORDIGITS           0x00001000
#define LINECALLFEATURE_MONITORMEDIA            0x00002000
#define LINECALLFEATURE_MONITORTONES            0x00004000
#define LINECALLFEATURE_PARK                    0x00008000
#define LINECALLFEATURE_PREPAREADDCONF          0x00010000
#define LINECALLFEATURE_REDIRECT                0x00020000
#define LINECALLFEATURE_REMOVEFROMCONF          0x00040000
#define LINECALLFEATURE_SECURECALL              0x00080000
#define LINECALLFEATURE_SENDUSERUSER            0x00100000
#define LINECALLFEATURE_SETCALLPARAMS           0x00200000
#define LINECALLFEATURE_SETMEDIACONTROL         0x00400000
#define LINECALLFEATURE_SETTERMINAL             0x00800000
#define LINECALLFEATURE_SETUPCONF               0x01000000
#define LINECALLFEATURE_SETUPTRANSFER           0x02000000
#define LINECALLFEATURE_SWAPHOLD                0x04000000
#define LINECALLFEATURE_UNHOLD                  0x08000000
#define LINECALLFEATURE_RELEASEUSERUSERINFO     0x10000000      // TAPI v1.4

#define LINECALLFEATURE_SETTREATMENT            0x20000000      // TAPI v2.0
#define LINECALLFEATURE_SETQOS                  0x40000000      // TAPI v2.0
#define LINECALLFEATURE_SETCALLDATA             0x80000000      // TAPI v2.0



#define LINECALLFEATURE2_NOHOLDCONFERENCE       0x00000001      // TAPI v2.0
#define LINECALLFEATURE2_ONESTEPTRANSFER        0x00000002      // TAPI v2.0
#define LINECALLFEATURE2_COMPLCAMPON            0x00000004      // TAPI v2.0
#define LINECALLFEATURE2_COMPLCALLBACK          0x00000008      // TAPI v2.0
#define LINECALLFEATURE2_COMPLINTRUDE           0x00000010      // TAPI v2.0
#define LINECALLFEATURE2_COMPLMESSAGE           0x00000020      // TAPI v2.0
#define LINECALLFEATURE2_TRANSFERNORM           0x00000040      // TAPI v2.0
#define LINECALLFEATURE2_TRANSFERCONF           0x00000080      // TAPI v2.0
#define LINECALLFEATURE2_PARKDIRECT             0x00000100      // TAPI v2.0
#define LINECALLFEATURE2_PARKNONDIRECT          0x00000200      // TAPI v2.0

#define LINECALLFEATURE2_FLASH                  0x20000000      // Line device support flash command (CDMA)
#define LINECALLFEATURE2_REJECTWAITINGCALL      0x40000000      // Line device can rejejct waiting call
#define LINECALLFEATURE2_MANAGECALLS            0x80000000      // Line device support lineManageCalls

#define LINECALLINFOSTATE_OTHER                 0x00000001
#define LINECALLINFOSTATE_DEVSPECIFIC           0x00000002
#define LINECALLINFOSTATE_BEARERMODE            0x00000004
#define LINECALLINFOSTATE_RATE                  0x00000008
#define LINECALLINFOSTATE_MEDIAMODE             0x00000010
#define LINECALLINFOSTATE_APPSPECIFIC           0x00000020
#define LINECALLINFOSTATE_CALLID                0x00000040
#define LINECALLINFOSTATE_RELATEDCALLID         0x00000080
#define LINECALLINFOSTATE_ORIGIN                0x00000100
#define LINECALLINFOSTATE_REASON                0x00000200
#define LINECALLINFOSTATE_COMPLETIONID          0x00000400
#define LINECALLINFOSTATE_NUMOWNERINCR          0x00000800
#define LINECALLINFOSTATE_NUMOWNERDECR          0x00001000
#define LINECALLINFOSTATE_NUMMONITORS           0x00002000
#define LINECALLINFOSTATE_TRUNK                 0x00004000
#define LINECALLINFOSTATE_CALLERID              0x00008000
#define LINECALLINFOSTATE_CALLEDID              0x00010000
#define LINECALLINFOSTATE_CONNECTEDID           0x00020000
#define LINECALLINFOSTATE_REDIRECTIONID         0x00040000
#define LINECALLINFOSTATE_REDIRECTINGID         0x00080000
#define LINECALLINFOSTATE_DISPLAY               0x00100000
#define LINECALLINFOSTATE_USERUSERINFO          0x00200000
#define LINECALLINFOSTATE_HIGHLEVELCOMP         0x00400000
#define LINECALLINFOSTATE_LOWLEVELCOMP          0x00800000
#define LINECALLINFOSTATE_CHARGINGINFO          0x01000000
#define LINECALLINFOSTATE_TERMINAL              0x02000000
#define LINECALLINFOSTATE_DIALPARAMS            0x04000000
#define LINECALLINFOSTATE_MONITORMODES          0x08000000

#define LINECALLINFOSTATE_TREATMENT             0x10000000      // TAPI v2.0
#define LINECALLINFOSTATE_QOS                   0x20000000      // TAPI v2.0
#define LINECALLINFOSTATE_CALLDATA              0x40000000      // TAPI v2.0
#define LINECALLINFOSTATE_SIMCALLMODIFIED       0x80000000      // WINCE ONLY; to support USIM CALL CONTROL

#define LINECALLORIGIN_OUTBOUND                 0x00000001
#define LINECALLORIGIN_INTERNAL                 0x00000002
#define LINECALLORIGIN_EXTERNAL                 0x00000004
#define LINECALLORIGIN_UNKNOWN                  0x00000010
#define LINECALLORIGIN_UNAVAIL                  0x00000020
#define LINECALLORIGIN_CONFERENCE               0x00000040
#define LINECALLORIGIN_INBOUND                  0x00000080      // TAPI v1.4

#define LINECALLPARAMFLAGS_SECURE               0x00000001
#define LINECALLPARAMFLAGS_IDLE                 0x00000002
#define LINECALLPARAMFLAGS_BLOCKID              0x00000004
#define LINECALLPARAMFLAGS_ORIGOFFHOOK          0x00000008
#define LINECALLPARAMFLAGS_DESTOFFHOOK          0x00000010

#define LINECALLPARAMFLAGS_NOHOLDCONFERENCE     0x00000020      // TAPI v2.0
#define LINECALLPARAMFLAGS_PREDICTIVEDIAL       0x00000040      // TAPI v2.0
#define LINECALLPARAMFLAGS_ONESTEPTRANSFER      0x00000080      // TAPI v2.0


#define LINECALLPARTYID_BLOCKED                 0x00000001
#define LINECALLPARTYID_OUTOFAREA               0x00000002
#define LINECALLPARTYID_NAME                    0x00000004
#define LINECALLPARTYID_ADDRESS                 0x00000008
#define LINECALLPARTYID_PARTIAL                 0x00000010
#define LINECALLPARTYID_UNKNOWN                 0x00000020
#define LINECALLPARTYID_UNAVAIL                 0x00000040

#define LINECALLPRIVILEGE_NONE                  0x00000001
#define LINECALLPRIVILEGE_MONITOR               0x00000002
#define LINECALLPRIVILEGE_OWNER                 0x00000004

#define LINECALLREASON_DIRECT                   0x00000001
#define LINECALLREASON_FWDBUSY                  0x00000002
#define LINECALLREASON_FWDNOANSWER              0x00000004
#define LINECALLREASON_FWDUNCOND                0x00000008
#define LINECALLREASON_PICKUP                   0x00000010
#define LINECALLREASON_UNPARK                   0x00000020
#define LINECALLREASON_REDIRECT                 0x00000040
#define LINECALLREASON_CALLCOMPLETION           0x00000080
#define LINECALLREASON_TRANSFER                 0x00000100
#define LINECALLREASON_REMINDER                 0x00000200
#define LINECALLREASON_UNKNOWN                  0x00000400
#define LINECALLREASON_UNAVAIL                  0x00000800
#define LINECALLREASON_INTRUDE                  0x00001000      // TAPI v1.4
#define LINECALLREASON_PARKED                   0x00002000      // TAPI v1.4

#define LINECALLREASON_CAMPEDON                 0x00004000      // TAPI v2.0
#define LINECALLREASON_ROUTEREQUEST             0x00008000      // TAPI v2.0


#define LINECALLSELECT_LINE                     0x00000001
#define LINECALLSELECT_ADDRESS                  0x00000002
#define LINECALLSELECT_CALL                     0x00000004
#define LINECALLSELECT_DEVICEID                 0x00000008      // TAPI v2.1
#define LINECALLSELECT_CALLID                   0x00000010      // TAPI v3.0

#define LINECALLSTATE_IDLE                      0x00000001
#define LINECALLSTATE_OFFERING                  0x00000002
#define LINECALLSTATE_ACCEPTED                  0x00000004
#define LINECALLSTATE_DIALTONE                  0x00000008
#define LINECALLSTATE_DIALING                   0x00000010
#define LINECALLSTATE_RINGBACK                  0x00000020
#define LINECALLSTATE_BUSY                      0x00000040
#define LINECALLSTATE_SPECIALINFO               0x00000080
#define LINECALLSTATE_CONNECTED                 0x00000100
#define LINECALLSTATE_PROCEEDING                0x00000200
#define LINECALLSTATE_ONHOLD                    0x00000400
#define LINECALLSTATE_CONFERENCED               0x00000800
#define LINECALLSTATE_ONHOLDPENDCONF            0x00001000
#define LINECALLSTATE_ONHOLDPENDTRANSFER        0x00002000
#define LINECALLSTATE_DISCONNECTED              0x00004000
#define LINECALLSTATE_UNKNOWN                   0x00008000


#define LINECALLTREATMENT_SILENCE               0x00000001      // TAPI v2.0
#define LINECALLTREATMENT_RINGBACK              0x00000002      // TAPI v2.0
#define LINECALLTREATMENT_BUSY                  0x00000003      // TAPI v2.0
#define LINECALLTREATMENT_MUSIC                 0x00000004      // TAPI v2.0


#define LINECARDOPTION_PREDEFINED               0x00000001      // TAPI v1.4
#define LINECARDOPTION_HIDDEN                   0x00000002      // TAPI v1.4

#define LINECONNECTEDMODE_ACTIVE                0x00000001      // TAPI v1.4
#define LINECONNECTEDMODE_INACTIVE              0x00000002      // TAPI v1.4

#define LINECONNECTEDMODE_ACTIVEHELD            0x00000004      // TAPI v2.0
#define LINECONNECTEDMODE_INACTIVEHELD          0x00000008      // TAPI v2.0
#define LINECONNECTEDMODE_CONFIRMED             0x00000010      // TAPI v2.0


#define LINEDEVCAPFLAGS_CROSSADDRCONF           0x00000001
#define LINEDEVCAPFLAGS_HIGHLEVCOMP             0x00000002
#define LINEDEVCAPFLAGS_LOWLEVCOMP              0x00000004
#define LINEDEVCAPFLAGS_MEDIACONTROL            0x00000008
#define LINEDEVCAPFLAGS_MULTIPLEADDR            0x00000010
#define LINEDEVCAPFLAGS_CLOSEDROP               0x00000020
#define LINEDEVCAPFLAGS_DIALBILLING             0x00000040
#define LINEDEVCAPFLAGS_DIALQUIET               0x00000080
#define LINEDEVCAPFLAGS_DIALDIALTONE            0x00000100
#define LINEDEVCAPFLAGS_MSP                     0x00000200      // TAPI v3.0
#define LINEDEVCAPFLAGS_CALLHUB                 0x00000400      // TAPI v3.0
#define LINEDEVCAPFLAGS_CALLHUBTRACKING         0x00000800      // TAPI v3.0
#define LINEDEVCAPFLAGS_PRIVATEOBJECTS          0x00001000      // TAPI v3.0

#define LINEDEVSTATE_OTHER                      0x00000001
#define LINEDEVSTATE_RINGING                    0x00000002
#define LINEDEVSTATE_CONNECTED                  0x00000004
#define LINEDEVSTATE_DISCONNECTED               0x00000008
#define LINEDEVSTATE_MSGWAITON                  0x00000010
#define LINEDEVSTATE_MSGWAITOFF                 0x00000020
#define LINEDEVSTATE_INSERVICE                  0x00000040
#define LINEDEVSTATE_OUTOFSERVICE               0x00000080
#define LINEDEVSTATE_MAINTENANCE                0x00000100
#define LINEDEVSTATE_OPEN                       0x00000200
#define LINEDEVSTATE_CLOSE                      0x00000400
#define LINEDEVSTATE_NUMCALLS                   0x00000800
#define LINEDEVSTATE_NUMCOMPLETIONS             0x00001000
#define LINEDEVSTATE_TERMINALS                  0x00002000
#define LINEDEVSTATE_ROAMMODE                   0x00004000
#define LINEDEVSTATE_BATTERY                    0x00008000
#define LINEDEVSTATE_SIGNAL                     0x00010000
#define LINEDEVSTATE_DEVSPECIFIC                0x00020000
#define LINEDEVSTATE_REINIT                     0x00040000
#define LINEDEVSTATE_LOCK                       0x00080000
#define LINEDEVSTATE_CAPSCHANGE                 0x00100000      // TAPI v1.4
#define LINEDEVSTATE_CONFIGCHANGE               0x00200000      // TAPI v1.4
#define LINEDEVSTATE_TRANSLATECHANGE            0x00400000      // TAPI v1.4
#define LINEDEVSTATE_COMPLCANCEL                0x00800000      // TAPI v1.4
#define LINEDEVSTATE_REMOVED                    0x01000000      // TAPI v1.4

#define LINEDEVSTATUSFLAGS_CONNECTED            0x00000001
#define LINEDEVSTATUSFLAGS_MSGWAIT              0x00000002
#define LINEDEVSTATUSFLAGS_INSERVICE            0x00000004
#define LINEDEVSTATUSFLAGS_LOCKED               0x00000008

#define LINEDIALTONEMODE_NORMAL                 0x00000001
#define LINEDIALTONEMODE_SPECIAL                0x00000002
#define LINEDIALTONEMODE_INTERNAL               0x00000004
#define LINEDIALTONEMODE_EXTERNAL               0x00000008
#define LINEDIALTONEMODE_UNKNOWN                0x00000010
#define LINEDIALTONEMODE_UNAVAIL                0x00000020
    
#define LINEDIGITMODE_PULSE                     0x00000001
#define LINEDIGITMODE_DTMF                      0x00000002
#define LINEDIGITMODE_DTMFEND                   0x00000004
    
#define LINEDISCONNECTMODE_NORMAL               0x00000001
#define LINEDISCONNECTMODE_UNKNOWN              0x00000002
#define LINEDISCONNECTMODE_REJECT               0x00000004
#define LINEDISCONNECTMODE_PICKUP               0x00000008
#define LINEDISCONNECTMODE_FORWARDED            0x00000010
#define LINEDISCONNECTMODE_BUSY                 0x00000020
#define LINEDISCONNECTMODE_NOANSWER             0x00000040
#define LINEDISCONNECTMODE_BADADDRESS           0x00000080
#define LINEDISCONNECTMODE_UNREACHABLE          0x00000100
#define LINEDISCONNECTMODE_CONGESTION           0x00000200
#define LINEDISCONNECTMODE_INCOMPATIBLE         0x00000400
#define LINEDISCONNECTMODE_UNAVAIL              0x00000800
#define LINEDISCONNECTMODE_NODIALTONE           0x00001000      // TAPI v1.4

#define LINEDISCONNECTMODE_NUMBERCHANGED        0x00002000      // TAPI v2.0
#define LINEDISCONNECTMODE_OUTOFORDER           0x00004000      // TAPI v2.0
#define LINEDISCONNECTMODE_TEMPFAILURE          0x00008000      // TAPI v2.0
#define LINEDISCONNECTMODE_QOSUNAVAIL           0x00010000      // TAPI v2.0
#define LINEDISCONNECTMODE_BLOCKED              0x00020000      // TAPI v2.0
#define LINEDISCONNECTMODE_DONOTDISTURB         0x00040000      // TAPI v2.0
#define LINEDISCONNECTMODE_CANCELLED            0x00080000      // TAPI v2.0
#define LINEDISCONNECTMODE_DESTINATIONBARRED    0x00100000      // TAPI v2.0, WINCE 5.1 AKU 3.X
#define LINEDISCONNECTMODE_FDNRESTRICT          0x00200000      // TAPI v2.0, WINCE 5.1 AKU 3.X
#define LINEDISCONNECTMODE_SIMCALLBLOCKED       0x00400000      // WINCE ONLY; to support USIM CALL CONTROL
#define LINEDISCONNECTMODE_SIMCALLMODIFIED      0x00800000      // WINCE ONLY; to support USIM CALL CONTROL



#define LINEERR_ALLOCATED                       0x80000001
#define LINEERR_BADDEVICEID                     0x80000002
#define LINEERR_BEARERMODEUNAVAIL               0x80000003
#define LINEERR_CALLUNAVAIL                     0x80000005
#define LINEERR_COMPLETIONOVERRUN               0x80000006
#define LINEERR_CONFERENCEFULL                  0x80000007
#define LINEERR_DIALBILLING                     0x80000008
#define LINEERR_DIALDIALTONE                    0x80000009
#define LINEERR_DIALPROMPT                      0x8000000A
#define LINEERR_DIALQUIET                       0x8000000B
#define LINEERR_INCOMPATIBLEAPIVERSION          0x8000000C
#define LINEERR_INCOMPATIBLEEXTVERSION          0x8000000D
#define LINEERR_INIFILECORRUPT                  0x8000000E
#define LINEERR_INUSE                           0x8000000F
#define LINEERR_INVALADDRESS                    0x80000010
#define LINEERR_INVALADDRESSID                  0x80000011
#define LINEERR_INVALADDRESSMODE                0x80000012
#define LINEERR_INVALADDRESSSTATE               0x80000013
#define LINEERR_INVALAPPHANDLE                  0x80000014
#define LINEERR_INVALAPPNAME                    0x80000015
#define LINEERR_INVALBEARERMODE                 0x80000016
#define LINEERR_INVALCALLCOMPLMODE              0x80000017
#define LINEERR_INVALCALLHANDLE                 0x80000018
#define LINEERR_INVALCALLPARAMS                 0x80000019
#define LINEERR_INVALCALLPRIVILEGE              0x8000001A
#define LINEERR_INVALCALLSELECT                 0x8000001B
#define LINEERR_INVALCALLSTATE                  0x8000001C
#define LINEERR_INVALCALLSTATELIST              0x8000001D
#define LINEERR_INVALCARD                       0x8000001E
#define LINEERR_INVALCOMPLETIONID               0x8000001F
#define LINEERR_INVALCONFCALLHANDLE             0x80000020
#define LINEERR_INVALCONSULTCALLHANDLE          0x80000021
#define LINEERR_INVALCOUNTRYCODE                0x80000022
#define LINEERR_INVALDEVICECLASS                0x80000023
#define LINEERR_INVALDEVICEHANDLE               0x80000024
#define LINEERR_INVALDIALPARAMS                 0x80000025
#define LINEERR_INVALDIGITLIST                  0x80000026
#define LINEERR_INVALDIGITMODE                  0x80000027
#define LINEERR_INVALDIGITS                     0x80000028
#define LINEERR_INVALEXTVERSION                 0x80000029
#define LINEERR_INVALGROUPID                    0x8000002A
#define LINEERR_INVALLINEHANDLE                 0x8000002B
#define LINEERR_INVALLINESTATE                  0x8000002C
#define LINEERR_INVALLOCATION                   0x8000002D
#define LINEERR_INVALMEDIALIST                  0x8000002E
#define LINEERR_INVALMEDIAMODE                  0x8000002F
#define LINEERR_INVALMESSAGEID                  0x80000030
#define LINEERR_INVALPARAM                      0x80000032
#define LINEERR_INVALPARKID                     0x80000033
#define LINEERR_INVALPARKMODE                   0x80000034
#define LINEERR_INVALPOINTER                    0x80000035
#define LINEERR_INVALPRIVSELECT                 0x80000036
#define LINEERR_INVALRATE                       0x80000037
#define LINEERR_INVALREQUESTMODE                0x80000038
#define LINEERR_INVALTERMINALID                 0x80000039
#define LINEERR_INVALTERMINALMODE               0x8000003A
#define LINEERR_INVALTIMEOUT                    0x8000003B
#define LINEERR_INVALTONE                       0x8000003C
#define LINEERR_INVALTONELIST                   0x8000003D
#define LINEERR_INVALTONEMODE                   0x8000003E
#define LINEERR_INVALTRANSFERMODE               0x8000003F
#define LINEERR_LINEMAPPERFAILED                0x80000040
#define LINEERR_NOCONFERENCE                    0x80000041
#define LINEERR_NODEVICE                        0x80000042
#define LINEERR_NODRIVER                        0x80000043
#define LINEERR_NOMEM                           0x80000044
#define LINEERR_NOREQUEST                       0x80000045
#define LINEERR_NOTOWNER                        0x80000046
#define LINEERR_NOTREGISTERED                   0x80000047
#define LINEERR_OPERATIONFAILED                 0x80000048
#define LINEERR_OPERATIONUNAVAIL                0x80000049
#define LINEERR_RATEUNAVAIL                     0x8000004A
#define LINEERR_RESOURCEUNAVAIL                 0x8000004B
#define LINEERR_REQUESTOVERRUN                  0x8000004C
#define LINEERR_STRUCTURETOOSMALL               0x8000004D
#define LINEERR_TARGETNOTFOUND                  0x8000004E
#define LINEERR_TARGETSELF                      0x8000004F
#define LINEERR_UNINITIALIZED                   0x80000050
#define LINEERR_USERUSERINFOTOOBIG              0x80000051
#define LINEERR_REINIT                          0x80000052
#define LINEERR_ADDRESSBLOCKED                  0x80000053
#define LINEERR_BILLINGREJECTED                 0x80000054
#define LINEERR_INVALFEATURE                    0x80000055
#define LINEERR_NOMULTIPLEINSTANCE              0x80000056

#define LINEERR_INVALAGENTID                    0x80000057      // TAPI v2.0
#define LINEERR_INVALAGENTGROUP                 0x80000058      // TAPI v2.0
#define LINEERR_INVALPASSWORD                   0x80000059      // TAPI v2.0
#define LINEERR_INVALAGENTSTATE                 0x8000005A      // TAPI v2.0
#define LINEERR_INVALAGENTACTIVITY              0x8000005B      // TAPI v2.0
#define LINEERR_DIALVOICEDETECT                 0x8000005C      // TAPI v2.0


#define LINEFEATURE_DEVSPECIFIC                 0x00000001
#define LINEFEATURE_DEVSPECIFICFEAT             0x00000002
#define LINEFEATURE_FORWARD                     0x00000004
#define LINEFEATURE_MAKECALL                    0x00000008
#define LINEFEATURE_SETMEDIACONTROL             0x00000010
#define LINEFEATURE_SETTERMINAL                 0x00000020

#define LINEFEATURE_SETDEVSTATUS                0x00000040      // TAPI v2.0
#define LINEFEATURE_FORWARDFWD                  0x00000080      // TAPI v2.0
#define LINEFEATURE_FORWARDDND                  0x00000100      // TAPI v2.0


#define LINEFORWARDMODE_UNCOND                  0x00000001
#define LINEFORWARDMODE_UNCONDINTERNAL          0x00000002
#define LINEFORWARDMODE_UNCONDEXTERNAL          0x00000004
#define LINEFORWARDMODE_UNCONDSPECIFIC          0x00000008
#define LINEFORWARDMODE_BUSY                    0x00000010
#define LINEFORWARDMODE_BUSYINTERNAL            0x00000020
#define LINEFORWARDMODE_BUSYEXTERNAL            0x00000040
#define LINEFORWARDMODE_BUSYSPECIFIC            0x00000080
#define LINEFORWARDMODE_NOANSW                  0x00000100
#define LINEFORWARDMODE_NOANSWINTERNAL          0x00000200
#define LINEFORWARDMODE_NOANSWEXTERNAL          0x00000400
#define LINEFORWARDMODE_NOANSWSPECIFIC          0x00000800
#define LINEFORWARDMODE_BUSYNA                  0x00001000
#define LINEFORWARDMODE_BUSYNAINTERNAL          0x00002000
#define LINEFORWARDMODE_BUSYNAEXTERNAL          0x00004000
#define LINEFORWARDMODE_BUSYNASPECIFIC          0x00008000
#define LINEFORWARDMODE_UNKNOWN                 0x00010000      // TAPI v1.4
#define LINEFORWARDMODE_UNAVAIL                 0x00020000      // TAPI v1.4

#define LINEGATHERTERM_BUFFERFULL               0x00000001
#define LINEGATHERTERM_TERMDIGIT                0x00000002
#define LINEGATHERTERM_FIRSTTIMEOUT             0x00000004
#define LINEGATHERTERM_INTERTIMEOUT             0x00000008
#define LINEGATHERTERM_CANCEL                   0x00000010

#define LINEGENERATETERM_DONE                   0x00000001
#define LINEGENERATETERM_CANCEL                 0x00000002

//
// These constants are mutually exclusive - there's no way to specify more
// than one at a time (and it doesn't make sense, either) so they're
// ordinal rather than bits.
//
#define LINEINITIALIZEEXOPTION_USEHIDDENWINDOW      0x00000001  // TAPI v2.0
#define LINEINITIALIZEEXOPTION_USEEVENT             0x00000002  // TAPI v2.0
#define LINEINITIALIZEEXOPTION_USECOMPLETIONPORT    0x00000003  // TAPI v2.0

#define LINELOCATIONOPTION_PULSEDIAL            0x00000001      // TAPI v1.4

#define LINEMAPPER                              0xFFFFFFFF

#define LINEMEDIACONTROL_NONE                   0x00000001
#define LINEMEDIACONTROL_START                  0x00000002
#define LINEMEDIACONTROL_RESET                  0x00000004
#define LINEMEDIACONTROL_PAUSE                  0x00000008
#define LINEMEDIACONTROL_RESUME                 0x00000010
#define LINEMEDIACONTROL_RATEUP                 0x00000020
#define LINEMEDIACONTROL_RATEDOWN               0x00000040
#define LINEMEDIACONTROL_RATENORMAL             0x00000080
#define LINEMEDIACONTROL_VOLUMEUP               0x00000100
#define LINEMEDIACONTROL_VOLUMEDOWN             0x00000200
#define LINEMEDIACONTROL_VOLUMENORMAL           0x00000400

#define LINEMEDIAMODE_UNKNOWN                   0x00000002
#define LINEMEDIAMODE_INTERACTIVEVOICE          0x00000004
#define LINEMEDIAMODE_AUTOMATEDVOICE            0x00000008
#define LINEMEDIAMODE_DATAMODEM                 0x00000010
#define LINEMEDIAMODE_G3FAX                     0x00000020
#define LINEMEDIAMODE_TDD                       0x00000040
#define LINEMEDIAMODE_G4FAX                     0x00000080
#define LINEMEDIAMODE_DIGITALDATA               0x00000100
#define LINEMEDIAMODE_TELETEX                   0x00000200
#define LINEMEDIAMODE_VIDEOTEX                  0x00000400
#define LINEMEDIAMODE_TELEX                     0x00000800
#define LINEMEDIAMODE_MIXED                     0x00001000
#define LINEMEDIAMODE_ADSI                      0x00002000
#define LINEMEDIAMODE_VOICEVIEW                 0x00004000      // TAPI v1.4
#define LINEMEDIAMODE_VIDEO                     0x00008000      // TAPI v2.1
#define LINEMEDIAMODE_PTT                       0x00010000
#define LINEMEDIAMODE_VT                        0x00020000
#define LAST_LINEMEDIAMODE                      0x00020000

#define LINEOFFERINGMODE_ACTIVE                 0x00000001      // TAPI v1.4
#define LINEOFFERINGMODE_INACTIVE               0x00000002      // TAPI v1.4

#define LINEOPENOPTION_SINGLEADDRESS            0x80000000      // TAPI v2.0
#define LINEOPENOPTION_PROXY                    0x40000000      // TAPI v2.0


#define LINEPARKMODE_DIRECTED                   0x00000001
#define LINEPARKMODE_NONDIRECTED                0x00000002

#define LINEPROXYREQUEST_SETAGENTGROUP          0x00000001      // TAPI v2.0
#define LINEPROXYREQUEST_SETAGENTSTATE          0x00000002      // TAPI v2.0
#define LINEPROXYREQUEST_SETAGENTACTIVITY       0x00000003      // TAPI v2.0
#define LINEPROXYREQUEST_GETAGENTCAPS           0x00000004      // TAPI v2.0
#define LINEPROXYREQUEST_GETAGENTSTATUS         0x00000005      // TAPI v2.0
#define LINEPROXYREQUEST_AGENTSPECIFIC          0x00000006      // TAPI v2.0
#define LINEPROXYREQUEST_GETAGENTACTIVITYLIST   0x00000007      // TAPI v2.0
#define LINEPROXYREQUEST_GETAGENTGROUPLIST      0x00000008      // TAPI v2.0

#define LINEREMOVEFROMCONF_NONE                 0x00000001
#define LINEREMOVEFROMCONF_LAST                 0x00000002
#define LINEREMOVEFROMCONF_ANY                  0x00000003

#define LINEREQUESTMODE_MAKECALL                0x00000001
#define LINEREQUESTMODE_MEDIACALL               0x00000002
#define LINEREQUESTMODE_DROP                    0x00000004
#define LAST_LINEREQUESTMODE                    LINEREQUESTMODE_MEDIACALL

#define LINEROAMMODE_UNKNOWN                    0x00000001
#define LINEROAMMODE_UNAVAIL                    0x00000002
#define LINEROAMMODE_HOME                       0x00000004
#define LINEROAMMODE_ROAMA                      0x00000008
#define LINEROAMMODE_ROAMB                      0x00000010

#define LINESPECIALINFO_NOCIRCUIT               0x00000001
#define LINESPECIALINFO_CUSTIRREG               0x00000002
#define LINESPECIALINFO_REORDER                 0x00000004
#define LINESPECIALINFO_UNKNOWN                 0x00000008
#define LINESPECIALINFO_UNAVAIL                 0x00000010

#define LINETERMDEV_PHONE                       0x00000001
#define LINETERMDEV_HEADSET                     0x00000002
#define LINETERMDEV_SPEAKER                     0x00000004

#define LINETERMMODE_BUTTONS                    0x00000001
#define LINETERMMODE_LAMPS                      0x00000002
#define LINETERMMODE_DISPLAY                    0x00000004
#define LINETERMMODE_RINGER                     0x00000008
#define LINETERMMODE_HOOKSWITCH                 0x00000010
#define LINETERMMODE_MEDIATOLINE                0x00000020
#define LINETERMMODE_MEDIAFROMLINE              0x00000040
#define LINETERMMODE_MEDIABIDIRECT              0x00000080

#define LINETERMSHARING_PRIVATE                 0x00000001
#define LINETERMSHARING_SHAREDEXCL              0x00000002
#define LINETERMSHARING_SHAREDCONF              0x00000004

#define LINETOLLLISTOPTION_ADD                  0x00000001
#define LINETOLLLISTOPTION_REMOVE               0x00000002

#define LINETONEMODE_CUSTOM                     0x00000001
#define LINETONEMODE_RINGBACK                   0x00000002
#define LINETONEMODE_BUSY                       0x00000004
#define LINETONEMODE_BEEP                       0x00000008
#define LINETONEMODE_BILLING                    0x00000010

#define LINETRANSFERMODE_TRANSFER               0x00000001
#define LINETRANSFERMODE_CONFERENCE             0x00000002

#define LINETRANSLATEOPTION_CARDOVERRIDE        0x00000001
#define LINETRANSLATEOPTION_CANCELCALLWAITING   0x00000002      // TAPI v1.4
#define LINETRANSLATEOPTION_FORCELOCAL          0x00000004      // TAPI v1.4
#define LINETRANSLATEOPTION_FORCELD             0x00000008      // TAPI v1.4

#define LINETRANSLATERESULT_CANONICAL           0x00000001
#define LINETRANSLATERESULT_INTERNATIONAL       0x00000002
#define LINETRANSLATERESULT_LONGDISTANCE        0x00000004
#define LINETRANSLATERESULT_LOCAL               0x00000008
#define LINETRANSLATERESULT_INTOLLLIST          0x00000010
#define LINETRANSLATERESULT_NOTINTOLLLIST       0x00000020
#define LINETRANSLATERESULT_DIALBILLING         0x00000040
#define LINETRANSLATERESULT_DIALQUIET           0x00000080
#define LINETRANSLATERESULT_DIALDIALTONE        0x00000100
#define LINETRANSLATERESULT_DIALPROMPT          0x00000200

#define LINETRANSLATERESULT_VOICEDETECT         0x00000400      // TAPI v2.0


#define PHONEBUTTONFUNCTION_UNKNOWN             0x00000000
#define PHONEBUTTONFUNCTION_CONFERENCE          0x00000001
#define PHONEBUTTONFUNCTION_TRANSFER            0x00000002
#define PHONEBUTTONFUNCTION_DROP                0x00000003
#define PHONEBUTTONFUNCTION_HOLD                0x00000004
#define PHONEBUTTONFUNCTION_RECALL              0x00000005
#define PHONEBUTTONFUNCTION_DISCONNECT          0x00000006
#define PHONEBUTTONFUNCTION_CONNECT             0x00000007
#define PHONEBUTTONFUNCTION_MSGWAITON           0x00000008
#define PHONEBUTTONFUNCTION_MSGWAITOFF          0x00000009
#define PHONEBUTTONFUNCTION_SELECTRING          0x0000000A
#define PHONEBUTTONFUNCTION_ABBREVDIAL          0x0000000B
#define PHONEBUTTONFUNCTION_FORWARD             0x0000000C
#define PHONEBUTTONFUNCTION_PICKUP              0x0000000D
#define PHONEBUTTONFUNCTION_RINGAGAIN           0x0000000E
#define PHONEBUTTONFUNCTION_PARK                0x0000000F
#define PHONEBUTTONFUNCTION_REJECT              0x00000010
#define PHONEBUTTONFUNCTION_REDIRECT            0x00000011
#define PHONEBUTTONFUNCTION_MUTE                0x00000012
#define PHONEBUTTONFUNCTION_VOLUMEUP            0x00000013
#define PHONEBUTTONFUNCTION_VOLUMEDOWN          0x00000014
#define PHONEBUTTONFUNCTION_SPEAKERON           0x00000015
#define PHONEBUTTONFUNCTION_SPEAKEROFF          0x00000016
#define PHONEBUTTONFUNCTION_FLASH               0x00000017
#define PHONEBUTTONFUNCTION_DATAON              0x00000018
#define PHONEBUTTONFUNCTION_DATAOFF             0x00000019
#define PHONEBUTTONFUNCTION_DONOTDISTURB        0x0000001A
#define PHONEBUTTONFUNCTION_INTERCOM            0x0000001B
#define PHONEBUTTONFUNCTION_BRIDGEDAPP          0x0000001C
#define PHONEBUTTONFUNCTION_BUSY                0x0000001D
#define PHONEBUTTONFUNCTION_CALLAPP             0x0000001E
#define PHONEBUTTONFUNCTION_DATETIME            0x0000001F
#define PHONEBUTTONFUNCTION_DIRECTORY           0x00000020
#define PHONEBUTTONFUNCTION_COVER               0x00000021
#define PHONEBUTTONFUNCTION_CALLID              0x00000022
#define PHONEBUTTONFUNCTION_LASTNUM             0x00000023
#define PHONEBUTTONFUNCTION_NIGHTSRV            0x00000024
#define PHONEBUTTONFUNCTION_SENDCALLS           0x00000025
#define PHONEBUTTONFUNCTION_MSGINDICATOR        0x00000026
#define PHONEBUTTONFUNCTION_REPDIAL             0x00000027
#define PHONEBUTTONFUNCTION_SETREPDIAL          0x00000028
#define PHONEBUTTONFUNCTION_SYSTEMSPEED         0x00000029
#define PHONEBUTTONFUNCTION_STATIONSPEED        0x0000002A
#define PHONEBUTTONFUNCTION_CAMPON              0x0000002B
#define PHONEBUTTONFUNCTION_SAVEREPEAT          0x0000002C
#define PHONEBUTTONFUNCTION_QUEUECALL           0x0000002D
#define PHONEBUTTONFUNCTION_NONE                0x0000002E

#define PHONEBUTTONMODE_DUMMY                   0x00000001
#define PHONEBUTTONMODE_CALL                    0x00000002
#define PHONEBUTTONMODE_FEATURE                 0x00000004
#define PHONEBUTTONMODE_KEYPAD                  0x00000008
#define PHONEBUTTONMODE_LOCAL                   0x00000010
#define PHONEBUTTONMODE_DISPLAY                 0x00000020

#define PHONEBUTTONSTATE_UP                     0x00000001
#define PHONEBUTTONSTATE_DOWN                   0x00000002
#define PHONEBUTTONSTATE_UNKNOWN                0x00000004      // TAPI v1.4
#define PHONEBUTTONSTATE_UNAVAIL                0x00000008      // TAPI v1.4

#define PHONEERR_ALLOCATED                      0x90000001
#define PHONEERR_BADDEVICEID                    0x90000002
#define PHONEERR_INCOMPATIBLEAPIVERSION         0x90000003
#define PHONEERR_INCOMPATIBLEEXTVERSION         0x90000004
#define PHONEERR_INIFILECORRUPT                 0x90000005
#define PHONEERR_INUSE                          0x90000006
#define PHONEERR_INVALAPPHANDLE                 0x90000007
#define PHONEERR_INVALAPPNAME                   0x90000008
#define PHONEERR_INVALBUTTONLAMPID              0x90000009
#define PHONEERR_INVALBUTTONMODE                0x9000000A
#define PHONEERR_INVALBUTTONSTATE               0x9000000B
#define PHONEERR_INVALDATAID                    0x9000000C
#define PHONEERR_INVALDEVICECLASS               0x9000000D
#define PHONEERR_INVALEXTVERSION                0x9000000E
#define PHONEERR_INVALHOOKSWITCHDEV             0x9000000F
#define PHONEERR_INVALHOOKSWITCHMODE            0x90000010
#define PHONEERR_INVALLAMPMODE                  0x90000011
#define PHONEERR_INVALPARAM                     0x90000012
#define PHONEERR_INVALPHONEHANDLE               0x90000013
#define PHONEERR_INVALPHONESTATE                0x90000014
#define PHONEERR_INVALPOINTER                   0x90000015
#define PHONEERR_INVALPRIVILEGE                 0x90000016
#define PHONEERR_INVALRINGMODE                  0x90000017
#define PHONEERR_NODEVICE                       0x90000018
#define PHONEERR_NODRIVER                       0x90000019
#define PHONEERR_NOMEM                          0x9000001A
#define PHONEERR_NOTOWNER                       0x9000001B
#define PHONEERR_OPERATIONFAILED                0x9000001C
#define PHONEERR_OPERATIONUNAVAIL               0x9000001D
#define PHONEERR_RESOURCEUNAVAIL                0x9000001F
#define PHONEERR_REQUESTOVERRUN                 0x90000020
#define PHONEERR_STRUCTURETOOSMALL              0x90000021
#define PHONEERR_UNINITIALIZED                  0x90000022
#define PHONEERR_REINIT                         0x90000023


#define PHONEFEATURE_GETBUTTONINFO              0x00000001      // TAPI v2.0
#define PHONEFEATURE_GETDATA                    0x00000002      // TAPI v2.0
#define PHONEFEATURE_GETDISPLAY                 0x00000004      // TAPI v2.0
#define PHONEFEATURE_GETGAINHANDSET             0x00000008      // TAPI v2.0
#define PHONEFEATURE_GETGAINSPEAKER             0x00000010      // TAPI v2.0
#define PHONEFEATURE_GETGAINHEADSET             0x00000020      // TAPI v2.0
#define PHONEFEATURE_GETHOOKSWITCHHANDSET       0x00000040      // TAPI v2.0
#define PHONEFEATURE_GETHOOKSWITCHSPEAKER       0x00000080      // TAPI v2.0
#define PHONEFEATURE_GETHOOKSWITCHHEADSET       0x00000100      // TAPI v2.0
#define PHONEFEATURE_GETLAMP                    0x00000200      // TAPI v2.0
#define PHONEFEATURE_GETRING                    0x00000400      // TAPI v2.0
#define PHONEFEATURE_GETVOLUMEHANDSET           0x00000800      // TAPI v2.0
#define PHONEFEATURE_GETVOLUMESPEAKER           0x00001000      // TAPI v2.0
#define PHONEFEATURE_GETVOLUMEHEADSET           0x00002000      // TAPI v2.0
#define PHONEFEATURE_SETBUTTONINFO              0x00004000      // TAPI v2.0
#define PHONEFEATURE_SETDATA                    0x00008000      // TAPI v2.0
#define PHONEFEATURE_SETDISPLAY                 0x00010000      // TAPI v2.0
#define PHONEFEATURE_SETGAINHANDSET             0x00020000      // TAPI v2.0
#define PHONEFEATURE_SETGAINSPEAKER             0x00040000      // TAPI v2.0
#define PHONEFEATURE_SETGAINHEADSET             0x00080000      // TAPI v2.0
#define PHONEFEATURE_SETHOOKSWITCHHANDSET       0x00100000      // TAPI v2.0
#define PHONEFEATURE_SETHOOKSWITCHSPEAKER       0x00200000      // TAPI v2.0
#define PHONEFEATURE_SETHOOKSWITCHHEADSET       0x00400000      // TAPI v2.0
#define PHONEFEATURE_SETLAMP                    0x00800000      // TAPI v2.0
#define PHONEFEATURE_SETRING                    0x01000000      // TAPI v2.0
#define PHONEFEATURE_SETVOLUMEHANDSET           0x02000000      // TAPI v2.0
#define PHONEFEATURE_SETVOLUMESPEAKER           0x04000000      // TAPI v2.0
#define PHONEFEATURE_SETVOLUMEHEADSET           0x08000000      // TAPI v2.0


#define PHONEHOOKSWITCHDEV_HANDSET              0x00000001
#define PHONEHOOKSWITCHDEV_SPEAKER              0x00000002
#define PHONEHOOKSWITCHDEV_HEADSET              0x00000004

#define PHONEHOOKSWITCHMODE_ONHOOK              0x00000001
#define PHONEHOOKSWITCHMODE_MIC                 0x00000002
#define PHONEHOOKSWITCHMODE_SPEAKER             0x00000004
#define PHONEHOOKSWITCHMODE_MICSPEAKER          0x00000008
#define PHONEHOOKSWITCHMODE_UNKNOWN             0x00000010


#define PHONEINITIALIZEEXOPTION_USEHIDDENWINDOW     0x00000001  // TAPI v2.0
#define PHONEINITIALIZEEXOPTION_USEEVENT            0x00000002  // TAPI v2.0
#define PHONEINITIALIZEEXOPTION_USECOMPLETIONPORT   0x00000003  // TAPI v2.0


#define PHONELAMPMODE_DUMMY                     0x00000001
#define PHONELAMPMODE_OFF                       0x00000002
#define PHONELAMPMODE_STEADY                    0x00000004
#define PHONELAMPMODE_WINK                      0x00000008
#define PHONELAMPMODE_FLASH                     0x00000010
#define PHONELAMPMODE_FLUTTER                   0x00000020
#define PHONELAMPMODE_BROKENFLUTTER             0x00000040
#define PHONELAMPMODE_UNKNOWN                   0x00000080

#define PHONEPRIVILEGE_MONITOR                  0x00000001
#define PHONEPRIVILEGE_OWNER                    0x00000002

#define PHONESTATE_OTHER                        0x00000001
#define PHONESTATE_CONNECTED                    0x00000002
#define PHONESTATE_DISCONNECTED                 0x00000004
#define PHONESTATE_OWNER                        0x00000008
#define PHONESTATE_MONITORS                     0x00000010
#define PHONESTATE_DISPLAY                      0x00000020
#define PHONESTATE_LAMP                         0x00000040
#define PHONESTATE_RINGMODE                     0x00000080
#define PHONESTATE_RINGVOLUME                   0x00000100
#define PHONESTATE_HANDSETHOOKSWITCH            0x00000200
#define PHONESTATE_HANDSETVOLUME                0x00000400
#define PHONESTATE_HANDSETGAIN                  0x00000800
#define PHONESTATE_SPEAKERHOOKSWITCH            0x00001000
#define PHONESTATE_SPEAKERVOLUME                0x00002000
#define PHONESTATE_SPEAKERGAIN                  0x00004000
#define PHONESTATE_HEADSETHOOKSWITCH            0x00008000
#define PHONESTATE_HEADSETVOLUME                0x00010000
#define PHONESTATE_HEADSETGAIN                  0x00020000
#define PHONESTATE_SUSPEND                      0x00040000
#define PHONESTATE_RESUME                       0x00080000
#define PHONESTATE_DEVSPECIFIC                  0x00100000
#define PHONESTATE_REINIT                       0x00200000
#define PHONESTATE_CAPSCHANGE                   0x00400000      // TAPI v1.4
#define PHONESTATE_REMOVED                      0x00800000      // TAPI v1.4

#define PHONESTATUSFLAGS_CONNECTED              0x00000001
#define PHONESTATUSFLAGS_SUSPENDED              0x00000002

#define STRINGFORMAT_ASCII                      0x00000001
#define STRINGFORMAT_DBCS                       0x00000002
#define STRINGFORMAT_UNICODE                    0x00000003
#define STRINGFORMAT_BINARY                     0x00000004

#define TAPI_REPLY                              WM_USER + 99

#define TAPIERR_CONNECTED                       0L
#define TAPIERR_DROPPED                         -1L
#define TAPIERR_NOREQUESTRECIPIENT              -2L
#define TAPIERR_REQUESTQUEUEFULL                -3L
#define TAPIERR_INVALDESTADDRESS                -4L
#define TAPIERR_INVALWINDOWHANDLE               -5L
#define TAPIERR_INVALDEVICECLASS                -6L
#define TAPIERR_INVALDEVICEID                   -7L
#define TAPIERR_DEVICECLASSUNAVAIL              -8L
#define TAPIERR_DEVICEIDUNAVAIL                 -9L
#define TAPIERR_DEVICEINUSE                     -10L
#define TAPIERR_DESTBUSY                        -11L
#define TAPIERR_DESTNOANSWER                    -12L
#define TAPIERR_DESTUNAVAIL                     -13L
#define TAPIERR_UNKNOWNWINHANDLE                -14L
#define TAPIERR_UNKNOWNREQUESTID                -15L
#define TAPIERR_REQUESTFAILED                   -16L
#define TAPIERR_REQUESTCANCELLED                -17L
#define TAPIERR_INVALPOINTER                    -18L


#define TAPIMAXDESTADDRESSSIZE                  80L
#define TAPIMAXAPPNAMESIZE                      40L
#define TAPIMAXCALLEDPARTYSIZE                  40L
#define TAPIMAXCOMMENTSIZE                      80L
#define TAPIMAXDEVICECLASSSIZE                  40L
#define TAPIMAXDEVICEIDSIZE                     40L


#ifndef GUID_DEFINED
#define GUID_DEFINED
typedef struct _GUID
{
    unsigned long  Data1;
    unsigned short Data2;
    unsigned short Data3;
    unsigned char  Data4[8];
} GUID;

#endif /* GUID_DEFINED */

#ifndef __LPGUID_DEFINED__
#define __LPGUID_DEFINED__
typedef GUID *LPGUID;
#endif


typedef struct lineaddresscaps_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwLineDeviceID;
    DWORD       dwAddressSize;
    DWORD       dwAddressOffset;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;
    DWORD       dwAddressSharing;
    DWORD       dwAddressStates;
    DWORD       dwCallInfoStates;
    DWORD       dwCallerIDFlags;
    DWORD       dwCalledIDFlags;
    DWORD       dwConnectedIDFlags;
    DWORD       dwRedirectionIDFlags;
    DWORD       dwRedirectingIDFlags;
    DWORD       dwCallStates;
    DWORD       dwDialToneModes;
    DWORD       dwBusyModes;
    DWORD       dwSpecialInfo;
    DWORD       dwDisconnectModes;
    DWORD       dwMaxNumActiveCalls;
    DWORD       dwMaxNumOnHoldCalls;
    DWORD       dwMaxNumOnHoldPendingCalls;
    DWORD       dwMaxNumConference;
    DWORD       dwMaxNumTransConf;
    DWORD       dwAddrCapFlags;
    DWORD       dwCallFeatures;
    DWORD       dwRemoveFromConfCaps;
    DWORD       dwRemoveFromConfState;
    DWORD       dwTransferModes;
    DWORD       dwParkModes;
    DWORD       dwForwardModes;
    DWORD       dwMaxForwardEntries;
    DWORD       dwMaxSpecificEntries;
    DWORD       dwMinFwdNumRings;
    DWORD       dwMaxFwdNumRings;
    DWORD       dwMaxCallCompletions;
    DWORD       dwCallCompletionConds;
    DWORD       dwCallCompletionModes;
    DWORD       dwNumCompletionMessages;
    DWORD       dwCompletionMsgTextEntrySize;
    DWORD       dwCompletionMsgTextSize;
    DWORD       dwCompletionMsgTextOffset;

    DWORD       dwAddressFeatures;                              // TAPI v1.4

    DWORD       dwPredictiveAutoTransferStates;                 // TAPI v2.0
    DWORD       dwNumCallTreatments;                            // TAPI v2.0
    DWORD       dwCallTreatmentListSize;                        // TAPI v2.0
    DWORD       dwCallTreatmentListOffset;                      // TAPI v2.0
    DWORD       dwDeviceClassesSize;                            // TAPI v2.0
    DWORD       dwDeviceClassesOffset;                          // TAPI v2.0
    DWORD       dwMaxCallDataSize;                              // TAPI v2.0
    DWORD       dwCallFeatures2;                                // TAPI v2.0
    DWORD       dwMaxNoAnswerTimeout;                           // TAPI v2.0
    DWORD       dwConnectedModes;                               // TAPI v2.0
    DWORD       dwOfferingModes;                                // TAPI v2.0
    DWORD       dwAvailableMediaModes;                          // TAPI v2.0

} LINEADDRESSCAPS, FAR *LPLINEADDRESSCAPS;

typedef struct lineaddressstatus_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwNumInUse;
    DWORD       dwNumActiveCalls;
    DWORD       dwNumOnHoldCalls;
    DWORD       dwNumOnHoldPendCalls;
    DWORD       dwAddressFeatures;
    DWORD       dwNumRingsNoAnswer;
    DWORD       dwForwardNumEntries;
    DWORD       dwForwardSize;
    DWORD       dwForwardOffset;
    DWORD       dwTerminalModesSize;
    DWORD       dwTerminalModesOffset;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;

} LINEADDRESSSTATUS, FAR *LPLINEADDRESSSTATUS;

typedef struct linedialparams_tag
{
    DWORD       dwDialPause;
    DWORD       dwDialSpeed;
    DWORD       dwDigitDuration;
    DWORD       dwWaitForDialtone;

} LINEDIALPARAMS, FAR *LPLINEDIALPARAMS;

typedef struct linecallinfo_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    HLINE       hLine;
    DWORD       dwLineDeviceID;
    DWORD       dwAddressID;
    DWORD       dwBearerMode;
    DWORD       dwRate;
    DWORD       dwMediaMode;
    DWORD       dwAppSpecific;
    DWORD       dwCallID;
    DWORD       dwRelatedCallID;
    DWORD       dwCallParamFlags;
    DWORD       dwCallStates;
    DWORD       dwMonitorDigitModes;
    DWORD       dwMonitorMediaModes;
    LINEDIALPARAMS  DialParams;
    DWORD       dwOrigin;
    DWORD       dwReason;
    DWORD       dwCompletionID;
    DWORD       dwNumOwners;
    DWORD       dwNumMonitors;
    DWORD       dwCountryCode;
    DWORD       dwTrunk;
    DWORD       dwCallerIDFlags;
    DWORD       dwCallerIDSize;
    DWORD       dwCallerIDOffset;
    DWORD       dwCallerIDNameSize;
    DWORD       dwCallerIDNameOffset;
    DWORD       dwCalledIDFlags;
    DWORD       dwCalledIDSize;
    DWORD       dwCalledIDOffset;
    DWORD       dwCalledIDNameSize;
    DWORD       dwCalledIDNameOffset;
    DWORD       dwConnectedIDFlags;
    DWORD       dwConnectedIDSize;
    DWORD       dwConnectedIDOffset;
    DWORD       dwConnectedIDNameSize;
    DWORD       dwConnectedIDNameOffset;
    DWORD       dwRedirectionIDFlags;
    DWORD       dwRedirectionIDSize;
    DWORD       dwRedirectionIDOffset;
    DWORD       dwRedirectionIDNameSize;
    DWORD       dwRedirectionIDNameOffset;
    DWORD       dwRedirectingIDFlags;
    DWORD       dwRedirectingIDSize;
    DWORD       dwRedirectingIDOffset;
    DWORD       dwRedirectingIDNameSize;
    DWORD       dwRedirectingIDNameOffset;
    DWORD       dwAppNameSize;
    DWORD       dwAppNameOffset;
    DWORD       dwDisplayableAddressSize;
    DWORD       dwDisplayableAddressOffset;
    DWORD       dwCalledPartySize;
    DWORD       dwCalledPartyOffset;
    DWORD       dwCommentSize;
    DWORD       dwCommentOffset;
    DWORD       dwDisplaySize;
    DWORD       dwDisplayOffset;
    DWORD       dwUserUserInfoSize;
    DWORD       dwUserUserInfoOffset;
    DWORD       dwHighLevelCompSize;
    DWORD       dwHighLevelCompOffset;
    DWORD       dwLowLevelCompSize;
    DWORD       dwLowLevelCompOffset;
    DWORD       dwChargingInfoSize;
    DWORD       dwChargingInfoOffset;
    DWORD       dwTerminalModesSize;
    DWORD       dwTerminalModesOffset;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;
    DWORD       dwCallTreatment;                                // TAPI v2.0
    DWORD       dwCallDataSize;                                 // TAPI v2.0
    DWORD       dwCallDataOffset;                               // TAPI v2.0
    DWORD       dwSendingFlowspecSize;                          // TAPI v2.0
    DWORD       dwSendingFlowspecOffset;                        // TAPI v2.0
    DWORD       dwReceivingFlowspecSize;                        // TAPI v2.0
    DWORD       dwReceivingFlowspecOffset;                      // TAPI v2.0
    DWORD       dwAddressType;                                  // TAPI v3.0
    DWORD       dwCallModificationType;                         // WINCE ONLY; to support USIM CALL CONTROL
    DWORD       dwCallType;                                     // WINCE ONLY; to support USIM CALL CONTROL
    DWORD       dwModifiedIDSize;                               // WINCE ONLY; to support USIM CALL CONTROL 
    DWORD       dwModifiedIDOffset;                             // WINCE ONLY; to support USIM CALL CONTROL
    DWORD       dwAlphaIdentifierType;                          // WINCE ONLY; to support USIM CALL CONTROL
    DWORD       dwAlphaIdentifierInfoSize;                      // WINCE ONLY; to support USIM CALL CONTROL
    DWORD       dwAlphaIdentifierInfoOffset;                    // WINCE ONLY; to support USIM CALL CONTROL
} LINECALLINFO, FAR *LPLINECALLINFO;

typedef struct linecalllist_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwCallsNumEntries;
    DWORD       dwCallsSize;
    DWORD       dwCallsOffset;

} LINECALLLIST, FAR *LPLINECALLLIST;

typedef struct linecallparams_tag               // Defaults:
{
    DWORD       dwTotalSize;                    // ---------
    DWORD       dwBearerMode;                   // voice
    DWORD       dwMinRate;                      // (3.1kHz)
    DWORD       dwMaxRate;                      // (3.1kHz)
    DWORD       dwMediaMode;                    // interactiveVoice
    DWORD       dwCallParamFlags;               // 0
    DWORD       dwAddressMode;                  // addressID
    DWORD       dwAddressID;                    // (any available)
    LINEDIALPARAMS  DialParams;                 // (0, 0, 0, 0)
    DWORD       dwOrigAddressSize;              // 0
    DWORD       dwOrigAddressOffset;
    DWORD       dwDisplayableAddressSize;
    DWORD       dwDisplayableAddressOffset;
    DWORD       dwCalledPartySize;              // 0
    DWORD       dwCalledPartyOffset;
    DWORD       dwCommentSize;                  // 0
    DWORD       dwCommentOffset;
    DWORD       dwUserUserInfoSize;             // 0
    DWORD       dwUserUserInfoOffset;
    DWORD       dwHighLevelCompSize;            // 0
    DWORD       dwHighLevelCompOffset;
    DWORD       dwLowLevelCompSize;             // 0
    DWORD       dwLowLevelCompOffset;
    DWORD       dwDevSpecificSize;              // 0
    DWORD       dwDevSpecificOffset;
    DWORD       dwPredictiveAutoTransferStates;                 // TAPI v2.0
    DWORD       dwTargetAddressSize;                            // TAPI v2.0
    DWORD       dwTargetAddressOffset;                          // TAPI v2.0
    DWORD       dwSendingFlowspecSize;                          // TAPI v2.0
    DWORD       dwSendingFlowspecOffset;                        // TAPI v2.0
    DWORD       dwReceivingFlowspecSize;                        // TAPI v2.0
    DWORD       dwReceivingFlowspecOffset;                      // TAPI v2.0
    DWORD       dwDeviceClassSize;                              // TAPI v2.0
    DWORD       dwDeviceClassOffset;                            // TAPI v2.0
    DWORD       dwDeviceConfigSize;                             // TAPI v2.0
    DWORD       dwDeviceConfigOffset;                           // TAPI v2.0
    DWORD       dwCallDataSize;                                 // TAPI v2.0
    DWORD       dwCallDataOffset;                               // TAPI v2.0
    DWORD       dwNoAnswerTimeout;                              // TAPI v2.0
    DWORD       dwCallingPartyIDSize;                           // TAPI v2.0
    DWORD       dwCallingPartyIDOffset;                         // TAPI v2.0
    DWORD       dwAddressType;                                  // TAPI v3.0
} LINECALLPARAMS, FAR *LPLINECALLPARAMS;

typedef struct linecallstatus_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwCallState;
    DWORD       dwCallStateMode;
    DWORD       dwCallPrivilege;
    DWORD       dwCallFeatures;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;

    DWORD       dwCallFeatures2;                                // TAPI v2.0
    SYSTEMTIME  tStateEntryTime;                                // TAPI v2.0
} LINECALLSTATUS, FAR *LPLINECALLSTATUS;


typedef struct linecalltreatmententry_tag
{
    DWORD       dwCallTreatmentID;                              // TAPI v2.0
    DWORD       dwCallTreatmentNameSize;                        // TAPI v2.0
    DWORD       dwCallTreatmentNameOffset;                      // TAPI v2.0

} LINECALLTREATMENTENTRY, FAR *LPLINECALLTREATMENTENTRY;


typedef struct linecardentry_tag
{
    DWORD       dwPermanentCardID;
    DWORD       dwCardNameSize;
    DWORD       dwCardNameOffset;
    DWORD       dwCardNumberDigits;                             // TAPI v1.4
    DWORD       dwSameAreaRuleSize;                             // TAPI v1.4
    DWORD       dwSameAreaRuleOffset;                           // TAPI v1.4
    DWORD       dwLongDistanceRuleSize;                         // TAPI v1.4
    DWORD       dwLongDistanceRuleOffset;                       // TAPI v1.4
    DWORD       dwInternationalRuleSize;                        // TAPI v1.4
    DWORD       dwInternationalRuleOffset;                      // TAPI v1.4
    DWORD       dwOptions;                                      // TAPI v1.4

} LINECARDENTRY, FAR *LPLINECARDENTRY;

typedef struct linecountryentry_tag
{
    DWORD       dwCountryID;                                    // TAPI v1.4
    DWORD       dwCountryCode;                                  // TAPI v1.4
    DWORD       dwNextCountryID;                                // TAPI v1.4
    DWORD       dwCountryNameSize;                              // TAPI v1.4
    DWORD       dwCountryNameOffset;                            // TAPI v1.4
    DWORD       dwSameAreaRuleSize;                             // TAPI v1.4
    DWORD       dwSameAreaRuleOffset;                           // TAPI v1.4
    DWORD       dwLongDistanceRuleSize;                         // TAPI v1.4
    DWORD       dwLongDistanceRuleOffset;                       // TAPI v1.4
    DWORD       dwInternationalRuleSize;                        // TAPI v1.4
    DWORD       dwInternationalRuleOffset;                      // TAPI v1.4

} LINECOUNTRYENTRY, FAR *LPLINECOUNTRYENTRY;

typedef struct linecountrylist_tag
{
    DWORD       dwTotalSize;                                    // TAPI v1.4
    DWORD       dwNeededSize;                                   // TAPI v1.4
    DWORD       dwUsedSize;                                     // TAPI v1.4
    DWORD       dwNumCountries;                                 // TAPI v1.4
    DWORD       dwCountryListSize;                              // TAPI v1.4
    DWORD       dwCountryListOffset;                            // TAPI v1.4

} LINECOUNTRYLIST, FAR *LPLINECOUNTRYLIST;

typedef struct linedevcaps_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwProviderInfoSize;
    DWORD       dwProviderInfoOffset;
    DWORD       dwSwitchInfoSize;
    DWORD       dwSwitchInfoOffset;
    DWORD       dwPermanentLineID;
    DWORD       dwLineNameSize;
    DWORD       dwLineNameOffset;
    DWORD       dwStringFormat;
    DWORD       dwAddressModes;
    DWORD       dwNumAddresses;
    DWORD       dwBearerModes;
    DWORD       dwMaxRate;
    DWORD       dwMediaModes;
    DWORD       dwGenerateToneModes;
    DWORD       dwGenerateToneMaxNumFreq;
    DWORD       dwGenerateDigitModes;
    DWORD       dwMonitorToneMaxNumFreq;
    DWORD       dwMonitorToneMaxNumEntries;
    DWORD       dwMonitorDigitModes;
    DWORD       dwGatherDigitsMinTimeout;
    DWORD       dwGatherDigitsMaxTimeout;
    DWORD       dwMedCtlDigitMaxListSize;
    DWORD       dwMedCtlMediaMaxListSize;
    DWORD       dwMedCtlToneMaxListSize;
    DWORD       dwMedCtlCallStateMaxListSize;
    DWORD       dwDevCapFlags;
    DWORD       dwMaxNumActiveCalls;
    DWORD       dwAnswerMode;
    DWORD       dwRingModes;
    DWORD       dwLineStates;
    DWORD       dwUUIAcceptSize;
    DWORD       dwUUIAnswerSize;
    DWORD       dwUUIMakeCallSize;
    DWORD       dwUUIDropSize;
    DWORD       dwUUISendUserUserInfoSize;
    DWORD       dwUUICallInfoSize;
    LINEDIALPARAMS  MinDialParams;
    LINEDIALPARAMS  MaxDialParams;
    LINEDIALPARAMS  DefaultDialParams;
    DWORD       dwNumTerminals;
    DWORD       dwTerminalCapsSize;
    DWORD       dwTerminalCapsOffset;
    DWORD       dwTerminalTextEntrySize;
    DWORD       dwTerminalTextSize;
    DWORD       dwTerminalTextOffset;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;

    DWORD       dwLineFeatures;                                 // TAPI v1.4

    DWORD       dwSettableDevStatus;                            // TAPI v2.0
    DWORD       dwDeviceClassesSize;                            // TAPI v2.0
    DWORD       dwDeviceClassesOffset;                          // TAPI v2.0
    GUID        PermanentLineGuid;                              // TAPI v2.2
    DWORD       dwAddressTypes;                                 // TAPI v3.0
    GUID        ProtocolGuid;                                   // TAPI v3.0
    DWORD       dwAvailableTracking;                            // TAPI v3.0

} LINEDEVCAPS, FAR *LPLINEDEVCAPS;
    
typedef struct linedevstatus_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwNumOpens;
    DWORD       dwOpenMediaModes;
    DWORD       dwNumActiveCalls;
    DWORD       dwNumOnHoldCalls;
    DWORD       dwNumOnHoldPendCalls;
    DWORD       dwLineFeatures;
    DWORD       dwNumCallCompletions;
    DWORD       dwRingMode;
    DWORD       dwSignalLevel;
    DWORD       dwBatteryLevel;
    DWORD       dwRoamMode;
    DWORD       dwDevStatusFlags;
    DWORD       dwTerminalModesSize;
    DWORD       dwTerminalModesOffset;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;

    DWORD       dwAvailableMediaModes;                          // TAPI v2.0
    DWORD       dwAppInfoSize;                                  // TAPI v2.0
    DWORD       dwAppInfoOffset;                                // TAPI v2.0
} LINEDEVSTATUS, FAR *LPLINEDEVSTATUS;

typedef struct lineextensionid_tag
{
    DWORD       dwExtensionID0;
    DWORD       dwExtensionID1;
    DWORD       dwExtensionID2;
    DWORD       dwExtensionID3;

} LINEEXTENSIONID, FAR *LPLINEEXTENSIONID;

typedef struct lineforward_tag
{
    DWORD       dwForwardMode;
    DWORD       dwCallerAddressSize;
    DWORD       dwCallerAddressOffset;
    DWORD       dwDestCountryCode;
    DWORD       dwDestAddressSize;
    DWORD       dwDestAddressOffset;

} LINEFORWARD, FAR *LPLINEFORWARD;

typedef struct lineforwardlist_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNumEntries;
    LINEFORWARD ForwardList[1];

} LINEFORWARDLIST, FAR *LPLINEFORWARDLIST;

typedef struct linegeneratetone_tag
{
    DWORD       dwFrequency;
    DWORD       dwCadenceOn;
    DWORD       dwCadenceOff;
    DWORD       dwVolume;

} LINEGENERATETONE, FAR *LPLINEGENERATETONE;

typedef struct lineinitializeexparams_tag
{
    DWORD       dwTotalSize;                                    // TAPI v2.0
    DWORD       dwNeededSize;                                   // TAPI v2.0
    DWORD       dwUsedSize;                                     // TAPI v2.0
    DWORD       dwOptions;                                      // TAPI v2.0

    union
    {
        HANDLE  hEvent;                                         // TAPI v2.0
        HANDLE  hCompletionPort;                                // TAPI v2.0

    } Handles;

    DWORD       dwCompletionKey;                                // TAPI v2.0

} LINEINITIALIZEEXPARAMS, FAR *LPLINEINITIALIZEEXPARAMS;

typedef struct linelocationentry_tag
{
    DWORD       dwPermanentLocationID;
    DWORD       dwLocationNameSize;
    DWORD       dwLocationNameOffset;
    DWORD       dwCountryCode;
    DWORD       dwCityCodeSize;
    DWORD       dwCityCodeOffset;
    DWORD       dwPreferredCardID;

    DWORD       dwLocalAccessCodeSize;                          // TAPI v1.4
    DWORD       dwLocalAccessCodeOffset;                        // TAPI v1.4
    DWORD       dwLongDistanceAccessCodeSize;                   // TAPI v1.4
    DWORD       dwLongDistanceAccessCodeOffset;                 // TAPI v1.4
    DWORD       dwTollPrefixListSize;                           // TAPI v1.4
    DWORD       dwTollPrefixListOffset;                         // TAPI v1.4
    DWORD       dwCountryID;                                    // TAPI v1.4
    DWORD       dwOptions;                                      // TAPI v1.4
    DWORD       dwCancelCallWaitingSize;                        // TAPI v1.4
    DWORD       dwCancelCallWaitingOffset;                      // TAPI v1.4

} LINELOCATIONENTRY, FAR *LPLINELOCATIONENTRY;

typedef struct linemediacontrolcallstate_tag
{
    DWORD       dwCallStates;
    DWORD       dwMediaControl;

} LINEMEDIACONTROLCALLSTATE, FAR *LPLINEMEDIACONTROLCALLSTATE;

typedef struct linemediacontroldigit_tag
{
    DWORD       dwDigit;
    DWORD       dwDigitModes;
    DWORD       dwMediaControl;

} LINEMEDIACONTROLDIGIT, FAR *LPLINEMEDIACONTROLDIGIT;

typedef struct linemediacontrolmedia_tag
{
    DWORD       dwMediaModes;
    DWORD       dwDuration;
    DWORD       dwMediaControl;

} LINEMEDIACONTROLMEDIA, FAR *LPLINEMEDIACONTROLMEDIA;

typedef struct linemediacontroltone_tag
{
    DWORD       dwAppSpecific;
    DWORD       dwDuration;
    DWORD       dwFrequency1;
    DWORD       dwFrequency2;
    DWORD       dwFrequency3;
    DWORD       dwMediaControl;

} LINEMEDIACONTROLTONE, FAR *LPLINEMEDIACONTROLTONE;

typedef struct linemessage_tag
{
    DWORD       hDevice;                                        // TAPI v2.0
    DWORD       dwMessageID;                                    // TAPI v2.0
    DWORD       dwCallbackInstance;                             // TAPI v2.0
    DWORD       dwParam1;                                       // TAPI v2.0
    DWORD       dwParam2;                                       // TAPI v2.0
    DWORD       dwParam3;                                       // TAPI v2.0

} LINEMESSAGE, FAR *LPLINEMESSAGE;


typedef struct linemonitortone_tag
{
    DWORD       dwAppSpecific;
    DWORD       dwDuration;
    DWORD       dwFrequency1;
    DWORD       dwFrequency2;
    DWORD       dwFrequency3;

} LINEMONITORTONE, FAR *LPLINEMONITORTONE;

typedef struct lineproviderentry_tag
{
    DWORD       dwPermanentProviderID;                          // TAPI v1.4
    DWORD       dwProviderFilenameSize;                         // TAPI v1.4
    DWORD       dwProviderFilenameOffset;                       // TAPI v1.4

} LINEPROVIDERENTRY, FAR *LPLINEPROVIDERENTRY;

typedef struct lineproviderlist_tag
{
    DWORD       dwTotalSize;                                    // TAPI v1.4
    DWORD       dwNeededSize;                                   // TAPI v1.4
    DWORD       dwUsedSize;                                     // TAPI v1.4
    DWORD       dwNumProviders;                                 // TAPI v1.4
    DWORD       dwProviderListSize;                             // TAPI v1.4
    DWORD       dwProviderListOffset;                           // TAPI v1.4

} LINEPROVIDERLIST, FAR *LPLINEPROVIDERLIST;


typedef struct linetermcaps_tag
{
    DWORD       dwTermDev;
    DWORD       dwTermModes;
    DWORD       dwTermSharing;

} LINETERMCAPS, FAR *LPLINETERMCAPS;

typedef struct linetranslatecaps_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwNumLocations;
    DWORD       dwLocationListSize;
    DWORD       dwLocationListOffset;
    DWORD       dwCurrentLocationID;
    DWORD       dwNumCards;
    DWORD       dwCardListSize;
    DWORD       dwCardListOffset;
    DWORD       dwCurrentPreferredCardID;

} LINETRANSLATECAPS, FAR *LPLINETRANSLATECAPS;

typedef struct linetranslateoutput_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwDialableStringSize;
    DWORD       dwDialableStringOffset;
    DWORD       dwDisplayableStringSize;
    DWORD       dwDisplayableStringOffset;
    DWORD       dwCurrentCountry;
    DWORD       dwDestCountry;
    DWORD       dwTranslateResults;

} LINETRANSLATEOUTPUT, FAR *LPLINETRANSLATEOUTPUT;

typedef struct phonebuttoninfo_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwButtonMode;
    DWORD       dwButtonFunction;
    DWORD       dwButtonTextSize;
    DWORD       dwButtonTextOffset;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;

    DWORD       dwButtonState;                                  // TAPI v1.4

} PHONEBUTTONINFO, FAR *LPPHONEBUTTONINFO;

typedef struct phonecaps_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwProviderInfoSize;
    DWORD       dwProviderInfoOffset;
    DWORD       dwPhoneInfoSize;
    DWORD       dwPhoneInfoOffset;
    DWORD       dwPermanentPhoneID;
    DWORD       dwPhoneNameSize;
    DWORD       dwPhoneNameOffset;
    DWORD       dwStringFormat;
    DWORD       dwPhoneStates;
    DWORD       dwHookSwitchDevs;
    DWORD       dwHandsetHookSwitchModes;
    DWORD       dwSpeakerHookSwitchModes;
    DWORD       dwHeadsetHookSwitchModes;
    DWORD       dwVolumeFlags;
    DWORD       dwGainFlags;
    DWORD       dwDisplayNumRows;
    DWORD       dwDisplayNumColumns;
    DWORD       dwNumRingModes;
    DWORD       dwNumButtonLamps;
    DWORD       dwButtonModesSize;
    DWORD       dwButtonModesOffset;
    DWORD       dwButtonFunctionsSize;
    DWORD       dwButtonFunctionsOffset;
    DWORD       dwLampModesSize;
    DWORD       dwLampModesOffset;
    DWORD       dwNumSetData;
    DWORD       dwSetDataSize;
    DWORD       dwSetDataOffset;
    DWORD       dwNumGetData;
    DWORD       dwGetDataSize;
    DWORD       dwGetDataOffset;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;
    DWORD       dwDeviceClassesSize;                            // TAPI v2.0
    DWORD       dwDeviceClassesOffset;                          // TAPI v2.0
    DWORD       dwPhoneFeatures;                                // TAPI v2.0
    DWORD       dwSettableHandsetHookSwitchModes;               // TAPI v2.0
    DWORD       dwSettableSpeakerHookSwitchModes;               // TAPI v2.0
    DWORD       dwSettableHeadsetHookSwitchModes;               // TAPI v2.0
    DWORD       dwMonitoredHandsetHookSwitchModes;              // TAPI v2.0
    DWORD       dwMonitoredSpeakerHookSwitchModes;              // TAPI v2.0
    DWORD       dwMonitoredHeadsetHookSwitchModes;              // TAPI v2.0
    GUID        PermanentPhoneGuid;                             // TAPI v2.2
} PHONECAPS, FAR *LPPHONECAPS;

typedef struct phoneextensionid_tag
{
    DWORD       dwExtensionID0;
    DWORD       dwExtensionID1;
    DWORD       dwExtensionID2;
    DWORD       dwExtensionID3;

} PHONEEXTENSIONID, FAR *LPPHONEEXTENSIONID;

typedef struct phoneinitializeexparams_tag
{
    DWORD       dwTotalSize;                                    // TAPI v2.0
    DWORD       dwNeededSize;                                   // TAPI v2.0
    DWORD       dwUsedSize;                                     // TAPI v2.0
    DWORD       dwOptions;                                      // TAPI v2.0

    union
    {
        HANDLE  hEvent;                                         // TAPI v2.0
        HANDLE  hCompletionPort;                                // TAPI v2.0

    } Handles;

    DWORD       dwCompletionKey;                                // TAPI v2.0

} PHONEINITIALIZEEXPARAMS, FAR *LPPHONEINITIALIZEEXPARAMS;

typedef struct phonemessage_tag
{
    DWORD       hDevice;                                        // TAPI v2.0
    DWORD       dwMessageID;                                    // TAPI v2.0
    DWORD       dwCallbackInstance;                             // TAPI v2.0
    DWORD       dwParam1;                                       // TAPI v2.0
    DWORD       dwParam2;                                       // TAPI v2.0
    DWORD       dwParam3;                                       // TAPI v2.0

} PHONEMESSAGE, FAR *LPPHONEMESSAGE;

typedef struct phonestatus_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwStatusFlags;
    DWORD       dwNumOwners;
    DWORD       dwNumMonitors;
    DWORD       dwRingMode;
    DWORD       dwRingVolume;
    DWORD       dwHandsetHookSwitchMode;
    DWORD       dwHandsetVolume;
    DWORD       dwHandsetGain;
    DWORD       dwSpeakerHookSwitchMode;
    DWORD       dwSpeakerVolume;
    DWORD       dwSpeakerGain;
    DWORD       dwHeadsetHookSwitchMode;
    DWORD       dwHeadsetVolume;
    DWORD       dwHeadsetGain;
    DWORD       dwDisplaySize;
    DWORD       dwDisplayOffset;
    DWORD       dwLampModesSize;
    DWORD       dwLampModesOffset;
    DWORD       dwOwnerNameSize;
    DWORD       dwOwnerNameOffset;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;

    DWORD       dwPhoneFeatures;                                // TAPI v2.0
} PHONESTATUS, FAR *LPPHONESTATUS;

typedef struct varstring_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwStringFormat;
    DWORD       dwStringSize;
    DWORD       dwStringOffset;

} VARSTRING, FAR *LPVARSTRING;


LONG
WINAPI
lineAccept(
    HCALL               hCall,
    LPCSTR              lpsUserUserInfo,
    DWORD               dwSize
    );

LONG
WINAPI
lineAddProvider(
    LPCWSTR             lpszProviderFilename,
    HWND                hwndOwner,
    LPDWORD             lpdwPermanentProviderID
    );


LONG
WINAPI
lineAddToConference(
    HCALL               hConfCall,
    HCALL               hConsultCall
    );

LONG
WINAPI
lineAnswer(
    HCALL               hCall,
    LPCSTR              lpsUserUserInfo,
    DWORD               dwSize
    );

LONG
WINAPI
lineBlindTransfer(
    HCALL               hCall,
    LPCWSTR             lpszDestAddressW,
    DWORD               dwCountryCode
    );

LONG
WINAPI
lineClose(
    HLINE               hLine
    );

LONG
WINAPI
lineCompleteTransfer(
    HCALL               hCall,
    HCALL               hConsultCall,
    LPHCALL             lphConfCall,
    DWORD               dwTransferMode
    );

LONG
WINAPI
lineConfigDialogEdit(
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCWSTR             lpszDeviceClass,
    LPVOID              const lpDeviceConfigIn,
    DWORD               dwSize,
    LPVARSTRING         lpDeviceConfigOut
    );

LONG
WINAPI
lineDeallocateCall(
    HCALL               hCall
    );

LONG
WINAPI
lineDevSpecific(
    HLINE               hLine,
    DWORD               dwAddressID,
    HCALL               hCall,
    LPVOID              lpParams,
    DWORD               dwSize
    );

LONG
WINAPI
lineDial(
    HCALL               hCall,
    LPCWSTR             lpszDestAddress,
    DWORD               dwCountryCode
    );

LONG
WINAPI
lineDrop(
    HCALL               hCall,
    LPCSTR              lpsUserUserInfo,
    DWORD               dwSize
    );

LONG
WINAPI
lineForward(
    HLINE               hLine,
    DWORD               bAllAddresses,
    DWORD               dwAddressID,
    LPLINEFORWARDLIST   const lpForwardList,
    DWORD               dwNumRingsNoAnswer,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    );

LONG
WINAPI
lineGenerateDigits(
    HCALL               hCall,
    DWORD               dwDigitMode,
    LPCWSTR             lpszDigits,
    DWORD               dwDuration
    );

LONG
WINAPI
lineGenerateTone(
    HCALL               hCall,
    DWORD               dwToneMode,
    DWORD               dwDuration,
    DWORD               dwNumTones,
    LPLINEGENERATETONE  const lpTones
    );

LONG
WINAPI
lineStartDTMF(
    HCALL               hCall,
    CHAR               cDTMFDigit
    );

LONG
WINAPI
lineStopDTMF(
    HCALL               hCall
    );

LONG
WINAPI
lineGetAddressCaps(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAddressID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPLINEADDRESSCAPS   lpAddressCaps
    );

LONG
WINAPI
lineGetAddressID(
    HLINE               hLine,
    LPDWORD             lpdwAddressID,
    DWORD               dwAddressMode,
    LPCWSTR             lpsAddress,
    DWORD               dwSize
    );

LONG
WINAPI
lineGetAddressStatus(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPLINEADDRESSSTATUS lpAddressStatus
    );


LONG
WINAPI
lineGetAppPriority(                                             // TAPI v1.4
    LPCWSTR             lpszAppFilename,
    DWORD               dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD               dwRequestMode,
    LPVARSTRING         lpExtensionName,
    LPDWORD             lpdwPriority
    );

LONG
WINAPI
lineGetCallInfo(
    HCALL               hCall,
    LPLINECALLINFO      lpCallInfo
    );


LONG
WINAPI
lineGetCallStatus(
    HCALL               hCall,
    LPLINECALLSTATUS    lpCallStatus
    );

LONG
WINAPI
lineGetConfRelatedCalls(
    HCALL               hCall,
    LPLINECALLLIST      lpCallList
    );
    
LONG
WINAPI
lineGetDevCaps(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPLINEDEVCAPS       lpLineDevCaps
    );

LONG
WINAPI
lineGetDevConfig(
    DWORD               dwDeviceID,
    LPVARSTRING         lpDeviceConfig,
    LPCWSTR             lpszDeviceClass
    );

LONG
WINAPI
lineGetNewCalls(
    HLINE               hLine,
    DWORD               dwAddressID,
    DWORD               dwSelect,
    LPLINECALLLIST      lpCallList
    );

LONG
WINAPI
lineGetIcon(
    DWORD               dwDeviceID,
    LPCWSTR             lpszDeviceClass,
    LPHICON             lphIcon
    );

LONG
WINAPI
lineGetID(
    HLINE               hLine,
    DWORD               dwAddressID,
    HCALL               hCall,
    DWORD               dwSelect,
    LPVARSTRING         lpDeviceID,
    LPCWSTR             lpszDeviceClass
    );

LONG
WINAPI
lineGetLineDevStatus(
    HLINE               hLine,
    LPLINEDEVSTATUS     lpLineDevStatus
    );


LONG
WINAPI
lineGetMessage(
    HLINEAPP        hLineApp,
    LPLINEMESSAGE   lpMessage,
    DWORD           dwTimeout
    );

LONG
WINAPI
lineGetNumRings(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPDWORD             lpdwNumRings
    );

LONG
WINAPI
lineGetProviderList(                                            // TAPI v1.4
    DWORD               dwAPIVersion,
    LPLINEPROVIDERLIST  lpProviderList
    );


LONG
WINAPI
lineGetStatusMessages(
    HLINE               hLine,
    LPDWORD             lpdwLineStates,
    LPDWORD             lpdwAddressStates
    );

LONG
WINAPI
lineGetTranslateCaps(
    HLINEAPP hLineApp,
    DWORD dwAPIVersion,
    LPLINETRANSLATECAPS lpTranslateCaps
    );

LONG
WINAPI
lineHandoff(
    HCALL               hCall,
    LPCWSTR             lpszFileName,
    DWORD               dwMediaMode
    );

LONG
WINAPI
lineHold(
    HCALL               hCall
    );

LONG
WINAPI
lineInitialize(
    LPHLINEAPP          lphLineApp,
    HINSTANCE           hInstance,
    LINECALLBACK        lpfnCallback,
    LPCWSTR             lpszAppName,
    LPDWORD             lpdwNumDevs
    );

LONG
WINAPI
lineInitializeEx(
    LPHLINEAPP                  lphLineApp,
    HINSTANCE                   hInstance,
    LINECALLBACK                lpfnCallback,
    LPCWSTR                     lpszFriendlyAppName,
    LPDWORD                     lpdwNumDevs,
    LPDWORD                     lpdwAPIVersion,
    LPLINEINITIALIZEEXPARAMS    lpLineInitializeExParams
    );

LONG
WINAPI
lineMakeCall(
    HLINE               hLine,
    LPHCALL             lphCall,
    LPCWSTR             lpszDestAddress,
    DWORD               dwCountryCode,
    LPLINECALLPARAMS    const lpCallParams
    );


LONG
WINAPI
lineMonitorDigits(
    HCALL               hCall,
    DWORD               dwDigitModes
    );

LONG
WINAPI
lineMonitorMedia(
    HCALL               hCall,
    DWORD               dwMediaModes
    );

LONG
WINAPI
lineNegotiateAPIVersion(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPILowVersion,
    DWORD               dwAPIHighVersion,
    LPDWORD             lpdwAPIVersion,
    LPLINEEXTENSIONID   lpExtensionID
    );

LONG
WINAPI
lineNegotiateExtVersion(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtLowVersion,
    DWORD               dwExtHighVersion,
    LPDWORD             lpdwExtVersion
    );

LONG
WINAPI
lineOpen(
    HLINEAPP hLineApp, 
    DWORD dwDeviceID,
    LPHLINE lphLine,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    DWORD               dwCallbackInstance,
    DWORD               dwPrivileges,
    DWORD               dwMediaModes,
    LPLINECALLPARAMS    const lpCallParams
    );

LONG
WINAPI
linePickup(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPHCALL             lphCall,
    LPCWSTR             lpszDestAddress,
    LPCWSTR             lpszGroupID
    );

LONG
WINAPI
linePrepareAddToConference(
    HCALL               hConfCall,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    );


LONG
WINAPI
lineRedirect(
    HCALL               hCall,
    LPCWSTR             lpszDestAddress,
    DWORD               dwCountryCode
    );

LONG
WINAPI
lineReleaseUserUserInfo(                                        // TAPI v1.4
    HCALL               hCall
    );

LONG
WINAPI
lineRemoveFromConference(
    HCALL               hCall
    );

LONG
WINAPI
lineSendUserUserInfo(
    HCALL               hCall,
    LPCSTR              lpsUserUserInfo,
    DWORD               dwSize
    );

LONG
WINAPI
lineSetAppPriority(                                             // TAPI v1.4
    LPCWSTR             lpszAppFilename,
    DWORD               dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD               dwRequestMode,
    LPCWSTR             lpszExtensionName,
    DWORD               dwPriority
    );


LONG
WINAPI
lineSetCallParams(
    HCALL               hCall,
    DWORD               dwBearerMode,
    DWORD               dwMinRate,
    DWORD               dwMaxRate,
    LPLINEDIALPARAMS    const lpDialParams
    );

LONG
WINAPI
lineSetCallPrivilege(
    HCALL               hCall,
    DWORD               dwCallPrivilege
    );


LONG
WINAPI
lineSetCurrentLocation(
    HLINEAPP            hLineApp,
    DWORD               dwLocation
    );

LONG
WINAPI
lineSetDevConfig(
    DWORD               dwDeviceID,
    LPVOID              const lpDeviceConfig,
    DWORD               dwSize,
    LPCWSTR             lpszDeviceClass
    );

LONG
WINAPI
lineSetMediaMode(
    HCALL               hCall,
    DWORD               dwMediaModes
    );

LONG
WINAPI
lineSetNumRings(
    HLINE               hLine,
    DWORD               dwAddressID,
    DWORD               dwNumRings
    );

LONG
WINAPI
lineSetStatusMessages(
    HLINE               hLine,
    DWORD               dwLineStates,
    DWORD               dwAddressStates
    );

LONG
WINAPI
lineSetTerminal(
    HLINE               hLine,
    DWORD               dwAddressID,
    HCALL               hCall,
    DWORD               dwSelect,
    DWORD               dwTerminalModes,
    DWORD               dwTerminalID,
    DWORD               bEnable
    );

LONG
WINAPI
lineSetTollList(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    LPCWSTR             lpszAddressIn,
    DWORD               dwTollListOption
    );


LONG
WINAPI
lineSetupConference(
    HCALL               hCall,
    HLINE               hLine,
    LPHCALL             lphConfCall,
    LPHCALL             lphConsultCall,
    DWORD               dwNumParties,
    LPLINECALLPARAMS    const lpCallParams
    );

LONG
WINAPI
lineSetupTransfer(
    HCALL               hCall,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    );

LONG
WINAPI
lineShutdown(
    HLINEAPP            hLineApp
    );

LONG
WINAPI
lineSwapHold(
    HCALL               hActiveCall,
    HCALL               hHeldCall
    );

LONG
WINAPI
lineTranslateAddress(
    HLINEAPP                hLineApp,
    DWORD                   dwDeviceID,
    DWORD                   dwAPIVersion,
    LPCWSTR                 lpszAddressIn,
    DWORD                   dwCard,
    DWORD                   dwTranslateOptions,
    LPLINETRANSLATEOUTPUT   lpTranslateOutput
    );


LONG
WINAPI
lineTranslateDialog(                                            // TAPI v1.4
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    HWND                hwndOwner,
    LPCWSTR             lpszAddressIn
    );

LONG
WINAPI
lineUnhold(
    HCALL               hCall
    );



LONG
WINAPI
phoneClose(
    HPHONE              hPhone
    );

LONG
WINAPI
phoneConfigDialog(
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCWSTR             lpszDeviceClass
    );

LONG
WINAPI
phoneDevSpecific(
    HPHONE hPhone,
    LPVOID lpParams,
    DWORD dwSize
    );

LONG
WINAPI
phoneGetDevCaps(
    HPHONEAPP           hPhoneApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPPHONECAPS         lpPhoneCaps
    );

LONG
WINAPI
phoneGetGain(
    HPHONE              hPhone,
    DWORD               dwHookSwitchDev,
    LPDWORD             lpdwGain
    );

LONG
WINAPI
phoneGetHookSwitch(
    HPHONE              hPhone,
    LPDWORD             lpdwHookSwitchDevs
    );

LONG
WINAPI
phoneGetIcon(
    DWORD               dwDeviceID,
    LPCWSTR             lpszDeviceClass,
    LPHICON             lphIcon
    );


LONG
WINAPI
phoneGetID(
    HPHONE              hPhone,
    LPVARSTRING         lpDeviceID,
    LPCWSTR             lpszDeviceClass
    );

LONG
WINAPI
phoneGetMessage(
    HPHONEAPP       hPhoneApp,
    LPPHONEMESSAGE  lpMessage,
    DWORD           dwTimeout
    );

LONG
WINAPI
phoneGetRing(
    HPHONE              hPhone,
    LPDWORD             lpdwRingMode,
    LPDWORD             lpdwVolume
    );

LONG
WINAPI
phoneGetStatus(
    HPHONE              hPhone,
    LPPHONESTATUS       lpPhoneStatus
    );

LONG
WINAPI
phoneGetStatusMessages(
    HPHONE              hPhone,
    LPDWORD             lpdwPhoneStates,
    LPDWORD             lpdwButtonModes,
    LPDWORD             lpdwButtonStates
    );

LONG
WINAPI
phoneGetVolume(
    HPHONE              hPhone,
    DWORD               dwHookSwitchDev,
    LPDWORD             lpdwVolume
    );

LONG
WINAPI
phoneInitializeEx(
    LPHPHONEAPP                 lphPhoneApp,
    HINSTANCE                   hInstance,
    PHONECALLBACK               lpfnCallback,
    LPCWSTR                     lpszFriendlyAppName,
    LPDWORD                     lpdwNumDevs,
    LPDWORD                     lpdwAPIVersion,
    LPPHONEINITIALIZEEXPARAMS   lpPhoneInitializeExParams
    );

LONG
WINAPI
phoneNegotiateAPIVersion(
    HPHONEAPP           hPhoneApp,
    DWORD               dwDeviceID,
    DWORD               dwAPILowVersion,
    DWORD               dwAPIHighVersion,
    LPDWORD             lpdwAPIVersion,
    LPPHONEEXTENSIONID  lpExtensionID
    );


LONG
WINAPI
phoneNegotiateExtVersion(
    HPHONEAPP           hPhoneApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtLowVersion,
    DWORD               dwExtHighVersion,
    LPDWORD             lpdwExtVersion
    );

LONG
WINAPI
phoneOpen(
    HPHONEAPP           hPhoneApp,
    DWORD               dwDeviceID,
    LPHPHONE            lphPhone,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    DWORD               dwCallbackInstance,
    DWORD               dwPrivilege
    );

LONG
WINAPI
phoneSetGain(
    HPHONE              hPhone,
    DWORD               dwHookSwitchDev,
    DWORD               dwGain
    );

LONG
WINAPI
phoneSetHookSwitch(
    HPHONE              hPhone,
    DWORD               dwHookSwitchDevs,
    DWORD               dwHookSwitchMode
    );

LONG
WINAPI
phoneSetRing(
    HPHONE              hPhone,
    DWORD               dwRingMode,
    DWORD               dwVolume
    );

LONG
WINAPI
phoneSetStatusMessages(
    HPHONE              hPhone,
    DWORD               dwPhoneStates,
    DWORD               dwButtonModes,
    DWORD               dwButtonStates
    );

LONG
WINAPI
phoneSetVolume(
    HPHONE              hPhone,
    DWORD               dwHookSwitchDev,
    DWORD               dwVolume
    );

LONG
WINAPI
phoneShutdown(
    HPHONEAPP           hPhoneApp
    );



/*

TAPIERROR_FORMATMESSAGE - macro to convert a TAPI error constant
    into a constant that FormatMessage will accept
    
        TAPIERR : Negative numbers and 0
            Map to : strip off high WORD
            Example: 0xFFFFFFFF (-1) becomes 0x0000FFFF
        LINEERR : Start at 0x80000000
            Map to : strip off 0x80000000 and add 0xE000
            Example: 0x80000004 becomes 0x0000E004
        PHONEERR: Start at 0x90000000
            Map to : strip off 0x90000000 and add 0xF000
            Example: 0x9000000A becomes 0x0000F00A

        pseudocode:
        
        if (__ErrCode__ is a TAPIERR)
            strip off high word

            else if (__ErrCode__ is a PHONEERR)
                strip off 0x90000000
                add 0xE000

                else
                    strip off 0x80000000
                    add 0xF000

*/

#define TAPIERROR_FORMATMESSAGE(__ErrCode__)                                                   \
                                                                                               \
                    ( ( (__ErrCode__) > 0xFFFF0000 ) ?                                         \
                                                                                               \
                            ( (__ErrCode__) & 0x0000FFFF ) :                                   \
                                                                                               \
                            ( ( (__ErrCode__) & 0x10000000 ) ?                                 \
                                                                                               \
                              ( (__ErrCode__) - 0x90000000 + 0xF000 ) :                        \
                                                                                               \
                              ( (__ErrCode__) - 0x80000000 + 0xE000 ) ) )


//
// Define unicode forms of API functions
//
#define lineAddProviderW        lineAddProvider
#define lineBlindTransferW      lineBlindTransfer
#define lineConfigDialogEditW   lineConfigDialogEdit
#define lineDialW               lineDial
#define lineForwardW            lineForward
#define lineGenerateDigitsW     lineGenerateDigits
#define lineGetAddressCapsW     lineGetAddressCaps
#define lineGetAddressIDW       lineGetAddressID
#define lineGetAddressStatusW   lineGetAddressStatus
#define lineGetAppPriorityW     lineGetAppPriority
#define lineGetCallInfoW        lineGetCallInfo
#define lineGetDevCapsW         lineGetDevCaps
#define lineGetDevConfigW       lineGetDevConfig
#define lineGetIconW            lineGetIcon
#define lineGetIDW              lineGetID
#define lineGetProviderListW    lineGetProviderList
#define lineGetTranslateCapsW   lineGetTranslateCaps
#define lineHandoffW            lineHandoff
#define lineInitializeExW       lineInitializeEx
#define lineMakeCallW           lineMakeCall
#define lineOpenW               lineOpen
#define linePickupW             linePickup
#define linePrepareAddToConferenceW linePrepareAddToConference
#define lineRedirectW           lineRedirect
#define lineSetAppPriorityW     lineSetAppPriority
#define lineSetDevConfigW       lineSetDevConfig
#define lineSetTollListW        lineSetTollList
#define lineSetupConferenceW    lineSetupConference
#define lineSetupTransferW      lineSetupTransfer
#define lineTranslateAddressW   lineTranslateAddress
#define lineTranslateDialogW    lineTranslateDialog
#define phoneConfigDialogW      phoneConfigDialog
#define phoneGetDevCapsW        phoneGetDevCaps
#define phoneGetIconW           phoneGetIcon
#define phoneGetIDW             phoneGetID
#define phoneGetStatusW         phoneGetStatus
#define phoneInitializeExW      phoneInitializeEx


#if defined(WINCEOEM) && defined(UNDER_CE)
#include <ptapi.h>
#if defined(WINCEMACRO) || defined(WINCEMACROTAPI)
#include <mtapi.h>
#endif
#endif


#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#endif // TAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\tcpestats.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    tcpestats.w

Abstract:

    This module contains the definitions and structures for TCP extended
    statistics.

Author:

    Xinyan Zan (xinyanz) 30-June-2006

Environment:

    User mode and kernel mode

--*/
#ifndef _TCPESTATS_
#define _TCPESTATS_
#pragma once

//
// Please don't change the order of this enum. The order defined in this
// enum needs to match the order in EstatsToTcpObjectMappingTable.
//
typedef enum {
    TcpConnectionEstatsSynOpts,
    TcpConnectionEstatsData,
    TcpConnectionEstatsSndCong,
    TcpConnectionEstatsPath,
    TcpConnectionEstatsSendBuff,
    TcpConnectionEstatsRec,
    TcpConnectionEstatsObsRec,
    TcpConnectionEstatsBandwidth,
    TcpConnectionEstatsFineRtt,
    TcpConnectionEstatsMaximum,
} TCP_ESTATS_TYPE, *PTCP_ESTATS_TYPE;

//
// TCP_BOOLEAN_OPTIONAL
//
// Define the states that a caller can specify when updating a boolean field.
//

typedef enum _TCP_BOOLEAN_OPTIONAL {
    TcpBoolOptDisabled = 0,
    TcpBoolOptEnabled,
    TcpBoolOptUnchanged = -1
} TCP_BOOLEAN_OPTIONAL, *PTCP_BOOLEAN_OPTIONAL;

//
// TCP_ESTATS_SYN_OPTS_ROS
//
// Define extended SYN-exchange information maintained for TCP connections.
//

typedef struct _TCP_ESTATS_SYN_OPTS_ROS_v0 {
    BOOLEAN ActiveOpen;
    ULONG MssRcvd;
    ULONG MssSent;
} TCP_ESTATS_SYN_OPTS_ROS_v0, *PTCP_ESTATS_SYN_OPTS_ROS_v0;


//
// TCP_SOFT_ERROR
//
// Enumerate the non-fatal errors recorded on each connection.
//

typedef enum {
    TcpErrorNone = 0,
    TcpErrorBelowDataWindow,
    TcpErrorAboveDataWindow,
    TcpErrorBelowAckWindow,
    TcpErrorAboveAckWindow,
    TcpErrorBelowTsWindow,
    TcpErrorAboveTsWindow,
    TcpErrorDataChecksumError,
    TcpErrorDataLengthError,
    TcpErrorMaxSoftError
} TCP_SOFT_ERROR, *PTCP_SOFT_ERROR;

//
// TCP_ESTATS_DATA_ROD
//
// Define extended data-transfer information for TCP connections.
//

typedef struct _TCP_ESTATS_DATA_ROD_v0 {
    ULONG64 DataBytesOut;
    ULONG64 DataSegsOut;
    ULONG64 DataBytesIn;
    ULONG64 DataSegsIn;
    ULONG64 SegsOut;
    ULONG64 SegsIn;
    ULONG SoftErrors;
    ULONG SoftErrorReason;
    ULONG SndUna;
    ULONG SndNxt;
    ULONG SndMax;
    ULONG64 ThruBytesAcked;
    ULONG RcvNxt;
    ULONG64 ThruBytesReceived;
} TCP_ESTATS_DATA_ROD_v0, *PTCP_ESTATS_DATA_ROD_v0;

//
// TCP_ESTATS_DATA_RW
//
// Define structure for enabling extended data-transfer information.
//

typedef struct _TCP_ESTATS_DATA_RW_v0 {
    BOOLEAN EnableCollection;
} TCP_ESTATS_DATA_RW_v0, *PTCP_ESTATS_DATA_RW_v0;


//
// TCP_ESTATS_SND_CONG_ROD
//
// Define extended sender-congestion information for TCP connections.
//

typedef struct _TCP_ESTATS_SND_CONG_ROD_v0 {
    ULONG SndLimTransRwin;
    ULONG SndLimTimeRwin;
    SIZE_T SndLimBytesRwin;
    ULONG SndLimTransCwnd;
    ULONG SndLimTimeCwnd;
    SIZE_T SndLimBytesCwnd;
    ULONG SndLimTransSnd;
    ULONG SndLimTimeSnd;
    SIZE_T SndLimBytesSnd;
    ULONG SlowStart;
    ULONG CongAvoid;
    ULONG OtherReductions;
    ULONG CurCwnd;
    ULONG MaxSsCwnd;
    ULONG MaxCaCwnd;
    ULONG CurSsthresh;
    ULONG MaxSsthresh;
    ULONG MinSsthresh;
} TCP_ESTATS_SND_CONG_ROD_v0, *PTCP_ESTATS_SND_CONG_ROD_v0;

//
// TCP_ESTATS_SND_CONG_ROS
//
// Define static extended sender-congestion information for TCP connections.

typedef struct _TCP_ESTATS_SND_CONG_ROS_v0 {
    ULONG LimCwnd;
} TCP_ESTATS_SND_CONG_ROS_v0, *PTCP_ESTATS_SND_CONG_ROS_v0;

//
// TCP_ESTATS_SND_CONG_RW
//
// Define structure for enabling extended sender-congestion information.
//

typedef struct _TCP_ESTATS_SND_CONG_RW_v0 {
    BOOLEAN EnableCollection;
} TCP_ESTATS_SND_CONG_RW_v0, *PTCP_ESTATS_SND_CONG_RW_v0;

//
// TCP_ESTATS_PATH_ROD
//
// Define extended path-measurement information for TCP connections.
//

typedef struct _TCP_ESTATS_PATH_ROD_v0 {
    ULONG FastRetran;
    ULONG Timeouts;
    ULONG SubsequentTimeouts;
    ULONG CurTimeoutCount;
    ULONG AbruptTimeouts;
    ULONG PktsRetrans;
    ULONG BytesRetrans;
    ULONG DupAcksIn;
    ULONG SacksRcvd;
    ULONG SackBlocksRcvd;
    ULONG CongSignals;
    ULONG PreCongSumCwnd;
    ULONG PreCongSumRtt;
    ULONG PostCongSumRtt;
    ULONG PostCongCountRtt;
    ULONG EcnSignals;
    ULONG EceRcvd;
    ULONG SendStall;
    ULONG QuenchRcvd;
    ULONG RetranThresh;
    ULONG SndDupAckEpisodes;
    ULONG SumBytesReordered;
    ULONG NonRecovDa;
    ULONG NonRecovDaEpisodes;
    ULONG AckAfterFr;
    ULONG DsackDups;
    ULONG SampleRtt;
    ULONG SmoothedRtt;
    ULONG RttVar;
    ULONG MaxRtt;
    ULONG MinRtt;
    ULONG SumRtt;
    ULONG CountRtt;
    ULONG CurRto;
    ULONG MaxRto;
    ULONG MinRto;
    ULONG CurMss;
    ULONG MaxMss;
    ULONG MinMss;
    ULONG SpuriousRtoDetections;
} TCP_ESTATS_PATH_ROD_v0, *PTCP_ESTATS_PATH_ROD_v0;

//
// TCP_ESTATS_PATH_ROS
//
// Define structure for enabling path-measurement information.
//

typedef struct _TCP_ESTATS_PATH_RW_v0 {
    BOOLEAN EnableCollection;
} TCP_ESTATS_PATH_RW_v0, *PTCP_ESTATS_PATH_RW_v0;

//
// TCP_ESTATS_SEND_BUFF_ROD
//
// Define extended output-queuing information for TCP connections.
//

typedef struct _TCP_ESTATS_SEND_BUFF_ROD_v0 {
    SIZE_T CurRetxQueue;
    SIZE_T MaxRetxQueue;
    SIZE_T CurAppWQueue;
    SIZE_T MaxAppWQueue;
} TCP_ESTATS_SEND_BUFF_ROD_v0, *PTCP_ESTATS_SEND_BUFF_ROD_v0;

//
// TCP_ESTATS_SEND_BUFF_RW
//
// Define structure for enabling output-queuing information.
//

typedef struct _TCP_ESTATS_SEND_BUFF_RW_v0 {
    BOOLEAN EnableCollection;
} TCP_ESTATS_SEND_BUFF_RW_v0, *PTCP_ESTATS_SEND_BUFF_RW_v0;


//
// TCP_ESTATS_REC_ROD
//
// Define extended local-receiver information for TCP connections.
//

typedef struct _TCP_ESTATS_REC_ROD_v0 {
    ULONG CurRwinSent;
    ULONG MaxRwinSent;
    ULONG MinRwinSent;
    ULONG LimRwin;
    ULONG DupAckEpisodes;
    ULONG DupAcksOut;
    ULONG CeRcvd;
    ULONG EcnSent;
    ULONG EcnNoncesRcvd;
    ULONG CurReasmQueue;
    ULONG MaxReasmQueue;
    SIZE_T CurAppRQueue;
    SIZE_T MaxAppRQueue;
    UCHAR WinScaleSent;
} TCP_ESTATS_REC_ROD_v0, *PTCP_ESTATS_REC_ROD_v0;

//
// TCP_ESTATS_REC_RW
//
// Define structure for enabling local-receiver information.
//

typedef struct _TCP_ESTATS_REC_RW_v0 {
    BOOLEAN EnableCollection;
} TCP_ESTATS_REC_RW_v0, *PTCP_ESTATS_REC_RW_v0;


//
// TCP_ESTATS_OBS_REC_ROD
//
// Define extended remote-receiver information for TCP connections.
//

typedef struct _TCP_ESTATS_OBS_REC_ROD_v0 {
    ULONG CurRwinRcvd;
    ULONG MaxRwinRcvd;
    ULONG MinRwinRcvd;
    UCHAR WinScaleRcvd;
} TCP_ESTATS_OBS_REC_ROD_v0, *PTCP_ESTATS_OBS_REC_ROD_v0;


//
// TCP_ESTATS_OBS_REC_RW
//
// Define structure for enabling remote-receiver information.
//

typedef struct _TCP_ESTATS_OBS_REC_RW_v0 {
    BOOLEAN EnableCollection;
} TCP_ESTATS_OBS_REC_RW_v0, *PTCP_ESTATS_OBS_REC_RW_v0;


//
// TCP_ESTATS_BW_RW
// 
// Define the structure for enabling bandwidth estimation for TCP connections.
//

typedef struct _TCP_ESTATS_BANDWIDTH_RW_v0 {
    TCP_BOOLEAN_OPTIONAL EnableCollectionOutbound;
    TCP_BOOLEAN_OPTIONAL EnableCollectionInbound;
} TCP_ESTATS_BANDWIDTH_RW_v0, *PTCP_ESTATS_BANDWIDTH_RW_v0;

//
// TCP_ESTATS_BW_ROD
//
// Define bandwidth estimation statistics for TCP connections.
//
// Bandwidth and Instability metrics are expressed as bits per second.
//

typedef struct _TCP_ESTATS_BANDWIDTH_ROD_v0 {
    ULONG64 OutboundBandwidth;
    ULONG64 InboundBandwidth;
    ULONG64 OutboundInstability;
    ULONG64 InboundInstability;
    BOOLEAN OutboundBandwidthPeaked;
    BOOLEAN InboundBandwidthPeaked;
} TCP_ESTATS_BANDWIDTH_ROD_v0, *PTCP_ESTATS_BANDWIDTH_ROD_v0;

//
// TCP_ESTATS_FINE_RTT_RW
//
// Define the structure for enabling fine-grained RTT estimation for TCP
// connections.
//

typedef struct _TCP_ESTATS_FINE_RTT_RW_v0 {
    BOOLEAN EnableCollection;
} TCP_ESTATS_FINE_RTT_RW_v0, *PTCP_ESTATS_FINE_RTT_RW_v0;


//
// TCP_ESTATS_FINE_RTT_ROD
//
// Define fine-grained RTT estimation statistics for TCP connections.
//

typedef struct _TCP_ESTATS_FINE_RTT_ROD_v0 {
    ULONG RttVar;
    ULONG MaxRtt;
    ULONG MinRtt;
    ULONG SumRtt;
} TCP_ESTATS_FINE_RTT_ROD_v0, *PTCP_ESTATS_FINE_RTT_ROD_v0;

#endif // _TCPESTATS_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\tchar.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/***
*tchar.h - definitions for generic international text functions
*
*Purpose:
*   This file has been completely revamped to support the full set of CRT-like
*   functionality exported by COREDLL and *only* those functions (v2.10 and later)
*
****/

#pragma once

#ifndef _INC_TCHAR
#define _INC_TCHAR

#if !defined(_TCHAR_NO_WINDEF)
/*
 * WINDEF is included for legacy reasons.
 */
#include <windef.h>
#endif

/*
 * STDLIB is included for legacy reasons.
 */
#include <stdlib.h>

#ifdef  __cplusplus
extern "C" {
#endif

#define __T(x)      __TEXT(x)
#define _T(x)       __TEXT(x)

#ifdef  UNICODE
/* ++++++++++++++++++++ UNICODE ++++++++++++++++++++ */

#ifndef __TCHAR_DEFINED
typedef wchar_t         _TCHAR;
typedef wchar_t         _TSCHAR;
typedef wchar_t         _TUCHAR;
typedef wchar_t         _TXCHAR;
typedef wint_t          _TINT;
#define __TCHAR_DEFINED
#endif

#if     !__STDC__
#ifndef _TCHAR_DEFINED
typedef wchar_t         TCHAR, *PTCHAR;
typedef wchar_t         TBYTE, *PTBYTE;
#define _TCHAR_DEFINED
#endif
#define __TEXT(x)       L ## x
#endif

#define _TEOF           WEOF


#define _tmain          wmain

#ifdef UNDER_CE
#   define _tWinMain    WinMain // On CE it's always WinMain
#else
#   define _tWinMain    wWinMain
#endif

/* Formatted i/o */
#define _tprintf        wprintf
#define _tprintf_s      wprintf_s
#define _ftprintf       fwprintf
#define _ftprintf_s     fwprintf_s
#define _stprintf       swprintf
#define _stprintf_s     swprintf_s
#define _sntprintf      _snwprintf
#define _sntprintf_s    _snwprintf_s
#define _sctprintf      _scwprintf
#define _vtprintf       vwprintf
#define _vtprintf_s     vwprintf_s
#define _vftprintf      vfwprintf
#define _vftprintf_s    vfwprintf_s
#define _vstprintf      vswprintf
#define _vstprintf_s    vswprintf_s
#define _vsntprintf     _vsnwprintf
#define _vsntprintf_s   _vsnwprintf_s
#define _vsctprintf     _vscwprintf
#define _tscanf         wscanf
#define _tscanf_s       wscanf_s
#define _ftscanf        fwscanf
#define _ftscanf_s      fwscanf_s
#define _stscanf        swscanf
#define _stscanf_s      swscanf_s

/* Unformatted i/o */
#define _fgettc         fgetwc
#define _fgetts         fgetws
#define _fputtc         fputwc
#define _fputts         fputws
#define _gettc          getwc
#define _gettchar       getwchar
#define _getts          _getws
#define _getts_s        _getws_s
#define _puttc          putwc
#define _puttchar       putwchar
#define _putts          _putws
#define _ungettc        ungetwc

// Stdio functions
#define _tfopen         _wfopen
#define _tfopen_s       _wfopen_s
#define _tfreopen       _wfreopen
#define _tfreopen_s     _wfreopen_s

/* String conversion functions */
#define _tcstod         wcstod
#define _tcstol         wcstol
#define _tcstoul        wcstoul

#define _itot           _itow
#define _itot_s         _itow_s
#define _ltot           _ltow
#define _ltot_s         _ltow_s
#define _ultot          _ultow
#define _ultot_s        _ultow_s
#define _ttoi           _wtoi
#define _tstoi          _wtoi
#define _ttol           _wtol
#define _tstol          _wtol
#ifndef UNDER_CE
// Not implemented for CE
#define _ttof           _wtof
#define _tstof          _wtof
#endif
#define _ttoi64         _wtoi64
#define _tstoi64        _wtoi64

/* String functions */
#define _tcscat         wcscat
#define _tcscat_s       wcscat_s
#define _tcschr         wcschr
#define _tcscmp         wcscmp
#define _tcscpy         wcscpy
#define _tcscpy_s       wcscpy_s
#define _tcscspn        wcscspn
#define _tcslen         wcslen
#define _tcsnlen        wcsnlen
#define _tcsclen        wcslen

#define _tcsncat        wcsncat
#define _tcsncat_s      wcsncat_s
#define _tcsnccat       wcsncat
#define _tcsnccmp       wcsncmp
#define _tcsncmp        wcsncmp
#define _tcsncpy        wcsncpy
#define _tcsncpy_s      wcsncpy_s
#define _tcsnccpy       wcsncpy
#define _tcspbrk        wcspbrk
#define _tcsrchr        wcsrchr
#define _tcsspn         wcsspn
#define _tcsstr         wcsstr
#define _tcstok         wcstok
#define _tcstok_s       wcstok_s
#define _tcsdup         _wcsdup
#define _tcsicmp        _wcsicmp
#define _tcsncicmp      _wcsnicmp
#define _tcsnicmp       _wcsnicmp
#define _tcsnset        _wcsnset
#define _tcsnset_s      _wcsnset_s
#define _tcsncset       _wcsnset
#define _tcsrev         _wcsrev
#define _tcsset         _wcsset
#define _tcsset_s       _wcsset_s

#define _tcslwr         _wcslwr
#define _tcslwr_s       _wcslwr_s
#define _tcsupr         _wcsupr
#define _tcsupr_s       _wcsupr_s

// ctype functions
#define _istalpha       iswalpha
#define _istupper       iswupper
#define _istlower       iswlower
#define _istdigit       iswdigit
#define _istxdigit      iswxdigit
#define _istspace       iswspace
#define _istpunct       iswpunct
#define _istalnum       iswalnum
#define _istprint       iswprint
#define _istgraph       iswgraph
#define _istcntrl       iswcntrl
#define _istascii       iswascii

#define _totupper       towupper
#define _totlower       towlower

#define _istlegal(_c)       (1)
#define _istlead(_c)        (0)
#define _istleadbyte(_c)    (0)

#else   /* ndef UNICODE */

/* ++++++++++++++++++++ SBCS (MBCS is not supported) ++++++++++++++++++++ */

#ifndef __TCHAR_DEFINED
typedef char            _TCHAR;
typedef signed char     _TSCHAR;
typedef unsigned char   _TUCHAR;
typedef unsigned char   _TXCHAR;
typedef unsigned int    _TINT;
#define __TCHAR_DEFINED
#endif

#if     !__STDC__
#ifndef _TCHAR_DEFINED
typedef char            TCHAR, *PTCHAR;
typedef unsigned char   TBYTE, *PTBYTE;
#define _TCHAR_DEFINED
#endif
#define __TEXT(x)       x
#endif

#define _TEOF           EOF


/* Program */
#define _tmain          main
#define _tWinMain       WinMain


/* Formatted i/o */
#define _tprintf        printf
#define _tprintf_s      printf_s
#define _ftprintf       fprintf
#define _ftprintf_s     fprintf_s
#define _stprintf       sprintf
#define _stprintf_s     sprintf_s
#define _sntprintf      _snprintf
#define _sntprintf_s    _snprintf_s
#define _sctprintf      _scprintf
#define _vtprintf       vprintf
#define _vtprintf_s     vprintf_s
#define _vftprintf      vfprintf
#define _vftprintf_s    vfprintf_s
#define _vstprintf      vsprintf
#define _vstprintf_s    vsprintf_s
#define _vsntprintf     _vsnprintf
#define _vsntprintf_s   _vsnprintf_s
#define _vsctprintf     _vscprintf
#define _tscanf         scanf
#define _tscanf_s       scanf_s
#define _ftscanf        fscanf
#define _ftscanf_s      fscanf_s
#define _stscanf        sscanf
#define _stscanf_s      sscanf_s

/* Unformatted i/o */
#define _fgettc         fgetc
#define _fgetts         fgets
#define _fputtc         fputc
#define _fputts         fputs
#define _gettc          getc
#define _gettchar       getchar
#define _getts          gets
#define _getts_s        gets_s
#define _puttc          putc
#define _puttchar       putchar
#define _putts          puts
#define _ungettc        ungetc

// Stdio functions
#define _tfopen         _fopen
#define _tfopen_s       _fopen_s

#ifndef UNDER_CE
// Not implemented for CE
#define _tfreopen       _freopen
#define _tfreopen_s     _freopen_s
#endif

// String conversion functions
#define _tcstod         strtod
#define _tcstol         strtol
#define _tcstoul        strtoul
#define _itot           _itoa
#define _itot_s         _itoa_s
#define _ltot           _ltoa
#define _ltot_s         _ltoa_s
#define _ultot          _ultoa
#define _ultot_s        _ultoa_s
#define _ttoi           atoi
#define _tstoi          atoi
#define _ttol           atol
#define _tstol          atol
#define _ttof           atof
#define _tstof          atof
#define _ttoi64         _atoi64
#define _tstoi64        _atoi64

/* String functions */
#define _tcscat         strcat
#define _tcscat_s       strcat_s
#define _tcschr         strchr
#define _tcscmp         strcmp
#define _tcscpy         strcpy
#define _tcscpy_s       strcpy_s
#define _tcscspn        strcspn
#define _tcslen         strlen
#define _tcsnlen        strnlen
#define _tcsclen        strlen

#define _tcsncat        strncat
#define _tcsncat_s      strncat_s
#define _tcsnccat       strncat
#define _tcsnccmp       strncmp
#define _tcsncmp        strncmp
#define _tcsncpy        strncpy
#define _tcsncpy_s      strncpy_s
#define _tcsnccpy       strncpy
#define _tcspbrk        strpbrk
#define _tcsrchr        strrchr
#define _tcsspn         strspn
#define _tcsstr         strstr
#define _tcstok         strtok
#define _tcstok_s       strtok_s
#define _tcsdup         _strdup
#define _tcsicmp        _stricmp
#define _tcsncicmp      _strnicmp
#define _tcsnicmp       _strnicmp
#define _tcsnset        _strnset
#define _tcsnset_s      _strnset_s
#define _tcsncset       _strnset
#define _tcsrev         _strrev
#define _tcsset         _strset
#define _tcsset_s       _strset_s
#define _tcslwr         _strlwr
#define _tcslwr_s       _strlwr_s
#define _tcsupr         _strupr
#define _tcsupr_s       _strupr_s

// ctype functions
#define _istalpha       isalpha
#define _istupper       isupper
#define _istlower       islower
#define _istdigit       isdigit
#define _istxdigit      isxdigit
#define _istspace       isspace
#define _istpunct       ispunct
#define _istalnum       isalnum
#define _istprint       isprint
#define _istgraph       isgraph
#define _istcntrl       iscntrl
#define _istascii       isascii

#define _totupper       toupper
#define _totlower       tolower

#define _istlegal(_c)       (1)
#define _istlead(_c)        (0)
#define _istleadbyte(_c)    (0)

#endif  /* UNICODE */

#ifdef __cplusplus
}
#endif

#endif  /* _INC_TCHAR */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\tcpmib.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++

Copyright (c) Microsoft Corporation

Module Name:

    tcpmib.h

Abstract:

    This module contains the public definitions and structures for the
    TCP-specific parts of MIB-II.  These definitions were previously
    in iprtrmib.h, which now includes this file.

Environment:

    user mode or kernel mode

--*/

#ifndef _TCPMIB_
#define _TCPMIB_
#pragma once

#ifndef ANY_SIZE
#define ANY_SIZE 1
#endif

#define TCPIP_OWNING_MODULE_SIZE 16

//
// TCP states, as defined in the MIB.
//
typedef enum {
    MIB_TCP_STATE_CLOSED     =  1,
    MIB_TCP_STATE_LISTEN     =  2,
    MIB_TCP_STATE_SYN_SENT   =  3,
    MIB_TCP_STATE_SYN_RCVD   =  4,
    MIB_TCP_STATE_ESTAB      =  5,
    MIB_TCP_STATE_FIN_WAIT1  =  6,
    MIB_TCP_STATE_FIN_WAIT2  =  7,
    MIB_TCP_STATE_CLOSE_WAIT =  8,
    MIB_TCP_STATE_CLOSING    =  9,
    MIB_TCP_STATE_LAST_ACK   = 10,
    MIB_TCP_STATE_TIME_WAIT  = 11,
    MIB_TCP_STATE_DELETE_TCB = 12,
} MIB_TCP_STATE;


//
// Various Offload states a TCP connection can be in.
//
typedef enum {
    TcpConnectionOffloadStateInHost,
    TcpConnectionOffloadStateOffloading,
    TcpConnectionOffloadStateOffloaded,
    TcpConnectionOffloadStateUploading,
    TcpConnectionOffloadStateMax
} TCP_CONNECTION_OFFLOAD_STATE, *PTCP_CONNECTION_OFFLOAD_STATE;

typedef struct _MIB_TCPROW_LH {
    union {
        DWORD dwState;       // Old field used DWORD type.
        MIB_TCP_STATE State; // New field uses enum type.
    };
    DWORD dwLocalAddr;
    DWORD dwLocalPort;
    DWORD dwRemoteAddr;
    DWORD dwRemotePort;
} MIB_TCPROW_LH, *PMIB_TCPROW_LH;

typedef struct _MIB_TCPROW_W2K {
    DWORD       dwState;
    DWORD       dwLocalAddr;
    DWORD       dwLocalPort;
    DWORD       dwRemoteAddr;
    DWORD       dwRemotePort;
} MIB_TCPROW_W2K, *PMIB_TCPROW_W2K;

#if (NTDDI_VERSION >= NTDDI_LONGHORN)
typedef MIB_TCPROW_LH MIB_TCPROW;
typedef MIB_TCPROW_LH *PMIB_TCPROW;
#elif (NTDDI_VERSION >= NTDDI_WIN2K)
typedef MIB_TCPROW_W2K MIB_TCPROW;
typedef MIB_TCPROW_W2K *PMIB_TCPROW;
#else
typedef MIB_TCPROW_LH MIB_TCPROW;
typedef MIB_TCPROW_LH *PMIB_TCPROW;
#endif

typedef struct _MIB_TCPTABLE {
    DWORD dwNumEntries;
    MIB_TCPROW table[ANY_SIZE];
} MIB_TCPTABLE, *PMIB_TCPTABLE;

#define SIZEOF_TCPTABLE(X) (FIELD_OFFSET(MIB_TCPTABLE,table[0]) + \
                            ((X) * sizeof(MIB_TCPROW)) + ALIGN_SIZE)

typedef struct _MIB_TCPROW2 {
    DWORD dwState;
    DWORD dwLocalAddr;
    DWORD dwLocalPort;
    DWORD dwRemoteAddr;
    DWORD dwRemotePort;
    DWORD dwOwningPid;
    TCP_CONNECTION_OFFLOAD_STATE dwOffloadState;
} MIB_TCPROW2, *PMIB_TCPROW2;

typedef struct _MIB_TCPTABLE2 {
    DWORD dwNumEntries;
    MIB_TCPROW2 table[ANY_SIZE];
} MIB_TCPTABLE2, *PMIB_TCPTABLE2;

#define SIZEOF_TCPTABLE2(X) (FIELD_OFFSET(MIB_TCPTABLE2,table[0]) + \
                            ((X) * sizeof(MIB_TCPROW2)) + ALIGN_SIZE)

typedef struct _MIB_TCPROW_OWNER_PID
{
    DWORD       dwState;
    DWORD       dwLocalAddr;
    DWORD       dwLocalPort;
    DWORD       dwRemoteAddr;
    DWORD       dwRemotePort;
    DWORD       dwOwningPid;
} MIB_TCPROW_OWNER_PID, *PMIB_TCPROW_OWNER_PID;

typedef struct _MIB_TCPTABLE_OWNER_PID
{
    DWORD                dwNumEntries;
    MIB_TCPROW_OWNER_PID table[ANY_SIZE];
} MIB_TCPTABLE_OWNER_PID, *PMIB_TCPTABLE_OWNER_PID;

#define SIZEOF_TCPTABLE_OWNER_PID(X) (FIELD_OFFSET(MIB_TCPTABLE_OWNER_PID, table[0]) + \
									  ((X) * sizeof(MIB_TCPROW_OWNER_PID)) + ALIGN_SIZE)


typedef struct _MIB_TCPROW_OWNER_MODULE
{
    DWORD           dwState;
    DWORD           dwLocalAddr;
    DWORD           dwLocalPort;
    DWORD           dwRemoteAddr;
    DWORD           dwRemotePort;
    DWORD           dwOwningPid;
    LARGE_INTEGER   liCreateTimestamp;
    ULONGLONG       OwningModuleInfo[TCPIP_OWNING_MODULE_SIZE];
} MIB_TCPROW_OWNER_MODULE, *PMIB_TCPROW_OWNER_MODULE;


typedef struct _MIB_TCPTABLE_OWNER_MODULE
{
    DWORD                   dwNumEntries;
    MIB_TCPROW_OWNER_MODULE table[ANY_SIZE];
} MIB_TCPTABLE_OWNER_MODULE, *PMIB_TCPTABLE_OWNER_MODULE;

#define SIZEOF_TCPTABLE_OWNER_MODULE(X) (FIELD_OFFSET(MIB_TCPTABLE_OWNER_MODULE, table[0]) + \
										 ((X) * sizeof(MIB_TCPROW_OWNER_MODULE)) + ALIGN_SIZE)

                            
#ifdef _WS2IPDEF_
//
// The following definitions require Winsock2.
//

typedef struct _MIB_TCP6ROW {
    MIB_TCP_STATE State;
    IN6_ADDR LocalAddr;
    DWORD dwLocalScopeId;
    DWORD dwLocalPort;
    IN6_ADDR RemoteAddr;
    DWORD dwRemoteScopeId;
    DWORD dwRemotePort;
} MIB_TCP6ROW, *PMIB_TCP6ROW;

typedef struct _MIB_TCP6TABLE {
    DWORD dwNumEntries;
    MIB_TCP6ROW table[ANY_SIZE];
} MIB_TCP6TABLE, *PMIB_TCP6TABLE;

#define SIZEOF_TCP6TABLE(X) (FIELD_OFFSET(MIB_TCP6TABLE,table[0]) + \
                             ((X) * sizeof(MIB_TCP6ROW)) + ALIGN_SIZE)

typedef struct _MIB_TCP6ROW2 {
    IN6_ADDR LocalAddr;
    DWORD dwLocalScopeId;
    DWORD dwLocalPort;
    IN6_ADDR RemoteAddr;
    DWORD dwRemoteScopeId;
    DWORD dwRemotePort;
    MIB_TCP_STATE State;
    DWORD dwOwningPid;
    TCP_CONNECTION_OFFLOAD_STATE dwOffloadState;
} MIB_TCP6ROW2, *PMIB_TCP6ROW2;

typedef struct _MIB_TCP6TABLE2 {
    DWORD dwNumEntries;
    MIB_TCP6ROW2 table[ANY_SIZE];
} MIB_TCP6TABLE2, *PMIB_TCP6TABLE2;

#define SIZEOF_TCP6TABLE2(X) (FIELD_OFFSET(MIB_TCP6TABLE2,table[0]) + \
							  ((X) * sizeof(MIB_TCP6ROW2)) + ALIGN_SIZE)


typedef struct _MIB_TCP6ROW_OWNER_PID
{
    UCHAR           ucLocalAddr[16];
    DWORD           dwLocalScopeId;
    DWORD           dwLocalPort;
    UCHAR           ucRemoteAddr[16];
    DWORD           dwRemoteScopeId;
    DWORD           dwRemotePort;
    DWORD           dwState;
    DWORD           dwOwningPid;
} MIB_TCP6ROW_OWNER_PID, *PMIB_TCP6ROW_OWNER_PID;

typedef struct _MIB_TCP6TABLE_OWNER_PID
{
    DWORD                   dwNumEntries;
    MIB_TCP6ROW_OWNER_PID   table[ANY_SIZE];
} MIB_TCP6TABLE_OWNER_PID, *PMIB_TCP6TABLE_OWNER_PID;

#define SIZEOF_TCP6TABLE_OWNER_PID(X) (FIELD_OFFSET(MIB_TCP6TABLE_OWNER_PID, table[0]) + \
									   ((X) * sizeof(MIB_TCP6ROW_OWNER_PID)) + ALIGN_SIZE)

typedef struct _MIB_TCP6ROW_OWNER_MODULE
{
    UCHAR           ucLocalAddr[16];
    DWORD           dwLocalScopeId;
    DWORD           dwLocalPort;
    UCHAR           ucRemoteAddr[16];
    DWORD           dwRemoteScopeId;
    DWORD           dwRemotePort;
    DWORD           dwState;
    DWORD           dwOwningPid;
    LARGE_INTEGER   liCreateTimestamp;
    ULONGLONG       OwningModuleInfo[TCPIP_OWNING_MODULE_SIZE];
} MIB_TCP6ROW_OWNER_MODULE, *PMIB_TCP6ROW_OWNER_MODULE;                             

typedef struct _MIB_TCP6TABLE_OWNER_MODULE
{
    DWORD                       dwNumEntries;
    MIB_TCP6ROW_OWNER_MODULE    table[ANY_SIZE];
} MIB_TCP6TABLE_OWNER_MODULE, *PMIB_TCP6TABLE_OWNER_MODULE;

#define SIZEOF_TCP6TABLE_OWNER_MODULE(X) (FIELD_OFFSET(MIB_TCP6TABLE_OWNER_MODULE, table[0]) + \
										  ((X) * sizeof(MIB_TCP6ROW_OWNER_MODULE)) + ALIGN_SIZE)

#endif // _WS2IPDEF_

#define MIB_TCP_MAXCONN_DYNAMIC ((ULONG)-1)

//
// The algorithm used to determine the timeout value used for retransmitting
// unacknowledged octets.
//
// REVIEW: This enum adds another version of the defines that already
// exist in iprtrmib.h (MIB_TCP_RTO_*).  Shouldn't we just use the
// public names that already exist?
//
typedef enum {
    TcpRtoAlgorithmOther,
    TcpRtoAlgorithmConstant,
    TcpRtoAlgorithmRsre,
    TcpRtoAlgorithmVanj,

    MIB_TCP_RTO_OTHER     = 1,
    MIB_TCP_RTO_CONSTANT  = 2,
    MIB_TCP_RTO_RSRE      = 3,
    MIB_TCP_RTO_VANJ      = 4,
} TCP_RTO_ALGORITHM, *PTCP_RTO_ALGORITHM;

typedef struct _MIB_TCPSTATS_LH {
    union {
        DWORD dwRtoAlgorithm;
        TCP_RTO_ALGORITHM RtoAlgorithm;
    };
    DWORD dwRtoMin;
    DWORD dwRtoMax;
    DWORD dwMaxConn;
    DWORD dwActiveOpens;
    DWORD dwPassiveOpens;
    DWORD dwAttemptFails;
    DWORD dwEstabResets;
    DWORD dwCurrEstab;
    DWORD dwInSegs;
    DWORD dwOutSegs;
    DWORD dwRetransSegs;
    DWORD dwInErrs;
    DWORD dwOutRsts;
    DWORD dwNumConns;
} MIB_TCPSTATS_LH, *PMIB_TCPSTATS_LH;

typedef struct _MIB_TCPSTATS_W2K {
    DWORD       dwRtoAlgorithm;
    DWORD       dwRtoMin;
    DWORD       dwRtoMax;
    DWORD       dwMaxConn;
    DWORD       dwActiveOpens;
    DWORD       dwPassiveOpens;
    DWORD       dwAttemptFails;
    DWORD       dwEstabResets;
    DWORD       dwCurrEstab;
    DWORD       dwInSegs;
    DWORD       dwOutSegs;
    DWORD       dwRetransSegs;
    DWORD       dwInErrs;
    DWORD       dwOutRsts;
    DWORD       dwNumConns;
} MIB_TCPSTATS_W2K, *PMIB_TCPSTATS_W2K;


#if (NTDDI_VERSION >= NTDDI_LONGHORN)
typedef MIB_TCPSTATS_LH MIB_TCPSTATS;
typedef MIB_TCPSTATS_LH *PMIB_TCPSTATS;
#elif (NTDDI_VERSION >= NTDDI_WIN2K)
typedef MIB_TCPSTATS_W2K MIB_TCPSTATS;
typedef MIB_TCPSTATS_W2K *PMIB_TCPSTATS;
#endif


#endif // _TCPMIB_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\tlog.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* at Tue Jan 23 14:31:26 2007
 */
/* Compiler settings for ..\tlog.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __tlog_h__
#define __tlog_h__

/* Forward Declarations */ 

#ifndef __ITravelEntry2_FWD_DEFINED__
#define __ITravelEntry2_FWD_DEFINED__
typedef interface ITravelEntry2 ITravelEntry2;
#endif 	/* __ITravelEntry2_FWD_DEFINED__ */


#ifndef __ITravelLogEx_FWD_DEFINED__
#define __ITravelLogEx_FWD_DEFINED__
typedef interface ITravelLogEx ITravelLogEx;
#endif 	/* __ITravelLogEx_FWD_DEFINED__ */


#ifndef __ITravelLog2_FWD_DEFINED__
#define __ITravelLog2_FWD_DEFINED__
typedef interface ITravelLog2 ITravelLog2;
#endif 	/* __ITravelLog2_FWD_DEFINED__ */


#ifndef __ITravelLogClientWrapper_FWD_DEFINED__
#define __ITravelLogClientWrapper_FWD_DEFINED__
typedef interface ITravelLogClientWrapper ITravelLogClientWrapper;
#endif 	/* __ITravelLogClientWrapper_FWD_DEFINED__ */


#ifndef __IShellTravelLogUI_FWD_DEFINED__
#define __IShellTravelLogUI_FWD_DEFINED__
typedef interface IShellTravelLogUI IShellTravelLogUI;
#endif 	/* __IShellTravelLogUI_FWD_DEFINED__ */


/* header files for imported files */
#include "ocidl.h"
#include "shtypes.h"
#include "tlogstg.h"
#include "shdeprecated.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_tlog_0000 */
/* [local] */ 

#define TLOGENTRYFLAG_TYPEDURL      0x00000001
#define TLOGENTRYFLAG_HUBPAGE       0x00000002
#define TLOGENTRYFLAG_SEARCHRESULT  0x00000004
#define TLOGENTRYFLAG_USERSET       0x40000000
#define TLOG_BACKEXTERNAL   -0x7fffffff


extern RPC_IF_HANDLE __MIDL_itf_tlog_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_tlog_0000_v0_0_s_ifspec;

#ifndef __ITravelEntry2_INTERFACE_DEFINED__
#define __ITravelEntry2_INTERFACE_DEFINED__

/* interface ITravelEntry2 */
/* [helpcontext][helpstring][hidden][object][uuid] */ 


EXTERN_C const IID IID_ITravelEntry2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ed4f9add-3cc4-46b7-a416-2ff54d7156bb")
    ITravelEntry2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddEntryFlags( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveEntryFlags( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEntryFlags( 
            /* [out] */ DWORD __RPC_FAR *pdwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITravelEntry2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITravelEntry2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITravelEntry2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITravelEntry2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddEntryFlags )( 
            ITravelEntry2 __RPC_FAR * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveEntryFlags )( 
            ITravelEntry2 __RPC_FAR * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEntryFlags )( 
            ITravelEntry2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwFlags);
        
        END_INTERFACE
    } ITravelEntry2Vtbl;

    interface ITravelEntry2
    {
        CONST_VTBL struct ITravelEntry2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITravelEntry2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITravelEntry2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITravelEntry2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITravelEntry2_AddEntryFlags(This,dwFlags)	\
    (This)->lpVtbl -> AddEntryFlags(This,dwFlags)

#define ITravelEntry2_RemoveEntryFlags(This,dwFlags)	\
    (This)->lpVtbl -> RemoveEntryFlags(This,dwFlags)

#define ITravelEntry2_GetEntryFlags(This,pdwFlags)	\
    (This)->lpVtbl -> GetEntryFlags(This,pdwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITravelEntry2_AddEntryFlags_Proxy( 
    ITravelEntry2 __RPC_FAR * This,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB ITravelEntry2_AddEntryFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITravelEntry2_RemoveEntryFlags_Proxy( 
    ITravelEntry2 __RPC_FAR * This,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB ITravelEntry2_RemoveEntryFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITravelEntry2_GetEntryFlags_Proxy( 
    ITravelEntry2 __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwFlags);


void __RPC_STUB ITravelEntry2_GetEntryFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITravelEntry2_INTERFACE_DEFINED__ */


#ifndef __ITravelLogEx_INTERFACE_DEFINED__
#define __ITravelLogEx_INTERFACE_DEFINED__

/* interface ITravelLogEx */
/* [helpcontext][helpstring][hidden][object][uuid] */ 


EXTERN_C const IID IID_ITravelLogEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f679-98b5-11cf-bb82-00aa00bdce0b")
    ITravelLogEx : public IUnknown
    {
    public:
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE FindTravelEntryWithUrl( 
            /* [in] */ IUnknown __RPC_FAR *punk,
            /* [in] */ UINT uiCP,
            /* [in] */ LPWSTR pszUrl,
            /* [out] */ ITravelEntry __RPC_FAR *__RPC_FAR *ppte) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE TravelToUrl( 
            /* [in] */ IUnknown __RPC_FAR *punk,
            /* [in] */ UINT uiCP,
            /* [in] */ LPWSTR pszUrl) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE DeleteIndexEntry( 
            /* [in] */ IUnknown __RPC_FAR *punk,
            /* [in] */ int index) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE DeleteUrlEntry( 
            /* [in] */ IUnknown __RPC_FAR *punk,
            /* [in] */ UINT uiCP,
            /* [in] */ LPWSTR pszUrl) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE CountEntryNodes( 
            /* [in] */ IUnknown __RPC_FAR *punk,
            /* [in] */ DWORD dwFlags,
            /* [out] */ DWORD __RPC_FAR *pdwCount) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE CreateEnumEntry( 
            /* [in] */ IUnknown __RPC_FAR *punk,
            /* [out] */ IEnumTravelLogEntry __RPC_FAR *__RPC_FAR *ppEnum,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE DeleteEntry( 
            /* [in] */ IUnknown __RPC_FAR *punk,
            /* [in] */ ITravelLogEntry __RPC_FAR *pte) = 0;
        
        virtual /* [local][helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE InsertEntry( 
            /* [in] */ IUnknown __RPC_FAR *punkBrowser,
            /* [in] */ ITravelLogEntry __RPC_FAR *pteRelativeTo,
            /* [in] */ BOOL fPrepend,
            /* [in] */ IUnknown __RPC_FAR *punkTLClient,
            /* [out] */ ITravelLogEntry __RPC_FAR *__RPC_FAR *ppEntry) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE TravelToEntry( 
            /* [in] */ IUnknown __RPC_FAR *punkBrowser,
            /* [in] */ ITravelLogEntry __RPC_FAR *pteDestination) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITravelLogExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITravelLogEx __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITravelLogEx __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITravelLogEx __RPC_FAR * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindTravelEntryWithUrl )( 
            ITravelLogEx __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *punk,
            /* [in] */ UINT uiCP,
            /* [in] */ LPWSTR pszUrl,
            /* [out] */ ITravelEntry __RPC_FAR *__RPC_FAR *ppte);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TravelToUrl )( 
            ITravelLogEx __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *punk,
            /* [in] */ UINT uiCP,
            /* [in] */ LPWSTR pszUrl);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteIndexEntry )( 
            ITravelLogEx __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *punk,
            /* [in] */ int index);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteUrlEntry )( 
            ITravelLogEx __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *punk,
            /* [in] */ UINT uiCP,
            /* [in] */ LPWSTR pszUrl);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CountEntryNodes )( 
            ITravelLogEx __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *punk,
            /* [in] */ DWORD dwFlags,
            /* [out] */ DWORD __RPC_FAR *pdwCount);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateEnumEntry )( 
            ITravelLogEx __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *punk,
            /* [out] */ IEnumTravelLogEntry __RPC_FAR *__RPC_FAR *ppEnum,
            /* [in] */ DWORD dwFlags);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteEntry )( 
            ITravelLogEx __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *punk,
            /* [in] */ ITravelLogEntry __RPC_FAR *pte);
        
        /* [local][helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InsertEntry )( 
            ITravelLogEx __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *punkBrowser,
            /* [in] */ ITravelLogEntry __RPC_FAR *pteRelativeTo,
            /* [in] */ BOOL fPrepend,
            /* [in] */ IUnknown __RPC_FAR *punkTLClient,
            /* [out] */ ITravelLogEntry __RPC_FAR *__RPC_FAR *ppEntry);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TravelToEntry )( 
            ITravelLogEx __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *punkBrowser,
            /* [in] */ ITravelLogEntry __RPC_FAR *pteDestination);
        
        END_INTERFACE
    } ITravelLogExVtbl;

    interface ITravelLogEx
    {
        CONST_VTBL struct ITravelLogExVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITravelLogEx_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITravelLogEx_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITravelLogEx_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITravelLogEx_FindTravelEntryWithUrl(This,punk,uiCP,pszUrl,ppte)	\
    (This)->lpVtbl -> FindTravelEntryWithUrl(This,punk,uiCP,pszUrl,ppte)

#define ITravelLogEx_TravelToUrl(This,punk,uiCP,pszUrl)	\
    (This)->lpVtbl -> TravelToUrl(This,punk,uiCP,pszUrl)

#define ITravelLogEx_DeleteIndexEntry(This,punk,index)	\
    (This)->lpVtbl -> DeleteIndexEntry(This,punk,index)

#define ITravelLogEx_DeleteUrlEntry(This,punk,uiCP,pszUrl)	\
    (This)->lpVtbl -> DeleteUrlEntry(This,punk,uiCP,pszUrl)

#define ITravelLogEx_CountEntryNodes(This,punk,dwFlags,pdwCount)	\
    (This)->lpVtbl -> CountEntryNodes(This,punk,dwFlags,pdwCount)

#define ITravelLogEx_CreateEnumEntry(This,punk,ppEnum,dwFlags)	\
    (This)->lpVtbl -> CreateEnumEntry(This,punk,ppEnum,dwFlags)

#define ITravelLogEx_DeleteEntry(This,punk,pte)	\
    (This)->lpVtbl -> DeleteEntry(This,punk,pte)

#define ITravelLogEx_InsertEntry(This,punkBrowser,pteRelativeTo,fPrepend,punkTLClient,ppEntry)	\
    (This)->lpVtbl -> InsertEntry(This,punkBrowser,pteRelativeTo,fPrepend,punkTLClient,ppEntry)

#define ITravelLogEx_TravelToEntry(This,punkBrowser,pteDestination)	\
    (This)->lpVtbl -> TravelToEntry(This,punkBrowser,pteDestination)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLogEx_FindTravelEntryWithUrl_Proxy( 
    ITravelLogEx __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *punk,
    /* [in] */ UINT uiCP,
    /* [in] */ LPWSTR pszUrl,
    /* [out] */ ITravelEntry __RPC_FAR *__RPC_FAR *ppte);


void __RPC_STUB ITravelLogEx_FindTravelEntryWithUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLogEx_TravelToUrl_Proxy( 
    ITravelLogEx __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *punk,
    /* [in] */ UINT uiCP,
    /* [in] */ LPWSTR pszUrl);


void __RPC_STUB ITravelLogEx_TravelToUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLogEx_DeleteIndexEntry_Proxy( 
    ITravelLogEx __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *punk,
    /* [in] */ int index);


void __RPC_STUB ITravelLogEx_DeleteIndexEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLogEx_DeleteUrlEntry_Proxy( 
    ITravelLogEx __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *punk,
    /* [in] */ UINT uiCP,
    /* [in] */ LPWSTR pszUrl);


void __RPC_STUB ITravelLogEx_DeleteUrlEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLogEx_CountEntryNodes_Proxy( 
    ITravelLogEx __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *punk,
    /* [in] */ DWORD dwFlags,
    /* [out] */ DWORD __RPC_FAR *pdwCount);


void __RPC_STUB ITravelLogEx_CountEntryNodes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLogEx_CreateEnumEntry_Proxy( 
    ITravelLogEx __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *punk,
    /* [out] */ IEnumTravelLogEntry __RPC_FAR *__RPC_FAR *ppEnum,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB ITravelLogEx_CreateEnumEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLogEx_DeleteEntry_Proxy( 
    ITravelLogEx __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *punk,
    /* [in] */ ITravelLogEntry __RPC_FAR *pte);


void __RPC_STUB ITravelLogEx_DeleteEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITravelLogEx_RemoteInsertEntry_Proxy( 
    ITravelLogEx __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *punkBrowser,
    /* [in] */ ITravelLogEntry __RPC_FAR *pteRelativeTo,
    /* [in] */ BOOL fPrepend,
    /* [in] */ IUnknown __RPC_FAR *punkTLClient,
    /* [out] */ ITravelLogEntry __RPC_FAR *__RPC_FAR *ppEntry);


void __RPC_STUB ITravelLogEx_RemoteInsertEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLogEx_TravelToEntry_Proxy( 
    ITravelLogEx __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *punkBrowser,
    /* [in] */ ITravelLogEntry __RPC_FAR *pteDestination);


void __RPC_STUB ITravelLogEx_TravelToEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITravelLogEx_INTERFACE_DEFINED__ */


#ifndef __ITravelLog2_INTERFACE_DEFINED__
#define __ITravelLog2_INTERFACE_DEFINED__

/* interface ITravelLog2 */
/* [helpcontext][helpstring][hidden][object][uuid] */ 


EXTERN_C const IID IID_ITravelLog2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0A46D8E2-2072-4AED-8509-BADB844E51F6")
    ITravelLog2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetJourneyOffset( 
            /* [out] */ int __RPC_FAR *pOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResetJourneyState( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FastBack( 
            /* [in] */ IUnknown __RPC_FAR *punkBrowser) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTypedNavigationPending( 
            /* [in] */ BOOL fPending) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFirstFastBackEntry( 
            /* [out] */ ITravelEntry __RPC_FAR *__RPC_FAR *ppte) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PopulateTravelLogUI( 
            /* [in] */ IUnknown __RPC_FAR *punkBrowser,
            /* [in] */ IUnknown __RPC_FAR *punkTravelLogUI,
            /* [in] */ int idFirst,
            /* [in] */ int idLast,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateEntry( 
            /* [in] */ IUnknown __RPC_FAR *punk,
            /* [in] */ BOOL fIsLocalAnchor,
            /* [in] */ BOOL fIsDocObjEntry) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITravelLog2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITravelLog2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITravelLog2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITravelLog2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetJourneyOffset )( 
            ITravelLog2 __RPC_FAR * This,
            /* [out] */ int __RPC_FAR *pOffset);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResetJourneyState )( 
            ITravelLog2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FastBack )( 
            ITravelLog2 __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *punkBrowser);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTypedNavigationPending )( 
            ITravelLog2 __RPC_FAR * This,
            /* [in] */ BOOL fPending);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFirstFastBackEntry )( 
            ITravelLog2 __RPC_FAR * This,
            /* [out] */ ITravelEntry __RPC_FAR *__RPC_FAR *ppte);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PopulateTravelLogUI )( 
            ITravelLog2 __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *punkBrowser,
            /* [in] */ IUnknown __RPC_FAR *punkTravelLogUI,
            /* [in] */ int idFirst,
            /* [in] */ int idLast,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateEntry )( 
            ITravelLog2 __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *punk,
            /* [in] */ BOOL fIsLocalAnchor,
            /* [in] */ BOOL fIsDocObjEntry);
        
        END_INTERFACE
    } ITravelLog2Vtbl;

    interface ITravelLog2
    {
        CONST_VTBL struct ITravelLog2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITravelLog2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITravelLog2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITravelLog2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITravelLog2_GetJourneyOffset(This,pOffset)	\
    (This)->lpVtbl -> GetJourneyOffset(This,pOffset)

#define ITravelLog2_ResetJourneyState(This)	\
    (This)->lpVtbl -> ResetJourneyState(This)

#define ITravelLog2_FastBack(This,punkBrowser)	\
    (This)->lpVtbl -> FastBack(This,punkBrowser)

#define ITravelLog2_SetTypedNavigationPending(This,fPending)	\
    (This)->lpVtbl -> SetTypedNavigationPending(This,fPending)

#define ITravelLog2_GetFirstFastBackEntry(This,ppte)	\
    (This)->lpVtbl -> GetFirstFastBackEntry(This,ppte)

#define ITravelLog2_PopulateTravelLogUI(This,punkBrowser,punkTravelLogUI,idFirst,idLast,dwFlags)	\
    (This)->lpVtbl -> PopulateTravelLogUI(This,punkBrowser,punkTravelLogUI,idFirst,idLast,dwFlags)

#define ITravelLog2_UpdateEntry(This,punk,fIsLocalAnchor,fIsDocObjEntry)	\
    (This)->lpVtbl -> UpdateEntry(This,punk,fIsLocalAnchor,fIsDocObjEntry)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITravelLog2_GetJourneyOffset_Proxy( 
    ITravelLog2 __RPC_FAR * This,
    /* [out] */ int __RPC_FAR *pOffset);


void __RPC_STUB ITravelLog2_GetJourneyOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITravelLog2_ResetJourneyState_Proxy( 
    ITravelLog2 __RPC_FAR * This);


void __RPC_STUB ITravelLog2_ResetJourneyState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITravelLog2_FastBack_Proxy( 
    ITravelLog2 __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *punkBrowser);


void __RPC_STUB ITravelLog2_FastBack_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITravelLog2_SetTypedNavigationPending_Proxy( 
    ITravelLog2 __RPC_FAR * This,
    /* [in] */ BOOL fPending);


void __RPC_STUB ITravelLog2_SetTypedNavigationPending_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITravelLog2_GetFirstFastBackEntry_Proxy( 
    ITravelLog2 __RPC_FAR * This,
    /* [out] */ ITravelEntry __RPC_FAR *__RPC_FAR *ppte);


void __RPC_STUB ITravelLog2_GetFirstFastBackEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITravelLog2_PopulateTravelLogUI_Proxy( 
    ITravelLog2 __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *punkBrowser,
    /* [in] */ IUnknown __RPC_FAR *punkTravelLogUI,
    /* [in] */ int idFirst,
    /* [in] */ int idLast,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB ITravelLog2_PopulateTravelLogUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITravelLog2_UpdateEntry_Proxy( 
    ITravelLog2 __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *punk,
    /* [in] */ BOOL fIsLocalAnchor,
    /* [in] */ BOOL fIsDocObjEntry);


void __RPC_STUB ITravelLog2_UpdateEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITravelLog2_INTERFACE_DEFINED__ */


#ifndef __ITravelLogClientWrapper_INTERFACE_DEFINED__
#define __ITravelLogClientWrapper_INTERFACE_DEFINED__

/* interface ITravelLogClientWrapper */
/* [helpcontext][helpstring][hidden][object][uuid] */ 


EXTERN_C const IID IID_ITravelLogClientWrapper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0AD364CE-ADCB-11d3-8269-00805FC732C0")
    ITravelLogClientWrapper : public IUnknown
    {
    public:
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetDummyWindowData( 
            /* [in] */ LPCWSTR pszUrl,
            /* [in] */ LPCWSTR pszTitle,
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [out] */ LPWINDOWDATA pWinData) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE FindWindowByIndex( 
            /* [in] */ DWORD dwID,
            /* [in] */ CLSID __RPC_FAR *pclsid,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITravelLogClientWrapperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITravelLogClientWrapper __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITravelLogClientWrapper __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITravelLogClientWrapper __RPC_FAR * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDummyWindowData )( 
            ITravelLogClientWrapper __RPC_FAR * This,
            /* [in] */ LPCWSTR pszUrl,
            /* [in] */ LPCWSTR pszTitle,
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [out] */ LPWINDOWDATA pWinData);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindWindowByIndex )( 
            ITravelLogClientWrapper __RPC_FAR * This,
            /* [in] */ DWORD dwID,
            /* [in] */ CLSID __RPC_FAR *pclsid,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk);
        
        END_INTERFACE
    } ITravelLogClientWrapperVtbl;

    interface ITravelLogClientWrapper
    {
        CONST_VTBL struct ITravelLogClientWrapperVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITravelLogClientWrapper_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITravelLogClientWrapper_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITravelLogClientWrapper_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITravelLogClientWrapper_GetDummyWindowData(This,pszUrl,pszTitle,pStream,pWinData)	\
    (This)->lpVtbl -> GetDummyWindowData(This,pszUrl,pszTitle,pStream,pWinData)

#define ITravelLogClientWrapper_FindWindowByIndex(This,dwID,pclsid,ppunk)	\
    (This)->lpVtbl -> FindWindowByIndex(This,dwID,pclsid,ppunk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLogClientWrapper_GetDummyWindowData_Proxy( 
    ITravelLogClientWrapper __RPC_FAR * This,
    /* [in] */ LPCWSTR pszUrl,
    /* [in] */ LPCWSTR pszTitle,
    /* [in] */ IStream __RPC_FAR *pStream,
    /* [out] */ LPWINDOWDATA pWinData);


void __RPC_STUB ITravelLogClientWrapper_GetDummyWindowData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLogClientWrapper_FindWindowByIndex_Proxy( 
    ITravelLogClientWrapper __RPC_FAR * This,
    /* [in] */ DWORD dwID,
    /* [in] */ CLSID __RPC_FAR *pclsid,
    /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk);


void __RPC_STUB ITravelLogClientWrapper_FindWindowByIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITravelLogClientWrapper_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_tlog_0568 */
/* [local] */ 

#define STLUI_FLAG_CURRENT      0x00000001
#define STLUI_FLAG_BACK         0x00000002
#define STLUI_FLAG_FORWARD      0x00000004
#define STLUI_ID_SHOWHISTORY    600


extern RPC_IF_HANDLE __MIDL_itf_tlog_0568_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_tlog_0568_v0_0_s_ifspec;

#ifndef __IShellTravelLogUI_INTERFACE_DEFINED__
#define __IShellTravelLogUI_INTERFACE_DEFINED__

/* interface IShellTravelLogUI */
/* [unique][helpcontext][helpstring][object][uuid] */ 


EXTERN_C const IID IID_IShellTravelLogUI;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DB126A9B-7868-43A3-82E7-5364A3A1A541")
    IShellTravelLogUI : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddTravelLogItem( 
            /* [in] */ LONG nItemID,
            /* [in] */ LPCWSTR pszTitle,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShowTravelLog( 
            /* [in] */ int x,
            /* [in] */ int y,
            /* [in] */ HWND hwndParent,
            /* [in] */ LPCRECT prcExclude,
            /* [out] */ LONG __RPC_FAR *pnItemID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellTravelLogUIVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IShellTravelLogUI __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IShellTravelLogUI __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IShellTravelLogUI __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IShellTravelLogUI __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddTravelLogItem )( 
            IShellTravelLogUI __RPC_FAR * This,
            /* [in] */ LONG nItemID,
            /* [in] */ LPCWSTR pszTitle,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShowTravelLog )( 
            IShellTravelLogUI __RPC_FAR * This,
            /* [in] */ int x,
            /* [in] */ int y,
            /* [in] */ HWND hwndParent,
            /* [in] */ LPCRECT prcExclude,
            /* [out] */ LONG __RPC_FAR *pnItemID);
        
        END_INTERFACE
    } IShellTravelLogUIVtbl;

    interface IShellTravelLogUI
    {
        CONST_VTBL struct IShellTravelLogUIVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellTravelLogUI_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellTravelLogUI_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellTravelLogUI_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellTravelLogUI_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IShellTravelLogUI_AddTravelLogItem(This,nItemID,pszTitle,dwFlags)	\
    (This)->lpVtbl -> AddTravelLogItem(This,nItemID,pszTitle,dwFlags)

#define IShellTravelLogUI_ShowTravelLog(This,x,y,hwndParent,prcExclude,pnItemID)	\
    (This)->lpVtbl -> ShowTravelLog(This,x,y,hwndParent,prcExclude,pnItemID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IShellTravelLogUI_Reset_Proxy( 
    IShellTravelLogUI __RPC_FAR * This);


void __RPC_STUB IShellTravelLogUI_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellTravelLogUI_AddTravelLogItem_Proxy( 
    IShellTravelLogUI __RPC_FAR * This,
    /* [in] */ LONG nItemID,
    /* [in] */ LPCWSTR pszTitle,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IShellTravelLogUI_AddTravelLogItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellTravelLogUI_ShowTravelLog_Proxy( 
    IShellTravelLogUI __RPC_FAR * This,
    /* [in] */ int x,
    /* [in] */ int y,
    /* [in] */ HWND hwndParent,
    /* [in] */ LPCRECT prcExclude,
    /* [out] */ LONG __RPC_FAR *pnItemID);


void __RPC_STUB IShellTravelLogUI_ShowTravelLog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellTravelLogUI_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long __RPC_FAR *, HWND __RPC_FAR * ); 

unsigned long             __RPC_USER  PIDLIST_ABSOLUTE_UserSize(     unsigned long __RPC_FAR *, unsigned long            , PIDLIST_ABSOLUTE __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  PIDLIST_ABSOLUTE_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, PIDLIST_ABSOLUTE __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  PIDLIST_ABSOLUTE_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, PIDLIST_ABSOLUTE __RPC_FAR * ); 
void                      __RPC_USER  PIDLIST_ABSOLUTE_UserFree(     unsigned long __RPC_FAR *, PIDLIST_ABSOLUTE __RPC_FAR * ); 

/* [local][helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLogEx_InsertEntry_Proxy( 
    ITravelLogEx __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *punkBrowser,
    /* [in] */ ITravelLogEntry __RPC_FAR *pteRelativeTo,
    /* [in] */ BOOL fPrepend,
    /* [in] */ IUnknown __RPC_FAR *punkTLClient,
    /* [out] */ ITravelLogEntry __RPC_FAR *__RPC_FAR *ppEntry);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITravelLogEx_InsertEntry_Stub( 
    ITravelLogEx __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *punkBrowser,
    /* [in] */ ITravelLogEntry __RPC_FAR *pteRelativeTo,
    /* [in] */ BOOL fPrepend,
    /* [in] */ IUnknown __RPC_FAR *punkTLClient,
    /* [out] */ ITravelLogEntry __RPC_FAR *__RPC_FAR *ppEntry);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\tlogstg.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* at Tue Jan 23 14:31:30 2007
 */
/* Compiler settings for ..\tlogstg.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __tlogstg_h__
#define __tlogstg_h__

/* Forward Declarations */ 

#ifndef __ITravelLogEntry_FWD_DEFINED__
#define __ITravelLogEntry_FWD_DEFINED__
typedef interface ITravelLogEntry ITravelLogEntry;
#endif 	/* __ITravelLogEntry_FWD_DEFINED__ */


#ifndef __ITravelLogClient_FWD_DEFINED__
#define __ITravelLogClient_FWD_DEFINED__
typedef interface ITravelLogClient ITravelLogClient;
#endif 	/* __ITravelLogClient_FWD_DEFINED__ */


#ifndef __IEnumTravelLogEntry_FWD_DEFINED__
#define __IEnumTravelLogEntry_FWD_DEFINED__
typedef interface IEnumTravelLogEntry IEnumTravelLogEntry;
#endif 	/* __IEnumTravelLogEntry_FWD_DEFINED__ */


#ifndef __ITravelLogStg_FWD_DEFINED__
#define __ITravelLogStg_FWD_DEFINED__
typedef interface ITravelLogStg ITravelLogStg;
#endif 	/* __ITravelLogStg_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oleidl.h"
#include "shtypes.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_tlogstg_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// tlogstg.h
//=--------------------------------------------------------------------------=
// Copyright (c) Microsoft Corporation. All rights reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// ITravelLogStg Interface.

#define SID_STravelLogCursor IID_ITravelLogStg 
typedef struct _WINDOWDATA
    {
    DWORD dwWindowID;
    UINT uiCP;
    PIDLIST_ABSOLUTE pidl;
    /* [string] */ LPWSTR lpszUrl;
    /* [string] */ LPWSTR lpszUrlLocation;
    /* [string] */ LPWSTR lpszTitle;
    }	WINDOWDATA;

typedef WINDOWDATA __RPC_FAR *LPWINDOWDATA;

typedef const WINDOWDATA __RPC_FAR *LPCWINDOWDATA;



extern RPC_IF_HANDLE __MIDL_itf_tlogstg_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_tlogstg_0000_v0_0_s_ifspec;

#ifndef __ITravelLogEntry_INTERFACE_DEFINED__
#define __ITravelLogEntry_INTERFACE_DEFINED__

/* interface ITravelLogEntry */
/* [helpstring][uuid][object] */ 


EXTERN_C const IID IID_ITravelLogEntry;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7EBFDD87-AD18-11d3-A4C5-00C04F72D6B8")
    ITravelLogEntry : public IUnknown
    {
    public:
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetTitle( 
            /* [out] */ LPWSTR __RPC_FAR *ppszTitle) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetURL( 
            /* [out] */ LPWSTR __RPC_FAR *ppszURL) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITravelLogEntryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITravelLogEntry __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITravelLogEntry __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITravelLogEntry __RPC_FAR * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTitle )( 
            ITravelLogEntry __RPC_FAR * This,
            /* [out] */ LPWSTR __RPC_FAR *ppszTitle);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetURL )( 
            ITravelLogEntry __RPC_FAR * This,
            /* [out] */ LPWSTR __RPC_FAR *ppszURL);
        
        END_INTERFACE
    } ITravelLogEntryVtbl;

    interface ITravelLogEntry
    {
        CONST_VTBL struct ITravelLogEntryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITravelLogEntry_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITravelLogEntry_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITravelLogEntry_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITravelLogEntry_GetTitle(This,ppszTitle)	\
    (This)->lpVtbl -> GetTitle(This,ppszTitle)

#define ITravelLogEntry_GetURL(This,ppszURL)	\
    (This)->lpVtbl -> GetURL(This,ppszURL)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLogEntry_GetTitle_Proxy( 
    ITravelLogEntry __RPC_FAR * This,
    /* [out] */ LPWSTR __RPC_FAR *ppszTitle);


void __RPC_STUB ITravelLogEntry_GetTitle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLogEntry_GetURL_Proxy( 
    ITravelLogEntry __RPC_FAR * This,
    /* [out] */ LPWSTR __RPC_FAR *ppszURL);


void __RPC_STUB ITravelLogEntry_GetURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITravelLogEntry_INTERFACE_DEFINED__ */


#ifndef __ITravelLogClient_INTERFACE_DEFINED__
#define __ITravelLogClient_INTERFACE_DEFINED__

/* interface ITravelLogClient */
/* [helpcontext][helpstring][object][uuid] */ 


EXTERN_C const IID IID_ITravelLogClient;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("241c033e-e659-43da-aa4d-4086dbc4758d")
    ITravelLogClient : public IUnknown
    {
    public:
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE FindWindowByIndex( 
            /* [in] */ DWORD dwID,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetWindowData( 
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [out] */ LPWINDOWDATA pWinData) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE LoadHistoryPosition( 
            /* [in] */ LPWSTR pszUrlLocation,
            /* [in] */ DWORD dwPosition) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITravelLogClientVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITravelLogClient __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITravelLogClient __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITravelLogClient __RPC_FAR * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindWindowByIndex )( 
            ITravelLogClient __RPC_FAR * This,
            /* [in] */ DWORD dwID,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWindowData )( 
            ITravelLogClient __RPC_FAR * This,
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [out] */ LPWINDOWDATA pWinData);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadHistoryPosition )( 
            ITravelLogClient __RPC_FAR * This,
            /* [in] */ LPWSTR pszUrlLocation,
            /* [in] */ DWORD dwPosition);
        
        END_INTERFACE
    } ITravelLogClientVtbl;

    interface ITravelLogClient
    {
        CONST_VTBL struct ITravelLogClientVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITravelLogClient_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITravelLogClient_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITravelLogClient_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITravelLogClient_FindWindowByIndex(This,dwID,ppunk)	\
    (This)->lpVtbl -> FindWindowByIndex(This,dwID,ppunk)

#define ITravelLogClient_GetWindowData(This,pStream,pWinData)	\
    (This)->lpVtbl -> GetWindowData(This,pStream,pWinData)

#define ITravelLogClient_LoadHistoryPosition(This,pszUrlLocation,dwPosition)	\
    (This)->lpVtbl -> LoadHistoryPosition(This,pszUrlLocation,dwPosition)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLogClient_FindWindowByIndex_Proxy( 
    ITravelLogClient __RPC_FAR * This,
    /* [in] */ DWORD dwID,
    /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk);


void __RPC_STUB ITravelLogClient_FindWindowByIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLogClient_GetWindowData_Proxy( 
    ITravelLogClient __RPC_FAR * This,
    /* [in] */ IStream __RPC_FAR *pStream,
    /* [out] */ LPWINDOWDATA pWinData);


void __RPC_STUB ITravelLogClient_GetWindowData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLo