/ The DAO state is store in the module state
	AFX_MODULE_STATE* pModuleState = AfxGetModuleState();
	_AFX_DAO_STATE* pDaoState = pModuleState->m_pDaoState;

	// Allocate a new DAO state if necessary
	if (pDaoState == NULL)
	{
		pDaoState = new _AFX_DAO_STATE;
		pModuleState->m_pDaoState = pDaoState;
	}
	return pDaoState;
}


//////////////////////////////////////////////////////////////////////////////
// DAODBEngine helpers
void AFXAPI AfxDaoInit()
{
	_AFX_DAO_STATE* pDaoState = AfxGetDaoState();

	// Attempt to initialize OLE component objects
	//  (use default IMalloc allocator)
	DAO_CHECK_ERROR(::CoInitialize(NULL),
		AFX_DAO_ERROR_ENGINE_INITIALIZATION);
	pDaoState->m_bOleInitialized = TRUE;

	// Hook AfxDaoTerm to CWinApp, otherwise explicit AfxDaoTerm call req'd
	CWinApp* pApp = AfxGetApp();
	if (pApp != NULL)
		pApp->m_lpfnDaoTerm = AfxDaoTerm;

	// Set the interface type
#ifdef _UNICODE
	const GUID& guidEngine = IID_IDAODBEngineW;
#else
	const GUID& guidEngine = IID_IDAODBEngine;
#endif

	// DAO 3.5 and 3.6 runtime key
	COleVariant varKey = _T("mbmabptebkjcdlgtjmskjwtsdhjbmkmwtrak");

	LPCLASSFACTORY2 pCF2;
	DAO_CHECK_ERROR(::CoGetClassObject(CLSID_CDAODBEngine,
		CLSCTX_INPROC_SERVER, NULL, IID_IClassFactory2, (LPVOID*)&pCF2),
		AFX_DAO_ERROR_ENGINE_INITIALIZATION);

	TRY
	{
		DAO_CHECK_ERROR(pCF2->CreateInstanceLic( NULL, NULL, guidEngine,
			V_BSTR(&varKey), (LPVOID*)&pDaoState->m_pDAODBEngine),
			AFX_DAO_ERROR_ENGINE_INITIALIZATION);
	}
	CATCH_ALL(e)
	{
		pCF2->Release();
		THROW_LAST();
	}
	END_CATCH_ALL

	pCF2->Release();
}

DAODBEngine* AFXAPI AfxDaoGetEngine()
{
	// Return DAODBEngine object for direct access
	return AfxGetDaoState()->m_pDAODBEngine;
}

void AFXAPI AfxDaoTerm()
{
	_AFX_DAO_STATE* pDaoState = AfxGetDaoState();

	// Close any CDaoWorkspaces left around
	void* pvKey;
	void* pvObject;
	POSITION pos = pDaoState->m_mapWorkspaces.GetStartPosition();
	while (pos != NULL)
	{
		pDaoState->m_mapWorkspaces.GetNextAssoc(pos, pvKey, pvObject);
		((CDaoWorkspace*)pvObject)->Close();
	}
	pDaoState->m_mapWorkspaces.RemoveAll();

	// Clean up engine object if necessary
	if (pDaoState->m_pDAODBEngine != NULL)
	{
		pDaoState->m_pDAODBEngine->Release();
		pDaoState->m_pDAODBEngine = NULL;
	}

	// Shutdown OLE component objects if necessary
	if (pDaoState->m_bOleInitialized)
	{
		::CoUninitialize();
		pDaoState->m_bOleInitialized = FALSE;
	}

	// If hooked up to CWinApp, make sure to unhook
	CWinApp* pApp = AfxGetApp();
	if (pApp != NULL)
		pApp->m_lpfnDaoTerm = NULL;
}


//////////////////////////////////////////////////////////////////////////////
// Inline function declarations expanded out-of-line

#ifndef _AFX_ENABLE_INLINES

#define _AFXDAOCORE_INLINE
#include "afxdao.inl"

#endif


#pragma warning(disable: 4074)
#pragma init_seg(lib)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\daoview.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "sal.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CDaoRecordView, CFormView)

BEGIN_MESSAGE_MAP(CDaoRecordView, CFormView)
	//{{AFX_MSG_MAP(CDaoRecordView)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
	ON_COMMAND_EX(ID_RECORD_FIRST, &CDaoRecordView::OnMove)
	ON_UPDATE_COMMAND_UI(ID_RECORD_FIRST, &CDaoRecordView::OnUpdateRecordFirst)
	ON_COMMAND_EX(ID_RECORD_PREV, &CDaoRecordView::OnMove)
	ON_UPDATE_COMMAND_UI(ID_RECORD_PREV, &CDaoRecordView::OnUpdateRecordPrev)
	ON_COMMAND_EX(ID_RECORD_NEXT, &CDaoRecordView::OnMove)
	ON_UPDATE_COMMAND_UI(ID_RECORD_NEXT, &CDaoRecordView::OnUpdateRecordNext)
	ON_COMMAND_EX(ID_RECORD_LAST, &CDaoRecordView::OnMove)
	ON_UPDATE_COMMAND_UI(ID_RECORD_LAST, &CDaoRecordView::OnUpdateRecordLast)
END_MESSAGE_MAP()

CDaoRecordView::CDaoRecordView(LPCTSTR lpszTemplateName)
	: CFormView(lpszTemplateName)
{
	m_nStatus = 0;

	// Setup dummy bookmarks
	m_varBookmarkCurrent = 1L;
	m_varBookmarkFirst = m_varBookmarkLast = 0L;
}

CDaoRecordView::CDaoRecordView(UINT nIDTemplate)
	: CFormView(nIDTemplate)
{
	m_nStatus = 0;

	// Setup dummy bookmarks
	m_varBookmarkCurrent = 1L;
	m_varBookmarkFirst = m_varBookmarkLast = 0L;
}

CDaoRecordView::~CDaoRecordView()
{
}

void CDaoRecordView::OnInitialUpdate()
{
	ASSERT_VALID(this);

	CDaoRecordset* pRecordset = OnGetRecordset();
	// recordset must be allocated already
	ASSERT(pRecordset != NULL);

	if (!pRecordset->IsOpen())
	{
		CWaitCursor wait;
		pRecordset->Open();
	}

	if (!pRecordset->IsEOF())
	{
		// Determine recordset properties for move button enabling
		if (pRecordset->CanBookmark())
		{
			// Get the bookmark of the first record
			m_varBookmarkCurrent = pRecordset->GetBookmark();
			m_varBookmarkFirst = m_varBookmarkCurrent;
		}

		// Enable forward scrolling buttons
		m_nStatus |= AFX_DAOVIEW_SCROLL_NEXT;

		// Enable backward scrolling buttons if possible
		if (pRecordset->CanScroll())
		{
			m_nStatus |= AFX_DAOVIEW_SCROLL_LAST;
			m_nStatus |= AFX_DAOVIEW_SCROLL_BACKWARD;
		}
		else
		{
			m_nStatus &= ~AFX_DAOVIEW_SCROLL_LAST;
			m_nStatus &= ~AFX_DAOVIEW_SCROLL_BACKWARD;
		}
	}
	else
	{
		// Disable scrolling
		m_nStatus &= ~AFX_DAOVIEW_SCROLL_NEXT;
		m_nStatus &= ~AFX_DAOVIEW_SCROLL_LAST;
		m_nStatus &= ~AFX_DAOVIEW_SCROLL_BACKWARD;
	}

	CFormView::OnInitialUpdate();
}

BOOL CDaoRecordView::OnMove(UINT nIDMoveCommand)
{
	ASSERT_VALID(this);

	CDaoRecordset* pSet = OnGetRecordset();
	if (pSet->CanUpdate())
	{
		pSet->Edit();
		if (!UpdateData())
			return TRUE;

		if (pSet->IsFieldDirty(NULL))
			pSet->Update();
		else
			pSet->CancelUpdate();
	}

	BOOL bBookmarkable = pSet->CanBookmark();
	BOOL bScrollable = pSet->CanScroll();

	switch (nIDMoveCommand)
	{
		case ID_RECORD_PREV:
			pSet->MovePrev();

			if (!pSet->IsBOF())
			{
				if (bBookmarkable)
					m_varBookmarkCurrent = pSet->GetBookmark();

				// Enable forward scrolling
				m_nStatus |= AFX_DAOVIEW_SCROLL_NEXT;

				if (bScrollable)
				{
					m_nStatus |= AFX_DAOVIEW_SCROLL_LAST;

					if (IsOnFirstRecord())
						// Disable backward scrolling
						m_nStatus &= ~AFX_DAOVIEW_SCROLL_BACKWARD;
					else
						m_nStatus |= AFX_DAOVIEW_SCROLL_BACKWARD;
				}
				else
				{
					m_nStatus &= ~AFX_DAOVIEW_SCROLL_LAST;
					m_nStatus &= ~AFX_DAOVIEW_SCROLL_BACKWARD;
				}


				break;
			}
			// Fall through to reset to first record

		case ID_RECORD_FIRST:
			pSet->MoveFirst();

			// backward scrolling never allowed after movefirst
			m_nStatus &= ~AFX_DAOVIEW_SCROLL_BACKWARD;

			if (pSet->IsEOF())
			{
				// Empty recordset, disable forward too
				m_nStatus &= ~AFX_DAOVIEW_SCROLL_NEXT;
				m_nStatus &= ~AFX_DAOVIEW_SCROLL_LAST;
			}
			else
			{
				if (bBookmarkable)
				{
					m_varBookmarkCurrent = pSet->GetBookmark();
					m_varBookmarkFirst = m_varBookmarkCurrent;
				}

				// Enable forward scrolling
				m_nStatus |= AFX_DAOVIEW_SCROLL_NEXT;

				if (bScrollable)
					m_nStatus |= AFX_DAOVIEW_SCROLL_LAST;
				else
					m_nStatus &= ~AFX_DAOVIEW_SCROLL_LAST;
			}

			break;

		case ID_RECORD_NEXT:
			pSet->MoveNext();

			if (!pSet->IsEOF())
			{
				if (bBookmarkable)
					m_varBookmarkCurrent = pSet->GetBookmark();

				if (IsOnLastRecord())
				{
					// Disable forward scrolling
					m_nStatus &= ~AFX_DAOVIEW_SCROLL_NEXT;
					m_nStatus &= ~AFX_DAOVIEW_SCROLL_LAST;
				}
				else
				{
					m_nStatus |= AFX_DAOVIEW_SCROLL_NEXT;
					m_nStatus |= AFX_DAOVIEW_SCROLL_LAST;
				}

				if (bScrollable)
					m_nStatus |= AFX_DAOVIEW_SCROLL_BACKWARD;
				else
				{
					m_nStatus &= ~AFX_DAOVIEW_SCROLL_LAST;
					m_nStatus &= ~AFX_DAOVIEW_SCROLL_BACKWARD;
				}

				break;
			}

			// Can't fall through to move last
			if (!bScrollable)
			{
				// At the end of forward only recordset
				m_nStatus &= ~AFX_DAOVIEW_SCROLL_NEXT;
				m_nStatus &= ~AFX_DAOVIEW_SCROLL_LAST;
				m_nStatus &= ~AFX_DAOVIEW_SCROLL_BACKWARD;
				break;
			}

			// Fall through to reset to last record

		case ID_RECORD_LAST:
			pSet->MoveLast();

			// forward scrolling never allowed after movelast
			m_nStatus &= ~AFX_DAOVIEW_SCROLL_NEXT;
			m_nStatus &= ~AFX_DAOVIEW_SCROLL_LAST;

			if (pSet->IsBOF())
			{
				// Empty recordset, disable backward too
				m_nStatus &= ~AFX_DAOVIEW_SCROLL_BACKWARD;
			}
			else
			{
				if (bBookmarkable)
				{
					m_varBookmarkCurrent = pSet->GetBookmark();
					m_varBookmarkLast = m_varBookmarkCurrent;
				}

				// Enable backward scrolling
				if (bBookmarkable)
					m_nStatus |= AFX_DAOVIEW_SCROLL_BACKWARD;
				else
					m_nStatus &= ~AFX_DAOVIEW_SCROLL_BACKWARD;
			}

			break;

		default:
			// Unexpected case value
			ASSERT(FALSE);
	}

	// Show results of move operation
	UpdateData(FALSE);
	return TRUE;
}

BOOL CDaoRecordView::IsOnFirstRecord()
{
	ASSERT_VALID(this);
	return (m_varBookmarkCurrent == m_varBookmarkFirst);
}

BOOL CDaoRecordView::IsOnLastRecord()
{
	ASSERT_VALID(this);
	return (m_varBookmarkCurrent == m_varBookmarkLast);
}

/////////////////////////////////////////////////////////////////////////////
// DDX Cover functions for use with fields of a recordset

/////////////////////////////////////////////////////////////////////////////
// Simple field formatting to text item

BOOL AFXAPI AfxFieldText(CDataExchange* pDX, int nIDC, void* pv,
	CDaoRecordset* pRecordset)
{
	ASSERT_VALID(pRecordset);

	HWND hWndCtrl = pDX->PrepareEditCtrl(nIDC);
	TCHAR szT[2];
	if (pDX->m_bSaveAndValidate)
	{
		::GetWindowText(hWndCtrl, szT, _countof(szT));
		if (szT[0] == '\0')
		{
			// If edit buffer not NULL prior to update, set it dirty
			// to catch case of setting field value from PSEUDO NULL to NULL.
			if (!pRecordset->IsFieldNull(pv))
				pRecordset->SetFieldDirty(pv, TRUE);
			pRecordset->SetFieldNull(pv);
			return TRUE;
		}
		else
		{
			// If edit buffer NULL prior to update, set it dirty
			// to catch case of setting field value to PSEUDO NULL.
			if (pRecordset->IsFieldNull(pv))
				pRecordset->SetFieldDirty(pv, TRUE);
			pRecordset->SetFieldNull(pv, FALSE);
		}
	}
	else
	{
		if (!pRecordset->IsOpen() || pRecordset->IsFieldNull(pv))
		{
			szT[0] = '\0';
			AfxSetWindowText(hWndCtrl, szT);
			return TRUE;
		}
	}
	return FALSE;
}

void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, BOOL& value,
	CDaoRecordset* pRecordset)
{
	if (!AfxFieldText(pDX, nIDC, &value, pRecordset))
		DDX_Text(pDX, nIDC, value);
}

void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, BYTE& value,
	CDaoRecordset* pRecordset)
{
	if (!AfxFieldText(pDX, nIDC, &value, pRecordset))
		DDX_Text(pDX, nIDC, value);
}

void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, short& value,
	CDaoRecordset* pRecordset)
{
	if (!AfxFieldText(pDX, nIDC, &value, pRecordset))
		DDX_Text(pDX, nIDC, value);
}

void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, long& value,
	CDaoRecordset* pRecordset)
{
	if (!AfxFieldText(pDX, nIDC, &value, pRecordset))
		DDX_Text(pDX, nIDC, value);
}

void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, DWORD& value,
	CDaoRecordset* pRecordset)
{
	if (!AfxFieldText(pDX, nIDC, &value, pRecordset))
		DDX_Text(pDX, nIDC, value);
}

void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, COleCurrency& value,
	CDaoRecordset* pRecordset)
{
	if (!AfxFieldText(pDX, nIDC, &value, pRecordset))
		DDX_Text(pDX, nIDC, value);
}

void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, float& value,
	CDaoRecordset* pRecordset)
{
	if (!AfxFieldText(pDX, nIDC, &value, pRecordset))
		DDX_Text(pDX, nIDC, value);
}

void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, double& value,
	CDaoRecordset* pRecordset)
{
	if (!AfxFieldText(pDX, nIDC, &value, pRecordset))
		DDX_Text(pDX, nIDC, value);
}

void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, COleDateTime& value,
	CDaoRecordset* pRecordset)
{
	if (!AfxFieldText(pDX, nIDC, &value, pRecordset))
		DDX_Text(pDX, nIDC, value);
}

void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, CString &value,
	CDaoRecordset* pRecordset)
{
	if (!AfxFieldText(pDX, nIDC, &value, pRecordset))
		DDX_Text(pDX, nIDC, value);
}

void AFXAPI DDX_FieldText(_In_ CDataExchange* pDX, _In_ int nIDC, _Out_z_cap_(nMaxLen) LPTSTR pstrValue,
	_In_ int nMaxLen, _In_ CDaoRecordset* pRecordset)
{
	if (!AfxFieldText(pDX, nIDC, &pstrValue, pRecordset))
		DDX_Text(pDX, nIDC, pstrValue, nMaxLen);
}

void AFXAPI DDX_FieldLBString(CDataExchange* pDX, int nIDC, CString& value,
	CDaoRecordset* pRecordset)
{
	ASSERT_VALID(pRecordset);

	HWND hWndCtrl = pDX->PrepareCtrl(nIDC);
	if (pDX->m_bSaveAndValidate)
	{
		int nIndex = (int)::SendMessage(hWndCtrl, LB_GETCURSEL, 0, 0L);
		if (nIndex != -1)
		{
			int nLen = (int)::SendMessage(hWndCtrl, LB_GETTEXTLEN, nIndex, 0L);
			::SendMessage(hWndCtrl, LB_GETTEXT, nIndex,
					(LPARAM)(LPSTR)value.GetBuffer(nLen));
			if (nLen == 0)
			{
				if (pRecordset->IsFieldNullable(&value))
					pRecordset->SetFieldNull(&value, TRUE);
			}
			else
			{
				pRecordset->SetFieldNull(&value, FALSE);
			}
			value.ReleaseBuffer();
		}
		else
		{
			// no selection
			value.GetBufferSetLength(0);
			if (pRecordset->IsFieldNullable(&value))
				pRecordset->SetFieldNull(&value);
		}
	}
	else
	{
		if (!pRecordset->IsOpen() || pRecordset->IsFieldNull(&value))
		{
			SendMessage(hWndCtrl, LB_SETCURSEL, (WPARAM)-1, 0L);
		}
		else
		{
			// set current selection based on data string
			if (::SendMessage(hWndCtrl, LB_SELECTSTRING, (WPARAM)-1,
			  (LPARAM)(LPCTSTR)value) == LB_ERR)
			{
				// no selection match
				TRACE(traceDatabase, 0, "Warning: no listbox item selected.\n");
			}
		}
	}
}

void AFXAPI DDX_FieldLBStringExact(CDataExchange* pDX, int nIDC, CString& value,
	CDaoRecordset* pRecordset)
{
	ASSERT_VALID(pRecordset);

	HWND hWndCtrl = pDX->PrepareCtrl(nIDC);
	if (pDX->m_bSaveAndValidate)
	{
		DDX_FieldLBString(pDX, nIDC, value, pRecordset);
	}
	else
	{
		if (!pRecordset->IsOpen() || pRecordset->IsFieldNull(&value))
		{
			SendMessage(hWndCtrl, LB_SETCURSEL, (WPARAM)-1, 0L);
		}
		else
		{
			// set current selection based on data string
			int i = (int)::SendMessage(hWndCtrl, LB_FINDSTRINGEXACT, (WPARAM)-1,
			  (LPARAM)(LPCTSTR)value);
			if (i < 0)
			{
				// no selection match
				TRACE(traceDatabase, 0, "Warning: no listbox item selected.\n");
			}
			else
			{
				// select it
				SendMessage(hWndCtrl, LB_SETCURSEL, i, 0L);
			}
		}
	}
}

void AFXAPI DDX_FieldCBString(CDataExchange* pDX, int nIDC, CString& value,
	CDaoRecordset* pRecordset)
{
	ASSERT_VALID(pRecordset);

	HWND hWndCtrl = pDX->PrepareCtrl(nIDC);
	if (pDX->m_bSaveAndValidate)
	{
		// just get current edit item text (or drop list static)
		int nLen = ::GetWindowTextLength(hWndCtrl);
		if (nLen != -1)
		{
			// get known length
			::GetWindowText(hWndCtrl, value.GetBuffer(nLen), nLen+1);
		}
		else
		{
			// for drop lists GetWindowTextLength does not work - assume
			//  preallocated length (or 256, whichever is larger)
			nLen = value.GetAllocLength();
			if (nLen < 256)
				nLen = 256;
			::GetWindowText(hWndCtrl, value.GetBuffer(nLen-1), nLen);
		}
		value.ReleaseBuffer();
		if (value.GetLength() == 0)
		{
			if (pRecordset->IsFieldNullable(&value))
				pRecordset->SetFieldNull(&value, TRUE);
		}
		else
		{
			pRecordset->SetFieldNull(&value, FALSE);
		}
	}
	else
	{
		if (!pRecordset->IsOpen() || pRecordset->IsFieldNull(&value))
		{
			SendMessage(hWndCtrl, CB_SETCURSEL, (WPARAM)-1, 0L);
		}
		else
		{
			// set current selection based on model string
			if (::SendMessage(hWndCtrl, CB_SELECTSTRING, (WPARAM)-1,
				(LPARAM)(LPCTSTR)value) == CB_ERR)
			{
				// just set the edit text (will be ignored if DROPDOWNLIST)
				AfxSetWindowText(hWndCtrl, value);
			}
		}
	}
}

void AFXAPI DDX_FieldCBStringExact(CDataExchange* pDX, int nIDC, CString& value,
	CDaoRecordset* pRecordset)
{
	ASSERT_VALID(pRecordset);

	HWND hWndCtrl = pDX->PrepareCtrl(nIDC);
	if (pDX->m_bSaveAndValidate)
	{
		DDX_FieldCBString(pDX, nIDC, value, pRecordset);
	}
	else
	{
		if (!pRecordset->IsOpen() || pRecordset->IsFieldNull(&value))
		{
			SendMessage(hWndCtrl, CB_SETCURSEL, (WPARAM)-1, 0L);
		}
		else
		{
			// set current selection based on data string
			int i = (int)::SendMessage(hWndCtrl, CB_FINDSTRINGEXACT, (WPARAM)-1,
			  (LPARAM)(LPCTSTR)value);
			if (i < 0)
			{
				// no selection match
				TRACE(traceDatabase, 0, "Warning: no combobox item selected.\n");
			}
			else
			{
				// select it
				SendMessage(hWndCtrl, CB_SETCURSEL, i, 0L);
			}
		}
	}
}

void AFXAPI DDX_FieldLBIndex(CDataExchange* pDX, int nIDC, int& index,
	CDaoRecordset* pRecordset)
{
	ASSERT_VALID(pRecordset);

	if (!pDX->m_bSaveAndValidate &&
		(!pRecordset->IsOpen() || pRecordset->IsFieldNull(&index)))
	{
		int nIndex = 0;
		DDX_LBIndex(pDX, nIDC, nIndex);
	}
	else
		DDX_LBIndex(pDX, nIDC, index);
}

void AFXAPI DDX_FieldCBIndex(CDataExchange* pDX, int nIDC, int& index,
	CDaoRecordset* pRecordset)
{
	ASSERT_VALID(pRecordset);

	if (!pDX->m_bSaveAndValidate &&
		(!pRecordset->IsOpen() || pRecordset->IsFieldNull(&index)))
	{
		int nIndex = 0;
		DDX_CBIndex(pDX, nIDC, nIndex);
	}
	else
		DDX_CBIndex(pDX, nIDC, index);
}

void AFXAPI DDX_FieldScroll(CDataExchange* pDX, int nIDC, int& value,
	CDaoRecordset* pRecordset)
{
	ASSERT_VALID(pRecordset);

	if (!pDX->m_bSaveAndValidate &&
		(!pRecordset->IsOpen() || pRecordset->IsFieldNull(&value)))
	{
		int nValue = 0;
		DDX_Scroll(pDX, nIDC, nValue);
	}
	else
		DDX_Scroll(pDX, nIDC, value);
}

void AFXAPI DDX_FieldSlider(CDataExchange* pDX, int nIDC, int& value,
	CDaoRecordset* pRecordset)
{
	ASSERT_VALID(pRecordset);

	if (!pDX->m_bSaveAndValidate &&
		(!pRecordset->IsOpen() || pRecordset->IsFieldNull(&value)))
	{
		int nValue = 0;
		DDX_Slider(pDX, nIDC, nValue);
	}
	else
		DDX_Slider(pDX, nIDC, value);
}

/////////////////////////////////////////////////////////////////////////////
// Data exchange for special controls

void AFXAPI DDX_FieldCheck(CDataExchange* pDX, int nIDC, int& value, CDaoRecordset* pRecordset)
{
	ASSERT_VALID(pRecordset);

	HWND hWndCtrl = pDX->PrepareCtrl(nIDC);
	if (pDX->m_bSaveAndValidate)
	{
		value = (int)::SendMessage(hWndCtrl, BM_GETCHECK, 0, 0L);
		ASSERT(value >= 0 && value <= 2);
		if (value == 2)
		{
			if (pRecordset->IsFieldNullable(&value))
				pRecordset->SetFieldNull(&value);
			else
			{
				TRACE(traceDatabase, 0, "Warning: can't set field NULL for checkbox value.\n");
				// Default to unchecked
				value = 0;
			}
		}
	}
	else
	{
		if (!pRecordset->IsOpen() || pRecordset->IsFieldNull(&value))
		{
			int style = ((int)::GetWindowLong(hWndCtrl, GWL_STYLE) & 0xf);
			if ((style == BS_3STATE || style == BS_AUTO3STATE))
				value = 2;
			else
			{
				TRACE(traceDatabase, 0, "Warning: can't set checkbox value for NULL field.\n");
				// Default to unchecked
				value = 0;
			}
		}
		if (value < 0 || value > 2)
		{
			value = 0;      // default to off
			TRACE(traceDatabase, 0, "Warning: dialog data checkbox value (%d) out of range.\n",
				value);
		}
		::SendMessage(hWndCtrl, BM_SETCHECK, (WPARAM)value, 0L);
	}
}

void AFXAPI DDX_FieldRadio(CDataExchange* pDX, int nIDC, int& value,
	CDaoRecordset* pRecordset)
{
	ASSERT_VALID(pRecordset);

	if (!pDX->m_bSaveAndValidate &&
		(!pRecordset->IsOpen() || pRecordset->IsFieldNull(&value)))
		value = -1;
	DDX_Radio(pDX, nIDC, value);
	if (pDX->m_bSaveAndValidate)
	{
		if (value == -1 && !pRecordset->IsFieldNullable(&value))
		{
			AfxFailRadio(pDX);
		}
		else
		{
			pRecordset->SetFieldNull(&value, (value == -1));
		}
	}
}

/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
void CDaoRecordView::AssertValid() const
{
	CFormView::AssertValid();
}

void CDaoRecordView::Dump(CDumpContext& dc) const
{
	ASSERT_VALID(this);

	CFormView::Dump(dc);

	dc << "m_nStatus =" << m_nStatus;
	dc << "m_varBookmarkCurrent =" << m_varBookmarkCurrent;
	dc << "m_varBookmarkFirst =" << m_varBookmarkFirst;
	dc << "m_varBookmarkLast =" << m_varBookmarkLast;

	dc << "\n";
}
#endif

//////////////////////////////////////////////////////////////////////////////
// Inline function declarations expanded out-of-line

#ifndef _AFX_ENABLE_INLINES

#define _AFXDAOVIEW_INLINE
#include "afxdao.inl"

#endif


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\ctlview.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// COleControl overridables for IViewObject implementation

BOOL COleControl::OnGetColorSet(DVTARGETDEVICE*, HDC, LPLOGPALETTE*)
{
	// Can be overridden by subclass
	return FALSE;
}

BOOL COleControl::OnGetViewExtent(DWORD dwDrawAspect, LONG /* lindex */,
	DVTARGETDEVICE* /* ptd */, LPSIZEL lpsizel)
{
	// Can be overridden by subclass for two-pass drawing
	if (dwDrawAspect == DVASPECT_OPAQUE || dwDrawAspect == DVASPECT_TRANSPARENT)
		dwDrawAspect = DVASPECT_CONTENT;
	return SUCCEEDED(m_xOleObject.GetExtent(dwDrawAspect, lpsizel));
}

BOOL COleControl::OnGetViewRect(DWORD dwAspect, LPRECTL pRect)
{
	// Can be overridden by subclass for two-pass drawing
	SIZEL size;
	OnGetViewExtent(dwAspect, -1, NULL, &size);
	pRect->left = 0;
	pRect->top = 0;
	pRect->right = size.cx;
	pRect->bottom = -size.cy;
	return TRUE;
}

DWORD COleControl::OnGetViewStatus()
{
	// Can be overridden by subclass for two-pass drawing
	return VIEWSTATUS_OPAQUE;
}

BOOL COleControl::OnQueryHitPoint(DWORD dwAspect, LPCRECT /* pRectBounds */,
	POINT /* ptlLoc */, LONG /* lCloseHint */, DWORD* pHitResult)
{
	// Can be overridden by subclass for non-rectangular hit-testing
	if (dwAspect == DVASPECT_CONTENT)
	{
		*pHitResult = HITRESULT_HIT;
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

BOOL COleControl::OnQueryHitRect(DWORD dwAspect, LPCRECT /* pRectBounds */,
	LPCRECT /* prcLoc */, LONG /* lCloseHint */, DWORD* pHitResult)
{
	// Can be overridden by subclass for non-rectangular hit-testing
	if (dwAspect == DVASPECT_CONTENT)
	{
		*pHitResult = HITRESULT_HIT;
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

BOOL COleControl::OnGetNaturalExtent(DWORD /* dwAspect */, LONG /* lindex */,
	DVTARGETDEVICE* /* ptd */, HDC /* hicTargetDev */,
	DVEXTENTINFO* /* pExtentInfo */, LPSIZEL /* psizel */)
{
	// Can be overridden by subclass to provide sizing hints
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// COleControl::XViewObject

STDMETHODIMP_(ULONG) COleControl::XViewObject::AddRef()
{
	METHOD_PROLOGUE_EX_(COleControl, ViewObject)
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) COleControl::XViewObject::Release()
{
	METHOD_PROLOGUE_EX_(COleControl, ViewObject)
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP COleControl::XViewObject::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(COleControl, ViewObject)
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}


STDMETHODIMP COleControl::XViewObject::Draw(DWORD dwDrawAspect, LONG lindex,
	void* pvAspect, DVTARGETDEVICE* ptd, HDC hicTargetDev, HDC hdcDraw,
	LPCRECTL lprcBounds, LPCRECTL lprcWBounds,
	BOOL (CALLBACK* pfnContinue)(DWORD_PTR), DWORD_PTR dwContinue)
{
	METHOD_PROLOGUE_EX(COleControl, ViewObject)

	HRESULT hResult = S_OK;

	CRect rc;

	if (lprcBounds == NULL)
	{
		if (pThis->m_bInPlaceSiteWndless)
			rc.CopyRect(pThis->m_rcPos);
		else
			return E_INVALIDARG;
	}
	else
	{
		rc.SetRect((int)lprcBounds->left, (int)lprcBounds->top,
			(int)lprcBounds->right, (int)lprcBounds->bottom);
	}

	// Check if optimized drawing is permitted
	if (pvAspect != NULL && (pThis->GetControlFlags() & canOptimizeDraw))
	{
		pThis->m_bOptimizedDraw = (((DVASPECTINFO*)pvAspect)->dwFlags &
			DVASPECTINFOFLAG_CANOPTIMIZE);
	}

	AfxLockTempMaps();

	// Convert from rectangle from logical to device coordinates,
	// save DC state, and switch to MM_TEXT mode.  After drawing,
	// restore DC state.

	switch (dwDrawAspect)
	{
	case DVASPECT_CONTENT:
		ENSURE(hdcDraw);
		if (GetDeviceCaps(hdcDraw, TECHNOLOGY) == DT_METAFILE)
		{
			// If attributes DC is NULL, create one, based on ptd.
			HDC hAttribDC = hicTargetDev;
			if (hicTargetDev == NULL)
				hAttribDC = ::_AfxOleCreateDC(ptd);

			// Draw into the metafile DC.
			CMetaFileDC dc;
			dc.Attach(hdcDraw);
			dc.SetAttribDC(hAttribDC);

			pThis->DrawMetafile(&dc, rc);

			dc.SetAttribDC(NULL);
			dc.Detach();

			// If we created an attributes DC, delete it now.
			if (hicTargetDev == NULL)
				::DeleteDC(hAttribDC);
		}
		else
		{
			CDC* pDC = CDC::FromHandle(hdcDraw);
			pThis->DrawContent(pDC, rc);
		}
		break;

	default:
		if (pThis->m_pDefIViewObject == NULL)
			pThis->m_pDefIViewObject =
				(LPVIEWOBJECT)pThis->QueryDefHandler(IID_IViewObject);

		if (pThis->m_pDefIViewObject != NULL)
		{
			hResult = pThis->m_pDefIViewObject->Draw(
				dwDrawAspect, lindex, pvAspect, ptd, hicTargetDev, hdcDraw,
				lprcBounds, lprcWBounds, pfnContinue, dwContinue);
		}
	}

	AfxUnlockTempMaps();
	pThis->m_bOptimizedDraw = FALSE;
	return hResult;
}

STDMETHODIMP COleControl::XViewObject::GetColorSet(DWORD dwDrawAspect,
	LONG lindex, void*, DVTARGETDEVICE* ptd, HDC hicTargetDev,
	LPLOGPALETTE* ppColorSet)
{
	METHOD_PROLOGUE_EX(COleControl, ViewObject)

	HRESULT hr = E_FAIL;

	if ((dwDrawAspect == DVASPECT_CONTENT) && (lindex == -1) &&
		pThis->OnGetColorSet(ptd, hicTargetDev, ppColorSet))
	{
		hr = S_OK;
	}

	return hr;
}

STDMETHODIMP COleControl::XViewObject::Freeze(DWORD, LONG, void*, DWORD*)
{
	return E_NOTIMPL;
}

STDMETHODIMP COleControl::XViewObject::Unfreeze(DWORD)
{
	return E_NOTIMPL;
}

STDMETHODIMP COleControl::XViewObject::SetAdvise(DWORD aspects, DWORD advf,
					LPADVISESINK pAdvSink)
{
	METHOD_PROLOGUE_EX_(COleControl, ViewObject)

	_AFXCTL_ADVISE_INFO** ppAdviseInfo = &pThis->m_pAdviseInfo;

	// Allocate space for advise info, if necessary.
	if (*ppAdviseInfo == NULL)
	{
		TRY
			*ppAdviseInfo = new _AFXCTL_ADVISE_INFO;
		END_TRY

		if (*ppAdviseInfo == NULL)
			return E_OUTOFMEMORY;
	}

	_AFXCTL_ADVISE_INFO* pAdviseInfo = *ppAdviseInfo;

	// Release previous sink, if any.
	if (pAdviseInfo->m_pAdvSink != NULL)
		pAdviseInfo->m_pAdvSink->Release();

	// Store new advise info.
	pAdviseInfo->m_dwAspects = aspects;
	pAdviseInfo->m_dwAdvf = advf;
	pAdviseInfo->m_pAdvSink = pAdvSink;
	if (pAdvSink != NULL)
		pAdvSink->AddRef();

	return S_OK;
}

STDMETHODIMP COleControl::XViewObject::GetAdvise(DWORD* pAspects, DWORD* pAdvf,
	LPADVISESINK* ppAdvSink)
{
	METHOD_PROLOGUE_EX_(COleControl, ViewObject)

	_AFXCTL_ADVISE_INFO* pAdviseInfo = pThis->m_pAdviseInfo;

	if ((pAdviseInfo != NULL) && (pAdviseInfo->m_pAdvSink != NULL))
	{
		if (pAspects != NULL)
			*pAspects = pAdviseInfo->m_dwAspects;

		if (pAdvf != NULL)
			*pAdvf = pAdviseInfo->m_dwAdvf;

		if (ppAdvSink != NULL)
		{
			*ppAdvSink = pAdviseInfo->m_pAdvSink;
			if (*ppAdvSink != NULL)
				(*ppAdvSink)->AddRef();
		}
	}
	else
	{
		if (pAspects != NULL)
			*pAspects = 0;

		if (pAdvf != NULL)
			*pAdvf = 0;

		if (ppAdvSink != NULL)
			*ppAdvSink = NULL;
	}

	return S_OK;
}

STDMETHODIMP COleControl::XViewObject::GetExtent(DWORD dwDrawAspect,
	LONG lindex, DVTARGETDEVICE* ptd, LPSIZEL lpsizel)
{
	METHOD_PROLOGUE_EX_(COleControl, ViewObject)
	return pThis->OnGetViewExtent(dwDrawAspect, lindex, ptd, lpsizel) ? S_OK :
		E_FAIL;
}

STDMETHODIMP COleControl::XViewObject::GetRect(DWORD dwAspect, LPRECTL pRect)
{
	METHOD_PROLOGUE_EX_(COleControl, ViewObject)
	return pThis->OnGetViewRect(dwAspect, pRect) ? S_OK : DV_E_DVASPECT;
}

STDMETHODIMP COleControl::XViewObject::GetViewStatus(DWORD* pdwStatus)
{
	METHOD_PROLOGUE_EX_(COleControl, ViewObject)
	*pdwStatus = pThis->OnGetViewStatus();
	return S_OK;
}

STDMETHODIMP COleControl::XViewObject::QueryHitPoint(DWORD dwAspect,
	LPCRECT pRectBounds, POINT ptlLoc, LONG lCloseHint, DWORD* pHitResult)
{
	METHOD_PROLOGUE_EX_(COleControl, ViewObject)
	return pThis->OnQueryHitPoint(dwAspect, pRectBounds, ptlLoc, lCloseHint,
		pHitResult) ? S_OK : E_FAIL;
}

STDMETHODIMP COleControl::XViewObject::QueryHitRect(DWORD dwAspect,
	LPCRECT pRectBounds, LPCRECT prcLoc, LONG lCloseHint, DWORD* pHitResult)
{
	METHOD_PROLOGUE_EX_(COleControl, ViewObject)
	return pThis->OnQueryHitRect(dwAspect, pRectBounds, prcLoc, lCloseHint,
		pHitResult) ? S_OK : E_FAIL;
}

STDMETHODIMP COleControl::XViewObject::GetNaturalExtent(DWORD dwAspect,
	LONG lindex, DVTARGETDEVICE* ptd, HDC hicTargetDev,
	DVEXTENTINFO* pExtentInfo, LPSIZEL psizel)
{
	METHOD_PROLOGUE_EX_(COleControl, ViewObject)
	return pThis->OnGetNaturalExtent(dwAspect, lindex, ptd, hicTargetDev,
		pExtentInfo, psizel) ? S_OK : E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// Force any extra compiler-generated code into AFX_INIT_SEG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\dbcore.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include <wchar.h>
#include "sal.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// Global data

#ifdef _DEBUG
BOOL bTraceSql = FALSE;
#endif

AFX_STATIC_DATA const TCHAR _afxODBCTrail[] = _T("ODBC;");
AFX_STATIC_DATA const TCHAR _afxComma[] = _T(",");
AFX_STATIC_DATA const TCHAR _afxLiteralSeparator = '\'';
AFX_STATIC_DATA const TCHAR _afxCall[] = _T("{CALL ");
AFX_STATIC_DATA const TCHAR _afxParamCall[] = _T("{?");
AFX_STATIC_DATA const TCHAR _afxSelect[] = _T("SELECT ");
AFX_STATIC_DATA const TCHAR _afxFrom[] = _T(" FROM ");
AFX_STATIC_DATA const TCHAR _afxWhere[] = _T(" WHERE ");
AFX_STATIC_DATA const TCHAR _afxOrderBy[] = _T(" ORDER BY ");
AFX_STATIC_DATA const TCHAR _afxForUpdate[] = _T(" FOR UPDATE ");

AFX_STATIC_DATA const TCHAR _afxRowFetch[] = _T("State:01S01");
AFX_STATIC_DATA const TCHAR _afxDataTruncated[] = _T("State:01004");
AFX_STATIC_DATA const TCHAR _afxInfoRange[] = _T("State:S1096");
AFX_STATIC_DATA const TCHAR _afxOutOfSequence[] = _T("State:S1010");
AFX_STATIC_DATA const TCHAR _afxDriverNotCapable[] = _T("State:S1C00");

AFX_STATIC_DATA const char _afxODBCDLL[] = "ODBC32.DLL";

/////////////////////////////////////////////////////////////////////////////
// for dynamic load of ODBC32.DLL

#pragma comment(lib, "odbc32.lib")

/////////////////////////////////////////////////////////////////////////////
// CDBException

static const _TCHAR szUnableToLoadErrorString[] = _T("MFC internal error: unable to load error string from resource.");

void AFXAPI AfxThrowDBException(RETCODE nRetCode, CDatabase* pdb, HSTMT hstmt)
{
	CDBException* pException = new CDBException(nRetCode);
	if (nRetCode == SQL_ERROR && pdb != NULL)
		pException->BuildErrorString(pdb, hstmt);
	else if (nRetCode > AFX_SQL_ERROR && nRetCode < AFX_SQL_ERROR_MAX)
	{	
		BOOL bResult = FALSE;
		VERIFY((bResult = pException->m_strError.LoadString(AFX_IDP_SQL_FIRST+(nRetCode-AFX_SQL_ERROR))) == TRUE);
		if (!bResult)
			pException->m_strError = szUnableToLoadErrorString;		
		TRACE(traceDatabase, 0, _T("%s\n"), pException->m_strError);
	}
	THROW(pException);
}

CDBException::CDBException(RETCODE nRetCode)
{
	m_nRetCode = nRetCode;
}

CDBException::~CDBException()
{
}

void CDBException::BuildErrorString(CDatabase* pdb, HSTMT hstmt, BOOL bTrace)
{
	ASSERT_VALID(this);
	UNUSED(bTrace);  // unused in release builds

	if (pdb != NULL)
	{
		SWORD nOutlen;
		RETCODE nRetCode;
		TCHAR lpszMsg[SQL_MAX_MESSAGE_LENGTH];
		TCHAR lpszState[SQL_SQLSTATE_SIZE+1];
		CString strMsg;
		CString strState;
		SDWORD lNative;

		_AFX_DB_STATE* pDbState = _afxDbState;
		AFX_SQL_SYNC(::SQLError(pDbState->m_henvAllConnections, pdb->m_hdbc,
			hstmt, reinterpret_cast<SQLTCHAR *>(lpszState), &lNative,
			reinterpret_cast<SQLTCHAR *>(lpszMsg), SQL_MAX_MESSAGE_LENGTH-1, &nOutlen));
		strState = lpszState;

		// Skip non-errors
		while ((nRetCode == SQL_SUCCESS || nRetCode == SQL_SUCCESS_WITH_INFO) &&
			lstrcmp(strState, _T("00000")) != 0)
		{
			strMsg = lpszMsg;

			TCHAR lpszNative[50];
			_stprintf_s(lpszNative, _countof(lpszNative), _T(",Native:%ld,Origin:"), lNative);
			strState += lpszNative;

			// transfer [origin] from message string to StateNativeOrigin string
			int nCloseBracket;
			int nMsgLength;
			while (!strMsg.IsEmpty() &&
				strMsg[0] == '[' && (nCloseBracket = strMsg.Find(']')) >= 0)
			{
				// Skip ']'
				nCloseBracket++;
				strState += strMsg.Left(nCloseBracket);

				nMsgLength = strMsg.GetLength();
				// Skip ' ', if present
				if (nCloseBracket < nMsgLength && strMsg[nCloseBracket] == ' ')
					nCloseBracket++;
				strMsg = strMsg.Right(nMsgLength - nCloseBracket);
			}
			strState += _T("\n");
			m_strStateNativeOrigin += _T("State:") + strState;
			m_strError += strMsg + _T("\n");

#ifdef _DEBUG
			if (bTrace)
			{
				TraceErrorMessage(strMsg);
				TraceErrorMessage(_T("State:") + strState);
			}
#endif // _DEBUG

			AFX_SQL_SYNC(::SQLError(pDbState->m_henvAllConnections,
				pdb->m_hdbc, hstmt, reinterpret_cast<SQLTCHAR *>(lpszState), &lNative,
				reinterpret_cast<SQLTCHAR *>(lpszMsg), SQL_MAX_MESSAGE_LENGTH-1, &nOutlen));
			strState = lpszState;
		}
	}
}


BOOL CDBException::GetErrorMessage(_Out_z_cap_(nMaxError) LPTSTR lpszError, _In_ UINT nMaxError,
		_Out_opt_ PUINT pnHelpContext /* = NULL */) const
{
	ASSERT(lpszError != NULL && AfxIsValidString(lpszError, nMaxError));

	if (!AfxIsValidString(lpszError, nMaxError))
	{
		return FALSE;
	}

	if (pnHelpContext != NULL)
		*pnHelpContext = 0;

	Checked::tcsncpy_s(lpszError, nMaxError, m_strError, _TRUNCATE);
	lpszError[nMaxError-1] = '\0';
	return TRUE;
}


#ifdef _DEBUG
void CDBException::TraceErrorMessage(LPCTSTR szTrace) const
{
	CString strTrace = szTrace;

	if (strTrace.GetLength() <= 80)
		TRACE(traceDatabase, 0, _T("%s\n"), strTrace);
	else
	{
		// Display 80 chars/line
		while (strTrace.GetLength() > 80)
		{
			TRACE(traceDatabase, 0, _T("%s\n"), strTrace.Left(80));
			strTrace = strTrace.Right(strTrace.GetLength() - 80);
		}
		TRACE(traceDatabase, 0, _T("%s\n"), strTrace);
	}
}
#endif // _DEBUG

void CDBException::Empty()
{
	m_strError.Empty();
	m_strStateNativeOrigin.Empty();
}

/////////////////////////////////////////////////////////////////////////////
// Global helper

HENV AFXAPI AfxGetHENV()
{
	_AFX_DB_STATE* pDbState = _afxDbState;
	return pDbState->m_henvAllConnections;
}

/////////////////////////////////////////////////////////////////////////////
// CDatabase implementation

CDatabase::CDatabase()
{
	m_hdbc = SQL_NULL_HDBC;
	m_hstmt = SQL_NULL_HSTMT;

	m_bUpdatable = FALSE;
	m_bTransactions = FALSE;
	DEBUG_ONLY(m_bTransactionPending = FALSE);
	m_dwLoginTimeout = DEFAULT_LOGIN_TIMEOUT;
	m_dwQueryTimeout = DEFAULT_QUERY_TIMEOUT;

	m_bStripTrailingSpaces = FALSE;
	m_bIncRecordCountOnAdd = FALSE;
	m_bAddForUpdate = FALSE;
}

CDatabase::~CDatabase()
{
	AFX_BEGIN_DESTRUCTOR

		ASSERT_VALID(this);

		Free();

	AFX_END_DESTRUCTOR
}

BOOL CDatabase::Open(LPCTSTR lpszDSN, BOOL bExclusive,
	BOOL bReadonly, LPCTSTR lpszConnect, BOOL bUseCursorLib)
{
	ENSURE_ARG(lpszDSN == NULL || AfxIsValidString(lpszDSN));
	ENSURE_ARG(lpszConnect == NULL || AfxIsValidString(lpszConnect));

	CString strConnect;

	if (lpszConnect != NULL)
		strConnect = lpszConnect;

	// if there is a "ODBC;" (or "odbc;") prefix in the connect string...
	if (_tcsnicmp(strConnect, _afxODBCTrail, lstrlen(_afxODBCTrail)) == 0)
	{
		// Strip "ODBC;"
		strConnect = strConnect.Right(strConnect.GetLength()
			- lstrlen(_afxODBCTrail));
	}

	if (lpszDSN != NULL && lstrlen(lpszDSN) != 0)
	{
		// Append "DSN=" lpszDSN
		strConnect += _T(";DSN=");
		strConnect += lpszDSN;
	}

	DWORD dwOptions = 0;

	if (bExclusive)
		dwOptions |= openExclusive;

	if (bReadonly)
		dwOptions |= openReadOnly;

	if (bUseCursorLib)
		dwOptions |= useCursorLib;

	return OpenEx(strConnect, dwOptions);
}

BOOL CDatabase::OpenEx(LPCTSTR lpszConnectString, DWORD dwOptions)
{
	ENSURE_VALID(this);
	ENSURE_ARG(lpszConnectString == NULL || AfxIsValidString(lpszConnectString));
	ENSURE_ARG(!(dwOptions & noOdbcDialog && dwOptions & forceOdbcDialog));

	// Exclusive access not supported.
	ASSERT(!(dwOptions & openExclusive));

	m_bUpdatable = !(dwOptions & openReadOnly);

	TRY
	{
		m_strConnect = lpszConnectString;

		// Allocate the HDBC and make connection
		AllocConnect(dwOptions);
		if(!Connect(dwOptions))
			return FALSE;

		// Verify support for required functionality and cache info
		VerifyConnect();
		GetConnectInfo();
	}
	CATCH_ALL(e)
	{
		Free();
		THROW_LAST();
	}
	END_CATCH_ALL

	return TRUE;
}

void CDatabase::ExecuteSQL(LPCTSTR lpszSQL)
{
	RETCODE nRetCode;
	HSTMT hstmt;

	ENSURE_VALID(this);
	ENSURE_ARG(AfxIsValidString(lpszSQL));

	AFX_SQL_SYNC(::SQLAllocStmt(m_hdbc, &hstmt));
	if (!CheckHstmt(nRetCode, hstmt))
		AfxThrowDBException(nRetCode, this, hstmt);

	TRY
	{
		OnSetOptions(hstmt);

		// Give derived CDatabase classes option to use parameters
		BindParameters(hstmt);

		LPTSTR pszSQL = const_cast<LPTSTR>(lpszSQL);
		AFX_ODBC_CALL(::SQLExecDirect(hstmt, reinterpret_cast<SQLTCHAR *>(pszSQL), SQL_NTS));
		if (!CheckHstmt(nRetCode, hstmt))
			AfxThrowDBException(nRetCode, this, hstmt);

		SWORD nResultColumns;
		do
		{
			AFX_ODBC_CALL(::SQLNumResultCols(hstmt, &nResultColumns));
			if(!CheckHstmt(nRetCode, hstmt))
				AfxThrowDBException(nRetCode, this, hstmt);

			if (nResultColumns != 0)
				do
				{
					AFX_ODBC_CALL(::SQLFetch(hstmt));
					if(!CheckHstmt(nRetCode, hstmt))
						AfxThrowDBException(nRetCode, this, hstmt);
				} while (nRetCode != SQL_NO_DATA_FOUND);
			AFX_ODBC_CALL(::SQLMoreResults(hstmt));
			if(!CheckHstmt(nRetCode, hstmt))
				AfxThrowDBException(nRetCode, this, hstmt);
		} while (nRetCode != SQL_NO_DATA_FOUND);
	}
	CATCH_ALL(e)
	{
		::SQLCancel(hstmt);
		AFX_SQL_SYNC(::SQLFreeStmt(hstmt, SQL_DROP));
		THROW_LAST();
	}
	END_CATCH_ALL

	AFX_SQL_SYNC(::SQLFreeStmt(hstmt, SQL_DROP));
}

// Shutdown pending query for CDatabase's private m_hstmt
void CDatabase::Cancel()
{
	ASSERT_VALID(this);
	ASSERT(m_hdbc != SQL_NULL_HDBC);

	::SQLCancel(m_hstmt);
}

// Disconnect connection
void CDatabase::Close()
{
	ASSERT_VALID(this);

	// Close any open recordsets
	AfxLockGlobals(CRIT_ODBC);
	TRY
	{
		while (!m_listRecordsets.IsEmpty())
		{
			CRecordset* pSet = (CRecordset*)m_listRecordsets.GetHead();
			pSet->Close();  // will implicitly remove from list
			pSet->m_pDatabase = NULL;
		}
	}
	CATCH_ALL(e)
	{
		AfxUnlockGlobals(CRIT_ODBC);
		THROW_LAST();
	}
	END_CATCH_ALL
	AfxUnlockGlobals(CRIT_ODBC);

	if (m_hdbc != SQL_NULL_HDBC)
	{
		RETCODE nRetCode;
		AFX_SQL_SYNC(::SQLDisconnect(m_hdbc));
		AFX_SQL_SYNC(::SQLFreeConnect(m_hdbc));
		m_hdbc = SQL_NULL_HDBC;

		_AFX_DB_STATE* pDbState = _afxDbState;

		AfxLockGlobals(CRIT_ODBC);
		ASSERT(pDbState->m_nAllocatedConnections != 0);
		pDbState->m_nAllocatedConnections--;
		AfxUnlockGlobals(CRIT_ODBC);
	}
}

// Silently disconnect and free all ODBC resources.  Don't throw any exceptions
void CDatabase::Free()
{
	ASSERT_VALID(this);

	// Trap failures upon close
	TRY
	{
		Close();
	}
	CATCH_ALL(e)
	{
		// Nothing we can do
		TRACE(traceDatabase, 0, _T("Error: exception by CDatabase::Close() ignored in CDatabase::Free().\n"));
		DELETE_EXCEPTION(e);
	}
	END_CATCH_ALL

	// free henv if refcount goes to 0
	_AFX_DB_STATE* pDbState = _afxDbState;
	AfxLockGlobals(CRIT_ODBC);
	if (pDbState->m_henvAllConnections != SQL_NULL_HENV)
	{
		ASSERT(pDbState->m_nAllocatedConnections >= 0);
		if (pDbState->m_nAllocatedConnections == 0)
		{
			// free last connection - release HENV
			RETCODE nRetCodeEnv = ::SQLFreeEnv(pDbState->m_henvAllConnections);
#ifdef _DEBUG
			if (nRetCodeEnv != SQL_SUCCESS)
				// Nothing we can do
				TRACE(traceDatabase, 0, _T("Error: SQLFreeEnv failure ignored in CDatabase::Free().\n"));
#endif
			pDbState->m_henvAllConnections = SQL_NULL_HENV;
		}
	}
	AfxUnlockGlobals(CRIT_ODBC);
}

void CDatabase::OnSetOptions(HSTMT hstmt)
{
	RETCODE nRetCode;
	ASSERT_VALID(this);
	ASSERT(m_hdbc != SQL_NULL_HDBC);

	if (m_dwQueryTimeout != -1)
	{
		// Attempt to set query timeout.  Ignore failure
		AFX_SQL_SYNC(::SQLSetStmtOption(hstmt, SQL_QUERY_TIMEOUT,
			m_dwQueryTimeout));
		if (!Check(nRetCode))
			// don't attempt it again
			m_dwQueryTimeout = (DWORD)-1;
	}
}

CString CDatabase::GetDatabaseName() const
{
	ASSERT_VALID(this);
	ASSERT(m_hdbc != SQL_NULL_HDBC);

	CString str;

	SWORD nResult;
	RETCODE nRetCode;

	AFX_SQL_SYNC(::SQLGetInfo(m_hdbc, SQL_DATABASE_NAME, NULL, 0, &nResult));
	if (Check(nRetCode))
	{
		LPTSTR pszName =
			str.GetBufferSetLength(nResult / sizeof(CString::XCHAR));

		AFX_SQL_SYNC(::SQLGetInfo(m_hdbc, SQL_DATABASE_NAME, pszName,
			SWORD(nResult + sizeof(CString::XCHAR)), &nResult));

		str.ReleaseBuffer();

		if(!Check(nRetCode))
			str.Empty();
	}
	return str;
}

BOOL CDatabase::BeginTrans()
{
	ASSERT_VALID(this);
	ASSERT(m_hdbc != SQL_NULL_HDBC);

	if (!m_bTransactions)
		return FALSE;

	// Only 1 level of transactions supported
#ifdef _DEBUG
	ASSERT(!m_bTransactionPending);
#endif

	RETCODE nRetCode;
	AFX_SQL_SYNC(::SQLSetConnectOption(m_hdbc, SQL_AUTOCOMMIT,
		SQL_AUTOCOMMIT_OFF));
	DEBUG_ONLY(m_bTransactionPending = TRUE);

	return Check(nRetCode);
}

BOOL CDatabase::CommitTrans()
{
	ASSERT_VALID(this);
	ASSERT(m_hdbc != SQL_NULL_HDBC);

	if (!m_bTransactions)
		return FALSE;

	// BeginTrans must be called first
#ifdef _DEBUG
	ASSERT(m_bTransactionPending);
#endif

	_AFX_DB_STATE* pDbState = _afxDbState;
	RETCODE nRetCode;
	AFX_SQL_SYNC(::SQLTransact(pDbState->m_henvAllConnections, m_hdbc, SQL_COMMIT));
	BOOL bSuccess = Check(nRetCode);

	// Turn back on auto commit
	AFX_SQL_SYNC(::SQLSetConnectOption(m_hdbc, SQL_AUTOCOMMIT,
		SQL_AUTOCOMMIT_ON));
	DEBUG_ONLY(m_bTransactionPending = FALSE);

	return bSuccess;
}

BOOL CDatabase::Rollback()
{
	ASSERT_VALID(this);
	ASSERT(m_hdbc != SQL_NULL_HDBC);

	if (!m_bTransactions)
		return FALSE;

	// BeginTrans must be called first
#ifdef _DEBUG
	ASSERT(m_bTransactionPending);
#endif

	_AFX_DB_STATE* pDbState = _afxDbState;
	RETCODE nRetCode;
	AFX_SQL_SYNC(::SQLTransact(pDbState->m_henvAllConnections, m_hdbc, SQL_ROLLBACK));
	BOOL bSuccess = Check(nRetCode);

	// Turn back on auto commit
	AFX_SQL_SYNC(::SQLSetConnectOption(m_hdbc, SQL_AUTOCOMMIT,
		SQL_AUTOCOMMIT_ON));
	DEBUG_ONLY(m_bTransactionPending = FALSE);

	return bSuccess;
}

// Screen for errors.
BOOL CDatabase::Check(RETCODE nRetCode) const
{
	return CheckHstmt(nRetCode, SQL_NULL_HSTMT);
}

BOOL CDatabase::CheckHstmt(RETCODE nRetCode, HSTMT hstmt) const
{
	ASSERT_VALID(this);
	UNUSED(hstmt);

	switch (nRetCode)
	{
	case SQL_SUCCESS_WITH_INFO:
#ifdef _DEBUG
	{
		CDBException e(nRetCode);
		TRACE(traceDatabase, 0, _T("Warning: ODBC Success With Info, "));
		e.BuildErrorString((CDatabase*)this, hstmt);
	}
#endif // _DEBUG

		// Fall through

	case SQL_SUCCESS:
	case SQL_NO_DATA_FOUND:
		return TRUE;
	}

	return FALSE;
}

//////////////////////////////////////////////////////////////////////////////
// CDatabase internal functions

//Replace brackets in SQL string with SQL_IDENTIFIER_QUOTE_CHAR
void CDatabase::ReplaceBrackets(_Inout_z_ LPTSTR lpchSQL)
{
	BOOL bInLiteral = FALSE;
	LPTSTR lpchNewSQL = lpchSQL;

	while (*lpchSQL)
	{
		if (*lpchSQL == _afxLiteralSeparator)
			{
				// Handle escaped literal
				if (*_tcsinc(lpchSQL) == _afxLiteralSeparator)
				{
					*lpchNewSQL = *lpchSQL;
					lpchSQL = _tcsinc(lpchSQL);
					lpchNewSQL = _tcsinc(lpchNewSQL);
				}
				else
					bInLiteral = !bInLiteral;

				*lpchNewSQL = *lpchSQL;
			}
		else if (*lpchSQL == _T('[') && !bInLiteral)
		{
			if (*_tcsinc(lpchSQL) == _T('['))
			{
				// Handle escaped left bracket by inserting one '['
				*lpchNewSQL = *lpchSQL;
				lpchSQL = _tcsinc(lpchSQL);
			}
			else
				*lpchNewSQL = m_chIDQuoteChar;
		}
		else if (*lpchSQL == _T(']') && !bInLiteral)
		{
			if (*_tcsinc(lpchSQL) == _T(']'))
			{
				// Handle escaped right bracket by inserting one ']'
				*lpchNewSQL = *lpchSQL;
				lpchSQL = _tcsinc(lpchSQL);
			}
			else
				*lpchNewSQL = m_chIDQuoteChar;
		}
		else
			*lpchNewSQL = *lpchSQL;

		lpchSQL = _tcsinc(lpchSQL);
		lpchNewSQL = _tcsinc(lpchNewSQL);
	}
	*lpchNewSQL = _T('\0');
}

// Allocate an henv (first time called) and hdbc
void CDatabase::AllocConnect(DWORD dwOptions)
{
	ASSERT_VALID(this);

	if (m_hdbc != SQL_NULL_HDBC)
		return;

	_AFX_DB_STATE* pDbState = _afxDbState;

	RETCODE nRetCode;

	AfxLockGlobals(CRIT_ODBC);
	if (pDbState->m_henvAllConnections == SQL_NULL_HENV)
	{
		ASSERT(pDbState->m_nAllocatedConnections == 0);

		// need to allocate an environment for first connection
		AFX_SQL_SYNC(::SQLAllocEnv(&pDbState->m_henvAllConnections));
		if (!Check(nRetCode))
		{
			AfxUnlockGlobals(CRIT_ODBC);
			AfxThrowMemoryException();  // fatal
		}
	}

	ASSERT(pDbState->m_henvAllConnections != SQL_NULL_HENV);
	AFX_SQL_SYNC(::SQLAllocConnect(pDbState->m_henvAllConnections, &m_hdbc));
	if (!Check(nRetCode))
	{
		AfxUnlockGlobals(CRIT_ODBC);
		ThrowDBException(nRetCode); // fatal
	}
	pDbState->m_nAllocatedConnections++;    // allocated at least
	AfxUnlockGlobals(CRIT_ODBC);

#ifdef _DEBUG
	if (bTraceSql)
	{
		::SQLSetConnectOption(m_hdbc, SQL_OPT_TRACEFILE,
			(SQLULEN)(DWORD_PTR)"odbccall.txt");
		::SQLSetConnectOption(m_hdbc, SQL_OPT_TRACE, 1);
	}
#endif // _DEBUG

	AFX_SQL_SYNC(::SQLSetConnectOption(m_hdbc, SQL_LOGIN_TIMEOUT,
		m_dwLoginTimeout));
#ifdef _DEBUG
	if (nRetCode != SQL_SUCCESS && nRetCode != SQL_SUCCESS_WITH_INFO)
		TRACE(traceDatabase, 0, _T("Warning: Failure setting login timeout.\n"));
#endif

	if (!m_bUpdatable)
	{
		AFX_SQL_SYNC(::SQLSetConnectOption(m_hdbc, SQL_ACCESS_MODE,
			SQL_MODE_READ_ONLY));
#ifdef _DEBUG
		if (nRetCode != SQL_SUCCESS && nRetCode != SQL_SUCCESS_WITH_INFO)
			TRACE(traceDatabase, 0, _T("Warning: Failure setting read only access mode.\n"));
#endif
	}

	// Turn on cursor lib support
	if (dwOptions & useCursorLib)
	{
		AFX_SQL_SYNC(::SQLSetConnectOption(m_hdbc,
			SQL_ODBC_CURSORS, SQL_CUR_USE_ODBC));
		// With cursor library added records immediately in result set
		m_bIncRecordCountOnAdd = TRUE;
	}
}

BOOL CDatabase::Connect(DWORD dwOptions)
{
	HWND hWndTop;
	HWND hWnd = CWnd::GetSafeOwner_(NULL, &hWndTop);
	if (hWnd == NULL)
		hWnd = ::GetDesktopWindow();

	TCHAR szConnectOutput[MAX_CONNECT_LEN];
	TCHAR *pszConnectInput = const_cast<LPTSTR>(static_cast<LPCTSTR>(m_strConnect));
	RETCODE nRetCode;
	SWORD nResult;
	UWORD wConnectOption = SQL_DRIVER_COMPLETE;

	if (dwOptions & noOdbcDialog)
		wConnectOption = SQL_DRIVER_NOPROMPT;
	else if (dwOptions & forceOdbcDialog)
		wConnectOption = SQL_DRIVER_PROMPT;
	AFX_SQL_SYNC(::SQLDriverConnect(m_hdbc, hWnd, reinterpret_cast<SQLTCHAR *>(pszConnectInput),
		SQL_NTS, reinterpret_cast<SQLTCHAR *>(szConnectOutput), _countof(szConnectOutput),
		&nResult, wConnectOption));
	if (hWndTop != NULL)
		::EnableWindow(hWndTop, TRUE);

	// If user hit 'Cancel'
	if (nRetCode == SQL_NO_DATA_FOUND)
	{
		Free();
		return FALSE;
	}

	if (!Check(nRetCode))
	{
#ifdef _DEBUG
		if (hWnd == NULL)
			TRACE(traceDatabase, 0, _T("Error: No default window (AfxGetApp()->m_pMainWnd) for SQLDriverConnect.\n"));
#endif
		ThrowDBException(nRetCode);
	}

	// Connect strings must have "ODBC;"
	m_strConnect = _afxODBCTrail;
	// Save connect string returned from ODBC
	m_strConnect += szConnectOutput;

	return TRUE;
}

void CDatabase::VerifyConnect()
{
	RETCODE nRetCode;
	SWORD nResult;

	SWORD nAPIConformance;
	AFX_SQL_SYNC(::SQLGetInfo(m_hdbc, SQL_ODBC_API_CONFORMANCE,
		&nAPIConformance, sizeof(nAPIConformance), &nResult));
	if (!Check(nRetCode))
		ThrowDBException(nRetCode);

	if (nAPIConformance < SQL_OAC_LEVEL1)
		ThrowDBException(AFX_SQL_ERROR_API_CONFORMANCE);

	SWORD nSQLConformance;
	AFX_SQL_SYNC(::SQLGetInfo(m_hdbc, SQL_ODBC_SQL_CONFORMANCE,
		&nSQLConformance, sizeof(nSQLConformance), &nResult));
	if (!Check(nRetCode))
		ThrowDBException(nRetCode);

	if (nSQLConformance < SQL_OSC_MINIMUM)
		ThrowDBException(AFX_SQL_ERROR_SQL_CONFORMANCE);
}

void CDatabase::GetConnectInfo()
{
	RETCODE nRetCode;
	SWORD nResult;

	// Reset the database update options
	m_dwUpdateOptions = 0;

	// Check for SQLSetPos support
	UDWORD dwDriverPosOperations;
	AFX_SQL_SYNC(::SQLGetInfo(m_hdbc, SQL_POS_OPERATIONS,
		&dwDriverPosOperations, sizeof(dwDriverPosOperations), &nResult));
	if (Check(nRetCode) &&
		(dwDriverPosOperations & SQL_POS_UPDATE) &&
		(dwDriverPosOperations & SQL_POS_DELETE) &&
		(dwDriverPosOperations & SQL_POS_ADD))
		m_dwUpdateOptions |= AFX_SQL_SETPOSUPDATES;

	// Check for positioned update SQL support
	UDWORD dwPositionedStatements;
	AFX_SQL_SYNC(::SQLGetInfo(m_hdbc, SQL_POSITIONED_STATEMENTS,
		&dwPositionedStatements, sizeof(dwPositionedStatements),
		&nResult));
	if (Check(nRetCode) &&
		(dwPositionedStatements & SQL_PS_POSITIONED_DELETE) &&
		(dwPositionedStatements & SQL_PS_POSITIONED_UPDATE))
		m_dwUpdateOptions |= AFX_SQL_POSITIONEDSQL;

	// Check for transaction support
	SWORD nTxnCapable;
	AFX_SQL_SYNC(::SQLGetInfo(m_hdbc, SQL_TXN_CAPABLE, &nTxnCapable,
		sizeof(nTxnCapable), &nResult));
	if (Check(nRetCode) && nTxnCapable != SQL_TC_NONE)
		m_bTransactions = TRUE;

	// Cache the effect of transactions on cursors
	AFX_SQL_SYNC(::SQLGetInfo(m_hdbc, SQL_CURSOR_COMMIT_BEHAVIOR,
		&m_nCursorCommitBehavior, sizeof(m_nCursorCommitBehavior),
		&nResult));
	if (!Check(nRetCode))
		m_nCursorCommitBehavior = SQL_ERROR;

	AFX_SQL_SYNC(::SQLGetInfo(m_hdbc, SQL_CURSOR_ROLLBACK_BEHAVIOR,
		&m_nCursorRollbackBehavior, sizeof(m_nCursorRollbackBehavior),
		&nResult));
	if (!Check(nRetCode))
		m_nCursorRollbackBehavior = SQL_ERROR;

	// Cache bookmark attributes
	AFX_SQL_SYNC(::SQLGetInfo(m_hdbc, SQL_BOOKMARK_PERSISTENCE,
		&m_dwBookmarkAttributes, sizeof(m_dwBookmarkAttributes),
		&nResult));
	Check(nRetCode);

	// Check for SQLGetData support req'd by RFX_LongBinary
	UDWORD dwGetDataExtensions;
	AFX_SQL_SYNC(::SQLGetInfo(m_hdbc, SQL_GETDATA_EXTENSIONS,
		&dwGetDataExtensions, sizeof(dwGetDataExtensions),
		&nResult));
	if (!Check(nRetCode))
		dwGetDataExtensions = 0;
	if (dwGetDataExtensions & SQL_GD_BOUND)
		m_dwUpdateOptions |= AFX_SQL_GDBOUND;

	if (m_bUpdatable)
	{
		// Make sure data source is Updatable
		TCHAR szReadOnly[10];
		AFX_SQL_SYNC(::SQLGetInfo(m_hdbc, SQL_DATA_SOURCE_READ_ONLY,
			szReadOnly, sizeof(szReadOnly), &nResult));
		if (Check(nRetCode) && nResult == sizeof(TCHAR))
			m_bUpdatable = szReadOnly[0] == _T('N');
		else
			m_bUpdatable = FALSE;
#ifdef _DEBUG
		if (!m_bUpdatable)
			TRACE(traceDatabase, 0, _T("Warning: data source is readonly.\n"));
#endif
	}
	else
	{
		// Make data source is !Updatable
		AFX_SQL_SYNC(::SQLSetConnectOption(m_hdbc,
			SQL_ACCESS_MODE, SQL_MODE_READ_ONLY));
	}

	// Cache the quote char to use when constructing SQL
	TCHAR szIDQuoteChar[2];
	AFX_SQL_SYNC(::SQLGetInfo(m_hdbc, SQL_IDENTIFIER_QUOTE_CHAR,
		szIDQuoteChar, sizeof(szIDQuoteChar), &nResult));
	if (Check(nRetCode) && nResult == sizeof(TCHAR))
		m_chIDQuoteChar = szIDQuoteChar[0];
	else
		m_chIDQuoteChar = '\"';

#ifdef _DEBUG
	TCHAR szInfo[64];
	AFX_SQL_SYNC(::SQLGetInfo(m_hdbc, SQL_DBMS_NAME,
		szInfo, sizeof(szInfo), &nResult));
	if (Check(nRetCode))
	{
		TRACE(traceDatabase, 0, _T("DBMS: %s\n"), szInfo);
		AFX_SQL_SYNC(::SQLGetInfo(m_hdbc, SQL_DBMS_VER,
			szInfo, sizeof(szInfo), &nResult));
		if (Check(nRetCode))
			TRACE(traceDatabase, 0, _T("Version: %s\n"), szInfo);
	}

	AFX_SQL_SYNC(::SQLGetInfo(m_hdbc, SQL_ODBC_VER,
		szInfo, sizeof(szInfo), &nResult));
	if(Check(nRetCode))
		TRACE(traceDatabase, 0, _T("ODBC Driver Manager Version: %s\n"), szInfo);
#endif // _DEBUG
}

void CDatabase::BindParameters(HSTMT /* hstmt */)
{
	// Must override and call SQLBindParameter directly
}

//////////////////////////////////////////////////////////////////////////////
// CDatabase diagnostics

#ifdef _DEBUG
void CDatabase::AssertValid() const
{
	CObject::AssertValid();
}

void CDatabase::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	dc << _T("m_hdbc = ") << m_hdbc;
	dc << _T("\nm_strConnect = ") << m_strConnect;
	dc << _T("\nm_bUpdatable = ") << m_bUpdatable;
	dc << _T("\nm_bTransactions = ") << m_bTransactions;
	dc << _T("\nm_bTransactionPending = ") << m_bTransactionPending;
	dc << _T("\nm_dwLoginTimeout = ") << m_dwLoginTimeout;
	dc << _T("\nm_dwQueryTimeout = ") << m_dwQueryTimeout;

	if (dc.GetDepth() > 0)
	{
		_AFX_DB_STATE* pDbState = _afxDbState;
		dc << _T("\nwith env:");
		dc << _T("\n\tnAllocated = ") << pDbState->m_nAllocatedConnections;
		dc << _T("\n\thenvAllConnections = ") << pDbState->m_henvAllConnections;
	}

	dc << _T("\n");
}

#endif // _DEBUG


//////////////////////////////////////////////////////////////////////////////
// CRecordset helpers

void AFXAPI _AfxSetCurrentRecord(long* plCurrentRecord, long nRows, RETCODE nRetCode);
void AFXAPI _AfxSetRecordCount(long* plRecordCount, long lCurrentRecord,
	BOOL bEOFSeen, RETCODE nRetCode);

//////////////////////////////////////////////////////////////////////////////
// CRecordset
 
CRecordset::CRecordset(CDatabase* pDatabase)
{
	ENSURE_ARG(pDatabase == NULL || AfxIsValidAddress(pDatabase, sizeof(CDatabase)));
	m_pDatabase = pDatabase;

	m_nOpenType = snapshot;
	m_lOpen = AFX_RECORDSET_STATUS_UNKNOWN;
	m_nEditMode = noMode;
	m_nDefaultType = snapshot;
	m_dwOptions = none;

	m_bAppendable = FALSE;
	m_bUpdatable = FALSE;
	m_bScrollable = FALSE;
	m_bRecordsetDb = FALSE;
	m_bRebindParams = FALSE;
	m_bLongBinaryColumns = FALSE;
	m_nLockMode = optimistic;
	m_dwInitialGetDataLen = 0;
	m_rgODBCFieldInfos = NULL;
	m_rgFieldInfos = NULL;
	m_rgRowStatus = NULL;
	m_dwRowsetSize = 25;
	m_dwAllocatedRowsetSize = 0;

	m_nFields = 0;
	m_nParams = 0;
	m_nFieldsBound = 0;
	m_lCurrentRecord = AFX_CURRENT_RECORD_UNDEFINED;
	m_lRecordCount = 0;
	m_bUseUpdateSQL = FALSE;
	m_bUseODBCCursorLib = FALSE;
	m_nResultCols = -1;
	m_bCheckCacheForDirtyFields = TRUE;

	m_pbFieldFlags = NULL;
	m_pbParamFlags = NULL;
	m_plParamLength = NULL;
	m_pvFieldProxy = NULL;
	m_pvParamProxy = NULL;
	m_nProxyFields = 0;
	m_nProxyParams = 0;

	m_hstmtUpdate = SQL_NULL_HSTMT;
	m_hstmt = SQL_NULL_HSTMT;
	if (m_pDatabase != NULL && m_pDatabase->IsOpen())
	{
		ASSERT_VALID(m_pDatabase);
		TRY
		{
			RETCODE nRetCode;
			AFX_SQL_SYNC(::SQLAllocStmt(m_pDatabase->m_hdbc, &m_hstmt));
			if (!Check(nRetCode))
				ThrowDBException(SQL_INVALID_HANDLE);

			// Add to list of CRecordsets with alloced hstmts
			AfxLockGlobals(CRIT_ODBC);
			TRY
			{
				m_pDatabase->m_listRecordsets.AddHead(this);
			}
			CATCH_ALL(e)
			{
				AfxUnlockGlobals(CRIT_ODBC);
				THROW_LAST();
			}
			END_CATCH_ALL
			AfxUnlockGlobals(CRIT_ODBC);
		}
		CATCH_ALL(e)
		{
			ASSERT(m_hstmt == SQL_NULL_HSTMT);
			DELETE_EXCEPTION(e);
		}
		END_CATCH_ALL
	}
}

CRecordset::~CRecordset()
{
	ASSERT_VALID(this);

	TRY
	{
		if (m_hstmt != NULL)
		{
#ifdef _DEBUG
			if (m_dwOptions & useMultiRowFetch)
			{
				TRACE(traceDatabase, 0, _T("\nWARNING: Close called implicitly from destructor."));
				TRACE(traceDatabase, 0, _T("\nUse of multi row fetch requires explicit call"));
				TRACE(traceDatabase, 0, _T("\nto Close or memory leaks will result.\n"));
			}
#endif
			Close();
		}
		if (m_bRecordsetDb)
			delete m_pDatabase;
		m_pDatabase = NULL;
	}
	CATCH_ALL(e)
	{
		// Nothing we can do
		TRACE(traceDatabase, 0, _T("Error: Exception ignored in ~CRecordset().\n"));
		DELETE_EXCEPTION(e);
	}
	END_CATCH_ALL
}

BOOL CRecordset::Open(UINT nOpenType, LPCTSTR lpszSQL, DWORD dwOptions)
{
	ENSURE(!IsOpen());
	ENSURE_VALID(this);
	ENSURE_ARG(lpszSQL == NULL || AfxIsValidString(lpszSQL));
	ENSURE_ARG(nOpenType == AFX_DB_USE_DEFAULT_TYPE ||
		nOpenType == dynaset || nOpenType == snapshot ||
		nOpenType == forwardOnly || nOpenType == dynamic);
	ENSURE_ARG(!(dwOptions & readOnly && dwOptions & appendOnly));

	// Can only use optimizeBulkAdd with appendOnly recordsets
	ENSURE_ARG((dwOptions & optimizeBulkAdd && dwOptions & appendOnly) ||
		!(dwOptions & optimizeBulkAdd));

	// forwardOnly recordsets have limited functionality
	ENSURE_ARG(!(nOpenType == forwardOnly && dwOptions & skipDeletedRecords));

	// Cache state info and allocate hstmt
	SetState(nOpenType, lpszSQL, dwOptions);
	if(!AllocHstmt())
		return FALSE;

	// Check if bookmarks upported (CanBookmark depends on open DB)
	ASSERT(dwOptions & useBookmarks ? CanBookmark() : TRUE);

	TRY
	{
		OnSetOptions(m_hstmt);

		// Allocate the field/param status arrays, if necessary
		BOOL bUnbound = FALSE;
		if (m_nFields > 0 || m_nParams > 0)
			AllocStatusArrays();
		else
			bUnbound = TRUE;

		// Build SQL and prep/execute or just execute direct
		BuildSQL(lpszSQL);
		PrepareAndExecute();

		// Cache some field info and prepare the rowset
		AllocAndCacheFieldInfo();
		AllocRowset();

		// If late binding, still need to allocate status arrays
		if (bUnbound && (m_nFields > 0 || m_nParams > 0))
			AllocStatusArrays();

		// Give derived classes a call before binding
		PreBindFields();

		// Fetch the first row of data
		MoveNext();

		// If EOF, then result set empty, so set BOF as well
		m_bBOF = m_bEOF;
	}
	CATCH_ALL(e)
	{
		Close();
		THROW_LAST();
	}
	END_CATCH_ALL

	return TRUE;
}

void CRecordset::Close()
{
	ENSURE_VALID(this);
	// Can't close if database has been deleted
	ENSURE(m_pDatabase != NULL);

	// This will force a requery for cursor name if reopened.
	m_strCursorName.Empty();

	if (m_rgFieldInfos != NULL &&
		m_nFields > 0 && m_bCheckCacheForDirtyFields)
	{
		FreeDataCache();
	}

	FreeRowset();

	m_nEditMode = noMode;

	delete [] m_rgFieldInfos;
	m_rgFieldInfos = NULL;

	delete [] m_rgODBCFieldInfos;
	m_rgODBCFieldInfos = NULL;

	delete [] m_pbFieldFlags;
	m_pbFieldFlags = NULL;

	delete [] m_pbParamFlags;
	m_pbParamFlags = NULL;

	if (m_pvFieldProxy != NULL)
	{
		for (UINT nField = 0; nField < m_nProxyFields; nField++)
			delete m_pvFieldProxy[nField];

		delete [] m_pvFieldProxy;
		m_pvFieldProxy = NULL;
		m_nProxyFields = 0;
	}

	if (m_pvParamProxy != NULL)
	{
		for (UINT nParam = 0; nParam < m_nProxyParams; nParam++)
			delete m_pvParamProxy[nParam];

		delete [] m_pvParamProxy;
		m_pvParamProxy = NULL;
		m_nProxyParams = 0;
	}

	delete [] m_plParamLength;
	m_plParamLength = NULL;

	RETCODE nRetCode;
	if (m_hstmt != SQL_NULL_HSTMT)
	{
		AFX_SQL_SYNC(::SQLFreeStmt(m_hstmt, SQL_DROP));
		m_hstmt = SQL_NULL_HSTMT;
	}

	if (m_hstmtUpdate != SQL_NULL_HSTMT)
	{
		AFX_SQL_SYNC(::SQLFreeStmt(m_hstmtUpdate, SQL_DROP));
		m_hstmtUpdate = SQL_NULL_HSTMT;
	}

	// Remove CRecordset from CDatabase's list
	AfxLockGlobals(CRIT_ODBC);
	TRY
	{
		POSITION pos = m_pDatabase->m_listRecordsets.Find(this);
		if (pos != NULL)
			m_pDatabase->m_listRecordsets.RemoveAt(pos);
#ifdef _DEBUG
		else
			TRACE(traceDatabase, 0, _T("WARNING: CRecordset not found in m_pDatabase->m_listRecordsets.\n"));
#endif
	}
	CATCH_ALL(e)
	{
		AfxUnlockGlobals(CRIT_ODBC);
		THROW_LAST();
	}
	END_CATCH_ALL
	AfxUnlockGlobals(CRIT_ODBC);

	m_lOpen = AFX_RECORDSET_STATUS_CLOSED;
	m_bBOF = TRUE;
	m_bEOF = TRUE;
	m_bDeleted = FALSE;
	m_bAppendable = FALSE;
	m_bUpdatable = FALSE;
	m_bScrollable = FALSE;
	m_bRebindParams = FALSE;
	m_bLongBinaryColumns = FALSE;
	m_nLockMode = optimistic;

	m_nFieldsBound = 0;
	m_nResultCols = -1;
}

BOOL CRecordset::IsOpen() const
	// Note: assumes base class CRecordset::Close called
{
	if (m_hstmt == NULL)
		return FALSE;

	if (m_lOpen == AFX_RECORDSET_STATUS_OPEN)
		return TRUE;

	RETCODE nRetCode;
	SWORD nCols;

	AFX_ODBC_CALL(::SQLNumResultCols(m_hstmt, &nCols));

	if (!Check(nRetCode))
	{
		// If function sequence error, CRecordset not open
		CDBException* e = new CDBException(nRetCode);
		e->BuildErrorString(m_pDatabase, m_hstmt, FALSE);
		if (e->m_strStateNativeOrigin.Find(_afxOutOfSequence) >= 0)
		{
			e->Delete();
			return FALSE;
		}
		else
		{
#ifdef _DEBUG
			TRACE(traceDatabase, 0, _T("Error: SQLNumResultCols failed during IsOpen().\n"));
			e->TraceErrorMessage(e->m_strError);
			e->TraceErrorMessage(e->m_strStateNativeOrigin);
#endif
			THROW(e);
		}
	}

	BOOL bOpen = FALSE;

	if (nCols != 0)
		bOpen = TRUE;

	return bOpen;
}

BOOL CRecordset::IsFieldDirty(void* pv)
{
	ASSERT_VALID(this);
	ASSERT(!(m_dwOptions & useMultiRowFetch));

	if (m_nFields <= 0)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	// If not in update op fields can't be dirty
	// must compare saved and current values
	if (m_nEditMode == noMode)
		return FALSE;

	// Must compare values to find dirty fields if necessary
	if (m_bCheckCacheForDirtyFields)
	{
		if (m_nEditMode == edit)
			MarkForUpdate();
		else
			MarkForAddNew();
	}

	int nIndex = 0, nIndexEnd;

	if (pv == NULL)
		nIndexEnd = m_nFields - 1;
	else
	{
		// GetBoundFieldIndex returns 1-based index
		nIndex = nIndexEnd = GetBoundFieldIndex(pv) - 1;

		// must be address of field member
		ASSERT(nIndex >= 0);
	}

	BOOL bDirty = FALSE;

	while (nIndex <= nIndexEnd && !bDirty)
		bDirty = IsFieldStatusDirty(nIndex++);

	return bDirty;
}

BOOL CRecordset::IsFieldNull(void* pv)
{
	ASSERT_VALID(this);
	ASSERT(!(m_dwOptions & useMultiRowFetch));

	int nIndex;
	BOOL bRetVal;

	if (pv == NULL)
	{
		bRetVal = FALSE;
		for (nIndex = 0; !bRetVal && nIndex <= int(m_nFields-1); nIndex++)
			bRetVal = IsFieldStatusNull((DWORD) nIndex);
	}
	else
	{
		nIndex = GetBoundFieldIndex(pv) - 1;
		if (nIndex < 0)
			ThrowDBException(AFX_SQL_ERROR_FIELD_NOT_FOUND);
		bRetVal = IsFieldStatusNull((DWORD) nIndex);
	}

	return bRetVal;
}

BOOL CRecordset::IsFieldNullable(void* pv)
{
	ASSERT_VALID(this);

	if (pv == NULL)
	{
		// Must specify valid column name
		ASSERT(FALSE);
		return FALSE;
	}

	int nIndex = GetBoundFieldIndex(pv) - 1;
	if (nIndex < 0)
		ThrowDBException(AFX_SQL_ERROR_FIELD_NOT_FOUND);

	return IsFieldNullable((DWORD)nIndex);
}

BOOL CRecordset::CanBookmark() const
{
	ASSERT_VALID(this);
	ENSURE(m_pDatabase != NULL && m_pDatabase->IsOpen());

	if (!(m_dwOptions & useBookmarks) ||
		(m_nOpenType == forwardOnly && !(m_dwOptions & useExtendedFetch)))
		return FALSE;

	return m_pDatabase->GetBookmarkPersistence() & SQL_BP_SCROLL;
}

void CRecordset::Move(long nRows, WORD wFetchType)
{
	ASSERT_VALID(this);
	ASSERT(m_hstmt != SQL_NULL_HSTMT);

	// First call - fields haven't been bound (m_nFieldsBound will change)
	if (m_nFieldsBound == 0)
	{
		InitRecord();
		ResetCursor();
	}

	if (m_nFieldsBound > 0)
	{
		// Reset field flags - mark all clean, all non-null
		memset(m_pbFieldFlags, 0, m_nFields);

		// Clear any edit mode that was set
		m_nEditMode = noMode;
	}

	// Check scrollability, EOF/BOF status
	CheckRowsetCurrencyStatus(wFetchType, nRows);

	RETCODE nRetCode;

	// Fetch the data, skipping deleted records if necessary
	if ((wFetchType == SQL_FETCH_FIRST ||
		wFetchType == SQL_FETCH_LAST ||
		wFetchType == SQL_FETCH_NEXT ||
		wFetchType == SQL_FETCH_PRIOR ||
		wFetchType == SQL_FETCH_RELATIVE) &&
		m_dwOptions & skipDeletedRecords)
	{
		SkipDeletedRecords(wFetchType, nRows, &m_dwRowsFetched, &nRetCode);
	}
	else
		// Fetch the data and check for errors
		nRetCode = FetchData(wFetchType, nRows, &m_dwRowsFetched);

	// Set currency status and increment the record counters
	SetRowsetCurrencyStatus(nRetCode, wFetchType, nRows, m_dwRowsFetched);

	// Need to fixup bound fields in some cases
	if (m_nFields > 0 && !IsEOF() && !IsBOF() &&
		!(m_dwOptions & useMultiRowFetch))
	{
		Fixups();
	}
}

void CRecordset::CheckRowsetError(RETCODE nRetCode)
{
	if (nRetCode == SQL_SUCCESS_WITH_INFO)
	{
		CDBException e(nRetCode);
		// Build the error string but don't send nuisance output to TRACE window
		e.BuildErrorString(m_pDatabase, m_hstmt, FALSE);

		if (e.m_strStateNativeOrigin.Find(_afxDataTruncated) >= 0)
		{
			ENSURE(m_pDatabase != NULL);
			// Ignore data truncated warning if binding long binary columns
			// (may mask non-long binary truncation warnings or other warnings)
			if (!((m_pDatabase->m_dwUpdateOptions & AFX_SQL_SETPOSUPDATES) &&
				m_bLongBinaryColumns))
			{
				NO_CPP_EXCEPTION(e.Empty());
				TRACE(traceDatabase, 0, _T("Error: field data truncated during data fetch.\n"));
				ThrowDBException(AFX_SQL_ERROR_DATA_TRUNCATED);
			}
		}
		else if (e.m_strStateNativeOrigin.Find(_afxRowFetch) >= 0)
		{
#ifdef _DEBUG
			TRACE(traceDatabase, 0, _T("Error: fetching row from server.\n"));
			e.TraceErrorMessage(e.m_strError);
			e.TraceErrorMessage(e.m_strStateNativeOrigin);
#endif
			NO_CPP_EXCEPTION(e.Empty());
			ThrowDBException(AFX_SQL_ERROR_ROW_FETCH);
		}
#ifdef _DEBUG
		else
		{
			// Not a truncation or row fetch warning so send debug output
			TRACE(traceDatabase, 0, _T("Warning: ODBC Success With Info,\n"));
			e.TraceErrorMessage(e.m_strError);
			e.TraceErrorMessage(e.m_strStateNativeOrigin);
		}
#endif // _DEBUG
	}
	else if (!Check(nRetCode))
		ThrowDBException(nRetCode);
}

void CRecordset::GetBookmark(CDBVariant& varBookmark)
{
	ASSERT_VALID(this);

	// Validate bookmarks are usable
	if (!(m_dwOptions & useBookmarks))
		ThrowDBException(AFX_SQL_ERROR_BOOKMARKS_NOT_ENABLED);
	else if (!CanBookmark())
		ThrowDBException(AFX_SQL_ERROR_BOOKMARKS_NOT_SUPPORTED);

	// Currently ODBC only supports 4 byte bookmarks
	// Initialize the variant to a long
	if (varBookmark.m_dwType != DBVT_LONG)
	{
		varBookmark.Clear();
		varBookmark.m_dwType = DBVT_LONG;
		varBookmark.m_lVal = 0;
	}

	RETCODE nRetCode;
	SQLLEN nActualSize;

	// Retrieve the bookmark (column 0) data
	AFX_ODBC_CALL(::SQLGetData(m_hstmt, 0, SQL_C_BOOKMARK,
		&varBookmark.m_lVal, sizeof(varBookmark.m_lVal), &nActualSize));
	if (!Check(nRetCode))
	{
		TRACE(traceDatabase, 0, _T("Error: GetBookmark operation failed.\n"));
		ThrowDBException(nRetCode);
	}
}

void CRecordset::SetBookmark(const CDBVariant& varBookmark)
{
	ASSERT_VALID(this);

	// Validate bookmarks are usable
	if (!(m_dwOptions & useBookmarks))
		ThrowDBException(AFX_SQL_ERROR_BOOKMARKS_NOT_ENABLED);
	else if (!CanBookmark())
		ThrowDBException(AFX_SQL_ERROR_BOOKMARKS_NOT_SUPPORTED);

	// Currently ODBC only supports 4 byte bookmarks
	ASSERT(varBookmark.m_dwType == DBVT_LONG);

	Move(varBookmark.m_lVal, SQL_FETCH_BOOKMARK);
}

void CRecordset::SetRowsetSize(DWORD dwNewRowsetSize)
{
	ENSURE_VALID(this);
	ENSURE_ARG(dwNewRowsetSize > 0);

	// If not yet open, only set expected length
	if (!IsOpen())
	{
		m_dwRowsetSize = dwNewRowsetSize;
		return;
	}

	if (!(m_dwOptions & useMultiRowFetch))
	{
		// Only works if bulk row fetching!
		ASSERT(FALSE);
		return;
	}

	// Need to reallocate some memory if rowset size grows
	if (m_dwAllocatedRowsetSize == 0 ||
		(m_dwAllocatedRowsetSize < dwNewRowsetSize))
	{
		// If rowset already allocated, delete old and reallocate
		FreeRowset();
		m_rgRowStatus = new WORD[dwNewRowsetSize];

		// If not a user allocated buffer grow the data buffers
		if (!(m_dwOptions & userAllocMultiRowBuffers))
		{
			// Allocate the rowset field buffers
			m_dwRowsetSize = dwNewRowsetSize;
			CFieldExchange fx(CFieldExchange::AllocMultiRowBuffer, this);
			DoBulkFieldExchange(&fx);

			m_dwAllocatedRowsetSize = dwNewRowsetSize;

			// Set bound fields to zero, rebind and reset bound field count
			int nOldFieldsBound = m_nFieldsBound;
			m_nFieldsBound = 0;
			InitRecord();
			m_nFieldsBound = nOldFieldsBound;
		}
	}
	else
	{
		// Just reset the new rowset size
		m_dwRowsetSize = dwNewRowsetSize;
	}

	RETCODE nRetCode;
	AFX_SQL_SYNC(::SQLSetStmtOption(m_hstmt, SQL_ROWSET_SIZE,
		m_dwRowsetSize));
}

void CRecordset::AddNew()
{
	ASSERT_VALID(this);
	ASSERT(m_hstmt != SQL_NULL_HSTMT);
	// we can't construct an INSERT statement w/o any columns
	ASSERT(m_nFields != 0);

	if (!m_bAppendable)
	{
		ThrowDBException(AFX_SQL_ERROR_RECORDSET_READONLY);
	}

	if (m_dwOptions & useMultiRowFetch)
	{
		// Can't use update methods on multi-row rowset
		ASSERT(FALSE);
		return;
	}

	if (m_bCheckCacheForDirtyFields && m_nFields > 0)
	{
		if (m_nEditMode == noMode)
		{
			// First addnew call, cache record values
			StoreFields();
		}
		else
		{
			// subsequent Edit/AddNew call.  Restore values, save them again
			LoadFields();
			StoreFields();
		}
	}

	SetFieldNull(NULL);
	SetFieldDirty(NULL, FALSE);

	m_nEditMode = addnew;
}

void CRecordset::Edit()
{
	ASSERT_VALID(this);
	ASSERT(m_hstmt != SQL_NULL_HSTMT);
	// we can't construct an UPDATE statement w/o any columns
	ASSERT(m_nFields != 0);

	if (!m_bUpdatable)
		ThrowDBException(AFX_SQL_ERROR_RECORDSET_READONLY);

	if (m_dwOptions & useMultiRowFetch)
	{
		// Can't use update methods on multi-row rowset
		ASSERT(FALSE);
		return;
	}

	if (m_bEOF || m_bBOF || m_bDeleted)
	{
		TRACE(traceDatabase, 0, _T("Error: Edit attempt failed - not on a record.\n"));
		ThrowDBException(AFX_SQL_ERROR_NO_CURRENT_RECORD);
	}

	if ((m_nOpenType == dynaset || m_nOpenType == dynamic) &&
		m_nLockMode == pessimistic)
	{
		RETCODE nRetCode;
		AFX_ODBC_CALL(::SQLSetPos(m_hstmt, 1, SQL_POSITION,
			SQL_LCK_EXCLUSIVE));
		if (!Check(nRetCode))
		{
			TRACE(traceDatabase, 0, _T("Error: attempt to lock record failed during Edit function.\n"));
			ThrowDBException(nRetCode);
		}
	}

	if (m_bCheckCacheForDirtyFields && m_nFields > 0)
	{
		if (m_nEditMode == noMode)
			// First edit call, cache record values
			StoreFields();
		else
		{
			// subsequent Edit/AddNew call.  Restore values, save them again
			LoadFields();
			StoreFields();
		}
	}

	m_nEditMode = edit;
}

BOOL CRecordset::Update()
{
	ASSERT_VALID(this);
	ASSERT(m_hstmt != SQL_NULL_HSTMT);

	if (m_dwOptions & useMultiRowFetch)
	{
		// Can't use update methods on multi-row rowset
		ASSERT(FALSE);
		return FALSE;
	}

	if (m_nEditMode != addnew && m_nEditMode != edit)
	{
		TRACE(traceDatabase, 0, _T("Error: must enter Edit or AddNew mode before updating.\n"));
		ThrowDBException(AFX_SQL_ERROR_ILLEGAL_MODE);
	}
	return UpdateInsertDelete();
}

void CRecordset::Delete()
{
	ASSERT_VALID(this);
	ASSERT(m_hstmt != SQL_NULL_HSTMT);

	if (m_dwOptions & useMultiRowFetch)
	{
		// Can't use update methods on multi-row rowset
		ASSERT(FALSE);
		return;
	}

	if (m_nEditMode != noMode)
	{
		TRACE(traceDatabase, 0, _T("Error: attempted to delete while still in Edit or AddNew mode.\n"));
		ThrowDBException(AFX_SQL_ERROR_ILLEGAL_MODE);
	}
	UpdateInsertDelete();   // This call can't fail in delete mode (noMode)
}

void CRecordset::CancelUpdate()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());

	if (m_nEditMode == noMode)
		// Do nothing if not in edit mode
		return;
	else
		// Reset the edit mode
		m_nEditMode = noMode;

	// Restore cache if necessary
	if (m_bCheckCacheForDirtyFields && m_nFields > 0)
		LoadFields();
}

BOOL CRecordset::FlushResultSet()
{
	RETCODE nRetCode;
	AFX_ODBC_CALL(::SQLMoreResults(m_hstmt));

	if (!Check(nRetCode))
	{
		TRACE(traceDatabase, 0, _T("Error: attempt FlushResultSet failed.\n"));
		AfxThrowDBException(nRetCode, m_pDatabase, m_hstmt);
	}

	// Reset state of cursor
	ResetCursor();

	// Don't call Fixups() if we have nothing to fixup
	if (m_nFieldsBound > 0)
	{
		// Need to fixup bound fields
		Fixups();
	}

	return nRetCode != SQL_NO_DATA_FOUND;
}

void CRecordset::GetODBCFieldInfo(LPCTSTR lpszName,
	CODBCFieldInfo& fieldinfo)
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(lpszName != NULL);

	// No data or no column info fetched yet
	if (GetODBCFieldCount() <= 0)
	{
		ASSERT(FALSE);
		return;
	}

	// Get the index of the field corresponding to name
	short nField = GetFieldIndexByName(lpszName);

	GetODBCFieldInfo(nField, fieldinfo);
}

void CRecordset::GetODBCFieldInfo(short nIndex,
	CODBCFieldInfo& fieldinfo)
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());

	// No data or no column info fetched yet
	if (GetODBCFieldCount() <= 0)
	{
		ASSERT(FALSE);
		return;
	}

	// Just copy the data into the field info
	CODBCFieldInfo* pInfo = &m_rgODBCFieldInfos[nIndex];
	fieldinfo.m_strName = pInfo->m_strName;
	fieldinfo.m_nSQLType = pInfo->m_nSQLType;
	fieldinfo.m_nPrecision = pInfo->m_nPrecision;
	fieldinfo.m_nScale = pInfo->m_nScale;
	fieldinfo.m_nNullability = pInfo->m_nNullability;
}

void CRecordset::GetFieldValue(LPCTSTR lpszName,
	CDBVariant& varValue, short nFieldType)
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(lpszName != NULL);

	// No data or no column info fetched yet
	if (GetODBCFieldCount() <= 0)
	{
		ASSERT(FALSE);
		varValue.Clear();
		return;
	}

	// Get the index of the field corresponding to name
	short nField = GetFieldIndexByName(lpszName);

	GetFieldValue(nField, varValue, nFieldType);
}

void CRecordset::GetFieldValue(short nIndex,
	CDBVariant& varValue, short nFieldType)
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());

	// Clear the previous variant
	varValue.Clear();

	// No data or no column info fetched yet
	if (GetODBCFieldCount() <= 0)
	{
		ASSERT(FALSE);
		return;
	}

	// Convert index to 1-based and check range
	nIndex++;
	if (nIndex < 1 || nIndex > GetODBCFieldCount())
	{
		ThrowDBException(AFX_SQL_ERROR_FIELD_NOT_FOUND);
	}

	void* pvData = NULL;
	SQLLEN nLen = 0;

	// Determine the default field type and get the data buffer
	if (nFieldType == DEFAULT_FIELD_TYPE)
	{
		nFieldType =
			GetDefaultFieldType(m_rgODBCFieldInfos[nIndex - 1].m_nSQLType);
	}
	pvData = GetDataBuffer(varValue, nFieldType, &nLen,
		m_rgODBCFieldInfos[nIndex - 1].m_nSQLType,
		m_rgODBCFieldInfos[nIndex - 1].m_nPrecision);

	// Now can actually get the data
	SQLLEN nActualSize = GetData(m_pDatabase, m_hstmt, nIndex,
		nFieldType, pvData,
		(SQLLEN) (varValue.m_dwType == DBVT_WSTRING ? nLen * sizeof(WCHAR) : nLen),
		m_rgODBCFieldInfos[nIndex - 1].m_nSQLType);

	// Handle NULL data separately
	if (nActualSize == SQL_NULL_DATA)
	{
		// Clear value and set the value NULL
		varValue.Clear();
	}
	else
	{
		// May need to cleanup and call SQLGetData again if LONG_VAR data
		switch(nFieldType)
		{
		case SQL_C_CHAR:
			GetLongCharDataAndCleanup(m_pDatabase, m_hstmt, nIndex,
				nActualSize, &pvData, nLen, *varValue.m_pstringA,
				m_rgODBCFieldInfos[nIndex - 1].m_nSQLType, SQL_C_CHAR);
			break;

		case SQL_C_WCHAR:
			GetLongCharDataAndCleanup(m_pDatabase, m_hstmt, nIndex,
				nActualSize, &pvData, nLen, *varValue.m_pstringW,
				m_rgODBCFieldInfos[nIndex - 1].m_nSQLType, SQL_C_WCHAR);
			break;

		case SQL_C_BINARY:
			GetLongBinaryDataAndCleanup(m_pDatabase, m_hstmt, nIndex,
				nActualSize, &pvData, nLen, varValue,
				m_rgODBCFieldInfos[nIndex - 1].m_nSQLType);
			break;
		}
	}
}

void CRecordset::GetFieldValue(LPCTSTR lpszName, CStringW& strValue)
{
	ENSURE_VALID(this);
	ENSURE(IsOpen());
	ENSURE_ARG(lpszName != NULL);

	// No data or no column info fetched yet
	if (GetODBCFieldCount() <= 0)
	{
		ASSERT(FALSE);
		return;
	}

	// Get the index of the field corresponding to name
	short nField = GetFieldIndexByName(lpszName);

	GetFieldValue(nField, strValue);
}

void CRecordset::GetFieldValue(LPCTSTR lpszName, CStringA& strValue)
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(lpszName != NULL);

	// No data or no column info fetched yet
	if (GetODBCFieldCount() <= 0)
	{
		ASSERT(FALSE);
		return;
	}

	// Get the index of the field corresponding to name
	short nField = GetFieldIndexByName(lpszName);

	GetFieldValue(nField, strValue);
}

void CRecordset::GetFieldValue(short nIndex, CStringW &strValue)
{
	GetFieldValueEx(nIndex, strValue, SQL_C_WCHAR);
}

void CRecordset::GetFieldValue(short nIndex, CStringA &strValue)
{
	GetFieldValueEx(nIndex, strValue, SQL_C_CHAR);
}

void CRecordset::SetFieldDirty(void* pv, BOOL bDirty)
{
	ASSERT_VALID(this);

	int nIndex, nIndexEnd;

	// If not setting all NULL, check simple case
	if (pv != NULL)
	{
		// GetBoundFieldIndex returns 1-based index
		nIndex = GetBoundFieldIndex(pv) - 1;

		if (nIndex < 0)
		{
			// pv must be address of field member
			ASSERT(FALSE);
			return;
		}
		else
		{
			nIndexEnd = nIndex;
		}
	}
	else
	{
		nIndex = 0;
		nIndexEnd = m_nFields - 1;
	}

	while (nIndex <= nIndexEnd)
	{
		if (bDirty)
			SetDirtyFieldStatus((DWORD)nIndex);
		else
			ClearDirtyFieldStatus((DWORD)nIndex);

		nIndex++;
	}
}

void CRecordset::SetFieldNull(void* pv, BOOL bNull)
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(!(m_dwOptions & useMultiRowFetch));

	// If not setting all fields NULL, check simple case (param) first
	if (pv != NULL)
	{
		// Cached index is 1-based
		int nIndex = GetBoundParamIndex(pv) - 1;
		if (nIndex >= 0)
		{
			if (bNull)
				SetNullParamStatus(nIndex);
			else
				ClearNullParamStatus(nIndex);
			return;
		}
	}

	// Not a param, must be a field
	if (m_nFields <= 0)
	{
		TRACE(traceDatabase, 0, _T("Warning: SetFieldNull() called with no bound fields.\n"));
		return;
	}

	// Need field exchange mechanism to set PSEUDO NULL values
	// and to reset data lengths (especially for RFX_LongBinary)
	CFieldExchange fx(CFieldExchange::SetFieldNull, this, pv);
	fx.m_nFieldFound = 0;
	fx.m_bField = bNull;
	DoFieldExchange(&fx);

	// If no field found, m_nFieldFound will still be zero
	ASSERT(fx.m_nFieldFound != 0);
}

void CRecordset::SetParamNull(int nIndex, BOOL bNull)
{
	ASSERT_VALID(this);
	ASSERT((DWORD)nIndex < m_nParams);

	// Can be called before Open, but need to alloc status arrays first
	if (!IsOpen())
		AllocStatusArrays();

	if (bNull)
		SetNullParamStatus(nIndex);
	else
		ClearNullParamStatus(nIndex);

	return;
}

void CRecordset::SetLockingMode(UINT nLockMode)
{
	if (nLockMode == pessimistic)
	{
		ENSURE(m_pDatabase != NULL);
		RETCODE nRetCode;
		UDWORD dwTypes;
		SWORD nResult;
		AFX_SQL_SYNC(::SQLGetInfo(m_pDatabase->m_hdbc, SQL_LOCK_TYPES,
			&dwTypes, sizeof(dwTypes), &nResult));
		if (!Check(nRetCode) || !(dwTypes & SQL_LCK_EXCLUSIVE))
			ThrowDBException(AFX_SQL_ERROR_LOCK_MODE_NOT_SUPPORTED);
	}
	m_nLockMode = nLockMode;
}

BOOL CRecordset::Requery()
{
	RETCODE nRetCode;

	ASSERT_VALID(this);
	ASSERT(IsOpen());

	// Can't requery if using direct execution
	if (m_dwOptions & executeDirect)
		return FALSE;

	TRY
	{
		// Detect changes to filter and sort
		if ((m_strFilter != m_strRequeryFilter) || (m_strSort != m_strRequerySort))
		{
			m_strRequeryFilter = m_strFilter;
			m_strRequerySort = m_strSort;
			Close();
			if (m_strRequerySQL.IsEmpty())
				return Open(m_nOpenType, NULL, m_dwOptions);
			else
				return Open(m_nOpenType, m_strRequerySQL, m_dwOptions);
		}
		else
		{
			// Shutdown current query, preserving buffers for performance
			AFX_SQL_SYNC(::SQLFreeStmt(m_hstmt, SQL_CLOSE));
			m_lOpen = AFX_RECORDSET_STATUS_CLOSED;

			// Rebind date/time parameters
			RebindParams(m_hstmt);

			// now attempt to re-execute the SQL Query
			AFX_ODBC_CALL(::SQLExecute(m_hstmt));
			if (!Check(nRetCode))
			{
				TRACE(traceDatabase, 0, _T("Error: Requery attempt failed.\n"));
				ThrowDBException(nRetCode);
			}

			m_lOpen = AFX_RECORDSET_STATUS_OPEN;

			// Reset some cursor properties and fetch first record
			ResetCursor();
			MoveNext();

			// If EOF, then result set empty, so set BOF as well
			m_bBOF = m_bEOF;
		}
	}
	CATCH_ALL(e)
	{
		Close();
		THROW_LAST();
	}
	END_CATCH_ALL

	return TRUE;    // all set
}

// Shutdown any pending query for CRecordset's hstmt's
void CRecordset::Cancel()
{
	ASSERT_VALID(this);
	ASSERT(m_hstmt != SQL_NULL_HSTMT);

	::SQLCancel(m_hstmt);

	// If Update hstmt has been allocated, shut it down also
	if (m_hstmtUpdate != SQL_NULL_HSTMT)
		::SQLCancel(m_hstmtUpdate);
}

CString CRecordset::GetDefaultConnect()
{
	ASSERT_VALID(this);

	return _afxODBCTrail;
}

CString CRecordset::GetDefaultSQL()
{
	ASSERT_VALID(this);

	// Override and add table name or entire SQL SELECT statement
	return _T("");
}

void CRecordset::DoFieldExchange(CFieldExchange* /* pFX */)
{
	ASSERT_VALID(this);

	// Do nothing if dynamically retrieving unbound fields,
	// otherwise override CRecordset and add RFX calls
}

void CRecordset::DoBulkFieldExchange(CFieldExchange* /* pFX */)
{
	ASSERT_VALID(this);

	// To use multi-record data fetching, you must use
	// a derived CRecordset class and call Close explicitly.
	ASSERT(FALSE);
}

void CRecordset::OnSetUpdateOptions(HSTMT hstmt)
{
	ASSERT_VALID(this);
	ASSERT(hstmt != SQL_NULL_HSTMT);
	UNUSED(hstmt);

	// user will override

	return;
}

void CRecordset::OnSetOptions(HSTMT hstmt)
{
	ASSERT_VALID(this);
	ASSERT(hstmt != SQL_NULL_HSTMT);
	ENSURE(m_pDatabase != NULL);

	// Inherit options settings from CDatabase
	m_pDatabase->OnSetOptions(hstmt);

	// If fowardOnly recordset and not using SQLExtendedFetch, quit now
	if (m_nOpenType == forwardOnly && !(m_dwOptions & useExtendedFetch))
		return;

	// Turn on bookmark support if necessary
	EnableBookmarks();

	// If using forwardOnly and extended fetch, quit now
	if (m_nOpenType == forwardOnly)
		return;

	// Make sure driver supports extended fetch, ODBC 2.0 and requested cursor type
	VerifyDriverBehavior();
	DWORD dwScrollType = VerifyCursorSupport();

	// Set the update method, concurrency and cursor type
	SetUpdateMethod();
	SetConcurrencyAndCursorType(hstmt, dwScrollType);
}

// Screen for errors.
BOOL CRecordset::Check(RETCODE nRetCode) const
{
	ASSERT_VALID(this);

	switch (nRetCode)
	{
	case SQL_SUCCESS_WITH_INFO:
#ifdef _DEBUG
	{
		CDBException e(nRetCode);
		TRACE(traceDatabase, 0, _T("Warning: ODBC Success With Info, "));
		e.BuildErrorString(m_pDatabase, m_hstmt);
	}
#endif

		// Fall through

	case SQL_SUCCESS:
	case SQL_NO_DATA_FOUND:
	case SQL_NEED_DATA:
		return TRUE;
	}

	return FALSE;
}

void CRecordset::PreBindFields()
{
	// Do nothing
}

//////////////////////////////////////////////////////////////////////////////
// CRecordset internal functions

// Cache state information internally in CRecordset
void CRecordset::SetState(int nOpenType, LPCTSTR lpszSQL, DWORD dwOptions)
{
	if (nOpenType == AFX_DB_USE_DEFAULT_TYPE)
		m_nOpenType = m_nDefaultType;
	else
		m_nOpenType = nOpenType;

	m_bAppendable = (dwOptions & appendOnly) != 0 ||
		(dwOptions & readOnly) == 0;
	m_bUpdatable = (dwOptions & readOnly) == 0 &&
		(dwOptions & appendOnly) == 0;

	// Can turn off dirty field checking via dwOptions
	if (dwOptions & noDirtyFieldCheck || dwOptions & useMultiRowFetch)
		m_bCheckCacheForDirtyFields = FALSE;

	// Set recordset readOnly if forwardOnly
	if (m_nOpenType == forwardOnly && !(dwOptions & readOnly))
	{
		TRACE(traceDatabase, 0, _T("Warning: Setting forwardOnly recordset readOnly.\n"));

		dwOptions |= readOnly;

		// If using multiRowFetch also set useExtendFetch
		if (dwOptions & useMultiRowFetch)
			dwOptions |= useExtendedFetch;
	}

	// Archive info for use in Requery
	m_dwOptions = dwOptions;
	m_strRequerySQL = lpszSQL;
	m_strRequeryFilter = m_strFilter;
	m_strRequerySort = m_strSort;
}

// Allocate the Hstmt and implicitly create and open Database if necessary
BOOL CRecordset::AllocHstmt()
{
	RETCODE nRetCode;
	if (m_hstmt == SQL_NULL_HSTMT)
	{
		CString strDefaultConnect;
		TRY
		{
			if (m_pDatabase == NULL)
			{
				m_pDatabase = new CDatabase();
				m_bRecordsetDb = TRUE;
			}

			strDefaultConnect = GetDefaultConnect();

			// If not already opened, attempt to open
			if (!m_pDatabase->IsOpen())
			{
				BOOL bUseCursorLib = m_bUseODBCCursorLib;

				// If non-readOnly snapshot request must use cursor lib
				if (m_nOpenType == snapshot && !(m_dwOptions & readOnly))
				{
					// This assumes drivers only support readOnly snapshots
					bUseCursorLib = TRUE;
				}

				if (!m_pDatabase->Open(_T(""), FALSE, FALSE,
					strDefaultConnect, bUseCursorLib))
				{
					return FALSE;
				}

				// If snapshot cursor requested and not supported, load cursor lib
				if (m_nOpenType == snapshot && !bUseCursorLib)
				{
					// Get the supported cursor types
					RETCODE nResult;
					UDWORD dwDriverScrollOptions;
					AFX_SQL_SYNC(::SQLGetInfo(m_pDatabase->m_hdbc, SQL_SCROLL_OPTIONS,
						&dwDriverScrollOptions, sizeof(dwDriverScrollOptions), &nResult));
					if (!Check(nRetCode))
					{
						TRACE(traceDatabase, 0, _T("Error: ODBC failure checking for driver capabilities.\n"));
						ThrowDBException(nRetCode);
					}

					// Check for STATIC cursor support and load cursor lib
					if (!(dwDriverScrollOptions & SQL_SO_STATIC))
					{
						m_pDatabase->Close();
						if (!m_pDatabase->Open(_T(""), FALSE, FALSE,
							strDefaultConnect, TRUE))
							return FALSE;
					}
				}
			}

			AFX_SQL_SYNC(::SQLAllocStmt(m_pDatabase->m_hdbc, &m_hstmt));
			if (!Check(nRetCode))
				ThrowDBException(SQL_INVALID_HANDLE);

			// Add to list of CRecordsets with alloced hstmts
			AfxLockGlobals(CRIT_ODBC);
			TRY
			{
				m_pDatabase->m_listRecordsets.AddHead(this);
			}
			CATCH_ALL(e)
			{
				AfxUnlockGlobals(CRIT_ODBC);
				THROW_LAST();
			}
			END_CATCH_ALL
			AfxUnlockGlobals(CRIT_ODBC);
		}
		CATCH_ALL(e)
		{
			TRACE(traceDatabase, 0, _T("Error: CDatabase create for CRecordset failed.\n"));

			NO_CPP_EXCEPTION(strDefaultConnect.Empty());
			if (m_bRecordsetDb)
			{
				delete m_pDatabase;
				m_pDatabase = NULL;
			}
			ASSERT(m_hstmt == SQL_NULL_HSTMT);
			THROW_LAST();
		}
		END_CATCH_ALL
	}

	return TRUE;
}

// Initialize the status arrays and create the SQL
void CRecordset::BuildSQL(LPCTSTR lpszSQL)
{
	if (lpszSQL == NULL)
		m_strSQL = GetDefaultSQL();
	else
		m_strSQL = lpszSQL;

	// Set any supplied params
	if (m_nParams != 0)
	{
		UINT nParams = BindParams(m_hstmt);
		ASSERT(nParams == m_nParams);
	}

	// Construct the SQL string
	BuildSelectSQL();
	AppendFilterAndSortSQL();

	// Do some extra checking if trying to set recordset updatable or appendable
	if ((m_bUpdatable || m_bAppendable) && !IsRecordsetUpdatable())
		m_bUpdatable = m_bAppendable = FALSE;

	ENSURE(m_pDatabase != NULL);
	if (m_bUpdatable && m_bUseUpdateSQL && m_pDatabase->m_bAddForUpdate)
		m_strSQL += _afxForUpdate;

	// Replace brackets with SQL_IDENTIFIER_QUOTE_CHAR
	m_pDatabase->ReplaceBrackets(m_strSQL.GetBuffer(0));
	m_strSQL.ReleaseBuffer();
}

// Prepare and Execute the SQL or simple call SQLExecDirect, resetting concurrency if necessary
void CRecordset::PrepareAndExecute()
{
	RETCODE nRetCode = 0;
	BOOL bConcurrency = FALSE;
	TCHAR *pszSQL = const_cast<LPTSTR>(static_cast<LPCTSTR>(m_strSQL));

	while (!bConcurrency)
	{
		// Prepare or execute the query
		if (m_dwOptions & executeDirect)
			AFX_ODBC_CALL(::SQLExecDirect(m_hstmt, reinterpret_cast<SQLTCHAR *>(pszSQL), SQL_NTS));
		else
			AFX_ODBC_CALL(::SQLPrepare(m_hstmt, reinterpret_cast<SQLTCHAR *>(pszSQL), SQL_NTS));
		if (Check(nRetCode))
			bConcurrency = TRUE;
		else
		{
			// If "Driver Not Capable" error, assume cursor type doesn't
			// support requested concurrency and try alternate concurrency.
			CDBException* e = new CDBException(nRetCode);
			e->BuildErrorString(m_pDatabase, m_hstmt);
			if (m_dwConcurrency != SQL_CONCUR_READ_ONLY &&
				e->m_strStateNativeOrigin.Find(_afxDriverNotCapable) >= 0)
			{
				TRACE(traceDatabase, 0, _T("Warning: Driver does not support requested concurrency.\n"));

				// Don't need exception to persist while attempting to reset concurrency
				e->Delete();

				// ODBC will automatically attempt to set alternate concurrency if
				// request fails, but it won't try LOCK even if driver supports it.
				if ((m_dwDriverConcurrency & SQL_SCCO_LOCK) &&
					(m_dwConcurrency == SQL_CONCUR_ROWVER ||
					m_dwConcurrency == SQL_CONCUR_VALUES))
				{
					m_dwConcurrency = SQL_CONCUR_LOCK;
				}
				else
				{
					m_dwConcurrency = SQL_CONCUR_READ_ONLY;
					m_bUpdatable = m_bAppendable = FALSE;

					TRACE(traceDatabase, 0, _T("Warning: Setting recordset read only.\n"));
				}

				// Attempt to reset the concurrency model.
				AFX_SQL_SYNC(::SQLSetStmtOption(m_hstmt, SQL_CONCURRENCY,
					m_dwConcurrency));
				if (!Check(nRetCode))
				{
					TRACE(traceDatabase, 0, _T("Error: ODBC failure setting recordset concurrency.\n"));
					ThrowDBException(nRetCode);
				}
			}
			else
			{
				TRACE(traceDatabase, 0, _T("Error: ODBC failure on SQLPrepare or SQLExecDirect\n"));
				THROW(e);
			}
		}
	}


	// now attempt to execute the SQL Query if not executed already
	if (!(m_dwOptions & executeDirect))
	{
		AFX_ODBC_CALL(::SQLExecute(m_hstmt));
		if (!Check(nRetCode))
			ThrowDBException(nRetCode);
	}
	m_lOpen = AFX_RECORDSET_STATUS_OPEN;

	// SQLExecute or SQLExecDirect may have changed an option value
	if (nRetCode == SQL_SUCCESS_WITH_INFO)
	{
		// Check if concurrency was changed in order to mark
		// recordset non-updatable if necessary
		DWORD dwConcurrency;
		AFX_SQL_SYNC(::SQLGetStmtOption(m_hstmt, SQL_CONCURRENCY, &dwConcurrency));
		if (!Check(nRetCode))
			ThrowDBException(nRetCode);

		if (dwConcurrency == SQL_CONCUR_READ_ONLY && (m_bUpdatable || m_bAppendable))
		{
			m_bUpdatable = FALSE;
			m_bAppendable = FALSE;

			TRACE(traceDatabase, 0, _T("Warning: Concurrency changed by driver.\n"));
			TRACE(traceDatabase, 0, _T("\tMarking CRecordset as not updatable.\n"));
		}
	}
}

// Ensure that driver supports extended fetch and ODBC 2.0 if necessary
void CRecordset::VerifyDriverBehavior()
{
	ENSURE(m_pDatabase != NULL);
	RETCODE nRetCode;
	UWORD wScrollable;
	// If SQLExtendedFetch not supported, use SQLFetch
	AFX_SQL_SYNC(::SQLGetFunctions(m_pDatabase->m_hdbc,
		SQL_API_SQLEXTENDEDFETCH, &wScrollable));
	if (!Check(nRetCode))
	{
		TRACE(traceDatabase, 0, _T("Error: ODBC failure determining whether recordset is scrollable.\n"));
		ThrowDBException(nRetCode);
	}
	m_bScrollable = wScrollable;
	if (!m_bScrollable)
	{
		TRACE(traceDatabase, 0, _T("Warning: SQLExtendedFetch not supported by driver\n"));
		TRACE(traceDatabase, 0, _T("and/or cursor library not loaded. Opening forwardOnly.\n"));
		TRACE(traceDatabase, 0, _T("for use with SQLFetch.\n"));

		m_bUpdatable = FALSE;
		return;
	}

	TCHAR szResult[30];
	SWORD nResult;
	// require ODBC v2.0
	AFX_SQL_SYNC(::SQLGetInfo(m_pDatabase->m_hdbc, SQL_ODBC_VER,
		szResult, sizeof(szResult), &nResult));
	if (!Check(nRetCode))
	{
		TRACE(traceDatabase, 0, _T("Error: ODBC failure checking for driver capabilities.\n"));
		ThrowDBException(nRetCode);
	}
	if (szResult[0] == '0' && szResult[1] < '2')
		ThrowDBException(AFX_SQL_ERROR_ODBC_V2_REQUIRED);
}

// Check that driver supports requested cursor type
DWORD CRecordset::VerifyCursorSupport()
{
	ENSURE(m_pDatabase != NULL);
	RETCODE nRetCode;
	SWORD nResult;
	UDWORD dwDriverScrollOptions;
	AFX_SQL_SYNC(::SQLGetInfo(m_pDatabase->m_hdbc, SQL_SCROLL_OPTIONS,
		&dwDriverScrollOptions, sizeof(dwDriverScrollOptions), &nResult));
	if (!Check(nRetCode))
	{
		TRACE(traceDatabase, 0, _T("Error: ODBC failure checking for driver capabilities.\n"));
		ThrowDBException(nRetCode);
	}

	SDWORD dwScrollOptions = SQL_CURSOR_FORWARD_ONLY;
	if (m_nOpenType == dynaset)
	{
		// Dynaset support requires ODBC's keyset driven cursor model
		if (!(dwDriverScrollOptions & SQL_SO_KEYSET_DRIVEN))
			ThrowDBException(AFX_SQL_ERROR_DYNASET_NOT_SUPPORTED);
		dwScrollOptions = SQL_CURSOR_KEYSET_DRIVEN;
	}
	else if (m_nOpenType == snapshot)
	{
		// Snapshot support requires ODBC's static cursor model
		if (!(dwDriverScrollOptions & SQL_SO_STATIC))
			ThrowDBException(AFX_SQL_ERROR_SNAPSHOT_NOT_SUPPORTED);
		dwScrollOptions = SQL_CURSOR_STATIC;
	}
	else
	{
		// Dynamic cursor support requires ODBC's dynamic cursor model
		if (!(dwDriverScrollOptions & SQL_SO_DYNAMIC))
			ThrowDBException(AFX_SQL_ERROR_DYNAMIC_CURSOR_NOT_SUPPORTED);
		dwScrollOptions = SQL_CURSOR_DYNAMIC;
	}

	return dwScrollOptions;
}

void CRecordset::AllocAndCacheFieldInfo()
{
	ASSERT(GetODBCFieldCount() < 0);
	ASSERT(m_rgODBCFieldInfos == NULL);

	RETCODE nRetCode;
	SWORD nActualLen;

	// Cache the number of result columns
	AFX_ODBC_CALL(::SQLNumResultCols(m_hstmt, &m_nResultCols));
	if (!Check(nRetCode))
	{
		TRACE(traceDatabase, 0, _T("Error: Can't get field info.\n"));
		ThrowDBException(nRetCode);
	}

	// If there are no fields quit now
	if (m_nResultCols == 0)
		return;

	// Allocate buffer and get the ODBC meta data
	m_rgODBCFieldInfos = new CODBCFieldInfo[m_nResultCols];
	TCHAR *lpszFieldName;

	// Get the field info each field
	for (WORD n = 1; n <= GetODBCFieldCount(); n++)
	{
		// Reset the buffer to point to next element
		lpszFieldName =
			static_cast<LPTSTR>(m_rgODBCFieldInfos[n - 1].m_strName.GetBuffer(MAX_FNAME_LEN + 1));

		AFX_ODBC_CALL(::SQLDescribeCol(m_hstmt, n,
			reinterpret_cast<SQLTCHAR *>(lpszFieldName), MAX_FNAME_LEN, &nActualLen,
			&m_rgODBCFieldInfos[n - 1].m_nSQLType,
			&m_rgODBCFieldInfos[n - 1].m_nPrecision,
			&m_rgODBCFieldInfos[n - 1].m_nScale,
			&m_rgODBCFieldInfos[n - 1].m_nNullability));
		m_rgODBCFieldInfos[n - 1].m_strName.ReleaseBuffer(nActualLen);

		if (!Check(nRetCode))
		{
			TRACE(traceDatabase, 0, _T("Error: ODBC failure getting field #%d info.\n"), n);
			ThrowDBException(nRetCode);
		}
	}
}

void CRecordset::AllocRowset()
{
	if (m_dwOptions & useMultiRowFetch)
		SetRowsetSize(m_dwRowsetSize);
	else
	{
		// Not using bulk row fetch, set rowset size to 1
		m_rgRowStatus = new WORD[1];
		m_dwRowsetSize = 1;
	}
}

void CRecordset::FreeRowset()
{
	// Delete the rowset status
	delete [] m_rgRowStatus;
	m_rgRowStatus = NULL;

	if (m_dwOptions & useMultiRowFetch &&
		!(m_dwOptions & userAllocMultiRowBuffers))
	{
		// Calling virtual function, DoBulkFieldExchange, here is bad
		// because Close then FreeRowset may get called from destructor.
		// There is no simple choice however if RFX_Bulk functions do
		// a memory allocation. The net result is that users MUST call
		// Close explicitly (rather than relying on destructor) if
		// using multi row fetches, otherwise they will get a memory leak.
		// If rowset already allocated, delete old rowset buffers
		if (m_dwAllocatedRowsetSize != 0)
		{
			CFieldExchange fx(CFieldExchange::DeleteMultiRowBuffer, this);
			DoBulkFieldExchange(&fx);
		}
	}

	m_dwAllocatedRowsetSize = 0;
}

void CRecordset::EnableBookmarks()
{
	
	// Turn on bookmark support if necessary
	if (m_dwOptions & useBookmarks)
	{
		RETCODE nRetCode;
		ENSURE(m_pDatabase != NULL);
		// Set stmt option if bookmarks supported by driver
		if (m_pDatabase->GetBookmarkPersistence() & SQL_BP_SCROLL)
		{
			AFX_SQL_SYNC(::SQLSetStmtOption(m_hstmt, SQL_USE_BOOKMARKS,
				SQL_UB_ON));
			if (!Check(nRetCode))
			{
				TRACE(traceDatabase, 0, _T("Error: Can't enable bookmark support.\n"));
				ThrowDBException(nRetCode);
			}
		}
	}
}

// Determine whether to use SQLSetPos or positioned update SQL
void CRecordset::SetUpdateMethod()
{
	ENSURE(m_pDatabase != NULL);
	// Determine update method
	if (m_pDatabase->m_dwUpdateOptions & AFX_SQL_SETPOSUPDATES)
		m_bUseUpdateSQL = FALSE;
	else if (m_pDatabase->m_dwUpdateOptions & AFX_SQL_POSITIONEDSQL)
		m_bUseUpdateSQL = TRUE;
	else
		m_bUpdatable = FALSE;
 }

// Determine which type of concurrency to set, set it and cursor type
void CRecordset::SetConcurrencyAndCursorType(HSTMT hstmt, DWORD dwScrollOptions)
{
	ENSURE(m_pDatabase != NULL);
	RETCODE nRetCode;
	SWORD nResult;

	m_dwConcurrency = SQL_CONCUR_READ_ONLY;
	if ((m_bUpdatable || m_bAppendable) && m_pDatabase->m_bUpdatable)
	{
		AFX_SQL_SYNC(::SQLGetInfo(m_pDatabase->m_hdbc, SQL_SCROLL_CONCURRENCY,
			&m_dwDriverConcurrency, sizeof(m_dwDriverConcurrency), &nResult));
		if (!Check(nRetCode))
		{
			TRACE(traceDatabase, 0, _T("Error: ODBC failure checking recordset updatability.\n"));
			ThrowDBException(nRetCode);
		}

		if (m_nLockMode == pessimistic)
		{
			if (m_dwDriverConcurrency & SQL_SCCO_LOCK)
				m_dwConcurrency = SQL_CONCUR_LOCK;
#ifdef _DEBUG
			else
				TRACE(traceDatabase, 0, _T("Warning: locking not supported, setting recordset read only.\n"));
#endif
		}
		else
		{
			// Use cheapest, most concurrent model
			if (m_dwDriverConcurrency & SQL_SCCO_OPT_ROWVER)
				m_dwConcurrency = SQL_CONCUR_ROWVER;
			else if (m_dwDriverConcurrency & SQL_SCCO_OPT_VALUES)
				m_dwConcurrency = SQL_CONCUR_VALUES;
			else if (m_dwDriverConcurrency & SQL_SCCO_LOCK)
				m_dwConcurrency = SQL_CONCUR_LOCK;
		}
	}

	// Set cursor type (Let rowset size default to 1).
	AFX_SQL_SYNC(::SQLSetStmtOption(hstmt, SQL_CURSOR_TYPE, dwScrollOptions));
	if (!Check(nRetCode))
	{
		TRACE(traceDatabase, 0, _T("Error: ODBC failure setting recordset cursor type.\n"));
		ThrowDBException(nRetCode);
	}

	// Set the concurrency model (NOTE: may have to reset concurrency later).
	AFX_SQL_SYNC(::SQLSetStmtOption(hstmt, SQL_CONCURRENCY, m_dwConcurrency));
	if (!Check(nRetCode))
	{
		TRACE(traceDatabase, 0, _T("Error: ODBC failure setting recordset concurrency.\n"));
		ThrowDBException(nRetCode);
	}
}

// Is there a join, stored proc call, GROUP BY, UNION or missing FROM?
BOOL CRecordset::IsSQLUpdatable(LPCTSTR lpszSQL)
{
	ENSURE_ARG(lpszSQL);
	// Parse for query procedure call keyword or return param
	if (!(_tcsnicmp(lpszSQL, _afxCall, lstrlen(_afxCall)-1) == 0 ||
		_tcsnicmp(lpszSQL, _afxParamCall, lstrlen(_afxParamCall)-1) == 0))
		// Assume this is a select query
		return IsSelectQueryUpdatable(lpszSQL);
	else
		// Don't know the table name to update in procedure call
		return FALSE;
}

BOOL CRecordset::IsSelectQueryUpdatable(LPCTSTR lpszSQL)
{
	LPCTSTR lpchTokenFrom;
	LPCTSTR lpchToken;
	LPCTSTR lpchTokenNext;
	LPTSTR lpszSQLStart;
	CString strSQL = lpszSQL;

	lpchTokenFrom = FindSQLToken(strSQL, _afxFrom);
	if (lpchTokenFrom == NULL)
	{
		TRACE(traceDatabase, 0, _T("Warning: Missing ' FROM ', recordset not updatable \n"));
		return FALSE;
	}

	lpchToken = FindSQLToken(strSQL, _T(" GROUP BY "));
	if (lpchToken != NULL)
	{
		TRACE(traceDatabase, 0, _T("Warning: SQL contains ' GROUP BY ', recordset not updatable \n"));
		return FALSE;
	}

	lpchToken = FindSQLToken(strSQL, _T(" UNION "));
	if (lpchToken != NULL)
	{
		TRACE(traceDatabase, 0, _T("Warning: SQL contains ' UNION ', recordset not updatable \n"));
		return FALSE;
	}

	// Find next token after FROM (can't have HAVING clause without GROUP BY)
	lpchToken = FindSQLToken(strSQL, _afxWhere);
	lpchTokenNext = FindSQLToken(strSQL, _afxOrderBy);

	lpszSQLStart = strSQL.GetBuffer(0);

	if (lpchTokenNext == NULL)
		lpchTokenNext = lpchToken;
	else if (lpchToken != NULL && lpchToken < lpchTokenNext)
		lpchTokenNext = lpchToken;

	if (lpchTokenNext != NULL)
	{
		int nFromLength = int(lpchTokenNext - lpchTokenFrom);
		Checked::memmove_s(lpszSQLStart, strSQL.GetLength()*sizeof(TCHAR), 
			lpchTokenFrom, nFromLength*sizeof(TCHAR));
		lpszSQLStart[nFromLength] = '\0';
	}
	else
	{
		Checked::memmove_s(lpszSQLStart, strSQL.GetLength()*sizeof(TCHAR), 
			lpchTokenFrom, (lstrlen(lpchTokenFrom) + 1) * sizeof(TCHAR));
	}

	strSQL.ReleaseBuffer();

	if (IsJoin(strSQL))
	{
		TRACE(traceDatabase, 0, _T("Warning: SQL contains join, recordset not updatable \n"));
		return FALSE;
	}

	// Cache table name (skip over " FROM ")
	m_strTableName = strSQL.Right(strSQL.GetLength()-6);

	return TRUE;
}


// Check FROM clause for join syntax
BOOL PASCAL CRecordset::IsJoin(LPCTSTR lpszJoinClause)
{
	// Look for comma in join clause
	if (FindSQLToken(lpszJoinClause, _afxComma) != NULL)
		return TRUE;

	// Look for outer join clause
	if (FindSQLToken(lpszJoinClause, _T(" JOIN ")) != NULL)
		return TRUE;

	return FALSE;
}

// Searches string for given token not in single quotes or brackets
LPCTSTR PASCAL CRecordset::FindSQLToken(LPCTSTR lpszSQL, LPCTSTR lpszSQLToken)
{
	ENSURE_ARG(lpszSQL!=NULL && lpszSQLToken!=NULL);
	BOOL bInLiteral;
	BOOL bInBrackets;
	int nLeftBrackets;
	int nRightBrackets;
	LPCTSTR lpch;
	LPCTSTR lpchSQLStart;
	LPCTSTR lpszFoundToken;
	int nTokenOffset = 0;
	CString strSQL = lpszSQL;

	strSQL.MakeUpper();
	lpszFoundToken = strSQL.GetBuffer(0);
	lpchSQLStart = lpszFoundToken;

	do
	{
		lpszFoundToken = _tcsstr(lpszFoundToken + nTokenOffset, lpszSQLToken);
		if (lpszFoundToken == NULL)
		{
			strSQL.ReleaseBuffer();
			return NULL;
		}

		bInLiteral = bInBrackets = FALSE;
		nLeftBrackets = nRightBrackets = 0;

		// Check if embedded in literal or brackets
		for (lpch = lpchSQLStart; lpch < lpszFoundToken; lpch = _tcsinc(lpch))
		{
			if (*lpch == _afxLiteralSeparator)
			{
				// Skip if escape literal
				if (*_tcsinc(lpch) == _afxLiteralSeparator)
					lpch = _tcsinc(lpch);
				else
					bInLiteral = !bInLiteral;
			}
			else if (!bInLiteral && (*lpch == '['))
			{
				// Skip if escape left bracket
				if (*_tcsinc(lpch) == '[')
					lpch = _tcsinc(lpch);
				else
				{
					nLeftBrackets++;
					if ((nLeftBrackets - nRightBrackets) > 0)
						bInBrackets = TRUE;
					else
						bInBrackets = FALSE;
				}
			}
			else if (!bInLiteral && (*lpch == ']'))
			{
				// Skip if escape right bracket
				if (*_tcsinc(lpch) == ']')
					lpch = _tcsinc(lpch);
				else
				{
					nRightBrackets++;
					if ((nLeftBrackets - nRightBrackets) > 0)
						bInBrackets = TRUE;
					else
						bInBrackets = FALSE;
				}
			}
		}

		// If first iteration, reset the offset to jump over found token
		if (nTokenOffset == 0)
			nTokenOffset = lstrlen(lpszSQLToken);

	} while (bInLiteral || bInBrackets);

	lpszFoundToken = lpszSQL + (lpszFoundToken - lpchSQLStart);
	strSQL.ReleaseBuffer();
	return lpszFoundToken;
}

// Bind fields (if not already bound), then retrieve 1st record
void CRecordset::InitRecord()
{
	// fields to bind
	if (m_nFields != 0)
	{
		m_nFieldsBound = BindFieldsToColumns();
		// m_nFields doesn't reflect number of
		// RFX_ output column calls in Do[Bulk]FieldExchange
		ASSERT((int)m_nFields == m_nFieldsBound);

		// Allocate the data cache if necessary
		if (m_nFields > 0 && m_bCheckCacheForDirtyFields)
			AllocDataCache();
	}
	else
		// No fields to bind, don't attempt to bind again
		m_nFieldsBound = -1;
}

void CRecordset::ResetCursor()
{
	m_bEOFSeen = m_bBOF = m_bEOF = FALSE;
	m_bDeleted = FALSE;
	m_lCurrentRecord = AFX_CURRENT_RECORD_BOF;
	m_lRecordCount = 0;
}

void CRecordset::CheckRowsetCurrencyStatus(UWORD wFetchType, long nRows)
{
	if (!m_bScrollable && wFetchType != SQL_FETCH_NEXT)
	{
		TRACE(traceDatabase, 0, _T("Error: forward-only recordsets only support MoveNext.\n"));
		ThrowDBException(AFX_SQL_ERROR_RECORDSET_FORWARD_ONLY);
	}

	if (IsEOF() && IsBOF())
	{
		// Can't position cursor if recordset empty
		TRACE(traceDatabase, 0, _T("Error: attempted to position cursor on empty recordset.\n"));
		ThrowDBException(AFX_SQL_ERROR_NO_DATA_FOUND);
	}

	if (m_nOpenType != dynamic)
	{
		if (IsEOF() && (wFetchType == SQL_FETCH_NEXT ||
		(wFetchType == SQL_FETCH_RELATIVE && nRows > 0)))
		{
			// if already at EOF, throw an exception
			TRACE(traceDatabase, 0, _T("Error: attempted to move past EOF.\n"));
			ThrowDBException(AFX_SQL_ERROR_NO_DATA_FOUND);
		}
		else if (IsBOF() && (wFetchType == SQL_FETCH_PRIOR ||
		(wFetchType == SQL_FETCH_RELATIVE && nRows < 0)))
		{
			// if already at BOF, throw an exception
			TRACE(traceDatabase, 0, _T("Error: attempted to move before BOF.\n"));
			ThrowDBException(AFX_SQL_ERROR_NO_DATA_FOUND);
		}
	}
}

RETCODE CRecordset::FetchData(UWORD wFetchType, SDWORD nRow,
	SQLULEN* pdwRowsFetched)
{
	RETCODE nRetCode;

	if (m_nOpenType == forwardOnly && !(m_dwOptions & useExtendedFetch))
	{
		ASSERT(wFetchType == SQL_FETCH_NEXT);

		AFX_ODBC_CALL(::SQLFetch(m_hstmt));
		ENSURE_ARG(pdwRowsFetched != NULL);
		*pdwRowsFetched = 1;

		m_bDeleted = FALSE;
	}
	else
	{
		AFX_ODBC_CALL(::SQLExtendedFetch(m_hstmt, wFetchType,
			nRow, pdwRowsFetched, m_rgRowStatus));
		
		if (nRetCode == SQL_SUCCESS || nRetCode == SQL_SUCCESS_WITH_INFO )
		{
			// Set deleted status
			m_bDeleted = GetRowStatus(1) == SQL_ROW_DELETED;
		}
	}

	CheckRowsetError(nRetCode);

	return nRetCode;
}

void CRecordset::SkipDeletedRecords(UWORD wFetchType, long nRows,
	SQLULEN* pdwRowsFetched, RETCODE* pnRetCode)
{
	ASSERT(!(m_dwOptions & useMultiRowFetch));
	ASSERT(wFetchType == SQL_FETCH_RELATIVE ||
		wFetchType == SQL_FETCH_FIRST ||
		wFetchType == SQL_FETCH_NEXT ||
		wFetchType == SQL_FETCH_LAST ||
		wFetchType == SQL_FETCH_PRIOR);
	ASSERT(nRows != 0);

	UWORD wDeletedFetchType = wFetchType;
	DWORD dwDeletedRows = abs(nRows);
	BOOL m_bDone;

	switch (wFetchType)
	{
	case SQL_FETCH_FIRST:
		wDeletedFetchType = SQL_FETCH_NEXT;
		break;

	case SQL_FETCH_LAST:
		wDeletedFetchType = SQL_FETCH_PRIOR;
		break;

	case SQL_FETCH_RELATIVE:
		if (nRows > 0)
			wDeletedFetchType = SQL_FETCH_NEXT;
		else
			wDeletedFetchType = SQL_FETCH_PRIOR;
		break;
	}

	// First fetch is as expected unless relative fetch
	if (wFetchType != SQL_FETCH_RELATIVE)
	{
		*pnRetCode = FetchData(wFetchType, 1, pdwRowsFetched);
		m_bDone = !m_bDeleted;
	}
	else
	{
		// Since deleted records must be skipped Move(n)
		// must be turned into n MoveNext/MovePrev calls
		*pnRetCode = FetchData(wDeletedFetchType, 1, pdwRowsFetched);
		if (!m_bDeleted)
		{
			dwDeletedRows--;
			m_bDone = dwDeletedRows == 0;
		}
		else
			m_bDone = FALSE;
	}

	// Continue fetching until all req'd deleted records skipped
	while (*pnRetCode != SQL_NO_DATA_FOUND && !m_bDone)
	{
		*pnRetCode = FetchData(wDeletedFetchType, 1, pdwRowsFetched);

		if (wFetchType == SQL_FETCH_RELATIVE)
		{
			if (!m_bDeleted)
			{
				dwDeletedRows--;
				m_bDone = dwDeletedRows == 0;
			}
			else
				m_bDone = FALSE;
		}
		else
			m_bDone = !m_bDeleted;
	}
}

void CRecordset::SetRowsetCurrencyStatus(RETCODE nRetCode,
	UWORD wFetchType, long nRows, SQLULEN dwRowsFetched)
{
	UNUSED_ALWAYS(dwRowsFetched);

	// Set the fetch direction
	int nDirection = 0;

	switch (wFetchType)
	{
	case SQL_FETCH_FIRST:
		nDirection = 1;
		if (nRetCode == SQL_NO_DATA_FOUND)
		{
			m_lCurrentRecord = AFX_CURRENT_RECORD_UNDEFINED;
			m_lRecordCount = 0;
		}
		else
			m_lCurrentRecord = 0;
		break;

	case SQL_FETCH_NEXT:
		nDirection = 1;
		_AfxSetCurrentRecord(&m_lCurrentRecord, nRows, nRetCode);
		_AfxSetRecordCount(&m_lRecordCount, m_lCurrentRecord,
			m_bEOFSeen, nRetCode);

		// This is the only way to know you've hit the end (m_bEOFSeen)
		if (!m_bEOFSeen && nRetCode == SQL_NO_DATA_FOUND &&
			m_lRecordCount == m_lCurrentRecord + 1)
		{
			m_bEOFSeen = TRUE;
		}
		break;

	case SQL_FETCH_LAST:
		nDirection = -1;
		if (nRetCode == SQL_NO_DATA_FOUND)
		{
			m_lCurrentRecord = AFX_CURRENT_RECORD_UNDEFINED;
			m_lRecordCount = 0;
		}
		else if (m_bEOFSeen)
			m_lCurrentRecord = m_lRecordCount - 1;
		else
			m_lCurrentRecord = AFX_CURRENT_RECORD_UNDEFINED;
		break;

	case SQL_FETCH_PRIOR:
		nDirection = -1;
		// If doing MovePrev after m_bEOF, don't increment current rec
		if (!m_bEOF)
			_AfxSetCurrentRecord(&m_lCurrentRecord, nRows, nRetCode);
		break;

	case SQL_FETCH_RELATIVE:
		nDirection = nRows;
		_AfxSetCurrentRecord(&m_lCurrentRecord, nRows, nRetCode);
		_AfxSetRecordCount(&m_lRecordCount, m_lCurrentRecord,
			m_bEOFSeen, nRetCode);
		break;

	case SQL_FETCH_ABSOLUTE:
		nDirection = nRows;
		if (nRetCode != SQL_NO_DATA_FOUND)
		{
			if (nRows > 0)
				m_lCurrentRecord = nRows - 1;
			else if (m_bEOFSeen)
				m_lCurrentRecord = m_lRecordCount + nRows;
			else
				m_lCurrentRecord = AFX_CURRENT_RECORD_UNDEFINED;
		}
		else
			m_lCurrentRecord = AFX_CURRENT_RECORD_UNDEFINED;

		_AfxSetRecordCount(&m_lRecordCount, m_lCurrentRecord,
			m_bEOFSeen, nRetCode);
		break;

	case SQL_FETCH_BOOKMARK:
		nDirection = 0;
		m_lCurrentRecord = AFX_CURRENT_RECORD_UNDEFINED;
		break;
	}

	// Set the BOF/EOF flags
	if (nRetCode == SQL_NO_DATA_FOUND)
	{
		if (wFetchType == SQL_FETCH_FIRST || wFetchType == SQL_FETCH_LAST ||
			wFetchType == SQL_FETCH_BOOKMARK)
		{
			// If MoveFirst/MoveLast fails, result set is empty
			// If SetBookmark fails, currency undefined
			m_bEOF = m_bBOF = TRUE;
		}
		else
		{
			m_bEOF = nDirection >= 0;
			m_bBOF = !m_bEOF;
		}
	}
	else
	{
		m_bEOF = m_bBOF = FALSE;
	}
}

void CRecordset::RefreshRowset(WORD wRow, WORD wLockType)
{
	ASSERT(IsOpen());
	ASSERT(m_dwOptions & useMultiRowFetch);

	RETCODE nRetCode;

	AFX_ODBC_CALL(::SQLSetPos(m_hstmt, wRow, SQL_REFRESH, wLockType));

	// Need to fixup bound fields in some cases
	if (m_nFields > 0 && !IsEOF() && !IsBOF() &&
		!(m_dwOptions & useMultiRowFetch))
	{
		Fixups();
	}
}

void CRecordset::SetRowsetCursorPosition(WORD wRow, WORD wLockType)
{
	ASSERT(IsOpen());
	ASSERT(m_dwOptions & useMultiRowFetch);

	RETCODE nRetCode;

	AFX_ODBC_CALL(::SQLSetPos(m_hstmt, wRow, SQL_POSITION, wLockType));
}

// "SELECT <user column name list> FROM <table name>"
void CRecordset::BuildSelectSQL()
{
	ASSERT_VALID(this);
	ASSERT(m_hstmt != SQL_NULL_HSTMT);

	// Ignore queries with procedure call keyword or output param
	if (!(_tcsnicmp(m_strSQL, _afxCall, lstrlen(_afxCall)-1) == 0 ||
		_tcsnicmp(m_strSQL, _afxParamCall, lstrlen(_afxParamCall)-1) == 0))
	{
		// Ignore queries already built
		if (_tcsnicmp(m_strSQL, _afxSelect, lstrlen(_afxSelect)-1) != 0)
		{
			// Assume m_strSQL specifies table name
			ASSERT(m_nFields != 0);

			CString strTableName;
			strTableName = m_strSQL;
			m_strSQL.Empty();
			m_strSQL = _afxSelect;

			// Set all fields dirty. AppendNames only outputs dirty field names
			SetFieldDirty(NULL);
			if (AppendNames(&m_strSQL, _T(",")) == 0)
			{
				TRACE(traceDatabase, 0, _T("Error: no field names - at least 1 required.\n"));
				ThrowDBException(AFX_SQL_ERROR_EMPTY_COLUMN_LIST);
			}

			// Overwrite final ',' separator with ' '
			ASSERT(m_strSQL[m_strSQL.GetLength()-1] == ',');
			m_strSQL.SetAt(m_strSQL.GetLength()-1, ' ');

			m_strSQL += _afxFrom;
			m_strSQL += strTableName;
		}
	}
}

// Add the filter and sort strings to query SQL
void CRecordset::AppendFilterAndSortSQL()
{
	if (!m_strFilter.IsEmpty())
	{
		m_strSQL += _afxWhere;
		m_strSQL += m_strFilter;
	}

	if (!m_strSort.IsEmpty())
	{
		m_strSQL += _afxOrderBy;
		m_strSQL += m_strSort;
	}
}

// Check for required SQLGetData support and do limited SQL parsing
BOOL CRecordset::IsRecordsetUpdatable()
{
	// Do limited SQL parsing to determine if SQL updatable
	if (!IsSQLUpdatable(m_strSQL))
		return FALSE;

	// Updatable recordsets with long binary columns must support
	// SQL_GD_BOUND to use SQLSetPos, otherwise must use SQL updates
	BOOL bUpdatable = TRUE;
	if (m_bLongBinaryColumns && !m_bUseUpdateSQL)
	{
		ENSURE(m_pDatabase != NULL);
		// Set non-updatable if you can't use SQLGetData on bound columns
		if (!(m_pDatabase->m_dwUpdateOptions & AFX_SQL_GDBOUND))
		{
			// Okay can't use SetPos, try and use positioned update SQL
			if (m_pDatabase->m_dwUpdateOptions & AFX_SQL_POSITIONEDSQL)
			{
				m_bUseUpdateSQL = TRUE;
				TRACE(traceDatabase, 0, _T("Warning: Can't use SQLSetPos due to lack of SQLGetData support.\n"));
				TRACE(traceDatabase, 0, _T("\tWill use positioned update SQL.\n"));
			}
			else
			{
				TRACE(traceDatabase, 0, _T("Warning: Setting recordset read only due to lack of SQLGetData support.\n"));
				bUpdatable = FALSE;
			}
		}
	}

	return bUpdatable;
}

// Execute the update (or delete) using SQLSetPos
void CRecordset::ExecuteSetPosUpdate()
{
	UWORD wExpectedRowStatus;
	UWORD wPosOption;
	if (m_nEditMode == noMode)
	{
		wPosOption = SQL_DELETE;
		wExpectedRowStatus = SQL_ROW_DELETED;
	}
	else
	{
		if (m_nEditMode == edit)
		{
			wPosOption = SQL_UPDATE;
			wExpectedRowStatus = SQL_ROW_UPDATED;
		}
		else
		{
			wPosOption = SQL_ADD;
			wExpectedRowStatus = SQL_ROW_ADDED;
		}
	}

	BindFieldsForUpdate();

	RETCODE nRetCode;
	AFX_ODBC_CALL(::SQLSetPos(m_hstmt, 1, wPosOption, SQL_LOCK_NO_CHANGE));
	if (!Check(nRetCode))
	{
		TRACE(traceDatabase, 0, _T("Error: failure updating record.\n"));
		AfxThrowDBException(nRetCode, m_pDatabase, m_hstmt);
	}
	// Only have data-at-execution columns for CLongBinary columns
	if (nRetCode == SQL_NEED_DATA)
		SendLongBinaryData(m_hstmt);
	// This should only fail if SQLSetPos returned SQL_SUCCESS_WITH_INFO explaining why
	if (nRetCode == SQL_SUCCESS_WITH_INFO && GetRowStatus(1) != wExpectedRowStatus)
		ThrowDBException(AFX_SQL_ERROR_UPDATE_DELETE_FAILED);

	UnbindFieldsForUpdate();
}

// Prepare for sending update SQL by initializing m_hstmtUpdate
void CRecordset::PrepareUpdateHstmt()
{
	ENSURE(m_pDatabase != NULL);
	RETCODE nRetCode;
	if (m_hstmtUpdate == SQL_NULL_HSTMT)
	{
		AFX_SQL_SYNC(::SQLAllocStmt(m_pDatabase->m_hdbc, &m_hstmtUpdate));
		if (!Check(nRetCode))
		{
			TRACE(traceDatabase, 0, _T("Error: failure to allocate update statement.\n"));
			AfxThrowDBException(nRetCode, m_pDatabase, m_hstmtUpdate);
		}

		OnSetUpdateOptions(m_hstmtUpdate);
	}
	else
	{
		AFX_SQL_SYNC(::SQLFreeStmt(m_hstmtUpdate, SQL_CLOSE));
		if (!Check(nRetCode))
			goto LErrRetCode;

		// Re-use (prepared) hstmt & param binding if optimizeBulkAdd option
		if(!(m_dwOptions & optimizeBulkAdd))
		{
			AFX_SQL_SYNC(::SQLFreeStmt(m_hstmtUpdate, SQL_RESET_PARAMS));
			if (!Check(nRetCode))
			{
	LErrRetCode:
				// Bad hstmt, free it and allocate another one
				AFX_SQL_SYNC(::SQLFreeStmt(m_hstmtUpdate, SQL_DROP));
				m_hstmtUpdate = SQL_NULL_HSTMT;

				AFX_SQL_SYNC(::SQLAllocStmt(m_pDatabase->m_hdbc, &m_hstmtUpdate));
				if (!Check(nRetCode))
				{
					TRACE(traceDatabase, 0, _T("Error: failure to allocate update statement.\n"));
					AfxThrowDBException(nRetCode, m_pDatabase, m_hstmtUpdate);
				}

				OnSetUpdateOptions(m_hstmtUpdate);
			}
		}
	}
}

// Build the UPDATE, INSERT or DELETE SQL
void CRecordset::BuildUpdateSQL()
{

	switch (m_nEditMode)
	{
	case noMode:
		// DELETE FROM <tablename> WHERE CURRENT OF
		{
			m_strUpdateSQL = _T("DELETE FROM ");
			m_strUpdateSQL += m_strTableName;
		}
		break;

	case addnew:
		// INSERT INTO <tablename> (<colname1>[,<colname2>]) VALUES (?[,?])
		{
			m_strUpdateSQL = _T("INSERT INTO ");
			m_strUpdateSQL += m_strTableName;

			m_strUpdateSQL += _T(" (");

			// Append column names
			AppendNames(&m_strUpdateSQL, _afxComma);

			// overwrite last ',' with ')'
			ASSERT(m_strUpdateSQL[m_strUpdateSQL.GetLength()-1] == ',');
			m_strUpdateSQL.SetAt(m_strUpdateSQL.GetLength()-1, ')');

			// Append values
			m_strUpdateSQL += _T(" VALUES (");
			AppendValues(m_hstmtUpdate, &m_strUpdateSQL, _afxComma);

			// overwrite last ',' with ')'
			ASSERT(m_strUpdateSQL[m_strUpdateSQL.GetLength()-1] == ',');
			m_strUpdateSQL.SetAt(m_strUpdateSQL.GetLength()-1, ')');
		}
		break;

	case edit:
		// UPDATE <tablename> SET <colname1>=?[,<colname2>=?] WHERE CURRENT OF
		{
			m_strUpdateSQL = _T("UPDATE ");
			m_strUpdateSQL += m_strTableName;

			m_strUpdateSQL += _T(" SET ");
			AppendNamesValues(m_hstmtUpdate, &m_strUpdateSQL, _afxComma);

			// overwrite last ',' with ' '
			ASSERT(m_strUpdateSQL[m_strUpdateSQL.GetLength()-1] == ',');
			m_strUpdateSQL.SetAt(m_strUpdateSQL.GetLength()-1, ' ');
		}
		break;
	}

	// Update and Delete need "WHERE CURRENT OF <cursorname>"
	if (m_nEditMode == edit || m_nEditMode == noMode)
	{
		m_strUpdateSQL += _T(" WHERE CURRENT OF ");

		// Cache cursor name assigned by ODBC
		if (m_strCursorName.IsEmpty())
		{
			// Get predefined cursor name from datasource
			RETCODE nRetCode;
			TCHAR szCursorName[MAX_CURSOR_NAME+1];
			SWORD nLength = _countof(szCursorName)-1;
			AFX_SQL_SYNC(::SQLGetCursorName(m_hstmt, 
				reinterpret_cast<SQLTCHAR *>(szCursorName), _countof(szCursorName), &nLength));
			if (!Check(nRetCode))
				ThrowDBException(nRetCode);
			m_strCursorName = szCursorName;
		}
		m_strUpdateSQL += m_strCursorName;
	}

	ENSURE(m_pDatabase != NULL);
	m_pDatabase->ReplaceBrackets(m_strUpdateSQL.GetBuffer(0));
	m_strUpdateSQL.ReleaseBuffer();

	// Must prepare the hstmt on first optimized bulk add
	if(m_dwOptions & firstBulkAdd)
	{
		RETCODE nRetCode;
		TCHAR *pszSQL = const_cast<LPTSTR>(static_cast<LPCTSTR>(m_strUpdateSQL));
		AFX_ODBC_CALL(::SQLPrepare(m_hstmtUpdate, reinterpret_cast<SQLTCHAR *>(pszSQL), SQL_NTS));
		if (!Check(nRetCode))
			ThrowDBException(nRetCode, m_hstmtUpdate);
	}
}

void CRecordset::ExecuteUpdateSQL()
{
	RETCODE nRetCode;

	if(!(m_dwOptions & optimizeBulkAdd))
	{
		TCHAR *pszSQL = const_cast<LPTSTR>(static_cast<LPCTSTR>(m_strUpdateSQL));
		AFX_ODBC_CALL(::SQLExecDirect(m_hstmtUpdate, reinterpret_cast<SQLTCHAR *>(pszSQL), SQL_NTS));
		if (!Check(nRetCode))
			ThrowDBException(nRetCode, m_hstmtUpdate);
	}
	else
	{
		AFX_ODBC_CALL(::SQLExecute(m_hstmtUpdate));
		if (!Check(nRetCode))
			ThrowDBException(nRetCode, m_hstmtUpdate);
	}

	// Only have data-at-execution parameters for CLongBinary columns
	if (nRetCode == SQL_NEED_DATA)
		SendLongBinaryData(m_hstmtUpdate);

#ifdef _WIN64
	SQLLEN lRowsAffected = 0;
#else
   LONG lRowsAffected = 0;
#endif

	AFX_SQL_SYNC(::SQLRowCount(m_hstmtUpdate, &lRowsAffected));
	if (!Check(nRetCode) || lRowsAffected == -1)
	{
		// Assume 1 row affected if # rows affected can't be determined
		lRowsAffected = 1;
	}
	else
	{
		if (lRowsAffected != 1)
		{
			TRACE(traceDatabase, 0, _T("Warning: %u rows affected by update operation (expected 1).\n"),
				lRowsAffected);

			ThrowDBException((RETCODE)(lRowsAffected == 0 ?
				AFX_SQL_ERROR_NO_ROWS_AFFECTED :
				AFX_SQL_ERROR_MULTIPLE_ROWS_AFFECTED));
		}
	}
	m_strUpdateSQL.Empty();
}


void CRecordset::SendLongBinaryData(HSTMT hstmt)
{
	RETCODE nRetCode;
	void* pv;
	AFX_ODBC_CALL(::SQLParamData(hstmt, &pv));
	if (!Check(nRetCode))
	{
		// cache away error
		CDBException* pException = new CDBException(nRetCode);
		pException->BuildErrorString(m_pDatabase, hstmt);

		// then cancel Execute operation
		Cancel();
		THROW(pException);
	}

	while (nRetCode == SQL_NEED_DATA)
	{
		CLongBinary* pLongBinary = (CLongBinary*)pv;
		ASSERT_VALID(pLongBinary);

		const BYTE* lpData = (const BYTE*)::GlobalLock(pLongBinary->m_hData);
		ASSERT(lpData != NULL);

		AFX_ODBC_CALL(::SQLPutData(hstmt, (PTR)lpData,
			(SQLLEN)pLongBinary->m_dwDataLength));

		::GlobalUnlock(pLongBinary->m_hData);

		if (!Check(nRetCode))
		{
			// cache away error
			CDBException* pException = new CDBException(nRetCode);
			pException->BuildErrorString(m_pDatabase, hstmt);

			// then cancel Execute operation
			Cancel();
			THROW(pException);
		}

		// Check for another DATA_AT_EXEC
		AFX_ODBC_CALL(::SQLParamData(hstmt, &pv));
		if (!Check(nRetCode))
		{
			TRACE(traceDatabase, 0, _T("Error: failure handling long binary value during update.\n"));
			ThrowDBException(nRetCode, hstmt);
		}
	}
}

//////////////////////////////////////////////////////////////////////////////
// CRecordset RFX implementations

void CRecordset::AllocStatusArrays()
{
	TRY
	{
		if (m_nFields != 0)
		{
			// Allocate buffers to hold field info
			if (m_rgFieldInfos == NULL)
			{
				m_rgFieldInfos = new CFieldInfo[m_nFields];
				memset(m_rgFieldInfos, 0, sizeof(CFieldInfo) * m_nFields);
			}

			if (m_pbFieldFlags == NULL)
			{
				m_pbFieldFlags = new BYTE[m_nFields];
				memset(m_pbFieldFlags, 0, m_nFields);
			}
		}

		if (m_nParams != 0)
		{
			// Allocate buffers to hold param info
			if (m_pbParamFlags == NULL)
			{
				m_pbParamFlags = new BYTE[m_nParams];
				memset(m_pbParamFlags, 0, m_nParams);
			}

			if (m_plParamLength == NULL)
			{
				m_plParamLength = new LONG_PTR[m_nParams];
				memset(m_plParamLength, 0, m_nParams*sizeof(LONG_PTR));
			}
		}
	}
	CATCH_ALL(e)
	{
		Close();
		THROW_LAST();
	}
	END_CATCH_ALL
}

int CRecordset::GetBoundFieldIndex(void* pv)
{
	void* pvIndex;

	if (!m_mapFieldIndex.Lookup(pv, pvIndex))
		return -1;
	else
		// Cached value is short not ptr
		return (int)(INT_PTR)pvIndex;
}

int CRecordset::GetBoundParamIndex(void* pv)
{
	void* pvIndex;

	if (!m_mapParamIndex.Lookup(pv, pvIndex))
		return -1;
	else
		// Cached value in data not ptr
		return (int)(INT_PTR)pvIndex;
}

short CRecordset::GetFieldIndexByName(LPCTSTR lpszFieldName)
{
	short nIndex;
	for (nIndex = 0; nIndex < GetODBCFieldCount(); nIndex++)
	{
		if (m_rgODBCFieldInfos[nIndex].m_strName == lpszFieldName)
			break;
	}

	// Check if field name found
	if (nIndex == GetODBCFieldCount())
		ThrowDBException(AFX_SQL_ERROR_FIELD_NOT_FOUND);

	return nIndex;
}

LONG_PTR* CRecordset::GetFieldLengthBuffer(DWORD nField, int nFieldType)
{
	if (nFieldType == CFieldExchange::outputColumn)
	{
		ASSERT(nField < m_nFields);
		if(nField >= m_nFields)
			AfxThrowUserException();
		return &m_rgFieldInfos[nField].m_nLength;
	}
	else
	{
		ASSERT(nField < m_nParams);
		if(nField >= m_nParams)
			AfxThrowUserException();
		return &m_plParamLength[nField];
	}
}

BYTE CRecordset::GetFieldStatus(DWORD nField)
{
	ASSERT(nField < m_nFields);
	if(nField >= m_nFields)
		AfxThrowUserException();

	return m_pbFieldFlags[nField];
}

void CRecordset::SetFieldStatus(DWORD nField, BYTE bFlags)
{
	ASSERT(nField < m_nFields);
	if(nField >= m_nFields)
		AfxThrowUserException();

	m_pbFieldFlags[nField] |= bFlags;
}

void CRecordset::ClearFieldStatus()
{
	memset(m_pbFieldFlags, 0, m_nFields);
}

BOOL CRecordset::IsFieldStatusDirty(DWORD nField) const
{
	ASSERT(nField < m_nFields);
	if(nField >= m_nFields)
		AfxThrowUserException();

	return m_pbFieldFlags[nField] & AFX_SQL_FIELD_FLAG_DIRTY;
}

void CRecordset::SetDirtyFieldStatus(DWORD nField)
{
	ASSERT(nField < m_nFields);
	if(nField >= m_nFields)
		AfxThrowUserException();

	m_pbFieldFlags[nField] |= AFX_SQL_FIELD_FLAG_DIRTY;
}

void CRecordset::ClearDirtyFieldStatus(DWORD nField)
{
	ASSERT(nField < m_nFields);
	if(nField >= m_nFields)
		AfxThrowUserException();

	m_pbFieldFlags[nField] &= ~AFX_SQL_FIELD_FLAG_DIRTY;
}

BOOL CRecordset::IsFieldStatusNull(DWORD nField) const
{
	ASSERT(nField < m_nFields);
	if(nField >= m_nFields)
		AfxThrowUserException();

	return m_pbFieldFlags[nField] & AFX_SQL_FIELD_FLAG_NULL;
}

void CRecordset::SetNullFieldStatus(DWORD nField)
{
	ASSERT(nField < m_nFields);
	if(nField >= m_nFields)
		AfxThrowUserException();

	m_pbFieldFlags[nField] |= AFX_SQL_FIELD_FLAG_NULL;
}

void CRecordset::ClearNullFieldStatus(DWORD nField)
{
	ASSERT(nField < m_nFields);
	if(nField >= m_nFields)
		AfxThrowUserException();

	m_pbFieldFlags[nField] &= ~AFX_SQL_FIELD_FLAG_NULL;
}

BOOL CRecordset::IsParamStatusNull(DWORD nParam) const
{
	ASSERT(nParam < m_nParams);
	if(nParam >= m_nParams)
		AfxThrowUserException();

	return m_pbParamFlags[nParam] & AFX_SQL_FIELD_FLAG_NULL;
}

void CRecordset::SetNullParamStatus(DWORD nParam)
{
	ASSERT(nParam < m_nParams);
	if(nParam >= m_nParams)
		AfxThrowUserException();

	m_pbParamFlags[nParam] |= AFX_SQL_FIELD_FLAG_NULL;
}

void CRecordset::ClearNullParamStatus(DWORD nParam)
{
	ASSERT(nParam < m_nParams);
	if(nParam >= m_nParams)
		AfxThrowUserException();

	m_pbParamFlags[nParam] &= ~AFX_SQL_FIELD_FLAG_NULL;
}

BOOL CRecordset::IsFieldNullable(DWORD nField) const
{
	ASSERT(nField <= INT_MAX);
	if(nField > INT_MAX)
		AfxThrowUserException();
	ASSERT((long)nField < GetODBCFieldCount());
	if((long)nField >= GetODBCFieldCount())
		AfxThrowUserException();

	// return TRUE if nulls allowed or if not known
	return m_rgODBCFieldInfos[nField].m_nNullability != SQL_NO_NULLS;
}

UINT CRecordset::BindParams(HSTMT hstmt)
{
	ASSERT_VALID(this);
	ASSERT(m_hstmt != SQL_NULL_HSTMT);

	CFieldExchange fx(CFieldExchange::BindParam, this);
	fx.m_hstmt = hstmt;

	DoFieldExchange(&fx);

	return fx.m_nParams;
}

void CRecordset::RebindParams(HSTMT hstmt)
{
	ASSERT_VALID(this);
	ASSERT(m_hstmt != SQL_NULL_HSTMT);

	if (m_bRebindParams)
	{
		CFieldExchange fx(CFieldExchange::RebindParam, this);
		fx.m_hstmt = hstmt;

		DoFieldExchange(&fx);
	}
}

UINT CRecordset::BindFieldsToColumns()
{
	ASSERT_VALID(this);
	ASSERT(m_hstmt != SQL_NULL_HSTMT);

	ASSERT(m_nFieldsBound == 0);
	ASSERT(m_nFields != 0 && m_nFields <= 255);

	CFieldExchange fx(CFieldExchange::BindFieldToColumn, this);
	fx.m_hstmt = m_hstmt;

	// Binding depends on fetch type
	if (m_dwOptions & useMultiRowFetch)
		DoBulkFieldExchange(&fx);
	else
		DoFieldExchange(&fx);

	return fx.m_nFields;
}

void CRecordset::BindFieldsForUpdate()
{
	ASSERT_VALID(this);

	if (m_nEditMode == edit || m_nEditMode == addnew)
	{
		CFieldExchange fx(CFieldExchange::BindFieldForUpdate, this);
		fx.m_hstmt = m_hstmt;
		DoFieldExchange(&fx);
	}
}

void CRecordset::UnbindFieldsForUpdate()
{
	ASSERT_VALID(this);

	if (m_nEditMode == edit || m_nEditMode == addnew)
	{
		CFieldExchange fx(CFieldExchange::UnbindFieldForUpdate, this);
		fx.m_hstmt = m_hstmt;
		DoFieldExchange(&fx);
	}
}

// After Move operation, reflect status and lengths of columns in RFX fields
void CRecordset::Fixups()
{
	ASSERT_VALID(this);
	ASSERT(m_hstmt != SQL_NULL_HSTMT);
	ASSERT(m_nFieldsBound != 0);

	CFieldExchange fx(CFieldExchange::Fixup, this);
	fx.m_hstmt = m_hstmt;
	DoFieldExchange(&fx);
}

UINT CRecordset::AppendNames(CString* pstr, LPCTSTR lpszSeparator)
{
	ASSERT_VALID(this);
	ASSERT(AfxIsValidAddress(pstr, sizeof(CString)));
	ASSERT(AfxIsValidString(lpszSeparator));
	ASSERT(m_hstmt != SQL_NULL_HSTMT);

	CFieldExchange fx(CFieldExchange::Name, this);
	fx.m_pstr = pstr;
	fx.m_lpszSeparator = lpszSeparator;

	if (m_dwOptions & useMultiRowFetch)
		DoBulkFieldExchange(&fx);
	else
		DoFieldExchange(&fx);

	return fx.m_nFields;
}

// For each "changed" column, append <column name>=<column value>,
UINT CRecordset::AppendNamesValues(HSTMT hstmt, CString* pstr,
	LPCTSTR lpszSeparator)
{
	ENSURE_VALID(this);
	ENSURE_ARG(AfxIsValidAddress(pstr, sizeof(CString)));
	ENSURE_ARG(AfxIsValidString(lpszSeparator));
	ENSURE(m_hstmt != SQL_NULL_HSTMT);
	ENSURE(hstmt != SQL_NULL_HSTMT);

	CFieldExchange fx(CFieldExchange::NameValue, this);
	fx.m_pstr = pstr;
	fx.m_lpszSeparator = lpszSeparator;
	fx.m_hstmt = hstmt;

	DoFieldExchange(&fx);

	return fx.m_nFields;
}

// For each "changed" column, append <column value>,
UINT CRecordset::AppendValues(HSTMT hstmt, CString* pstr,
	LPCTSTR lpszSeparator)
{
	ASSERT_VALID(this);
	ASSERT(AfxIsValidAddress(pstr, sizeof(CString)));
	ASSERT(AfxIsValidString(lpszSeparator));
	ASSERT(m_hstmt != SQL_NULL_HSTMT);
	ASSERT(hstmt != SQL_NULL_HSTMT);

	CFieldExchange fx(CFieldExchange::Value, this);
	fx.m_pstr = pstr;
	fx.m_lpszSeparator = lpszSeparator;
	fx.m_hstmt = hstmt;

	DoFieldExchange(&fx);

	return fx.m_nFields;
}


// Cache fields of copy buffer in a CMemFile with CArchive
void CRecordset::StoreFields()
{
	ASSERT_VALID(this);
	ASSERT(m_nFieldsBound != 0);

	CFieldExchange fx(CFieldExchange::StoreField, this);
	DoFieldExchange(&fx);
}

// Restore fields of copy buffer from archived memory file
void CRecordset::LoadFields()
{
	ASSERT_VALID(this);
	ASSERT(m_nFieldsBound != 0);

	// Must clear out the old status
	ClearFieldStatus();

	CFieldExchange fx(CFieldExchange::LoadField, this);
	DoFieldExchange(&fx);
}

void CRecordset::MarkForUpdate()
{
	ASSERT_VALID(this);

	CFieldExchange fx(CFieldExchange::MarkForUpdate, this);
	DoFieldExchange(&fx);
}

void CRecordset::MarkForAddNew()
{
	ASSERT_VALID(this);

	CFieldExchange fx(CFieldExchange::MarkForAddNew, this);
	DoFieldExchange(&fx);
}

void CRecordset::AllocDataCache()
{
	ASSERT_VALID(this);

	CFieldExchange fx(CFieldExchange::AllocCache, this);
	DoFieldExchange(&fx);
}

void CRecordset::FreeDataCache()
{
	ASSERT_VALID(this);

	CFieldInfo* pInfo;

	for (DWORD nField = 0; nField < m_nFields; nField++)
	{
		pInfo = &m_rgFieldInfos[nField];

		switch(pInfo->m_nDataType)
		{
		default:
			ASSERT(FALSE);
			// fall through

		// Data not cached
		case AFX_RFX_NO_TYPE:
			break;

		// Types cached by value (sizeof(TYPE) <= sizeof(void*))
		case AFX_RFX_BOOL:
		case AFX_RFX_BYTE:
		case AFX_RFX_INT:
		case AFX_RFX_LONG:
		case AFX_RFX_SINGLE:
			pInfo->m_pvDataCache = NULL;
			break;

		case AFX_RFX_WTEXT:
			delete reinterpret_cast<CStringW *>(pInfo->m_pvDataCache);
			pInfo->m_pvDataCache = NULL;
			break;

		case AFX_RFX_ATEXT:
			delete reinterpret_cast<CStringA *>(pInfo->m_pvDataCache);
			pInfo->m_pvDataCache = NULL;
			break;

		case AFX_RFX_LPWSTR:
			delete [] LPWSTR(pInfo->m_pvDataCache);
			pInfo->m_pvDataCache = NULL;
			break;

		case AFX_RFX_LPASTR:
			delete [] LPSTR(pInfo->m_pvDataCache);
			pInfo->m_pvDataCache = NULL;
			break;

		case AFX_RFX_DOUBLE:
			delete (double*)pInfo->m_pvDataCache;
			pInfo->m_pvDataCache = NULL;
			break;

		case AFX_RFX_BIGINT:
			delete (LONGLONG*)pInfo->m_pvDataCache;
			pInfo->m_pvDataCache = NULL;
			break;

		case AFX_RFX_TIMESTAMP:
			delete (TIMESTAMP_STRUCT*)pInfo->m_pvDataCache;
			pInfo->m_pvDataCache = NULL;
			break;

		case AFX_RFX_OLEDATE:
			delete (COleDateTime*)pInfo->m_pvDataCache;
			pInfo->m_pvDataCache = NULL;
			break;

		case AFX_RFX_DATE:
			delete (CTime*)pInfo->m_pvDataCache;
			pInfo->m_pvDataCache = NULL;
			break;

		case AFX_RFX_BINARY:
			delete (CByteArray*)pInfo->m_pvDataCache;
			pInfo->m_pvDataCache = NULL;
			break;
		}
	}
}

#ifdef _DEBUG
void CRecordset::DumpFields(CDumpContext& dc) const
{
	CFieldExchange fx(CFieldExchange::DumpField, (CRecordset *)this);
	fx.m_pdcDump = &dc;
	((CRecordset *)this)->DoFieldExchange(&fx);
}
#endif // _DEBUG


// Perform Update (m_nModeEdit == edit), Insert (addnew),
// or Delete (noMode)
BOOL CRecordset::UpdateInsertDelete()
{
	ASSERT_VALID(this);
	ASSERT(m_hstmt != SQL_NULL_HSTMT);

	// Delete mode
	if (m_nEditMode == addnew)
	{
		if (!m_bAppendable)
		{
			TRACE(traceDatabase, 0, _T("Error: attempted to add a record to a read only recordset.\n"));
			ThrowDBException(AFX_SQL_ERROR_RECORDSET_READONLY);
		}
	}
	else
	{
		if (!m_bUpdatable)
		{
			TRACE(traceDatabase, 0, _T("Error: attempted to update a read only recordset.\n"));
			ThrowDBException(AFX_SQL_ERROR_RECORDSET_READONLY);
		}

		// Requires currency
		if (m_bEOF || m_bBOF || m_bDeleted)
		{
			TRACE(traceDatabase, 0, _T("Error: attempting to update recordset - but no record is current.\n"));
			ThrowDBException(AFX_SQL_ERROR_NO_CURRENT_RECORD);
		}
	}

	// Update or AddNew is NOP w/o at least 1 changed field
	if (m_nEditMode != noMode && !IsFieldDirty(NULL))
		return FALSE;

	if (!m_bUseUpdateSQL)
	{
		// Most efficient update method
		ExecuteSetPosUpdate();
	}
	else
	{

		BOOL bNullHstmt = (m_hstmtUpdate == NULL);

		// Make sure m_hstmtUpdate allocated
		PrepareUpdateHstmt();

		// Build update SQL unless optimizing bulk adds and hstmt not NULL
		if(!(m_dwOptions & optimizeBulkAdd) || bNullHstmt)
		{
			// Mark as first bulk add if optimizing
			if(m_dwOptions & optimizeBulkAdd)
			{
				m_dwOptions &= ~optimizeBulkAdd;
				m_dwOptions |= firstBulkAdd;
			}
			BuildUpdateSQL();

			// Reset flag marking first optimization
			if(m_dwOptions & firstBulkAdd)
			{
				m_dwOptions &= ~firstBulkAdd;
				m_dwOptions |= optimizeBulkAdd;
			}
		}
		else
		{
			// Just reset the data lengths and datetime proxies
			AppendValues(m_hstmtUpdate, &m_strUpdateSQL, _afxComma);
		}

		ExecuteUpdateSQL();
	}

	TRY
	{
		// Delete
		switch (m_nEditMode)
		{
		case noMode:
			// Decrement record count
			if (m_lCurrentRecord >= 0)
			{
				if (m_lRecordCount > 0)
					m_lRecordCount--;
				m_lCurrentRecord--;
			}

			// indicate on a deleted record
			m_bDeleted = TRUE;
			// Set all fields to NULL
			SetFieldNull(NULL);
			break;

		case addnew:
			// The recordset may no longer be empty (depending on driver behavior)
			// reset m_bEOF/m_bBOF so Move can be called
			m_bEOF = m_bBOF = FALSE;
			ENSURE(m_pDatabase != NULL);
			if (m_pDatabase->m_bIncRecordCountOnAdd && m_lCurrentRecord >= 0)
			{
				if (m_lRecordCount != -1)
					m_lRecordCount++;
				m_lCurrentRecord++;
			}

			// Reset the data cache if necessary
			if (m_bCheckCacheForDirtyFields && m_nFields > 0)
				LoadFields();
			break;

		case edit:
			break;
		}

		// Reset the edit mode
		m_nEditMode = noMode;
	}
	END_TRY

	// Unless doing a bulk AddNew, reset the dirty flags
	if (m_bCheckCacheForDirtyFields && !(m_dwOptions & optimizeBulkAdd))
		SetFieldDirty(NULL, FALSE);

	// Must return TRUE since record updated
	return TRUE;
}

// Fetch and alloc algorithms for CLongBinary data when length unknown
SQLLEN CRecordset::GetLBFetchSize(SQLLEN lOldSize)
{
	// Make it twice as big
	return lOldSize << 1;
}

SQLLEN CRecordset::GetLBReallocSize(SQLLEN lOldSize)
{
	// Make it twice as big (no effect if less than fetch size)
	return lOldSize << 1;
}

short PASCAL CRecordset::GetDefaultFieldType(short nSQLType)
{
	short nFieldType = 0;

	switch (nSQLType)
	{
	case SQL_BIT:
		nFieldType = SQL_C_BIT;
		break;

	case SQL_TINYINT:
		nFieldType = SQL_C_UTINYINT;
		break;

	case SQL_SMALLINT:
		nFieldType = SQL_C_SSHORT;
		break;

	case SQL_INTEGER:
		nFieldType = SQL_C_SLONG;
		break;

	case SQL_REAL:
		nFieldType = SQL_C_FLOAT;
		break;

	case SQL_FLOAT:
	case SQL_DOUBLE:
		nFieldType = SQL_C_DOUBLE;
		break;

	case SQL_DATE:
	case SQL_TIME:
	case SQL_TIMESTAMP:
		nFieldType = SQL_C_TIMESTAMP;
		break;

	case SQL_NUMERIC:
	case SQL_DECIMAL:
	case SQL_BIGINT:
		nFieldType = SQL_C_TCHAR;
		break;

	case SQL_CHAR:
	case SQL_VARCHAR:
	case SQL_LONGVARCHAR:
		nFieldType = SQL_C_CHAR;
		break;

	case SQL_WCHAR:
	case SQL_WVARCHAR:
	case SQL_WLONGVARCHAR:
		nFieldType = SQL_C_WCHAR;
		break;

	case SQL_BINARY:
	case SQL_VARBINARY:
	case SQL_LONGVARBINARY:
		nFieldType = SQL_C_BINARY;
		break;

	default:
		ASSERT(FALSE);
	}

	return nFieldType;
}

void* PASCAL CRecordset::GetDataBuffer(CDBVariant& varValue,
	short nFieldType, SQLLEN* pnLen, short nSQLType, SQLULEN nPrecision)
{
	ENSURE_ARG(pnLen != NULL);
	void* pvData = NULL;

	switch (nFieldType)
	{
	case SQL_C_BIT:
		pvData = &varValue.m_boolVal;
		varValue.m_dwType = DBVT_BOOL;
		varValue.m_boolVal = 0;  // SQL will only set the low byte, so we need
			// to initialize the whole thing to zero.
		*pnLen = sizeof(varValue.m_boolVal);
		break;

	case SQL_C_UTINYINT:
		pvData = &varValue.m_chVal;
		varValue.m_dwType = DBVT_UCHAR;
		*pnLen = sizeof(varValue.m_chVal);
		break;

	case SQL_C_SSHORT:
		pvData = &varValue.m_iVal;
		varValue.m_dwType = DBVT_SHORT;
		*pnLen = sizeof(varValue.m_iVal);
		break;

	case SQL_C_SLONG:
		pvData = &varValue.m_lVal;
		varValue.m_dwType = DBVT_LONG;
		*pnLen = sizeof(varValue.m_lVal);
		break;

	case SQL_C_FLOAT:
		pvData = &varValue.m_fltVal;
		varValue.m_dwType = DBVT_SINGLE;
		*pnLen = sizeof(varValue.m_fltVal);
		break;

	case SQL_C_DOUBLE:
		pvData = &varValue.m_dblVal;
		varValue.m_dwType = DBVT_DOUBLE;
		*pnLen = sizeof(varValue.m_dblVal);
		break;

	case SQL_C_TIMESTAMP:
		pvData = varValue.m_pdate = new TIMESTAMP_STRUCT;
		varValue.m_dwType = DBVT_DATE;
		*pnLen = sizeof(*varValue.m_pdate);
		break;

	case SQL_C_CHAR:
		varValue.m_pstringA = new CStringA;
		varValue.m_dwType = DBVT_ASTRING;

		*pnLen = GetTextLen(nSQLType, nPrecision);
		if (*pnLen > INT_MAX)
			AfxThrowMemoryException();
		pvData = varValue.m_pstringA->GetBufferSetLength(int(*pnLen));  
		break;

	case SQL_C_WCHAR:
		varValue.m_pstringW = new CStringW;
		varValue.m_dwType = DBVT_WSTRING;

		*pnLen = GetTextLen(nSQLType, nPrecision);
		if (*pnLen > INT_MAX)
			AfxThrowMemoryException();

		pvData = varValue.m_pstringW->GetBufferSetLength(int(*pnLen)); 
		break;

	case SQL_C_BINARY:
		varValue.m_pbinary = new CLongBinary;
		varValue.m_dwType = DBVT_BINARY;

		if (nSQLType == SQL_LONGVARBINARY)
		{
			// pvData can't be NULL, so nLen must be at least 1
			*pnLen = 1;
		}
		else
		{
			// better know the length!
			ASSERT(nPrecision != 0);
			*pnLen = nPrecision;
		}

		varValue.m_pbinary->m_hData = ::GlobalAlloc(GMEM_MOVEABLE, *pnLen);
		varValue.m_pbinary->m_dwDataLength = *pnLen;

		pvData = ::GlobalLock(varValue.m_pbinary->m_hData);
		break;

	default:
		ASSERT(FALSE);
	}

	return pvData;
}

SQLLEN PASCAL CRecordset::GetTextLen(short nSQLType, SQLULEN nPrecision)
{
	SQLLEN nLen;

	if (nSQLType == SQL_LONGVARCHAR || nSQLType == SQL_LONGVARBINARY)
	{
		// Use a dummy length of 1 (will just get NULL terminator)
		nLen = 1;
	}
	else if(nSQLType == SQL_WLONGVARCHAR)
	{
		// Use a dummy length of DBCS 1
		nLen = sizeof(WCHAR);
	}
	else
	{
		// better know the length
		//ASSERT(nPrecision >= 0);

		nLen = nPrecision + 1;

		switch (nSQLType)
		{
		case SQL_INTEGER:
		case SQL_SMALLINT:
			nLen++;  // '-' sign
			break;

		case SQL_NUMERIC:
		case SQL_DECIMAL:
		case SQL_FLOAT:
		case SQL_REAL:
		case SQL_DOUBLE:
			nLen += 2;  // '-' sign and decimal point
			break;
		}
	}

	return nLen;
}

SQLLEN PASCAL CRecordset::GetData(CDatabase* pdb, HSTMT hstmt,
	short nFieldIndex, short nFieldType, LPVOID pvData, SQLLEN nLen,
	short nSQLType)
{
	UNUSED(nSQLType);

	SQLLEN nActualSize;
	RETCODE nRetCode;

	// Retrieve the column in question
	AFX_ODBC_CALL(::SQLGetData(hstmt, nFieldIndex,
		nFieldType, pvData, nLen, &nActualSize));

	// Ignore data truncated warnings for long data
	if (nRetCode == SQL_SUCCESS_WITH_INFO)
	{
#ifdef _DEBUG
		CDBException e(nRetCode);

		// Build the error string but don't send nuisance output to TRACE window
		e.BuildErrorString(pdb, hstmt, FALSE);

		// If not a data truncated warning on long var column,
		// then send debug output
		if ((nSQLType != SQL_LONGVARCHAR &&
			nSQLType != SQL_WLONGVARCHAR &&
			nSQLType != SQL_LONGVARBINARY) ||
			(e.m_strStateNativeOrigin.Find(_afxDataTruncated) < 0))
		{
			TRACE(traceDatabase, 0, _T("Warning: ODBC Success With Info on field %d.\n"),
				nFieldIndex - 1);
			e.TraceErrorMessage(e.m_strError);
			e.TraceErrorMessage(e.m_strStateNativeOrigin);
		}
#endif // _DEBUG
	}
	else if (nRetCode == SQL_NO_DATA_FOUND)
	{
		TRACE(traceDatabase, 0, _T("Error: GetFieldValue operation failed on field %d.\n"), nFieldIndex - 1);
		TRACE(traceDatabase, 0, _T("\tData already fetched for this field.\n"));
		AfxThrowDBException(nRetCode, pdb, hstmt);
	}
	else if (nRetCode != SQL_SUCCESS)
	{
		TRACE(traceDatabase, 0, _T("Error: GetFieldValue operation failed on field %d.\n"), nFieldIndex - 1);
		AfxThrowDBException(nRetCode, pdb, hstmt);
	}

	return nActualSize;
}

template<typename StringType>
inline static void PASCAL GetLongCharDataAndCleanup(CDatabase* pdb,
	HSTMT hstmt, short nFieldIndex, SQLLEN nActualSize, LPVOID* ppvData,
	SQLLEN nLen, StringType& strValue, short nSQLType, short nSQLCType)
{
	RETCODE nRetCode;

	// Release the buffer now that data has been fetched
	strValue.ReleaseBuffer((int)(nActualSize < nLen ? nActualSize : nLen));

	// If long data, may need to call SQLGetData again
	if (nLen <= nActualSize &&
		(nSQLType == SQL_WLONGVARCHAR || nSQLType == SQL_LONGVARCHAR ||
		nSQLType == SQL_LONGVARBINARY || nSQLType == SQL_VARCHAR))
	{
		// Reallocate the size (this will copy the data)
		if (nActualSize > (INT_MAX-1))
			AfxThrowMemoryException();
		ENSURE_ARG(ppvData!=NULL);
		*ppvData = strValue.GetBufferSetLength((int)nActualSize + 1);

		// Get pointer, skipping over original data, but not the NULL
		SQLLEN nOldLen = nLen - 1;
		*ppvData = (BYTE*)*ppvData + nOldLen * sizeof(TCHAR);
		nLen = (nActualSize + 1 - nOldLen) * sizeof(TCHAR);

		SQLLEN nActualSizeRetrieved = 0;  // length in bytes

		// Retrieve the column in question
		AFX_ODBC_CALL(::SQLGetData(hstmt, nFieldIndex,
			nSQLCType, *ppvData, nLen, &nActualSizeRetrieved));
		if (nRetCode == SQL_SUCCESS_WITH_INFO)
		{
#ifdef _DEBUG
			TRACE(traceDatabase, 0, _T("Warning: ODBC Success With Info on field %d.\n"),
				nFieldIndex - 1);
			CDBException e(nRetCode);
			e.BuildErrorString(pdb, hstmt);
#endif // _DEBUG
		}
		else if (nRetCode != SQL_SUCCESS)
		{
			TRACE(traceDatabase, 0, _T("Error: GetFieldValue operation failed on field %d.\n"),
				nFieldIndex - 1);
			AfxThrowDBException(nRetCode, pdb, hstmt);
		}

		// Release the buffer now that data has been fetched
		strValue.ReleaseBuffer((int)((nActualSizeRetrieved / sizeof(TCHAR)) + nOldLen));
	}
}

void PASCAL CRecordset::GetLongCharDataAndCleanup(CDatabase* pdb, HSTMT hstmt,
	short nFieldIndex, SQLLEN nActualSize, LPVOID* ppvData, SQLLEN nLen,
	CStringW& strValue, short nSQLType, short nSQLCType)
{
	::GetLongCharDataAndCleanup(pdb, hstmt, nFieldIndex, nActualSize, ppvData, nLen,
		strValue, nSQLType, nSQLCType);
}
void PASCAL CRecordset::GetLongCharDataAndCleanup(CDatabase* pdb, HSTMT hstmt,
	short nFieldIndex, SQLLEN nActualSize, LPVOID* ppvData, SQLLEN nLen,
	CStringA& strValue, short nSQLType, short nSQLCType)
{
	::GetLongCharDataAndCleanup(pdb, hstmt, nFieldIndex, nActualSize, ppvData, nLen,
		strValue, nSQLType, nSQLCType);
}

void PASCAL CRecordset::GetLongBinaryDataAndCleanup(CDatabase* pdb, HSTMT hstmt,
	short nFieldIndex, SQLLEN nActualSize, LPVOID* ppvData, SQLLEN nLen,
	CDBVariant& varValue, short nSQLType)
{
	RETCODE nRetCode;

	::GlobalUnlock(varValue.m_pbinary->m_hData);

	// If long data, may need to call SQLGetData again
	if (nLen < nActualSize && nSQLType == SQL_LONGVARBINARY)
	{
		// Reallocate a bigger buffer
		HGLOBAL hOldData = varValue.m_pbinary->m_hData;
		varValue.m_pbinary->m_hData = ::GlobalReAlloc(hOldData,
			nActualSize, GMEM_MOVEABLE);

		// Validate the memory was allocated and can be locked
		if (varValue.m_pbinary->m_hData == NULL)
		{
			// Restore the old handle (not NULL if Realloc failed)
			varValue.m_pbinary->m_hData = hOldData;
			AfxThrowMemoryException();
		}
		varValue.m_pbinary->m_dwDataLength = nActualSize;

		// Get pointer, skipping over original data
		ENSURE_ARG(ppvData!=NULL);
		*ppvData = (BYTE*)::GlobalLock(varValue.m_pbinary->m_hData) + nLen;
		INT_PTR nOldLen = nLen;
		nLen = nActualSize - nOldLen;

		// Retrieve the column in question
		AFX_ODBC_CALL(::SQLGetData(hstmt, nFieldIndex,
			SQL_C_BINARY, *ppvData, nLen, &nActualSize));
		if (nRetCode == SQL_SUCCESS_WITH_INFO)
		{
#ifdef _DEBUG
			TRACE(traceDatabase, 0, _T("Warning: ODBC Success With Info on field %d.\n"),
				nFieldIndex - 1);
			CDBException e(nRetCode);
			e.BuildErrorString(pdb, hstmt);
#endif // _DEBUG
		}
		else if (nRetCode != SQL_SUCCESS)
		{
			TRACE(traceDatabase, 0, _T("Error: GetFieldValue operation failed on field %d.\n"),
				nFieldIndex - 1);
			AfxThrowDBException(nRetCode, pdb, hstmt);
		}

		ASSERT((int)varValue.m_pbinary->m_dwDataLength ==
			nActualSize + nOldLen);

		// Release the buffer now that data has been fetched
		::GlobalUnlock(varValue.m_pbinary->m_hData);
	}
}

//////////////////////////////////////////////////////////////////////////////
// CRecordset diagnostics

#ifdef _DEBUG
void CRecordset::AssertValid() const
{
	CObject::AssertValid();
	if (m_pDatabase != NULL)
		m_pDatabase->AssertValid();
}

void CRecordset::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	dc << _T("m_nOpenType = ") << m_nOpenType;
	dc << _T("\nm_strSQL = ") << m_strSQL;
	dc << _T("\nm_hstmt = ") << m_hstmt;
	dc << _T("\nm_bRecordsetDb = ") << m_bRecordsetDb;

	dc << _T("\nm_lOpen = ") << m_lOpen;
	dc << _T("\nm_bScrollable = ") << m_bScrollable;
	dc << _T("\nm_bUpdatable = ") << m_bUpdatable;
	dc << _T("\nm_bAppendable = ") << m_bAppendable;

	dc << _T("\nm_nFields = ") << m_nFields;
	dc << _T("\nm_nFieldsBound = ") << m_nFieldsBound;
	dc << _T("\nm_nParams = ") << m_nParams;

	dc << _T("\nm_bEOF = ") << m_bEOF;
	dc << _T("\nm_bBOF = ") << m_bBOF;
	dc << _T("\nm_bDeleted = ") << m_bEOF;

	dc << _T("\nm_bLockMode = ") << m_nLockMode;
	dc << _T("\nm_nEditMode = ") << m_nEditMode;
	dc << _T("\nm_strCursorName = ") << m_strCursorName;
	dc << _T("\nm_hstmtUpdate = ") << m_hstmtUpdate;

	dc << _T("\nDump values for each field in current record.");
	DumpFields(dc);

	if (dc.GetDepth() > 0)
	{
		if (m_pDatabase == NULL)
			dc << _T("with no database\n");
		else
			dc << _T("with database: ") << m_pDatabase;
	}
}
#endif // _DEBUG

//////////////////////////////////////////////////////////////////////////////
// Helpers

void AFXAPI _AfxSetCurrentRecord(long* plCurrentRecord, long nRows, RETCODE nRetCode)
{
	ENSURE_ARG(plCurrentRecord!=NULL);
	if (*plCurrentRecord != AFX_CURRENT_RECORD_UNDEFINED &&
		nRetCode != SQL_NO_DATA_FOUND)
		*plCurrentRecord += nRows;
}

void AFXAPI _AfxSetRecordCount(long* plRecordCount, long lCurrentRecord,
	BOOL bEOFSeen, RETCODE nRetCode)
{
	// If not at the end and haven't yet been to the end, incr count
	if (nRetCode != SQL_NO_DATA_FOUND && !bEOFSeen &&
		lCurrentRecord != AFX_CURRENT_RECORD_UNDEFINED)
	{
		ENSURE_ARG(plRecordCount != NULL);
		// lCurrentRecord 0-based and it's already been set
		*plRecordCount =
			__max(*plRecordCount, lCurrentRecord + 1);
	}
}

//////////////////////////////////////////////////////////////////////////////
// Inline function declarations expanded out-of-line

#ifndef _AFX_ENABLE_INLINES

#define _AFXDBCORE_INLINE
#include "afxdb.inl"

#endif


IMPLEMENT_DYNAMIC(CDBException, CException)
IMPLEMENT_DYNAMIC(CDatabase, CObject)
IMPLEMENT_DYNAMIC(CRecordset, CObject)

#pragma warning(disable: 4074)
#pragma init_seg(lib)

PROCESS_LOCAL(_AFX_DB_STATE, _afxDbState)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\dbflt.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include <float.h>



// Helpers for floating point operations
const float afxFloatPseudoNull = AFX_RFX_SINGLE_PSEUDO_NULL;
const double afxDoublePseudoNull = AFX_RFX_DOUBLE_PSEUDO_NULL;

extern void AFXAPI AfxTextFloatFormat(CDataExchange* pDX, int nIDC,
	void* pData, double value, int nSizeGcvt);

extern BOOL AFXAPI AfxFieldText(CDataExchange* pDX, int nIDC, void* pv,
	CRecordset* pRecordset);

void AFXAPI RFX_Single(CFieldExchange* pFX, LPCTSTR szName,
	float& value)
{
	ASSERT(AfxIsValidAddress(pFX, sizeof(CFieldExchange)));
	ENSURE_ARG(pFX!=NULL);
	ENSURE_ARG(AfxIsValidString(szName));

	UINT nField;
	if (!pFX->IsFieldType(&nField))
		return;

	LONG_PTR* plLength = pFX->m_prs->GetFieldLengthBuffer(nField - 1, pFX->m_nFieldType);
	switch (pFX->m_nOperation)
	{
	case CFieldExchange::BindFieldToColumn:
		{
#ifdef _DEBUG
			// Assumes all bound fields BEFORE unbound fields
			CODBCFieldInfo* pODBCInfo =
				&pFX->m_prs->m_rgODBCFieldInfos[nField - 1];

			if (pODBCInfo->m_nSQLType != SQL_C_FLOAT)
				// Warn of possible field schema mismatch
				TRACE(traceDatabase, 0, "Warning: float converted from SQL type %ld.\n",
					pODBCInfo->m_nSQLType);
#endif
		}
		// fall through

	default:
LDefault:
		pFX->Default(szName, &value, plLength, SQL_C_FLOAT,
			sizeof(value), 13);
		return;

	case CFieldExchange::Fixup:
		if (*plLength == SQL_NULL_DATA)
		{
			pFX->m_prs->SetNullFieldStatus(nField - 1);
			value = afxFloatPseudoNull;
		}
		return;

	case CFieldExchange::SetFieldNull:
		if ((pFX->m_pvField == NULL &&
			pFX->m_nFieldType == CFieldExchange::outputColumn) ||
			pFX->m_pvField == &value)
		{
			if (pFX->m_bField)
			{
				pFX->m_prs->SetNullFieldStatus(nField - 1);
				value = afxFloatPseudoNull;
				*plLength = SQL_NULL_DATA;
			}
			else
			{
				pFX->m_prs->ClearNullFieldStatus(nField - 1);
				*plLength = sizeof(value);
			}
#ifdef _DEBUG
			pFX->m_nFieldFound = nField;
#endif
		}
		return;

	case CFieldExchange::MarkForAddNew:
		// can force writing of psuedo-null value (as a non-null) by setting field dirty
		if (value != afxFloatPseudoNull)
		{
			pFX->m_prs->SetDirtyFieldStatus(nField - 1);
			pFX->m_prs->ClearNullFieldStatus(nField - 1);
		}
		return;

	case CFieldExchange::MarkForUpdate:
		if (value != afxFloatPseudoNull)
			pFX->m_prs->ClearNullFieldStatus(nField - 1);
		goto LDefault;

	case CFieldExchange::AllocCache:
		{
			CFieldInfo* pInfo = &pFX->m_prs->m_rgFieldInfos[nField - 1];

			// Data cached by value, no allocation necessary
			pInfo->m_nDataType = AFX_RFX_SINGLE;
		}
		return;

#ifdef _DEBUG
	case CFieldExchange::DumpField:
		{
			*pFX->m_pdcDump << "\n" << szName << " = " << value;
		}
		return;
#endif //_DEBUG

	}
}


void AFXAPI RFX_Double(CFieldExchange* pFX, LPCTSTR szName,
	double& value)
{
	ASSERT(AfxIsValidAddress(pFX, sizeof(CFieldExchange)));
	ENSURE_ARG(pFX!=NULL);
	ENSURE_ARG(AfxIsValidString(szName));

	UINT nField;
	if (!pFX->IsFieldType(&nField))
		return;

	LONG_PTR* plLength = pFX->m_prs->GetFieldLengthBuffer(nField - 1, pFX->m_nFieldType);
	switch (pFX->m_nOperation)
	{
	case CFieldExchange::BindFieldToColumn:
		{
#ifdef _DEBUG
			// Assumes all bound fields BEFORE unbound fields
			CODBCFieldInfo* pODBCInfo =
				&pFX->m_prs->m_rgODBCFieldInfos[nField - 1];

			if (pODBCInfo->m_nSQLType != SQL_C_DOUBLE &&
				pODBCInfo->m_nSQLType != SQL_FLOAT)
			{
				// Warn of possible field schema mismatch
				TRACE(traceDatabase, 0, "Warning: double converted from SQL type %ld.\n",
					pODBCInfo->m_nSQLType);
			}
#endif
		}
		// fall through

	default:
LDefault:
		pFX->Default(szName, &value, plLength, SQL_C_DOUBLE,
			sizeof(value), 22);
		return;

	case CFieldExchange::Fixup:
		if (*plLength == SQL_NULL_DATA)
		{
			pFX->m_prs->SetNullFieldStatus(nField - 1);
			value = afxDoublePseudoNull;
		}
		return;

	case CFieldExchange::SetFieldNull:
		if ((pFX->m_pvField == NULL &&
			pFX->m_nFieldType == CFieldExchange::outputColumn) ||
			pFX->m_pvField == &value)
		{
			if (pFX->m_bField)
			{
				pFX->m_prs->SetNullFieldStatus(nField - 1);
				value = afxDoublePseudoNull;
				*plLength = SQL_NULL_DATA;
			}
			else
			{
				pFX->m_prs->ClearNullFieldStatus(nField - 1);
				*plLength = sizeof(value);
			}
#ifdef _DEBUG
			pFX->m_nFieldFound = nField;
#endif
		}
		return;

	case CFieldExchange::MarkForAddNew:
		// can force writing of psuedo-null value (as a non-null) by setting field dirty
		if (value != afxDoublePseudoNull)
		{
			pFX->m_prs->SetDirtyFieldStatus(nField - 1);
			pFX->m_prs->ClearNullFieldStatus(nField - 1);
		}
		return;

	case CFieldExchange::MarkForUpdate:
		if (value != afxDoublePseudoNull)
			pFX->m_prs->ClearNullFieldStatus(nField - 1);
		goto LDefault;

	case CFieldExchange::AllocCache:
		{
			CFieldInfo* pInfo = &pFX->m_prs->m_rgFieldInfos[nField - 1];
			pInfo->m_pvDataCache = new double;
			pInfo->m_nDataType = AFX_RFX_DOUBLE;
		}
		return;

#ifdef _DEBUG
	case CFieldExchange::DumpField:
		{
			*pFX->m_pdcDump << "\n" << szName << " = " << value;
		}
		return;
#endif //_DEBUG

	}
}

/////////////////////////////////////////////////////////////////////////////

void AFXAPI RFX_Single_Bulk(CFieldExchange* pFX, LPCTSTR szName,
	float** prgFltVals, LONG_PTR** prgLengths)
{
	ENSURE_ARG(AfxIsValidAddress(pFX, sizeof(CFieldExchange)));
	ENSURE_ARG(AfxIsValidString(szName));
	ENSURE_ARG(prgFltVals != NULL && prgLengths != NULL);

	UINT nField;
	if (!pFX->IsFieldType(&nField))
		return;

	switch (pFX->m_nOperation)
	{
	case CFieldExchange::AllocMultiRowBuffer:
		{
			// The buffer pointer better be initialized to NULL
			// or cleanup in exceptional cases mail fail
			ASSERT(*prgFltVals == NULL);
			ASSERT(*prgLengths == NULL);

			int nRowsetSize = pFX->m_prs->GetRowsetSize();

			// Allocate buffers to hold data and length
			*prgFltVals = new float[nRowsetSize];
			*prgLengths = new LONG_PTR[nRowsetSize];
		}
		break;

	case CFieldExchange::DeleteMultiRowBuffer:
		delete [] *prgFltVals;
		*prgFltVals = NULL;

		delete [] *prgLengths;
		*prgLengths = NULL;
		break;

	default:
		AfxRFXBulkDefault(pFX, szName, *prgFltVals, *prgLengths,
			SQL_C_FLOAT, sizeof(float));
		break;
	}
}

void AFXAPI RFX_Double_Bulk(CFieldExchange* pFX, LPCTSTR szName,
	double** prgDblVals, LONG_PTR** prgLengths)
{
	ENSURE_ARG(AfxIsValidAddress(pFX, sizeof(CFieldExchange)));
	ENSURE_ARG(AfxIsValidString(szName));
	ENSURE_ARG(prgDblVals != NULL && prgLengths != NULL);

	UINT nField;
	if (!pFX->IsFieldType(&nField))
		return;

	switch (pFX->m_nOperation)
	{
	case CFieldExchange::AllocMultiRowBuffer:
		{
			// The buffer pointer better be initialized to NULL
			// or cleanup in exceptional cases mail fail
			ASSERT(*prgDblVals == NULL);
			ASSERT(*prgLengths == NULL);

			int nRowsetSize = pFX->m_prs->GetRowsetSize();

			// Allocate buffers to hold data and length
			*prgDblVals = new double[nRowsetSize];
			*prgLengths = new LONG_PTR[nRowsetSize];
		}
		break;

	case CFieldExchange::DeleteMultiRowBuffer:
		delete [] *prgDblVals;
		*prgDblVals = NULL;

		delete [] *prgLengths;
		*prgLengths = NULL;
		break;

	default:
		AfxRFXBulkDefault(pFX, szName, *prgDblVals, *prgLengths,
			SQL_C_DOUBLE, sizeof(double));
		break;
	}
}

/////////////////////////////////////////////////////////////////////////////

void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, float& value,
	CRecordset* pRecordset)
{
	if (!AfxFieldText(pDX, nIDC, &value, pRecordset))
		AfxTextFloatFormat(pDX, nIDC, &value, value, FLT_DIG);
}

void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, double& value,
	CRecordset* pRecordset)
{
	if (!AfxFieldText(pDX, nIDC, &value, pRecordset))
		AfxTextFloatFormat(pDX, nIDC, &value, value, DBL_DIG);
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\dbimpl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Note: must include AFXDB.H first

#pragma once

#undef AFX_DATA
#define AFX_DATA AFX_DB_DATA

/////////////////////////////////////////////////////////////////////////////
// _AFX_DB_STATE

#undef AFX_DATA
#define AFX_DATA

class _AFX_DB_STATE : public CNoTrackObject
{
public:
	// MFC/DB global data
	HENV m_henvAllConnections;      // per-app HENV (CDatabase)
	int m_nAllocatedConnections;    // per-app reference to HENV above
};

EXTERN_PROCESS_LOCAL(_AFX_DB_STATE, _afxDbState)

#undef AFX_DATA
#define AFX_DATA

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\dbvar.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

//////////////////////////////////////////////////////////////////////////////
// Implementation of CDBVariant

CDBVariant::CDBVariant()
{
	// Initialize type and value
	m_dwType = DBVT_NULL;
}

void CDBVariant::Clear()
{
	switch(m_dwType)
	{
	case DBVT_NULL:
		return;

	case DBVT_BOOL:
	case DBVT_UCHAR:
	case DBVT_SHORT:
	case DBVT_LONG:
	case DBVT_SINGLE:
	case DBVT_DOUBLE:
		break;

	case DBVT_STRING:
		delete m_pstring;
		break;

	case DBVT_BINARY:
		delete m_pbinary;
		break;

	case DBVT_DATE:
		delete m_pdate;
		break;

	case DBVT_ASTRING:
		delete m_pstringA;
		break;

	case DBVT_WSTRING:
		delete m_pstringW;
		break;

	default:
		ASSERT(FALSE);
		break;
	}
	m_dwType = DBVT_NULL;
}

CDBVariant::~CDBVariant()
{
	Clear();
}

//////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\dblong.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CLongBinary class for holding LONG VARBINARY data

CLongBinary::CLongBinary()
{
	m_hData = NULL;
}

CLongBinary::~CLongBinary()
{
	if (m_hData != NULL)
	{
		::GlobalFree(m_hData);
		m_hData = NULL;
	}
}

//////////////////////////////////////////////////////////////////////////////
// CLongBinary diagnostics

#ifdef _DEBUG
void CLongBinary::AssertValid() const
{
	CObject::AssertValid();
}

void CLongBinary::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	dc << "m_hData = " << m_hData;
	dc << "\nm_dwDataLength = " << m_dwDataLength;
	dc << "\n";
}
#endif //_DEBUG

//////////////////////////////////////////////////////////////////////////////



IMPLEMENT_DYNAMIC(CLongBinary, CObject)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\dbrfx.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"	
#include "sal.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CDBByteArray db specific class for holding byte array data
class CDBByteArray : public CByteArray
{
	DECLARE_DYNAMIC(CDBByteArray)

// Operations
	void SetLength(int nNewSize);
};

inline void CDBByteArray::SetLength(int nNewSize)
{
	// Can't grow buffer since ODBC has been SQLBindCol'd on it.
	ASSERT(nNewSize <= m_nMaxSize);
	if(nNewSize > m_nMaxSize)
		AfxThrowInvalidArgException();
	m_nSize = nNewSize;
}

//////////////////////////////////////////////////////////////////////////////
// CFieldExchange

CFieldExchange::CFieldExchange(UINT nOperation, CRecordset* prs, void* pvField)
{
#ifdef _DEBUG
#pragma warning( push )
#pragma warning( disable: 4296 )
	ASSERT(nOperation >= BindParam && nOperation <= DumpField);
#pragma warning( pop )
#endif
	ENSURE_VALID(prs);
	ENSURE(prs->m_hstmt != SQL_NULL_HSTMT);

	m_nFieldType = (UINT) noFieldType;
	m_nOperation = nOperation;
	m_prs = prs;
	m_pvField = pvField;

	m_nFields = 0;
	m_nParams = 0;
	m_nParamFields = 0;
	m_bField = FALSE;
	m_pstr = NULL;
	m_hstmt = SQL_NULL_HSTMT;

	m_lDefaultLBFetchSize = 0x00010000;
	m_lDefaultLBReallocSize = 0x00010000;
}

BOOL CFieldExchange::IsFieldType(UINT* pnField)
{
	ENSURE_ARG(pnField != NULL);
	if (m_nFieldType == outputColumn)
	{
		*pnField = ++m_nFields;
		// Recordset's m_nFields must match number of Fields!
		ASSERT(m_nFields <= m_prs->m_nFields);
	}
	else
	{
		// Make sure SetFieldType was called
		ASSERT(m_nFieldType == inputParam ||
			m_nFieldType == outputParam ||
			m_nFieldType == inoutParam);

		*pnField = ++m_nParams;
		// Recordset's m_nParams must match number of Params!
		ASSERT(m_nParams <= m_prs->m_nParams);
	}

	if (m_nOperation == BindParam || m_nOperation == RebindParam)
	{
		// only valid on a param field type
		return m_nFieldType != outputColumn;
	}
	else
	if (m_nOperation == Fixup)
	{
		return m_nFieldType == outputColumn ||
			   m_nFieldType == outputParam  ||
			   m_nFieldType == inoutParam;
	}
	else
	{
		// valid only on an outputColumn field type
		return m_nFieldType == outputColumn;
	}
}

// Default implementation for RFX functions
void CFieldExchange::Default(LPCTSTR szName,
	void* pv, LONG_PTR* plLength, int nCType, SQLULEN cbValue, SQLULEN cbPrecision)
{
	RETCODE nRetCode;
	UINT nField = (m_nFieldType == outputColumn)? m_nFields: m_nParams;
	switch (m_nOperation)
	{
	case BindParam:
		ENSURE_ARG(plLength != NULL);
		if (m_prs->IsParamStatusNull(nField - 1))
			*plLength = SQL_NULL_DATA;
		else
			*plLength = cbValue;
		// For params, CType is same as SQL type
		AFX_SQL_SYNC(::SQLBindParameter(m_hstmt, (UWORD)nField,
			(SWORD)m_nFieldType, (SWORD)nCType, (SWORD)nCType, cbPrecision, 0,
			pv, 0, plLength));
		if (nRetCode != SQL_SUCCESS)
			m_prs->ThrowDBException(nRetCode, m_hstmt);

		// Add the member address to the param map
		m_prs->m_mapParamIndex.SetAt(pv, (void*)(UINT_PTR)nField);
		return;

	case RebindParam:
		ENSURE_ARG(plLength != NULL);
		// Only need to reset param length
		*plLength = m_prs->IsParamStatusNull(nField - 1) ? SQL_NULL_DATA : cbValue;
		return;

	case BindFieldForUpdate:
		ENSURE_ARG(plLength != NULL);
		if (!m_prs->IsFieldStatusDirty(nField - 1))
		{
			// If not dirty, set length to SQL_IGNORE for SQLSetPos updates
			*plLength = SQL_IGNORE;
		}
		else if (!m_prs->IsFieldStatusNull(nField - 1))
		{
			// Reset the length as it may have changed for var length fields
			*plLength = cbValue;
		}
		else if (m_prs->IsFieldStatusNull(nField - 1))
			*plLength = SQL_NULL_DATA;

		return;

	case UnbindFieldForUpdate:
		// Reset bound length to actual length to clear SQL_IGNOREs
		if (!m_prs->IsFieldStatusDirty(nField - 1))
		{
			ENSURE_ARG(plLength != NULL);
			*plLength = cbValue;
		}
		return;

	case BindFieldToColumn:
		AFX_SQL_SYNC(::SQLBindCol(m_prs->m_hstmt, (UWORD)nField, (SWORD)nCType,
			pv, cbValue, plLength));
		if (!m_prs->Check(nRetCode))
			m_prs->ThrowDBException(nRetCode);

		// Add the member address to the field map
		m_prs->m_mapFieldIndex.SetAt(pv, (void*)(UINT_PTR)nField);
		return;

	case Name:
		if (m_prs->IsFieldStatusDirty(nField - 1))
		{
			// We require a name
			ASSERT(lstrlen(szName) != 0);

			*m_pstr += szName;
			*m_pstr += m_lpszSeparator;
		}
		return;

	case NameValue:
		if (m_prs->IsFieldStatusDirty(nField - 1))
		{
			*m_pstr += szName;
			*m_pstr += '=';
		}

		// Fall through
	case Value:
		if (m_prs->IsFieldStatusDirty(nField - 1))
		{
			ENSURE_ARG(plLength != NULL);
			// If user marked column NULL, reflect this in length
			if (m_prs->IsFieldStatusNull(nField - 1))
				*plLength = SQL_NULL_DATA;
			else
				*plLength = cbValue;

			// If optimizing for bulk add, only need lengths set correctly
			if(!(m_prs->m_dwOptions & CRecordset::optimizeBulkAdd))
			{
				*m_pstr += '?';
				*m_pstr += m_lpszSeparator;
				m_nParamFields++;

				// Assumes all bound fields BEFORE unbound fields
				CODBCFieldInfo* pODBCInfo =
					&m_prs->m_rgODBCFieldInfos[nField - 1];

				AFX_SQL_SYNC(::SQLBindParameter(m_hstmt,
					(UWORD)m_nParamFields, SQL_PARAM_INPUT,
					(SWORD)nCType, pODBCInfo->m_nSQLType,
					pODBCInfo->m_nPrecision, pODBCInfo->m_nScale,
					pv, 0, plLength));
				if (nRetCode != SQL_SUCCESS)
					m_prs->ThrowDBException(nRetCode, m_hstmt);
			}
		}
		return;

	case MarkForUpdate:
		{
			// Get the field data
			CFieldInfo* pInfo = &m_prs->m_rgFieldInfos[nField - 1];

			// If user changed field value from previous value, mark field dirty
			if ((pInfo->m_bStatus & AFX_SQL_FIELD_FLAG_NULL))
			{
				if (!m_prs->IsFieldStatusNull(nField - 1))
					m_prs->SetDirtyFieldStatus(nField - 1);
			}
			else
			{
				// Saved field is not NULL. current field null, so field dirty
				BOOL bDirty = m_prs->IsFieldStatusNull(nField - 1);

				// If values differ, then field dirty
				void* pvDataCache;

				if (pInfo->m_nDataType == AFX_RFX_BOOL ||
					pInfo->m_nDataType == AFX_RFX_BYTE ||
					pInfo->m_nDataType == AFX_RFX_INT ||
					pInfo->m_nDataType == AFX_RFX_LONG ||
					pInfo->m_nDataType == AFX_RFX_SINGLE)
				{
					// If caching data by value, pass a ref
					pvDataCache = &pInfo->m_pvDataCache;
				}
				else
					pvDataCache = pInfo->m_pvDataCache;

				if (bDirty || !AfxCompareValueByRef(pv, pvDataCache, pInfo->m_nDataType))
					m_prs->SetDirtyFieldStatus(nField - 1);
			}

#ifdef _DEBUG
			// Field address must not change - ODBC's SQLBindCol depends upon this
			void* pvBind;
			
			switch (pInfo->m_nDataType)
			{
			default:
				pvBind = pv;
				break;

			case AFX_RFX_LPWSTR:
			case AFX_RFX_LPASTR:
				pvBind = pv;
				break;

			case AFX_RFX_WTEXT:
				ENSURE_ARG(pv != NULL);
				pvBind = static_cast<CStringW *>(pv)->GetBuffer(0);
				static_cast<CStringW *>(pv)->ReleaseBuffer();
				break;

			case AFX_RFX_ATEXT:
				ENSURE_ARG(pv != NULL);
				pvBind = static_cast<CStringA *>(pv)->GetBuffer(0);
				static_cast<CStringA *>(pv)->ReleaseBuffer();
				break;

			case AFX_RFX_OLEDATE:
			case AFX_RFX_DATE:
				pvBind = m_prs->m_pvFieldProxy[nField-1];
				break;

			case AFX_RFX_BINARY:
				ENSURE_ARG(pv != NULL);
				pvBind = ((CByteArray*)pv)->GetData();
				break;
			}

			if (pInfo->m_pvBindAddress != pvBind)
			{
				TRACE(traceDatabase, 0, "Error: field address (column %u) has changed!\n",
					nField);
				ASSERT(FALSE);
			}
#endif // _DEBUG

			if ((m_pvField == NULL  || m_pvField == pv) &&
				m_prs->IsFieldStatusDirty(nField - 1))
			{
				m_bField = TRUE;
			}
		}
		return;

	case StoreField:
		AfxStoreField(*m_prs, nField, pv);
		return;

	case LoadField:
		AfxLoadField(*m_prs, nField, pv, plLength);
		return;

	default:
		ASSERT(FALSE);
	}
}

namespace nsRFX_Text
{
inline int RFX_Text_strlen(_In_ LPSTR  psz){return ::lstrlenA(psz);}
inline int RFX_Text_strlen(_In_ LPWSTR psz){return ::lstrlenW(psz);}

inline void RFX_Text_inc(LPSTR *ppsz)
	#ifdef _MBCS
		{*ppsz = reinterpret_cast<char *>(_mbsinc(reinterpret_cast<unsigned char *>(*ppsz)));}
	#else
		{(*ppsz)++;}
	#endif
inline void RFX_Text_inc(_Inout_ LPWSTR *ppsz){(*ppsz)++;}

template<typename CharType>
void RFX_Text(CFieldExchange* pFX, LPCTSTR szName,
	CharType *value, int nMaxLength, int nColumnType, short nScale,
	short nFieldType, CharType cSpace)
{
	ENSURE_ARG(AfxIsValidAddress(pFX, sizeof(CFieldExchange)));
	ENSURE_ARG(AfxIsValidString(szName));
	ENSURE_ARG(AfxIsValidAddress(value, nMaxLength * sizeof(CharType)));

	RETCODE nRetCode;
	UINT nField;
	if (!pFX->IsFieldType(&nField))
		return;

	LONG_PTR* plLength = pFX->m_prs->GetFieldLengthBuffer(
		nField - 1, pFX->m_nFieldType);
	switch (pFX->m_nOperation)
	{
	default:
		pFX->Default(szName, value, plLength,
			nFieldType, RFX_Text_strlen(value) * sizeof(CharType), nMaxLength);
		return;

	case CFieldExchange::BindParam:
		{
			void* pvParam = value;

			*plLength = pFX->m_prs->IsParamStatusNull(nField - 1) ?
				SQL_NULL_DATA : SQL_NTS;

			AFX_SQL_SYNC(::SQLBindParameter(pFX->m_hstmt, (UWORD)nField,
				 (SWORD)pFX->m_nFieldType, nFieldType, (SWORD)nColumnType,
				 nMaxLength, nScale, pvParam, nMaxLength * sizeof(CharType),
				 plLength));

			if (nRetCode != SQL_SUCCESS)
				pFX->m_prs->ThrowDBException(nRetCode, pFX->m_hstmt);

			// Add the member address to the param map
			pFX->m_prs->m_mapParamIndex.SetAt(value, (void*)(UINT_PTR)nField);
		}
		return;

	case CFieldExchange::BindFieldToColumn:
		{
			// Assumes all bound fields BEFORE unbound fields
			CODBCFieldInfo* pODBCInfo =
				&pFX->m_prs->m_rgODBCFieldInfos[nField - 1];
			SQLULEN cbColumn = pODBCInfo->m_nPrecision;

			switch (pODBCInfo->m_nSQLType)
			{
			default:
#ifdef _DEBUG
				// Warn of possible field schema mismatch
				TRACE(traceDatabase, 1, "Warning: CString converted from SQL type %ld.\n",
					pODBCInfo->m_nSQLType);
#endif // _DEBUG

				// Add room for extra information like sign, decimal point, etc.
				cbColumn += 10;
				break;

			case SQL_LONGVARCHAR:
			case SQL_CHAR:
			case SQL_VARCHAR:
			case SQL_WLONGVARCHAR:
			case SQL_WCHAR:
			case SQL_WVARCHAR:
				break;

			case SQL_FLOAT:
			case SQL_REAL:
			case SQL_DOUBLE:
				// Add room for sign, decimal point and " E +XXX"
				cbColumn += 10;
				break;

			case SQL_DECIMAL:
			case SQL_NUMERIC:
				// Add room for sign and decimal point
				cbColumn += 2;
				break;

			case SQL_TIMESTAMP:
			case SQL_DATE:
			case SQL_TIME:
				// May need extra space, i.e. "{TS mm/dd/yyyy hh:mm:ss}"
				cbColumn += 10;
				break;

			case SQL_TINYINT:
			case SQL_SMALLINT:
			case SQL_INTEGER:
			case SQL_BIGINT:
				// Add room for sign
				cbColumn += 1;
				break;
			}

			// Constrain to user specified max length, subject to 256 byte min
			if (cbColumn > (SQLULEN)nMaxLength || cbColumn < 256)
				cbColumn = nMaxLength;

			// Set up binding addres

			void* pvData = value;
			value[cbColumn] = 0;

			AFX_SQL_SYNC(::SQLBindCol(pFX->m_prs->m_hstmt, (UWORD)nField,
				nFieldType, pvData, (cbColumn+1) * sizeof(CharType), plLength));
			if (!pFX->m_prs->Check(nRetCode))
				pFX->m_prs->ThrowDBException(nRetCode);

			// Add the member address to the field map
			pFX->m_prs->m_mapFieldIndex.SetAt(value, (void*)(UINT_PTR)nField);
		}
		return;

	case CFieldExchange::Fixup:
		if (*plLength == SQL_NULL_DATA)
		{
			if (pFX->m_bField)
			{
				pFX->m_prs->SetNullFieldStatus(nField - 1);
			}
			value[0] = 0;
		}
		else
		{
			CharType *lpsz = value;
			if (pFX->m_prs->m_pDatabase->m_bStripTrailingSpaces)
			{
				// find first trailing space
				CharType *lpszFirstTrailing = NULL;
				while (*lpsz != 0)
				{
					if (*lpsz != cSpace)
						lpszFirstTrailing = NULL;
					else
					{
						if (lpszFirstTrailing == NULL)
							lpszFirstTrailing = lpsz;
					}
					RFX_Text_inc(&lpsz);
				}
				// truncate
				if (lpszFirstTrailing != NULL)
					*lpszFirstTrailing = 0;

			}
			*plLength = RFX_Text_strlen(value) * sizeof(CharType);
		}
		return;

	case CFieldExchange::SetFieldNull:
		if ((pFX->m_pvField == NULL &&
			pFX->m_nFieldType == CFieldExchange::outputColumn) ||
			pFX->m_pvField == value)
		{
			if (pFX->m_bField)
			{
				// Mark fields null
				pFX->m_prs->SetNullFieldStatus(nField - 1);
				// Set string 0 length
				*plLength = SQL_NULL_DATA;
			}
			else
			{
				pFX->m_prs->ClearNullFieldStatus(nField - 1);
				*plLength = SQL_NTS;
			}
#ifdef _DEBUG
			pFX->m_nFieldFound = nField;
#endif
		}
		return;

	case CFieldExchange::MarkForAddNew:
		// can force writing of psuedo-null value (as a non-null) by setting field dirty
		if (*value != 0)
		{
			pFX->m_prs->SetDirtyFieldStatus(nField - 1);
			pFX->m_prs->ClearNullFieldStatus(nField - 1);
		}
		return;

	case CFieldExchange::MarkForUpdate:
		if (*value == 0)
			pFX->m_prs->SetNullFieldStatus(nField - 1);
		else
			pFX->m_prs->ClearNullFieldStatus(nField - 1);
		pFX->Default(szName, value, plLength,
			nFieldType, RFX_Text_strlen(value) * sizeof(CharType), nMaxLength);
		return;

	case CFieldExchange::LoadField:
		{
			// Get the field data
			CFieldInfo* pInfo = &pFX->m_prs->m_rgFieldInfos[nField - 1];

			// Restore the status
			pFX->m_prs->SetFieldStatus(nField - 1, pInfo->m_bStatus);

			// If not NULL, restore the value and length
			if (!pFX->m_prs->IsFieldStatusNull(nField - 1))
			{
				value = static_cast<CharType *>(pInfo->m_pvDataCache);
				*plLength = RFX_Text_strlen(value) * sizeof(CharType);
			}
			else
				*plLength = SQL_NULL_DATA;

#ifdef _DEBUG
			// Buffer address must not change - ODBC's SQLBindCol depends upon this
			void *pvBind = value;
			if (pvBind != pInfo->m_pvBindAddress)
			{
				TRACE(traceDatabase, 0, "Error: buffer (column %u) address has changed!\n",
					nField);
				ASSERT(FALSE);
			}
#endif // _DEBUG
		}
		return;

	case CFieldExchange::StoreField:
		AfxStoreField(*pFX->m_prs, nField, value);
		return;

	case CFieldExchange::AllocCache:
		{
			CFieldInfo* pInfo = &pFX->m_prs->m_rgFieldInfos[nField - 1];
			pInfo->m_pvDataCache = new CharType[nMaxLength];
			pInfo->m_nDataType = nFieldType == SQL_C_WCHAR ? AFX_RFX_LPWSTR : AFX_RFX_LPASTR;
		}
		return;

#ifdef _DEBUG
	case CFieldExchange::DumpField:
		*pFX->m_pdcDump << "\n" << szName << " = " << value;
		return;
#endif // _DEBUG
	}
}

// Note: CString.m_pchData must not be changed.  This address is registered
// with ODBC and must remain valid until the recordset is released.
template<typename StringType>
void RFX_Text(CFieldExchange* pFX, LPCTSTR szName,
	StringType &value, int nMaxLength, int nColumnType, short nScale,
	short nFieldType, typename StringType::XCHAR cSpace)
{
	ENSURE_ARG(AfxIsValidAddress(pFX, sizeof(CFieldExchange)));
	ENSURE_ARG(AfxIsValidString(szName));
	ENSURE_ARG(AfxIsValidAddress(&value, sizeof(StringType)));

	RETCODE nRetCode;
	UINT nField;
	if (!pFX->IsFieldType(&nField))
		return;

	LONG_PTR* plLength = pFX->m_prs->GetFieldLengthBuffer(
		nField - 1, pFX->m_nFieldType);
	switch (pFX->m_nOperation)
	{
	default:
		pFX->Default(szName, value.GetBuffer(0), plLength,
			nFieldType, value.GetLength() * sizeof(StringType::XCHAR), nMaxLength);
		value.ReleaseBuffer();
		return;

	case CFieldExchange::BindParam:
		{
			// Preallocate to nMaxLength and setup binding address
			value.GetBufferSetLength(nMaxLength);
			void *pvParam = value.LockBuffer();

			*plLength = pFX->m_prs->IsParamStatusNull(nField - 1) ?
				SQL_NULL_DATA : SQL_NTS;

			AFX_SQL_SYNC(::SQLBindParameter(pFX->m_hstmt, (UWORD)nField,
				 (SWORD)pFX->m_nFieldType, nFieldType, (SWORD)nColumnType,
				 nMaxLength, nScale, pvParam, nMaxLength * sizeof(StringType::XCHAR),
				 plLength));

			value.ReleaseBuffer();

			if (nRetCode != SQL_SUCCESS)
				pFX->m_prs->ThrowDBException(nRetCode, pFX->m_hstmt);

			// Add the member address to the param map
			pFX->m_prs->m_mapParamIndex.SetAt(&value, (void*)(UINT_PTR)nField);
		}
		return;

	case CFieldExchange::BindFieldToColumn:
		{
			// Assumes all bound fields BEFORE unbound fields
			CODBCFieldInfo* pODBCInfo =
				&pFX->m_prs->m_rgODBCFieldInfos[nField - 1];
			SQLULEN cbColumn = pODBCInfo->m_nPrecision;

			switch (pODBCInfo->m_nSQLType)
			{
			default:
#ifdef _DEBUG
				// Warn of possible field schema mismatch
				TRACE(traceDatabase, 1, "Warning: CString converted from SQL type %ld.\n",
					pODBCInfo->m_nSQLType);
#endif // _DEBUG

				// Add room for extra information like sign, decimal point, etc.
				cbColumn += 10;
				break;

			case SQL_LONGVARCHAR:
			case SQL_CHAR:
			case SQL_VARCHAR:
			case SQL_WLONGVARCHAR:
			case SQL_WCHAR:
			case SQL_WVARCHAR:
				break;

			case SQL_FLOAT:
			case SQL_REAL:
			case SQL_DOUBLE:
				// Add room for sign, decimal point and " E +XXX"
				cbColumn += 10;
				break;

			case SQL_DECIMAL:
			case SQL_NUMERIC:
				// Add room for sign and decimal point
				cbColumn += 2;
				break;

			case SQL_TIMESTAMP:
			case SQL_DATE:
			case SQL_TIME:
				// May need extra space, i.e. "{TS mm/dd/yyyy hh:mm:ss}"
				cbColumn += 10;
				break;

			case SQL_TINYINT:
			case SQL_SMALLINT:
			case SQL_INTEGER:
			case SQL_BIGINT:
				// Add room for sign
				cbColumn += 1;
				break;
			}

			// Constrain to user specified max length, subject to 256 byte min
			if (cbColumn > (SQLULEN)nMaxLength || cbColumn < 256)
				cbColumn = nMaxLength;

			// Set up binding addres
			void* pvData;
			if (cbColumn > (INT_MAX-1))
				AfxThrowMemoryException();
			value.GetBufferSetLength((int)cbColumn+1);  
			pvData = value.LockBuffer();

			AFX_SQL_SYNC(::SQLBindCol(pFX->m_prs->m_hstmt, (UWORD)nField,
				nFieldType, pvData, (cbColumn+1) * sizeof(StringType::XCHAR),
				plLength));
			value.ReleaseBuffer();
			if (!pFX->m_prs->Check(nRetCode))
				pFX->m_prs->ThrowDBException(nRetCode);

			// Add the member address to the field map
			pFX->m_prs->m_mapFieldIndex.SetAt(&value, (void*)(UINT_PTR)nField);
		}
		return;

	case CFieldExchange::Fixup:
		if (*plLength == SQL_NULL_DATA)
		{
			if (pFX->m_bField)
			{
				pFX->m_prs->SetNullFieldStatus(nField - 1);
			}
			value.GetBufferSetLength(0);
			value.ReleaseBuffer();
		}
		else
		{
			StringType::XCHAR *lpsz = value.GetBuffer(0);
			if (pFX->m_prs->m_pDatabase->m_bStripTrailingSpaces)
			{
				// find first trailing space
				StringType::XCHAR *lpszFirstTrailing = NULL;
				while (*lpsz != 0)
				{
					if (*lpsz != cSpace)
						lpszFirstTrailing = NULL;
					else
					{
						if (lpszFirstTrailing == NULL)
							lpszFirstTrailing = lpsz;
					}
					RFX_Text_inc(&lpsz);
				}
				// truncate
				if (lpszFirstTrailing != NULL)
					*lpszFirstTrailing = 0;

			}
			value.ReleaseBuffer();
			*plLength = value.GetLength() * sizeof(StringType::XCHAR);
		}
		return;

	case CFieldExchange::SetFieldNull:
		if ((pFX->m_pvField == NULL &&
			pFX->m_nFieldType == CFieldExchange::outputColumn) ||
			pFX->m_pvField == &value)
		{
			if (pFX->m_bField)
			{
				// Mark fields null
				pFX->m_prs->SetNullFieldStatus(nField - 1);
				// Set string 0 length
				value.GetBufferSetLength(0);
				value.ReleaseBuffer();
				*plLength = SQL_NULL_DATA;
			}
			else
			{
				pFX->m_prs->ClearNullFieldStatus(nField - 1);
				*plLength = SQL_NTS;
			}
#ifdef _DEBUG
			pFX->m_nFieldFound = nField;
#endif
		}
		return;

	case CFieldExchange::MarkForAddNew:
		// can force writing of psuedo-null value (as a non-null) by setting field dirty
		if (!value.IsEmpty())
		{
			pFX->m_prs->SetDirtyFieldStatus(nField - 1);
			pFX->m_prs->ClearNullFieldStatus(nField - 1);
		}
		return;

	case CFieldExchange::MarkForUpdate:
		if (value.IsEmpty())
			pFX->m_prs->SetNullFieldStatus(nField - 1);
		else
			pFX->m_prs->ClearNullFieldStatus(nField - 1);
		pFX->Default(szName, &value, plLength,
			nFieldType, value.GetLength() * sizeof(StringType::XCHAR), nMaxLength);
		return;

	case CFieldExchange::LoadField:
		{
			// Get the field data
			CFieldInfo* pInfo = &pFX->m_prs->m_rgFieldInfos[nField - 1];

			// Restore the status
			pFX->m_prs->SetFieldStatus(nField - 1, pInfo->m_bStatus);

			// If not NULL, restore the value and length
			if (!pFX->m_prs->IsFieldStatusNull(nField - 1))
			{
				value = *static_cast<StringType *>(pInfo->m_pvDataCache);
				*plLength = value.GetLength() * sizeof(StringType::XCHAR);
			}
			else
				*plLength = SQL_NULL_DATA;

#ifdef _DEBUG
			// Buffer address must not change - ODBC's SQLBindCol depends upon this
			void* pvBind = value.GetBuffer(0);
			value.ReleaseBuffer();
			if (pvBind != pInfo->m_pvBindAddress)
			{
				TRACE(traceDatabase, 0, "Error: CString buffer (column %u) address has changed!\n",
					nField);
				ASSERT(FALSE);
			}
#endif // _DEBUG
		}
		return;

	case CFieldExchange::StoreField:
		AfxStoreField(*pFX->m_prs, nField, &value);
		return;

	case CFieldExchange::AllocCache:
		{
			CFieldInfo* pInfo = &pFX->m_prs->m_rgFieldInfos[nField - 1];
			pInfo->m_pvDataCache = new StringType;
			pInfo->m_nDataType = nFieldType == SQL_C_WCHAR ? AFX_RFX_WTEXT : AFX_RFX_ATEXT;
		}
		return;

#ifdef _DEBUG
	case CFieldExchange::DumpField:
		*pFX->m_pdcDump << "\n" << szName << " = " << value;
		return;
#endif // _DEBUG

	}
}
} // namespace

void AFXAPI RFX_Text(_In_ CFieldExchange* pFX, _In_z_ LPCTSTR szName,
	_Out_cap_(nMaxLength) _Pre_notnull_ _Post_z_ LPWSTR value, _In_ int nMaxLength, _In_ int nColumnType, _In_ short nScale)
{
	nsRFX_Text::RFX_Text(pFX, szName, value, nMaxLength, nColumnType, nScale, SQL_C_WCHAR, L' ');
}

void AFXAPI RFX_Text(_In_ CFieldExchange* pFX, _In_ LPCTSTR szName,
	_Out_cap_(nMaxLength) _Pre_notnull_ _Post_z_ LPSTR value, _In_ int nMaxLength, _In_ int nColumnType, _In_ short nScale)
{
	nsRFX_Text::RFX_Text(pFX, szName, value, nMaxLength, nColumnType, nScale, SQL_C_CHAR, ' ');
}

void AFXAPI RFX_Text(CFieldExchange* pFX, LPCTSTR szName,
	CStringW &value, int nMaxLength, int nColumnType, short nScale)
{
	nsRFX_Text::RFX_Text(pFX, szName, value, nMaxLength, nColumnType, nScale, SQL_C_WCHAR, L' ');
}

void AFXAPI RFX_Text(CFieldExchange* pFX, LPCTSTR szName,
	CStringA &value, int nMaxLength, int nColumnType, short nScale)
{
	nsRFX_Text::RFX_Text(pFX, szName, value, nMaxLength, nColumnType, nScale, SQL_C_CHAR, ' ');
}

void AFXAPI RFX_Int(CFieldExchange* pFX, LPCTSTR szName, int& value)
{
	ENSURE_ARG(AfxIsValidAddress(pFX, sizeof(CFieldExchange)));
	ENSURE_ARG(AfxIsValidString(szName));

	UINT nField;
	if (!pFX->IsFieldType(&nField))
		return;

	LONG_PTR* plLength = pFX->m_prs->GetFieldLengthBuffer(
		nField - 1, pFX->m_nFieldType);
	switch (pFX->m_nOperation)
	{
	case CFieldExchange::BindFieldToColumn:
		{
#ifdef _DEBUG
			// Assumes all bound fields BEFORE unbound fields
			CODBCFieldInfo* pODBCInfo =
				&pFX->m_prs->m_rgODBCFieldInfos[nField - 1];

			if (pODBCInfo->m_nSQLType != SQL_C_SHORT)
			{
				// Warn of possible field schema mismatch
				TRACE(traceDatabase, 1, "Warning: int converted from SQL type %ld.\n",
					pODBCInfo->m_nSQLType);
			}
#endif // _DEBUG
		}
		// fall through

	default:
LDefault:
		pFX->Default(szName, &value, plLength, SQL_C_LONG,
			sizeof(value), 5);
		return;

	case CFieldExchange::Fixup:
		if (*plLength == SQL_NULL_DATA)
		{
			if (pFX->m_bField)
			{
				pFX->m_prs->SetNullFieldStatus(nField - 1);
			}
			value = AFX_RFX_INT_PSEUDO_NULL;
		}
		return;

	case CFieldExchange::SetFieldNull:
		if ((pFX->m_pvField == NULL &&
			pFX->m_nFieldType == CFieldExchange::outputColumn) ||
			pFX->m_pvField == &value)
		{
			if (pFX->m_bField)
			{
				// Mark fields null
				pFX->m_prs->SetNullFieldStatus(nField - 1);
				value = AFX_RFX_INT_PSEUDO_NULL;
				*plLength = SQL_NULL_DATA;
			}
			else
			{
				pFX->m_prs->ClearNullFieldStatus(nField - 1);
				*plLength = sizeof(value);
			}
#ifdef _DEBUG
			pFX->m_nFieldFound = nField;
#endif
		}
		return;

	case CFieldExchange::MarkForAddNew:
		// can force writing of psuedo-null value (as a non-null) by setting field dirty
		if (value != AFX_RFX_INT_PSEUDO_NULL)
		{
			pFX->m_prs->SetDirtyFieldStatus(nField - 1);
			pFX->m_prs->ClearNullFieldStatus(nField - 1);
		}
		return;

	case CFieldExchange::MarkForUpdate:
		if (value != AFX_RFX_INT_PSEUDO_NULL)
			pFX->m_prs->ClearNullFieldStatus(nField - 1);
		goto LDefault;

	case CFieldExchange::AllocCache:
		{
			CFieldInfo* pInfo = &pFX->m_prs->m_rgFieldInfos[nField - 1];

			// Data cached by value, no allocation necessary
			pInfo->m_nDataType = AFX_RFX_INT;
		}
		return;

#ifdef _DEBUG
	case CFieldExchange::DumpField:
		*pFX->m_pdcDump << "\n" << szName << " = " << value;
		return;
#endif // _DEBUG

	}
}

void AFXAPI RFX_BigInt(CFieldExchange* pFX, LPCTSTR szName, LONGLONG& value)
{
	ENSURE_ARG(AfxIsValidAddress(pFX, sizeof(CFieldExchange)));
	ENSURE_ARG(AfxIsValidString(szName));

	UINT nField;
	if (!pFX->IsFieldType(&nField))
		return;

	LONG_PTR* plLength = pFX->m_prs->GetFieldLengthBuffer(
		nField - 1, pFX->m_nFieldType);
	switch (pFX->m_nOperation)
	{
	case CFieldExchange::BindFieldToColumn:
		{
#ifdef _DEBUG
			// Assumes all bound fields BEFORE unbound fields
			CODBCFieldInfo* pODBCInfo =
				&pFX->m_prs->m_rgODBCFieldInfos[nField - 1];

			if (pODBCInfo->m_nSQLType != SQL_C_SBIGINT)
			{
				// Warn of possible field schema mismatch
				TRACE(traceDatabase, 1, "Warning: long converted from SQL type %ld.\n",
					pODBCInfo->m_nSQLType);
			}
#endif // _DEBUG
		}
		// fall through

	default:
LDefault:
		pFX->Default(szName, &value, plLength, SQL_C_SBIGINT,
			sizeof(value), 19);
		return;

	case CFieldExchange::Fixup:
		if (*plLength == SQL_NULL_DATA)
		{
			if (pFX->m_bField)
			{
				pFX->m_prs->SetNullFieldStatus(nField - 1);
			}
			value = AFX_RFX_BIGINT_PSEUDO_NULL;
		}
		return;

	case CFieldExchange::SetFieldNull:
		if ((pFX->m_pvField == NULL &&
			pFX->m_nFieldType == CFieldExchange::outputColumn) ||
			pFX->m_pvField == &value)
		{
			if (pFX->m_bField)
			{
				// Mark fields null
				pFX->m_prs->SetNullFieldStatus(nField - 1);
				value = AFX_RFX_BIGINT_PSEUDO_NULL;
				*plLength = SQL_NULL_DATA;
			}
			else
			{
				pFX->m_prs->ClearNullFieldStatus(nField - 1);
				*plLength = sizeof(value);
			}
#ifdef _DEBUG
			pFX->m_nFieldFound = nField;
#endif
		}
		return;

	case CFieldExchange::MarkForAddNew:
		// can force writing of psuedo-null value (as a non-null) by setting field dirty
		if (value != AFX_RFX_BIGINT_PSEUDO_NULL)
		{
			pFX->m_prs->SetDirtyFieldStatus(nField - 1);
			pFX->m_prs->ClearNullFieldStatus(nField - 1);
		}
		return;

	case CFieldExchange::MarkForUpdate:
		if (value != AFX_RFX_LONG_PSEUDO_NULL)
			pFX->m_prs->ClearNullFieldStatus(nField - 1);
		goto LDefault;

	case CFieldExchange::AllocCache:
		{
			CFieldInfo* pInfo = &pFX->m_prs->m_rgFieldInfos[nField - 1];
			pInfo->m_pvDataCache = new LONGLONG;
			pInfo->m_nDataType = AFX_RFX_BIGINT;
		}
		return;

#ifdef _DEBUG
	case CFieldExchange::DumpField:
		*pFX->m_pdcDump << "\n" << szName << " = " << value;
		return;
#endif // _DEBUG

	}
}

void AFXAPI RFX_Long(CFieldExchange* pFX, LPCTSTR szName, long& value)
{
	ENSURE_ARG(AfxIsValidAddress(pFX, sizeof(CFieldExchange)));
	ENSURE_ARG(AfxIsValidString(szName));

	UINT nField;
	if (!pFX->IsFieldType(&nField))
		return;

	LONG_PTR* plLength = pFX->m_prs->GetFieldLengthBuffer(
		nField - 1, pFX->m_nFieldType);
	switch (pFX->m_nOperation)
	{
	case CFieldExchange::BindFieldToColumn:
		{
#ifdef _DEBUG
			// Assumes all bound fields BEFORE unbound fields
			CODBCFieldInfo* pODBCInfo =
				&pFX->m_prs->m_rgODBCFieldInfos[nField - 1];

			if (pODBCInfo->m_nSQLType != SQL_C_LONG)
			{
				// Warn of possible field schema mismatch
				TRACE(traceDatabase, 1, "Warning: long converted from SQL type %ld.\n",
					pODBCInfo->m_nSQLType);
			}
#endif // _DEBUG
		}
		// fall through

	default:
LDefault:
		pFX->Default(szName, &value, plLength, SQL_C_LONG,
			sizeof(value), 10);
		return;

	case CFieldExchange::Fixup:
		if (*plLength == SQL_NULL_DATA)
		{
			if (pFX->m_bField)
			{
				pFX->m_prs->SetNullFieldStatus(nField - 1);
			}
			value = AFX_RFX_LONG_PSEUDO_NULL;
		}
		return;

	case CFieldExchange::SetFieldNull:
		if ((pFX->m_pvField == NULL &&
			pFX->m_nFieldType == CFieldExchange::outputColumn) ||
			pFX->m_pvField == &value)
		{
			if (pFX->m_bField)
			{
				// Mark fields null
				pFX->m_prs->SetNullFieldStatus(nField - 1);
				value = AFX_RFX_LONG_PSEUDO_NULL;
				*plLength = SQL_NULL_DATA;
			}
			else
			{
				pFX->m_prs->ClearNullFieldStatus(nField - 1);
				*plLength = sizeof(value);
			}
#ifdef _DEBUG
			pFX->m_nFieldFound = nField;
#endif
		}
		return;

	case CFieldExchange::MarkForAddNew:
		// can force writing of psuedo-null value (as a non-null) by setting field dirty
		if (value != AFX_RFX_LONG_PSEUDO_NULL)
		{
			pFX->m_prs->SetDirtyFieldStatus(nField - 1);
			pFX->m_prs->ClearNullFieldStatus(nField - 1);
		}
		return;

	case CFieldExchange::MarkForUpdate:
		if (value != AFX_RFX_LONG_PSEUDO_NULL)
			pFX->m_prs->ClearNullFieldStatus(nField - 1);
		goto LDefault;

	case CFieldExchange::AllocCache:
		{
			CFieldInfo* pInfo = &pFX->m_prs->m_rgFieldInfos[nField - 1];

			// Data cached by value, no allocation necessary
			pInfo->m_nDataType = AFX_RFX_LONG;
		}
		return;

#ifdef _DEBUG
	case CFieldExchange::DumpField:
		*pFX->m_pdcDump << "\n" << szName << " = " << value;
		return;
#endif // _DEBUG

	}
}

void AFXAPI RFX_Byte(CFieldExchange* pFX, LPCTSTR szName, BYTE& value)
{
	ENSURE_ARG(AfxIsValidAddress(pFX, sizeof(CFieldExchange)));
	ENSURE_ARG(AfxIsValidString(szName));

	UINT nField;
	if (!pFX->IsFieldType(&nField))
		return;

	LONG_PTR* plLength = pFX->m_prs->GetFieldLengthBuffer(
		nField - 1, pFX->m_nFieldType);
	switch (pFX->m_nOperation)
	{
	case CFieldExchange::BindFieldToColumn:
		{
#ifdef _DEBUG
			// Assumes all bound fields BEFORE unbound fields
			CODBCFieldInfo* pODBCInfo =
				&pFX->m_prs->m_rgODBCFieldInfos[nField - 1];

			if (pODBCInfo->m_nSQLType != SQL_TINYINT)
			{
				// Warn of possible field schema mismatch
				TRACE(traceDatabase, 1, "Warning: BYTE converted from SQL type %ld.\n",
					pODBCInfo->m_nSQLType);
			}
#endif // _DEBUG
		}
		// fall through

	default:
LDefault:
		pFX->Default(szName, &value, plLength, SQL_TINYINT,
			sizeof(value), 3);
		break;

	case CFieldExchange::Fixup:
		if (*plLength == SQL_NULL_DATA)
		{
			if (pFX->m_bField)
			{
				pFX->m_prs->SetNullFieldStatus(nField - 1);
			}
			value = AFX_RFX_BYTE_PSEUDO_NULL;
		}
		return;

	case CFieldExchange::SetFieldNull:
		if ((pFX->m_pvField == NULL &&
			pFX->m_nFieldType == CFieldExchange::outputColumn) ||
			pFX->m_pvField == &value)
		{
			if (pFX->m_bField)
			{
				// Mark fields null
				pFX->m_prs->SetNullFieldStatus(nField - 1);
				value = AFX_RFX_BYTE_PSEUDO_NULL;
				*plLength = SQL_NULL_DATA;
			}
			else
			{
				pFX->m_prs->ClearNullFieldStatus(nField - 1);
				*plLength = sizeof(value);
			}
#ifdef _DEBUG
			pFX->m_nFieldFound = nField;
#endif
		}
		return;

	case CFieldExchange::MarkForAddNew:
		// can force writing of psuedo-null value (as a non-null) by setting field dirty
		if (value != AFX_RFX_BYTE_PSEUDO_NULL)
		{
			pFX->m_prs->SetDirtyFieldStatus(nField - 1);
			pFX->m_prs->ClearNullFieldStatus(nField - 1);
		}
		return;

	case CFieldExchange::MarkForUpdate:
		if (value != AFX_RFX_BYTE_PSEUDO_NULL)
			pFX->m_prs->ClearNullFieldStatus(nField - 1);
		goto LDefault;

	case CFieldExchange::AllocCache:
		{
			CFieldInfo* pInfo = &pFX->m_prs->m_rgFieldInfos[nField - 1];

			// Data cached by value, no allocation necessary
			pInfo->m_nDataType = AFX_RFX_BYTE;
		}
		return;

#ifdef _DEBUG
	case CFieldExchange::DumpField:
		*pFX->m_pdcDump << "\n" << szName << " = " << value;
		return;
#endif // _DEBUG

	}
}

void AFXAPI RFX_Bool(CFieldExchange* pFX, LPCTSTR szName, BOOL& value)
{
	ENSURE_ARG(AfxIsValidAddress(pFX, sizeof(CFieldExchange)));
	ENSURE_ARG(AfxIsValidString(szName));

	UINT nField;
	if (!pFX->IsFieldType(&nField))
		return;

	LONG_PTR* plLength = pFX->m_prs->GetFieldLengthBuffer(
		nField - 1, pFX->m_nFieldType);
	switch (pFX->m_nOperation)
	{
	case CFieldExchange::BindFieldToColumn:
		{
#ifdef _DEBUG
			// Assumes all bound fields BEFORE unbound fields
			CODBCFieldInfo* pODBCInfo =
				&pFX->m_prs->m_rgODBCFieldInfos[nField - 1];

			if (pODBCInfo->m_nSQLType != SQL_BIT)
			{
				// Warn of possible field schema mismatch
				TRACE(traceDatabase, 1, "Warning: BOOL converted from SQL type %ld.\n",
					pODBCInfo->m_nSQLType);
			}
#endif // _DEBUG
		}
		// Fall through

	default:
LDefault:
		pFX->Default(szName, &value, plLength, SQL_BIT,
			sizeof(value), 1);
		return;

	case CFieldExchange::Fixup:
		if (*plLength == SQL_NULL_DATA)
		{
			if (pFX->m_bField)
			{
				pFX->m_prs->SetNullFieldStatus(nField - 1);
			}
			value = AFX_RFX_BOOL_PSEUDO_NULL;
		}
		else
			// Cast BYTE into BOOL (int)
			value = *(BYTE *)&value;
		return;

	case CFieldExchange::SetFieldNull:
		if ((pFX->m_pvField == NULL &&
			pFX->m_nFieldType == CFieldExchange::outputColumn) ||
			pFX->m_pvField == &value)
		{
			if (pFX->m_bField)
			{
				// Mark fields null
				pFX->m_prs->SetNullFieldStatus(nField - 1);
				value = AFX_RFX_BOOL_PSEUDO_NULL;
				*plLength = SQL_NULL_DATA;
			}
			else
			{
				pFX->m_prs->ClearNullFieldStatus(nField - 1);
				*plLength = sizeof(value);
			}
#ifdef _DEBUG
			pFX->m_nFieldFound = nField;
#endif
		}
		return;

	case CFieldExchange::MarkForAddNew:
		// can force writing of psuedo-null value (as a non-null) by setting field dirty
		if (value != AFX_RFX_BOOL_PSEUDO_NULL)
		{
			pFX->m_prs->SetDirtyFieldStatus(nField - 1);
			pFX->m_prs->ClearNullFieldStatus(nField - 1);
		}
		return;

	case CFieldExchange::MarkForUpdate:
		if (value != AFX_RFX_BOOL_PSEUDO_NULL)
			pFX->m_prs->ClearNullFieldStatus(nField - 1);
		goto LDefault;

	case CFieldExchange::AllocCache:
		{
			CFieldInfo* pInfo = &pFX->m_prs->m_rgFieldInfos[nField - 1];

			// Data cached by value, no allocation necessary
			pInfo->m_nDataType = AFX_RFX_BOOL;
		}
		return;

#ifdef _DEBUG
	case CFieldExchange::DumpField:
		*pFX->m_pdcDump << "\n" << szName << " = " << value;
		return;
#endif // _DEBUG

	}
}

// Note: CByteArray.m_pData must not be changed.  This address is registered
// with ODBC and must remain valid until the recordset is released.
void AFXAPI RFX_Binary(CFieldExchange* pFX, LPCTSTR szName,
	CByteArray& value, INT_PTR nMaxLength)
{
	ENSURE_ARG(AfxIsValidAddress(pFX, sizeof(CFieldExchange)));
	ENSURE_ARG(AfxIsValidString(szName));

	RETCODE nRetCode;
	UINT nField;
	if (!pFX->IsFieldType(&nField))
		return;

	LONG_PTR* plLength = pFX->m_prs->GetFieldLengthBuffer(
		nField - 1, pFX->m_nFieldType);

	BOOL bByRef = FALSE;
	switch (pFX->m_nOperation)
	{
	default:
LDefault:
		{
			void* pvData = NULL;
			if (value.GetSize() > 0)
			{
				if (bByRef)
					pvData = &value;
				else
					pvData = &value[0];
			}

			pFX->Default(szName, pvData, plLength, SQL_C_BINARY,
				(int)value.GetSize(), (UINT)value.GetSize());
		}
		return;

	case CFieldExchange::BindFieldToColumn:
		{
			// Assumes all bound fields BEFORE unbound fields
			CODBCFieldInfo* pODBCInfo =
				&pFX->m_prs->m_rgODBCFieldInfos[nField - 1];
			ULONG_PTR cbColumn = pODBCInfo->m_nPrecision;

#ifdef _DEBUG
			if (pODBCInfo->m_nSQLType != SQL_BINARY &&
				pODBCInfo->m_nSQLType != SQL_VARBINARY &&
				pODBCInfo->m_nSQLType != SQL_LONGVARBINARY)
			{
				// Warn of possible field schema mismatch
				TRACE(traceDatabase, 1, "Warning: CByteArray converted from SQL type %ld.\n",
					pODBCInfo->m_nSQLType);
			}
#endif // _DEBUG

			// Constrain to user specified max length
			if (cbColumn > (UINT_PTR)nMaxLength)
				cbColumn = nMaxLength;
			value.SetSize(cbColumn);
			AFX_SQL_SYNC(::SQLBindCol(pFX->m_prs->m_hstmt, (UWORD)nField,
				SQL_C_BINARY, &value[0], (LONG)cbColumn, plLength));
			if (!pFX->m_prs->Check(nRetCode))
				pFX->m_prs->ThrowDBException(nRetCode);

			// Add the member address to the field map
			pFX->m_prs->m_mapFieldIndex.SetAt(&value, (void*)(UINT_PTR)nField);
		}
		return;

	case CFieldExchange::Fixup:
		if (*plLength == SQL_NULL_DATA)
		{
			if (pFX->m_bField)
			{
				pFX->m_prs->SetNullFieldStatus(nField - 1);
			}
			value.SetSize(1);
			value[0] = AFX_RFX_BYTE_PSEUDO_NULL;
		}
		else
		{
			ASSERT(*plLength <= (LONG)nMaxLength);
			((CDBByteArray&)value).SetLength((UINT)*plLength);
		}
		return;

	case CFieldExchange::SetFieldNull:
		if ((pFX->m_pvField == NULL &&
			pFX->m_nFieldType == CFieldExchange::outputColumn) ||
			pFX->m_pvField == &value)
		{
			if (pFX->m_bField)
			{
				// Mark fields null
				pFX->m_prs->SetNullFieldStatus(nField - 1);
				value.SetSize(1);
				value[0] = AFX_RFX_BYTE_PSEUDO_NULL;
				*plLength = SQL_NULL_DATA;
			}
			else
			{
				pFX->m_prs->ClearNullFieldStatus(nField - 1);
				*plLength = value.GetSize();
			}
#ifdef _DEBUG
			pFX->m_nFieldFound = nField;
#endif
		}
		return;

	case CFieldExchange::MarkForAddNew:
		// can force writing of psuedo-null value (as a non-null) by setting field dirty
		if (value.GetSize() != 1 || value[0] != AFX_RFX_BYTE_PSEUDO_NULL)
		{
			pFX->m_prs->SetDirtyFieldStatus(nField - 1);
			pFX->m_prs->ClearNullFieldStatus(nField - 1);
		}
		return;

	case CFieldExchange::MarkForUpdate:
		if (value.GetSize() != 1 || value[0] != AFX_RFX_BYTE_PSEUDO_NULL)
			pFX->m_prs->ClearNullFieldStatus(nField - 1);
		bByRef = TRUE;
		goto LDefault;

	case CFieldExchange::StoreField:
		AfxStoreField(*pFX->m_prs, nField, &value);
		return;

	case CFieldExchange::LoadField:
		AfxLoadField(*pFX->m_prs, nField, &value, plLength);
		return;

	case CFieldExchange::AllocCache:
		{
			CFieldInfo* pInfo = &pFX->m_prs->m_rgFieldInfos[nField - 1];
			pInfo->m_pvDataCache = new CByteArray;
			pInfo->m_nDataType = AFX_RFX_BINARY;
		}
		return;

#ifdef _DEBUG
	case CFieldExchange::DumpField:
		*pFX->m_pdcDump << "\n" << szName << ":";
		value.Dump(*pFX->m_pdcDump);
		return;
#endif // _DEBUG

	}
}

void AFXAPI RFX_Date(CFieldExchange* pFX, LPCTSTR szName, CTime& value)
{
	ENSURE_ARG(AfxIsValidAddress(pFX, sizeof(CFieldExchange)));
	ENSURE_ARG(AfxIsValidString(szName));

	RETCODE nRetCode=0;
	UINT nField=0;
	if (!pFX->IsFieldType(&nField))
		return;

	ENSURE(pFX->m_prs);
	LONG_PTR* plLength = pFX->m_prs->GetFieldLengthBuffer(
		nField - 1, pFX->m_nFieldType);
	ENSURE(plLength);

	switch (pFX->m_nOperation)
	{
	default:
LDefault:
		pFX->Default(szName, &value, plLength, SQL_C_TIMESTAMP,
			sizeof(value), TIMESTAMP_PRECISION);
		return;

	case CFieldExchange::BindParam:
		{
			TIMESTAMP_STRUCT* pts=NULL;
			pFX->m_prs->m_bRebindParams = TRUE;

			// Allocate proxy array if necessary
			if (pFX->m_prs->m_pvParamProxy == NULL)
			{
				pFX->m_prs->m_pvParamProxy = new void*[pFX->m_prs->m_nParams];
				memset(pFX->m_prs->m_pvParamProxy, 0,
					pFX->m_prs->m_nParams*sizeof(void*));
				pFX->m_prs->m_nProxyParams = pFX->m_prs->m_nParams;
			}

			// Allocate TIMESTAMP_STRUCT if necessary for SQLBindParameter
			if (pFX->m_prs->m_pvParamProxy[nField-1] == NULL)
				pFX->m_prs->m_pvParamProxy[nField-1] = new TIMESTAMP_STRUCT;

			pts = (TIMESTAMP_STRUCT *)pFX->m_prs->m_pvParamProxy[nField-1];

			if (pFX->m_prs->IsParamStatusNull(nField - 1))
				*plLength = SQL_NULL_DATA;
			else
			{
				pts->year = (SWORD)value.GetYear();
				pts->month = (UWORD)value.GetMonth();
				pts->day = (UWORD)value.GetDay();
				pts->hour = (UWORD)value.GetHour();
				pts->minute = (UWORD)value.GetMinute();
				pts->second = (UWORD)value.GetSecond();
				pts->fraction = 0;
				*plLength = sizeof(TIMESTAMP_STRUCT);
			}

			AFX_SQL_SYNC(::SQLBindParameter(pFX->m_hstmt, (UWORD)nField,
				(SWORD)pFX->m_nFieldType, SQL_C_TIMESTAMP, SQL_C_TIMESTAMP,
				TIMESTAMP_PRECISION, 0, pts, 0, plLength));
			if (nRetCode != SQL_SUCCESS)
				pFX->m_prs->ThrowDBException(nRetCode, pFX->m_hstmt);

			// Add the member address to the param map
			pFX->m_prs->m_mapParamIndex.SetAt(&value, (void*)(UINT_PTR)nField);
		}
		return;

	case CFieldExchange::RebindParam:
		{
			if(pFX->m_prs->IsParamStatusNull(nField - 1))
				*plLength =  SQL_NULL_DATA;
			else
			{
				ASSERT(pFX->m_prs->m_nProxyParams != 0);
				// Fill buffer (expected by SQLBindParameter) with new param data
				TIMESTAMP_STRUCT* pts = (TIMESTAMP_STRUCT *)pFX->m_prs->m_pvParamProxy[nField-1];
				pts->year = (SWORD)value.GetYear();
				pts->month = (UWORD)value.GetMonth();
				pts->day = (UWORD)value.GetDay();
				pts->hour = (UWORD)value.GetHour();
				pts->minute = (UWORD)value.GetMinute();
				pts->second = (UWORD)value.GetSecond();
				pts->fraction = 0;
				*plLength = sizeof(TIMESTAMP_STRUCT);
			}
		}
		return;

	case CFieldExchange::BindFieldToColumn:
		{
#ifdef _DEBUG
			// Assumes all bound fields BEFORE unbound fields
			CODBCFieldInfo* pODBCInfo =
				&pFX->m_prs->m_rgODBCFieldInfos[nField - 1];

			if (pODBCInfo->m_nSQLType != SQL_DATE &&
				pODBCInfo->m_nSQLType != SQL_TIME &&
				pODBCInfo->m_nSQLType != SQL_TIMESTAMP)
			{
				// Warn of possible field schema mismatch
				TRACE(traceDatabase, 1, "Warning: CTime converted from SQL type %ld.\n",
					pODBCInfo->m_nSQLType);
			}
#endif // _DEBUG

			// Allocate proxy array if necessary
			if (pFX->m_prs->m_pvFieldProxy == NULL)
			{
				pFX->m_prs->m_pvFieldProxy = new void*[pFX->m_prs->m_nFields];
				memset(pFX->m_prs->m_pvFieldProxy, 0,
					pFX->m_prs->m_nFields*sizeof(void*));
				pFX->m_prs->m_nProxyFields = pFX->m_prs->m_nFields;
			}

			// Allocate TIMESTAMP_STRUCT for SQLBindCol (not necessary on Requery)
			if (pFX->m_prs->m_pvFieldProxy[nField-1] == NULL)
				pFX->m_prs->m_pvFieldProxy[nField-1] = new TIMESTAMP_STRUCT;

			AFX_SQL_SYNC(::SQLBindCol(pFX->m_prs->m_hstmt, (UWORD)nField,
				SQL_C_TIMESTAMP, pFX->m_prs->m_pvFieldProxy[nField-1],
				sizeof(TIMESTAMP_STRUCT), plLength));
			if (!pFX->m_prs->Check(nRetCode))
				pFX->m_prs->ThrowDBException(nRetCode);

			// Add the member address to the field map
			pFX->m_prs->m_mapFieldIndex.SetAt(&value, (void*)(UINT_PTR)nField);
		}
		return;

	case CFieldExchange::BindFieldForUpdate:
		if (pFX->m_prs->m_nProxyFields != 0)
		{
			// Fill buffer (expected by SQLSetPos) with new field data
			TIMESTAMP_STRUCT* pts=NULL;
			pts = (TIMESTAMP_STRUCT *)pFX->m_prs->m_pvFieldProxy[nField-1];
			pts->year = (SWORD)value.GetYear();
			pts->month = (UWORD)value.GetMonth();
			pts->day = (UWORD)value.GetDay();
			pts->hour = (UWORD)value.GetHour();
			pts->minute = (UWORD)value.GetMinute();
			pts->second = (UWORD)value.GetSecond();
			pts->fraction = 0;

			pFX->Default(szName, (void *)pts, plLength, SQL_C_TIMESTAMP,
				sizeof(TIMESTAMP_STRUCT), TIMESTAMP_PRECISION);
		}
		return;

	case CFieldExchange::Fixup:
		if (*plLength == SQL_NULL_DATA)
		{
			if (pFX->m_bField)
			{
				pFX->m_prs->SetNullFieldStatus(nField - 1);
			}
			value = AFX_RFX_DATE_PSEUDO_NULL;
		}
		else
		{
			TIMESTAMP_STRUCT* pts =
				(TIMESTAMP_STRUCT*)pFX->m_prs->m_pvFieldProxy[nField-1];
 
		 
#ifdef _DEBUG
				if (pts->fraction != 0)
					TRACE(traceDatabase, 1, "Warning: ignoring milliseconds.\n");
#endif
				
				_ATLTRY{
				    
					value = CTime(pts->year, pts->month, pts->day,
					pts->hour, pts->minute, pts->second);
				
				}_ATLCATCHALL(){ 
				    //time is invalid 
					 pFX->m_prs->SetNullFieldStatus(nField - 1);
     				 value = AFX_RFX_DATE_PSEUDO_NULL;
	
				}
			 
		}
		return;

	case CFieldExchange::NameValue:
		if (pFX->m_prs->IsFieldStatusDirty(nField - 1))
		{
			*pFX->m_pstr += szName;
			*pFX->m_pstr += '=';
		}
		// Fall through

	case CFieldExchange::Value:
		if (pFX->m_prs->IsFieldStatusDirty(nField - 1))
		{
			TIMESTAMP_STRUCT* pts =
				(TIMESTAMP_STRUCT*)pFX->m_prs->m_pvFieldProxy[nField-1];
			if (pFX->m_prs->IsFieldStatusNull(nField - 1))
			{
				*plLength = SQL_NULL_DATA;
			}
			else
			{
				pts->year = (SWORD)value.GetYear();
				pts->month = (UWORD)value.GetMonth();
				pts->day = (UWORD)value.GetDay();
				pts->hour = (UWORD)value.GetHour();
				pts->minute = (UWORD)value.GetMinute();
				pts->second = (UWORD)value.GetSecond();
				pts->fraction = 0;
				*plLength = sizeof(TIMESTAMP_STRUCT);
			}

			// If optimizing for bulk add, only need lengths & proxy set correctly
			if(!(pFX->m_prs->m_dwOptions & CRecordset::optimizeBulkAdd))
			{
				*pFX->m_pstr += '?';
				*pFX->m_pstr += pFX->m_lpszSeparator;
				pFX->m_nParamFields++;

				// Assumes all bound fields BEFORE unbound fields
				CODBCFieldInfo* pODBCInfo =
					&pFX->m_prs->m_rgODBCFieldInfos[nField - 1];

				AFX_SQL_SYNC(::SQLBindParameter(pFX->m_hstmt,
					(UWORD)pFX->m_nParamFields, SQL_PARAM_INPUT,
					SQL_C_TIMESTAMP, pODBCInfo->m_nSQLType,
					TIMESTAMP_PRECISION, 0, pts, 0, plLength));
			}
		}
		return;

	case CFieldExchange::SetFieldNull:
		if ((pFX->m_pvField == NULL &&
			pFX->m_nFieldType == CFieldExchange::outputColumn) ||
			pFX->m_pvField == &value)
		{
			if (pFX->m_bField)
			{
				// Mark fields null
				pFX->m_prs->SetNullFieldStatus(nField - 1);
				value = AFX_RFX_DATE_PSEUDO_NULL;
				*plLength = SQL_NULL_DATA;
			}
			else
			{
				pFX->m_prs->ClearNullFieldStatus(nField - 1);
				*plLength = sizeof(TIMESTAMP_STRUCT);
			}
#ifdef _DEBUG
			pFX->m_nFieldFound = nField;
#endif
		}
		return;

	case CFieldExchange::MarkForAddNew:
		{
			// can force writing of psuedo-null value (as a non-null) by setting field dirty
			CTime timeNull = AFX_RFX_DATE_PSEUDO_NULL;
			if (value != timeNull)
			{
				pFX->m_prs->SetDirtyFieldStatus(nField - 1);
				pFX->m_prs->ClearNullFieldStatus(nField - 1);
			}
		}
		return;

	case CFieldExchange::MarkForUpdate:
		{
			CTime timeNull = AFX_RFX_DATE_PSEUDO_NULL;
			if (value != timeNull)
				pFX->m_prs->ClearNullFieldStatus(nField - 1);
		}
		goto LDefault;

	case CFieldExchange::LoadField:
		{
			// Get the field data
			CFieldInfo* pInfo = &pFX->m_prs->m_rgFieldInfos[nField - 1];

			// Restore the status
			pFX->m_prs->SetFieldStatus(nField - 1, pInfo->m_bStatus);

			// If not NULL, restore the value, length and proxy
			if (!pFX->m_prs->IsFieldStatusNull(nField - 1))
			{
				AfxCopyValueByRef(pInfo->m_pvDataCache, &value,
					plLength, pInfo->m_nDataType);

				// Restore proxy for correct WHERE CURRENT OF operations
				TIMESTAMP_STRUCT* pts =
					(TIMESTAMP_STRUCT*)pFX->m_prs->m_pvFieldProxy[nField-1];

				pts->year = (SWORD)value.GetYear();
				pts->month = (UWORD)value.GetMonth();
				pts->day = (UWORD)value.GetDay();
				pts->hour = (UWORD)value.GetHour();
				pts->minute = (UWORD)value.GetMinute();
				pts->second = (UWORD)value.GetSecond();
				pts->fraction = 0;
			}
			else
				*plLength = SQL_NULL_DATA;

#ifdef _DEBUG
			// Buffer address must not change - ODBC's SQLBindCol depends upon this
			if (pInfo->m_pvBindAddress != pFX->m_prs->m_pvFieldProxy[nField-1])
			{
				TRACE(traceDatabase, 0, "Error: CString buffer (column %u) address has changed!\n",
					nField);
				ASSERT(FALSE);
			}
#endif // _DEBUG
		}
		return;

	case CFieldExchange::AllocCache:
		{
			CFieldInfo* pInfo = &pFX->m_prs->m_rgFieldInfos[nField - 1];
			pInfo->m_pvDataCache = new CTime;
			pInfo->m_nDataType = AFX_RFX_DATE;
		}
		return;

#ifdef _DEBUG
	case CFieldExchange::DumpField:
		*pFX->m_pdcDump << "\n" << szName << " = " << value;
		return;
#endif // _DEBUG

	}
}

void AFXAPI RFX_Date(CFieldExchange* pFX, LPCTSTR szName,
	TIMESTAMP_STRUCT& value)
{
	ENSURE_ARG(AfxIsValidAddress(pFX, sizeof(CFieldExchange)));
	ENSURE_ARG(AfxIsValidString(szName));

	UINT nField=0;
	if (!pFX->IsFieldType(&nField))
		return;

	ENSURE(pFX->m_prs);
	LONG_PTR* plLength = pFX->m_prs->GetFieldLengthBuffer(
		nField - 1, pFX->m_nFieldType);
	ENSURE(plLength);

	switch (pFX->m_nOperation)
	{
	case CFieldExchange::BindFieldToColumn:
		{
#ifdef _DEBUG
			// Assumes all bound fields BEFORE unbound fields
			CODBCFieldInfo* pODBCInfo =
				&pFX->m_prs->m_rgODBCFieldInfos[nField - 1];

			ENSURE(pODBCInfo);

			if (pODBCInfo->m_nSQLType != SQL_DATE &&
				pODBCInfo->m_nSQLType != SQL_TIME &&
				pODBCInfo->m_nSQLType != SQL_TIMESTAMP)
			{
				// Warn of possible field schema mismatch
				TRACE(traceDatabase, 1, "Warning: TIMESTAMP_STRUCT converted from SQL type %ld.\n",
					pODBCInfo->m_nSQLType);
			}
#endif // _DEBUG
			// fall through
		}

	default:
LDefault:
		pFX->Default(szName, &value, plLength, SQL_C_TIMESTAMP,
			sizeof(value), TIMESTAMP_PRECISION);
		return;

	case CFieldExchange::Fixup:
		if (*plLength == SQL_NULL_DATA)
		{
			if (pFX->m_bField)
			{
				pFX->m_prs->SetNullFieldStatus(nField - 1);
			}
			value.year = AFX_RFX_TIMESTAMP_PSEUDO_NULL;
			value.month = AFX_RFX_TIMESTAMP_PSEUDO_NULL;
			value.day = AFX_RFX_TIMESTAMP_PSEUDO_NULL;
			value.hour = AFX_RFX_TIMESTAMP_PSEUDO_NULL;
			value.minute = AFX_RFX_TIMESTAMP_PSEUDO_NULL;
			value.second = AFX_RFX_TIMESTAMP_PSEUDO_NULL;
			value.fraction = AFX_RFX_TIMESTAMP_PSEUDO_NULL;
		}
		return;

	case CFieldExchange::SetFieldNull:
		if ((pFX->m_pvField == NULL &&
			pFX->m_nFieldType == CFieldExchange::outputColumn) ||
			pFX->m_pvField == &value)
		{
			if (pFX->m_bField)
			{
				// Mark fields null
				pFX->m_prs->SetNullFieldStatus(nField - 1);
				value.year = AFX_RFX_TIMESTAMP_PSEUDO_NULL;
				value.month = AFX_RFX_TIMESTAMP_PSEUDO_NULL;
				value.day = AFX_RFX_TIMESTAMP_PSEUDO_NULL;
				value.hour = AFX_RFX_TIMESTAMP_PSEUDO_NULL;
				value.minute = AFX_RFX_TIMESTAMP_PSEUDO_NULL;
				value.second = AFX_RFX_TIMESTAMP_PSEUDO_NULL;
				value.fraction = AFX_RFX_TIMESTAMP_PSEUDO_NULL;
				*plLength = SQL_NULL_DATA;
			}
			else
			{
				pFX->m_prs->ClearNullFieldStatus(nField - 1);
				*plLength = sizeof(TIMESTAMP_STRUCT);
			}
#ifdef _DEBUG
			pFX->m_nFieldFound = nField;
#endif
		}
		return;

	case CFieldExchange::MarkForAddNew:
		// can force writing of psuedo-null value (as a non-null) by setting field dirty
		if (!(value.year == AFX_RFX_TIMESTAMP_PSEUDO_NULL &&
			value.month == AFX_RFX_TIMESTAMP_PSEUDO_NULL &&
			value.day == AFX_RFX_TIMESTAMP_PSEUDO_NULL &&
			value.hour == AFX_RFX_TIMESTAMP_PSEUDO_NULL &&
			value.minute == AFX_RFX_TIMESTAMP_PSEUDO_NULL &&
			value.second == AFX_RFX_TIMESTAMP_PSEUDO_NULL &&
			value.fraction == AFX_RFX_TIMESTAMP_PSEUDO_NULL ))
		{
			pFX->m_prs->SetDirtyFieldStatus(nField - 1);
			pFX->m_prs->ClearNullFieldStatus(nField - 1);
		}
		return;

	case CFieldExchange::MarkForUpdate:
		if (!(value.year == AFX_RFX_TIMESTAMP_PSEUDO_NULL &&
			value.month == AFX_RFX_TIMESTAMP_PSEUDO_NULL &&
			value.day == AFX_RFX_TIMESTAMP_PSEUDO_NULL &&
			value.hour == AFX_RFX_TIMESTAMP_PSEUDO_NULL &&
			value.minute == AFX_RFX_TIMESTAMP_PSEUDO_NULL &&
			value.second == AFX_RFX_TIMESTAMP_PSEUDO_NULL &&
			value.fraction == AFX_RFX_TIMESTAMP_PSEUDO_NULL ))
		{
			pFX->m_prs->ClearNullFieldStatus(nField - 1);
		}
		goto LDefault;

	case CFieldExchange::AllocCache:
		{
			CFieldInfo* pInfo = &pFX->m_prs->m_rgFieldInfos[nField - 1];
			pInfo->m_pvDataCache = new TIMESTAMP_STRUCT;
			pInfo->m_nDataType = AFX_RFX_TIMESTAMP;
		}
		return;

#ifdef _DEBUG
	case CFieldExchange::DumpField:
		*pFX->m_pdcDump << "\n" << szName << ".year = " << (int)value.year;
		*pFX->m_pdcDump << "\n" << szName << ".month = " << value.month;
		*pFX->m_pdcDump << "\n" << szName << ".day = " << value.day;
		*pFX->m_pdcDump << "\n" << szName << ".hour = " << value.hour;
		*pFX->m_pdcDump << "\n" << szName << ".minute = " << value.minute;
		*pFX->m_pdcDump << "\n" << szName << ".second = " << value.second;
		*pFX->m_pdcDump << "\n" << szName << ".fraction = " << value.fraction;
		return;
#endif // _DEBUG

	}
}

void AFXAPI RFX_Date(CFieldExchange* pFX, LPCTSTR szName,
	COleDateTime& value)
{
	ENSURE_ARG(AfxIsValidAddress(pFX, sizeof(CFieldExchange)));
	ENSURE_ARG(AfxIsValidString(szName));

	UINT nField=0;
	if (!pFX->IsFieldType(&nField))
		return;

	RETCODE nRetCode=0;
	ENSURE(pFX->m_prs);
	LONG_PTR* plLength = pFX->m_prs->GetFieldLengthBuffer(
		nField - 1, pFX->m_nFieldType);
	ENSURE(plLength);
	switch (pFX->m_nOperation)
	{
	case CFieldExchange::BindParam:
		{
			TIMESTAMP_STRUCT* pts=NULL;
			pFX->m_prs->m_bRebindParams = TRUE;

			if (pFX->m_prs->IsParamStatusNull(nField - 1))
			{
				pts = NULL;
				*plLength = SQL_NULL_DATA;
			}
			else
			{
				// Allocate proxy array if necessary
				if (pFX->m_prs->m_pvParamProxy == NULL)
				{
					pFX->m_prs->m_pvParamProxy = new void*[pFX->m_prs->m_nParams];
					memset(pFX->m_prs->m_pvParamProxy, 0,
						pFX->m_prs->m_nParams*sizeof(void*));
					pFX->m_prs->m_nProxyParams = pFX->m_prs->m_nParams;
				}

				// Allocate TIMESTAMP_STRUCT if necessary for SQLBindParameter
				if (pFX->m_prs->m_pvParamProxy[nField-1] == NULL)
				{
					pts = new TIMESTAMP_STRUCT;
					pFX->m_prs->m_pvParamProxy[nField-1] = pts;
				}
				else
					pts = (TIMESTAMP_STRUCT *)pFX->m_prs->m_pvParamProxy[nField-1];

				pts->year = (SWORD)value.GetYear();
				pts->month = (UWORD)value.GetMonth();
				pts->day = (UWORD)value.GetDay();
				pts->hour = (UWORD)value.GetHour();
				pts->minute = (UWORD)value.GetMinute();
				pts->second = (UWORD)value.GetSecond();
				pts->fraction = 0;
				*plLength = sizeof(TIMESTAMP_STRUCT);
			}

			AFX_SQL_SYNC(::SQLBindParameter(pFX->m_hstmt, (UWORD)nField,
				(SWORD)pFX->m_nFieldType, SQL_C_TIMESTAMP, SQL_C_TIMESTAMP,
				TIMESTAMP_PRECISION, 0, pts, 0, plLength));
			if (nRetCode != SQL_SUCCESS)
				pFX->m_prs->ThrowDBException(nRetCode, pFX->m_hstmt);

			// Add the member address to the param map
			pFX->m_prs->m_mapParamIndex.SetAt(&value, (void*)(UINT_PTR)nField);
		}
		return;

	case CFieldExchange::NameValue:
		if (pFX->m_prs->IsFieldStatusDirty(nField - 1))
		{
			*pFX->m_pstr += szName;
			*pFX->m_pstr += '=';
		}
		// Fall through

	case CFieldExchange::Value:
		if (pFX->m_prs->IsFieldStatusDirty(nField - 1))
		{
			TIMESTAMP_STRUCT* pts =
				(TIMESTAMP_STRUCT*)pFX->m_prs->m_pvFieldProxy[nField-1];
			if (pFX->m_prs->IsFieldStatusNull(nField - 1))
			{
				*plLength = SQL_NULL_DATA;
			}
			else
			{
				pts->year = (SWORD)value.GetYear();
				pts->month = (UWORD)value.GetMonth();
				pts->day = (UWORD)value.GetDay();
				pts->hour = (UWORD)value.GetHour();
				pts->minute = (UWORD)value.GetMinute();
				pts->second = (UWORD)value.GetSecond();
				pts->fraction = 0;
				*plLength = sizeof(TIMESTAMP_STRUCT);
			}

			// If optimizing for bulk add, only need lengths & proxy set correctly
			if(!(pFX->m_prs->m_dwOptions & CRecordset::optimizeBulkAdd))
			{
				*pFX->m_pstr += '?';
				*pFX->m_pstr += pFX->m_lpszSeparator;
				pFX->m_nParamFields++;

				// Assumes all bound fields BEFORE unbound fields
				CODBCFieldInfo* pODBCInfo =
					&pFX->m_prs->m_rgODBCFieldInfos[nField - 1];

				AFX_SQL_SYNC(::SQLBindParameter(pFX->m_hstmt,
					(UWORD)pFX->m_nParamFields, SQL_PARAM_INPUT,
					SQL_C_TIMESTAMP, pODBCInfo->m_nSQLType,
					TIMESTAMP_PRECISION, 0, pts, 0, plLength));
			}
		}
		return;

	case CFieldExchange::RebindParam:
		{
			*plLength = pFX->m_prs->IsParamStatusNull(nField - 1) ?
				SQL_NULL_DATA : sizeof(TIMESTAMP_STRUCT);
			if (pFX->m_prs->m_nProxyParams != 0)
			{
				// Fill buffer (expected by SQLBindParameter) with new param data
				TIMESTAMP_STRUCT* pts;
				pts = (TIMESTAMP_STRUCT *)pFX->m_prs->m_pvParamProxy[nField-1];
				pts->year = (SWORD)value.GetYear();
				pts->month = (UWORD)value.GetMonth();
				pts->day = (UWORD)value.GetDay();
				pts->hour = (UWORD)value.GetHour();
				pts->minute = (UWORD)value.GetMinute();
				pts->second = (UWORD)value.GetSecond();
				pts->fraction = 0;
			}
		}
		return;

	case CFieldExchange::BindFieldForUpdate:
		if (pFX->m_prs->m_nProxyFields != 0)
		{
			// Fill buffer (expected by SQLSetPos) with new field data
			TIMESTAMP_STRUCT* pts=NULL;
			pts = (TIMESTAMP_STRUCT *)pFX->m_prs->m_pvFieldProxy[nField-1];
			pts->year = (SWORD)value.GetYear();
			pts->month = (UWORD)value.GetMonth();
			pts->day = (UWORD)value.GetDay();
			pts->hour = (UWORD)value.GetHour();
			pts->minute = (UWORD)value.GetMinute();
			pts->second = (UWORD)value.GetSecond();
			pts->fraction = 0;

			pFX->Default(szName, (void *)pts, plLength, SQL_C_TIMESTAMP,
				sizeof(TIMESTAMP_STRUCT), TIMESTAMP_PRECISION);
		}
		return;

	case CFieldExchange::LoadField:
		{
			// Get the field data
			CFieldInfo* pInfo = &pFX->m_prs->m_rgFieldInfos[nField - 1];

			// Restore the status
			pFX->m_prs->SetFieldStatus(nField - 1, pInfo->m_bStatus);

			// If not NULL, restore the value, length and proxy
			if (!pFX->m_prs->IsFieldStatusNull(nField - 1))
			{
				AfxCopyValueByRef(pInfo->m_pvDataCache, &value,
					plLength, pInfo->m_nDataType);

				// Restore proxy for correct WHERE CURRENT OF operations
				TIMESTAMP_STRUCT* pts =
					(TIMESTAMP_STRUCT*)pFX->m_prs->m_pvFieldProxy[nField-1];

				pts->year = (SWORD)value.GetYear();
				pts->month = (UWORD)value.GetMonth();
				pts->day = (UWORD)value.GetDay();
				pts->hour = (UWORD)value.GetHour();
				pts->minute = (UWORD)value.GetMinute();
				pts->second = (UWORD)value.GetSecond();
				pts->fraction = 0;
			}
			else
				*plLength = SQL_NULL_DATA;

#ifdef _DEBUG
			// Buffer address must not change - ODBC's SQLBindCol depends upon this
			if (pInfo->m_pvBindAddress != pFX->m_prs->m_pvFieldProxy[nField-1])
			{
				TRACE(traceDatabase, 0, "Error: CString buffer (column %u) address has changed!\n",
					nField);
				ASSERT(FALSE);
			}
#endif // _DEBUG
		}
		return;

	case CFieldExchange::BindFieldToColumn:
		{
#ifdef _DEBUG
			// Assumes all bound fields BEFORE unbound fields
			CODBCFieldInfo* pODBCInfo =
				&pFX->m_prs->m_rgODBCFieldInfos[nField - 1];

			ENSURE(pODBCInfo);

			if (pODBCInfo->m_nSQLType != SQL_DATE &&
				pODBCInfo->m_nSQLType != SQL_TIME &&
				pODBCInfo->m_nSQLType != SQL_TIMESTAMP)
			{
				// Warn of possible field schema mismatch
				TRACE(traceDatabase, 1, "Warning: COleDateTime converted from SQL type %ld.\n",
					pODBCInfo->m_nSQLType);
			}
#endif // _DEBUG

			// Allocate proxy array if necessary
			if (pFX->m_prs->m_pvFieldProxy == NULL)
			{
				pFX->m_prs->m_pvFieldProxy = new void*[pFX->m_prs->m_nFields];
				memset(pFX->m_prs->m_pvFieldProxy, 0,
					pFX->m_prs->m_nFields*sizeof(void*));
				pFX->m_prs->m_nProxyFields = pFX->m_prs->m_nFields;
			}

			// Allocate TIMESTAMP_STRUCT for SQLBindCol (not necessary on Requery)
			if (pFX->m_prs->m_pvFieldProxy[nField-1] == NULL)
				pFX->m_prs->m_pvFieldProxy[nField-1] = new TIMESTAMP_STRUCT;

			AFX_SQL_SYNC(::SQLBindCol(pFX->m_prs->m_hstmt, (UWORD)nField,
				SQL_C_TIMESTAMP, pFX->m_prs->m_pvFieldProxy[nField-1],
				sizeof(TIMESTAMP_STRUCT), plLength));
			if (!pFX->m_prs->Check(nRetCode))
				pFX->m_prs->ThrowDBException(nRetCode);

			// Add the member address to the field map
			pFX->m_prs->m_mapFieldIndex.SetAt(&value, (void*)(UINT_PTR)nField);
		}
		return;

	default:
LDefault:
		pFX->Default(szName, &value, plLength, SQL_C_TIMESTAMP,
			sizeof(value), TIMESTAMP_PRECISION);
		return;

	case CFieldExchange::AllocCache:
		{
			CFieldInfo* pInfo = &pFX->m_prs->m_rgFieldInfos[nField - 1];
			pInfo->m_pvDataCache = new COleDateTime;
			pInfo->m_nDataType = AFX_RFX_OLEDATE;
		}
		return;

	case CFieldExchange::Fixup:
		if (*plLength == SQL_NULL_DATA)
		{
			if (pFX->m_bField)
			{
				pFX->m_prs->SetNullFieldStatus(nField - 1);
			}
			value.SetStatus(COleDateTime::null);
		}
		else
		{
			TIMESTAMP_STRUCT* pts =
				(TIMESTAMP_STRUCT*)pFX->m_prs->m_pvFieldProxy[nField-1];
#ifdef _DEBUG
			if (pts->fraction != 0)
				TRACE(traceDatabase, 1, "Warning: ignoring milliseconds.\n");
#endif
			value = COleDateTime(pts->year, pts->month, pts->day,
				pts->hour, pts->minute, pts->second);
		}
		return;

	case CFieldExchange::SetFieldNull:
		if ((pFX->m_pvField == NULL &&
			pFX->m_nFieldType == CFieldExchange::outputColumn) ||
			pFX->m_pvField == &value)
		{
			if (pFX->m_bField)
			{
				// Mark fields null
				pFX->m_prs->SetNullFieldStatus(nField - 1);
				value.SetStatus(COleDateTime::null);
				*plLength = SQL_NULL_DATA;
			}
			else
			{
				pFX->m_prs->ClearNullFieldStatus(nField - 1);
				*plLength = sizeof(TIMESTAMP_STRUCT);
			}
#ifdef _DEBUG
			pFX->m_nFieldFound = nField;
#endif
		}
		return;

	case CFieldExchange::MarkForAddNew:
		// can force writing of psuedo-null value (as a non-null) by setting field dirty
		if (value.GetStatus() != COleDateTime::null)
		{
			pFX->m_prs->SetDirtyFieldStatus(nField - 1);
			pFX->m_prs->ClearNullFieldStatus(nField - 1);
		}
		return;

	case CFieldExchange::MarkForUpdate:
		if (value.GetStatus() != COleDateTime::null)
			pFX->m_prs->ClearNullFieldStatus(nField - 1);
		goto LDefault;

#ifdef _DEBUG
	case CFieldExchange::DumpField:
		CString str;
		str = value.Format();
		*pFX->m_pdcDump << "\n" << str;
		return;
#endif // _DEBUG

	}
}

void AFXAPI RFX_LongBinary(CFieldExchange* pFX, LPCTSTR szName,
	CLongBinary& value)
{
	ENSURE_ARG(AfxIsValidAddress(pFX, sizeof(CFieldExchange)));
	ENSURE_ARG(AfxIsValidString(szName));


  
	RETCODE nRetCode;
	UINT nField;
	if (!pFX->IsFieldType(&nField))
		return;

	LONG_PTR* plLength = pFX->m_prs->GetFieldLengthBuffer(
		nField - 1, pFX->m_nFieldType);
 



	switch (pFX->m_nOperation )
	{
	case CFieldExchange::Name:
		pFX->m_prs->m_bLongBinaryColumns = TRUE;
		pFX->Default(szName, &value, plLength, SQL_C_DEFAULT, 0, 0);
		return;

	case CFieldExchange::BindFieldToColumn:
		// Don't bind if using update SQL, simply do SQLGetData on Fixup
		if (!pFX->m_prs->m_bUseUpdateSQL &&
			(pFX->m_prs->CanUpdate() || pFX->m_prs->CanAppend()))
		{
			// Bind for updates with cb=0 now. Driver may not support post Execute or ExtendedFetch binding
			AFX_SQL_SYNC(::SQLBindCol(pFX->m_prs->m_hstmt, (UWORD)nField, SQL_C_DEFAULT,
				&value, 0, plLength));
			if (!pFX->m_prs->Check(nRetCode))
				pFX->m_prs->ThrowDBException(nRetCode);
		}

		// Add the member address to the field map
		pFX->m_prs->m_mapFieldIndex.SetAt(&value, (void*)(UINT_PTR)nField);
		return;

#ifdef _DEBUG
	case CFieldExchange::BindParam:
		// CLongBinary parameters are not supported
		ASSERT(FALSE);

	case CFieldExchange::MarkForAddNew:
	case CFieldExchange::MarkForUpdate:
		// We do not archive LongBinary values
	case CFieldExchange::StoreField:
	case CFieldExchange::LoadField:
		// We do not archive LongBinary values
#endif // _DEBUG
	default:
		return;

	case CFieldExchange::Fixup:

		// Get the size of the long binary field
		*plLength = pFX->GetLongBinarySize(nField);

	 
		if (*plLength != SQL_NULL_DATA && *plLength !=0)
			pFX->GetLongBinaryData(nField, value, plLength);

		// Set the status and length
		if (*plLength == SQL_NULL_DATA)
		{
			// Field NULL, set length and status
			value.m_dwDataLength = 0;
			pFX->m_prs->SetNullFieldStatus(nField - 1);
		}
		else if (*plLength==0) {
			value.m_dwDataLength = 0;
			pFX->m_prs->ClearNullFieldStatus(nField - 1);
                                
		}	else	{
			// Field not NULL, clear the status (length already set)
			pFX->m_prs->ClearNullFieldStatus(nField - 1);
		}

		return;

	 
	case CFieldExchange::NameValue:
		if (pFX->m_prs->IsFieldStatusDirty(nField - 1))
		{
			*pFX->m_pstr += szName;
			*pFX->m_pstr += '=';
		}

		// Fall through
	case CFieldExchange::Value:
		if (pFX->m_prs->IsFieldStatusDirty(nField - 1))
		{
			// If user marked column NULL, reflect this in length
			if (pFX->m_prs->IsFieldStatusNull(nField - 1))
				*plLength = SQL_NULL_DATA;
			else
			{
				// Indicate data will be sent after SQLExecute
				// Length is signed value, it's limited by LONG_MAX
				if (value.m_dwDataLength >
					(ULONG)(LONG_MAX - labs(SQL_LEN_DATA_AT_EXEC_OFFSET)))
				{
					ASSERT(FALSE);
					*plLength = LONG_MAX - labs(SQL_LEN_DATA_AT_EXEC_OFFSET);
				}
				else
					*plLength = value.m_dwDataLength;

				*plLength = SQL_LEN_DATA_AT_EXEC(*plLength);
			}

			// If optimizing for bulk add, only need lengths set correctly
			if(!(pFX->m_prs->m_dwOptions & CRecordset::optimizeBulkAdd))
			{
				*pFX->m_pstr += '?';
				*pFX->m_pstr += pFX->m_lpszSeparator;
				pFX->m_nParamFields++;

				// Assumes all bound fields BEFORE unbound fields
				CODBCFieldInfo* pODBCInfo =
					&pFX->m_prs->m_rgODBCFieldInfos[nField - 1];

				AFX_SQL_SYNC(::SQLBindParameter(pFX->m_hstmt,
					(UWORD)pFX->m_nParamFields, SQL_PARAM_INPUT,
					SQL_C_DEFAULT, pODBCInfo->m_nSQLType,
					(SQLULEN)value.m_dwDataLength, 0, &value, 0, plLength));
				if (nRetCode != SQL_SUCCESS)
					pFX->m_prs->ThrowDBException(nRetCode, pFX->m_hstmt);
			}
		}
		return;

	case CFieldExchange::BindFieldForUpdate:
		if (pFX->m_prs->IsFieldStatusDirty(nField - 1))
		{
			// If user marked column NULL, reflect this in length
			if (pFX->m_prs->IsFieldStatusNull(nField - 1))
				*plLength = SQL_NULL_DATA;
			else
			{
				// Length is signed value, it's limited by LONG_MAX
				if (value.m_dwDataLength >
					(ULONG)(LONG_MAX - labs(SQL_LEN_DATA_AT_EXEC_OFFSET)))
				{
					ASSERT(FALSE);
					*plLength = LONG_MAX - labs(SQL_LEN_DATA_AT_EXEC_OFFSET);
				}
				else
					*plLength = value.m_dwDataLength;

				*plLength = SQL_LEN_DATA_AT_EXEC(*plLength);
			}
		}
		else
			*plLength = SQL_IGNORE;

		return;

	case CFieldExchange::UnbindFieldForUpdate:
		*plLength = value.m_dwDataLength;
		return;

	case CFieldExchange::SetFieldNull:
		if ((pFX->m_pvField == NULL &&
			pFX->m_nFieldType == CFieldExchange::outputColumn) ||
			pFX->m_pvField == &value)
		{
			if (pFX->m_bField)
			{
				// Mark fields null
				pFX->m_prs->SetNullFieldStatus(nField - 1);
				value.m_dwDataLength = 0;
				*plLength = SQL_NULL_DATA;
			}
			else
			{
				pFX->m_prs->ClearNullFieldStatus(nField - 1);

				// Length is signed value, it's limited by LONG_MAX
				if (value.m_dwDataLength >
					(ULONG)(LONG_MAX - labs(SQL_LEN_DATA_AT_EXEC_OFFSET)))
				{
					ASSERT(FALSE);
					*plLength = LONG_MAX - labs(SQL_LEN_DATA_AT_EXEC_OFFSET);
				}
				else
					*plLength = value.m_dwDataLength;

				*plLength = SQL_LEN_DATA_AT_EXEC(*plLength);
			}
#ifdef _DEBUG
			pFX->m_nFieldFound = nField;
#endif
		}
		return;

	case CFieldExchange::AllocCache:
		// Caching not supported for long binary
		return;

#ifdef _DEBUG
	case CFieldExchange::DumpField:
		*pFX->m_pdcDump << "\n" << szName << " = ";
		value.Dump(*pFX->m_pdcDump);
		return;
#endif // _DEBUG

	}
}

SQLLEN CFieldExchange::GetLongBinarySize(int nField)
{
	RETCODE nRetCode;
	int nDummy;
	SQLLEN lSize;

	// Give empty buffer to find size of entire LongBinary
	AFX_ODBC_CALL(::SQLGetData(m_prs->m_hstmt,
		(UWORD)nField, SQL_C_DEFAULT, &nDummy, 0, &lSize));

	switch (nRetCode)
	{
		case SQL_SUCCESS:
			break;

		case SQL_SUCCESS_WITH_INFO:
#ifdef _DEBUG
			{
				CDBException* e = new CDBException(nRetCode);
				e->BuildErrorString(m_prs->m_pDatabase,
					m_prs->m_hstmt, FALSE);

				// Ignore data truncated messages
				if (e->m_strStateNativeOrigin.Find(_T("State:01004")) < 0)
				{
					TRACE(traceDatabase, 0, "Warning: ODBC Success With Info, ");
					e->TraceErrorMessage(e->m_strError);
					e->TraceErrorMessage(e->m_strStateNativeOrigin);
				}
				e->Delete();
			}
#endif // _DEBUG
			break;

		default:
			m_prs->ThrowDBException(nRetCode);
	}

	return lSize;
}

void CFieldExchange::GetLongBinaryData(int nField, CLongBinary& lb,
	SQLLEN* plSize)
{
	ENSURE_ARG(plSize!=NULL);

	RETCODE nRetCode;
	SQLLEN lActualDataSize = 0;
	SQLLEN lChunkDataSize;
	SQLLEN lReallocSize;
	const BYTE* lpLongBinary;

	lb.m_dwDataLength = 0;

	// Determine initial chunk sizes
	if (*plSize == SQL_NO_TOTAL)
	{
		lChunkDataSize = m_lDefaultLBFetchSize;
		lReallocSize = m_lDefaultLBReallocSize;
	}
	else
	{
		lChunkDataSize = *plSize;
		lReallocSize = *plSize;
	}

	do
	{
		SQLLEN lNewChunkDataSize = lb.m_dwDataLength + lChunkDataSize;
		SQLLEN lNewReallocSize = lb.m_dwDataLength + lReallocSize;
		if ((lNewChunkDataSize < (SQLLEN)lb.m_dwDataLength) || (lNewChunkDataSize < lChunkDataSize))
                        AfxThrowMemoryException();
		if ((lNewReallocSize < (SQLLEN)lb.m_dwDataLength) || (lNewReallocSize < lReallocSize))
                        AfxThrowMemoryException();

		// Check if CLongBianary is big enough
		lpLongBinary = ReallocLongBinary(lb,
			lNewChunkDataSize,
			lNewReallocSize);

		// Adjust the pointer so that data added at end
		lpLongBinary += lb.m_dwDataLength;

		AFX_ODBC_CALL(::SQLGetData(m_prs->m_hstmt, (UWORD)nField,
			SQL_C_BINARY, (UCHAR*)lpLongBinary, lChunkDataSize, &lActualDataSize));
		::GlobalUnlock(lb.m_hData);

		switch (nRetCode)
		{
			case SQL_NO_DATA_FOUND:
				m_prs->SetNullFieldStatus(nField - 1);
				*plSize = SQL_NULL_DATA;
				break;

			case SQL_SUCCESS:
				// All data fetched
				lb.m_dwDataLength += lActualDataSize;
				*plSize = lb.m_dwDataLength;
				return;

			case SQL_SUCCESS_WITH_INFO:
				{
					CDBException* e = new CDBException(nRetCode);
					e->BuildErrorString(m_prs->m_pDatabase, m_prs->m_hstmt,
						FALSE);

					// Ignore data truncated messages
					if (e->m_strStateNativeOrigin.Find(_T("State:01004")) < 0)
					{
#ifdef _DEBUG
						TRACE(traceDatabase, 0, "Warning: ODBC Success With Info, ");
						e->TraceErrorMessage(e->m_strError);
						e->TraceErrorMessage(e->m_strStateNativeOrigin);
#endif // _DEBUG
						// Must be some other warning, should be finished
						lb.m_dwDataLength += lActualDataSize;
					}
					else
					{
						// Should only happen if further calls to SQLGetData necessary

						// Increment the length by the chunk size for subsequent SQLGetData call
						lb.m_dwDataLength += lChunkDataSize;

						// Recalculate chunk and alloc sizes
						lChunkDataSize = m_prs->GetLBFetchSize(lChunkDataSize);
						lReallocSize = m_prs->GetLBReallocSize(lReallocSize);
						// force loop to repeat
						lActualDataSize = SQL_NO_TOTAL;
					}

					*plSize = lb.m_dwDataLength;
					e->Delete();
				}
				break;

			default:
				m_prs->ThrowDBException(nRetCode);
		}

	} while (lActualDataSize == SQL_NO_TOTAL);
}

BYTE* CFieldExchange::ReallocLongBinary(CLongBinary& lb, SQLLEN lSizeRequired,
	SQLLEN lReallocSize)
{
	// realloc max of lSizeRequired, lReallocSize (m_dwDataLength untouched)

	if (lSizeRequired < 0)
	{
		ASSERT(FALSE);
		lSizeRequired = 0;
	}

	HGLOBAL hOldData = NULL;

	// Allocate or Realloc as req'd
	if (lb.m_hData == NULL)
		lb.m_hData = ::GlobalAlloc(GMEM_MOVEABLE, lReallocSize);
	else
	{
		ULONG_PTR dwSize = ::GlobalSize(lb.m_hData);
		if (dwSize < (DWORD)lSizeRequired)
		{
			// Save the old handle in case ReAlloc fails
			hOldData = lb.m_hData;

			// Allocate more memory if necessary
			lb.m_hData = ::GlobalReAlloc(lb.m_hData,
				__max(lSizeRequired, lReallocSize), GMEM_MOVEABLE);
		}
	}

	// Validate the memory was allocated and can be locked
	if (lb.m_hData == NULL)
	{
		// Restore the old handle (not NULL if Realloc failed)
		lb.m_hData = hOldData;
		AfxThrowMemoryException();
	}

	BYTE* lpLongBinary = (BYTE*)::GlobalLock(lb.m_hData);
	if (lpLongBinary == NULL)
	{
		::GlobalFree(lb.m_hData);
		lb.m_hData = NULL;
		AfxThrowMemoryException();
	}

	return lpLongBinary;
}

//////////////////////////////////////////////////////////////////////////////
// Recordset Field Exchange Helpers


void AFXAPI AfxStoreField(CRecordset& rs, UINT nField, void* pvField)
{
	ENSURE(rs.m_rgFieldInfos && nField >= 1 && nField <= rs.m_nFields);
	// Get the field data
	CFieldInfo* pInfo = &rs.m_rgFieldInfos[nField - 1];
	// Cache the status
	pInfo->m_bStatus = rs.GetFieldStatus(nField - 1);

	// Save the data
	if (!rs.IsFieldStatusNull(nField - 1))
	{
		// Don't need to save length for variable len
		// objects as CString and CByteArray track len internally
		LONG_PTR nDummyLength;

		if (pInfo->m_nDataType == AFX_RFX_BOOL ||
			pInfo->m_nDataType == AFX_RFX_BYTE ||
			pInfo->m_nDataType == AFX_RFX_INT ||
			pInfo->m_nDataType == AFX_RFX_LONG ||
			pInfo->m_nDataType == AFX_RFX_SINGLE)
		{
			// If caching data by value, pass a ref
			AfxCopyValueByRef(pvField, &pInfo->m_pvDataCache,
				&nDummyLength, pInfo->m_nDataType);
		}
		else
		{
			AfxCopyValueByRef(pvField, pInfo->m_pvDataCache,
				&nDummyLength, pInfo->m_nDataType);
		}
	}

#ifdef _DEBUG
	// Cache the bind address expected by ODBC
	switch(pInfo->m_nDataType)
	{
	default:
		// All types that are bound directly
		pInfo->m_pvBindAddress = pvField;
		break;

	case AFX_RFX_WTEXT:
		ENSURE_ARG(pvField);
		pInfo->m_pvBindAddress = static_cast<CStringW *>(pvField)->GetBuffer(0);
		static_cast<CStringW *>(pvField)->ReleaseBuffer();
		break;

	case AFX_RFX_ATEXT:
		ENSURE_ARG(pvField);
		pInfo->m_pvBindAddress = static_cast<CStringA *>(pvField)->GetBuffer(0);
		static_cast<CStringA *>(pvField)->ReleaseBuffer();
		break;

	case AFX_RFX_LPWSTR:
	case AFX_RFX_LPASTR:
		pInfo->m_pvBindAddress = pvField;
		break;

	case AFX_RFX_DATE:
	case AFX_RFX_OLEDATE:
		pInfo->m_pvBindAddress = rs.m_pvFieldProxy[nField-1];
		break;

	case AFX_RFX_BINARY:
		ENSURE_ARG(pvField);
		pInfo->m_pvBindAddress = ((CByteArray*)pvField)->GetData();
		break;
	}
#endif
}

void AFXAPI AfxLoadField(CRecordset& rs, UINT nField,
	void* pvField, LONG_PTR* plLength)
{
	// Get the field data
	CFieldInfo* pInfo = &rs.m_rgFieldInfos[nField - 1];

	// Assumes old field status cleared out
	rs.SetFieldStatus(nField - 1, pInfo->m_bStatus);

	// If not NULL, restore the value and the length
	if (!rs.IsFieldStatusNull(nField - 1))
	{
		if (pInfo->m_nDataType == AFX_RFX_BOOL ||
			pInfo->m_nDataType == AFX_RFX_BYTE ||
			pInfo->m_nDataType == AFX_RFX_INT ||
			pInfo->m_nDataType == AFX_RFX_LONG ||
			pInfo->m_nDataType == AFX_RFX_SINGLE)
		{
			// If caching data by value, pass a ref
			AfxCopyValueByRef(&pInfo->m_pvDataCache, pvField,
				plLength, pInfo->m_nDataType);
		}
		else
		{
			AfxCopyValueByRef(pInfo->m_pvDataCache, pvField,
				plLength, pInfo->m_nDataType);
		}
	}
	else
		*plLength = SQL_NULL_DATA;

#ifdef _DEBUG
	// Buffer address must not change - ODBC's SQLBindCol depends upon this
	if (pInfo->m_nDataType == AFX_RFX_BINARY)
	{
		// Change pvField to point to the data of the CByteArray
		pvField = ((CByteArray*)pvField)->GetData();
	}

	if (pInfo->m_pvBindAddress != pvField)
	{
		TRACE(traceDatabase, 0, "Error: field address (column %u) has changed!\n",
			nField);
		ASSERT(FALSE);
	}
#endif // _DEBUG
}

BOOL AFXAPI AfxCompareValueByRef(void* pvSrc, void* pvDest, int nSrcType)
{
	ENSURE_ARG(pvSrc != NULL);
	ENSURE_ARG(pvDest != NULL);

	switch(nSrcType)
	{
	case AFX_RFX_LONGBINARY:
		// Caching long binary Src not supported
	default:
		return FALSE;

	case AFX_RFX_LPWSTR:
		return ::lstrcmpW(static_cast<LPCWSTR>(pvDest), static_cast<LPCWSTR>(pvSrc)) == 0;

	case AFX_RFX_LPASTR:
		return ::lstrcmpA(static_cast<LPCSTR>(pvDest), static_cast<LPCSTR>(pvSrc)) == 0;

	case AFX_RFX_WTEXT:
		return *static_cast<CStringW *>(pvDest) == *static_cast<CStringW *>(pvSrc);

	case AFX_RFX_ATEXT:
		return *static_cast<CStringA *>(pvDest) == *static_cast<CStringA *>(pvSrc);

	case AFX_RFX_BINARY:
		{
			CByteArray* pByteArraySrc = (CByteArray*)pvSrc;
			CByteArray* pByteArrayDest = (CByteArray*)pvDest;

			// If sizes compare, compare the Src
			INT_PTR nSize = pByteArraySrc->GetSize();
			return nSize == pByteArrayDest->GetSize() &&
				   memcmp(pByteArrayDest->GetData(), pByteArraySrc->GetData(), nSize) == 0;
		}

	case AFX_RFX_BOOL:
		return *(BOOL*)pvDest == *(BOOL*)pvSrc;

	case AFX_RFX_BYTE:
		return *(BYTE*)pvDest == *(BYTE*)pvSrc;

	case AFX_RFX_INT:
		return *(int*)pvDest == *(int*)pvSrc;

	case AFX_RFX_BIGINT:
		return *(LONGLONG*)pvDest == *(LONGLONG*)pvSrc;

	case AFX_RFX_LONG:
		return *(long*)pvDest == *(long*)pvSrc;

	case AFX_RFX_SINGLE:
		return *(float*)pvDest == *(float*)pvSrc;

	case AFX_RFX_DOUBLE:
		return *(double*)pvDest == *(double*)pvSrc;

	case AFX_RFX_OLEDATE:
		return *(COleDateTime*)pvDest == *(COleDateTime*)pvSrc;

	case AFX_RFX_DATE:
		return *(CTime*)pvDest == *(CTime*)pvSrc;

	case AFX_RFX_TIMESTAMP:
		{
			TIMESTAMP_STRUCT* pSrc = (TIMESTAMP_STRUCT*)pvSrc;
			TIMESTAMP_STRUCT* pDest = (TIMESTAMP_STRUCT*)pvDest;
			return pSrc->year == pDest->year &&
				pSrc->month == pDest->month &&
				pSrc->day == pDest->day &&
				pSrc->hour == pDest->hour &&
				pSrc->minute == pDest->minute &&
				pSrc->second == pDest->second &&
				pSrc->fraction == pDest->fraction;
		}
	}
}

void AFXAPI AfxCopyValueByRef(void* pvSrc, void* pvDest, LONG_PTR* plLength, int nDestType)
{
	ENSURE_ARG(pvSrc != NULL);
	ENSURE_ARG(pvDest != NULL);
	ENSURE_ARG(plLength != NULL);

	switch (nDestType)
	{
	case AFX_RFX_LONGBINARY:
		// Caching long binary Dest not supported
	default:
		ASSERT(FALSE);
		break;

	case AFX_RFX_LPWSTR:
		lstrcpyW(static_cast<LPWSTR>(pvDest), static_cast<LPCWSTR>(pvSrc));
		*plLength = lstrlenW(static_cast<LPCWSTR>(pvDest)) * sizeof(WCHAR);
		break;

	case AFX_RFX_LPASTR:
		lstrcpyA(static_cast<LPSTR>(pvDest), static_cast<LPCSTR>(pvSrc));
		*plLength = lstrlenA(static_cast<LPCSTR>(pvDest))  * sizeof(CHAR);
		break;

	case AFX_RFX_WTEXT:
		*static_cast<CStringW *>(pvDest) = *static_cast<CStringW *>(pvSrc);
		*plLength = static_cast<CStringW *>(pvDest)->GetLength() * sizeof(WCHAR);
		break;

	case AFX_RFX_ATEXT:
		*static_cast<CStringA *>(pvDest) = *static_cast<CStringA *>(pvSrc);
		*plLength = static_cast<CStringA *>(pvDest)->GetLength() * sizeof(CHAR);
		break;

	case AFX_RFX_BINARY:
		((CByteArray*)pvDest)->Copy(*(CByteArray*)pvSrc);
		*plLength = ((CByteArray*)pvSrc)->GetSize();
		break;

	case AFX_RFX_BOOL:
		*(BOOL*)pvDest = *(BOOL*)pvSrc;
		*plLength = sizeof(BOOL);
		break;

	case AFX_RFX_BYTE:
		*(BYTE*)pvDest = *(BYTE*)pvSrc;
		*plLength = sizeof(BYTE);
		break;

	case AFX_RFX_INT:
		*(int*)pvDest = *(int*)pvSrc;
		*plLength = sizeof(int);
		break;

	case AFX_RFX_BIGINT:
		*(LONGLONG*)pvDest = *(LONGLONG*)pvSrc;
		*plLength = sizeof(LONGLONG);
		break;

	case AFX_RFX_LONG:
		*(long*)pvDest = *(long*)pvSrc;
		*plLength = sizeof(long);
		break;

	case AFX_RFX_SINGLE:
		*(float*)pvDest = *(float*)pvSrc;
		*plLength = sizeof(float);
		break;

	case AFX_RFX_DOUBLE:
		*(double*)pvDest = *(double*)pvSrc;
		*plLength = sizeof(double);
		break;

	case AFX_RFX_DATE:
		*(CTime*)pvDest = *(CTime*)pvSrc;
		*plLength = sizeof(TIMESTAMP_STRUCT);
		break;

	case AFX_RFX_OLEDATE:
		*(COleDateTime*)pvDest = *(COleDateTime*)pvSrc;
		*plLength = sizeof(TIMESTAMP_STRUCT);
		break;

	case AFX_RFX_TIMESTAMP:
		{
			TIMESTAMP_STRUCT* pDest = (TIMESTAMP_STRUCT*)pvDest;
			TIMESTAMP_STRUCT* pSrc = (TIMESTAMP_STRUCT*)pvSrc;

			pDest->year = pSrc->year;
			pDest->month = pSrc->month;
			pDest->day = pSrc->day;
			pDest->hour = pSrc->hour;
			pDest->minute = pSrc->minute;
			pDest->second = pSrc->second;
			pDest->fraction = pSrc->fraction;

			*plLength = sizeof(TIMESTAMP_STRUCT);
		}
		break;
	}
}

//////////////////////////////////////////////////////////////////////////////
// Bulk Recordset Field Exchange
template<typename CharType>
inline void RFX_Text_Bulk(CFieldExchange* pFX, LPCTSTR szName,
	_Out_ _Deref_post_cap_(nMaxLength) CharType **prgStrVals, LONG_PTR** prgLengths, int nMaxLength,
	short nFieldType)
{
	ENSURE_ARG(AfxIsValidAddress(pFX, sizeof(CFieldExchange)));
	ENSURE_ARG(AfxIsValidString(szName));
	

	UINT nField;
	if (!pFX->IsFieldType(&nField))
		return;

	ENSURE_ARG(prgStrVals!=NULL && prgLengths!=NULL);
	switch (pFX->m_nOperation)
	{
	case CFieldExchange::AllocMultiRowBuffer:
		{
			// The buffer pointer better be initialized to NULL
			// or cleanup in exceptional cases mail fail
			ASSERT(*prgStrVals == NULL);
			ASSERT(*prgLengths == NULL);

			int nRowsetSize = pFX->m_prs->GetRowsetSize();

			// Allocate buffers to hold data and length
			*prgStrVals = new CharType[nRowsetSize * nMaxLength]; // Make sure bulk-row fetching works for Unicode
			*prgLengths = new LONG_PTR[nRowsetSize];
		}
		break;

	case CFieldExchange::DeleteMultiRowBuffer:
		delete [] *prgStrVals;
		*prgStrVals = NULL;

		delete [] *prgLengths;
		*prgLengths = NULL;
		break;

	default:
		AfxRFXBulkDefault(pFX, szName, *prgStrVals, *prgLengths,
			nFieldType, nMaxLength);
		break;
	}
}

void AFXAPI RFX_Text_Bulk(CFieldExchange* pFX, LPCTSTR szName,
	_Out_ _Deref_post_cap_(nMaxLength) LPWSTR *prgStrVals, LONG_PTR** prgLengths, int nMaxLength)
{
	RFX_Text_Bulk(pFX, szName, prgStrVals, prgLengths, nMaxLength, SQL_C_WCHAR);
}

void AFXAPI RFX_Text_Bulk(CFieldExchange* pFX, LPCTSTR szName,
	_Out_ _Deref_post_cap_(nMaxLength) LPSTR *prgStrVals, LONG_PTR** prgLengths, int nMaxLength)
{
	RFX_Text_Bulk(pFX, szName, prgStrVals, prgLengths, nMaxLength, SQL_C_CHAR);
}

void AFXAPI RFX_Bool_Bulk(CFieldExchange* pFX, LPCTSTR szName,
	BOOL** prgBoolVals, LONG_PTR** prgLengths)
{
	ENSURE_ARG(AfxIsValidAddress(pFX, sizeof(CFieldExchange)));
	ENSURE_ARG(AfxIsValidString(szName));

	UINT nField;
	if (!pFX->IsFieldType(&nField))
		return;

	ENSURE_ARG(prgBoolVals!=NULL && prgLengths!=NULL);
	switch (pFX->m_nOperation)
	{
	case CFieldExchange::AllocMultiRowBuffer:
		{
			// The buffer pointer better be initialized to NULL
			// or cleanup in exceptional cases mail fail
			ASSERT(*prgBoolVals == NULL);
			ASSERT(*prgLengths == NULL);

			int nRowsetSize = pFX->m_prs->GetRowsetSize();

			// Allocate buffers to hold data and length
			*prgBoolVals = new BOOL[nRowsetSize];
			*prgLengths = new LONG_PTR[nRowsetSize];
		}
		break;

	case CFieldExchange::DeleteMultiRowBuffer:
		delete [] *prgBoolVals;
		*prgBoolVals = NULL;

		delete [] *prgLengths;
		*prgLengths = NULL;
		break;

	default:
		AfxRFXBulkDefault(pFX, szName, *prgBoolVals, *prgLengths,
			SQL_C_LONG, sizeof(BOOL));
		break;
	}
}

void AFXAPI RFX_Int_Bulk(CFieldExchange* pFX, LPCTSTR szName,
	int** prgIntVals, LONG_PTR** prgLengths)
{
	ENSURE_ARG(AfxIsValidAddress(pFX, sizeof(CFieldExchange)));
	ENSURE_ARG(AfxIsValidString(szName));

	UINT nField;
	if (!pFX->IsFieldType(&nField))
		return;

	ENSURE_ARG(prgIntVals!=NULL && prgLengths!=NULL);
	switch (pFX->m_nOperation)
	{
	case CFieldExchange::AllocMultiRowBuffer:
		{
			// The buffer pointer better be initialized to NULL
			// or cleanup in exceptional cases mail fail
			ASSERT(*prgIntVals == NULL);
			ASSERT(*prgLengths == NULL);

			int nRowsetSize = pFX->m_prs->GetRowsetSize();

			// Allocate buffers to hold data and length
			*prgIntVals = new int[nRowsetSize];
			*prgLengths = new LONG_PTR[nRowsetSize];
		}
		break;

	case CFieldExchange::DeleteMultiRowBuffer:
		delete [] *prgIntVals;
		*prgIntVals = NULL;

		delete [] *prgLengths;
		*prgLengths = NULL;
		break;

	default:
		AfxRFXBulkDefault(pFX, szName, *prgIntVals, *prgLengths,
			SQL_C_LONG, sizeof(int));
		break;
	}
}

void AFXAPI RFX_Long_Bulk(CFieldExchange* pFX, LPCTSTR szName,
	long** prgLongVals, LONG_PTR** prgLengths)
{
	ENSURE_ARG(AfxIsValidAddress(pFX, sizeof(CFieldExchange)));
	ENSURE_ARG(AfxIsValidString(szName));
	
	UINT nField;
	if (!pFX->IsFieldType(&nField))
		return;

	ENSURE_ARG(prgLongVals!=NULL && prgLengths!=NULL);
	switch (pFX->m_nOperation)
	{
	case CFieldExchange::AllocMultiRowBuffer:
		{
			// The buffer pointer better be initialized to NULL
			// or cleanup in exceptional cases mail fail
			ASSERT(*prgLongVals == NULL);
			ASSERT(*prgLengths == NULL);

			int nRowsetSize = pFX->m_prs->GetRowsetSize();

			// Allocate buffers to hold data and length
			*prgLongVals = new long[nRowsetSize];
			*prgLengths = new LONG_PTR[nRowsetSize];
		}
		break;

	case CFieldExchange::DeleteMultiRowBuffer:
		delete [] *prgLongVals;
		*prgLongVals = NULL;

		delete [] *prgLengths;
		*prgLengths = NULL;
		break;

	default:
		AfxRFXBulkDefault(pFX, szName, *prgLongVals, *prgLengths,
			SQL_C_LONG, sizeof(long));
		break;
	}
}

void AFXAPI RFX_Date_Bulk(CFieldExchange* pFX, LPCTSTR szName,
	TIMESTAMP_STRUCT** prgTSVals, LONG_PTR** prgLengths)
{
	ENSURE_ARG(AfxIsValidAddress(pFX, sizeof(CFieldExchange)));
	ENSURE_ARG(AfxIsValidString(szName));

	UINT nField;
	if (!pFX->IsFieldType(&nField))
		return;

	ENSURE_ARG(prgTSVals!=NULL && prgLengths!=NULL);
	switch (pFX->m_nOperation)
	{
	case CFieldExchange::AllocMultiRowBuffer:
		{
			// The buffer pointer better be initialized to NULL
			// or cleanup in exceptional cases mail fail
			ASSERT(*prgTSVals == NULL);
			ASSERT(*prgLengths == NULL);

			int nRowsetSize = pFX->m_prs->GetRowsetSize();

			// Allocate buffers to hold data and length
			*prgTSVals = new TIMESTAMP_STRUCT[nRowsetSize];
			*prgLengths = new LONG_PTR[nRowsetSize];
		}
		break;

	case CFieldExchange::DeleteMultiRowBuffer:
		delete [] *prgTSVals;
		*prgTSVals = NULL;

		delete [] *prgLengths;
		*prgLengths = NULL;
		break;

	default:
		AfxRFXBulkDefault(pFX, szName, *prgTSVals, *prgLengths,
			SQL_C_TIMESTAMP, sizeof(TIMESTAMP_STRUCT));
		break;
	}
}

void AFXAPI RFX_Byte_Bulk(CFieldExchange* pFX, LPCTSTR szName,
	BYTE** prgByteVals, LONG_PTR** prgLengths)
{
	ENSURE_ARG(AfxIsValidAddress(pFX, sizeof(CFieldExchange)));
	ENSURE_ARG(AfxIsValidString(szName));

	UINT nField;
	if (!pFX->IsFieldType(&nField))
		return;

	ENSURE_ARG(prgByteVals!=NULL && prgLengths!=NULL);
	switch (pFX->m_nOperation)
	{
	case CFieldExchange::AllocMultiRowBuffer:
		{
			// The buffer pointer better be initialized to NULL
			// or cleanup in exceptional cases mail fail
			ASSERT(*prgByteVals == NULL);
			ASSERT(*prgLengths == NULL);

			int nRowsetSize = pFX->m_prs->GetRowsetSize();

			// Allocate buffers to hold data and length
			*prgByteVals = new BYTE[nRowsetSize];
			*prgLengths = new LONG_PTR[nRowsetSize];
		}
		break;

	case CFieldExchange::DeleteMultiRowBuffer:
		delete [] *prgByteVals;
		*prgByteVals = NULL;

		delete [] *prgLengths;
		*prgLengths = NULL;
		break;

	default:
		AfxRFXBulkDefault(pFX, szName, *prgByteVals, *prgLengths,
			SQL_C_TINYINT, sizeof(BYTE));
		break;
	}
}

void AFXAPI RFX_Binary_Bulk(CFieldExchange* pFX, LPCTSTR szName,
	BYTE** prgByteVals, LONG_PTR** prgLengths, int nMaxLength)
{
	ENSURE_ARG(AfxIsValidAddress(pFX, sizeof(CFieldExchange)));
	ENSURE_ARG(AfxIsValidString(szName));

	UINT nField;
	if (!pFX->IsFieldType(&nField))
		return;

	ENSURE_ARG(prgByteVals!=NULL && prgLengths!=NULL);
	switch (pFX->m_nOperation)
	{
	case CFieldExchange::AllocMultiRowBuffer:
		{
			// The buffer pointer better be initialized to NULL
			// or cleanup in exceptional cases mail fail
			ASSERT(*prgByteVals == NULL);
			ASSERT(*prgLengths == NULL);

			int nRowsetSize = pFX->m_prs->GetRowsetSize();

			// Allocate buffers to hold data and length
			*prgByteVals = new BYTE[nRowsetSize * nMaxLength];
			*prgLengths = new LONG_PTR[nRowsetSize];
		}
		break;

	case CFieldExchange::DeleteMultiRowBuffer:
		delete [] *prgByteVals;
		*prgByteVals = NULL;

		delete [] *prgLengths;
		*prgLengths = NULL;
		break;

	default:
		AfxRFXBulkDefault(pFX, szName, *prgByteVals, *prgLengths,
			SQL_C_BINARY, nMaxLength);
		break;
	}
}

void AFXAPI AfxRFXBulkDefault(CFieldExchange* pFX, LPCTSTR szName,
	void* pv, LONG_PTR* rgLengths, int nCType, SQLULEN cbValue)
{
	ENSURE_ARG(pFX!=NULL);

	RETCODE nRetCode;

	switch(pFX->m_nOperation)
	{
	default:
		// Operation not valid for bulk fetch
		ASSERT(FALSE);
		return;

	case CFieldExchange::Name:
		ENSURE_ARG(szName!=NULL);
		// We require a name
		ASSERT(lstrlen(szName) != 0);

		*pFX->m_pstr += szName;
		*pFX->m_pstr += pFX->m_lpszSeparator;
		break;

	case CFieldExchange::BindFieldToColumn:
		AFX_SQL_SYNC(::SQLBindCol(pFX->m_prs->m_hstmt,
			(UWORD)pFX->m_nFields, (SWORD)nCType, pv, cbValue, rgLengths));
		if (!pFX->m_prs->Check(nRetCode))
			pFX->m_prs->ThrowDBException(nRetCode);
		break;
	}
}

//////////////////////////////////////////////////////////////////////////////
// Inline function declarations expanded out-of-line

#ifndef _AFX_ENABLE_INLINES

#define _AFXDBRFX_INLINE
#include "afxdb.inl"

#endif


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\dcprev.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "sal.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// Helper functions

AFX_STATIC long AFXAPI _AfxMultMultDivDiv(
	int factor, int num1, int num2,
	int den1, int den2)
{
#ifdef _AFX_PORTABLE
	// make sure that (num1 * num2) does not overflow 31-bits.
	long temp = num1 < 0 ? -num1 : num1;
	for (int nBitsResult = 0; temp != 0; nBitsResult++)
		temp >>= 1;
	temp = num2 < 0 ? -num2 : num2;
	for (; temp != 0; nBitsResult++)
		temp >>= 1;
	if (nBitsResult > 31)
	{
		num1 >>= nBitsResult - 31;
		num2 >>= nBitsResult - 31;
	}

	// make sure that (den1 * den2) does not overflow 31-bits
	temp = den1 < 0 ? -den1 : den1;
	for (nBitsResult = 0; temp != 0; nBitsResult++)
		temp >>= 1;
	temp = den2 < 0 ? -den2 : den2;
	for (; temp != 0; nBitsResult++)
		temp >>= 1;
	if (nBitsResult > 31)
	{
		den1 >>= nBitsResult - 31;
		den2 >>= nBitsResult - 31;
	}

	long numerator = (long)num1 * (long)num2;   // no overflow
	long denominator = (long)den1 * (long)den2; // no overflow
#else
	__int64 numerator = (__int64)num1 * (__int64)num2;   // no overflow
	__int64 denominator = (__int64)den1 * (__int64)den2; // no overflow
	__int64 temp;
#endif

	temp = numerator < 0 ? -numerator : numerator;
	int nBitsInNum;
	for (nBitsInNum = 0; temp != 0; nBitsInNum++)
		temp >>= 1;

	temp = factor < 0 ? -factor : factor;
	int nBitsInFactor;
	for (nBitsInFactor = 0; temp != 0; nBitsInFactor++)
		temp >>= 1;

	nBitsInNum += nBitsInFactor;

	//
	// normalizing the denominator to positive results in an easier
	// determination of whether there is overflow
	//
	if (denominator < 0)
	{
		denominator = -denominator;
		numerator = -numerator;
	}

	// Get the product of factor * numerator representable in a long/__int64
	// while distributing loss of presision across all three numerator terms
	// Adjust denominator as well
	//
	while (nBitsInNum-- > 31)
	{
		numerator >>= 1;
		denominator >>= 1;
		if (nBitsInNum-- <= 31)
			break;
		numerator >>= 1;
		denominator >>= 1;
		if (nBitsInNum-- <= 31)
			break;
		factor >>= 1;
		denominator >>= 1;
	}
	numerator *= factor;

	if (denominator == 0)
		return numerator < 0 ? LONG_MIN : LONG_MAX;

	return (long) ((numerator + denominator/2) / denominator);
}

/////////////////////////////////////////////////////////////////////////////
// Print Preview DC (CPreviewDC)

CPreviewDC::CPreviewDC()
{
	// Initial scale factor and top-left offset
	m_nScaleNum = m_nScaleDen = 1;
	m_sizeTopLeft.cx = m_sizeTopLeft.cy = 8;
	m_hFont = m_hPrinterFont = NULL;
}

void CPreviewDC::SetOutputDC(HDC hDC)
{
	ASSERT(hDC != NULL);
	m_nSaveDCIndex = ::SaveDC(hDC); // restore in ReleaseOutputDC()
	CDC::SetOutputDC(hDC);

	if (m_hAttribDC != NULL)
	{
		MirrorMappingMode(FALSE);

		if (m_hFont)
			::SelectObject(m_hDC, m_hFont);
		else
			MirrorFont();
		MirrorAttributes();
	}
}

void CPreviewDC::ReleaseOutputDC()
{
	ASSERT(m_hDC != NULL);
	::RestoreDC(m_hDC, m_nSaveDCIndex); // Saved in SetOutputDC()
	CDC::ReleaseOutputDC();
}

void CPreviewDC::SetAttribDC(HDC hDC)
{
	ASSERT(hDC != NULL);
	CDC::SetAttribDC(hDC);

	MirrorMappingMode(TRUE);
	MirrorFont();
	MirrorAttributes();
}

CPreviewDC::~CPreviewDC()
{
	ASSERT(m_hDC == NULL);      // Should not have a screen DC at this time
	AfxDeleteObject((HGDIOBJ*)&m_hFont);
}

void CPreviewDC::SetScaleRatio(int nNumerator, int nDenominator)
{
	m_nScaleNum = nNumerator;
	m_nScaleDen = nDenominator;
	if (m_hAttribDC != NULL)
	{
		MirrorMappingMode(TRUE);
		MirrorFont();
	}
}

// Implementation support
#ifdef _DEBUG
void CPreviewDC::AssertValid() const
{
	CDC::AssertValid();
}


void CPreviewDC::Dump(CDumpContext& dc) const
{
	CDC::Dump(dc);

	dc << "Scale Factor: " << m_nScaleNum << "/" << m_nScaleDen;
	dc << "\n";
}
#endif

int CPreviewDC::SaveDC()
{
	ASSERT(m_hAttribDC != NULL);
	int nAttribIndex = ::SaveDC(m_hAttribDC);
	if (m_hDC != NULL)
	{
		// remove font from object
		::SelectObject(m_hDC, GetStockObject(SYSTEM_FONT));
		m_nSaveDCDelta = ::SaveDC(m_hDC) - nAttribIndex;
		// Select font back in after save
		::SelectObject(m_hDC, m_hFont);
	}
	else
	{
		m_nSaveDCDelta = 0x7fff;        // impossibly high value
	}
	return nAttribIndex;
}

BOOL CPreviewDC::RestoreDC(int nSavedDC)
{
	ASSERT(m_hAttribDC != NULL);
	BOOL bSuccess = ::RestoreDC(m_hAttribDC, nSavedDC);
	if (bSuccess)
	{
		if (m_nSaveDCDelta != 0x7fff)
		{
			ASSERT(m_hDC != NULL);      // removed Output DC after save

			if (nSavedDC != -1)
				nSavedDC += m_nSaveDCDelta;
			bSuccess = ::RestoreDC(m_hDC, nSavedDC);
			MirrorFont();               // mirror the font
		}
		else
		{
			ASSERT(m_hDC == NULL);      // Added the Output DC after save
		}
	}
	return bSuccess;
}

void CPreviewDC::MirrorAttributes()
{
	ASSERT(m_hAttribDC != NULL);

	if (m_hDC != NULL)
	{
		// extract and re-set Pen and Brush
		HGDIOBJ hTemp = ::SelectObject(m_hAttribDC, ::GetStockObject(BLACK_PEN));
		::SelectObject(m_hAttribDC, hTemp);
		::SelectObject(m_hDC, hTemp);
		hTemp = ::SelectObject(m_hAttribDC, ::GetStockObject(BLACK_BRUSH));
		::SelectObject(m_hAttribDC, hTemp);
		::SelectObject(m_hDC, hTemp);

		SetROP2(GetROP2());
		SetBkMode(GetBkMode());
		SetTextAlign(GetTextAlign());
		SetPolyFillMode(GetPolyFillMode());
		SetStretchBltMode(GetStretchBltMode());
		SetTextColor(GetNearestColor(GetTextColor()));
		SetBkColor(GetNearestColor(GetBkColor()));
	}
}

CGdiObject* CPreviewDC::SelectStockObject(int nIndex)
{
	ASSERT(m_hAttribDC != NULL);

	HGDIOBJ hObj = ::GetStockObject(nIndex);

	switch (nIndex)
	{
	case ANSI_FIXED_FONT:
	case ANSI_VAR_FONT:
	case DEVICE_DEFAULT_FONT:
	case OEM_FIXED_FONT:
	case SYSTEM_FONT:
	case SYSTEM_FIXED_FONT:
	case DEFAULT_GUI_FONT:
		// Handle the stock fonts correctly
		{
			CGdiObject* pObject = CGdiObject::FromHandle(
							::SelectObject(m_hAttribDC, hObj));

			// Don't re-mirror screen font if this is the same font.
			if (m_hPrinterFont == (HFONT) hObj)
				return pObject;

			m_hPrinterFont = (HFONT) hObj;

			ASSERT(m_hPrinterFont != NULL); // Do not allow infinite recursion

			MirrorFont();
			return pObject;
		}

	default:
		if (m_hDC != NULL)
			::SelectObject(m_hDC, hObj);
		return CGdiObject::FromHandle(::SelectObject(m_hAttribDC, hObj));
	}
}

void CPreviewDC::MirrorFont()
{
	if (m_hAttribDC == NULL)
		return;         // Can't do anything without Attrib DC

	if (m_hPrinterFont == NULL)
	{
		SelectStockObject(DEVICE_DEFAULT_FONT); // will recurse
		return;
	}

	if (m_hDC == NULL)
		return;         // can't mirror font without a screen DC

	LOGFONT logFont;
	// Fill the logFont structure with the original info
	::GetObject(m_hPrinterFont, sizeof(LOGFONT), (LPVOID)&logFont);

	TEXTMETRIC tm;

	GetTextFace(LF_FACESIZE, (LPTSTR)&logFont.lfFaceName[0]);
	GetTextMetrics(&tm);

	// Set real values based on the Printer's text metrics.

	if (tm.tmHeight < 0)
		logFont.lfHeight = tm.tmHeight;
	else
		logFont.lfHeight = -(tm.tmHeight - tm.tmInternalLeading);

	logFont.lfWidth = tm.tmAveCharWidth;
	logFont.lfWeight = tm.tmWeight;
	logFont.lfItalic = tm.tmItalic;
	logFont.lfUnderline = tm.tmUnderlined;
	logFont.lfStrikeOut = tm.tmStruckOut;
	logFont.lfCharSet = tm.tmCharSet;
	logFont.lfPitchAndFamily = tm.tmPitchAndFamily;

	HFONT hNewFont = ::CreateFontIndirect(&logFont);
	::SelectObject(m_hDC, hNewFont);

	::GetTextMetrics(m_hDC, &tm);

	// Is the displayed font too large?

	int cyDesired = -logFont.lfHeight;
	int cyActual;
	if (tm.tmHeight < 0)
		cyActual = -tm.tmHeight;
	else
		cyActual = tm.tmHeight - tm.tmInternalLeading;

	CSize sizeWinExt;
	VERIFY(::GetWindowExtEx(m_hDC, &sizeWinExt));
	CSize sizeVpExt;
	VERIFY(::GetViewportExtEx(m_hDC, &sizeVpExt));

	// Only interested in Extent Magnitudes, not direction
	if (sizeWinExt.cy < 0)
		sizeWinExt.cy = -sizeWinExt.cy;
	if (sizeVpExt.cy < 0)
		sizeVpExt.cy = -sizeVpExt.cy;

	// Convert to screen device coordinates to eliminate rounding
	// errors as a source of SmallFont aliasing

	cyDesired = MulDiv(cyDesired, sizeVpExt.cy, sizeWinExt.cy);
	cyActual = MulDiv(cyActual, sizeVpExt.cy, sizeWinExt.cy);

	ASSERT(cyDesired >= 0 && cyActual >= 0);

	if (cyDesired < cyActual)
	{
		logFont.lfFaceName[0] = 0;      // let the mapper find a good fit

		if ((logFont.lfPitchAndFamily & 0xf0) == FF_DECORATIVE)
			logFont.lfPitchAndFamily = DEFAULT_PITCH | FF_DECORATIVE;
		else
			logFont.lfPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE;

		HFONT hTempFont = ::CreateFontIndirect(&logFont);
		::SelectObject(m_hDC, hTempFont);           // Select it in.
		::DeleteObject(hNewFont);
		hNewFont = hTempFont;
	}

	AfxDeleteObject((HGDIOBJ*)&m_hFont);  // delete the old logical font
	m_hFont = hNewFont;         // save the new one
}

CFont* CPreviewDC::SelectObject(CFont* pFont)
{
	if (pFont == NULL)
		return NULL;

	ASSERT(m_hAttribDC != NULL);
	ASSERT_VALID(pFont);

	CFont* pOldFont = (CFont*) CGdiObject::FromHandle(
				::SelectObject(m_hAttribDC, pFont->m_hObject));

	// If same as already selected, don't re-mirror screen font
	if (m_hPrinterFont != pFont->m_hObject)
	{
		m_hPrinterFont = (HFONT)pFont->m_hObject;
		MirrorFont();
	}

	return pOldFont;
}

/////////////////////////////////////////////////////////////////////////////
// Drawing-Attribute Functions

COLORREF CPreviewDC::SetBkColor(COLORREF crColor)
{
	ASSERT(m_hAttribDC != NULL);
	if (m_hDC != NULL)
		::SetBkColor(m_hDC, ::GetNearestColor(m_hAttribDC, crColor));
	return ::SetBkColor(m_hAttribDC, crColor);
}

COLORREF CPreviewDC::SetTextColor(COLORREF crColor)
{
	ASSERT(m_hAttribDC != NULL);
	if (m_hDC != NULL)
		::SetTextColor(m_hDC, ::GetNearestColor(m_hAttribDC, crColor));
	return ::SetTextColor(m_hAttribDC, crColor);
}

int CPreviewDC::SetMapMode(int nMapMode)
{
	ASSERT(m_hAttribDC != NULL);
	int nModeOld = ::SetMapMode(m_hAttribDC, nMapMode);
	MirrorMappingMode(TRUE);
	return nModeOld;
}

CPoint CPreviewDC::SetViewportOrg(int x, int y)
{
	ASSERT(m_hAttribDC != NULL);
	CPoint ptOrgOld;
	VERIFY(::SetViewportOrgEx(m_hAttribDC, x, y, &ptOrgOld));
	MirrorViewportOrg();
	return ptOrgOld;
}

CPoint CPreviewDC::OffsetViewportOrg(int nWidth, int nHeight)
{
	ASSERT(m_hAttribDC != NULL);
	CPoint ptOrgOld;
	VERIFY(::OffsetViewportOrgEx(m_hAttribDC, nWidth, nHeight, &ptOrgOld));
	MirrorViewportOrg();
	return ptOrgOld;
}

CSize CPreviewDC::SetViewportExt(int x, int y)
{
	ASSERT(m_hAttribDC != NULL);
	CSize sizeExtOld;
	VERIFY(::SetViewportExtEx(m_hAttribDC, x, y, &sizeExtOld));
	MirrorMappingMode(TRUE);
	return sizeExtOld;
}

CSize CPreviewDC::ScaleViewportExt(int xNum, int xDenom, int yNum, int yDenom)
{
	ASSERT(m_hAttribDC != NULL);
	CSize sizeExtOld;
	VERIFY(::ScaleViewportExtEx(m_hAttribDC, xNum, xDenom,
		yNum, yDenom, &sizeExtOld));
	MirrorMappingMode(TRUE);
	return sizeExtOld;
}

CSize CPreviewDC::SetWindowExt(int x, int y)
{
	ASSERT(m_hAttribDC != NULL);
	CSize sizeExtOld;
	VERIFY(::SetWindowExtEx(m_hAttribDC, x, y, &sizeExtOld));
	MirrorMappingMode(TRUE);
	return sizeExtOld;
}

CSize CPreviewDC::ScaleWindowExt(int xNum, int xDenom, int yNum, int yDenom)
{
	ASSERT(m_hAttribDC != NULL);
	CSize sizeExtOld;
	VERIFY(::ScaleWindowExtEx(m_hAttribDC, xNum, xDenom, yNum, yDenom,
		&sizeExtOld));
	MirrorMappingMode(TRUE);
	return sizeExtOld;
}

/////////////////////////////////////////////////////////////////////////////
// Text Functions

// private helpers for TextOut functions

AFX_STATIC int AFXAPI _AfxComputeNextTab(int x, UINT nTabStops, LPINT lpnTabStops, int nTabOrigin, int nTabWidth)
{
	ENSURE(nTabWidth!=0);
	x -= nTabOrigin;        // normalize position to tab origin
	for (UINT i = 0; i < nTabStops; i++, lpnTabStops++)
	{
		if (*lpnTabStops > x)
        {
			return *lpnTabStops + nTabOrigin;
        }
	}
	return (x / nTabWidth + 1) * nTabWidth + nTabOrigin;
}

// Compute a character delta table for correctly positioning the screen
// font characters where the printer characters will appear on the page
CSize CPreviewDC::ComputeDeltas(int& x, LPCTSTR lpszString, UINT &nCount,
	BOOL bTabbed, UINT nTabStops, LPINT lpnTabStops, int nTabOrigin,
	_Pre_notnull_ _Post_z_ LPTSTR lpszOutputString, int* pnDxWidths, int& nRightFixup)
{
	ASSERT_VALID(this);

	TEXTMETRIC tmAttrib;
	TEXTMETRIC tmScreen;
	::GetTextMetrics(m_hAttribDC, &tmAttrib);
	::GetTextMetrics(m_hDC, &tmScreen);

	CSize sizeExtent;
	::GetTextExtentPoint32W(m_hAttribDC, L"A", 1, &sizeExtent);

	CPoint ptCurrent;
	UINT nAlignment = ::GetTextAlign(m_hAttribDC);
	BOOL bUpdateCP = (nAlignment & TA_UPDATECP) != 0;
	if (bUpdateCP)
	{
		::GetCurrentPositionEx(m_hDC, &ptCurrent);
		x = ptCurrent.x;
	}

	LPCTSTR lpszCurChar = lpszString;
	LPCTSTR lpszStartRun = lpszString;
	int* pnCurDelta = pnDxWidths;
	int nStartRunPos = x;
	int nCurrentPos = x;
	int nStartOffset = 0;

	int nTabWidth = 0;
	if (bTabbed)
	{
		if (nTabStops == 1)
		{
			nTabWidth = lpnTabStops[0];
		}
		else
		{
			// Get default size of a tab
			nTabWidth = LOWORD(::GetTabbedTextExtentW(m_hAttribDC,
				L"\t", 1, 0, NULL));
		}
	}

	for (UINT i = 0; i < nCount; i++)
	{
		BOOL bSpace = ((_TUCHAR)*lpszCurChar == (_TUCHAR)tmAttrib.tmBreakChar);
		if (bSpace || (bTabbed && *lpszCurChar == '\t'))
		{
			// bSpace will be either TRUE (==1) or FALSE (==0).  For spaces
			// we want the space included in the GetTextExtent, for tabs we
			// do not want the tab included
			int nRunLength = (int)(lpszCurChar - lpszStartRun) + bSpace;

			CSize sizeExtent;
			::GetTextExtentPoint32(m_hAttribDC, lpszStartRun, nRunLength,
				&sizeExtent);
			int nNewPos = nStartRunPos + sizeExtent.cx
				- tmAttrib.tmOverhang;

			// now, if this is a Tab (!bSpace), compute the next tab stop
			if (!bSpace)
			{
				nNewPos = _AfxComputeNextTab(nNewPos, nTabStops, lpnTabStops,
								nTabOrigin, nTabWidth);
			}

			// Add this width to previous width
			if (pnCurDelta == pnDxWidths)
				nStartOffset += nNewPos - nCurrentPos;
			else
				*(pnCurDelta-1) += nNewPos - nCurrentPos;

			nCurrentPos = nNewPos;

			nStartRunPos = nCurrentPos;     // set start of run
			// *lpszCurChar must be SBC: tmBreakChar or '\t'
			lpszStartRun = lpszCurChar + 1;
		}
		else
		{
			// For the non-tabbed or non-tab-character case
			int cxScreen;
			if (_istlead(*lpszCurChar) && i+1 < nCount)
			{
				SIZE size;
				if (::GetTextExtentPoint(m_hDC, lpszCurChar, 2, &size))
					cxScreen = size.cx /2;   // average of the 2 chars
				else
					cxScreen = tmScreen.tmAveCharWidth; // revert to default average

				if (::GetTextExtentPoint(m_hAttribDC, lpszCurChar, 2, &size))
					*pnCurDelta = size.cx /2; // average of the 2 chars
				else
					*pnCurDelta = tmAttrib.tmAveCharWidth; // revert to default average
			}
			else
			{
				::GetCharWidth(m_hDC, (_TUCHAR)*lpszCurChar,
					(_TUCHAR)*lpszCurChar, &cxScreen);
				if (!::GetCharWidth(m_hAttribDC, (_TUCHAR)*lpszCurChar,
					(_TUCHAR)*lpszCurChar, pnCurDelta))
				{
					// If printer driver fails the above call, use the average width
					*pnCurDelta = tmAttrib.tmAveCharWidth;
				}
			}
			*pnCurDelta -= tmAttrib.tmOverhang;
			cxScreen -= tmScreen.tmOverhang;
			nCurrentPos += *pnCurDelta;     // update current position

			// Center character in allotted space
			if (pnCurDelta != pnDxWidths)
			{
				int diff = (*pnCurDelta - cxScreen) / 2;
				*pnCurDelta -= diff;
				*(pnCurDelta - 1) += diff;
			}
			*lpszOutputString++ = *lpszCurChar;
			if (_istlead(*lpszCurChar) && i+1 < nCount)
			{
				*lpszOutputString++ = *(lpszCurChar+1); // copy trailing byte
				*(pnCurDelta + 1) = *pnCurDelta;        // double wide
				nCurrentPos += *pnCurDelta;
				pnCurDelta++;
				i++;
			}
			pnCurDelta++;
		}
		lpszCurChar = _tcsinc(lpszCurChar);
	}

	nAlignment &= TA_CENTER|TA_RIGHT;
	sizeExtent.cx = nCurrentPos - x;
	nRightFixup = 0;

	if (nAlignment == TA_LEFT)
		x += nStartOffset;      // Full left side adjustment
	else if (nAlignment == TA_CENTER)
		x += nStartOffset/2;    // Adjust Center by 1/2 left side adjustment
	else if (nAlignment == TA_RIGHT)
		nRightFixup = nStartOffset; // Right adjust needed later if TA_UPDATECP

	if (bUpdateCP)
		::MoveToEx(m_hDC, x, ptCurrent.y, NULL);

	nCount = (UINT)(pnCurDelta - pnDxWidths);   // number of characters output
	return sizeExtent;
}

BOOL CPreviewDC::TextOut(int x, int y, LPCTSTR lpszString, int nCount)
{
	return ExtTextOut(x, y, 0, NULL, lpszString, nCount, NULL);
}

BOOL CPreviewDC::ExtTextOut(int x, int y, UINT nOptions, LPCRECT lpRect,
	LPCTSTR lpszString, UINT nCount, LPINT lpDxWidths)
{
	ASSERT(m_hDC != NULL);
	ASSERT(m_hAttribDC != NULL);
	ASSERT(lpszString != NULL);
	ASSERT(lpDxWidths == NULL ||
			AfxIsValidAddress(lpDxWidths, sizeof(int) * nCount, FALSE));
	ASSERT(AfxIsValidAddress(lpszString, nCount, FALSE));

	::ATL::CAutoVectorPtr<int> spDeltas;
	::ATL::CAutoVectorPtr<TCHAR> spOutputString;
	int nRightFixup = 0;

	if (lpDxWidths == NULL)
	{
		if (nCount == 0)    // Do nothing
			return TRUE;

		if(	!spDeltas.Allocate(nCount) || 
			!spOutputString.Allocate(nCount)
			)
		{
			return FALSE;
		}

		ComputeDeltas(x, (LPTSTR)lpszString, nCount, FALSE, 0, NULL, 0,
										spOutputString, spDeltas, nRightFixup);

		lpDxWidths = spDeltas;
		lpszString = spOutputString;
	}

	BOOL bSuccess = ::ExtTextOut(m_hDC, x, y, nOptions, lpRect, lpszString,
														nCount, lpDxWidths);
	if (nRightFixup != 0 && bSuccess && (GetTextAlign() & TA_UPDATECP))
	{
		CPoint pt;
		::GetCurrentPositionEx(m_hDC, &pt);
		MoveTo(pt.x - nRightFixup, pt.y);
	}

	return bSuccess;
}

CSize CPreviewDC::TabbedTextOut(int x, int y, LPCTSTR lpszString, int nCount,
	int nTabPositions, LPINT lpnTabStopPositions, int nTabOrigin)
{
	ASSERT(m_hAttribDC != NULL);
	ASSERT(m_hDC != NULL);
	ASSERT(lpszString != NULL);
	ASSERT(AfxIsValidAddress(lpszString, nCount, FALSE));
	ASSERT(lpnTabStopPositions == NULL ||
			AfxIsValidAddress(lpnTabStopPositions, sizeof(int) * nTabPositions,
				FALSE));

	if (nCount <= 0)
		return 0;         // nCount is zero, there is nothing to print

	int nRightFixup;

	::ATL::CAutoVectorPtr<int> spDeltas;
	::ATL::CAutoVectorPtr<TCHAR> spOutputString;
	if(	!spDeltas.Allocate(nCount) || 
		!spOutputString.Allocate(nCount)
		)
	{
		return 0;
	}

	UINT uCount = nCount;
	CSize sizeFinalExtent = ComputeDeltas(x, lpszString, uCount, TRUE,
							nTabPositions, lpnTabStopPositions, nTabOrigin,
							spOutputString, spDeltas, nRightFixup);

	BOOL bSuccess = ExtTextOut(x, y, 0, NULL, spOutputString, uCount, spDeltas);

	if (bSuccess && (GetTextAlign() & TA_UPDATECP))
	{
		CPoint pt;
		::GetCurrentPositionEx(m_hDC, &pt);
		MoveTo(pt.x - nRightFixup, pt.y);
	}

	return sizeFinalExtent;
}

// This one is too complicated to do character-by-character output positioning
// All we really need to do here is mirror the current position
int CPreviewDC::DrawText(LPCTSTR lpszString, int nCount, LPRECT lpRect,
	UINT nFormat)
{
	ASSERT(m_hAttribDC != NULL);
	ASSERT(m_hDC != NULL);
	ASSERT(lpszString != NULL);
	ASSERT(lpRect != NULL);
	ASSERT(AfxIsValidAddress(lpRect, sizeof(RECT)));
	ASSERT(nCount == -1 ?
		AfxIsValidString(lpszString) :
		AfxIsValidAddress(lpszString, nCount, FALSE));

	int retVal = ::DrawText(m_hDC, lpszString, nCount, lpRect, nFormat);

	CPoint pos;
	::GetCurrentPositionEx(m_hDC, &pos);
	::MoveToEx(m_hAttribDC, pos.x, pos.y, NULL);
	return retVal;
}

int CPreviewDC::DrawTextEx(_In_count_(nCount) LPTSTR lpszString, int nCount, LPRECT lpRect,
	UINT nFormat, LPDRAWTEXTPARAMS lpDTParams)
{
	ASSERT(m_hAttribDC != NULL);
	ASSERT(m_hDC != NULL);
	ASSERT(lpszString != NULL);
	ASSERT(lpRect != NULL);
	ASSERT(AfxIsValidAddress(lpRect, sizeof(RECT)));
	ASSERT(nCount == -1 ?
		AfxIsValidString(lpszString) :
		AfxIsValidAddress(lpszString, nCount, FALSE));

	int retVal = ::DrawTextEx(m_hDC, lpszString, nCount, lpRect, nFormat, lpDTParams);

	CPoint pos;
	::GetCurrentPositionEx(m_hDC, &pos);
	::MoveToEx(m_hAttribDC, pos.x, pos.y, NULL);
	return retVal;
}

BOOL CPreviewDC::GrayString(CBrush*,
				BOOL (CALLBACK *)(HDC, LPARAM, int),
					LPARAM lpData, int nCount, int x, int y, int, int)
{
	TRACE(traceAppMsg, 0, "TextOut() substituted for GrayString() in Print Preview.\n");
	return TextOut(x, y, (LPCTSTR)lpData, nCount);
}

int CPreviewDC::Escape(int nEscape, int nCount, LPCSTR lpszInData, void* lpOutData)
{
	// The tact here is to NOT allow any of the document control escapes
	// to be passed through.  Elimination of StartDoc and EndDoc should
	// eliminate anything actually going to the printer.  Also anything
	// that actually draws something will be filtered.

	ASSERT(m_hAttribDC != NULL);

	switch (nEscape)
	{
	case NEXTBAND:
	case SETCOLORTABLE:
	case GETCOLORTABLE:
	case FLUSHOUTPUT:
	case DRAFTMODE:
	case QUERYESCSUPPORT:
	case GETPHYSPAGESIZE:
	case GETPRINTINGOFFSET:
	case GETSCALINGFACTOR:
	case GETPENWIDTH:
	case SETCOPYCOUNT:
	case SELECTPAPERSOURCE:
	case GETTECHNOLOGY:
	case SETLINECAP:
	case SETLINEJOIN:
	case SETMITERLIMIT:
	case BANDINFO:
	case GETVECTORPENSIZE:
	case GETVECTORBRUSHSIZE:
	case ENABLEDUPLEX:
	case GETSETPAPERBINS:
	case GETSETPRINTORIENT:
	case ENUMPAPERBINS:
	case SETDIBSCALING:
	case ENUMPAPERMETRICS:
	case GETSETPAPERMETRICS:
	case GETEXTENDEDTEXTMETRICS:
	case GETEXTENTTABLE:
	case GETPAIRKERNTABLE:
	case GETTRACKKERNTABLE:
	case ENABLERELATIVEWIDTHS:
	case ENABLEPAIRKERNING:
	case SETKERNTRACK:
	case SETALLJUSTVALUES:
	case SETCHARSET:
	case SET_BACKGROUND_COLOR:
	case SET_SCREEN_ANGLE:
	case SET_SPREAD:
		return ::Escape(m_hAttribDC, nEscape, nCount, lpszInData, lpOutData);

	default:
		return 0;
	}
}

void CPreviewDC::MirrorMappingMode(BOOL bCompute)
{
	ASSERT(m_hAttribDC != NULL);
	if (bCompute)
	{
		//
		// The following formula is used to compute the screen's viewport extent
		// From the printer and screen information and the Printer's Viewport
		// Extents.  (Note:  This formula is used twice, once for horizontal
		// and once for vertical)
		//
		// It is assumed that the Window Extents are maintained as equal.
		//
		//                  m * LogPixPerInch(Screen) * VpExt(Printer)
		// VpExt(Screen) = -------------------------------------------------
		//                          n * LogPixPerInch(Printer)
		//
		// Where m/n is the scaling factor.  (m/n > 1 is expansion)
		//

		VERIFY(::GetViewportExtEx(m_hAttribDC, &m_sizeVpExt));
		VERIFY(::GetWindowExtEx(m_hAttribDC, &m_sizeWinExt));

		while (m_sizeWinExt.cx > -0x4000 && m_sizeWinExt.cx < 0x4000 &&
			   m_sizeVpExt.cx  > -0x4000 && m_sizeVpExt.cx  < 0x4000)
		{
			m_sizeWinExt.cx <<= 1;
			m_sizeVpExt.cx  <<= 1;
		}

		while (m_sizeWinExt.cy > -0x4000 && m_sizeWinExt.cy < 0x4000 &&
			   m_sizeVpExt.cy  > -0x4000 && m_sizeVpExt.cy  < 0x4000)
		{
			m_sizeWinExt.cy <<= 1;
			m_sizeVpExt.cy  <<= 1;
		}

		long lTempExt = _AfxMultMultDivDiv(m_sizeVpExt.cx,
			m_nScaleNum, afxData.cxPixelsPerInch,
			m_nScaleDen, ::GetDeviceCaps(m_hAttribDC, LOGPIXELSX));

		ASSERT(m_sizeWinExt.cx != 0);
		m_sizeVpExt.cx = (int)lTempExt;

		lTempExt = _AfxMultMultDivDiv(m_sizeVpExt.cy,
			m_nScaleNum, afxData.cyPixelsPerInch,
			m_nScaleDen, ::GetDeviceCaps(m_hAttribDC, LOGPIXELSY));

		ASSERT(m_sizeWinExt.cy != 0);
		m_sizeVpExt.cy = (int)lTempExt;
	}

	if (m_hDC != NULL)
	{
		::SetMapMode(m_hDC, MM_ANISOTROPIC);
		::SetWindowExtEx(m_hDC, m_sizeWinExt.cx, m_sizeWinExt.cy, NULL);
		::SetViewportExtEx(m_hDC, m_sizeVpExt.cx, m_sizeVpExt.cy, NULL);

		// Now that the Logical Units are synchronized, we can set the Viewport Org
		MirrorViewportOrg();
	}
}

void CPreviewDC::MirrorViewportOrg()
{
	if (m_hAttribDC == NULL || m_hDC == NULL)
		return;

	CPoint ptVpOrg;
	VERIFY(::GetViewportOrgEx(m_hAttribDC, &ptVpOrg));
	PrinterDPtoScreenDP(&ptVpOrg);
	ptVpOrg += m_sizeTopLeft;
	::SetViewportOrgEx(m_hDC, ptVpOrg.x, ptVpOrg.y, NULL);

	CPoint ptWinOrg;
	VERIFY(::GetWindowOrgEx(m_hAttribDC, &ptWinOrg));
	::SetWindowOrgEx(m_hDC, ptWinOrg.x, ptWinOrg.y, NULL);
}

void CPreviewDC::SetTopLeftOffset(CSize sizeTopLeft)
{
	ASSERT(m_hAttribDC != NULL);
	m_sizeTopLeft = sizeTopLeft;
	MirrorViewportOrg();
}

void CPreviewDC::ClipToPage()
{
	ASSERT(m_hAttribDC != NULL);
	ASSERT(m_hDC != NULL);
	// Create a rect in Screen Device coordinates that is one pixel larger
	// on all sides than the actual page.  This is to hide the fact that
	// the printer to screen mapping mode is approximate and may result
	// in rounding error.

	CPoint pt(::GetDeviceCaps(m_hAttribDC, HORZRES),
				::GetDeviceCaps(m_hAttribDC, VERTRES));
	PrinterDPtoScreenDP(&pt);

	// Set the screen dc to MM_TEXT and no WindowOrg for the interesection

	::SetMapMode(m_hDC, MM_TEXT);
	::SetWindowOrgEx(m_hDC, 0, 0, NULL);
	::SetViewportOrgEx(m_hDC, m_sizeTopLeft.cx, m_sizeTopLeft.cy, NULL);
	::IntersectClipRect(m_hDC, -1, -1, pt.x + 2, pt.y + 2);

	// Resynchronize the mapping mode
	MirrorMappingMode(FALSE);
}

// these conversion functions can be used without an attached screen DC

void CPreviewDC::PrinterDPtoScreenDP(LPPOINT lpPoint) const
{
	ASSERT(m_hAttribDC != NULL);

	CSize sizePrinterVpExt;
	VERIFY(::GetViewportExtEx(m_hAttribDC, &sizePrinterVpExt));
	CSize sizePrinterWinExt;
	VERIFY(::GetWindowExtEx(m_hAttribDC, &sizePrinterWinExt));

	long xScreen = _AfxMultMultDivDiv(lpPoint->x,
		sizePrinterWinExt.cx, m_sizeVpExt.cx,
		sizePrinterVpExt.cx, m_sizeWinExt.cx);

	lpPoint->x = (int)xScreen;

	long yScreen = _AfxMultMultDivDiv(lpPoint->y,
		sizePrinterWinExt.cy, m_sizeVpExt.cy,
		sizePrinterVpExt.cy, m_sizeWinExt.cy);

	lpPoint->y = (int)yScreen;
}



IMPLEMENT_DYNAMIC(CPreviewDC, CDC)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\dispimpl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// Platform specific defines

#include <afxv_cpu.h>

#ifdef _X86_
#define _STACK_CHAR     long
#define _STACK_SHORT    long
#define _STACK_LONG     long
#define _STACK_LONGLONG __int64
#define _STACK_FLOAT    float
#define _STACK_DOUBLE   double
#define _STACK_PTR      void*
#define _SCRATCH_SIZE   16
#define _STACK_OFFSET   0
#define _STACK_MIN      0
#endif

#ifdef _AMD64_
#define _ALIGN_STACKPOINTER	16
#define _ALIGN_STACK	8
#define _STACK_CHAR		__int64
#define _STACK_SHORT	__int64
#define _STACK_INT      __int64
#define _STACK_LONG     __int64
#define _STACK_LONGLONG	__int64
#define _STACK_FLOAT    float
#define _STACK_DOUBLE   double
#define _STACK_PTR      void*
#define _SCRATCH_SIZE   32
#define _STACK_OFFSET   0
#define _STACK_MIN      0
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\dbview.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "sal.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP(CRecordView, CFormView)
	//{{AFX_MSG_MAP(CRecordView)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
	ON_COMMAND_EX(ID_RECORD_FIRST, &CRecordView::OnMove)
	ON_UPDATE_COMMAND_UI(ID_RECORD_FIRST, &CRecordView::OnUpdateRecordFirst)
	ON_COMMAND_EX(ID_RECORD_PREV, &CRecordView::OnMove)
	ON_UPDATE_COMMAND_UI(ID_RECORD_PREV, &CRecordView::OnUpdateRecordPrev)
	ON_COMMAND_EX(ID_RECORD_NEXT, &CRecordView::OnMove)
	ON_UPDATE_COMMAND_UI(ID_RECORD_NEXT, &CRecordView::OnUpdateRecordNext)
	ON_COMMAND_EX(ID_RECORD_LAST, &CRecordView::OnMove)
	ON_UPDATE_COMMAND_UI(ID_RECORD_LAST, &CRecordView::OnUpdateRecordLast)
END_MESSAGE_MAP()


CRecordView::CRecordView(LPCTSTR lpszTemplateName)
	: CFormView(lpszTemplateName)
{
}

CRecordView::CRecordView(UINT nIDTemplate)
	: CFormView(nIDTemplate)
{
}

CRecordView::~CRecordView()
{
}

void CRecordView::OnInitialUpdate()
{
	CRecordset* pRecordset = OnGetRecordset();
	// recordset must be allocated already
	ASSERT(pRecordset != NULL);

	if (!pRecordset->IsOpen())
	{
		CWaitCursor wait;
		pRecordset->Open();
	}

	CFormView::OnInitialUpdate();
}

BOOL CRecordView::IsOnFirstRecord()
{
	ASSERT_VALID(this);
	CRecordsetStatus status;
	OnGetRecordset()->GetStatus(status);
	return status.m_lCurrentRecord == 0;
}

BOOL CRecordView::IsOnLastRecord()
{
	ASSERT_VALID(this);
	CRecordset* pRecordset = OnGetRecordset();
	CRecordsetStatus status;
	pRecordset->GetStatus(status);
	if (!status.m_bRecordCountFinal)
		return FALSE;
	return ((status.m_lCurrentRecord+1 == pRecordset->GetRecordCount()));
}

BOOL CRecordView::OnMove(UINT nIDMoveCommand)
{
	CRecordset* pSet = OnGetRecordset();
	if (pSet->CanUpdate() && !pSet->IsDeleted())
	{
		pSet->Edit();
		if (!UpdateData())
			return TRUE;

		pSet->Update();
	}

	switch (nIDMoveCommand)
	{
		case ID_RECORD_PREV:
			pSet->MovePrev();
			if (!pSet->IsBOF())
				break;

		case ID_RECORD_FIRST:
			pSet->MoveFirst();
			break;

		case ID_RECORD_NEXT:
			pSet->MoveNext();
			if (!pSet->IsEOF())
				break;
			if (!pSet->CanScroll())
			{
				// clear out screen since we're sitting on EOF
				pSet->SetFieldNull(NULL);
				break;
			}

		case ID_RECORD_LAST:
			pSet->MoveLast();
			break;

		default:
			// Unexpected case value
			ASSERT(FALSE);
	}

	// Show results of move operation
	UpdateData(FALSE);
	return TRUE;
}

void CRecordView::OnUpdateRecordFirst(CCmdUI* pCmdUI)
{
	CRecordset* prs = OnGetRecordset();

	// enable if opened, can scroll backwards,
	pCmdUI->Enable(prs->IsOpen() && prs->CanScroll() &&
		// >= 1 records present and not already on first record
		!(prs->IsEOF() && prs->IsBOF()) && !IsOnFirstRecord());
}

void CRecordView::OnUpdateRecordPrev(CCmdUI* pCmdUI)
{
	CRecordView::OnUpdateRecordFirst(pCmdUI);
}

void CRecordView::OnUpdateRecordNext(CCmdUI* pCmdUI)
{
	CRecordset* prs = OnGetRecordset();

	// enable if opened and >= 1 records present
	pCmdUI->Enable(prs->IsOpen() && !(prs->IsEOF() && prs->IsBOF())
		// and not already on last record
		&& !IsOnLastRecord());
}

void CRecordView::OnUpdateRecordLast(CCmdUI* pCmdUI)
{
	CRecordset* prs = OnGetRecordset();

	// enable if opened, can scroll,
	pCmdUI->Enable(prs->IsOpen() && prs->CanScroll() &&
		// >= 1 records present and not already on last record
		!(prs->IsEOF() && prs->IsBOF()) && !IsOnLastRecord());
}



/////////////////////////////////////////////////////////////////////////////
// DDX Cover functions for use with fields of a recordset

/////////////////////////////////////////////////////////////////////////////
// Simple field formatting to text item

BOOL AFXAPI AfxFieldText(CDataExchange* pDX, int nIDC, void* pv,
	CRecordset* pRecordset)
{
	ASSERT_VALID(pRecordset);

	HWND hWndCtrl = pDX->PrepareEditCtrl(nIDC);
	TCHAR szT[2];
	if (pDX->m_bSaveAndValidate)
	{
		::GetWindowText(hWndCtrl, szT, _countof(szT));
		if (szT[0] == '\0')
		{
			if (pRecordset->IsFieldNullable(pv))
			{
				pRecordset->SetFieldNull(pv);
				return TRUE;
			}
		}
		else
			pRecordset->SetFieldNull(pv, FALSE);
	}
	else
	{
		if (!pRecordset->IsOpen() || pRecordset->IsFieldNull(pv))
		{
			szT[0] = '\0';
			AfxSetWindowText(hWndCtrl, szT);
			return TRUE;
		}
		else if (pRecordset->IsDeleted())
		{
			CString strDeleted(MAKEINTRESOURCE(AFX_IDS_DELETED));
			AfxSetWindowText(hWndCtrl, strDeleted);
			return TRUE;
		}
	}
	return FALSE;
}

void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, int& value,
	CRecordset* pRecordset)
{
	if (!AfxFieldText(pDX, nIDC, &value, pRecordset))
		DDX_Text(pDX, nIDC, value);
}

void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, BYTE& value,
	CRecordset* pRecordset)
{
	if (!AfxFieldText(pDX, nIDC, &value, pRecordset))
		DDX_Text(pDX, nIDC, value);
}

void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, UINT& value,
	CRecordset* pRecordset)
{
	if (!AfxFieldText(pDX, nIDC, &value, pRecordset))
		DDX_Text(pDX, nIDC, value);
}

void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, long& value,
	CRecordset* pRecordset)
{
	if (!AfxFieldText(pDX, nIDC, &value, pRecordset))
		DDX_Text(pDX, nIDC, value);
}

void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, DWORD& value,
	CRecordset* pRecordset)
{
	if (!AfxFieldText(pDX, nIDC, &value, pRecordset))
		DDX_Text(pDX, nIDC, value);
}

void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, CString& value,
	CRecordset* pRecordset)
{
	ASSERT_VALID(pRecordset);
	HWND hWndCtrl = pDX->PrepareEditCtrl(nIDC);
	if (pDX->m_bSaveAndValidate)
	{
		// check if length is too long (this is complicated by Windows NT/J)
		int nLen = ::GetWindowTextLength(hWndCtrl);
		if (nLen > value.GetAllocLength())
		{
			if (!_afxDBCS)
				AfxFailMaxChars(pDX, value.GetAllocLength());
			CString strTemp;
			::GetWindowText(hWndCtrl, strTemp.GetBuffer(nLen), nLen+1);
			strTemp.ReleaseBuffer();
			nLen = strTemp.GetLength();
			if (nLen > value.GetAllocLength())
				AfxFailMaxChars(pDX, value.GetAllocLength());
		}
		// get known length
		::GetWindowText(hWndCtrl, value.GetBuffer(0), nLen+1);
		value.ReleaseBuffer();
		if (nLen == 0)
		{
			if (pRecordset->IsFieldNullable(&value))
				pRecordset->SetFieldNull(&value, TRUE);
		}
		else
		{
			pRecordset->SetFieldNull(&value, FALSE);
		}
	}
	else if (pRecordset->IsDeleted())
	{
		CString strDeleted(MAKEINTRESOURCE(AFX_IDS_DELETED));
		AfxSetWindowText(hWndCtrl, strDeleted);
	}
	else
	{
		AfxSetWindowText(hWndCtrl, value);
	}
}

void AFXAPI DDX_FieldText(_In_ CDataExchange* pDX, _In_ int nIDC, _Out_z_cap_(nMaxLen) LPTSTR pstrValue,
	_In_ int nMaxLen, _In_ CRecordset* pRecordset)
{
	ASSERT_VALID(pRecordset);
	HWND hWndCtrl = pDX->PrepareEditCtrl(nIDC);
	if (pDX->m_bSaveAndValidate)
	{
		int nLen = ::GetWindowText(hWndCtrl, pstrValue, nMaxLen);

		if (nLen == 0)
		{
			if (pRecordset->IsFieldNullable(pstrValue))
				pRecordset->SetFieldNull(pstrValue, TRUE);
		}
		else
			pRecordset->SetFieldNull(pstrValue, FALSE);
	}
	else if (pRecordset->IsDeleted())
	{
		CString strDeleted(MAKEINTRESOURCE(AFX_IDS_DELETED));
		AfxSetWindowText(hWndCtrl, strDeleted);
	}
	else
		AfxSetWindowText(hWndCtrl, pstrValue);
}

void AFXAPI DDX_FieldLBString(CDataExchange* pDX, int nIDC, CString& value,
	CRecordset* pRecordset)
{
	ASSERT_VALID(pRecordset);

	HWND hWndCtrl = pDX->PrepareCtrl(nIDC);
	if (pDX->m_bSaveAndValidate)
	{
		int nIndex = (int)::SendMessage(hWndCtrl, LB_GETCURSEL, 0, 0L);
		if (nIndex != -1)
		{
			int nLen = (int)::SendMessage(hWndCtrl, LB_GETTEXTLEN, nIndex, 0L);
			if (nLen > value.GetAllocLength())
				AfxFailMaxChars(pDX, value.GetAllocLength());
			::SendMessage(hWndCtrl, LB_GETTEXT, nIndex,
					(LPARAM)(LPSTR)value.GetBuffer(0));
			if (nLen == 0)
			{
				if (pRecordset->IsFieldNullable(&value))
					pRecordset->SetFieldNull(&value, TRUE);
			}
			else
			{
				pRecordset->SetFieldNull(&value, FALSE);
			}
			value.ReleaseBuffer();
		}
		else
		{
			// no selection
			value.GetBufferSetLength(0);
			if (pRecordset->IsFieldNullable(&value))
				pRecordset->SetFieldNull(&value);
		}
	}
	else
	{
		if (!pRecordset->IsOpen() || pRecordset->IsFieldNull(&value))
		{
			SendMessage(hWndCtrl, LB_SETCURSEL, (WPARAM)-1, 0L);
		}
		else
		{
			// set current selection based on data string
			if (::SendMessage(hWndCtrl, LB_SELECTSTRING, (WPARAM)-1,
			  (LPARAM)(LPCTSTR)value) == LB_ERR)
			{
				// no selection match
				TRACE(traceDatabase, 0, "Warning: no listbox item selected.\n");
			}
		}
	}
}

void AFXAPI DDX_FieldLBStringExact(CDataExchange* pDX, int nIDC, CString& value,
	CRecordset* pRecordset)
{
	ASSERT_VALID(pRecordset);

	HWND hWndCtrl = pDX->PrepareCtrl(nIDC);
	if (pDX->m_bSaveAndValidate)
	{
		DDX_FieldLBString(pDX, nIDC, value, pRecordset);
	}
	else
	{
		if (!pRecordset->IsOpen() || pRecordset->IsFieldNull(&value))
		{
			SendMessage(hWndCtrl, LB_SETCURSEL, (WPARAM)-1, 0L);
		}
		else
		{
			// set current selection based on data string
			int i = (int)::SendMessage(hWndCtrl, LB_FINDSTRINGEXACT, (WPARAM)-1,
			  (LPARAM)(LPCTSTR)value);
			if (i < 0)
			{
				// no selection match
				TRACE(traceDatabase, 0, "Warning: no listbox item selected.\n");
			}
			else
			{
				// select it
				SendMessage(hWndCtrl, LB_SETCURSEL, i, 0L);
			}
		}
	}
}

void AFXAPI DDX_FieldLBIndex(CDataExchange* pDX, int nIDC, int& index,
	CRecordset* pRecordset)
{
	ASSERT_VALID(pRecordset);

	if (!pDX->m_bSaveAndValidate &&
		(!pRecordset->IsOpen() || pRecordset->IsFieldNull(&index)))
	{
		int nIndex = 0;
		DDX_LBIndex(pDX, nIDC, nIndex);
	}
	else
		DDX_LBIndex(pDX, nIDC, index);
}

void AFXAPI DDX_FieldCBString(CDataExchange* pDX, int nIDC, CString& value,
	CRecordset* pRecordset)
{
	ASSERT_VALID(pRecordset);

	HWND hWndCtrl = pDX->PrepareCtrl(nIDC);
	if (pDX->m_bSaveAndValidate)
	{
		// just get current edit item text (or drop list static)
		int nLen = ::GetWindowTextLength(hWndCtrl);
		if (nLen != -1)
		{
			CString strTemp;
			::GetWindowText(hWndCtrl, strTemp.GetBuffer(nLen), nLen+1);
			strTemp.ReleaseBuffer();
			nLen = strTemp.GetLength();
			if (nLen > value.GetAllocLength())
				AfxFailMaxChars(pDX, value.GetAllocLength());
			// get known length
			::GetWindowText(hWndCtrl, value.GetBuffer(0), nLen+1);
		}
		else
		{
			// for drop lists GetWindowTextLength does not work - assume
			//  preallocated length
			::GetWindowText(hWndCtrl, value.GetBuffer(0), value.GetAllocLength()+1);
		}
		value.ReleaseBuffer();
		if (value.GetLength() == 0)
		{
			if (pRecordset->IsFieldNullable(&value))
				pRecordset->SetFieldNull(&value, TRUE);
		}
		else
		{
			pRecordset->SetFieldNull(&value, FALSE);
		}
	}
	else
	{
		if (!pRecordset->IsOpen() || pRecordset->IsFieldNull(&value))
		{
			SendMessage(hWndCtrl, CB_SETCURSEL, (WPARAM)-1, 0L);
		}
		else
		{
			// set current selection based on model string
			if (::SendMessage(hWndCtrl, CB_SELECTSTRING, (WPARAM)-1,
				(LPARAM)(LPCTSTR)value) == CB_ERR)
			{
				// just set the edit text (will be ignored if DROPDOWNLIST)
				AfxSetWindowText(hWndCtrl, value);
			}
		}
	}
}

void AFXAPI DDX_FieldCBStringExact(CDataExchange* pDX, int nIDC, CString& value,
	CRecordset* pRecordset)
{
	ASSERT_VALID(pRecordset);

	HWND hWndCtrl = pDX->PrepareCtrl(nIDC);
	if (pDX->m_bSaveAndValidate)
	{
		DDX_FieldCBString(pDX, nIDC, value, pRecordset);
	}
	else
	{
		if (!pRecordset->IsOpen() || pRecordset->IsFieldNull(&value))
		{
			SendMessage(hWndCtrl, CB_SETCURSEL, (WPARAM)-1, 0L);
		}
		else
		{
			// set current selection based on data string
			int i = (int)::SendMessage(hWndCtrl, CB_FINDSTRINGEXACT, (WPARAM)-1,
			  (LPARAM)(LPCTSTR)value);
			if (i < 0)
			{
				// no selection match
				TRACE(traceDatabase, 0, "Warning: no combobox item selected.\n");
			}
			else
			{
				// select it
				SendMessage(hWndCtrl, CB_SETCURSEL, i, 0L);
			}
		}
	}
}

void AFXAPI DDX_FieldCBIndex(CDataExchange* pDX, int nIDC, int& index,
	CRecordset* pRecordset)
{
	ASSERT_VALID(pRecordset);

	if (!pDX->m_bSaveAndValidate &&
		(!pRecordset->IsOpen() || pRecordset->IsFieldNull(&index)))
	{
		int nIndex = 0;
		DDX_CBIndex(pDX, nIDC, nIndex);
	}
	else
		DDX_CBIndex(pDX, nIDC, index);
}

void AFXAPI DDX_FieldScroll(CDataExchange* pDX, int nIDC, int& value,
	CRecordset* pRecordset)
{
	ASSERT_VALID(pRecordset);

	if (!pDX->m_bSaveAndValidate &&
		(!pRecordset->IsOpen() || pRecordset->IsFieldNull(&value)))
	{
		int nValue = 0;
		DDX_Scroll(pDX, nIDC, nValue);
	}
	else
		DDX_Scroll(pDX, nIDC, value);
}

/////////////////////////////////////////////////////////////////////////////
// Data exchange for special controls

void AFXAPI DDX_FieldCheck(CDataExchange* pDX, int nIDC, int& value, CRecordset* pRecordset)
{
	ASSERT_VALID(pRecordset);

	HWND hWndCtrl = pDX->PrepareCtrl(nIDC);
	if (pDX->m_bSaveAndValidate)
	{
		value = (int)::SendMessage(hWndCtrl, BM_GETCHECK, 0, 0L);
		ASSERT(value >= 0 && value <= 2);
		if (value == 2)
		{
			if (pRecordset->IsFieldNullable(&value))
				pRecordset->SetFieldNull(&value);
			else
			{
				TRACE(traceDatabase, 0, "Warning: checkbox value indeterminate and field can't be NULL.\n");
				// Default to unchecked
				value = 0;
			}
		}
	}
	else
	{
		if (!pRecordset->IsOpen() || pRecordset->IsFieldNull(&value))
		{
			int style = ((int)::GetWindowLong(hWndCtrl, GWL_STYLE) & 0xf);
			if ((style == BS_3STATE || style == BS_AUTO3STATE))
				value = 2;
			else
			{
				TRACE(traceDatabase, 0, "Warning: field NULL and checkbox can't be indeterminate.\n");
				// Default to unchecked
				value = 0;
			}
		}
		if (value < 0 || value > 2)
		{
			value = 0;      // default to off
			TRACE(traceDatabase, 0, "Warning: dialog data checkbox value (%d) out of range.\n",
				value);
		}
		::SendMessage(hWndCtrl, BM_SETCHECK, (WPARAM)value, 0L);
	}
}

void AFXAPI DDX_FieldRadio(CDataExchange* pDX, int nIDC, int& value,
	CRecordset* pRecordset)
{
	ASSERT_VALID(pRecordset);

	if (!pDX->m_bSaveAndValidate &&
		(!pRecordset->IsOpen() || pRecordset->IsFieldNull(&value)))
		value = -1;
	DDX_Radio(pDX, nIDC, value);
	if (pDX->m_bSaveAndValidate)
	{
		if (value == -1 && !pRecordset->IsFieldNullable(&value))
		{
			AfxFailRadio(pDX);
		}
		else
		{
			pRecordset->SetFieldNull(&value, (value == -1));
		}
	}
}

/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
void CRecordView::AssertValid() const
{
	CFormView::AssertValid();
}

void CRecordView::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);

	dc << "m_bOnFirstRecord = " << m_bOnFirstRecord;
	dc << "\nm_bOnLastRecord = " << m_bOnLastRecord;

	dc << "\n";
}
#endif

//////////////////////////////////////////////////////////////////////////////
// Inline function declarations expanded out-of-line

#ifndef _AFX_ENABLE_INLINES

#define _AFXDBVIEW_INLINE
#include "afxdb.inl"

#endif


IMPLEMENT_DYNAMIC(CRecordView, CFormView)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\dcmeta.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "sal.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CMetaFileDC

CMetaFileDC::CMetaFileDC()
{
}

void CMetaFileDC::SetOutputDC(HDC)
{
	TRACE(traceAppMsg, 0, "Must use Create() or Get() to set Metafile Output DC.\n");
	ASSERT(FALSE);
}
void CMetaFileDC::ReleaseOutputDC()
{
	TRACE(traceAppMsg, 0, "Must use Close() to release output Metafile DC.\n");
	ASSERT(FALSE);
}

void CMetaFileDC::SetAttribDC(HDC hDC)  // Set the Attribute DC
{
	if (hDC != m_hDC)
		CDC::SetAttribDC(hDC);
	if (m_hDC == m_hAttribDC)   // if we somehow got to this, correct it
		ReleaseAttribDC();
}

CMetaFileDC::~CMetaFileDC()
{
	if (m_hDC != NULL)      // Must be not wanting to keep the metafile
	{
		TRACE(traceAppMsg, 0, "Warning! Destroying CMetaFileDC without closing.\n");
		HMETAFILE hmfTemp = Close();
		::DeleteMetaFile(hmfTemp);
	}
}

/////////////////////////////////////////////////////////////////////////////
// Device-Context Functions

// Clipping Functions
// Normally both Set and Get clipping functions go directly to the output DC
// With metafiles, we must mirror to both DCs and ask the Attribute DC for
// the Get.

int CMetaFileDC::GetClipBox(LPRECT lpRect) const
{
	ASSERT(m_hAttribDC != NULL);
	ENSURE_ARG(AfxIsValidAddress(lpRect, sizeof(RECT)));

	return ::GetClipBox(m_hAttribDC, lpRect);
}

BOOL CMetaFileDC::PtVisible(int x, int y) const
{
	ASSERT(m_hAttribDC != NULL);
	return ::PtVisible(m_hAttribDC, x, y);
}

BOOL CMetaFileDC::RectVisible(LPCRECT) const
{
	ASSERT(m_hAttribDC != NULL);

	return TRUE;    // rect is always visible for metafiles
}

// Text Functions
BOOL CMetaFileDC::TextOut(int x, int y, LPCTSTR lpszString, int nCount)
{
	ASSERT(m_hDC != NULL);
	ASSERT(m_hDC != m_hAttribDC);
	ENSURE_ARG(AfxIsValidAddress(lpszString, nCount, FALSE));

	BOOL bSuccess = ::TextOut(m_hDC, x, y, lpszString, nCount);
	if (bSuccess && m_hAttribDC != NULL && (GetTextAlign() & TA_UPDATECP))
	{
		CSize size = GetTextExtent(lpszString, nCount);
		TEXTMETRIC tm;
		GetTextMetrics(&tm);
		AdjustCP(size.cx - tm.tmOverhang);
	}
	return bSuccess;
}

BOOL CMetaFileDC::ExtTextOut(int x, int y, UINT nOptions, LPCRECT lpRect,
			  LPCTSTR lpszString, UINT nCount, LPINT lpDxWidths)
{
	ASSERT(m_hDC != NULL);
	ASSERT(m_hDC != m_hAttribDC);
	ENSURE_ARG(lpDxWidths == NULL ||
			AfxIsValidAddress(lpDxWidths, sizeof(int) * nCount, FALSE));
	ENSURE_ARG(AfxIsValidAddress(lpszString, nCount, FALSE));

	BOOL bSuccess = ::ExtTextOut(m_hDC, x, y, nOptions, lpRect,
			  lpszString, nCount, lpDxWidths);

	if (bSuccess && m_hAttribDC != NULL && (GetTextAlign() & TA_UPDATECP))
	{
		int nWidth = 0;
		for (UINT i = 0; i < nCount; i++)
			nWidth += *lpDxWidths++;
		AdjustCP(nWidth);
	}
	return bSuccess;
}

CSize CMetaFileDC::TabbedTextOut(int x, int y, LPCTSTR lpszString,
	int nCount, int nTabPositions, LPINT lpnTabStopPositions, int nTabOrigin)
{
	ENSURE(m_hDC != NULL);
	ENSURE(m_hAttribDC != NULL);
	ASSERT(m_hDC != m_hAttribDC);
	ENSURE_ARG(lpszString != NULL);
	if (nCount == -1)
	{
		//Assume string len < 2GB
		size_t uCount=_tcslen(lpszString);
		ENSURE(uCount<INT_MAX); 
		nCount = static_cast<int>(uCount);
	}

	int xStart = x;
	CSize size;
	int cxTabStop = 0;
	int cxDefaultTab = (int)LOWORD(
		::GetTabbedTextExtentW(m_hAttribDC, L"\t", 1, 0, NULL));

	if (!lpnTabStopPositions)
	{
		// no tab stops given, use default tab stop
		cxTabStop = cxDefaultTab;
	}
	else if (nTabPositions == 1)
	{
		// one tab stop given, use it instead of default tab stop
		cxTabStop = lpnTabStopPositions[0];
		if (cxTabStop == 0)
			cxTabStop = 1;
	}

	// write the string out in tab delimited runs
	while (nCount != 0)
	{
		// find next tab character
		LPCTSTR lpszTab = lpszString;
		while (nCount != 0 && *lpszTab != _T('\t') && *lpszTab != _T('\0'))
		{
			if (_istlead(*lpszTab))
				++lpszTab, --nCount;
			++lpszTab;
			--nCount;
		}

		// write the string
		int nChars = int(lpszTab - lpszString);
		::TextOut(m_hDC, x, y, lpszString, nChars);

		// advance by its extent
		CSize size;
		::GetTextExtentPoint32(m_hAttribDC, lpszString, nChars, &size);
		x += size.cx;

		// advance current x co-ordinate based on tab stops
		if (nCount != 0 && *lpszTab != _T('\0'))
		{
			ASSERT(*lpszTab == _T('\t'));
			lpszString = lpszTab + 1;   // skip over the tab
			--nCount;

			// calculate next x position based on tab stops
			if (cxTabStop == 0)
			{
				int i;
				for (i = 0; i < nTabPositions; i++)
				{
					if (x < lpnTabStopPositions[i]+nTabOrigin)
					{
						x = lpnTabStopPositions[i]+nTabOrigin;
						break;
					}
				}
				if (i == nTabPositions)
				{
					// when all out of tab stops, go back to default tab stops
					cxTabStop = cxDefaultTab;
				}
			}
			if (cxTabStop != 0)
			{
				// advance based on single tab stop
				x = ((x - nTabOrigin) / cxTabStop) * cxTabStop +
					cxTabStop + nTabOrigin;
			}
		}
	}

	// adjust the current position
	if (m_hAttribDC != NULL && (GetTextAlign() & TA_UPDATECP))
	{
		TEXTMETRIC tm;
		GetTextMetrics(&tm);
		AdjustCP(x - xStart - tm.tmOverhang);
	}

	// return the extent
	size.cx = x - xStart;
	return size;
}

void CMetaFileDC::AdjustCP(int cx)
{
	if (m_hAttribDC == NULL)
		return;     // do nothing
	UINT nAlign = GetTextAlign() & (TA_LEFT|TA_CENTER|TA_RIGHT);
	if (nAlign == TA_CENTER)
		return;     // Center Alignment does not affect CP
	if (nAlign == TA_RIGHT)
		cx = -cx;

	CPoint point = GetCurrentPosition();
	point.x += cx;
	::MoveToEx(m_hAttribDC, point.x, point.y, NULL);
}

int CMetaFileDC::DrawText(LPCTSTR lpszString, int nCount, LPRECT lpRect,
					UINT nFormat)
{
	ASSERT(m_hDC != NULL);
	ASSERT(m_hDC != m_hAttribDC);
	ENSURE_ARG(lpszString != NULL);
	ENSURE_ARG(lpRect != NULL);
	ASSERT(AfxIsValidAddress(lpRect, sizeof(RECT)));
	ENSURE_ARG(nCount == -1 || AfxIsValidAddress(lpszString, nCount, FALSE));

	int nHeight = ::DrawText(m_hDC, lpszString, nCount, lpRect, nFormat);

	// If adjusting CP:
	if (m_hAttribDC != NULL &&
		(GetTextAlign() & TA_UPDATECP) && ((nFormat & DT_CALCRECT) == 0))
	{
		CRect rect(lpRect->left, lpRect->top, lpRect->right, lpRect->bottom);
		nHeight = ::DrawText(m_hAttribDC, lpszString, nCount, &rect,
			nFormat | DT_CALCRECT | DT_SINGLELINE);
		AdjustCP(rect.Width());
	}

	return nHeight;
}

int CMetaFileDC::DrawTextEx(_In_count_(nCount) LPTSTR lpszString, int nCount, LPRECT lpRect,
					UINT nFormat, LPDRAWTEXTPARAMS lpDTParams)
{
	ASSERT(m_hDC != NULL);
	ASSERT(m_hDC != m_hAttribDC);
	ENSURE_ARG(lpszString != NULL);
	ENSURE_ARG(lpRect != NULL);
	ASSERT(AfxIsValidAddress(lpRect, sizeof(RECT)));
	ENSURE_ARG(nCount == -1 || AfxIsValidAddress(lpszString, nCount, FALSE));

	int nHeight = ::DrawTextEx(m_hDC, lpszString, nCount, lpRect, nFormat, lpDTParams);

	// If adjusting CP:
	if (m_hAttribDC != NULL &&
		(GetTextAlign() & TA_UPDATECP) && ((nFormat & DT_CALCRECT) == 0))
	{
		CRect rect(lpRect->left, lpRect->top, lpRect->right, lpRect->bottom);
		nHeight = ::DrawTextEx(m_hAttribDC, lpszString, nCount, &rect,
			nFormat | DT_CALCRECT | DT_SINGLELINE, lpDTParams);
		AdjustCP(rect.Width());
	}

	return nHeight;
}

// Printer Escape Functions
int CMetaFileDC::Escape(int nEscape, int nCount, LPCSTR lpszInData, LPVOID lpOutData)
{
	ASSERT(m_hDC != NULL);
	ASSERT(m_hDC != m_hAttribDC);
	int nRet = ::Escape(m_hDC, nEscape, nCount, lpszInData, lpOutData);

	if (m_hAttribDC == NULL)
		return nRet;

	// The tact here is to NOT allow any of the document control escapes
	// to be passed through.  Elimination of StartDoc and EndDoc should
	// eliminate anything actually going to the printer.  Also anything
	// that actually draws something will be filtered.
	//

	switch (nEscape)
	{
	case NEXTBAND:
	case SETCOLORTABLE:
	case GETCOLORTABLE:
	case FLUSHOUTPUT:
	case DRAFTMODE:
	case QUERYESCSUPPORT:
	case GETPHYSPAGESIZE:
	case GETPRINTINGOFFSET:
	case GETSCALINGFACTOR:
	case GETPENWIDTH:
	case SETCOPYCOUNT:
	case SELECTPAPERSOURCE:
	case GETTECHNOLOGY:
	case SETLINECAP:
	case SETLINEJOIN:
	case SETMITERLIMIT:
	case BANDINFO:
	case GETVECTORPENSIZE:
	case GETVECTORBRUSHSIZE:
	case ENABLEDUPLEX:
	case GETSETPAPERBINS:
	case GETSETPRINTORIENT:
	case ENUMPAPERBINS:
	case SETDIBSCALING:
	case ENUMPAPERMETRICS:
	case GETSETPAPERMETRICS:
	case GETEXTENDEDTEXTMETRICS:
	case GETEXTENTTABLE:
	case GETPAIRKERNTABLE:
	case GETTRACKKERNTABLE:
	case ENABLERELATIVEWIDTHS:
	case ENABLEPAIRKERNING:
	case SETKERNTRACK:
	case SETALLJUSTVALUES:
	case SETCHARSET:
	case SET_BACKGROUND_COLOR:
	case SET_SCREEN_ANGLE:
	case SET_SPREAD:
		return ::Escape(m_hAttribDC, nEscape, nCount, lpszInData, lpOutData);

	default:
		break;      // return output DC return value
	}

	return nRet;
}

// Viewport origin and Viewport extent overrides
//  (usually, don't modify viewport orgin and extent on the output dc)

CPoint CMetaFileDC::SetViewportOrg(int x, int y)
{
	ASSERT(m_hDC != NULL);
	CPoint point;
	if (m_hAttribDC == NULL)
		::SetViewportOrgEx(m_hDC, x, y, &point);
	else
		::SetViewportOrgEx(m_hAttribDC, x, y, &point);
	return point;
}

CPoint CMetaFileDC::OffsetViewportOrg(int nWidth, int nHeight)
{
	ASSERT(m_hDC != NULL);
	CPoint point;
	if (m_hAttribDC == NULL)
		::OffsetViewportOrgEx(m_hDC, nWidth, nHeight, &point);
	else
		::OffsetViewportOrgEx(m_hAttribDC, nWidth, nHeight, &point);
	return point;
}

CSize CMetaFileDC::SetViewportExt(int x, int y)
{
	ASSERT(m_hDC != NULL);
	CSize size;
	if (m_hAttribDC == NULL)
		::SetViewportExtEx(m_hDC, x, y, &size);
	else
		::SetViewportExtEx(m_hAttribDC, x, y, &size);
	return size;
}

CSize CMetaFileDC::ScaleViewportExt(int xNum, int xDenom, int yNum, int yDenom)
{
	ASSERT(m_hDC != NULL);
	CSize size;
	if (m_hAttribDC == NULL)
		::ScaleViewportExtEx(m_hDC, xNum, xDenom, yNum, yDenom, &size);
	else
		::ScaleViewportExtEx(m_hAttribDC, xNum, xDenom, yNum, yDenom, &size);
	return size;
}


IMPLEMENT_DYNAMIC(CMetaFileDC, CDC)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\dlgclr.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// Choose Color dialog

class _AFX_COLOR_STATE : public CNoTrackObject
{
public:
	// custom colors are held here and saved between calls
	COLORREF m_crSavedCustom[16];

	_AFX_COLOR_STATE();
};

_AFX_COLOR_STATE::_AFX_COLOR_STATE()
{
	// custom colors are initialized to white
	for (int i = 0; i < _countof(m_crSavedCustom); i++)
		m_crSavedCustom[i] = RGB(255, 255, 255);
}

EXTERN_PROCESS_LOCAL(_AFX_COLOR_STATE, _afxClrState)

CColorDialog::CColorDialog(COLORREF clrInit, DWORD dwFlags,
	CWnd* pParentWnd) : CCommonDialog(pParentWnd)
{
	memset(&m_cc, 0, sizeof(m_cc));
	m_nIDHelp = AFX_IDD_COLOR;

	m_cc.lStructSize = sizeof(m_cc);
	m_cc.lpCustColors = GetSavedCustomColors();
	m_cc.Flags = dwFlags | CC_ENABLEHOOK;
	m_cc.lpfnHook = (COMMDLGPROC)_AfxCommDlgProc;

	if ((m_cc.rgbResult = clrInit) != 0)
		m_cc.Flags |= CC_RGBINIT;
}

INT_PTR CColorDialog::DoModal()
{
	ASSERT_VALID(this);
	ASSERT(m_cc.Flags & CC_ENABLEHOOK);
	ASSERT(m_cc.lpfnHook != NULL); // can still be a user hook

	m_cc.hwndOwner = PreModal();
	INT_PTR nResult = ::AfxCtxChooseColor(&m_cc);
	PostModal();
	return nResult ? nResult : IDCANCEL;
}

BOOL CColorDialog::OnColorOK()
{
	ASSERT_VALID(this);
	// Do not call Default() if you override
	return FALSE;
}

void CColorDialog::SetCurrentColor(COLORREF clr)
{
	ASSERT_VALID(this);
	ASSERT(m_hWnd != NULL);

	SendMessage(_afxMsgSETRGB, 0, (DWORD)clr);
}

COLORREF* PASCAL CColorDialog::GetSavedCustomColors()
{
	return &_afxClrState->m_crSavedCustom[0];
}

////////////////////////////////////////////////////////////////////////////
// CColorDialog diagnostics

#ifdef _DEBUG
void CColorDialog::Dump(CDumpContext& dc) const
{
	CDialog::Dump(dc);

	dc << "m_cc.hwndOwner = " << m_cc.hwndOwner;
	dc << "\nm_cc.rgbResult = ";
	dc.DumpAsHex(m_cc.rgbResult);
	dc << "\nm_cc.Flags = ";
	dc.DumpAsHex(m_cc.Flags);
	dc << "\nm_cc.lpCustColors ";

	for (int iClr = 0; iClr < 16; iClr++)
	{
		dc << "\n\t";
		dc.DumpAsHex(m_cc.lpCustColors[iClr]);
	}

	if (m_cc.lpfnHook == (COMMDLGPROC)_AfxCommDlgProc)
		dc << "\nhook function set to standard MFC hook function";
	else
		dc << "\nhook function set to non-standard hook function";

	dc << "\n";
}
#endif //_DEBUG


IMPLEMENT_DYNAMIC(CColorDialog, CCommonDialog)

#pragma warning(disable: 4074)
#pragma init_seg(lib)

PROCESS_LOCAL(_AFX_COLOR_STATE, _afxClrState)

////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\dlgcomm.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include <dlgs.h>



#define new DEBUG_NEW

UINT _afxMsgLBSELCHANGE = 0;
UINT _afxMsgSHAREVI = 0;
UINT _afxMsgFILEOK = 0;
UINT _afxMsgCOLOROK = 0;
UINT _afxMsgHELP = 0;
UINT _afxMsgSETRGB = 0;

BEGIN_MESSAGE_MAP(CCommonDialog, CDialog)
	//{{AFX_MSG_MAP(CCommonDialog)
	ON_WM_HELPINFO()
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

UINT_PTR CALLBACK
_AfxCommDlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	if (hWnd == NULL)
		return 0;

	// If a m_pAlternateWndInit is set, this is the first time we've
	// seend the hWnd given to us in the callback. We'll need to
	// subclass it and reset the m_pAlternateWndInit flag.

	_AFX_THREAD_STATE* pThreadState = _afxThreadState.GetData();
	if (pThreadState->m_pAlternateWndInit != NULL && CWnd::FromHandlePermanent(hWnd) == NULL)
	{
		ASSERT_KINDOF(CFileDialog, pThreadState->m_pAlternateWndInit);
		pThreadState->m_pAlternateWndInit->SubclassWindow(hWnd);
		pThreadState->m_pAlternateWndInit = NULL;
	}

	if (message == WM_INITDIALOG)
	{
		_afxMsgLBSELCHANGE = ::RegisterWindowMessage(LBSELCHSTRING);
		_afxMsgSHAREVI = ::RegisterWindowMessage(SHAREVISTRING);
		_afxMsgFILEOK = ::RegisterWindowMessage(FILEOKSTRING);
		_afxMsgCOLOROK = ::RegisterWindowMessage(COLOROKSTRING);
		_afxMsgHELP = ::RegisterWindowMessage(HELPMSGSTRING);
		_afxMsgSETRGB = ::RegisterWindowMessage(SETRGBSTRING);
		return (UINT)AfxDlgProc(hWnd, message, wParam, lParam);
	}

	if (message == _afxMsgHELP ||
	   (message == WM_COMMAND && LOWORD(wParam) == pshHelp))
	{
		// just translate the message into the AFX standard help command.
		SendMessage(hWnd, WM_COMMAND, ID_HELP, 0);
		return 1;
	}

	if (message < 0xC000)
	{
		// not a ::RegisterWindowMessage message
		return 0;
	}

	// assume it is already wired up to a permanent one
	CDialog* pDlg = (CDialog*)CWnd::FromHandlePermanent(hWnd);
	if(!pDlg)
	{
		// someone else sent us a registered message. Ignore it
		return 0;
	}
	ASSERT_KINDOF(CDialog, pDlg);

	if (pDlg->IsKindOf(RUNTIME_CLASS(CFileDialog)))
	{
		// If we're exploring then we are not interested in the Registered messages
		if (((CFileDialog*)pDlg)->m_ofn.Flags & OFN_EXPLORER)
			return 0;
	}

	// RegisterWindowMessage - does not copy to lastState buffer, so
	// CWnd::GetCurrentMessage and CWnd::Default will NOT work
	// while in these handlers

	// Dispatch special commdlg messages through our virtual callbacks
	if (message == _afxMsgSHAREVI)
	{
		ASSERT_KINDOF(CFileDialog, pDlg);
		return ((CFileDialog*)pDlg)->OnShareViolation((LPCTSTR)lParam);
	}
	else if (message == _afxMsgFILEOK)
	{
		ASSERT_KINDOF(CFileDialog, pDlg);

		((CFileDialog*)pDlg)->m_pofnTemp = (OPENFILENAME*)lParam;
		BOOL bResult = ((CFileDialog*)pDlg)->OnFileNameOK();
		((CFileDialog*)pDlg)->m_pofnTemp = NULL;

		return bResult;
	}
	else if (message == _afxMsgLBSELCHANGE)
	{
		ASSERT_KINDOF(CFileDialog, pDlg);
		((CFileDialog*)pDlg)->OnLBSelChangedNotify((UINT)wParam, LOWORD(lParam),
				HIWORD(lParam));
		return 0;
	}
	else if (message == _afxMsgCOLOROK)
	{
		ASSERT_KINDOF(CColorDialog, pDlg);
		return ((CColorDialog*)pDlg)->OnColorOK();
	}
	else if (message == _afxMsgSETRGB)
	{
		// nothing to do here, since this is a SendMessage
		return 0;
	}
	return 0;
}

////////////////////////////////////////////////////////////////////////////
// CCommonDialog - common dialog helper class

void CCommonDialog::OnOK()
{
	ASSERT_VALID(this);

	if (!UpdateData(TRUE))
	{
		TRACE(traceAppMsg, 0, "UpdateData failed during dialog termination.\n");
		// the UpdateData routine will set focus to correct item
		return;
	}

	// Common dialogs do not require ::EndDialog
	Default();
}

void CCommonDialog::OnCancel()
{
	ASSERT_VALID(this);

	// Common dialogs do not require ::EndDialog
	Default();
}

BOOL CCommonDialog::OnHelpInfo(HELPINFO*)
{
	return (Default() != 0);
}

void CCommonDialog::OnPaint()
{
	// Don't call CDialog::OnPaint
	Default();
}

IMPLEMENT_DYNAMIC(CCommonDialog, CDialog)

////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\dlgdata.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "occimpl.h"
#include "sal.h"

/////////////////////////////////////////////////////////////////////////////
// CDataExchange member functions (contructor is in wincore.cpp for swap tuning)

HWND CDataExchange::PrepareEditCtrl(int nIDC)
{
	HWND hWndCtrl = PrepareCtrl(nIDC);
	m_bEditLastControl = TRUE;

	return hWndCtrl;
}

HWND CDataExchange::PrepareCtrl(int nIDC)
{
	ASSERT(nIDC != 0);
	ASSERT(nIDC != -1); // not allowed
	HWND hWndCtrl;
	COleControlSite* pSite = NULL;
	m_pDlgWnd->GetDlgItem(nIDC, &hWndCtrl);
	if (hWndCtrl == NULL)
	{
		// Could be a windowless OCX
		pSite = m_pDlgWnd->GetOleControlSite(nIDC);
		if (pSite == NULL)
		{
			TRACE(traceAppMsg, 0, "Error: no data exchange control with ID 0x%04X.\n", nIDC);
			ASSERT(FALSE);
			AfxThrowNotSupportedException();
		}
	}
	m_idLastControl = nIDC;
	m_bEditLastControl = FALSE; // not an edit item by default

	return hWndCtrl;
}

void CDataExchange::Fail()
{
	if (!m_bSaveAndValidate)
	{
		TRACE(traceAppMsg, 0, "Warning: CDataExchange::Fail called when not validating.\n");
		// throw the exception anyway
	}
	else if (m_idLastControl != NULL)
	{
		// restore focus and selection to offending field
		HWND hWndLastControl;
		m_pDlgWnd->GetDlgItem(m_idLastControl, &hWndLastControl);
		if (hWndLastControl != NULL)
		{
			::SetFocus(hWndLastControl);
			if (m_bEditLastControl) // select edit item
				::SendMessage(hWndLastControl, EM_SETSEL, 0, -1);
		}
	}
	else
	{
		TRACE(traceAppMsg, 0, "Error: fail validation with no control to restore focus to.\n");
		// do nothing more
	}

	AfxThrowUserException();
}

/////////////////////////////////////////////////////////////////////////////
// Notes for implementing dialog data exchange and validation procs:
//  * always start with PrepareCtrl or PrepareEditCtrl
//  * always start with 'pDX->m_bSaveAndValidate' check
//  * pDX->Fail() will throw an exception - so be prepared
//  * avoid creating temporary HWNDs for dialog controls - i.e.
//      use HWNDs for child elements
//  * validation procs should only act if 'm_bSaveAndValidate'
//  * use the suffices:
//      DDX_ = exchange proc
//      DDV_ = validation proc
//
/////////////////////////////////////////////////////////////////////////////

AFX_STATIC void AFX_CDECL _Afx_DDX_TextWithFormat(CDataExchange* pDX, int nIDC,
												  LPCTSTR lpszFormat, UINT nIDPrompt, ...)
												  // only supports windows output formats - no floating point
{
	va_list pData;
	va_start(pData, nIDPrompt);

	HWND hWndCtrl = pDX->PrepareEditCtrl(nIDC);
	ASSERT( hWndCtrl != NULL );

	const int SZT_SIZE = 64;
	TCHAR szT[SZT_SIZE];
	if (pDX->m_bSaveAndValidate)
	{
		void* pResult;

		pResult = va_arg( pData, void* );
		// the following works for %d, %u, %ld, %lu
		::GetWindowText(hWndCtrl, szT, _countof(szT));
		if (_sntscanf_s(szT, _countof(szT), lpszFormat, pResult) != 1)
		{
			AfxMessageBox(nIDPrompt);
			pDX->Fail();        // throws exception
		}
	}
	else
	{

		ATL_CRT_ERRORCHECK_SPRINTF(_vsntprintf_s(szT, _countof(szT), _countof(szT) - 1, lpszFormat, pData));
		// does not support floating point numbers - see dlgfloat.cpp
		AfxSetWindowText(hWndCtrl, szT);
	}

	va_end(pData);
}

/////////////////////////////////////////////////////////////////////////////
// Simple formatting to text item

void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, BYTE& value)
{
	int n = (int)value;
	if (pDX->m_bSaveAndValidate)
	{
		_Afx_DDX_TextWithFormat(pDX, nIDC, _T("%u"), AFX_IDP_PARSE_BYTE, &n);
		if (n > 255)
		{
			AfxMessageBox(AFX_IDP_PARSE_BYTE);
			pDX->Fail();        // throws exception
		}
		value = (BYTE)n;
	}
	else
		_Afx_DDX_TextWithFormat(pDX, nIDC, _T("%u"), AFX_IDP_PARSE_BYTE, n);
}

void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, short& value)
{
	if (pDX->m_bSaveAndValidate)
		_Afx_DDX_TextWithFormat(pDX, nIDC, _T("%hd"), AFX_IDP_PARSE_INT, &value);
	else
		_Afx_DDX_TextWithFormat(pDX, nIDC, _T("%hd"), AFX_IDP_PARSE_INT, value);
}

void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, int& value)
{
	if (pDX->m_bSaveAndValidate)
		_Afx_DDX_TextWithFormat(pDX, nIDC, _T("%d"), AFX_IDP_PARSE_INT, &value);
	else
		_Afx_DDX_TextWithFormat(pDX, nIDC, _T("%d"), AFX_IDP_PARSE_INT, value);
}

void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, UINT& value)
{
	if (pDX->m_bSaveAndValidate)
		_Afx_DDX_TextWithFormat(pDX, nIDC, _T("%u"), AFX_IDP_PARSE_UINT, &value);
	else
		_Afx_DDX_TextWithFormat(pDX, nIDC, _T("%u"), AFX_IDP_PARSE_UINT, value);
}

void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, long& value)
{
	if (pDX->m_bSaveAndValidate)
		_Afx_DDX_TextWithFormat(pDX, nIDC, _T("%ld"), AFX_IDP_PARSE_INT, &value);
	else
		_Afx_DDX_TextWithFormat(pDX, nIDC, _T("%ld"), AFX_IDP_PARSE_INT, value);
}

void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, DWORD& value)
{
	if (pDX->m_bSaveAndValidate)
		_Afx_DDX_TextWithFormat(pDX, nIDC, _T("%lu"), AFX_IDP_PARSE_UINT, &value);
	else
		_Afx_DDX_TextWithFormat(pDX, nIDC, _T("%lu"), AFX_IDP_PARSE_UINT, value);
}

void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, LONGLONG& value)
{
	if (pDX->m_bSaveAndValidate)
		_Afx_DDX_TextWithFormat(pDX, nIDC, _T("%I64d"), AFX_IDP_PARSE_INT, &value);
	else
		_Afx_DDX_TextWithFormat(pDX, nIDC, _T("%I64d"), AFX_IDP_PARSE_INT, value);
}

void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, ULONGLONG& value)
{
	if (pDX->m_bSaveAndValidate)
		_Afx_DDX_TextWithFormat(pDX, nIDC, _T("%I64u"), AFX_IDP_PARSE_UINT, &value);
	else
		_Afx_DDX_TextWithFormat(pDX, nIDC, _T("%I64u"), AFX_IDP_PARSE_UINT, value);
}

void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, CString& value)
{
	HWND hWndCtrl = pDX->PrepareEditCtrl(nIDC);
	if (pDX->m_bSaveAndValidate)
	{
		int nLen = ::GetWindowTextLength(hWndCtrl);
		::GetWindowText(hWndCtrl, value.GetBufferSetLength(nLen), nLen+1);
		value.ReleaseBuffer();
	}
	else
	{
		AfxSetWindowText(hWndCtrl, value);
	}
}

void AFXAPI DDX_Text(_Inout_ CDataExchange* pDX, _In_ int nIDC, _Out_z_cap_(nMaxLen) LPTSTR value, _In_ int nMaxLen)
{
	ASSERT(nMaxLen != 0);

	HWND hWndCtrl = pDX->PrepareEditCtrl(nIDC);
	if (pDX->m_bSaveAndValidate)
	{
		int nLen = ::GetWindowTextLength(hWndCtrl);
		int nRetrieved = ::GetWindowText(hWndCtrl, value, nMaxLen);
		if (nLen > nRetrieved)
			TRACE(traceAppMsg, 0, "Text in control ID %d is too long. Call DDV_MaxChars()!\n", nIDC);
	}
	else
	{
		AfxSetWindowText(hWndCtrl, value);
	}
}

/////////////////////////////////////////////////////////////////////////////
// Data exchange for special control

void AFXAPI DDX_Check(CDataExchange* pDX, int nIDC, int& value)
{
	pDX->PrepareCtrl(nIDC);
	HWND hWndCtrl;
	pDX->m_pDlgWnd->GetDlgItem(nIDC, &hWndCtrl);
	if (pDX->m_bSaveAndValidate)
	{
		value = (int)::SendMessage(hWndCtrl, BM_GETCHECK, 0, 0L);
		ASSERT(value >= 0 && value <= 2);
	}
	else
	{
		if (value < 0 || value > 2)
		{
			TRACE(traceAppMsg, 0, "Warning: dialog data checkbox value (%d) out of range.\n",
				value);
			value = 0;  // default to off
		}
		::SendMessage(hWndCtrl, BM_SETCHECK, (WPARAM)value, 0L);
	}
}

void AFXAPI DDX_Radio(CDataExchange* pDX, int nIDC, int& value)
// must be first in a group of auto radio buttons
{
	pDX->PrepareCtrl(nIDC);
	HWND hWndCtrl;
	pDX->m_pDlgWnd->GetDlgItem(nIDC, &hWndCtrl);

	ASSERT(::GetWindowLong(hWndCtrl, GWL_STYLE) & WS_GROUP);
	ASSERT(::SendMessage(hWndCtrl, WM_GETDLGCODE, 0, 0L) & DLGC_RADIOBUTTON);

	if (pDX->m_bSaveAndValidate)
		value = -1;     // value if none found

	// walk all children in group
	int iButton = 0;
	do
	{
		if (::SendMessage(hWndCtrl, WM_GETDLGCODE, 0, 0L) & DLGC_RADIOBUTTON)
		{
			// control in group is a radio button
			if (pDX->m_bSaveAndValidate)
			{
				if (::SendMessage(hWndCtrl, BM_GETCHECK, 0, 0L) != 0)
				{
					ASSERT(value == -1);    // only set once
					value = iButton;
				}
			}
			else
			{
				// select button
				::SendMessage(hWndCtrl, BM_SETCHECK, (iButton == value), 0L);
			}
			iButton++;
		}
		else
		{
			TRACE(traceAppMsg, 0, "Warning: skipping non-radio button in group.\n");
		}
		hWndCtrl = ::GetWindow(hWndCtrl, GW_HWNDNEXT);

	} while (hWndCtrl != NULL &&
		!(GetWindowLong(hWndCtrl, GWL_STYLE) & WS_GROUP));
}

/////////////////////////////////////////////////////////////////////////////
// Listboxes, comboboxes

void AFXAPI DDX_LBString(CDataExchange* pDX, int nIDC, CString& value)
{
	pDX->PrepareCtrl(nIDC);
	HWND hWndCtrl;
	pDX->m_pDlgWnd->GetDlgItem(nIDC, &hWndCtrl);
	if (pDX->m_bSaveAndValidate)
	{
		int nIndex = (int)::SendMessage(hWndCtrl, LB_GETCURSEL, 0, 0L);
		if (nIndex != -1)
		{
			int nLen = (int)::SendMessage(hWndCtrl, LB_GETTEXTLEN, nIndex, 0L);
			::SendMessage(hWndCtrl, LB_GETTEXT, nIndex,
				(LPARAM)(LPVOID)value.GetBufferSetLength(nLen));
		}
		else
		{
			// no selection
			value.Empty();
		}
		value.ReleaseBuffer();
	}
	else
	{
		// set current selection based on data string
		if (::SendMessage(hWndCtrl, LB_SELECTSTRING, (WPARAM)-1,
			(LPARAM)(LPCTSTR)value) == LB_ERR)
		{
			// no selection match
			TRACE(traceAppMsg, 0, "Warning: no listbox item selected.\n");
		}
	}
}

void AFXAPI DDX_LBStringExact(CDataExchange* pDX, int nIDC, CString& value)
{
	pDX->PrepareCtrl(nIDC);
	HWND hWndCtrl;
	pDX->m_pDlgWnd->GetDlgItem(nIDC, &hWndCtrl);
	if (pDX->m_bSaveAndValidate)
	{
		DDX_LBString(pDX, nIDC, value);
	}
	else
	{
		// set current selection based on data string
		int i = (int)::SendMessage(hWndCtrl, LB_FINDSTRINGEXACT, (WPARAM)-1,
			(LPARAM)(LPCTSTR)value);
		if (i < 0)
		{
			// no selection match
			TRACE(traceAppMsg, 0, "Warning: no listbox item selected.\n");
		}
		else
		{
			// select it
			SendMessage(hWndCtrl, LB_SETCURSEL, i, 0L);
		}
	}
}

void AFXAPI DDX_CBString(CDataExchange* pDX, int nIDC, CString& value)
{
	HWND hWndCtrl;
	pDX->m_pDlgWnd->GetDlgItem(nIDC, &hWndCtrl);

	if ((::GetWindowLong(hWndCtrl, GWL_STYLE) & CBS_DROPDOWNLIST) != CBS_DROPDOWNLIST)
	{
		pDX->PrepareEditCtrl(nIDC);
	}
	else
	{
		pDX->PrepareCtrl(nIDC);
	}

	if (pDX->m_bSaveAndValidate)
	{
		// just get current edit item text (or drop list static)
		int nLen = ::GetWindowTextLength(hWndCtrl);
		if (nLen > 0)
		{
			// get known length
			::GetWindowText(hWndCtrl, value.GetBufferSetLength(nLen), nLen+1);
		}
		else
		{
			// for drop lists GetWindowTextLength does not work - assume
			//  max of 255 characters
			::GetWindowText(hWndCtrl, value.GetBuffer(255), 255+1);
		}
		value.ReleaseBuffer();
	}
	else
	{
		// set current selection based on model string
		if (::SendMessage(hWndCtrl, CB_SELECTSTRING, (WPARAM)-1,
			(LPARAM)(LPCTSTR)value) == CB_ERR)
		{
			// just set the edit text (will be ignored if DROPDOWNLIST)
			AfxSetWindowText(hWndCtrl, value);
		}
	}
}

void AFXAPI DDX_CBStringExact(CDataExchange* pDX, int nIDC, CString& value)
{
	HWND hWndCtrl;
	pDX->m_pDlgWnd->GetDlgItem(nIDC, &hWndCtrl);

	if ((::GetWindowLong(hWndCtrl, GWL_STYLE) & CBS_DROPDOWNLIST) != CBS_DROPDOWNLIST)
	{
		pDX->PrepareEditCtrl(nIDC);
	}
	else
	{
		pDX->PrepareCtrl(nIDC);
	}

	if (pDX->m_bSaveAndValidate)
	{
		DDX_CBString(pDX, nIDC, value);
	}
	else
	{
		// set current selection based on data string
		int i = (int)::SendMessage(hWndCtrl, CB_FINDSTRINGEXACT, (WPARAM)-1,
			(LPARAM)(LPCTSTR)value);
		if (i < 0)
		{
			// just set the edit text (will be ignored if DROPDOWNLIST)
			AfxSetWindowText(hWndCtrl, value);
		}
		else
		{
			// select it
			SendMessage(hWndCtrl, CB_SETCURSEL, i, 0L);
		}
	}
}

void AFXAPI DDX_LBIndex(CDataExchange* pDX, int nIDC, int& index)
{
	pDX->PrepareCtrl(nIDC);
	HWND hWndCtrl;
	pDX->m_pDlgWnd->GetDlgItem(nIDC, &hWndCtrl);
	if (pDX->m_bSaveAndValidate)
		index = (int)::SendMessage(hWndCtrl, LB_GETCURSEL, 0, 0L);
	else
		::SendMessage(hWndCtrl, LB_SETCURSEL, (WPARAM)index, 0L);
}

void AFXAPI DDX_CBIndex(CDataExchange* pDX, int nIDC, int& index)
{
	pDX->PrepareCtrl(nIDC);
	HWND hWndCtrl;
	pDX->m_pDlgWnd->GetDlgItem(nIDC, &hWndCtrl);
	if (pDX->m_bSaveAndValidate)
		index = (int)::SendMessage(hWndCtrl, CB_GETCURSEL, 0, 0L);
	else

		::SendMessage(hWndCtrl, CB_SETCURSEL, (WPARAM)index, 0L);
}

void AFXAPI DDX_Scroll(CDataExchange* pDX, int nIDC, int& value)
{
	pDX->PrepareCtrl(nIDC);
	HWND hWndCtrl;
	pDX->m_pDlgWnd->GetDlgItem(nIDC, &hWndCtrl);
	if (pDX->m_bSaveAndValidate)
		value = GetScrollPos(hWndCtrl, SB_CTL);
	else
		SetScrollPos(hWndCtrl, SB_CTL, value, TRUE);
}

void AFXAPI DDX_Slider(CDataExchange* pDX, int nIDC, int& value)
{
	pDX->PrepareCtrl(nIDC);
	HWND hWndCtrl;
	pDX->m_pDlgWnd->GetDlgItem(nIDC, &hWndCtrl);
	if (pDX->m_bSaveAndValidate)
		value = (int) ::SendMessage(hWndCtrl, TBM_GETPOS, 0, 0l);
	else
		::SendMessage(hWndCtrl, TBM_SETPOS, TRUE, value);
}

void AFXAPI DDX_IPAddress(CDataExchange* pDX, int nIDC, DWORD& value)
{
	pDX->PrepareCtrl(nIDC);
	HWND hWndCtrl;
	pDX->m_pDlgWnd->GetDlgItem(nIDC, &hWndCtrl);
	if (pDX->m_bSaveAndValidate)
		::SendMessage(hWndCtrl, IPM_GETADDRESS, 0, (LPARAM) &value);
	else
		::SendMessage(hWndCtrl, IPM_SETADDRESS, 0, (LPARAM) value);
}

/////////////////////////////////////////////////////////////////////////////
// Range Dialog Data Validation

AFX_STATIC void AFXAPI _AfxFailMinMaxWithFormat(CDataExchange* pDX,
												LONGLONG minVal, LONGLONG maxVal, LPCTSTR lpszFormat, UINT nIDPrompt)
												// error string must have '%1' and '%2' strings for min and max values
												// since minVal and maxVal are 64-bit, lpszFormat should be "%I64d" or "%I64u"
{
	ASSERT(lpszFormat != NULL);

	if (!pDX->m_bSaveAndValidate)
	{
		TRACE(traceAppMsg, 0, "Warning: initial dialog data is out of range.\n");
		return;     // don't stop now
	}

	const int MINMAX_BUFFER_SIZE = 64;
	TCHAR szMin[MINMAX_BUFFER_SIZE];
	TCHAR szMax[MINMAX_BUFFER_SIZE];

	ATL_CRT_ERRORCHECK_SPRINTF(_sntprintf_s(szMin, _countof(szMin), _countof(szMin) - 1, lpszFormat, minVal));
	ATL_CRT_ERRORCHECK_SPRINTF(_sntprintf_s(szMax, _countof(szMax), _countof(szMax) - 1, lpszFormat, maxVal));

	CString prompt;
	AfxFormatString2(prompt, nIDPrompt, szMin, szMax);
	AfxMessageBox(prompt, MB_ICONEXCLAMATION, nIDPrompt);
	prompt.Empty(); // exception prep
	pDX->Fail();
}

//NOTE: don't use overloaded function names to avoid type ambiguities
void AFXAPI DDV_MinMaxByte(CDataExchange* pDX, BYTE value, BYTE minVal, BYTE maxVal)
{
	ASSERT(minVal <= maxVal);
	if (value < minVal || value > maxVal)
		_AfxFailMinMaxWithFormat(pDX, minVal, maxVal, _T("%I64u"),
		AFX_IDP_PARSE_INT_RANGE);
}

void AFXAPI DDV_MinMaxShort(CDataExchange* pDX, short value, short minVal, short maxVal)
{
	ASSERT(minVal <= maxVal);
	if (value < minVal || value > maxVal)
		_AfxFailMinMaxWithFormat(pDX, minVal, maxVal, _T("%I64d"),
		AFX_IDP_PARSE_INT_RANGE);
}

void AFXAPI DDV_MinMaxInt(CDataExchange* pDX, int value, int minVal, int maxVal)
{
	ASSERT(minVal <= maxVal);
	if (value < minVal || value > maxVal)
		_AfxFailMinMaxWithFormat(pDX, minVal, maxVal, _T("%I64d"),
		AFX_IDP_PARSE_INT_RANGE);
}

void AFXAPI DDV_MinMaxLong(CDataExchange* pDX, long value, long minVal, long maxVal)
{
	ASSERT(minVal <= maxVal);
	if (value < minVal || value > maxVal)
		_AfxFailMinMaxWithFormat(pDX, minVal, maxVal, _T("%I64d"),
		AFX_IDP_PARSE_INT_RANGE);
}

void AFXAPI DDV_MinMaxUInt(CDataExchange* pDX, UINT value, UINT minVal, UINT maxVal)
{
	ASSERT(minVal <= maxVal);
	if (value < minVal || value > maxVal)
		_AfxFailMinMaxWithFormat(pDX, minVal, maxVal, _T("%I64u"),
		AFX_IDP_PARSE_INT_RANGE);
}

void AFXAPI DDV_MinMaxDWord(CDataExchange* pDX, DWORD value, DWORD minVal, DWORD maxVal)
{
	ASSERT(minVal <= maxVal);
	if (value < minVal || value > maxVal)
		_AfxFailMinMaxWithFormat(pDX, minVal, maxVal, _T("%I64u"),
		AFX_IDP_PARSE_INT_RANGE);
}

void AFXAPI DDV_MinMaxLongLong(CDataExchange* pDX, LONGLONG value, LONGLONG minVal, LONGLONG maxVal)
{
	ASSERT(minVal <= maxVal);
	if ((value < minVal) || (value > maxVal))
		_AfxFailMinMaxWithFormat(pDX, minVal, maxVal, _T("%I64d"),
		AFX_IDP_PARSE_INT_RANGE);
}

void AFXAPI DDV_MinMaxULongLong(CDataExchange* pDX, ULONGLONG value, ULONGLONG minVal, ULONGLONG maxVal)
{
	ASSERT(minVal <= maxVal);
	if ((value < minVal) || (value > maxVal))
		_AfxFailMinMaxWithFormat(pDX, minVal, maxVal, _T("%I64u"),
		AFX_IDP_PARSE_INT_RANGE);
}

void AFXAPI DDV_MinMaxSlider(CDataExchange* pDX, DWORD value, DWORD minVal, DWORD maxVal)
{
	ASSERT(minVal <= maxVal);

	if (!pDX->m_bSaveAndValidate)
	{
		if (minVal > value || maxVal < value)
		{
			TRACE(traceAppMsg, 0, "Warning: initial dialog data is out of "
				"range in control ID %d.\n", pDX->m_idLastControl);
			return;     // don't stop now
		}
	}

	HWND hWndLastControl;
	pDX->m_pDlgWnd->GetDlgItem(pDX->m_idLastControl, &hWndLastControl);
	::SendMessage(hWndLastControl, TBM_SETRANGEMIN, FALSE, (LPARAM) minVal);
	::SendMessage(hWndLastControl, TBM_SETRANGEMAX, TRUE, (LPARAM) maxVal);
}

/////////////////////////////////////////////////////////////////////////////
// Max Chars Dialog Data Validation

void AFXAPI DDV_MaxChars(CDataExchange* pDX, CString const& value, int nChars)
{
	ASSERT(nChars >= 1);        // allow them something
	if (pDX->m_bSaveAndValidate && value.GetLength() > nChars)
	{
		TCHAR szT[32];
		_stprintf_s(szT, _countof(szT), _T("%d"), nChars);
		CString prompt;
		AfxFormatString1(prompt, AFX_IDP_PARSE_STRING_SIZE, szT);
		AfxMessageBox(prompt, MB_ICONEXCLAMATION, AFX_IDP_PARSE_STRING_SIZE);
		prompt.Empty(); // exception prep
		pDX->Fail();
	}
	else if (pDX->m_idLastControl != 0 && pDX->m_bEditLastControl)
	{
		HWND hWndLastControl;
		pDX->m_pDlgWnd->GetDlgItem(pDX->m_idLastControl, &hWndLastControl);
		// limit the control max-chars automatically
		// send messages for both an edit control and a combobox control--one will
		// be understood and one will be disregarded, but this is the only way to
		// ensure that the characters will be limited for both kinds of controls.
		::SendMessage(hWndLastControl, EM_SETLIMITTEXT, nChars, 0);
		::SendMessage(hWndLastControl, CB_LIMITTEXT, nChars, 0);
	}
}

/////////////////////////////////////////////////////////////////////////////
// Special DDX_ proc for subclassing controls

void AFXAPI DDX_Control(CDataExchange* pDX, int nIDC, CWnd& rControl)
{
	if ((rControl.m_hWnd == NULL) && (rControl.GetControlUnknown() == NULL))    // not subclassed yet
	{
		ASSERT(!pDX->m_bSaveAndValidate);

		pDX->PrepareCtrl(nIDC);
		HWND hWndCtrl;
		pDX->m_pDlgWnd->GetDlgItem(nIDC, &hWndCtrl);
		
		CMFCControlContainer* pMFCCtrlContainer = pDX->m_pDlgWnd->GetMFCControlContainer();
		if (pMFCCtrlContainer != NULL && pMFCCtrlContainer->IsSubclassedFeaturePackControl(hWndCtrl))
		{
			pMFCCtrlContainer->ReSubclassControl(hWndCtrl, (WORD)nIDC, rControl);
			return;
		}
		
		if ((hWndCtrl != NULL) && !rControl.SubclassWindow(hWndCtrl))
		{
			ASSERT(FALSE);      // possibly trying to subclass twice?
			AfxThrowNotSupportedException();
		}
#ifndef _AFX_NO_OCC_SUPPORT
		else
		{
			if (hWndCtrl == NULL)
			{
				if (pDX->m_pDlgWnd->GetOleControlSite(nIDC) != NULL)
				{
					rControl.AttachControlSite(pDX->m_pDlgWnd, nIDC);
				}
			}
			else
			{
				// If the control has reparented itself (e.g., invisible control),
				// make sure that the CWnd gets properly wired to its control site.
				if (pDX->m_pDlgWnd->m_hWnd != ::GetParent(rControl.m_hWnd))
					rControl.AttachControlSite(pDX->m_pDlgWnd);
			}
		}
#endif //!_AFX_NO_OCC_SUPPORT

	}
}

/////////////////////////////////////////////////////////////////////////////
// Global failure dialog helpers (used by database classes)

void AFXAPI AfxFailMaxChars(CDataExchange* pDX, int nChars)
{
	TCHAR lpszTemp[32];
	_stprintf_s(lpszTemp, _countof(lpszTemp), _T("%d"), nChars);
	CString prompt;
	AfxFormatString1(prompt, AFX_IDP_PARSE_STRING_SIZE, lpszTemp);
	AfxMessageBox(prompt, MB_ICONEXCLAMATION, AFX_IDP_PARSE_STRING_SIZE);
	prompt.Empty(); // exception prep
	pDX->Fail();
}

void AFXAPI AfxFailRadio(CDataExchange* pDX)
{
	CString prompt;
	AfxFormatStrings(prompt, AFX_IDP_PARSE_RADIO_BUTTON, NULL, 0);
	AfxMessageBox(prompt, MB_ICONEXCLAMATION, AFX_IDP_PARSE_RADIO_BUTTON);
	prompt.Empty(); // exception prep
	pDX->Fail();
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\dlgdhtml.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include <afxdhtml.h>


#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CDHtmlDialog

BEGIN_MESSAGE_MAP(CDHtmlDialog, CDialog)
	ON_WM_DESTROY()
	ON_WM_SIZE()
	ON_REGISTERED_MESSAGE(CDHtmlDialog::WM_DESTROYMODELESS, &CDHtmlDialog::OnDestroyModeless)
END_MESSAGE_MAP()

BEGIN_EVENTSINK_MAP(CDHtmlDialog, CDialog)
	ON_EVENT(CDHtmlDialog, AFX_IDC_BROWSER, 252 /* NavigateComplete2 */, _OnNavigateComplete2, VTS_DISPATCH VTS_PVARIANT)
	ON_EVENT(CDHtmlDialog, AFX_IDC_BROWSER, 250 /* BeforeNavigate2 */, _OnBeforeNavigate2, VTS_DISPATCH VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PBOOL)
	ON_EVENT(CDHtmlDialog, AFX_IDC_BROWSER, 259 /* DocumentComplete */, _OnDocumentComplete, VTS_DISPATCH VTS_PVARIANT)
END_EVENTSINK_MAP()

/////////////////////////////////////////////////////////////////////////////


IMPLEMENT_DYNAMIC(CDHtmlDialog, CDialog)
IMPLEMENT_DYNAMIC(CMultiPageDHtmlDialog, CDHtmlDialog)

/////////////////////////////////////////////////////////////////////////////
// CDHtmlEventSink

HRESULT CDHtmlEventSink::ConnectToConnectionPoint(IUnknown *punkObj, REFIID riid, DWORD *pdwCookie)
{
	return AtlAdvise(punkObj, (IDispatch *) this, riid, pdwCookie);
}

void CDHtmlEventSink::DisconnectFromConnectionPoint(IUnknown *punkObj, REFIID riid, DWORD& dwCookie)
{
	AtlUnadvise(punkObj, riid, dwCookie);
}

STDMETHODIMP CDHtmlEventSink::CDHtmlSinkHandlerQueryInterface(REFIID iid, LPVOID* ppvObj)
{
	if (!ppvObj)
		return E_POINTER;

	*ppvObj = NULL;
	if (IsEqualIID(iid, __uuidof(IDispatch)) || IsEqualIID(iid, __uuidof(IUnknown)))
	{
		*ppvObj = (IDispatch *) this;
		AddRef();
		return S_OK;
	}
	return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CDHtmlEventSink::AddRef()
{
	return 1;
}

STDMETHODIMP_(ULONG) CDHtmlEventSink::Release()
{
	return 1;
}

STDMETHODIMP CDHtmlEventSink::GetTypeInfoCount(UINT *pctinfo)
{
	*pctinfo = 0;
	ATLTRACENOTIMPL(_T("CDHtmlEventSink::GetTypeInfoCount"));
}

STDMETHODIMP CDHtmlEventSink::GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo)
{
	iTInfo; // unused
	lcid; // unused

	*ppTInfo = NULL;
	ATLTRACENOTIMPL(_T("CDHtmlEventSink::GetTypeInfo"));
}

STDMETHODIMP CDHtmlEventSink::GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId)
{
	riid; // unused
	rgszNames; // unused
	cNames; // unused
	lcid; // unused
	rgDispId; // unused

	ATLTRACENOTIMPL(_T("CDHtmlEventSink::GetIDsOfNames"));
}

STDMETHODIMP CDHtmlEventSink::Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags,
	DISPPARAMS *pDispParams, VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
{
	riid; // unused
	lcid; // unused
	wFlags; // unused

	IHTMLElement *psrcElement;
	HRESULT hr = S_OK;

	VariantInit(pVarResult);

	if (DHtmlEventHook(&hr, dispIdMember, pDispParams, pVarResult, pExcepInfo, puArgErr))
		return hr;

	const DHtmlEventMapEntry *pMap = GetDHtmlEventMap();

	int nIndex = FindDHtmlEventEntry(pMap, dispIdMember, &psrcElement);
	if (nIndex<0)
		return DISP_E_MEMBERNOTFOUND;

	// now call it
	if (pMap)
	{
		hr = (this->*((DHEVTFUNC) (GetDHtmlEventMap()[nIndex].pfnEventFunc)))(psrcElement);
		if (GetDHtmlEventMap()[nIndex].nType != DHTMLEVENTMAPENTRY_CONTROL && pVarResult)
		{
			pVarResult->vt = VT_BOOL;
			pVarResult->boolVal = (hr==S_OK) ? ATL_VARIANT_TRUE : ATL_VARIANT_FALSE;
		}
	}
	if (psrcElement)
		psrcElement->Release();

	return hr;
}

BOOL CDHtmlEventSink::DHtmlEventHook(HRESULT *phr, DISPID dispIdMember, DISPPARAMS *pDispParams,
	VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
{
	phr; // unused
	dispIdMember; // unused
	pDispParams; // unused
	pVarResult; // unused
	pExcepInfo; // unused
	puArgErr; // unused

	// stub base implementation
	return FALSE;
}

int CDHtmlEventSink::FindDHtmlEventEntry(const DHtmlEventMapEntry *pEventMap, DISPID dispIdMember,
						   IHTMLElement **ppsrcElement)
{
	HRESULT hr = DISP_E_MEMBERNOTFOUND;
	CComPtr<IHTMLWindow2> sphtmlWnd;
	CComPtr<IHTMLEventObj> sphtmlEvent;
	CComPtr<IHTMLElement> sphtmlElement;
	CComPtr<IHTMLDocument2> sphtmlDoc;
	CComBSTR bstrName;
	CComBSTR bstrClass;
	CComBSTR bstrTagName;

	int i;
	int nIndexFound = -1;

	if(ppsrcElement == NULL)
		return E_POINTER;

	*ppsrcElement = NULL;

	if (!pEventMap)
		goto Error;

	// get the html document
	hr = GetDHtmlDocument(&sphtmlDoc);
	if (sphtmlDoc == NULL)
		goto Error;

	// get the element that generated the event
	sphtmlDoc->get_parentWindow(&sphtmlWnd);
	if ((sphtmlWnd==NULL) || FAILED(sphtmlWnd->get_event(&sphtmlEvent)) || (sphtmlEvent==NULL))
	{
		hr = DISP_E_MEMBERNOTFOUND;
		goto Error;
	}
	sphtmlEvent->get_srcElement(&sphtmlElement);
	*ppsrcElement = sphtmlElement;
	if (sphtmlElement)
		sphtmlElement.p->AddRef();
	// look for the dispid in the map
	for (i=0; pEventMap[i].nType != DHTMLEVENTMAPENTRY_END; i++)
	{
		if (pEventMap[i].dispId == dispIdMember)
		{
			if (pEventMap[i].nType == DHTMLEVENTMAPENTRY_NAME)
			{
				if (!bstrName && sphtmlElement)
					sphtmlElement->get_id(&bstrName);
				if (bstrName && pEventMap[i].szName && !wcscmp(bstrName, CComBSTR(pEventMap[i].szName)) ||
					(!bstrName && !sphtmlElement))
				{
					nIndexFound = i;
					break;
				}
			}
			else if (pEventMap[i].nType == DHTMLEVENTMAPENTRY_CLASS)
			{
				if (!bstrClass && sphtmlElement)
					sphtmlElement->get_className(&bstrClass);
				if (bstrClass && !wcscmp(bstrClass, CComBSTR(pEventMap[i].szName)))
				{
					nIndexFound = i;
					break;
				}
			}
			else if (pEventMap[i].nType == DHTMLEVENTMAPENTRY_TAG)
			{
				if (!bstrTagName && sphtmlElement)
					sphtmlElement->get_tagName(&bstrTagName);
				if (bstrTagName && !_wcsicmp(bstrTagName, CComBSTR(pEventMap[i].szName)))
				{
					nIndexFound = i;
					break;
				}
			}
		}
	}
Error:
	if (nIndexFound==-1 && *ppsrcElement)
	{
		(*ppsrcElement)->Release();
		*ppsrcElement = NULL;
	}
	return nIndexFound;
}

/////////////////////////////////////////////////////////////////////////////
// CDHtmlControlSink

CDHtmlControlSink::CDHtmlControlSink()
{
	m_dwCookie = 0;
	m_pHandler = NULL;
	m_dwThunkOffset = 0;
	memset(&m_iid, 0x00, sizeof(IID));
}

CDHtmlControlSink::CDHtmlControlSink(IUnknown *punkObj, CDHtmlSinkHandler *pHandler,
		LPCTSTR szControlId, DWORD_PTR dwThunkOffset /*= 0*/)
{
	m_dwCookie = 0;
	m_pHandler = pHandler;
	m_szControlId = szControlId;
	m_dwThunkOffset = dwThunkOffset;
	ConnectToControl(punkObj);
}

CDHtmlControlSink::~CDHtmlControlSink()
{
	if (m_dwCookie != 0)
		AtlUnadvise(m_spunkObj, m_iid, m_dwCookie);
}

HRESULT CDHtmlControlSink::ConnectToControl(IUnknown *punkObj)
{
	m_spunkObj = punkObj;
	HRESULT hr = AtlGetObjectSourceInterface(punkObj, &m_libid, &m_iid, &m_wMajor, &m_wMinor);
	if (FAILED(hr))
		return hr;

	CComPtr<ITypeLib> spTypeLib;

	hr = LoadRegTypeLib(m_libid, m_wMajor, m_wMinor, LOCALE_USER_DEFAULT, &spTypeLib);
	if (FAILED(hr))
		return hr;

	hr = spTypeLib->GetTypeInfoOfGuid(m_iid, &m_spTypeInfo);
	if (FAILED(hr))
		return hr;

	return AtlAdvise(punkObj, this, m_iid, &m_dwCookie);
}

STDMETHODIMP_(ULONG) CDHtmlControlSink::AddRef()
{
	return 1;
}

STDMETHODIMP_(ULONG) CDHtmlControlSink::Release()
{
	return 1;
}

STDMETHODIMP CDHtmlControlSink::QueryInterface(REFIID iid, LPVOID* ppvObj)
{
	if (!ppvObj)
		return E_POINTER;

	*ppvObj = NULL;
	if (IsEqualIID(iid, __uuidof(IUnknown)) || 
		IsEqualIID(iid, __uuidof(IDispatch)) || 
		IsEqualIID(iid, m_iid))
	{
		*ppvObj = this;
		return S_OK;
	}
	return E_NOINTERFACE;
}

STDMETHODIMP CDHtmlControlSink::GetTypeInfoCount(UINT *pctinfo)
{
	*pctinfo = 0;
	ATLTRACENOTIMPL(_T("CDHtmlControlSink::GetTypeInfoCount"));
}

STDMETHODIMP CDHtmlControlSink::GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo)
{
	iTInfo; // unused
	lcid; // unused

	*ppTInfo = NULL;
	ATLTRACENOTIMPL(_T("CDHtmlControlSink::GetTypeInfo"));
}

STDMETHODIMP CDHtmlControlSink::GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId)
{
	riid; // unused
	rgszNames; // unused
	cNames; // unused
	lcid; // unused
	rgDispId; // unused

	ATLTRACENOTIMPL(_T("CDHtmlControlSink::GetIDsOfNames"));
}

STDMETHODIMP CDHtmlControlSink::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
	DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
{
	riid; // unused
	wFlags; // unused
	pExcepInfo; // unused
	puArgErr; // unused

	_ATL_FUNC_INFO info;

	BOOL fFound = FALSE;
	DHEVTFUNCCONTROL pEvent = NULL;

	const DHtmlEventMapEntry *pEventMap = m_pHandler->GetDHtmlEventMap();
	for (int i=0; pEventMap[i].nType != DHTMLEVENTMAPENTRY_END; i++)
	{
		if (pEventMap[i].nType==DHTMLEVENTMAPENTRY_CONTROL &&
			pEventMap[i].dispId == dispidMember &&
			!_tcscmp(pEventMap[i].szName, m_szControlId))
		{
			// found the entry
			pEvent = pEventMap[i].pfnEventFunc;
			fFound = TRUE;
			break;
		}
	}
	if (!fFound)
		return DISP_E_MEMBERNOTFOUND;

	HRESULT hr = GetFuncInfoFromId(m_iid, dispidMember, lcid, info);
	if (FAILED(hr))
	{
		return S_OK;
	}
	return InvokeFromFuncInfo(pEvent, info, pdispparams, pvarResult);
}

//Helper for invoking the event
HRESULT CDHtmlControlSink::InvokeFromFuncInfo(DHEVTFUNCCONTROL pEvent, _ATL_FUNC_INFO& info, DISPPARAMS* pdispparams, VARIANT* pvarResult)
{
	USES_ATL_SAFE_ALLOCA;
	if (info.nParams < 0)
	{
		return E_INVALIDARG;
	}
	if (info.nParams > size_t(-1) / sizeof(VARIANTARG*))
	{
		return E_OUTOFMEMORY;
	}
	VARIANTARG** pVarArgs = info.nParams ? (VARIANTARG**)_ATL_SAFE_ALLOCA(sizeof(VARIANTARG*)*info.nParams,_ATL_SAFE_ALLOCA_DEF_THRESHOLD) : 0;
	if(!pVarArgs)
	{
		return E_OUTOFMEMORY;
	}

	for (int i=0; i<info.nParams; i++)
	{
		pVarArgs[i] = &pdispparams->rgvarg[info.nParams - i - 1];
	}

	CComStdCallThunk<CDHtmlSinkHandler> thunk;
	if (m_pHandler)
		thunk.Init(pEvent, reinterpret_cast< CDHtmlSinkHandler* >((DWORD_PTR) m_pHandler - m_dwThunkOffset));

	CComVariant tmpResult;
	if (pvarResult == NULL)
		pvarResult = &tmpResult;

	HRESULT hr = DispCallFunc(
		&thunk,
		0,
		info.cc,
		info.vtReturn,
		info.nParams,
		info.pVarTypes,
		pVarArgs,
		pvarResult);
	ATLASSERT(SUCCEEDED(hr));
	return hr;
}

HRESULT CDHtmlControlSink::GetFuncInfoFromId(const IID& iid, DISPID dispidMember, LCID lcid, _ATL_FUNC_INFO& info)
{
	if (!m_spTypeInfo)
		return E_FAIL;
	return AtlGetFuncInfoFromId(m_spTypeInfo, iid, dispidMember, lcid, info);
}

VARTYPE CDHtmlControlSink::GetUserDefinedType(ITypeInfo *pTI, HREFTYPE hrt)
{
	return AtlGetUserDefinedType(pTI, hrt);
}

/////////////////////////////////////////////////////////////////////////////
// CDHtmlElementEventSink

CDHtmlElementEventSink::CDHtmlElementEventSink(CDHtmlEventSink *pHandler, IDispatch *pdisp)
{
	m_pHandler = pHandler;
	pdisp->QueryInterface(__uuidof(IUnknown), (void **) &m_spunkElem);
	m_dwCookie = 0;
}

STDMETHODIMP_(ULONG) CDHtmlElementEventSink::AddRef()
{
	return 1;
}

STDMETHODIMP_(ULONG) CDHtmlElementEventSink::Release()
{
	return 1;
}

STDMETHODIMP CDHtmlElementEventSink::QueryInterface(REFIID iid, LPVOID* ppvObj)
{
	if (!ppvObj)
		return E_POINTER;

	*ppvObj = NULL;
	if (IsEqualIID(iid, __uuidof(IUnknown)) || 
		IsEqualIID(iid, __uuidof(IDispatch)))
	{
		*ppvObj = this;
		return S_OK;
	}
	return E_NOINTERFACE;
}

STDMETHODIMP CDHtmlElementEventSink::GetTypeInfoCount(UINT *pctinfo)
{
	*pctinfo = 0;
	ATLTRACENOTIMPL(_T("CDHtmlElementEventSink::GetTypeInfoCount"));
}

STDMETHODIMP CDHtmlElementEventSink::GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo)
{
	iTInfo; // unused
	lcid; // unused

	*ppTInfo = NULL;
	ATLTRACENOTIMPL(_T("CDHtmlElementEventSink::GetTypeInfo"));
}

STDMETHODIMP CDHtmlElementEventSink::GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId)
{
	riid; // unused
	rgszNames; // unused
	cNames; // unused
	lcid; // unused
	rgDispId; // unused

	ATLTRACENOTIMPL(_T("CDHtmlElementEventSink::GetIDsOfNames"));
}

STDMETHODIMP CDHtmlElementEventSink::Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags,
	DISPPARAMS *pdispparams, VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
{
	riid; // unused
	lcid; // unused
	wFlags; // unused
	pdispparams; // unused
	pExcepInfo; // unused
	puArgErr; // unused

	HRESULT hr;
	CComPtr<IHTMLWindow2> sphtmlWnd;
	CComPtr<IHTMLDocument2> sphtmlDoc;
	CComPtr<IHTMLElement> sphtmlElem;
	CComPtr<IHTMLElement> spsrcElem;
	CComPtr<IHTMLEventObj> sphtmlEvent;

	CComBSTR bstrId;

	if (pVarResult)
		VariantInit(pVarResult);
	hr = m_spunkElem->QueryInterface(&sphtmlElem);
	if (!sphtmlElem)
		return hr;

	hr = sphtmlElem->get_id(&bstrId);
	if (FAILED(hr))
		return hr;

	hr = m_pHandler->GetDHtmlDocument(&sphtmlDoc);
	if (FAILED(hr))
		return hr;

	hr = sphtmlDoc->get_parentWindow(&sphtmlWnd);
	if (FAILED(hr))
		return hr;

	hr = sphtmlWnd->get_event(&sphtmlEvent);
	if (FAILED(hr))
		return hr;

	hr = sphtmlEvent->get_srcElement(&spsrcElem);
	if (FAILED(hr))
		return hr;

	const DHtmlEventMapEntry *pEventMap = m_pHandler->GetDHtmlEventMap();
	for (int i=0; pEventMap[i].nType != DHTMLEVENTMAPENTRY_END; i++)
	{
		if (pEventMap[i].nType==DHTMLEVENTMAPENTRY_ELEMENT &&
			pEventMap[i].dispId == dispIdMember)
		{
			if (pEventMap[i].szName && !wcscmp(CComBSTR(pEventMap[i].szName), bstrId))
			{
				// found the entry
				hr = (m_pHandler->*((DHEVTFUNC) (m_pHandler->GetDHtmlEventMap()[i].pfnEventFunc)))(spsrcElem);
				if (pVarResult)
				{
					pVarResult->vt = VT_BOOL;
					pVarResult->boolVal = (hr==S_OK) ? ATL_VARIANT_TRUE : ATL_VARIANT_FALSE;
				}
				return S_OK;
			}
		}
	}

	return DISP_E_MEMBERNOTFOUND;
}

HRESULT CDHtmlElementEventSink::Advise(LPUNKNOWN pUnkObj, REFIID iid)
{
	return AtlAdvise((LPUNKNOWN)pUnkObj, (LPDISPATCH)this, iid, &m_dwCookie);

}

HRESULT CDHtmlElementEventSink::UnAdvise(LPUNKNOWN pUnkObj, REFIID iid)
{
	iid; // unused

	return AtlUnadvise((LPUNKNOWN)pUnkObj, __uuidof(HTMLElementEvents), m_dwCookie);
}

/////////////////////////////////////////////////////////////////////////////
// CBrowserControlSite

CBrowserControlSite::CBrowserControlSite(COleControlContainer* pCtrlCont, CDHtmlDialog *pHandler) :
	COleControlSite(pCtrlCont)
{
	ASSERT(pHandler);
	m_pHandler = pHandler;
}

LPUNKNOWN CBrowserControlSite::GetInterfaceHook(const void *iid)
{
	if (IsEqualIID((REFIID) (*(IID*)iid), IID_IDocHostUIHandler))
		return (IDocHostUIHandler *) this;
	return NULL;
}

// IUnknown methods
STDMETHODIMP CBrowserControlSite::QueryInterface(REFIID riid, void **ppvObject)
{
	return COleControlSite::ExternalQueryInterface(&riid, ppvObject);
}
STDMETHODIMP_(ULONG) CBrowserControlSite::AddRef()
{
	return ExternalAddRef();
}

STDMETHODIMP_(ULONG) CBrowserControlSite::Release()
{
	return ExternalRelease();
}

// IDocHostUIHandler methods
STDMETHODIMP CBrowserControlSite::ShowContextMenu(DWORD dwID, POINT *ppt, IUnknown *pcmdtReserved, IDispatch *pdispReserved)
{
	return m_pHandler->ShowContextMenu(dwID, ppt, pcmdtReserved, pdispReserved);
}
STDMETHODIMP CBrowserControlSite::GetHostInfo(DOCHOSTUIINFO *pInfo)
{
	return m_pHandler->GetHostInfo(pInfo);
}
STDMETHODIMP CBrowserControlSite::ShowUI(DWORD dwID, IOleInPlaceActiveObject *pActiveObject, IOleCommandTarget *pCommandTarget, IOleInPlaceFrame *pFrame, IOleInPlaceUIWindow *pDoc)
{
	return m_pHandler->ShowUI(dwID, pActiveObject, pCommandTarget, pFrame, pDoc);
}
STDMETHODIMP CBrowserControlSite::HideUI(void)
{
	return m_pHandler->HideUI();
}
STDMETHODIMP CBrowserControlSite::UpdateUI(void)
{
	return m_pHandler->UpdateUI();
}
STDMETHODIMP CBrowserControlSite::EnableModeless(BOOL fEnable)
{
	return m_pHandler->EnableModeless(fEnable);
}
STDMETHODIMP CBrowserControlSite::OnDocWindowActivate(BOOL fActivate)
{
	return m_pHandler->OnDocWindowActivate(fActivate);
}
STDMETHODIMP CBrowserControlSite::OnFrameWindowActivate(BOOL fActivate)
{
	return m_pHandler->OnFrameWindowActivate(fActivate);
}
STDMETHODIMP CBrowserControlSite::ResizeBorder(LPCRECT prcBorder, IOleInPlaceUIWindow *pUIWindow, BOOL fRameWindow)
{
	return m_pHandler->ResizeBorder(prcBorder, pUIWindow, fRameWindow);
}
STDMETHODIMP CBrowserControlSite::TranslateAccelerator(LPMSG lpMsg, const GUID *pguidCmdGroup, DWORD nCmdID)
{
	return m_pHandler->TranslateAccelerator(lpMsg, pguidCmdGroup, nCmdID);
}
STDMETHODIMP CBrowserControlSite::GetOptionKeyPath(LPOLESTR *pchKey, DWORD dw)
{
	return m_pHandler->GetOptionKeyPath(pchKey, dw);
}
STDMETHODIMP CBrowserControlSite::GetDropTarget(IDropTarget *pDropTarget, IDropTarget **ppDropTarget)
{
	return m_pHandler->GetDropTarget(pDropTarget, ppDropTarget);
}
STDMETHODIMP CBrowserControlSite::GetExternal(IDispatch **ppDispatch)
{
	return m_pHandler->GetExternal(ppDispatch);
}
STDMETHODIMP CBrowserControlSite::TranslateUrl(DWORD dwTranslate, OLECHAR *pchURLIn, OLECHAR **ppchURLOut)
{
	return m_pHandler->TranslateUrl(dwTranslate, pchURLIn, ppchURLOut);
}
STDMETHODIMP CBrowserControlSite::FilterDataObject(IDataObject *pDO, IDataObject **ppDORet)
{
	return m_pHandler->FilterDataObject(pDO, ppDORet);
}

/////////////////////////////////////////////////////////////////////////////
// CDHtmlDialog

CDHtmlDialog::CDHtmlDialog() :
	CDialog()
{
	Initialize();
}

CDHtmlDialog::CDHtmlDialog(UINT nIDTemplate, UINT nHtmlResID /*= 0*/, CWnd *pParentWnd /*= NULL*/) : 
	CDialog(nIDTemplate, pParentWnd)
{	
	Initialize();
	m_nHtmlResID = nHtmlResID;
}

CDHtmlDialog::CDHtmlDialog(LPCTSTR lpszTemplateName, LPCTSTR szHtmlResID /*= NULL*/, CWnd *pParentWnd /*= NULL*/) :
	CDialog(lpszTemplateName, pParentWnd)
{
	Initialize();
	m_szHtmlResID = const_cast<LPTSTR>(szHtmlResID);
}

CDHtmlDialog::~CDHtmlDialog()
{
}

BOOL CDHtmlDialog::CreateControlSite(COleControlContainer* pContainer, 
		COleControlSite** ppSite, UINT /* nID */, REFCLSID /* clsid */)
{
	if(ppSite == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}
		
	CBrowserControlSite *pBrowserSite = 
			new CBrowserControlSite(pContainer, this);
	if (!pBrowserSite)
		return FALSE;
		
	*ppSite = pBrowserSite;
	return TRUE;
}

HRESULT CDHtmlDialog::GetDHtmlDocument(IHTMLDocument2 **pphtmlDoc)
{
	if(pphtmlDoc == NULL)
	{
		ASSERT(FALSE);
		return E_POINTER;
	}
	
	*pphtmlDoc = NULL;

	if (m_spHtmlDoc)
	{
		*pphtmlDoc = m_spHtmlDoc;
		(*pphtmlDoc)->AddRef();
		return S_OK;
	}
	return E_NOINTERFACE;
}

void CDHtmlDialog::GetCurrentUrl(CString& szUrl)
{
	szUrl = m_strCurrentUrl;
}

BOOL CDHtmlDialog::CanAccessExternal()
{
	// if the dispatch we have is safe, 
	// we allow access
	if (IsExternalDispatchSafe())
		return TRUE;

	// the external dispatch is not safe, so we check
	// whether the current zone allows for scripting
	// of objects that are not safe for scripting
	if (m_spHtmlDoc == NULL)
		return FALSE;

	CComPtr<IInternetHostSecurityManager> spSecMan;
	m_spHtmlDoc->QueryInterface(IID_IInternetHostSecurityManager,
			(void **) &spSecMan);
	if (spSecMan == NULL)
		return FALSE;

	HRESULT hr = spSecMan->ProcessUrlAction(URLACTION_ACTIVEX_OVERRIDE_OBJECT_SAFETY,
		NULL, 0, NULL, 0, 0, PUAF_DEFAULT);
	if (hr == S_OK)
		return TRUE;
	return FALSE;
}

void CDHtmlDialog::OnBeforeNavigate(LPDISPATCH pDisp, LPCTSTR szUrl)
{
	szUrl; // unused

	if (pDisp != m_pBrowserApp)
		return;
	DisconnectDHtmlEvents();
	m_spHtmlDoc = NULL;
	m_strCurrentUrl.Empty();
}

void CDHtmlDialog::OnNavigateComplete(LPDISPATCH pDisp, LPCTSTR szUrl)
{
	if (pDisp != m_pBrowserApp)
		return;
	IDispatch *pdispDoc = NULL;
	m_pBrowserApp->get_Document(&pdispDoc);
	if (!pdispDoc)
		return;

	ASSERT(m_spHtmlDoc==NULL);

	pdispDoc->QueryInterface(IID_IHTMLDocument2, (void **) &m_spHtmlDoc);

	if (m_bUseHtmlTitle)
	{
		CComBSTR bstrTitle;
		m_spHtmlDoc->get_title(&bstrTitle);
		CString str = CString(bstrTitle);
		SetWindowText(str);
	}

	m_strCurrentUrl = szUrl;

	ConnectDHtmlEvents(pdispDoc);
	pdispDoc->Release();
}

void CDHtmlDialog::OnDocumentComplete(LPDISPATCH pDisp, LPCTSTR szUrl)
{
	szUrl; // unused

	if (pDisp != m_pBrowserApp)
		return;
	ConnectDHtmlElementEvents((((DWORD_PTR)static_cast< CDHtmlSinkHandler* >(this)) - (DWORD_PTR)this));
	UpdateData(FALSE);
}

BOOL CDHtmlDialog::LoadFromResource(LPCTSTR lpszResource)
{
	HINSTANCE hInstance = AfxGetResourceHandle();
	ASSERT(hInstance != NULL);

	CString strResourceURL;
	BOOL bRetVal = TRUE;
	LPTSTR lpszModule = new TCHAR[_MAX_PATH];

	int ret = GetModuleFileName(hInstance, lpszModule, _MAX_PATH);
	
	if (ret == 0 || ret == _MAX_PATH)
		bRetVal = FALSE;
	else
	{
		strResourceURL.Format(_T("res://%s/%s"), lpszModule, lpszResource);
		Navigate(strResourceURL, 0, 0, 0);
	}

	delete [] lpszModule;
	return bRetVal;
}

BOOL CDHtmlDialog::LoadFromResource(UINT nRes)
{
	HINSTANCE hInstance = AfxGetResourceHandle();
	ASSERT(hInstance != NULL);

	CString strResourceURL;
	BOOL bRetVal = TRUE;
	LPTSTR lpszModule = new TCHAR[_MAX_PATH];

	if (GetModuleFileName(hInstance, lpszModule, _MAX_PATH))
	{
		strResourceURL.Format(_T("res://%s/%d"), lpszModule, nRes);
		Navigate(strResourceURL, 0, 0, 0);
	}
	else
		bRetVal = FALSE;

	delete [] lpszModule;
	return bRetVal;
}

void CDHtmlDialog::Navigate(LPCTSTR lpszURL, DWORD dwFlags /*= 0*/, 
	LPCTSTR lpszTargetFrameName /*= NULL*/, LPCTSTR lpszHeaders /*= NULL*/,
	LPVOID lpvPostData /*= NULL*/, DWORD dwPostDataLen /*= 0*/)
{
	CComBSTR bstrURL = lpszURL;

	COleSafeArray vPostData;
	if (lpvPostData != NULL)
	{
		if (dwPostDataLen == 0)
			dwPostDataLen = lstrlen((LPCTSTR) lpvPostData);

		vPostData.CreateOneDim(VT_UI1, dwPostDataLen, lpvPostData);
	}

	m_pBrowserApp->Navigate(bstrURL,
		COleVariant((long) dwFlags, VT_I4),
		COleVariant(lpszTargetFrameName, VT_BSTR),
		vPostData,
		COleVariant(lpszHeaders, VT_BSTR));
}

void CDHtmlDialog::DestroyModeless()
{
	if (!CDHtmlDialog::WM_DESTROYMODELESS)
		CDHtmlDialog::WM_DESTROYMODELESS = RegisterWindowMessage(_T("DHtmlDialogDestroy"));
	PostMessage(CDHtmlDialog::WM_DESTROYMODELESS, 0, 0);
}

void CDHtmlDialog::OnDestroy()
{
	DisconnectDHtmlEvents();
	m_spHtmlDoc = NULL;

	// now tell the browser control we're shutting down
	if (m_pBrowserApp)
	{
		CComPtr<IOleObject> spObject;
		m_pBrowserApp->QueryInterface(IID_IOleObject, (void **) &spObject);
		if (spObject != NULL)
		{
			spObject->Close(OLECLOSE_NOSAVE);
			spObject.Release();
		}
		m_pBrowserApp = NULL;
	}
	CDialog::OnDestroy();
}

void CDHtmlDialog::OnSize(UINT nType, int cx, int cy)
{
	CDialog::OnSize(nType, cx, cy);
	if (!m_bAttachedControl && m_wndBrowser.m_hWnd)
		m_wndBrowser.MoveWindow(0, 0, cx, cy);	
}

BOOL CDHtmlDialog::OnInitDialog()
{
	AfxEnableControlContainer();

	CDialog::OnInitDialog();

	RECT rectClient;
	GetClientRect(&rectClient);

	// if we've been created from the dynamic template
	// set the caption
	if (!m_lpszTemplateName)
		SetWindowText(m_strDlgCaption);

	// check if there is a browser control on the dialog
	// already
	CWnd *pCtrl = GetDlgItem(AFX_IDC_BROWSER);
	LPUNKNOWN lpUnk;
	if (pCtrl)
	{
		lpUnk = pCtrl->GetControlUnknown();
		if (lpUnk && SUCCEEDED(lpUnk->QueryInterface(IID_IWebBrowser2, (void **) &m_pBrowserApp)))
		{
			m_wndBrowser.Attach(pCtrl->m_hWnd);
			m_bAttachedControl = TRUE;
		}
	}
	if (m_pBrowserApp == NULL)
	{
		// create the control window
		m_wndBrowser.CreateControl(CLSID_WebBrowser, NULL,
					WS_VISIBLE | WS_CHILD, rectClient, this, AFX_IDC_BROWSER);
		lpUnk = m_wndBrowser.GetControlUnknown();
		if (FAILED(lpUnk->QueryInterface(IID_IWebBrowser2, (void**) &m_pBrowserApp)))
		{
			m_wndBrowser.DestroyWindow();
			DestroyWindow();
			return TRUE;
		}
	}

	if (m_nHtmlResID)
		LoadFromResource(m_nHtmlResID);
	else if (m_szHtmlResID)
		LoadFromResource(m_szHtmlResID);
	else if (m_strCurrentUrl)
		Navigate(m_strCurrentUrl);
	return TRUE;
}

BEGIN_DHTML_EVENT_MAP_INLINE(CDHtmlDialog)
	DHTML_EVENT(DISPID_EVMETH_ONREADYSTATECHANGE, NULL, OnDocumentReadyStateChange)
END_DHTML_EVENT_MAP_INLINE()

void CDHtmlDialog::Initialize()
{
	SetHostFlags(DOCHOSTUIFLAG_NO3DBORDER | DOCHOSTUIFLAG_SCROLL_NO);
	m_bUseHtmlTitle = FALSE;
	m_bAttachedControl = FALSE;
	m_pBrowserApp = NULL;
	m_dwDHtmlEventSinkCookie = 0;
	m_szHtmlResID = NULL;
	m_nHtmlResID = 0;
}

void CDHtmlDialog::_OnBeforeNavigate2(LPDISPATCH pDisp, VARIANT FAR* URL, VARIANT FAR* Flags, VARIANT FAR* TargetFrameName, VARIANT FAR* PostData, VARIANT FAR* Headers, BOOL FAR* Cancel)
{
	Flags; // unused
	TargetFrameName; // unused
	PostData; // unused
	Headers; // unused
	Cancel; // unused

	CString str(V_BSTR(URL));
	OnBeforeNavigate(pDisp, str);
}

void CDHtmlDialog::_OnNavigateComplete2(LPDISPATCH pDisp, VARIANT FAR* URL)
{
	ASSERT(V_VT(URL) == VT_BSTR);

	CString str(V_BSTR(URL));

	OnNavigateComplete(pDisp, str);
}

void CDHtmlDialog::_OnDocumentComplete(LPDISPATCH pDisp, VARIANT* URL)
{
	ASSERT(V_VT(URL) == VT_BSTR);

	CString str(V_BSTR(URL));
	OnDocumentComplete(pDisp, str);
}

HRESULT CDHtmlDialog::OnDocumentReadyStateChange(IHTMLElement *phtmlElem)
{
	phtmlElem; // unused

	CComPtr<IHTMLDocument2> sphtmlDoc;
	GetDHtmlDocument(&sphtmlDoc);
	if (sphtmlDoc)
	{
		CComBSTR bstrState;
		sphtmlDoc->get_readyState(&bstrState);
		if (bstrState)
		{
			if (bstrState==TEXT("complete"))
				ConnectDHtmlElementEvents((((DWORD_PTR)static_cast< CDHtmlSinkHandler* >(this)) - (DWORD_PTR) this));
			else if (bstrState==TEXT("loading"))
				DisconnectDHtmlElementEvents();
		}
	}
	return S_OK;
}

LRESULT CDHtmlDialog::OnDestroyModeless(WPARAM, LPARAM)
{
	DestroyWindow();
	return 0;
}

void CDHtmlDialog::DDX_DHtml_ElementText(CDataExchange* pDX, LPCTSTR szId, DISPID dispid, CString& value)
{
	DDX_DHtml_ElementText(szId, dispid, value, pDX->m_bSaveAndValidate);
}

void CDHtmlDialog::DDX_DHtml_ElementText(CDataExchange* pDX, LPCTSTR szId, DISPID dispid, short& value)
{
	DDX_DHtml_ElementText(szId, dispid, value, pDX->m_bSaveAndValidate);
}

void CDHtmlDialog::DDX_DHtml_ElementText(CDataExchange* pDX, LPCTSTR szId, DISPID dispid, int& value)
{
	DDX_DHtml_ElementText(szId, dispid, value, pDX->m_bSaveAndValidate);
}

void CDHtmlDialog::DDX_DHtml_ElementText(CDataExchange* pDX, LPCTSTR szId, DISPID dispid, long& value)
{
	DDX_DHtml_ElementText(szId, dispid, value, pDX->m_bSaveAndValidate);
}

void CDHtmlDialog::DDX_DHtml_ElementText(CDataExchange* pDX, LPCTSTR szId, DISPID dispid, DWORD& value)
{
	DDX_DHtml_ElementText(szId, dispid, value, pDX->m_bSaveAndValidate);
}

void CDHtmlDialog::DDX_DHtml_ElementText(CDataExchange* pDX, LPCTSTR szId, DISPID dispid, float& value)
{
	DDX_DHtml_ElementText(szId, dispid, value, pDX->m_bSaveAndValidate);
}

void CDHtmlDialog::DDX_DHtml_ElementText(CDataExchange* pDX, LPCTSTR szId, DISPID dispid, double& value)
{
	DDX_DHtml_ElementText(szId, dispid, value, pDX->m_bSaveAndValidate);
}

void CDHtmlDialog::DDX_DHtml_CheckBox(CDataExchange* pDX, LPCTSTR szId, int& value)
{
	DDX_DHtml_CheckBox(szId, value, pDX->m_bSaveAndValidate);
}

void CDHtmlDialog::DDX_DHtml_Radio(CDataExchange* pDX, LPCTSTR szId, long& value)
{
	DDX_DHtml_Radio(szId, value, pDX->m_bSaveAndValidate);
}

void CDHtmlDialog::DDX_DHtml_SelectValue(CDataExchange* pDX, LPCTSTR szId, CString& value)
{
	DDX_DHtml_SelectValue(szId, value, pDX->m_bSaveAndValidate);
}

void CDHtmlDialog::DDX_DHtml_SelectString(CDataExchange* pDX, LPCTSTR szId, CString& value)
{
	DDX_DHtml_SelectString(szId, value, pDX->m_bSaveAndValidate);
}

void CDHtmlDialog::DDX_DHtml_SelectIndex(CDataExchange* pDX, LPCTSTR szId, long& value)
{
	DDX_DHtml_SelectIndex(szId, value, pDX->m_bSaveAndValidate);
}

void CDHtmlDialog::DDX_DHtml_AxControl(CDataExchange *pDX, LPCTSTR szId, DISPID dispid, VARIANT& var)
{
	DDX_DHtml_AxControl(szId, dispid, var, pDX->m_bSaveAndValidate);
}

void CDHtmlDialog::DDX_DHtml_AxControl(CDataExchange *pDX, LPCTSTR szId, LPCTSTR szPropName, VARIANT& var)
{
	DDX_DHtml_AxControl(szId, szPropName, var, pDX->m_bSaveAndValidate);
}

void CDHtmlDialog::DDX_DHtml_ElementText(LPCTSTR szId, DISPID dispid, CString& value, BOOL bSave)
{
	CComPtr<IHTMLDocument2> sphtmlDoc;
	GetDHtmlDocument(&sphtmlDoc);
	if (sphtmlDoc == NULL)
		return;

	CComVariant var;
	if (bSave)
	{
		var = GetElementProperty(szId, dispid);
		var.ChangeType(VT_BSTR);
		value = var.bstrVal;
	}
	else
	{
		var = (LPCTSTR)value;
		SetElementProperty(szId, dispid, &var);
	}
}

void CDHtmlDialog::DDX_DHtml_ElementText(LPCTSTR szId, DISPID dispid, short& value, BOOL bSave)
{
	if (bSave)
		DDX_DHtml_ElementTextWithFormat(szId, dispid, _T("%sd"), AFX_IDP_PARSE_INT, bSave, &value);
	else
		DDX_DHtml_ElementTextWithFormat(szId, dispid, _T("%hd"), AFX_IDP_PARSE_INT, bSave, value);
}

void CDHtmlDialog::DDX_DHtml_ElementText(LPCTSTR szId, DISPID dispid, int& value, BOOL bSave)
{
	if (bSave)
		DDX_DHtml_ElementTextWithFormat(szId, dispid, _T("%d"), AFX_IDP_PARSE_INT, bSave, &value);
	else
		DDX_DHtml_ElementTextWithFormat(szId, dispid, _T("%d"), AFX_IDP_PARSE_INT, bSave, value);
}

void CDHtmlDialog::DDX_DHtml_ElementText(LPCTSTR szId, DISPID dispid, long& value, BOOL bSave)
{
	if (bSave)
		DDX_DHtml_ElementTextWithFormat(szId, dispid, _T("%ld"), AFX_IDP_PARSE_INT, bSave, &value);
	else
		DDX_DHtml_ElementTextWithFormat(szId, dispid, _T("%ld"), AFX_IDP_PARSE_INT, bSave, value);
}

void CDHtmlDialog::DDX_DHtml_ElementText(LPCTSTR szId, DISPID dispid, DWORD& value, BOOL bSave)
{
	if (bSave)
		DDX_DHtml_ElementTextWithFormat(szId, dispid, _T("%lu"), AFX_IDP_PARSE_UINT, bSave, &value);
	else
		DDX_DHtml_ElementTextWithFormat(szId, dispid, _T("%lu"), AFX_IDP_PARSE_UINT, bSave, value);
}

void CDHtmlDialog::DDX_DHtml_ElementText(LPCTSTR szId, DISPID dispid, float& value, BOOL bSave)
{
	DDX_DHtml_ElementTextFloatFormat(szId, dispid, &value, value, FLT_DIG, bSave);
}

void CDHtmlDialog::DDX_DHtml_ElementText(LPCTSTR szId, DISPID dispid, double& value, BOOL bSave)
{
	DDX_DHtml_ElementTextFloatFormat(szId, dispid, &value, value, DBL_DIG, bSave);
}

/////////////////////////////////////////////////////////////////////////////
// Data exchange for special controls
void CDHtmlDialog::DDX_DHtml_CheckBox(LPCTSTR szId, int& value, BOOL bSave)
{
	COleVariant var;

	CComPtr<IHTMLDocument2> sphtmlDoc;
	GetDHtmlDocument(&sphtmlDoc);
	if (sphtmlDoc == NULL)
		return;

	CComPtr<IHTMLOptionButtonElement> spOptionButton;
	HRESULT hr = S_OK;

	hr = GetElementInterface(szId, __uuidof(IHTMLOptionButtonElement), (void **) &spOptionButton);
	if (spOptionButton == NULL)
		goto Error;


	if (bSave)
	{
		VARIANT_BOOL bIndeterminate;
		VARIANT_BOOL bChecked;
		hr = spOptionButton->get_checked(&bChecked);
		if (FAILED(hr))
			goto Error;
		hr = spOptionButton->get_indeterminate(&bIndeterminate);
		if (FAILED(hr))
			goto Error;
		value = ((bChecked != ATL_VARIANT_FALSE) ? BST_CHECKED : BST_UNCHECKED) | 
			((bIndeterminate != ATL_VARIANT_FALSE) ? BST_INDETERMINATE : 0);
	}
	else
	{
		hr = spOptionButton->put_checked((value & BST_CHECKED) ? ATL_VARIANT_TRUE : ATL_VARIANT_FALSE);
		if (FAILED(hr))
			goto Error;
		hr = spOptionButton->put_indeterminate((value & BST_INDETERMINATE) ? ATL_VARIANT_TRUE : ATL_VARIANT_FALSE);
		if (FAILED(hr))
			goto Error;
	}
Error:
	if (FAILED(hr))
	{
		TRACE(traceHtml, 0, "Failed DDX_DHtml_CheckBox\n");
	}
}

void CDHtmlDialog::DDX_DHtml_Radio(LPCTSTR szId, long& value, BOOL bSave)
{
	COleVariant var;

	CComPtr<IHTMLDocument2> sphtmlDoc;
	GetDHtmlDocument(&sphtmlDoc);
	if (sphtmlDoc == NULL)
		return;

	CComPtr<IHTMLOptionButtonElement> spOptionButton;
	CComPtr<IDispatch> spdispCollection;
	CComPtr<IHTMLElementCollection> spElementColl;
	BOOL bIsCollection = FALSE;
	CComPtr<IDispatch> spdispElem;

	HRESULT hr = S_OK;
	COleVariant varIndex;
	COleVariant varEmpty;
	varIndex.vt = VT_I4;
	varIndex.lVal = 0;

	// get the radio buttons in the group
	hr = GetElement(szId, &spdispCollection, &bIsCollection);
	if (spdispCollection && bIsCollection)
	{
		hr = spdispCollection->QueryInterface(__uuidof(IHTMLElementCollection), (void **) &spElementColl);
		if (spElementColl == NULL)
		{
			TRACE(traceHtml, 0, "Error: Collection didn't support IHTMLElementCollection!\n");
			ASSERT(FALSE);
			goto Error;
		}

		if (bSave)
			value = -1;     // value if none found

		long lCount = 0;
		spElementColl->get_length(&lCount);

		for (long lCntr = 0; lCntr < lCount; lCntr++)
		{				
			spdispElem = NULL;
			spOptionButton = NULL;
			varIndex.lVal = lCntr;
			hr = spElementColl->item(varIndex, varEmpty, &spdispElem);
			if (spdispElem == NULL)
				break;
			hr = spdispElem->QueryInterface(__uuidof(IHTMLOptionButtonElement), (void **) &spOptionButton);

			if (bSave)
			{
				VARIANT_BOOL bChecked;
				hr = spOptionButton->get_checked(&bChecked);
				if (FAILED(hr))
					goto Error;
				if (bChecked != ATL_VARIANT_FALSE)
				{
					value = varIndex.lVal;
					break;
				}
			}
			else
			{
				if (varIndex.lVal == value)
				{
					spOptionButton->put_checked(ATL_VARIANT_TRUE);
					break;
				}
			}
		};
	}
Error:
	if (FAILED(hr))
	{
		TRACE(traceHtml, 0, "Warning: Failed DDX_DHtml_Radio\n");
	}
}

void CDHtmlDialog::DDX_DHtml_SelectValue(LPCTSTR szId, CString& value, BOOL bSave)
{
	CComPtr<IHTMLDocument2> sphtmlDoc;
	GetDHtmlDocument(&sphtmlDoc);
	if (sphtmlDoc == NULL)
		return;

	CComBSTR bstrText;
	CComPtr<IHTMLSelectElement> spSelect;
	HRESULT hr = GetElementInterface(szId, __uuidof(IHTMLSelectElement), (void **) &spSelect);
	if (FAILED(hr))
		goto Error;

	if (bSave)
	{
		spSelect->get_value(&bstrText);
		if (bstrText)
			value = bstrText;
	}
	else
	{
		bstrText.Attach(value.AllocSysString());
		spSelect->put_value(bstrText);
	}

Error:
	return;
}

void CDHtmlDialog::DDX_DHtml_SelectString(LPCTSTR szId, CString& value, BOOL bSave)
{
	CComPtr<IHTMLDocument2> sphtmlDoc;
	GetDHtmlDocument(&sphtmlDoc);
	if (sphtmlDoc == NULL)
		return;

	COleVariant varEmpty, varIndex;

	CComPtr<IHTMLSelectElement> spSelect;
	CComPtr<IDispatch> spdispOption;
	CComPtr<IHTMLOptionElement> spOption;
	CComBSTR bstrText;
	HRESULT hr = S_OK;
	long lIndex=-1;

	hr = GetElementInterface(szId, __uuidof(IHTMLSelectElement), (void **) &spSelect);
	if (spSelect == NULL)
		return;

	if (bSave)
	{
		// get the selected item
		value.Empty();
		spSelect->get_selectedIndex(&lIndex);
		if (lIndex >= 0)
		{
			varIndex = lIndex;

			spSelect->item(varIndex, varEmpty, &spdispOption);
			if (spdispOption)
			{
				spdispOption->QueryInterface(__uuidof(IHTMLOptionElement), (void **) &spOption);
				if (spOption)
				{
					spOption->get_text(&bstrText);
					if (bstrText)
						value = bstrText;
				}
			}
		}
	}
	else
	{
		bstrText.Attach(value.AllocSysString());
		lIndex = Select_FindString(spSelect, bstrText, FALSE);
		spSelect->put_selectedIndex(lIndex);
	}
}

void CDHtmlDialog::DDX_DHtml_SelectIndex(LPCTSTR szId, long& value, BOOL bSave)
{
	CComPtr<IHTMLDocument2> sphtmlDoc;
	GetDHtmlDocument(&sphtmlDoc);
	if (sphtmlDoc == NULL)
		return;

	CComPtr<IHTMLSelectElement> spSelect;
	HRESULT hr;

	hr = GetElementInterface(szId, __uuidof(IHTMLSelectElement), (void **) &spSelect);
	if (spSelect == NULL)
		return;

	if (bSave)
		spSelect->get_selectedIndex(&value);
	else
		spSelect->put_selectedIndex(value);
}

void CDHtmlDialog::DDX_DHtml_AxControl(LPCTSTR szId, DISPID dispid, VARIANT& var, BOOL bSave)
{
	if (bSave)
		var = GetControlProperty(szId, dispid);
	else
		SetControlProperty(szId, dispid, &var);
}

void CDHtmlDialog::DDX_DHtml_AxControl(LPCTSTR szId, LPCTSTR szPropName, VARIANT& var, BOOL bSave)
{
	if (bSave)
		var = GetControlProperty(szId, szPropName);
	else
		SetControlProperty(szId, szPropName, &var);
}

void CDHtmlDialog::OnDDXError(LPCTSTR szId, UINT nIDPrompt, BOOL /*bSave*/)
{
	AfxMessageBox(nIDPrompt);
	// default implementation just sets the
	// focus back to the offending element
	SetFocusToElement(szId);
	CComPtr<IHTMLEventObj> sphtmlEvent;
	GetEvent(&sphtmlEvent);
	if (sphtmlEvent)
		sphtmlEvent->put_cancelBubble(ATL_VARIANT_TRUE);
	AfxThrowUserException();
}

void __cdecl CDHtmlDialog::DDX_DHtml_ElementTextWithFormat(LPCTSTR szId,
	DISPID dispid, LPCTSTR lpszFormat, UINT nIDPrompt, BOOL bSave, ...)
	// only supports windows output formats - no floating point
{
	va_list pData;
	va_start(pData, bSave);

	CString value;

	if (bSave)
	{
		DDX_DHtml_ElementText(szId, dispid, value, bSave);
		// the following works for %d, %u, %ld, %lu
		if (!_AfxSimpleScanf(value, lpszFormat, pData))
		{
			// set the focus to the offending element
			SetFocusToElement(szId);

			OnDDXError(szId, nIDPrompt, bSave);
			va_end(pData);
			return;
		}
	}
	else
	{
		CString strTemp ;
		strTemp.FormatV(lpszFormat,pData);
		// does not support floating point numbers - see dlgfloat.cpp
		DDX_DHtml_ElementText(szId, dispid, strTemp, bSave);
	}
	va_end(pData);
}

void CDHtmlDialog::DDX_DHtml_ElementTextFloatFormat(LPCTSTR szId,
	DISPID dispid, void* pData, double value, int nSizeGcvt, BOOL bSave)
{
	ATLASSERT(pData != NULL);

	CString strValue;
	if (bSave)
	{
		DDX_DHtml_ElementText(szId, dispid, strValue, bSave);
		double d;
		if (!_AfxSimpleFloatParse(strValue, d))
		{
			OnDDXError(szId, AFX_IDP_PARSE_REAL, bSave);
		}
		if (nSizeGcvt == FLT_DIG)
			*((float*)pData) = (float)d;
		else
			*((double*)pData) = d;
	}
	else
	{
		CString szBuffer;
		szBuffer.Format(_T("%.*g"), nSizeGcvt, value);
		DDX_DHtml_ElementText(szId, dispid, szBuffer, bSave);
	}
}


BOOL CDHtmlDialog::_AfxSimpleScanf(LPCTSTR lpszText,
	LPCTSTR lpszFormat, va_list pData)
{
	ATLASSERT(lpszText != NULL);
	ATLASSERT(lpszFormat != NULL);

	ATLASSERT(*lpszFormat == '%');
	lpszFormat++;        // skip '%'

	BOOL bLong = FALSE;
	BOOL bShort = FALSE;
	if (*lpszFormat == 'l')
	{
		bLong = TRUE;
		lpszFormat++;
	}
	else if (*lpszFormat == 's')
	{
		bShort = TRUE;
		lpszFormat++;
	}

	ATLASSERT(*lpszFormat == 'd' || *lpszFormat == 'u');
	ATLASSERT(lpszFormat[1] == '\0');

	while (*lpszText == ' ' || *lpszText == '\t')
		lpszText++;
	TCHAR chFirst = lpszText[0];
	long l, l2;
	if (*lpszFormat == 'd')
	{
		// signed
		l = _tcstol(lpszText, (LPTSTR*)&lpszText, 10);
		l2 = (int)l;
	}
	else
	{
		// unsigned
		if (*lpszText == '-')
			return FALSE;
		l = (long)_tcstoul(lpszText, (LPTSTR*)&lpszText, 10);
		l2 = (unsigned int)l;
	}
	if (l == 0 && chFirst != '0')
		return FALSE;   // could not convert

	while (*lpszText == ' ' || *lpszText == '\t')
		lpszText++;
	if (*lpszText != '\0')
		return FALSE;   // not terminated properly

	if (bShort)
	{
		if ((short)l != l)
			return FALSE;   // too big for short
		*va_arg(pData, short*) = (short)l;
	}
	else
	{
		ATLASSERT(sizeof(long) == sizeof(int));
		ATLASSERT(l == l2);
		*va_arg(pData, long*) = l;
	}

	// all ok
	return TRUE;
}

BOOL CDHtmlDialog::_AfxSimpleFloatParse(LPCTSTR lpszText, double& d)
{
	ATLASSERT(lpszText != NULL);
	while (*lpszText == ' ' || *lpszText == '\t')
		lpszText++;

	TCHAR chFirst = lpszText[0];
	d = _tcstod(lpszText, (LPTSTR*)&lpszText);
	if (d == 0.0 && chFirst != '0')
		return FALSE;   // could not convert
	while (*lpszText == ' ' || *lpszText == '\t')
		lpszText++;

	if (*lpszText != '\0')
		return FALSE;   // not terminated properly

	return TRUE;
}

long CDHtmlDialog::Select_FindString(IHTMLSelectElement *pSelect, BSTR bstr, BOOL /*fExact*/)
{
	long lIndexFound = -1;
	COleVariant varIndex, varEmpty;
	CComPtr<IDispatch> spdispOption;
	CComPtr<IHTMLOptionElement> spOption;
	long lCount = 0;

	HRESULT hr = pSelect->get_length(&lCount);
	if (FAILED(hr))
		goto Error;
	varIndex.vt = VT_I4;
	// loop through the items searching for the string
	for (varIndex.lVal=0; varIndex.lVal<lCount; varIndex.lVal++)
	{
		pSelect->item(varIndex, varEmpty, &spdispOption);
		if (spdispOption)
		{
			spdispOption->QueryInterface(__uuidof(IHTMLOptionElement), (void **) &spOption);
			if (spOption)
			{
				CComBSTR bstrText;
				spOption->get_text(&bstrText);
				if (bstrText && !wcscmp(bstrText, bstr))
				{
					// we found it
					lIndexFound = varIndex.lVal;
					break;
				}
				spOption = NULL;
			}
			spdispOption = NULL;
		}
	}

Error:
	return lIndexFound;
}

void CDHtmlDialog::SetFocusToElement(LPCTSTR szId)
{
	// check if the element is a control element
	CComPtr<IHTMLControlElement> sphtmlCtrlElem;
	HRESULT hr = GetElementInterface(szId, &sphtmlCtrlElem);
	if (sphtmlCtrlElem)
	{
		sphtmlCtrlElem->focus();
		return;
	}

	// check if the element is an anchor element
	CComPtr<IHTMLAnchorElement> sphtmlAnchorElem;
	hr = GetElementInterface(szId, &sphtmlAnchorElem);
	if (sphtmlAnchorElem)
	{
		sphtmlAnchorElem->focus();
		return;
	}

	// otherwise all we can do is scroll the element into view
	CComPtr<IHTMLElement> sphtmlElem;
	hr = GetElementInterface(szId, &sphtmlElem);
	if (sphtmlElem)
	{
		CComVariant var;
		var.vt = VT_BOOL;
		var.boolVal = ATL_VARIANT_TRUE;
		sphtmlElem->scrollIntoView(var);
	}
}

HRESULT CDHtmlDialog::ConnectDHtmlEvents(IUnknown *punkDoc)
{
	return ConnectToConnectionPoint(punkDoc, __uuidof(HTMLDocumentEvents), &m_dwDHtmlEventSinkCookie);
}

void CDHtmlDialog::DisconnectDHtmlEvents()
{
	CComPtr<IHTMLDocument2> sphtmlDoc;
	GetDHtmlDocument(&sphtmlDoc);

	if (sphtmlDoc == NULL)
		return;
	DisconnectFromConnectionPoint(sphtmlDoc, __uuidof(HTMLDocumentEvents), m_dwDHtmlEventSinkCookie);
	DisconnectDHtmlElementEvents();
}

HRESULT CDHtmlDialog::ConnectDHtmlElementEvents(DWORD_PTR dwThunkOffset /*= 0*/)
{
	HRESULT hr = S_OK;
	const DHtmlEventMapEntry* pEventMap = GetDHtmlEventMap();
	if (!pEventMap)
		return hr;

	for (int i=0; pEventMap[i].nType != DHTMLEVENTMAPENTRY_END; i++)
	{
		if (pEventMap[i].nType==DHTMLEVENTMAPENTRY_ELEMENT)
		{
			// an element name must be specified when using element events
			ATLASSERT(pEventMap[i].szName);

			// connect to the element's event sink
			CComPtr<IDispatch> spdispElement;
			GetElement(pEventMap[i].szName, &spdispElement);
			if (spdispElement)
			{
				if (!IsSinkedElement(spdispElement))
				{
					CDHtmlElementEventSink *pSink = NULL;
					ATLTRY(pSink = new CDHtmlElementEventSink(this, spdispElement));
					if (pSink == NULL)
						return E_OUTOFMEMORY;
					hr = AtlAdvise(spdispElement, pSink, __uuidof(IDispatch), &pSink->m_dwCookie);
					if (SUCCEEDED(hr))
						m_SinkedElements.Add(pSink);
					else
						delete pSink;
#ifdef _DEBUG
					if (FAILED(hr))
						TRACE(traceHtml, 0, "Warning: Failed to connect to ConnectionPoint!\n");
#endif
				}
			}
		}
		else if (pEventMap[i].nType==DHTMLEVENTMAPENTRY_CONTROL)
		{
			// check if we already have a sink connected to this control
			if (!FindSinkForObject(pEventMap[i].szName))
			{
				// create a new sink and
				// connect it to the element's event sink
				CComPtr<IDispatch> spdispElement;
				GetElement(pEventMap[i].szName, &spdispElement);
				if (spdispElement)
				{
					CComPtr<IHTMLObjectElement> sphtmlObj;
					spdispElement->QueryInterface(__uuidof(IHTMLObjectElement), (void **) &sphtmlObj);
					if (sphtmlObj)
					{
						CComPtr<IDispatch> spdispControl;
						sphtmlObj->get_object(&spdispControl);
						if (spdispControl)
						{
							// create a new control sink to connect to the control's events
							CDHtmlControlSink *pSink = NULL; 
							ATLTRY(pSink = new CDHtmlControlSink(spdispControl, this, pEventMap[i].szName, dwThunkOffset));
							if (pSink == NULL)
								return E_OUTOFMEMORY;
							m_ControlSinks.Add(pSink);
						}
					}
				}
			}
		}
	}
	return hr;
}

BOOL CDHtmlDialog::FindSinkForObject(LPCTSTR szName)
{	
	int nLength = m_ControlSinks.GetSize();
	if (nLength > 0)
	{
		ENSURE_ARG(szName!=NULL);
	}
	for (int i=0; i<nLength; i++)
	{
		if (!_tcscmp(szName, m_ControlSinks[i]->m_szControlId))
			return TRUE;
	}
	return FALSE;
}

BOOL CDHtmlDialog::IsSinkedElement(IDispatch *pdispElem)
{
	ENSURE_ARG(pdispElem!=NULL);
	CComPtr<IUnknown> spunk;
	pdispElem->QueryInterface(__uuidof(IUnknown), (void **) &spunk);
	if (!spunk)
		return FALSE;
	for (int i=0; i<m_SinkedElements.GetSize(); i++)
	{
		if (spunk == m_SinkedElements[i]->m_spunkElem)
			return TRUE;
	}
	return FALSE;
}

void CDHtmlDialog::DisconnectDHtmlElementEvents()
{
	const DHtmlEventMapEntry* pEventMap = GetDHtmlEventMap();

	if (!pEventMap)
		return;

	int i;

	// disconnect from element events
	for (i=0; i<m_SinkedElements.GetSize(); i++)
	{
		CDHtmlElementEventSink *pSink = m_SinkedElements[i];
		AtlUnadvise(pSink->m_spunkElem, __uuidof(IDispatch), pSink->m_dwCookie);
		delete pSink;
	}
	m_SinkedElements.RemoveAll();

	// disconnect from control events
	for (i=0; i<m_ControlSinks.GetSize(); i++)
	{
		DisconnectFromConnectionPoint(m_ControlSinks[i]->m_spunkObj, 
				m_ControlSinks[i]->m_iid, m_ControlSinks[i]->m_dwCookie);
		delete m_ControlSinks[i];
	}
	m_ControlSinks.RemoveAll();
	return;
}

HRESULT CDHtmlDialog::GetElement(LPCTSTR szElementId, IDispatch **ppdisp, 
								 BOOL *pbCollection /*= NULL*/)
{
	ENSURE_ARG(ppdisp!=NULL);
	CComPtr<IHTMLElementCollection> sphtmlAll;
	CComPtr<IHTMLElementCollection> sphtmlColl;
	CComPtr<IDispatch> spdispElem;
	CComVariant varName;
	CComVariant varIndex;
	HRESULT hr = S_OK;
	CComPtr<IHTMLDocument2> sphtmlDoc;

	*ppdisp = NULL;

	if (pbCollection)
		*pbCollection = FALSE;

	hr = GetDHtmlDocument(&sphtmlDoc);
	if (sphtmlDoc == NULL)
		return hr;

	if(szElementId == NULL)
		return E_INVALIDARG;
		
	const CString strElementId(szElementId);
	varName.vt = VT_BSTR;
	varName.bstrVal = strElementId.AllocSysString();
	
#ifndef _UNICODE	
	if (!varName.bstrVal)
	{
		hr = E_OUTOFMEMORY;
		goto Error;
	}
#endif

	hr = sphtmlDoc->get_all(&sphtmlAll);
	if (sphtmlAll == NULL)
		goto Error;
	hr = sphtmlAll->item(varName, varIndex, &spdispElem);
	if (spdispElem == NULL)
	{
		hr = E_NOINTERFACE;
		goto Error;
	}

	spdispElem->QueryInterface(__uuidof(IHTMLElementCollection), (void **) &sphtmlColl);
	if (sphtmlColl)
	{
		if (pbCollection)
			*pbCollection = TRUE;
#ifdef _DEBUG
		else
		{
			TRACE(traceHtml, 0, "Warning: duplicate IDs or NAMEs.\n");
			ATLASSERT(FALSE);
		}
#endif

	}
Error:
	if (SUCCEEDED(hr))
	{
		*ppdisp = spdispElem;
		if (spdispElem)
			(*ppdisp)->AddRef();
	}
	return hr;
}

HRESULT CDHtmlDialog::GetElement(LPCTSTR szElementId, IHTMLElement **pphtmlElement)
{
	return GetElementInterface(szElementId, __uuidof(IHTMLElement), (void **) pphtmlElement);
}

HRESULT CDHtmlDialog::GetElementInterface(LPCTSTR szElementId, REFIID riid, void **ppvObj)
{
	ENSURE_ARG(ppvObj!=NULL);
	HRESULT hr = E_NOINTERFACE;
	*ppvObj = NULL;
	CComPtr<IDispatch> spdispElem;

	hr = GetElement(szElementId, &spdispElem);

	if (spdispElem)
		hr = spdispElem->QueryInterface(riid, ppvObj);
	return hr;
}

BSTR CDHtmlDialog::GetElementText(LPCTSTR szElementId)
{
	BSTR bstrText = NULL;
	CComPtr<IHTMLElement> sphtmlElem;
	GetElement(szElementId, &sphtmlElem);
	if (sphtmlElem)
		sphtmlElem->get_innerText(&bstrText);
	return bstrText;
}

void CDHtmlDialog::SetElementText(LPCTSTR szElementId, BSTR bstrText)
{
	CComPtr<IHTMLElement> sphtmlElem;
	GetElement(szElementId, &sphtmlElem);
	if (sphtmlElem)
		sphtmlElem->put_innerText(bstrText);
}

void CDHtmlDialog::SetElementText(IUnknown *punkElem, BSTR bstrText)
{
	ENSURE_ARG(punkElem!=NULL);
	CComPtr<IHTMLElement> sphtmlElem;
	punkElem->QueryInterface(__uuidof(IHTMLElement), (void **) &sphtmlElem);
	if (sphtmlElem != NULL)
		sphtmlElem->put_innerText(bstrText);
}

BSTR CDHtmlDialog::GetElementHtml(LPCTSTR szElementId)
{
	BSTR bstrText = NULL;
	CComPtr<IHTMLElement> sphtmlElem;
	GetElement(szElementId, &sphtmlElem);
	if (sphtmlElem)
		sphtmlElem->get_innerHTML(&bstrText);
	return bstrText;
}

void CDHtmlDialog::SetElementHtml(LPCTSTR szElementId, BSTR bstrText)
{
	CComPtr<IHTMLElement> sphtmlElem;
	GetElement(szElementId, &sphtmlElem);
	if (sphtmlElem)
		sphtmlElem->put_innerHTML(bstrText);
}

void CDHtmlDialog::SetElementHtml(IUnknown *punkElem, BSTR bstrText)
{
	ENSURE_ARG(punkElem!=NULL);
	CComPtr<IHTMLElement> sphtmlElem;
	punkElem->QueryInterface(__uuidof(IHTMLElement), (void **) &sphtmlElem);
	if (sphtmlElem != NULL)
		sphtmlElem->put_innerHTML(bstrText);
}

VARIANT CDHtmlDialog::GetElementProperty(LPCTSTR szElementId, DISPID dispid)
{
	VARIANT varRet;
	CComPtr<IDispatch> spdispElem;
	varRet.vt = VT_EMPTY;
	GetElement(szElementId, &spdispElem);
	if (spdispElem)
	{
		DISPPARAMS dispparamsNoArgs = { NULL, NULL, 0, 0 };
		spdispElem->Invoke(dispid, IID_NULL, LOCALE_USER_DEFAULT, 
			DISPATCH_PROPERTYGET, &dispparamsNoArgs, &varRet, NULL, NULL);
	}
	return varRet;
}

void CDHtmlDialog::SetElementProperty(LPCTSTR szElementId, DISPID dispid, VARIANT *pVar)
{
	CComPtr<IDispatch> spdispElem;

	GetElement(szElementId, &spdispElem);
	if (spdispElem)
	{
		DISPPARAMS dispparams = {NULL, NULL, 1, 1};
		dispparams.rgvarg = pVar;
		DISPID dispidPut = DISPID_PROPERTYPUT;
		dispparams.rgdispidNamedArgs = &dispidPut;

		spdispElem->Invoke(dispid, IID_NULL,
				LOCALE_USER_DEFAULT, DISPATCH_PROPERTYPUT,
				&dispparams, NULL, NULL, NULL);
	}
}

HRESULT CDHtmlDialog::GetControlDispatch(LPCTSTR szId, IDispatch **ppdisp)
{
	HRESULT hr = S_OK;
	CComPtr<IDispatch> spdispElem;

	hr = GetElement(szId, &spdispElem);

	if (spdispElem)
	{
		CComPtr<IHTMLObjectElement> sphtmlObj;

		hr = spdispElem.QueryInterface(&sphtmlObj);
		if (sphtmlObj)
		{
			spdispElem.Release();
			hr = sphtmlObj->get_object(ppdisp);
		}
	}
	return hr;
}

VARIANT CDHtmlDialog::GetControlProperty(IDispatch *pdispControl, DISPID dispid)
{
	VARIANT varRet;
	varRet.vt = VT_EMPTY;
	if (pdispControl)
	{
		DISPPARAMS dispparamsNoArgs = { NULL, NULL, 0, 0 };
		pdispControl->Invoke(dispid, IID_NULL, LOCALE_USER_DEFAULT, 
			DISPATCH_PROPERTYGET, &dispparamsNoArgs, &varRet, NULL, NULL);
	}
	return varRet;
}

VARIANT CDHtmlDialog::GetControlProperty(LPCTSTR szId, DISPID dispid)
{
	CComPtr<IDispatch> spdispElem;

	GetControlDispatch(szId, &spdispElem);
	return GetControlProperty(spdispElem, dispid);
}

VARIANT CDHtmlDialog::GetControlProperty(LPCTSTR szId, LPCTSTR szPropName)
{
	CComVariant varEmpty;
	CComPtr<IDispatch> spdispElem;

	GetControlDispatch(szId, &spdispElem);
	if (!spdispElem)
		return varEmpty;

	DISPID dispid;
	USES_CONVERSION;
	LPOLESTR pPropName = (LPOLESTR)T2COLE(szPropName);
	HRESULT hr = spdispElem->GetIDsOfNames(IID_NULL, &pPropName, 1, LOCALE_USER_DEFAULT, &dispid);
	if (SUCCEEDED(hr))
		return GetControlProperty(spdispElem, dispid);
	return varEmpty;
}

void CDHtmlDialog::SetControlProperty(IDispatch *pdispControl, DISPID dispid, VARIANT *pVar)
{
	if (pdispControl != NULL)
	{
		DISPPARAMS dispparams = {NULL, NULL, 1, 1};
		dispparams.rgvarg = pVar;
		DISPID dispidPut = DISPID_PROPERTYPUT;
		dispparams.rgdispidNamedArgs = &dispidPut;

		pdispControl->Invoke(dispid, IID_NULL,
				LOCALE_USER_DEFAULT, DISPATCH_PROPERTYPUT,
				&dispparams, NULL, NULL, NULL);
	}
}

void CDHtmlDialog::SetControlProperty(LPCTSTR szElementId, DISPID dispid, VARIANT *pVar)
{
	CComPtr<IDispatch> spdispElem;
	GetControlDispatch(szElementId, &spdispElem);

	SetControlProperty(spdispElem, dispid, pVar);
}

void CDHtmlDialog::SetControlProperty(LPCTSTR szElementId, LPCTSTR szPropName, VARIANT *pVar)
{
	CComPtr<IDispatch> spdispElem;
	GetControlDispatch(szElementId, &spdispElem);
	if (!spdispElem)
		return;
	DISPID dispid;
	USES_CONVERSION;
	LPOLESTR pPropName = (LPOLESTR)T2COLE(szPropName);
	HRESULT hr = spdispElem->GetIDsOfNames(IID_NULL, &pPropName, 1, LOCALE_USER_DEFAULT, &dispid);
	if (SUCCEEDED(hr))
		SetControlProperty(spdispElem, dispid, pVar);
}

HRESULT CDHtmlDialog::GetEvent(IHTMLEventObj **ppEventObj)
{
	ENSURE_ARG(ppEventObj!=NULL);
	CComPtr<IHTMLWindow2> sphtmlWnd;
	CComPtr<IHTMLDocument2> sphtmlDoc;

	*ppEventObj = NULL;

	HRESULT hr = GetDHtmlDocument(&sphtmlDoc);
	if (sphtmlDoc == NULL)
		return hr;

	hr = sphtmlDoc->get_parentWindow(&sphtmlWnd);
	if (FAILED(hr))
		goto Error;
	hr = sphtmlWnd->get_event(ppEventObj);

Error:
	return hr;
}

void CDHtmlDialog::SetHostFlags(DWORD dwFlags)
{
	m_dwHostFlags = dwFlags;
}

void CDHtmlDialog::SetExternalDispatch(IDispatch *pdispExternal)
{
	m_spExternalDisp = pdispExternal;
}

BOOL CDHtmlDialog::IsExternalDispatchSafe()
{
	return FALSE;
}


STDMETHODIMP CDHtmlDialog::ShowContextMenu(DWORD dwID, POINT *ppt, IUnknown *pcmdtReserved, IDispatch *pdispReserved)
{
	dwID; // unused
	ppt; // unused
	pcmdtReserved; // unused
	pdispReserved; // unused

	return S_FALSE;
}
STDMETHODIMP CDHtmlDialog::GetHostInfo(DOCHOSTUIINFO *pInfo)
{
	pInfo->dwFlags = m_dwHostFlags;
	return S_OK;
}
STDMETHODIMP CDHtmlDialog::ShowUI(DWORD dwID, IOleInPlaceActiveObject *pActiveObject, IOleCommandTarget *pCommandTarget, IOleInPlaceFrame *pFrame, IOleInPlaceUIWindow *pDoc)
{
	dwID; // unused
	pActiveObject; // unused
	pCommandTarget; // unused
	pFrame; // unused
	pDoc; // unused

	return S_FALSE;
}
STDMETHODIMP CDHtmlDialog::HideUI(void)
{
	return E_NOTIMPL;
}
STDMETHODIMP CDHtmlDialog::UpdateUI(void)
{
	return E_NOTIMPL;
}
STDMETHODIMP CDHtmlDialog::EnableModeless(BOOL fEnable)
{
	fEnable; // unused

	return E_NOTIMPL;
}
STDMETHODIMP CDHtmlDialog::OnDocWindowActivate(BOOL fActivate)
{
	fActivate; // unused

	return E_NOTIMPL;
}
STDMETHODIMP CDHtmlDialog::OnFrameWindowActivate(BOOL fActivate)
{
	fActivate; // unused

	return E_NOTIMPL;
}
STDMETHODIMP CDHtmlDialog::ResizeBorder(LPCRECT prcBorder, IOleInPlaceUIWindow *pUIWindow, BOOL fRameWindow)
{
	prcBorder; // unused
	pUIWindow; // unused
	fRameWindow; // unused

	return E_NOTIMPL;
}
STDMETHODIMP CDHtmlDialog::TranslateAccelerator(LPMSG lpMsg, const GUID *pguidCmdGroup, DWORD nCmdID)
{
	lpMsg; // unused
	pguidCmdGroup; // unused
	nCmdID; // unused

	return S_FALSE;
}
STDMETHODIMP CDHtmlDialog::GetOptionKeyPath(LPOLESTR *pchKey, DWORD dw)
{
	pchKey; // unused
	dw; // unused

	return E_NOTIMPL;
}
STDMETHODIMP CDHtmlDialog::GetDropTarget(IDropTarget *pDropTarget, IDropTarget **ppDropTarget)
{
	pDropTarget; // unused

	*ppDropTarget = NULL;
	return E_NOTIMPL;
}
STDMETHODIMP CDHtmlDialog::GetExternal(IDispatch **ppDispatch)
{
	if(ppDispatch == NULL)
		return E_POINTER;
		
	*ppDispatch = NULL;
	if (m_spExternalDisp.p && CanAccessExternal())
	{
		m_spExternalDisp.p->AddRef();
		*ppDispatch = m_spExternalDisp.p;
		return S_OK;
	}
	return E_NOTIMPL;
}
STDMETHODIMP CDHtmlDialog::TranslateUrl(DWORD dwTranslate, OLECHAR *pchURLIn, OLECHAR **ppchURLOut)
{
	dwTranslate; // unused
	pchURLIn; // unused
	
	if(ppchURLOut == NULL)
		return E_POINTER;
		
	*ppchURLOut = NULL;
	return S_FALSE;
}
STDMETHODIMP CDHtmlDialog::FilterDataObject(IDataObject *pDO, IDataObject **ppDORet)
{
	pDO; // unused;
	
	if(ppDORet == NULL)
		return E_POINTER;
		
	*ppDORet = NULL;
	return S_FALSE;
}

// This function is overridden in derived class via DECLARE_DHTML_EVENT_MAP	
const DHtmlEventMapEntry* CDHtmlDialog::GetDHtmlEventMap()
{
	return NULL;
}

/////////////////////////////////////////////////////////////////////////////
// CMultiPageDHtmlDialog

CMultiPageDHtmlDialog::CMultiPageDHtmlDialog() : CDHtmlDialog()
{
	m_pCurrentMap = NULL;
}

CMultiPageDHtmlDialog::CMultiPageDHtmlDialog(UINT nIDTemplate, UINT nHtmlResID /*= 0*/, CWnd *pParentWnd /*= NULL*/) : 
	CDHtmlDialog(nIDTemplate, nHtmlResID, pParentWnd)
{
	m_pCurrentMap = NULL;
}

CMultiPageDHtmlDialog::CMultiPageDHtmlDialog(LPCTSTR lpszTemplateName, LPCTSTR szHtmlResID /*= NULL*/, CWnd *pParentWnd /*= NULL*/) :
	CDHtmlDialog(lpszTemplateName, szHtmlResID, pParentWnd)
{
	m_pCurrentMap = NULL;
}

CMultiPageDHtmlDialog::~CMultiPageDHtmlDialog()
{
}

const DHtmlEventMapEntry* CMultiPageDHtmlDialog::GetEventMapForUrl(LPCTSTR szUrl)
{
	szUrl; // unused

	return NULL;
}

const DHtmlEventMapEntry* CMultiPageDHtmlDialog::GetDHtmlEventMap()
{
	return m_pCurrentMap;
}

void CMultiPageDHtmlDialog::OnNavigateComplete(LPDISPATCH pDisp, LPCTSTR szUrl)
{
	if (pDisp != m_pBrowserApp)
		return;
	CString strUrl = szUrl;
	if (!strUrl.Left(4).CompareNoCase(_T("res:")))
	{
		int nIndex = strUrl.ReverseFind('/');
		if (nIndex >= 0)
			strUrl = strUrl.Mid(nIndex+1);
	}
	m_pCurrentMap = GetEventMapForUrl(strUrl);
	CDHtmlDialog::OnNavigateComplete(pDisp, szUrl);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\dlgfile.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include <dlgs.h>       // for standard control IDs for commdlg
#include "afxglobals.h"

#define new DEBUG_NEW

////////////////////////////////////////////////////////////////////////////
// FileOpen/FileSaveAs common dialog helper

CFileDialog::CFileDialog(BOOL bOpenFileDialog,
	LPCTSTR lpszDefExt, LPCTSTR lpszFileName, DWORD dwFlags,
	LPCTSTR lpszFilter, CWnd* pParentWnd, DWORD dwSize, BOOL bVistaStyle)
	: CCommonDialog(pParentWnd)
{
	OSVERSIONINFO vi;
	ZeroMemory(&vi, sizeof(OSVERSIONINFO));
	vi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	::GetVersionEx(&vi);

	// if running under Vista
	if (vi.dwMajorVersion >= 6)
	{
		m_bVistaStyle = bVistaStyle;
	}
	else
	{
		m_bVistaStyle = FALSE;
	}

	m_bPickFoldersMode = FALSE;

	// determine size of OPENFILENAME struct if dwSize is zero
	if (dwSize == 0)
	{
		dwSize = sizeof(OPENFILENAME);
	}

	// size of OPENFILENAME must be at least version 5
	ASSERT(dwSize >= sizeof(OPENFILENAME));
	// allocate memory for OPENFILENAME struct based on size passed in
	m_pOFN = static_cast<LPOPENFILENAME>(malloc(dwSize));
	ASSERT(m_pOFN != NULL);
	if (m_pOFN == NULL)
		AfxThrowMemoryException();

	memset(&m_ofn, 0, dwSize); // initialize structure to 0/NULL
	m_szFileName[0] = '\0';
	m_szFileTitle[0] = '\0';
	m_pofnTemp = NULL;

	m_bOpenFileDialog = bOpenFileDialog;
	m_nIDHelp = bOpenFileDialog ? AFX_IDD_FILEOPEN : AFX_IDD_FILESAVE;

	m_ofn.lStructSize = dwSize;
	m_ofn.lpstrFile = m_szFileName;
	m_ofn.nMaxFile = _countof(m_szFileName);
	m_ofn.lpstrDefExt = lpszDefExt;
	m_ofn.lpstrFileTitle = (LPTSTR)m_szFileTitle;
	m_ofn.nMaxFileTitle = _countof(m_szFileTitle);
	m_ofn.Flags |= dwFlags | OFN_ENABLEHOOK | OFN_EXPLORER;
	if(dwFlags & OFN_ENABLETEMPLATE)
		m_ofn.Flags &= ~OFN_ENABLESIZING;
	m_ofn.hInstance = AfxGetResourceHandle();
	m_ofn.lpfnHook = (COMMDLGPROC)_AfxCommDlgProc;

	// setup initial file name
	if (lpszFileName != NULL)
		Checked::tcsncpy_s(m_szFileName, _countof(m_szFileName), lpszFileName, _TRUNCATE);

	// Translate filter into commdlg format (lots of \0)
	if (lpszFilter != NULL)
	{
		m_strFilter = lpszFilter;
		LPTSTR pch = m_strFilter.GetBuffer(0); // modify the buffer in place
		// MFC delimits with '|' not '\0'
		while ((pch = _tcschr(pch, '|')) != NULL)
			*pch++ = '\0';
		m_ofn.lpstrFilter = m_strFilter;
		// do not call ReleaseBuffer() since the string contains '\0' characters
	}

	if (m_bVistaStyle == TRUE)
	{
		if (SUCCEEDED(CoInitializeEx(NULL, COINIT_APARTMENTTHREADED)))
		{ // multi-threaded is not supported
			IFileDialog* pIFileDialog;
			IFileDialogCustomize* pIFileDialogCustomize;

			HRESULT hr;

			USE_INTERFACE_PART_STD(FileDialogEvents);
			USE_INTERFACE_PART_STD(FileDialogControlEvents);

			if (m_bOpenFileDialog)
			{
				hr = CoCreateInstance(CLSID_FileOpenDialog, NULL, CLSCTX_INPROC_SERVER, 
									  IID_PPV_ARGS(&pIFileDialog));
			}
			else
			{
				hr = CoCreateInstance(CLSID_FileSaveDialog, NULL, CLSCTX_INPROC_SERVER, 
									  IID_PPV_ARGS(&pIFileDialog));
			}
			if (FAILED(hr))
			{
				m_bVistaStyle = FALSE;
				return;
			}

			hr = pIFileDialog->QueryInterface(IID_PPV_ARGS(&pIFileDialogCustomize));
			ENSURE(SUCCEEDED(hr));

			hr = pIFileDialog->Advise(reinterpret_cast<IFileDialogEvents*>(&m_xFileDialogEvents), &m_dwCookie);
			ENSURE(SUCCEEDED(hr));

			m_pIFileDialog = static_cast<void*>(pIFileDialog);
			m_pIFileDialogCustomize = static_cast<void*>(pIFileDialogCustomize);
		}
		else
		{
			m_bVistaStyle = FALSE;
		}
	}
}

CFileDialog::~CFileDialog()
{
	free(m_pOFN);

	if (m_bVistaStyle == TRUE)
	{
		HRESULT hr;
		hr = (static_cast<IFileDialog*>(m_pIFileDialog))->Unadvise(m_dwCookie);
		ENSURE(SUCCEEDED(hr));

		(static_cast<IFileDialogCustomize*>(m_pIFileDialogCustomize))->Release();
		(static_cast<IFileDialog*>(m_pIFileDialog))->Release();

		CoUninitialize();
	}
}

const OPENFILENAME& CFileDialog::GetOFN() const
{
	return *m_pOFN;
}

OPENFILENAME& CFileDialog::GetOFN()
{
	return *m_pOFN;
}

void CFileDialog::UpdateOFNFromShellDialog()
{
	ASSERT(m_bVistaStyle == TRUE);
	if (m_bVistaStyle == TRUE)
	{
		IShellItem *psiResult;
		HRESULT hr = (static_cast<IFileDialog*>(m_pIFileDialog))->GetResult(&psiResult);
		if (SUCCEEDED(hr))
		{
			// Save properties:
			IFileSaveDialog* pSaveFile = GetIFileSaveDialog();
			if (pSaveFile != NULL)
			{
				IPropertyStore* pStore = NULL;
				HRESULT hr = pSaveFile->GetProperties(&pStore);
				if (SUCCEEDED(hr))
				{
					pSaveFile->ApplyProperties(psiResult, pStore, GetSafeHwnd (), NULL);
					pStore->Release();
				}

				pSaveFile->Release();
			}	

			LPWSTR wcPathName = NULL;
			hr = psiResult->GetDisplayName(SIGDN_FILESYSPATH, &wcPathName);
			if (SUCCEEDED(hr))
			{
				CStringW strTmp(wcPathName);
				::PathRemoveFileSpecW(strTmp.GetBuffer());
				strTmp.ReleaseBuffer();
				size_t offset = strTmp.GetLength();
				if (wcPathName[offset] == L'\\')
				{
					offset++;
				}
#ifdef UNICODE
				wcsncpy_s(m_ofn.lpstrFile, m_ofn.nMaxFile - 1, wcPathName, _TRUNCATE);
				wcsncpy_s(m_ofn.lpstrFileTitle, m_ofn.nMaxFileTitle, wcPathName + offset, _TRUNCATE);
#else
				::WideCharToMultiByte(CP_ACP, 0, wcPathName + offset,
										-1, m_ofn.lpstrFileTitle, m_ofn.nMaxFileTitle, NULL, NULL);
				m_ofn.lpstrFileTitle[m_ofn.nMaxFileTitle - 1] = _T('\0');
				::WideCharToMultiByte(CP_ACP, 0, wcPathName, -1, m_ofn.lpstrFile,
										m_ofn.nMaxFile - 1, NULL, NULL);
				m_ofn.lpstrFile[m_ofn.nMaxFile - 2] = _T('\0');
#endif
				m_ofn.lpstrFile[_tcslen(m_ofn.lpstrFile) + 1] = _T('\0');
				CoTaskMemFree(wcPathName);
			}
			psiResult->Release();
		}
		else if (m_ofn.Flags & OFN_ALLOWMULTISELECT)
		{
			IFileOpenDialog *pfod = NULL;
			HRESULT hr = (static_cast<IFileDialog*>(m_pIFileDialog))->QueryInterface(IID_PPV_ARGS(&pfod));
			if (SUCCEEDED(hr))
			{
				IShellItemArray *ppenum = NULL;
				HRESULT hr = pfod->GetResults(&ppenum);
				if (SUCCEEDED(hr))
				{
					IEnumShellItems *ppenumShellItems;
					hr = ppenum->EnumItems(&ppenumShellItems);
					if (SUCCEEDED(hr))
					{
						IShellItem *rgelt[1];
						ULONG celtFetched = 0;
						if (ppenumShellItems->Next(1, rgelt, &celtFetched) == S_OK)
						{
							CStringW strTmp;
							LPTSTR pszFileName = m_ofn.lpstrFile;
							LPWSTR wcPathName = NULL;
							hr = rgelt[0]->GetDisplayName(SIGDN_FILESYSPATH, &wcPathName);
							if (SUCCEEDED(hr))
							{
								::PathRemoveFileSpecW(wcPathName);
#ifdef UNICODE
								wcsncpy_s(pszFileName, m_ofn.nMaxFile - 1, wcPathName, _TRUNCATE);
								pszFileName += wcslen(wcPathName) + 1;
#else
								pszFileName += ::WideCharToMultiByte(CP_ACP, 0, wcPathName, -1,
												pszFileName, m_ofn.nMaxFile - 1, NULL, NULL);
#endif
								CoTaskMemFree(wcPathName);
							}
							do
							{
								wcPathName = NULL;
								hr = rgelt[0]->GetDisplayName(SIGDN_FILESYSPATH, &wcPathName);
								if (SUCCEEDED(hr))
								{
									strTmp = wcPathName;
									::PathRemoveFileSpecW(strTmp.GetBuffer());
									strTmp.ReleaseBuffer();
									size_t offset = strTmp.GetLength();
									if (wcPathName[offset] == L'\\')
									{
										offset++;
									}
#ifdef UNICODE
									wcsncpy_s(pszFileName, m_ofn.nMaxFile - (pszFileName - m_ofn.lpstrFile) - 1,
											wcPathName + offset, _TRUNCATE);
									pszFileName += wcslen(wcPathName + offset) + 1;
#else
									pszFileName += ::WideCharToMultiByte(CP_ACP, 0, wcPathName + offset, -1, pszFileName,
													m_ofn.nMaxFile - static_cast<int>(pszFileName - m_ofn.lpstrFile) - 1,
													NULL, NULL);
#endif
									CoTaskMemFree(wcPathName);
								}
								hr = rgelt[0]->Release();
							} while((pszFileName < m_ofn.lpstrFile + m_ofn.nMaxFile - 1)
									&& (ppenumShellItems->Next(1, rgelt, &celtFetched) == S_OK));
							if(pszFileName < m_ofn.lpstrFile + m_ofn.nMaxFile - 1)
							{
								pszFileName[0] = _T('\0');
							}
							else
							{
								m_ofn.lpstrFile[m_ofn.nMaxFile - 2] = _T('\0');
								m_ofn.lpstrFile[m_ofn.nMaxFile - 1] = _T('\0');
							}
						}
						ppenumShellItems->Release();
					}
					ppenum->Release();
				}
				pfod->Release();
			}
		}

		CString strPathName = GetPathName();

		CString strFileName;
		LPTSTR pszFilename = ::PathFindFileName(strPathName);
		if (pszFilename != NULL)
		{
			strFileName = pszFilename;
		}

		CString strExtension;
		LPTSTR pszExtension = ::PathFindExtension(strPathName);
		if (pszExtension != NULL && *pszExtension == _T('.'))
		{
			strExtension = pszExtension + 1;
		}

		m_ofn.nFileOffset = static_cast<WORD>(strPathName.GetLength() -  strFileName.GetLength());
		m_ofn.nFileExtension = static_cast<WORD>(strPathName.GetLength() -  strExtension.GetLength());
	}
}

void CFileDialog::ApplyOFNToShellDialog()
{
	ASSERT(m_bVistaStyle == TRUE);
	if (m_bVistaStyle == TRUE)
	{
		HRESULT hr;
// m_ofn.lpstrTitle
		if(m_ofn.lpstrTitle != NULL)
		{
#ifdef UNICODE
			hr = (static_cast<IFileDialog*>(m_pIFileDialog))->SetTitle(m_ofn.lpstrTitle);
			ENSURE(SUCCEEDED(hr));
#else
			CStringW strTitle(m_ofn.lpstrTitle);
			hr = (static_cast<IFileDialog*>(m_pIFileDialog))->SetTitle(strTitle.GetString());
			ENSURE(SUCCEEDED(hr));
#endif
		}
// m_ofn.lpstrDefExt
		if(m_ofn.lpstrDefExt != NULL)
		{
			CStringW strDefExt(m_ofn.lpstrDefExt);
			hr = (static_cast<IFileDialog*>(m_pIFileDialog))->SetDefaultExtension(strDefExt.GetString());
			ENSURE(SUCCEEDED(hr));
		}
// m_ofn.lpstrFilter
		if(m_ofn.lpstrFilter != NULL)
		{
			UINT nFilterCount = 0;
			LPCTSTR lpstrFilter = m_ofn.lpstrFilter;
			while(lpstrFilter[0])
			{
				lpstrFilter += _tcslen(lpstrFilter)+1;
				lpstrFilter += _tcslen(lpstrFilter)+1;
				nFilterCount ++;
			}
			if (nFilterCount > 0)
			{
				COMDLG_FILTERSPEC* pFilter = NULL;
				pFilter = new COMDLG_FILTERSPEC[nFilterCount];
				ASSERT(pFilter != NULL);
				if (pFilter == NULL)
				{
					AfxThrowMemoryException();
				}
				lpstrFilter = m_ofn.lpstrFilter;
				size_t nFilterIndex = 0;
				size_t filterSize;
				LPWSTR lpwstrFilter;
				while (nFilterIndex < nFilterCount)
				{
					CStringW strTemp;

					filterSize = _tcslen(lpstrFilter)+1;
					lpwstrFilter = static_cast<LPWSTR>(new WCHAR[filterSize]);
					ASSERT(lpwstrFilter != NULL);
					if (lpwstrFilter == NULL)
					{
						AfxThrowMemoryException();
					}
					strTemp = lpstrFilter;
					memcpy_s(lpwstrFilter, (strTemp.GetLength()+1)*sizeof(WCHAR),
						strTemp.GetString(), (strTemp.GetLength()+1)*sizeof(WCHAR));
					pFilter[nFilterIndex].pszName = lpwstrFilter;
					lpstrFilter += filterSize;

					filterSize = _tcslen(lpstrFilter)+1;
					lpwstrFilter = static_cast<LPWSTR>(new WCHAR[filterSize]);
					ASSERT(lpwstrFilter != NULL);
					if (lpwstrFilter == NULL)
					{
						AfxThrowMemoryException();
					}
					strTemp = lpstrFilter;
					memcpy_s(lpwstrFilter, (strTemp.GetLength()+1)*sizeof(WCHAR),
						strTemp.GetString(), (strTemp.GetLength()+1)*sizeof(WCHAR));
					pFilter[nFilterIndex].pszSpec = lpwstrFilter;
					lpstrFilter += filterSize;

					nFilterIndex ++;
				}
				hr = (static_cast<IFileDialog*>(m_pIFileDialog))->SetFileTypes(nFilterCount, pFilter);
				ENSURE(SUCCEEDED(hr));
				for (nFilterIndex = 0; nFilterIndex < nFilterCount; nFilterIndex++)
				{
					delete[] pFilter[nFilterIndex].pszName;
					delete[] pFilter[nFilterIndex].pszSpec;
				}
				delete[] pFilter;

				hr = (static_cast<IFileDialog*>(m_pIFileDialog))->SetFileTypeIndex(m_ofn.nFilterIndex > 1 ? m_ofn.nFilterIndex : 1);
				ENSURE(SUCCEEDED(hr));
			}
		}
// m_ofn.lpstrFile and m_ofn.lpstrInitialDir
		if((m_ofn.lpstrFile != NULL) || (m_ofn.lpstrInitialDir != NULL))
		{
			CStringW strInitialDir;
			if(m_ofn.lpstrFile != NULL)
			{
				CStringW strFile(m_ofn.lpstrFile);
				strInitialDir = strFile;
				::PathRemoveFileSpecW(strInitialDir.GetBuffer());
				strInitialDir.ReleaseBuffer();
				int offset = strInitialDir.GetLength();
				if (strFile[offset] == L'\\')
				{
					offset++;
				}
				hr = (static_cast<IFileDialog*>(m_pIFileDialog))->SetFileName(strFile.GetString() + offset);
				ENSURE(SUCCEEDED(hr));
			}
			if((m_ofn.lpstrInitialDir != NULL) && strInitialDir.IsEmpty())
			{
				strInitialDir = m_ofn.lpstrInitialDir;
			}
			if(!strInitialDir.IsEmpty())
			{
				IShellItem *psiInitialDir = NULL;

				hr = afxGlobalData.ShellCreateItemFromParsingName(strInitialDir.GetString(), NULL, IID_PPV_ARGS(&psiInitialDir));
				if (SUCCEEDED(hr))
				{
					hr = (static_cast<IFileDialog*>(m_pIFileDialog))->SetFolder(psiInitialDir);
					ENSURE(SUCCEEDED(hr));
					psiInitialDir->Release();
				}
			}
		}
// m_ofn.Flags
		DWORD dwFlags = 0;
		hr = (static_cast<IFileDialog*>(m_pIFileDialog))->GetOptions(&dwFlags);
		ENSURE(SUCCEEDED(hr));

#ifndef VISTA_FILE_DIALOG_FLAG_MAPPING
#define VISTA_FILE_DIALOG_FLAG_MAPPING(OLD,NEW) \
	((m_ofn.Flags & (OLD)) ? (dwFlags |= (NEW)) : (dwFlags &= ~(NEW)))
#ifndef VISTA_FILE_DIALOG_FLAG_DIRECT_MAPPING
#define VISTA_FILE_DIALOG_FLAG_DIRECT_MAPPING(FLAG) \
	VISTA_FILE_DIALOG_FLAG_MAPPING(OFN_##FLAG, FOS_##FLAG)

		VISTA_FILE_DIALOG_FLAG_DIRECT_MAPPING(ALLOWMULTISELECT);
		VISTA_FILE_DIALOG_FLAG_DIRECT_MAPPING(CREATEPROMPT);
		VISTA_FILE_DIALOG_FLAG_DIRECT_MAPPING(DONTADDTORECENT);
		VISTA_FILE_DIALOG_FLAG_DIRECT_MAPPING(FILEMUSTEXIST);
		VISTA_FILE_DIALOG_FLAG_DIRECT_MAPPING(FORCESHOWHIDDEN);
		VISTA_FILE_DIALOG_FLAG_DIRECT_MAPPING(NOCHANGEDIR);
		VISTA_FILE_DIALOG_FLAG_DIRECT_MAPPING(NODEREFERENCELINKS);
		VISTA_FILE_DIALOG_FLAG_DIRECT_MAPPING(NOREADONLYRETURN);
		VISTA_FILE_DIALOG_FLAG_DIRECT_MAPPING(NOTESTFILECREATE);
		VISTA_FILE_DIALOG_FLAG_DIRECT_MAPPING(NOVALIDATE);
		VISTA_FILE_DIALOG_FLAG_DIRECT_MAPPING(OVERWRITEPROMPT);
		VISTA_FILE_DIALOG_FLAG_DIRECT_MAPPING(PATHMUSTEXIST);
		VISTA_FILE_DIALOG_FLAG_DIRECT_MAPPING(SHAREAWARE);

		(m_ofn.FlagsEx & OFN_EX_NOPLACESBAR) ? (dwFlags |=  FOS_HIDEPINNEDPLACES) : (dwFlags &= ~FOS_HIDEPINNEDPLACES);
		m_bPickFoldersMode ? (dwFlags |=  FOS_PICKFOLDERS) : (dwFlags &= ~FOS_PICKFOLDERS);

#undef VISTA_FILE_DIALOG_FLAG_DIRECT_MAPPING
#undef VISTA_FILE_DIALOG_FLAG_MAPPING
#endif
#endif
		hr = (static_cast<IFileDialog*>(m_pIFileDialog))->SetOptions(dwFlags);
		ENSURE(SUCCEEDED(hr));
	}
}

HRESULT CFileDialog::_PSGetPropertyDescriptionListFromString(LPCWSTR pszPropList, REFIID riid, void **ppv)
{
	static HMODULE hPropSysDll = AfxCtxLoadLibrary(_T("propsys.dll"));
	ENSURE(hPropSysDll != NULL);
	typedef HRESULT (__stdcall *PFNPSGETPROPERTYDESCRIPTIONLISTFROMSTRING)(LPCWSTR, REFIID, void**);
	static PFNPSGETPROPERTYDESCRIPTIONLISTFROMSTRING pFunc = (PFNPSGETPROPERTYDESCRIPTIONLISTFROMSTRING)GetProcAddress(hPropSysDll, "PSGetPropertyDescriptionListFromString");
	ENSURE(pFunc != NULL);
	return (*pFunc)(pszPropList, riid, ppv);
}

IFileOpenDialog* CFileDialog::GetIFileOpenDialog()
{
	ASSERT(m_bVistaStyle == TRUE);
	IFileOpenDialog* pIFileOpenDialog = NULL;
	if (m_bVistaStyle == TRUE)
	{
		(static_cast<IFileDialog*>(m_pIFileDialog))->QueryInterface(IID_PPV_ARGS(&pIFileOpenDialog));
	}
	return pIFileOpenDialog;
}

IFileSaveDialog* CFileDialog::GetIFileSaveDialog()
{
	ASSERT(m_bVistaStyle == TRUE);
	IFileSaveDialog* pIFileSaveDialog = NULL;
	if (m_bVistaStyle == TRUE)
	{
		(static_cast<IFileDialog*>(m_pIFileDialog))->QueryInterface(IID_PPV_ARGS(&pIFileSaveDialog));
	}
	return pIFileSaveDialog;
}

IFileDialogCustomize* CFileDialog::GetIFileDialogCustomize()
{
	ASSERT(m_bVistaStyle == TRUE);
	IFileDialogCustomize* pIFileDialogCustomize = NULL;
	if (m_bVistaStyle == TRUE)
	{
		(static_cast<IFileDialog*>(m_pIFileDialog))->QueryInterface(IID_PPV_ARGS(&pIFileDialogCustomize));
	}
	return pIFileDialogCustomize;
}

void CFileDialog::AddPlace(LPCWSTR lpszFolder, FDAP fdap)
{
	if (!m_bVistaStyle)
	{
		return;
	}

	ASSERT(lpszFolder != NULL);

	CComPtr<IShellItem> shellItem;

	HRESULT hr = afxGlobalData.ShellCreateItemFromParsingName(lpszFolder, 0, IID_IShellItem, reinterpret_cast<void**>(&shellItem));
	ENSURE(SUCCEEDED(hr));

	AddPlace(shellItem, fdap);
}

void CFileDialog::AddPlace(IShellItem* psi, FDAP fdap)
{
	if (!m_bVistaStyle)
	{
		return;
	}

	HRESULT hr = (static_cast<IFileDialog*>(m_pIFileDialog))->AddPlace(psi, fdap);

	ENSURE(SUCCEEDED(hr));
}

BEGIN_INTERFACE_MAP(CFileDialog, CCmdTarget)
	INTERFACE_PART(CFileDialog, IID_IFileDialogEvents, FileDialogEvents)
	INTERFACE_PART(CFileDialog, IID_IFileDialogControlEvents, FileDialogControlEvents)
END_INTERFACE_MAP()

STDMETHODIMP_(ULONG) CFileDialog::XFileDialogEvents::AddRef()
{
	METHOD_PROLOGUE(CFileDialog, FileDialogEvents)
	return pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CFileDialog::XFileDialogEvents::Release()
{
	METHOD_PROLOGUE(CFileDialog, FileDialogEvents)
	return pThis->ExternalRelease();
}

STDMETHODIMP CFileDialog::XFileDialogEvents::QueryInterface(
	REFIID iid, void FAR* FAR* ppvObj)
{
	METHOD_PROLOGUE(CFileDialog, FileDialogEvents)
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP CFileDialog::XFileDialogEvents::OnFileOk(IFileDialog *)
{
	METHOD_PROLOGUE(CFileDialog, FileDialogEvents)
	pThis->UpdateOFNFromShellDialog();
	return pThis->OnFileNameOK() ? S_FALSE : S_OK;
}

STDMETHODIMP CFileDialog::XFileDialogEvents::OnFolderChange(IFileDialog *)
{
	METHOD_PROLOGUE(CFileDialog, FileDialogEvents)
	pThis->OnFolderChange();
	return S_OK;
}

STDMETHODIMP CFileDialog::XFileDialogEvents::OnFolderChanging(IFileDialog *, IShellItem *)
{
	METHOD_PROLOGUE(CFileDialog, FileDialogEvents)
	return S_OK;
}

STDMETHODIMP CFileDialog::XFileDialogEvents::OnHelp(IFileDialog *)
{
	METHOD_PROLOGUE(CFileDialog, FileDialogEvents)
	return S_OK;
}

STDMETHODIMP CFileDialog::XFileDialogEvents::OnSelectionChange(IFileDialog *)
{
	METHOD_PROLOGUE(CFileDialog, FileDialogEvents)
	pThis->OnFileNameChange();
	return S_OK;
}

STDMETHODIMP CFileDialog::XFileDialogEvents::OnTypeChange(IFileDialog *)
{
	METHOD_PROLOGUE(CFileDialog, FileDialogEvents)
	UINT uIdx = 0;
	(static_cast<IFileDialog*>(pThis->m_pIFileDialog))->GetFileTypeIndex(&uIdx);
	pThis->m_ofn.nFilterIndex = static_cast<DWORD>(uIdx);
	pThis->OnTypeChange();
	return S_OK;
}

STDMETHODIMP CFileDialog::XFileDialogEvents::OnOverwrite(IFileDialog *, IShellItem *, FDE_OVERWRITE_RESPONSE *)
{
	METHOD_PROLOGUE(CFileDialog, FileDialogEvents)
	return S_OK;
}

STDMETHODIMP CFileDialog::XFileDialogEvents::OnShareViolation(
	IFileDialog *,
	IShellItem *psi,
	FDE_SHAREVIOLATION_RESPONSE *pResponse)
{
	METHOD_PROLOGUE(CFileDialog, FileDialogEvents)
	LPWSTR wcPathName = NULL;
	HRESULT hr;
	ENSURE(psi != NULL);
	hr = psi->GetDisplayName(SIGDN_FILESYSPATH, &wcPathName);
	ENSURE(SUCCEEDED(hr));
	CString strPathName(wcPathName);
	CoTaskMemFree(wcPathName);
	UINT retval = pThis->OnShareViolation(strPathName.GetString());
	ENSURE(pResponse != NULL);
	if (retval == OFN_SHAREWARN)
	{
		*pResponse = FDESVR_DEFAULT;
	}
	else if (retval == OFN_SHARENOWARN)
	{
		*pResponse = FDESVR_ACCEPT;
	}
	else if (retval == OFN_SHAREFALLTHROUGH)
	{
		*pResponse = FDESVR_REFUSE;
	}
	return S_OK;
}

STDMETHODIMP_(ULONG) CFileDialog::XFileDialogControlEvents::AddRef()
{
	METHOD_PROLOGUE(CFileDialog, FileDialogControlEvents)
	return pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CFileDialog::XFileDialogControlEvents::Release()
{
	METHOD_PROLOGUE(CFileDialog, FileDialogControlEvents)
	return pThis->ExternalRelease();
}

STDMETHODIMP CFileDialog::XFileDialogControlEvents::QueryInterface(
	REFIID iid, void FAR* FAR* ppvObj)
{
	METHOD_PROLOGUE(CFileDialog, FileDialogControlEvents)
	ENSURE(ppvObj != NULL);
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP CFileDialog::XFileDialogControlEvents::OnItemSelected(IFileDialogCustomize *, DWORD dwIDCtl, DWORD dwIDItem)
{
	METHOD_PROLOGUE(CFileDialog, FileDialogControlEvents)
	pThis->OnItemSelected(dwIDCtl, dwIDItem);
	return S_OK;
}

STDMETHODIMP CFileDialog::XFileDialogControlEvents::OnButtonClicked(IFileDialogCustomize *, DWORD dwIDCtl)
{
	METHOD_PROLOGUE(CFileDialog, FileDialogControlEvents)
	pThis->OnButtonClicked(dwIDCtl);
	return S_OK;
}

STDMETHODIMP CFileDialog::XFileDialogControlEvents::OnCheckButtonToggled(IFileDialogCustomize *, DWORD dwIDCtl, BOOL bChecked)
{
	METHOD_PROLOGUE(CFileDialog, FileDialogControlEvents)
	pThis->OnCheckButtonToggled(dwIDCtl, bChecked);
	return S_OK;
}

STDMETHODIMP CFileDialog::XFileDialogControlEvents::OnControlActivating(IFileDialogCustomize *, DWORD dwIDCtl)
{
	METHOD_PROLOGUE(CFileDialog, FileDialogControlEvents)
	pThis->OnControlActivating(dwIDCtl);
	return S_OK;
}

INT_PTR CFileDialog::DoModal()
{
	ASSERT_VALID(this);
	ASSERT(m_ofn.Flags & OFN_ENABLEHOOK);
	ASSERT(m_ofn.lpfnHook != NULL); // can still be a user hook

	// zero out the file buffer for consistent parsing later
	ASSERT(AfxIsValidAddress(m_ofn.lpstrFile, m_ofn.nMaxFile));
	DWORD nOffset = lstrlen(m_ofn.lpstrFile)+1;
	ASSERT(nOffset <= m_ofn.nMaxFile);
	memset(m_ofn.lpstrFile+nOffset, 0, (m_ofn.nMaxFile-nOffset)*sizeof(TCHAR));

	//  This is a special case for the file open/save dialog,
	//  which sometimes pumps while it is coming up but before it has
	//  disabled the main window.
	HWND hWndFocus = ::GetFocus();
	BOOL bEnableParent = FALSE;
	m_ofn.hwndOwner = PreModal();
	AfxUnhookWindowCreate();
	if (m_ofn.hwndOwner != NULL && ::IsWindowEnabled(m_ofn.hwndOwner))
	{
		bEnableParent = TRUE;
		::EnableWindow(m_ofn.hwndOwner, FALSE);
	}

	_AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
	ASSERT(pThreadState->m_pAlternateWndInit == NULL);

	if (m_bVistaStyle == TRUE)
	{
		AfxHookWindowCreate(this);
	}
	else if (m_ofn.Flags & OFN_EXPLORER)
		pThreadState->m_pAlternateWndInit = this;
	else
		AfxHookWindowCreate(this);

	INT_PTR nResult = 0;

	if (m_bVistaStyle == TRUE)
	{
		ApplyOFNToShellDialog();
		HRESULT hr = (static_cast<IFileDialog*>(m_pIFileDialog))->Show(m_ofn.hwndOwner);
		nResult = (hr == S_OK) ? IDOK : IDCANCEL;
	}
	else if (m_bOpenFileDialog)
		nResult = ::AfxCtxGetOpenFileName(&m_ofn);
	else
		nResult = ::AfxCtxGetSaveFileName(&m_ofn);

	if (nResult)
		ASSERT(pThreadState->m_pAlternateWndInit == NULL);
	pThreadState->m_pAlternateWndInit = NULL;

	// Second part of special case for file open/save dialog.
	if (bEnableParent)
		::EnableWindow(m_ofn.hwndOwner, TRUE);
	if (::IsWindow(hWndFocus))
		::SetFocus(hWndFocus);

	PostModal();
	return nResult ? nResult : IDCANCEL;
}

IShellItem *CFileDialog::GetResult()
{
	IShellItem *pItem = NULL;
	if (!m_bVistaStyle)
	{
		return pItem;
	}

	HRESULT hr = (static_cast<IFileDialog*>(m_pIFileDialog))->GetResult(&pItem);
	if (SUCCEEDED(hr))
	{
		return pItem;
	}

#ifndef UNICODE
	CStringW strPathNameW = GetPathName().GetString();
	hr = afxGlobalData.ShellCreateItemFromParsingName((PCWSTR)strPathNameW, 0, IID_IShellItem, (void**)&pItem);
#else
	hr = afxGlobalData.ShellCreateItemFromParsingName((PCWSTR)GetPathName().GetString(), 0, IID_IShellItem, (void**)&pItem);
#endif
	ENSURE(SUCCEEDED(hr));

	return pItem;
}

IShellItemArray *CFileDialog::GetResults()
{
	IShellItemArray *pItems = NULL;
	if (!m_bVistaStyle)
	{
		return pItems;
	}

	IFileOpenDialog* pfod = NULL;
	HRESULT hr = (static_cast<IFileDialog*>(m_pIFileDialog))->QueryInterface(IID_PPV_ARGS(&pfod));
	ENSURE(SUCCEEDED(hr));

	hr = pfod->GetResults(&pItems);

	pfod->Release();
	ENSURE(SUCCEEDED(hr));

	return pItems;
}

CString CFileDialog::GetPathName() const
{
	if (m_bVistaStyle == TRUE)
	{
		if (m_hWnd != NULL)
		{
			CString strResult;
			IShellItem *psiResult;
			HRESULT hr = (static_cast<IFileDialog*>(m_pIFileDialog))->GetCurrentSelection(&psiResult);
			if (SUCCEEDED(hr))
			{
				SFGAOF sfgaoAttribs;
				if ((psiResult->GetAttributes(SFGAO_STREAM, &sfgaoAttribs) == S_FALSE)
					&& (psiResult->GetAttributes(SFGAO_FOLDER, &sfgaoAttribs) == S_OK))
				{
					;
				}
				else
				{
					LPWSTR wcPathName = NULL;
					hr = psiResult->GetDisplayName(SIGDN_FILESYSPATH, &wcPathName);
					if (SUCCEEDED(hr))
					{
						strResult = wcPathName;
						strResult.ReleaseBuffer();
						CoTaskMemFree(wcPathName);
					}
				}
				psiResult->Release();
			}
			return strResult;
		}
		else
		{
			return m_ofn.lpstrFile;
		}
	}
	else if ((m_ofn.Flags & OFN_EXPLORER) && m_hWnd != NULL)
	{
		ASSERT(::IsWindow(m_hWnd));
		CString strResult;
		if (GetParent()->SendMessage(CDM_GETSPEC, (WPARAM)MAX_PATH,
			(LPARAM)strResult.GetBuffer(MAX_PATH)) < 0)
		{
			strResult.Empty();
		}
		else
		{
			strResult.ReleaseBuffer();
		}

		if (!strResult.IsEmpty())
		{
			if (GetParent()->SendMessage(CDM_GETFILEPATH, (WPARAM)MAX_PATH,
				(LPARAM)strResult.GetBuffer(MAX_PATH)) < 0)
				strResult.Empty();
			else
			{
				strResult.ReleaseBuffer();
				return strResult;
			}
		}
	}
	return m_ofn.lpstrFile;
}

CString CFileDialog::GetFileName() const
{
	if (m_bVistaStyle == TRUE)
	{
		if (m_hWnd != NULL)
		{
			LPWSTR wcFileName;
			HRESULT hr = (static_cast<IFileDialog*>(m_pIFileDialog))->GetFileName(&wcFileName);
			CString strResult(wcFileName);

			if (SUCCEEDED(hr))
			{
				CoTaskMemFree(wcFileName);
			}
			strResult.ReleaseBuffer();
			return strResult;
		}
		else
		{
			return m_ofn.lpstrFileTitle;
		}
	}
	else if ((m_ofn.Flags & OFN_EXPLORER) && m_hWnd != NULL)
	{
		ASSERT(::IsWindow(m_hWnd));
		CString strResult;
		if (GetParent()->SendMessage(CDM_GETSPEC, (WPARAM)MAX_PATH,
			(LPARAM)strResult.GetBuffer(MAX_PATH)) < 0)
		{
			strResult.Empty();
		}
		else
		{
			strResult.ReleaseBuffer();
			return strResult;
		}
	}
	return m_ofn.lpstrFileTitle;
}

CString CFileDialog::GetFileExt() const
{
	if (m_bVistaStyle == TRUE)
	{
		CString strResult;
		if (m_hWnd != NULL)
		{
			strResult = GetFileName();
		}
		else
		{
			strResult = GetPathName();
		}
		strResult.ReleaseBuffer();
		LPTSTR pszExtension = ::PathFindExtension(strResult);
		if (pszExtension != NULL && *pszExtension == _T('.'))
		{
			return pszExtension+1;
		}

		strResult.Empty();
		return strResult;
	}
	else if ((m_ofn.Flags & OFN_EXPLORER) && m_hWnd != NULL)
	{
		ASSERT(::IsWindow(m_hWnd));
		CString strResult;
		LPTSTR pszResult = strResult.GetBuffer(MAX_PATH);
		LRESULT nResult = GetParent()->SendMessage(CDM_GETSPEC, MAX_PATH,
			reinterpret_cast<LPARAM>(pszResult));
		strResult.ReleaseBuffer();
		if (nResult >= 0)
		{
			LPTSTR pszExtension = ::PathFindExtension(strResult);
			if (pszExtension != NULL && *pszExtension == _T('.'))
			{
				return pszExtension+1;
			}
		}

		strResult.Empty();
		return strResult;
	}

	if (m_pofnTemp != NULL)
		if (m_pofnTemp->nFileExtension == 0)
			return _T("");
		else
			return m_pofnTemp->lpstrFile + m_pofnTemp->nFileExtension;

	if (m_ofn.nFileExtension == 0)
		return _T("");
	else
		return m_ofn.lpstrFile + m_ofn.nFileExtension;
}

CString CFileDialog::GetFileTitle() const
{
	CString strResult = GetFileName();
	LPTSTR pszBuffer = strResult.GetBuffer();
	::PathRemoveExtension(pszBuffer);
	strResult.ReleaseBuffer();
	return strResult;
}

CString CFileDialog::GetNextPathName(POSITION& pos) const
{
	BOOL bExplorer = m_ofn.Flags & OFN_EXPLORER;
	TCHAR chDelimiter;
	if (bExplorer)
		chDelimiter = '\0';
	else
		chDelimiter = ' ';

	LPTSTR lpsz = (LPTSTR)pos;
	if (lpsz == m_ofn.lpstrFile) // first time
	{
		if ((m_ofn.Flags & OFN_ALLOWMULTISELECT) == 0)
		{
			pos = NULL;
			return m_ofn.lpstrFile;
		}

		// find char pos after first Delimiter
		while(*lpsz != chDelimiter && *lpsz != '\0')
			lpsz = _tcsinc(lpsz);
		lpsz = _tcsinc(lpsz);

		// if single selection then return only selection
		if (*lpsz == 0)
		{
			pos = NULL;
			return m_ofn.lpstrFile;
		}
	}

	CString strBasePath = m_ofn.lpstrFile;
	if (!bExplorer)
	{
		LPTSTR lpszPath = m_ofn.lpstrFile;
		while(*lpszPath != chDelimiter)
			lpszPath = _tcsinc(lpszPath);
		strBasePath = strBasePath.Left(int(lpszPath - m_ofn.lpstrFile));
	}

	LPTSTR lpszFileName = lpsz;
	CString strFileName = lpsz;

	// find char pos at next Delimiter
	while(*lpsz != chDelimiter && *lpsz != '\0')
		lpsz = _tcsinc(lpsz);

	if (!bExplorer && *lpsz == '\0')
		pos = NULL;
	else
	{
		if (!bExplorer)
			strFileName = strFileName.Left(int(lpsz - lpszFileName));

		lpsz = _tcsinc(lpsz);
		if (*lpsz == '\0') // if double terminated then done
			pos = NULL;
		else
			pos = (POSITION)lpsz;
	}

	TCHAR strDrive[_MAX_DRIVE], strDir[_MAX_DIR], strName[_MAX_FNAME], strExt[_MAX_EXT];
	Checked::tsplitpath_s(strFileName, strDrive, _MAX_DRIVE, strDir, _MAX_DIR, strName, _MAX_FNAME, strExt, _MAX_EXT);
	TCHAR strPath[_MAX_PATH];
	if (*strDrive || *strDir)
	{
		Checked::tcscpy_s(strPath, _countof(strPath), strFileName);
	}
	else
	{
		if ((strBasePath.GetLength() != 3) || (strBasePath[1] != ':') || (strBasePath[2] != '\\'))
		{
			strBasePath += _T("\\");
		}
		Checked::tsplitpath_s(strBasePath, strDrive, _MAX_DRIVE, strDir, _MAX_DIR, NULL, 0, NULL, 0);
		Checked::tmakepath_s(strPath, _MAX_PATH, strDrive, strDir, strName, strExt);
	}
	
	return strPath;
}

void CFileDialog::SetTemplate(LPCTSTR lpWin3ID, LPCTSTR lpWin4ID)
{
	if (m_bVistaStyle == TRUE)
	{
		AfxThrowNotSupportedException();
	}
	if (m_ofn.Flags & OFN_EXPLORER)
		m_ofn.lpTemplateName = lpWin4ID;
	else
		m_ofn.lpTemplateName = lpWin3ID;
	m_ofn.Flags |= OFN_ENABLETEMPLATE;
}

CString CFileDialog::GetFolderPath() const
{
	CString strResult;
	if (m_bVistaStyle == TRUE)
	{
		IShellItem *psiResult;
		HRESULT hr = (static_cast<IFileDialog*>(m_pIFileDialog))->GetFolder(&psiResult);
		if (SUCCEEDED(hr))
		{
			LPWSTR wcFolderPath = NULL;
			hr = psiResult->GetDisplayName(SIGDN_FILESYSPATH, &wcFolderPath);
			if (SUCCEEDED(hr))
			{
				strResult = wcFolderPath;
				CoTaskMemFree(wcFolderPath);
			}
			psiResult->Release();
		}
	}
	else
	{
		ASSERT(::IsWindow(m_hWnd));
		ASSERT(m_ofn.Flags & OFN_EXPLORER);

		if (GetParent()->SendMessage(CDM_GETFOLDERPATH, (WPARAM)MAX_PATH, (LPARAM)strResult.GetBuffer(MAX_PATH)) < 0)
			strResult.Empty();
		else
			strResult.ReleaseBuffer();
	}
	return strResult;
}

#ifdef UNICODE
void CFileDialog::SetControlText(int nID, const wchar_t  *lpsz)
{
	ASSERT(::IsWindow(m_hWnd));

	if (m_bVistaStyle == TRUE)
	{
		HRESULT hr = (static_cast<IFileDialogCustomize*>(m_pIFileDialogCustomize))->SetControlLabel(nID, lpsz);
		ENSURE(SUCCEEDED(hr));
	}
	else
	{
		ASSERT(m_ofn.Flags & OFN_EXPLORER);
		GetParent()->SendMessage(CDM_SETCONTROLTEXT, (WPARAM)nID, (LPARAM)lpsz);
	}
}
#endif

void CFileDialog::SetControlText(int nID, LPCSTR lpsz)
{
	ASSERT(::IsWindow(m_hWnd));

	if (m_bVistaStyle == TRUE)
	{
		CStringW dest(lpsz);
		HRESULT hr = (static_cast<IFileDialogCustomize*>(m_pIFileDialogCustomize))->SetControlLabel(nID, dest.GetString());
		ENSURE(SUCCEEDED(hr));
	}
	else
	{
		ASSERT(m_ofn.Flags & OFN_EXPLORER);

#ifdef UNICODE
		CStringW dest(lpsz);
		GetParent()->SendMessage(CDM_SETCONTROLTEXT, (WPARAM)nID, (LPARAM)dest.GetString());
#else
		GetParent()->SendMessage(CDM_SETCONTROLTEXT, (WPARAM)nID, (LPARAM)lpsz);
#endif
	}
}

void CFileDialog::HideControl(int nID)
{
	ASSERT(::IsWindow(m_hWnd));
	if (m_bVistaStyle == TRUE)
	{
		HRESULT hr = (static_cast<IFileDialogCustomize*>(m_pIFileDialogCustomize))->SetControlState(nID, CDCS_INACTIVE);
		ENSURE(SUCCEEDED(hr));
	}
	else
	{
		ASSERT(m_ofn.Flags & OFN_EXPLORER);
		GetParent()->SendMessage(CDM_HIDECONTROL, (WPARAM)nID, 0);
	}
}

void CFileDialog::SetDefExt(LPCSTR lpsz)
{
	ASSERT(::IsWindow(m_hWnd));
	if (m_bVistaStyle == TRUE)
	{
		CStringW strExt(lpsz);
		HRESULT hr = (static_cast<IFileDialog*>(m_pIFileDialog))->SetDefaultExtension(strExt.GetString());
		ENSURE(SUCCEEDED(hr));
	}
	else
	{
		ASSERT(m_ofn.Flags & OFN_EXPLORER);
		GetParent()->SendMessage(CDM_SETDEFEXT, 0, (LPARAM)lpsz);
	}
}

UINT CFileDialog::OnShareViolation(LPCTSTR)
{
	ASSERT_VALID(this);

	// Do not call Default() if you override
	return OFN_SHAREWARN; // default
}

BOOL CFileDialog::OnFileNameOK()
{
	ASSERT_VALID(this);

	// Do not call Default() if you override
	return FALSE;
}

void CFileDialog::OnLBSelChangedNotify(UINT, UINT, UINT)
{
	ASSERT_VALID(this);

	// Do not call Default() if you override
	// no default processing needed
}

void CFileDialog::OnInitDone()
{
	ASSERT_VALID(this);
	GetParent()->CenterWindow();

	// Do not call Default() if you override
	// no default processing needed
}

void CFileDialog::OnFileNameChange()
{
	ASSERT_VALID(this);

	// Do not call Default() if you override
	// no default processing needed
}

void CFileDialog::OnFolderChange()
{
	ASSERT_VALID(this);

	// Do not call Default() if you override
	// no default processing needed
}

void CFileDialog::OnTypeChange()
{
	ASSERT_VALID(this);

	// Do not call Default() if you override
	// no default processing needed
}

BOOL CFileDialog::SetProperties(LPCWSTR lpszPropList)
{
	ASSERT(m_bVistaStyle == TRUE);
	ASSERT(lpszPropList != NULL);
	ASSERT(GetSafeHwnd() == NULL);

	BOOL bRes = FALSE;

	if (!m_bVistaStyle)
	{
		return bRes;
	}

	IFileSaveDialog* pSaveFile = GetIFileSaveDialog();
	if (pSaveFile == NULL)
	{
		return bRes;
	}

	IPropertyDescriptionList* pPropertyDescriptionList = NULL;
	HRESULT hr = _PSGetPropertyDescriptionListFromString(lpszPropList, IID_PPV_ARGS(&pPropertyDescriptionList));

	if (SUCCEEDED(hr))
	{
		hr = pSaveFile->SetCollectedProperties(pPropertyDescriptionList, TRUE);
		if (SUCCEEDED(hr))
		{
			IShellItem2* pItem = NULL;
#ifndef UNICODE
			CStringW strPathNameW = GetPathName().GetString();
			hr = afxGlobalData.ShellCreateItemFromParsingName((PCWSTR)strPathNameW, 0, IID_IShellItem2, reinterpret_cast<void**>(&pItem));
#else
			hr = afxGlobalData.ShellCreateItemFromParsingName((PCWSTR)GetPathName().GetString(), 0, IID_IShellItem2, reinterpret_cast<void**>(&pItem));
#endif
			if (SUCCEEDED(hr) && pItem != NULL)
			{
				IPropertyStore* pStore = NULL;
				hr = pItem->GetPropertyStore(GPS_HANDLERPROPERTIESONLY, IID_IPropertyStore, (LPVOID*)&pStore);
				if (SUCCEEDED(hr))
				{
					pSaveFile->SetProperties(pStore);
					pStore->Release();
				}

				pItem->Release();
			}
			bRes = TRUE;
		}

		pPropertyDescriptionList->Release();
	}

	pSaveFile->Release();
	return bRes;
}

HRESULT CFileDialog::EnableOpenDropDown(DWORD dwIDCtl)
{
	if (!m_bVistaStyle)
	{
		return E_NOTIMPL;
	}

	IFileDialogCustomize* pFileDialogCustomize = GetIFileDialogCustomize();
	HRESULT hr = pFileDialogCustomize->EnableOpenDropDown(dwIDCtl);

	pFileDialogCustomize->Release();
	return hr;
}

HRESULT CFileDialog::AddMenu(DWORD dwIDCtl, const CString& strLabel)
{
	if (!m_bVistaStyle)
	{
		return E_NOTIMPL;
	}

	IFileDialogCustomize* pFileDialogCustomize = GetIFileDialogCustomize();

#ifndef UNICODE
	CStringW strLabelW = strLabel;
	HRESULT hr = pFileDialogCustomize->AddMenu(dwIDCtl, (LPCWSTR)strLabelW.GetString());
#else
	HRESULT hr = pFileDialogCustomize->AddMenu(dwIDCtl, (LPCWSTR)strLabel.GetString());
#endif

	pFileDialogCustomize->Release();
	return hr;
}

HRESULT CFileDialog::AddPushButton(DWORD dwIDCtl, const CString& strLabel)
{
	if (!m_bVistaStyle)
	{
		return E_NOTIMPL;
	}

	IFileDialogCustomize* pFileDialogCustomize = GetIFileDialogCustomize();

#ifndef UNICODE
	CStringW strLabelW = strLabel;
	HRESULT hr = pFileDialogCustomize->AddPushButton(dwIDCtl, (LPCWSTR)strLabelW.GetString());
#else
	HRESULT hr = pFileDialogCustomize->AddPushButton(dwIDCtl, (LPCWSTR)strLabel.GetString());
#endif

	pFileDialogCustomize->Release();
	return hr;
}

HRESULT CFileDialog::AddComboBox(DWORD dwIDCtl)
{
	if (!m_bVistaStyle)
	{
		return E_NOTIMPL;
	}

	IFileDialogCustomize* pFileDialogCustomize = GetIFileDialogCustomize();

	HRESULT hr = pFileDialogCustomize->AddComboBox(dwIDCtl);

	pFileDialogCustomize->Release();
	return hr;
}

HRESULT CFileDialog::AddRadioButtonList(DWORD dwIDCtl)
{
	if (!m_bVistaStyle)
	{
		return E_NOTIMPL;
	}

	IFileDialogCustomize* pFileDialogCustomize = GetIFileDialogCustomize();

	HRESULT hr = pFileDialogCustomize->AddRadioButtonList(dwIDCtl);

	pFileDialogCustomize->Release();
	return hr;
}

HRESULT CFileDialog::AddCheckButton(DWORD dwIDCtl, const CString& strLabel, BOOL bChecked)
{
	if (!m_bVistaStyle)
	{
		return E_NOTIMPL;
	}

	IFileDialogCustomize* pFileDialogCustomize = GetIFileDialogCustomize();

#ifndef UNICODE
	CStringW strLabelW = strLabel;
	HRESULT hr = pFileDialogCustomize->AddCheckButton(dwIDCtl, (LPCWSTR)strLabelW.GetString(), bChecked);
#else
	HRESULT hr = pFileDialogCustomize->AddCheckButton(dwIDCtl, (LPCWSTR)strLabel.GetString(), bChecked);
#endif

	pFileDialogCustomize->Release();
	return hr;
}

HRESULT CFileDialog::AddEditBox(DWORD dwIDCtl, const CString& strText)
{
	if (!m_bVistaStyle)
	{
		return E_NOTIMPL;
	}

	IFileDialogCustomize* pFileDialogCustomize = GetIFileDialogCustomize();

#ifndef UNICODE
	CStringW strTextW = strText;
	HRESULT hr = pFileDialogCustomize->AddEditBox(dwIDCtl, (LPCWSTR)strTextW.GetString());
#else
	HRESULT hr = pFileDialogCustomize->AddEditBox(dwIDCtl, (LPCWSTR)strText.GetString());
#endif

	pFileDialogCustomize->Release();
	return hr;
}

HRESULT CFileDialog::AddSeparator(DWORD dwIDCtl)
{
	if (!m_bVistaStyle)
	{
		return E_NOTIMPL;
	}

	IFileDialogCustomize* pFileDialogCustomize = GetIFileDialogCustomize();

	HRESULT hr = pFileDialogCustomize->AddSeparator(dwIDCtl);

	pFileDialogCustomize->Release();
	return hr;
}

HRESULT CFileDialog::AddText(DWORD dwIDCtl, const CString& strText)
{
	if (!m_bVistaStyle)
	{
		return E_NOTIMPL;
	}

	IFileDialogCustomize* pFileDialogCustomize = GetIFileDialogCustomize();

#ifndef UNICODE
	CStringW strTextW = strText;
	HRESULT hr = pFileDialogCustomize->AddText(dwIDCtl, (LPCWSTR)strTextW.GetString());
#else
	HRESULT hr = pFileDialogCustomize->AddText(dwIDCtl, (LPCWSTR)strText.GetString());
#endif

	pFileDialogCustomize->Release();
	return hr;
}

HRESULT CFileDialog::SetControlLabel(DWORD dwIDCtl, const CString& strLabel)
{
	if (!m_bVistaStyle)
	{
		return E_NOTIMPL;
	}

	IFileDialogCustomize* pFileDialogCustomize = GetIFileDialogCustomize();

#ifndef UNICODE
	CStringW strLabelW = strLabel;
	HRESULT hr = pFileDialogCustomize->SetControlLabel(dwIDCtl, (LPCWSTR)strLabelW.GetString());
#else
	HRESULT hr = pFileDialogCustomize->SetControlLabel(dwIDCtl, (LPCWSTR)strLabel.GetString());
#endif

	pFileDialogCustomize->Release();
	return hr;
}

HRESULT CFileDialog::GetControlState(DWORD dwIDCtl, CDCONTROLSTATEF& dwState)
{
	if (!m_bVistaStyle)
	{
		return E_NOTIMPL;
	}

	IFileDialogCustomize* pFileDialogCustomize = GetIFileDialogCustomize();

	HRESULT hr = pFileDialogCustomize->GetControlState(dwIDCtl, &dwState);

	pFileDialogCustomize->Release();
	return hr;
}

HRESULT CFileDialog::SetControlState(DWORD dwIDCtl, CDCONTROLSTATEF dwState)
{
	if (!m_bVistaStyle)
	{
		return E_NOTIMPL;
	}

	IFileDialogCustomize* pFileDialogCustomize = GetIFileDialogCustomize();

	HRESULT hr = pFileDialogCustomize->SetControlState(dwIDCtl, dwState);

	pFileDialogCustomize->Release();
	return hr;
}

HRESULT CFileDialog::GetEditBoxText(DWORD dwIDCtl, CString& strText)
{
	if (!m_bVistaStyle)
	{
		return E_NOTIMPL;
	}

	IFileDialogCustomize* pFileDialogCustomize = GetIFileDialogCustomize();

	strText.Empty();

	LPWSTR wcText = NULL;
	HRESULT hr = pFileDialogCustomize->GetEditBoxText(dwIDCtl, &wcText);

	if (SUCCEEDED(hr))
	{
		strText = wcText;
		CoTaskMemFree(wcText);
	}

	pFileDialogCustomize->Release();
	return hr;
}

HRESULT CFileDialog::SetEditBoxText(DWORD dwIDCtl, const CString& strText)
{
	if (!m_bVistaStyle)
	{
		return E_NOTIMPL;
	}

	IFileDialogCustomize* pFileDialogCustomize = GetIFileDialogCustomize();

#ifndef UNICODE
	CStringW strTextW = strText;
	HRESULT hr = pFileDialogCustomize->SetEditBoxText(dwIDCtl, (LPCWSTR)strTextW.GetString());
#else
	HRESULT hr = pFileDialogCustomize->SetEditBoxText(dwIDCtl, (LPCWSTR)strText.GetString());
#endif

	pFileDialogCustomize->Release();
	return hr;
}

HRESULT CFileDialog::GetCheckButtonState(DWORD dwIDCtl, BOOL& bChecked)
{
	if (!m_bVistaStyle)
	{
		return E_NOTIMPL;
	}

	IFileDialogCustomize* pFileDialogCustomize = GetIFileDialogCustomize();

	HRESULT hr = pFileDialogCustomize->GetCheckButtonState(dwIDCtl, &bChecked);

	pFileDialogCustomize->Release();
	return hr;
}

HRESULT CFileDialog::SetCheckButtonState(DWORD dwIDCtl, BOOL bChecked)
{
	if (!m_bVistaStyle)
	{
		return E_NOTIMPL;
	}

	IFileDialogCustomize* pFileDialogCustomize = GetIFileDialogCustomize();

	HRESULT hr = pFileDialogCustomize->SetCheckButtonState(dwIDCtl, bChecked);

	pFileDialogCustomize->Release();
	return hr;
}

HRESULT CFileDialog::AddControlItem(DWORD dwIDCtl, DWORD dwIDItem, const CString& strLabel)
{
	if (!m_bVistaStyle)
	{
		return E_NOTIMPL;
	}

	IFileDialogCustomize* pFileDialogCustomize = GetIFileDialogCustomize();

#ifndef UNICODE
	CStringW strLabelW = strLabel;
	HRESULT hr = pFileDialogCustomize->AddControlItem(dwIDCtl, dwIDItem, (LPCWSTR)strLabelW.GetString());
#else
	HRESULT hr = pFileDialogCustomize->AddControlItem(dwIDCtl, dwIDItem, (LPCWSTR)strLabel.GetString());
#endif

	pFileDialogCustomize->Release();
	return hr;
}

HRESULT CFileDialog::RemoveControlItem(DWORD dwIDCtl, DWORD dwIDItem)
{
	if (!m_bVistaStyle)
	{
		return E_NOTIMPL;
	}

	IFileDialogCustomize* pFileDialogCustomize = GetIFileDialogCustomize();

	HRESULT hr = pFileDialogCustomize->RemoveControlItem(dwIDCtl, dwIDItem);

	pFileDialogCustomize->Release();
	return hr;
}

HRESULT CFileDialog::GetControlItemState(DWORD dwIDCtl, DWORD dwIDItem, CDCONTROLSTATEF& dwState)
{
	if (!m_bVistaStyle)
	{
		return E_NOTIMPL;
	}

	IFileDialogCustomize* pFileDialogCustomize = GetIFileDialogCustomize();

	HRESULT hr = pFileDialogCustomize->GetControlItemState(dwIDCtl, dwIDItem, &dwState);

	pFileDialogCustomize->Release();
	return hr;
}

HRESULT CFileDialog::SetControlItemState(DWORD dwIDCtl, DWORD dwIDItem, CDCONTROLSTATEF dwState)
{
	if (!m_bVistaStyle)
	{
		return E_NOTIMPL;
	}

	IFileDialogCustomize* pFileDialogCustomize = GetIFileDialogCustomize();

	HRESULT hr = pFileDialogCustomize->SetControlItemState(dwIDCtl, dwIDItem, dwState);

	pFileDialogCustomize->Release();
	return hr;
}

HRESULT CFileDialog::GetSelectedControlItem(DWORD dwIDCtl, DWORD& dwIDItem)
{
	if (!m_bVistaStyle)
	{
		return E_NOTIMPL;
	}

	IFileDialogCustomize* pFileDialogCustomize = GetIFileDialogCustomize();

	HRESULT hr = pFileDialogCustomize->GetSelectedControlItem(dwIDCtl, &dwIDItem);

	pFileDialogCustomize->Release();
	return hr;
}

HRESULT CFileDialog::SetSelectedControlItem(DWORD dwIDCtl, DWORD dwIDItem)
{
	if (!m_bVistaStyle)
	{
		return E_NOTIMPL;
	}

	IFileDialogCustomize* pFileDialogCustomize = GetIFileDialogCustomize();

	HRESULT hr = pFileDialogCustomize->SetSelectedControlItem(dwIDCtl, dwIDItem);

	pFileDialogCustomize->Release();
	return hr;
}

HRESULT CFileDialog::StartVisualGroup(DWORD dwIDCtl, const CString& strLabel)
{
	if (!m_bVistaStyle)
	{
		return E_NOTIMPL;
	}

	IFileDialogCustomize* pFileDialogCustomize = GetIFileDialogCustomize();

#ifndef UNICODE
	CStringW strLabelW = strLabel;
	HRESULT hr = pFileDialogCustomize->StartVisualGroup(dwIDCtl, (LPCWSTR)strLabelW.GetString());
#else
	HRESULT hr = pFileDialogCustomize->StartVisualGroup(dwIDCtl, (LPCWSTR)strLabel.GetString());
#endif

	pFileDialogCustomize->Release();
	return hr;
}

HRESULT CFileDialog::EndVisualGroup()
{
	if (!m_bVistaStyle)
	{
		return E_NOTIMPL;
	}

	IFileDialogCustomize* pFileDialogCustomize = GetIFileDialogCustomize();

	HRESULT hr = pFileDialogCustomize->EndVisualGroup();

	pFileDialogCustomize->Release();
	return hr;
}

HRESULT CFileDialog::MakeProminent(DWORD dwIDCtl)
{
	if (!m_bVistaStyle)
	{
		return E_NOTIMPL;
	}

	IFileDialogCustomize* pFileDialogCustomize = GetIFileDialogCustomize();

	HRESULT hr = pFileDialogCustomize->MakeProminent(dwIDCtl);

	pFileDialogCustomize->Release();
	return hr;
}

HRESULT CFileDialog::SetControlItemText(DWORD dwIDCtl, DWORD dwIDItem, const CString& strLabel)
{
	if (!m_bVistaStyle)
	{
		return E_NOTIMPL;
	}

	IFileDialogCustomize* pFileDialogCustomize = GetIFileDialogCustomize();

#ifndef UNICODE
	CStringW strLabelW = strLabel;
	HRESULT hr = pFileDialogCustomize->SetControlItemText(dwIDCtl, dwIDItem, (LPCWSTR)strLabelW.GetString());
#else
	HRESULT hr = pFileDialogCustomize->SetControlItemText(dwIDCtl, dwIDItem, (LPCWSTR)strLabel.GetString());
#endif

	pFileDialogCustomize->Release();
	return hr;
}

void CFileDialog::OnItemSelected(DWORD, DWORD)
{
	ASSERT_VALID(this);

	// Do not call Default() if you override
	// no default processing needed
}

void CFileDialog::OnButtonClicked(DWORD)
{
	ASSERT_VALID(this);

	// Do not call Default() if you override
	// no default processing needed
}

void CFileDialog::OnCheckButtonToggled(DWORD, BOOL)
{
	ASSERT_VALID(this);

	// Do not call Default() if you override
	// no default processing needed
}

void CFileDialog::OnControlActivating(DWORD)
{
	ASSERT_VALID(this);

	// Do not call Default() if you override
	// no default processing needed
}

BOOL CFileDialog::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult)
{
	ASSERT(pResult != NULL);

	// allow message map to override
	if (CCommonDialog::OnNotify(wParam, lParam, pResult))
		return TRUE;

	OFNOTIFY* pNotify = (OFNOTIFY*)lParam;
	switch(pNotify->hdr.code)
	{
	case CDN_INITDONE:
		OnInitDone();
		return TRUE;
	case CDN_SELCHANGE:
		OnFileNameChange();
		return TRUE;
	case CDN_FOLDERCHANGE:
		OnFolderChange();
		return TRUE;
	case CDN_SHAREVIOLATION:
		*pResult = OnShareViolation(pNotify->pszFile);
		return TRUE;
	case CDN_HELP:
		if (!SendMessage(WM_COMMAND, ID_HELP))
			SendMessage(WM_COMMANDHELP, 0, 0);
		return TRUE;
	case CDN_FILEOK:
		*pResult = OnFileNameOK();
		return TRUE;
	case CDN_TYPECHANGE:
		OnTypeChange();
		return TRUE;
	}

	return FALSE;   // not handled
}

////////////////////////////////////////////////////////////////////////////
// CFileDialog diagnostics

#ifdef _DEBUG
void CFileDialog::Dump(CDumpContext& dc) const
{
	CDialog::Dump(dc);

	if (m_bOpenFileDialog)
		dc << "File open dialog";
	else
		dc << "File save dialog";
	dc << "\nm_ofn.hwndOwner = " << (void*)m_ofn.hwndOwner;
	dc << "\nm_ofn.nFilterIndex = " << m_ofn.nFilterIndex;
	dc << "\nm_ofn.lpstrFile = " << m_ofn.lpstrFile;
	dc << "\nm_ofn.nMaxFile = " << m_ofn.nMaxFile;
	dc << "\nm_ofn.lpstrFileTitle = " << m_ofn.lpstrFileTitle;
	dc << "\nm_ofn.nMaxFileTitle = " << m_ofn.nMaxFileTitle;
	dc << "\nm_ofn.lpstrTitle = " << m_ofn.lpstrTitle;
	dc << "\nm_ofn.Flags = ";
	dc.DumpAsHex(m_ofn.Flags);
	dc << "\nm_ofn.lpstrDefExt = " << m_ofn.lpstrDefExt;
	dc << "\nm_ofn.nFileOffset = " << m_ofn.nFileOffset;
	dc << "\nm_ofn.nFileExtension = " << m_ofn.nFileExtension;

	dc << "\nm_ofn.lpstrFilter = ";
	LPCTSTR lpstrItem = m_ofn.lpstrFilter;
	LPTSTR lpszBreak = _T("|");

	while (lpstrItem != NULL && *lpstrItem != '\0')
	{
		dc << lpstrItem << lpszBreak;
		lpstrItem += lstrlen(lpstrItem) + 1;
	}
	if (lpstrItem != NULL)
		dc << lpszBreak;

	dc << "\nm_ofn.lpstrCustomFilter = ";
	lpstrItem = m_ofn.lpstrCustomFilter;
	while (lpstrItem != NULL && *lpstrItem != '\0')
	{
		dc << lpstrItem << lpszBreak;
		lpstrItem += lstrlen(lpstrItem) + 1;
	}
	if (lpstrItem != NULL)
		dc << lpszBreak;

	if (m_ofn.lpfnHook == (COMMDLGPROC)_AfxCommDlgProc)
		dc << "\nhook function set to standard MFC hook function";
	else
		dc << "\nhook function set to non-standard hook function";

	dc << "\nVista style" << ((m_bVistaStyle==TRUE)? "enabled" : "disabled");
	dc << "\nm_dwCookie = " << m_dwCookie;
	dc << "\nm_pIFileDialog = " << m_pIFileDialog;
	dc << "\nm_pIFileDialogCustomize = " << m_pIFileDialogCustomize;

	dc << "\n";
}
#endif //_DEBUG


IMPLEMENT_DYNAMIC(CFileDialog, CCommonDialog)

////////////////////////////////////////////////////////////////////////////
// Folder Picker common dialog helper

CFolderPickerDialog::CFolderPickerDialog(LPCTSTR lpszFolder, DWORD dwFlags, CWnd* pParentWnd, DWORD dwSize) :
	CFileDialog(TRUE, NULL, lpszFolder, dwFlags, NULL, pParentWnd, dwSize, TRUE)
{
	m_bPickFoldersMode = TRUE;
}

CFolderPickerDialog::~CFolderPickerDialog()
{
}

IMPLEMENT_DYNAMIC(CFolderPickerDialog, CFileDialog)

////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\dlgcore.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "occimpl.h"

#include "afxdatarecovery.h"

#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// AfxDlgProc - does nothing since all messages are handled via AfxWndProc

INT_PTR CALLBACK AfxDlgProc(HWND hWnd, UINT message, WPARAM, LPARAM)
{
	if (message == WM_INITDIALOG)
	{
		// special case for WM_INITDIALOG
		CDialog* pDlg = DYNAMIC_DOWNCAST(CDialog, CWnd::FromHandlePermanent(hWnd));
		if (pDlg != NULL)
			return pDlg->OnInitDialog();
		else
			return 1;
	}
	return 0;
}

/////////////////////////////////////////////////////////////////////////////
// CDialog - Modeless and Modal

BEGIN_MESSAGE_MAP(CDialog, CWnd)
	//{{AFX_MSG_MAP(CDialog)
	ON_COMMAND(IDOK, &CDialog::OnOK)
	ON_COMMAND(IDCANCEL, &CDialog::OnCancel)
	ON_MESSAGE(WM_COMMANDHELP, &CDialog::OnCommandHelp)
	ON_MESSAGE(WM_HELPHITTEST, &CDialog::OnHelpHitTest)
	ON_MESSAGE(WM_INITDIALOG, &CDialog::HandleInitDialog)
	ON_MESSAGE(WM_SETFONT, &CDialog::HandleSetFont)
	ON_WM_PAINT()
	ON_WM_QUERYENDSESSION()
	ON_WM_ENDSESSION()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL CDialog::PreTranslateMessage(MSG* pMsg)
{
	// for modeless processing (or modal)
	ASSERT(m_hWnd != NULL);

	// allow tooltip messages to be filtered
	if (CWnd::PreTranslateMessage(pMsg))
		return TRUE;

	// don't translate dialog messages when in Shift+F1 help mode
	CFrameWnd* pFrameWnd = GetTopLevelFrame();
	if (pFrameWnd != NULL && pFrameWnd->m_bHelpMode)
		return FALSE;

	// fix around for VK_ESCAPE in a multiline Edit that is on a Dialog
	// that doesn't have a cancel or the cancel is disabled.
	if (pMsg->message == WM_KEYDOWN &&
		(pMsg->wParam == VK_ESCAPE || pMsg->wParam == VK_CANCEL) &&
		(::GetWindowLong(pMsg->hwnd, GWL_STYLE) & ES_MULTILINE) &&
		_AfxCompareClassName(pMsg->hwnd, _T("Edit")))
	{
		HWND hItem = ::GetDlgItem(m_hWnd, IDCANCEL);
		if (hItem == NULL || ::IsWindowEnabled(hItem))
		{
			SendMessage(WM_COMMAND, IDCANCEL, 0);
			return TRUE;
		}
	}
	// filter both messages to dialog and from children
	return PreTranslateInput(pMsg);
}

BOOL CDialog::OnCmdMsg(UINT nID, int nCode, void* pExtra,
	AFX_CMDHANDLERINFO* pHandlerInfo)
{
	if (CWnd::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
		return TRUE;

	if ((nCode != CN_COMMAND && nCode != CN_UPDATE_COMMAND_UI) ||
			!IS_COMMAND_ID(nID) || nID >= 0xf000)
	{
		// control notification or non-command button or system command
		return FALSE;       // not routed any further
	}

	// if we have an owner window, give it second crack
	CWnd* pOwner = GetParent();
	if (pOwner != NULL)
	{
		TRACE(traceCmdRouting, 1, "Routing command id 0x%04X to owner window.\n", nID);

		ASSERT(pOwner != this);
		if (pOwner->OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
			return TRUE;
	}

	// last crack goes to the current CWinThread object
	CWinThread* pThread = AfxGetThread();
	if (pThread != NULL)
	{
		TRACE(traceCmdRouting, 1, "Routing command id 0x%04X to app.\n", nID);

		if (pThread->OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
			return TRUE;
	}

	TRACE(traceCmdRouting, 1, "IGNORING command id 0x%04X sent to %hs dialog.\n", nID,
			GetRuntimeClass()->m_lpszClassName);

	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Modeless Dialogs have 2-phase construction

CDialog::CDialog()
{
	ASSERT(m_hWnd == NULL);

	Initialize();
}

CDialog::~CDialog()
{
	if (m_hWnd != NULL)
	{
		TRACE(traceAppMsg, 0, "Warning: calling DestroyWindow in CDialog::~CDialog --\n");
		TRACE(traceAppMsg, 0, "\tOnDestroy or PostNcDestroy in derived class will not be called.\n");
		DestroyWindow();
	}
}

void CDialog::Initialize()
{
	m_nIDHelp = 0;
	m_lpszTemplateName = NULL;
	m_hDialogTemplate = NULL;
	m_lpDialogTemplate = NULL;
	m_lpDialogInit = NULL;
	m_pParentWnd = NULL;
	m_hWndTop = NULL;
#ifndef _AFX_NO_OCC_SUPPORT
	m_pOccDialogInfo = NULL;
#endif
}

void CDialog::OnPaint()
{
	CPaintDC dc(this);
	if (PaintWindowlessControls(&dc))
	   return;
	Default();
}

BOOL CDialog::OnQueryEndSession()
{
	CWinApp* pApp = AfxGetApp();
	if (pApp != NULL && pApp->m_pMainWnd == this)
	{
		if (AfxGetThreadState()->m_lastSentMsg.lParam & ENDSESSION_CLOSEAPP)
		{
			// Restart Manager is querying about restarting the application
			return pApp->SupportsRestartManager();
		}
	}

	return TRUE;
}

void CDialog::OnEndSession(BOOL bEnding)
{
	if (!bEnding)
		return;

	CWinApp* pApp = AfxGetApp();
	if (pApp != NULL && pApp->m_pMainWnd == this)
	{
		if (AfxGetThreadState()->m_lastSentMsg.lParam & ENDSESSION_CLOSEAPP)
		{
			// Restart Manager is restarting the application
			CDataRecoveryHandler *pHandler = pApp->GetDataRecoveryHandler();
			if (pHandler)
			{
				pHandler->SetShutdownByRestartManager(TRUE);
			}
		}
	}
}

BOOL CDialog::Create(LPCTSTR lpszTemplateName, CWnd* pParentWnd)
{
	ASSERT(IS_INTRESOURCE(lpszTemplateName) ||
		AfxIsValidString(lpszTemplateName));

	m_lpszTemplateName = lpszTemplateName;  // used for help
	if (IS_INTRESOURCE(m_lpszTemplateName) && m_nIDHelp == 0)
		m_nIDHelp = LOWORD((DWORD_PTR)m_lpszTemplateName);

#ifdef _DEBUG
	if (!_AfxCheckDialogTemplate(lpszTemplateName, FALSE))
	{
		ASSERT(FALSE);          // invalid dialog template name
		PostNcDestroy();        // cleanup if Create fails too soon
		return FALSE;
	}
#endif //_DEBUG

	HINSTANCE hInst = AfxFindResourceHandle(lpszTemplateName, RT_DIALOG);
	HRSRC hResource = ::FindResource(hInst, lpszTemplateName, RT_DIALOG);
	HGLOBAL hTemplate = LoadResource(hInst, hResource);
	BOOL bResult = CreateIndirect(hTemplate, pParentWnd, hInst);
	FreeResource(hTemplate);

	return bResult;
}

// for backward compatibility
BOOL CDialog::CreateIndirect(HGLOBAL hDialogTemplate, CWnd* pParentWnd)
{
	return CreateIndirect(hDialogTemplate, pParentWnd, NULL);
}

BOOL CDialog::CreateIndirect(HGLOBAL hDialogTemplate, CWnd* pParentWnd,
	HINSTANCE hInst)
{
	ASSERT(hDialogTemplate != NULL);

	LPCDLGTEMPLATE lpDialogTemplate = (LPCDLGTEMPLATE)LockResource(hDialogTemplate);
	BOOL bResult = CreateIndirect(lpDialogTemplate, pParentWnd, NULL, hInst);
	UnlockResource(hDialogTemplate);

	return bResult;
}

// for backward compatibility
BOOL CDialog::CreateIndirect(LPCDLGTEMPLATE lpDialogTemplate, CWnd* pParentWnd,
	void* lpDialogInit)
{
	return CreateIndirect(lpDialogTemplate, pParentWnd, lpDialogInit, NULL);
}

BOOL CDialog::CreateIndirect(LPCDLGTEMPLATE lpDialogTemplate, CWnd* pParentWnd,
	void* lpDialogInit, HINSTANCE hInst)
{
	ASSERT(lpDialogTemplate != NULL);

	if (pParentWnd == NULL)
		pParentWnd = AfxGetMainWnd();
	m_lpDialogInit = lpDialogInit;

	return CreateDlgIndirect(lpDialogTemplate, pParentWnd, hInst);
}

BOOL CWnd::CreateDlg(LPCTSTR lpszTemplateName, CWnd* pParentWnd)
{
	// load resource
	LPCDLGTEMPLATE lpDialogTemplate = NULL;
	HGLOBAL hDialogTemplate = NULL;
	HINSTANCE hInst = AfxFindResourceHandle(lpszTemplateName, RT_DIALOG);
	HRSRC hResource = ::FindResource(hInst, lpszTemplateName, RT_DIALOG);
	hDialogTemplate = LoadResource(hInst, hResource);
	if (hDialogTemplate != NULL)
		lpDialogTemplate = (LPCDLGTEMPLATE)LockResource(hDialogTemplate);
	ASSERT(lpDialogTemplate != NULL);

	// create a modeless dialog
	BOOL bSuccess = CreateDlgIndirect(lpDialogTemplate, pParentWnd, hInst);

	// free resource
	UnlockResource(hDialogTemplate);
	FreeResource(hDialogTemplate);

	return bSuccess;
}

BOOL CWnd::CreateDlgIndirect(LPCDLGTEMPLATE lpDialogTemplate,
	CWnd* pParentWnd, HINSTANCE hInst)
{

#ifdef _DEBUG
	if ( AfxGetApp()->IsKindOf( RUNTIME_CLASS( COleControlModule ) ) )
	{
		TRACE(traceAppMsg, 0, "Warning: Creating dialog from within a COleControlModule application is not a supported scenario.\n");
	}
#endif

	ASSERT(lpDialogTemplate != NULL);
	if (pParentWnd != NULL)
		ASSERT_VALID(pParentWnd);

	if(!hInst)
		hInst = AfxGetResourceHandle();

#ifndef _AFX_NO_OCC_SUPPORT
	_AFX_OCC_DIALOG_INFO occDialogInfo;
	COccManager* pOccManager = afxOccManager;
#endif

	HGLOBAL hTemplate = NULL;

	HWND hWnd = NULL;
#ifdef _DEBUG
	DWORD dwError = 0;
#endif

	TRY
	{
		VERIFY(AfxDeferRegisterClass(AFX_WNDCOMMCTLS_REG));
		AfxDeferRegisterClass(AFX_WNDCOMMCTLSNEW_REG);

#ifdef _UNICODE
		AfxInitNetworkAddressControl();
#endif

		AfxRegisterMFCCtrlClasses();

#ifndef _AFX_NO_OCC_SUPPORT
		// separately create OLE controls in the dialog template
		if (pOccManager != NULL)
		{
			if (!SetOccDialogInfo(&occDialogInfo))
				return FALSE;

			lpDialogTemplate = pOccManager->PreCreateDialog(&occDialogInfo,
				lpDialogTemplate);
		}

		if (lpDialogTemplate == NULL)
			return FALSE;
#endif //!_AFX_NO_OCC_SUPPORT

		// If no font specified, set the system font.
		CString strFace;
		WORD wSize = 0;
		BOOL bSetSysFont = !CDialogTemplate::GetFont(lpDialogTemplate, strFace,
			wSize);

		if (bSetSysFont)
		{
			CDialogTemplate dlgTemp(lpDialogTemplate);
			dlgTemp.SetSystemFont(wSize);
			hTemplate = dlgTemp.Detach();
		}

		if (hTemplate != NULL)
			lpDialogTemplate = (DLGTEMPLATE*)GlobalLock(hTemplate);

		// setup for modal loop and creation
		m_nModalResult = -1;
		m_nFlags |= WF_CONTINUEMODAL;

		// create modeless dialog
		AfxHookWindowCreate(this);
		hWnd = ::CreateDialogIndirect(hInst, lpDialogTemplate,
			pParentWnd->GetSafeHwnd(), AfxDlgProc);
#ifdef _DEBUG
		dwError = ::GetLastError();
#endif
	}
	CATCH_ALL(e)
	{
		DELETE_EXCEPTION(e);
		m_nModalResult = -1;
	}
	END_CATCH_ALL

	/* This is a bit tricky.  At this point, 1 of 3 things has happened:
 	 * 1) ::CreateDialogIndirect() created successfully and hWnd != NULL.
 	 * 2) ::CreateDialogIndirect() did create a window and then send the appropiate 
 	 *    creation messages (ie. WM_CREATE).  However, the user handled WM_CREATE and 
 	 *    returned -1.  This causes windows to send WM_DESTROY and WM_NCDESTROY to the
 	 *    newly created window.  Since WM_NCDESTROY has been sent, the destructor of this
 	 *    CWnd object has been called.  And ::CreateDialogIndirect() returns NULL.
 	 * 3) ::CreateDialogIndirect() did NOT create the window (ie. due to error in template)
 	 *    and returns NULL. 
 	 *
 	 * (Note: In 3, this object is still valid; whereas in 2, this object has been deleted).
 	 *
 	 * Adding to the complexity, this function needs to do 2 memory clean up (call 
 	 * pOccManager->PostCreateDialog() and delete occDialogInfo) if the destructor of 
 	 * this object hasn't been called.  If the destructor has been called, the clean up is done
 	 * in the destructor.
 	 *
 	 * We can use the return valid of AfxUnhookWindowCreate() to differentiate between 2 and 3.
 	 *  - If AfxUnhookWindowCreate() returns true and hWnd==NULL, this means that (2) has happened
 	 *    and we don't have to clean up anything. (Cleanup should be done in the destructor).
 	 *  - If AfxUnhookWindowCreate() returns false and hWnd== NULL, this means that (3) has happened
 	 *    and we need to call PostNcDestroy().
 	 *
 	 * Note: hWnd != NULL implies that AfxUnhookWindowCreate() return TRUE.
         *
         * Note2: From this point on, don't access any member variables without checking hWnd.  If 
         *        hWnd == NULL, the object has been destroyed already.
 	 */

#ifndef _AFX_NO_OCC_SUPPORT
	if (pOccManager != NULL)
	{
		if (hWnd != NULL)
		{
			pOccManager->PostCreateDialog(&occDialogInfo);
			SetOccDialogInfo(NULL);
		}
	}
#endif //!_AFX_NO_OCC_SUPPORT

	if (!AfxUnhookWindowCreate())
		PostNcDestroy();        // cleanup if Create fails too soon

	// handle EndDialog calls during OnInitDialog
#ifdef _DEBUG
#ifndef _AFX_NO_OCC_SUPPORT
        // Saving the old flag for checking WF_CONTINUEMODAL (if the object has not been destroyed)
        // This needs to be after ::CreateDialogIndirect().
	DWORD dwOldFlags = 0;
        if (hWnd != NULL)
            dwOldFlags = m_nFlags;
#endif
#endif
	if (hWnd != NULL && !(m_nFlags & WF_CONTINUEMODAL))
	{
		::DestroyWindow(hWnd);
		hWnd = NULL;
	}

	if (hTemplate != NULL)
	{
		GlobalUnlock(hTemplate);
		GlobalFree(hTemplate);
	}

	// help with error diagnosis (only if WM_INITDIALOG didn't EndDialog())
	if (hWnd == NULL)
	{
#ifdef _DEBUG
#ifndef _AFX_NO_OCC_SUPPORT
		if (dwOldFlags & WF_CONTINUEMODAL)
		{
			if (afxOccManager == NULL)
			{
				TRACE(traceAppMsg, 0, ">>> If this dialog has OLE controls:\n");
				TRACE(traceAppMsg, 0, ">>> AfxEnableControlContainer has not been called yet.\n");
				TRACE(traceAppMsg, 0, ">>> You should call it in your app's InitInstance function.\n");
			}
			else if (dwError != 0)
			{
				TRACE(traceAppMsg, 0, "Warning: Dialog creation failed!  GetLastError returns 0x%8.8X\n", dwError);
			}
		}
#endif //!_AFX_NO_OCC_SUPPORT
#endif //_DEBUG
		return FALSE;
	}

	ASSERT(hWnd == m_hWnd);
	return TRUE;
}

#ifndef _AFX_NO_OCC_SUPPORT

BOOL CDialog::SetOccDialogInfo(_AFX_OCC_DIALOG_INFO* pOccDialogInfo)
{
	m_pOccDialogInfo = pOccDialogInfo;
	return TRUE;
}

_AFX_OCC_DIALOG_INFO* CDialog::GetOccDialogInfo()
{
	return m_pOccDialogInfo;	
}

#endif

/////////////////////////////////////////////////////////////////////////////
// Modal Dialogs

// Modal Constructors just save parameters
CDialog::CDialog(LPCTSTR lpszTemplateName, CWnd* pParentWnd)
{
	ASSERT(IS_INTRESOURCE(lpszTemplateName) ||
		AfxIsValidString(lpszTemplateName));

	Initialize();

	m_pParentWnd = pParentWnd;
	m_lpszTemplateName = lpszTemplateName;
	if (IS_INTRESOURCE(m_lpszTemplateName))
		m_nIDHelp = LOWORD((DWORD_PTR)m_lpszTemplateName);
}

CDialog::CDialog(UINT nIDTemplate, CWnd* pParentWnd)
{
	Initialize();

	m_pParentWnd = pParentWnd;
	m_lpszTemplateName = MAKEINTRESOURCE(nIDTemplate);
	m_nIDHelp = nIDTemplate;
}

BOOL CDialog::InitModalIndirect(HGLOBAL hDialogTemplate, CWnd* pParentWnd)
{
	// must be called on an empty constructed CDialog
	ASSERT(m_lpszTemplateName == NULL);
	ASSERT(m_hDialogTemplate == NULL);
	ASSERT(hDialogTemplate != NULL);

	if (m_pParentWnd == NULL)
		m_pParentWnd = pParentWnd;

	m_hDialogTemplate = hDialogTemplate;

	return TRUE;    // always ok (DoModal actually brings up dialog)
}

BOOL CDialog::InitModalIndirect(LPCDLGTEMPLATE lpDialogTemplate, CWnd* pParentWnd,
	void* lpDialogInit)
{
	// must be called on an empty constructed CDialog
	ASSERT(m_lpszTemplateName == NULL);
	ASSERT(m_lpDialogTemplate == NULL);
	ASSERT(lpDialogTemplate != NULL);

	if (m_pParentWnd == NULL)
		m_pParentWnd = pParentWnd;

	m_lpDialogTemplate = lpDialogTemplate;
	m_lpDialogInit = lpDialogInit;

	return TRUE;    // always ok (DoModal actually brings up dialog)
}

HWND CDialog::PreModal()
{
	// cannot call DoModal on a dialog already constructed as modeless
	ASSERT(m_hWnd == NULL);

	// allow OLE servers to disable themselves
	CWinApp* pApp = AfxGetApp();
	if (pApp != NULL)
		pApp->EnableModeless(FALSE);

	// find parent HWND
	HWND hWnd = CWnd::GetSafeOwner_(m_pParentWnd->GetSafeHwnd(), &m_hWndTop);

	// hook for creation of dialog
	AfxHookWindowCreate(this);

	// return window to use as parent for dialog
	return hWnd;
}

void CDialog::PostModal()
{
	AfxUnhookWindowCreate();   // just in case
	Detach();               // just in case

	// re-enable windows
	if (::IsWindow(m_hWndTop))
		::EnableWindow(m_hWndTop, TRUE);
	m_hWndTop = NULL;
	CWinApp* pApp = AfxGetApp();
	if (pApp != NULL)
		pApp->EnableModeless(TRUE);
}

INT_PTR CDialog::DoModal()
{
	// can be constructed with a resource template or InitModalIndirect
	ASSERT(m_lpszTemplateName != NULL || m_hDialogTemplate != NULL ||
		m_lpDialogTemplate != NULL);

	// load resource as necessary
	LPCDLGTEMPLATE lpDialogTemplate = m_lpDialogTemplate;
	HGLOBAL hDialogTemplate = m_hDialogTemplate;
	HINSTANCE hInst = AfxGetResourceHandle();
	if (m_lpszTemplateName != NULL)
	{
		hInst = AfxFindResourceHandle(m_lpszTemplateName, RT_DIALOG);
		HRSRC hResource = ::FindResource(hInst, m_lpszTemplateName, RT_DIALOG);
		hDialogTemplate = LoadResource(hInst, hResource);
	}
	if (hDialogTemplate != NULL)
		lpDialogTemplate = (LPCDLGTEMPLATE)LockResource(hDialogTemplate);

	// return -1 in case of failure to load the dialog template resource
	if (lpDialogTemplate == NULL)
		return -1;

	// disable parent (before creating dialog)
	HWND hWndParent = PreModal();
	AfxUnhookWindowCreate();
	BOOL bEnableParent = FALSE;
#ifndef _AFX_NO_OLE_SUPPORT
	CWnd* pMainWnd = NULL;
	BOOL bEnableMainWnd = FALSE;
#endif
	if (hWndParent && hWndParent != ::GetDesktopWindow() && ::IsWindowEnabled(hWndParent))
	{
		::EnableWindow(hWndParent, FALSE);
		bEnableParent = TRUE;
#ifndef _AFX_NO_OLE_SUPPORT
		pMainWnd = AfxGetMainWnd();
		if (pMainWnd && pMainWnd->IsFrameWnd() && pMainWnd->IsWindowEnabled())
		{
			//
			// We are hosted by non-MFC container
			// 
			pMainWnd->EnableWindow(FALSE);
			bEnableMainWnd = TRUE;
		}
#endif
	}

	TRY
	{
		// create modeless dialog
		AfxHookWindowCreate(this);
		if (CreateDlgIndirect(lpDialogTemplate,
						CWnd::FromHandle(hWndParent), hInst))
		{
			if (m_nFlags & WF_CONTINUEMODAL)
			{
				// enter modal loop
				DWORD dwFlags = MLF_SHOWONIDLE;
				if (GetStyle() & DS_NOIDLEMSG)
					dwFlags |= MLF_NOIDLEMSG;
				VERIFY(RunModalLoop(dwFlags) == m_nModalResult);
			}

			// hide the window before enabling the parent, etc.
			if (m_hWnd != NULL)
				SetWindowPos(NULL, 0, 0, 0, 0, SWP_HIDEWINDOW|
					SWP_NOSIZE|SWP_NOMOVE|SWP_NOACTIVATE|SWP_NOZORDER);
		}
	}
	CATCH_ALL(e)
	{
		DELETE_EXCEPTION(e);
		m_nModalResult = -1;
	}
	END_CATCH_ALL

#ifndef _AFX_NO_OLE_SUPPORT
	if (bEnableMainWnd)
		pMainWnd->EnableWindow(TRUE);
#endif
	if (bEnableParent)
		::EnableWindow(hWndParent, TRUE);
	if (hWndParent != NULL && ::GetActiveWindow() == m_hWnd)
		::SetActiveWindow(hWndParent);

	// destroy modal window
	DestroyWindow();
	PostModal();

	// unlock/free resources as necessary
	if (m_lpszTemplateName != NULL || m_hDialogTemplate != NULL)
		UnlockResource(hDialogTemplate);
	if (m_lpszTemplateName != NULL)
		FreeResource(hDialogTemplate);

	return m_nModalResult;
}

void CDialog::EndDialog(int nResult)
{
	ASSERT(::IsWindow(m_hWnd));

	if (m_nFlags & (WF_MODALLOOP|WF_CONTINUEMODAL))
		EndModalLoop(nResult);

	::EndDialog(m_hWnd, nResult);
}

/////////////////////////////////////////////////////////////////////////////
// Standard CDialog implementation

LRESULT CDialog::HandleSetFont(WPARAM wParam, LPARAM)
{
	OnSetFont(CFont::FromHandle((HFONT)wParam));
	return Default();
}

void CDialog::PreInitDialog()
{
	// ignore it
}

LRESULT CDialog::HandleInitDialog(WPARAM, LPARAM)
{
	PreInitDialog();

#ifndef _AFX_NO_OCC_SUPPORT
	// create OLE controls
	COccManager* pOccManager = afxOccManager;
	if ((pOccManager != NULL) && (m_pOccDialogInfo != NULL))
	{
		BOOL bDlgInit;
		if (m_lpDialogInit != NULL)
			bDlgInit = pOccManager->CreateDlgControls(this, m_lpDialogInit,
				m_pOccDialogInfo);
		else
			bDlgInit = pOccManager->CreateDlgControls(this, m_lpszTemplateName,
				m_pOccDialogInfo);

		if (!bDlgInit)
		{
			TRACE(traceAppMsg, 0, "Warning: CreateDlgControls failed during dialog init.\n");
			EndDialog(-1);
			return FALSE;
		}
	}
#endif

	// Default will call the dialog proc, and thus OnInitDialog
	LRESULT bResult = Default();

#ifndef _AFX_NO_OCC_SUPPORT
	if (bResult && (m_nFlags & WF_OLECTLCONTAINER))
	{
		if (m_pCtrlCont != NULL)
		{
			m_pCtrlCont->m_pSiteFocus = NULL;
		}

		CWnd* pWndNext = GetNextDlgTabItem(NULL);
		if (pWndNext != NULL)
		{
			pWndNext->SetFocus();   // UI Activate OLE control
			bResult = FALSE;
			
		}
	}
#endif

	return bResult;
}

BOOL AFXAPI AfxHelpEnabled()
{
	if (AfxGetApp() == NULL)
		return FALSE;

	// help is enabled if the app has a handler for ID_HELP
	AFX_CMDHANDLERINFO info;

	// check main window first
	CWnd* pWnd = AfxGetMainWnd();
	if (pWnd != NULL && pWnd->OnCmdMsg(ID_HELP, CN_COMMAND, NULL, &info))
		return TRUE;

	// check app last
	return AfxGetApp()->OnCmdMsg(ID_HELP, CN_COMMAND, NULL, &info);
}

void CDialog::OnSetFont(CFont*)
{
	// ignore it
}

BOOL CDialog::OnInitDialog()
{
	// execute dialog RT_DLGINIT resource
	BOOL bDlgInit;
	if (m_lpDialogInit != NULL)
		bDlgInit = ExecuteDlgInit(m_lpDialogInit);
	else
		bDlgInit = ExecuteDlgInit(m_lpszTemplateName);

	if (!bDlgInit)
	{
		TRACE(traceAppMsg, 0, "Warning: ExecuteDlgInit failed during dialog init.\n");
		EndDialog(-1);
		return FALSE;
	}

	// transfer data into the dialog from member variables
	if (!UpdateData(FALSE))
	{
		TRACE(traceAppMsg, 0, "Warning: UpdateData failed during dialog init.\n");
		EndDialog(-1);
		return FALSE;
	}

	// enable/disable help button automatically
	CWnd* pHelpButton = GetDlgItem(ID_HELP);
	if (pHelpButton != NULL)
		pHelpButton->ShowWindow(AfxHelpEnabled() ? SW_SHOW : SW_HIDE);

	return TRUE;    // set focus to first one
}

void CDialog::OnOK()
{
	if (!UpdateData(TRUE))
	{
		TRACE(traceAppMsg, 0, "UpdateData failed during dialog termination.\n");
		// the UpdateData routine will set focus to correct item
		return;
	}
	EndDialog(IDOK);
}

void CDialog::OnCancel()
{
	EndDialog(IDCANCEL);
}

BOOL CDialog::CheckAutoCenter()
{
	// load resource as necessary
	LPCDLGTEMPLATE lpDialogTemplate = m_lpDialogTemplate;
	HGLOBAL hDialogTemplate = m_hDialogTemplate;
	if (m_lpszTemplateName != NULL)
	{
		HINSTANCE hInst = AfxFindResourceHandle(m_lpszTemplateName, RT_DIALOG);
		HRSRC hResource = ::FindResource(hInst, m_lpszTemplateName, RT_DIALOG);
		hDialogTemplate = LoadResource(hInst, hResource);
	}
	if (hDialogTemplate != NULL)
		lpDialogTemplate = (LPCDLGTEMPLATE)LockResource(hDialogTemplate);

	// determine if dialog should be centered
	BOOL bResult = TRUE;

	if (lpDialogTemplate != NULL)
	{
		DWORD dwStyle = lpDialogTemplate->style;
		short x;
		short y;

		if (((DLGTEMPLATEEX*)lpDialogTemplate)->signature == 0xFFFF)
		{
			// it's a DIALOGEX resource
			dwStyle = ((DLGTEMPLATEEX*)lpDialogTemplate)->style;
			x = ((DLGTEMPLATEEX*)lpDialogTemplate)->x;
			y = ((DLGTEMPLATEEX*)lpDialogTemplate)->y;
		}
		else
		{
			// it's a DIALOG resource
			x = lpDialogTemplate->x;
			y = lpDialogTemplate->y;
		}

		bResult = !(dwStyle & (DS_CENTER|DS_CENTERMOUSE|DS_ABSALIGN)) &&
			x == 0 && y == 0;
	}

	// unlock/free resources as necessary
	if (m_lpszTemplateName != NULL || m_hDialogTemplate != NULL)
		UnlockResource(hDialogTemplate);
	if (m_lpszTemplateName != NULL)
		FreeResource(hDialogTemplate);

	return bResult; // TRUE if auto-center is ok
}

/////////////////////////////////////////////////////////////////////////////
// CDialog support for context sensitive help.

LRESULT CDialog::OnCommandHelp(WPARAM, LPARAM lParam)
{
	if (lParam == 0 && m_nIDHelp != 0)
		lParam = HID_BASE_RESOURCE + m_nIDHelp;
	if (lParam != 0)
	{
		CWinApp* pApp = AfxGetApp();
		if (pApp != NULL)
			pApp->WinHelpInternal(lParam);
		return TRUE;
	}
	return FALSE;
}

LRESULT CDialog::OnHelpHitTest(WPARAM, LPARAM)
{
	if (m_nIDHelp != 0)
		return HID_BASE_RESOURCE + m_nIDHelp;
	return 0;
}

/////////////////////////////////////////////////////////////////////////////
// CDialog Diagnostics

#ifdef _DEBUG
void CDialog::AssertValid() const
{
	CWnd::AssertValid();
}

void CDialog::Dump(CDumpContext& dc) const
{
	CWnd::Dump(dc);

	dc << "m_lpszTemplateName = ";
	if (IS_INTRESOURCE(m_lpszTemplateName))
		dc << (int)LOWORD((DWORD_PTR)m_lpszTemplateName);
	else
		dc << m_lpszTemplateName;

	dc << "\nm_hDialogTemplate = " << (void*)m_hDialogTemplate;
	dc << "\nm_lpDialogTemplate = " << (void*)m_lpDialogTemplate;
	dc << "\nm_pParentWnd = " << (void*)m_pParentWnd;
	dc << "\nm_nIDHelp = " << m_nIDHelp;

	dc << "\n";
}

// diagnostic routine to check for and decode dialog templates
// return FALSE if a program error occurs (i.e. bad resource ID or
//   bad dialog styles).
BOOL AFXAPI _AfxCheckDialogTemplate(LPCTSTR lpszResource, BOOL bInvisibleChild)
{
	ASSERT(lpszResource != NULL);
	HINSTANCE hInst = AfxFindResourceHandle(lpszResource, RT_DIALOG);
	HRSRC hResource = ::FindResource(hInst, lpszResource, RT_DIALOG);
	if (hResource == NULL)
	{
		if (DWORD_PTR(lpszResource) > 0xffff)
			TRACE(traceAppMsg, 0, _T("ERROR: Cannot find dialog template named '%s'.\n"),
				lpszResource);
		else
			TRACE(traceAppMsg, 0, "ERROR: Cannot find dialog template with IDD 0x%04X.\n",
				LOWORD((DWORD_PTR)lpszResource));
		return FALSE;
	}

	if (!bInvisibleChild)
		return TRUE;        // that's all we need to check

	// we must check that the dialog template is for an invisible child
	//  window that can be used for a form-view or dialog-bar
	HGLOBAL hTemplate = LoadResource(hInst, hResource);
	if (hTemplate == NULL)
	{
		TRACE(traceAppMsg, 0, "Warning: LoadResource failed for dialog template.\n");
		// this is only a warning, the real call to CreateDialog will fail
		return TRUE;        // not a program error - just out of memory
	}
	DLGTEMPLATEEX* pTemplate = (DLGTEMPLATEEX*)LockResource(hTemplate);
	DWORD dwStyle;
	if (pTemplate->signature == 0xFFFF)
		dwStyle = pTemplate->style;
	else
		dwStyle = ((DLGTEMPLATE*)pTemplate)->style;
	UnlockResource(hTemplate);
	FreeResource(hTemplate);

	if (dwStyle & WS_VISIBLE)
	{
		if (DWORD_PTR(lpszResource) > 0xffff)
			TRACE(traceAppMsg, 0, _T("ERROR: Dialog named '%s' must be invisible.\n"),
				lpszResource);
		else
			TRACE(traceAppMsg, 0, "ERROR: Dialog with IDD 0x%04X must be invisible.\n",
				LOWORD((DWORD_PTR)lpszResource));
		return FALSE;
	}
	if (!(dwStyle & WS_CHILD))
	{
		if (DWORD_PTR(lpszResource) > 0xffff)
			TRACE(traceAppMsg, 0, _T("ERROR: Dialog named '%s' must have the child style.\n"),
				lpszResource);
		else
			TRACE(traceAppMsg, 0, "ERROR: Dialog with IDD 0x%04X must have the child style.\n",
				LOWORD((DWORD_PTR)lpszResource));
		return FALSE;
	}

	return TRUE;
}

#endif //_DEBUG


IMPLEMENT_DYNAMIC(CDialog, CWnd)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\dlgfnt.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// Choose Font dialog

CFontDialog::CFontDialog(LPLOGFONT lplfInitial, DWORD dwFlags, CDC* pdcPrinter,
	CWnd* pParentWnd) : CCommonDialog(pParentWnd)
{
	memset(&m_cf, 0, sizeof(m_cf));
	memset(&m_lf, 0, sizeof(m_lf));
	memset(&m_szStyleName, 0, sizeof(m_szStyleName));

	m_nIDHelp = AFX_IDD_FONT;

	m_cf.lStructSize = sizeof(m_cf);
	m_cf.lpszStyle = (LPTSTR)&m_szStyleName;
	m_cf.Flags = dwFlags | CF_ENABLEHOOK;
	m_cf.lpfnHook = (COMMDLGPROC)_AfxCommDlgProc;

	if (lplfInitial)
	{
		m_cf.lpLogFont = lplfInitial;
		m_cf.Flags |= CF_INITTOLOGFONTSTRUCT;
		Checked::memcpy_s(&m_lf, sizeof(LOGFONT), m_cf.lpLogFont, sizeof(LOGFONT));
	}
	else
	{
		m_cf.lpLogFont = &m_lf;
	}

	if (pdcPrinter)
	{
		ASSERT(pdcPrinter->m_hDC != NULL);
		m_cf.hDC = pdcPrinter->m_hDC;
		m_cf.Flags |= CF_PRINTERFONTS;
	}
}

#ifndef _AFX_NO_RICHEDIT_SUPPORT
CFontDialog::CFontDialog(const CHARFORMAT& charformat, DWORD dwFlags,
	CDC* pdcPrinter, CWnd* pParentWnd) : CCommonDialog(pParentWnd)
{
	memset(&m_cf, 0, sizeof(m_cf));
	memset(&m_lf, 0, sizeof(m_lf));
	memset(&m_szStyleName, 0, sizeof(m_szStyleName));

	m_nIDHelp = AFX_IDD_FONT;

	m_cf.lStructSize = sizeof(m_cf);
	m_cf.lpszStyle = (LPTSTR)&m_szStyleName;
	m_cf.Flags = dwFlags | CF_ENABLEHOOK | CF_INITTOLOGFONTSTRUCT;
	m_cf.Flags |= FillInLogFont(charformat);
	m_cf.lpfnHook = (COMMDLGPROC)_AfxCommDlgProc;

	m_cf.lpLogFont = &m_lf;

	if (pdcPrinter)
	{
		ASSERT(pdcPrinter->m_hDC != NULL);
		m_cf.hDC = pdcPrinter->m_hDC;
		m_cf.Flags |= CF_PRINTERFONTS;
	}
	if (charformat.dwMask & CFM_COLOR)
		m_cf.rgbColors = charformat.crTextColor;
}
#endif

INT_PTR CFontDialog::DoModal()
{
	ASSERT_VALID(this);
	ASSERT(m_cf.Flags & CF_ENABLEHOOK);
	ASSERT(m_cf.lpfnHook != NULL); // can still be a user hook

	m_cf.hwndOwner = PreModal();
	INT_PTR nResult = ::AfxCtxChooseFont(&m_cf);
	PostModal();

	if (nResult == IDOK)
	{
		// copy logical font from user's initialization buffer (if needed)
		Checked::memcpy_s(&m_lf, sizeof(LOGFONT), m_cf.lpLogFont, sizeof(LOGFONT));
		return IDOK;
	}
	return nResult ? nResult : IDCANCEL;
}

void CFontDialog::GetCurrentFont(LPLOGFONT lplf)
{
	ASSERT(lplf != NULL);

	if (m_hWnd != NULL)
		SendMessage(WM_CHOOSEFONT_GETLOGFONT, 0, (LPARAM)(LPVOID)lplf);
	else
		*lplf = m_lf;
}

#ifndef _AFX_NO_RICHEDIT_SUPPORT
////////////////////////////////////////////////////////////////////////////
// CFontDialog CHARFORMAT helpers

DWORD CFontDialog::FillInLogFont(const CHARFORMAT& cf)
{
	DWORD dwFlags = 0;
	BOOL bIsFormat2 = (cf.cbSize >= sizeof(CHARFORMAT2));

	if (cf.dwMask & CFM_SIZE)
	{
		CDC dc;
		BOOL bSuccess=dc.CreateDC(_T("DISPLAY"), NULL, NULL, NULL);
		ENSURE(bSuccess);
		LONG yPerInch = dc.GetDeviceCaps(LOGPIXELSY);
		m_lf.lfHeight = -(int) ((cf.yHeight * yPerInch) / 1440);
	}
	else
	{
		m_lf.lfHeight = 0;
	}

	m_lf.lfWidth = 0;
	m_lf.lfEscapement = 0;
	m_lf.lfOrientation = 0;

	if ((cf.dwMask & (CFM_ITALIC|CFM_BOLD)) == (CFM_ITALIC|CFM_BOLD))
	{
		m_lf.lfWeight = (cf.dwEffects & CFE_BOLD) ? FW_BOLD : FW_NORMAL;
		m_lf.lfItalic = (BYTE)((cf.dwEffects & CFE_ITALIC) ? TRUE : FALSE);
	}
	else
	{
		dwFlags |= CF_NOSTYLESEL;
		m_lf.lfWeight = FW_DONTCARE;
		m_lf.lfItalic = FALSE;
	}

	if ((cf.dwMask & (CFM_UNDERLINE|CFM_STRIKEOUT|CFM_COLOR)) ==
		(CFM_UNDERLINE|CFM_STRIKEOUT|CFM_COLOR))
	{
		dwFlags |= CF_EFFECTS;
		m_lf.lfUnderline = (BYTE)((cf.dwEffects & CFE_UNDERLINE) ? TRUE : FALSE);
		m_lf.lfStrikeOut = (BYTE)((cf.dwEffects & CFE_STRIKEOUT) ? TRUE : FALSE);
	}
	else
	{
		m_lf.lfUnderline = (BYTE)FALSE;
		m_lf.lfStrikeOut = (BYTE)FALSE;
	}

	if (cf.dwMask & CFM_CHARSET)
		m_lf.lfCharSet = cf.bCharSet;
	else
		dwFlags |= CF_NOSCRIPTSEL;
	m_lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
	m_lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
	m_lf.lfQuality = DEFAULT_QUALITY;

	if (bIsFormat2)
	{
		const CHARFORMAT2* pCF2 = (const CHARFORMAT2*) &cf;
		if (pCF2->dwMask & CFM_WEIGHT)
			m_lf.lfWeight = pCF2->wWeight;

		// CHAFORMAT2 has UNICODE face name, CHARFORMAT doesn't

		if (cf.dwMask & CFM_FACE)
		{
			m_lf.lfPitchAndFamily = pCF2->bPitchAndFamily;
			Checked::tcscpy_s(m_lf.lfFaceName, _countof(m_lf.lfFaceName), (LPTSTR)pCF2->szFaceName);
		}
	}
	else
	{
		m_lf.lfPitchAndFamily = cf.bPitchAndFamily;
		CString strFaceName(cf.szFaceName);
		Checked::tcsncpy_s(m_lf.lfFaceName, _countof(m_lf.lfFaceName), strFaceName.GetString(), _TRUNCATE);
	}

	if (!(cf.dwMask & CFM_FACE))
	{
		m_lf.lfPitchAndFamily = DEFAULT_PITCH|FF_DONTCARE;
		m_lf.lfFaceName[0] = (TCHAR)0;
	}

	return dwFlags;
}

void CFontDialog::GetCharFormat(CHARFORMAT& cf) const
{
	cf.dwEffects = 0;
	cf.dwMask = 0;
	if ((m_cf.Flags & CF_NOSTYLESEL) == 0)
	{
		cf.dwMask |= CFM_BOLD | CFM_ITALIC;
		cf.dwEffects |= (IsBold()) ? CFE_BOLD : 0;
		cf.dwEffects |= (IsItalic()) ? CFE_ITALIC : 0;
	}
	if ((m_cf.Flags & CF_NOSIZESEL) == 0)
	{
		cf.dwMask |= CFM_SIZE;
		//GetSize() returns in tenths of points so mulitply by 2 to get twips
		cf.yHeight = GetSize()*2;
	}

	if ((m_cf.Flags & CF_NOFACESEL) == 0)
	{
		cf.dwMask |= CFM_FACE;
		cf.bPitchAndFamily = m_cf.lpLogFont->lfPitchAndFamily;
		Checked::tcsncpy_s(cf.szFaceName, _countof(cf.szFaceName), GetFaceName(), _TRUNCATE);
	}

	if (m_cf.Flags & CF_EFFECTS)
	{
		cf.dwMask |= CFM_UNDERLINE | CFM_STRIKEOUT | CFM_COLOR;
		cf.dwEffects |= (IsUnderline()) ? CFE_UNDERLINE : 0;
		cf.dwEffects |= (IsStrikeOut()) ? CFE_STRIKEOUT : 0;
		cf.crTextColor = GetColor();
	}
	if ((m_cf.Flags & CF_NOSCRIPTSEL) == 0)
	{
		cf.bCharSet = m_cf.lpLogFont->lfCharSet;
		cf.dwMask |= CFM_CHARSET;
	}
	cf.yOffset = 0;
}
#endif

////////////////////////////////////////////////////////////////////////////
// CFontDialog diagnostics

#ifdef _DEBUG
void CFontDialog::Dump(CDumpContext& dc) const
{
	CDialog::Dump(dc);

	dc << "m_cf.hwndOwner = " << m_cf.hwndOwner;
	dc << "\nm_cf.hDC = " << m_cf.hDC;
	dc << "\nm_cf.iPointSize = " << m_cf.iPointSize;
	dc << "\nm_cf.Flags = ";
	dc.DumpAsHex(m_cf.Flags);
	dc << "\nm_cf.lpszStyle = " << m_cf.lpszStyle;
	dc << "\nm_cf.nSizeMin = " << m_cf.nSizeMin;
	dc << "\nm_cf.nSizeMax = " << m_cf.nSizeMax;
	dc << "\nm_cf.nFontType = " << m_cf.nFontType;
	dc << "\nm_cf.rgbColors = ";
	dc.DumpAsHex(m_cf.rgbColors);

	if (m_cf.lpfnHook == (COMMDLGPROC)_AfxCommDlgProc)
		dc << "\nhook function set to standard MFC hook function";
	else
		dc << "\nhook function set to non-standard hook function";

	dc << "\n";
}
#endif //_DEBUG


IMPLEMENT_DYNAMIC(CFontDialog, CCommonDialog)

////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\dlgfr.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include <stddef.h>     // for offsetof macro



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// Find/FindReplace dialogs

CFindReplaceDialog::CFindReplaceDialog() : CCommonDialog(NULL)
{
	memset(&m_fr, 0, sizeof(m_fr));
	m_szFindWhat[0] = '\0';
	m_szReplaceWith[0] = '\0';

	m_fr.Flags = FR_ENABLEHOOK;
	m_fr.lpfnHook = (COMMDLGPROC)_AfxCommDlgProc;
	m_fr.lStructSize = sizeof(m_fr);
	m_fr.lpstrFindWhat = (LPTSTR)m_szFindWhat;
}

void CFindReplaceDialog::PostNcDestroy()
{
	ASSERT(m_hWnd == NULL);
	delete this;
}

BOOL CFindReplaceDialog::Create(BOOL bFindDialogOnly,
	LPCTSTR lpszFindWhat, LPCTSTR lpszReplaceWith,
	DWORD dwFlags, CWnd* pParentWnd)
{
	ASSERT_VALID(this);
	ASSERT(m_fr.Flags & FR_ENABLEHOOK);
	ASSERT(m_fr.lpfnHook != NULL);

	m_nIDHelp = bFindDialogOnly ? AFX_IDD_FIND : AFX_IDD_REPLACE;

	m_fr.wFindWhatLen = _countof(m_szFindWhat);
	m_fr.lpstrReplaceWith = (LPTSTR)m_szReplaceWith;
	m_fr.wReplaceWithLen = _countof(m_szReplaceWith);
	m_fr.Flags |= dwFlags;

	if (pParentWnd == NULL)
		m_fr.hwndOwner = AfxGetMainWnd()->GetSafeHwnd();
	else
	{
		ASSERT_VALID(pParentWnd);
		m_fr.hwndOwner = pParentWnd->m_hWnd;
	}
	ASSERT(m_fr.hwndOwner != NULL); // must have a parent for modeless dialog

	if (lpszFindWhat != NULL)
		Checked::tcsncpy_s(m_szFindWhat, _countof(m_szFindWhat), lpszFindWhat, _TRUNCATE);

	if (lpszReplaceWith != NULL)
		Checked::tcsncpy_s(m_szReplaceWith, _countof(m_szReplaceWith), lpszReplaceWith, _TRUNCATE);

	HWND hWnd;

	AfxHookWindowCreate(this);
	if (bFindDialogOnly)
		hWnd = ::AfxCtxFindText(&m_fr);
	else
		hWnd = ::AfxCtxReplaceText(&m_fr);
	if (!AfxUnhookWindowCreate())
		PostNcDestroy();

	ASSERT(hWnd == NULL || hWnd == m_hWnd);
	return hWnd != NULL;
}

CFindReplaceDialog* PASCAL CFindReplaceDialog::GetNotifier(LPARAM lParam)
{
	ASSERT(lParam != NULL);
	CFindReplaceDialog* pDlg;

	pDlg = (CFindReplaceDialog*)(lParam - offsetof(CFindReplaceDialog, m_fr));
	ASSERT_VALID(pDlg);
	ASSERT_KINDOF(CFindReplaceDialog, pDlg);

	return pDlg;
}

////////////////////////////////////////////////////////////////////////////
// CFindReplaceDialog diagnostics

#ifdef _DEBUG
void CFindReplaceDialog::Dump(CDumpContext& dc) const
{
	CDialog::Dump(dc);

	dc << "m_fr.hwndOwner = " << m_fr.hwndOwner;
	dc << "\nm_fr.Flags = ";
	dc.DumpAsHex(m_fr.Flags);
	dc << "\nm_fr.lpstrFindWhat = " << m_fr.lpstrFindWhat;
	dc << "\nm_fr.lpstrReplaceWith = " << m_fr.lpstrReplaceWith;

	if (m_fr.lpfnHook == (COMMDLGPROC)_AfxCommDlgProc)
		dc << "\nhook function set to standard MFC hook function";
	else
		dc << "\nhook function set to non-standard hook function";

	dc << "\n";
}
#endif //_DEBUG


IMPLEMENT_DYNAMIC(CFindReplaceDialog, CCommonDialog)

////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\dlgfloat.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include <float.h>              // floating point precision



/////////////////////////////////////////////////////////////////////////////
// Extra data validation procs for float/double support
//  see "dlgdata.cpp" for non-floating point support
/////////////////////////////////////////////////////////////////////////////

/*
AFX_STATIC BOOL AFXAPI _AfxSimpleFloatParse(LPCTSTR lpszText, double& d)
{
	ASSERT(lpszText != NULL);
	while (*lpszText == ' ' || *lpszText == '\t')
		lpszText++;

	TCHAR chFirst = lpszText[0];
	d = _tcstod(lpszText, (LPTSTR*)&lpszText);
	if (d == 0.0 && chFirst != '0')
		return FALSE;   // could not convert
	while (*lpszText == ' ' || *lpszText == '\t')
		lpszText++;

	if (*lpszText != '\0')
		return FALSE;   // not terminated properly

	return TRUE;
}
*/

void AFXAPI AfxTextFloatFormat(CDataExchange* pDX, int nIDC,
	void* pData, double value, int nSizeGcvt)
{
	ASSERT(pData != NULL);

	pDX->PrepareEditCtrl(nIDC);
	HWND hWndCtrl;
	pDX->m_pDlgWnd->GetDlgItem(nIDC, &hWndCtrl);
	
	const int TEXT_BUFFER_SIZE = 400;
	TCHAR szBuffer[TEXT_BUFFER_SIZE];
	if (pDX->m_bSaveAndValidate)
	{
		::GetWindowText(hWndCtrl, szBuffer, _countof(szBuffer));
		double d;
		if (_sntscanf_s(szBuffer, _countof(szBuffer), _T("%lf"), &d) != 1)
		{
			AfxMessageBox(AFX_IDP_PARSE_REAL);
			pDX->Fail();            // throws exception
		}
		if (nSizeGcvt == FLT_DIG)
			*((float*)pData) = (float)d;
		else
			*((double*)pData) = d;
	}
	else
	{
		ATL_CRT_ERRORCHECK_SPRINTF(_sntprintf_s(szBuffer, _countof(szBuffer), _countof(szBuffer) -1, _T("%.*g"), nSizeGcvt, value));
		AfxSetWindowText(hWndCtrl, szBuffer);
	}
}

void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, float& value)
{
	AfxTextFloatFormat(pDX, nIDC, &value, value, FLT_DIG);
}

void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, double& value)
{
	AfxTextFloatFormat(pDX, nIDC, &value, value, DBL_DIG);
}

/////////////////////////////////////////////////////////////////////////////
// Validation procs

AFX_STATIC void AFXAPI _AfxFailMinMaxReal(CDataExchange* pDX,
	 double minVal, double maxVal, int precision, UINT nIDPrompt)
	// error string must have '%1' and '%2' in it
{
	if (!pDX->m_bSaveAndValidate)
	{
		TRACE(traceAppMsg, 0, "Warning: initial dialog data is out of range.\n");
		return;         // don't stop now
	}
	
	const int MINMAX_BUFFER_SIZE = 32;
	TCHAR szMin[MINMAX_BUFFER_SIZE], szMax[MINMAX_BUFFER_SIZE];
	CString prompt;

	ATL_CRT_ERRORCHECK_SPRINTF(_sntprintf_s(szMin, _countof(szMin), _countof(szMin) - 1, _T("%.*g"), precision, minVal));
	ATL_CRT_ERRORCHECK_SPRINTF(_sntprintf_s(szMax, _countof(szMax), _countof(szMax) - 1, _T("%.*g"), precision, maxVal));

	AfxFormatString2(prompt, nIDPrompt, szMin, szMax);

	AfxMessageBox(prompt, MB_ICONEXCLAMATION, nIDPrompt);
	prompt.Empty(); // exception prep
	pDX->Fail();
}

void AFXAPI DDV_MinMaxFloat(CDataExchange* pDX, float const& value, float minVal, float maxVal)
{
	ASSERT(minVal <= maxVal);
	if (value < minVal || value > maxVal)
		_AfxFailMinMaxReal(pDX, (double)minVal, (double)maxVal, FLT_DIG,
			AFX_IDP_PARSE_REAL_RANGE);
}

void AFXAPI DDV_MinMaxDouble(CDataExchange* pDX, double const& value, double minVal, double maxVal)
{
	ASSERT(minVal <= maxVal);
	if (value < minVal || value > maxVal)
		_AfxFailMinMaxReal(pDX, (double)minVal, (double)maxVal, DBL_DIG,
			AFX_IDP_PARSE_REAL_RANGE);
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\dlgtempl.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "sal.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// _AfxConvertDialogUnitsToPixels

AFX_STATIC void AFXAPI _AfxConvertDialogUnitsToPixels(LPCTSTR pszFontFace, WORD wFontSize,
	int cxDlg, int cyDlg, SIZE* pSizePixel)
{
	// Attempt to create the font to be used in the dialog box
	UINT cxSysChar, cySysChar;
	LOGFONT lf;
	HDC hDC = ::GetDC(NULL);
	memset(&lf, 0, sizeof(LOGFONT));
	lf.lfHeight = -MulDiv(wFontSize, GetDeviceCaps(hDC, LOGPIXELSY), 72);
	lf.lfWeight = FW_NORMAL;
	lf.lfCharSet = DEFAULT_CHARSET;
	Checked::tcsncpy_s(lf.lfFaceName, _countof(lf.lfFaceName), pszFontFace, _TRUNCATE);

	HFONT hNewFont = CreateFontIndirect(&lf);
	if (hNewFont != NULL)
	{
		HFONT hFontOld = (HFONT)SelectObject(hDC, hNewFont);
		TEXTMETRIC tm;
		GetTextMetrics(hDC, &tm);
		cySysChar = tm.tmHeight + tm.tmExternalLeading;
		SIZE size;
		::GetTextExtentPoint32(hDC,
			_T("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"), 52,
			&size);
		cxSysChar = (size.cx + 26) / 52;
		SelectObject(hDC, hFontOld);
		DeleteObject(hNewFont);
	}
	else
	{
		// Could not create the font so just use the system's values
		cxSysChar = LOWORD(GetDialogBaseUnits());
		cySysChar = HIWORD(GetDialogBaseUnits());
	}
	::ReleaseDC(NULL, hDC);

	// Translate dialog units to pixels
	pSizePixel->cx = MulDiv(cxDlg, cxSysChar, 4);
	pSizePixel->cy = MulDiv(cyDlg, cySysChar, 8);
}

/////////////////////////////////////////////////////////////////////////////
// IsDialogEx

AFX_STATIC inline BOOL IsDialogEx(const DLGTEMPLATE* pTemplate)
{
	return ((DLGTEMPLATEEX*)pTemplate)->signature == 0xFFFF;
}

/////////////////////////////////////////////////////////////////////////////
// HasFont

AFX_STATIC inline BOOL HasFont(const DLGTEMPLATE* pTemplate)
{
	return (DS_SETFONT &
		(IsDialogEx(pTemplate) ? ((DLGTEMPLATEEX*)pTemplate)->style :
		pTemplate->style));
}

/////////////////////////////////////////////////////////////////////////////
// FontAttrSize

AFX_STATIC inline int FontAttrSize(BOOL bDialogEx)
{
	return (int)sizeof(WORD) * (bDialogEx ? 3 : 1);
}

/////////////////////////////////////////////////////////////////////////////
// CDialogTemplate - implementation class

CDialogTemplate::CDialogTemplate(const DLGTEMPLATE* pTemplate)
{
	if (pTemplate == NULL)
	{
		m_hTemplate = NULL;
		m_dwTemplateSize = 0;
		m_bSystemFont = FALSE;
	}
	else
	{
		BOOL bSet=SetTemplate(pTemplate, GetTemplateSize(pTemplate));
		if(!bSet)
		{
			AfxThrowMemoryException();
		}
	}
}

CDialogTemplate::CDialogTemplate(HGLOBAL hTemplate)
{
	if (hTemplate == NULL)
	{
		m_hTemplate = NULL;
		m_dwTemplateSize = 0;
		m_bSystemFont = FALSE;
	}
	else
	{
		DLGTEMPLATE* pTemplate = (DLGTEMPLATE*)GlobalLock(hTemplate);
		BOOL bSet=SetTemplate(pTemplate, GetTemplateSize(pTemplate));
		GlobalUnlock(hTemplate);
		if(!bSet)
		{
			AfxThrowMemoryException();
		}
	}
}

BOOL CDialogTemplate::SetTemplate(const DLGTEMPLATE* pTemplate, UINT cb)
{
	m_dwTemplateSize = cb;
	SIZE_T nAllocSize=m_dwTemplateSize + LF_FACESIZE * 2;
	if (nAllocSize < m_dwTemplateSize)
	{
		return FALSE;
	}
	if ((m_hTemplate = GlobalAlloc(GPTR,nAllocSize)) == NULL)
	{
		return FALSE;
	}
	DLGTEMPLATE* pNew = (DLGTEMPLATE*)GlobalLock(m_hTemplate);
	Checked::memcpy_s((BYTE*)pNew, (size_t)m_dwTemplateSize, pTemplate, (size_t)m_dwTemplateSize);

	m_bSystemFont = (::HasFont(pNew) == 0);

	GlobalUnlock(m_hTemplate);
	return TRUE;
}

CDialogTemplate::~CDialogTemplate()
{
	if (m_hTemplate != NULL)
		GlobalFree(m_hTemplate);
}

BOOL CDialogTemplate::Load(LPCTSTR lpDialogTemplateID)
{
	HINSTANCE hInst = AfxFindResourceHandle(lpDialogTemplateID, RT_DIALOG);
	if (hInst == NULL)
	{
		return FALSE;
	}
	HRSRC hRsrc = FindResource(hInst, lpDialogTemplateID, RT_DIALOG);
	if (hRsrc == NULL)
	{
		return FALSE;
	}
	HGLOBAL hTemplate = LoadResource(hInst, hRsrc);
	DLGTEMPLATE* pTemplate = (DLGTEMPLATE*)LockResource(hTemplate);
	BOOL bSet=SetTemplate(pTemplate, (UINT)SizeofResource(hInst, hRsrc));
	UnlockResource(hTemplate);
	FreeResource(hTemplate);
	return bSet;
}

HGLOBAL CDialogTemplate::Detach()
{
	HGLOBAL hTmp = m_hTemplate;
	m_hTemplate = NULL;
	return hTmp;
}

BOOL CDialogTemplate::HasFont() const
{
	DLGTEMPLATE* pTemplate = (DLGTEMPLATE*)GlobalLock(m_hTemplate);
	BOOL bHasFont = ::HasFont(pTemplate);
	GlobalUnlock(m_hTemplate);
	return bHasFont;
}

inline WCHAR* _SkipString(_In_z_ WCHAR* p)
{
	while (*p++);
	return p;
}

BYTE* AFX_CDECL CDialogTemplate::GetFontSizeField(const DLGTEMPLATE* pTemplate)
{
	BOOL bDialogEx = IsDialogEx(pTemplate);
	WORD* pw;

	if (bDialogEx)
		pw = (WORD*)((DLGTEMPLATEEX*)pTemplate + 1);
	else
		pw = (WORD*)(pTemplate + 1);

	if (*pw == (WORD)-1)        // Skip menu name string or ordinal
		pw += 2; // WORDs
	else
		while(*pw++);

	if (*pw == (WORD)-1)        // Skip class name string or ordinal
		pw += 2; // WORDs
	else
		while(*pw++);

	while (*pw++);          // Skip caption string

	return (BYTE*)pw;
}

UINT AFX_CDECL CDialogTemplate::GetTemplateSize(const DLGTEMPLATE* pTemplate)
{
	BOOL bDialogEx = IsDialogEx(pTemplate);
	BYTE* pb = GetFontSizeField(pTemplate);

	if (::HasFont(pTemplate))
	{
		// Skip font size and name
		pb += FontAttrSize(bDialogEx);  // Skip font size, weight, (italic, charset)
		pb += 2 * (wcslen((WCHAR*)pb) + 1);
	}

	WORD nCtrl = bDialogEx ? (WORD)((DLGTEMPLATEEX*)pTemplate)->cDlgItems :
		(WORD)pTemplate->cdit;

	while (nCtrl > 0)
	{
		pb = (BYTE*)(((DWORD_PTR)pb + 3) & ~DWORD_PTR(3)); // DWORD align

		pb += (bDialogEx ? sizeof(DLGITEMTEMPLATEEX) : sizeof(DLGITEMTEMPLATE));

		if (*(WORD*)pb == (WORD)-1)     // Skip class name string or ordinal
			pb += 2 * sizeof(WORD);
		else
			pb = (BYTE*)_SkipString((WCHAR*)pb);

		if (*(WORD*)pb == (WORD)-1)     // Skip text string or ordinal
			pb += 2 * sizeof(WORD);
		else
			pb = (BYTE*)_SkipString((WCHAR*)pb);

		WORD cbExtra = *(WORD*)pb;      // Skip extra data
		if (cbExtra != 0 && !bDialogEx)
			cbExtra -= 2;
		pb += sizeof(WORD) + cbExtra;
		--nCtrl;
	}

	return UINT(pb - (BYTE*)pTemplate);
}

BOOL AFX_CDECL CDialogTemplate::GetFont(const DLGTEMPLATE* pTemplate,
	CString& strFace, WORD& nFontSize)
{
	ASSERT(pTemplate != NULL);

	if (!::HasFont(pTemplate))
		return FALSE;

	BYTE* pb = GetFontSizeField(pTemplate);
	nFontSize = *(WORD*)pb;
	pb += FontAttrSize(IsDialogEx(pTemplate));

#if defined(_UNICODE)
	// Copy font name
	strFace = (LPCTSTR)pb;
#else
	// Convert Unicode font name to MBCS
	WideCharToMultiByte(CP_ACP, 0, (LPCWSTR)pb, -1,
		strFace.GetBufferSetLength(LF_FACESIZE), LF_FACESIZE, NULL, NULL);
	strFace.ReleaseBuffer();
#endif

	return TRUE;
}

BOOL CDialogTemplate::GetFont(CString& strFace, WORD& nFontSize) const
{
	ASSERT(m_hTemplate != NULL);

	DLGTEMPLATE* pTemplate = (DLGTEMPLATE*)GlobalLock(m_hTemplate);
	BOOL bResult = GetFont(pTemplate, strFace, nFontSize);
	GlobalUnlock(m_hTemplate);
	return bResult;
}

BOOL CDialogTemplate::SetFont(LPCTSTR lpFaceName, WORD nFontSize)
{
	ASSERT(m_hTemplate != NULL);

	if (m_dwTemplateSize == 0)
		return FALSE;

	DLGTEMPLATE* pTemplate = (DLGTEMPLATE*)GlobalLock(m_hTemplate);

	BOOL bDialogEx = IsDialogEx(pTemplate);
	BOOL bHasFont = ::HasFont(pTemplate);
	int cbFontAttr = FontAttrSize(bDialogEx);

	if (bDialogEx)
		((DLGTEMPLATEEX*)pTemplate)->style |= DS_SETFONT;
	else
		pTemplate->style |= DS_SETFONT;

	int nFaceNameLen = lstrlen(lpFaceName);
	if( nFaceNameLen >= LF_FACESIZE )
	{
		// Name too long
		return FALSE;
	}

#ifdef _UNICODE
	int cbNew = cbFontAttr + ((nFaceNameLen + 1) * sizeof(TCHAR));
	BYTE* pbNew = (BYTE*)lpFaceName;
#else
	WCHAR wszFaceName [LF_FACESIZE];
	int cbNew = cbFontAttr + 2 * MultiByteToWideChar(CP_ACP, 0, lpFaceName, -1, wszFaceName, LF_FACESIZE);
	BYTE* pbNew = (BYTE*)wszFaceName;
#endif
	if (cbNew < cbFontAttr)
	{
		return FALSE;
	}
	BYTE* pb = GetFontSizeField(pTemplate);
	int cbOld = (int)(bHasFont ? cbFontAttr + 2 * (wcslen((WCHAR*)(pb + cbFontAttr)) + 1) : 0);

	BYTE* pOldControls = (BYTE*)(((DWORD_PTR)pb + cbOld + 3) & ~DWORD_PTR(3));
	BYTE* pNewControls = (BYTE*)(((DWORD_PTR)pb + cbNew + 3) & ~DWORD_PTR(3));

	WORD nCtrl = bDialogEx ? (WORD)((DLGTEMPLATEEX*)pTemplate)->cDlgItems :
		(WORD)pTemplate->cdit;

	if (cbNew != cbOld && nCtrl > 0)
	{
		size_t nBuffLeftSize=(size_t)(m_dwTemplateSize - (pOldControls - (BYTE*)pTemplate));
		if (nBuffLeftSize > m_dwTemplateSize)
		{
			return FALSE;
		}
		Checked::memmove_s(pNewControls,nBuffLeftSize, pOldControls, nBuffLeftSize);
	}

	*(WORD*)pb = nFontSize;
	Checked::memmove_s(pb + cbFontAttr, cbNew - cbFontAttr, pbNew, cbNew - cbFontAttr);

	m_dwTemplateSize += ULONG(pNewControls - pOldControls);

	GlobalUnlock(m_hTemplate);
	m_bSystemFont = FALSE;
	return TRUE;
}

BOOL CDialogTemplate::SetSystemFont(WORD wSize)
{
	LOGFONT lf;
	LPCTSTR pszFace = _T("System");
	WORD wDefSize = 10;
	HFONT hFont = (HFONT)::GetStockObject(DEFAULT_GUI_FONT);
	if (hFont == NULL)
		hFont = (HFONT)::GetStockObject(SYSTEM_FONT);
	if (hFont != NULL)
	{
		if (::GetObject(hFont, sizeof(LOGFONT), &lf) != 0)
		{
			pszFace = lf.lfFaceName;
			HDC hDC = ::GetDC(NULL);
			if (lf.lfHeight < 0)
				lf.lfHeight = -lf.lfHeight;
			wDefSize = (WORD)MulDiv(lf.lfHeight, 72, GetDeviceCaps(hDC, LOGPIXELSY));
			::ReleaseDC(NULL, hDC);
		}
	}

	if (wSize == 0)
		wSize = wDefSize;

	return SetFont(pszFace, wSize);
}

void CDialogTemplate::GetSizeInDialogUnits(SIZE* pSize) const
{
	ASSERT(m_hTemplate != NULL);
	ASSERT_POINTER(pSize, SIZE);

	DLGTEMPLATE* pTemplate = (DLGTEMPLATE*)GlobalLock(m_hTemplate);

	if (IsDialogEx(pTemplate))
	{
		pSize->cx = ((DLGTEMPLATEEX*)pTemplate)->cx;
		pSize->cy = ((DLGTEMPLATEEX*)pTemplate)->cy;
	}
	else
	{
		pSize->cx = pTemplate->cx;
		pSize->cy = pTemplate->cy;
	}

	GlobalUnlock(m_hTemplate);
}

void CDialogTemplate::GetSizeInPixels(SIZE* pSize) const
{
	ASSERT(m_hTemplate != NULL);
	ASSERT_POINTER(pSize, SIZE);

	if (m_bSystemFont)
	{
		GetSizeInDialogUnits(pSize);
		DWORD dwDLU = GetDialogBaseUnits();
		pSize->cx = (pSize->cx * LOWORD(dwDLU)) / 4;
		pSize->cy = (pSize->cy * HIWORD(dwDLU)) / 8;
	}
	else
	{
		CString strFace;
		WORD wSize = 10;
		GetFont(strFace, wSize);

		SIZE size;
		GetSizeInDialogUnits(&size);
		_AfxConvertDialogUnitsToPixels(strFace, wSize, size.cx, size.cy, pSize);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\dlgprnt.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include <dlgs.h>       // for standard control IDs for commdlg



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// Page Setup dialog

CPageSetupDialog::CPageSetupDialog(DWORD dwFlags, CWnd* pParentWnd) :
	CCommonDialog(pParentWnd)
{
	memset(&m_psd, 0, sizeof(m_psd));

	m_psd.lStructSize = sizeof(m_psd);
	m_psd.Flags = (dwFlags | PSD_ENABLEPAGESETUPHOOK | PSD_ENABLEPAGEPAINTHOOK);
	m_psd.lpfnPageSetupHook = (COMMDLGPROC)_AfxCommDlgProc;
	m_psd.lpfnPagePaintHook = (COMMDLGPROC)CPageSetupDialog::PaintHookProc;
	if (AfxHelpEnabled())
		m_psd.Flags |= PSD_SHOWHELP;
}

INT_PTR CPageSetupDialog::DoModal()
{
	ASSERT_VALID(this);
	ASSERT(m_psd.Flags & PSD_ENABLEPAGESETUPHOOK);
	ASSERT(m_psd.Flags & PSD_ENABLEPAGEPAINTHOOK);
	ASSERT(m_psd.lpfnPageSetupHook != NULL); // can still be a user hook
	ASSERT(m_psd.lpfnPagePaintHook != NULL); // can still be a user hook

	m_psd.hwndOwner = PreModal();
	INT_PTR nResult = ::AfxCtxPageSetupDlg(&m_psd);
	PostModal();
	return nResult ? nResult : IDCANCEL;
}

////////////////////////////////////////////////////////////////////////////
// CPageSetupDialog attributes

LPDEVMODE CPageSetupDialog::GetDevMode() const
{
	if (m_psd.hDevMode == NULL)
		return NULL;

	return (LPDEVMODE)::GlobalLock(m_psd.hDevMode);
}

CString CPageSetupDialog::GetDriverName() const
{
	if (m_psd.hDevNames == NULL)
		return (LPCTSTR)NULL;

	LPDEVNAMES lpDev = (LPDEVNAMES)GlobalLock(m_psd.hDevNames);
	return (LPCTSTR)lpDev + lpDev->wDriverOffset;
}

CString CPageSetupDialog::GetDeviceName() const
{
	if (m_psd.hDevNames == NULL)
		return (LPCTSTR)NULL;

	LPDEVNAMES lpDev = (LPDEVNAMES)GlobalLock(m_psd.hDevNames);
	return (LPCTSTR)lpDev + lpDev->wDeviceOffset;
}

CString CPageSetupDialog::GetPortName() const
{
	if (m_psd.hDevNames == NULL)
		return (LPCTSTR)NULL;

	LPDEVNAMES lpDev = (LPDEVNAMES)GlobalLock(m_psd.hDevNames);
	return (LPCTSTR)lpDev + lpDev->wOutputOffset;
}

// Create an HDC from the devnames and devmode.
HDC CPageSetupDialog::CreatePrinterDC()
{
	ASSERT_VALID(this);
	return AfxCreateDC(m_psd.hDevNames, m_psd.hDevMode);
}

void CPageSetupDialog::GetMargins(LPRECT lpRectMargins, LPRECT lpRectMinMargins) const
{
	if (lpRectMargins != NULL)
	{
		Checked::memcpy_s(lpRectMargins, sizeof(RECT), 
			&m_psd.rtMargin, sizeof(RECT));
	}
	if (lpRectMinMargins != NULL)
	{
		Checked::memcpy_s(lpRectMinMargins, sizeof(RECT), 
			&m_psd.rtMinMargin, sizeof(RECT));
	}
}

////////////////////////////////////////////////////////////////////////////
// CPageSetupDialog diagnostics

#ifdef _DEBUG
void CPageSetupDialog::Dump(CDumpContext& dc) const
{
	CDialog::Dump(dc);

	dc << "m_psd.hwndOwner = " << m_psd.hwndOwner;
	dc << "\nm_psd.Flags = ";
	dc.DumpAsHex(m_psd.Flags);

	dc << "\nm_psd.ptPaperSize = " << m_psd.ptPaperSize;
	dc << "\nm_psd.rtMinMargin = " << m_psd.rtMinMargin;
	dc << "\nm_psd.rtMinMargin = " << m_psd.rtMinMargin;

	if (m_psd.lpfnPageSetupHook == (COMMDLGPROC)_AfxCommDlgProc)
		dc << "\nsetup hook function set to standard MFC hook function";
	else
		dc << "\nsetup hook function set to non-standard hook function";

	if (m_psd.lpfnPagePaintHook == (COMMDLGPROC)_AfxCommDlgProc)
		dc << "\nprint hook function set to standard MFC hook function";
	else
		dc << "\nprint hook function set to non-standard hook function";

	dc << "\n";
}
#endif //_DEBUG

////////////////////////////////////////////////////////////////////////////
// CPageSetupDialog hook

UINT CPageSetupDialog::PreDrawPage(WORD /*wPaperType*/, WORD /*wFlags*/,
	LPPAGESETUPDLG)
{
	return 0;
	//return 1 to prevent any more drawing
}

UINT CPageSetupDialog::OnDrawPage(CDC*, UINT /*nMessage*/, LPRECT)
{
	return 0; // do the default
}

UINT CALLBACK CPageSetupDialog::PaintHookProc(HWND hWnd, UINT message, WPARAM wParam,
	LPARAM lParam)
{
	if (hWnd == NULL)
		return 0;
	// Get our Window
	// assume it is already wired up to a permanent one
	// the hWnd is the HWND of a control in the page setup proc
	CPageSetupDialog* pDlg = DYNAMIC_DOWNCAST(CPageSetupDialog,
		CWnd::FromHandlePermanent(::GetParent(hWnd)));
	if (pDlg == NULL)
		return 0;
	switch (message)
	{
	case WM_PSD_PAGESETUPDLG:
		return pDlg->PreDrawPage(LOWORD(wParam), HIWORD(wParam),
			(LPPAGESETUPDLG) lParam);
		break;
	case WM_PSD_FULLPAGERECT:
	case WM_PSD_MINMARGINRECT:
	case WM_PSD_MARGINRECT:
	case WM_PSD_GREEKTEXTRECT:
	case WM_PSD_ENVSTAMPRECT:
	case WM_PSD_YAFULLPAGERECT:
		return pDlg->OnDrawPage(CDC::FromHandle((HDC)wParam), message, (LPRECT)lParam);
		break;
	}
	return 0;
}

/////////////////////////////////////////////////////////////////////////////
// Print/Print Setup dialog

BEGIN_MESSAGE_MAP(CPrintDialog, CCommonDialog)
	//{{AFX_MSG_MAP(CPrintDialog)
	ON_COMMAND(psh1, &CPrintDialog::OnPrintSetup) // print setup button when print is displayed
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CPrintDialog::CPrintDialog(BOOL bPrintSetupOnly,
	DWORD dwFlags, CWnd* pParentWnd)
	: m_pd(m_pdActual), CCommonDialog(pParentWnd)
{
	memset(&m_pdActual, 0, sizeof(m_pdActual));

	m_pd.lStructSize = sizeof(m_pdActual);
	m_pd.Flags = dwFlags | PD_ENABLEPRINTHOOK | PD_ENABLESETUPHOOK;
	if (AfxHelpEnabled())
		m_pd.Flags |= PD_SHOWHELP;
	m_pd.lpfnPrintHook = (COMMDLGPROC)_AfxCommDlgProc;
	m_pd.lpfnSetupHook = (COMMDLGPROC)_AfxCommDlgProc;

	if (bPrintSetupOnly)
	{
		m_nIDHelp = AFX_IDD_PRINTSETUP;
		m_pd.Flags |= PD_PRINTSETUP;
	}
	else
	{
		m_nIDHelp = AFX_IDD_PRINT;
		m_pd.Flags |= PD_RETURNDC;
	}

	m_pd.Flags &= ~PD_RETURNIC; // do not support information context
}

// Helper ctor for AttachOnSetup
CPrintDialog::CPrintDialog(PRINTDLG& pdInit)
	: m_pd(pdInit), CCommonDialog(NULL)
{
}

// Function to keep m_pd in sync after user invokes Setup from
// the print dialog (via the Setup button)
// If you decide to handle any messages/notifications and wish to
// handle them differently between Print/PrintSetup then override
// this function and create an object of a derived class
CPrintDialog* CPrintDialog::AttachOnSetup()
{
	ASSERT_VALID(this);

	CPrintDialog* pDlgSetup;

	pDlgSetup = new CPrintDialog(m_pd);
	pDlgSetup->m_hWnd = NULL;
	pDlgSetup->m_pParentWnd = m_pParentWnd;
	pDlgSetup->m_nIDHelp = AFX_IDD_PRINTSETUP;
	return pDlgSetup;
}

void CPrintDialog::OnPrintSetup()
{
	ASSERT_VALID(this);

	CPrintDialog* pDlgSetup = AttachOnSetup();
	ASSERT(pDlgSetup != NULL);

	AfxHookWindowCreate(pDlgSetup);
	Default();
	AfxUnhookWindowCreate();

	delete pDlgSetup;
}

INT_PTR CPrintDialog::DoModal()
{
	ASSERT_VALID(this);

	m_pd.hwndOwner = PreModal();
	INT_PTR nResult = ::AfxCtxPrintDlg(&m_pd);
	PostModal();
	return nResult ? nResult : IDCANCEL;
}

// Create an HDC without calling DoModal.
HDC CPrintDialog::CreatePrinterDC()
{
	ASSERT_VALID(this);
	m_pd.hDC = AfxCreateDC(m_pd.hDevNames, m_pd.hDevMode);
	return m_pd.hDC;
}

int CPrintDialog::GetCopies() const
{
	ASSERT_VALID(this);

	if (m_pd.Flags & PD_USEDEVMODECOPIES)
    {
        LPDEVMODE pDevMode=GetDevMode();
        ENSURE(pDevMode);
		return pDevMode->dmCopies;
    }
	else
    {
		return m_pd.nCopies;
    }
}

LPDEVMODE CPrintDialog::GetDevMode() const
{
	if (m_pd.hDevMode == NULL)
		return NULL;

	return (LPDEVMODE)::GlobalLock(m_pd.hDevMode);
}

CString CPrintDialog::GetDriverName() const
{
	if (m_pd.hDevNames == NULL)
		return (LPCTSTR)NULL;

	LPDEVNAMES lpDev = (LPDEVNAMES)GlobalLock(m_pd.hDevNames);

	// If this asserts it is because m_pd.hDevNames is no longer
	// valid.  This can occur if you call GetPrinterDeviceDefaults()
	// while in OnBeginPrinting().  Continuing will cause an
	// access violation.
	ASSERT(lpDev);

	return (LPCTSTR)lpDev + lpDev->wDriverOffset;
}

CString CPrintDialog::GetDeviceName() const
{
	if (m_pd.hDevNames == NULL)
		return (LPCTSTR)NULL;

	LPDEVNAMES lpDev = (LPDEVNAMES)GlobalLock(m_pd.hDevNames);

	// If this asserts it is because m_pd.hDevNames is no longer
	// valid.  This can occur if you call GetPrinterDeviceDefaults()
	// while in OnBeginPrinting().  Continuing will cause an
	// access violation.
	ASSERT(lpDev);

	return (LPCTSTR)lpDev + lpDev->wDeviceOffset;
}

CString CPrintDialog::GetPortName() const
{
	if (m_pd.hDevNames == NULL)
		return (LPCTSTR)NULL;

	LPDEVNAMES lpDev = (LPDEVNAMES)GlobalLock(m_pd.hDevNames);

	// If this asserts it is because m_pd.hDevNames is no longer
	// valid.  This can occur if you call GetPrinterDeviceDefaults()
	// while in OnBeginPrinting().  Continuing will cause an
	// access violation.
	ASSERT(lpDev);

	return (LPCTSTR)lpDev + lpDev->wOutputOffset;
}

// this function must not be in afxdlgs.inl because of DLL delay loading
BOOL CPrintDialog::GetDefaults()
{
	m_pd.Flags |= PD_RETURNDEFAULT;
	return ::AfxCtxPrintDlg(&m_pd);
}

////////////////////////////////////////////////////////////////////////////
// CPrintDialog diagnostics

#ifdef _DEBUG
void CPrintDialog::Dump(CDumpContext& dc) const
{
	CDialog::Dump(dc);

	dc << "m_pd.hwndOwner = " << m_pd.hwndOwner;

	if (m_pd.hDC != NULL)
		dc << "\nm_pd.hDC = " << CDC::FromHandle(m_pd.hDC);

	dc << "\nm_pd.Flags = ";
	dc.DumpAsHex(m_pd.Flags);
	dc << "\nm_pd.nFromPage = " << m_pd.nFromPage;
	dc << "\nm_pd.nToPage = " << m_pd.nToPage;
	dc << "\nm_pd.nMinPage = " << m_pd.nMinPage;
	dc << "\nm_pd.nMaxPage = " << m_pd.nMaxPage;
	dc << "\nm_pd.nCopies = " << m_pd.nCopies;

	if (m_pd.lpfnSetupHook == (COMMDLGPROC)_AfxCommDlgProc)
		dc << "\nsetup hook function set to standard MFC hook function";
	else
		dc << "\nsetup hook function set to non-standard hook function";

	if (m_pd.lpfnPrintHook == (COMMDLGPROC)_AfxCommDlgProc)
		dc << "\nprint hook function set to standard MFC hook function";
	else
		dc << "\nprint hook function set to non-standard hook function";

	dc << "\n";
}
#endif //_DEBUG

////////////////////////////////////////////////////////////////////////////
// AfxCreateDC

HDC AFXAPI AfxCreateDC(HGLOBAL hDevNames, HGLOBAL hDevMode)
{
	if (hDevNames == NULL)
		return NULL;

	LPDEVNAMES lpDevNames = (LPDEVNAMES)::GlobalLock(hDevNames);
	LPDEVMODE  lpDevMode = (hDevMode != NULL) ?
						(LPDEVMODE)::GlobalLock(hDevMode) : NULL;

	if (lpDevNames == NULL)
		return NULL;

	HDC hDC = ::CreateDC((LPCTSTR)lpDevNames + lpDevNames->wDriverOffset,
					  (LPCTSTR)lpDevNames + lpDevNames->wDeviceOffset,
					  (LPCTSTR)lpDevNames + lpDevNames->wOutputOffset,
					  lpDevMode);

	::GlobalUnlock(hDevNames);
	if (hDevMode != NULL)
		::GlobalUnlock(hDevMode);
	return hDC;
}


IMPLEMENT_DYNAMIC(CPrintDialog, CCommonDialog)
IMPLEMENT_DYNAMIC(CPageSetupDialog, CCommonDialog)

////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\dlgprntx.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include <dlgs.h>       // for standard control IDs for commdlg



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// Windows 2000 Print dialog

#include "initguid.h"
#define INITGUID

DEFINE_GUID(IID_IPrintDialogCallback, 0x5852a2c3, 0x6530, 0x11d1, 0xb6, 0xa3, 0x0, 0x0, 0xf8, 0x75, 0x7b, 0xf9);
DEFINE_GUID(IID_IPrintDialogServices, 0x509aaeda, 0x5639, 0x11d1, 0xb6, 0xa1, 0x0, 0x0, 0xf8, 0x75, 0x7b, 0xf9);

BEGIN_MESSAGE_MAP(CPrintDialogEx, CCommonDialog)
	//{{AFX_MSG_MAP(CPrintDialogEx)
	ON_MESSAGE(WM_INITDIALOG, &CPrintDialogEx::HandleInitDialog)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CPrintDialogEx::CPrintDialogEx(DWORD dwFlags, CWnd* pParentWnd)
	: m_pUnkSite(NULL), CCommonDialog(pParentWnd)
{
	memset(&m_pdex, 0, sizeof(m_pdex));

	m_pdex.lStructSize = sizeof(m_pdex);
	m_pdex.Flags = dwFlags;
	m_pdex.nStartPage = START_PAGE_GENERAL;

	m_pdex.Flags &= ~PD_RETURNIC; // do not support information context
}

INT_PTR CPrintDialogEx::DoModal()
{
	ASSERT_VALID(this);

	m_pdex.hwndOwner = PreModal();
	ASSERT(m_pdex.lpCallback == NULL);
	m_pdex.lpCallback = (IUnknown*)(IPrintDialogCallback*)this;
	INT_PTR nResult = ::AfxCtxPrintDlgEx(&m_pdex);
	PostModal();
	return nResult;
}

// Create an HDC without calling DoModal.
HDC CPrintDialogEx::CreatePrinterDC()
{
	ASSERT_VALID(this);
	m_pdex.hDC = AfxCreateDC(m_pdex.hDevNames, m_pdex.hDevMode);
	return m_pdex.hDC;
}

int CPrintDialogEx::GetCopies() const
{
	ASSERT_VALID(this);

	if (m_pdex.Flags & PD_USEDEVMODECOPIES)
    {
        LPDEVMODE pDevMode=GetDevMode();
        ENSURE(pDevMode);
		return pDevMode->dmCopies;
    }
	else
    {
		return m_pdex.nCopies;
    }
}

LPDEVMODE CPrintDialogEx::GetDevMode() const
{
	if (m_pdex.hDevMode == NULL)
		return NULL;

	return (LPDEVMODE)::GlobalLock(m_pdex.hDevMode);
}

CString CPrintDialogEx::GetDriverName() const
{
	if (m_pdex.hDevNames == NULL)
		return (LPCTSTR)NULL;

	LPDEVNAMES lpDev = (LPDEVNAMES)GlobalLock(m_pdex.hDevNames);
	return (LPCTSTR)lpDev + lpDev->wDriverOffset;
}

CString CPrintDialogEx::GetDeviceName() const
{
	if (m_pdex.hDevNames == NULL)
		return (LPCTSTR)NULL;

	LPDEVNAMES lpDev = (LPDEVNAMES)GlobalLock(m_pdex.hDevNames);
	return (LPCTSTR)lpDev + lpDev->wDeviceOffset;
}

CString CPrintDialogEx::GetPortName() const
{
	if (m_pdex.hDevNames == NULL)
		return (LPCTSTR)NULL;

	LPDEVNAMES lpDev = (LPDEVNAMES)GlobalLock(m_pdex.hDevNames);
	return (LPCTSTR)lpDev + lpDev->wOutputOffset;
}

// this function must not be in afxdlgs.inl because of DLL delay loading
BOOL CPrintDialogEx::GetDefaults()
{
	m_pdex.Flags |= PD_RETURNDEFAULT;
	if (m_hWnd == NULL)
	{
		// set a reasonable parent HWND so the call can succeed
		m_pdex.hwndOwner = CWnd::GetSafeOwner_(m_pParentWnd->GetSafeHwnd(), &m_hWndTop);
	}

	return SUCCEEDED(::AfxCtxPrintDlgEx(&m_pdex));
}

////////////////////////////////////////////////////////////////////////////
// CPrintDialogEx interfaces

// IUnknown
HRESULT CPrintDialogEx::QueryInterface(REFIID riid, void** ppvObject)
{
	if(ppvObject == NULL)
		return E_POINTER;

	if(InlineIsEqualUnknown(riid) || InlineIsEqualGUID(riid, IID_IPrintDialogCallback))
	{
		*ppvObject = (IPrintDialogCallback*)this;
//		AddRef();
		return S_OK;
	}
	else if(InlineIsEqualGUID(riid, IID_IObjectWithSite))
	{
		*ppvObject = (IObjectWithSite*)this;
//		AddRef();
		return S_OK;
	}

	return E_NOINTERFACE;
}

ULONG CPrintDialogEx::AddRef()
{
	return 1;
}

ULONG CPrintDialogEx::Release()
{
	return 1;
}

// IPrintDialogCallback
HRESULT CPrintDialogEx::InitDone()
{
	return S_FALSE;
}

HRESULT CPrintDialogEx::SelectionChange()
{
	return S_FALSE;
}

HRESULT CPrintDialogEx::HandleMessage(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam, LRESULT* plResult)
{
	// set up m_hWnd the first time
	if(m_hWnd == NULL)
		Attach(hWnd);

	// we need to set this, because the message comes from the another loop
	_AFX_THREAD_STATE* pThreadState = _afxThreadState.GetData();
	pThreadState->m_lastSentMsg.hwnd = hWnd;
	pThreadState->m_lastSentMsg.message = message;
	pThreadState->m_lastSentMsg.wParam = wParam;
	pThreadState->m_lastSentMsg.lParam = lParam;
	pThreadState->m_lastSentMsg.time = ::GetMessageTime();
	pThreadState->m_lastSentMsg.pt = CPoint(::GetMessagePos());

	// call message map
	HRESULT hRet = OnWndMsg(message, wParam, lParam, plResult) ? S_OK : S_FALSE;

	// special case handling
	if(hRet == S_OK && message == WM_NOTIFY)	// return in DWL_MSGRESULT
		::SetWindowLongPtr(::GetParent(hWnd), DWLP_MSGRESULT, (LONG_PTR)*plResult);

	if(message == WM_INITDIALOG && hRet == S_OK && (BOOL)*plResult != FALSE)
		hRet = S_FALSE;

	return hRet;
}

// IObjectWithSite
HRESULT CPrintDialogEx::SetSite(IUnknown *pUnkSite)
{
	if (m_pUnkSite != NULL)
		m_pUnkSite->Release();
	m_pUnkSite = pUnkSite;
	if (m_pUnkSite != NULL)
		m_pUnkSite->AddRef();
	return S_OK;
}

HRESULT CPrintDialogEx::GetSite(REFIID riid, void **ppvSite)
{
	HRESULT hRes = E_POINTER;
	if (ppvSite != NULL)
	{
		if (m_pUnkSite != NULL)
		{
			hRes = m_pUnkSite->QueryInterface(riid, ppvSite);
		}
		else
		{
			*ppvSite = NULL;
			hRes = E_FAIL;
		}
	}
	return hRes;
}

////////////////////////////////////////////////////////////////////////////
// CPrintDialogEx implementation (overrides)

HWND CPrintDialogEx::PreModal()
{
	// cannot call DoModal on a dialog already constructed as modeless
	ASSERT(m_hWnd == NULL);

	// allow OLE servers to disable themselves
	CWinApp* pApp = AfxGetApp();
	if (pApp != NULL)
		pApp->EnableModeless(FALSE);

	// find parent HWND
	HWND hWnd = CWnd::GetSafeOwner_(m_pParentWnd->GetSafeHwnd(), &m_hWndTop);

	// return window to use as parent for dialog
	return hWnd;
}

void CPrintDialogEx::PostModal()
{
	Detach();               // just in case

	// re-enable windows
	if (::IsWindow(m_hWndTop))
		::EnableWindow(m_hWndTop, TRUE);
	m_hWndTop = NULL;
	CWinApp* pApp = AfxGetApp();
	if (pApp != NULL)
		pApp->EnableModeless(TRUE);
}

LRESULT CPrintDialogEx::DefWindowProc(UINT /*nMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/)
{
	// does nothing, this is a dialog
	return 0;
}

LRESULT CPrintDialogEx::HandleInitDialog(WPARAM /*wParam*/, LPARAM /*lParam*/)
{
	PreInitDialog();

#ifndef _AFX_NO_OCC_SUPPORT
	// create OLE controls
	COccManager* pOccManager = afxOccManager;
	if ((pOccManager != NULL) && (m_pOccDialogInfo != NULL))
	{
		BOOL bDlgInit;
		if (m_lpDialogInit != NULL)
			bDlgInit = pOccManager->CreateDlgControls(this, m_lpDialogInit,
				m_pOccDialogInfo);
		else
			bDlgInit = pOccManager->CreateDlgControls(this, m_lpszTemplateName,
				m_pOccDialogInfo);

		if (!bDlgInit)
		{
			TRACE(traceAppMsg, 0, "Warning: CreateDlgControls failed during dialog init.\n");
			EndDialog(-1);
			return FALSE;
		}
	}
#endif

	// Call OnInitDialog
	BOOL bResult = OnInitDialog();


#ifndef _AFX_NO_OCC_SUPPORT
	if (bResult && (m_nFlags & WF_OLECTLCONTAINER))
	{
		CWnd* pWndNext = GetNextDlgTabItem(NULL);
		if (pWndNext != NULL)
		{
			pWndNext->SetFocus();   // UI Activate OLE control
			bResult = FALSE;
		}
	}
#endif

	return bResult;
}

////////////////////////////////////////////////////////////////////////////
// CPrintDialogEx diagnostics

#ifdef _DEBUG
void CPrintDialogEx::Dump(CDumpContext& dc) const
{
	CDialog::Dump(dc);

	dc << "m_pdex.hwndOwner = " << m_pdex.hwndOwner;

	if (m_pdex.hDC != NULL)
		dc << "\nm_pdex.hDC = " << CDC::FromHandle(m_pdex.hDC);

	dc << "\nm_pdex.Flags = ";
	dc.DumpAsHex(m_pdex.Flags);
	dc << "\nm_pdex.nMinPage = " << m_pdex.nMinPage;
	dc << "\nm_pdex.nMaxPage = " << m_pdex.nMaxPage;
	dc << "\nm_pdex.nCopies = " << m_pdex.nCopies;

	dc << "\n";
}
#endif //_DEBUG

IMPLEMENT_DYNAMIC(CPrintDialogEx, CCommonDialog)

////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\dllinit.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include <stdarg.h>
#include "atlbuild.h"
#include "sal.h"



#ifndef _AFXDLL
	#error file must be compiled with _AFXDLL
#endif

/////////////////////////////////////////////////////////////////////////////
// _AFXDLL support

static AFX_EXTENSION_MODULE coreDLL;
#ifdef _AFX_OLE_IMPL
AFX_MODULE_STATE* AFXAPI _AfxGetOleModuleState();
#endif

/////////////////////////////////////////////////////////////////////////////
// CDynLinkLibrary class

IMPLEMENT_DYNAMIC(CDynLinkLibrary, CCmdTarget)

// Constructor - will wire into the current application's list
CDynLinkLibrary::CDynLinkLibrary(AFX_EXTENSION_MODULE& state, BOOL bSystem)
{
#ifndef _AFX_NO_OLE_SUPPORT
	m_factoryList.Construct(offsetof(COleObjectFactory, m_pNextFactory));
#endif
	m_classList.Construct(offsetof(CRuntimeClass, m_pNextClass));

	// copy info from AFX_EXTENSION_MODULE struct
	ASSERT(state.hModule != NULL);
	m_hModule = state.hModule;
	m_hResource = state.hResource;
	m_classList.m_pHead = state.pFirstSharedClass;
#ifndef _AFX_NO_OLE_SUPPORT
	m_factoryList.m_pHead = state.pFirstSharedFactory;
#endif
	m_bSystem = bSystem;

	// insert at the head of the list (extensions will go in front of core DLL)
	DEBUG_ONLY(m_pNextDLL = NULL);
	AfxLockGlobals(CRIT_DYNLINKLIST);
	m_pModuleState->m_libraryList.AddHead(this);
	AfxUnlockGlobals(CRIT_DYNLINKLIST);
}

CDynLinkLibrary::CDynLinkLibrary(HINSTANCE hModule, HINSTANCE hResource)
{
#ifndef _AFX_NO_OLE_SUPPORT
	m_factoryList.Construct(offsetof(COleObjectFactory, m_pNextFactory));
#endif
	m_classList.Construct(offsetof(CRuntimeClass, m_pNextClass));

	m_hModule = hModule;
	m_hResource = hResource;
	m_classList.m_pHead = NULL;
#ifndef _AFX_NO_OLE_SUPPORT
	m_factoryList.m_pHead = NULL;
#endif
	m_bSystem = FALSE;

	// insert at the head of the list (extensions will go in front of core DLL)
	DEBUG_ONLY(m_pNextDLL = NULL);
	AfxLockGlobals(CRIT_DYNLINKLIST);
	m_pModuleState->m_libraryList.AddHead(this);
	AfxUnlockGlobals(CRIT_DYNLINKLIST);
}


CDynLinkLibrary::~CDynLinkLibrary()
{
	// remove this frame window from the list of frame windows
	AfxLockGlobals(CRIT_DYNLINKLIST);
	m_pModuleState->m_libraryList.Remove(this);
	AfxUnlockGlobals(CRIT_DYNLINKLIST);
}

/////////////////////////////////////////////////////////////////////////////
// CDynLinkLibrary diagnostics

#ifdef _DEBUG
void CDynLinkLibrary::AssertValid() const
{
	ASSERT(m_hModule != NULL);
}

void CDynLinkLibrary::Dump(CDumpContext& dc) const
{
	CCmdTarget::Dump(dc);

	dc << "m_hModule = " << (UINT_PTR)m_hModule;
	dc << "\nm_hResource = " << (UINT_PTR)m_hResource;

	if (m_hModule != NULL)
	{
		TCHAR szName[_MAX_PATH];
		GetModuleFileName(m_hModule, szName, _countof(szName));
		dc << "\nmodule name = " << szName;
	}
	else
		dc << "\nmodule name is unknown";

	dc << "\n";
}
#endif //_DEBUG


/////////////////////////////////////////////////////////////////////////////
// special initialization and helper functions

// This is called in an extension DLL's DllMain
//  It makes a copy of the DLL's HMODULE, as well as a copy of the
//  runtime class objects that have been initialized by this
//  extension DLL as part of normal static object construction
//  executed before DllMain is entered.

BOOL AFXAPI AfxInitExtensionModule(AFX_EXTENSION_MODULE& state, HMODULE hModule)
{
	// only initialize once
	if (state.bInitialized)
	{
		AfxInitLocalData(hModule);
		return TRUE;
	}
	state.bInitialized = TRUE;

	// save the current HMODULE information for resource loading
	ASSERT(hModule != NULL);
	state.hModule = hModule;
	state.hResource = hModule;

	// save the start of the runtime class list
	AFX_MODULE_STATE* pModuleState = AfxGetModuleState();
	state.pFirstSharedClass = pModuleState->m_classList.GetHead();
	pModuleState->m_classList.m_pHead = pModuleState->m_pClassInit;

#ifndef _AFX_NO_OLE_SUPPORT
	// save the start of the class factory list
	state.pFirstSharedFactory = pModuleState->m_factoryList.GetHead();
	pModuleState->m_factoryList.m_pHead = pModuleState->m_pFactoryInit;
#endif

	return TRUE;
}


void AFXAPI AfxTermExtensionModule(AFX_EXTENSION_MODULE& state, BOOL bAll)
{
	// make sure initialized
	if (!state.bInitialized)
		return;

	// search for CDynLinkLibrary matching state.hModule and delete it
	ASSERT(state.hModule != NULL);
	AFX_MODULE_STATE* pModuleState = AfxGetModuleState();
	AfxLockGlobals(CRIT_DYNLINKLIST);
	for (CDynLinkLibrary* pDLL = pModuleState->m_libraryList; pDLL != NULL; )
	{
		CDynLinkLibrary* pNextDLL = pDLL->m_pNextDLL;
		if (bAll || pDLL->m_hModule == state.hModule)
			delete pDLL;    // will unwire itself
		pDLL = pNextDLL;
	}
	AfxUnlockGlobals(CRIT_DYNLINKLIST);

	// delete any local storage attached to this module
	AfxTermLocalData(state.hModule, TRUE);

	// remove any entries from the CWnd message map cache
	AfxResetMsgCache();
}

/////////////////////////////////////////////////////////////////////////////
// special LoadLibrary and FreeLibrary for loading MFC extension DLLs

HINSTANCE AFXAPI AfxLoadLibrary(LPCTSTR lpszModuleName)
{
	ASSERT(lpszModuleName != NULL);
	AfxLockGlobals(CRIT_LOCKSHARED);
 	HINSTANCE hInstLib = AfxCtxLoadLibrary(lpszModuleName);
	AfxUnlockGlobals(CRIT_LOCKSHARED);
	return hInstLib;
}

 
 
HINSTANCE AFXAPI AfxLoadLibraryEx(LPCTSTR lpFileName,  HANDLE hFile,  DWORD dwFlags)
{  
		
	ASSERT(lpFileName != NULL);
	AfxLockGlobals(CRIT_LOCKSHARED);
	HINSTANCE hInstLib = AfxCtxLoadLibraryEx(lpFileName,hFile,dwFlags);
	AfxUnlockGlobals(CRIT_LOCKSHARED);
	return hInstLib;
}
 

BOOL AFXAPI AfxFreeLibrary(HINSTANCE hInstLib)
{
	AfxLockGlobals(CRIT_LOCKSHARED);
	BOOL bResult = FreeLibrary(hInstLib);
	AfxUnlockGlobals(CRIT_LOCKSHARED);
	return bResult;
}

/////////////////////////////////////////////////////////////////////////////
// Resource helpers


ULONG AFXAPI AfxGetDllVersion()
{
	return( _LIBS_BUILD );
}

HINSTANCE AFXAPI AfxFindResourceHandle(LPCTSTR lpszName, LPCTSTR lpszType)
{
	ASSERT(lpszName != NULL);
	ASSERT(lpszType != NULL);

	HINSTANCE hInst;

	// first check the main module state
	AFX_MODULE_STATE* pModuleState = AfxGetModuleState();
	if (!pModuleState->m_bSystem)
	{
		hInst = AfxGetResourceHandle();
		if (::FindResource(hInst, lpszName, lpszType) != NULL)
			return hInst;
	}

	// check for non-system DLLs in proper order
	AfxLockGlobals(CRIT_DYNLINKLIST);
	CDynLinkLibrary* pDLL;
	for (pDLL = pModuleState->m_libraryList; pDLL != NULL;
		pDLL = pDLL->m_pNextDLL)
	{
		if (!pDLL->m_bSystem && pDLL->m_hResource != NULL &&
			::FindResource(pDLL->m_hResource, lpszName, lpszType) != NULL)
		{
			// found it in a DLL
			AfxUnlockGlobals(CRIT_DYNLINKLIST);
			return pDLL->m_hResource;
		}
	}
	AfxUnlockGlobals(CRIT_DYNLINKLIST);

	// check language specific resource next
	hInst = pModuleState->m_appLangDLL;
	if (hInst != NULL && ::FindResource(hInst, lpszName, lpszType) != NULL)
		return hInst;

	// check the main system module state
	if (pModuleState->m_bSystem)
	{
		hInst = AfxGetResourceHandle();
		if (::FindResource(hInst, lpszName, lpszType) != NULL)
			return hInst;
	}

	// check for system DLLs in proper order
	AfxLockGlobals(CRIT_DYNLINKLIST);
	for (pDLL = pModuleState->m_libraryList; pDLL != NULL; pDLL = pDLL->m_pNextDLL)
	{
		if (pDLL->m_bSystem && pDLL->m_hResource != NULL &&
			::FindResource(pDLL->m_hResource, lpszName, lpszType) != NULL)
		{
			// found it in a DLL
			AfxUnlockGlobals(CRIT_DYNLINKLIST);
			return pDLL->m_hResource;
		}
	}
	AfxUnlockGlobals(CRIT_DYNLINKLIST);

	// if failed to find resource, return application resource
	return AfxGetResourceHandle();
}

HINSTANCE AFXAPI AfxFindStringResourceHandle(UINT nID)
{
	HINSTANCE hInst;

	// first check the main module state
	AFX_MODULE_STATE* pModuleState = AfxGetModuleState();
	if (!pModuleState->m_bSystem)
	{
		hInst = AfxGetResourceHandle();
		if (AtlGetStringResourceImage(hInst, nID) != NULL)
		{
			// found a non-zero string in app
			return hInst;
		}
	}

	// check non-system DLLs in proper order
	AfxLockGlobals(CRIT_DYNLINKLIST);
	CDynLinkLibrary* pDLL;
	for (pDLL = pModuleState->m_libraryList; pDLL != NULL;
		pDLL = pDLL->m_pNextDLL)
	{
		if (!pDLL->m_bSystem && (hInst = pDLL->m_hResource) != NULL &&
		  (AtlGetStringResourceImage(hInst, nID) != NULL))
		{
			AfxUnlockGlobals(CRIT_DYNLINKLIST);
			return hInst;
		}
	}
	AfxUnlockGlobals(CRIT_DYNLINKLIST);

	// check language specific DLL next
	hInst = pModuleState->m_appLangDLL;
	if (hInst != NULL && (AtlGetStringResourceImage(hInst, nID) != NULL))
	{
		// found a non-zero string in language DLL
		return hInst;
	}

	// check the system module state
	if (pModuleState->m_bSystem)
	{
		hInst = AfxGetResourceHandle();
		if (AtlGetStringResourceImage(hInst, nID) != NULL)
		{
			// found a non-zero string in app
			return hInst;
		}
	}

	// check system DLLs in proper order
	AfxLockGlobals(CRIT_DYNLINKLIST);
	for (pDLL = pModuleState->m_libraryList; pDLL != NULL; pDLL = pDLL->m_pNextDLL)
	{
		if (pDLL->m_bSystem && (hInst = pDLL->m_hResource) != NULL &&
		  (AtlGetStringResourceImage(hInst, nID) != NULL))
		{
			AfxUnlockGlobals(CRIT_DYNLINKLIST);
			return hInst;
		}
	}
	AfxUnlockGlobals(CRIT_DYNLINKLIST);

	// did not find it
	return NULL;
}

// AfxLoadString must not only check for the appropriate string segment
//   in the resource file, but also that the string is non-zero
int AFXAPI AfxLoadString(_In_ UINT nID, _Out_z_cap_post_count_(nMaxBuf, return + 1) LPWSTR lpszBuf, _In_ UINT nMaxBuf)
{
	ASSERT(AfxIsValidAddress(lpszBuf, nMaxBuf*sizeof(WCHAR)));
	if( lpszBuf == NULL || nMaxBuf == 0)
		AfxThrowInvalidArgException();

	HINSTANCE hInst;
	const ATLSTRINGRESOURCEIMAGE* pImage;
	int nCharsToCopy;

	hInst = AfxFindStringResourceHandle(nID);
	if (hInst == NULL)
	{
		lpszBuf[0] = L'\0';
		return 0;
	}

	pImage = AtlGetStringResourceImage(hInst, nID);
	ASSERT(pImage != NULL);
	ASSERT(pImage->nLength != 0);
	nCharsToCopy = min(nMaxBuf-1, pImage->nLength);
	Checked::memcpy_s(lpszBuf, (nMaxBuf-1)*sizeof(WCHAR), 
		pImage->achString, nCharsToCopy*sizeof(WCHAR));
	lpszBuf[nCharsToCopy] = L'\0';

	return nCharsToCopy;
}

int AFXAPI AfxLoadString(_In_ UINT nID, _Out_z_cap_post_count_(nMaxBuf, return + 1) LPSTR lpszBuf, _In_ UINT nMaxBuf)
{
	ASSERT(AfxIsValidAddress(lpszBuf, nMaxBuf*sizeof(CHAR)));
	if( lpszBuf == NULL || nMaxBuf == 0)
		AfxThrowInvalidArgException();

	HINSTANCE hInst;
	const ATLSTRINGRESOURCEIMAGE* pImage;
	int nBytes;

	hInst = AfxFindStringResourceHandle(nID);
	if (hInst == NULL)
	{
		lpszBuf[0] = L'\0';
		return 0;
	}

	pImage = AtlGetStringResourceImage(hInst, nID);
	ENSURE(pImage != NULL);
	ENSURE(pImage->nLength != 0);
	nBytes = ::WideCharToMultiByte(CP_ACP, 0, pImage->achString, pImage->nLength, lpszBuf, nMaxBuf-1, NULL, NULL);
	lpszBuf[nBytes] = '\0';

	return nBytes;
}

/////////////////////////////////////////////////////////////////////////////
// Library initialization and cleanup


extern "C" BOOL WINAPI RawDllMain(HINSTANCE, DWORD dwReason, LPVOID);
extern "C" BOOL (WINAPI * const _pRawDllMain)(HINSTANCE , DWORD , LPVOID) = &RawDllMain;

extern "C"
BOOL WINAPI RawDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID)
{
	hInstance;
	try
	{
		if (dwReason == DLL_PROCESS_ATTACH)
		{
			SetErrorMode(SetErrorMode(0) |
				SEM_FAILCRITICALERRORS|SEM_NOOPENFILEERRORBOX);

			// add a reference to thread local storage data
			AfxTlsAddRef();

			// make sure we have enough memory to attempt to start (8kb)
			void* pMinHeap = LocalAlloc(NONZEROLPTR, 0x2000);
			if (pMinHeap == NULL)
				return FALSE;   // fail if memory alloc fails
			LocalFree(pMinHeap);

			// cause early initialization of _afxCriticalSection
			if (!AfxCriticalInit())
				return FALSE;

#ifdef _AFX_OLE_IMPL
			// set module state before initialization
			AFX_MODULE_STATE* pModuleState = _AfxGetOleModuleState();
			_AFX_THREAD_STATE* pState = AfxGetThreadState();
			pState->m_pPrevModuleState = AfxSetModuleState(pModuleState);
#endif
		}
		else if (dwReason == DLL_PROCESS_DETACH)
		{
#ifdef _AFX_OLE_IMPL
			_AFX_THREAD_STATE* pThreadState = _afxThreadState.GetDataNA();
			if (pThreadState != NULL)
			{
				// restore previously-saved module state
				VERIFY(AfxSetModuleState(pThreadState->m_pPrevModuleState) ==
					_AfxGetOleModuleState());
				DEBUG_ONLY(pThreadState->m_pPrevModuleState = NULL);
			}
#endif

			// free up the _afxCriticalSection
			AfxCriticalTerm();

			// remove reference from thread local data
			AfxTlsRelease();
		}
	}
	catch( CException* e )
	{
		e->Delete();
		return FALSE;
	}
	
	return TRUE;    // ok
}

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID)
{
	try
	{
		if (dwReason == DLL_PROCESS_ATTACH)
		{

#ifdef _AFX_OLE_IMPL
			BOOL bRegister = !coreDLL.bInitialized;

			// shared initialization
			AFX_MODULE_STATE* pModuleState = _AfxGetOleModuleState();
			pModuleState->m_hCurrentInstanceHandle = hInstance;
			pModuleState->m_hCurrentResourceHandle = hInstance;
			pModuleState->m_pClassInit = pModuleState->m_classList.GetHead();
			pModuleState->m_pFactoryInit = pModuleState->m_factoryList.GetHead();
#endif

			// initialize this DLL's extension module
			VERIFY(AfxInitExtensionModule(coreDLL, hInstance));

#ifdef _AFX_OLE_IMPL
			AfxWinInit(hInstance, NULL, _T(""), 0);

			// Register class factories in context of private module state
			if (bRegister)
				COleObjectFactory::RegisterAll();
#endif

#ifdef _AFX_OLE_IMPL
			// restore previously-saved module state
			VERIFY(AfxSetModuleState(AfxGetThreadState()->m_pPrevModuleState) ==
				_AfxGetOleModuleState());
			DEBUG_ONLY(AfxGetThreadState()->m_pPrevModuleState = NULL);
#endif

			// wire up this DLL into the resource chain
			CDynLinkLibrary* pDLL = new CDynLinkLibrary(coreDLL, TRUE);
			ASSERT(pDLL != NULL);
			pDLL->m_factoryList.m_pHead = NULL;

			HINSTANCE hLangDLL = AfxLoadLangResourceDLL(_T("%s") _T("MFC") _T(_MFC_FILENAME_VER) _T("%s.DLL"), _T(""));

			AFX_MODULE_STATE* pState = AfxGetModuleState();
			pState->m_appLangDLL = hLangDLL;

#ifdef _AFX_OLE_IMPL
			// copy it to the private OLE state too
			pModuleState->m_appLangDLL = hLangDLL;
#endif
		}
		else if (dwReason == DLL_PROCESS_DETACH)
		{
			// free language specific DLL
			AFX_MODULE_STATE* pState = AfxGetModuleState();
			if (pState->m_appLangDLL != NULL)
			{
				::FreeLibrary(pState->m_appLangDLL);
				pState->m_appLangDLL = NULL;
			}

			// free the DLL info blocks
			CDynLinkLibrary* pDLL;
			while ((pDLL = pState->m_libraryList) != NULL)
				delete pDLL;
			ASSERT(pState->m_libraryList.IsEmpty());

			// cleanup module state for this process
			AfxTermExtensionModule(coreDLL);

#ifdef _AFX_OLE_IMPL
			// set module state for cleanup
			ASSERT(AfxGetThreadState()->m_pPrevModuleState == NULL);
			AfxGetThreadState()->m_pPrevModuleState =
				AfxSetModuleState(_AfxGetOleModuleState());
#endif

			// cleanup module state in OLE private module state
			AfxTermExtensionModule(coreDLL, TRUE);

			// free any local data for this process/thread
			AfxTermLocalData(NULL, TRUE);
		}
		else if (dwReason == DLL_THREAD_DETACH)
		{
			AfxTermThread();
		}
	}
	catch( CException* e )
	{
		if(e)
		{	
			e->Delete();
		}
		return FALSE;
	}

	return TRUE;    // ok
}

////////////////////////////////////////////////////////////////////////////
// Special initialization entry point for controls

void AFXAPI AfxCoreInitModule()
{
	ASSERT(AfxGetModuleState() != AfxGetAppModuleState());

	// construct new dynlink library in this context for core resources
	CDynLinkLibrary* pDLL = new CDynLinkLibrary(coreDLL, TRUE);
	ASSERT(pDLL != NULL);
	pDLL->m_factoryList.m_pHead = NULL;

	// borrow resources from language specific DLL if loaded
	AFX_MODULE_STATE* pModuleState = AfxGetModuleState();
	AFX_MODULE_STATE* pAppState = AfxGetAppModuleState();
	if (pModuleState->m_appLangDLL == NULL)
		pModuleState->m_appLangDLL = pAppState->m_appLangDLL;
}

#ifdef _AFX_OLE_IMPL
// This CWinApp is required so this module state has a CWinApp object!
CWinApp _afxOleWinApp;

/////////////////////////////////////////////////////////////////////////////
// static-linked version of AfxWndProc for use by this module

#undef AfxWndProc

LRESULT CALLBACK
AfxWndProcDllOle(HWND hWnd, UINT nMsg, WPARAM wParam, LPARAM lParam)
{
	AFX_MANAGE_STATE(_AfxGetOleModuleState());
	return AfxWndProc(hWnd, nMsg, wParam, lParam);
}

/////////////////////////////////////////////////////////////////////////////

// force initialization early
#pragma warning(disable: 4074)
#pragma init_seg(lib)

static AFX_MODULE_STATE _afxOleModuleState(TRUE, &AfxWndProcDllOle,
	_MFC_VER, TRUE);

AFX_MODULE_STATE* AFXAPI _AfxGetOleModuleState()
{
	return &_afxOleModuleState;
}
#endif

/////////////////////////////////////////////////////////////////////////////
// Special code to wire up vector deleting destructors

static void _AfxForceVectorDelete()
{
#ifdef _DEBUG
	ASSERT(FALSE);  // never called
#endif

	new CBitmap[2];
	new CBitmapButton[2];
	new CBrush[2];
	new CButton[2];
	new CByteArray[2];
	new CComboBox[2];
	new CDC[2];
	new CDWordArray[2];
	new CDialog[2];
	new CDialogBar[2];
	new CEdit[2];
	new CFile[2];
	new CFont[2];
	new CFrameWnd[2];
	new CGdiObject[2];
	new CListBox[2];
	new CCheckListBox[2];
	new CMapPtrToPtr[2];
	new CMapPtrToWord[2];
	new CMapStringToOb[2];
	new CMapStringToPtr[2];
	new CMapStringToString[2];
	new CMapWordToOb[2];
	new CMapWordToPtr[2];
	new CMemFile[2];
	new CMenu[2];
	new CMetaFileDC[2];
	new CObArray[2];
	new CObList[2];
	new CPalette[2];
	new CPen[2];
	new CPtrArray[2];
	new CPtrList[2];
	new CRectTracker[2];
	new CRgn[2];
	new CScrollBar[2];
	new CSharedFile[2];
	new CSplitterWnd[2];
	new CStatic[2];
	new CStatusBar[2];
	new CStdioFile[2];
	new CString[2];
	new CStringArray[2];
	new CStringList[2];
	new CThreadSlotData[2];
	new CTime[2];
	new CTimeSpan[2];
	new CToolBar[2];
	new CUIntArray[2];
	new CWnd[2];
	new CWordArray[2];

	new CFileFind[2];
	new CInternetSession[2];

	new CDragListBox[2];
	new CStatusBarCtrl[2];
	new CListCtrl[2];
	new CTreeCtrl[2];
	new CSpinButtonCtrl[2];
	new CSliderCtrl[2];
	new CProgressCtrl[2];
	new CHeaderCtrl[2];
	new CHotKeyCtrl[2];
	new CToolTipCtrl[2];
	new CTabCtrl[2];
	new CAnimateCtrl[2];
	new CImageList[2];
	new CToolBarCtrl[2];
	new CRichEditCtrl[2];

	new CMirrorFile[2];
	new CDockState[2];

	new CListView[2];
	new CTreeView[2];
	new CCommandLineInfo[2];
	new CDocManager[2];

	new CPageSetupDialog[2];

	new CSemaphore[2];
	new CMutex[2];
	new CEvent[2];
	new CCriticalSection[2];

#ifdef _AFX_OLE_IMPL
	new COleDataSource[2];
	new COleDispatchDriver[2];
	new COleDropSource[2];
	new CMonikerFile[2];
	new COleResizeBar[2];
	new CAsyncMonikerFile[2];
	new CCachedDataPathProperty[2];
	new CDataPathProperty[2];
	new COleStreamFile[2];
	new COleTemplateServer[2];
	new COleDataObject[2];
	new COleDropTarget[2];
	new COleIPFrameWnd[2];

	new COleDocIPFrameWnd[2];

	new COleVariant[2];
	new CRichEditView[2];
	new CRichEditCntrItem[2];
#endif

#ifdef _AFX_DB_IMPL
	new CDatabase[2];
	new CLongBinary[2];
#endif

// Net
#ifdef _AFX_NET_IMPL
	new CAsyncSocket[2];
	new CSocket[2];
#endif
}
void (*_afxForceVectorDelete_mfc)() = &_AfxForceVectorDelete;

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\doccore.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "io.h" // for _access

#include "afxdatarecovery.h"

/////////////////////////////////////////////////////////////////////////////
// CDocument

BEGIN_MESSAGE_MAP(CDocument, CCmdTarget)
	//{{AFX_MSG_MAP(CDocument)
	ON_COMMAND(ID_FILE_CLOSE, &CDocument::OnFileClose)
	ON_COMMAND(ID_FILE_SAVE, &CDocument::OnFileSave)
	ON_COMMAND(ID_FILE_SAVE_AS, &CDocument::OnFileSaveAs)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

#if WINVER >= 0x0600
BEGIN_INTERFACE_MAP(CDocument, CCmdTarget)
	INTERFACE_PART(CDocument, IID_IInitializeWithStream, InitializeWithStream)
	INTERFACE_PART(CDocument, IID_IPreviewHandler, PreviewHandler)
	INTERFACE_PART(CDocument, IID_IPreviewHandlerVisuals, PreviewHandlerVisuals)
	INTERFACE_PART(CDocument, IID_IObjectWithSite, ObjectWithSite)
	INTERFACE_PART(CDocument, IID_IOleWindow, OleWindow)
END_INTERFACE_MAP()
#endif

/////////////////////////////////////////////////////////////////////////////
// CDocument construction/destruction

CDocument::CDocument()
{
	m_pDocTemplate = NULL;
	m_bModified = FALSE;
	m_bAutoDelete = TRUE;       // default to auto delete document
	m_bEmbedded = FALSE;        // default to file-based document
	ASSERT(m_viewList.IsEmpty());

	m_pStream = NULL;
	m_hWndHost = NULL;
	m_pPreviewFrame = NULL;
	m_rectHost.SetRectEmpty();
	m_grfMode = 0;
	m_bGetThumbnailMode = FALSE;
	m_bPreviewHandlerMode = FALSE;
	m_bSearchMode = FALSE;
	m_posReadChunk = NULL;
	m_pDocumentAdapter = NULL;
	m_pPreviewHandlerSite = NULL;
	m_bFinalRelease = FALSE;
	m_bOLELocked = FALSE;

	m_clrRichPreviewBackColor = RGB(255, 255, 255);
	m_clrRichPreviewTextColor = RGB(0, 0, 0);
}

CDocument::~CDocument()
{
	// do not call DeleteContents here !
#ifdef _DEBUG
	if (IsModified())
		TRACE(traceAppMsg, 0, "Warning: destroying an unsaved document.\n");
#endif

	// there should be no views left!
	DisconnectViews();
	ASSERT(m_viewList.IsEmpty());

	if (m_pDocTemplate != NULL)
		m_pDocTemplate->RemoveDocument(this);
	ASSERT(m_pDocTemplate == NULL);     // must be detached

	// if IPreviewHandler::Unload was not called for some reason release stream and site
	if (m_pStream != NULL)
	{
		// if stream is not NULL it has not been released yet
		m_pStream->Release();
		m_pStream = NULL;
	}

	if (m_pDocumentAdapter != NULL)
	{
		m_pDocumentAdapter->m_pParentDoc = NULL;
	}

	if (m_pPreviewHandlerSite != NULL)
	{
		m_pPreviewHandlerSite->Release();
		m_pPreviewHandlerSite = NULL;
	}

	ClearChunkList();
}

void CDocument::OnFinalRelease()
{
	ASSERT_VALID(this);

	if (m_bPreviewHandlerMode)
	{
		if (m_bOLELocked)
		{
			AfxOleUnlockApp();
			m_bOLELocked = FALSE;
		}

		m_bAutoDelete = TRUE;
	}
	m_bFinalRelease = TRUE; // rich preview documents can be destroyed only from FinalRelease
	OnCloseDocument();  // may 'delete this'
}

void CDocument::DisconnectViews()
{
	while (!m_viewList.IsEmpty())
	{
		CView* pView = (CView*)m_viewList.RemoveHead();
		ASSERT_VALID(pView);
		ASSERT_KINDOF(CView, pView);
		pView->m_pDocument = NULL;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CDocument attributes, general services

void CDocument::SetTitle(LPCTSTR lpszTitle)
{
	m_strTitle = lpszTitle;
	UpdateFrameCounts();        // will cause name change in views
}

void CDocument::DeleteContents()
{
}

/////////////////////////////////////////////////////////////////////////////
// Closing documents or views

void CDocument::OnChangedViewList()
{
	// if no more views on the document, delete ourself
	// not called if directly closing the document or terminating the app
	if (m_viewList.IsEmpty() && m_bAutoDelete)
	{
		OnCloseDocument();
		return;
	}

	// update the frame counts as needed
	UpdateFrameCounts();
}

void CDocument::UpdateFrameCounts()
	 // assumes 1 doc per frame
{
	// walk all frames of views (mark and sweep approach)
	POSITION pos = GetFirstViewPosition();
	while (pos != NULL)
	{
		CView* pView = GetNextView(pos);
		ASSERT_VALID(pView);
		ASSERT(::IsWindow(pView->m_hWnd));
		if (pView->IsWindowVisible())   // Do not count invisible windows.
		{
			CFrameWnd* pFrame = pView->GetParentFrame();
			if (pFrame != NULL)
				pFrame->m_nWindow = -1;     // unknown
		}
	}

	// now do it again counting the unique ones
	int nFrames = 0;
	pos = GetFirstViewPosition();
	while (pos != NULL)
	{
		CView* pView = GetNextView(pos);
		ASSERT_VALID(pView);
		ASSERT(::IsWindow(pView->m_hWnd));
		if (pView->IsWindowVisible())   // Do not count invisible windows.
		{
			CFrameWnd* pFrame = pView->GetParentFrame();
			if (pFrame != NULL && pFrame->m_nWindow == -1)
			{
				ASSERT_VALID(pFrame);
				// not yet counted (give it a 1 based number)
				pFrame->m_nWindow = ++nFrames;
			}
		}
	}

	// lastly walk the frames and update titles (assume same order)
	// go through frames updating the appropriate one
	int iFrame = 1;
	pos = GetFirstViewPosition();
	while (pos != NULL)
	{
		CView* pView = GetNextView(pos);
		ASSERT_VALID(pView);
		ASSERT(::IsWindow(pView->m_hWnd));
		if (pView->IsWindowVisible())   // Do not count invisible windows.
		{
			CFrameWnd* pFrame = pView->GetParentFrame();
			if (pFrame != NULL && pFrame->m_nWindow == iFrame)
			{
				ASSERT_VALID(pFrame);
				if (nFrames == 1)
					pFrame->m_nWindow = 0;      // the only one of its kind
				pFrame->OnUpdateFrameTitle(TRUE);
				iFrame++;
			}
		}
	}
	ASSERT(iFrame == nFrames + 1);
}

BOOL CDocument::CanCloseFrame(CFrameWnd* pFrameArg)
	// permission to close all views using this frame
	//  (at least one of our views must be in this frame)
{
	ASSERT_VALID(pFrameArg);
	UNUSED(pFrameArg);   // unused in release builds

	POSITION pos = GetFirstViewPosition();
	while (pos != NULL)
	{
		CView* pView = GetNextView(pos);
		ASSERT_VALID(pView);
		CFrameWnd* pFrame = pView->GetParentFrame();
		// assume frameless views are ok to close
		if (pFrame != NULL)
		{
			// assumes 1 document per frame
			ASSERT_VALID(pFrame);
			if (pFrame->m_nWindow > 0)
				return TRUE;        // more than one frame refering to us
		}
	}

	// otherwise only one frame that we know about
	return SaveModified();
}

void CDocument::PreCloseFrame(CFrameWnd* /*pFrameArg*/)
{
	// default does nothing
}

/////////////////////////////////////////////////////////////////////////////
// File/Path commands

void CDocument::SetPathName(LPCTSTR lpszPathName, BOOL bAddToMRU)
{
	// store the path fully qualified
	TCHAR szFullPath[_MAX_PATH];
	ENSURE(lpszPathName);
	if ( lstrlen(lpszPathName) >= _MAX_PATH )
	{
		ASSERT(FALSE);
		// MFC requires paths with length < _MAX_PATH
		// No other way to handle the error from a void function
		AfxThrowFileException(CFileException::badPath);
	}

	if( AfxFullPath(szFullPath, lpszPathName) == FALSE )
	{
		ASSERT(FALSE);
		// MFC requires paths with length < _MAX_PATH
		// No other way to handle the error from a void function
		AfxThrowFileException(CFileException::badPath);
	}

	m_strPathName = szFullPath;
	ASSERT(!m_strPathName.IsEmpty());       // must be set to something
	m_bEmbedded = FALSE;
	ASSERT_VALID(this);

	// set the document title based on path name
	TCHAR szTitle[_MAX_FNAME];
	if (AfxGetFileTitle(szFullPath, szTitle, _MAX_FNAME) == 0)
		SetTitle(szTitle);

	// add it to the file MRU list
	if (bAddToMRU)
		AfxGetApp()->AddToRecentFileList(m_strPathName);

	ASSERT_VALID(this);
}

void CDocument::ClearPathName()
{
	// If we need to keep the document content but also force a
	// prompt on the next save, we need to clear the path name.
	m_strPathName.Empty();
}

/////////////////////////////////////////////////////////////////////////////
// Standard file menu commands

void CDocument::OnFileClose()
{
	if (!SaveModified())
		return;

	// shut it down
	OnCloseDocument();
		// this should destroy the document
}

void CDocument::OnFileSave()
{
	DoFileSave();
}

void CDocument::OnFileSaveAs()
{
	if(!DoSave(NULL))
		TRACE(traceAppMsg, 0, "Warning: File save-as failed.\n");
}

BOOL CDocument::DoFileSave()
{
	DWORD dwAttrib = GetFileAttributes(m_strPathName);
	if (dwAttrib & FILE_ATTRIBUTE_READONLY)
	{
		// we do not have read-write access or the file does not (now) exist
		if (!DoSave(NULL))
		{
			TRACE(traceAppMsg, 0, "Warning: File save with new name failed.\n");
			return FALSE;
		}
	}
	else
	{
		if (!DoSave(m_strPathName))
		{
			TRACE(traceAppMsg, 0, "Warning: File save failed.\n");
			return FALSE;
		}
	}
	return TRUE;
}

BOOL CDocument::DoSave(LPCTSTR lpszPathName, BOOL bReplace)
	// Save the document data to a file
	// lpszPathName = path name where to save document file
	// if lpszPathName is NULL then the user will be prompted (SaveAs)
	// note: lpszPathName can be different than 'm_strPathName'
	// if 'bReplace' is TRUE will change file name if successful (SaveAs)
	// if 'bReplace' is FALSE will not change path name (SaveCopyAs)
{
	CString newName = lpszPathName;

	if (newName.IsEmpty())
	{
		CDocTemplate* pTemplate = GetDocTemplate();
		ASSERT(pTemplate != NULL);

		newName = m_strPathName;
		if (bReplace && newName.IsEmpty())
		{
			newName = m_strTitle;
			// check for dubious filename
			int iBad = newName.FindOneOf(_T(":/\\"));
			if (iBad != -1)
				newName.ReleaseBuffer(iBad);

			if (AfxGetApp() && AfxGetApp()->GetDataRecoveryHandler())
			{
				// remove "[recovered]" from the title if it exists
				CString strNormalTitle = AfxGetApp()->GetDataRecoveryHandler()->GetNormalDocumentTitle(this);
				if (!strNormalTitle.IsEmpty())
					newName = strNormalTitle;
			}

			// append the default suffix if there is one
			CString strExt;
			if (pTemplate->GetDocString(strExt, CDocTemplate::filterExt) && !strExt.IsEmpty())
			{
				ASSERT(strExt[0] == '.');
				int iStart = 0;
				newName += strExt.Tokenize(_T(";"), iStart);
			}
		}

		if (!AfxGetApp()->DoPromptFileName(newName,
		  bReplace ? AFX_IDS_SAVEFILE : AFX_IDS_SAVEFILECOPY,
		  OFN_HIDEREADONLY | OFN_PATHMUSTEXIST, FALSE, pTemplate))
			return FALSE;       // don't even attempt to save
	}

	CWaitCursor wait;

	if (!OnSaveDocument(newName))
	{
		if (lpszPathName == NULL)
		{
			// be sure to delete the file
			TRY
			{
				CFile::Remove(newName);
			}
			CATCH_ALL(e)
			{
				TRACE(traceAppMsg, 0, "Warning: failed to delete file after failed SaveAs.\n");
				DELETE_EXCEPTION(e);
			}
			END_CATCH_ALL
		}
		return FALSE;
	}

	// reset the title and change the document name
	if (bReplace)
	{
		SetPathName(newName);
		OnDocumentEvent(onAfterSaveDocument);
	}

	return TRUE;        // success
}

BOOL CDocument::SaveModified()
{
	if (!IsModified())
		return TRUE;        // ok to continue

	CDataRecoveryHandler *pHandler = NULL;
	if (AfxGetApp())
	{
		// if close is triggered by the restart manager, the file
		// will be auto-saved and a prompt for save is not permitted.
		pHandler = AfxGetApp()->GetDataRecoveryHandler();
		if (pHandler != NULL)
		{
			if (pHandler->GetShutdownByRestartManager())
				return TRUE;
		}
	}

	// get name/title of document
	CString name;
	if (m_strPathName.IsEmpty())
	{
		// get name based on caption
		name = m_strTitle;

		if (pHandler != NULL)
		{
			// remove "[recovered]" from the title if it exists
			CString strNormalTitle = pHandler->GetNormalDocumentTitle(this);
			if (!strNormalTitle.IsEmpty())
				name = strNormalTitle;
		}

		if (name.IsEmpty())
			ENSURE(name.LoadString(AFX_IDS_UNTITLED));
	}
	else
	{
		// get name based on file title of path name
		name = m_strPathName;
		AfxGetFileTitle(m_strPathName, name.GetBuffer(_MAX_PATH), _MAX_PATH);
		name.ReleaseBuffer();
	}

	CString prompt;
	AfxFormatString1(prompt, AFX_IDP_ASK_TO_SAVE, name);
	switch (AfxMessageBox(prompt, MB_YESNOCANCEL, AFX_IDP_ASK_TO_SAVE))
	{
	case IDCANCEL:
		return FALSE;       // don't continue

	case IDYES:
		// If so, either Save or Update, as appropriate
		if (!DoFileSave())
			return FALSE;       // don't continue
		break;

	case IDNO:
		// If not saving changes, revert the document
		break;

	default:
		ASSERT(FALSE);
		break;
	}
	return TRUE;    // keep going
}

HMENU CDocument::GetDefaultMenu()
{
	return NULL;    // just use original default
}

HACCEL CDocument::GetDefaultAccelerator()
{
	return NULL;    // just use original default
}

void CDocument::ReportSaveLoadException(LPCTSTR lpszPathName,
	CException* e, BOOL bSaving, UINT nIDPDefault)
{
	UINT nIDP = nIDPDefault;
	UINT nHelpContext = nIDPDefault;
	CString prompt;

	if (e != NULL)
	{
		ASSERT_VALID(e);
		if (e->IsKindOf(RUNTIME_CLASS(CUserException)))
			return; // already reported

		if (e->IsKindOf(RUNTIME_CLASS(CArchiveException)))
		{
			switch (((CArchiveException*)e)->m_cause)
			{
			case CArchiveException::badSchema:
			case CArchiveException::badClass:
			case CArchiveException::badIndex:
			case CArchiveException::endOfFile:
				nIDP = AFX_IDP_FAILED_INVALID_FORMAT;
				break;
			default:
				break;
			}
		}
		else if (e->IsKindOf(RUNTIME_CLASS(CFileException)))
		{
			TRACE(traceAppMsg, 0, "Reporting file I/O exception on Save/Load with lOsError = $%lX.\n",
				((CFileException*)e)->m_lOsError);

			CFileException* pFileException = (CFileException*)e;
			if (pFileException->m_strFileName.IsEmpty())
				pFileException->m_strFileName = lpszPathName;

			LPTSTR lpszMessage = prompt.GetBuffer(_MAX_PATH);
			ASSERT(lpszMessage != NULL);
			if (!e->GetErrorMessage(lpszMessage, _MAX_PATH-1, &nHelpContext))
			{
				switch (((CFileException*)e)->m_cause)
				{
					case CFileException::fileNotFound:
					case CFileException::badPath:
						nIDP = AFX_IDP_FAILED_INVALID_PATH;
						break;
					case CFileException::diskFull:
						nIDP = AFX_IDP_FAILED_DISK_FULL;
						break;
					case CFileException::accessDenied:
						nIDP = bSaving ? AFX_IDP_FAILED_ACCESS_WRITE :
								AFX_IDP_FAILED_ACCESS_READ;
						break;

					case CFileException::badSeek:
					case CFileException::genericException:
					case CFileException::tooManyOpenFiles:
					case CFileException::invalidFile:
					case CFileException::hardIO:
					case CFileException::directoryFull:
						break;

					default:
						break;
				}
			}
			prompt.ReleaseBuffer();
		}
	}

	if (prompt.IsEmpty())
	{
		TCHAR szTitle[_MAX_PATH];
		AfxGetFileTitle(lpszPathName, szTitle, _countof(szTitle));
		AfxFormatString1(prompt, nIDP, szTitle);
	}

	AfxMessageBox(prompt, MB_ICONEXCLAMATION, nHelpContext);
}

/////////////////////////////////////////////////////////////////////////////
// File operations (default uses CDocument::Serialize)

BOOL CMirrorFile::Open(LPCTSTR lpszFileName, UINT nOpenFlags,
	CFileException* pError)
{
	ASSERT(lpszFileName != NULL);
	m_strMirrorName.Empty();

	CFileStatus status;
	if (nOpenFlags & CFile::modeCreate) //opened for writing
	{
		if (CFile::GetStatus(lpszFileName, status))
		{
			CString strRoot;
			AfxGetRoot(lpszFileName, strRoot);

			DWORD dwSecPerClus, dwBytesPerSec, dwFreeClus, dwTotalClus;
			int nBytes = 0;
			if (GetDiskFreeSpace(strRoot, &dwSecPerClus, &dwBytesPerSec, &dwFreeClus,
				&dwTotalClus))
			{
				nBytes = dwFreeClus*dwSecPerClus*dwBytesPerSec;
			}
			if (nBytes > 2*status.m_size) // at least 2x free space avail
			{
				// get the directory for the file
				TCHAR szPath[_MAX_PATH];
				LPTSTR lpszName;
				GetFullPathName(lpszFileName, _MAX_PATH, szPath, &lpszName);
				*lpszName = NULL;

				//let's create a temporary file name
				GetTempFileName(szPath, _T("MFC"), 0,
					m_strMirrorName.GetBuffer(_MAX_PATH+1));
				m_strMirrorName.ReleaseBuffer();
			}
		}
	}

	if (!m_strMirrorName.IsEmpty() &&
		CFile::Open(m_strMirrorName, nOpenFlags, pError))
	{
		m_strFileName = lpszFileName;
		FILETIME ftCreate, ftAccess, ftModify;
		if (::GetFileTime((HANDLE)m_hFile, &ftCreate, &ftAccess, &ftModify))
		{
			AfxTimeToFileTime(status.m_ctime, &ftCreate);
			SetFileTime((HANDLE)m_hFile, &ftCreate, &ftAccess, &ftModify);
		}

		DWORD dwLength = 0;
		PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
		if (GetFileSecurity(lpszFileName, DACL_SECURITY_INFORMATION,
			NULL, dwLength, &dwLength))
		{
			pSecurityDescriptor = (PSECURITY_DESCRIPTOR) new BYTE[dwLength];
			if (::GetFileSecurity(lpszFileName, DACL_SECURITY_INFORMATION,
				pSecurityDescriptor, dwLength, &dwLength))
			{
				SetFileSecurity(m_strMirrorName, DACL_SECURITY_INFORMATION, pSecurityDescriptor);
			}
			delete[] (BYTE*)pSecurityDescriptor;
		}
		return TRUE;
	}
	m_strMirrorName.Empty();
	return CFile::Open(lpszFileName, nOpenFlags, pError);
}

void CMirrorFile::Abort()
{
	CFile::Abort();
	if (!m_strMirrorName.IsEmpty())
		CFile::Remove(m_strMirrorName);
}

void CMirrorFile::Close()
{
	CString strName = m_strFileName; //file close empties string
	CFile::Close();
	if (!m_strMirrorName.IsEmpty())
	{
		if(!ReplaceFile(strName, m_strMirrorName, NULL, 0, NULL, NULL))
		{
			CFile::Remove(strName);
			CFile::Rename(m_strMirrorName, strName);
		}
	}
}

CFile* CDocument::GetFile(LPCTSTR lpszFileName, UINT nOpenFlags,
	CFileException* pError)
{
	CMirrorFile* pFile = new CMirrorFile;
	ASSERT(pFile != NULL);
	if (!pFile->Open(lpszFileName, nOpenFlags, pError))
	{
		delete pFile;
		pFile = NULL;
	}
	return pFile;
}

void CDocument::ReleaseFile(CFile* pFile, BOOL bAbort)
{
	ASSERT_KINDOF(CFile, pFile);
	if (bAbort)
		pFile->Abort(); // will not throw an exception
	else
		pFile->Close();
	delete pFile;
}

BOOL CDocument::OnNewDocument()
{
#ifdef _DEBUG
	if(IsModified())
		TRACE(traceAppMsg, 0, "Warning: OnNewDocument replaces an unsaved document.\n");
#endif

	DeleteContents();
	m_strPathName.Empty();      // no path name yet
	SetModifiedFlag(FALSE);     // make clean
	OnDocumentEvent(onAfterNewDocument);

	return TRUE;
}

BOOL CDocument::OnOpenDocument(LPCTSTR lpszPathName)
{
#ifdef _DEBUG
	if (IsModified())
		TRACE(traceAppMsg, 0, "Warning: OnOpenDocument replaces an unsaved document.\n");
#endif

	ENSURE(lpszPathName);

	CFileException* pfe = new CFileException;
	CFile* pFile = GetFile(lpszPathName,
		CFile::modeRead|CFile::shareDenyWrite, pfe);
	if (pFile == NULL)
	{
		TRY
		{
			ReportSaveLoadException(lpszPathName, pfe,
				FALSE, AFX_IDP_FAILED_TO_OPEN_DOC);
		}
		END_TRY
		DELETE_EXCEPTION(pfe);
		return FALSE;
	}

	DELETE_EXCEPTION(pfe);

	DeleteContents();
	SetModifiedFlag();  // dirty during de-serialize

	CArchive loadArchive(pFile, CArchive::load | CArchive::bNoFlushOnDelete);
	loadArchive.m_pDocument = this;
	loadArchive.m_bForceFlat = FALSE;
	TRY
	{
		CWaitCursor wait;
		if (pFile->GetLength() != 0)
			Serialize(loadArchive);     // load me
		loadArchive.Close();
		ReleaseFile(pFile, FALSE);
	}
	CATCH_ALL(e)
	{
		ReleaseFile(pFile, TRUE);
		DeleteContents();   // remove failed contents

		TRY
		{
			ReportSaveLoadException(lpszPathName, e,
				FALSE, AFX_IDP_FAILED_TO_OPEN_DOC);
		}
		END_TRY
		DELETE_EXCEPTION(e);
		return FALSE;
	}
	END_CATCH_ALL

	SetModifiedFlag(FALSE);     // start off with unmodified

	return TRUE;
}

BOOL CDocument::OnSaveDocument(LPCTSTR lpszPathName)
{
	ENSURE(lpszPathName);

	CFileException *pfe = new CFileException;
	CFile* pFile = NULL;
	pFile = GetFile(lpszPathName, CFile::modeCreate |
		CFile::modeReadWrite | CFile::shareExclusive, pfe);

	if (pFile == NULL)
	{
		TRY
		{
			ReportSaveLoadException(lpszPathName, pfe,
				TRUE, AFX_IDP_INVALID_FILENAME);
		}
		END_TRY
		DELETE_EXCEPTION(pfe);
		return FALSE;
	}

	DELETE_EXCEPTION(pfe);

	CArchive saveArchive(pFile, CArchive::store | CArchive::bNoFlushOnDelete);
	saveArchive.m_pDocument = this;
	saveArchive.m_bForceFlat = FALSE;
	TRY
	{
		CWaitCursor wait;
		Serialize(saveArchive);     // save me
		saveArchive.Close();
		ReleaseFile(pFile, FALSE);
	}
	CATCH_ALL(e)
	{
		ReleaseFile(pFile, TRUE);

		TRY
		{
			ReportSaveLoadException(lpszPathName, e,
				TRUE, AFX_IDP_FAILED_TO_SAVE_DOC);
		}
		END_TRY
		DELETE_EXCEPTION(e);
		return FALSE;
	}
	END_CATCH_ALL

	SetModifiedFlag(FALSE);     // back to unmodified

	return TRUE;        // success
}

void CDocument::OnCloseDocument()
	// must close all views now (no prompting) - usually destroys this
{
	// search/organize/preview handler can be destroyed only from FinalRelease 
	if (IsSearchAndOrganizeHandler() && !m_bFinalRelease)
	{
		return;
	}

	// destroy all frames viewing this document
	// the last destroy may destroy us
	BOOL bAutoDelete = m_bAutoDelete;
	m_bAutoDelete = FALSE;  // don't destroy document while closing views
	while (!m_viewList.IsEmpty())
	{
		// get frame attached to the view
		CView* pView = (CView*)m_viewList.GetHead();
		ASSERT_VALID(pView);
		CFrameWnd* pFrame = pView->EnsureParentFrame();

		// and close it
		PreCloseFrame(pFrame);
		pFrame->DestroyWindow();
			// will destroy the view as well
	}
	m_bAutoDelete = bAutoDelete;
	OnDocumentEvent(onAfterCloseDocument);

	// clean up contents of document before destroying the document itself
	DeleteContents();

	// delete the document if necessary
	if (m_bAutoDelete)
		delete this;
}

void CDocument::OnDocumentEvent(DocumentEvent deEvent)
{
	// check if recovery handling is enabled...
	CWinApp *pApp = AfxGetApp();
	if (pApp != NULL)
	{
		CDataRecoveryHandler *pHandler = pApp->GetDataRecoveryHandler();
		if (pHandler != NULL)
		{
			// ...and if so, notify of the specified event.
			switch (deEvent)
			{
				case onAfterNewDocument:
				{
					// add the document to the open document list.
					pHandler->CreateDocumentInfo(this);
					break;
				}

				case onAfterOpenDocument:
				{
					// add the document to the open document list.
					pHandler->CreateDocumentInfo(this);
					break;
				}

				case onAfterSaveDocument:
				{
					// update the document info (filename may have changed).
					pHandler->UpdateDocumentInfo(this);
					break;
				}

				case onAfterCloseDocument:
				{
					// remove any document auto-save info, as long as the
					// restart manager is not actually causing the close.
					if (!pHandler->GetShutdownByRestartManager())
					{
						pHandler->RemoveDocumentInfo(this);
					}
					break;
				}
			}
		}
	}
}

void CDocument::OnIdle()
{
	// check if recovery handling is enabled...
	CWinApp *pApp = AfxGetApp();
	if (pApp != NULL)
	{
		CDataRecoveryHandler *pHandler = pApp->GetDataRecoveryHandler();
		if ((pHandler != NULL) && (pHandler->GetSaveDocumentInfoOnIdle()))
		{
			// ...and if so, save the document info.  Note that the info is saved
			// even if the document is not modified (for reopen on restart), but
			// the content is auto-saved only if the document is modified.
			pHandler->AutosaveDocumentInfo(this);
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// View operations

void CDocument::AddView(CView* pView)
{
	ASSERT_VALID(pView);
	ASSERT(pView->m_pDocument == NULL); // must not be already attached
	ASSERT(m_viewList.Find(pView, NULL) == NULL);   // must not be in list

	m_viewList.AddTail(pView);
	ASSERT(pView->m_pDocument == NULL); // must be un-attached
	pView->m_pDocument = this;

	OnChangedViewList();    // must be the last thing done to the document
}

void CDocument::RemoveView(CView* pView)
{
	ASSERT_VALID(pView);
	ASSERT(pView->m_pDocument == this); // must be attached to us

	m_viewList.RemoveAt(m_viewList.Find(pView));
	pView->m_pDocument = NULL;

	OnChangedViewList();    // must be the last thing done to the document
}

POSITION CDocument::GetFirstViewPosition() const
{
	return m_viewList.GetHeadPosition();
}

CView* CDocument::GetNextView(POSITION& rPosition) const
{
	ASSERT(rPosition != BEFORE_START_POSITION);
		// use CDocument::GetFirstViewPosition instead !
	if (rPosition == NULL)
		return NULL;    // nothing left
	CView* pView = (CView*)m_viewList.GetNext(rPosition);
	ASSERT_KINDOF(CView, pView);
	return pView;
}

void CDocument::UpdateAllViews(CView* pSender, LPARAM lHint, CObject* pHint)
	// walk through all views
{
	ASSERT(pSender == NULL || !m_viewList.IsEmpty());
		// must have views if sent by one of them

	POSITION pos = GetFirstViewPosition();
	while (pos != NULL)
	{
		CView* pView = GetNextView(pos);
		ASSERT_VALID(pView);
		if (pView != pSender)
			pView->OnUpdate(pSender, lHint, pHint);
	}
}

void CDocument::SendInitialUpdate()
	// walk through all views and call OnInitialUpdate
{
	POSITION pos = GetFirstViewPosition();
	while (pos != NULL)
	{
		CView* pView = GetNextView(pos);
		ASSERT_VALID(pView);
		pView->OnInitialUpdate();
	}
}

/////////////////////////////////////////////////////////////////////////////
// command routing

BOOL CDocument::OnCmdMsg(UINT nID, int nCode, void* pExtra,
	AFX_CMDHANDLERINFO* pHandlerInfo)
{
	if (CCmdTarget::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
		return TRUE;

	// otherwise check template
	if (m_pDocTemplate != NULL &&
	  m_pDocTemplate->OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
		return TRUE;

	return FALSE;
}
/////////////////////////////////////////////////////////////////////////////
// CDocument search/organize/preview/live-icon support
HRESULT CDocument::LoadDocumentFromStream(IStream* pStream, DWORD grfMode)
{
	ASSERT_VALID(this);
	return OnLoadDocumentFromStream(pStream, grfMode);
}

void CDocument::OnUnloadHandler()
{
}

HRESULT CDocument::OnLoadDocumentFromStream(IStream* pStream, DWORD grfMode)
{
	UNREFERENCED_PARAMETER(grfMode);

	ASSERT(pStream != NULL);
	if (pStream == NULL)
	{
		return E_INVALIDARG;
	}
	
	COleStreamFile file;
	file.Attach(pStream);

	CArchive loadArchive(&file, CArchive::load | CArchive::bNoFlushOnDelete);
	loadArchive.m_pDocument = this;
	loadArchive.m_bForceFlat = FALSE;

	HRESULT hr = S_OK;
	TRY
	{
		Serialize (loadArchive);
		loadArchive.Close();
	}
	CATCH_ALL(e)
	{
		DELETE_EXCEPTION(e);
		TRACE0("Error: CDocument::OnLoadDocumentFromStream - serialization from stream failed.");
		hr = E_FAIL;
	}
	END_CATCH_ALL

	return hr;
}

HRESULT CDocument::OnPreviewHandlerQueryFocus(HWND* phwnd)
{
	if (phwnd == NULL)
	{
		TRACE0("Error: IPreviewHandler::QueryFocus called with NULL pointer.");
		return E_INVALIDARG;
	}

	*phwnd = ::GetFocus();
	HRESULT hr = S_OK;

	if (*phwnd == NULL)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
	}

	return hr;
}
HRESULT CDocument::OnPreviewHandlerTranslateAccelerator(MSG* pmsg)
{
	HRESULT hr = S_FALSE;
	UNREFERENCED_PARAMETER(pmsg);

	if (m_pPreviewHandlerSite != NULL)
	{
		//
		// If previewer has multiple tab stops, it's needed to do appropriate first/last child checking.
		// This sample previewer has no tabstops, so we want to just forward this message out 
		//
		hr = m_pPreviewHandlerSite->TranslateAccelerator(pmsg);
	}

	return hr;
}

BOOL CDocument::OnCreatePreviewFrame()
{
	CWinApp* pApp = AfxGetApp();
	ASSERT_VALID(pApp);
	POSITION pos = pApp->GetFirstDocTemplatePosition();

	while (pos != NULL)
	{
		CDocTemplate* pDocTemplate = (CDocTemplate*) pApp->GetNextDocTemplate(pos);
		ASSERT_VALID(pDocTemplate);
		if (pDocTemplate->m_pDocClass == GetRuntimeClass())
		{
			m_pPreviewFrame = pDocTemplate->CreatePreviewFrame(CWnd::FromHandle(m_hWndHost), this);
			ASSERT_VALID(m_pPreviewFrame);
			break;
		}
	}

	if (m_pPreviewFrame == NULL)
	{
		TRACE0("Error: Document was unable to create preview frame.");
		return FALSE;
	}

	CWnd* pWnd = m_pPreviewFrame->GetDescendantWindow(AFX_IDW_PANE_FIRST);

	// ensure it's first in the view list
	if (pWnd != NULL)
	{
		POSITION pos = m_viewList.Find(pWnd);
		if (pos != NULL)
		{
			m_viewList.RemoveAt(pos);
			m_viewList.AddHead(pWnd);
		}
	}

	m_pPreviewFrame->ModifyStyleEx(WS_EX_CLIENTEDGE, 0, 0);

	for (POSITION pos = GetFirstViewPosition(); pos != NULL;)
	{
		CView* pView = GetNextView(pos);
		ASSERT_VALID(pView);

		pView->ModifyStyleEx(WS_EX_CLIENTEDGE, 0, 0);

		if (m_pPreviewFrame->GetActiveView() == NULL && m_pPreviewFrame->IsChild(pView))
		{
			m_pPreviewFrame->SetActivePreviewView(pView);
		}
	}

	return TRUE;
}

BOOL CDocument::GetThumbnail(UINT cx, HBITMAP* phbmp, WTS_ALPHATYPE* pdwAlpha)
{
	ASSERT(phbmp != NULL);
	if (pdwAlpha != NULL)
	{
		*pdwAlpha = WTSAT_UNKNOWN;
	}

	HDC hdc = ::GetDC(NULL);
	CDC* pDC = CDC::FromHandle(hdc);
	CDC dc;
	CDC* pDrawDC = pDC;
	CBitmap* pOldBitmap = NULL;
	CBitmap bitmap;

	// Here you need  to calculate document area to be displayed on the Live Icon
	CRect rectDocBounds = CRect(0, 0, cx, cx);

	if (dc.CreateCompatibleDC(pDC))
	{
		if (bitmap.CreateCompatibleBitmap(pDC, rectDocBounds.Width(), rectDocBounds.Height()))
		{
			pDrawDC = &dc;
			pOldBitmap = dc.SelectObject(&bitmap);
		}
	}
	else
	{
		::ReleaseDC(NULL, hdc);
		return FALSE;
	}

	dc.SelectObject(&bitmap);

	OnDrawThumbnail(dc, &rectDocBounds);

	if (pDrawDC != pDC)
	{
		dc.SelectObject(pOldBitmap);
	}

	::ReleaseDC(NULL, hdc);
	*phbmp = (HBITMAP)bitmap.Detach();

	return TRUE;
}

BOOL CDocument::IsSearchAndOrganizeHandler() const
{
	return m_bPreviewHandlerMode || m_bSearchMode || m_bGetThumbnailMode;
}

void CDocument::OnRichPreviewUnload()
{
	m_bModified = FALSE;

	// tell the document to clear data.
	// sometimes Release is not called after unload
	// therefore the data must be unloaded here
	OnUnloadHandler();
	DeleteContents();

	if (m_pPreviewHandlerSite != NULL)
	{
		m_pPreviewHandlerSite->Release();
		m_pPreviewHandlerSite = NULL;
	}

	if (m_pPreviewFrame != NULL && IsWindow(m_pPreviewFrame->GetSafeHwnd()))
	{
		m_pPreviewFrame->SetActiveView(NULL);
		::DestroyWindow(m_pPreviewFrame->GetSafeHwnd());
		m_pPreviewFrame = NULL;
	}

	if (m_pStream != NULL)
	{
		// if stream is not NULL it has not been released yet
		m_pStream->Release();
		m_pStream = NULL;
	}

	m_hWndHost = NULL;
	m_rectHost.SetRectEmpty();
	m_grfMode = 0;
}

#if WINVER >= 0x0600
/////////////////////////////////////////////////////////////////////////////
// IInitializeWithStream interface implementation
STDMETHODIMP_(ULONG) CDocument::XInitializeWithStream::AddRef()
{
	METHOD_PROLOGUE_EX(CDocument, InitializeWithStream)
	return pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CDocument::XInitializeWithStream::Release()
{
	METHOD_PROLOGUE_EX(CDocument, InitializeWithStream)
	return pThis->ExternalRelease();
}

STDMETHODIMP CDocument::XInitializeWithStream::QueryInterface(REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX(CDocument, InitializeWithStream);
	return pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP CDocument::XInitializeWithStream::Initialize(IStream* pStream, DWORD grfMode)
{
	METHOD_PROLOGUE(CDocument, InitializeWithStream);
	if (pStream == NULL)
	{
		TRACE0("Error: IInitializeWithStream::Iniitalize called with pStream = NULL");
		return E_INVALIDARG;
	}

	pThis->m_bPreviewHandlerMode = TRUE;
	pThis->m_bAutoDelete = false;

	pStream->AddRef();
	pThis->m_pStream = pStream;
	pThis->m_grfMode = grfMode;

	if (!pThis->m_bOLELocked)
	{
		AfxOleLockApp();
		pThis->m_bOLELocked = TRUE;
	}

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPreviewHandler interface implementation
STDMETHODIMP_(ULONG) CDocument::XPreviewHandler::AddRef()
{
	METHOD_PROLOGUE_EX(CDocument, PreviewHandler)
	return pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CDocument::XPreviewHandler::Release()
{
	METHOD_PROLOGUE_EX(CDocument, PreviewHandler)
	return pThis->ExternalRelease();
}

STDMETHODIMP CDocument::XPreviewHandler::QueryInterface(REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX(CDocument, PreviewHandler)
	return pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP CDocument::XPreviewHandler::SetWindow(HWND hwnd, const RECT *prc)
{
	METHOD_PROLOGUE(CDocument, PreviewHandler);

	pThis->m_hWndHost = hwnd;
	if (prc != NULL)
	{
		pThis->m_rectHost = *prc;
	}
	
	return S_OK;
}

STDMETHODIMP CDocument::XPreviewHandler::SetRect(const RECT *prc)
{
	METHOD_PROLOGUE(CDocument, PreviewHandler);
	if (prc == NULL)
	{
		TRACE0("Error: IPreviewHandler::SetRect failed, because prc = NULL");
		return E_INVALIDARG;
	}

	pThis->m_rectHost = *prc;

	if (pThis->m_pPreviewFrame != NULL)
	{
		ASSERT_VALID(pThis->m_pPreviewFrame);
		pThis->m_pPreviewFrame->SetWindowPos(NULL, 0, 0, pThis->m_rectHost.Width(), pThis->m_rectHost.Height(), SWP_NOACTIVATE | SWP_NOZORDER);
		pThis->UpdateAllViews(NULL);
	}
	
	return S_OK;
}

STDMETHODIMP CDocument::XPreviewHandler::DoPreview()
{
	METHOD_PROLOGUE(CDocument, PreviewHandler);

	if (pThis->m_pStream == NULL)
	{
		TRACE0("Error: IPreviewHandler::DoPreview is called, but m_pStream is NULL.");
		return E_FAIL;
	}

	pThis->m_bEmbedded = TRUE;
	pThis->OnNewDocument();

	if (!pThis->OnCreatePreviewFrame())
	{
		return E_FAIL;
	}

	ASSERT_VALID(pThis->m_pPreviewFrame);

	HRESULT hr = S_OK;
	TRY
	{
		hr = pThis->LoadDocumentFromStream(pThis->m_pStream, pThis->m_grfMode);
	}
	CATCH_ALL(e)
	{
		DELETE_EXCEPTION(e);
		TRACE0("Error: DoPreview failed because LoadDocumentFromStream has thrown an exception.");
		hr = E_FAIL;
	}
	END_CATCH_ALL

	// release the stream immediately
	pThis->m_pStream->Release();
	pThis->m_pStream = NULL;

	if (hr != S_OK)
	{
		return hr;
	}

	CRect rectHost = pThis->m_rectHost;
	pThis->m_pPreviewFrame->SetWindowPos(NULL, rectHost.left, rectHost.top, rectHost.Width(), rectHost.Height(), SWP_NOZORDER | SWP_NOACTIVATE);

	pThis->m_pPreviewFrame->ShowWindow(SW_SHOW);
	pThis->SendInitialUpdate();

	return S_OK;
}

STDMETHODIMP CDocument::XPreviewHandler::Unload()
{
	METHOD_PROLOGUE(CDocument, PreviewHandler);
	pThis->OnRichPreviewUnload();
	return S_OK;
}

STDMETHODIMP CDocument::XPreviewHandler::SetFocus()
{
	METHOD_PROLOGUE(CDocument, PreviewHandler)

	if (pThis->m_pPreviewFrame != NULL && IsWindow(pThis->m_pPreviewFrame->GetSafeHwnd()))
	{
		ASSERT_VALID(pThis->m_pPreviewFrame);
		pThis->m_pPreviewFrame->SetFocus();
	}
	return S_OK;
}

STDMETHODIMP CDocument::XPreviewHandler::QueryFocus(HWND *phwnd)
{
	METHOD_PROLOGUE(CDocument, PreviewHandler)
	return pThis->OnPreviewHandlerQueryFocus(phwnd);
}

STDMETHODIMP CDocument::XPreviewHandler::TranslateAccelerator(MSG *pmsg)
{
	METHOD_PROLOGUE(CDocument, PreviewHandler)
	return pThis->OnPreviewHandlerTranslateAccelerator(pmsg);
}

/////////////////////////////////////////////////////////////////////////////
// IPreviewHandlerVisuals interface implementation
STDMETHODIMP_(ULONG) CDocument::XPreviewHandlerVisuals::AddRef()
{
	METHOD_PROLOGUE_EX(CDocument, PreviewHandlerVisuals)
	return pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CDocument::XPreviewHandlerVisuals::Release()
{
	METHOD_PROLOGUE_EX(CDocument, PreviewHandlerVisuals)
	return pThis->ExternalRelease();
}

STDMETHODIMP CDocument::XPreviewHandlerVisuals::QueryInterface(REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE(CDocument, PreviewHandlerVisuals)
	return pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP CDocument::XPreviewHandlerVisuals::SetBackgroundColor(COLORREF color)
{
	METHOD_PROLOGUE(CDocument, PreviewHandlerVisuals)
	pThis->m_clrRichPreviewBackColor = color;
	pThis->OnRichPreviewBackColorChanged();
	return S_OK;
}

STDMETHODIMP CDocument::XPreviewHandlerVisuals::SetFont(const LOGFONTW *plf)
{
	METHOD_PROLOGUE(CDocument, PreviewHandlerVisuals)
	if (plf == NULL)
	{
		return E_POINTER;
	}
	
	pThis->OnBeforeRichPreviewFontChanged();
	pThis->m_lfRichPreviewFont.DeleteObject();

#ifdef _UNICODE
	pThis->m_lfRichPreviewFont.CreateFontIndirect(plf);
#else
	LOGFONTA lf;
	memcpy(&lf, plf, sizeof(LOGFONTA));

	size_t  i;
	size_t	bufSize = 32;
	wcstombs_s(&i, lf.lfFaceName, bufSize, plf->lfFaceName, bufSize);
	pThis->m_lfRichPreviewFont.CreateFontIndirect(&lf);
#endif
	
	pThis->OnRichPreviewFontChanged();
	return S_OK;
}

STDMETHODIMP CDocument::XPreviewHandlerVisuals::SetTextColor(COLORREF color)
{
	METHOD_PROLOGUE(CDocument, PreviewHandlerVisuals)
	pThis->m_clrRichPreviewTextColor = color;
	pThis->OnRichPreviewTextColorChanged();
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IObjectWithSite interface implementation
STDMETHODIMP_(ULONG) CDocument::XObjectWithSite::AddRef()
{
	METHOD_PROLOGUE_EX(CDocument, ObjectWithSite)
	return pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CDocument::XObjectWithSite::Release()
{
	METHOD_PROLOGUE_EX(CDocument, ObjectWithSite)
	return pThis->ExternalRelease();
}

STDMETHODIMP CDocument::XObjectWithSite::QueryInterface(REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX(CDocument, ObjectWithSite)
	return pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP CDocument::XObjectWithSite::SetSite(IUnknown *punkSite)
{
	METHOD_PROLOGUE(CDocument, ObjectWithSite);
	pThis->m_spUnkSite = punkSite;
	//
	// Clean up old frame
	//
	if (pThis->m_pPreviewHandlerSite != NULL)
	{
		pThis->m_pPreviewHandlerSite->Release();
		pThis->m_pPreviewHandlerSite = NULL;
	}

	//
	// Get the new frame
	//
	if (pThis->m_spUnkSite)
	{
		pThis->m_spUnkSite->QueryInterface(IID_PPV_ARGS(&pThis->m_pPreviewHandlerSite));
	}

	pThis->OnRichPreviewSiteChanged();

	return S_OK;
}

STDMETHODIMP CDocument::XObjectWithSite::GetSite(REFIID riid, void **ppvSite)
{
	METHOD_PROLOGUE(CDocument, ObjectWithSite)

	ASSERT(ppvSite != NULL);
	HRESULT hRes = E_POINTER;
	if (ppvSite != NULL)
	{
		if (pThis->m_spUnkSite)
			hRes = pThis->m_spUnkSite->QueryInterface(riid, ppvSite);
		else
		{
			*ppvSite = NULL;
			hRes = E_FAIL;
		}
	}
	return hRes;
}
/////////////////////////////////////////////////////////////////////////////
// IOleWindow interface implementation
STDMETHODIMP_(ULONG) CDocument::XOleWindow::AddRef()
{
	METHOD_PROLOGUE_EX(CDocument, OleWindow)
	return pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CDocument::XOleWindow::Release()
{
	METHOD_PROLOGUE_EX(CDocument, OleWindow)
	return pThis->ExternalRelease();
}

STDMETHODIMP CDocument::XOleWindow::QueryInterface(REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX(CDocument, OleWindow);
	return pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP CDocument::XOleWindow::GetWindow(HWND *phwnd)
{
	METHOD_PROLOGUE(CDocument, OleWindow);

	HRESULT hr = E_INVALIDARG;
	if (phwnd != NULL)
	{
		*phwnd = pThis->m_hWndHost; 
		hr = S_OK;
	}

	return hr;
}

STDMETHODIMP CDocument::XOleWindow::ContextSensitiveHelp(BOOL)
{
	METHOD_PROLOGUE(CDocument, OleWindow);
	return E_NOTIMPL;
}
#endif

void CDocument::OnDrawThumbnail(CDC& dc, LPRECT lprcBounds)
{
	UNREFERENCED_PARAMETER(dc);
	UNREFERENCED_PARAMETER(lprcBounds);
}

void CDocument::ClearChunkList()
{
	m_posReadChunk = NULL;

	POSITION pos = m_lstChunks.GetHeadPosition();
	while (pos != NULL)
	{
		IFilterChunkValue* v = (IFilterChunkValue*) m_lstChunks.GetNext(pos);
		if (v != NULL)
		{
			delete v;
		}
	}

	m_lstChunks.RemoveAll();
}

BOOL CDocument::SetChunkValue(IFilterChunkValue* pValue)
{
	if (pValue == NULL || !pValue->IsValid())
	{
		return false;
	}

	POSITION pos = FindChunk(pValue->GetChunkGUID(), pValue->GetChunkPID());

	if (pos == NULL)
	{
		m_lstChunks.AddTail(pValue);
	}

	return TRUE;
}

void CDocument::BeginReadChunks()
{
	m_posReadChunk = m_lstChunks.GetHeadPosition();
}

BOOL CDocument::ReadNextChunkValue(IFilterChunkValue** ppValue)
{
	if (m_posReadChunk == NULL || ppValue == NULL)
	{
		return FALSE;
	}

	*ppValue = (IFilterChunkValue*) m_lstChunks.GetNext(m_posReadChunk);
	return TRUE;
}

void CDocument::RemoveChunk(REFCLSID guid, DWORD pid)
{
	POSITION pos = FindChunk(guid, pid);
	if (pos != NULL)
	{
		delete m_lstChunks.GetAt(pos);
		m_lstChunks.RemoveAt(pos);
	}
}

POSITION CDocument::FindChunk(REFCLSID guid, DWORD pid)
{
	POSITION value = NULL;
	POSITION pos = m_lstChunks.GetHeadPosition();
	POSITION posPrev = NULL;
	while (pos != NULL)
	{
		posPrev = pos;
		IFilterChunkValue* v = (IFilterChunkValue*) m_lstChunks.GetNext(pos);
		if (IsEqualIID(v->GetChunkGUID(), guid) && v->GetChunkPID() == pid)
		{
			value = posPrev;
			break;
		}
	}

	return value;
}

/////////////////////////////////////////////////////////////////////////////
// CDocument diagnostics

#ifdef _DEBUG
void CDocument::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	dc << "m_strTitle = " << m_strTitle;
	dc << "\nm_strPathName = " << m_strPathName;
	dc << "\nm_bModified = " << m_bModified;
	dc << "\nm_pDocTemplate = " << (void*)m_pDocTemplate;

	if (dc.GetDepth() > 0)
	{
		POSITION pos = GetFirstViewPosition();
		while (pos != NULL)
		{
			CView* pView = GetNextView(pos);
			dc << "\nwith view " << (void*)pView;
		}
	}

	dc << "\n";
}

void CDocument::AssertValid() const
{
	CObject::AssertValid();

	POSITION pos = GetFirstViewPosition();
	while (pos != NULL)
	{
		CView* pView = GetNextView(pos);
		ASSERT_VALID(pView);
	}
}
#endif //_DEBUG

IMPLEMENT_DYNAMIC(CDocument, CCmdTarget)

/////////////////////////////////////////////////////////////////////////////
CMFCFilterChunkValueImpl::CMFCFilterChunkValueImpl()
{
	Clear();
}

CMFCFilterChunkValueImpl::~CMFCFilterChunkValueImpl()
{
	// NOTE, the member m_propVariant is not a real allocated variant using CoTaskMemAlloc, so do not call PropVariantClear() on it
	Clear();
}

void CMFCFilterChunkValueImpl::Clear()
{
	m_fIsValid = false;
	ZeroMemory(&m_chunk, sizeof(m_chunk));
	PropVariantInit(&m_propVariant);
	m_strValue.Empty();
}

HRESULT CMFCFilterChunkValueImpl::GetValue(PROPVARIANT **ppPropVariant)
{
	HRESULT hr = S_OK;
	if (ppPropVariant == NULL)
		return E_INVALIDARG;

	*ppPropVariant = NULL;

	CComHeapPtr<PROPVARIANT> spPropVariant;

	// allocate a propvariant on the COM heap
	if (spPropVariant.Allocate())
	{
		// fill it with COMHeap copied data from our local non-com heap propvariant 
		hr = PropVariantCopy(spPropVariant, &m_propVariant);
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}

	if (SUCCEEDED(hr))
	{
		// detach and return this as the value
		*ppPropVariant = spPropVariant.Detach();
	}
	return hr;
}

HRESULT CMFCFilterChunkValueImpl::CopyChunk(STAT_CHUNK *pStatChunk)
{
	if (pStatChunk == NULL)
		return E_INVALIDARG;

	*pStatChunk = m_chunk;
	return S_OK;
}

HRESULT CMFCFilterChunkValueImpl::SetTextValue(REFPROPERTYKEY pkey, LPCTSTR pszValue, CHUNKSTATE chunkType /*= CHUNK_VALUE*/, LCID locale/* = 0*/,
			DWORD cwcLenSource/* = 0*/, DWORD cwcStartSource/* = 0*/, CHUNK_BREAKTYPE chunkBreakType/* = CHUNK_NO_BREAK*/)
{
	if (pszValue == NULL)
		return E_INVALIDARG;

	HRESULT hr = SetChunk(pkey, chunkType, locale, cwcLenSource, cwcStartSource, chunkBreakType);
	if (SUCCEEDED(hr))
	{
		m_strValue = pszValue;
#ifdef UNICODE
		m_propVariant.vt = VT_LPWSTR;
		m_propVariant.pwszVal = (LPWSTR)(LPCTSTR)m_strValue;
#else
		m_propVariant.vt = VT_LPSTR;
		m_propVariant.pszVal = (LPSTR)(LPCTSTR)m_strValue;
#endif
		m_fIsValid = true;
	}
	return hr;
};
HRESULT CMFCFilterChunkValueImpl::SetBoolValue(REFPROPERTYKEY pkey, BOOL bVal, CHUNKSTATE chunkType/* = CHUNK_VALUE*/, LCID locale/* = 0*/, 
			DWORD cwcLenSource/* = 0*/, DWORD cwcStartSource/* = 0*/, CHUNK_BREAKTYPE chunkBreakType/* = CHUNK_NO_BREAK*/)
{
	return SetBoolValue(pkey, bVal ? VARIANT_TRUE : VARIANT_FALSE, chunkType, locale, cwcLenSource, cwcStartSource, chunkBreakType);
};
HRESULT CMFCFilterChunkValueImpl::SetBoolValue(REFPROPERTYKEY pkey, VARIANT_BOOL bVal, CHUNKSTATE chunkType/* = CHUNK_VALUE*/, LCID locale/* = 0*/, 
			DWORD cwcLenSource/* = 0*/, DWORD cwcStartSource/* = 0*/, CHUNK_BREAKTYPE chunkBreakType/* = CHUNK_NO_BREAK*/)
{
	HRESULT hr = SetChunk(pkey, chunkType, locale, cwcLenSource, cwcStartSource, chunkBreakType);
	if (SUCCEEDED(hr))
	{
		m_propVariant.vt = VT_BOOL;
		m_propVariant.boolVal = bVal;
		m_fIsValid = true;
	}
	return hr;
};

HRESULT CMFCFilterChunkValueImpl::SetIntValue(REFPROPERTYKEY pkey, int nVal, CHUNKSTATE chunkType/* = CHUNK_VALUE*/, LCID locale/* = 0*/,
			DWORD cwcLenSource/* = 0*/, DWORD cwcStartSource/* = 0*/, CHUNK_BREAKTYPE chunkBreakType/* = CHUNK_NO_BREAK*/)
{
	HRESULT hr = SetChunk(pkey, chunkType, locale, cwcLenSource, cwcStartSource, chunkBreakType);
	if (SUCCEEDED(hr))
	{
		m_propVariant.vt = VT_I4;
		m_propVariant.lVal = nVal;
		m_fIsValid = true;
	}
	return hr;
};

HRESULT CMFCFilterChunkValueImpl::SetLongValue(REFPROPERTYKEY pkey, long lVal, CHUNKSTATE chunkType/* = CHUNK_VALUE*/, LCID locale/* = 0*/, 
			DWORD cwcLenSource/* = 0*/, DWORD cwcStartSource/* = 0*/, CHUNK_BREAKTYPE chunkBreakType/* = CHUNK_NO_BREAK*/)
{
	HRESULT hr = SetChunk(pkey, chunkType, locale, cwcLenSource, cwcStartSource, chunkBreakType);
	if (SUCCEEDED(hr))
	{
		m_propVariant.vt = VT_I4;
		m_propVariant.lVal = lVal;
		m_fIsValid = true;
	}
	return hr;
};

HRESULT CMFCFilterChunkValueImpl::SetDwordValue(REFPROPERTYKEY pkey, DWORD dwVal, CHUNKSTATE chunkType/* = CHUNK_VALUE*/, LCID locale/* = 0*/, 
			DWORD cwcLenSource/* = 0*/, DWORD cwcStartSource/* = 0*/, CHUNK_BREAKTYPE chunkBreakType/* = CHUNK_NO_BREAK*/)
{
	HRESULT hr = SetChunk(pkey, chunkType, locale, cwcLenSource, cwcStartSource, chunkBreakType);
	if (SUCCEEDED(hr))
	{
		m_propVariant.vt = VT_UI4;
		m_propVariant.ulVal = dwVal;
		m_fIsValid = true;
	}
	return hr;
};

HRESULT CMFCFilterChunkValueImpl::SetInt64Value(REFPROPERTYKEY pkey, __int64 nVal, CHUNKSTATE chunkType/* = CHUNK_VALUE*/, LCID locale/* = 0*/, 
			DWORD cwcLenSource/* = 0*/, DWORD cwcStartSource/* = 0*/, CHUNK_BREAKTYPE chunkBreakType/* = CHUNK_NO_BREAK*/)
{
	HRESULT hr = SetChunk(pkey, chunkType, locale, cwcLenSource, cwcStartSource, chunkBreakType);
	if (SUCCEEDED(hr))
	{
		m_propVariant.vt = VT_I8;
		m_propVariant.hVal.QuadPart = nVal;
		m_fIsValid = true;
	}
	return hr;
};

HRESULT CMFCFilterChunkValueImpl::SetSystemTimeValue(REFPROPERTYKEY pkey, const SYSTEMTIME &systemTime, CHUNKSTATE chunkType/* = CHUNK_VALUE*/, LCID locale/* = 0*/,
			DWORD cwcLenSource/* = 0*/, DWORD cwcStartSource/* = 0*/, CHUNK_BREAKTYPE chunkBreakType/* = CHUNK_NO_BREAK*/)
{
	HRESULT hr = SetChunk(pkey, chunkType, locale, cwcLenSource, cwcStartSource, chunkBreakType);
	if (SUCCEEDED(hr))
	{
		m_propVariant.vt = VT_FILETIME;
		SystemTimeToFileTime(&systemTime, &m_propVariant.filetime);
		m_fIsValid = true;
	}
	return hr;
};

HRESULT CMFCFilterChunkValueImpl::SetFileTimeValue(REFPROPERTYKEY pkey, FILETIME dtVal, CHUNKSTATE chunkType/* = CHUNK_VALUE*/, LCID locale/* = 0*/,
			DWORD cwcLenSource/* = 0*/, DWORD cwcStartSource/* = 0*/, CHUNK_BREAKTYPE chunkBreakType/* = CHUNK_NO_BREAK*/)
{
	HRESULT hr = SetChunk(pkey, chunkType, locale, cwcLenSource, cwcStartSource, chunkBreakType);
	if (SUCCEEDED(hr))
	{
		m_propVariant.vt = VT_FILETIME;
		m_propVariant.filetime = dtVal;
		m_fIsValid = true;
	}
	return hr;
};

HRESULT CMFCFilterChunkValueImpl::SetChunk(REFPROPERTYKEY pkey, CHUNKSTATE chunkType/*=CHUNK_VALUE*/, LCID locale /*=0*/, 
			DWORD cwcLenSource /*=0*/, DWORD cwcStartSource /*=0*/, CHUNK_BREAKTYPE chunkBreakType /*= CHUNK_NO_BREAK */)
{
	Clear();

	// initialize the chunk
	m_chunk.attribute.psProperty.ulKind = PRSPEC_PROPID;
	m_chunk.attribute.psProperty.propid = pkey.pid;
	m_chunk.attribute.guidPropSet = pkey.fmtid;
	m_chunk.flags = chunkType;
	m_chunk.locale = locale == 0 ? GetUserDefaultLCID() : locale;
	m_chunk.cwcLenSource = cwcLenSource;
	m_chunk.cwcStartSource = cwcStartSource;
	m_chunk.breakType = chunkBreakType;

	return S_OK;
}

void CMFCFilterChunkValueImpl::CopyFrom(IFilterChunkValue* pValue)
{
	Clear();

	pValue->CopyChunk(&m_chunk);

	// NOTE this object does not contain a real property variant that was allocated with CoTaskMemAlloc
	m_propVariant = pValue->GetValueNoAlloc();
	m_strValue = pValue->GetString();

	// fix up the string ownership to member
#ifdef UNICODE	
	if (m_propVariant.vt == VT_LPWSTR)
	{
		m_propVariant.pwszVal = (LPWSTR)(LPCTSTR)m_strValue;
	}
#else
	if (m_propVariant.vt == VT_LPSTR)
	{
		m_propVariant.pszVal = (LPSTR)(LPCTSTR)m_strValue;
	}
#endif
	else if (m_propVariant.vt & VT_VECTOR)
	{
	}

	m_fIsValid = pValue->IsValid();

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\dockcont.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

#define HORZF(dw) (dw & CBRS_ORIENT_HORZ)
#define VERTF(dw) (dw & CBRS_ORIENT_VERT)

AFX_STATIC void AFXAPI _AfxAdjustRectangle(CRect& rect, CPoint pt)
{
	int nXOffset = (pt.x < rect.left) ? (pt.x - rect.left) :
					(pt.x > rect.right) ? (pt.x - rect.right) : 0;
	int nYOffset = (pt.y < rect.top) ? (pt.y - rect.top) :
					(pt.y > rect.bottom) ? (pt.y - rect.bottom) : 0;
	rect.OffsetRect(nXOffset, nYOffset);
}

/////////////////////////////////////////////////////////////////////////////
// CDockContext

CDockContext::CDockContext(CControlBar* pBar)
{
	ASSERT(pBar != NULL);
	ASSERT(pBar->m_pDockSite != NULL);

	m_pBar = pBar;
	m_pDockSite = pBar->m_pDockSite;

	m_uMRUDockID = 0;
	m_rectMRUDockPos.left = 0;
	m_rectMRUDockPos.top = 0;
	if (pBar->m_dwStyle & CBRS_SIZE_DYNAMIC)
		m_dwMRUFloatStyle = pBar->m_dwStyle & (CBRS_ALIGN_TOP | CBRS_SIZE_DYNAMIC);
	else if (pBar->m_dwStyle & CBRS_ORIENT_HORZ)
		m_dwMRUFloatStyle = CBRS_ALIGN_TOP | (pBar->m_dwStyle & CBRS_FLOAT_MULTI);
	else
		m_dwMRUFloatStyle = CBRS_ALIGN_LEFT | (pBar->m_dwStyle & CBRS_FLOAT_MULTI);
	m_ptMRUFloatPos.x = CW_USEDEFAULT;

	ASSERT(m_pDockSite->IsFrameWnd());
	m_pDC = NULL;
}

CDockContext::~CDockContext()
{
	AFX_BEGIN_DESTRUCTOR

		ASSERT(m_pBar != NULL);
		if (m_pBar->m_pDockBar != NULL)
			m_pBar->m_pDockBar->RemoveControlBar(m_pBar, -1, FALSE);

	AFX_END_DESTRUCTOR
}

/////////////////////////////////////////////////////////////////////////////
// CDockContext Drag Operations

void CDockContext::StartDrag(CPoint pt)
{
	ASSERT_VALID(m_pBar);
	m_bDragging = TRUE;

	InitLoop();

	// GetWindowRect returns screen coordinates(not mirrored),
	// so if the desktop is mirrored then turn off mirroring
	// for the desktop dc so that we get correct focus rect drawn.
	// This layout change should be remembered, just in case ...

	if (m_pDC->GetLayout() & LAYOUT_RTL)
		m_pDC->SetLayout(LAYOUT_LTR);

	if (m_pBar->m_dwStyle & CBRS_SIZE_DYNAMIC)
	{
		// get true bar size (including borders)
		CRect rect;
		m_pBar->GetWindowRect(rect);
		m_ptLast = pt;
		CSize sizeHorz = m_pBar->CalcDynamicLayout(0, LM_HORZ | LM_HORZDOCK);
		CSize sizeVert = m_pBar->CalcDynamicLayout(0, LM_VERTDOCK);
		CSize sizeFloat = m_pBar->CalcDynamicLayout(0, LM_HORZ | LM_MRUWIDTH);

		m_rectDragHorz = CRect(rect.TopLeft(), sizeHorz);
		m_rectDragVert = CRect(rect.TopLeft(), sizeVert);

		// calculate frame dragging rectangle
		m_rectFrameDragHorz = CRect(rect.TopLeft(), sizeFloat);
		m_rectFrameDragVert = CRect(rect.TopLeft(), sizeFloat);

		CMiniFrameWnd::CalcBorders(&m_rectFrameDragHorz);
		CMiniFrameWnd::CalcBorders(&m_rectFrameDragVert);

		m_rectFrameDragHorz.InflateRect(-afxData.cxBorder2, -afxData.cyBorder2);
		m_rectFrameDragVert.InflateRect(-afxData.cxBorder2, -afxData.cyBorder2);
	}
	else if (m_pBar->m_dwStyle & CBRS_SIZE_FIXED)
	{
		// get true bar size (including borders)
		CRect rect;
		m_pBar->GetWindowRect(rect);
		m_ptLast = pt;
		CSize sizeHorz = m_pBar->CalcDynamicLayout(-1, LM_HORZ | LM_HORZDOCK);
		CSize sizeVert = m_pBar->CalcDynamicLayout(-1, LM_VERTDOCK);

		// calculate frame dragging rectangle
		m_rectFrameDragHorz = m_rectDragHorz = CRect(rect.TopLeft(), sizeHorz);
		m_rectFrameDragVert = m_rectDragVert = CRect(rect.TopLeft(), sizeVert);

		CMiniFrameWnd::CalcBorders(&m_rectFrameDragHorz);
		CMiniFrameWnd::CalcBorders(&m_rectFrameDragVert);
		m_rectFrameDragHorz.InflateRect(-afxData.cxBorder2, -afxData.cyBorder2);
		m_rectFrameDragVert.InflateRect(-afxData.cxBorder2, -afxData.cyBorder2);
	}
	else
	{
		// get true bar size (including borders)
		CRect rect;
		m_pBar->GetWindowRect(rect);
		m_ptLast = pt;
		BOOL bHorz = HORZF(m_dwStyle);
		DWORD dwMode = !bHorz ? (LM_HORZ | LM_HORZDOCK) : LM_VERTDOCK;
		CSize size = m_pBar->CalcDynamicLayout(-1, dwMode);

		// calculate inverted dragging rect
		if (bHorz)
		{
			m_rectDragHorz = rect;
			m_rectDragVert = CRect(CPoint(pt.x - rect.Height()/2, rect.top), size);
		}
		else // vertical orientation
		{
			m_rectDragVert = rect;
			m_rectDragHorz = CRect(CPoint(rect.left, pt.y - rect.Width()/2), size);
		}

		// calculate frame dragging rectangle
		m_rectFrameDragHorz = m_rectDragHorz;
		m_rectFrameDragVert = m_rectDragVert;

		CMiniFrameWnd::CalcBorders(&m_rectFrameDragHorz);
		CMiniFrameWnd::CalcBorders(&m_rectFrameDragVert);
		m_rectFrameDragHorz.InflateRect(-afxData.cxBorder2, -afxData.cyBorder2);
		m_rectFrameDragVert.InflateRect(-afxData.cxBorder2, -afxData.cyBorder2);
	}

	// adjust rectangles so that point is inside
	_AfxAdjustRectangle(m_rectDragHorz, pt);
	_AfxAdjustRectangle(m_rectDragVert, pt);
	_AfxAdjustRectangle(m_rectFrameDragHorz, pt);
	_AfxAdjustRectangle(m_rectFrameDragVert, pt);

	// initialize tracking state and enter tracking loop
	m_dwOverDockStyle = CanDock();
	Move(pt);   // call it here to handle special keys
	Track();
}

void CDockContext::Move(CPoint pt)
{
	CPoint ptOffset = pt - m_ptLast;

	// offset all drag rects to new position
	m_rectDragHorz.OffsetRect(ptOffset);
	m_rectFrameDragHorz.OffsetRect(ptOffset);
	m_rectDragVert.OffsetRect(ptOffset);
	m_rectFrameDragVert.OffsetRect(ptOffset);
	m_ptLast = pt;

	// if control key is down don't dock
	m_dwOverDockStyle = m_bForceFrame ? 0 : CanDock();

	// update feedback
	DrawFocusRect();
}

void CDockContext::OnKey(int nChar, BOOL bDown)
{
	if (nChar == VK_CONTROL)
		UpdateState(&m_bForceFrame, bDown);
	if (nChar == VK_SHIFT)
		UpdateState(&m_bFlip, bDown);
}

void CDockContext::EndDrag()
{
	CancelLoop();

	if (m_dwOverDockStyle != 0)
	{
		CDockBar* pDockBar = GetDockBar(m_dwOverDockStyle);
		ASSERT(pDockBar != NULL);

		CRect rect = (m_dwOverDockStyle & CBRS_ORIENT_VERT) ?
			m_rectDragVert : m_rectDragHorz;

		UINT uID = _AfxGetDlgCtrlID(pDockBar->m_hWnd);
		if (uID >= AFX_IDW_DOCKBAR_TOP &&
			uID <= AFX_IDW_DOCKBAR_BOTTOM)
		{
			m_uMRUDockID = uID;
			m_rectMRUDockPos = rect;
			pDockBar->ScreenToClient(&m_rectMRUDockPos);
		}

		// dock it at the specified position, RecalcLayout will snap
		m_pDockSite->DockControlBar(m_pBar, pDockBar, &rect);
		m_pDockSite->RecalcLayout();
	}
	else if ((m_dwStyle & CBRS_SIZE_DYNAMIC) || (HORZF(m_dwStyle) && !m_bFlip) ||
			(VERTF(m_dwStyle) && m_bFlip))
	{
		m_dwMRUFloatStyle = CBRS_ALIGN_TOP | (m_dwDockStyle & CBRS_FLOAT_MULTI);
		m_ptMRUFloatPos = m_rectFrameDragHorz.TopLeft();
		m_pDockSite->FloatControlBar(m_pBar, m_ptMRUFloatPos, m_dwMRUFloatStyle);
	}
	else // vertical float
	{
		m_dwMRUFloatStyle = CBRS_ALIGN_LEFT | (m_dwDockStyle & CBRS_FLOAT_MULTI);
		m_ptMRUFloatPos = m_rectFrameDragVert.TopLeft();
		m_pDockSite->FloatControlBar(m_pBar, m_ptMRUFloatPos, m_dwMRUFloatStyle);
	}
}

/////////////////////////////////////////////////////////////////////////////
// CDockContext Resize Operations

#define m_rectRequestedSize     m_rectDragHorz
#define m_rectActualSize        m_rectDragVert
#define m_rectActualFrameSize   m_rectFrameDragHorz
#define m_rectFrameBorders      m_rectFrameDragVert

void CDockContext::StartResize(int nHitTest, CPoint pt)
{
	ASSERT_VALID(m_pBar);
	ASSERT(m_pBar->m_dwStyle & CBRS_SIZE_DYNAMIC);
	m_bDragging = FALSE;

	InitLoop();

	// GetWindowRect returns screen coordinates(not mirrored)
	// So if the desktop is mirrored then turn off mirroring
	// for the desktop dc so that we draw correct focus rect 

	if (m_pDC->GetLayout() & LAYOUT_RTL)
		m_pDC->SetLayout(LAYOUT_LTR);

	// get true bar size (including borders)
	CRect rect;
	m_pBar->GetWindowRect(rect);
	m_ptLast = pt;
	m_nHitTest = nHitTest;

	CSize size = m_pBar->CalcDynamicLayout(0, LM_HORZ | LM_MRUWIDTH);
	m_rectRequestedSize = CRect(rect.TopLeft(), size);
	m_rectActualSize = CRect(rect.TopLeft(), size);
	m_rectActualFrameSize = CRect(rect.TopLeft(), size);

	// calculate frame rectangle
	CMiniFrameWnd::CalcBorders(&m_rectActualFrameSize);
	m_rectActualFrameSize.InflateRect(-afxData.cxBorder2, -afxData.cyBorder2);

	m_rectFrameBorders = CRect(CPoint(0,0),
		m_rectActualFrameSize.Size() - m_rectActualSize.Size());

	// initialize tracking state and enter tracking loop
	m_dwOverDockStyle = 0;
	Stretch(pt);   // call it here to handle special keys
	Track();
}

void CDockContext::Stretch(CPoint pt)
{
	CPoint ptOffset = pt - m_ptLast;

	// offset all drag rects to new position
	int nLength = 0;
	DWORD dwMode = LM_HORZ;
	if (m_nHitTest == HTLEFT || m_nHitTest == HTRIGHT)
	{
		if (m_nHitTest == HTLEFT)
			m_rectRequestedSize.left += ptOffset.x;
		else
			m_rectRequestedSize.right += ptOffset.x;
		nLength = m_rectRequestedSize.Width();
	}
	else
	{
		dwMode |= LM_LENGTHY;
		if (m_nHitTest == HTTOP)
			m_rectRequestedSize.top += ptOffset.y;
		else
			m_rectRequestedSize.bottom += ptOffset.y;
		nLength = m_rectRequestedSize.Height();
	}
	nLength = (nLength >= 0) ? nLength : 0;

	CSize size = m_pBar->CalcDynamicLayout(nLength, dwMode);

	CRect rectDesk;
	rectDesk.left=GetSystemMetrics(SM_XVIRTUALSCREEN);
	rectDesk.top=GetSystemMetrics(SM_YVIRTUALSCREEN);
	rectDesk.right=rectDesk.left+GetSystemMetrics(SM_CXVIRTUALSCREEN);
	rectDesk.bottom=rectDesk.top+GetSystemMetrics(SM_CYVIRTUALSCREEN);
	CRect rectTemp = m_rectActualFrameSize;

	if (m_nHitTest == HTLEFT || m_nHitTest == HTTOP)
	{
		rectTemp.left = rectTemp.right -
			(size.cx + m_rectFrameBorders.Width());
		rectTemp.top = rectTemp.bottom -
			(size.cy + m_rectFrameBorders.Height());
		CRect rect;
		if (rect.IntersectRect(rectDesk, rectTemp))
		{
			m_rectActualSize.left = m_rectActualSize.right - size.cx;
			m_rectActualSize.top = m_rectActualSize.bottom - size.cy;
			m_rectActualFrameSize.left = rectTemp.left;
			m_rectActualFrameSize.top = rectTemp.top;
		}
	}
	else
	{
		rectTemp.right = rectTemp.left +
			(size.cx + m_rectFrameBorders.Width());
		rectTemp.bottom = rectTemp.top +
			(size.cy + m_rectFrameBorders.Height());
		CRect rect;
		if (rect.IntersectRect(rectDesk, rectTemp))
		{
			m_rectActualSize.right = m_rectActualSize.left + size.cx;
			m_rectActualSize.bottom = m_rectActualSize.top + size.cy;
			m_rectActualFrameSize.right = rectTemp.right;
			m_rectActualFrameSize.bottom = rectTemp.bottom;
		}
	}
	m_ptLast = pt;

	// update feedback
	DrawFocusRect();
}

void CDockContext::EndResize()
{
	CancelLoop();

	m_pBar->CalcDynamicLayout(m_rectActualSize.Width(), LM_HORZ | LM_COMMIT);
	m_pDockSite->FloatControlBar(m_pBar, m_rectActualFrameSize.TopLeft(),
		CBRS_ALIGN_TOP | (m_dwDockStyle & CBRS_FLOAT_MULTI) | CBRS_SIZE_DYNAMIC);
}

/////////////////////////////////////////////////////////////////////////////
// CDockContext Double Click Operations

void CDockContext::ToggleDocking()
{
	if (m_pBar->IsFloating())
	{
		// Dock it only if is allowed to be docked
		if (m_pBar->m_dwDockStyle & CBRS_ALIGN_ANY)
		{
			ASSERT((m_uMRUDockID >= AFX_IDW_DOCKBAR_TOP &&
				m_uMRUDockID <= AFX_IDW_DOCKBAR_BOTTOM) ||
				m_uMRUDockID == 0);

			CRect rect = m_rectMRUDockPos;
			CDockBar* pDockBar = NULL;
			if (m_uMRUDockID != 0)
			{
				pDockBar = (CDockBar*)m_pDockSite->GetControlBar(m_uMRUDockID);
                ENSURE(pDockBar);
				pDockBar->ClientToScreen(&rect);
			}

			// dock it at the specified position, RecalcLayout will snap
			m_pDockSite->ReDockControlBar(m_pBar, pDockBar, &rect);
			m_pDockSite->RecalcLayout();
		}
	}
	else
	{
		CPoint ptFloat = m_ptMRUFloatPos;
		if (ptFloat.x < 0 || ptFloat.y < 0)
		{
			ptFloat = m_rectMRUDockPos.TopLeft();
			m_pBar->GetParent()->ClientToScreen(&ptFloat);
		}
		m_pDockSite->FloatControlBar(m_pBar, ptFloat, m_dwMRUFloatStyle);
	}
}

/////////////////////////////////////////////////////////////////////////////
// CDockContext Operations

void CDockContext::InitLoop()
{
	// handle pending WM_PAINT messages
	MSG msg;
	while (::PeekMessage(&msg, NULL, WM_PAINT, WM_PAINT, PM_NOREMOVE))
	{
		if (!GetMessage(&msg, NULL, WM_PAINT, WM_PAINT))
			return;
		DispatchMessage(&msg);
	}

	// get styles from bar
	m_dwDockStyle = m_pBar->m_dwDockStyle;
	m_dwStyle = m_pBar->m_dwStyle & CBRS_ALIGN_ANY;
	ASSERT(m_dwStyle != 0);

	// initialize state
	m_rectLast.SetRectEmpty();
	m_sizeLast.cx = m_sizeLast.cy = 0;
	m_bForceFrame = m_bFlip = m_bDitherLast = FALSE;

	// lock window update while dragging
	ASSERT(m_pDC == NULL);
	CWnd* pWnd = CWnd::GetDesktopWindow();
	if (pWnd->LockWindowUpdate())
		m_pDC = pWnd->GetDCEx(NULL, DCX_WINDOW|DCX_CACHE|DCX_LOCKWINDOWUPDATE);
	else
		m_pDC = pWnd->GetDCEx(NULL, DCX_WINDOW|DCX_CACHE);
	ASSERT(m_pDC != NULL);
}

void CDockContext::CancelLoop()
{
	DrawFocusRect(TRUE);    // gets rid of focus rect
	ReleaseCapture();

	CWnd* pWnd = CWnd::GetDesktopWindow();
	pWnd->UnlockWindowUpdate();
	if (m_pDC != NULL)
	{
		pWnd->ReleaseDC(m_pDC);
		m_pDC = NULL;
	}
}

/////////////////////////////////////////////////////////////////////////////
// Implementation

void CDockContext::DrawFocusRect(BOOL bRemoveRect)
{
	ASSERT(m_pDC != NULL);

	// default to thin frame
	CSize size(AFX_CX_BORDER, AFX_CY_BORDER);

	// determine new rect and size
	CRect rect;
	CBrush* pWhiteBrush = CBrush::FromHandle((HBRUSH)::GetStockObject(WHITE_BRUSH));
	CBrush* pDitherBrush = CDC::GetHalftoneBrush();
	CBrush* pBrush = pWhiteBrush;

	if (HORZF(m_dwOverDockStyle))
		rect = m_rectDragHorz;
	else if (VERTF(m_dwOverDockStyle))
		rect = m_rectDragVert;
	else
	{
		// use thick frame instead
		size.cx = GetSystemMetrics(SM_CXFRAME) - AFX_CX_BORDER;
		size.cy = GetSystemMetrics(SM_CYFRAME) - AFX_CY_BORDER;
		if ((HORZF(m_dwStyle) && !m_bFlip) || (VERTF(m_dwStyle) && m_bFlip))
			rect = m_rectFrameDragHorz;
		else
			rect = m_rectFrameDragVert;
		pBrush = pDitherBrush;
	}
	if (bRemoveRect)
		size.cx = size.cy = 0;

	if ((HORZF(m_dwOverDockStyle) || VERTF(m_dwOverDockStyle)))
	{
		// looks better one pixel in (makes the bar look pushed down)
		rect.InflateRect(-AFX_CX_BORDER, -AFX_CY_BORDER);
	}

	// draw it and remember last size
	m_pDC->DrawDragRect(&rect, size, &m_rectLast, m_sizeLast,
		pBrush, m_bDitherLast ? pDitherBrush : pWhiteBrush);
	m_rectLast = rect;
	m_sizeLast = size;
	m_bDitherLast = (pBrush == pDitherBrush);
}

void CDockContext::UpdateState(BOOL* pFlag, BOOL bNewValue)
{
	if (*pFlag != bNewValue)
	{
		*pFlag = bNewValue;
		m_bFlip = (HORZF(m_dwDockStyle) && VERTF(m_dwDockStyle) && m_bFlip); // shift key
		m_dwOverDockStyle = (m_bForceFrame) ? 0 : CanDock();
		DrawFocusRect();
	}
}

DWORD CDockContext::CanDock()
{
	BOOL bStyleHorz;
	DWORD dwDock = 0; // Dock Canidate
	DWORD dwCurr = 0; // Current Orientation

	// let's check for something in our current orientation first
	// then if the shift key is not forcing our orientation then
	// check for horizontal or vertical orientations as long
	// as we are close enough
	ASSERT(m_dwStyle != 0);

	bStyleHorz = HORZF(m_dwStyle);
	bStyleHorz = m_bFlip ? !bStyleHorz : bStyleHorz;

	if (bStyleHorz && HORZF(m_dwDockStyle))
		dwDock = m_pDockSite->CanDock(m_rectDragHorz,
									  m_dwDockStyle & ~CBRS_ORIENT_VERT);
	else if (VERTF(m_dwDockStyle))
		dwDock = m_pDockSite->CanDock(m_rectDragVert,
									  m_dwDockStyle & ~CBRS_ORIENT_HORZ);

	if (!m_bFlip)
	{
		if (dwDock == 0 && HORZF(m_dwDockStyle))
		{
			dwCurr = m_pDockSite->CanDock(m_rectDragVert,
										  m_dwDockStyle & ~CBRS_ORIENT_VERT);
			dwDock = m_pDockSite->CanDock(m_rectDragHorz,
										  m_dwDockStyle & ~CBRS_ORIENT_VERT);
			dwDock = (dwDock == dwCurr) ? dwDock : 0;
		}
		if (dwDock == 0 && VERTF(m_dwDockStyle))
		{
			dwCurr = m_pDockSite->CanDock(m_rectDragHorz,
										  m_dwDockStyle & ~CBRS_ORIENT_HORZ);
			dwDock = m_pDockSite->CanDock(m_rectDragVert,
										  m_dwDockStyle & ~CBRS_ORIENT_HORZ);
			dwDock = (dwDock == dwCurr) ? dwDock : 0;
		}
	}

	return dwDock;
}

CDockBar* CDockContext::GetDockBar(DWORD dwOverDockStyle)
{
	DWORD dw = 0;
	CDockBar* pBar;
	if (HORZF(dwOverDockStyle))
	{
		dw = m_pDockSite->CanDock(m_rectDragHorz,
			dwOverDockStyle & ~CBRS_ORIENT_VERT, &pBar);
		ASSERT(dw != 0);
		ASSERT(pBar != NULL);
		return pBar;
	}
	if (VERTF(dwOverDockStyle))
	{
		dw = m_pDockSite->CanDock(m_rectDragVert,
			dwOverDockStyle & ~CBRS_ORIENT_HORZ, &pBar);
		ASSERT(dw != 0);
		ASSERT(pBar != NULL);
		return pBar;
	}
	return NULL;
}

BOOL CDockContext::Track()
{
	// don't handle if capture already set
	if (::GetCapture() != NULL)
		return FALSE;

	// set capture to the window which received this message
	m_pBar->SetCapture();
	ASSERT(m_pBar == CWnd::GetCapture());

	// get messages until capture lost or cancelled/accepted
	while (CWnd::GetCapture() == m_pBar)
	{
		MSG msg;
		if (!::GetMessage(&msg, NULL, 0, 0))
		{
			AfxPostQuitMessage((int)msg.wParam);
			break;
		}

		switch (msg.message)
		{
		case WM_LBUTTONUP:
			if (m_bDragging)
				EndDrag();
			else
				EndResize();
			return TRUE;
		case WM_MOUSEMOVE:
			if (m_bDragging)
				Move(msg.pt);
			else
				Stretch(msg.pt);
			break;
		case WM_KEYUP:
			if (m_bDragging)
				OnKey((int)msg.wParam, FALSE);
			break;
		case WM_KEYDOWN:
			if (m_bDragging)
				OnKey((int)msg.wParam, TRUE);
			if (msg.wParam == VK_ESCAPE)
			{
				CancelLoop();
				return FALSE;
			}
			break;
		case WM_RBUTTONDOWN:
			CancelLoop();
			return FALSE;

		// just dispatch rest of the messages
		default:
			DispatchMessage(&msg);
			break;
		}
	}

	CancelLoop();

	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\dlgprop.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "occimpl.h"



#define new DEBUG_NEW
const TCHAR*  PROP_CLOSEPENDING_NAME = _T("AfxClosePending");

////////////////////////////////////////////////////////////////////////////
// CPropertyPage -- one page of a tabbed dialog

UINT CALLBACK
AfxPropPageCallback(HWND, UINT message, PROPSHEETPAGE* pPropPage)
{
	switch (message)
	{
	case PSPCB_CREATE:
		{
			ASSERT(AfxIsValidAddress(pPropPage, pPropPage->dwSize));
			CPropertyPage* pPage =
				STATIC_DOWNCAST(CPropertyPage, (CObject*)pPropPage->lParam);
			ASSERT_VALID(pPage);
			TRY
			{
				AfxHookWindowCreate(pPage);
			}
			CATCH_ALL(e)
			{
				// Note: DELETE_EXCEPTION(e) not necessary
				return FALSE;
			}
			END_CATCH_ALL
		}
		return TRUE;

	case PSPCB_RELEASE:
		AfxUnhookWindowCreate();
		break;
	}

	return 0;
}

BEGIN_MESSAGE_MAP(CPropertyPage, CDialog)
	//{{AFX_MSG_MAP(CPropertyPage)
	ON_WM_CTLCOLOR()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


const PROPSHEETPAGE& CPropertyPage::GetPSP() const
{
	return *m_pPSP;
}

PROPSHEETPAGE& CPropertyPage::GetPSP()
{
	return *m_pPSP;
}

void CPropertyPage::AllocPSP(DWORD dwSize)
{
	if (dwSize == 0)
	{
		dwSize = sizeof(PROPSHEETPAGE);
	}

	// size of PROPSHEETPAGE must be at least version 4
	ASSERT(dwSize >= PROPSHEETPAGE_V2_SIZE);
	// allocate memory for PROPSHEETPAGE struct based on size passed in
	m_pPSP = static_cast<LPPROPSHEETPAGE>(malloc(dwSize));
	ASSERT(m_pPSP != NULL);
	if (m_pPSP == NULL)
		AfxThrowMemoryException();

	memset(m_pPSP,0,dwSize);
	m_pPSP->dwSize = dwSize;
}

// simple construction

CPropertyPage::CPropertyPage(UINT nIDTemplate, UINT nIDCaption, DWORD dwSize)
{
	ASSERT(nIDTemplate != 0);
	AllocPSP(dwSize);
	CommonConstruct(MAKEINTRESOURCE(nIDTemplate), nIDCaption);
}

CPropertyPage::CPropertyPage(LPCTSTR lpszTemplateName, UINT nIDCaption, DWORD dwSize)
{
	ENSURE_ARG(AfxIsValidString(lpszTemplateName));
	AllocPSP(dwSize);
	CommonConstruct(lpszTemplateName, nIDCaption);
}

void CPropertyPage::Construct(UINT nIDTemplate, UINT nIDCaption)
{
	ASSERT(nIDTemplate != 0);
	CommonConstruct(MAKEINTRESOURCE(nIDTemplate), nIDCaption);
}

void CPropertyPage::Construct(LPCTSTR lpszTemplateName, UINT nIDCaption)
{
	ENSURE_ARG(IS_INTRESOURCE(lpszTemplateName) ||
		AfxIsValidString(lpszTemplateName));
	CommonConstruct(lpszTemplateName, nIDCaption);
}

CPropertyPage::CPropertyPage()
{
	AllocPSP(0);
	CommonConstruct(NULL, 0);
}

void CPropertyPage::CommonConstruct(LPCTSTR lpszTemplateName, UINT nIDCaption)
{
	m_psp.dwFlags = PSP_USECALLBACK;
	if (lpszTemplateName != NULL)
		m_psp.hInstance = AfxFindResourceHandle(lpszTemplateName, RT_DIALOG);
	m_psp.pszTemplate = lpszTemplateName;
	m_psp.pfnDlgProc = AfxDlgProc;
	m_psp.lParam = (LPARAM)this;
	m_psp.pfnCallback = AfxPropPageCallback;
	if (nIDCaption != 0)
	{
		ENSURE(m_strCaption.LoadString(nIDCaption));
		m_psp.pszTitle = m_strCaption;
		m_psp.dwFlags |= PSP_USETITLE;
	}
	if (AfxHelpEnabled())
		m_psp.dwFlags |= PSP_HASHELP;
	if (IS_INTRESOURCE(lpszTemplateName))
		m_nIDHelp = LOWORD((DWORD_PTR)lpszTemplateName);
	m_lpszTemplateName = m_psp.pszTemplate;
	m_bFirstSetActive = TRUE;
}

CPropertyPage::CPropertyPage(UINT nIDTemplate, UINT nIDCaption, UINT nIDHeaderTitle, UINT nIDHeaderSubTitle, DWORD dwSize)
{
	ASSERT(nIDTemplate != 0);
	AllocPSP(dwSize);
	CommonConstruct(MAKEINTRESOURCE(nIDTemplate), nIDCaption, nIDHeaderTitle, nIDHeaderSubTitle);
}

CPropertyPage::CPropertyPage(LPCTSTR lpszTemplateName, UINT nIDCaption, UINT nIDHeaderTitle, UINT nIDHeaderSubTitle, DWORD dwSize)
{
	ASSERT(AfxIsValidString(lpszTemplateName));
	AllocPSP(dwSize);
	CommonConstruct(lpszTemplateName, nIDCaption, nIDHeaderTitle, nIDHeaderSubTitle);
}

void CPropertyPage::Construct(UINT nIDTemplate, UINT nIDCaption, UINT nIDHeaderTitle, UINT nIDHeaderSubTitle)
{
	ASSERT(nIDTemplate != 0);
	CommonConstruct(MAKEINTRESOURCE(nIDTemplate), nIDCaption, nIDHeaderTitle, nIDHeaderSubTitle);
}

void CPropertyPage::Construct(LPCTSTR lpszTemplateName, UINT nIDCaption, UINT nIDHeaderTitle, UINT nIDHeaderSubTitle)
{
	ENSURE_ARG(HIWORD(lpszTemplateName) == 0 ||
		AfxIsValidString(lpszTemplateName));
	CommonConstruct(lpszTemplateName, nIDCaption, nIDHeaderTitle, nIDHeaderSubTitle);
}

void CPropertyPage::CommonConstruct(LPCTSTR lpszTemplateName, UINT nIDCaption, UINT nIDHeaderTitle, UINT nIDHeaderSubTitle)
{
	CommonConstruct(lpszTemplateName, nIDCaption);

	if (nIDHeaderTitle != 0)
	{
		ENSURE(m_strHeaderTitle.LoadString(nIDHeaderTitle));
	}

	if (nIDHeaderSubTitle != 0)
	{
		ENSURE(m_strHeaderSubTitle.LoadString(nIDHeaderSubTitle));
	}
}


CPropertyPage::~CPropertyPage()
{
	free(m_pPSP);
#ifndef _AFX_NO_OCC_SUPPORT
	Cleanup();
#endif

	if (m_hDialogTemplate != NULL)
		GlobalFree(m_hDialogTemplate);
}

#ifndef _AFX_NO_OCC_SUPPORT

void CPropertyPage::Cleanup()
{
	COccManager* pOccManager = afxOccManager;
	if ((pOccManager != NULL) && (m_pOccDialogInfo != NULL))
	{
		pOccManager->PostCreateDialog(m_pOccDialogInfo);
		free(m_pOccDialogInfo);
		m_pOccDialogInfo = NULL;
	}
}

AFX_STATIC DLGTEMPLATE* AFXAPI
_AfxChangePropPageFont(const DLGTEMPLATE* pTemplate, BOOL bWizard)
{
	CString strFaceDefault;
	WORD wSizeDefault;

	if (!AfxGetPropSheetFont(strFaceDefault, wSizeDefault, bWizard))
		return NULL;

	// set font of property page to same font used by property sheet
	CString strFace;
	WORD wSize;
	if ((!CDialogTemplate::GetFont(pTemplate, strFace, wSize)) ||
		(strFace != strFaceDefault) || (wSize != wSizeDefault))
	{
		CDialogTemplate dlgTemplate(pTemplate);
		dlgTemplate.SetFont(strFaceDefault, wSizeDefault);
		return (DLGTEMPLATE*)dlgTemplate.Detach();
	}

	return NULL;
}

const DLGTEMPLATE* CPropertyPage::InitDialogInfo(const DLGTEMPLATE* pTemplate)
{
	// cleanup from previous run, if any
	Cleanup();

	m_pOccDialogInfo = (_AFX_OCC_DIALOG_INFO*)malloc(
		sizeof(_AFX_OCC_DIALOG_INFO));

	return afxOccManager->PreCreateDialog(m_pOccDialogInfo, pTemplate);
}

#endif

void CPropertyPage::PreProcessPageTemplate(PROPSHEETPAGE& psp, BOOL bWizard)
{
	const DLGTEMPLATE* pTemplate;

	if (psp.dwFlags & PSP_DLGINDIRECT)
	{
		pTemplate = psp.pResource;
	}
	else
	{
		HRSRC hResource = ::FindResource(psp.hInstance,	psp.pszTemplate, RT_DIALOG);
		if (hResource == NULL)
		{
			AfxThrowResourceException();
		}
		HGLOBAL hTemplate = LoadResource(psp.hInstance,	hResource);
		if (hTemplate == NULL)
		{
			AfxThrowResourceException();
		}
		pTemplate = (LPCDLGTEMPLATE)LockResource(hTemplate);
		if (pTemplate == NULL)
		{
			AfxThrowResourceException();
		}
	}

#ifndef _AFX_NO_OCC_SUPPORT
	// if the dialog could contain OLE controls, deal with them now
	if (afxOccManager != NULL)
		pTemplate = InitDialogInfo(pTemplate);
#endif

	// set font of property page to same font used by property sheet
	HGLOBAL hTemplate = _AfxChangePropPageFont(pTemplate, bWizard);

	if (m_hDialogTemplate != NULL)
	{
		GlobalFree(m_hDialogTemplate);
		m_hDialogTemplate = NULL;
	}

	if (hTemplate != NULL)
	{
		pTemplate = (LPCDLGTEMPLATE)hTemplate;
		m_hDialogTemplate = hTemplate;
	}
	psp.pResource = pTemplate;
	psp.dwFlags |= PSP_DLGINDIRECT;
}

void CPropertyPage::CancelToClose()
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(GetParent() != NULL);

	GetParent()->SendMessage(PSM_CANCELTOCLOSE);
}

void CPropertyPage::SetModified(BOOL bChanged)
{
	if (m_hWnd == NULL) // allowed for backward compatibility
		return;

	ASSERT(::IsWindow(m_hWnd));
	ASSERT(GetParent() != NULL);

	CWnd* pParentWnd = GetParent();
	if (bChanged)
		pParentWnd->SendMessage(PSM_CHANGED, (WPARAM)m_hWnd);
	else
		pParentWnd->SendMessage(PSM_UNCHANGED, (WPARAM)m_hWnd);
}

LRESULT CPropertyPage::QuerySiblings(WPARAM wParam, LPARAM lParam)
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(GetParent() != NULL);

	return GetParent()->SendMessage(PSM_QUERYSIBLINGS, wParam, lParam);
}

BOOL CPropertyPage::OnApply()
{
	ASSERT_VALID(this);

	OnOK();
	return TRUE;
}

void CPropertyPage::OnReset()
{
	ASSERT_VALID(this);

	OnCancel();
}

void CPropertyPage::OnOK()
{
	ASSERT_VALID(this);
}

void CPropertyPage::OnCancel()
{
	ASSERT_VALID(this);
}

BOOL CPropertyPage::OnSetActive()
{
	ASSERT_VALID(this);

	if (m_bFirstSetActive)
		m_bFirstSetActive = FALSE;
	else
		UpdateData(FALSE);
	return TRUE;
}

BOOL CPropertyPage::OnKillActive()
{
	ASSERT_VALID(this);

	if (!UpdateData())
	{
		TRACE(traceAppMsg, 0, "UpdateData failed during page deactivation\n");
		return FALSE;
	}
	return TRUE;
}

BOOL CPropertyPage::OnQueryCancel()
{
	return TRUE;    // ok to cancel
}

LRESULT CPropertyPage::OnWizardBack()
{
	return 0;
}

LRESULT CPropertyPage::OnWizardNext()
{
	return 0;
}

HWND CPropertyPage::OnWizardFinishEx()
{	
	//Reversing the return values from OnWizardFinish.
	return OnWizardFinish() ? (HWND)FALSE : (HWND)TRUE;
}


BOOL CPropertyPage::OnWizardFinish()
{
	BOOL bClose=FALSE;
	if (UpdateData())
	{
		CWnd* pParent = GetParent();
		CPropertySheet* pSheet = DYNAMIC_DOWNCAST(CPropertySheet, pParent);
		if (pSheet != NULL)
		{
			if (pSheet->IsModeless() && pSheet->IsWizard())
			{
				//Msg is posted so PreTranslateMessage of CPropertySheet is called
				//and it will immediatly DestoryWindow().
				pSheet->PostMessage(WM_NULL,0,0);
			}
		}
		bClose=TRUE;
	}
	return bClose;
}

LRESULT CPropertyPage::MapWizardResult(LRESULT lToMap)
{
	// -1 and 0 are special
	if (lToMap == -1 || lToMap == 0)
		return lToMap;

	// only do special stuff if MFC owns the property sheet
	CWnd* pParent = GetParent();
	CPropertySheet* pSheet = DYNAMIC_DOWNCAST(CPropertySheet, pParent);
	if (pSheet != NULL)
	{
		// search the pages for a matching ID
		const PROPSHEETPAGE* ppsp = pSheet->m_psh.ppsp;
		for (int i = 0; i < pSheet->m_pages.GetSize(); i++)
		{
			// check page[i] for a match
			CPropertyPage* pPage = pSheet->GetPage(i);
			if ((LRESULT)pPage->m_psp.pszTemplate == lToMap)
				return (LRESULT)ppsp->pResource;

			// jump to next page
			(BYTE*&)ppsp += ppsp->dwSize;
		}
	}
	// otherwise, just use the original value
	return lToMap;
}

BOOL CPropertyPage::IsButtonEnabled(int iButton)
{
	HWND hWnd = ::GetDlgItem(::GetParent(m_hWnd), iButton);
	if (hWnd == NULL)
		return FALSE;
	return ::IsWindowEnabled(hWnd);
}

BOOL CPropertyPage::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult)
{
	ASSERT(pResult != NULL);
	NMHDR* pNMHDR = (NMHDR*)lParam;

	// allow message map to override
	if (CDialog::OnNotify(wParam, lParam, pResult))
		return TRUE;

	// don't handle messages not from the page/sheet itself
	if (pNMHDR->hwndFrom != m_hWnd && pNMHDR->hwndFrom != ::GetParent(m_hWnd))
		return FALSE;

	// handle default
	switch (pNMHDR->code)
	{
	case PSN_SETACTIVE:
		{
			CPropertySheet* pSheet = DYNAMIC_DOWNCAST(CPropertySheet, GetParent());
			if (pSheet != NULL && !(pSheet->m_nFlags & WF_CONTINUEMODAL) && !(pSheet->m_bModeless))
				*pResult = -1;
			else
				*pResult = OnSetActive() ? 0 : -1;
		}
		break;
	case PSN_KILLACTIVE:
		*pResult = !OnKillActive();
		break;
	case PSN_APPLY:
		*pResult = OnApply() ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE;
		break;
	case PSN_RESET:
		OnReset();
		break;
	case PSN_QUERYCANCEL:
		*pResult = !OnQueryCancel();
		break;
	case PSN_WIZNEXT:
		*pResult = MapWizardResult(OnWizardNext());
		break;
	case PSN_WIZBACK:
		*pResult = MapWizardResult(OnWizardBack());
		break;
	case PSN_WIZFINISH:
		*pResult = reinterpret_cast<LRESULT>(OnWizardFinishEx());		
		break;
	case PSN_HELP:
		SendMessage(WM_COMMAND, ID_HELP);
		break;

	default:
		return FALSE;   // not handled
	}

	return TRUE;    // handled
}

/////////////////////////////////////////////////////////////////////////////
// CPropertyPage message Handlers

BOOL CPropertyPage::PreTranslateMessage(MSG* pMsg)
{
	VERIFY(!CWnd::PreTranslateMessage(pMsg));

	return FALSE;   // handled by CPropertySheet::PreTranslateMessage
}

HBRUSH CPropertyPage::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)
{
	LRESULT lResult;
	if (pWnd->SendChildNotifyLastMsg(&lResult))
		return (HBRUSH)lResult;

	return CDialog::OnCtlColor(pDC, pWnd, nCtlColor);
}

/////////////////////////////////////////////////////////////////////////////
// CPropertyPage Diagnostics

#ifdef _DEBUG
void CPropertyPage::AssertValid() const
{
	CDialog::AssertValid();
	ASSERT(m_psp.dwFlags & PSP_USECALLBACK);
	ASSERT(m_psp.pfnDlgProc == AfxDlgProc);
	ASSERT(m_psp.lParam == (LPARAM)this);
}

void CPropertyPage::Dump(CDumpContext& dc) const
{
	CDialog::Dump(dc);

	dc << "m_strCaption = " << m_strCaption << "\n";
	dc << "m_psp.dwFlags = " << m_psp.dwFlags << "\n";
}
#endif //_DEBUG

void CPropertyPage::EndDialog(int nID)
{
	// Normally you shouldn't call EndDialog from a page. But in case it does
	// happen during error situations, call CPropertySheet::EndDialog instead.

	CPropertySheet* pParent = DYNAMIC_DOWNCAST(CPropertySheet, GetParent());
	if (pParent != NULL)
		pParent->EndDialog(nID);
}

/////////////////////////////////////////////////////////////////////////////
// CPropertySheet -- a tabbed "dialog" (really a popup-window)

BEGIN_MESSAGE_MAP(CPropertySheet, CWnd)
	//{{AFX_MSG_MAP(CPropertySheet)
	ON_WM_CTLCOLOR()
	ON_WM_NCCREATE()
	ON_MESSAGE(WM_INITDIALOG, &CPropertySheet::HandleInitDialog)
	ON_MESSAGE(WM_COMMANDHELP,&CPropertySheet::OnCommandHelp)
	ON_WM_CLOSE()
	ON_WM_SYSCOMMAND()
	ON_MESSAGE(DM_SETDEFID, &CPropertySheet::OnSetDefID)
	ON_MESSAGE(WM_KICKIDLE,&CPropertySheet::OnKickIdle)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

AFX_STATIC_DATA const int _afxPropSheetIDs[4] = { ID_WIZNEXT, ID_WIZFINISH, ID_WIZBACK, IDCANCEL };

LRESULT CPropertySheet::OnSetDefID(WPARAM wParam, LPARAM lParam)
{
	// A wrong or invalid ID may be passed in here.  If this is the case, then look for a valid one
	HWND hWndParam;
	if (IsWizard() &&
		(
			((hWndParam = ::GetDlgItem(m_hWnd, (int)wParam)) == NULL) ||
			!(::GetWindowLong(hWndParam, GWL_STYLE) & WS_VISIBLE) ||
			!::IsWindowEnabled(hWndParam)
		))
	{

		for (int i = 0; i < _countof(_afxPropSheetIDs); i++)
		{
			// find first button that is visible and  enabled
			HWND hWnd = ::GetDlgItem(m_hWnd, _afxPropSheetIDs[i]);
			if ((GetWindowLong(hWnd, GWL_STYLE) & WS_VISIBLE) &&
				::IsWindowEnabled(hWnd))
			{
				// focus could be incorrect as well in this case
				// so ... let's set it to the default button
				HWND hWndFocus = ::GetFocus();
				if (!::IsWindowEnabled(hWndFocus))
					::SetFocus(hWnd);
				return DefWindowProc(DM_SETDEFID, _afxPropSheetIDs[i], lParam);
			}
		}
	}
	return Default();
}

// simple construction

CPropertySheet::CPropertySheet()
{
	CommonConstruct(NULL, 0);
}

CPropertySheet::CPropertySheet(UINT nIDCaption, CWnd* pParentWnd,
	UINT iSelectPage)
{
	ASSERT(nIDCaption != 0);

	ENSURE(m_strCaption.LoadString(nIDCaption));
	CommonConstruct(pParentWnd, iSelectPage);
}

CPropertySheet::CPropertySheet(LPCTSTR pszCaption, CWnd* pParentWnd,
	UINT iSelectPage)
{
	ENSURE_ARG(AfxIsValidString(pszCaption));

	m_strCaption = pszCaption;
	CommonConstruct(pParentWnd, iSelectPage);
}

void CPropertySheet::Construct(UINT nIDCaption, CWnd* pParentWnd,
	UINT iSelectPage)
{
	ASSERT(nIDCaption != 0);

	ENSURE(m_strCaption.LoadString(nIDCaption));
	CommonConstruct(pParentWnd, iSelectPage);
}

void CPropertySheet::Construct(LPCTSTR pszCaption, CWnd* pParentWnd,
	UINT iSelectPage)
{
	ENSURE_ARG(AfxIsValidString(pszCaption));

	m_strCaption = pszCaption;
	CommonConstruct(pParentWnd, iSelectPage);
}

void CPropertySheet::CommonConstruct(CWnd* pParentWnd, UINT iSelectPage)
{
	memset(&m_psh, 0, sizeof(m_psh));
	m_psh.dwSize = sizeof(m_psh);
	m_psh.dwFlags = PSH_PROPSHEETPAGE;
	m_psh.pszCaption = m_strCaption;
	m_psh.nStartPage = iSelectPage;
	m_bStacked = TRUE;
	m_bModeless = FALSE;

	if (AfxHelpEnabled())
		m_psh.dwFlags |= PSH_HASHELP;

	m_pParentWnd = pParentWnd;  // m_psh.hwndParent set in DoModal/create
}

CPropertySheet::CPropertySheet(UINT nIDCaption, CWnd* pParentWnd,
	UINT iSelectPage, HBITMAP hbmWatermark, HPALETTE hpalWatermark,
	HBITMAP hbmHeader)
{
	ASSERT(nIDCaption != 0);

	ENSURE(m_strCaption.LoadString(nIDCaption));
	CommonConstruct(pParentWnd, iSelectPage, hbmWatermark, hpalWatermark, hbmHeader);
}

CPropertySheet::CPropertySheet(LPCTSTR pszCaption, CWnd* pParentWnd,
	UINT iSelectPage, HBITMAP hbmWatermark, HPALETTE hpalWatermark,
	HBITMAP hbmHeader)
{
	ENSURE_ARG(AfxIsValidString(pszCaption));

	m_strCaption = pszCaption;
	CommonConstruct(pParentWnd, iSelectPage, hbmWatermark, hpalWatermark, hbmHeader);
}

void CPropertySheet::Construct(UINT nIDCaption, CWnd* pParentWnd,
	UINT iSelectPage, HBITMAP hbmWatermark, HPALETTE hpalWatermark,
	HBITMAP hbmHeader)
{
	ASSERT(nIDCaption != 0);

	ENSURE(m_strCaption.LoadString(nIDCaption));
	CommonConstruct(pParentWnd, iSelectPage, hbmWatermark, hpalWatermark, hbmHeader);
}

void CPropertySheet::Construct(LPCTSTR pszCaption, CWnd* pParentWnd,
	UINT iSelectPage, HBITMAP hbmWatermark, HPALETTE hpalWatermark,
	HBITMAP hbmHeader)
{
	ENSURE_ARG(AfxIsValidString(pszCaption));

	m_strCaption = pszCaption;
	CommonConstruct(pParentWnd, iSelectPage, hbmWatermark, hpalWatermark, hbmHeader);
}

void CPropertySheet::CommonConstruct(CWnd* pParentWnd, UINT iSelectPage,
	HBITMAP hbmWatermark, HPALETTE hpalWatermark, HBITMAP hbmHeader)
{
	CommonConstruct(pParentWnd, iSelectPage);

	if (hbmWatermark != NULL)
	{
		m_psh.hbmWatermark = hbmWatermark;
		m_psh.dwFlags |= (PSH_USEHBMWATERMARK | PSH_WATERMARK);
		m_psh.dwSize = sizeof(m_psh);
	}
	if (hpalWatermark != NULL)
	{
		m_psh.hplWatermark = hpalWatermark;
		m_psh.dwFlags |= PSH_USEHPLWATERMARK;
		m_psh.dwSize = sizeof(m_psh);
	}
	if (hbmHeader != NULL)
	{
		m_psh.hbmHeader = hbmHeader;
		m_psh.dwFlags |= (PSH_USEHBMHEADER | PSH_HEADER);
		m_psh.dwSize = sizeof(m_psh);
	}
}

void CPropertySheet::EnableStackedTabs(BOOL bStacked)
{
	m_bStacked = bStacked;
}

void CPropertySheet::SetTitle(LPCTSTR lpszText, UINT nStyle)
{
	ASSERT((nStyle & ~PSH_PROPTITLE) == 0); // only PSH_PROPTITLE is valid
	ASSERT(lpszText == NULL || AfxIsValidString(lpszText));

	if (m_hWnd == NULL)
	{
		// set internal state
		m_strCaption = lpszText;
		m_psh.pszCaption = m_strCaption;
		m_psh.dwFlags &= ~PSH_PROPTITLE;
		m_psh.dwFlags |= nStyle;
	}
	else
	{
		// set external state
		SendMessage(PSM_SETTITLE, nStyle, (LPARAM)lpszText);
	}
}

CPropertySheet::~CPropertySheet()
{
	free((void*)m_psh.ppsp);
}

BOOL CPropertySheet::PreTranslateMessage(MSG* pMsg)
{
	ASSERT_VALID(this);

	// allow tooltip messages to be filtered
	if (CWnd::PreTranslateMessage(pMsg))
		return TRUE;

	HGLOBAL hMemProp = (HGLOBAL) GetProp(this->m_hWnd, PROP_CLOSEPENDING_NAME); 
	BOOL* pBool = static_cast<BOOL*>(GlobalLock(hMemProp));
	
	if (pBool != NULL)
	{
		if( *pBool == TRUE && NULL == PropSheet_GetCurrentPageHwnd(m_hWnd))
		{		
			GlobalUnlock(hMemProp); 
			hMemProp = RemoveProp(this->m_hWnd, PROP_CLOSEPENDING_NAME);
			if (hMemProp)
				GlobalFree(hMemProp);
			DestroyWindow();
			return TRUE;
		} 
		else
		{
			GlobalUnlock(hMemProp); 
		}
	}

	// allow sheet to translate Ctrl+Tab, Shift+Ctrl+Tab,
	//  Ctrl+PageUp, and Ctrl+PageDown
	if (pMsg->message == WM_KEYDOWN && GetAsyncKeyState(VK_CONTROL) < 0 &&
		(pMsg->wParam == VK_TAB || pMsg->wParam == VK_PRIOR || pMsg->wParam == VK_NEXT))
	{
		if (SendMessage(PSM_ISDIALOGMESSAGE, 0, (LPARAM)pMsg))
			return TRUE;
	}

	// handle rest with IsDialogMessage
	return PreTranslateInput(pMsg);
}

BOOL CPropertySheet::OnCmdMsg(UINT nID, int nCode, void* pExtra,
	AFX_CMDHANDLERINFO* pHandlerInfo)
{
	if (CWnd::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
		return TRUE;

	if ((nCode != CN_COMMAND && nCode != CN_UPDATE_COMMAND_UI) ||
			!IS_COMMAND_ID(nID) || nID >= 0xf000)
	{
		// control notification or non-command button or system command
		return FALSE;       // not routed any further
	}

	// if we have an owner window, give it second crack
	CWnd* pOwner = GetParent();
	if (pOwner != NULL)
	{
		TRACE(traceCmdRouting, 1, "Routing command id 0x%04X to owner window.\n", nID);

		ASSERT(pOwner != this);
		if (pOwner->OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
			return TRUE;
	}

	// last crack goes to the current CWinThread object
	CWinThread* pThread = AfxGetThread();
	if (pThread != NULL)
	{
		TRACE(traceCmdRouting, 1, "Routing command id 0x%04X to app.\n", nID);

		if (pThread->OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
			return TRUE;
	}

	TRACE(traceCmdRouting, 1, "IGNORING command id 0x%04X sent to %hs dialog.\n", nID,
		GetRuntimeClass()->m_lpszClassName);

	return FALSE;
}

CPropertyPage* CPropertySheet::GetActivePage() const
{
	ASSERT_VALID(this);

	CPropertyPage* pPage;
	if (m_hWnd != NULL)
		pPage = STATIC_DOWNCAST(CPropertyPage,
			CWnd::FromHandle((HWND)::SendMessage(m_hWnd, PSM_GETCURRENTPAGEHWND, 0, 0)));
	else
		pPage = GetPage(GetActiveIndex());
	return pPage;
}

BOOL CPropertySheet::ContinueModal()
{
	// allow CWnd::EndModalLoop to be used
	if (!CWnd::ContinueModal())
		return FALSE;

	// when active page is NULL, the modal loop should end
	ASSERT(::IsWindow(m_hWnd));
	BOOL bResult = SendMessage(PSM_GETCURRENTPAGEHWND) != 0;
	return bResult;
}

INT_PTR CPropertySheet::DoModal()
{
	ASSERT_VALID(this);
	ASSERT(m_hWnd == NULL);

	// register common controls
	VERIFY(AfxDeferRegisterClass(AFX_WNDCOMMCTLS_REG));
	AfxDeferRegisterClass(AFX_WNDCOMMCTLSNEW_REG);

#ifdef _UNICODE
	AfxInitNetworkAddressControl();
#endif

	// finish building PROPSHEETHEADER structure
	BuildPropPageArray();

	// allow OLE servers to disable themselves
	CWinApp* pApp = AfxGetApp();
	if (pApp != NULL)
		pApp->EnableModeless(FALSE);

	// find parent HWND
	HWND hWndTop;
	HWND hWndParent = CWnd::GetSafeOwner_(m_pParentWnd->GetSafeHwnd(), &hWndTop);
	m_psh.hwndParent = hWndParent;
	BOOL bEnableParent = FALSE;
	if (hWndParent != NULL && ::IsWindowEnabled(hWndParent))
	{
		::EnableWindow(hWndParent, FALSE);
		bEnableParent = TRUE;
	}
	HWND hWndCapture = ::GetCapture();
	if (hWndCapture != NULL)
		::SendMessage(hWndCapture, WM_CANCELMODE, 0, 0);

	// setup for modal loop and creation
	m_nModalResult = 0;
	if( !(PSH_AEROWIZARD & m_psh.dwFlags ) )
	{
		m_nFlags |= WF_CONTINUEMODAL;
	}

	INT_PTR nResult = 0;

	// hook for creation of window
	AfxHookWindowCreate(this);
	if( PSH_AEROWIZARD & m_psh.dwFlags )
	{
		nResult = ::AfxPropertySheet(&m_psh);
		AfxUnhookWindowCreate();
		m_hWnd = NULL;
	}
	else
	{
		m_psh.dwFlags |= PSH_MODELESS;
		HWND hWnd = (HWND)::AfxPropertySheet(&m_psh);
#ifdef _DEBUG
		DWORD dwError = ::GetLastError();
#endif
		m_psh.dwFlags &= ~PSH_MODELESS;
		AfxUnhookWindowCreate();

		// handle error
		if (hWnd == NULL || hWnd == (HWND)-1)
		{
#ifdef _DEBUG
			TRACE(traceAppMsg, 0, "PropertySheet() failed: GetLastError returned %d\n", dwError);
#endif
			m_nFlags &= ~WF_CONTINUEMODAL;
		}

		nResult = m_nModalResult;
		if (ContinueModal())
		{
			// enter modal loop
			DWORD dwFlags = MLF_SHOWONIDLE;
			if (GetStyle() & DS_NOIDLEMSG)
				dwFlags |= MLF_NOIDLEMSG;
			nResult = RunModalLoop(dwFlags);
		}

		// hide the window before enabling parent window, etc.
		if (m_hWnd != NULL)
		{
			SetWindowPos(NULL, 0, 0, 0, 0, SWP_HIDEWINDOW|
				SWP_NOSIZE|SWP_NOMOVE|SWP_NOACTIVATE|SWP_NOZORDER);
		}
	}

	if (bEnableParent)
		::EnableWindow(hWndParent, TRUE);
	if (hWndParent != NULL && ::GetActiveWindow() == m_hWnd)
		::SetActiveWindow(hWndParent);

	if( !(PSH_AEROWIZARD & m_psh.dwFlags) )
	{
		// cleanup
		DestroyWindow();
	}

	// allow OLE servers to enable themselves
	if (pApp != NULL)
		pApp->EnableModeless(TRUE);
	if (hWndTop != NULL)
		::EnableWindow(hWndTop, TRUE);

	return nResult;
}

int CALLBACK
AfxPropSheetCallback(HWND, UINT message, LPARAM lParam)
{
	switch (message)
	{
	case PSCB_PRECREATE:
		{
			_AFX_THREAD_STATE* pState = AfxGetThreadState();
			LPDLGTEMPLATE lpTemplate = (LPDLGTEMPLATE)lParam;
			if (lpTemplate->style != pState->m_dwPropStyle ||
				lpTemplate->dwExtendedStyle != pState->m_dwPropExStyle)
			{
				// Mark the dialog template as read-write.
				DWORD dwOldProtect;
				VirtualProtect(lpTemplate, sizeof(DLGTEMPLATE), PAGE_READWRITE, &dwOldProtect);

				// Ensure DS_SETFONT is set correctly.
				lpTemplate->style = lpTemplate->style & DS_SETFONT ?
									pState->m_dwPropStyle | DS_SETFONT :
									pState->m_dwPropStyle & ~DS_SETFONT;

				lpTemplate->dwExtendedStyle = pState->m_dwPropExStyle;
				return TRUE;
			}
			return FALSE;
		}
	}

	return 0;
}

BOOL CPropertySheet::Create(CWnd* pParentWnd, DWORD dwStyle, DWORD dwExStyle)
{
	ENSURE( 0 == ( m_psh.dwFlags & PSH_AEROWIZARD ) );

	_AFX_THREAD_STATE* pState = AfxGetThreadState();

	// Calculate the default window style.
	if (dwStyle == (DWORD)-1)
	{
		pState->m_dwPropStyle = DS_MODALFRAME | DS_3DLOOK | DS_CONTEXTHELP |
								DS_SETFONT | WS_POPUP | WS_VISIBLE | WS_CAPTION;

		// Wizards don't have WS_SYSMENU.
		if (!IsWizard())
			pState->m_dwPropStyle |= WS_SYSMENU;
	}
	else
	{
		pState->m_dwPropStyle = dwStyle;
	}
	pState->m_dwPropExStyle = dwExStyle;

	ASSERT_VALID(this);
	ASSERT(m_hWnd == NULL);

	VERIFY(AfxDeferRegisterClass(AFX_WNDCOMMCTLS_REG));
	AfxDeferRegisterClass(AFX_WNDCOMMCTLSNEW_REG);

#ifdef _UNICODE
	AfxInitNetworkAddressControl();
#endif

	// finish building PROPSHEETHEADER structure
	BuildPropPageArray();
	m_bModeless = TRUE;
	m_psh.dwFlags |= (PSH_MODELESS|PSH_USECALLBACK);
	m_psh.pfnCallback = AfxPropSheetCallback;
	m_psh.hwndParent = pParentWnd->GetSafeHwnd();

	// hook the window creation process
	AfxHookWindowCreate(this);
	HWND hWnd = (HWND)AfxPropertySheet(&m_psh);
#ifdef _DEBUG
	DWORD dwError = ::GetLastError();
#endif

	// cleanup on failure, otherwise return TRUE
	if (!AfxUnhookWindowCreate())
		PostNcDestroy();    // cleanup if Create fails

	// setting a custom property in our window
	HGLOBAL hMem = GlobalAlloc(GPTR, sizeof(BOOL)); 
	BOOL* pBool = static_cast<BOOL*>(GlobalLock(hMem));
	if (pBool != NULL)
	{
		*pBool = TRUE;
		GlobalUnlock(hMem); 
		if (SetProp(this->m_hWnd, PROP_CLOSEPENDING_NAME, hMem) == 0)
		{
			GlobalFree(hMem);
			this->DestroyWindow();
			return FALSE;
		}
	}
	else
	{
		this->DestroyWindow();
		return FALSE;
	}
	
	if (hWnd == NULL || hWnd == (HWND)-1)
	{
#ifdef _DEBUG
		TRACE(traceAppMsg, 0, "PropertySheet() failed: GetLastError returned %d\n", dwError);
#endif
		return FALSE;
	}

	ASSERT(hWnd == m_hWnd);
	return TRUE;
}

void CPropertySheet::BuildPropPageArray()
{
	// delete existing prop page array
	free((void*)m_psh.ppsp);
	m_psh.ppsp = NULL;

	// determine size of PROPSHEETPAGE array
	int i;
	int nBytes = 0;
	for (i = 0; i < m_pages.GetSize(); i++)
	{
		CPropertyPage* pPage = GetPage(i);
		nBytes += pPage->m_psp.dwSize;
	}

	// build new PROPSHEETPAGE array
	PROPSHEETPAGE* ppsp = (PROPSHEETPAGE*)malloc(nBytes);
	BYTE* ppspOrigByte=reinterpret_cast<BYTE*>(ppsp);
	if (ppsp == NULL)
		AfxThrowMemoryException();
	BYTE* pPropSheetPagesArrEnd=ppspOrigByte + nBytes;
	ENSURE(pPropSheetPagesArrEnd >= ppspOrigByte);
	m_psh.ppsp = ppsp;
	BOOL bWizard = (m_psh.dwFlags & (PSH_WIZARD | PSH_WIZARD97));
	for (i = 0; i < m_pages.GetSize(); i++)
	{
		CPropertyPage* pPage = GetPage(i);
		BYTE* ppspByte=reinterpret_cast<BYTE*>(ppsp);		
		ENSURE_THROW(ppspByte >= ppspOrigByte && ppspByte <= pPropSheetPagesArrEnd,AfxThrowMemoryException());
		Checked::memcpy_s(ppsp, pPropSheetPagesArrEnd - reinterpret_cast<BYTE*>(ppsp), &pPage->m_psp, pPage->m_psp.dwSize);

		if (!pPage->m_strHeaderTitle.IsEmpty())
		{
			ppsp->pszHeaderTitle = pPage->m_strHeaderTitle;
			ppsp->dwFlags |= PSP_USEHEADERTITLE;
		}
		if (!pPage->m_strHeaderSubTitle.IsEmpty())
		{
			ppsp->pszHeaderSubTitle = pPage->m_strHeaderSubTitle;
			ppsp->dwFlags |= PSP_USEHEADERSUBTITLE;
		}
		pPage->PreProcessPageTemplate(*ppsp, bWizard);
		(BYTE*&)ppsp += ppsp->dwSize;
	}
	m_psh.nPages = (int)m_pages.GetSize();
}

////////////////////////////////////////////////////////////////////////////

int CPropertySheet::GetPageCount() const
{
	ASSERT_VALID(this);

	if (m_hWnd == NULL)
		return (int)m_pages.GetSize();

	CTabCtrl* pTab = GetTabControl();
	ENSURE(pTab);
	return pTab->GetItemCount();
}

int CPropertySheet::GetActiveIndex() const
{
	if (m_hWnd == NULL)
		return m_psh.nStartPage;

	CTabCtrl* pTab = GetTabControl();
	ENSURE(pTab);
	return pTab->GetCurSel();
}

BOOL CPropertySheet::SetActivePage(int nPage)
{
	if (m_hWnd == NULL)
	{
		m_psh.nStartPage = nPage;
		return TRUE;
	}
	return (BOOL)SendMessage(PSM_SETCURSEL, nPage);
}

int CPropertySheet::GetPageIndex(CPropertyPage* pPage)
{
	for (int i = 0; i < GetPageCount(); i++)
	{
		if (GetPage(i) == pPage)
			return i;
	}
	return -1;  // pPage not found
}

BOOL CPropertySheet::SetActivePage(CPropertyPage* pPage)
{
	ASSERT_VALID(this);
	ENSURE_VALID(pPage);
	ASSERT_KINDOF(CPropertyPage, pPage);

	int nPage = GetPageIndex(pPage);
	ASSERT(pPage >= 0);

	return SetActivePage(nPage);
}

void CPropertySheet::AddPage(CPropertyPage* pPage)
{
	ASSERT_VALID(this);
	ENSURE_VALID(pPage);
	ASSERT_KINDOF(CPropertyPage, pPage);

	// add page to internal list
	m_pages.Add(pPage);

	// add page externally
	if (m_hWnd != NULL)
	{
		// determine size of PROPSHEETPAGE array
		PROPSHEETPAGE* ppsp = const_cast<PROPSHEETPAGE*>(m_psh.ppsp);
		int nBytes = 0;
		int nNextBytes;
		for (UINT i = 0; i < m_psh.nPages; i++)
		{
			nNextBytes = nBytes + ppsp->dwSize;
			if ((nNextBytes < nBytes) || (nNextBytes < (int)ppsp->dwSize))
				AfxThrowMemoryException();
			nBytes = nNextBytes;
			(BYTE*&)ppsp += ppsp->dwSize;
		}

		nNextBytes = nBytes + pPage->m_psp.dwSize;
		if ((nNextBytes < nBytes) || (nNextBytes < (int)pPage->m_psp.dwSize))
			AfxThrowMemoryException();

		// build new prop page array
		ppsp = (PROPSHEETPAGE*)realloc((void*)m_psh.ppsp, nNextBytes);
		if (ppsp == NULL)
			AfxThrowMemoryException();
		m_psh.ppsp = ppsp;

		// copy processed PROPSHEETPAGE struct to end
		(BYTE*&)ppsp += nBytes;
		Checked::memcpy_s(ppsp, nNextBytes - nBytes , &pPage->m_psp, pPage->m_psp.dwSize);
		pPage->PreProcessPageTemplate(*ppsp, IsWizard());
		if (!pPage->m_strHeaderTitle.IsEmpty())
		{
			ppsp->pszHeaderTitle = pPage->m_strHeaderTitle;
			ppsp->dwFlags |= PSP_USEHEADERTITLE;
		}
		if (!pPage->m_strHeaderSubTitle.IsEmpty())
		{
			ppsp->pszHeaderSubTitle = pPage->m_strHeaderSubTitle;
			ppsp->dwFlags |= PSP_USEHEADERSUBTITLE;
		}
		HPROPSHEETPAGE hPSP = AfxCreatePropertySheetPage(ppsp);
		if (hPSP == NULL)
			AfxThrowMemoryException();

		if (!SendMessage(PSM_ADDPAGE, 0, (LPARAM)hPSP))
		{
			AfxDestroyPropertySheetPage(hPSP);
			AfxThrowMemoryException();
		}
		++m_psh.nPages;
	}
}

void CPropertySheet::RemovePage(CPropertyPage* pPage)
{
	ASSERT_VALID(this);
	ENSURE_VALID(pPage);
	ASSERT_KINDOF(CPropertyPage, pPage);

	int nPage = GetPageIndex(pPage);
	ASSERT(nPage >= 0);

	RemovePage(nPage);
}

void CPropertySheet::RemovePage(int nPage)
{
	ASSERT_VALID(this);

	// remove the page externally
	if (m_hWnd != NULL)
		SendMessage(PSM_REMOVEPAGE, nPage);

	// remove the page from internal list
	m_pages.RemoveAt(nPage);
}

void CPropertySheet::EndDialog(int nEndID)
{
	ASSERT_VALID(this);
	CWnd::EndModalLoop(nEndID);
	::PropSheet_PressButton(m_hWnd,PSBTN_CANCEL); //Now PSN_RESET and other notifications are sent to property pages.				
}

void CPropertySheet::OnClose()
{
	m_nModalResult = IDCANCEL;
	if (m_bModeless)
	{
		::PropSheet_PressButton(m_hWnd,PSBTN_CANCEL); //Now PSN_RESET and other notifications are sent to property pages.
	}
	else
	{
		Default();
	}
}

LRESULT CPropertySheet::OnKickIdle(WPARAM wp, LPARAM lp)
{
	ASSERT_VALID(this);
	/* Forward the message on to the active page of the property sheet */
	CPropertyPage * pPage = GetActivePage();
	if( pPage != NULL )
	{
		ASSERT_VALID(pPage);
		return pPage->SendMessage( WM_KICKIDLE, wp, lp );
	}
	else
		return 0;
}

void CPropertySheet::OnSysCommand(UINT nID, LPARAM)
{
	m_nModalResult = IDCANCEL;
	switch (nID & 0xFFF0)
	{
	case SC_CLOSE:
		if (m_bModeless)
		{
			SendMessage(WM_CLOSE);
			return;
		}
	}
	Default();
}

/////////////////////////////////////////////////////////////////////////////
// CPropertySheet message handlers

AFX_STATIC_DATA int _afxPropSheetButtons[] = { IDOK, IDCANCEL, ID_APPLY_NOW, IDHELP };

BOOL CPropertySheet::OnInitDialog()
{
	// change tab style if scrolling tabs desired (stacked tabs are default)
	if (!m_bStacked)
	{
		HWND hWndTab = (HWND)::GetDlgItem(m_hWnd, AFX_IDC_TAB_CONTROL);
		if (hWndTab != NULL)
			CWnd::ModifyStyle(hWndTab, TCS_MULTILINE, TCS_SINGLELINE, 0);
	}

	if (!IsWizard())
	{
		// resize the tab control so the layout is less restrictive
		HWND hWnd = (HWND)::GetDlgItem(m_hWnd, AFX_IDC_TAB_CONTROL);
		ASSERT(hWnd != NULL);
		CRect rectOld;
		::GetWindowRect(hWnd, &rectOld);
		ScreenToClient(rectOld);
		CRect rectNew(0, 0, 0, 32);
		::MapDialogRect(m_hWnd, &rectNew);
		if (rectNew.bottom < rectOld.bottom)
		{
			// move tab control
			int cyDiff = rectOld.Height() - rectNew.bottom;
			::SetWindowPos(hWnd, NULL, 0, 0, rectOld.Width(), rectNew.bottom,
				SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);

			// move buttons by similar amount
			for (int i = 0; i < _countof(_afxPropSheetButtons); i++)
			{
				hWnd = ::GetDlgItem(m_hWnd, _afxPropSheetButtons[i]);
				if (hWnd != NULL)
				{
					::GetWindowRect(hWnd, &rectOld);
					ScreenToClient(&rectOld);
					::SetWindowPos(hWnd, NULL,
						rectOld.left, rectOld.top - cyDiff,
						0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
				}
			}

			// resize property sheet itself similarly
			GetWindowRect(&rectOld);
			SetWindowPos(NULL, 0, 0, rectOld.Width(), rectOld.Height() - cyDiff,
				SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
		}
	}

	BOOL bResult = (BOOL)Default();

	if (m_bModeless && !IsWizard())
	{
		// layout property sheet so button area is not accounted for
		CRect rectWnd;
		GetWindowRect(rectWnd);
		CRect rectButton;
		HWND hWnd = ::GetDlgItem(m_hWnd, IDOK);
		if (hWnd != NULL)
		{
			::GetWindowRect(hWnd, rectButton);
			SetWindowPos(NULL, 0, 0,
				rectWnd.Width(), rectButton.top - rectWnd.top,
				SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
		}

		// remove standard buttons for modeless dialogs
		for (int i = 0; i < _countof(_afxPropSheetButtons); i++)
		{
			HWND hWndButton = ::GetDlgItem(m_hWnd, _afxPropSheetButtons[i]);
			if (hWndButton != NULL)
			{
				::ShowWindow(hWndButton, SW_HIDE);
				::EnableWindow(hWndButton, FALSE);
			}
		}
	}

	// center the property sheet relative to the parent window
	if (!(GetStyle() & WS_CHILD))
		CenterWindow();

	return bResult;
}

BOOL CPropertySheet::OnNcCreate(LPCREATESTRUCT)
{
	// By default, MFC does not directly support the new style
	// help button in the caption, so it is turned off here.
	// It can be added back in and implemented by derived classes
	// from CPropertySheet.
	ModifyStyleEx(WS_EX_CONTEXTHELP, 0);

	return (BOOL)Default();
}

LRESULT CPropertySheet::HandleInitDialog(WPARAM, LPARAM)
{
	LRESULT lResult = OnInitDialog();
	return lResult;
}

BOOL CPropertySheet::OnCommand(WPARAM wParam, LPARAM lParam)
{
	// allow message map override
	if (CWnd::OnCommand(wParam, lParam))
		return TRUE;

	// crack message parameters
	UINT nID = LOWORD(wParam);
	HWND hWndCtrl = (HWND)lParam;
	int nCode = HIWORD(wParam);

	// set m_nModalResult to ID of button, whenever button is clicked
	if (hWndCtrl != NULL && nCode == BN_CLICKED)
	{
		if (::SendMessage(hWndCtrl, WM_GETDLGCODE, 0, 0) &
			(DLGC_BUTTON|DLGC_DEFPUSHBUTTON))
		{
			LONG lStyle = ::GetWindowLong(hWndCtrl, GWL_STYLE) & 0x0F;
			if (lStyle == BS_PUSHBUTTON || lStyle == BS_DEFPUSHBUTTON ||
				lStyle == BS_USERBUTTON || lStyle == BS_OWNERDRAW)
			{
				m_nModalResult = nID;
			}
		}
	}
	return FALSE;
}

LRESULT CPropertySheet::OnCommandHelp(WPARAM wParam, LPARAM lParam)
{
	ASSERT_VALID(this);

	CPropertyPage* pPage = GetActivePage();
	ASSERT_VALID(pPage);
	return AfxCallWndProc(pPage, pPage->m_hWnd, WM_COMMANDHELP, wParam, lParam);
}

HBRUSH CPropertySheet::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)
{
	ENSURE_ARG(pWnd != NULL);
	LRESULT lResult;
	if (pWnd->SendChildNotifyLastMsg(&lResult))
		return (HBRUSH)lResult;

	return CWnd::OnCtlColor(pDC, pWnd, nCtlColor);
}

/////////////////////////////////////////////////////////////////////////////
// CPropertySheet Diagnostics

#ifdef _DEBUG
void CPropertySheet::AssertValid() const
{
	CWnd::AssertValid();
	m_pages.AssertValid();
	ASSERT(m_psh.dwSize == sizeof(m_psh));
	ASSERT((m_psh.dwFlags & PSH_PROPSHEETPAGE) == PSH_PROPSHEETPAGE);
}

void CPropertySheet::Dump(CDumpContext& dc) const
{
	CWnd::Dump(dc);

	dc << "m_strCaption = " << m_strCaption << "\n";
	dc << "Number of Pages = " << LONGLONG(m_pages.GetSize()) << "\n";
	dc << "Stacked = " << m_bStacked << "\n";
	dc << "Modeless = " << m_bModeless << "\n";
}
#endif //_DEBUG


IMPLEMENT_DYNAMIC(CPropertyPage, CCommonDialog)
IMPLEMENT_DYNAMIC(CPropertySheet, CWnd)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\dllmodul.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

__declspec(selectany) int __mixedModuleStartup;

#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// global data

// The following symbol used to force inclusion of this module for _USRDLL
#ifdef _X86_
extern "C" { int _afxForceUSRDLL; }
#else
extern "C" { int __afxForceUSRDLL; }
#endif

#ifdef _AFXDLL

static AFX_EXTENSION_MODULE controlDLL;

// force initialization early
#pragma warning(disable: 4074)
#pragma init_seg(lib)

/////////////////////////////////////////////////////////////////////////////
// static-linked version of AfxWndProc for use by this module

LRESULT CALLBACK AfxWndProcDllStatic(HWND, UINT, WPARAM, LPARAM);

class _AFX_DLL_MODULE_STATE : public AFX_MODULE_STATE
{
public:
	_AFX_DLL_MODULE_STATE() : AFX_MODULE_STATE(TRUE, AfxWndProcDllStatic, _MFC_VER)
		{ }
};

static _AFX_DLL_MODULE_STATE afxModuleState;

#undef AfxWndProc
LRESULT CALLBACK
AfxWndProcDllStatic(HWND hWnd, UINT nMsg, WPARAM wParam, LPARAM lParam)
{
	AFX_MANAGE_STATE(&afxModuleState);
	return AfxWndProc(hWnd, nMsg, wParam, lParam);
}

AFX_MODULE_STATE* AFXAPI AfxGetStaticModuleState()
{
	AFX_MODULE_STATE* pModuleState = &afxModuleState;
	return pModuleState;
}

#else

AFX_MODULE_STATE* AFXAPI AfxGetStaticModuleState()
{
	AFX_MODULE_STATE* pModuleState = AfxGetModuleState();
	return pModuleState;
}

#endif

/////////////////////////////////////////////////////////////////////////////
// export DllMain for the DLL

extern "C"
BOOL WINAPI InternalDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		BOOL bResult = FALSE;

#ifdef _AFXDLL
		// wire up resources from core DLL
		AfxCoreInitModule();
#endif

		_AFX_THREAD_STATE* pState = AfxGetThreadState();
		AFX_MODULE_STATE* pPrevModState = pState->m_pPrevModuleState;

		// Initialize DLL's instance(/module) not the app's
		if (!AfxWinInit(hInstance, NULL, _T(""), 0))
		{
			AfxWinTerm();
			goto Cleanup;       // Init Failed
		}

		// initialize the single instance DLL
		CWinApp* pApp; pApp = AfxGetApp();
		if (pApp != NULL && !pApp->InitInstance())
		{
			pApp->ExitInstance();
			AfxWinTerm();
			goto Cleanup;       // Init Failed
		}

		pState->m_pPrevModuleState = pPrevModState;
#ifdef _AFXDLL
		// wire up this DLL into the resource chain
		VERIFY(AfxInitExtensionModule(controlDLL, hInstance));
		TRY
		{
			CDynLinkLibrary* pDLL; 
			pDLL = new CDynLinkLibrary(controlDLL);
		}
		CATCH(CMemoryException, e)
		{
			DELETE_EXCEPTION(e);
			pApp->ExitInstance();
			AfxWinTerm();
			goto Cleanup;       // Init Failed
		}
		END_CATCH
#else
		AfxInitLocalData(hInstance);
#endif

		bResult = TRUE;

Cleanup:
		pState->m_pPrevModuleState = pPrevModState;
#ifdef _AFXDLL
		// restore previously-saved module state
		VERIFY(AfxSetModuleState(AfxGetThreadState()->m_pPrevModuleState) ==
			&afxModuleState);
		DEBUG_ONLY(AfxGetThreadState()->m_pPrevModuleState = NULL);
#endif
		return bResult;
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
#ifdef _AFXDLL
		// set module state for cleanup
		ASSERT(AfxGetThreadState()->m_pPrevModuleState == NULL);
		AfxGetThreadState()->m_pPrevModuleState =
			AfxSetModuleState(&afxModuleState);
#endif

		CWinApp* pApp = AfxGetApp();
		if (pApp != NULL)
			pApp->ExitInstance();

#ifdef _DEBUG
		// check for missing AfxLockTempMap calls
		if (AfxGetModuleThreadState()->m_nTempMapLock != 0)
		{
			TRACE(traceAppMsg, 0, "Warning: Temp map lock count non-zero (%ld).\n",
				AfxGetModuleThreadState()->m_nTempMapLock);
		}
#endif
		AfxLockTempMaps();
		AfxUnlockTempMaps(-1);

		// terminate the library before destructors are called
		AfxWinTerm();

#ifdef _AFXDLL
		AfxTermExtensionModule(controlDLL, TRUE);
		if (__mixedModuleStartup)
		{
			// restore module state after cleanup
			_AFX_THREAD_STATE* pState = AfxGetThreadState();
			VERIFY(AfxSetModuleState(pState->m_pPrevModuleState) ==
				&afxModuleState);
			DEBUG_ONLY(pState->m_pPrevModuleState = NULL);
		}
#else
		AfxTermLocalData(hInstance, TRUE);
#endif
	}
	else if (dwReason == DLL_THREAD_DETACH)
	{
#ifdef _AFXDLL
		AFX_MANAGE_STATE_NO_INIT_MANAGED(&afxModuleState);
#endif

#ifdef _DEBUG
		// check for missing AfxLockTempMap calls
		if (AfxGetModuleThreadState()->m_nTempMapLock != 0)
		{
			TRACE(traceAppMsg, 0, "Warning: Temp map lock count non-zero (%ld).\n",
				AfxGetModuleThreadState()->m_nTempMapLock);
		}
#endif
		AfxLockTempMaps();
		AfxUnlockTempMaps(-1);

		AfxTermThread(hInstance);
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// initialize app state such that it points to this module's core state

extern "C" BOOL WINAPI RawDllMain(HINSTANCE, DWORD dwReason, LPVOID);
extern "C" BOOL (WINAPI * const _pActualRawDllMain)(HINSTANCE , DWORD , LPVOID) = &RawDllMain;

extern "C"
BOOL WINAPI RawDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID)
{
	hInstance;
	if (dwReason == DLL_PROCESS_ATTACH)
	{
#ifdef _AFXDLL
		// make sure we have enough memory to attempt to start (8kb)
		void* pMinHeap = LocalAlloc(NONZEROLPTR, 0x2000);
		if (pMinHeap == NULL)
			return FALSE;   // fail if memory alloc fails
		LocalFree(pMinHeap);

		// set module state before initialization
		_AFX_THREAD_STATE* pState = AfxGetThreadState();
		pState->m_pPrevModuleState = AfxSetModuleState(&afxModuleState);
	}
	else if (dwReason == DLL_PROCESS_DETACH && !__mixedModuleStartup)
	{
		// restore module state after cleanup
		_AFX_THREAD_STATE* pState = AfxGetThreadState();
		VERIFY(AfxSetModuleState(pState->m_pPrevModuleState) ==
			&afxModuleState);
		DEBUG_ONLY(pState->m_pPrevModuleState = NULL);

#endif //_AFXDLL
	}
	return TRUE;
}

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	if (__mixedModuleStartup)
	{
		// Skip initialization in mixed mode (done in PostDllMain, see afxdisp.h)
		if (dwReason == DLL_PROCESS_ATTACH)
		{
			// save the module instance
			AFX_MODULE_STATE* pModuleState = AfxGetModuleState();
			pModuleState->m_hCurrentInstanceHandle = hInstance;
#ifdef _AFXDLL
			// restore previously-saved module state
			VERIFY(AfxSetModuleState(AfxGetThreadState()->m_pPrevModuleState) ==
				&afxModuleState);
			DEBUG_ONLY(AfxGetThreadState()->m_pPrevModuleState = NULL);
#endif
			return TRUE;
		}
		else if (dwReason == DLL_PROCESS_DETACH)
		{
			return TRUE;
		}
		else
		{
			return InternalDllMain(hInstance, dwReason, lpReserved);
		}
	}
	else
	{
		return InternalDllMain(hInstance, dwReason, lpReserved);
	}
}

/////////////////////////////////////////////////////////////////////////////
// Special case for static library startup/termination

#ifndef _AFXDLL

// force initialization early
#pragma warning(disable: 4074)
#pragma init_seg(lib)

void AFX_CDECL AfxTermDllState()
{
	// terminate local data and critical sections
	AfxTermLocalData(NULL, TRUE);
	AfxCriticalTerm();

	// release the reference to thread local storage data
	AfxTlsRelease();
}

char _afxTermDllState = (char)(AfxTlsAddRef(), atexit(&AfxTermDllState));

#endif // !_AFXDLL

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\dockstat.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CDockState

AFX_STATIC_DATA const TCHAR _afxVisible[] = _T("Visible");
AFX_STATIC_DATA const TCHAR _afxBarSection[] = _T("%s-Bar%d");
AFX_STATIC_DATA const TCHAR _afxSummarySection[] = _T("%s-Summary");
AFX_STATIC_DATA const TCHAR _afxXPos[] = _T("XPos");
AFX_STATIC_DATA const TCHAR _afxYPos[] = _T("YPos");
AFX_STATIC_DATA const TCHAR _afxMRUWidth[] = _T("MRUWidth");
AFX_STATIC_DATA const TCHAR _afxDocking[] = _T("Docking");
AFX_STATIC_DATA const TCHAR _afxMRUDockID[] = _T("MRUDockID");
AFX_STATIC_DATA const TCHAR _afxMRUDockLeftPos[] = _T("MRUDockLeftPos");
AFX_STATIC_DATA const TCHAR _afxMRUDockRightPos[] = _T("MRUDockRightPos");
AFX_STATIC_DATA const TCHAR _afxMRUDockTopPos[] = _T("MRUDockTopPos");
AFX_STATIC_DATA const TCHAR _afxMRUDockBottomPos[] = _T("MRUDockBottomPos");
AFX_STATIC_DATA const TCHAR _afxMRUFloatStyle[] = _T("MRUFloatStyle");
AFX_STATIC_DATA const TCHAR _afxMRUFloatXPos[] = _T("MRUFloatXPos");
AFX_STATIC_DATA const TCHAR _afxMRUFloatYPos[] = _T("MRUFloatYPos");

AFX_STATIC_DATA const TCHAR _afxBarID[] = _T("BarID");
AFX_STATIC_DATA const TCHAR _afxHorz[] = _T("Horz");
AFX_STATIC_DATA const TCHAR _afxFloating[] = _T("Floating");
AFX_STATIC_DATA const TCHAR _afxBars[] = _T("Bars");
AFX_STATIC_DATA const TCHAR _afxScreenCX[] = _T("ScreenCX");
AFX_STATIC_DATA const TCHAR _afxScreenCY[] = _T("ScreenCY");
AFX_STATIC_DATA const TCHAR _afxBar[] = _T("Bar#%d");

CControlBarInfo::CControlBarInfo()
{
	m_nBarID = 0;
	m_bDockBar = m_bVisible = m_bFloating = m_bHorz = m_bDocking = FALSE;
	m_pBar = NULL;
	m_pointPos.x = m_pointPos.y = -1;
	m_nMRUWidth = 32767;

	m_uMRUDockID = 0;
	m_rectMRUDockPos.SetRectEmpty();
	m_dwMRUFloatStyle = 0;
	m_ptMRUFloatPos = CPoint(0,0);

	ASSERT(sizeof(DWORD_PTR) == sizeof(void*));
}

void CControlBarInfo::Serialize(CArchive& ar, CDockState* pDockState)
{
	ASSERT(pDockState!=NULL);

	if (ar.IsStoring())
	{
		ar << (DWORD)m_nBarID;
		ar << (DWORD)m_bVisible;
		ar << (DWORD)m_bFloating;
		ar << (DWORD)m_bHorz;
		ar << m_pointPos;
		if (pDockState->GetVersion() > 1)
		{
			ar << (DWORD)m_nMRUWidth;
			ar << (DWORD)m_bDocking;
			if (m_bDocking)
			{
				ar << (DWORD)m_uMRUDockID;
				ar << m_rectMRUDockPos;
				ar << m_dwMRUFloatStyle;
				ar << m_ptMRUFloatPos;
			}
		}

		ar << (WORD)m_arrBarID.GetSize();
		if (m_arrBarID.GetSize() != 0)
		{
			ar.Write(&m_arrBarID.ElementAt(0),
				(ULONG)(m_arrBarID.GetSize()*sizeof(UINT)));
		}
	}
	else
	{

		DWORD dw;
		ar >> dw;
		m_nBarID = (int)dw;
		ar >> dw;
		m_bVisible = (BOOL)dw;
		ar >> dw;
		m_bFloating = (BOOL)dw;
		ar >> dw;
		m_bHorz = (BOOL)dw;
		ar >> m_pointPos;

		if (pDockState->GetVersion() > 1)
		{
			pDockState->ScalePoint(m_pointPos);

			ar >> dw;
			m_nMRUWidth = (int)dw;
			ar >> dw;
			m_bDocking = (BOOL)dw;
			if (m_bDocking)
			{
				ar >> dw;
				m_uMRUDockID = (DWORD)dw;
				ar >> m_rectMRUDockPos;
				pDockState->ScaleRectPos(m_rectMRUDockPos);

				ar >> m_dwMRUFloatStyle;
				ar >> m_ptMRUFloatPos;
				pDockState->ScalePoint(m_ptMRUFloatPos);
			}
		}

		WORD w;
		ar >> w;
		m_arrBarID.SetSize(w);
		if (w != 0)
		{
			ar.EnsureRead(&m_arrBarID.ElementAt(0),
				(ULONG)(m_arrBarID.GetSize()*sizeof(UINT)));
		}
	}
}

BOOL CControlBarInfo::LoadState(LPCTSTR lpszProfileName, int nIndex, CDockState* pDockState)
{
	ASSERT(pDockState != NULL);

	CWinApp* pApp = AfxGetApp();
	TCHAR szSection[256];
	ATL_CRT_ERRORCHECK_SPRINTF(_sntprintf_s(szSection, _countof(szSection), _countof(szSection)-1, _afxBarSection, lpszProfileName, nIndex));

	m_nBarID = pApp->GetProfileInt(szSection, _afxBarID, 0);
	m_bVisible = (BOOL) pApp->GetProfileInt(szSection, _afxVisible, TRUE);
	m_bHorz = (BOOL) pApp->GetProfileInt(szSection, _afxHorz, TRUE);
	m_bFloating = (BOOL) pApp->GetProfileInt(szSection, _afxFloating, FALSE);
	m_pointPos = CPoint(
		pApp->GetProfileInt(szSection, _afxXPos, -1),
		pApp->GetProfileInt(szSection, _afxYPos, -1));
	pDockState->ScalePoint(m_pointPos);
	if (m_bFloating)
	{
		if (m_pointPos.x - GetSystemMetrics(SM_CXFRAME) < GetSystemMetrics(SM_XVIRTUALSCREEN))
			m_pointPos.x = GetSystemMetrics(SM_CXFRAME) + GetSystemMetrics(SM_XVIRTUALSCREEN);
		if (m_pointPos.x + GetSystemMetrics(SM_CXFRAME) > GetSystemMetrics(SM_CXVIRTUALSCREEN))
			m_pointPos.x = - GetSystemMetrics(SM_CXFRAME) + GetSystemMetrics(SM_CXVIRTUALSCREEN);
		if (m_pointPos.y - GetSystemMetrics(SM_CYFRAME) - GetSystemMetrics(SM_CYSMCAPTION) < GetSystemMetrics(SM_YVIRTUALSCREEN))
			m_pointPos.y = GetSystemMetrics(SM_CYFRAME) + GetSystemMetrics(SM_CYSMCAPTION) + GetSystemMetrics(SM_YVIRTUALSCREEN);
		if (m_pointPos.y + GetSystemMetrics(SM_CYFRAME) + GetSystemMetrics(SM_CYSMCAPTION) > GetSystemMetrics(SM_CYVIRTUALSCREEN))
			m_pointPos.y = - GetSystemMetrics(SM_CYFRAME) - GetSystemMetrics(SM_CYSMCAPTION) + GetSystemMetrics(SM_CYVIRTUALSCREEN);

		if (!MonitorFromPoint(m_pointPos, MONITOR_DEFAULTTONULL))
		{
			m_pointPos.x = GetSystemMetrics(SM_CXFRAME);
			m_pointPos.y = GetSystemMetrics(SM_CYSMCAPTION) + GetSystemMetrics(SM_CYFRAME);
		}
	}
	
	m_nMRUWidth = pApp->GetProfileInt(szSection, _afxMRUWidth, 32767);
	m_bDocking = pApp->GetProfileInt(szSection, _afxDocking, 0);
	if (m_bDocking)
	{
		m_uMRUDockID = pApp->GetProfileInt(szSection, _afxMRUDockID, 0);

		m_rectMRUDockPos = CRect(
			pApp->GetProfileInt(szSection, _afxMRUDockLeftPos, 0),
			pApp->GetProfileInt(szSection, _afxMRUDockTopPos, 0),
			pApp->GetProfileInt(szSection, _afxMRUDockRightPos, 0),
			pApp->GetProfileInt(szSection, _afxMRUDockBottomPos, 0));
		pDockState->ScaleRectPos(m_rectMRUDockPos);

		m_dwMRUFloatStyle = pApp->GetProfileInt(szSection, _afxMRUFloatStyle, 0);

		m_ptMRUFloatPos = CPoint(
			pApp->GetProfileInt(szSection, _afxMRUFloatXPos, 0),
			pApp->GetProfileInt(szSection, _afxMRUFloatYPos, 0));
		pDockState->ScalePoint(m_ptMRUFloatPos);
	}

	int nBars = pApp->GetProfileInt(szSection, _afxBars, 0);
	for (int i=0; i < nBars; i++)
	{
		TCHAR buf[16];
		_stprintf_s(buf, _countof(buf), _afxBar, i);
		m_arrBarID.Add(pApp->GetProfileInt(szSection, buf, 0));
	}

	return m_nBarID != 0;
}

BOOL CControlBarInfo::SaveState(LPCTSTR lpszProfileName, int nIndex)
{
	TCHAR szSection[256];
	ATL_CRT_ERRORCHECK_SPRINTF(_sntprintf_s(szSection, _countof(szSection), _countof(szSection)-1, _afxBarSection, lpszProfileName, nIndex));

	// delete the section
	CWinApp* pApp = AfxGetApp();
	pApp->WriteProfileString(szSection, NULL, NULL);

	if (m_bDockBar && m_bVisible && !m_bFloating && m_pointPos.x == -1 &&
		m_pointPos.y == -1 && m_arrBarID.GetSize() <= 1)
	{
		return FALSE;
	}

	pApp->WriteProfileInt(szSection, _afxBarID, m_nBarID);
	if (!m_bVisible)
		pApp->WriteProfileInt(szSection, _afxVisible, m_bVisible);
	if (m_bFloating)
	{
		pApp->WriteProfileInt(szSection, _afxHorz, m_bHorz);
		pApp->WriteProfileInt(szSection, _afxFloating, m_bFloating);
	}
	if (m_pointPos.x != -1)
		pApp->WriteProfileInt(szSection, _afxXPos, m_pointPos.x);
	if (m_pointPos.y != -1)
		pApp->WriteProfileInt(szSection, _afxYPos, m_pointPos.y);
	if (m_nMRUWidth != 32767)
		pApp->WriteProfileInt(szSection, _afxMRUWidth, m_nMRUWidth);
	if (m_bDocking)
	{
		pApp->WriteProfileInt(szSection, _afxDocking, m_bDocking);
		pApp->WriteProfileInt(szSection, _afxMRUDockID, m_uMRUDockID);
		pApp->WriteProfileInt(szSection, _afxMRUDockLeftPos, m_rectMRUDockPos.left);
		pApp->WriteProfileInt(szSection, _afxMRUDockTopPos, m_rectMRUDockPos.top);
		pApp->WriteProfileInt(szSection, _afxMRUDockRightPos, m_rectMRUDockPos.right);
		pApp->WriteProfileInt(szSection, _afxMRUDockBottomPos, m_rectMRUDockPos.bottom);
		pApp->WriteProfileInt(szSection, _afxMRUFloatStyle, m_dwMRUFloatStyle);
		pApp->WriteProfileInt(szSection, _afxMRUFloatXPos, m_ptMRUFloatPos.x);
		pApp->WriteProfileInt(szSection, _afxMRUFloatYPos, m_ptMRUFloatPos.y);
	}

	if (m_arrBarID.GetSize() > 1) //if ==1 then still empty
	{
		pApp->WriteProfileInt(szSection, _afxBars, (int)m_arrBarID.GetSize());
		for (int i = 0; i < m_arrBarID.GetSize(); i++)
		{
			TCHAR buf[16];
			_stprintf_s(buf, _countof(buf), _afxBar, i);
			pApp->WriteProfileInt(szSection, buf, m_arrBarID[i]);
		}
	}
	return TRUE;
}

CDockState::CDockState()
{
	m_dwVersion = 2;

	m_bScaling = FALSE;

	m_rectDevice.left = 0;
	m_rectDevice.top = 0;
	m_rectDevice.right = GetSystemMetrics(SM_CXSCREEN);
	m_rectDevice.bottom = GetSystemMetrics(SM_CYSCREEN);

	m_rectClip.left = GetSystemMetrics(SM_XVIRTUALSCREEN);
	m_rectClip.top = GetSystemMetrics(SM_YVIRTUALSCREEN);
	m_rectClip.right = GetSystemMetrics(SM_CXVIRTUALSCREEN);
	m_rectClip.bottom = GetSystemMetrics(SM_CYVIRTUALSCREEN);

	m_rectClip.right -= GetSystemMetrics(SM_CXICON);
	m_rectClip.bottom -= GetSystemMetrics(SM_CYICON) + GetSystemMetrics(SM_CYSMCAPTION);
}

CDockState::~CDockState()
{
	for (int i = 0; i < m_arrBarInfo.GetSize(); i++)
		delete (CControlBarInfo*)m_arrBarInfo[i];
}

void CDockState::Serialize(CArchive& ar)
{
	// read/write version info
	if (ar.IsStoring())
	{
		ar << m_dwVersion;

		if (m_dwVersion > 1)
		{
			ar << GetScreenSize();
		}

		// write array contents
		ar << (WORD)m_arrBarInfo.GetSize();
		for (int i = 0; i < m_arrBarInfo.GetSize(); i++)
			((CControlBarInfo*)m_arrBarInfo[i])->Serialize(ar, this);
	}
	else
	{
		Clear(); //empty out dockstate
		ar >> m_dwVersion;       // read version marker
		ASSERT(m_dwVersion == 1 || m_dwVersion == 2);

		if (m_dwVersion > 1)
		{
			CSize size;
			ar >> size;
			SetScreenSize(size);
		}

		// read array contents
		WORD nOldSize;
		ar >> nOldSize;
		m_arrBarInfo.SetSize(nOldSize);
		for (int i = 0; i < m_arrBarInfo.GetSize(); i++)
		{
			m_arrBarInfo[i] = new CControlBarInfo;
			((CControlBarInfo*)m_arrBarInfo[i])->Serialize(ar, this);
		}
		m_dwVersion = 2;
	}
}

void CDockState::LoadState(LPCTSTR lpszProfileName)
{
	CWinApp* pApp = AfxGetApp();
	TCHAR szSection[256];
	ATL_CRT_ERRORCHECK_SPRINTF(_sntprintf_s(szSection, _countof(szSection), _countof(szSection)-1, _afxSummarySection, lpszProfileName));

	int nBars = pApp->GetProfileInt(szSection, _afxBars, 0);

	CSize size;
	size.cx = pApp->GetProfileInt(szSection, _afxScreenCX, 0);
	size.cy = pApp->GetProfileInt(szSection, _afxScreenCY, 0);
	SetScreenSize(size);

	// delete current information since the new one is about to be loaded
	for (int i = 0; i < m_arrBarInfo.GetSize(); i++)
	{
		delete m_arrBarInfo[i];
	}
	m_arrBarInfo.SetSize(0);
	for (int i = 0; i < nBars; i++)
	{
		CControlBarInfo* pInfo = new CControlBarInfo;
		m_arrBarInfo.Add(pInfo);
		pInfo->LoadState(lpszProfileName, i, this);
	}
}

void CDockState::SaveState(LPCTSTR lpszProfileName)
{
	int nIndex = 0;
	for (int i = 0;i < m_arrBarInfo.GetSize(); i++)
	{
		CControlBarInfo* pInfo = (CControlBarInfo*)m_arrBarInfo[i];
		ASSERT(pInfo != NULL);
		if (pInfo->SaveState(lpszProfileName, nIndex))
			nIndex++;
	}
	CWinApp* pApp = AfxGetApp();
	TCHAR szSection[256];
	ATL_CRT_ERRORCHECK_SPRINTF(_sntprintf_s(szSection, _countof(szSection), _countof(szSection)-1, _afxSummarySection, lpszProfileName));
	pApp->WriteProfileInt(szSection, _afxBars, nIndex);

	CSize size = GetScreenSize();
	pApp->WriteProfileInt(szSection, _afxScreenCX, size.cx);
	pApp->WriteProfileInt(szSection, _afxScreenCY, size.cy);
}

void CDockState::Clear()
{
	for (int i = 0; i < m_arrBarInfo.GetSize(); i++)
		delete (CControlBarInfo*) m_arrBarInfo[i];
	m_arrBarInfo.RemoveAll();
}

DWORD CDockState::GetVersion()
{
	return m_dwVersion;
}

void CDockState::ScalePoint(CPoint& pt)
{
	if (m_bScaling)
	{
		CSize sizeDevice = m_rectDevice.Size();

		pt.x = MulDiv(pt.x, sizeDevice.cx, m_sizeLogical.cx);
		pt.y = MulDiv(pt.y, sizeDevice.cy, m_sizeLogical.cy);
	}

	if (pt.x > m_rectClip.right)
		pt.x = m_rectClip.right;
	if (pt.y > m_rectClip.bottom)
		pt.y = m_rectClip.bottom;
}

void CDockState::ScaleRectPos(CRect& rect)
{
	CPoint pt;

	if (m_bScaling)
	{
		pt = rect.TopLeft();
		CSize sizeDevice = m_rectDevice.Size();

		pt.x = MulDiv(pt.x, sizeDevice.cx, m_sizeLogical.cx) - rect.left;
		pt.y = MulDiv(pt.y, sizeDevice.cy, m_sizeLogical.cy) - rect.top;
		rect.OffsetRect(pt);
	}
	pt.x = pt.y = 0;

	if (rect.left > m_rectClip.right)
		pt.x = m_rectClip.right - rect.left;
	else if (rect.left < m_rectClip.left)
		pt.x = m_rectClip.left - rect.left;
	if (rect.top > m_rectClip.bottom)
		pt.y = m_rectClip.bottom - rect.top;
	else if (rect.top < m_rectClip.top)
		pt.y = m_rectClip.top - rect.top;

	if (!((pt.x == 0) && (pt.y == 0)))
		rect.OffsetRect(pt);
}

CSize CDockState::GetScreenSize()
{
	return m_rectDevice.Size();
}

void CDockState::SetScreenSize(CSize& size)
{
	m_sizeLogical = size;
	m_bScaling = (size != m_rectDevice.Size());
}

void CFrameWnd::LoadBarState(LPCTSTR lpszProfileName)
{
	CDockState state;
	state.LoadState(lpszProfileName);
	SetDockState(state);
}

void CFrameWnd::SaveBarState(LPCTSTR lpszProfileName) const
{
	CDockState state;
	GetDockState(state);
	state.SaveState(lpszProfileName);
}

void CFrameWnd::SetDockState(const CDockState& state)
{
	int i;

	// first pass through barinfo's sets the m_pBar member correctly
	// creating floating frames or docking floating controls if necessary
	for (i = 0; i < state.m_arrBarInfo.GetSize(); i++)
	{
		CControlBarInfo* pInfo = (CControlBarInfo*)state.m_arrBarInfo[i];
		ASSERT(pInfo != NULL);
		if (pInfo->m_bFloating) // control is floating in the loading state
		{
			// need to create floating frame to match
			CMiniDockFrameWnd* pDockFrame = CreateFloatingFrame(
				pInfo->m_bHorz ? CBRS_ALIGN_TOP : CBRS_ALIGN_LEFT);
			ASSERT(pDockFrame != NULL);
			CRect rect(pInfo->m_pointPos, CSize(10, 10));
			pDockFrame->CalcWindowRect(&rect);
			pDockFrame->SetWindowPos(NULL, rect.left, rect.top, 0, 0,
				SWP_NOSIZE|SWP_NOZORDER|SWP_NOACTIVATE);
			CDockBar* pDockBar =
				(CDockBar*)pDockFrame->GetDlgItem(AFX_IDW_DOCKBAR_FLOAT);
			ASSERT(pDockBar != NULL);
			ASSERT_KINDOF(CDockBar, pDockBar);
			pInfo->m_pBar = pDockBar;
		}
		else // regular dock bar or toolbar in the loading state
		{
			pInfo->m_pBar = GetControlBar(pInfo->m_nBarID);
			ASSERT(pInfo->m_pBar != NULL); //toolbar id's probably changed

			if (pInfo->m_pBar != NULL)
			{
				if ((pInfo->m_pBar->m_pDockBar != NULL) && 
					(pInfo->m_pBar->m_pDockBar->m_bFloating)) // control is floating in the current state
				{
					// need to dock the control bar
					DockControlBar (pInfo->m_pBar);
				}
			}
		}
		if (pInfo->m_pBar != NULL)
			pInfo->m_pBar->m_nMRUWidth = pInfo->m_nMRUWidth;
	}

	// the second pass will actually dock all of the control bars and
	//  set everything correctly
	for (i = 0; i < state.m_arrBarInfo.GetSize(); i++)
	{
		CControlBarInfo* pInfo = (CControlBarInfo*)state.m_arrBarInfo[i];
		ASSERT(pInfo != NULL);
		if (pInfo->m_pBar != NULL)
			pInfo->m_pBar->SetBarInfo(pInfo, this);
	}

	// last pass shows all the floating windows that were previously shown
	for (i = 0; i < state.m_arrBarInfo.GetSize(); i++)
	{
		CControlBarInfo* pInfo = (CControlBarInfo*)state.m_arrBarInfo[i];
		ASSERT(pInfo != NULL);
		ASSERT(pInfo->m_pBar != NULL);
		if(pInfo->m_pBar != NULL)
		{
			if (pInfo->m_bFloating)
			{
				CDockBar* pDockBar = (CDockBar*)pInfo->m_pBar;
				ASSERT_KINDOF(CDockBar, pDockBar);
				if (pDockBar->GetDockedVisibleCount() > 0)
				{
    				CFrameWnd* pFrameWnd = pInfo->m_pBar->EnsureParentFrame();
					pFrameWnd->RecalcLayout();
					pFrameWnd->ShowWindow(SW_SHOWNA);
				}
			}
		}
	}
	DelayRecalcLayout();
}

void CFrameWnd::GetDockState(CDockState& state) const
{
	state.Clear(); //make sure dockstate is empty
	// get state info for each bar
	POSITION pos = m_listControlBars.GetHeadPosition();
	while (pos != NULL)
	{
		CControlBar* pBar = (CControlBar*)m_listControlBars.GetNext(pos);
		ASSERT(pBar != NULL);
		CControlBarInfo* pInfo = new CControlBarInfo;
		pBar->GetBarInfo(pInfo);
		state.m_arrBarInfo.Add(pInfo);
	}
}

// Note: GetBarInfo and SetBarInfo are not virtual since doing so adds
//  to much code to an application which does not save and load docking
//  state.  For this reason, the CControlBar implementations must
//  delagate to CDockBar as appropriate.

void CControlBar::GetBarInfo(CControlBarInfo* pInfo)
{
	ASSERT_VALID(this);

	// get state info
	pInfo->m_nBarID = _AfxGetDlgCtrlID(m_hWnd);
	pInfo->m_pBar = this;
	pInfo->m_bVisible = IsVisible(); // handles delayed showing and hiding
	pInfo->m_nMRUWidth = m_nMRUWidth;

	if (m_pDockBar != NULL) // don't need position unless docked
	{
		CRect rect;
		GetWindowRect(&rect);
		m_pDockBar->ScreenToClient(&rect);
		pInfo->m_pointPos = rect.TopLeft();

		ASSERT(m_pDockContext != NULL);
		pInfo->m_bDocking = TRUE;
		pInfo->m_uMRUDockID = m_pDockContext->m_uMRUDockID;
		pInfo->m_rectMRUDockPos = m_pDockContext->m_rectMRUDockPos;
		pInfo->m_dwMRUFloatStyle = m_pDockContext->m_dwMRUFloatStyle;
		pInfo->m_ptMRUFloatPos = m_pDockContext->m_ptMRUFloatPos;
	}

	// save dockbar specific parts
	if (IsDockBar())
		((CDockBar*)this)->GetBarInfo(pInfo);
}

void CControlBar::SetBarInfo(CControlBarInfo* pInfo, CFrameWnd* pFrameWnd)
{
	// dockbars are handled differently
	if (IsDockBar())
	{
		((CDockBar*)this)->SetBarInfo(pInfo, pFrameWnd);
		return;
	}

	// don't set position when not docked
	UINT nFlags = SWP_NOSIZE|SWP_NOACTIVATE|SWP_NOZORDER;
	if (m_pDockBar == NULL)
		nFlags |= SWP_NOMOVE;

	m_nMRUWidth = pInfo->m_nMRUWidth;
	CalcDynamicLayout(0, LM_HORZ | LM_MRUWIDTH | LM_COMMIT);

	if (pInfo->m_bDocking)
	{
		ASSERT(m_pDockContext != NULL);
		// You need to call EnableDocking before calling LoadBarState

		m_pDockContext->m_uMRUDockID = pInfo->m_uMRUDockID;
		m_pDockContext->m_rectMRUDockPos = pInfo->m_rectMRUDockPos;
		m_pDockContext->m_dwMRUFloatStyle = pInfo->m_dwMRUFloatStyle;
		m_pDockContext->m_ptMRUFloatPos = pInfo->m_ptMRUFloatPos;
	}

	// move and show/hide the window
	SetWindowPos(NULL, pInfo->m_pointPos.x, pInfo->m_pointPos.y, 0, 0,
		nFlags | (pInfo->m_bVisible ? SWP_SHOWWINDOW : SWP_HIDEWINDOW));
}

void CDockBar::GetBarInfo(CControlBarInfo* pInfo)
{
	ASSERT_VALID(this);

	pInfo->m_bDockBar = TRUE;
	pInfo->m_bFloating = m_bFloating;
	if (m_bFloating)
	{
		CRect rect;
		GetWindowRect(&rect);
		pInfo->m_pointPos = rect.TopLeft();
	}
	pInfo->m_bHorz = m_dwStyle & CBRS_ORIENT_HORZ ? TRUE : FALSE;
	for (int i = 0; i < m_arrBars.GetSize(); i++)
	{
		CControlBar* pBar = (CControlBar*)m_arrBars[i];
		if (pBar != NULL && (DWORD_PTR(pBar) <= 0xffff))
		{
			WORD w = LOWORD(((DWORD_PTR)pBar));
			pInfo->m_arrBarID.Add((UINT)MAKELONG(w, 1));
		}
		else
		{
			pInfo->m_arrBarID.Add(pBar == NULL ?
				0 : _AfxGetDlgCtrlID(pBar->m_hWnd));
		}
	}
}

void CDockBar::SetBarInfo(CControlBarInfo* pInfo, CFrameWnd* pFrameWnd)
{
	ASSERT(pFrameWnd != NULL);
	ASSERT_VALID(this);

	int nSize = (int)pInfo->m_arrBarID.GetSize();
	// don't insert trailing NULLs
	while (nSize != 0 && (pInfo->m_arrBarID[nSize-1] == 0 ||
		pInfo->m_arrBarID[nSize-1] == (UINT)MAKELONG(0, 1)))
	{
		nSize--;
	}
	// start at 1 to avoid inserting leading NULL
	for (int i = 1; i < nSize; i++)
	{
		CControlBar* pBar = NULL;
		if (pInfo->m_arrBarID[i] <= 0xffff)
		{
			pBar = pFrameWnd->GetControlBar(pInfo->m_arrBarID[i]);
			if (pBar != NULL)
			{
				if (pBar->GetParent() != this)
					pBar->SetParent(this);
				if (pBar->m_pDockBar != NULL)
					pBar->m_pDockBar->RemoveControlBar(pBar, -1, -1);
				//remove the ID place holder if it exists in this dockbar
				RemovePlaceHolder(pBar);
				pBar->m_pDockBar = this;

				// align correctly and turn on all borders
				DWORD dwStyle = pBar->GetBarStyle();
				dwStyle &= ~(CBRS_ALIGN_ANY);
				dwStyle |= (m_dwStyle & CBRS_ALIGN_ANY);
				dwStyle |= CBRS_BORDER_ANY;
				if (m_bFloating)
					dwStyle |= CBRS_FLOATING;
				else
					dwStyle &= ~CBRS_FLOATING;
				pBar->SetBarStyle(dwStyle);

				// handle special case for floating toolbars
				if (m_bFloating)
				{
					// set CBRS_FLOAT_MULTI style if docking bar has it
					if (pBar->m_dwDockStyle & CBRS_FLOAT_MULTI)
						m_dwStyle |= CBRS_FLOAT_MULTI;

					// set owner of parent frame as appropriate
					CFrameWnd* pDockFrame = pBar->EnsureParentFrame();
					ASSERT(pDockFrame != pBar->m_pDockSite);
					if (pDockFrame->m_hWndOwner == NULL)
						pDockFrame->m_hWndOwner = pBar->m_hWnd;

					if (pBar->m_dwStyle & CBRS_SIZE_DYNAMIC)
						pDockFrame->ModifyStyle(MFS_MOVEFRAME, 0);
				}

				// set initial text of the dock bar
				if (i == 1 && !(m_dwStyle & CBRS_FLOAT_MULTI))
				{
					CString strTitle;
					pBar->GetWindowText(strTitle);
					AfxSetWindowText(m_hWnd, strTitle);
				}
			}
		}
		else
		{
			WORD w = (WORD)pInfo->m_arrBarID[i];
			pBar = (CControlBar*)(LONG_PTR)MAKELONG(w, 0);
			RemovePlaceHolder(pBar);
		}
		m_arrBars.InsertAt(i, pBar);
	}
	int nArrSize = (int)m_arrBars.GetSize();
	if (nSize < nArrSize && m_arrBars[nSize] != NULL)
	{
		m_arrBars.InsertAt(nSize, (void*)NULL);
		nArrSize++;
	}
	if (m_arrBars[nArrSize-1] != NULL)
		m_arrBars.InsertAt(nArrSize, (void*)NULL);
	ASSERT_VALID(this);
}


IMPLEMENT_SERIAL(CDockState, CObject, 0)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\docmulti.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CMultiDocTemplate construction/destruction

CMultiDocTemplate::CMultiDocTemplate(UINT nIDResource, CRuntimeClass* pDocClass,
	CRuntimeClass* pFrameClass, CRuntimeClass* pViewClass)
		: CDocTemplate(nIDResource, pDocClass, pFrameClass, pViewClass)
{
	ASSERT(m_docList.IsEmpty());

	m_hMenuShared = NULL;
	m_hAccelTable = NULL;
	m_nUntitledCount = 0;   // start at 1

	// load resources in constructor if not statically allocated
	if (!CDocManager::bStaticInit)
		LoadTemplate();
}

void CMultiDocTemplate::LoadTemplate()
{
	CDocTemplate::LoadTemplate();

	if (m_nIDResource != 0 && m_hMenuShared == NULL)
	{
		HINSTANCE hInst = AfxFindResourceHandle(
			MAKEINTRESOURCE(m_nIDResource), RT_MENU);
		m_hMenuShared = ::LoadMenuW(hInst, MAKEINTRESOURCEW(m_nIDResource));
		m_hAccelTable =
			::LoadAcceleratorsW(hInst, MAKEINTRESOURCEW(m_nIDResource));
	}

#ifdef _DEBUG
	// warnings about missing components (don't bother with accelerators)
	if (m_hMenuShared == NULL)
		TRACE(traceAppMsg, 0, "Warning: no shared menu for document template #%d.\n",
			m_nIDResource);
#endif //_DEBUG
}

CMultiDocTemplate::~CMultiDocTemplate()
{
#ifdef _DEBUG
	if (!m_docList.IsEmpty())
		TRACE(traceAppMsg, 0, "Warning: destroying CMultiDocTemplate with %d documents alive.\n",
			m_docList.GetCount());
#endif
	// delete shared components
	if (m_hMenuShared != NULL)
		::DestroyMenu(m_hMenuShared);
	if (m_hAccelTable != NULL)
		::FreeResource((HGLOBAL)m_hAccelTable);
}

/////////////////////////////////////////////////////////////////////////////
// CMultiDocTemplate attributes

POSITION CMultiDocTemplate::GetFirstDocPosition() const
{
	return m_docList.GetHeadPosition();
}

CDocument* CMultiDocTemplate::GetNextDoc(POSITION& rPos) const
{
	return (CDocument*)m_docList.GetNext(rPos);
}

/////////////////////////////////////////////////////////////////////////////
// CMultiDocTemplate document management (a list of currently open documents)

void CMultiDocTemplate::AddDocument(CDocument* pDoc)
{
	ASSERT_VALID(pDoc);

	CDocTemplate::AddDocument(pDoc);
	ASSERT(m_docList.Find(pDoc, NULL) == NULL); // must not be in list
	m_docList.AddTail(pDoc);
}


void CMultiDocTemplate::RemoveDocument(CDocument* pDoc)
{
	ASSERT_VALID(pDoc);

	CDocTemplate::RemoveDocument(pDoc);
	m_docList.RemoveAt(m_docList.Find(pDoc));
}

/////////////////////////////////////////////////////////////////////////////
// CMultiDocTemplate commands

CDocument* CMultiDocTemplate::OpenDocumentFile(LPCTSTR lpszPathName, BOOL bMakeVisible)
{
	return OpenDocumentFile(lpszPathName, TRUE, bMakeVisible);
}

CDocument* CMultiDocTemplate::OpenDocumentFile(LPCTSTR lpszPathName, BOOL bAddToMRU, BOOL bMakeVisible)
{
	CDocument* pDocument = CreateNewDocument();
	if (pDocument == NULL)
	{
		TRACE(traceAppMsg, 0, "CDocTemplate::CreateNewDocument returned NULL.\n");
		AfxMessageBox(AFX_IDP_FAILED_TO_CREATE_DOC);
		return NULL;
	}
	ASSERT_VALID(pDocument);

	BOOL bAutoDelete = pDocument->m_bAutoDelete;
	pDocument->m_bAutoDelete = FALSE;   // don't destroy if something goes wrong
	CFrameWnd* pFrame = CreateNewFrame(pDocument, NULL);
	pDocument->m_bAutoDelete = bAutoDelete;
	if (pFrame == NULL)
	{
		AfxMessageBox(AFX_IDP_FAILED_TO_CREATE_DOC);
		delete pDocument;       // explicit delete on error
		return NULL;
	}
	ASSERT_VALID(pFrame);

	if (lpszPathName == NULL)
	{
		// create a new document - with default document name
		SetDefaultTitle(pDocument);

		// avoid creating temporary compound file when starting up invisible
		if (!bMakeVisible)
			pDocument->m_bEmbedded = TRUE;

		if (!pDocument->OnNewDocument())
		{
			// user has be alerted to what failed in OnNewDocument
			TRACE(traceAppMsg, 0, "CDocument::OnNewDocument returned FALSE.\n");
			pFrame->DestroyWindow();
			return NULL;
		}

		// it worked, now bump untitled count
		m_nUntitledCount++;
	}
	else
	{
		// open an existing document
		CWaitCursor wait;
		if (!pDocument->OnOpenDocument(lpszPathName))
		{
			// user has be alerted to what failed in OnOpenDocument
			TRACE(traceAppMsg, 0, "CDocument::OnOpenDocument returned FALSE.\n");
			pFrame->DestroyWindow();
			return NULL;
		}
		pDocument->SetPathName(lpszPathName, bAddToMRU);
		pDocument->OnDocumentEvent(CDocument::onAfterOpenDocument);
	}

	InitialUpdateFrame(pFrame, pDocument, bMakeVisible);
	return pDocument;
}

void CMultiDocTemplate::SetDefaultTitle(CDocument* pDocument)
{
	CString strDocName;
	if (GetDocString(strDocName, CDocTemplate::docName) &&
		!strDocName.IsEmpty())
	{
		TCHAR szNum[16];
		_stprintf_s(szNum, _countof(szNum), _T("%d"), m_nUntitledCount+1);
		strDocName += szNum;
	}
	else
	{
		// use generic 'untitled' - ignore untitled count
		ENSURE(strDocName.LoadString(AFX_IDS_UNTITLED));
	}
	pDocument->SetTitle(strDocName);
}

/////////////////////////////////////////////////////////////////////////////
// CMultiDocTemplate diagnostics

#ifdef _DEBUG
void CMultiDocTemplate::Dump(CDumpContext& dc) const
{
	CDocTemplate::Dump(dc);

	dc << "m_hMenuShared = " << m_hMenuShared;
	dc << "\nm_hAccelTable = " << m_hAccelTable;
	dc << "\nm_nUntitledCount = " << m_nUntitledCount;
	dc << "\nwith " << LONGLONG(m_docList.GetCount()) << " open documents";
	POSITION pos = GetFirstDocPosition();
	while (pos != NULL)
	{
		CDocument* pDoc = GetNextDoc(pos);
		dc << "\nwith document " << (void*)pDoc;
	}

	dc << "\n";
}

void CMultiDocTemplate::AssertValid() const
{
	CDocTemplate::AssertValid();

	POSITION pos = GetFirstDocPosition();
	while (pos != NULL)
	{
		CDocument* pDoc = GetNextDoc(pos);
		ASSERT_VALID(pDoc);
	}
}
#endif //_DEBUG


IMPLEMENT_DYNAMIC(CMultiDocTemplate, CDocTemplate)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\docsingl.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CSingleDocTemplate construction/destruction

CSingleDocTemplate::CSingleDocTemplate(UINT nIDResource,
	CRuntimeClass* pDocClass, CRuntimeClass* pFrameClass,
	CRuntimeClass* pViewClass)
		: CDocTemplate(nIDResource, pDocClass, pFrameClass, pViewClass)
{
	m_pOnlyDoc = NULL;
}

CSingleDocTemplate::~CSingleDocTemplate()
{
#ifdef _DEBUG
	if (m_pOnlyDoc != NULL)
		TRACE(traceAppMsg, 0, "Warning: destroying CSingleDocTemplate with live document.\n");
#endif
}

/////////////////////////////////////////////////////////////////////////////
// CSingleDocTemplate attributes

POSITION CSingleDocTemplate::GetFirstDocPosition() const
{
	return (m_pOnlyDoc == NULL) ? NULL : BEFORE_START_POSITION;
}

CDocument* CSingleDocTemplate::GetNextDoc(POSITION& rPos) const
{
	CDocument* pDoc = NULL;
	if (rPos == BEFORE_START_POSITION)
	{
		// first time through, return a real document
		ASSERT(m_pOnlyDoc != NULL);
		pDoc = m_pOnlyDoc;
	}
	rPos = NULL;        // no more
	return pDoc;
}

/////////////////////////////////////////////////////////////////////////////
// CSingleDocTemplate document management (a list of currently open documents)

void CSingleDocTemplate::AddDocument(CDocument* pDoc)
{
	ASSERT(m_pOnlyDoc == NULL);     // one at a time please
	ASSERT_VALID(pDoc);

	CDocTemplate::AddDocument(pDoc);
	m_pOnlyDoc = pDoc;
}

void CSingleDocTemplate::RemoveDocument(CDocument* pDoc)
{
	ASSERT(m_pOnlyDoc == pDoc);     // must be this one
	ASSERT_VALID(pDoc);

	CDocTemplate::RemoveDocument(pDoc);
	m_pOnlyDoc = NULL;
}

/////////////////////////////////////////////////////////////////////////////
// CSingleDocTemplate commands

extern BOOL g_bRemoveFromMRU;

CDocument* CSingleDocTemplate::OpenDocumentFile(LPCTSTR lpszPathName, BOOL bMakeVisible)
{
	return OpenDocumentFile(lpszPathName, TRUE, bMakeVisible);
}

CDocument* CSingleDocTemplate::OpenDocumentFile(LPCTSTR lpszPathName, BOOL bAddToMRU, BOOL bMakeVisible)
{
	CDocument* pDocument = NULL;
	CFrameWnd* pFrame = NULL;
	BOOL bCreated = FALSE;      // => doc and frame created
	BOOL bWasModified = FALSE;

	if (m_pOnlyDoc != NULL)
	{
		// already have a document - reinit it
		pDocument = m_pOnlyDoc;
		if (!pDocument->SaveModified())
		{
			// set a flag to indicate that the document being opened should not
			// be removed from the MRU list, if it was being opened from there
			g_bRemoveFromMRU = FALSE;
			return NULL;        // leave the original one
		}

		pFrame = (CFrameWnd*)AfxGetMainWnd();
		ASSERT(pFrame != NULL);
		ASSERT_KINDOF(CFrameWnd, pFrame);
		ASSERT_VALID(pFrame);
	}
	else
	{
		// create a new document
		pDocument = CreateNewDocument();
		ASSERT(pFrame == NULL);     // will be created below
		bCreated = TRUE;
	}

	if (pDocument == NULL)
	{
		AfxMessageBox(AFX_IDP_FAILED_TO_CREATE_DOC);
		return NULL;
	}
	ASSERT(pDocument == m_pOnlyDoc);

	if (pFrame == NULL)
	{
		ASSERT(bCreated);

		// create frame - set as main document frame
		BOOL bAutoDelete = pDocument->m_bAutoDelete;
		pDocument->m_bAutoDelete = FALSE;
					// don't destroy if something goes wrong
		pFrame = CreateNewFrame(pDocument, NULL);
		pDocument->m_bAutoDelete = bAutoDelete;
		if (pFrame == NULL)
		{
			AfxMessageBox(AFX_IDP_FAILED_TO_CREATE_DOC);
			delete pDocument;       // explicit delete on error
			return NULL;
		}
	}

	if (lpszPathName == NULL)
	{
		// create a new document
		SetDefaultTitle(pDocument);

		// avoid creating temporary compound file when starting up invisible
		if (!bMakeVisible)
			pDocument->m_bEmbedded = TRUE;

		if (!pDocument->OnNewDocument())
		{
			// user has been alerted to what failed in OnNewDocument
			TRACE(traceAppMsg, 0, "CDocument::OnNewDocument returned FALSE.\n");
			if (bCreated)
				pFrame->DestroyWindow();    // will destroy document
			return NULL;
		}
	}
	else
	{
		CWaitCursor wait;

		// open an existing document
		bWasModified = pDocument->IsModified();
		pDocument->SetModifiedFlag(FALSE);  // not dirty for open

		if (!pDocument->OnOpenDocument(lpszPathName))
		{
			// user has been alerted to what failed in OnOpenDocument
			TRACE(traceAppMsg, 0, "CDocument::OnOpenDocument returned FALSE.\n");
			if (bCreated)
			{
				pFrame->DestroyWindow();    // will destroy document
			}
			else if (!pDocument->IsModified())
			{
				// original document is untouched
				pDocument->SetModifiedFlag(bWasModified);
			}
			else
			{
				// we corrupted the original document
				SetDefaultTitle(pDocument);

				if (!pDocument->OnNewDocument())
				{
					TRACE(traceAppMsg, 0, "Error: OnNewDocument failed after trying "
						"to open a document - trying to continue.\n");
					// assume we can continue
				}
			}
			return NULL;        // open failed
		}
		pDocument->SetPathName(lpszPathName, bAddToMRU);
		pDocument->OnDocumentEvent(CDocument::onAfterOpenDocument);
	}

	CWinThread* pThread = AfxGetThread();
	ASSERT(pThread);
	if (bCreated && pThread->m_pMainWnd == NULL)
	{
		// set as main frame (InitialUpdateFrame will show the window)
		pThread->m_pMainWnd = pFrame;
	}
	InitialUpdateFrame(pFrame, pDocument, bMakeVisible);

	return pDocument;
}

void CSingleDocTemplate::SetDefaultTitle(CDocument* pDocument)
{
	CString strDocName;
	if (!GetDocString(strDocName, CDocTemplate::docName) ||
		strDocName.IsEmpty())
	{
		// use generic 'untitled'
		ENSURE(strDocName.LoadString(AFX_IDS_UNTITLED));
	}
	pDocument->SetTitle(strDocName);
}

/////////////////////////////////////////////////////////////////////////////
// CSingleDocTemplate diagnostics

#ifdef _DEBUG
void CSingleDocTemplate::Dump(CDumpContext& dc) const
{
	CDocTemplate::Dump(dc);

	if (m_pOnlyDoc)
		dc << "with document: " << (void*)m_pOnlyDoc;
	else
		dc << "with no document";

	dc << "\n";
}

void CSingleDocTemplate::AssertValid() const
{
	CDocTemplate::AssertValid();
	if (m_pOnlyDoc)
		ASSERT_VALID(m_pOnlyDoc);
}
#endif //_DEBUG


IMPLEMENT_DYNAMIC(CSingleDocTemplate, CDocTemplate)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\doctempl.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CDocTemplate construction/destruction

CDocTemplate::CDocTemplate(UINT nIDResource, CRuntimeClass* pDocClass,
	CRuntimeClass* pFrameClass, CRuntimeClass* pViewClass)
{
	ASSERT_VALID_IDR(nIDResource);
	ASSERT(pDocClass == NULL ||
		pDocClass->IsDerivedFrom(RUNTIME_CLASS(CDocument)));
	ASSERT(pFrameClass == NULL ||
		pFrameClass->IsDerivedFrom(RUNTIME_CLASS(CFrameWnd)));
	ASSERT(pViewClass == NULL ||
		pViewClass->IsDerivedFrom(RUNTIME_CLASS(CView)));

	m_nIDResource = nIDResource;
	m_nIDServerResource = NULL;
	m_nIDEmbeddingResource = NULL;
	m_nIDContainerResource = NULL;
	m_nIDPreviewResource = NULL;

	m_pDocClass = pDocClass;
	m_pFrameClass = pFrameClass;
	m_pViewClass = pViewClass;
	m_pOleFrameClass = NULL;
	m_pOleViewClass = NULL;

	
	m_pPreviewFrameClass = NULL;
	m_pPreviewViewClass = NULL;

	m_pAttachedFactory = NULL;
	m_hMenuInPlace = NULL;
	m_hAccelInPlace = NULL;
	m_hMenuEmbedding = NULL;
	m_hAccelEmbedding = NULL;
	m_hMenuInPlaceServer = NULL;
	m_hAccelInPlaceServer = NULL;

	// add to pStaticList if constructed as static instead of on heap
	if (CDocManager::bStaticInit)
	{
		m_bAutoDelete = FALSE;
		if (CDocManager::pStaticList == NULL)
			CDocManager::pStaticList = new CPtrList;
		if (CDocManager::pStaticDocManager == NULL)
			CDocManager::pStaticDocManager = new CDocManager;
		CDocManager::pStaticList->AddTail(this);
	}
	else
	{
		m_bAutoDelete = TRUE;   // usually allocated on the heap
		LoadTemplate();
	}
}

void CDocTemplate::LoadTemplate()
{
	if (m_strDocStrings.IsEmpty() && !m_strDocStrings.LoadString(m_nIDResource))
	{
		TRACE(traceAppMsg, 0, "Warning: no document names in string for template #%d.\n",
			m_nIDResource);
	}

	if (m_nIDEmbeddingResource != 0 && m_hMenuEmbedding == NULL)
	{
		// load menu to be used while editing an embedding (as a server)
		HINSTANCE hInst = AfxFindResourceHandle(
			MAKEINTRESOURCE(m_nIDEmbeddingResource), RT_MENU);
		m_hMenuEmbedding =
			::LoadMenuW(hInst, MAKEINTRESOURCEW(m_nIDEmbeddingResource));
		m_hAccelEmbedding =
			::LoadAcceleratorsW(hInst, MAKEINTRESOURCEW(m_nIDEmbeddingResource));
	}
	if (m_nIDServerResource != 0 && m_hMenuInPlaceServer == NULL)
	{
		// load menu to be used while editing in-place (as a server)
		HINSTANCE hInst = AfxFindResourceHandle(
			MAKEINTRESOURCE(m_nIDServerResource), RT_MENU);
		m_hMenuInPlaceServer = ::LoadMenuW(hInst,
			MAKEINTRESOURCEW(m_nIDServerResource));
		m_hAccelInPlaceServer = ::LoadAcceleratorsW(hInst,
			MAKEINTRESOURCEW(m_nIDServerResource));
	}

	if (m_nIDContainerResource != 0 && m_hMenuInPlace == NULL)
	{
		// load menu to be used while in-place editing session (as a container)
		HINSTANCE hInst = AfxFindResourceHandle(
			MAKEINTRESOURCE(m_nIDContainerResource), RT_MENU);
		m_hMenuInPlace = ::LoadMenuW(hInst,
			MAKEINTRESOURCEW(m_nIDContainerResource));
		m_hAccelInPlace = ::LoadAcceleratorsW(hInst,
			MAKEINTRESOURCEW(m_nIDContainerResource));
	}
}

void CDocTemplate::SetServerInfo(UINT nIDOleEmbedding, UINT nIDOleInPlaceServer,
	CRuntimeClass* pOleFrameClass, CRuntimeClass* pOleViewClass)
{
	ASSERT_VALID_IDR(nIDOleEmbedding);
	if (nIDOleInPlaceServer != 0)
		ASSERT_VALID_IDR(nIDOleInPlaceServer);
	ASSERT(pOleFrameClass == NULL ||
		pOleFrameClass->IsDerivedFrom(RUNTIME_CLASS(CFrameWnd)));
	ASSERT(pOleViewClass == NULL ||
		pOleViewClass->IsDerivedFrom(RUNTIME_CLASS(CView)));

	m_pOleFrameClass = pOleFrameClass;
	m_pOleViewClass = pOleViewClass;

	m_nIDEmbeddingResource = nIDOleEmbedding;
	m_nIDServerResource = nIDOleInPlaceServer;
	if (!CDocManager::bStaticInit)
		LoadTemplate();
}

void CDocTemplate::SetContainerInfo(UINT nIDOleInPlaceContainer)
{
	ASSERT(nIDOleInPlaceContainer != 0);

	m_nIDContainerResource = nIDOleInPlaceContainer;
	if (!CDocManager::bStaticInit)
		LoadTemplate();
}

void CDocTemplate::SetPreviewInfo (UINT nIDPreviewFrame, CRuntimeClass* pPreviewFrameClass, CRuntimeClass* pPreviewViewClass)
{
	if (nIDPreviewFrame != 0)
		ASSERT_VALID_IDR(nIDPreviewFrame);
	ASSERT(pPreviewFrameClass == NULL || pPreviewFrameClass->IsDerivedFrom (RUNTIME_CLASS(CFrameWnd)));
	ASSERT(pPreviewViewClass == NULL || pPreviewViewClass->IsDerivedFrom (RUNTIME_CLASS(CView)));

	m_nIDPreviewResource = nIDPreviewFrame;
	m_pPreviewFrameClass = pPreviewFrameClass;
	m_pPreviewViewClass = pPreviewViewClass;
}

CDocTemplate::~CDocTemplate()
{
	// delete OLE resources
	if (m_hMenuInPlace != NULL)
		::DestroyMenu(m_hMenuInPlace);
	if (m_hAccelInPlace != NULL)
		::FreeResource(m_hAccelInPlace);
	if (m_hMenuEmbedding != NULL)
		::DestroyMenu(m_hMenuEmbedding);
	if (m_hAccelEmbedding != NULL)
		::FreeResource(m_hAccelEmbedding);
	if (m_hMenuInPlaceServer != NULL)
		::DestroyMenu(m_hMenuInPlaceServer);
	if (m_hAccelInPlaceServer != NULL)
		::FreeResource(m_hAccelInPlaceServer);
}

/////////////////////////////////////////////////////////////////////////////
// CDocTemplate attributes

BOOL CDocTemplate::GetDocString(CString& rString, enum DocStringIndex i) const
{
	return AfxExtractSubString(rString, m_strDocStrings, (int)i);
}

/////////////////////////////////////////////////////////////////////////////
// Document management

void CDocTemplate::AddDocument(CDocument* pDoc)
{
	ASSERT_VALID(pDoc);
	ASSERT(pDoc->m_pDocTemplate == NULL);   // no template attached yet
	pDoc->m_pDocTemplate = this;
}

void CDocTemplate::RemoveDocument(CDocument* pDoc)
{
	ASSERT_VALID(pDoc);
	ASSERT(pDoc->m_pDocTemplate == this);   // must be attached to us
	pDoc->m_pDocTemplate = NULL;
}

CDocTemplate::Confidence CDocTemplate::MatchDocType(LPCTSTR lpszPathName,
	CDocument*& rpDocMatch)
{
	ASSERT(lpszPathName != NULL);
	rpDocMatch = NULL;

	// go through all documents
	POSITION pos = GetFirstDocPosition();
	while (pos != NULL)
	{
		CDocument* pDoc = GetNextDoc(pos);
		if (AfxComparePath(pDoc->GetPathName(), lpszPathName))
		{
			// already open
			rpDocMatch = pDoc;
			return yesAlreadyOpen;
		}
	}

	// see if it matches our default suffix
	CString strFilterExt;
	if (GetDocString(strFilterExt, CDocTemplate::filterExt) &&
	  !strFilterExt.IsEmpty())
	{
		// see if extension matches
		ASSERT(strFilterExt[0] == '.');
		LPCTSTR lpszDot = ::PathFindExtension(lpszPathName);
		if (lpszDot != NULL)
        {
            if(::AfxComparePath(lpszDot, static_cast<const TCHAR *>(strFilterExt)))
            {
			    return yesAttemptNative; // extension matches, looks like ours
            }
        }
	}

	// otherwise we will guess it may work
	return yesAttemptForeign;
}

CDocument* CDocTemplate::CreateNewDocument()
{
	// default implementation constructs one from CRuntimeClass
	if (m_pDocClass == NULL)
	{
		TRACE(traceAppMsg, 0, "Error: you must override CDocTemplate::CreateNewDocument.\n");
		ASSERT(FALSE);
		return NULL;
	}
	CDocument* pDocument = (CDocument*)m_pDocClass->CreateObject();
	if (pDocument == NULL)
	{
		TRACE(traceAppMsg, 0, "Warning: Dynamic create of document type %hs failed.\n",
			m_pDocClass->m_lpszClassName);
		return NULL;
	}
	ASSERT_KINDOF(CDocument, pDocument);
	AddDocument(pDocument);
	return pDocument;
}

/////////////////////////////////////////////////////////////////////////////
// Default frame creation

CFrameWnd* CDocTemplate::CreateNewFrame(CDocument* pDoc, CFrameWnd* pOther)
{
	if (pDoc != NULL)
		ASSERT_VALID(pDoc);
	// create a frame wired to the specified document

	ASSERT(m_nIDResource != 0); // must have a resource ID to load from
	CCreateContext context;
	context.m_pCurrentFrame = pOther;
	context.m_pCurrentDoc = pDoc;
	context.m_pNewViewClass = m_pViewClass;
	context.m_pNewDocTemplate = this;

	if (m_pFrameClass == NULL)
	{
		TRACE(traceAppMsg, 0, "Error: you must override CDocTemplate::CreateNewFrame.\n");
		ASSERT(FALSE);
		return NULL;
	}
	CFrameWnd* pFrame = (CFrameWnd*)m_pFrameClass->CreateObject();
	if (pFrame == NULL)
	{
		TRACE(traceAppMsg, 0, "Warning: Dynamic create of frame %hs failed.\n",
			m_pFrameClass->m_lpszClassName);
		return NULL;
	}
	ASSERT_KINDOF(CFrameWnd, pFrame);

	if (context.m_pNewViewClass == NULL)
		TRACE(traceAppMsg, 0, "Warning: creating frame with no default view.\n");

	// create new from resource
	if (!pFrame->LoadFrame(m_nIDResource,
			WS_OVERLAPPEDWINDOW | FWS_ADDTOTITLE,   // default frame styles
			NULL, &context))
	{
		TRACE(traceAppMsg, 0, "Warning: CDocTemplate couldn't create a frame.\n");
		// frame will be deleted in PostNcDestroy cleanup
		return NULL;
	}

	// it worked !
	return pFrame;
}

CFrameWnd* CDocTemplate::CreateOleFrame(CWnd* pParentWnd, CDocument* pDoc,
	BOOL bCreateView)
{
	CCreateContext context;
	context.m_pCurrentFrame = NULL;
	context.m_pCurrentDoc = pDoc;
	context.m_pNewViewClass = bCreateView ? m_pOleViewClass : NULL;
	context.m_pNewDocTemplate = this;

	if (m_pOleFrameClass == NULL)
	{
		TRACE(traceAppMsg, 0, "Warning: pOleFrameClass not specified for doc template.\n");
		return NULL;
	}

	ASSERT(m_nIDServerResource != 0); // must have a resource ID to load from
	CFrameWnd* pFrame = (CFrameWnd*)m_pOleFrameClass->CreateObject();
	if (pFrame == NULL)
	{
		TRACE(traceAppMsg, 0, "Warning: Dynamic create of frame %hs failed.\n",
			m_pOleFrameClass->m_lpszClassName);
		return NULL;
	}

	// create new from resource (OLE frames are created as child windows)
	if (!pFrame->LoadFrame(m_nIDServerResource,
		WS_CHILD|WS_CLIPSIBLINGS, pParentWnd, &context))
	{
		TRACE(traceAppMsg, 0, "Warning: CDocTemplate couldn't create an OLE frame.\n");
		// frame will be deleted in PostNcDestroy cleanup
		return NULL;
	}

	// it worked !
	return pFrame;
}

CFrameWnd* CDocTemplate::CreatePreviewFrame(CWnd* pParentWnd, CDocument* pDoc)
{
	CCreateContext context;
	context.m_pCurrentFrame = NULL;
	context.m_pCurrentDoc = pDoc;
	context.m_pNewViewClass = m_pPreviewViewClass != NULL ? m_pPreviewViewClass : m_pViewClass;

	CRuntimeClass* pFrameClass = m_pPreviewFrameClass != NULL ? m_pPreviewFrameClass : RUNTIME_CLASS (CFrameWnd);
	VERIFY(pFrameClass != NULL);

	CFrameWnd* pFrame = (CFrameWnd*)pFrameClass->CreateObject();
	if (pFrame == NULL)
	{
		TRACE0("Warning: Dynamic create of frame %hs failed.\n");
		return NULL;
	}
	ASSERT_KINDOF(CFrameWnd, pFrame);

	if (m_nIDPreviewResource != 0)
	{
		// create new from resource (preview frames are created as child windows)
		if (!pFrame->LoadFrame(m_nIDPreviewResource,
			WS_CHILD|WS_CLIPSIBLINGS, pParentWnd, &context))
		{
			TRACE(traceAppMsg, 0, "Warning: CDocTemplate couldn't create a preview frame.\n");
			// frame will be deleted in PostNcDestroy cleanup
			return NULL;
		}
	}
	else
	{
		// create dummy frame
		CREATESTRUCT cs;
		memset(&cs, 0, sizeof(CREATESTRUCT));
		cs.style = WS_CHILD|WS_CLIPSIBLINGS;

		VERIFY(AfxDeferRegisterClass(AFX_WNDFRAMEORVIEW_REG));
		cs.lpszClass = _afxWndFrameOrView;  // COLOR_WINDOW background

		WNDCLASS wndcls;
		if (cs.lpszClass != NULL && AfxCtxGetClassInfo(AfxGetInstanceHandle(), cs.lpszClass, &wndcls))
		{
			// register a very similar WNDCLASS
			LPCTSTR lpcszClassName = AfxRegisterWndClass(wndcls.style, wndcls.hCursor, wndcls.hbrBackground);

			CRect rectEmpty; 
			rectEmpty.SetRectEmpty ();

			if (!pFrame->Create(lpcszClassName, _T (""), cs.style, rectEmpty,
				pParentWnd, 0, 0L, &context))
			{
				TRACE(traceAppMsg, 0, "Warning: CDocTemplate couldn't create a preview frame.\n");
				// frame will be deleted in PostNcDestroy cleanup
				return FALSE;   // will self destruct on failure normally
			}
		}
	}

	return pFrame;
}

void CDocTemplate::InitialUpdateFrame(CFrameWnd* pFrame, CDocument* pDoc,
	BOOL bMakeVisible)
{
	// just delagate to implementation in CFrameWnd
	pFrame->InitialUpdateFrame(pDoc, bMakeVisible);
}

/////////////////////////////////////////////////////////////////////////////
// CDocTemplate commands and command helpers

BOOL CDocTemplate::SaveAllModified()
{
	POSITION pos = GetFirstDocPosition();
	while (pos != NULL)
	{
		CDocument* pDoc = GetNextDoc(pos);
		if (!pDoc->SaveModified())
			return FALSE;
	}
	return TRUE;
}


void CDocTemplate::CloseAllDocuments(BOOL)
{
	POSITION pos = GetFirstDocPosition();
	while (pos != NULL)
	{
		CDocument* pDoc = GetNextDoc(pos);
		pDoc->OnCloseDocument();
	}
}

void CDocTemplate::OnIdle()
{
	POSITION pos = GetFirstDocPosition();
	while (pos != NULL)
	{
		CDocument* pDoc = GetNextDoc(pos);
		ASSERT_VALID(pDoc);
		ASSERT_KINDOF(CDocument, pDoc);
		pDoc->OnIdle();
	}
}

BOOL CDocTemplate::OnCmdMsg(UINT nID, int nCode, void* pExtra,
	AFX_CMDHANDLERINFO* pHandlerInfo)
{
	BOOL bReturn;
	CCmdTarget* pFactory = DYNAMIC_DOWNCAST(CCmdTarget, m_pAttachedFactory);

	if (nCode == CN_OLE_UNREGISTER && pFactory != NULL)
		bReturn = pFactory->OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
	else
		bReturn = CCmdTarget::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);

	return bReturn;
}

/////////////////////////////////////////////////////////////////////////////
// CDocTemplate diagnostics

#ifdef _DEBUG
void CDocTemplate::Dump(CDumpContext& dc) const
{
	CCmdTarget::Dump(dc);

	dc << "m_nIDResource = " << m_nIDResource;
	dc << "\nm_strDocStrings: " << m_strDocStrings;

	if (m_pDocClass)
		dc << "\nm_pDocClass = " << m_pDocClass->m_lpszClassName;
	else
		dc << "\nm_pDocClass = NULL";

	if (dc.GetDepth() > 0)
	{
		dc << "\ndocument list = {";
		POSITION pos = GetFirstDocPosition();
		while (pos != NULL)
		{
			CDocument* pDoc = GetNextDoc(pos);
			dc << "\ndocument " << pDoc;
		}
		dc << "\n}";
	}

	dc << "\n";
}

void CDocTemplate::AssertValid() const
{
	CCmdTarget::AssertValid();

	POSITION pos = GetFirstDocPosition();
	while (pos != NULL)
	{
		CDocument* pDoc = GetNextDoc(pos);
		ASSERT_VALID(pDoc);
	}
}
#endif //_DEBUG


IMPLEMENT_DYNAMIC(CDocTemplate, CCmdTarget)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\docmapi.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#pragma warning(disable: 4228)
#include <mapi.h>
#pragma warning(default: 4228)



/////////////////////////////////////////////////////////////////////////////
// MAPI implementation helpers and globals

AFX_STATIC_DATA BOOL _afxIsMailAvail = (BOOL)-1;    // start out not determined

/////////////////////////////////////////////////////////////////////////////
// _AFX_MAIL_STATE

class _AFX_MAIL_STATE : public CNoTrackObject
{
public:
	HINSTANCE m_hInstMail;      // handle to MAPI32.DLL
	virtual ~_AFX_MAIL_STATE();
};

_AFX_MAIL_STATE::~_AFX_MAIL_STATE()
{
	if (m_hInstMail != NULL)
		::FreeLibrary(m_hInstMail);
}

EXTERN_PROCESS_LOCAL(_AFX_MAIL_STATE, _afxMailState)

/////////////////////////////////////////////////////////////////////////////
// CDocument MAPI support

void CDocument::OnFileSendMail()
{
	ASSERT_VALID(this);
	ASSERT(_afxIsMailAvail);   // update handler always gets called first

	CWaitCursor wait;

	_AFX_MAIL_STATE* pMailState = _afxMailState;
	if (pMailState->m_hInstMail == NULL)
		pMailState->m_hInstMail = ::AfxCtxLoadLibraryW(L"MAPI32.DLL");

	if (pMailState->m_hInstMail == NULL)
	{
		AfxMessageBox(AFX_IDP_FAILED_MAPI_LOAD);
		return;
	}
	ASSERT(pMailState->m_hInstMail != NULL);

	ULONG (PASCAL *lpfnSendMail)(ULONG, ULONG_PTR, MapiMessage*, FLAGS, ULONG);
	(FARPROC&)lpfnSendMail = GetProcAddress(pMailState->m_hInstMail, "MAPISendMail");
	if (lpfnSendMail == NULL)
	{
		AfxMessageBox(AFX_IDP_INVALID_MAPI_DLL);
		return;
	}
	ASSERT(lpfnSendMail != NULL);

	TCHAR szTempName[_MAX_PATH];
	TCHAR szPath[_MAX_PATH];
	BOOL bRemoveTemp = FALSE;
	if (m_strPathName.IsEmpty() || IsModified())
	{
		// save to temporary path
		VERIFY(GetTempPath(_countof(szPath), szPath) != 0);
		VERIFY(GetTempFileName(szPath, _T("afx"), 0, szTempName) != 0);

		// save it, but remember original modified flag
		BOOL bModified = IsModified();
		BOOL bResult = DoSave(szTempName, FALSE);
		SetModifiedFlag(bModified);
		if (!bResult)
		{
			TRACE(traceAppMsg, 0, "Warning: file save failed during File.Send Mail.\n");
			return;
		}
		bRemoveTemp = TRUE;
	}
	else
	{
		// use actual file since it isn't modified
		Checked::tcsncpy_s(szTempName, _countof(szTempName), m_strPathName, _TRUNCATE);
	}
#ifdef _UNICODE
	char szTempNameA[_MAX_PATH];
	_wcstombsz(szTempNameA, szTempName, _countof(szTempNameA));
#endif

	// build an appropriate title for the attachment
	TCHAR szTitle[_MAX_PATH];
	if (!m_strPathName.IsEmpty())
		AfxGetFileName(m_strPathName, szTitle, _countof(szTitle));
	else
	{
		Checked::tcsncpy_s(szTitle, _countof(szTitle), m_strTitle, _TRUNCATE);
		if (CString(::PathFindExtension(m_strTitle)).GetLength() == 0) // no extension
		{
			// append the default suffix if there is one
			CString strExt;
			CDocTemplate* pTemplate = GetDocTemplate();
			if (pTemplate != NULL &&
				pTemplate->GetDocString(strExt, CDocTemplate::filterExt))
			{
				if( lstrlen(szTitle) + lstrlen(strExt) < _countof(szTitle) )
				{
					Checked::tcscat_s(szTitle, _countof(szTitle), strExt);
				}
			}
		}
	}

#ifdef _UNICODE
	char szTitleA[_MAX_PATH];
	_wcstombsz(szTitleA, szTitle, _countof(szTitleA));
#endif

	// prepare the file description (for the attachment)
	MapiFileDesc fileDesc;
	memset(&fileDesc, 0, sizeof(fileDesc));
	fileDesc.nPosition = (ULONG)-1;
#ifdef _UNICODE
	fileDesc.lpszPathName = szTempNameA;
	fileDesc.lpszFileName = szTitleA;
#else
	fileDesc.lpszPathName = szTempName;
	fileDesc.lpszFileName = szTitle;
#endif

	// prepare the message (empty with 1 attachment)
	MapiMessage message;
	memset(&message, 0, sizeof(message));
	message.nFileCount = 1;
	message.lpFiles = &fileDesc;

	// prepare for modal dialog box
	AfxGetApp()->EnableModeless(FALSE);
	HWND hWndTop;
	CWnd* pParentWnd = CWnd::GetSafeOwner(NULL, &hWndTop);

	// some extra precautions are required to use MAPISendMail as it
	// tends to enable the parent window in between dialogs (after
	// the login dialog, but before the send note dialog).
	pParentWnd->SetCapture();
	::SetFocus(NULL);
	pParentWnd->m_nFlags |= WF_STAYDISABLED;

	int nError = lpfnSendMail(0, (ULONG_PTR)pParentWnd->GetSafeHwnd(),
		&message, MAPI_LOGON_UI|MAPI_DIALOG, 0);

	// after returning from the MAPISendMail call, the window must
	// be re-enabled and focus returned to the frame to undo the workaround
	// done before the MAPI call.
	::ReleaseCapture();
	pParentWnd->m_nFlags &= ~WF_STAYDISABLED;

	pParentWnd->EnableWindow(TRUE);
	::SetActiveWindow(NULL);
	pParentWnd->SetActiveWindow();
	pParentWnd->SetFocus();
	if (hWndTop != NULL)
		::EnableWindow(hWndTop, TRUE);
	AfxGetApp()->EnableModeless(TRUE);

	if (nError != SUCCESS_SUCCESS &&
		nError != MAPI_USER_ABORT && nError != MAPI_E_LOGIN_FAILURE)
	{
		AfxMessageBox(AFX_IDP_FAILED_MAPI_SEND);
	}

	// remove temporary file, if temporary file was used
	if (bRemoveTemp)
		CFile::Remove(szTempName);
}

void CDocument::OnUpdateFileSendMail(CCmdUI* pCmdUI)
{
	ASSERT_VALID(this);

	if (_afxIsMailAvail == (BOOL)-1)
	{
		_afxIsMailAvail = ::GetProfileInt(_T("MAIL"), _T("MAPI"), 0) != 0 &&
			SearchPath(NULL, _T("MAPI32.DLL"), NULL, 0, NULL, NULL) != 0;
	}

	// enable the Send... menu item if available
	pCmdUI->Enable(_afxIsMailAvail);
	CMenu* pMenu = pCmdUI->m_pMenu;
	if (!_afxIsMailAvail && pMenu != NULL)
	{
		// remove the Send... menu and surrounding separators
		UINT nStateAbove = pMenu->GetMenuState(pCmdUI->m_nIndex-1, MF_BYPOSITION);
		UINT nStateBelow = pMenu->GetMenuState(pCmdUI->m_nIndex+1, MF_BYPOSITION);
		pMenu->RemoveMenu(pCmdUI->m_nIndex, MF_BYPOSITION);
		if (nStateAbove & nStateBelow & MF_SEPARATOR)
		{
			// a separator must be removed since the Send... is gone
			if (nStateAbove != (UINT)-1)
				pMenu->RemoveMenu(pCmdUI->m_nIndex-1, MF_BYPOSITION);
			else if (nStateBelow != (UINT)-1)
				pMenu->RemoveMenu(pCmdUI->m_nIndex, MF_BYPOSITION);
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// COleDocument MAPI support

void COleDocument::OnFileSendMail()
{
	ASSERT_VALID(this);
	ASSERT(m_bRemember);

	LPSTORAGE lpOrigStg = m_lpRootStg;
	m_lpRootStg = NULL;

	TRY
	{
		m_bRemember = FALSE;
		CDocument::OnFileSendMail();
	}
	CATCH_ALL(e)
	{
		m_lpRootStg = lpOrigStg;
		m_bRemember = TRUE;
		THROW_LAST();
	}
	END_CATCH_ALL

	m_lpRootStg = lpOrigStg;
	m_bRemember = TRUE;
}


#pragma warning(disable: 4074)
#pragma init_seg(lib)

PROCESS_LOCAL(_AFX_MAIL_STATE, _afxMailState)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\docmgr.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "sal.h"
#include "afxglobals.h"



AFX_STATIC_DATA const TCHAR _afxShellOpenFmt[] = _T("%s\\shell\\open\\%s");
AFX_STATIC_DATA const TCHAR _afxShellPrintFmt[] = _T("%s\\shell\\print\\%s");
AFX_STATIC_DATA const TCHAR _afxShellPrintToFmt[] = _T("%s\\shell\\printto\\%s");
AFX_STATIC_DATA const TCHAR _afxDefaultIconFmt[] = _T("%s\\DefaultIcon");
AFX_STATIC_DATA const TCHAR _afxShellNewFmt[] = _T("%s\\ShellNew");
AFX_STATIC_DATA const TCHAR _afxShellExFmt[] = _T("%s\\ShellEx");
AFX_STATIC_DATA const TCHAR _afxPreviewHostCLSIDKey [] = _T("\\{8895b1c6-b41f-4c1c-a562-0d564250836f}");

#define DEFAULT_ICON_INDEX 0

AFX_STATIC_DATA const TCHAR _afxIconIndexFmt[] = _T(",%d");
AFX_STATIC_DATA const TCHAR _afxCommand[] = _T("command");
AFX_STATIC_DATA const TCHAR _afxOpenArg[] = _T(" \"%1\"");
AFX_STATIC_DATA const TCHAR _afxPrintArg[] = _T(" /p \"%1\"");
AFX_STATIC_DATA const TCHAR _afxPrintToArg[] = _T(" /pt \"%1\" \"%2\" \"%3\" \"%4\"");
AFX_STATIC_DATA const TCHAR _afxDDEArg[] = _T(" /dde");
AFX_STATIC_DATA const TCHAR _afxDDEArg2[] = _T(" /ddenoshow");

AFX_STATIC_DATA const TCHAR _afxDDEExec[] = _T("ddeexec");
AFX_STATIC_DATA const TCHAR _afxDDEOpen[] = _T("[open(\"%1\")]");
AFX_STATIC_DATA const TCHAR _afxDDEPrint[] = _T("[print(\"%1\")]");
AFX_STATIC_DATA const TCHAR _afxDDEPrintTo[] = _T("[printto(\"%1\",\"%2\",\"%3\",\"%4\")]");

AFX_STATIC_DATA const TCHAR _afxShellNewValueName[] = _T("NullFile");
AFX_STATIC_DATA const TCHAR _afxShellNewValue[] = _T("");

AFX_STATIC_DATA const TCHAR _afxAppUserModelIDValueName[] = _T("AppUserModelID");

// recursively remove a registry key if and only if it has no subkeys

BOOL AFXAPI _AfxDeleteRegKey(LPCTSTR lpszKey)
{
	// copy the string
	LPTSTR lpszKeyCopy = _tcsdup(lpszKey);

	if(lpszKeyCopy == NULL)
		return FALSE;

	LPTSTR lpszLast = lpszKeyCopy + lstrlen(lpszKeyCopy);

	// work until the end of the string
	while (lpszLast != NULL)
	{
		*lpszLast = '\0';
		lpszLast = _tcsdec(lpszKeyCopy, lpszLast);

		// try to open that key
		HKEY hKey;
		if (AfxRegOpenKeyEx(HKEY_CLASSES_ROOT, lpszKeyCopy, 0, KEY_ENUMERATE_SUB_KEYS, &hKey) != ERROR_SUCCESS)
			break;

		// enumerate the keys underneath
		TCHAR szScrap[_MAX_PATH+1];
		DWORD dwLen = _countof(szScrap);
		BOOL bItExists = FALSE;

		if (::RegEnumKey(hKey, 0, szScrap, dwLen) == ERROR_SUCCESS)
			bItExists = TRUE;
		::RegCloseKey(hKey);

		// found one?  quit looping
		if (bItExists)
			break;

		// otherwise, delete and find the previous backwhack
		AfxRegDeleteKey(HKEY_CLASSES_ROOT, lpszKeyCopy);
		lpszLast = _tcsrchr(lpszKeyCopy, '\\');
	}

	// release the string and return
	free(lpszKeyCopy);
	return TRUE;
}

AFX_STATIC BOOL AFXAPI
_AfxSetRegKey(LPCTSTR lpszKey, LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL)
{
	if (lpszValueName == NULL)
	{
		if (AfxRegSetValue(HKEY_CLASSES_ROOT, lpszKey, REG_SZ,
			  lpszValue, lstrlen(lpszValue) * sizeof(TCHAR)) != ERROR_SUCCESS)
		{
			TRACE(traceAppMsg, 0, _T("Warning: registration database update failed for key '%s'.\n"),
				lpszKey);
			return FALSE;
		}
		return TRUE;
	}
	else
	{
		HKEY hKey;

		if(AfxRegCreateKey(HKEY_CLASSES_ROOT, lpszKey, &hKey) == ERROR_SUCCESS)
		{
			LONG lResult = ::RegSetValueEx(hKey, lpszValueName, 0, REG_SZ,
				(CONST BYTE*)lpszValue, (lstrlen(lpszValue) + 1) * sizeof(TCHAR));

			if(::RegCloseKey(hKey) == ERROR_SUCCESS && lResult == ERROR_SUCCESS)
				return TRUE;
		}
		TRACE(traceAppMsg, 0, _T("Warning: registration database update failed for key '%s'.\n"), lpszKey);
		return FALSE;
	}
}

CDocManager::CDocManager()
{
}

void CDocManager::UnregisterShellFileTypes()
{
	ASSERT(!m_templateList.IsEmpty());  // must have some doc templates

	CString strPathName, strTemp;

	AfxGetModuleShortFileName(AfxGetInstanceHandle(), strPathName);

	POSITION pos = m_templateList.GetHeadPosition();
	for (int nTemplateIndex = 1; pos != NULL; nTemplateIndex++)
	{
		CDocTemplate* pTemplate = (CDocTemplate*)m_templateList.GetNext(pos);

		CString strFilterExt, strFileTypeId, strFileTypeName;
		if (pTemplate->GetDocString(strFileTypeId,
		   CDocTemplate::regFileTypeId) && !strFileTypeId.IsEmpty())
		{
			// enough info to register it
			if (!pTemplate->GetDocString(strFileTypeName,
			   CDocTemplate::regFileTypeName))
				strFileTypeName = strFileTypeId;    // use id name

			ASSERT(strFileTypeId.Find(' ') == -1);  // no spaces allowed

			strTemp.Format(_afxDefaultIconFmt, (LPCTSTR)strFileTypeId);
			_AfxDeleteRegKey(strTemp);

			// If MDI Application
			if (!pTemplate->GetDocString(strTemp, CDocTemplate::windowTitle) ||
				strTemp.IsEmpty())
			{
				// path\shell\open\ddeexec = [open("%1")]
				strTemp.Format(_afxShellOpenFmt, (LPCTSTR)strFileTypeId,
					(LPCTSTR)_afxDDEExec);
				_AfxDeleteRegKey(strTemp);

				// path\shell\print\ddeexec = [print("%1")]
				strTemp.Format(_afxShellPrintFmt, (LPCTSTR)strFileTypeId,
					(LPCTSTR)_afxDDEExec);
				_AfxDeleteRegKey(strTemp);

				// path\shell\printto\ddeexec = [printto("%1","%2","%3","%4")]
				strTemp.Format(_afxShellPrintToFmt, (LPCTSTR)strFileTypeId,
					(LPCTSTR)_afxDDEExec);
				_AfxDeleteRegKey(strTemp);
			}

			// path\shell\open\command = path filename
			strTemp.Format(_afxShellOpenFmt, (LPCTSTR)strFileTypeId,
				(LPCTSTR)_afxCommand);
			_AfxDeleteRegKey(strTemp);

			// path\shell\print\command = path /p filename
			strTemp.Format(_afxShellPrintFmt, (LPCTSTR)strFileTypeId,
				(LPCTSTR)_afxCommand);
			_AfxDeleteRegKey(strTemp);

			// path\shell\printto\command = path /pt filename printer driver port
			strTemp.Format(_afxShellPrintToFmt, (LPCTSTR)strFileTypeId,
				(LPCTSTR)_afxCommand);
			_AfxDeleteRegKey(strTemp);

			pTemplate->GetDocString(strFilterExt, CDocTemplate::filterExt);
			if (!strFilterExt.IsEmpty())
			{
				ASSERT(strFilterExt[0] == '.');

				LONG lSize = _MAX_PATH * 2;
				LONG lResult = AfxRegQueryValue(HKEY_CLASSES_ROOT, strFilterExt,
					strTemp.GetBuffer(lSize), &lSize);
				strTemp.ReleaseBuffer();

				if (lResult != ERROR_SUCCESS || strTemp.IsEmpty() ||
					strTemp == strFileTypeId)
				{
					strTemp.Format(_afxShellNewFmt, (LPCTSTR)strFilterExt);
					_AfxDeleteRegKey(strTemp);

					if (!pTemplate->m_strCLSID.IsEmpty())
					{
						strTemp.Format(_afxShellExFmt, (LPCTSTR)strFilterExt);
						strTemp.Append(_afxPreviewHostCLSIDKey);
						_AfxDeleteRegKey(strTemp);
					}
					
					strTemp.Format(_afxShellExFmt, (LPCTSTR)strFilterExt);
					_AfxDeleteRegKey(strTemp);

					// no association for that suffix
					_AfxDeleteRegKey(strFilterExt);
				}

				if (!pTemplate->m_strCLSID.IsEmpty())
				{
					AfxUnRegisterPreviewHandler(pTemplate->m_strCLSID);

					CString strServerName;
					CString strLocalServerName;
					CString strLocalShortName;

					if (!pTemplate->GetDocString(strServerName,
						CDocTemplate::regFileTypeId) || strServerName.IsEmpty())
					{
						TRACE(traceOle, 0, "Error: not enough information in DocTemplate to unregister Preview Handler.\n");
						return;
					}
					if (!pTemplate->GetDocString(strLocalServerName,
						CDocTemplate::regFileTypeName))
						strLocalServerName = strServerName;     // use non-localized name
					if (!pTemplate->GetDocString(strLocalShortName,
						CDocTemplate::fileNewName))
						strLocalShortName = strLocalServerName; // use long name

					AfxOleUnregisterServerClass(pTemplate->m_clsid, strServerName,
						strLocalShortName, strLocalServerName, OAT_DISPATCH_OBJECT,
						NULL, NULL);
				}
			}
		}
	}
}

void CDocManager::RegisterShellFileTypes(BOOL bCompat)
{
	ASSERT(!m_templateList.IsEmpty());  // must have some doc templates

	CString strPathName, strTemp;

	AfxGetModuleShortFileName(AfxGetInstanceHandle(), strPathName);

	POSITION pos = m_templateList.GetHeadPosition();
	for (int nTemplateIndex = 1; pos != NULL; nTemplateIndex++)
	{
		CDocTemplate* pTemplate = (CDocTemplate*)m_templateList.GetNext(pos);

		CString strOpenCommandLine = strPathName;
		CString strPrintCommandLine = strPathName;
		CString strPrintToCommandLine = strPathName;
		CString strDefaultIconCommandLine = strPathName;

		if (bCompat)
		{
			CString strIconIndex;
			HICON hIcon = ::ExtractIcon(AfxGetInstanceHandle(), strPathName, nTemplateIndex);
			if (hIcon != NULL)
			{
				strIconIndex.Format(_afxIconIndexFmt, nTemplateIndex);
				DestroyIcon(hIcon);
			}
			else
			{
				strIconIndex.Format(_afxIconIndexFmt, DEFAULT_ICON_INDEX);
			}
			strDefaultIconCommandLine += strIconIndex;
		}

		CString strFilterExt, strFileTypeId, strFileTypeName;
		if (pTemplate->GetDocString(strFileTypeId,
		   CDocTemplate::regFileTypeId) && !strFileTypeId.IsEmpty())
		{
			// enough info to register it
			if (!pTemplate->GetDocString(strFileTypeName,
			   CDocTemplate::regFileTypeName))
				strFileTypeName = strFileTypeId;    // use id name

			ASSERT(strFileTypeId.Find(' ') == -1);  // no spaces allowed

			// first register the type ID of our server
			if (!_AfxSetRegKey(strFileTypeId, strFileTypeName))
				continue;       // just skip it

			if (afxGlobalData.bIsWindows7)
			{
				CWinApp* pApp = AfxGetApp();
				if (pApp != NULL && _tcslen(pApp->m_pszAppID) > 0)
				{
					_AfxSetRegKey(strFileTypeId, pApp->m_pszAppID, _afxAppUserModelIDValueName);
				}
			}

			if (bCompat)
			{
				// path\DefaultIcon = path,1
				strTemp.Format(_afxDefaultIconFmt, (LPCTSTR)strFileTypeId);
				if (!_AfxSetRegKey(strTemp, strDefaultIconCommandLine))
					continue;       // just skip it
			}

			// If MDI Application
			if (!pTemplate->GetDocString(strTemp, CDocTemplate::windowTitle) ||
				strTemp.IsEmpty())
			{
				// path\shell\open\ddeexec = [open("%1")]
				strTemp.Format(_afxShellOpenFmt, (LPCTSTR)strFileTypeId,
					(LPCTSTR)_afxDDEExec);
				if (!_AfxSetRegKey(strTemp, _afxDDEOpen))
					continue;       // just skip it

				if (bCompat)
				{
					// path\shell\print\ddeexec = [print("%1")]
					strTemp.Format(_afxShellPrintFmt, (LPCTSTR)strFileTypeId,
						(LPCTSTR)_afxDDEExec);
					if (!_AfxSetRegKey(strTemp, _afxDDEPrint))
						continue;       // just skip it

					// path\shell\printto\ddeexec = [printto("%1","%2","%3","%4")]
					strTemp.Format(_afxShellPrintToFmt, (LPCTSTR)strFileTypeId,
						(LPCTSTR)_afxDDEExec);
					if (!_AfxSetRegKey(strTemp, _afxDDEPrintTo))
						continue;       // just skip it

					// path\shell\open\command = path /dde
					// path\shell\print\command = path /ddenoshow
					// path\shell\printto\command = path /ddenoshow
					strOpenCommandLine += _afxDDEArg;
					strPrintCommandLine += _afxDDEArg2;
					strPrintToCommandLine += _afxDDEArg2;
				}
				else
				{
					strOpenCommandLine += _afxOpenArg;
				}
			}
			else
			{
				// path\shell\open\command = path filename
				// path\shell\print\command = path /p filename
				// path\shell\printto\command = path /pt filename printer driver port
				strOpenCommandLine += _afxOpenArg;
				if (bCompat)
				{
					strPrintCommandLine += _afxPrintArg;
					strPrintToCommandLine += _afxPrintToArg;
				}
			}

			// path\shell\open\command = path filename
			strTemp.Format(_afxShellOpenFmt, (LPCTSTR)strFileTypeId,
				(LPCTSTR)_afxCommand);
			if (!_AfxSetRegKey(strTemp, strOpenCommandLine))
				continue;       // just skip it

			if (bCompat)
			{
				// path\shell\print\command = path /p filename
				strTemp.Format(_afxShellPrintFmt, (LPCTSTR)strFileTypeId,
					(LPCTSTR)_afxCommand);
				if (!_AfxSetRegKey(strTemp, strPrintCommandLine))
					continue;       // just skip it

				// path\shell\printto\command = path /pt filename printer driver port
				strTemp.Format(_afxShellPrintToFmt, (LPCTSTR)strFileTypeId,
					(LPCTSTR)_afxCommand);
				if (!_AfxSetRegKey(strTemp, strPrintToCommandLine))
					continue;       // just skip it
			}

			pTemplate->GetDocString(strFilterExt, CDocTemplate::filterExt);
			if (!strFilterExt.IsEmpty())
			{
				ASSERT(strFilterExt[0] == '.');

				LONG lSize = _MAX_PATH * 2;
				LONG lResult = AfxRegQueryValue(HKEY_CLASSES_ROOT, strFilterExt,
					strTemp.GetBuffer(lSize), &lSize);
				strTemp.ReleaseBuffer();

				if (lResult != ERROR_SUCCESS || strTemp.IsEmpty() ||
					strTemp == strFileTypeId)
				{
					// no association for that suffix
					if (!_AfxSetRegKey(strFilterExt, strFileTypeId))
						continue;

					if (bCompat)
					{
						strTemp.Format(_afxShellNewFmt, (LPCTSTR)strFilterExt);
						(void)_AfxSetRegKey(strTemp, _afxShellNewValue, _afxShellNewValueName);
					}
				}

				if (!pTemplate->m_strCLSID.IsEmpty())
				{
					CString strShortTypeName;
					pTemplate->GetDocString(strShortTypeName, CDocTemplate::fileNewName);
					AfxRegisterPreviewHandler (pTemplate->m_strCLSID, strShortTypeName, strFilterExt);

					CString strServerName;
					CString strLocalServerName;
					CString strLocalShortName;

					if (!pTemplate->GetDocString(strServerName,
						CDocTemplate::regFileTypeId) || strServerName.IsEmpty())
					{
						TRACE(traceOle, 0, "Error: not enough information in DocTemplate to register OLE server.\n");
						return;
					}
					if (!pTemplate->GetDocString(strLocalServerName,
						CDocTemplate::regFileTypeName))
						strLocalServerName = strServerName;     // use non-localized name
					if (!pTemplate->GetDocString(strLocalShortName,
						CDocTemplate::fileNewName))
						strLocalShortName = strLocalServerName; // use long name
					
					AfxOleRegisterServerClass(pTemplate->m_clsid, strServerName,
						strLocalShortName, strLocalServerName, OAT_DISPATCH_OBJECT,
						NULL, NULL, DEFAULT_ICON_INDEX, NULL, NULL);
				}
			}
		}
	}
}


AFX_STATIC void AFXAPI _AfxAppendFilterSuffix(CString& filter, OPENFILENAME& ofn,
	CDocTemplate* pTemplate, CString* pstrDefaultExt)
{
	ENSURE_VALID(pTemplate);
	ASSERT_KINDOF(CDocTemplate, pTemplate);

	CString strFilterExt, strFilterName;
	if (pTemplate->GetDocString(strFilterExt, CDocTemplate::filterExt) &&
		!strFilterExt.IsEmpty() &&
		pTemplate->GetDocString(strFilterName, CDocTemplate::filterName) &&
		!strFilterName.IsEmpty())
	{
		if (pstrDefaultExt != NULL)
			pstrDefaultExt->Empty();

		// add to filter
		filter += strFilterName;
		ASSERT(!filter.IsEmpty());  // must have a file type name
		filter += (TCHAR)'\0';  // next string please

		int iStart = 0;
		do
		{
			CString strExtension = strFilterExt.Tokenize( _T( ";" ), iStart );

			if (iStart != -1)
			{
				// a file based document template - add to filter list

				// If you hit the following ASSERT, your document template 
				// string is formatted incorrectly.  The section of your 
				// document template string that specifies the allowable file
				// extensions should be formatted as follows:
				//    .<ext1>;.<ext2>;.<ext3>
				// Extensions may contain wildcards (e.g. '?', '*'), but must
				// begin with a '.' and be separated from one another by a ';'.
				// Example:
				//    .jpg;.jpeg
				ASSERT(strExtension[0] == '.');
				if ((pstrDefaultExt != NULL) && pstrDefaultExt->IsEmpty())
				{
					// set the default extension
					*pstrDefaultExt = strExtension.Mid( 1 );  // skip the '.'
					ofn.lpstrDefExt = const_cast< LPTSTR >((LPCTSTR)(*pstrDefaultExt));
					ofn.nFilterIndex = ofn.nMaxCustFilter + 1;  // 1 based number
				}

				filter += (TCHAR)'*';
				filter += strExtension;
				filter += (TCHAR)';';  // Always append a ';'.  The last ';' will get replaced with a '\0' later.
			}
		} while (iStart != -1);

		filter.SetAt( filter.GetLength()-1, '\0' );;  // Replace the last ';' with a '\0'
		ofn.nMaxCustFilter++;
	}
}

// Get the best document template for the named file

class CNewTypeDlg : public CDialog
{
protected:
	CPtrList*   m_pList;        // actually a list of doc templates
public:
	CDocTemplate*   m_pSelectedTemplate;

public:
	//{{AFX_DATA(CNewTypeDlg)
	enum { IDD = AFX_IDD_NEWTYPEDLG };
	//}}AFX_DATA
	CNewTypeDlg(CPtrList* pList) : CDialog(CNewTypeDlg::IDD)
	{
		m_pList = pList;
		m_pSelectedTemplate = NULL;
	}
	~CNewTypeDlg() { }

protected:
	BOOL OnInitDialog();
	void OnOK();
	//{{AFX_MSG(CNewTypeDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

BEGIN_MESSAGE_MAP(CNewTypeDlg, CDialog)
	//{{AFX_MSG_MAP(CNewTypeDlg)
	ON_LBN_DBLCLK(AFX_IDC_LISTBOX, &CNewTypeDlg::OnOK)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL CNewTypeDlg::OnInitDialog()
{
	CListBox* pListBox = (CListBox*)GetDlgItem(AFX_IDC_LISTBOX);
	ENSURE(pListBox != NULL);

	// fill with document templates in list
	pListBox->ResetContent();

	POSITION pos = m_pList->GetHeadPosition();
	// add all the CDocTemplates in the list by name
	while (pos != NULL)
	{
		CDocTemplate* pTemplate = (CDocTemplate*)m_pList->GetNext(pos);
		ASSERT_KINDOF(CDocTemplate, pTemplate);

		CString strTypeName;
		if (pTemplate->GetDocString(strTypeName, CDocTemplate::fileNewName) &&
		   !strTypeName.IsEmpty())
		{
			// add it to the listbox
			int nIndex = pListBox->AddString(strTypeName);
			if (nIndex == -1)
			{
				EndDialog(-1);
				return FALSE;
			}
			pListBox->SetItemDataPtr(nIndex, pTemplate);
		}
	}

	int nTemplates = pListBox->GetCount();
	if (nTemplates == 0)
	{
		TRACE(traceAppMsg, 0, "Error: no document templates to select from!\n");
		EndDialog(-1); // abort
	}
	else if (nTemplates == 1)
	{
		// get the first/only item
		m_pSelectedTemplate = (CDocTemplate*)pListBox->GetItemDataPtr(0);
		ASSERT_VALID(m_pSelectedTemplate);
		ASSERT_KINDOF(CDocTemplate, m_pSelectedTemplate);
		EndDialog(IDOK);    // done
	}
	else
	{
		// set selection to the first one (NOT SORTED)
		pListBox->SetCurSel(0);
	}

	return CDialog::OnInitDialog();
}

void CNewTypeDlg::OnOK()
{
	CListBox* pListBox = (CListBox*)GetDlgItem(AFX_IDC_LISTBOX);
	ENSURE(pListBox != NULL);
	// if listbox has selection, set the selected template
	int nIndex;
	if ((nIndex = pListBox->GetCurSel()) == -1)
	{
		// no selection
		m_pSelectedTemplate = NULL;
	}
	else
	{
		m_pSelectedTemplate = (CDocTemplate*)pListBox->GetItemDataPtr(nIndex);
		ASSERT_VALID(m_pSelectedTemplate);
		ASSERT_KINDOF(CDocTemplate, m_pSelectedTemplate);
	}
	CDialog::OnOK();
}

/////////////////////////////////////////////////////////////////////////////
// CDocManager

void CDocManager::AddDocTemplate(CDocTemplate* pTemplate)
{
	if (pTemplate == NULL)
	{
		if (pStaticList != NULL)
		{
			POSITION pos = pStaticList->GetHeadPosition();
			while (pos != NULL)
			{
				pTemplate = (CDocTemplate*)pStaticList->GetNext(pos);
				AddDocTemplate(pTemplate);
			}
			delete pStaticList;
			pStaticList = NULL;
		}
		bStaticInit = FALSE;
	}
	else
	{
		ASSERT_VALID(pTemplate);
		ASSERT(m_templateList.Find(pTemplate, NULL) == NULL);// must not be in list
		pTemplate->LoadTemplate();
		m_templateList.AddTail(pTemplate);
	}
}

POSITION CDocManager::GetFirstDocTemplatePosition() const
{
	return m_templateList.GetHeadPosition();
}

CDocTemplate* CDocManager::GetNextDocTemplate(POSITION& pos) const
{
	return (CDocTemplate*)m_templateList.GetNext(pos);
}

BOOL CDocManager::SaveAllModified()
{
	POSITION pos = m_templateList.GetHeadPosition();
	while (pos != NULL)
	{
		CDocTemplate* pTemplate = (CDocTemplate*)m_templateList.GetNext(pos);
		ASSERT_KINDOF(CDocTemplate, pTemplate);
		if (!pTemplate->SaveAllModified())
			return FALSE;
	}
	return TRUE;
}

void CDocManager::CloseAllDocuments(BOOL bEndSession)
{
	POSITION pos = m_templateList.GetHeadPosition();
	while (pos != NULL)
	{
		CDocTemplate* pTemplate = (CDocTemplate*)m_templateList.GetNext(pos);
		ASSERT_KINDOF(CDocTemplate, pTemplate);
		pTemplate->CloseAllDocuments(bEndSession);
	}
}

BOOL CDocManager::DoPromptFileName(CString& fileName, UINT nIDSTitle, DWORD lFlags, BOOL bOpenFileDialog, CDocTemplate* pTemplate)
{
	CFileDialog dlgFile(bOpenFileDialog, NULL, NULL, OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT, NULL, NULL, 0);

	CString title;
	ENSURE(title.LoadString(nIDSTitle));

	dlgFile.m_ofn.Flags |= lFlags;

	CString strFilter;
	CString strDefault;
	if (pTemplate != NULL)
	{
		ASSERT_VALID(pTemplate);
		_AfxAppendFilterSuffix(strFilter, dlgFile.m_ofn, pTemplate, &strDefault);
	}
	else
	{
		// do for all doc template
		POSITION pos = m_templateList.GetHeadPosition();
		BOOL bFirst = TRUE;
		while (pos != NULL)
		{
			pTemplate = (CDocTemplate*)m_templateList.GetNext(pos);
			_AfxAppendFilterSuffix(strFilter, dlgFile.m_ofn, pTemplate,
				bFirst ? &strDefault : NULL);
			bFirst = FALSE;
		}
	}

	// append the "*.*" all files filter
	CString allFilter;
	VERIFY(allFilter.LoadString(AFX_IDS_ALLFILTER));
	strFilter += allFilter;
	strFilter += (TCHAR)'\0';   // next string please
	strFilter += _T("*.*");
	strFilter += (TCHAR)'\0';   // last string
	dlgFile.m_ofn.nMaxCustFilter++;

	dlgFile.m_ofn.lpstrFilter = strFilter;
	dlgFile.m_ofn.lpstrTitle = title;
	dlgFile.m_ofn.lpstrFile = fileName.GetBuffer(_MAX_PATH);

	INT_PTR nResult = dlgFile.DoModal();
	fileName.ReleaseBuffer();
	return nResult == IDOK;
}

int CDocManager::GetDocumentCount()
{
	// count all documents
	int nCount = 0;
	POSITION pos = m_templateList.GetHeadPosition();
	while (pos != NULL)
	{
		CDocTemplate* pTemplate = (CDocTemplate*)m_templateList.GetNext(pos);
		POSITION pos2 = pTemplate->GetFirstDocPosition();
		while (pos2 != NULL)
		{
			pTemplate->GetNextDoc(pos2);
			++nCount;
		}
	}
	return nCount;
}

BOOL CDocManager::OnDDECommand(_In_z_ LPTSTR lpszCommand)
{
	CString strCommand = lpszCommand;
	CDocument* pDoc = NULL;

	// open format is "[open("%s")]" - no whitespace allowed, one per line
	// print format is "[print("%s")]" - no whitespace allowed, one per line
	// print to format is "[printto("%s","%s","%s","%s")]" - no whitespace allowed, one per line
	CCommandLineInfo cmdInfo;
	cmdInfo.m_nShellCommand = CCommandLineInfo::FileDDE;

	if (strCommand.Left(7) == _T("[open(\""))
	{
		cmdInfo.m_nShellCommand = CCommandLineInfo::FileOpen;
		strCommand = strCommand.Right(strCommand.GetLength() - 7);
	}
	else if (strCommand.Left(8) == _T("[print(\""))
	{
		cmdInfo.m_nShellCommand = CCommandLineInfo::FilePrint;
		strCommand = strCommand.Right(strCommand.GetLength() - 8);
	}
	else if (strCommand.Left(10) == _T("[printto(\""))
	{
		cmdInfo.m_nShellCommand = CCommandLineInfo::FilePrintTo;\
		strCommand = strCommand.Right(strCommand.GetLength() - 10);
	}
	else
		return FALSE; // not a command we handle

	int i = strCommand.Find('"');
	if (i == -1)
		return FALSE; // illegally terminated

	cmdInfo.m_strFileName = strCommand.Left(i);
	strCommand = strCommand.Right(strCommand.GetLength() - i);

	CCommandLineInfo* pOldInfo = NULL;
	BOOL bRetVal = TRUE;

	// If we were started up for DDE retrieve the Show state
	if (AfxGetApp()->m_pCmdInfo != NULL)
	{
		AfxGetApp()->m_nCmdShow = (int)(INT_PTR)AfxGetApp()->m_pCmdInfo;
		AfxGetApp()->m_pCmdInfo = &cmdInfo;
	}
	else
		pOldInfo = AfxGetApp()->m_pCmdInfo;

	if (cmdInfo.m_nShellCommand == CCommandLineInfo::FileOpen)
	{
		// show the application window
		CWnd* pMainWnd = AfxGetApp()->m_pMainWnd;
		int nCmdShow = AfxGetApp()->m_nCmdShow;
		if (nCmdShow == -1 || nCmdShow == SW_SHOWNORMAL)
		{
			if (pMainWnd->IsIconic())
				nCmdShow = SW_RESTORE;
			else
				nCmdShow = SW_SHOW;
		}
		pMainWnd->ShowWindow(nCmdShow);
		if (nCmdShow != SW_MINIMIZE)
			pMainWnd->SetForegroundWindow();

		// then open the document
		AfxGetApp()->OpenDocumentFile(cmdInfo.m_strFileName);

		// user is now "in control" of the application
		if (!AfxOleGetUserCtrl())
			AfxOleSetUserCtrl(TRUE);

		// next time, show the window as default
		AfxGetApp()->m_nCmdShow = -1;
		goto RestoreAndReturn;
	}

	if (cmdInfo.m_nShellCommand == CCommandLineInfo::FilePrintTo)
	{
		if (strCommand.Left(3) != _T("\",\""))
		{
			bRetVal = FALSE;
			goto RestoreAndReturn;
		}
		else
		{
			strCommand = strCommand.Right(strCommand.GetLength() - 3);
			i = strCommand.Find('"');
			if (i == -1)
			{
				bRetVal = FALSE;
				goto RestoreAndReturn;
			}
			else
			{
				cmdInfo.m_strPrinterName = strCommand.Left(i);
				strCommand = strCommand.Right(strCommand.GetLength() - i);
			}
		}

		if (strCommand.Left(3) != _T("\",\""))
		{
			bRetVal = FALSE;
			goto RestoreAndReturn;
		}
		else
		{
			strCommand = strCommand.Right(strCommand.GetLength() - 3);
			i = strCommand.Find('"');
			if (i == -1)
			{
				bRetVal = FALSE;
				goto RestoreAndReturn;
			}
			else
			{
				cmdInfo.m_strDriverName = strCommand.Left(i);
				strCommand = strCommand.Right(strCommand.GetLength() - i);
			}
		}

		if (strCommand.Left(3) != _T("\",\""))
		{
			bRetVal = FALSE;
			goto RestoreAndReturn;
		}
		else
		{
			strCommand = strCommand.Right(strCommand.GetLength() - 3);
			i = strCommand.Find('"');
			if (i == -1)
			{
				bRetVal = FALSE;
				goto RestoreAndReturn;
			}
			else
			{
				cmdInfo.m_strPortName = strCommand.Left(i);
				strCommand = strCommand.Right(strCommand.GetLength() - i);
			}
		}
	}

	// get document count before opening it
	int nOldCount; nOldCount = GetDocumentCount();

	// open the document, then print it.
	pDoc = AfxGetApp()->OpenDocumentFile(cmdInfo.m_strFileName, FALSE);
	AfxGetApp()->m_pCmdInfo = &cmdInfo;
	AfxGetApp()->m_pMainWnd->SendMessage(WM_COMMAND, ID_FILE_PRINT_DIRECT);
	AfxGetApp()->m_pCmdInfo = NULL;

	// close the document if it wasn't open previously (based on doc count)
	if (GetDocumentCount() > nOldCount)
		pDoc->OnCloseDocument();

	 // if the app was only started to process this command then close
	 if (!AfxOleGetUserCtrl())
		AfxGetApp()->m_pMainWnd->PostMessage(WM_CLOSE);

RestoreAndReturn:
	AfxGetApp()->m_pCmdInfo = pOldInfo;
	return bRetVal;
}

void CDocManager::OnFileNew()
{
	if (m_templateList.IsEmpty())
	{
		TRACE(traceAppMsg, 0, "Error: no document templates registered with CWinApp.\n");
		AfxMessageBox(AFX_IDP_FAILED_TO_CREATE_DOC);
		return;
	}

	CDocTemplate* pTemplate = (CDocTemplate*)m_templateList.GetHead();
	if (m_templateList.GetCount() > 1)
	{
		// more than one document template to choose from
		// bring up dialog prompting user
		CNewTypeDlg dlg(&m_templateList);
		INT_PTR nID = dlg.DoModal();
		if (nID == IDOK)
			pTemplate = dlg.m_pSelectedTemplate;
		else
			return;     // none - cancel operation
	}

	ASSERT(pTemplate != NULL);
	ASSERT_KINDOF(CDocTemplate, pTemplate);

	pTemplate->OpenDocumentFile(NULL);
		// if returns NULL, the user has already been alerted
}

void CDocManager::OnFileOpen()
{
	// prompt the user (with all document templates)
	CString newName;
	if (!DoPromptFileName(newName, AFX_IDS_OPENFILE,
	  OFN_HIDEREADONLY | OFN_FILEMUSTEXIST, TRUE, NULL))
		return; // open cancelled

	AfxGetApp()->OpenDocumentFile(newName);
		// if returns NULL, the user has already been alerted
}

#ifdef _DEBUG
void CDocManager::AssertValid() const
{
	CObject::AssertValid();

	POSITION pos = m_templateList.GetHeadPosition();
	while (pos != NULL)
	{
		CDocTemplate* pTemplate = (CDocTemplate*)m_templateList.GetNext(pos);
		ASSERT_VALID(pTemplate);
	}
}

void CDocManager::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	if (dc.GetDepth() != 0)
	{
		dc << "\nm_templateList[] = {";
		POSITION pos = m_templateList.GetHeadPosition();
		while (pos != NULL)
		{
			CDocTemplate* pTemplate =
				(CDocTemplate*)m_templateList.GetNext(pos);
			dc << "\ntemplate " << pTemplate;
		}
		dc << "}";
	}

	dc << "\n";
}
#endif

CDocument* CDocManager::OpenDocumentFile(LPCTSTR lpszFileName)
{
	return OpenDocumentFile(lpszFileName, TRUE);
}

CDocument* CDocManager::OpenDocumentFile(LPCTSTR lpszFileName, BOOL bAddToMRU)
{
	if (lpszFileName == NULL)
	{
		AfxThrowInvalidArgException();
	}
	// find the highest confidence
	POSITION pos = m_templateList.GetHeadPosition();
	CDocTemplate::Confidence bestMatch = CDocTemplate::noAttempt;
	CDocTemplate* pBestTemplate = NULL;
	CDocument* pOpenDocument = NULL;

	TCHAR szPath[_MAX_PATH];
	ASSERT(lstrlen(lpszFileName) < _countof(szPath));
	TCHAR szTemp[_MAX_PATH];
	if (lpszFileName[0] == '\"')
		++lpszFileName;
	Checked::tcsncpy_s(szTemp, _countof(szTemp), lpszFileName, _TRUNCATE);
	LPTSTR lpszLast = _tcsrchr(szTemp, '\"');
	if (lpszLast != NULL)
		*lpszLast = 0;
	
	if( AfxFullPath(szPath, szTemp) == FALSE )
	{
		ASSERT(FALSE);
		return NULL; // We won't open the file. MFC requires paths with
		             // length < _MAX_PATH
	}

	TCHAR szLinkName[_MAX_PATH];
	if (AfxResolveShortcut(AfxGetMainWnd(), szPath, szLinkName, _MAX_PATH))
		Checked::tcscpy_s(szPath, _countof(szPath), szLinkName);

	while (pos != NULL)
	{
		CDocTemplate* pTemplate = (CDocTemplate*)m_templateList.GetNext(pos);
		ASSERT_KINDOF(CDocTemplate, pTemplate);

		CDocTemplate::Confidence match;
		ASSERT(pOpenDocument == NULL);
		match = pTemplate->MatchDocType(szPath, pOpenDocument);
		if (match > bestMatch)
		{
			bestMatch = match;
			pBestTemplate = pTemplate;
		}
		if (match == CDocTemplate::yesAlreadyOpen)
			break;      // stop here
	}

	if (pOpenDocument != NULL)
	{
		POSITION posOpenDoc = pOpenDocument->GetFirstViewPosition();
		if (posOpenDoc != NULL)
		{
			CView* pView = pOpenDocument->GetNextView(posOpenDoc); // get first one
			ASSERT_VALID(pView);
			CFrameWnd* pFrame = pView->GetParentFrame();

			if (pFrame == NULL)
				TRACE(traceAppMsg, 0, "Error: Can not find a frame for document to activate.\n");
			else
			{
				pFrame->ActivateFrame();

				if (pFrame->GetParent() != NULL)
				{
					CFrameWnd* pAppFrame;
					if (pFrame != (pAppFrame = (CFrameWnd*)AfxGetApp()->m_pMainWnd))
					{
						ASSERT_KINDOF(CFrameWnd, pAppFrame);
						pAppFrame->ActivateFrame();
					}
				}
			}
		}
		else
			TRACE(traceAppMsg, 0, "Error: Can not find a view for document to activate.\n");

		return pOpenDocument;
	}

	if (pBestTemplate == NULL)
	{
		AfxMessageBox(AFX_IDP_FAILED_TO_OPEN_DOC);
		return NULL;
	}

	return pBestTemplate->OpenDocumentFile(szPath, bAddToMRU, TRUE);
}

int CDocManager::GetOpenDocumentCount()
{
	int nOpen = 0;
	POSITION pos = m_templateList.GetHeadPosition();
	while (pos != NULL)
	{
		CDocTemplate* pTemplate = (CDocTemplate*)m_templateList.GetNext(pos);
		POSITION pos2 = pTemplate->GetFirstDocPosition();
		while (pos2)
		{
			if (pTemplate->GetNextDoc(pos2) != NULL)
				nOpen++;
		}
	}
	return nOpen;
}

CDocTemplate* CDocManager::GetBestTemplate(LPCTSTR lpszFileName)
{
	if (lpszFileName == NULL)
	{
		AfxThrowInvalidArgException();
	}

	// find the highest confidence
	POSITION pos = m_templateList.GetHeadPosition();
	CDocTemplate::Confidence bestMatch = CDocTemplate::noAttempt;
	CDocTemplate* pBestTemplate = NULL;
	CDocument* pOpenDocument = NULL;

	while (pos != NULL)
	{
		CDocTemplate* pTemplate = (CDocTemplate*)m_templateList.GetNext(pos);
		ASSERT_KINDOF(CDocTemplate, pTemplate);

		CDocTemplate::Confidence match;
		match = pTemplate->MatchDocType(lpszFileName, pOpenDocument);
		if (match > bestMatch)
		{
			bestMatch = match;
			pBestTemplate = pTemplate;
		}
	}

	return pBestTemplate;
}

CDocManager::~CDocManager()
{
	// for cleanup - delete all document templates
	POSITION pos = m_templateList.GetHeadPosition();
	while (pos != NULL)
	{
		POSITION posTemplate = pos;
		CDocTemplate* pTemplate = (CDocTemplate*)m_templateList.GetNext(pos);
		if (pTemplate->m_bAutoDelete)
		{
			m_templateList.RemoveAt(posTemplate);
			delete (CDocTemplate*)pTemplate;
		}
	}
}


IMPLEMENT_DYNAMIC(CDocManager, CObject)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\dumpflt.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include <float.h>



/////////////////////////////////////////////////////////////////////////////
// Diagnostic Stream output for floating point numbers

#ifdef _DEBUG
CDumpContext& CDumpContext::operator<<(float f)
{
	char szBuffer[32];
	Checked::gcvt_s(szBuffer, 32, f, FLT_DIG);

	*this << szBuffer;
	return *this;
}

CDumpContext& CDumpContext::operator<<(double d)
{
	char szBuffer[32];
	Checked::gcvt_s(szBuffer, 32, d, DBL_DIG);

	*this << szBuffer;
	return *this;
}
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\dumpout.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include <stdarg.h>

#ifdef _DEBUG   // entire file



/////////////////////////////////////////////////////////////////////////////
// Helper routines that can be called from debugger

void AFXAPI AfxDump(const CObject* pOb)
{
	afxDump << pOb;
}

/////////////////////////////////////////////////////////////////////////////
// Diagnostic Trace

void AFX_CDECL AfxTrace(LPCTSTR lpszFormat, ...)
{
	va_list args;
	va_start(args, lpszFormat);

	int nBuf;
	TCHAR szBuffer[512];

	nBuf = _vstprintf_s(szBuffer, _countof(szBuffer), lpszFormat, args); 

	// was there an error? was the expanded string too long?
	ASSERT(nBuf >= 0);

	afxDump << szBuffer;

	va_end(args);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\dumpstak.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#include <atlutil.h>


/////////////////////////////////////////////////////////////////////////////
// Routine to produce stack dump

class CTraceClipboardData : public IStackDumpHandler
{
	HGLOBAL m_hMemory;
	DWORD	m_dwSize;
	DWORD m_dwUsed;
	DWORD m_dwTarget;

public:
	void __stdcall OnBegin()
	{
		SendOut("=== begin AfxDumpStack output ===\r\n");
	}
	void __stdcall OnEntry(void *pvAddress, LPCSTR szModule, LPCSTR szSymbol)
	{
		char sz[40];
		sprintf_s(sz, _countof(sz), "%p: ", pvAddress);
		SendOut(sz);

		if (szModule)
		{
			ATLASSERT(szSymbol);
			SendOut(szModule);
			SendOut("! ");
			SendOut(szSymbol);
		}
		else
			SendOut("symbol not found");
		SendOut("\r\n");
	}

	void __stdcall OnError(LPCSTR szError)
	{
		SendOut(szError);
	}
	void __stdcall OnEnd()
	{
		SendOut("=== end AfxDumpStack() output ===\r\n");
	}
	void SendOut(LPCSTR pszData);
	CTraceClipboardData(DWORD dwTarget);
	~CTraceClipboardData();
};

CTraceClipboardData::CTraceClipboardData(DWORD dwTarget)
	: m_dwTarget(dwTarget), m_dwSize(0), m_dwUsed(0), m_hMemory(NULL)
{
}

CTraceClipboardData::~CTraceClipboardData()
{
	if (m_hMemory != NULL)
	{
		// chuck it onto the clipboard
		// don't free it unless there's an error

		if (!OpenClipboard(NULL))
			GlobalFree(m_hMemory);
		else if (!EmptyClipboard() ||
				SetClipboardData(CF_TEXT, m_hMemory) == NULL)
		{
			GlobalFree(m_hMemory);
		}
		else
			CloseClipboard();
	}
}

void CTraceClipboardData::SendOut(LPCSTR pszData)
{
	int nLength;
	if (pszData == NULL || (nLength = lstrlenA(pszData)) == 0)
		return;

	// send it to TRACE (can be redirected)
	if (m_dwTarget & AFX_STACK_DUMP_TARGET_TRACE)
		TRACE(traceAppMsg, 0, "%hs", pszData);

	// send it to OutputDebugString() (can't redirect)
	if (m_dwTarget & AFX_STACK_DUMP_TARGET_ODS)
		OutputDebugStringA(pszData);

	// build a buffer for the clipboard
	if (m_dwTarget & AFX_STACK_DUMP_TARGET_CLIPBOARD)
	{
		if (m_hMemory == NULL)
		{
			if( nLength > (1024L*1024L) - 1 )
			{
				TRACE(traceAppMsg, 0, "AfxDumpStack Error: pszData larger than one megabyte.\n");
				m_dwTarget &= ~AFX_STACK_DUMP_TARGET_CLIPBOARD;
			}
			else
			{
				m_hMemory = GlobalAlloc(GMEM_MOVEABLE, max( 1024L, nLength + 1 ) );
				if (m_hMemory == NULL)
				{
					TRACE(traceAppMsg, 0, "AfxDumpStack Error: No memory available for clipboard.\n");
					m_dwTarget &= ~AFX_STACK_DUMP_TARGET_CLIPBOARD;
				}
				else
				{
					m_dwUsed = nLength;
					m_dwSize = max( 1024L, nLength + 1 );
					LPSTR pstr = (LPSTR) GlobalLock(m_hMemory);
					if (pstr != NULL)
					{
						Checked::strcpy_s(pstr, ::GlobalSize(m_hMemory), pszData);
						GlobalUnlock(m_hMemory);
					}
					else
					{
						TRACE(traceAppMsg, 0, "AfxDumpStack Error: Couldn't lock memory!\n");
						GlobalFree(m_hMemory);
						m_hMemory = NULL;
						m_dwTarget &= ~AFX_STACK_DUMP_TARGET_CLIPBOARD;
					}
				}
			}
		}
		else
		{
			if ((m_dwUsed + nLength + 1) >= m_dwSize)
			{
				// grow by leaps and bounds
				DWORD dwNewSize = m_dwSize * 2;
				if (dwNewSize > (1024L*1024L))
				{
					TRACE(traceAppMsg, 0, "AfxDumpStack Error: more than one megabyte on clipboard.\n");
					m_dwTarget &= ~AFX_STACK_DUMP_TARGET_CLIPBOARD;
				}

				HGLOBAL hMemory = GlobalReAlloc(m_hMemory, dwNewSize, GMEM_MOVEABLE);
				if (hMemory == NULL)
				{
					TRACE(traceAppMsg, 0, "AfxDumpStack Error: Couldn't get %d bytes!\n", m_dwSize);
					m_dwTarget &= ~AFX_STACK_DUMP_TARGET_CLIPBOARD;
				}
				else
				{
					m_hMemory = hMemory;
					m_dwSize = dwNewSize;
				}
			}

			LPSTR pstr = (LPSTR) GlobalLock(m_hMemory);
			if (pstr != NULL)
			{
				Checked::strncpy_s(pstr + m_dwUsed, m_dwSize - m_dwUsed, pszData, _TRUNCATE);
				m_dwUsed += nLength;
				GlobalUnlock(m_hMemory);
			}
			else
			{
				TRACE(traceAppMsg, 0, "AfxDumpStack Error: Couldn't lock memory!\n");
				m_dwTarget &= ~AFX_STACK_DUMP_TARGET_CLIPBOARD;
			}
		}
	}

	return;
}

/////////////////////////////////////////////////////////////////////////////
// AfxDumpStack API

void AFXAPI AfxDumpStack(DWORD dwTarget /* = AFX_STACK_DUMP_TARGET_DEFAULT */)
{
	CTraceClipboardData clipboardData(dwTarget);

	AtlDumpStack(&clipboardData);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\dumpinit.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "sal.h"

#ifdef _DEBUG   // entire file


AFX_DATADEF CDumpContext afxDump;
AFX_DATADEF BOOL afxTraceEnabled = TRUE;
AFX_DATADEF UINT afxTraceFlags = 0;
static BOOL _afxDiagnosticInit = AfxDiagnosticInit();
static BOOL _afxMemoryLeakDump = TRUE;

/////////////////////////////////////////////////////////////////////////////
// _AFX_DEBUG_STATE implementation

#ifndef _AFX_NO_DEBUG_CRT
static _CRT_DUMP_CLIENT pfnOldCrtDumpClient = NULL;


void __cdecl _AfxCrtDumpClient(void * pvData, size_t nBytes)
{
	if(_CrtReportBlockType(pvData) != _AFX_CLIENT_BLOCK)
		return;
	char sz[256];
	CObject* pObject = (CObject*)pvData;
	bool fCLRPresent=(::GetModuleHandleW(L"mscoree.dll")!=NULL);

#ifndef _AFX_PORTABLE
	// use SEH (structured exception handling) to catch even GPFs
	//  that result from partially valid objects.
	__try
#endif
	{
		if(fCLRPresent) 
		{
			// If the CLR is in the process, we may well be dumping after the managed code execution environment has 
			// shut down. In this case, we can't be sure it is safe to call any method on the object at all, nor 
			// what exception we'd see if we did. So we resort to a terse form
			// 
			// To investigate leaks like this, you'll likely need to set a breakpoint here and look at the object itself
			// or force the leak code to run earlier in your process shutdown
			sprintf_s(sz, _countof(sz), "an object at $%p, %u bytes long\n", pvData, nBytes);
			afxDump << sz;
		}
		// with vtable, verify that object and vtable are valid
		else if (!AfxIsValidAddress(*(void**)pObject, sizeof(void*), FALSE) ||
			!AfxIsValidAddress(pObject, pObject->GetRuntimeClass()->m_nObjectSize, FALSE))
		{
			// short form for invalid objects
			sprintf_s(sz, _countof(sz), "an invalid object at $%p, %u bytes long\n", pvData, nBytes);
			afxDump << sz;
		}
		else if (afxDump.GetDepth() > 0)
		{
			// long form
			pObject->Dump(afxDump);
			afxDump << "\n";
		}
		else
		{
			// short form
			ATL_CRT_ERRORCHECK_SPRINTF(_snprintf_s(sz, _countof(sz), _countof(sz) - 1, "a %hs object at $%p, %u bytes long\n",
				pObject->GetRuntimeClass()->m_lpszClassName, pvData, nBytes));
			afxDump << sz;
		}
	}
#ifndef _AFX_PORTABLE
	__except(EXCEPTION_ACCESS_VIOLATION == GetExceptionCode())
	{
		// short form for trashed objects
		sprintf_s(sz, _countof(sz), "faulted while dumping object at $%p, %u bytes long\n", pvData, nBytes);
		afxDump << sz;
	}
#endif

	if (pfnOldCrtDumpClient != NULL)
		(*pfnOldCrtDumpClient)(pvData, nBytes);
	return;
}

int __cdecl _AfxCrtReportHook(int nRptType, _In_ char *szMsg, int* pResult)
{
	// no hook on asserts or when m_pFile is NULL
	if (nRptType == _CRT_ASSERT || afxDump.m_pFile == NULL)
		return FALSE;

	ASSERT( pResult != NULL );
	if( pResult == NULL )
		AfxThrowInvalidArgException();

	ASSERT( szMsg != NULL );
	if( szMsg == NULL )
		AfxThrowInvalidArgException();

	// non-NULL m_pFile, so go through afxDump for the message
	*pResult = FALSE;
	afxDump << szMsg;
	//Allow other report hooks to be called.
	return FALSE;
}
#endif // _AFX_NO_DEBUG_CRT

_AFX_DEBUG_STATE::_AFX_DEBUG_STATE()
{
#ifndef _AFX_NO_DEBUG_CRT
	ASSERT(pfnOldCrtDumpClient == NULL);
	pfnOldCrtDumpClient = _CrtSetDumpClient(_AfxCrtDumpClient);

	ASSERT(_CrtSetReportHook2(_CRT_RPTHOOK_INSTALL,_AfxCrtReportHook) != -1);
	_CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_WNDW);
#endif // _AFX_NO_DEBUG_CRT
}

_AFX_DEBUG_STATE::~_AFX_DEBUG_STATE()
{
#ifndef _AFX_NO_DEBUG_CRT
	if (_afxMemoryLeakDump)
		_CrtDumpMemoryLeaks();
	int nOldState = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);
	_CrtSetDbgFlag(nOldState & ~_CRTDBG_LEAK_CHECK_DF);

	ASSERT(_CrtSetReportHook2(_CRT_RPTHOOK_REMOVE,_AfxCrtReportHook) != -1);	
	_CrtSetDumpClient(pfnOldCrtDumpClient);
#endif // _AFX_NO_DEBUG_CRT
}

#pragma warning(disable: 4074)
#pragma init_seg(lib)

PROCESS_LOCAL(_AFX_DEBUG_STATE, afxDebugState)

BOOL AFXAPI AfxDiagnosticInit(void)
{
	// just get the debug state to cause initialization
	_AFX_DEBUG_STATE* pState = afxDebugState.GetData();
	ASSERT(pState != NULL);

	return TRUE;
}

BOOL AFXAPI AfxEnableMemoryLeakDump(BOOL bDump)
{
	// get the old flag state
	BOOL bRet = _afxMemoryLeakDump;

	// set the flag to the desired state
	_afxMemoryLeakDump = bDump;

	return bRet;
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\except.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "sal.h"


#ifdef _DEBUG
void PASCAL CException::operator delete(void* pbData)
{
	// check for proper exception object deletion
	CException* pException = (CException*)pbData;
	// use: pException->Delete(), do not use: delete pException
	ASSERT(pException->m_bReadyForDelete);
	ASSERT(pException->m_bAutoDelete > 0);

	// avoid crash when assert above is ignored
	if (pException->m_bReadyForDelete && pException->m_bAutoDelete > 0)
		CObject::operator delete(pbData);
}

void PASCAL CException::operator delete(void* pbData,
	LPCSTR /* lpszFileName */, int /* nLine */)
{
	operator delete(pbData);
}

#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// AFX_EXCEPTION_CONTEXT (thread global state)

inline AFX_EXCEPTION_CONTEXT* AfxGetExceptionContext()
{
	DWORD lError = GetLastError();
	AFX_EXCEPTION_CONTEXT* pContext = &_afxThreadState->m_exceptionContext;
	SetLastError(lError);
	return pContext;
}

/////////////////////////////////////////////////////////////////////////////
// CException

CException::CException()
{
	// most exceptions are deleted when not needed
	m_bAutoDelete = TRUE;
#ifdef _DEBUG
	m_bReadyForDelete = FALSE;
#endif
}

CException::CException(BOOL bAutoDelete)
{
	// for exceptions which are not auto-delete (usually)
	m_bAutoDelete = bAutoDelete;
#ifdef _DEBUG
	m_bReadyForDelete = FALSE;
#endif
}

void CException::Delete()
{
	// delete exception if it is auto-deleting
	if (m_bAutoDelete > 0)
	{
#ifdef _DEBUG
		m_bReadyForDelete = TRUE;
#endif
		delete this;
	}
}

BOOL CException::GetErrorMessage(_Out_z_cap_(nMaxError) LPTSTR lpszError, _In_ UINT nMaxError,
		_Out_opt_ PUINT pnHelpContext /* = NULL */ ) const
{
	if (pnHelpContext != NULL)
		*pnHelpContext = 0;

	if (nMaxError != 0 && lpszError != NULL)
		*lpszError = '\0';

	return FALSE;
}

BOOL CException::GetErrorMessage(_Out_z_cap_(nMaxError) LPTSTR lpszError, _In_ UINT nMaxError,
		_Out_opt_ PUINT pnHelpContext /* = NULL */ )
{
	// Call the const version of GetErrorMessage
	return const_cast<const CException*>(this)->GetErrorMessage(lpszError, nMaxError, pnHelpContext);
}

int CException::ReportError(UINT nType /* = MB_OK */,
	UINT nError /* = 0 */)
{
	TCHAR   szErrorMessage[512];
	int     nDisposition;
	UINT    nHelpContext;

	if (GetErrorMessage(szErrorMessage, _countof(szErrorMessage), &nHelpContext))
		nDisposition = AfxMessageBox(szErrorMessage, nType, nHelpContext);
	else
	{
		if (nError == 0)
			nError = AFX_IDP_NO_ERROR_AVAILABLE;
		nDisposition = AfxMessageBox(nError, nType, nHelpContext);
	}
	return nDisposition;
}

/////////////////////////////////////////////////////////////////////////////
// AFX_EXCEPTION_LINK linked 'jmpbuf' and out-of-line helpers

AFX_EXCEPTION_LINK::AFX_EXCEPTION_LINK()
{
	// setup initial link state
	m_pException = NULL;    // no current exception yet

	// wire into top of exception link stack
	AFX_EXCEPTION_CONTEXT* pContext = AfxGetExceptionContext();
	m_pLinkPrev = pContext->m_pLinkTop;
	pContext->m_pLinkTop = this;
}

// out-of-line cleanup called from inline AFX_EXCEPTION_LINK destructor
void AFXAPI AfxTryCleanup()
{
	AFX_EXCEPTION_CONTEXT* pContext = AfxGetExceptionContext();
	AFX_EXCEPTION_LINK* pLinkTop = pContext->m_pLinkTop;

	// delete current exception
	ASSERT(pLinkTop != NULL);
	if (pLinkTop == NULL)
		return;
	if (pLinkTop->m_pException != NULL)
		pLinkTop->m_pException->Delete();

	// remove ourself from the top of the chain
	pContext->m_pLinkTop = pLinkTop->m_pLinkPrev;
}

// special out-of-line implementation of THROW_LAST (for auto-delete behavior)
void AFXAPI AfxThrowLastCleanup()
{
	AFX_EXCEPTION_CONTEXT* pContext = AfxGetExceptionContext();
	AFX_EXCEPTION_LINK* pLinkTop = pContext->m_pLinkTop;

	// check for THROW_LAST inside of auto-delete block
	if (pLinkTop != NULL)
	{
		// make sure current exception does not get auto-deleted
		pLinkTop->m_pException = NULL;
	}

	// THROW_LAST macro will do actual 'throw'
}



IMPLEMENT_DYNAMIC(CException, CObject)
IMPLEMENT_DYNAMIC(CSimpleException, CException)

IMPLEMENT_DYNAMIC(CMemoryException, CSimpleException)
CMemoryException _simpleMemoryException(FALSE, AFX_IDS_MEMORY_EXCEPTION);

IMPLEMENT_DYNAMIC(CNotSupportedException, CSimpleException)
CNotSupportedException _simpleNotSupportedException(FALSE, AFX_IDS_NOT_SUPPORTED_EXCEPTION);

IMPLEMENT_DYNAMIC(CInvalidArgException, CSimpleException)
CInvalidArgException _simpleInvalidArgException(FALSE, AFX_IDS_INVALID_ARG_EXCEPTION);

/////////////////////////////////////////////////////////////////////////////
// Standard exceptions


void CSimpleException::InitString()
{
	m_bInitialized = TRUE;
	m_bLoaded = (AfxLoadString(m_nResourceID,
		m_szMessage, _countof(m_szMessage)) != 0);
}

BOOL CSimpleException::GetErrorMessage(_Out_z_cap_(nMaxError) LPTSTR lpszError, _In_ UINT nMaxError,
		_Out_opt_ PUINT pnHelpContext) const
{
	ASSERT(lpszError != NULL && AfxIsValidString(lpszError, nMaxError));
	if (lpszError == NULL || nMaxError == 0)
		return FALSE;


	if (pnHelpContext != NULL)
		*pnHelpContext = 0;

	// if we didn't load our string (eg, we're a console app)
	// return a null string and FALSE

	if (!m_bInitialized)
		const_cast<CSimpleException*>(this)->InitString();

	if (m_bLoaded)
		Checked::tcsncpy_s(lpszError, nMaxError, m_szMessage, _TRUNCATE);
	else
		lpszError[0] = '\0';

	return m_bLoaded;
}

void __declspec(noreturn) AFXAPI AfxThrowMemoryException()
{
	THROW(&_simpleMemoryException);
}

void __declspec(noreturn) AFXAPI AfxThrowNotSupportedException()
{
	THROW(&_simpleNotSupportedException);
}

void __declspec(noreturn) AFXAPI AfxThrowInvalidArgException()
{
	THROW(&_simpleInvalidArgException);
}


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\filecore.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include <winnetwk.h>
#include <shlobj.h>
#include <shellapi.h>
#include <Strsafe.h>
#include "sal.h"

AFX_STATIC void AFXAPI _AfxFillExceptionInfo(CFileException* pException,LPCTSTR lpszFileName)
{
	if (pException != NULL)
	{
		pException->m_lOsError = ::GetLastError();
		pException->m_cause =
			CFileException::OsErrorToException(pException->m_lOsError);

		// use passed file name (not expanded vesion) when reporting
		// an error while opening

		pException->m_strFileName = lpszFileName;
	}
}

AFX_STATIC BOOL AFXAPI _AfxFullPath2(_Out_z_cap_c_(_MAX_PATH) LPTSTR lpszPathOut, LPCTSTR lpszFileIn,CFileException* pException);

#define new DEBUG_NEW

AFX_STATIC inline BOOL IsDirSep(TCHAR ch)
{
	return (ch == '\\' || ch == '/');
}

#ifndef _AFX_NO_OLE_SUPPORT

#undef DEFINE_GUID

#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
		EXTERN_C AFX_COMDAT const GUID afx##name \
				= { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }

#define DEFINE_SHLGUID(name, l, w1, w2) DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)

DEFINE_SHLGUID(CLSID_ShellLink, 0x00021401L, 0, 0);
#ifndef _UNICODE
DEFINE_SHLGUID(IID_IShellLinkA, 0x000214EEL, 0, 0);
#else
DEFINE_SHLGUID(IID_IShellLinkW, 0x000214F9L, 0, 0);
#endif
#define CLSID_ShellLink afxCLSID_ShellLink

#undef IID_IShellLink
#undef IShellLink
#ifndef _UNICODE
#define IID_IShellLink afxIID_IShellLinkA
#define IShellLink IShellLinkA
#else
#define IID_IShellLink afxIID_IShellLinkW
#define IShellLink IShellLinkW
#endif

#endif !_AFX_NO_OLE_SUPPORT

////////////////////////////////////////////////////////////////////////////
// CFile implementation

const HANDLE CFile::hFileNull = INVALID_HANDLE_VALUE;

CFile::CFile()
{
	CommonBaseInit(INVALID_HANDLE_VALUE, NULL);
}

CFile::CFile(CAtlTransactionManager* pTM)
{
	CommonBaseInit(INVALID_HANDLE_VALUE, pTM);
}

CFile::CFile(HANDLE hFile)
{
	ASSERT(hFile != INVALID_HANDLE_VALUE);
#ifdef _DEBUG
	DWORD dwFlags = 0;
	ASSERT(GetHandleInformation(hFile, &dwFlags) != 0);
#endif
	CommonBaseInit(hFile, NULL);
}

CFile::CFile(LPCTSTR lpszFileName, UINT nOpenFlags)
{
	CommonInit(lpszFileName, nOpenFlags, NULL);
}

CFile::CFile(LPCTSTR lpszFileName, UINT nOpenFlags, CAtlTransactionManager* pTM)
{
	CommonInit(lpszFileName, nOpenFlags, pTM);
}

void CFile::CommonBaseInit(HANDLE hFile, CAtlTransactionManager* pTM)
{
	m_hFile = hFile;
	m_bCloseOnDelete = FALSE;
	m_pTM = pTM;
}

void CFile::CommonInit(LPCTSTR lpszFileName, UINT nOpenFlags, CAtlTransactionManager* pTM)
{
	ASSERT(lpszFileName != NULL);
	ASSERT(AfxIsValidString(lpszFileName));
	if (lpszFileName == NULL)
	{
		AfxThrowInvalidArgException();
	}

	CommonBaseInit(INVALID_HANDLE_VALUE, pTM);

	CFileException e;
	if (!Open(lpszFileName, nOpenFlags, &e))
	{
		AfxThrowFileException(e.m_cause, e.m_lOsError, e.m_strFileName);
	}
}

CFile::~CFile()
{
	AFX_BEGIN_DESTRUCTOR

	if (m_hFile != INVALID_HANDLE_VALUE && m_bCloseOnDelete)
	{
		Close();
	}

	AFX_END_DESTRUCTOR
}

CFile* CFile::Duplicate() const
{
	ASSERT_VALID(this);
	ASSERT(m_hFile != INVALID_HANDLE_VALUE);

	CFile* pFile = new CFile();
	HANDLE hFile;
	if (!::DuplicateHandle(::GetCurrentProcess(), m_hFile,
		::GetCurrentProcess(), &hFile, 0, FALSE, DUPLICATE_SAME_ACCESS))
	{
		delete pFile;
		CFileException::ThrowOsError((LONG)::GetLastError(), m_strFileName);
	}
	pFile->m_hFile = hFile;
	ASSERT(pFile->m_hFile != INVALID_HANDLE_VALUE);
	pFile->m_bCloseOnDelete = m_bCloseOnDelete;
	pFile->m_pTM = m_pTM;

	return pFile;
}

BOOL CFile::Open(LPCTSTR lpszFileName, UINT nOpenFlags, CAtlTransactionManager* pTM, CFileException* pException)
{
	ASSERT_VALID(this);

	m_pTM = pTM;
	return Open(lpszFileName, nOpenFlags, pException);
}

BOOL CFile::Open(LPCTSTR lpszFileName, UINT nOpenFlags, CFileException* pException)
{
	ASSERT_VALID(this);
	ASSERT(AfxIsValidString(lpszFileName));

	ASSERT(pException == NULL ||
		AfxIsValidAddress(pException, sizeof(CFileException)));
	ASSERT((nOpenFlags & typeText) == 0);   // text mode not supported

	// shouldn't open an already open file (it will leak)
	ASSERT(m_hFile == INVALID_HANDLE_VALUE);

	// CFile objects are always binary and CreateFile does not need flag
	nOpenFlags &= ~(UINT)typeBinary;

	m_bCloseOnDelete = FALSE;

	m_hFile = INVALID_HANDLE_VALUE;
	m_strFileName.Empty();

	TCHAR szTemp[_MAX_PATH];
	if (lpszFileName != NULL && SUCCEEDED(StringCchLength(lpszFileName, _MAX_PATH, NULL)) )
	{
		if( _AfxFullPath2(szTemp, lpszFileName,pException) == FALSE )
			return FALSE;
	}
	else
	{
		// user passed in a buffer greater then _MAX_PATH
		if (pException != NULL)
		{
			pException->m_cause = CFileException::badPath;
			pException->m_strFileName = lpszFileName;
		}
		return FALSE; // path is too long
	}
		
	m_strFileName = szTemp;
	ASSERT(shareCompat == 0);

	// map read/write mode
	ASSERT((modeRead|modeWrite|modeReadWrite) == 3);
	DWORD dwAccess = 0;
	switch (nOpenFlags & 3)
	{
	case modeRead:
		dwAccess = GENERIC_READ;
		break;
	case modeWrite:
		dwAccess = GENERIC_WRITE;
		break;
	case modeReadWrite:
		dwAccess = GENERIC_READ | GENERIC_WRITE;
		break;
	default:
		ASSERT(FALSE);  // invalid share mode
	}

	// map share mode
	DWORD dwShareMode = 0;
	switch (nOpenFlags & 0x70)    // map compatibility mode to exclusive
	{
	default:
		ASSERT(FALSE);  // invalid share mode?
	case shareCompat:
	case shareExclusive:
		dwShareMode = 0;
		break;
	case shareDenyWrite:
		dwShareMode = FILE_SHARE_READ;
		break;
	case shareDenyRead:
		dwShareMode = FILE_SHARE_WRITE;
		break;
	case shareDenyNone:
		dwShareMode = FILE_SHARE_WRITE | FILE_SHARE_READ;
		break;
	}

	// Note: typeText and typeBinary are used in derived classes only.

	// map modeNoInherit flag
	SECURITY_ATTRIBUTES sa;
	sa.nLength = sizeof(sa);
	sa.lpSecurityDescriptor = NULL;
	sa.bInheritHandle = (nOpenFlags & modeNoInherit) == 0;

	// map creation flags
	DWORD dwCreateFlag;
	if (nOpenFlags & modeCreate)
	{
		if (nOpenFlags & modeNoTruncate)
			dwCreateFlag = OPEN_ALWAYS;
		else
			dwCreateFlag = CREATE_ALWAYS;
	}
	else
		dwCreateFlag = OPEN_EXISTING;

	// special system-level access flags

	// Random access and sequential scan should be mutually exclusive
	ASSERT((nOpenFlags&(osRandomAccess|osSequentialScan)) != (osRandomAccess|
		osSequentialScan) );

	DWORD dwFlags = FILE_ATTRIBUTE_NORMAL;
	if (nOpenFlags & osNoBuffer)
		dwFlags |= FILE_FLAG_NO_BUFFERING;
	if (nOpenFlags & osWriteThrough)
		dwFlags |= FILE_FLAG_WRITE_THROUGH;
	if (nOpenFlags & osRandomAccess)
		dwFlags |= FILE_FLAG_RANDOM_ACCESS;
	if (nOpenFlags & osSequentialScan)
		dwFlags |= FILE_FLAG_SEQUENTIAL_SCAN;

	// attempt file creation
	HANDLE hFile = m_pTM != NULL ? 
		m_pTM->CreateFile(lpszFileName, dwAccess, dwShareMode, &sa, dwCreateFlag, dwFlags, NULL) :
		::CreateFile(lpszFileName, dwAccess, dwShareMode, &sa, dwCreateFlag, dwFlags, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		_AfxFillExceptionInfo(pException,lpszFileName);		
		return FALSE;
	}
	m_hFile = hFile;
	m_bCloseOnDelete = TRUE;

	return TRUE;
}

UINT CFile::Read(void* lpBuf, UINT nCount)
{
	ASSERT_VALID(this);
	ASSERT(m_hFile != INVALID_HANDLE_VALUE);

	if (nCount == 0)
		return 0;   // avoid Win32 "null-read"

	ASSERT(lpBuf != NULL);
	ASSERT(AfxIsValidAddress(lpBuf, nCount));

	DWORD dwRead;
	if (!::ReadFile(m_hFile, lpBuf, nCount, &dwRead, NULL))
		CFileException::ThrowOsError((LONG)::GetLastError(), m_strFileName);

	return (UINT)dwRead;
}

void CFile::Write(const void* lpBuf, UINT nCount)
{
	ASSERT_VALID(this);
	ASSERT(m_hFile != INVALID_HANDLE_VALUE);

	if (nCount == 0)
		return;     // avoid Win32 "null-write" option

	ASSERT(lpBuf != NULL);
	ASSERT(AfxIsValidAddress(lpBuf, nCount, FALSE));

	DWORD nWritten;
	if (!::WriteFile(m_hFile, lpBuf, nCount, &nWritten, NULL))
		CFileException::ThrowOsError((LONG)::GetLastError(), m_strFileName);

	if (nWritten != nCount)
		AfxThrowFileException(CFileException::diskFull, -1, m_strFileName);
}

ULONGLONG CFile::Seek(LONGLONG lOff, UINT nFrom)
{
	ASSERT_VALID(this);
	ASSERT(m_hFile != INVALID_HANDLE_VALUE);
	ASSERT(nFrom == begin || nFrom == end || nFrom == current);
	ASSERT(begin == FILE_BEGIN && end == FILE_END && current == FILE_CURRENT);

   LARGE_INTEGER liOff;

   liOff.QuadPart = lOff;
	liOff.LowPart = ::SetFilePointer(m_hFile, liOff.LowPart, &liOff.HighPart,
	  (DWORD)nFrom);
	if (liOff.LowPart  == (DWORD)-1)
	  if (::GetLastError() != NO_ERROR)
		   CFileException::ThrowOsError((LONG)::GetLastError(), m_strFileName);

	return liOff.QuadPart;
}

ULONGLONG CFile::GetPosition() const
{
	ASSERT_VALID(this);
	ASSERT(m_hFile != INVALID_HANDLE_VALUE);

   LARGE_INTEGER liPos;
   liPos.QuadPart = 0;
	liPos.LowPart = ::SetFilePointer(m_hFile, liPos.LowPart, &liPos.HighPart , FILE_CURRENT);
	if (liPos.LowPart == (DWORD)-1)
	  if (::GetLastError() != NO_ERROR)
		   CFileException::ThrowOsError((LONG)::GetLastError(), m_strFileName);

	return liPos.QuadPart;
}

void CFile::Flush()
{
	ASSERT_VALID(this);

	if (m_hFile == INVALID_HANDLE_VALUE)
		return;

	if (!::FlushFileBuffers(m_hFile))
		CFileException::ThrowOsError((LONG)::GetLastError(), m_strFileName);
}

void CFile::Close()
{
	ASSERT_VALID(this);
	ASSERT(m_hFile != INVALID_HANDLE_VALUE);
	BOOL bError = FALSE;
	if (m_hFile != INVALID_HANDLE_VALUE)
		bError = !::CloseHandle(m_hFile);

	m_hFile = INVALID_HANDLE_VALUE;
	m_bCloseOnDelete = FALSE;
	m_strFileName.Empty();

	if (bError)
		CFileException::ThrowOsError((LONG)::GetLastError(), m_strFileName);
}

void CFile::Abort()
{
	ASSERT_VALID(this);
	if (m_hFile != INVALID_HANDLE_VALUE)
	{
		// close but ignore errors
		::CloseHandle(m_hFile);
		m_hFile = INVALID_HANDLE_VALUE;
	}
	m_strFileName.Empty();
}

void CFile::LockRange(ULONGLONG dwPos, ULONGLONG dwCount)
{
	ASSERT_VALID(this);
	ASSERT(m_hFile != INVALID_HANDLE_VALUE);

   ULARGE_INTEGER liPos;
   ULARGE_INTEGER liCount;

   liPos.QuadPart = dwPos;
   liCount.QuadPart = dwCount;
	if (!::LockFile(m_hFile, liPos.LowPart, liPos.HighPart, liCount.LowPart, 
	  liCount.HighPart))
   {
		CFileException::ThrowOsError((LONG)::GetLastError(), m_strFileName);
   }
}

void CFile::UnlockRange(ULONGLONG dwPos, ULONGLONG dwCount)
{
	ASSERT_VALID(this);
	ASSERT(m_hFile != INVALID_HANDLE_VALUE);

   ULARGE_INTEGER liPos;
   ULARGE_INTEGER liCount;

   liPos.QuadPart = dwPos;
   liCount.QuadPart = dwCount;
	if (!::UnlockFile(m_hFile, liPos.LowPart, liPos.HighPart, liCount.LowPart,
	  liCount.HighPart))
   {
		CFileException::ThrowOsError((LONG)::GetLastError(), m_strFileName);
   }
}

void CFile::SetLength(ULONGLONG dwNewLen)
{
	ASSERT_VALID(this);
	ASSERT(m_hFile != INVALID_HANDLE_VALUE);

	Seek(dwNewLen, (UINT)begin);

	if (!::SetEndOfFile(m_hFile))
		CFileException::ThrowOsError((LONG)::GetLastError(), m_strFileName);
}

ULONGLONG CFile::GetLength() const
{
	ASSERT_VALID(this);

   ULARGE_INTEGER liSize;
   liSize.LowPart = ::GetFileSize(m_hFile, &liSize.HighPart);
   if (liSize.LowPart == INVALID_FILE_SIZE)
	  if (::GetLastError() != NO_ERROR)
		 CFileException::ThrowOsError((LONG)::GetLastError(), m_strFileName);

	return liSize.QuadPart;
}

// CFile does not support direct buffering (CMemFile does)
UINT CFile::GetBufferPtr(UINT nCommand, UINT /*nCount*/,
	void** /*ppBufStart*/, void** /*ppBufMax*/)
{
	ASSERT(nCommand == bufferCheck);
	UNUSED(nCommand);    // not used in retail build

	return 0;   // no support
}

void PASCAL CFile::Rename(LPCTSTR lpszOldName, LPCTSTR lpszNewName, CAtlTransactionManager* pTM)
{
	BOOL bRes = (pTM != NULL) ? pTM->MoveFile(lpszOldName, lpszNewName) : ::MoveFile((LPTSTR)lpszOldName, (LPTSTR)lpszNewName);
	if (!bRes)
		CFileException::ThrowOsError((LONG)::GetLastError(), lpszOldName);
}

void PASCAL CFile::Remove(LPCTSTR lpszFileName, CAtlTransactionManager* pTM)
{
	BOOL bRes = (pTM != NULL) ? pTM->DeleteFile(lpszFileName) : ::DeleteFile((LPTSTR)lpszFileName);
	if (!bRes)
		CFileException::ThrowOsError((LONG)::GetLastError(), lpszFileName);
}


/////////////////////////////////////////////////////////////////////////////
// CFile implementation helpers

#ifdef AfxGetFileName
#undef AfxGetFileName
#endif

#ifndef _AFX_NO_OLE_SUPPORT

HRESULT AFX_COM::CreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter,
	REFIID riid, LPVOID* ppv)
{
	// find the object's class factory
	LPCLASSFACTORY pf = NULL;
	
	if (ppv == NULL)
		return E_INVALIDARG;
	*ppv = NULL;
	
	HRESULT hRes = GetClassObject(rclsid, IID_IClassFactory, (LPVOID*)&pf);
	if (FAILED(hRes))
		return hRes;

	if (pf == NULL)
		return E_POINTER;
		
	// call it to create the instance	
	hRes = pf->CreateInstance(pUnkOuter, riid, ppv);

	// let go of the factory
	pf->Release();
	return hRes;
}

HRESULT AFX_COM::GetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	*ppv = NULL;
	HINSTANCE hInst = NULL;

	// find server name for this class ID

	CString strCLSID = AfxStringFromCLSID(rclsid);
	CString strServer;
	if (!AfxGetInProcServer(strCLSID, strServer))
		return REGDB_E_CLASSNOTREG;

	// try to load it
	hInst = AfxCtxLoadLibrary(strServer);
	if (hInst == NULL)
		return REGDB_E_CLASSNOTREG;

#pragma warning(disable:4191)
	// get its entry point
	HRESULT (STDAPICALLTYPE* pfn)(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
	pfn = (HRESULT (STDAPICALLTYPE*)(REFCLSID rclsid, REFIID riid, LPVOID* ppv))
		GetProcAddress(hInst, "DllGetClassObject");
#pragma warning(default:4191)

	// call it, if it worked
	if (pfn != NULL)
		return pfn(rclsid, riid, ppv);
	return CO_E_ERRORINDLL;
}

CString AFXAPI AfxStringFromCLSID(REFCLSID rclsid)
{
	TCHAR szCLSID[256];
	_stprintf_s(szCLSID, _countof(szCLSID),
		_T("{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"),
		rclsid.Data1, rclsid.Data2, rclsid.Data3,
		rclsid.Data4[0], rclsid.Data4[1], rclsid.Data4[2], rclsid.Data4[3],
		rclsid.Data4[4], rclsid.Data4[5], rclsid.Data4[6], rclsid.Data4[7]);
	return szCLSID;
}

BOOL AFXAPI AfxGetInProcServer(LPCTSTR lpszCLSID, CString& str)
{
	HKEY hKey = NULL;
	BOOL b = FALSE;
	LPTSTR lpsz = str.GetBuffer(_MAX_PATH);
	DWORD dwSize = _MAX_PATH * sizeof(TCHAR);
	DWORD dwType = REG_NONE;
	LONG lRes = ~ERROR_SUCCESS;

	if (RegOpenKeyExW(HKEY_CLASSES_ROOT, L"CLSID", 0, KEY_READ, &hKey) == ERROR_SUCCESS)
	{
		HKEY hKeyCLSID = NULL;
		if (RegOpenKeyEx(hKey, lpszCLSID, 0, KEY_READ, &hKeyCLSID) == ERROR_SUCCESS)
		{
			HKEY hKeyInProc = NULL;
			if (RegOpenKeyExW(hKeyCLSID, L"InProcServer32", 0, KEY_QUERY_VALUE, &hKeyInProc) ==
				ERROR_SUCCESS)
			{
				lRes = ::RegQueryValueEx(hKeyInProc, _T(""),
					NULL, &dwType, (BYTE*)lpsz, &dwSize);
				b = (lRes == ERROR_SUCCESS);
				RegCloseKey(hKeyInProc);
			}
			RegCloseKey(hKeyCLSID);
		}
		RegCloseKey(hKey);
	}
	str.ReleaseBuffer();
	return b;
}
#endif  //!_AFX_NO_OLE_SUPPORT


BOOL AFXAPI AfxResolveShortcut(CWnd* pWnd, LPCTSTR lpszFileIn,
	_Out_cap_(cchPath) LPTSTR lpszFileOut, int cchPath)
{
	AFX_COM com;
	IShellLink* psl = NULL;
	*lpszFileOut = 0;   // assume failure
	
	if (!pWnd)
		return FALSE;

	SHFILEINFO info;
	if ((SHGetFileInfo(lpszFileIn, 0, &info, sizeof(info),
		SHGFI_ATTRIBUTES) == 0) || !(info.dwAttributes & SFGAO_LINK))
	{
		return FALSE;
	}

	if (FAILED(com.CreateInstance(CLSID_ShellLink, NULL, IID_IShellLink,
		(LPVOID*)&psl)) || psl == NULL)
	{
		return FALSE;
	}

	IPersistFile *ppf = NULL;
	if (SUCCEEDED(psl->QueryInterface(IID_IPersistFile, (LPVOID*)&ppf)))
	{
		CStringW strFileIn(lpszFileIn);
		if (ppf != NULL && SUCCEEDED(ppf->Load(strFileIn.GetString(), STGM_READ)))
		{
			/* Resolve the link, this may post UI to find the link */
			if (SUCCEEDED(psl->Resolve(pWnd->GetSafeHwnd(),
				SLR_ANY_MATCH)))
			{
				psl->GetPath(lpszFileOut, cchPath, NULL, 0);
				ppf->Release();
				psl->Release();
				return TRUE;
			}
		}
		if (ppf != NULL)
			ppf->Release();
	}
	psl->Release();
	return FALSE;
}


// turn a file, relative path or other into an absolute path
BOOL AFXAPI _AfxFullPath2(_Out_z_cap_c_(_MAX_PATH) LPTSTR lpszPathOut, LPCTSTR lpszFileIn, CFileException* pException)
	// lpszPathOut = buffer of _MAX_PATH
	// lpszFileIn = file, relative path or absolute path
	// (both in ANSI character set)
	// pException - pointer to exception object - can be NULL.
{
	pException;
	ENSURE(lpszPathOut);
	ENSURE(lpszFileIn);
	ASSERT(AfxIsValidAddress(lpszPathOut, _MAX_PATH));

	// first, fully qualify the path name
	LPTSTR lpszFilePart;
	DWORD dwRet = GetFullPathName(lpszFileIn, _MAX_PATH, lpszPathOut, &lpszFilePart);
	if (dwRet == 0)
	{
#ifdef _DEBUG
		if (lpszFileIn != NULL && lpszFileIn[0] != '\0')
			TRACE(traceAppMsg, 0, _T("Warning: could not parse the path '%s'.\n"), lpszFileIn);
#endif
		Checked::tcsncpy_s(lpszPathOut, _MAX_PATH, lpszFileIn, _TRUNCATE); // take it literally
		_AfxFillExceptionInfo(pException,lpszFileIn);
		return FALSE;
	}
	else if (dwRet >= _MAX_PATH)
	{
		#ifdef _DEBUG
			if (lpszFileIn[0] != '\0')
				TRACE1("Warning: could not parse the path '%s'. Path is too long.\n", lpszFileIn);
		#endif
		// GetFullPathName() returned a path greater than _MAX_PATH
		if (pException != NULL)
		{
			pException->m_cause = CFileException::badPath;
			pException->m_strFileName = lpszFileIn;
		}
		return FALSE; // long path won't fit in buffer
	}

	CString strRoot;
	// determine the root name of the volume
	AfxGetRoot(lpszPathOut, strRoot);

	if (!::PathIsUNC( strRoot ))
	{
		// get file system information for the volume
		DWORD dwFlags, dwDummy;
		if (!GetVolumeInformation(strRoot, NULL, 0, NULL, &dwDummy, &dwFlags,
			NULL, 0))
		{
			TRACE(traceAppMsg, 0, _T("Warning: could not get volume information '%s'.\n"),
				(LPCTSTR)strRoot);
			_AfxFillExceptionInfo(pException,lpszFileIn);
			return FALSE;   // preserving case may not be correct
		}

		// not all characters have complete uppercase/lowercase
		if (!(dwFlags & FS_CASE_IS_PRESERVED))
			CharUpper(lpszPathOut);

		// assume non-UNICODE file systems, use OEM character set
		if (!(dwFlags & FS_UNICODE_STORED_ON_DISK))
		{
			WIN32_FIND_DATA data;
			HANDLE h = FindFirstFile(lpszFileIn, &data);
			if (h != INVALID_HANDLE_VALUE)
			{
				FindClose(h);
				if(lpszFilePart != NULL && lpszFilePart > lpszPathOut)
				{
					int nFileNameLen = lstrlen(data.cFileName);
					int nIndexOfPart = (int)(lpszFilePart - lpszPathOut);
					if ((nFileNameLen + nIndexOfPart) < _MAX_PATH)
					{
						Checked::tcscpy_s(lpszFilePart, _MAX_PATH - nIndexOfPart, data.cFileName);
					}
					else
					{
						// the path+filename of the file is too long
						if (pException != NULL)
						{
							pException->m_cause = CFileException::badPath;
							pException->m_strFileName = lpszFileIn;
						}
						return FALSE; // Path doesn't fit in the buffer.
					}
				}
				else
				{
					_AfxFillExceptionInfo(pException,lpszFileIn);
					return FALSE;
				}
			}
		}
	}
	
	return TRUE;
}
//Backward compatible wrapper that calls the new exception throwing func.
BOOL AFXAPI AfxFullPath(_Pre_notnull_ _Post_z_ LPTSTR lpszPathOut, LPCTSTR lpszFileIn)
{
	return _AfxFullPath2(lpszPathOut, lpszFileIn,NULL);
}

void AFXAPI AfxGetRoot(LPCTSTR lpszPath, CString& strRoot)
{
	ASSERT(lpszPath != NULL);

	LPTSTR lpszRoot = strRoot.GetBuffer(_MAX_PATH);
	memset(lpszRoot, 0, _MAX_PATH);
	Checked::tcsncpy_s(lpszRoot, _MAX_PATH, lpszPath, _TRUNCATE);
	PathStripToRoot(lpszRoot);
	strRoot.ReleaseBuffer();
}

BOOL AFXAPI AfxComparePath(LPCTSTR lpszPath1, LPCTSTR lpszPath2)
{
#pragma warning(push)
#pragma warning(disable:4068)
#pragma prefast(push)
#pragma prefast(disable:400, "lstrcmpi is ok here as we are backing it up with further comparison")
	// use case insensitive compare as a starter
	if (lstrcmpi(lpszPath1, lpszPath2) != 0)
    {
		return FALSE;
    }
#pragma prefast(pop)
#pragma warning(pop)

	// on non-DBCS systems, we are done
	if (!GetSystemMetrics(SM_DBCSENABLED))
		return TRUE;

	// on DBCS systems, the file name may not actually be the same
	// in particular, the file system is case sensitive with respect to
	// "full width" roman characters.
	// (ie. fullwidth-R is different from fullwidth-r).
	int nLen = lstrlen(lpszPath1);
	if (nLen != lstrlen(lpszPath2))
		return FALSE;
	ASSERT(nLen < _MAX_PATH);

	// need to get both CT_CTYPE1 and CT_CTYPE3 for each filename
	LCID lcid = GetThreadLocale();
	WORD aCharType11[_MAX_PATH];
	VERIFY(GetStringTypeEx(lcid, CT_CTYPE1, lpszPath1, -1, aCharType11));
	WORD aCharType13[_MAX_PATH];
	VERIFY(GetStringTypeEx(lcid, CT_CTYPE3, lpszPath1, -1, aCharType13));
	WORD aCharType21[_MAX_PATH];
	VERIFY(GetStringTypeEx(lcid, CT_CTYPE1, lpszPath2, -1, aCharType21));
#ifdef _DEBUG
	WORD aCharType23[_MAX_PATH];
	VERIFY(GetStringTypeEx(lcid, CT_CTYPE3, lpszPath2, -1, aCharType23));
#endif

	// for every C3_FULLWIDTH character, make sure it has same C1 value
	int i = 0;
	for (LPCTSTR lpsz = lpszPath1; *lpsz != 0; lpsz = _tcsinc(lpsz))
	{
		// check for C3_FULLWIDTH characters only
		if (aCharType13[i] & C3_FULLWIDTH)
		{
#ifdef _DEBUG
			ASSERT(aCharType23[i] & C3_FULLWIDTH); // should always match!
#endif

			// if CT_CTYPE1 is different then file system considers these
			// file names different.
			if (aCharType11[i] != aCharType21[i])
				return FALSE;
		}
		++i; // look at next character type
	}
	return TRUE; // otherwise file name is truly the same
}

UINT AFXAPI AfxGetFileTitle(LPCTSTR lpszPathName, _Out_cap_(nMax) LPTSTR lpszTitle, UINT nMax)
{
	ASSERT(lpszTitle == NULL ||
		AfxIsValidAddress(lpszTitle, _MAX_FNAME));
	ASSERT(AfxIsValidString(lpszPathName));

	// use a temporary to avoid bugs in ::GetFileTitle when lpszTitle is NULL
	TCHAR szTemp[_MAX_PATH];
	LPTSTR lpszTemp = lpszTitle;
	if (lpszTemp == NULL)
	{
		lpszTemp = szTemp;
		nMax = _countof(szTemp);
	}
	if (::GetFileTitle(lpszPathName, lpszTemp, (WORD)nMax) != 0)
	{
		// when ::GetFileTitle fails, use cheap imitation
		return AfxGetFileName(lpszPathName, lpszTitle, nMax);
	}
	return lpszTitle == NULL ? lstrlen(lpszTemp)+1 : 0;
}

void AFXAPI AfxGetModuleFileName(HINSTANCE hInst, CString& strFileName)
{
	TCHAR szLongPathName[_MAX_PATH];
	::GetModuleFileName(hInst, szLongPathName, _MAX_PATH);
	strFileName = szLongPathName;
}

void AFXAPI AfxGetModuleShortFileName(HINSTANCE hInst, CString& strShortName)
{
	TCHAR szLongPathName[_MAX_PATH];
	::GetModuleFileName(hInst, szLongPathName, _MAX_PATH);
	if (::GetShortPathName(szLongPathName,
		strShortName.GetBuffer(_MAX_PATH), _MAX_PATH) == 0)
	{
		// rare failure case (especially on not-so-modern file systems)
		strShortName = szLongPathName;
	}
	strShortName.ReleaseBuffer();
}

/////////////////////////////////////////////////////////////////////////////
// CFile diagnostics

#ifdef _DEBUG
void CFile::AssertValid() const
{
	CObject::AssertValid();
	// we permit the descriptor m_hFile to be any value for derived classes
}

void CFile::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	dc << "with handle " << (void*)m_hFile;
	dc << " and name \"" << m_strFileName << "\"";
	dc << "\n";
}
#endif


IMPLEMENT_DYNAMIC(CFile, CObject)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\dumpcont.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



/////////////////////////////////////////////////////////////////////////////
// Diagnostic Stream output

void CDumpContext::OutputString(LPCTSTR lpsz)
{
	// use C-runtime/OutputDebugString when m_pFile is NULL
	if (m_pFile == NULL)
	{
		TRACE(traceDumpContext, 0, _T("%s"), lpsz);
		return;
	}

	ASSERT( lpsz != NULL );
	if( lpsz == NULL )
		AfxThrowUserException();
	// otherwise, write the string to the file
	m_pFile->Write(lpsz, lstrlen(lpsz)*sizeof(TCHAR));
}

CDumpContext::CDumpContext(CFile* pFile)
{
	if (pFile)
		ASSERT_VALID(pFile);

	m_pFile = pFile;
	m_nDepth = 0;
}

void CDumpContext::Flush()
{
	if (m_pFile)
		m_pFile->Flush();
}

CDumpContext& CDumpContext::operator<<(LPCTSTR lpsz)
{
	if (lpsz == NULL)
	{
		OutputString(_T("NULL"));
		return *this;
	}

	ASSERT( lpsz != NULL );
	if( lpsz == NULL )
		AfxThrowUserException();

	if (m_pFile == NULL)
	{
		TCHAR szBuffer[512];
		LPTSTR lpBuf = szBuffer;
		while (*lpsz != '\0')
		{
			if (lpBuf > szBuffer + _countof(szBuffer) - 3)
			{
				*lpBuf = '\0';
				OutputString(szBuffer);
				lpBuf = szBuffer;
			}
			if (*lpsz == '\n')
				*lpBuf++ = '\r';
			*lpBuf++ = *lpsz++;
		}
		*lpBuf = '\0';
		OutputString(szBuffer);
		return *this;
	}

	m_pFile->Write(lpsz, lstrlen(lpsz)*sizeof(TCHAR));
	return *this;
}

CDumpContext& CDumpContext::operator<<(BYTE by)
{
	TCHAR szBuffer[32];

	_stprintf_s(szBuffer, _countof(szBuffer), _T("%d"), (DWORD)by);
	OutputString(szBuffer);

	return *this;
}

CDumpContext& CDumpContext::DumpAsHex(BYTE b)
{
	TCHAR szBuffer[32];

	_stprintf_s(szBuffer, _countof(szBuffer), _T("0x%02x"), (DWORD)b);
	OutputString(szBuffer);

	return *this;
}

CDumpContext& CDumpContext::operator<<(WORD w)
{
	TCHAR szBuffer[32];

	_stprintf_s(szBuffer, _countof(szBuffer), _T("%u"), (UINT) w);
	OutputString(szBuffer);

	return *this;
}

CDumpContext& CDumpContext::DumpAsHex(WORD w)
{
	TCHAR szBuffer[32];

	_stprintf_s(szBuffer, _countof(szBuffer), _T("0x%04x"), (DWORD)w);
	OutputString(szBuffer);

	return *this;
}

#ifdef _WIN64
CDumpContext& CDumpContext::operator<<(UINT u)
#else
CDumpContext& CDumpContext::operator<<(UINT_PTR u)
#endif
{
	TCHAR szBuffer[32];

	_stprintf_s(szBuffer, _countof(szBuffer), _T("%u"), u);
	OutputString(szBuffer);

	return *this;
}

#ifdef _WIN64
CDumpContext& CDumpContext::operator<<(LONG l)
#else
CDumpContext& CDumpContext::operator<<(LONG_PTR l)
#endif
{
	TCHAR szBuffer[32];

	_stprintf_s(szBuffer, _countof(szBuffer), _T("%d"), l);
	OutputString(szBuffer);

	return *this;
}

#ifdef _WIN64
CDumpContext& CDumpContext::operator<<(DWORD dw)
#else
CDumpContext& CDumpContext::operator<<(DWORD_PTR dw)
#endif
{
	TCHAR szBuffer[32];

	_stprintf_s(szBuffer, _countof(szBuffer), _T("%u"), dw);
	OutputString(szBuffer);

	return *this;
}

#ifdef _WIN64
CDumpContext& CDumpContext::operator<<(int n)
#else
CDumpContext& CDumpContext::operator<<(INT_PTR n)
#endif
{
	TCHAR szBuffer[32];

	_stprintf_s(szBuffer, _countof(szBuffer), _T("%d"), n);
	OutputString(szBuffer);

	return *this;
}

#ifdef _WIN64
CDumpContext& CDumpContext::DumpAsHex(UINT u)
#else
CDumpContext& CDumpContext::DumpAsHex(UINT_PTR u)
#endif
{
	TCHAR szBuffer[32];

	_stprintf_s(szBuffer, _countof(szBuffer), _T("0x%08x"), u);
	OutputString(szBuffer);

	return *this;
}

#ifdef _WIN64
CDumpContext& CDumpContext::DumpAsHex(LONG l)
#else
CDumpContext& CDumpContext::DumpAsHex(LONG_PTR l)
#endif
{
	TCHAR szBuffer[32];

	_stprintf_s(szBuffer, _countof(szBuffer), _T("0x%08x"), l);
	OutputString(szBuffer);

	return *this;
}

#ifdef _WIN64
CDumpContext& CDumpContext::DumpAsHex(DWORD dw)
#else
CDumpContext& CDumpContext::DumpAsHex(DWORD_PTR dw)
#endif
{
	TCHAR szBuffer[32];

	_stprintf_s(szBuffer, _countof(szBuffer), _T("0x%08x"), dw);
	OutputString(szBuffer);

	return *this;
}

#ifdef _WIN64
CDumpContext& CDumpContext::DumpAsHex(int n)
#else
CDumpContext& CDumpContext::DumpAsHex(INT_PTR n)
#endif
{
	TCHAR szBuffer[32];

	_stprintf_s(szBuffer, _countof(szBuffer), _T("0x%08x"), n);
	OutputString(szBuffer);

	return *this;
}

CDumpContext& CDumpContext::operator<<(LONGLONG n)
{
	TCHAR szBuffer[32];

	_stprintf_s(szBuffer, _countof(szBuffer), _T("%I64d"), n);
	OutputString(szBuffer);

	return *this;
}

CDumpContext& CDumpContext::operator<<(ULONGLONG n)
{
	TCHAR szBuffer[32];

	_stprintf_s(szBuffer, _countof(szBuffer), _T("%I64u"), n);
	OutputString(szBuffer);

	return *this;
}

CDumpContext& CDumpContext::DumpAsHex(LONGLONG n)
{
	TCHAR szBuffer[32];

	_stprintf_s(szBuffer, _countof(szBuffer), _T("0x%016I64x"), n);
	OutputString(szBuffer);

	return *this;
}

CDumpContext& CDumpContext::DumpAsHex(ULONGLONG n)
{
	TCHAR szBuffer[32];

	_stprintf_s(szBuffer, _countof(szBuffer), _T("0x%016I64x"), n);
	OutputString(szBuffer);

	return *this;
}

CDumpContext& CDumpContext::operator<<(const CObject* pOb)
{
	if (pOb == NULL)
		*this << _T("NULL");
	else
#ifdef _AFXDLL
		pOb->Dump(*this);
#else
		*this << _T("Unable to dump object in static release builds");
#endif

	return *this;
}

CDumpContext& CDumpContext::operator<<(const CObject& ob)
{
	return *this << &ob;
}

CDumpContext& CDumpContext::operator<<(const void* lp)
{
	TCHAR szBuffer[32];

	// prefix a pointer with "$" and print in hex
	_stprintf_s(szBuffer, _countof(szBuffer), _T("$%p"), lp);
	OutputString(szBuffer);

	return *this;
}

CDumpContext& CDumpContext::operator<<(HWND h)
{
	return *this << (void*)h;
}

CDumpContext& CDumpContext::operator<<(HDC h)
{
	return *this << (void*)h;
}

CDumpContext& CDumpContext::operator<<(HMENU h)
{
	return *this << (void*)h;
}

CDumpContext& CDumpContext::operator<<(HACCEL h)
{
	return *this << (void*)h;
}

CDumpContext& CDumpContext::operator<<(HFONT h)
{
	return *this << (void*)h;
}

/////////////////////////////////////////////////////////////////////////////
// Formatted output

void CDumpContext::HexDump(LPCTSTR lpszLine, BYTE* pby,
	int nBytes, int nWidth)
// do a simple hex-dump (8 per line) to a CDumpContext
//  the "lpszLine" is a string to print at the start of each line
//    (%lx should be used to expand the current address)
{
	ASSERT(nBytes > 0);
	if( nBytes <= 0 )
		AfxThrowInvalidArgException();
	ASSERT(nWidth > 0);
	if( nWidth <= 0 )
		AfxThrowInvalidArgException();
	ASSERT(AfxIsValidString(lpszLine));
	if( lpszLine == NULL )
		AfxThrowInvalidArgException();
	ASSERT(AfxIsValidAddress(pby, nBytes, FALSE));
	if( pby == NULL )
		AfxThrowInvalidArgException();

	int nRow = 0;
	TCHAR szBuffer[32];

	while (nBytes--)
	{
		if (nRow == 0)
		{
			_stprintf_s(szBuffer, _countof(szBuffer), lpszLine, pby);
			*this << szBuffer;
		}

		_stprintf_s(szBuffer, _countof(szBuffer), _T(" %02X"), *pby++);
		*this << szBuffer;

		if (++nRow >= nWidth)
		{
			*this << _T("\n");
			nRow = 0;
		}
	}
	if (nRow != 0)
		*this << _T("\n");
}

/////////////////////////////////////////////////////////////////////////////

#ifdef _UNICODE
// special version for ANSI characters
CDumpContext& CDumpContext::operator<<(LPCSTR lpsz)
{
	if (lpsz == NULL)
	{
		OutputString(L"(NULL)");
		return *this;
	}

	// limited length
	TCHAR szBuffer[512];
	_mbstowcsz(szBuffer, lpsz, _countof(szBuffer));
	szBuffer[511] = 0;
	return *this << szBuffer;
}
#else   //_UNICODE
// special version for WIDE characters
CDumpContext& CDumpContext::operator<<(LPCWSTR lpsz)
{
	if (lpsz == NULL)
	{
		OutputString("(NULL)");
		return *this;
	}

	// limited length
	char szBuffer[512];
	_wcstombsz(szBuffer, lpsz, _countof(szBuffer));
	szBuffer[511] = 0;
	return *this << szBuffer;
}
#endif  //!_UNICODE

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\elements.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Collection implementation helpers

/*
* The short story:
*   this file contains inline functions that make up the building blocks
*   for implementing the string versions of standard parameterized
*   collection shapes
*
* The long story:
*   Because the implementation of collection classes moves objects around
*   in various ways, it is very inefficient to use only generic C++ constructs.
*   For example, in order to grow an array of FOO objects by one element,
*   you would be forced to allocate a new array of appropriate size, calling
*   the FOO constructor on every element.  Then copy the original array, element
*   by element using a possibly overloaded assignment operator.  Finally destroy
*   the original array element by element.
*   For built-in data types (WORD, DWORD, pointer types), this is complete
*   overkill.  For non-trivial classes (eg: CString in particular) this is
*   a terrible implementation.
*
*   The bottom line: we have two special routines for doing construction
*   and destruction of arrays of special elements - in particular CStrings.
*   The standard templates are parameterized on 'HAS_CREATE' which is
*   non-zero if the collection implementation requires a special
*   construct and destruct function.
*
*   Please note that these are inline overloaded operators, and do not have
*   any form of runtime polymorphism (i.e. nothing is 'virtual').
*/

/////////////////////////////////////////////////////////////////////////////
// Special implementations for CStrings
// it is faster to bit-wise copy a CString than to call an official
//   constructor - since an empty CString can be bit-wise copied

static inline void ConstructElement(CString* pNewData)
{
	ENSURE_ARG(pNewData!=NULL);
	new( pNewData ) CString;
}

static inline void DestructElement(CString* pOldData)
{
	ENSURE_ARG(pOldData!=NULL);
	pOldData->~CString();
}

static inline void CopyElement(CString* pSrc, CString* pDest)
{
	ENSURE_ARG(pSrc!=NULL && pDest!=NULL);
	*pSrc = *pDest;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\filefind.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

////////////////////////////////////////////////////////////////////////////
// CFileFind implementation

CFileFind::CFileFind()
{
	m_pFoundInfo = NULL;
	m_pNextInfo = NULL;
	m_hContext = NULL;
	m_chDirSeparator = '\\';
	m_pTM = NULL;
}

CFileFind::CFileFind(CAtlTransactionManager* pTM)
{
	m_pFoundInfo = NULL;
	m_pNextInfo = NULL;
	m_hContext = NULL;
	m_chDirSeparator = '\\';
	m_pTM = pTM;
}

CFileFind::~CFileFind()
{
	Close();
}

void CFileFind::Close()
{
	if (m_pFoundInfo != NULL)
	{
		delete m_pFoundInfo;
		m_pFoundInfo = NULL;
	}

	if (m_pNextInfo != NULL)
	{
		delete m_pNextInfo;
		m_pNextInfo = NULL;
	}

	if (m_hContext != NULL)
	{
		if (m_hContext != INVALID_HANDLE_VALUE)
			CloseContext();
		m_hContext = NULL;
	}
}

void CFileFind::CloseContext()
{
	::FindClose(m_hContext);
	return;
}

BOOL CFileFind::FindFile(LPCTSTR pstrName /* = NULL */,
	DWORD dwUnused /* = 0 */)
{
	UNUSED_ALWAYS(dwUnused);
	Close();

	if (pstrName == NULL)
		pstrName = _T("*.*");
	else if (lstrlen(pstrName) >= (_countof(((WIN32_FIND_DATA*) m_pNextInfo)->cFileName)))
	{
		::SetLastError(ERROR_BAD_ARGUMENTS);
		return FALSE;		
	}
	
	m_pNextInfo = new WIN32_FIND_DATA;

	WIN32_FIND_DATA *pFindData = (WIN32_FIND_DATA *)m_pNextInfo;

	Checked::tcscpy_s(pFindData->cFileName, _countof(pFindData->cFileName), pstrName);

	m_hContext = m_pTM != NULL ?
		m_pTM->FindFirstFile(pstrName, (WIN32_FIND_DATA*) m_pNextInfo) :
		::FindFirstFile(pstrName, (WIN32_FIND_DATA*) m_pNextInfo);

	if (m_hContext == INVALID_HANDLE_VALUE)
	{
		DWORD dwTemp = ::GetLastError();
		Close();
		::SetLastError(dwTemp);
		return FALSE;
	}

	LPTSTR pstrRoot = m_strRoot.GetBufferSetLength(_MAX_PATH);
	LPCTSTR pstr = _tfullpath(pstrRoot, pstrName, _MAX_PATH);

	// passed name isn't a valid path but was found by the API
	ASSERT(pstr != NULL);
	if (pstr == NULL)
	{
		m_strRoot.ReleaseBuffer(0);
		Close();
		::SetLastError(ERROR_INVALID_NAME);
		return FALSE;
	}
	else
	{
		TCHAR strDrive[_MAX_DRIVE], strDir[_MAX_DIR];
		Checked::tsplitpath_s(pstrRoot, strDrive, _MAX_DRIVE, strDir, _MAX_DIR, NULL, 0, NULL, 0);
		Checked::tmakepath_s(pstrRoot, _MAX_PATH, strDrive, strDir, NULL, NULL);
		m_strRoot.ReleaseBuffer(-1);
	}
	return TRUE;
}

BOOL CFileFind::MatchesMask(DWORD dwMask) const
{
	ASSERT(m_hContext != NULL);
	ASSERT_VALID(this);

	if (m_pFoundInfo != NULL)
		return (!!(((LPWIN32_FIND_DATA) m_pFoundInfo)->dwFileAttributes & dwMask));
	else
		return FALSE;
}

BOOL CFileFind::GetLastAccessTime(FILETIME* pTimeStamp) const
{
	ASSERT(m_hContext != NULL);
	ASSERT(pTimeStamp != NULL);
	ASSERT_VALID(this);

	if (m_pFoundInfo != NULL && pTimeStamp != NULL)
	{
		*pTimeStamp = ((LPWIN32_FIND_DATA) m_pFoundInfo)->ftLastAccessTime;
		return TRUE;
	}
	else
		return FALSE;
}

BOOL CFileFind::GetLastWriteTime(FILETIME* pTimeStamp) const
{
	ASSERT(m_hContext != NULL);
	ASSERT(pTimeStamp != NULL);
	ASSERT_VALID(this);

	if (m_pFoundInfo != NULL && pTimeStamp != NULL)
	{
		*pTimeStamp = ((LPWIN32_FIND_DATA) m_pFoundInfo)->ftLastWriteTime;
		return TRUE;
	}
	else
		return FALSE;
}

BOOL CFileFind::GetCreationTime(FILETIME* pTimeStamp) const
{
	ASSERT(m_hContext != NULL);
	ASSERT_VALID(this);

	if (m_pFoundInfo != NULL && pTimeStamp != NULL)
	{
		*pTimeStamp = ((LPWIN32_FIND_DATA) m_pFoundInfo)->ftCreationTime;
		return TRUE;
	}
	else
		return FALSE;
}

BOOL CFileFind::GetLastAccessTime(CTime& refTime) const
{
	ASSERT(m_hContext != NULL);
	ASSERT_VALID(this);

	if (m_pFoundInfo != NULL)
	{
		if (CTime::IsValidFILETIME(((LPWIN32_FIND_DATA) m_pFoundInfo)->ftLastAccessTime))
		{
			refTime = CTime(((LPWIN32_FIND_DATA) m_pFoundInfo)->ftLastAccessTime);
		}
		else
		{
			refTime = CTime();
		}
		return TRUE;
	}
	else
		return FALSE;
}

BOOL CFileFind::GetLastWriteTime(CTime& refTime) const
{
	ASSERT(m_hContext != NULL);
	ASSERT_VALID(this);

	if (m_pFoundInfo != NULL)
	{
		if (CTime::IsValidFILETIME(((LPWIN32_FIND_DATA) m_pFoundInfo)->ftLastWriteTime))
		{
			refTime = CTime(((LPWIN32_FIND_DATA) m_pFoundInfo)->ftLastWriteTime);
		}
		else
		{
			refTime = CTime();
		}
		return TRUE;
	}
	else
		return FALSE;
}

BOOL CFileFind::GetCreationTime(CTime& refTime) const
{
	ASSERT(m_hContext != NULL);
	ASSERT_VALID(this);

	if (m_pFoundInfo != NULL)
	{
		if (CTime::IsValidFILETIME(((LPWIN32_FIND_DATA) m_pFoundInfo)->ftCreationTime))
		{
			refTime = CTime(((LPWIN32_FIND_DATA) m_pFoundInfo)->ftCreationTime);
		}
		else
		{
			refTime = CTime();
		}
		return TRUE;
	}
	else
		return FALSE;
}

BOOL CFileFind::IsDots() const
{
	ASSERT(m_hContext != NULL);
	ASSERT_VALID(this);

	// return TRUE if the file name is "." or ".." and
	// the file is a directory

	BOOL bResult = FALSE;
	if (m_pFoundInfo != NULL && IsDirectory())
	{
		LPWIN32_FIND_DATA pFindData = (LPWIN32_FIND_DATA) m_pFoundInfo;
		if (pFindData->cFileName[0] == '.')
		{
			if (pFindData->cFileName[1] == '\0' ||
				(pFindData->cFileName[1] == '.' &&
				 pFindData->cFileName[2] == '\0'))
			{
				bResult = TRUE;
			}
		}
	}

	return bResult;
}

BOOL CFileFind::FindNextFile()
{
	ASSERT(m_hContext != NULL);

	if (m_hContext == NULL)
		return FALSE;
	if (m_pFoundInfo == NULL)
		m_pFoundInfo = new WIN32_FIND_DATA;

	ASSERT_VALID(this);

	void* pTemp = m_pFoundInfo;
	m_pFoundInfo = m_pNextInfo;
	m_pNextInfo = pTemp;

	return ::FindNextFile(m_hContext, (LPWIN32_FIND_DATA) m_pNextInfo);
}

CString CFileFind::GetFileURL() const
{
	ASSERT(m_hContext != NULL);
	ASSERT_VALID(this);

	CString strResult("file://");
	strResult += GetFilePath();
	return strResult;
}

CString CFileFind::GetRoot() const
{
	ASSERT(m_hContext != NULL);
	ASSERT_VALID(this);

	return m_strRoot;
}

CString CFileFind::GetFilePath() const
{
	ASSERT(m_hContext != NULL);
	ASSERT_VALID(this);

	CString strResult = m_strRoot;
	LPCTSTR pszResult;
	LPCTSTR pchLast;
	pszResult = strResult;
	pchLast = _tcsdec( pszResult, pszResult+strResult.GetLength() );
    ENSURE(pchLast!=NULL);
	if ((*pchLast != _T('\\')) && (*pchLast != _T('/')))
		strResult += m_chDirSeparator;
	strResult += GetFileName();
	return strResult;
}

CString CFileFind::GetFileTitle() const
{
	ASSERT(m_hContext != NULL);
	ASSERT_VALID(this);

	CString strFullName = GetFileName();
	CString strResult;

	Checked::tsplitpath_s(strFullName, NULL, 0, NULL, 0, 
		strResult.GetBuffer(_MAX_FNAME), _MAX_FNAME, NULL, 0);

	strResult.ReleaseBuffer();
	return strResult;
}

CString CFileFind::GetFileName() const
{
	ASSERT(m_hContext != NULL);
	ASSERT_VALID(this);

	CString ret;

	if (m_pFoundInfo != NULL)
		ret = ((LPWIN32_FIND_DATA) m_pFoundInfo)->cFileName;
	return ret;
}

ULONGLONG CFileFind::GetLength() const
{
	ASSERT(m_hContext != NULL);
	ASSERT_VALID(this);

   ULARGE_INTEGER nFileSize;

	if (m_pFoundInfo != NULL)
   {
	  nFileSize.LowPart = ((LPWIN32_FIND_DATA) m_pFoundInfo)->nFileSizeLow;
	  nFileSize.HighPart = ((LPWIN32_FIND_DATA) m_pFoundInfo)->nFileSizeHigh;
   }
   else
   {
	  nFileSize.QuadPart = 0;
   }

   return nFileSize.QuadPart;
}

#ifdef _DEBUG
void CFileFind::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);
	dc << "\nm_hContext = " << (void*) m_hContext;
}

void CFileFind::AssertValid() const
{
	// if you trip the ASSERT in the else side, you've called
	// a Get() function without having done at least one
	// FindNext() call

	if (m_hContext == NULL)
		ASSERT(m_pFoundInfo == NULL && m_pNextInfo == NULL);
	else
		ASSERT(m_pFoundInfo != NULL && m_pNextInfo != NULL);

}
#endif


IMPLEMENT_DYNAMIC(CFileFind, CObject)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\fileshrd.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

////////////////////////////////////////////////////////////////////////////
// CSharedFile implementation

CSharedFile::CSharedFile(UINT nAllocFlags, UINT nGrowBytes)
	: CMemFile(nGrowBytes)
{
	m_nAllocFlags = nAllocFlags;
	m_hGlobalMemory = NULL;
	m_bAllowGrow = TRUE;
}

CSharedFile::~CSharedFile()
{
	if (m_lpBuffer)
		Close();        // call appropriate Close/Free
	ASSERT(m_lpBuffer == NULL);
}

void CSharedFile::SetHandle(HGLOBAL hGlobalMemory, BOOL bAllowGrow)
{
	ASSERT(m_hGlobalMemory == NULL);        // do once only
	ASSERT(m_lpBuffer == NULL);     // do once only
	ASSERT(m_nPosition == 0);

	if (hGlobalMemory == NULL) 
	{
		AfxThrowInvalidArgException();
	}

	m_hGlobalMemory = hGlobalMemory;
	m_lpBuffer = (BYTE*)::GlobalLock(m_hGlobalMemory);
	m_nBufferSize = m_nFileSize = (ULONG)::GlobalSize(m_hGlobalMemory);
	m_bAllowGrow = bAllowGrow;
}

BYTE* CSharedFile::Alloc(SIZE_T nBytes)
{
	ASSERT(m_hGlobalMemory == NULL);        // do once only
	m_hGlobalMemory = ::GlobalAlloc(m_nAllocFlags, nBytes);
	if (m_hGlobalMemory == NULL)
		return NULL;
	return (BYTE*)::GlobalLock(m_hGlobalMemory);
}

BYTE* CSharedFile::Realloc(BYTE*, SIZE_T nBytes)
{
	if (!m_bAllowGrow)
		return NULL;
	ASSERT(m_hGlobalMemory != NULL);

	::GlobalUnlock(m_hGlobalMemory);
	HGLOBAL hNew;
	hNew = ::GlobalReAlloc(m_hGlobalMemory, nBytes, m_nAllocFlags);
	if (hNew == NULL)
		return NULL;
	m_hGlobalMemory = hNew;
	return (BYTE*)::GlobalLock(m_hGlobalMemory);
}

void CSharedFile::Free(BYTE*)
{
	ASSERT(m_hGlobalMemory != NULL);
	::GlobalUnlock(m_hGlobalMemory);
	::GlobalFree(m_hGlobalMemory);
}

HGLOBAL CSharedFile::Detach()
{
	HGLOBAL hMem;
	ASSERT(m_hGlobalMemory != NULL);
	hMem = m_hGlobalMemory;

	::GlobalUnlock(m_hGlobalMemory);
	m_hGlobalMemory = NULL; // detach from global handle

	// re-initialize the CMemFile parts too
	m_lpBuffer = NULL;
	m_nBufferSize = 0;

	return hMem;
}


IMPLEMENT_DYNAMIC(CSharedFile, CMemFile)

////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\filelist.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "sal.h"

#if (WINVER >= 0x0601)
#include <ShlObj.h>
#endif

#include <AtlConv.h>
#include "afxglobals.h"

/////////////////////////////////////////////////////////////////////////////
// lpszCanon = C:\MYAPP\DEBUGS\C\TESWIN.C
//
// cchMax   b   Result
// ------   -   ---------
//  1- 7    F   <empty>
//  1- 7    T   TESWIN.C
//  8-14    x   TESWIN.C
// 15-16    x   C:\...\TESWIN.C
// 17-23    x   C:\...\C\TESWIN.C
// 24-25    x   C:\...\DEBUGS\C\TESWIN.C
// 26+      x   C:\MYAPP\DEBUGS\C\TESWIN.C

AFX_STATIC void AFXAPI _AfxAbbreviateName(_Inout_z_ LPTSTR lpszCanon, int cchMax, BOOL bAtLeastName)
{
	ENSURE_ARG(AfxIsValidString(lpszCanon));

	int cchFullPath, cchFileName, cchVolName;
	const TCHAR* lpszCur;
	const TCHAR* lpszBase;
	const TCHAR* lpszFileName;

	lpszBase = lpszCanon;
	cchFullPath = lstrlen(lpszCanon);

	cchFileName = AfxGetFileName(lpszCanon, NULL, 0) - 1;
	lpszFileName = lpszBase + (cchFullPath-cchFileName);

	// If cchMax is more than enough to hold the full path name, we're done.
	// This is probably a pretty common case, so we'll put it first.
	if (cchMax >= cchFullPath)
		return;

	// If cchMax isn't enough to hold at least the basename, we're done
	if (cchMax < cchFileName)
	{
		if (!bAtLeastName)
			lpszCanon[0] = _T('\0');
		else
			Checked::tcscpy_s(lpszCanon, cchFullPath + 1, lpszFileName);
		return;
	}

	// Calculate the length of the volume name.  Normally, this is two characters
	// (e.g., "C:", "D:", etc.), but for a UNC name, it could be more (e.g.,
	// "\\server\share").
	//
	// If cchMax isn't enough to hold at least <volume_name>\...\<base_name>, the
	// result is the base filename.

	lpszCur = lpszBase + 2;                 // Skip "C:" or leading "\\"

	if (lpszBase[0] == '\\' && lpszBase[1] == '\\') // UNC pathname
	{
		// First skip to the '\' between the server name and the share name,
		while (*lpszCur != '\\')
		{
			lpszCur = _tcsinc(lpszCur);
			ASSERT(*lpszCur != '\0');
		}
	}
	// if a UNC get the share name, if a drive get at least one directory
	ASSERT(*lpszCur == '\\');
	// make sure there is another directory, not just c:\filename.ext
	if (cchFullPath - cchFileName > 3)
	{
		lpszCur = _tcsinc(lpszCur);
		while (*lpszCur != '\\')
		{
			lpszCur = _tcsinc(lpszCur);
			ASSERT(*lpszCur != '\0');
		}
	}
	ASSERT(*lpszCur == '\\');

	cchVolName = int(lpszCur - lpszBase);
	if (cchMax < cchVolName + 5 + cchFileName)
	{
		Checked::tcscpy_s(lpszCanon, cchFullPath + 1, lpszFileName);
		return;
	}

	// Now loop through the remaining directory components until something
	// of the form <volume_name>\...\<one_or_more_dirs>\<base_name> fits.
	//
	// Assert that the whole filename doesn't fit -- this should have been
	// handled earlier.

	ASSERT(cchVolName + (int)lstrlen(lpszCur) > cchMax);
	while (cchVolName + 4 + (int)lstrlen(lpszCur) > cchMax)
	{
		do
		{
			lpszCur = _tcsinc(lpszCur);
			ASSERT(*lpszCur != '\0');
		}
		while (*lpszCur != '\\');
	}

	// Form the resultant string and we're done.
	int cch;
	if (cchVolName >= 0 && cchVolName < cchMax)
		cch = cchVolName;
	else cch = cchMax;
	Checked::memcpy_s(lpszCanon + cch, cchFullPath + 1 - cch, _T("\\..."), sizeof(_T("\\...")) );
	Checked::tcscat_s(lpszCanon, cchFullPath + 1, lpszCur);
}

/////////////////////////////////////////////////////////////////////////////
// CRecentFileList

#pragma warning(disable: 4267)
CRecentFileList::CRecentFileList(UINT nStart, LPCTSTR lpszSection,
	LPCTSTR lpszEntryFormat, int nSize, int nMaxDispLen)
{
	ENSURE_ARG(nSize >= 0);
	m_arrNames = new CString[nSize];
	ENSURE_ARG(m_arrNames != NULL);
	
	m_nSize = nSize;
	m_nStart = nStart;
	
	m_strSectionName = lpszSection;
	m_strEntryFormat = lpszEntryFormat;
	
	m_nMaxDisplayLength = nMaxDispLen;
}

CRecentFileList::~CRecentFileList()
{
	delete[] m_arrNames;
}

// Operations
void CRecentFileList::Add(LPCTSTR lpszPathName)
{
	ASSERT(m_arrNames != NULL);
	ASSERT(AfxIsValidString(lpszPathName));

	// fully qualify the path name
	TCHAR szTemp[_MAX_PATH];
	if ( lpszPathName == NULL || lstrlen(lpszPathName) >= _MAX_PATH )
	{
		ASSERT(FALSE);
		// MFC requires paths with length < _MAX_PATH
		// No other way to handle the error from a void function
		AfxThrowFileException(CFileException::badPath);
	}

	AfxFullPath(szTemp, lpszPathName);
	
	// update the MRU list, if an existing MRU string matches file name
	int iMRU;
	for (iMRU = 0; iMRU < m_nSize-1; iMRU++)
	{
		if (AfxComparePath(m_arrNames[iMRU], szTemp))
			break;      // iMRU will point to matching entry
	}
	// move MRU strings before this one down
	for (; iMRU > 0; iMRU--)
	{
		ASSERT(iMRU > 0);
		ASSERT(iMRU < m_nSize);
		m_arrNames[iMRU] = m_arrNames[iMRU-1];
	}
	// place this one at the beginning
	m_arrNames[0] = szTemp;

	// any addition to the MRU should also be added to recent docs
#ifdef UNICODE
	SHAddToRecentDocs(SHARD_PATHW, lpszPathName);
#else
	SHAddToRecentDocs(SHARD_PATHA, lpszPathName);
#endif
}

void CRecentFileList::Add(LPCTSTR lpszPathName, LPCTSTR lpszAppID)
{
	if (!afxGlobalData.bIsWindows7)
	{
		Add(lpszPathName);
		return;
	}

	CString strAppID = lpszAppID == NULL ? _T("") : lpszAppID;

#if (WINVER >= 0x0601)
	ASSERT(AfxIsValidString(lpszPathName));

	Add(lpszPathName);

	HRESULT hr = S_OK;
	CComPtr<IShellItem> psi = NULL;

#ifdef UNICODE
	hr = afxGlobalData.ShellCreateItemFromParsingName(lpszPathName, NULL, IID_IShellItem, reinterpret_cast<void**>(&psi));
#else
	{
		USES_CONVERSION;
		LPOLESTR lpWPath = A2W(lpszPathName);
		hr = afxGlobalData.ShellCreateItemFromParsingName(lpWPath, NULL, IID_IShellItem, (LPVOID*)&psi);
	}
#endif

	ENSURE(SUCCEEDED(hr));

	Add(psi, strAppID);
#endif
}
void CRecentFileList::Add(IShellItem* pItem, LPCTSTR lpszAppID)
{
	if (!afxGlobalData.bIsWindows7)
	{
		return;
	}

	ASSERT(pItem != NULL);

	if (pItem == NULL)
	{
		return;
	}

	CString strAppID = lpszAppID == NULL ? _T("") : lpszAppID;

#if (WINVER >= 0x0601)
	SHARDAPPIDINFO info;

#ifdef UNICODE
	info.pszAppID = strAppID;
#else
	{
		USES_CONVERSION;
		info.pszAppID = A2W(strAppID);
	}
#endif

	info.psi = pItem;
	SHAddToRecentDocs(SHARD_APPIDINFO, &info);
#endif
}

void CRecentFileList::Add(IShellLink* pLink, LPCTSTR lpszAppID)
{
	if (!afxGlobalData.bIsWindows7)
	{
		return;
	}

	ASSERT(pLink != NULL);

	if (pLink == NULL)
	{
		return;
	}

	CString strAppID = lpszAppID == NULL ? _T("") : lpszAppID;

#if (WINVER >= 0x0601)
	SHARDAPPIDINFOLINK info;

#ifdef UNICODE
	info.pszAppID = strAppID;
#else
	{
		USES_CONVERSION;
		info.pszAppID = A2W(strAppID);
	}
#endif

	info.psl = pLink;
	if (strAppID.GetLength() == 0)
		SHAddToRecentDocs(SHARD_LINK, &info);
	else
		SHAddToRecentDocs(SHARD_APPIDINFOLINK, &info);
#endif
}

void CRecentFileList::Add(PIDLIST_ABSOLUTE pidl, LPCTSTR lpszAppID)
{
	if (!afxGlobalData.bIsWindows7)
	{
		return;
	}

	CString strAppID = lpszAppID == NULL ? _T("") : lpszAppID;

#if (WINVER >= 0x0601)
	SHARDAPPIDINFOIDLIST info;

#ifdef UNICODE
	info.pszAppID = strAppID;
#else
	{
		USES_CONVERSION;
		info.pszAppID = A2W(strAppID);
	}
#endif

	info.pidl = pidl;
	SHAddToRecentDocs(SHARD_APPIDINFOIDLIST, &info);
#endif

}

void CRecentFileList::Remove(int nIndex)
{
	ENSURE_ARG(nIndex >= 0 && nIndex < m_nSize);

	m_arrNames[nIndex].Empty();
	int iMRU;
	for (iMRU = nIndex; iMRU < m_nSize-1; iMRU++)
		m_arrNames[iMRU] = m_arrNames[iMRU+1];

	ASSERT(iMRU < m_nSize);
	m_arrNames[iMRU].Empty();
}

BOOL CRecentFileList::GetDisplayName(CString& strName, int nIndex,
	LPCTSTR lpszCurDir, int nCurDir, BOOL bAtLeastName) const
{
	ENSURE_ARG(lpszCurDir == NULL || AfxIsValidString(lpszCurDir, nCurDir));

	ASSERT(m_arrNames != NULL);
	ENSURE_ARG(nIndex < m_nSize);
	if (lpszCurDir == NULL || m_arrNames[nIndex].IsEmpty())
		return FALSE;

	int nLenName = m_arrNames[nIndex].GetLength();
	LPTSTR lpch = strName.GetBuffer( nLenName + 1);
	if (lpch == NULL)
	{
		AfxThrowMemoryException();
	}
	Checked::tcsncpy_s(lpch, nLenName + 1, m_arrNames[nIndex], _TRUNCATE);
	// nLenDir is the length of the directory part of the full path
	int nLenDir = nLenName - (AfxGetFileName(lpch, NULL, 0) - 1);
	BOOL bSameDir = FALSE;
	if (nLenDir == nCurDir)
	{
		TCHAR chSave = lpch[nLenDir];
		lpch[nCurDir] = 0;  // terminate at same location as current dir
		bSameDir = ::AfxComparePath(lpszCurDir, lpch);
		lpch[nLenDir] = chSave;
	}
	// copy the full path, otherwise abbreviate the name
	if (bSameDir)
	{
		// copy file name only since directories are same
		TCHAR szTemp[_MAX_PATH];
		AfxGetFileTitle(lpch+nCurDir, szTemp, _countof(szTemp));
		Checked::tcsncpy_s(lpch, nLenName + 1, szTemp, _TRUNCATE);
	}
	else if (m_nMaxDisplayLength != -1)
	{
		// strip the extension if the system calls for it
		TCHAR szTemp[_MAX_PATH];
		AfxGetFileTitle(lpch+nLenDir, szTemp, _countof(szTemp));
		Checked::tcsncpy_s(lpch+nLenDir, nLenName + 1 - nLenDir, szTemp, _TRUNCATE);

		// abbreviate name based on what will fit in limited space
		_AfxAbbreviateName(lpch, m_nMaxDisplayLength, bAtLeastName);
	}
	strName.ReleaseBuffer();
	return TRUE;
}

void CRecentFileList::UpdateMenu(CCmdUI* pCmdUI)
{
	ENSURE_ARG(pCmdUI != NULL);
	ASSERT(m_arrNames != NULL);

	CMenu* pMenu = pCmdUI->m_pMenu;
	if (m_strOriginal.IsEmpty() && pMenu != NULL)
		pMenu->GetMenuString(pCmdUI->m_nID, m_strOriginal, MF_BYCOMMAND);

	if (m_arrNames[0].IsEmpty())
	{
		// no MRU files
		if (!m_strOriginal.IsEmpty())
			pCmdUI->SetText(m_strOriginal);
		pCmdUI->Enable(FALSE);
		return;
	}

	if (pCmdUI->m_pMenu == NULL)
		return;

	int iMRU;
	for (iMRU = 0; iMRU < m_nSize; iMRU++)
		pCmdUI->m_pMenu->DeleteMenu(pCmdUI->m_nID + iMRU, MF_BYCOMMAND);

	TCHAR szCurDir[_MAX_PATH];
	DWORD dwDirLen = GetCurrentDirectory(_MAX_PATH, szCurDir);
	if( dwDirLen == 0 || dwDirLen >= _MAX_PATH )
		return;	// Path too long

	int nCurDir = lstrlen(szCurDir);
	ASSERT(nCurDir >= 0);
	szCurDir[nCurDir] = '\\';
	szCurDir[++nCurDir] = '\0';

	CString strName;
	CString strTemp;
	for (iMRU = 0; iMRU < m_nSize; iMRU++)
	{
		if (!GetDisplayName(strName, iMRU, szCurDir, nCurDir))
			break;

		// double up any '&' characters so they are not underlined
		LPCTSTR lpszSrc = strName;
		LPTSTR lpszDest = strTemp.GetBuffer(strName.GetLength()*2);
		while (*lpszSrc != 0)
		{
			if (*lpszSrc == '&')
				*lpszDest++ = '&';
			if (_istlead(*lpszSrc))
				*lpszDest++ = *lpszSrc++;
			*lpszDest++ = *lpszSrc++;
		}
		*lpszDest = 0;
		strTemp.ReleaseBuffer();

		// insert mnemonic + the file name
		TCHAR buf[10];
		int nItem = ((iMRU + m_nStart) % _AFX_MRU_MAX_COUNT) + 1;


		// number &1 thru &9, then 1&0, then 11 thru ...
		if (nItem > 10)
			_stprintf_s(buf, _countof(buf), _T("%d "), nItem);
		else if (nItem == 10)
			Checked::tcscpy_s(buf, _countof(buf), _T("1&0 "));
		else
			_stprintf_s(buf, _countof(buf), _T("&%d "), nItem);

		pCmdUI->m_pMenu->InsertMenu(pCmdUI->m_nIndex++,
			MF_STRING | MF_BYPOSITION, pCmdUI->m_nID++,
			CString(buf) + strTemp);
	}

	// update end menu count
	pCmdUI->m_nIndex--; // point to last menu added
	pCmdUI->m_nIndexMax = pCmdUI->m_pMenu->GetMenuItemCount();

	pCmdUI->m_bEnableChanged = TRUE;    // all the added items are enabled
}

void CRecentFileList::WriteList()
{
	ASSERT(m_arrNames != NULL);
	ASSERT(!m_strSectionName.IsEmpty());
	ASSERT(!m_strEntryFormat.IsEmpty());
	int nLen = m_strEntryFormat.GetLength() + 10;
	LPTSTR pszEntry = new TCHAR[nLen];
	CWinApp* pApp = AfxGetApp();
	pApp->WriteProfileString(m_strSectionName, NULL, NULL);
	for (int iMRU = 0; iMRU < m_nSize; iMRU++)
	{
		_stprintf_s(pszEntry, nLen, m_strEntryFormat, iMRU + 1);
		if (!m_arrNames[iMRU].IsEmpty())
		{
			pApp->WriteProfileString(m_strSectionName, pszEntry,
				m_arrNames[iMRU]);
		}
	}
	delete[] pszEntry;
}

void CRecentFileList::ReadList()
{
	ASSERT(m_arrNames != NULL);
	ASSERT(!m_strSectionName.IsEmpty());
	ASSERT(!m_strEntryFormat.IsEmpty());
	int nLen = m_strEntryFormat.GetLength() + 10;
	LPTSTR pszEntry = new TCHAR[nLen];
	CWinApp* pApp = AfxGetApp();
	for (int iMRU = 0; iMRU < m_nSize; iMRU++)
	{
		_stprintf_s(pszEntry, nLen, m_strEntryFormat, iMRU + 1);
		m_arrNames[iMRU] = pApp->GetProfileString(
			m_strSectionName, pszEntry, _T(""));
	}
	delete[] pszEntry;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\filemem.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

////////////////////////////////////////////////////////////////////////////
// CMemFile implementation

CMemFile::CMemFile(UINT nGrowBytes)
{
	ASSERT(nGrowBytes <= UINT_MAX);

	m_nGrowBytes = nGrowBytes;
	m_nPosition = 0;
	m_nBufferSize = 0;
	m_nFileSize = 0;
	m_lpBuffer = NULL;
	m_bAutoDelete = TRUE;
}

CMemFile::CMemFile(BYTE* lpBuffer, UINT nBufferSize, UINT nGrowBytes)
{
	if (lpBuffer == NULL && nBufferSize != 0) 
	{
		AfxThrowInvalidArgException();
	}

	ASSERT(nGrowBytes <= UINT_MAX);

	m_nGrowBytes = nGrowBytes;
	m_nPosition = 0;
	m_nBufferSize = nBufferSize;
	m_nFileSize = nGrowBytes == 0 ? nBufferSize : 0;
	m_lpBuffer = lpBuffer;
	m_bAutoDelete = FALSE;
}

void CMemFile::Attach(BYTE* lpBuffer, UINT nBufferSize, UINT nGrowBytes) 
{
	if (lpBuffer == NULL && nBufferSize != 0) 
	{
		AfxThrowInvalidArgException();
	}
	
	ASSERT(m_lpBuffer == NULL);

	m_nGrowBytes = nGrowBytes;
	m_nPosition = 0;
	m_nBufferSize = nBufferSize;
	m_nFileSize = nGrowBytes == 0 ? nBufferSize : 0;
	m_lpBuffer = lpBuffer;
	m_bAutoDelete = FALSE;
}

BYTE* CMemFile::Detach()
{
	BYTE* lpBuffer = m_lpBuffer;
	m_lpBuffer = NULL;
	m_nFileSize = 0;
	m_nBufferSize = 0;
	m_nPosition = 0;

	return lpBuffer;
}

CMemFile::~CMemFile()
{
	// Close should have already been called, but we check anyway
	if (m_lpBuffer)
		Close();
	ASSERT(m_lpBuffer == NULL);

	m_nGrowBytes = 0;
	m_nPosition = 0;
	m_nBufferSize = 0;
	m_nFileSize = 0;
}

BYTE* CMemFile::Alloc(SIZE_T nBytes)
{
	return (BYTE*)malloc(nBytes);
}

BYTE* CMemFile::Realloc(BYTE* lpMem, SIZE_T nBytes)
{
	ASSERT(nBytes > 0);	// nBytes == 0 means free		
	return (BYTE*)realloc(lpMem, nBytes);
}

BYTE* CMemFile::Memcpy(BYTE* lpMemTarget, const BYTE* lpMemSource,
	SIZE_T nBytes)
{
	ASSERT(lpMemTarget != NULL);
	ASSERT(lpMemSource != NULL);

	ASSERT(AfxIsValidAddress(lpMemTarget, nBytes));
	ASSERT(AfxIsValidAddress(lpMemSource, nBytes, FALSE));

	Checked::memcpy_s(lpMemTarget, nBytes, lpMemSource, nBytes);
	return lpMemTarget;
}

void CMemFile::Free(BYTE* lpMem)
{
	ASSERT(lpMem != NULL);

	free(lpMem);
}

ULONGLONG CMemFile::GetPosition() const
{
	ASSERT_VALID(this);
	return m_nPosition;
}

void CMemFile::GrowFile(SIZE_T dwNewLen)
{
	ASSERT_VALID(this);

	if (dwNewLen > m_nBufferSize)
	{
		// grow the buffer
		SIZE_T dwNewBufferSize = m_nBufferSize;

		// watch out for buffers which cannot be grown!
		ASSERT(m_nGrowBytes != 0);
		if (m_nGrowBytes == 0)
			AfxThrowMemoryException();

		// determine new buffer size
		while (dwNewBufferSize < dwNewLen)
			dwNewBufferSize += m_nGrowBytes;

		// allocate new buffer
		BYTE* lpNew;
		if (m_lpBuffer == NULL)
			lpNew = Alloc(dwNewBufferSize);
		else
			lpNew = Realloc(m_lpBuffer, dwNewBufferSize);

		if (lpNew == NULL)
			AfxThrowMemoryException();

		m_lpBuffer = lpNew;
		m_nBufferSize = dwNewBufferSize;
	}
	ASSERT_VALID(this);
}

ULONGLONG CMemFile::GetLength() const
{
   ASSERT_VALID(this);

   return m_nFileSize;
}

void CMemFile::SetLength(ULONGLONG dwNewLen)
{
	ASSERT_VALID(this);

#ifdef WIN32
   if (dwNewLen > ULONG_MAX)
	  AfxThrowMemoryException();
#endif  // WIN32
	if (dwNewLen > m_nBufferSize)
		GrowFile((SIZE_T)dwNewLen);

	if (dwNewLen < m_nPosition)
		m_nPosition = (SIZE_T)dwNewLen;

	m_nFileSize = (SIZE_T)dwNewLen;
	ASSERT_VALID(this);
}

UINT CMemFile::Read(void* lpBuf, UINT nCount)
{
	ASSERT_VALID(this);

	if (nCount == 0)
		return 0;

	ASSERT(lpBuf != NULL);

	if (lpBuf == NULL) 
	{
		AfxThrowInvalidArgException();
	}

	ASSERT(AfxIsValidAddress(lpBuf, nCount));

	if (m_nPosition > m_nFileSize)
		return 0;

	UINT nRead;
	if (m_nPosition + nCount > m_nFileSize || m_nPosition + nCount < m_nPosition)
		nRead = (UINT)(m_nFileSize - m_nPosition);
	else
		nRead = nCount;

	Memcpy((BYTE*)lpBuf, (BYTE*)m_lpBuffer + m_nPosition, nRead);
	m_nPosition += nRead;

	ASSERT_VALID(this);

	return nRead;
}

void CMemFile::Write(const void* lpBuf, UINT nCount)
{
	ASSERT_VALID(this);

	if (nCount == 0)
		return;

	ASSERT(lpBuf != NULL);
	ASSERT(AfxIsValidAddress(lpBuf, nCount, FALSE));

	if (lpBuf == NULL) 
	{
		AfxThrowInvalidArgException();
	}
	//If we have no room for nCount, it must be an overflow
	if (m_nPosition + nCount < m_nPosition)
	{
		AfxThrowInvalidArgException();
	}

	if (m_nPosition + nCount > m_nBufferSize)
		GrowFile(m_nPosition + nCount);

	ENSURE(m_nPosition + nCount <= m_nBufferSize);

	Memcpy((BYTE*)m_lpBuffer + m_nPosition, (BYTE*)lpBuf, nCount);

	m_nPosition += nCount;

	if (m_nPosition > m_nFileSize)
		m_nFileSize = m_nPosition;

	ASSERT_VALID(this);
}

ULONGLONG CMemFile::Seek(LONGLONG lOff, UINT nFrom)
{
	ASSERT_VALID(this);
	ASSERT(nFrom == begin || nFrom == end || nFrom == current);

	LONGLONG lNewPos = m_nPosition;

	if (nFrom == begin)
		lNewPos = lOff;
	else if (nFrom == current)
		lNewPos += lOff;
	else if (nFrom == end) {
		if (lOff > 0) 
		{
			AfxThrowFileException(CFileException::badSeek);// offsets must be negative when seeking from the end
		}
		lNewPos = m_nFileSize + lOff;	
	} else
		return m_nPosition;

	if (lNewPos < 0)
		AfxThrowFileException(CFileException::badSeek);
	if (static_cast<DWORD>(lNewPos) > m_nFileSize)
		GrowFile((SIZE_T)lNewPos);

	m_nPosition = (SIZE_T)lNewPos;

	ASSERT_VALID(this);
	return m_nPosition;
}

void CMemFile::Flush()
{
	ASSERT_VALID(this);
}

void CMemFile::Close()
{
	ASSERT((m_lpBuffer == NULL && m_nBufferSize == 0) ||
		!m_bAutoDelete || AfxIsValidAddress(m_lpBuffer, (UINT)m_nBufferSize, FALSE));
	ASSERT(m_nFileSize <= m_nBufferSize);

	m_nGrowBytes = 0;
	m_nPosition = 0;
	m_nBufferSize = 0;
	m_nFileSize = 0;
	if (m_lpBuffer && m_bAutoDelete)
		Free(m_lpBuffer);
	m_lpBuffer = NULL;
}

void CMemFile::Abort()
{
	ASSERT_VALID(this);

	Close();
}

void CMemFile::LockRange(ULONGLONG /* dwPos */, ULONGLONG /* dwCount */)
{
	ASSERT_VALID(this);
	AfxThrowNotSupportedException();
}


void CMemFile::UnlockRange(ULONGLONG /* dwPos */, ULONGLONG /* dwCount */)
{
	ASSERT_VALID(this);
	AfxThrowNotSupportedException();
}

CFile* CMemFile::Duplicate() const
{
	ASSERT_VALID(this);
	AfxThrowNotSupportedException();
}

// only CMemFile supports "direct buffering" interaction with CArchive
UINT CMemFile::GetBufferPtr(UINT nCommand, UINT nCount,
	void** ppBufStart, void**ppBufMax)
{
	ASSERT(nCommand == bufferCheck || nCommand == bufferCommit ||
		nCommand == bufferRead || nCommand == bufferWrite);



	if (nCommand == bufferCheck)
	{
		// only allow direct buffering if we're 
		// growable
		if (m_nGrowBytes > 0)
			return bufferDirect;
		else
			return 0;
	}

	if (nCommand == bufferCommit)
	{
		// commit buffer
		ASSERT(ppBufStart == NULL);
		ASSERT(ppBufMax == NULL);
		m_nPosition += nCount;
		if (m_nPosition > m_nFileSize)
			m_nFileSize = m_nPosition;
		return 0;
	}


	ASSERT(nCommand == bufferWrite || nCommand == bufferRead);
	ASSERT(ppBufStart != NULL);
	ASSERT(ppBufMax != NULL);

	if (ppBufStart == NULL || ppBufMax == NULL) 
	{
		return 0;
	}

	// when storing, grow file as necessary to satisfy buffer request
	if (nCommand == bufferWrite)
	{
		if (m_nPosition + nCount < m_nPosition || m_nPosition + nCount < nCount)
		{
			AfxThrowInvalidArgException();
		}
		if (m_nPosition + nCount > m_nBufferSize)
		{
			GrowFile(m_nPosition + nCount);
		}
	}

	// store buffer max and min
	*ppBufStart = m_lpBuffer + m_nPosition;

	// end of buffer depends on whether you are reading or writing
	if (nCommand == bufferWrite)
		*ppBufMax = m_lpBuffer + min(m_nBufferSize, m_nPosition + nCount);
	else
	{
		if (nCount == (UINT)-1)
			nCount = UINT(m_nBufferSize - m_nPosition);
		*ppBufMax = m_lpBuffer + min(m_nFileSize, m_nPosition + nCount);
		m_nPosition += LPBYTE(*ppBufMax) - LPBYTE(*ppBufStart);
	}

	// return number of bytes in returned buffer space (may be <= nCount)
	return ULONG(LPBYTE(*ppBufMax) - LPBYTE(*ppBufStart));
}

/////////////////////////////////////////////////////////////////////////////
// CMemFile diagonstics

#ifdef _DEBUG
void CMemFile::Dump(CDumpContext& dc) const
{
	CFile::Dump(dc);

	dc << "m_nFileSize = " << ULONGLONG(m_nFileSize);
	dc << "\nm_nBufferSize = " << ULONGLONG(m_nBufferSize);
	dc << "\nm_nPosition = " << ULONGLONG(m_nPosition);
	dc << "\nm_nGrowBytes = " << ULONGLONG(m_nGrowBytes);

	dc << "\n";
}

void CMemFile::AssertValid() const
{
	CFile::AssertValid();

	ASSERT((m_lpBuffer == NULL && m_nBufferSize == 0) ||
		AfxIsValidAddress(m_lpBuffer, (UINT)m_nBufferSize, FALSE));
	ASSERT(m_nFileSize <= m_nBufferSize);
	// m_nPosition might be after the end of file, so we cannot ASSERT
	// its validity
}
#endif // _DEBUG


IMPLEMENT_DYNAMIC(CMemFile, CFile)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\filetxt.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include <errno.h>
#include <io.h>
#include <fcntl.h>
#include "sal.h"

#define new DEBUG_NEW

////////////////////////////////////////////////////////////////////////////
// CStdioFile implementation

CStdioFile::CStdioFile()
{
	CommonBaseInit(NULL, NULL);
}

CStdioFile::CStdioFile(CAtlTransactionManager* pTM)
{
	CommonBaseInit(NULL, pTM);
}

CStdioFile::CStdioFile(FILE* pOpenStream)
{
	ASSERT(pOpenStream != NULL);
	if (pOpenStream == NULL)
	{
		AfxThrowInvalidArgException();
	}

	CommonBaseInit(pOpenStream, NULL);
}

CStdioFile::CStdioFile(LPCTSTR lpszFileName, UINT nOpenFlags)
{
	CommonInit(lpszFileName, nOpenFlags, NULL);
}

CStdioFile::CStdioFile(LPCTSTR lpszFileName, UINT nOpenFlags, CAtlTransactionManager* pTM)
{
	CommonInit(lpszFileName, nOpenFlags, pTM);
}

void CStdioFile::CommonBaseInit(FILE* pOpenStream, CAtlTransactionManager* pTM)
{
	m_pStream = pOpenStream;
	m_pTM = pTM;

	if (pOpenStream != NULL)
	{
		m_hFile = (HANDLE)_get_osfhandle(_fileno(pOpenStream));
		ASSERT(!m_bCloseOnDelete);
	}
}

void CStdioFile::CommonInit(LPCTSTR lpszFileName, UINT nOpenFlags, CAtlTransactionManager* pTM)
{
	ASSERT(lpszFileName != NULL);
	ASSERT(AfxIsValidString(lpszFileName));
	if (lpszFileName == NULL)
	{
		AfxThrowInvalidArgException();
	}

	CommonBaseInit(NULL, pTM);

	CFileException e;
	if (!Open(lpszFileName, nOpenFlags, &e))
	{
		AfxThrowFileException(e.m_cause, e.m_lOsError, e.m_strFileName);
	}
}

CStdioFile::~CStdioFile()
{
	AFX_BEGIN_DESTRUCTOR

	ASSERT_VALID(this);

	if (m_pStream != NULL && m_bCloseOnDelete)
	{
		Close();
	}

	AFX_END_DESTRUCTOR
}

BOOL CStdioFile::Open(LPCTSTR lpszFileName, UINT nOpenFlags, CAtlTransactionManager* pTM, CFileException* pException)
{
	m_pTM = pTM;
	return Open(lpszFileName, nOpenFlags, pException);
}

BOOL CStdioFile::Open(LPCTSTR lpszFileName, UINT nOpenFlags, CFileException* pException)
{
	ASSERT(pException == NULL || AfxIsValidAddress(pException, sizeof(CFileException)));
	ASSERT(lpszFileName != NULL);
	ASSERT(AfxIsValidString(lpszFileName));

	if (lpszFileName == NULL)
	{
		return FALSE;
	}

	m_pStream = NULL;
	if (!CFile::Open(lpszFileName, (nOpenFlags & ~typeText), pException))
		return FALSE;

	ASSERT(m_hFile != hFileNull);
	ASSERT(m_bCloseOnDelete);

	char szMode[4]; // C-runtime open string
	int nMode = 0;

	// determine read/write mode depending on CFile mode
	if (nOpenFlags & modeCreate)
	{
		if (nOpenFlags & modeNoTruncate)
			szMode[nMode++] = 'a';
		else
			szMode[nMode++] = 'w';
	}
	else if (nOpenFlags & modeWrite)
		szMode[nMode++] = 'a';
	else
		szMode[nMode++] = 'r';

	// add '+' if necessary (when read/write modes mismatched)
	if (szMode[0] == 'r' && (nOpenFlags & modeReadWrite) ||
		szMode[0] != 'r' && !(nOpenFlags & modeWrite))
	{
		// current szMode mismatched, need to add '+' to fix
		szMode[nMode++] = '+';
	}

	// will be inverted if not necessary
	int nFlags = _O_RDONLY|_O_TEXT;
	if (nOpenFlags & (modeWrite|modeReadWrite))
		nFlags ^= _O_RDONLY;

	if (nOpenFlags & typeBinary)
		szMode[nMode++] = 'b', nFlags ^= _O_TEXT;
	else
		szMode[nMode++] = 't';
	szMode[nMode++] = '\0';

	// open a C-runtime low-level file handle
	int nHandle = _open_osfhandle((UINT_PTR) m_hFile, nFlags);

	// open a C-runtime stream from that handle
	if (nHandle != -1)
		m_pStream = _fdopen(nHandle, szMode);

	if (m_pStream == NULL)
	{
		// an error somewhere along the way...
		if (pException != NULL)
		{
			pException->m_lOsError = _doserrno;
			pException->m_cause = CFileException::OsErrorToException(_doserrno);
		}

		CFile::Abort(); // close m_hFile
		return FALSE;
	}

	return TRUE;
}

UINT CStdioFile::Read(void* lpBuf, UINT nCount)
{
	ASSERT_VALID(this);
	ASSERT(m_pStream != NULL);

	if (nCount == 0)
		return 0;   // avoid Win32 "null-read"

	ASSERT(AfxIsValidAddress(lpBuf, nCount));

	if (lpBuf == NULL)
	{
		AfxThrowInvalidArgException();
	}

	UINT nRead = 0;

	if ((nRead = (UINT)fread(lpBuf, sizeof(BYTE), nCount, m_pStream)) == 0 && !feof(m_pStream))
		AfxThrowFileException(CFileException::genericException, _doserrno, m_strFileName);
	if (ferror(m_pStream))
	{
		Afx_clearerr_s(m_pStream);
		AfxThrowFileException(CFileException::genericException, _doserrno, m_strFileName);
	}
	return nRead;
}

void CStdioFile::Write(const void* lpBuf, UINT nCount)
{
	ASSERT_VALID(this);
	ASSERT(m_pStream != NULL);
	ASSERT(AfxIsValidAddress(lpBuf, nCount, FALSE));

	if (lpBuf == NULL)
	{
		AfxThrowInvalidArgException();
	}

	if (fwrite(lpBuf, sizeof(BYTE), nCount, m_pStream) != nCount)
		AfxThrowFileException(CFileException::genericException, _doserrno, m_strFileName);
}

void CStdioFile::WriteString(LPCTSTR lpsz)
{
	ASSERT(lpsz != NULL);
	ASSERT(m_pStream != NULL);
	
	if (lpsz == NULL)
	{
		AfxThrowInvalidArgException();
	}

	if (_fputts(lpsz, m_pStream) == _TEOF)
		AfxThrowFileException(CFileException::diskFull, _doserrno, m_strFileName);
}

LPTSTR CStdioFile::ReadString(_Out_z_cap_(nMax) LPTSTR lpsz, _In_ UINT nMax)
{
	ASSERT(lpsz != NULL);
	ASSERT(AfxIsValidAddress(lpsz, nMax));
	ASSERT(m_pStream != NULL);

	if (lpsz == NULL)
	{
		AfxThrowInvalidArgException();
	}

	LPTSTR lpszResult = _fgetts(lpsz, nMax, m_pStream);
	if (lpszResult == NULL && !feof(m_pStream))
	{
		Afx_clearerr_s(m_pStream);
		AfxThrowFileException(CFileException::genericException, _doserrno, m_strFileName);
	}
	return lpszResult;
}

BOOL CStdioFile::ReadString(CString& rString)
{
	ASSERT_VALID(this);

	rString = _T("");    // empty string without deallocating
	const int nMaxSize = 128;
	LPTSTR lpsz = rString.GetBuffer(nMaxSize);
	LPTSTR lpszResult;
	int nLen = 0;
	for (;;)
	{
		lpszResult = _fgetts(lpsz, nMaxSize+1, m_pStream);
		rString.ReleaseBuffer();

		// handle error/eof case
		if (lpszResult == NULL && !feof(m_pStream))
		{
			Afx_clearerr_s(m_pStream);
			AfxThrowFileException(CFileException::genericException, _doserrno,
				m_strFileName);
		}

		// if string is read completely or EOF
		if (lpszResult == NULL ||
			(nLen = (int)lstrlen(lpsz)) < nMaxSize ||
			lpsz[nLen-1] == '\n')
			break;

		nLen = rString.GetLength();
		lpsz = rString.GetBuffer(nMaxSize + nLen) + nLen;
	}

	// remove '\n' from end of string if present
	lpsz = rString.GetBuffer(0);
	nLen = rString.GetLength();
	if (nLen != 0 && lpsz[nLen-1] == '\n')
		rString.GetBufferSetLength(nLen-1);

	return nLen != 0;
}

ULONGLONG CStdioFile::Seek(LONGLONG lOff, UINT nFrom)
{
	ASSERT_VALID(this);
	ASSERT(nFrom == begin || nFrom == end || nFrom == current);
	ASSERT(m_pStream != NULL);

   LONG lOff32;

   if ((lOff < LONG_MIN) || (lOff > LONG_MAX))
   {
	  AfxThrowFileException(CFileException::badSeek, -1, m_strFileName);
   }

   lOff32 = (LONG)lOff;
	if (fseek(m_pStream, lOff32, nFrom) != 0)
		AfxThrowFileException(CFileException::badSeek, _doserrno,
			m_strFileName);

	long pos = ftell(m_pStream);
	return pos;
}

ULONGLONG CStdioFile::GetLength() const
{
   ASSERT_VALID(this);

   LONG nCurrent;
   LONG nLength;
   LONG nResult;

   nCurrent = ftell(m_pStream);
   if (nCurrent == -1)
	  AfxThrowFileException(CFileException::invalidFile, _doserrno,
		 m_strFileName);

   nResult = fseek(m_pStream, 0, SEEK_END);
   if (nResult != 0)
	  AfxThrowFileException(CFileException::badSeek, _doserrno,
		 m_strFileName);

   nLength = ftell(m_pStream);
   if (nLength == -1)
	  AfxThrowFileException(CFileException::invalidFile, _doserrno,
		 m_strFileName);
   nResult = fseek(m_pStream, nCurrent, SEEK_SET);
   if (nResult != 0)
	  AfxThrowFileException(CFileException::badSeek, _doserrno,
		 m_strFileName);

   return nLength;
}

ULONGLONG CStdioFile::GetPosition() const
{
	ASSERT_VALID(this);
	ASSERT(m_pStream != NULL);

	long pos = ftell(m_pStream);
	if (pos == -1)
		AfxThrowFileException(CFileException::invalidFile, _doserrno,
			m_strFileName);
	return pos;
}

void CStdioFile::Flush()
{
	ASSERT_VALID(this);

	if (m_pStream != NULL && fflush(m_pStream) != 0)
		AfxThrowFileException(CFileException::diskFull, _doserrno,
			m_strFileName);
}

void CStdioFile::Close()
{
	ASSERT_VALID(this);
	ASSERT(m_pStream != NULL);

	int nErr = 0;

	if (m_pStream != NULL)
		nErr = fclose(m_pStream);

	m_hFile = hFileNull;
	m_bCloseOnDelete = FALSE;
	m_pStream = NULL;

	if (nErr != 0)
		AfxThrowFileException(CFileException::diskFull, _doserrno,
			m_strFileName);
}

void CStdioFile::Abort()
{
	ASSERT_VALID(this);

	if (m_pStream != NULL && m_bCloseOnDelete)
		fclose(m_pStream);  // close but ignore errors
	m_hFile = hFileNull;
	m_pStream = NULL;
	m_bCloseOnDelete = FALSE;
}

CFile* CStdioFile::Duplicate() const
{
	ASSERT_VALID(this);
	ASSERT(m_pStream != NULL);

	AfxThrowNotSupportedException();
}

void CStdioFile::LockRange(ULONGLONG /* dwPos */, ULONGLONG /* dwCount */)
{
	ASSERT_VALID(this);
	ASSERT(m_pStream != NULL);

	AfxThrowNotSupportedException();
}

void CStdioFile::UnlockRange(ULONGLONG /* dwPos */, ULONGLONG /* dwCount */)
{
	ASSERT_VALID(this);
	ASSERT(m_pStream != NULL);

	AfxThrowNotSupportedException();
}

#ifdef _DEBUG
void CStdioFile::Dump(CDumpContext& dc) const
{
	CFile::Dump(dc);

	dc << "m_pStream = " << (void*)m_pStream;
	dc << "\n";
}
#endif


IMPLEMENT_DYNAMIC(CStdioFile, CFile)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\fixalloc.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// fixalloc.cpp - implementation of fixed block allocator

#include "stdafx.h"
#include "fixalloc.h"

#ifdef _DEBUG



#define new DEBUG_NEW
#endif


/////////////////////////////////////////////////////////////////////////////
// CFixedAllocNoSync

CFixedAllocNoSync::CFixedAllocNoSync(UINT nAllocSize, UINT nBlockSize)
{
	ASSERT(nAllocSize >= sizeof(CNode));
	ASSERT(nBlockSize > 1);
	
	if (nAllocSize < sizeof(CNode))
		nAllocSize = sizeof(CNode);
	if (nBlockSize <= 1)
		nBlockSize = 64;

	m_nAllocSize = nAllocSize;
	m_nBlockSize = nBlockSize;
	m_pNodeFree = NULL;
	m_pBlocks = NULL;
}

CFixedAllocNoSync::~CFixedAllocNoSync()
{
	FreeAll();
}

void CFixedAllocNoSync::FreeAll()
{
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
	m_pNodeFree = NULL;
}

void* CFixedAllocNoSync::Alloc()
{
	if (m_pNodeFree == NULL)
	{
		// add another block
		CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize, m_nAllocSize);

		// chain them into free list
		CNode* pNode = (CNode*)pNewBlock->data();
		// free in reverse order to make it easier to debug
		(BYTE*&)pNode += (m_nAllocSize * m_nBlockSize) - m_nAllocSize;
		for (int i = m_nBlockSize-1; i >= 0; i--, (BYTE*&)pNode -= m_nAllocSize)
		{
			pNode->pNext = m_pNodeFree;
			m_pNodeFree = pNode;
		}
	}
	ASSERT(m_pNodeFree != NULL);  // we must have something

	// remove the first available node from the free list
	void* pNode = m_pNodeFree;
	m_pNodeFree = m_pNodeFree->pNext;
	return pNode;
}

void CFixedAllocNoSync::Free(void* p)
{
	if (p != NULL)
	{
		// simply return the node to the free list
		CNode* pNode = (CNode*)p;
		pNode->pNext = m_pNodeFree;
		m_pNodeFree = pNode;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CFixedAlloc

CFixedAlloc::CFixedAlloc(UINT nAllocSize, UINT nBlockSize)
	: base(nAllocSize, nBlockSize)
{
	InitializeCriticalSection(&m_protect);
}

CFixedAlloc::~CFixedAlloc()
{
	DeleteCriticalSection(&m_protect);
}

void CFixedAlloc::FreeAll()
{	
	EnterCriticalSection(&m_protect);
	__try
	{
		base::FreeAll();
	}
	__finally
	{
		LeaveCriticalSection(&m_protect);
	}
}

void* CFixedAlloc::Alloc()
{
	EnterCriticalSection(&m_protect);
	void* p = NULL;
	TRY
	{
		p = base::Alloc();
	}
	CATCH_ALL(e)
	{
		LeaveCriticalSection(&m_protect);
		THROW_LAST();
	}
	END_CATCH_ALL

	LeaveCriticalSection(&m_protect);
	return p;
}

void CFixedAlloc::Free(void* p)
{		
	if (p != NULL)
	{		
		EnterCriticalSection(&m_protect);
		__try
		{
			base::Free(p);
		}
		__finally
		{
			LeaveCriticalSection(&m_protect);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\filex.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include <errno.h>
#include "sal.h"



#ifdef _DEBUG
static const LPCSTR rgszCFileExceptionCause[] =
{
	"none",
	"generic",
	"fileNotFound",
	"badPath",
	"tooManyOpenFiles",
	"accessDenied",
	"invalidFile",
	"removeCurrentDir",
	"directoryFull",
	"badSeek",
	"hardIO",
	"sharingViolation",
	"lockViolation",
	"diskFull",
	"endOfFile",
};
static const char szUnknown[] = "unknown";
#endif

/////////////////////////////////////////////////////////////////////////////
// CFileException

void PASCAL CFileException::ThrowOsError(LONG lOsError,
	LPCTSTR lpszFileName /* = NULL */)
{
	if (lOsError != 0)
		AfxThrowFileException(CFileException::OsErrorToException(lOsError),
			lOsError, lpszFileName);
}

void PASCAL CFileException::ThrowErrno(int nErrno,
	LPCTSTR lpszFileName /* = NULL */)
{
	if (nErrno != 0)
		AfxThrowFileException(CFileException::ErrnoToException(nErrno),
			_doserrno, lpszFileName);
}

BOOL CFileException::GetErrorMessage(_Out_z_cap_(nMaxError) LPTSTR lpszError, _In_ UINT nMaxError,
		_Out_opt_ PUINT pnHelpContext) const
{
	ASSERT(lpszError != NULL && AfxIsValidString(lpszError, nMaxError));

	if (lpszError == NULL || nMaxError == 0) 
	{
		return FALSE;
	}

	if (pnHelpContext != NULL)
		*pnHelpContext = m_cause + AFX_IDP_FILE_NONE;

	CString strMessage;
	CString strFileName = m_strFileName;
	if (strFileName.IsEmpty())
		strFileName.LoadString(AFX_IDS_UNNAMED_FILE);
	AfxFormatString1(strMessage,
		m_cause + AFX_IDP_FILE_NONE, strFileName);
	Checked::tcsncpy_s(lpszError, nMaxError, strMessage, _TRUNCATE);

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CFileException diagnostics

#ifdef _DEBUG
void CFileException::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	dc << "m_cause = ";
	if (m_cause >= 0 && m_cause < _countof(rgszCFileExceptionCause))
		dc << rgszCFileExceptionCause[m_cause];
	else
		dc << szUnknown;
	dc << "\nm_lOsError = " << m_lOsError;

	dc << "\n";
}
#endif

/////////////////////////////////////////////////////////////////////////////
// CFileException helpers

void __declspec(noreturn) AFXAPI AfxThrowFileException(int cause, LONG lOsError,
	LPCTSTR lpszFileName /* == NULL */)
{
#ifdef _DEBUG
	LPCSTR lpsz;
	if (cause >= 0 && cause < _countof(rgszCFileExceptionCause))
		lpsz = rgszCFileExceptionCause[cause];
	else
		lpsz = szUnknown;
	TRACE(traceAppMsg, 0, _T("CFile exception: %hs, File %s, OS error information = %ld.\n"),
		lpsz, (lpszFileName == NULL) ? _T("Unknown") : lpszFileName, lOsError);
#endif
	THROW(new CFileException(cause, lOsError, lpszFileName));
}

int PASCAL CFileException::ErrnoToException(int nErrno)
{
	switch(nErrno)
	{
	case EPERM:
	case EACCES:
		return CFileException::accessDenied;
	case EBADF:
		return CFileException::invalidFile;
	case EDEADLOCK:
		return CFileException::sharingViolation;
	case EMFILE:
		return CFileException::tooManyOpenFiles;
	case ENOENT:
	case ENFILE:
		return CFileException::fileNotFound;
	case ENOSPC:
		return CFileException::diskFull;
	case EINVAL:
	case EIO:
		return CFileException::hardIO;
	default:
		return CFileException::genericException;
	}
}

int PASCAL CFileException::OsErrorToException(LONG lOsErr)
{
	// NT Error codes
	switch ((UINT)lOsErr)
	{
	case NO_ERROR:
		return CFileException::none;
	case ERROR_FILE_NOT_FOUND:
		return CFileException::fileNotFound;
	case ERROR_PATH_NOT_FOUND:
		return CFileException::badPath;
	case ERROR_TOO_MANY_OPEN_FILES:
		return CFileException::tooManyOpenFiles;
	case ERROR_ACCESS_DENIED:
		return CFileException::accessDenied;
	case ERROR_INVALID_HANDLE:
		return CFileException::fileNotFound;
	case ERROR_BAD_FORMAT:
		return CFileException::invalidFile;
	case ERROR_INVALID_ACCESS:
		return CFileException::accessDenied;
	case ERROR_INVALID_DRIVE:
		return CFileException::badPath;
	case ERROR_CURRENT_DIRECTORY:
		return CFileException::removeCurrentDir;
	case ERROR_NOT_SAME_DEVICE:
		return CFileException::badPath;
	case ERROR_NO_MORE_FILES:
		return CFileException::fileNotFound;
	case ERROR_WRITE_PROTECT:
		return CFileException::accessDenied;
	case ERROR_BAD_UNIT:
		return CFileException::hardIO;
	case ERROR_NOT_READY:
		return CFileException::hardIO;
	case ERROR_BAD_COMMAND:
		return CFileException::hardIO;
	case ERROR_CRC:
		return CFileException::hardIO;
	case ERROR_BAD_LENGTH:
		return CFileException::badSeek;
	case ERROR_SEEK:
		return CFileException::badSeek;
	case ERROR_NOT_DOS_DISK:
		return CFileException::invalidFile;
	case ERROR_SECTOR_NOT_FOUND:
		return CFileException::badSeek;
	case ERROR_WRITE_FAULT:
		return CFileException::accessDenied;
	case ERROR_READ_FAULT:
		return CFileException::badSeek;
	case ERROR_SHARING_VIOLATION:
		return CFileException::sharingViolation;
	case ERROR_LOCK_VIOLATION:
		return CFileException::lockViolation;
	case ERROR_WRONG_DISK:
		return CFileException::badPath;
	case ERROR_SHARING_BUFFER_EXCEEDED:
		return CFileException::tooManyOpenFiles;
	case ERROR_HANDLE_EOF:
		return CFileException::endOfFile;
	case ERROR_HANDLE_DISK_FULL:
		return CFileException::diskFull;
	case ERROR_DUP_NAME:
		return CFileException::badPath;
	case ERROR_BAD_NETPATH:
		return CFileException::badPath;
	case ERROR_NETWORK_BUSY:
		return CFileException::accessDenied;
	case ERROR_DEV_NOT_EXIST:
		return CFileException::badPath;
	case ERROR_ADAP_HDW_ERR:
		return CFileException::hardIO;
	case ERROR_BAD_NET_RESP:
		return CFileException::accessDenied;
	case ERROR_UNEXP_NET_ERR:
		return CFileException::hardIO;
	case ERROR_BAD_REM_ADAP:
		return CFileException::invalidFile;
	case ERROR_NO_SPOOL_SPACE:
		return CFileException::directoryFull;
	case ERROR_NETNAME_DELETED:
		return CFileException::accessDenied;
	case ERROR_NETWORK_ACCESS_DENIED:
		return CFileException::accessDenied;
	case ERROR_BAD_DEV_TYPE:
		return CFileException::invalidFile;
	case ERROR_BAD_NET_NAME:
		return CFileException::badPath;
	case ERROR_TOO_MANY_NAMES:
		return CFileException::tooManyOpenFiles;
	case ERROR_SHARING_PAUSED:
		return CFileException::badPath;
	case ERROR_REQ_NOT_ACCEP:
		return CFileException::accessDenied;
	case ERROR_FILE_EXISTS:
		return CFileException::accessDenied;
	case ERROR_CANNOT_MAKE:
		return CFileException::accessDenied;
	case ERROR_ALREADY_ASSIGNED:
		return CFileException::badPath;
	case ERROR_INVALID_PASSWORD:
		return CFileException::accessDenied;
	case ERROR_NET_WRITE_FAULT:
		return CFileException::hardIO;
	case ERROR_DISK_CHANGE:
		return CFileException::fileNotFound;
	case ERROR_DRIVE_LOCKED:
		return CFileException::lockViolation;
	case ERROR_BUFFER_OVERFLOW:
		return CFileException::badPath;
	case ERROR_DISK_FULL:
		return CFileException::diskFull;
	case ERROR_NO_MORE_SEARCH_HANDLES:
		return CFileException::tooManyOpenFiles;
	case ERROR_INVALID_TARGET_HANDLE:
		return CFileException::invalidFile;
	case ERROR_INVALID_CATEGORY:
		return CFileException::hardIO;
	case ERROR_INVALID_NAME:
		return CFileException::badPath;
	case ERROR_INVALID_LEVEL:
		return CFileException::badPath;
	case ERROR_NO_VOLUME_LABEL:
		return CFileException::badPath;
	case ERROR_NEGATIVE_SEEK:
		return CFileException::badSeek;
	case ERROR_SEEK_ON_DEVICE:
		return CFileException::badSeek;
	case ERROR_DIR_NOT_ROOT:
		return CFileException::badPath;
	case ERROR_DIR_NOT_EMPTY:
		return CFileException::removeCurrentDir;
	case ERROR_LABEL_TOO_LONG:
		return CFileException::badPath;
	case ERROR_BAD_PATHNAME:
		return CFileException::badPath;
	case ERROR_LOCK_FAILED:
		return CFileException::lockViolation;
	case ERROR_BUSY:
		return CFileException::accessDenied;
	case ERROR_INVALID_ORDINAL:
		return CFileException::invalidFile;
	case ERROR_ALREADY_EXISTS:
		return CFileException::accessDenied;
	case ERROR_INVALID_EXE_SIGNATURE:
		return CFileException::invalidFile;
	case ERROR_BAD_EXE_FORMAT:
		return CFileException::invalidFile;
	case ERROR_FILENAME_EXCED_RANGE:
		return CFileException::badPath;
	case ERROR_META_EXPANSION_TOO_LONG:
		return CFileException::badPath;
	case ERROR_DIRECTORY:
		return CFileException::badPath;
	case ERROR_OPERATION_ABORTED:
		return CFileException::hardIO;
	case ERROR_IO_INCOMPLETE:
		return CFileException::hardIO;
	case ERROR_IO_PENDING:
		return CFileException::hardIO;
	case ERROR_SWAPERROR:
		return CFileException::accessDenied;
	default:
		return CFileException::genericException;
	}
}


IMPLEMENT_DYNAMIC(CFileException, CException)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\filest.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include <errno.h>
#include <io.h>
#include <sys\types.h>
#include <sys\stat.h>



#define new DEBUG_NEW

////////////////////////////////////////////////////////////////////////////
// Status information for all file classes
// In this file so everyone doesn't get the CTime package

/////////////////////////////////////////////////////////////////////////////
// CFileStatus diagnostics

#ifdef _DEBUG
void CFileStatus::Dump(CDumpContext& dc) const
{
	dc << "a CFileStatus at " << (void*)this;

	dc << "\nm_ctime = " << m_ctime;
	dc << "\nm_mtime = " << m_mtime;
	dc << "\nm_atime = " << m_atime;
	dc << "\nm_size = " << m_size;
	dc << "\nm_attribute = " << m_attribute;
	dc << "\nm_szFullName = " << m_szFullName;

	dc << "\n";
}
#endif

/////////////////////////////////////////////////////////////////////////////
// CFile name handlers

CString CFile::GetFileName() const
{
	ASSERT_VALID(this);

	CFileStatus status;
	GetStatus(status);
	CString strResult;
	AfxGetFileName(status.m_szFullName, strResult.GetBuffer(_MAX_FNAME),
		_MAX_FNAME);
	strResult.ReleaseBuffer();
	return strResult;
}

CString CFile::GetFileTitle() const
{
	ASSERT_VALID(this);

	CFileStatus status;
	GetStatus(status);
	CString strResult;
	AfxGetFileTitle(status.m_szFullName, strResult.GetBuffer(_MAX_FNAME),
		_MAX_FNAME);
	strResult.ReleaseBuffer();
	return strResult;
}

CString CFile::GetFilePath() const
{
	ASSERT_VALID(this);

	CFileStatus status;
	GetStatus(status);
	return status.m_szFullName;
}

/////////////////////////////////////////////////////////////////////////////
// CFile Status implementation

BOOL CFile::GetStatus(CFileStatus& rStatus) const
{
	ASSERT_VALID(this);

	memset(&rStatus, 0, sizeof(CFileStatus));

	// copy file name from cached m_strFileName
	Checked::tcsncpy_s(rStatus.m_szFullName, _countof(rStatus.m_szFullName), m_strFileName, _TRUNCATE);

	if (m_hFile != hFileNull)
	{
		// get time current file size
		FILETIME ftCreate, ftAccess, ftModify;
		if (!::GetFileTime(m_hFile, &ftCreate, &ftAccess, &ftModify))
			return FALSE;


		LARGE_INTEGER li;

		if (::GetFileSizeEx(m_hFile, &li) == 0)
			return FALSE;

		rStatus.m_size = li.QuadPart;


		if (m_strFileName.IsEmpty())
			rStatus.m_attribute = 0;
		else
		{
			DWORD dwAttribute = m_pTM != NULL ? 
				m_pTM->GetFileAttributes(m_strFileName) :
				::GetFileAttributes(m_strFileName);

			// don't return an error for this because previous versions of MFC didn't
			if (dwAttribute == 0xFFFFFFFF)
				rStatus.m_attribute = 0;
			else
			{
				rStatus.m_attribute = (BYTE) dwAttribute;
#ifdef _DEBUG
				// MFC BUG: m_attribute is only a BYTE wide
				if (dwAttribute & ~0xFF)
					TRACE(traceAppMsg, 0, "Warning: CFile::GetStatus() returns m_attribute without high-order flags.\n");
#endif
			}
		}

		// convert times as appropriate
		// some file systems may not record file creation time, file access time etc
		if (CTime::IsValidFILETIME(ftCreate))
		{
			rStatus.m_ctime = CTime(ftCreate);
		}
		else
		{
			rStatus.m_ctime = CTime();
		}

		if (CTime::IsValidFILETIME(ftAccess))
		{
			rStatus.m_atime = CTime(ftAccess);
		}
		else
		{
			rStatus.m_atime = CTime();
		}
		
		if (CTime::IsValidFILETIME(ftModify))
		{
			rStatus.m_mtime = CTime(ftModify);
		}
		else
		{
			rStatus.m_mtime = CTime();
		}

		if (rStatus.m_ctime.GetTime() == 0)
			rStatus.m_ctime = rStatus.m_mtime;

		if (rStatus.m_atime.GetTime() == 0)
			rStatus.m_atime = rStatus.m_mtime;
	}
	return TRUE;
}

BOOL PASCAL CFile::GetStatus(LPCTSTR lpszFileName, CFileStatus& rStatus, CAtlTransactionManager* pTM)
{
	ASSERT( lpszFileName != NULL );

	if ( lpszFileName == NULL ) 
	{
		return FALSE;
	}

	if ( lstrlen(lpszFileName) >= _MAX_PATH )
	{
		ASSERT(FALSE); // MFC requires paths with length < _MAX_PATH
		return FALSE;
	}
	
	// attempt to fully qualify path first
	if (!AfxFullPath(rStatus.m_szFullName, lpszFileName))
	{
		rStatus.m_szFullName[0] = '\0';
		return FALSE;
	}

	WIN32_FILE_ATTRIBUTE_DATA fileAttributeData;

	if (pTM != NULL)
	{
		if (!pTM->GetFileAttributesEx(lpszFileName, GetFileExInfoStandard, &fileAttributeData))
			return FALSE;
	}
	else
	{
		if (!GetFileAttributesEx(lpszFileName, GetFileExInfoStandard, &fileAttributeData))
			return FALSE;
	}

	// strip attribute of NORMAL bit, our API doesn't have a "normal" bit.
	rStatus.m_attribute = (BYTE)
		(fileAttributeData.dwFileAttributes & ~FILE_ATTRIBUTE_NORMAL);

	rStatus.m_size = fileAttributeData.nFileSizeHigh;
	rStatus.m_size <<= 32;
	rStatus.m_size |= fileAttributeData.nFileSizeLow;

	// convert times as appropriate
	if (CTime::IsValidFILETIME(fileAttributeData.ftCreationTime))
	{
		rStatus.m_ctime = CTime(fileAttributeData.ftCreationTime);
	}
	else
	{
		rStatus.m_ctime = CTime();
	}

	if (CTime::IsValidFILETIME(fileAttributeData.ftLastAccessTime))
	{
		rStatus.m_atime = CTime(fileAttributeData.ftLastAccessTime);
	}
	else
	{
		rStatus.m_atime = CTime();
	}

	if (CTime::IsValidFILETIME(fileAttributeData.ftLastWriteTime))
	{
		rStatus.m_mtime = CTime(fileAttributeData.ftLastWriteTime);
	}
	else
	{
		rStatus.m_mtime = CTime();
	}

	if (rStatus.m_ctime.GetTime() == 0)
		rStatus.m_ctime = rStatus.m_mtime;

	if (rStatus.m_atime.GetTime() == 0)
		rStatus.m_atime = rStatus.m_mtime;

	return TRUE;
}

void AFX_CDECL AfxTimeToFileTime(const CTime& time, LPFILETIME pFileTime)
{
	ASSERT(pFileTime != NULL);

	if (pFileTime == NULL) 
	{
		AfxThrowInvalidArgException();
	}

	SYSTEMTIME sysTime;
	sysTime.wYear = (WORD)time.GetYear();
	sysTime.wMonth = (WORD)time.GetMonth();
	sysTime.wDay = (WORD)time.GetDay();
	sysTime.wHour = (WORD)time.GetHour();
	sysTime.wMinute = (WORD)time.GetMinute();
	sysTime.wSecond = (WORD)time.GetSecond();
	sysTime.wMilliseconds = 0;

	// convert system time to local file time
	FILETIME localTime;
	if (!SystemTimeToFileTime((LPSYSTEMTIME)&sysTime, &localTime))
		CFileException::ThrowOsError((LONG)::GetLastError());

	// convert local file time to UTC file time
	if (!LocalFileTimeToFileTime(&localTime, pFileTime))
		CFileException::ThrowOsError((LONG)::GetLastError());
}

void PASCAL CFile::SetStatus(LPCTSTR lpszFileName, const CFileStatus& status, CAtlTransactionManager* pTM)
{
	FILETIME creationTime;
	FILETIME lastAccessTime;
	FILETIME lastWriteTime;
	LPFILETIME lpCreationTime = NULL;
	LPFILETIME lpLastAccessTime = NULL;
	LPFILETIME lpLastWriteTime = NULL;

	DWORD wAttr = (pTM != NULL) ? pTM->GetFileAttributes((LPTSTR)lpszFileName) : GetFileAttributes((LPTSTR)lpszFileName);
	if (wAttr == (DWORD)-1L)
		CFileException::ThrowOsError((LONG)GetLastError(), lpszFileName);

	if ((DWORD)status.m_attribute != wAttr && (wAttr & readOnly))
	{
		// Set file attribute, only if currently readonly.
		// This way we will be able to modify the time assuming the
		// caller changed the file from readonly.

		BOOL bRes = (pTM != NULL) ? pTM->SetFileAttributes((LPTSTR)lpszFileName, (DWORD)status.m_attribute) : SetFileAttributes((LPTSTR)lpszFileName, (DWORD)status.m_attribute);
		if (!bRes)
			CFileException::ThrowOsError((LONG)GetLastError(), lpszFileName);
	}

	// last modification time
	if (status.m_mtime.GetTime() != 0)
	{
		AfxTimeToFileTime(status.m_mtime, &lastWriteTime);
		lpLastWriteTime = &lastWriteTime;

		// last access time
		if (status.m_atime.GetTime() != 0)
		{
			AfxTimeToFileTime(status.m_atime, &lastAccessTime);
			lpLastAccessTime = &lastAccessTime;
		}

		// create time
		if (status.m_ctime.GetTime() != 0)
		{
			AfxTimeToFileTime(status.m_ctime, &creationTime);
			lpCreationTime = &creationTime;
		}

		HANDLE hFile = pTM != NULL ?
			pTM->CreateFile (lpszFileName, GENERIC_READ|GENERIC_WRITE,
				FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL) :
			::CreateFile(lpszFileName, GENERIC_READ|GENERIC_WRITE,
				FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

		if (hFile == INVALID_HANDLE_VALUE)
			CFileException::ThrowOsError((LONG)::GetLastError(), lpszFileName);

		if (!SetFileTime((HANDLE)hFile, lpCreationTime, lpLastAccessTime, lpLastWriteTime))
		{
			LONG sc=(LONG)::GetLastError();
			::CloseHandle(hFile);
			CFileException::ThrowOsError(sc, lpszFileName);
		}

		if (!::CloseHandle(hFile))
			CFileException::ThrowOsError((LONG)::GetLastError(), lpszFileName);
	}

	if ((DWORD)status.m_attribute != wAttr && !(wAttr & readOnly))
	{
		BOOL bRes = (pTM != NULL) ?
			pTM->SetFileAttributes((LPTSTR)lpszFileName, (DWORD)status.m_attribute) :
			SetFileAttributes((LPTSTR)lpszFileName, (DWORD)status.m_attribute);

		if (!bRes)
			CFileException::ThrowOsError((LONG)GetLastError(), lpszFileName);
	}
}

///////////////////////////////////////////////////////////////////////////////
// CMemFile::GetStatus implementation

BOOL CMemFile::GetStatus(CFileStatus& rStatus) const
{
	ASSERT_VALID(this);

	rStatus.m_ctime = 0;
	rStatus.m_mtime = 0;
	rStatus.m_atime = 0;
	rStatus.m_size = m_nFileSize;
	rStatus.m_attribute = normal;
	rStatus.m_szFullName[0] = '\0';
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\inetcall.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifdef _AFXDLL
#include "stdafx.h"
#endif

// Note: because of the nature of these functions, it is not possible
//  to create a 'C' or 'C++' version of them.  These functions are used
//  for the lowest level of the OLE IDispatch implementation, and need
//  to be ported to each supported platform.

extern "C" {

/////////////////////////////////////////////////////////////////////////////
// Intel 386 version

#ifdef _X86_


__declspec(naked) void AFXISAPI
_AfxParseCall(AFX_PISAPICMD /*pfn*/, void* /*pArgs*/, UINT /*nSizeArgs*/)
{
	_asm
	{
		pop     edx         // edx = return address
		pop     eax         // eax = pfn
		pop     ecx         // ecx = pArgs
		add     ecx,[esp]   // ecx += nSizeArgs (=scratch area)
		mov     [ecx],edx   // scratch[0] = return address
		sub     ecx,[esp]   // ecx = pArgs (again)
		mov     esp,ecx     // esp = pArgs (usually already correct)
		pop     ecx         // ecx = this pointer (the CCmdTarget*)
		call    eax         // call member function
		ret                 // esp[0] should = scratch[0] = return address
	}
}
#endif // _X86_

/////////////////////////////////////////////////////////////////////////////
// AMD 64 version

#ifdef _AMD64_

// Note: AMD64 version is in src\amd64\inetcal_.s

// The AMD64 compiler does not support inline assembly, so it
//  must be build separately with the MASM64 assembler.


#endif // _AMD64_

/////////////////////////////////////////////////////////////////////////////
// MIPS R4000 version

#ifdef _MIPS_

extern "C" void _asm(char *, ...);
void AFXISAPI
_AfxParseCall(AFX_PMSG /*pfn*/, void* /*pArgs*/, UINT /*nSizeArgs*/)
{
	_asm("addiu     %sp,%a1,0x0");      // sp = pArgs
	_asm("addiu     %t6,%a0,0x0");      // t6 = pfn (save it)
	_asm("lw        %a0,0x0(%sp)");     // a0 = param0
	_asm("lw        %a1,0x4(%sp)");     // a1 = param1
	_asm("lw        %a2,0x8(%sp)");     // a2 = param2
	_asm("lw        %a3,0xc(%sp)");     // a3 = param3
	_asm("j         %t6");              // ip = pfn (jump to target function)
}

#endif // _MIPS_

/////////////////////////////////////////////////////////////////////////////

} // end extern "C" block

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\fixalloc.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// fixalloc.h - declarations for fixed block allocator

#ifndef __FIXALLOC_H__
#define __FIXALLOC_H__

#include "afxplex_.h"

/////////////////////////////////////////////////////////////////////////////
// CFixedAlloc

class CFixedAllocNoSync
{
// Constructors
public:
	CFixedAllocNoSync(UINT nAllocSize, UINT nBlockSize = 64);

// Attributes
	UINT GetAllocSize() { return m_nAllocSize; }

// Operations
public:
	void* Alloc();  // return a chunk of memory of nAllocSize
	void Free(void* p); // free chunk of memory returned from Alloc
	void FreeAll(); // free everything allocated from this allocator

// Implementation
public:
	~CFixedAllocNoSync();

protected:
	struct CNode
	{
		CNode* pNext;	// only valid when in free list
	};

	UINT m_nAllocSize;	// size of each block from Alloc
	UINT m_nBlockSize;	// number of blocks to get at a time
	CPlex* m_pBlocks;	// linked list of blocks (is nBlocks*nAllocSize)
	CNode* m_pNodeFree;	// first free node (NULL if no free nodes)
};

class CFixedAlloc : public CFixedAllocNoSync
{
	typedef class CFixedAllocNoSync base;

// Constructors
public:
	CFixedAlloc(UINT nAllocSize, UINT nBlockSize = 64);

// Operations
public:
	void* Alloc();	// return a chunk of memory of nAllocSize
	void Free(void* p);	// free chunk of memory returned from Alloc
	void FreeAll();	// free everything allocated from this allocator

// Implementation
public:
	~CFixedAlloc();

protected:
	CRITICAL_SECTION m_protect;
};

#ifndef _DEBUG

// DECLARE_FIXED_ALLOC -- used in class definition
#define DECLARE_FIXED_ALLOC(class_name) \
public: \
	void* operator new(size_t size) \
	{ \
		ASSERT(size == s_alloc.GetAllocSize()); \
		UNUSED(size); \
		return s_alloc.Alloc(); \
	} \
	void* operator new(size_t, void* p) \
		{ return p; } \
	void operator delete(void* p) { s_alloc.Free(p); } \
	void* operator new(size_t size, LPCSTR, int) \
	{ \
		ASSERT(size == s_alloc.GetAllocSize()); \
		UNUSED(size); \
		return s_alloc.Alloc(); \
	} \
protected: \
	static CFixedAlloc s_alloc \

// IMPLEMENT_FIXED_ALLOC -- used in class implementation file
#define IMPLEMENT_FIXED_ALLOC(class_name, block_size) \
CFixedAlloc class_name::s_alloc(sizeof(class_name), block_size) \

// DECLARE_FIXED_ALLOC -- used in class definition
#define DECLARE_FIXED_ALLOC_NOSYNC(class_name) \
public: \
	void* operator new(size_t size) \
	{ \
		ASSERT(size == s_alloc.GetAllocSize()); \
		UNUSED(size); \
		return s_alloc.Alloc(); \
	} \
	void* operator new(size_t, void* p) \
		{ return p; } \
	void operator delete(void* p) { s_alloc.Free(p); } \
	void* operator new(size_t size, LPCSTR, int) \
	{ \
		ASSERT(size == s_alloc.GetAllocSize()); \
		UNUSED(size); \
		return s_alloc.Alloc(); \
	} \
protected: \
	static CFixedAllocNoSync s_alloc \

// IMPLEMENT_FIXED_ALLOC_NOSYNC -- used in class implementation file
#define IMPLEMENT_FIXED_ALLOC_NOSYNC(class_nbame, block_size) \
CFixedAllocNoSync class_name::s_alloc(sizeof(class_name), block_size) \

#else //!_DEBUG

#define DECLARE_FIXED_ALLOC(class_name) // nothing in debug
#define IMPLEMENT_FIXED_ALLOC(class_name, block_size) // nothing in debug
#define DECLARE_FIXED_ALLOC_NOSYNC(class_name) // nothing in debug
#define IMPLEMENT_FIXED_ALLOC_NOSYNC(class_name, block_size) // nothing in debug

#endif //!_DEBUG

#ifndef _AFX_DISABLE_DEPRECATED
#pragma deprecated( CFixedAlloc )
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\inet.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include <afxtempl.h>
#include <afxinet.h>
#include "sal.h"

#pragma warning(disable: 4706) // assignment within conditional



#define new DEBUG_NEW

#ifndef _AFXDLL
#pragma comment(lib, "wininet.lib")
#endif

/////////////////////////////////////////////////////////////////////////////
// non-localized useful strings

typedef struct tagServiceTable {
	DWORD dwService;
	LPCTSTR pstrIdentifier;
} SvcTable;

AFX_STATIC_DATA const TCHAR _afxURLftp[] = _T("ftp://");
AFX_STATIC_DATA const TCHAR _afxURLgopher[] = _T("gopher://");
AFX_STATIC_DATA const TCHAR _afxURLhttp[] = _T("http://");

const LPCTSTR CHttpConnection::szHtmlVerbs[] = {
	_T("POST"),
	_T("GET"),
	_T("HEAD"),
	_T("PUT"),
	_T("LINK"),
	_T("DELETE"),
	_T("UNLINK"),
};


/////////////////////////////////////////////////////////////////////////////
// map of HINTERNETs to CInternetSessions* for callbacks

// forward declared because we need a #pragma -- see end of this file

class CSessionMapPtrToPtr : public CMapPtrToPtr
{
private:
	CCriticalSection m_sect;

public:
	CSessionMapPtrToPtr() { }
	~CSessionMapPtrToPtr() { }

	void SetAt(HINTERNET hInternet, CInternetSession* pSess)
	{
		m_sect.Lock();
		CMapPtrToPtr::SetAt(hInternet, pSess);
		m_sect.Unlock();
	}

	void RemoveKey(HINTERNET hInternet)
	{
		m_sect.Lock();
		CMapPtrToPtr::RemoveKey(hInternet);
		m_sect.Unlock();
	}

	BOOL Lookup(HINTERNET hInternet, CInternetSession*& refpSession)
	{
		BOOL bRet;
		m_sect.Lock();
		bRet = CMapPtrToPtr::Lookup(hInternet, (void*&) refpSession);
		m_sect.Unlock();
		return bRet;
	}
};

extern CSessionMapPtrToPtr _afxSessionMap;


/////////////////////////////////////////////////////////////////////////////
// Global Functions

AFX_STATIC BOOL AFXAPI _AfxParseURLWorker(LPCTSTR pstrURL,
	LPURL_COMPONENTS lpComponents, DWORD& dwServiceType,
	INTERNET_PORT& nPort, DWORD dwFlags)
{
	// this function will return bogus stuff if lpComponents
	// isn't set up to copy the components

	ASSERT(lpComponents != NULL && pstrURL != NULL);
	if (lpComponents == NULL || pstrURL == NULL)
		return FALSE;
	ASSERT(lpComponents->dwHostNameLength == 0 ||
			lpComponents->lpszHostName != NULL);
	ASSERT(lpComponents->dwUrlPathLength == 0 ||
			lpComponents->lpszUrlPath != NULL);
	ASSERT(lpComponents->dwUserNameLength == 0 ||
			lpComponents->lpszUserName != NULL);
	ASSERT(lpComponents->dwPasswordLength == 0 ||
			lpComponents->lpszPassword != NULL);

	ASSERT(AfxIsValidAddress(lpComponents, sizeof(URL_COMPONENTS), TRUE));

	LPTSTR pstrCanonicalizedURL;
	TCHAR szCanonicalizedURL[INTERNET_MAX_URL_LENGTH];
	DWORD dwNeededLength = INTERNET_MAX_URL_LENGTH;
	BOOL bRetVal;
	BOOL bMustFree = FALSE;

	// Decoding is done in InternetCrackUrl/UrlUnescape 
	// so we don't need the ICU_DECODE flag here.
	
	DWORD dwCanonicalizeFlags = dwFlags &
		(ICU_NO_ENCODE | ICU_NO_META |
		ICU_ENCODE_SPACES_ONLY | ICU_BROWSER_MODE);

	DWORD dwCrackFlags = 0;
 	
	BOOL bUnescape = FALSE;

	if((dwFlags & (ICU_ESCAPE | ICU_DECODE)) && (lpComponents->dwUrlPathLength != 0) )
	{
	
		// We use only the ICU_ESCAPE flag for decoding even if
		// ICU_DECODE is passed.
		
		// Also, if ICU_BROWSER_MODE is passed we do the unescaping
		// manually because InternetCrackUrl doesn't do
		// Browser mode unescaping
		
		if (dwFlags & ICU_BROWSER_MODE)
			bUnescape = TRUE;
		else
			dwCrackFlags |= ICU_ESCAPE;
	}

	bRetVal = InternetCanonicalizeUrl(pstrURL, szCanonicalizedURL,
		&dwNeededLength, dwCanonicalizeFlags);

	if (!bRetVal)
	{
		if (::GetLastError() != ERROR_INSUFFICIENT_BUFFER)
			return FALSE;

		pstrCanonicalizedURL = new TCHAR[dwNeededLength];
		if (pstrCanonicalizedURL == NULL)
			return FALSE;

		bMustFree = TRUE;
		bRetVal = InternetCanonicalizeUrl(pstrURL, pstrCanonicalizedURL,
			&dwNeededLength, dwCanonicalizeFlags);
		if (!bRetVal)
		{
			delete [] pstrCanonicalizedURL;
			return FALSE;
		}
	}
	else
	{
		pstrCanonicalizedURL = szCanonicalizedURL;
	}

	// now that it's safely canonicalized, crack it

	bRetVal = InternetCrackUrl(pstrCanonicalizedURL, 0,
						dwCrackFlags, lpComponents);

	if(bUnescape)
	{
		// Length of buffer passed to UrlUnescape cannot be larger than INTERNET_MAX_URL_LENGTH characters.
		if (_tcslen(lpComponents->lpszUrlPath) >= INTERNET_MAX_URL_LENGTH || 
			FAILED(UrlUnescape(lpComponents->lpszUrlPath,NULL,NULL,URL_UNESCAPE_INPLACE | URL_DONT_UNESCAPE_EXTRA_INFO)))
		{
			if (bMustFree)
				delete [] pstrCanonicalizedURL;
		
			return FALSE;
		}
		
		lpComponents->dwUrlPathLength = lstrlen(lpComponents->lpszUrlPath);
	}
	
	if (bMustFree)
	{
		delete [] pstrCanonicalizedURL;
	}

	// convert to MFC-style service ID

	if (!bRetVal)
	{
		dwServiceType = AFX_INET_SERVICE_UNK;
	}
	else
	{
		nPort = lpComponents->nPort;
		switch (lpComponents->nScheme)
		{
		case INTERNET_SCHEME_FTP:
			dwServiceType = AFX_INET_SERVICE_FTP;
			break;

		case INTERNET_SCHEME_GOPHER:
			dwServiceType = AFX_INET_SERVICE_GOPHER;
			break;

		case INTERNET_SCHEME_HTTP:
			dwServiceType = AFX_INET_SERVICE_HTTP;
			break;

		case INTERNET_SCHEME_HTTPS:
			dwServiceType = AFX_INET_SERVICE_HTTPS;
			break;

		case INTERNET_SCHEME_FILE:
			dwServiceType = AFX_INET_SERVICE_FILE;
			break;

		case INTERNET_SCHEME_NEWS:
			dwServiceType = AFX_INET_SERVICE_NNTP;
			break;

		case INTERNET_SCHEME_MAILTO:
			dwServiceType = AFX_INET_SERVICE_MAILTO;
			break;

		default:
			dwServiceType = AFX_INET_SERVICE_UNK;
		}
	}

	return bRetVal;
}

BOOL AFXAPI AfxParseURLEx(LPCTSTR pstrURL, DWORD& dwServiceType,
	CString& strServer, CString& strObject, INTERNET_PORT& nPort,
	CString& strUsername, CString& strPassword, DWORD dwFlags/* = 0*/)
{
	dwServiceType = AFX_INET_SERVICE_UNK;

	ASSERT(pstrURL != NULL);
	if (pstrURL == NULL)
		return FALSE;

	URL_COMPONENTS urlComponents;
	memset(&urlComponents, 0, sizeof(URL_COMPONENTS));
	urlComponents.dwStructSize = sizeof(URL_COMPONENTS);

	urlComponents.dwHostNameLength = INTERNET_MAX_HOST_NAME_LENGTH;
	urlComponents.lpszHostName = strServer.GetBuffer(INTERNET_MAX_HOST_NAME_LENGTH+1);
	urlComponents.dwUrlPathLength = INTERNET_MAX_PATH_LENGTH;
	urlComponents.lpszUrlPath = strObject.GetBuffer(INTERNET_MAX_PATH_LENGTH+1);
	urlComponents.dwUserNameLength = INTERNET_MAX_USER_NAME_LENGTH;
	urlComponents.lpszUserName = strUsername.GetBuffer(INTERNET_MAX_USER_NAME_LENGTH+1);
	urlComponents.dwPasswordLength = INTERNET_MAX_PASSWORD_LENGTH;
	urlComponents.lpszPassword = strPassword.GetBuffer(INTERNET_MAX_PASSWORD_LENGTH+1);

	BOOL bRetVal = _AfxParseURLWorker(pstrURL, &urlComponents,
					dwServiceType, nPort, dwFlags);

	strServer.ReleaseBuffer();
	strObject.ReleaseBuffer();
	strUsername.ReleaseBuffer();
	strPassword.ReleaseBuffer();
	return bRetVal;
}

BOOL AFXAPI AfxParseURL(LPCTSTR pstrURL, DWORD& dwServiceType,
	CString& strServer, CString& strObject, INTERNET_PORT& nPort)
{
	dwServiceType = AFX_INET_SERVICE_UNK;

	ASSERT(pstrURL != NULL);
	if (pstrURL == NULL)
		return FALSE;

	URL_COMPONENTS urlComponents;
	memset(&urlComponents, 0, sizeof(URL_COMPONENTS));
	urlComponents.dwStructSize = sizeof(URL_COMPONENTS);

	urlComponents.dwHostNameLength = INTERNET_MAX_URL_LENGTH;
	urlComponents.lpszHostName = strServer.GetBuffer(INTERNET_MAX_URL_LENGTH+1);
	urlComponents.dwUrlPathLength = INTERNET_MAX_URL_LENGTH;
	urlComponents.lpszUrlPath = strObject.GetBuffer(INTERNET_MAX_URL_LENGTH+1);

	BOOL bRetVal = _AfxParseURLWorker(pstrURL, &urlComponents,
					dwServiceType, nPort, ICU_BROWSER_MODE);

	strServer.ReleaseBuffer();
	strObject.ReleaseBuffer();
	return bRetVal;
}


DWORD AFXAPI AfxGetInternetHandleType(HINTERNET hQuery)
{
	DWORD dwServiceType;
	DWORD dwTypeLen = sizeof(dwServiceType);
	if (hQuery == NULL ||
		!InternetQueryOption(hQuery, INTERNET_OPTION_HANDLE_TYPE,
			&dwServiceType, &dwTypeLen))
		return AFX_INET_SERVICE_UNK;
	else
		return dwServiceType;
}

AFX_STATIC BOOL AFXAPI 
_AfxQueryCStringInternetOption(HINTERNET hHandle, DWORD dwOption, CString& refString)
{
	DWORD dwLength = 0;
	LPTSTR pstrBuffer;

	if (hHandle == NULL)
		return FALSE;

	if (!InternetQueryOption(hHandle, dwOption, NULL, &dwLength) &&
		GetLastError() != ERROR_INSUFFICIENT_BUFFER)
	{
		refString.Empty();
		return FALSE;
	}

	pstrBuffer = refString.GetBuffer(dwLength);
	BOOL bRet = InternetQueryOption(hHandle, dwOption, pstrBuffer, &dwLength);
	refString.ReleaseBuffer();
	return bRet;
}

#ifdef _DEBUG
void AFXAPI AfxInternetStatusCallbackDebug(HINTERNET hInternet,
	DWORD_PTR dwContext, DWORD dwInternetStatus, LPVOID lpvStatusInformation,
	DWORD dwStatusInformationLength)
{
	UNUSED_ALWAYS(hInternet);
	TRACE(traceInternet, 1, "Internet ctxt=%d: ", dwContext);

	switch (dwInternetStatus)
	{
	case INTERNET_STATUS_RESOLVING_NAME:
		TRACE(traceInternet, 1, _T("resolving name for %s\n"), lpvStatusInformation);
		break;

	case INTERNET_STATUS_NAME_RESOLVED:
		TRACE(traceInternet, 1, _T("resolved name for %s!\n"), lpvStatusInformation);
		break;

	case INTERNET_STATUS_HANDLE_CREATED:
		TRACE(traceInternet, 1, "handle %8.8X created\n", hInternet);
		break;

	case INTERNET_STATUS_CONNECTING_TO_SERVER:
		{
		sockaddr* pSockAddr = (sockaddr*) lpvStatusInformation;
		TRACE(traceInternet, 1, _T("connecting to socket address '%s'\n"), pSockAddr->sa_data);
		}
		break;

	case INTERNET_STATUS_REQUEST_SENT:
		TRACE(traceInternet, 1, "request sent!\n");
		break;

	case INTERNET_STATUS_SENDING_REQUEST:
		TRACE(traceInternet, 1, "sending request...\n");
		break;

	case INTERNET_STATUS_CONNECTED_TO_SERVER:
		TRACE(traceInternet, 1, "connected to socket address!\n");
		break;

	case INTERNET_STATUS_RECEIVING_RESPONSE:
		TRACE(traceInternet, 1, "receiving response...\n");
		break;

	case INTERNET_STATUS_RESPONSE_RECEIVED:
		TRACE(traceInternet, 1, "response received!\n");
		break;

	case INTERNET_STATUS_CLOSING_CONNECTION:
		TRACE(traceInternet, 1, "closing connection %8.8X\n", hInternet);
		break;

	case INTERNET_STATUS_CONNECTION_CLOSED:
		TRACE(traceInternet, 1, "connection %8.8X closed!\n", hInternet);
		break;

	case INTERNET_STATUS_HANDLE_CLOSING:
		TRACE(traceInternet, 1, "handle %8.8X closed!\n", hInternet);
		break;

	case INTERNET_STATUS_REQUEST_COMPLETE:
		if (dwStatusInformationLength == sizeof(INTERNET_ASYNC_RESULT))
		{
			INTERNET_ASYNC_RESULT* pResult = (INTERNET_ASYNC_RESULT*) lpvStatusInformation;
			TRACE(traceInternet, 1, "request complete, dwResult = %8.8X, dwError = %8.8X\n",
				pResult->dwResult, pResult->dwError);
		}
		else
			TRACE(traceInternet, 1, "request complete.\n");
		break;

	case INTERNET_STATUS_CTL_RESPONSE_RECEIVED:
	case INTERNET_STATUS_REDIRECT:
	default:
		TRACE(traceInternet, 1, "Unknown status: %d\n", dwInternetStatus);
		break;
	}
}
#endif // _DEBUG

void AFXAPI AfxInternetStatusCallback(HINTERNET hInternet, DWORD_PTR dwContext,
	DWORD dwInternetStatus, LPVOID lpvStatusInformation,
	DWORD dwStatusInformationLength)
{
	CInternetSession* pSession;

#ifdef _DEBUG
	AfxInternetStatusCallbackDebug(hInternet, dwContext,
		dwInternetStatus, lpvStatusInformation, dwStatusInformationLength);
#endif

	if (_afxSessionMap.Lookup(hInternet, pSession))
	{
		pSession->OnStatusCallback(dwContext, dwInternetStatus,
			lpvStatusInformation, dwStatusInformationLength);
	}

	// note that an entry we can't match is simply ignored as
	// WININET can send notifications for handles that we can't
	// see -- such as when using InternetOpenURL()
}


/////////////////////////////////////////////////////////////////////////////
// CInternetSession

CInternetSession::~CInternetSession()
{
	Close();
}

CInternetSession::CInternetSession(LPCTSTR pstrAgent /* = NULL */,
	DWORD_PTR dwContext /* = 1 */,
	DWORD dwAccessType /* = PRE_CONFIG_INTERNET_ACCESS */,
	LPCTSTR pstrProxyName /* = NULL */,
	LPCTSTR pstrProxyBypass /* = NULL */,
	DWORD dwFlags /* = 0 */)
{
	ASSERT((dwFlags & INTERNET_FLAG_ASYNC) == 0);
	m_bCallbackEnabled = FALSE;
	m_pOldCallback = NULL;

	m_dwContext = dwContext;
	if (pstrAgent == NULL)
		pstrAgent = AfxGetAppName();
	m_hSession = InternetOpen(pstrAgent, dwAccessType,
		pstrProxyName, pstrProxyBypass, dwFlags);

	if (m_hSession == NULL)
		AfxThrowInternetException(m_dwContext);
	else
		_afxSessionMap.SetAt(m_hSession, this);
}

void CInternetSession::Close()
{
	if (m_bCallbackEnabled)
		EnableStatusCallback(FALSE);

	if (m_hSession != NULL)
	{
		InternetCloseHandle(m_hSession);
		_afxSessionMap.RemoveKey(m_hSession);
		m_hSession = NULL;
	}
}

CGopherConnection* CInternetSession::GetGopherConnection(LPCTSTR pstrServer,
	LPCTSTR pstrUserName /* = NULL */, LPCTSTR pstrPassword /* = NULL */,
	INTERNET_PORT nPort /* = INTERNET_INVALID_PORT_NUMBER */)
{
	ASSERT(AfxIsValidString(pstrServer));

	CGopherConnection* pResult = new CGopherConnection(this,
		pstrServer, pstrUserName, pstrPassword, m_dwContext, nPort);
	return pResult;
}

CFtpConnection* CInternetSession::GetFtpConnection(LPCTSTR pstrServer,
	LPCTSTR pstrUserName /* = NULL */, LPCTSTR pstrPassword /* = NULL */,
	INTERNET_PORT nPort /* = INTERNET_INVALID_PORT_NUMBER */,
	BOOL bPassive /* = FALSE */)
{
	ASSERT(AfxIsValidString(pstrServer));

	CFtpConnection* pResult = new CFtpConnection(this,
		pstrServer, pstrUserName, pstrPassword, m_dwContext,
		nPort, bPassive);
	return pResult;
}

CHttpConnection* CInternetSession::GetHttpConnection(LPCTSTR pstrServer,
	INTERNET_PORT nPort /* = INTERNET_INVALID_PORT_NUMBER */,
	LPCTSTR pstrUserName /* = NULL */, LPCTSTR pstrPassword /* = NULL */)
{
	ASSERT(AfxIsValidString(pstrServer));

	CHttpConnection* pResult = new CHttpConnection(this,
		pstrServer, nPort, pstrUserName, pstrPassword, m_dwContext);
	return pResult;
}

CHttpConnection* CInternetSession::GetHttpConnection(LPCTSTR pstrServer,
	DWORD dwFlags, INTERNET_PORT nPort /* = INTERNET_INVALID_PORT_NUMBER */,
	LPCTSTR pstrUserName /* = NULL */, LPCTSTR pstrPassword /* = NULL */)
{
	ASSERT(AfxIsValidString(pstrServer));
	ASSERT((dwFlags & INTERNET_FLAG_ASYNC) == 0);

	CHttpConnection* pResult = new CHttpConnection(this, pstrServer,
			dwFlags, nPort, pstrUserName, pstrPassword, m_dwContext);
	return pResult;
}

CStdioFile* CInternetSession::OpenURL(LPCTSTR pstrURL,
	DWORD_PTR dwContext /* = 0 */, DWORD dwFlags /* = INTERNET_FLAG_TRANSFER_BINARY */,
	LPCTSTR pstrHeaders /* = NULL */, DWORD dwHeadersLength /* = 0 */)
{
	ASSERT(AfxIsValidString(pstrURL));
	ASSERT(dwHeadersLength == 0 || pstrHeaders != NULL);
	ASSERT((dwFlags & INTERNET_FLAG_ASYNC) == 0);

	// must have TRANSFER_BINARY or TRANSFER_ASCII but not both
#define _AFX_TRANSFER_MASK (INTERNET_FLAG_TRANSFER_BINARY | INTERNET_FLAG_TRANSFER_ASCII)
	ASSERT((dwFlags & _AFX_TRANSFER_MASK) != 0);
	ASSERT((dwFlags & _AFX_TRANSFER_MASK) != _AFX_TRANSFER_MASK);

	if (dwContext == 1)
		dwContext = m_dwContext;

	DWORD dwServiceType;
	CString strServer;
	CString strObject;
	INTERNET_PORT nPort;
	CStdioFile* pResult;

	BOOL bParsed = AfxParseURL(pstrURL, dwServiceType, strServer, strObject, nPort);

	// if it turns out to be a file...
	if (bParsed && dwServiceType == AFX_INET_SERVICE_FILE)
	{
		ENSURE( INTERNET_MAX_URL_LENGTH >= strObject.GetLength() );

		DWORD dwUnescapedUrlLen = INTERNET_MAX_URL_LENGTH+1;
		CString strUnescapedUrl;
		LPTSTR pstrUnescapedUrl = strUnescapedUrl.GetBuffer(INTERNET_MAX_URL_LENGTH+1);

		HRESULT hr = UrlUnescape((LPTSTR)((LPCTSTR)strObject),
								pstrUnescapedUrl,
								&dwUnescapedUrlLen,
								URL_DONT_UNESCAPE_EXTRA_INFO);

		strUnescapedUrl.ReleaseBuffer();

		if (FAILED(hr))
			AfxThrowInternetException(m_dwContext, hr);

		int nMode = CFile::modeRead | CFile::shareCompat;
		if (dwFlags & INTERNET_FLAG_TRANSFER_BINARY)
			nMode |= CFile::typeBinary;
		else
			nMode |= CFile::typeText;

		pResult = new CStdioFile(strUnescapedUrl, nMode);
	}
	else
	{
		HINTERNET hOpener;

		hOpener = InternetOpenUrl(m_hSession, pstrURL, pstrHeaders,
			dwHeadersLength, dwFlags, dwContext);

		if (hOpener == NULL)
			AfxThrowInternetException(m_dwContext);

		if (!bParsed)
			dwServiceType = AfxGetInternetHandleType(hOpener);

		switch (dwServiceType)
		{
			case INTERNET_HANDLE_TYPE_GOPHER_FILE:
			case AFX_INET_SERVICE_GOPHER:
			// WININET supplies no way to convert from a URL to a Gopher locator
				pResult = new CGopherFile(hOpener, m_hSession, _T(""),
					0, dwContext);
				_afxSessionMap.SetAt(hOpener, this);
				break;

			case INTERNET_HANDLE_TYPE_FTP_FILE:
			case AFX_INET_SERVICE_FTP:
				pResult = new CInternetFile(hOpener, m_hSession, strObject,
					strServer, dwContext, TRUE);
				_afxSessionMap.SetAt(hOpener, this);
				break;

			case INTERNET_HANDLE_TYPE_HTTP_REQUEST:
			case AFX_INET_SERVICE_HTTP:
			case AFX_INET_SERVICE_HTTPS:
				pResult = new CHttpFile(hOpener, m_hSession, strObject, strServer,
					CHttpConnection::szHtmlVerbs[CHttpConnection::HTTP_VERB_GET],
					dwContext);
				_afxSessionMap.SetAt(hOpener, this);
				break;

			default:
				TRACE(traceInternet, 0, "Error: Unidentified service type: %8.8X\n", dwServiceType);
				pResult = NULL;
		}
	}

	return pResult;
}

BOOL CInternetSession::SetOption(DWORD dwOption, LPVOID lpBuffer,
	DWORD dwBufferLength, DWORD dwFlags /* = 0 */)
{
	ASSERT(AfxIsValidAddress(lpBuffer, dwBufferLength, FALSE));
	ASSERT(dwOption >= INTERNET_FIRST_OPTION &&
		dwOption <= INTERNET_LAST_OPTION);
	ASSERT(dwBufferLength != 0);
	ASSERT((dwFlags & INTERNET_FLAG_ASYNC) == 0);

	// bogus flag?
	ASSERT(dwFlags == 0 || ((dwFlags & ISO_VALID_FLAGS) == dwFlags));

	return InternetSetOptionEx(m_hSession, dwOption,
		lpBuffer, dwBufferLength, dwFlags);
}

BOOL CInternetSession::QueryOption(DWORD dwOption, LPVOID lpBuffer,
	LPDWORD lpdwBufferLength) const
{
	ASSERT(dwOption >= INTERNET_FIRST_OPTION &&
		dwOption <= INTERNET_LAST_OPTION);
	ASSERT_POINTER(lpdwBufferLength, DWORD);
	ASSERT(AfxIsValidAddress(lpBuffer, *lpdwBufferLength));
	ASSERT(*lpdwBufferLength != 0);

	return InternetQueryOption(m_hSession, dwOption,
		lpBuffer, lpdwBufferLength);
}

BOOL CInternetSession::QueryOption(DWORD dwOption, DWORD& dwValue) const
{
	DWORD dwLen = sizeof(DWORD);
	return InternetQueryOption(m_hSession, dwOption,
		&dwValue, &dwLen);
}

void CInternetSession::OnStatusCallback(DWORD_PTR dwContext,
	DWORD dwInternetStatus, LPVOID lpvStatusInformation,
	DWORD dwStatusInformationLength)
{
	ASSERT(m_bCallbackEnabled != NULL);

	if (m_pOldCallback != NULL)
	{
		(*m_pOldCallback)(m_hSession, dwContext, dwInternetStatus,
			lpvStatusInformation, dwStatusInformationLength);
	}
}

BOOL CInternetSession::EnableStatusCallback(BOOL bEnable /* = TRUE */)
{
	ASSERT(!bEnable || m_hSession != NULL);
	if (m_hSession == NULL)
		return FALSE;

	BOOL bResult = TRUE;

	if (bEnable)
	{
		ASSERT(!m_bCallbackEnabled);
		if (!m_bCallbackEnabled)
		{
			INTERNET_STATUS_CALLBACK pRet =
				InternetSetStatusCallback(m_hSession, AfxInternetStatusCallback);

			if (pRet != INTERNET_INVALID_STATUS_CALLBACK)
			{
				m_pOldCallback = pRet;
				m_bCallbackEnabled = TRUE;
			}
			else
				AfxThrowInternetException(m_dwContext);
		}
	}
	else
	{
		ASSERT(m_bCallbackEnabled);

		if (m_bCallbackEnabled)
		{
			InternetSetStatusCallback(m_hSession, NULL);
			m_bCallbackEnabled = FALSE;
		}
	}

	return bResult;
}

BOOL CInternetSession::SetCookie(LPCTSTR pstrUrl, LPCTSTR pstrCookieName, LPCTSTR pstrCookieData)
{
	ASSERT(AfxIsValidString(pstrUrl));
	ASSERT(AfxIsValidString(pstrCookieName));
	return InternetSetCookie(pstrUrl, pstrCookieName, pstrCookieData);
}

BOOL CInternetSession::GetCookie(_In_z_ LPCTSTR pstrUrl, _In_z_ LPCTSTR pstrCookieName, _Out_z_cap_(dwBufLen) LPTSTR pstrCookieData, _In_ DWORD dwBufLen)
{
	ASSERT(AfxIsValidString(pstrUrl));
	ASSERT(AfxIsValidString(pstrCookieName));
	ASSERT(pstrCookieData != NULL);
	return InternetGetCookie(pstrUrl, pstrCookieName, pstrCookieData, &dwBufLen);
}

DWORD CInternetSession::GetCookieLength(LPCTSTR pstrUrl, LPCTSTR pstrCookieName)
{
	ASSERT(AfxIsValidString(pstrUrl));
	ASSERT(AfxIsValidString(pstrCookieName));

	DWORD dwRet;
	if (!InternetGetCookie(pstrUrl, pstrCookieName, NULL, &dwRet))
		dwRet = 0;
	return dwRet;
}

BOOL CInternetSession::GetCookie(LPCTSTR pstrUrl, LPCTSTR pstrCookieName, CString& strCookieData)
{
	ASSERT(AfxIsValidString(pstrUrl));
	ASSERT(AfxIsValidString(pstrCookieName));

	DWORD dwLen = GetCookieLength(pstrUrl, pstrCookieName);

	LPTSTR pstrTarget = strCookieData.GetBuffer(dwLen+1);
	BOOL bRetVal = InternetGetCookie(pstrUrl, pstrCookieName, pstrTarget, &dwLen);
	strCookieData.ReleaseBuffer(dwLen);

	if (!bRetVal)
		strCookieData.Empty();
	return bRetVal;
}

#ifdef _DEBUG
void CInternetSession::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);
	dc << "m_hSession = " << m_hSession;
	dc << "\nm_dwContext = " << m_dwContext;
}
#endif


/////////////////////////////////////////////////////////////////////////////
// Internet Files

CInternetFile::CInternetFile(HINTERNET hFile, HINTERNET /* hSession */,
	LPCTSTR pstrFileName, LPCTSTR pstrServer, DWORD_PTR dwContext, BOOL bReadMode)
	: m_dwContext(dwContext)
{
	// caller must set _afxSessionMap()!

	ASSERT(AfxIsValidString(pstrServer));
	ASSERT(AfxIsValidString(pstrFileName));
	ASSERT(hFile != NULL);

	m_strFileName = pstrFileName;
	m_strServerName = pstrServer;

	m_hFile = hFile;
	m_bReadMode = bReadMode;

	m_pbReadBuffer = NULL;
	m_pbWriteBuffer = NULL;

	m_nReadBufferSize = 0;
	m_nReadBufferPos = 0;
	m_nWriteBufferSize = 0;
	m_nWriteBufferPos = 0;
	m_nReadBufferBytes = 0;
}

CInternetFile::CInternetFile(HINTERNET hFile,
	LPCTSTR pstrFileName, CInternetConnection* pConnection, BOOL bReadMode)
{
	ASSERT(AfxIsValidString(pstrFileName));
	ASSERT(pConnection != NULL);
	ASSERT_VALID(pConnection);
	ASSERT(hFile != NULL);

	_afxSessionMap.SetAt(hFile, pConnection->GetSession());

	m_strFileName = pstrFileName;

	m_dwContext = pConnection->GetContext();
	m_strServerName = pConnection->GetServerName();
	m_hFile = hFile;
	m_bReadMode = bReadMode;

	m_pbReadBuffer = NULL;
	m_pbWriteBuffer = NULL;

	m_nReadBufferSize = 0;
	m_nReadBufferPos = 0;
	m_nWriteBufferSize = 0;
	m_nWriteBufferPos = 0;
	m_nReadBufferBytes = 0;
}

BOOL CInternetFile::QueryOption(DWORD dwOption, LPVOID lpBuffer,
	LPDWORD lpdwBufferLength) const
{
	ASSERT(dwOption >= INTERNET_FIRST_OPTION &&
		dwOption <= INTERNET_LAST_OPTION);
	ASSERT_POINTER(lpdwBufferLength, DWORD);
	ASSERT(AfxIsValidAddress(lpBuffer, *lpdwBufferLength));
	ASSERT(*lpdwBufferLength != 0);
	ASSERT(m_hFile != NULL);

	return InternetQueryOption(m_hFile, dwOption,
		lpBuffer, lpdwBufferLength);
}

BOOL CInternetFile::QueryOption(DWORD dwOption, DWORD& dwValue) const
{
	ASSERT(m_hFile != NULL);

	DWORD dwLen = sizeof(DWORD);
	return InternetQueryOption(m_hFile, dwOption,
		&dwValue, &dwLen);
}

BOOL CInternetFile::SetOption(DWORD dwOption, LPVOID lpBuffer,
	DWORD dwBufferLength, DWORD dwFlags /* = 0 */)
{
	ASSERT(dwOption >= INTERNET_FIRST_OPTION &&
		dwOption <= INTERNET_LAST_OPTION);
	ASSERT(AfxIsValidAddress(lpBuffer, dwBufferLength, FALSE));
	ASSERT(dwBufferLength != 0);
	ASSERT((dwFlags & INTERNET_FLAG_ASYNC) == 0);

	// bogus flag?
	ASSERT(dwFlags == 0 || ((dwFlags & ISO_VALID_FLAGS) == dwFlags));

	return InternetSetOptionEx(m_hFile, dwOption,
		lpBuffer, dwBufferLength, dwFlags);
}

BOOL CInternetFile::SetReadBufferSize(UINT nReadSize)
{
	ASSERT_VALID(this);
	BOOL bRet = TRUE;

	if (nReadSize != -1 && nReadSize != m_nReadBufferSize)
	{
		if (m_nReadBufferPos > nReadSize)
			bRet = FALSE;
		else
		{
			if (nReadSize == 0)
			{
				delete [] m_pbReadBuffer;
				m_pbReadBuffer = NULL;
			}
			else if (m_pbReadBuffer == NULL)
			{
				m_pbReadBuffer = new BYTE[nReadSize];
				m_nReadBufferPos = nReadSize;
			}
			else
			{
				DWORD dwMoved = m_nReadBufferSize - m_nReadBufferPos;
				LPBYTE pbTemp = m_pbReadBuffer;
				m_pbReadBuffer = new BYTE[nReadSize];

				if (dwMoved > 0 && dwMoved <= nReadSize)
				{
					Checked::memcpy_s(m_pbReadBuffer, nReadSize, 
						pbTemp + m_nReadBufferPos, dwMoved);

					m_nReadBufferPos = 0;
					m_nReadBufferBytes = dwMoved;
				}
				else
				{
					m_nReadBufferBytes = 0;
					m_nReadBufferPos = nReadSize;
				}
				delete [] pbTemp;
			}

			m_nReadBufferSize = nReadSize;
		}
	}

	return bRet;
}

BOOL CInternetFile::SetWriteBufferSize(UINT nWriteSize)
{
	ASSERT_VALID(this);
	BOOL bRet = TRUE;

	if (nWriteSize != m_nWriteBufferSize)
	{
		if (m_nWriteBufferPos > nWriteSize)
			Flush();

		if (nWriteSize == 0)
		{
			delete [] m_pbWriteBuffer;
			m_pbWriteBuffer = NULL;
		}
		else if (m_pbWriteBuffer == NULL)
		{
			m_pbWriteBuffer = new BYTE[nWriteSize];
			m_nWriteBufferPos = 0;
		}
		else
		{
			LPBYTE pbTemp = m_pbWriteBuffer;
			m_pbWriteBuffer = new BYTE[nWriteSize];
			if (m_nWriteBufferPos <= nWriteSize)
			{
				Checked::memcpy_s(m_pbWriteBuffer, nWriteSize, 
					pbTemp, m_nWriteBufferPos);
			}
			delete [] pbTemp;
		}

		m_nWriteBufferSize = nWriteSize;
	}

	return bRet;
}

ULONGLONG CInternetFile::Seek(LONGLONG lOffset, UINT nFrom)
{
	ASSERT_VALID(this);
	ASSERT(m_hFile != NULL);
	ASSERT(m_bReadMode);
	ASSERT(m_pbReadBuffer == NULL);

	// can't do this on a file for writing
	// can't do this on a file that's got a buffer

	if (!m_bReadMode || m_pbReadBuffer != NULL)
		AfxThrowInternetException(m_dwContext, ERROR_INVALID_HANDLE);

	switch (nFrom)
	{
		case begin:
			nFrom = FILE_BEGIN;
			break;

		case current:
			nFrom = FILE_CURRENT;
			break;

		case end:
			nFrom = FILE_END;
			break;

		default:
			ASSERT(FALSE);  // got a bogus nFrom value
			AfxThrowInternetException(m_dwContext, ERROR_INVALID_PARAMETER);
			break;
	}

   if ((lOffset < LONG_MIN) || (lOffset > LONG_MAX))
   {
	  AfxThrowInternetException(m_dwContext, ERROR_INVALID_PARAMETER);
   }

	LONG lRet;
	lRet = InternetSetFilePointer(m_hFile, LONG(lOffset), NULL, nFrom, 
	  m_dwContext);
	if (lRet == -1)
		AfxThrowInternetException(m_dwContext);

	return lRet;
}

CInternetFile::~CInternetFile()
{
	if (m_hFile != NULL)
	{
#ifdef _DEBUG
		const CString strName(GetRuntimeClass()->m_lpszClassName);		
		TRACE(traceInternet, 0, _T("Warning: destroying an open %s with handle %8.8X\n"),
			strName.GetString(), m_hFile);
#endif
		Close();
	}

	if (m_pbReadBuffer != NULL)
		delete m_pbReadBuffer;

	if (m_pbWriteBuffer != NULL)
		delete m_pbWriteBuffer;
}

void CInternetFile::Abort()
{
	ASSERT_VALID(this);
	if (m_hFile != NULL)
		Close();
	m_strFileName.Empty();
}

void CInternetFile::Flush()
{
	if (m_pbWriteBuffer != NULL && m_nWriteBufferPos > 0)
	{
		DWORD dwBytes;

		if (!InternetWriteFile(m_hFile, m_pbWriteBuffer,
				m_nWriteBufferPos, &dwBytes))
			AfxThrowInternetException(m_dwContext);

		if (dwBytes != m_nWriteBufferPos)
			AfxThrowInternetException(m_dwContext);

		m_nWriteBufferPos = 0;
	}
}

void CInternetFile::Close()
{
	if (m_hFile != NULL)
	{
		Flush();
		InternetCloseHandle(m_hFile);
		_afxSessionMap.RemoveKey(m_hFile);
		m_hFile = NULL;

		if (m_pbWriteBuffer != NULL)
		{
			delete [] m_pbWriteBuffer;
			m_pbWriteBuffer = NULL;
		}

		if (m_pbReadBuffer != NULL)
		{
			delete [] m_pbReadBuffer;
			m_pbReadBuffer = NULL;
		}
	}
}

UINT CInternetFile::Read(LPVOID lpBuf, UINT nCount)
{
	ASSERT_VALID(this);
	ASSERT(AfxIsValidAddress(lpBuf, nCount));
	ASSERT(m_hFile != NULL);
	ASSERT(m_bReadMode);

	DWORD dwBytes;

	if (!m_bReadMode || m_hFile == NULL)
		AfxThrowInternetException(m_dwContext, ERROR_INVALID_HANDLE);

	if (m_pbReadBuffer == NULL)
	{
		if (!InternetReadFile(m_hFile, (LPVOID) lpBuf, nCount, &dwBytes))
				AfxThrowInternetException(m_dwContext);
		return dwBytes;
	}

	LPBYTE lpbBuf = (LPBYTE) lpBuf;

	// if the requested size is bigger than our buffer,
	// then handle it directly

	if (nCount >= m_nReadBufferSize)
	{
		DWORD dwMoved = max(0, (long)m_nReadBufferBytes - (long)m_nReadBufferPos);
		if (dwMoved <= nCount)
		{
			Checked::memcpy_s(lpBuf, nCount, 
				m_pbReadBuffer + m_nReadBufferPos, dwMoved);
		}
		else
		{
			return 0; // output buffer not big enough.
		}

		m_nReadBufferPos = m_nReadBufferSize;
		if (!InternetReadFile(m_hFile, lpbBuf+dwMoved, nCount-dwMoved, &dwBytes))
				AfxThrowInternetException(m_dwContext);
		dwBytes += dwMoved;
	}
	else
	{
		if (m_nReadBufferPos + nCount >= m_nReadBufferBytes)
		{
			DWORD dwMoved = max(0, (long)m_nReadBufferBytes - (long)m_nReadBufferPos);
			if (dwMoved <= nCount)
			{
				Checked::memcpy_s(lpbBuf, nCount, 
					m_pbReadBuffer + m_nReadBufferPos, dwMoved);
			}
			else
			{
				return 0;
			}

			DWORD dwRead;
			if (!InternetReadFile(m_hFile, m_pbReadBuffer, m_nReadBufferSize,
					&dwRead))
				AfxThrowInternetException(m_dwContext);
			m_nReadBufferBytes = dwRead;

			dwRead = min(nCount - dwMoved, m_nReadBufferBytes);
			Checked::memcpy_s(lpbBuf + dwMoved, nCount - dwMoved, m_pbReadBuffer, dwRead);
			m_nReadBufferPos = dwRead;
			dwBytes = dwMoved + dwRead;
		}
		else
		{
			Checked::memcpy_s(lpbBuf, nCount, m_pbReadBuffer + m_nReadBufferPos, nCount);
			m_nReadBufferPos += nCount;
			dwBytes = nCount;
		}
	}

	return dwBytes;
}

void CInternetFile::Write(const void* lpBuf, UINT nCount)
{
	ASSERT_VALID(this);
	ASSERT(m_hFile != NULL);
	ASSERT(AfxIsValidAddress(lpBuf, nCount, FALSE));
	ASSERT(m_bReadMode == FALSE || m_bReadMode == -1);

	if (m_bReadMode == TRUE || m_hFile == NULL)
		AfxThrowInternetException(m_dwContext, ERROR_INVALID_HANDLE);

	DWORD dwBytes;
	if (m_pbWriteBuffer == NULL)
	{
		if (!InternetWriteFile(m_hFile, lpBuf, nCount, &dwBytes))
			AfxThrowInternetException(m_dwContext);

		if (dwBytes != nCount)
			AfxThrowInternetException(m_dwContext);
	}
	else
	{
		if ((m_nWriteBufferPos + nCount) >= m_nWriteBufferSize)
		{
			// write what is in the buffer just now

			if (!InternetWriteFile(m_hFile, m_pbWriteBuffer,
					m_nWriteBufferPos, &dwBytes))
				AfxThrowInternetException(m_dwContext);

			// reset the buffer position since it is now clean

			m_nWriteBufferPos = 0;
		}

		// if we can't hope to buffer the write request,
		// do it immediately ... otherwise, buffer it!

		if (nCount >= m_nWriteBufferSize)
		{
			if (!InternetWriteFile(m_hFile, (LPVOID) lpBuf, nCount, &dwBytes))
				AfxThrowInternetException(m_dwContext);
		}
		else
		{
			if (m_nWriteBufferPos + nCount <= m_nWriteBufferSize)
			{
				Checked::memcpy_s(m_pbWriteBuffer + m_nWriteBufferPos, 
					m_nWriteBufferSize - m_nWriteBufferPos, lpBuf, nCount);
				m_nWriteBufferPos += nCount;
			}
		}
	}
}

void CInternetFile::WriteString(LPCTSTR pstr)
{
	ASSERT(m_bReadMode == FALSE || m_bReadMode == -1);
	ASSERT(AfxIsValidString(pstr));
	ASSERT_VALID(this);
	ASSERT(m_hFile != NULL);

	if (m_bReadMode == TRUE)
		AfxThrowInternetException(m_dwContext, ERROR_INVALID_HANDLE);

	Write(pstr, lstrlen(pstr) * sizeof(TCHAR));
}

LPTSTR CInternetFile::ReadString(_Out_z_cap_(nMax) LPTSTR pstr, _In_ UINT nMax)
{
	ASSERT_VALID(this);
	ASSERT(m_hFile != NULL);
	ASSERT(AfxIsValidAddress(pstr, nMax*sizeof(TCHAR)));
	DWORD dwRead;

	// if we're reading line-by-line, we must have a buffer

	if (m_pbReadBuffer == NULL)
	{
		if (!SetReadBufferSize(4096))   // arbitrary but reasonable
			return NULL;
		if (!InternetReadFile(m_hFile, m_pbReadBuffer, m_nReadBufferSize,
				&dwRead))
			AfxThrowInternetException(m_dwContext);
		m_nReadBufferBytes = dwRead;
		m_nReadBufferPos = 0;
	}

	LPSTR pstrChar = (LPSTR) (m_pbReadBuffer + m_nReadBufferPos);
	LPSTR pstrTarget = (LPSTR)pstr;

	UINT nMaxChars = (nMax-1)*sizeof(TCHAR);
	while (nMaxChars)
	{
		if (m_nReadBufferPos >= m_nReadBufferBytes)
		{
			if (!InternetReadFile(m_hFile, m_pbReadBuffer, m_nReadBufferSize,
					&dwRead))
				AfxThrowInternetException(m_dwContext);
			m_nReadBufferBytes = dwRead;
			if (m_nReadBufferBytes == 0)
			{
				memset(pstrTarget, 0, (nMaxChars & (sizeof(TCHAR)-1)) + sizeof(TCHAR));
				if (pstrTarget == (LPCSTR)pstr)
					return NULL;
				else
					return pstr;
			}
			else
			{
				m_nReadBufferPos = 0;
				pstrChar = (LPSTR) m_pbReadBuffer;
			}
		}

		if (*pstrChar != '\r')
		{
			*pstrTarget++ = *pstrChar;
			nMaxChars--;
		}

		m_nReadBufferPos++;
		if (*pstrChar++ == '\n')
			break;
	}

	memset(pstrTarget, 0, (nMaxChars & (sizeof(TCHAR)-1)) + sizeof(TCHAR));
	return pstr;
}

BOOL CInternetFile::ReadString(CString& rString)
{
	ASSERT_VALID(this);
	ASSERT(m_hFile != NULL);

	rString = _T("");    // empty string without deallocating
	const int nMaxSize = 128;

	LPTSTR pstrPlace = rString.GetBuffer(nMaxSize);
	LPTSTR pstrResult;

	int nLen;

	do
	{
		pstrResult = ReadString(pstrPlace, nMaxSize);
		rString.ReleaseBuffer();

		// if string is read completely or EOF
		if (pstrResult == NULL ||
			(nLen = lstrlen(pstrPlace)) < (nMaxSize-1) ||
			pstrPlace[nLen-1] == '\n')
			break;

		nLen = rString.GetLength();
		pstrPlace = rString.GetBuffer(nMaxSize + nLen) + nLen;
	} while (1);

	// remove '\n' from end of string if present
	pstrPlace = rString.GetBuffer(0);
	nLen = rString.GetLength();
	if (nLen != 0 && pstrPlace[nLen-1] == '\n')
		pstrPlace[nLen-1] = '\0';
	rString.ReleaseBuffer();

	return ( (pstrResult != NULL) || (nLen != 0 ) );
}

ULONGLONG CInternetFile::GetLength() const
{
	ASSERT_VALID(this);
	ASSERT(m_hFile != NULL);

	DWORD dwRet = 0;

	if (m_hFile != NULL)
	{
		if (!InternetQueryDataAvailable(m_hFile, &dwRet, 0, 0))
			dwRet = 0;
	}

	return dwRet;
}

void CInternetFile::LockRange(ULONGLONG /* dwPos */, ULONGLONG /* dwCount */)
{
	ASSERT_VALID(this);
	ASSERT(m_hFile != NULL);

	AfxThrowNotSupportedException();
}

void CInternetFile::UnlockRange(ULONGLONG /* dwPos */, ULONGLONG /* dwCount */)
{
	ASSERT_VALID(this);
	ASSERT(m_hFile != NULL);

	AfxThrowNotSupportedException();
}

void CInternetFile::SetLength(ULONGLONG)
{
	ASSERT_VALID(this);
	ASSERT(m_hFile != NULL);

	AfxThrowNotSupportedException();
}

CFile* CInternetFile::Duplicate() const
{
	ASSERT_VALID(this);
	ASSERT(m_pStream != NULL);

	AfxThrowNotSupportedException();
}

#ifdef _DEBUG
void CInternetFile::AssertValid() const
{
	// Don't call CStdioFile's AsssertValid()
	CFile::AssertValid();

	ASSERT(m_hConnection != NULL);

	// make sure we really have a decent handle
	if (m_hFile != NULL)
	{
		DWORD dwResult = AfxGetInternetHandleType(m_hFile);

		if (IsKindOf(RUNTIME_CLASS(CHttpFile)))
		{
			ASSERT(dwResult == INTERNET_HANDLE_TYPE_HTTP_REQUEST);
		}
		else if (IsKindOf(RUNTIME_CLASS(CGopherFile)))
		{
			ASSERT(dwResult == INTERNET_HANDLE_TYPE_GOPHER_FILE ||
				dwResult == INTERNET_HANDLE_TYPE_GOPHER_FIND_HTML ||
				dwResult == INTERNET_HANDLE_TYPE_GOPHER_FILE_HTML ||
				dwResult == INTERNET_HANDLE_TYPE_HTTP_REQUEST);
		}
		else if (IsKindOf(RUNTIME_CLASS(CInternetFile)))
		{
			ASSERT(dwResult == INTERNET_HANDLE_TYPE_FTP_FILE ||
				dwResult == INTERNET_HANDLE_TYPE_FTP_FILE_HTML ||
				dwResult == INTERNET_HANDLE_TYPE_FTP_FIND_HTML ||
				dwResult == INTERNET_HANDLE_TYPE_HTTP_REQUEST);
		}
		else
			ASSERT(FALSE);  // some bogus object!
	}
}

void CInternetFile::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	dc << "\na " << GetRuntimeClass()->m_lpszClassName;
	dc << " with handle " << m_hFile;
}
#endif

/////////////////////////////////////////////////////////////////////////////
// CInternetConnection

CInternetConnection::CInternetConnection(CInternetSession* pSession,
	LPCTSTR pstrServerName,
	INTERNET_PORT nPort /* = INTERNET_INVALID_PORT_NUMBER */,
	DWORD_PTR dwContext /* = 1 */)
	: m_strServerName(pstrServerName)
{
	ASSERT(pSession != NULL);
	ASSERT_VALID(pSession);
	ASSERT(pstrServerName != NULL);

	m_nPort = nPort;
	m_pSession = pSession;
	m_hConnection = NULL;
	if (dwContext == 1)
		dwContext = pSession->GetContext();
	m_dwContext = dwContext;
}

CInternetConnection::~CInternetConnection()
{
	if (m_hConnection != NULL)
	{
#ifdef _DEBUG
		const CString strName(GetRuntimeClass()->m_lpszClassName);
		TRACE(traceInternet, 0, _T("Warning: Disconnecting %s handle %8.8X in context %8.8X at destruction.\n"),
			strName.GetString(), m_hConnection, m_dwContext);
#endif
		Close();
	}
}

BOOL CInternetConnection::SetOption(DWORD dwOption, LPVOID lpBuffer,
	DWORD dwBufferLength, DWORD dwFlags /* = 0 */)
{
	ASSERT(dwOption >= INTERNET_FIRST_OPTION &&
		dwOption <= INTERNET_LAST_OPTION);
	ASSERT(AfxIsValidAddress(lpBuffer, dwBufferLength, FALSE));
	ASSERT(dwBufferLength != 0);
	ASSERT((dwFlags & INTERNET_FLAG_ASYNC) == 0);

	// bogus flag?
	ASSERT(dwFlags == 0 || ((dwFlags & ISO_VALID_FLAGS) == dwFlags));

	return InternetSetOptionEx(m_hConnection, dwOption,
		lpBuffer, dwBufferLength, dwFlags);
}

BOOL CInternetConnection::QueryOption(DWORD dwOption, LPVOID lpBuffer,
	LPDWORD lpdwBufferLength) const
{
	ASSERT(dwOption >= INTERNET_FIRST_OPTION &&
		dwOption <= INTERNET_LAST_OPTION);
	ASSERT_POINTER(lpdwBufferLength, DWORD);
	ASSERT(AfxIsValidAddress(lpBuffer, *lpdwBufferLength));
	ASSERT(*lpdwBufferLength != 0);

	return InternetQueryOption(m_hConnection, dwOption,
		lpBuffer, lpdwBufferLength);
}

BOOL CInternetConnection::QueryOption(DWORD dwOption, DWORD& dwValue) const
{
	DWORD dwLen = sizeof(DWORD);
	return InternetQueryOption(m_hConnection, dwOption,
		&dwValue, &dwLen);
}

void CInternetConnection::Close()
{
	if (m_hConnection != NULL)
	{
		InternetCloseHandle(m_hConnection);
		_afxSessionMap.RemoveKey(m_hConnection);
		m_hConnection = NULL;
	}
}

#ifdef _DEBUG
void CInternetConnection::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);
	dc << "m_hConnection = " << m_hConnection;
}

void CInternetConnection::AssertValid() const
{
	CObject::AssertValid();
}
#endif


/////////////////////////////////////////////////////////////////////////////
// CFtpConnection

CFtpConnection::~CFtpConnection()
{
}

CFtpConnection::CFtpConnection(CInternetSession* pSession,
	HINTERNET hConnected, LPCTSTR pstrServer, DWORD_PTR dwContext)
	: CInternetConnection(pSession, pstrServer, INTERNET_INVALID_PORT_NUMBER,
	dwContext)
{
	ASSERT(pSession != NULL);
	ASSERT(AfxIsValidString(pstrServer));

	BOOL bBadType = FALSE;
	if (AfxGetInternetHandleType(hConnected) != INTERNET_HANDLE_TYPE_CONNECT_FTP)
	{
		ASSERT(FALSE);      // used the wrong handle type
		bBadType = TRUE;
	}

	m_strServerName = pstrServer;
	m_hConnection = hConnected;
	if (m_hConnection == NULL || bBadType)
		AfxThrowInternetException(m_dwContext, ERROR_INVALID_HANDLE);
	else
		_afxSessionMap.SetAt(m_hConnection, m_pSession);
}

CFtpConnection::CFtpConnection(CInternetSession* pSession,
	LPCTSTR pstrServer, LPCTSTR pstrUserName /* = NULL */,
	LPCTSTR pstrPassword /* = NULL */, DWORD_PTR dwContext /* = 0 */,
	INTERNET_PORT nPort /* = INTERNET_INVALID_PORT_NUMBER */,
	BOOL bPassive /* = FALSE */)
	: CInternetConnection(pSession, pstrServer, nPort, dwContext)
{
	ASSERT(pSession != NULL);
	ASSERT_KINDOF(CInternetSession, pSession);
	ASSERT(AfxIsValidString(pstrServer));

	m_strServerName = pstrServer;

	m_hConnection = InternetConnect((HINTERNET) *pSession, pstrServer,
		nPort, pstrUserName, pstrPassword, INTERNET_SERVICE_FTP,
		(bPassive ? INTERNET_FLAG_PASSIVE : 0), m_dwContext);

	if (m_hConnection == NULL)
		AfxThrowInternetException(m_dwContext, ::GetLastError());
	else
		_afxSessionMap.SetAt(m_hConnection, m_pSession);
}

BOOL CFtpConnection::Remove(LPCTSTR pstrFileName)
{
	ASSERT_VALID(this);
	ASSERT(m_hConnection != NULL);
	ASSERT(AfxIsValidString(pstrFileName));

	return FtpDeleteFile(m_hConnection, pstrFileName);
}

BOOL CFtpConnection::Rename(LPCTSTR pstrExisting, LPCTSTR pstrNew)
{
	ASSERT_VALID(this);
	ASSERT(m_hConnection != NULL);
	ASSERT(AfxIsValidString(pstrExisting));
	ASSERT(AfxIsValidString(pstrNew));

	return FtpRenameFile(m_hConnection, pstrExisting, pstrNew);
}

BOOL CFtpConnection::CreateDirectory(LPCTSTR pstrDirName)
{
	ASSERT_VALID(this);
	ASSERT(m_hConnection != NULL);
	ASSERT(AfxIsValidString(pstrDirName));

	return FtpCreateDirectory(m_hConnection, pstrDirName);
}

BOOL CFtpConnection::RemoveDirectory(LPCTSTR pstrDirName)
{
	ASSERT_VALID(this);
	ASSERT(m_hConnection != NULL);
	ASSERT(AfxIsValidString(pstrDirName));

	return FtpRemoveDirectory(m_hConnection, pstrDirName);
}

BOOL CFtpConnection::SetCurrentDirectory(LPCTSTR pstrDirName)
{
	ASSERT_VALID(this);
	ASSERT(m_hConnection != NULL);
	ASSERT(AfxIsValidString(pstrDirName));

	return FtpSetCurrentDirectory(m_hConnection, pstrDirName);
}

BOOL CFtpConnection::GetCurrentDirectory(_Out_z_cap_post_count_(*lpdwLen, *lpdwLen) LPTSTR pstrDirName, 
	_Inout_ LPDWORD lpdwLen) const
{
	ASSERT_VALID(this);
	ASSERT(m_hConnection != NULL);
	ASSERT(AfxIsValidAddress(pstrDirName, *lpdwLen));
	ASSERT(lpdwLen != 0);

	return FtpGetCurrentDirectory(m_hConnection, pstrDirName, lpdwLen);
}

BOOL CFtpConnection::GetCurrentDirectoryAsURL(CString& strDirName) const
{
	CString strDirectory;
	if (!GetCurrentDirectory(strDirectory))
		return FALSE;

	strDirName = _afxURLftp;
	strDirName += GetServerName();

	if (strDirectory[0] != '/')
		strDirName += '/';

	strDirName += strDirectory;
	return TRUE;
}

BOOL CFtpConnection::GetCurrentDirectoryAsURL(_Out_z_cap_post_count_(*lpdwLen, *lpdwLen) LPTSTR pstrName, 
	_Inout_ LPDWORD lpdwLen) const
{
	ASSERT(lpdwLen != NULL);
	ASSERT_POINTER(lpdwLen, DWORD);
	ASSERT(AfxIsValidAddress(pstrName, *lpdwLen));
	ASSERT(*lpdwLen != 0);
	if (pstrName == NULL  || lpdwLen == NULL)
		return FALSE;

	CString strTemp;

	if (lpdwLen == NULL || !GetCurrentDirectoryAsURL(strTemp))
		return FALSE;

	if (pstrName == NULL)
		*lpdwLen = (DWORD)strTemp.GetLength();
	else if (*lpdwLen > 0)
		Checked::tcsncpy_s(pstrName, *lpdwLen, (LPCTSTR) strTemp, _TRUNCATE);

	return TRUE;
}

BOOL CFtpConnection::GetCurrentDirectory(CString& strDirName) const
{
	ASSERT_VALID(this);
	ASSERT(m_hConnection != NULL);

	DWORD dwLen = INTERNET_MAX_PATH_LENGTH;
	LPTSTR pstrTarget = strDirName.GetBufferSetLength(dwLen);
	BOOL bRet = FtpGetCurrentDirectory(m_hConnection, pstrTarget, &dwLen);

	if (bRet)
		strDirName.ReleaseBuffer(dwLen);
	else
		strDirName.ReleaseBuffer(0);

	return bRet;
}

CInternetFile* CFtpConnection::OpenFile(LPCTSTR pstrFileName,
	DWORD dwAccess /* = GENERIC_READ */,
	DWORD dwFlags /* = FTP_TRANSFER_TYPE_BINARY */,
	DWORD_PTR dwContext /* = 1 */)
{
	ASSERT_VALID(this);
	ASSERT(m_hConnection != NULL);
	ASSERT(dwAccess != (GENERIC_READ | GENERIC_WRITE));
	ASSERT(dwAccess == GENERIC_READ || dwAccess == GENERIC_WRITE);
	ASSERT(AfxIsValidString(pstrFileName));

	HINTERNET hFile;
	if (dwContext == 1)
		dwContext = m_dwContext;

	hFile = FtpOpenFile(m_hConnection, pstrFileName, dwAccess,
		dwFlags, dwContext);
	if (hFile == NULL)
		AfxThrowInternetException(dwContext);

	CInternetFile* pFile = new CInternetFile(hFile, pstrFileName, this,
		(dwAccess == GENERIC_READ));
	return pFile;
}

CInternetFile* CFtpConnection::Command(LPCTSTR pszCommand, CmdResponseType eResponse,
	DWORD dwFlags, DWORD_PTR dwContext)
{
	ASSERT_VALID(this);
	ASSERT(m_hConnection != NULL);
	ASSERT(AfxIsValidString(pszCommand));

	HINTERNET hFile = NULL;
	if (dwContext == 1)
		dwContext = m_dwContext;

	BOOL bSuccess;
	bSuccess = ::FtpCommand(m_hConnection, eResponse != CmdRespNone, dwFlags, pszCommand,
		dwContext, &hFile);
	if (!bSuccess)
		AfxThrowInternetException(dwContext);

	CInternetFile* pFile = NULL;
	if (hFile != NULL)
		pFile = new CInternetFile(hFile, pszCommand, this, eResponse == CmdRespRead);

	return pFile;
}

BOOL CFtpConnection::PutFile(LPCTSTR pstrLocalFile, LPCTSTR pstrRemoteFile,
	DWORD dwFlags /* = FTP_TRANSFER_TYPE_BINARY */,
	DWORD_PTR dwContext /* = 1 */)
{
	ASSERT_VALID(this);
	ASSERT(m_hConnection != NULL);
	ASSERT(AfxIsValidString(pstrRemoteFile));
	ASSERT(AfxIsValidString(pstrLocalFile));
	ASSERT((dwFlags & INTERNET_FLAG_ASYNC) == 0);

	if (dwContext == 1)
		dwContext = m_dwContext;

	return FtpPutFile(m_hConnection, pstrLocalFile, pstrRemoteFile,
		dwFlags, dwContext);
}

BOOL CFtpConnection::GetFile(LPCTSTR pstrRemoteFile, LPCTSTR pstrLocalFile,
	BOOL bFailIfExists /* = TRUE */,
	DWORD dwAttributes /* = FILE_ATTRIBUTE_NORMAL */,
	DWORD dwFlags /* = FTP_TRANSFER_TYPE_BINARY */, DWORD_PTR dwContext /* = 1 */)
{
	ASSERT_VALID(this);
	ASSERT(m_hConnection != NULL);
	ASSERT(AfxIsValidString(pstrRemoteFile));
	ASSERT(AfxIsValidString(pstrLocalFile));
	ASSERT(!(dwAttributes & FILE_ATTRIBUTE_DIRECTORY));
	ASSERT((dwFlags & INTERNET_FLAG_ASYNC) == 0);

	if (dwContext == 1)
		dwContext = m_dwContext;

	return FtpGetFile(m_hConnection, pstrRemoteFile, pstrLocalFile,
		bFailIfExists, dwAttributes, dwFlags, dwContext);
}

#ifdef _DEBUG
void CFtpConnection::Dump(CDumpContext& dc) const
{
	CInternetConnection::Dump(dc);
	dc << "\nm_strServerName = " << m_strServerName;
}

void CFtpConnection::AssertValid() const
{
	ASSERT(m_pSession != NULL);
	if (m_hConnection != NULL)
	{
		ASSERT(AfxGetInternetHandleType(m_hConnection)
				== INTERNET_HANDLE_TYPE_CONNECT_FTP);
	}
}
#endif


/////////////////////////////////////////////////////////////////////////////
// CGopherConnection

CGopherConnection::~CGopherConnection()
{
}

CGopherConnection::CGopherConnection(CInternetSession* pSession,
	LPCTSTR pstrServer, LPCTSTR pstrUserName /* = NULL */,
	LPCTSTR pstrPassword /* = NULL */, DWORD_PTR dwContext /* = 0 */,
	INTERNET_PORT nPort /* = INTERNET_INVALID_PORT_NUMBER */)
	: CInternetConnection(pSession, pstrServer, nPort, dwContext)
{
	ASSERT(pSession != NULL);
	ASSERT_KINDOF(CInternetSession, pSession);
	ASSERT(AfxIsValidString(pstrServer));

	m_hConnection = InternetConnect((HINTERNET) *pSession, pstrServer,
		nPort, pstrUserName, pstrPassword, INTERNET_SERVICE_GOPHER,
		0, m_dwContext);

	if (m_hConnection == NULL)
		AfxThrowInternetException(m_dwContext);
	else
		_afxSessionMap.SetAt(m_hConnection, m_pSession);
}

CGopherConnection::CGopherConnection(CInternetSession* pSession,
	HINTERNET hConnected, LPCTSTR pstrServer, DWORD_PTR dwContext)
	: CInternetConnection(pSession, pstrServer,
		INTERNET_INVALID_PORT_NUMBER, dwContext)
{
	ASSERT(pSession != NULL);
	ASSERT(AfxIsValidString(pstrServer));

	BOOL bBadType = FALSE;
	if (AfxGetInternetHandleType(hConnected) != INTERNET_HANDLE_TYPE_CONNECT_GOPHER)
	{
		ASSERT(FALSE);      // used the wrong handle type
		bBadType = TRUE;
	}

	m_hConnection = hConnected;
	if (m_hConnection == NULL || bBadType)
		AfxThrowInternetException(m_dwContext);
	else
		_afxSessionMap.SetAt(m_hConnection, m_pSession);
}

CGopherLocator CGopherConnection::CreateLocator(LPCTSTR pstrLocator)
{
	CGopherLocator ret(pstrLocator, lstrlen(pstrLocator));
	return ret;
}

CGopherLocator CGopherConnection::CreateLocator(LPCTSTR pstrServerName,
	LPCTSTR pstrDisplayString, LPCTSTR pstrSelectorString, DWORD dwGopherType,
	INTERNET_PORT nPort /* = INTERNET_INVALID_PORT_NUMBER */)
{
	TCHAR szLocator[MAX_GOPHER_LOCATOR_LENGTH];
	DWORD dwLocLen = MAX_GOPHER_LOCATOR_LENGTH;
	ASSERT(AfxIsValidString(pstrDisplayString));
	ASSERT(AfxIsValidString(pstrServerName));
	ASSERT(AfxIsValidString(pstrSelectorString));

	if (!GopherCreateLocator(pstrServerName, nPort,
			pstrDisplayString, pstrSelectorString, dwGopherType,
			szLocator, &dwLocLen))
		AfxThrowInternetException(0);

	CGopherLocator ret(szLocator, dwLocLen);
	return ret;
}

CGopherLocator CGopherConnection::CreateLocator(
	LPCTSTR pstrDisplayString, LPCTSTR pstrSelectorString, DWORD dwGopherType)
{
	TCHAR szLocator[MAX_GOPHER_LOCATOR_LENGTH];
	DWORD dwLocLen = MAX_GOPHER_LOCATOR_LENGTH;
	ASSERT(AfxIsValidString(pstrDisplayString));
	ASSERT(AfxIsValidString(pstrSelectorString));

	if (!GopherCreateLocator(m_strServerName, m_nPort,
			pstrDisplayString, pstrSelectorString, dwGopherType,
			szLocator, &dwLocLen))
		AfxThrowInternetException(m_dwContext);

	CGopherLocator ret(szLocator, dwLocLen);
	return ret;
}


BOOL CGopherConnection::GetAttribute(CGopherLocator& refLocator,
	CString strRequestedAttributes, CString& strResult)
{
	DWORD dwLen = 4*MIN_GOPHER_ATTRIBUTE_LENGTH; // more than the minimum
	BOOL bRet;
	LPTSTR pstrResult = strResult.GetBuffer(dwLen);

	if (!GopherGetAttribute(m_hConnection, (LPCTSTR) refLocator,
			pstrResult, NULL, dwLen, &dwLen,
			NULL, m_dwContext)) 
	{
		bRet = FALSE;
		strResult.ReleaseBuffer(0);
	}
	else
	{
		bRet = TRUE;
		strResult.ReleaseBuffer(dwLen);
	}

	return bRet;
}

CGopherFile* CGopherConnection::OpenFile(CGopherLocator& refLocator,
	DWORD dwFlags /* = 0 */, LPCTSTR pstrView /* = NULL */,
	DWORD_PTR dwContext /* = 1 */)
{
	ASSERT_VALID(this);
	ASSERT(m_hConnection != NULL);

	HINTERNET hFile;
	if (dwContext == 1)
		dwContext = m_dwContext;

	hFile = GopherOpenFile(m_hConnection, (LPCTSTR) refLocator, pstrView,
		dwFlags, dwContext);

	if (hFile == NULL)
		AfxThrowInternetException(dwContext);

	CGopherFile* pFile = new CGopherFile(hFile, refLocator, this);
	return pFile;
}

#ifdef _DEBUG
void CGopherConnection::Dump(CDumpContext& dc) const
{
	CInternetConnection::Dump(dc);
	dc << "\nm_strServerName = " << m_strServerName;
}

void CGopherConnection::AssertValid() const
{
	ASSERT(m_pSession != NULL);
	if (m_hConnection != NULL)
	{
		ASSERT(AfxGetInternetHandleType(m_hConnection)
				== INTERNET_HANDLE_TYPE_CONNECT_GOPHER);
	}
}
#endif


/////////////////////////////////////////////////////////////////////////////
// CHttpConnection

CHttpConnection::~CHttpConnection()
{
}

CHttpConnection::CHttpConnection(CInternetSession* pSession,
	HINTERNET hConnected, LPCTSTR pstrServer, DWORD_PTR dwContext /* = 0 */)
	: CInternetConnection(pSession, pstrServer, INTERNET_INVALID_PORT_NUMBER, dwContext)
{
	ASSERT(pSession != NULL);
	ASSERT(AfxIsValidString(pstrServer));

	m_strServerName = pstrServer;

	BOOL bBadType = FALSE;
	if (AfxGetInternetHandleType(hConnected) != INTERNET_HANDLE_TYPE_CONNECT_HTTP)
	{
		ASSERT(FALSE);      // used the wrong handle type
		bBadType = TRUE;
	}

	m_hConnection = hConnected;
	if (m_hConnection == NULL || bBadType)
		AfxThrowInternetException(m_dwContext, ERROR_INVALID_HANDLE);
	else
		_afxSessionMap.SetAt(m_hConnection, m_pSession);
}

CHttpConnection::CHttpConnection(CInternetSession* pSession,
	LPCTSTR pstrServer,
	INTERNET_PORT nPort /* = INTERNET_INVALID_PORT_NUMBER */,
	LPCTSTR pstrUserName /* = NULL */,
	LPCTSTR pstrPassword /* = NULL */, DWORD_PTR dwContext /* = 1 */)
	: CInternetConnection(pSession, pstrServer, nPort, dwContext)
{
	ASSERT(pSession != NULL);
	ASSERT_KINDOF(CInternetSession, pSession);
	ASSERT(AfxIsValidString(pstrServer));

	m_strServerName = pstrServer;

	m_hConnection = InternetConnect((HINTERNET) *pSession, pstrServer,
		nPort, pstrUserName, pstrPassword, INTERNET_SERVICE_HTTP,
		0, m_dwContext);

	if (m_hConnection == NULL)
		AfxThrowInternetException(m_dwContext);
	else
		_afxSessionMap.SetAt(m_hConnection, m_pSession);
}

CHttpConnection::CHttpConnection(CInternetSession* pSession,
	LPCTSTR pstrServer, DWORD dwFlags,
	INTERNET_PORT nPort /* = INTERNET_INVALID_PORT_NUMBER */,
	LPCTSTR pstrUserName /* = NULL */,
	LPCTSTR pstrPassword /* = NULL */,
	DWORD_PTR dwContext /* = 1 */)
	: CInternetConnection(pSession, pstrServer, nPort, dwContext)
{
	ASSERT(pSession != NULL);
	ASSERT_KINDOF(CInternetSession, pSession);
	ASSERT((dwFlags & INTERNET_FLAG_ASYNC) == 0);
	ASSERT(AfxIsValidString(pstrServer));

	m_strServerName = pstrServer;

	m_hConnection = InternetConnect((HINTERNET) *pSession, pstrServer,
		nPort, pstrUserName, pstrPassword, INTERNET_SERVICE_HTTP,
		dwFlags, m_dwContext);

	if (m_hConnection == NULL)
		AfxThrowInternetException(m_dwContext);
	else
		_afxSessionMap.SetAt(m_hConnection, m_pSession);
}

CHttpFile* CHttpConnection::OpenRequest(LPCTSTR pstrVerb,
	LPCTSTR pstrObjectName, LPCTSTR pstrReferer, DWORD_PTR dwContext,
	LPCTSTR* ppstrAcceptTypes, LPCTSTR pstrVersion, DWORD dwFlags)
{
	ASSERT_VALID(this);
	ASSERT(m_hConnection != NULL);
	ASSERT((dwFlags & INTERNET_FLAG_ASYNC) == 0);

	if (dwContext == 1)
		dwContext = m_dwContext;

	if (pstrVersion == NULL)
		pstrVersion = HTTP_VERSION;

	HINTERNET hFile;
	hFile = HttpOpenRequest(m_hConnection, pstrVerb, pstrObjectName,
		pstrVersion, pstrReferer, ppstrAcceptTypes, dwFlags, dwContext);

	CHttpFile* pRet = new CHttpFile(hFile, pstrVerb, pstrObjectName, this);
	if (pRet != NULL)
		pRet->m_dwContext = dwContext;
	return pRet;
}

CHttpFile* CHttpConnection::OpenRequest(int nVerb,
	LPCTSTR pstrObjectName, LPCTSTR pstrReferer /* = NULL */, DWORD_PTR dwContext,
	LPCTSTR* ppstrAcceptTypes /* = NULL */,
	LPCTSTR pstrVersion /* = NULL */, DWORD dwFlags)
{
	ASSERT_VALID(this);
	ASSERT(m_hConnection != NULL);
	ASSERT((dwFlags & INTERNET_FLAG_ASYNC) == 0);
	ASSERT(AfxIsValidString(pstrObjectName));

	ASSERT(nVerb >= _HTTP_VERB_MIN && nVerb <= _HTTP_VERB_MAX);

	LPCTSTR pstrVerb;
	if (nVerb >= _HTTP_VERB_MIN && nVerb <= _HTTP_VERB_MAX)
		pstrVerb = szHtmlVerbs[nVerb];
	else
		pstrVerb = _T("");

	return OpenRequest(pstrVerb, pstrObjectName, pstrReferer,
		dwContext, ppstrAcceptTypes, pstrVersion, dwFlags);
}

#ifdef _DEBUG
void CHttpConnection::Dump(CDumpContext& dc) const
{
	CInternetConnection::Dump(dc);
	dc << "\nm_strServerName = " << m_strServerName;
}

void CHttpConnection::AssertValid() const
{
	ASSERT(m_pSession != NULL);
	if (m_hConnection != NULL)
	{
		ASSERT(AfxGetInternetHandleType(m_hConnection)
				== INTERNET_HANDLE_TYPE_CONNECT_HTTP);
	}
}
#endif


/////////////////////////////////////////////////////////////////////////////
// CHttpFile

CHttpFile::CHttpFile(HINTERNET hFile, HINTERNET hSession, LPCTSTR pstrObject,
	LPCTSTR pstrServer, LPCTSTR pstrVerb, DWORD_PTR dwContext)
 : CInternetFile(hFile, hSession, pstrObject, pstrServer, dwContext, TRUE),
	m_strVerb(pstrVerb), m_strObject(pstrObject)
{
	// caller must set _afxSessionMap!
	ASSERT(AfxIsValidString(pstrVerb));
	m_hConnection = hFile;
}


CHttpFile::CHttpFile(HINTERNET hFile, LPCTSTR pstrVerb, LPCTSTR pstrObject,
	CHttpConnection* pConnection)
 : CInternetFile(hFile, pstrObject, pConnection, TRUE),
	m_strVerb(pstrVerb), m_strObject(pstrObject)
{
	ASSERT(pstrVerb != NULL);
	ASSERT(pstrObject != NULL);
	ASSERT(pConnection != NULL);
	ASSERT_VALID(pConnection);
	m_hConnection = hFile;
}

CHttpFile::~CHttpFile()
{
}

DWORD CHttpFile::ErrorDlg(CWnd* pParent /* = NULL */,
	DWORD dwError /* = ERROR_INTERNET_INCORRECT_PASSWORD */,
	DWORD dwFlags /* = FLAGS_ERROR_UI_FLAGS_GENERATE_DATA | FLAGS_ERROR_UI_FLAGS_CHANGE_OPTIONS*/,
	LPVOID* lppvData /* = NULL */)
{
	ASSERT((dwFlags & INTERNET_FLAG_ASYNC) == 0);
	HWND hWnd;
	LPVOID lpEmpty;
	LPVOID* lppvHolder;

	if (lppvData == NULL)
	{
		lpEmpty = NULL;
		lppvHolder = &lpEmpty;
	}
	else
		lppvHolder = lppvData;

	if (pParent == NULL || pParent->m_hWnd == NULL)
		hWnd = GetDesktopWindow();
	else
		hWnd = pParent->m_hWnd;

	return InternetErrorDlg(hWnd, m_hFile, dwError, dwFlags, lppvHolder);
}

CString CHttpFile::GetVerb() const
{
	ASSERT_VALID(this);
	ASSERT(m_hFile != NULL);

	return m_strVerb;
}

CString CHttpFile::GetObject() const
{
	ASSERT_VALID(this);
	ASSERT(m_hFile != NULL);

	return m_strObject;
}

CString CHttpFile::GetFileURL() const
{
	ASSERT_VALID(this);
	ASSERT(m_hFile != NULL);

	CString str(_afxURLhttp);
	if (m_hConnection != NULL)
	{
		str += m_strServerName;
		INT_PTR nLen = m_strObject.GetLength();
		if (nLen > 0)
		{
			if (m_strObject[0] != '/' && m_strObject[0] != '\\')
				str += '/';
			str += m_strObject;
		}
	}

	return str;
}

BOOL CHttpFile::AddRequestHeaders(LPCTSTR pstrHeaders,
	DWORD dwModifiers /* = HTTP_ADDREQ_FLAG_ADD */,
	int dwHeadersLen /* = -1 */)
{
	ASSERT(AfxIsValidString(pstrHeaders));
	ASSERT(dwHeadersLen == 0 || pstrHeaders != NULL);
	ASSERT_VALID(this);
	ASSERT(m_hFile != NULL);

	if (dwHeadersLen == -1)
		if (pstrHeaders == NULL)
			dwHeadersLen = 0;
		else
			dwHeadersLen = lstrlen(pstrHeaders);

	return HttpAddRequestHeaders(m_hFile, pstrHeaders, dwHeadersLen,
		dwModifiers);
}

BOOL CHttpFile::AddRequestHeaders(CString& str,
	DWORD dwModifiers /* = HTTP_ADDREQ_FLAG_ADD */)
{
	return AddRequestHeaders((LPCTSTR) str, dwModifiers, (int)str.GetLength());
}

BOOL CHttpFile::SendRequest(LPCTSTR pstrHeaders /* = NULL */,
	DWORD dwHeadersLen /* = 0 */, LPVOID lpOptional /* = NULL */,
	DWORD dwOptionalLen /* = 0 */)
{
	ASSERT(dwOptionalLen == 0 || lpOptional != NULL);
	ASSERT(dwHeadersLen == 0 || pstrHeaders != NULL);
	ASSERT_VALID(this);
	ASSERT(m_hFile != NULL);

	BOOL bRet = HttpSendRequest(m_hFile,
		pstrHeaders, dwHeadersLen, lpOptional, dwOptionalLen);

	if (!bRet)
		AfxThrowInternetException(m_dwContext);

	return bRet;
}

BOOL CHttpFile::EndRequest(
	DWORD dwFlags /* = 0 */,
	LPINTERNET_BUFFERS lpBuffIn /* = NULL */, DWORD_PTR dwContext /* = 1 */)
{
	ASSERT(m_hFile != NULL);
	ASSERT(m_bReadMode == -1);

	if (dwContext == 1)
		dwContext = m_dwContext;

	BOOL bRet = HttpEndRequest(m_hFile, lpBuffIn, dwFlags, dwContext);

	if (!bRet)
		AfxThrowInternetException(m_dwContext);
	return bRet;
}

BOOL CHttpFile::SendRequestEx(DWORD dwTotalLen,
	DWORD dwFlags /* = HSR_INITIATE */, DWORD_PTR dwContext /* = 1 */)
{
	ASSERT(m_hFile != NULL);

	INTERNET_BUFFERS buffer;
	memset(&buffer, 0, sizeof(buffer));
	buffer.dwStructSize = sizeof(buffer);
	buffer.dwBufferTotal = dwTotalLen;

	if (dwContext == 1)
		dwContext = m_dwContext;

	return SendRequestEx(&buffer, NULL, dwFlags, dwContext);
}

BOOL CHttpFile::SendRequestEx(LPINTERNET_BUFFERS lpBuffIn,
	LPINTERNET_BUFFERS lpBuffOut, DWORD dwFlags /* = HSR_INITIATE */,
	DWORD_PTR dwContext /* = 1 */)
{
	ASSERT(m_hFile != NULL);
	ASSERT_NULL_OR_POINTER(lpBuffIn, INTERNET_BUFFERS);
	ASSERT_NULL_OR_POINTER(lpBuffOut, INTERNET_BUFFERS);

	if (dwContext == 1)
		dwContext = m_dwContext;

	BOOL bRet = HttpSendRequestEx(m_hFile, lpBuffIn, lpBuffOut,
		dwFlags, dwContext);

	if (!bRet)
		AfxThrowInternetException(m_dwContext);

	m_bReadMode = -1;
	return bRet;
}

BOOL CHttpFile::SendRequest(CString& strHeaders,
	LPVOID lpOptional /* = NULL */, DWORD dwOptionalLen /* = 0 */)
{
	ASSERT(dwOptionalLen == 0 || lpOptional != NULL);
	ASSERT_VALID(this);
	ASSERT(m_hFile != NULL);

	return SendRequest((LPCTSTR) strHeaders, (ULONG)strHeaders.GetLength(),
		lpOptional, dwOptionalLen);
}

BOOL CHttpFile::QueryInfo(DWORD dwInfoLevel,
	LPVOID lpvBuffer, LPDWORD lpdwBufferLength, LPDWORD lpdwIndex) const
{
	ASSERT(((HTTP_QUERY_HEADER_MASK & dwInfoLevel) <= HTTP_QUERY_MAX || 
		dwInfoLevel == HTTP_QUERY_CUSTOM) && dwInfoLevel != 0);
	ASSERT(lpvBuffer != NULL && *lpdwBufferLength > 0);
	ASSERT_VALID(this);
	ASSERT(m_hFile != NULL);

	return HttpQueryInfo(m_hFile, dwInfoLevel, lpvBuffer,
		lpdwBufferLength, lpdwIndex);
}

BOOL CHttpFile::QueryInfo(DWORD dwInfoLevel, DWORD& dwResult,
	LPDWORD lpdwIndex /* = NULL */) const
{
	dwInfoLevel |= HTTP_QUERY_FLAG_NUMBER;
	DWORD dwDWSize = sizeof(DWORD);
	return QueryInfo(dwInfoLevel, &dwResult, &dwDWSize, lpdwIndex);
}

BOOL CHttpFile::QueryInfo(DWORD dwInfoLevel, SYSTEMTIME* pSystemTime,
	LPDWORD lpdwIndex /* = NULL */) const
{
	dwInfoLevel |= HTTP_QUERY_FLAG_SYSTEMTIME;
	DWORD dwTimeSize = sizeof(SYSTEMTIME);
	return QueryInfo(dwInfoLevel, pSystemTime, &dwTimeSize, lpdwIndex);
}

BOOL CHttpFile::QueryInfoStatusCode(DWORD& dwStatusCode) const
{
	ASSERT_VALID(this);
	ASSERT(m_hFile != NULL);

	TCHAR szBuffer[80];
	DWORD dwLen = _countof(szBuffer);
	BOOL bRet;

	bRet = HttpQueryInfo(m_hFile, HTTP_QUERY_STATUS_CODE,
				szBuffer, &dwLen, NULL);

	if (bRet)
		dwStatusCode = (DWORD) _ttol(szBuffer);
	return bRet;
}

BOOL CHttpFile::QueryInfo(DWORD dwInfoLevel, CString& str,
	LPDWORD lpdwIndex) const
{
	ASSERT(dwInfoLevel <= HTTP_QUERY_MAX);
	ASSERT_VALID(this);
	ASSERT(m_hFile != NULL);

	BOOL bRet;
	DWORD dwLen = 0;

	// ask for nothing to see how long the return really is

	str.Empty();
	if (HttpQueryInfo(m_hFile, dwInfoLevel, NULL, &dwLen, 0))
		bRet = TRUE;
	else
	{
		// now that we know how long it is, ask for exactly that much
		// space and really request the header from the API

		LPTSTR pstr = str.GetBufferSetLength(dwLen);
		bRet = HttpQueryInfo(m_hFile, dwInfoLevel, pstr, &dwLen, lpdwIndex);
		if (bRet)
			str.ReleaseBuffer(dwLen);
		else
			str.ReleaseBuffer(0);
	}

	return bRet;
}

#ifdef _DEBUG
void CHttpFile::Dump(CDumpContext& dc) const
{
	dc << "\nm_strFileName = " << m_strFileName;
	dc << "\nm_strVerb = " << m_strVerb;
}

void CHttpFile::AssertValid() const
{
	CInternetFile::AssertValid();
}
#endif

/////////////////////////////////////////////////////////////////////////////
// CGopherFile

CGopherFile::CGopherFile(HINTERNET hFile, CGopherLocator& refLocator,
	CGopherConnection* pConnection)
	: CInternetFile(hFile, _T(""), pConnection, TRUE),
		m_Locator(refLocator)
{
	ASSERT(pConnection != NULL);
	ASSERT_VALID(pConnection);
}

CGopherFile::CGopherFile(HINTERNET hFile, HINTERNET hSession,
	LPCTSTR pstrLocator, DWORD dwLocLen, DWORD_PTR dwContext)
	: CInternetFile(hFile, hSession, _T(""), _T(""), dwContext, TRUE),
		m_Locator(pstrLocator, dwLocLen)
{
	// caller muset set _afxSessionMap!
}

CGopherFile::~CGopherFile()
{
}

void CGopherFile::Write(const void* lpBuf, UINT nCount)
{
	UNUSED_ALWAYS(lpBuf);
	UNUSED_ALWAYS(nCount);

	ASSERT(FALSE);
	AfxThrowNotSupportedException();
}

void CGopherFile::WriteString(LPCTSTR pstr)
{
	UNUSED_ALWAYS(pstr);

	ASSERT(FALSE);
	AfxThrowNotSupportedException();
}

#ifdef _DEBUG
void CGopherFile::Dump(CDumpContext& dc) const
{
	CInternetFile::Dump(dc);
}

void CGopherFile::AssertValid() const
{
	CInternetFile::AssertValid();
}
#endif

/////////////////////////////////////////////////////////////////////////////
// CFtpFileFind

CFtpFileFind::CFtpFileFind(CFtpConnection* pConnection, DWORD_PTR dwContext)
{
	ASSERT(pConnection != NULL);

	if (NULL == pConnection)
	{
		AfxThrowInvalidArgException();
	}

	ASSERT_KINDOF(CFtpConnection, pConnection);

	m_pConnection = pConnection;
	if (dwContext == 1)
		dwContext = pConnection->GetContext();
	m_dwContext = dwContext;
	m_chDirSeparator = '/';
}

CFtpFileFind::~CFtpFileFind()
{
	Close();
}

BOOL CFtpFileFind::FindFile(LPCTSTR pstrName /* = NULL */,
	DWORD dwFlags /* = INTERNET_FLAG_RELOAD */)
{
	ASSERT((dwFlags & INTERNET_FLAG_ASYNC) == 0);
	ASSERT(m_pConnection != NULL);
	ASSERT_VALID(m_pConnection);

	if (m_pConnection == NULL)
		return FALSE;

	if ( lstrlen(pstrName) >= MAX_PATH )
		return FALSE; // WIN32_FIND_DATA.cFileName is MAX_PATH in length
	Close();
	m_pNextInfo = new WIN32_FIND_DATA;
	if (m_pNextInfo == NULL)
		return FALSE;

	if (pstrName == NULL)
		pstrName = _T("*");

	WIN32_FIND_DATA *pFindData = (WIN32_FIND_DATA *)m_pNextInfo;
	Checked::tcsncpy_s(pFindData->cFileName, _countof(pFindData->cFileName), pstrName, _TRUNCATE);

	m_hContext = FtpFindFirstFile((HINTERNET) *m_pConnection,
		pstrName, (LPWIN32_FIND_DATA) m_pNextInfo, dwFlags, m_dwContext);
	if (m_hContext == NULL)
	{
		Close();
		return FALSE;
	}

	LPCTSTR pstrRoot = _tcspbrk(pstrName, _T("\\/"));
	CString strCWD;
	m_pConnection->GetCurrentDirectory(strCWD);

	if (pstrRoot == NULL)
	{
		if (m_pConnection->SetCurrentDirectory(pstrName))
		{
			m_pConnection->GetCurrentDirectory(m_strRoot);
			m_pConnection->SetCurrentDirectory(strCWD);
		}
		else
			m_strRoot = strCWD;
	}
	else
	{
		// find the last forward or backward whack

		int nLast;
		LPCTSTR pstrOther = _tcsrchr(pstrName, '\\');
		pstrRoot = _tcsrchr(pstrName, '/');

		if (pstrRoot == NULL)
			pstrRoot = pstrName;
		if (pstrOther == NULL)
			pstrOther = pstrName;

		if (pstrRoot >= pstrOther)
			nLast = ULONG( pstrRoot - pstrName );
		else
			nLast = ULONG( pstrOther - pstrName );

		// from the start to the last whack is the root

		if (nLast == 0)
			nLast++;

		m_strRoot = pstrName;
		m_strRoot = m_strRoot.Left(nLast);
	}

	return TRUE;
}

BOOL CFtpFileFind::FindNextFile()
{
	ASSERT(m_hContext != NULL);
	if (m_hContext == NULL)
		return FALSE;

	if (m_pFoundInfo == NULL)
	{
		m_pFoundInfo = new WIN32_FIND_DATA;
		if (m_pFoundInfo == NULL)
			return FALSE;
	}

	ASSERT_VALID(this);
	void* pTemp = m_pFoundInfo;
	m_pFoundInfo = m_pNextInfo;
	m_pNextInfo = pTemp;

	return InternetFindNextFile(m_hContext, m_pNextInfo);
}

void CFtpFileFind::CloseContext()
{
	if (m_hContext != NULL && m_hContext != INVALID_HANDLE_VALUE)
	{
		InternetCloseHandle(m_hContext);
		m_hContext = NULL;
	}
}

CString CFtpFileFind::GetFileURL() const
{
	ASSERT_VALID(this);
	ASSERT(m_hContext != NULL);

	CString str;

	if (m_hContext != NULL)
	{
		str += _afxURLftp;
		str += m_pConnection->GetServerName();
		str += GetFilePath();
	}

	return str;
}

#ifdef _DEBUG
void CFtpFileFind::Dump(CDumpContext& dc) const
{
	CFileFind::Dump(dc);
	dc << "m_hContext = " << m_hContext;
}

void CFtpFileFind::AssertValid() const
{
	CFileFind::AssertValid();
}
#endif


/////////////////////////////////////////////////////////////////////////////
// CGopherFileFind

CGopherFileFind::CGopherFileFind(CGopherConnection* pConnection,
	DWORD_PTR dwContext)
{
	ASSERT(pConnection != NULL);
	ASSERT_KINDOF(CGopherConnection, pConnection);

	m_pConnection = pConnection;
	if (dwContext == 1)
		dwContext = pConnection->GetContext();
	m_dwContext = dwContext;
}

CGopherFileFind::~CGopherFileFind()
{
	Close();
}

BOOL CGopherFileFind::FindFile(LPCTSTR pstrString,
	DWORD dwFlags /* = INTERNET_FLAG_RELOAD */)
{
	ASSERT((dwFlags & INTERNET_FLAG_ASYNC) == 0);
	Close();

	m_pNextInfo = new GOPHER_FIND_DATA;
	if (m_pNextInfo == NULL)
		return FALSE;

	m_hContext = GopherFindFirstFile((HINTERNET) *m_pConnection,
		NULL, pstrString,
		(GOPHER_FIND_DATA*) m_pNextInfo, dwFlags, m_dwContext);

	if (m_hContext == NULL)
		Close();
	return (m_hContext != NULL);
}

BOOL CGopherFileFind::FindFile(CGopherLocator& refLocator,
	LPCTSTR pstrString, DWORD dwFlags /* = INTERNET_FLAG_RELOAD */)
{
	ASSERT((dwFlags & INTERNET_FLAG_ASYNC) == 0);
	Close();

	m_pNextInfo = new GOPHER_FIND_DATA;
	if (m_pNextInfo == NULL)
		return FALSE;

	m_pFoundInfo = new GOPHER_FIND_DATA;
	if (m_pFoundInfo == NULL)
	{
		delete m_pNextInfo;
		m_pNextInfo = NULL;
		return FALSE;
	}

	m_hContext = GopherFindFirstFile((HINTERNET) *m_pConnection,
		(LPCTSTR) refLocator, pstrString,
		(GOPHER_FIND_DATA*) m_pNextInfo, dwFlags, m_dwContext);

	if (m_hContext == NULL)
		Close();
	return (m_hContext != NULL);
}

BOOL CGopherFileFind::FindNextFile()
{
	ASSERT(m_hContext != NULL);
	if (m_hContext == NULL)
		return FALSE;

	if (m_pFoundInfo == NULL)
	{
		m_pFoundInfo = new GOPHER_FIND_DATA;
		if (m_pFoundInfo == NULL)
			return FALSE;
	}

	ASSERT_VALID(this);
	void* pTemp = m_pFoundInfo;
	m_pFoundInfo = m_pNextInfo;
	m_pNextInfo = pTemp;

	return InternetFindNextFile(m_hContext, m_pNextInfo);
}

void CGopherFileFind::CloseContext()
{
	if (m_hContext != NULL && m_hContext != INVALID_HANDLE_VALUE)
	{
		InternetCloseHandle(m_hContext);
		m_hContext = NULL;
	}
}

CString CGopherFileFind::GetFileName() const
{
	AfxThrowNotSupportedException();
}

CString CGopherFileFind::GetFilePath() const
{
	AfxThrowNotSupportedException();
}

CString CGopherFileFind::GetFileTitle() const
{
	AfxThrowNotSupportedException();
}

BOOL CGopherFileFind::IsDots() const
{
	// gophers never have dots
	return FALSE;
}

BOOL CGopherFileFind::GetLastWriteTime(FILETIME* pTimeStamp) const
{
	ASSERT(m_hContext != NULL);
	ASSERT_POINTER(pTimeStamp, FILETIME);
	ASSERT_VALID(this);

	if (m_pFoundInfo != NULL && pTimeStamp != NULL)
	{
		*pTimeStamp = ((LPGOPHER_FIND_DATA) m_pFoundInfo)->LastModificationTime;
		return TRUE;
	}
	else
		return FALSE;
}

BOOL CGopherFileFind::GetLastAccessTime(FILETIME* pTimeStamp) const
{
	ASSERT_POINTER(pTimeStamp, FILETIME);
	return GetLastWriteTime(pTimeStamp);
}

BOOL CGopherFileFind::GetCreationTime(FILETIME* pTimeStamp) const
{
	ASSERT_POINTER(pTimeStamp, FILETIME);
	return GetLastWriteTime(pTimeStamp);
}

BOOL CGopherFileFind::GetLastWriteTime(CTime& refTime) const
{
	ASSERT(m_hContext != NULL);
	ASSERT_VALID(this);

	if (m_pFoundInfo != NULL)
	{
		refTime = CTime(((LPGOPHER_FIND_DATA) m_pFoundInfo)->LastModificationTime);
		return TRUE;
	}
	else
		return FALSE;
}

BOOL CGopherFileFind::GetCreationTime(CTime& refTime) const
{
	return GetLastWriteTime(refTime);
}

BOOL CGopherFileFind::GetLastAccessTime(CTime& refTime) const
{
	return GetLastWriteTime(refTime);
}


CString CGopherFileFind::GetFileURL() const
{
	AfxThrowNotSupportedException();
}

CString CGopherFileFind::GetRoot() const
{
	AfxThrowNotSupportedException();
}

CGopherLocator CGopherFileFind::GetLocator() const
{
	ASSERT_VALID(this);
	ASSERT(m_pConnection != NULL && m_hContext != NULL);

	return m_pConnection->CreateLocator(
		((LPGOPHER_FIND_DATA) m_pFoundInfo)->Locator);
}

CString CGopherFileFind::GetScreenName() const
{
	ASSERT_VALID(this);
	ASSERT(m_hContext != NULL);

	CString str;

	if (m_pFoundInfo != NULL)
		str = ((LPGOPHER_FIND_DATA) m_pFoundInfo)->DisplayString;

	return str;
}

ULONGLONG CGopherFileFind::GetLength() const
{
	ASSERT_VALID(this);

   ULARGE_INTEGER nLength;

	if (m_pFoundInfo != NULL)
   {
	  nLength.LowPart = ((LPGOPHER_FIND_DATA) m_pFoundInfo)->SizeLow;
	  nLength.HighPart = ((LPGOPHER_FIND_DATA) m_pFoundInfo)->SizeHigh;
   }
   else
   {
	  nLength.QuadPart = 0;
   }

   return nLength.QuadPart;
}

#ifdef _DEBUG
void CGopherFileFind::Dump(CDumpContext& dc) const
{
	CFileFind::Dump(dc);
	dc << "m_hContext = " << m_hContext;
}

void CGopherFileFind::AssertValid() const
{
	CFileFind::AssertValid();
}
#endif


/////////////////////////////////////////////////////////////////////////////
// CGopherLocator

CGopherLocator::CGopherLocator(LPCTSTR pstrLocator, DWORD dwLocLen)
{
	ASSERT(AfxIsValidString(pstrLocator));
	LPTSTR pstr = m_Locator.GetBufferSetLength(dwLocLen);
	Checked::memcpy_s(pstr, dwLocLen, pstrLocator, dwLocLen);
	m_Locator.ReleaseBuffer(dwLocLen);
	m_dwBufferLength = dwLocLen;
}

CGopherLocator::~CGopherLocator()
{
}

/////////////////////////////////////////////////////////////////////////////
// exception handling

void AFXAPI AfxThrowInternetException(DWORD_PTR dwContext, DWORD dwError /* = 0 */)
{
	if (dwError == 0)
		dwError = ::GetLastError();

	CInternetException* pException = new CInternetException(dwError);
	pException->m_dwContext = dwContext;

	TRACE(traceInternet, 0, "Warning: throwing CInternetException for error %d\n", dwError);
	THROW(pException);
}


BOOL CInternetException::GetErrorMessage(_Out_z_cap_(nMaxError) LPTSTR pstrError, _In_ UINT nMaxError,
	_Out_opt_ PUINT pnHelpContext) const
{
	ASSERT(pstrError != NULL && AfxIsValidString(pstrError, nMaxError));

	if (pnHelpContext != NULL)
	{
		*pnHelpContext = 0;
	}

	LPTSTR lpBuffer;
	BOOL bRet = TRUE;

	HINSTANCE hWinINetLibrary;
	hWinINetLibrary = ::AfxCtxLoadLibraryW(L"WININET.DLL");

	if (hWinINetLibrary == NULL ||
		FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
			hWinINetLibrary, m_dwError,
			MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),
			(LPTSTR) &lpBuffer, 0, NULL) == 0)
	{
		// it failed! try Windows...

		bRet = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
			NULL,  m_dwError,
			MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),
			(LPTSTR) &lpBuffer, 0, NULL);
	}

	if (!bRet)
	{
		*pstrError = '\0';
	}
	else
	{
		if (m_dwError == ERROR_INTERNET_EXTENDED_ERROR)
		{
			LPTSTR lpExtended;
			DWORD dwLength = 0;
			DWORD dwError;

			// find the length of the error
			if (!InternetGetLastResponseInfo(&dwError, NULL, &dwLength) &&
				GetLastError() == ERROR_INSUFFICIENT_BUFFER)
			{
				lpExtended = (LPTSTR) LocalAlloc(LPTR, dwLength*sizeof(TCHAR));
				if(lpExtended)
				{
					InternetGetLastResponseInfo(&dwError, lpExtended, &dwLength);
					if( nMaxError >= dwLength )
					{
					    Checked::tcsncpy_s(pstrError, nMaxError, lpExtended, _TRUNCATE);
					}
					else
					{
					    *pstrError = '\0';
					    bRet=FALSE;
					}
					LocalFree(lpExtended);
				}
				else
				{
					*pstrError = '\0';
					bRet=FALSE;
				}
			}
			else
			{
				TRACE(traceInternet, 0, "Warning: Extended error reported with no response info\n");
			}
			bRet = TRUE;
		}
		else
		{
			Checked::tcsncpy_s(pstrError, nMaxError, lpBuffer, _TRUNCATE);
			bRet = TRUE;
		}

		LocalFree(lpBuffer);
	}

#ifndef _AFXDLL
	::FreeLibrary(hWinINetLibrary);
#endif
	return bRet;
}

CInternetException::CInternetException(DWORD dwError)
{
	m_dwError = dwError;
}

CInternetException::~CInternetException()
{
}

#ifdef _DEBUG
void CInternetException::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	dc << "m_dwError = " << m_dwError;
	dc << "\nm_dwContext = " << m_dwContext;
}
#endif

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations expanded out-of-line

#ifndef _AFX_ENABLE_INLINES

// expand inlines for OLE dialog APIs
#define _AFXINET_INLINE
#include "afxinet.inl"

#endif //!_AFX_ENABLE_INLINES

/////////////////////////////////////////////////////////////////////////////
// Pre-startup code


IMPLEMENT_DYNAMIC(CInternetException, CException)
IMPLEMENT_DYNAMIC(CInternetFile, CStdioFile)
IMPLEMENT_DYNAMIC(CHttpFile, CInternetFile)
IMPLEMENT_DYNAMIC(CGopherFile, CInternetFile)
IMPLEMENT_DYNAMIC(CInternetSession, CObject)
IMPLEMENT_DYNAMIC(CInternetConnection, CObject)
IMPLEMENT_DYNAMIC(CFtpConnection, CInternetConnection)
IMPLEMENT_DYNAMIC(CHttpConnection, CInternetConnection)
IMPLEMENT_DYNAMIC(CGopherConnection, CInternetConnection)
IMPLEMENT_DYNAMIC(CFtpFileFind, CFileFind)
IMPLEMENT_DYNAMIC(CGopherFileFind, CFileFind)

#pragma warning(disable: 4074)
#pragma init_seg(lib)

CSessionMapPtrToPtr _afxSessionMap;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\list_p.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
//
// Implementation of parameterized List
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"





#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////

CPtrList::CPtrList(INT_PTR nBlockSize)
{
	ASSERT(nBlockSize > 0);

	m_nCount = 0;
	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
	m_pBlocks = NULL;
	m_nBlockSize = nBlockSize;
}

void CPtrList::RemoveAll()
{
	ASSERT_VALID(this);

	// destroy elements


	m_nCount = 0;
	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
}

CPtrList::~CPtrList()
{
	RemoveAll();
	ASSERT(m_nCount == 0);
}

/////////////////////////////////////////////////////////////////////////////
// Node helpers
/*
 * Implementation note: CNode's are stored in CPlex blocks and
 *  chained together. Free blocks are maintained in a singly linked list
 *  using the 'pNext' member of CNode with 'm_pNodeFree' as the head.
 *  Used blocks are maintained in a doubly linked list using both 'pNext'
 *  and 'pPrev' as links and 'm_pNodeHead' and 'm_pNodeTail'
 *   as the head/tail.
 *
 * We never free a CPlex block unless the List is destroyed or RemoveAll()
 *  is used - so the total number of CPlex blocks may grow large depending
 *  on the maximum past size of the list.
 */

CPtrList::CNode*
CPtrList::NewNode(CPtrList::CNode* pPrev, CPtrList::CNode* pNext)
{
	if (m_pNodeFree == NULL)
	{
		// add another block
		CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,
				 sizeof(CNode));

		// chain them into free list
		CNode* pNode = (CNode*) pNewBlock->data();
		// free in reverse order to make it easier to debug
		pNode += m_nBlockSize - 1;
		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pNode--)
		{
			pNode->pNext = m_pNodeFree;
			m_pNodeFree = pNode;
		}
	}
	ASSERT(m_pNodeFree != NULL);  // we must have something

	CPtrList::CNode* pNode = m_pNodeFree;
	m_pNodeFree = m_pNodeFree->pNext;
	pNode->pPrev = pPrev;
	pNode->pNext = pNext;
	m_nCount++;
	ASSERT(m_nCount > 0);  // make sure we don't overflow




	pNode->data = 0; // start with zero

	return pNode;
}

void CPtrList::FreeNode(CPtrList::CNode* pNode)
{
	if (pNode == NULL)
	{
		AfxThrowInvalidArgException();
	}

	pNode->pNext = m_pNodeFree;
	m_pNodeFree = pNode;
	m_nCount--;
	ASSERT(m_nCount >= 0);  // make sure we don't underflow

	// if no more elements, cleanup completely
	if (m_nCount == 0)
		RemoveAll();
}

/////////////////////////////////////////////////////////////////////////////

POSITION CPtrList::AddHead(void* newElement)
{

	ASSERT_VALID(this);

	CNode* pNewNode = NewNode(NULL, m_pNodeHead);
	pNewNode->data = newElement;
	if (m_pNodeHead != NULL)
		m_pNodeHead->pPrev = pNewNode;
	else
		m_pNodeTail = pNewNode;
	m_pNodeHead = pNewNode;
	return (POSITION) pNewNode;

}



POSITION CPtrList::AddTail(void* newElement)
{

	ASSERT_VALID(this);

	CNode* pNewNode = NewNode(m_pNodeTail, NULL);
	pNewNode->data = newElement;
	if (m_pNodeTail != NULL)
		m_pNodeTail->pNext = pNewNode;
	else
		m_pNodeHead = pNewNode;
	m_pNodeTail = pNewNode;
	return (POSITION) pNewNode;

}



void CPtrList::AddHead(CPtrList* pNewList)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pNewList);
	if (pNewList == NULL)
	{
		AfxThrowInvalidArgException();
	}
	ASSERT_KINDOF(CPtrList, pNewList);

	// add a list of same elements to head (maintain order)
	POSITION pos = pNewList->GetTailPosition();
	while (pos != NULL)
		AddHead(pNewList->GetPrev(pos));
}

void CPtrList::AddTail(CPtrList* pNewList)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pNewList);
	if (pNewList == NULL)
	{
		AfxThrowInvalidArgException();
	}
	ASSERT_KINDOF(CPtrList, pNewList);
	
	// add a list of same elements
	POSITION pos = pNewList->GetHeadPosition();
	while (pos != NULL)
		AddTail(pNewList->GetNext(pos));
}

void* CPtrList::RemoveHead()
{
	ENSURE_VALID(this);
	ENSURE(m_pNodeHead != NULL);  // throws if called on empty list
	ASSERT(AfxIsValidAddress(m_pNodeHead, sizeof(CNode)));

	CNode* pOldNode = m_pNodeHead;
	void* returnValue = pOldNode->data;

	m_pNodeHead = pOldNode->pNext;
	if (m_pNodeHead != NULL)
		m_pNodeHead->pPrev = NULL;
	else
		m_pNodeTail = NULL;
	FreeNode(pOldNode);
	return returnValue;
}

void* CPtrList::RemoveTail()
{
	ASSERT_VALID(this);
	ASSERT(m_pNodeTail != NULL);  // don't call on empty list !!!
	ASSERT(AfxIsValidAddress(m_pNodeTail, sizeof(CNode)));

	CNode* pOldNode = m_pNodeTail;
	void* returnValue = pOldNode->data;

	m_pNodeTail = pOldNode->pPrev;
	if (m_pNodeTail != NULL)
		m_pNodeTail->pNext = NULL;
	else
		m_pNodeHead = NULL;
	FreeNode(pOldNode);
	return returnValue;
}

POSITION CPtrList::InsertBefore(POSITION position, void* newElement)
{

	ASSERT_VALID(this);

	if (position == NULL)
		return AddHead(newElement); // insert before nothing -> head of the list

	// Insert it before position
	CNode* pOldNode = (CNode*) position;
	CNode* pNewNode = NewNode(pOldNode->pPrev, pOldNode);
	pNewNode->data = newElement;

	if (pOldNode->pPrev != NULL)
	{
		ASSERT(AfxIsValidAddress(pOldNode->pPrev, sizeof(CNode)));
		pOldNode->pPrev->pNext = pNewNode;
	}
	else
	{
		ASSERT(pOldNode == m_pNodeHead);
		m_pNodeHead = pNewNode;
	}
	pOldNode->pPrev = pNewNode;
	return (POSITION) pNewNode;

}



POSITION CPtrList::InsertAfter(POSITION position, void* newElement)
{

	ASSERT_VALID(this);

	if (position == NULL)
		return AddTail(newElement); // insert after nothing -> tail of the list

	// Insert it before position
	CNode* pOldNode = (CNode*) position;
	ASSERT(AfxIsValidAddress(pOldNode, sizeof(CNode)));
	CNode* pNewNode = NewNode(pOldNode, pOldNode->pNext);
	pNewNode->data = newElement;

	if (pOldNode->pNext != NULL)
	{
		ASSERT(AfxIsValidAddress(pOldNode->pNext, sizeof(CNode)));
		pOldNode->pNext->pPrev = pNewNode;
	}
	else
	{
		ASSERT(pOldNode == m_pNodeTail);
		m_pNodeTail = pNewNode;
	}
	pOldNode->pNext = pNewNode;
	return (POSITION) pNewNode;

}



void CPtrList::RemoveAt(POSITION position)
{
	ASSERT_VALID(this);

	CNode* pOldNode = (CNode*) position;
	ASSERT(AfxIsValidAddress(pOldNode, sizeof(CNode)));

	if (pOldNode == NULL)
	{
		AfxThrowInvalidArgException();
	}
	
	// remove pOldNode from list
	if (pOldNode == m_pNodeHead)
	{
		m_pNodeHead = pOldNode->pNext;
	}
	else
	{
		ASSERT(AfxIsValidAddress(pOldNode->pPrev, sizeof(CNode)));
		pOldNode->pPrev->pNext = pOldNode->pNext;
	}
	if (pOldNode == m_pNodeTail)
	{
		m_pNodeTail = pOldNode->pPrev;
	}
	else
	{
		ASSERT(AfxIsValidAddress(pOldNode->pNext, sizeof(CNode)));
		pOldNode->pNext->pPrev = pOldNode->pPrev;
	}
	FreeNode(pOldNode);
}


/////////////////////////////////////////////////////////////////////////////
// slow operations

POSITION CPtrList::FindIndex(INT_PTR nIndex) const
{
	ASSERT_VALID(this);

	if (nIndex >= m_nCount || nIndex < 0)
		return NULL;  // went too far

	CNode* pNode = m_pNodeHead;
	while (nIndex--)
	{
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		pNode = pNode->pNext;
	}
	return (POSITION) pNode;
}

POSITION CPtrList::Find(void* searchValue, POSITION startAfter) const
{
	ASSERT_VALID(this);

	CNode* pNode = (CNode*) startAfter;
	if (pNode == NULL)
	{
		pNode = m_pNodeHead;  // start at head
	}
	else
	{
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		pNode = pNode->pNext;  // start after the one specified
	}

	for (; pNode != NULL; pNode = pNode->pNext)
		if (pNode->data == searchValue)
			return (POSITION) pNode;
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// Diagnostics

#ifdef _DEBUG
void CPtrList::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	dc << "with " << LONGLONG(m_nCount) << " elements";
	if (dc.GetDepth() > 0)
	{
		POSITION pos = GetHeadPosition();
		while (pos != NULL)
			dc << "\n\t" << GetNext(pos);
	}

	dc << "\n";
}

void CPtrList::AssertValid() const
{
	CObject::AssertValid();

	if (m_nCount == 0)
	{
		// empty list
		ASSERT(m_pNodeHead == NULL);
		ASSERT(m_pNodeTail == NULL);
	}
	else
	{
		// non-empty list
		ASSERT(AfxIsValidAddress(m_pNodeHead, sizeof(CNode)));
		ASSERT(AfxIsValidAddress(m_pNodeTail, sizeof(CNode)));
	}
}
#endif //_DEBUG



IMPLEMENT_DYNAMIC(CPtrList, CObject)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\list_s.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
//
// Implementation of parameterized List
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"




#include "elements.h"  // used for special creation


#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////

CStringList::CStringList(INT_PTR nBlockSize)
{
	ASSERT(nBlockSize > 0);

	m_nCount = 0;
	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
	m_pBlocks = NULL;
	m_nBlockSize = nBlockSize;
}

void CStringList::RemoveAll()
{
	ASSERT_VALID(this);

	// destroy elements

	CNode* pNode;
	for (pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
		DestructElement(&pNode->data);


	m_nCount = 0;
	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
}

CStringList::~CStringList()
{
	RemoveAll();
	ASSERT(m_nCount == 0);
}

/////////////////////////////////////////////////////////////////////////////
// Node helpers
/*
 * Implementation note: CNode's are stored in CPlex blocks and
 *  chained together. Free blocks are maintained in a singly linked list
 *  using the 'pNext' member of CNode with 'm_pNodeFree' as the head.
 *  Used blocks are maintained in a doubly linked list using both 'pNext'
 *  and 'pPrev' as links and 'm_pNodeHead' and 'm_pNodeTail'
 *   as the head/tail.
 *
 * We never free a CPlex block unless the List is destroyed or RemoveAll()
 *  is used - so the total number of CPlex blocks may grow large depending
 *  on the maximum past size of the list.
 */

CStringList::CNode*
CStringList::NewNode(CStringList::CNode* pPrev, CStringList::CNode* pNext)
{
	if (m_pNodeFree == NULL)
	{
		// add another block
		CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,
				 sizeof(CNode));

		// chain them into free list
		CNode* pNode = (CNode*) pNewBlock->data();
		// free in reverse order to make it easier to debug
		pNode += m_nBlockSize - 1;
		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pNode--)
		{
			pNode->pNext = m_pNodeFree;
			m_pNodeFree = pNode;
		}
	}
	ASSERT(m_pNodeFree != NULL);  // we must have something

	CStringList::CNode* pNode = m_pNodeFree;
	m_pNodeFree = m_pNodeFree->pNext;
	pNode->pPrev = pPrev;
	pNode->pNext = pNext;
	m_nCount++;
	ASSERT(m_nCount > 0);  // make sure we don't overflow


	ConstructElement(&pNode->data);



	return pNode;
}

void CStringList::FreeNode(CStringList::CNode* pNode)
{
	if (pNode == NULL)
	{
		AfxThrowInvalidArgException();
	}
	
	DestructElement(&pNode->data);

	pNode->pNext = m_pNodeFree;
	m_pNodeFree = pNode;
	m_nCount--;
	ASSERT(m_nCount >= 0);  // make sure we don't underflow

	// if no more elements, cleanup completely
	if (m_nCount == 0)
		RemoveAll();
}

/////////////////////////////////////////////////////////////////////////////

POSITION CStringList::AddHead(LPCTSTR newElement)
{

	return AddHead(CString(newElement));

}


POSITION CStringList::AddHead(const CString& newElement)
{
	ASSERT_VALID(this);

	CNode* pNewNode = NewNode(NULL, m_pNodeHead);
	pNewNode->data = newElement;
	if (m_pNodeHead != NULL)
		m_pNodeHead->pPrev = pNewNode;
	else
		m_pNodeTail = pNewNode;
	m_pNodeHead = pNewNode;
	return (POSITION) pNewNode;
}


POSITION CStringList::AddTail(LPCTSTR newElement)
{

	return AddTail(CString(newElement));

}


POSITION CStringList::AddTail(const CString& newElement)
{
	ASSERT_VALID(this);

	CNode* pNewNode = NewNode(m_pNodeTail, NULL);
	pNewNode->data = newElement;
	if (m_pNodeTail != NULL)
		m_pNodeTail->pNext = pNewNode;
	else
		m_pNodeHead = pNewNode;
	m_pNodeTail = pNewNode;
	return (POSITION) pNewNode;
}


void CStringList::AddHead(CStringList* pNewList)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pNewList);
	if (pNewList == NULL)
	{
		AfxThrowInvalidArgException();
	}
	ASSERT_KINDOF(CStringList, pNewList);

	// add a list of same elements to head (maintain order)
	POSITION pos = pNewList->GetTailPosition();
	while (pos != NULL)
		AddHead(pNewList->GetPrev(pos));
}

void CStringList::AddTail(CStringList* pNewList)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pNewList);
	if (pNewList == NULL)
	{
		AfxThrowInvalidArgException();
	}
	ASSERT_KINDOF(CStringList, pNewList);

	// add a list of same elements
	POSITION pos = pNewList->GetHeadPosition();
	while (pos != NULL)
		AddTail(pNewList->GetNext(pos));
}

CString CStringList::RemoveHead()
{
	ENSURE_VALID(this);
	ENSURE(m_pNodeHead != NULL);  // throws if called on empty list
	ASSERT(AfxIsValidAddress(m_pNodeHead, sizeof(CNode)));

	CNode* pOldNode = m_pNodeHead;
	CString returnValue = pOldNode->data;

	m_pNodeHead = pOldNode->pNext;
	if (m_pNodeHead != NULL)
		m_pNodeHead->pPrev = NULL;
	else
		m_pNodeTail = NULL;
	FreeNode(pOldNode);
	return returnValue;
}

CString CStringList::RemoveTail()
{
	ASSERT_VALID(this);
	ASSERT(m_pNodeTail != NULL);  // don't call on empty list !!!
	ASSERT(AfxIsValidAddress(m_pNodeTail, sizeof(CNode)));

	CNode* pOldNode = m_pNodeTail;
	CString returnValue = pOldNode->data;

	m_pNodeTail = pOldNode->pPrev;
	if (m_pNodeTail != NULL)
		m_pNodeTail->pNext = NULL;
	else
		m_pNodeHead = NULL;
	FreeNode(pOldNode);
	return returnValue;
}

POSITION CStringList::InsertBefore(POSITION position, LPCTSTR newElement)
{

	return InsertBefore(position, CString(newElement));

}


POSITION CStringList::InsertBefore(POSITION position, const CString& newElement)
{
	ASSERT_VALID(this);

	if (position == NULL)
		return AddHead(newElement); // insert before nothing -> head of the list

	// Insert it before position
	CNode* pOldNode = (CNode*) position;
	CNode* pNewNode = NewNode(pOldNode->pPrev, pOldNode);
	pNewNode->data = newElement;

	if (pOldNode->pPrev != NULL)
	{
		ASSERT(AfxIsValidAddress(pOldNode->pPrev, sizeof(CNode)));
		pOldNode->pPrev->pNext = pNewNode;
	}
	else
	{
		ASSERT(pOldNode == m_pNodeHead);
		m_pNodeHead = pNewNode;
	}
	pOldNode->pPrev = pNewNode;
	return (POSITION) pNewNode;
}


POSITION CStringList::InsertAfter(POSITION position, LPCTSTR newElement)
{

	return InsertAfter(position, CString(newElement));

}


POSITION CStringList::InsertAfter(POSITION position, const CString& newElement)
{
	ASSERT_VALID(this);

	if (position == NULL)
		return AddTail(newElement); // insert after nothing -> tail of the list

	// Insert it before position
	CNode* pOldNode = (CNode*) position;
	ASSERT(AfxIsValidAddress(pOldNode, sizeof(CNode)));
	CNode* pNewNode = NewNode(pOldNode, pOldNode->pNext);
	pNewNode->data = newElement;

	if (pOldNode->pNext != NULL)
	{
		ASSERT(AfxIsValidAddress(pOldNode->pNext, sizeof(CNode)));
		pOldNode->pNext->pPrev = pNewNode;
	}
	else
	{
		ASSERT(pOldNode == m_pNodeTail);
		m_pNodeTail = pNewNode;
	}
	pOldNode->pNext = pNewNode;
	return (POSITION) pNewNode;
}


void CStringList::RemoveAt(POSITION position)
{
	ASSERT_VALID(this);

	CNode* pOldNode = (CNode*) position;
	ASSERT(AfxIsValidAddress(pOldNode, sizeof(CNode)));

	if (pOldNode == NULL)
	{
		AfxThrowInvalidArgException();
	}
	
	// remove pOldNode from list
	if (pOldNode == m_pNodeHead)
	{
		m_pNodeHead = pOldNode->pNext;
	}
	else
	{
		ASSERT(AfxIsValidAddress(pOldNode->pPrev, sizeof(CNode)));
		pOldNode->pPrev->pNext = pOldNode->pNext;
	}
	if (pOldNode == m_pNodeTail)
	{
		m_pNodeTail = pOldNode->pPrev;
	}
	else
	{
		ASSERT(AfxIsValidAddress(pOldNode->pNext, sizeof(CNode)));
		pOldNode->pNext->pPrev = pOldNode->pPrev;
	}
	FreeNode(pOldNode);
}


/////////////////////////////////////////////////////////////////////////////
// slow operations

POSITION CStringList::FindIndex(INT_PTR nIndex) const
{
	ASSERT_VALID(this);

	if (nIndex >= m_nCount || nIndex < 0)
		return NULL;  // went too far

	CNode* pNode = m_pNodeHead;
	while (nIndex--)
	{
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		pNode = pNode->pNext;
	}
	return (POSITION) pNode;
}

POSITION CStringList::Find(LPCTSTR searchValue, POSITION startAfter) const
{
	ASSERT_VALID(this);

	CNode* pNode = (CNode*) startAfter;
	if (pNode == NULL)
	{
		pNode = m_pNodeHead;  // start at head
	}
	else
	{
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		pNode = pNode->pNext;  // start after the one specified
	}

	for (; pNode != NULL; pNode = pNode->pNext)
		if (pNode->data == searchValue)
			return (POSITION) pNode;
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// Serialization

void CStringList::Serialize(CArchive& ar)
{
	ASSERT_VALID(this);

	CObject::Serialize(ar);

	if (ar.IsStoring())
	{
		ar.WriteCount(m_nCount);
		for (CNode* pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
		{
			ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
			ar << pNode->data;
		}
	}
	else
	{
		DWORD_PTR nNewCount = ar.ReadCount();
		CString newData;
		while (nNewCount--)
		{
			ar >> newData;
			AddTail(newData);
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// Diagnostics

#ifdef _DEBUG
void CStringList::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	dc << "with " << LONGLONG(m_nCount) << " elements";
	if (dc.GetDepth() > 0)
	{
		POSITION pos = GetHeadPosition();
		while (pos != NULL)
			dc << "\n\t" << GetNext(pos);
	}

	dc << "\n";
}

void CStringList::AssertValid() const
{
	CObject::AssertValid();

	if (m_nCount == 0)
	{
		// empty list
		ASSERT(m_pNodeHead == NULL);
		ASSERT(m_pNodeTail == NULL);
	}
	else
	{
		// non-empty list
		ASSERT(AfxIsValidAddress(m_pNodeHead, sizeof(CNode)));
		ASSERT(AfxIsValidAddress(m_pNodeTail, sizeof(CNode)));
	}
}
#endif //_DEBUG



IMPLEMENT_SERIAL(CStringList, CObject, 0)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\map_pw.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
//
// Implementation of parmeterized Map
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <afxtempl.h>

#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////

CMapPtrToWord::CMapPtrToWord(INT_PTR nBlockSize)
{
	ASSERT(nBlockSize > 0);
	if (nBlockSize <= 0)
		nBlockSize = 10;	// default size

	m_pHashTable = NULL;
	m_nHashTableSize = 17;  // default size
	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks = NULL;
	m_nBlockSize = nBlockSize;
}

inline UINT CMapPtrToWord::HashKey(void* key) const
{
	return (::HashKey<DWORD_PTR>((DWORD_PTR)key));
}

void CMapPtrToWord::InitHashTable(
	UINT nHashSize, BOOL bAllocNow)
//
// Used to force allocation of a hash table or to override the default
//   hash table size of (which is fairly small)
{
	ASSERT_VALID(this);
	ASSERT(m_nCount == 0);
	ASSERT(nHashSize > 0);
	if (nHashSize == 0)
		nHashSize = 17;	// default value

	if (m_pHashTable != NULL)
	{
		// free hash table
		delete[] m_pHashTable;
		m_pHashTable = NULL;
	}

	if (bAllocNow)
	{
		m_pHashTable = new CAssoc* [nHashSize];
		memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);
	}
	m_nHashTableSize = nHashSize;
}

void CMapPtrToWord::RemoveAll()
{
	ASSERT_VALID(this);



	if (m_pHashTable != NULL)
	{
		// free hash table
		delete[] m_pHashTable;
		m_pHashTable = NULL;
	}

	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
}

CMapPtrToWord::~CMapPtrToWord()
{
	RemoveAll();
	ASSERT(m_nCount == 0);
}

/////////////////////////////////////////////////////////////////////////////
// Assoc helpers
// same as CList implementation except we store CAssoc's not CNode's
//    and CAssoc's are singly linked all the time

CMapPtrToWord::CAssoc*
CMapPtrToWord::NewAssoc()
{
	if (m_pFreeList == NULL)
	{
		// add another block
		CPlex* newBlock = CPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CMapPtrToWord::CAssoc));
		// chain them into free list
		CMapPtrToWord::CAssoc* pAssoc = (CMapPtrToWord::CAssoc*) newBlock->data();
		// free in reverse order to make it easier to debug
		pAssoc += m_nBlockSize - 1;
		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pAssoc--)
		{
			pAssoc->pNext = m_pFreeList;
			m_pFreeList = pAssoc;
		}
	}
	ASSERT(m_pFreeList != NULL);  // we must have something

	CMapPtrToWord::CAssoc* pAssoc = m_pFreeList;
	m_pFreeList = m_pFreeList->pNext;
	m_nCount++;
	ASSERT(m_nCount > 0);  // make sure we don't overflow


	pAssoc->key = 0;




	pAssoc->value = 0;

	return pAssoc;
}

void CMapPtrToWord::FreeAssoc(CMapPtrToWord::CAssoc* pAssoc)
{

	pAssoc->pNext = m_pFreeList;
	m_pFreeList = pAssoc;
	m_nCount--;
	ASSERT(m_nCount >= 0);  // make sure we don't underflow

	// if no more elements, cleanup completely
	if (m_nCount == 0)
		RemoveAll();
}

CMapPtrToWord::CAssoc*
CMapPtrToWord::GetAssocAt(void* key, UINT& nHashBucket, UINT& nHashValue) const
// find association (or return NULL)
{
	nHashValue = HashKey(key);
	nHashBucket = nHashValue % m_nHashTableSize;

	if (m_pHashTable == NULL)
		return NULL;

	// see if it exists
	CAssoc* pAssoc;
	for (pAssoc = m_pHashTable[nHashBucket]; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{

		if (pAssoc->key == key)
			return pAssoc;

	}
	return NULL;
}



/////////////////////////////////////////////////////////////////////////////

BOOL CMapPtrToWord::Lookup(void* key, WORD& rValue) const
{
	ASSERT_VALID(this);

	UINT nHashBucket, nHashValue;
	CAssoc* pAssoc = GetAssocAt(key, nHashBucket, nHashValue);
	if (pAssoc == NULL)
		return FALSE;  // not in map

	rValue = pAssoc->value;
	return TRUE;
}

WORD& CMapPtrToWord::operator[](void* key)
{
	ASSERT_VALID(this);

	UINT nHashBucket, nHashValue;
	CAssoc* pAssoc;
	if ((pAssoc = GetAssocAt(key, nHashBucket, nHashValue)) == NULL)
	{
		if (m_pHashTable == NULL)
			InitHashTable(m_nHashTableSize);

		// it doesn't exist, add a new Association
		pAssoc = NewAssoc();

		pAssoc->key = key;
		// 'pAssoc->value' is a constructed object, nothing more

		// put into hash table
		pAssoc->pNext = m_pHashTable[nHashBucket];
		m_pHashTable[nHashBucket] = pAssoc;
	}
	return pAssoc->value;  // return new reference
}


BOOL CMapPtrToWord::RemoveKey(void* key)
// remove key - return TRUE if removed
{
	ASSERT_VALID(this);

	if (m_pHashTable == NULL)
		return FALSE;  // nothing in the table

	CAssoc** ppAssocPrev;
	ppAssocPrev = &m_pHashTable[HashKey(key) % m_nHashTableSize];

	CAssoc* pAssoc;
	for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if (pAssoc->key == key)
		{
			// remove it
			*ppAssocPrev = pAssoc->pNext;  // remove from list
			FreeAssoc(pAssoc);
			return TRUE;
		}
		ppAssocPrev = &pAssoc->pNext;
	}
	return FALSE;  // not found
}


/////////////////////////////////////////////////////////////////////////////
// Iterating

void CMapPtrToWord::GetNextAssoc(POSITION& rNextPosition,
	void*& rKey, WORD& rValue) const
{
	ASSERT_VALID(this);
	ASSERT(m_pHashTable != NULL);  // never call on empty map

	CAssoc* pAssocRet = (CAssoc*)rNextPosition;
	ASSERT(pAssocRet != NULL);
	if (pAssocRet == NULL)
		return;

	if (pAssocRet == (CAssoc*) BEFORE_START_POSITION)
	{
		// find the first association
		for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
		{
			if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
			{
				break;
			}
		}
		ENSURE(pAssocRet != NULL);  // must find something
	}

	// find next association
	ASSERT(AfxIsValidAddress(pAssocRet, sizeof(CAssoc)));
	CAssoc* pAssocNext;
	if ((pAssocNext = pAssocRet->pNext) == NULL)
	{
		// go to next bucket

		for (UINT nBucket = (HashKey(pAssocRet->key) % m_nHashTableSize) + 1;

		  nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
				break;
	}

	rNextPosition = (POSITION) pAssocNext;

	// fill in return data
	rKey = pAssocRet->key;
	rValue = pAssocRet->value;
}


/////////////////////////////////////////////////////////////////////////////
// Diagnostics

#ifdef _DEBUG
void CMapPtrToWord::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	dc << "with " << LONGLONG(m_nCount) << " elements";
	if (dc.GetDepth() > 0)
	{
		// Dump in format "[key] -> value"
		void* key;
		WORD val;

		POSITION pos = GetStartPosition();
		while (pos != NULL)
		{
			GetNextAssoc(pos, key, val);
			dc << "\n\t[" << key << "] = " << val;
		}
	}

	dc << "\n";
}

void CMapPtrToWord::AssertValid() const
{
	CObject::AssertValid();

	ASSERT(m_nHashTableSize > 0);
	ASSERT(m_nCount == 0 || m_pHashTable != NULL);
		// non-empty map should have hash table
}
#endif //_DEBUG



IMPLEMENT_DYNAMIC(CMapPtrToWord, CObject)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\list_o.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
//
// Implementation of parameterized List
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"





#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////

CObList::CObList(INT_PTR nBlockSize)
{
	ASSERT(nBlockSize > 0);

	m_nCount = 0;
	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
	m_pBlocks = NULL;
	m_nBlockSize = nBlockSize;
}

void CObList::RemoveAll()
{
	ASSERT_VALID(this);

	// destroy elements


	m_nCount = 0;
	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
}

CObList::~CObList()
{
	RemoveAll();
	ASSERT(m_nCount == 0);
}

/////////////////////////////////////////////////////////////////////////////
// Node helpers
/*
 * Implementation note: CNode's are stored in CPlex blocks and
 *  chained together. Free blocks are maintained in a singly linked list
 *  using the 'pNext' member of CNode with 'm_pNodeFree' as the head.
 *  Used blocks are maintained in a doubly linked list using both 'pNext'
 *  and 'pPrev' as links and 'm_pNodeHead' and 'm_pNodeTail'
 *   as the head/tail.
 *
 * We never free a CPlex block unless the List is destroyed or RemoveAll()
 *  is used - so the total number of CPlex blocks may grow large depending
 *  on the maximum past size of the list.
 */

CObList::CNode*
CObList::NewNode(CObList::CNode* pPrev, CObList::CNode* pNext)
{
	if (m_pNodeFree == NULL)
	{
		// add another block
		CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,
				 sizeof(CNode));

		// chain them into free list
		CNode* pNode = (CNode*) pNewBlock->data();
		// free in reverse order to make it easier to debug
		pNode += m_nBlockSize - 1;
		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pNode--)
		{
			pNode->pNext = m_pNodeFree;
			m_pNodeFree = pNode;
		}
	}
	ASSERT(m_pNodeFree != NULL);  // we must have something

	CObList::CNode* pNode = m_pNodeFree;
	m_pNodeFree = m_pNodeFree->pNext;
	pNode->pPrev = pPrev;
	pNode->pNext = pNext;
	m_nCount++;
	ASSERT(m_nCount > 0);  // make sure we don't overflow




	pNode->data = 0; // start with zero

	return pNode;
}

void CObList::FreeNode(CObList::CNode* pNode)
{
	if (pNode == NULL)
	{
		AfxThrowInvalidArgException();
	}
	pNode->pNext = m_pNodeFree;
	m_pNodeFree = pNode;
	m_nCount--;
	ASSERT(m_nCount >= 0);  // make sure we don't underflow

	// if no more elements, cleanup completely
	if (m_nCount == 0)
		RemoveAll();
}

/////////////////////////////////////////////////////////////////////////////

POSITION CObList::AddHead(CObject* newElement)
{

	ASSERT_VALID(this);

	CNode* pNewNode = NewNode(NULL, m_pNodeHead);
	pNewNode->data = newElement;
	if (m_pNodeHead != NULL)
		m_pNodeHead->pPrev = pNewNode;
	else
		m_pNodeTail = pNewNode;
	m_pNodeHead = pNewNode;
	return (POSITION) pNewNode;

}



POSITION CObList::AddTail(CObject* newElement)
{

	ASSERT_VALID(this);

	CNode* pNewNode = NewNode(m_pNodeTail, NULL);
	pNewNode->data = newElement;
	if (m_pNodeTail != NULL)
		m_pNodeTail->pNext = pNewNode;
	else
		m_pNodeHead = pNewNode;
	m_pNodeTail = pNewNode;
	return (POSITION) pNewNode;

}



void CObList::AddHead(CObList* pNewList)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pNewList);
	if (pNewList == NULL)
	{
		AfxThrowInvalidArgException();
	}
	ASSERT_KINDOF(CObList, pNewList);

	// add a list of same elements to head (maintain order)
	POSITION pos = pNewList->GetTailPosition();
	while (pos != NULL)
		AddHead(pNewList->GetPrev(pos));
}

void CObList::AddTail(CObList* pNewList)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pNewList);
	if (pNewList == NULL)
	{
		AfxThrowInvalidArgException();
	}
	ASSERT_KINDOF(CObList, pNewList);

	// add a list of same elements
	POSITION pos = pNewList->GetHeadPosition();
	while (pos != NULL)
		AddTail(pNewList->GetNext(pos));
}

CObject* CObList::RemoveHead()
{
	ENSURE_VALID(this);
	ENSURE(m_pNodeHead != NULL);  // throws if called on empty list

	ASSERT(AfxIsValidAddress(m_pNodeHead, sizeof(CNode)));

	CNode* pOldNode = m_pNodeHead;
	CObject* returnValue = pOldNode->data;

	m_pNodeHead = pOldNode->pNext;
	if (m_pNodeHead != NULL)
		m_pNodeHead->pPrev = NULL;
	else
		m_pNodeTail = NULL;
	FreeNode(pOldNode);
	return returnValue;
}

CObject* CObList::RemoveTail()
{
	ASSERT_VALID(this);
	ASSERT(m_pNodeTail != NULL);  // don't call on empty list !!!
	ASSERT(AfxIsValidAddress(m_pNodeTail, sizeof(CNode)));

	CNode* pOldNode = m_pNodeTail;
	CObject* returnValue = pOldNode->data;

	m_pNodeTail = pOldNode->pPrev;
	if (m_pNodeTail != NULL)
		m_pNodeTail->pNext = NULL;
	else
		m_pNodeHead = NULL;
	FreeNode(pOldNode);
	return returnValue;
}

POSITION CObList::InsertBefore(POSITION position, CObject* newElement)
{

	ASSERT_VALID(this);

	if (position == NULL)
		return AddHead(newElement); // insert before nothing -> head of the list

	// Insert it before position
	CNode* pOldNode = (CNode*) position;
	CNode* pNewNode = NewNode(pOldNode->pPrev, pOldNode);
	pNewNode->data = newElement;

	if (pOldNode->pPrev != NULL)
	{
		ASSERT(AfxIsValidAddress(pOldNode->pPrev, sizeof(CNode)));
		pOldNode->pPrev->pNext = pNewNode;
	}
	else
	{
		ASSERT(pOldNode == m_pNodeHead);
		m_pNodeHead = pNewNode;
	}
	pOldNode->pPrev = pNewNode;
	return (POSITION) pNewNode;

}



POSITION CObList::InsertAfter(POSITION position, CObject* newElement)
{

	ASSERT_VALID(this);

	if (position == NULL)
		return AddTail(newElement); // insert after nothing -> tail of the list

	// Insert it before position
	CNode* pOldNode = (CNode*) position;
	ASSERT(AfxIsValidAddress(pOldNode, sizeof(CNode)));
	CNode* pNewNode = NewNode(pOldNode, pOldNode->pNext);
	pNewNode->data = newElement;

	if (pOldNode->pNext != NULL)
	{
		ASSERT(AfxIsValidAddress(pOldNode->pNext, sizeof(CNode)));
		pOldNode->pNext->pPrev = pNewNode;
	}
	else
	{
		ASSERT(pOldNode == m_pNodeTail);
		m_pNodeTail = pNewNode;
	}
	pOldNode->pNext = pNewNode;
	return (POSITION) pNewNode;

}



void CObList::RemoveAt(POSITION position)
{
	ASSERT_VALID(this);

	CNode* pOldNode = (CNode*) position;
	ASSERT(AfxIsValidAddress(pOldNode, sizeof(CNode)));

	if (pOldNode == NULL)
	{
		AfxThrowInvalidArgException();
	}
	
	// remove pOldNode from list
	if (pOldNode == m_pNodeHead)
	{
		m_pNodeHead = pOldNode->pNext;
	}
	else
	{
		ASSERT(AfxIsValidAddress(pOldNode->pPrev, sizeof(CNode)));
		pOldNode->pPrev->pNext = pOldNode->pNext;
	}
	if (pOldNode == m_pNodeTail)
	{
		m_pNodeTail = pOldNode->pPrev;
	}
	else
	{
		ASSERT(AfxIsValidAddress(pOldNode->pNext, sizeof(CNode)));
		pOldNode->pNext->pPrev = pOldNode->pPrev;
	}
	FreeNode(pOldNode);
}


/////////////////////////////////////////////////////////////////////////////
// slow operations

POSITION CObList::FindIndex(INT_PTR nIndex) const
{
	ASSERT_VALID(this);

	if (nIndex >= m_nCount || nIndex < 0)
		return NULL;  // went too far

	CNode* pNode = m_pNodeHead;
	while (nIndex--)
	{
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		pNode = pNode->pNext;
	}
	return (POSITION) pNode;
}

POSITION CObList::Find(CObject* searchValue, POSITION startAfter) const
{
	ASSERT_VALID(this);

	CNode* pNode = (CNode*) startAfter;
	if (pNode == NULL)
	{
		pNode = m_pNodeHead;  // start at head
	}
	else
	{
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		pNode = pNode->pNext;  // start after the one specified
	}

	for (; pNode != NULL; pNode = pNode->pNext)
		if (pNode->data == searchValue)
			return (POSITION) pNode;
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// Serialization

void CObList::Serialize(CArchive& ar)
{
	ASSERT_VALID(this);

	CObject::Serialize(ar);

	if (ar.IsStoring())
	{
		ar.WriteCount(m_nCount);
		for (CNode* pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
		{
			ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
			ar << pNode->data;
		}
	}
	else
	{
		DWORD_PTR nNewCount = ar.ReadCount();
		CObject* newData;
		while (nNewCount--)
		{
			ar >> newData;
			AddTail(newData);
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// Diagnostics

#ifdef _DEBUG
void CObList::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	dc << "with " << LONGLONG(m_nCount) << " elements";
	if (dc.GetDepth() > 0)
	{
		POSITION pos = GetHeadPosition();
		while (pos != NULL)
			dc << "\n\t" << GetNext(pos);
	}

	dc << "\n";
}

void CObList::AssertValid() const
{
	CObject::AssertValid();

	if (m_nCount == 0)
	{
		// empty list
		ASSERT(m_pNodeHead == NULL);
		ASSERT(m_pNodeTail == NULL);
	}
	else
	{
		// non-empty list
		ASSERT(AfxIsValidAddress(m_pNodeHead, sizeof(CNode)));
		ASSERT(AfxIsValidAddress(m_pNodeTail, sizeof(CNode)));
	}
}
#endif //_DEBUG



IMPLEMENT_SERIAL(CObList, CObject, 0)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\map_pp.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
//
// Implementation of parmeterized Map
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <afxtempl.h>

#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////

CMapPtrToPtr::CMapPtrToPtr(INT_PTR nBlockSize)
{
	ASSERT(nBlockSize > 0);
	if (nBlockSize <= 0)
		nBlockSize = 10;	// default size

	m_pHashTable = NULL;
	m_nHashTableSize = 17;  // default size
	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks = NULL;
	m_nBlockSize = nBlockSize;
}

inline UINT CMapPtrToPtr::HashKey(void* key) const
{
	return (::HashKey<DWORD_PTR>((DWORD_PTR)key));
}

void CMapPtrToPtr::InitHashTable(
	UINT nHashSize, BOOL bAllocNow)
//
// Used to force allocation of a hash table or to override the default
//   hash table size of (which is fairly small)
{
	ASSERT_VALID(this);
	ASSERT(m_nCount == 0);
	ASSERT(nHashSize > 0);
	if (nHashSize == 0)
		nHashSize = 17;	// default value

	if (m_pHashTable != NULL)
	{
		// free hash table
		delete[] m_pHashTable;
		m_pHashTable = NULL;
	}

	if (bAllocNow)
	{
		m_pHashTable = new CAssoc* [nHashSize];
		memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);
	}
	m_nHashTableSize = nHashSize;
}

void CMapPtrToPtr::RemoveAll()
{
	ASSERT_VALID(this);



	if (m_pHashTable != NULL)
	{
		// free hash table
		delete[] m_pHashTable;
		m_pHashTable = NULL;
	}

	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
}

CMapPtrToPtr::~CMapPtrToPtr()
{
	RemoveAll();
	ASSERT(m_nCount == 0);
}

/////////////////////////////////////////////////////////////////////////////
// Assoc helpers
// same as CList implementation except we store CAssoc's not CNode's
//    and CAssoc's are singly linked all the time

CMapPtrToPtr::CAssoc*
CMapPtrToPtr::NewAssoc()
{
	if (m_pFreeList == NULL)
	{
		// add another block
		CPlex* newBlock = CPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CMapPtrToPtr::CAssoc));
		// chain them into free list
		CMapPtrToPtr::CAssoc* pAssoc = (CMapPtrToPtr::CAssoc*) newBlock->data();
		// free in reverse order to make it easier to debug
		pAssoc += m_nBlockSize - 1;
		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pAssoc--)
		{
			pAssoc->pNext = m_pFreeList;
			m_pFreeList = pAssoc;
		}
	}
	ASSERT(m_pFreeList != NULL);  // we must have something

	CMapPtrToPtr::CAssoc* pAssoc = m_pFreeList;
	m_pFreeList = m_pFreeList->pNext;
	m_nCount++;
	ASSERT(m_nCount > 0);  // make sure we don't overflow


	pAssoc->key = 0;




	pAssoc->value = 0;

	return pAssoc;
}

void CMapPtrToPtr::FreeAssoc(CMapPtrToPtr::CAssoc* pAssoc)
{

	pAssoc->pNext = m_pFreeList;
	m_pFreeList = pAssoc;
	m_nCount--;
	ASSERT(m_nCount >= 0);  // make sure we don't underflow

	// if no more elements, cleanup completely
	if (m_nCount == 0)
		RemoveAll();
}

CMapPtrToPtr::CAssoc*
CMapPtrToPtr::GetAssocAt(void* key, UINT& nHashBucket, UINT& nHashValue) const
// find association (or return NULL)
{
	nHashValue = HashKey(key);
	nHashBucket = nHashValue % m_nHashTableSize;

	if (m_pHashTable == NULL)
		return NULL;

	// see if it exists
	CAssoc* pAssoc;
	for (pAssoc = m_pHashTable[nHashBucket]; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{

		if (pAssoc->key == key)
			return pAssoc;

	}
	return NULL;
}


void* CMapPtrToPtr::GetValueAt(void* key) const
// find value (or return NULL -- NULL values not different as a result)
{
	ENSURE(this);

	if (m_pHashTable == NULL)
		return NULL;

	UINT nHash = HashKey(key) % m_nHashTableSize;

	// see if it exists
	CAssoc* pAssoc;
	for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if (pAssoc->key == key)
			return pAssoc->value;
	}
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////

BOOL CMapPtrToPtr::Lookup(void* key, void*& rValue) const
{
	ASSERT_VALID(this);

	UINT nHashBucket, nHashValue;
	CAssoc* pAssoc = GetAssocAt(key, nHashBucket, nHashValue);
	if (pAssoc == NULL)
		return FALSE;  // not in map

	rValue = pAssoc->value;
	return TRUE;
}

void*& CMapPtrToPtr::operator[](void* key)
{
	ASSERT_VALID(this);

	UINT nHashBucket, nHashValue;
	CAssoc* pAssoc;
	if ((pAssoc = GetAssocAt(key, nHashBucket, nHashValue)) == NULL)
	{
		if (m_pHashTable == NULL)
			InitHashTable(m_nHashTableSize);

		// it doesn't exist, add a new Association
		pAssoc = NewAssoc();

		pAssoc->key = key;
		// 'pAssoc->value' is a constructed object, nothing more

		// put into hash table
		pAssoc->pNext = m_pHashTable[nHashBucket];
		m_pHashTable[nHashBucket] = pAssoc;
	}
	return pAssoc->value;  // return new reference
}


BOOL CMapPtrToPtr::RemoveKey(void* key)
// remove key - return TRUE if removed
{
	ASSERT_VALID(this);

	if (m_pHashTable == NULL)
		return FALSE;  // nothing in the table

	CAssoc** ppAssocPrev;
	ppAssocPrev = &m_pHashTable[HashKey(key) % m_nHashTableSize];

	CAssoc* pAssoc;
	for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if (pAssoc->key == key)
		{
			// remove it
			*ppAssocPrev = pAssoc->pNext;  // remove from list
			FreeAssoc(pAssoc);
			return TRUE;
		}
		ppAssocPrev = &pAssoc->pNext;
	}
	return FALSE;  // not found
}


/////////////////////////////////////////////////////////////////////////////
// Iterating

void CMapPtrToPtr::GetNextAssoc(POSITION& rNextPosition,
	void*& rKey, void*& rValue) const
{
	ASSERT_VALID(this);
	ASSERT(m_pHashTable != NULL);  // never call on empty map

	CAssoc* pAssocRet = (CAssoc*)rNextPosition;
	ASSERT(pAssocRet != NULL);
	if (pAssocRet == NULL)
		return;

	if (pAssocRet == (CAssoc*) BEFORE_START_POSITION)
	{
		// find the first association
		for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
        {
			if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
            {
				break;
            }
        }
		ENSURE(pAssocRet != NULL);  // must find something
	}

	// find next association
	ASSERT(AfxIsValidAddress(pAssocRet, sizeof(CAssoc)));
	CAssoc* pAssocNext;
	if ((pAssocNext = pAssocRet->pNext) == NULL)
	{
		// go to next bucket

		for (UINT nBucket = (HashKey(pAssocRet->key) % m_nHashTableSize) + 1;

		  nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
				break;
	}

	rNextPosition = (POSITION) pAssocNext;

	// fill in return data
	rKey = pAssocRet->key;
	rValue = pAssocRet->value;
}


/////////////////////////////////////////////////////////////////////////////
// Diagnostics

#ifdef _DEBUG
void CMapPtrToPtr::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	dc << "with " << LONGLONG(m_nCount) << " elements";
	if (dc.GetDepth() > 0)
	{
		// Dump in format "[key] -> value"
		void* key;
		void* val;

		POSITION pos = GetStartPosition();
		while (pos != NULL)
		{
			GetNextAssoc(pos, key, val);
			dc << "\n\t[" << key << "] = " << val;
		}
	}

	dc << "\n";
}

void CMapPtrToPtr::AssertValid() const
{
	CObject::AssertValid();

	ASSERT(m_nHashTableSize > 0);
	ASSERT(m_nCount == 0 || m_pHashTable != NULL);
		// non-empty map should have hash table
}
#endif //_DEBUG



IMPLEMENT_DYNAMIC(CMapPtrToPtr, CObject)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\map_sp.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
//
// Implementation of parmeterized Map from CString to value
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#include "elements.h"  // used for special creation

#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////

CMapStringToPtr::CMapStringToPtr(INT_PTR nBlockSize)
{
	ASSERT(nBlockSize > 0);
	if (nBlockSize <= 0)
		nBlockSize = 10;	// default size

	m_pHashTable = NULL;
	m_nHashTableSize = 17;  // default size
	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks = NULL;
	m_nBlockSize = nBlockSize;
}

inline UINT CMapStringToPtr::HashKey(LPCTSTR key) const
{
	if (key == NULL)
	{
		AfxThrowInvalidArgException();
	}

	// hash key to UINT value by pseudorandomizing transform
	// (algorithm copied from STL string hash in xfunctional)
	UINT uHashVal = 2166136261U;
	UINT uFirst = 0;
	UINT uLast = (UINT)_tcslen(key);
	UINT uStride = 1 + uLast / 10;

	for(; uFirst < uLast; uFirst += uStride)
	{
		uHashVal = 16777619U * uHashVal ^ (UINT)key[uFirst];
	}

	return(uHashVal);
}

void CMapStringToPtr::InitHashTable(
	UINT nHashSize, BOOL bAllocNow)
//
// Used to force allocation of a hash table or to override the default
//   hash table size of (which is fairly small)
{
	ASSERT_VALID(this);
	ASSERT(m_nCount == 0);
	ASSERT(nHashSize > 0);
	if (nHashSize == 0)
		nHashSize = 17;	// default value

	if (m_pHashTable != NULL)
	{
		// free hash table
		delete[] m_pHashTable;
		m_pHashTable = NULL;
	}

	if (bAllocNow)
	{
		m_pHashTable = new CAssoc* [nHashSize];
		memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);
	}
	m_nHashTableSize = nHashSize;
}

void CMapStringToPtr::RemoveAll()
{
	ASSERT_VALID(this);

	if (m_pHashTable != NULL)
	{
		// destroy elements
		for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
		{
			CAssoc* pAssoc;
			for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
			  pAssoc = pAssoc->pNext)
			{
				DestructElement(&pAssoc->key);  // free up string data

			}
		}

		// free hash table
		delete [] m_pHashTable;
		m_pHashTable = NULL;
	}

	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
}

CMapStringToPtr::~CMapStringToPtr()
{
	RemoveAll();
	ASSERT(m_nCount == 0);
}

/////////////////////////////////////////////////////////////////////////////
// Assoc helpers
// same as CList implementation except we store CAssoc's not CNode's
//    and CAssoc's are singly linked all the time

CMapStringToPtr::CAssoc*
CMapStringToPtr::NewAssoc()
{
	if (m_pFreeList == NULL)
	{
		// add another block
		CPlex* newBlock = CPlex::Create(m_pBlocks, m_nBlockSize,
							sizeof(CMapStringToPtr::CAssoc));
		// chain them into free list
		CMapStringToPtr::CAssoc* pAssoc =
				(CMapStringToPtr::CAssoc*) newBlock->data();
		// free in reverse order to make it easier to debug
		pAssoc += m_nBlockSize - 1;
		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pAssoc--)
		{
			pAssoc->pNext = m_pFreeList;
			m_pFreeList = pAssoc;
		}
	}
	ASSERT(m_pFreeList != NULL);  // we must have something

	CMapStringToPtr::CAssoc* pAssoc = m_pFreeList;
	m_pFreeList = m_pFreeList->pNext;
	m_nCount++;
	ASSERT(m_nCount > 0);  // make sure we don't overflow
#pragma push_macro("new")
#undef new
	new( &pAssoc->key ) CString;
#pragma pop_macro("new")


	pAssoc->value = 0;

	return pAssoc;
}

void CMapStringToPtr::FreeAssoc(CMapStringToPtr::CAssoc* pAssoc)
{
	DestructElement(&pAssoc->key);  // free up string data

	pAssoc->pNext = m_pFreeList;
	m_pFreeList = pAssoc;
	m_nCount--;
	ASSERT(m_nCount >= 0);  // make sure we don't underflow

	// if no more elements, cleanup completely
	if (m_nCount == 0)
		RemoveAll();
}

CMapStringToPtr::CAssoc*
CMapStringToPtr::GetAssocAt(LPCTSTR key, UINT& nHashBucket, UINT& nHashValue) const
// find association (or return NULL)
{
	nHashValue = HashKey(key);
	nHashBucket = nHashValue % m_nHashTableSize;

	if (m_pHashTable == NULL)
		return NULL;

	// see if it exists
	CAssoc* pAssoc;
	for (pAssoc = m_pHashTable[nHashBucket]; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if (pAssoc->nHashValue == nHashValue && pAssoc->key == key)
			return pAssoc;
	}
	return NULL;
}

/////////////////////////////////////////////////////////////////////////////

BOOL CMapStringToPtr::Lookup(LPCTSTR key, void*& rValue) const
{
	ASSERT_VALID(this);

	UINT nHashBucket, nHashValue;
	CAssoc* pAssoc = GetAssocAt(key, nHashBucket, nHashValue);
	if (pAssoc == NULL)
		return FALSE;  // not in map

	rValue = pAssoc->value;
	return TRUE;
}

BOOL CMapStringToPtr::LookupKey(LPCTSTR key, LPCTSTR& rKey) const
{
	ASSERT_VALID(this);

	UINT nHashBucket, nHashValue;
	CAssoc* pAssoc = GetAssocAt(key, nHashBucket, nHashValue);
	if (pAssoc == NULL)
		return FALSE;  // not in map

	rKey = pAssoc->key;
	return TRUE;
}

void*& CMapStringToPtr::operator[](LPCTSTR key)
{
	ASSERT_VALID(this);

	UINT nHashBucket, nHashValue;
	CAssoc* pAssoc;
	if ((pAssoc = GetAssocAt(key, nHashBucket, nHashValue)) == NULL)
	{
		if (m_pHashTable == NULL)
			InitHashTable(m_nHashTableSize);

		// it doesn't exist, add a new Association
		pAssoc = NewAssoc();
		pAssoc->nHashValue = nHashValue;
		pAssoc->key = key;
		// 'pAssoc->value' is a constructed object, nothing more

		// put into hash table
		pAssoc->pNext = m_pHashTable[nHashBucket];
		m_pHashTable[nHashBucket] = pAssoc;
	}
	return pAssoc->value;  // return new reference
}


BOOL CMapStringToPtr::RemoveKey(LPCTSTR key)
// remove key - return TRUE if removed
{
	ASSERT_VALID(this);

	if (m_pHashTable == NULL)
		return FALSE;  // nothing in the table

	CAssoc** ppAssocPrev;
	UINT nHashValue;
	nHashValue = HashKey(key);
	ppAssocPrev = &m_pHashTable[nHashValue%m_nHashTableSize];

	CAssoc* pAssoc;
	for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if ((pAssoc->nHashValue == nHashValue) && (pAssoc->key == key))
		{
			// remove it
			*ppAssocPrev = pAssoc->pNext;  // remove from list
			FreeAssoc(pAssoc);
			return TRUE;
		}
		ppAssocPrev = &pAssoc->pNext;
	}
	return FALSE;  // not found
}


/////////////////////////////////////////////////////////////////////////////
// Iterating

void CMapStringToPtr::GetNextAssoc(POSITION& rNextPosition,
	CString& rKey, void*& rValue) const
{
	ASSERT_VALID(this);
	ASSERT(m_pHashTable != NULL);  // never call on empty map

	CAssoc* pAssocRet = (CAssoc*)rNextPosition;
	ASSERT(pAssocRet != NULL);
	if (pAssocRet == NULL)
		return;

	if (pAssocRet == (CAssoc*) BEFORE_START_POSITION)
	{
		// find the first association
		for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
		{
			if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
			{
				break;
			}
		}
		ENSURE(pAssocRet != NULL);  // must find something
	}

	// find next association
	ASSERT(AfxIsValidAddress(pAssocRet, sizeof(CAssoc)));
	CAssoc* pAssocNext;
	if ((pAssocNext = pAssocRet->pNext) == NULL)
	{
		// go to next bucket
		for (UINT nBucket = (pAssocRet->nHashValue % m_nHashTableSize) + 1;
		  nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
				break;
	}

	rNextPosition = (POSITION) pAssocNext;

	// fill in return data
	rKey = pAssocRet->key;
	rValue = pAssocRet->value;
}


/////////////////////////////////////////////////////////////////////////////
// Diagnostics

#ifdef _DEBUG
void CMapStringToPtr::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	dc << "with " << LONGLONG(m_nCount) << " elements";
	if (dc.GetDepth() > 0)
	{
		// Dump in format "[key] -> value"
		CString key;
		void* val;

		POSITION pos = GetStartPosition();
		while (pos != NULL)
		{
			GetNextAssoc(pos, key, val);
			dc << "\n\t[" << key << "] = " << val;
		}
	}

	dc << "\n";
}

void CMapStringToPtr::AssertValid() const
{
	CObject::AssertValid();

	ASSERT(m_nHashTableSize > 0);
	ASSERT(m_nCount == 0 || m_pHashTable != NULL);
		// non-empty map should have hash table
}
#endif //_DEBUG



IMPLEMENT_DYNAMIC(CMapStringToPtr, CObject)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\map_ss.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
//
// Implementation of parmeterized Map from CString to value
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#include "elements.h"  // used for special creation

#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////

CMapStringToString::CMapStringToString(INT_PTR nBlockSize)
{
	ASSERT(nBlockSize > 0);
	if (nBlockSize <= 0)
		nBlockSize = 10;	// default size

	m_pHashTable = NULL;
	m_nHashTableSize = 17;  // default size
	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks = NULL;
	m_nBlockSize = nBlockSize;
}

inline UINT CMapStringToString::HashKey(LPCTSTR key) const
{
	if (key == NULL)
	{
		AfxThrowInvalidArgException();
	}

	// hash key to UINT value by pseudorandomizing transform
	// (algorithm copied from STL string hash in xfunctional)
	UINT uHashVal = 2166136261U;
	UINT uFirst = 0;
	UINT uLast = (UINT)_tcslen(key);
	UINT uStride = 1 + uLast / 10;

	for(; uFirst < uLast; uFirst += uStride)
	{
		uHashVal = 16777619U * uHashVal ^ (UINT)key[uFirst];
	}

	return(uHashVal);
}

void CMapStringToString::InitHashTable(
	UINT nHashSize, BOOL bAllocNow)
//
// Used to force allocation of a hash table or to override the default
//   hash table size of (which is fairly small)
{
	ASSERT_VALID(this);
	ASSERT(m_nCount == 0);
	ASSERT(nHashSize > 0);
	if (nHashSize == 0)
		nHashSize = 17;	// default value

	if (m_pHashTable != NULL)
	{
		// free hash table
		delete[] m_pHashTable;
		m_pHashTable = NULL;
	}

	if (bAllocNow)
	{
		m_pHashTable = new CAssoc* [nHashSize];
		memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);
	}
	m_nHashTableSize = nHashSize;
}

void CMapStringToString::RemoveAll()
{
	ASSERT_VALID(this);

	if (m_pHashTable != NULL)
	{
		// destroy elements
		for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
		{
			CAssoc* pAssoc;
			for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
			  pAssoc = pAssoc->pNext)
			{
				pAssoc->~CAssoc();
				//DestructElement((CString*)&pAssoc->key);  // free up string data
				//DestructElement(&pAssoc->value);

			}
		}

		// free hash table
		delete [] m_pHashTable;
		m_pHashTable = NULL;
	}

	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
}

CMapStringToString::~CMapStringToString()
{
	RemoveAll();
	ASSERT(m_nCount == 0);
}

/////////////////////////////////////////////////////////////////////////////
// Assoc helpers
// same as CList implementation except we store CAssoc's not CNode's
//    and CAssoc's are singly linked all the time

CMapStringToString::CAssoc*
CMapStringToString::NewAssoc(LPCTSTR key)
{
	if (m_pFreeList == NULL)
	{
		// add another block
		CPlex* newBlock = CPlex::Create(m_pBlocks, m_nBlockSize,
							sizeof(CMapStringToString::CAssoc));
		// chain them into free list
		CMapStringToString::CAssoc* pAssoc =
				(CMapStringToString::CAssoc*) newBlock->data();
		// free in reverse order to make it easier to debug
		pAssoc += m_nBlockSize - 1;
		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pAssoc--)
		{
			pAssoc->pNext = m_pFreeList;
			m_pFreeList = pAssoc;
		}
	}
	ASSERT(m_pFreeList != NULL);  // we must have something

	CMapStringToString::CAssoc* pAssoc = m_pFreeList;
	m_pFreeList = m_pFreeList->pNext;
	m_nCount++;
	ASSERT(m_nCount > 0);  // make sure we don't overflow
#pragma push_macro("new")
#undef new
	::new(pAssoc) CAssoc(key);
#pragma pop_macro("new")
//	CString::Construct(&pAssoc->key);
//	ConstructElement(&pAssoc->value);

	return pAssoc;
}

void CMapStringToString::FreeAssoc(CMapStringToString::CAssoc* pAssoc)
{
	pAssoc->~CAssoc();
//	DestructElement((CString*)&pAssoc->key);  // free up string data
//	DestructElement(&pAssoc->value);

	pAssoc->pNext = m_pFreeList;
	m_pFreeList = pAssoc;
	m_nCount--;
	ASSERT(m_nCount >= 0);  // make sure we don't underflow

	// if no more elements, cleanup completely
	if (m_nCount == 0)
		RemoveAll();
}

CMapStringToString::CAssoc*
CMapStringToString::GetAssocAt(LPCTSTR key, UINT& nHashBucket, UINT& nHashValue) const
// find association (or return NULL)
{
	nHashValue = HashKey(key);
	nHashBucket = nHashValue % m_nHashTableSize;

	if (m_pHashTable == NULL)
		return NULL;

	// see if it exists
	CAssoc* pAssoc;
	for (pAssoc = m_pHashTable[nHashBucket]; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if (pAssoc->nHashValue == nHashValue && pAssoc->key == key)
			return pAssoc;
	}
	return NULL;
}

/////////////////////////////////////////////////////////////////////////////

const CMapStringToString::CPair *CMapStringToString::PLookup(LPCTSTR key) const
{
	ASSERT_VALID(this);

	UINT nHashBucket, nHashValue;
	CAssoc* pAssoc = GetAssocAt(key, nHashBucket, nHashValue);
	return pAssoc;
}

CMapStringToString::CPair *CMapStringToString::PLookup(LPCTSTR key)
{
	ASSERT_VALID(this);

	UINT nHashBucket, nHashValue;
	CAssoc* pAssoc = GetAssocAt(key, nHashBucket, nHashValue);
	return pAssoc;
}

BOOL CMapStringToString::Lookup(LPCTSTR key, CString& rValue) const
{
	ASSERT_VALID(this);

	UINT nHashBucket, nHashValue;
	CAssoc* pAssoc = GetAssocAt(key, nHashBucket, nHashValue);
	if (pAssoc == NULL)
		return FALSE;  // not in map

	rValue = pAssoc->value;
	return TRUE;
}

BOOL CMapStringToString::LookupKey(LPCTSTR key, LPCTSTR& rKey) const
{
	ASSERT_VALID(this);

	UINT nHashBucket, nHashValue;
	CAssoc* pAssoc = GetAssocAt(key, nHashBucket, nHashValue);
	if (pAssoc == NULL)
		return FALSE;  // not in map

	rKey = pAssoc->key;
	return TRUE;
}

CString& CMapStringToString::operator[](LPCTSTR key)
{
	ASSERT_VALID(this);

	UINT nHashBucket, nHashValue;
	CAssoc* pAssoc;
	if ((pAssoc = GetAssocAt(key, nHashBucket, nHashValue)) == NULL)
	{
		if (m_pHashTable == NULL)
			InitHashTable(m_nHashTableSize);

		// it doesn't exist, add a new Association
		pAssoc = NewAssoc(key);
		pAssoc->nHashValue = nHashValue;
		// 'pAssoc->value' is a constructed object, nothing more

		// put into hash table
		pAssoc->pNext = m_pHashTable[nHashBucket];
		m_pHashTable[nHashBucket] = pAssoc;
	}
	return pAssoc->value;  // return new reference
}


BOOL CMapStringToString::RemoveKey(LPCTSTR key)
// remove key - return TRUE if removed
{
	ASSERT_VALID(this);

	if (m_pHashTable == NULL)
		return FALSE;  // nothing in the table

	CAssoc** ppAssocPrev;
	UINT nHashValue;
	nHashValue = HashKey(key);
	ppAssocPrev = &m_pHashTable[nHashValue%m_nHashTableSize];

	CAssoc* pAssoc;
	for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if ((pAssoc->nHashValue == nHashValue) && (pAssoc->key == key))
		{
			// remove it
			*ppAssocPrev = pAssoc->pNext;  // remove from list
			FreeAssoc(pAssoc);
			return TRUE;
		}
		ppAssocPrev = &pAssoc->pNext;
	}
	return FALSE;  // not found
}


/////////////////////////////////////////////////////////////////////////////
// Iterating

const CMapStringToString::CPair *CMapStringToString::PGetFirstAssoc() const
{
	ASSERT_VALID(this);
	ASSERT(m_pHashTable != NULL);  // never call on empty map

	if( m_nCount == 0 ) return NULL;

	CAssoc* pAssocRet = NULL;

	// find the first association
	for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
		if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
			break;
	ASSERT(pAssocRet != NULL);  // must find something

	return pAssocRet;
}

CMapStringToString::CPair *CMapStringToString::PGetFirstAssoc()
{
	ASSERT_VALID(this);
	ASSERT(m_pHashTable != NULL);  // never call on empty map

	if( m_nCount == 0 ) return NULL;

	CAssoc* pAssocRet = NULL;

	// find the first association
	for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
		if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
			break;
	ASSERT(pAssocRet != NULL);  // must find something

	return pAssocRet;
}

void CMapStringToString::GetNextAssoc(POSITION& rNextPosition,
	CString& rKey, CString& rValue) const
{
	ASSERT_VALID(this);
	ASSERT(m_pHashTable != NULL);  // never call on empty map

	CAssoc* pAssocRet = (CAssoc*)rNextPosition;
	ASSERT(pAssocRet != NULL);
	if (pAssocRet == NULL)
		return;

	if (pAssocRet == (CAssoc*) BEFORE_START_POSITION)
	{
		// find the first association
		for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
		{
			if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
			{
				break;
			}
		}
		ENSURE(pAssocRet != NULL);  // must find something
	}

	// find next association
	ASSERT(AfxIsValidAddress(pAssocRet, sizeof(CAssoc)));
	CAssoc* pAssocNext;
	if ((pAssocNext = pAssocRet->pNext) == NULL)
	{
		// go to next bucket
		for (UINT nBucket = (pAssocRet->nHashValue % m_nHashTableSize) + 1;
		  nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
				break;
	}

	rNextPosition = (POSITION) pAssocNext;

	// fill in return data
	rKey = pAssocRet->key;
	rValue = pAssocRet->value;
}

const CMapStringToString::CPair *CMapStringToString::PGetNextAssoc(const CPair *pAssoc) const
{
	ASSERT_VALID(this);
	ASSERT(m_pHashTable != NULL);  // never call on empty map

	CAssoc* pAssocRet = (CAssoc*)pAssoc;
	ASSERT(pAssocRet != NULL);
	
	if(m_pHashTable == NULL || pAssocRet == NULL)
		return NULL;
		
	ASSERT(pAssocRet != (CAssoc*)BEFORE_START_POSITION );

	// find next association
	ASSERT(AfxIsValidAddress(pAssocRet, sizeof(CAssoc)));
	CAssoc* pAssocNext;
	if ((pAssocNext = pAssocRet->pNext) == NULL)
	{
		// go to next bucket
		for (UINT nBucket = (pAssocRet->nHashValue % m_nHashTableSize) + 1;
		  nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
				break;
	}

	return pAssocNext;
}

CMapStringToString::CPair *CMapStringToString::PGetNextAssoc(const CPair *pAssoc)
{
	ASSERT_VALID(this);
	ASSERT(m_pHashTable != NULL);  // never call on empty map

	CAssoc* pAssocRet = (CAssoc*)pAssoc;
	ASSERT(pAssocRet != NULL);

	if(m_pHashTable == NULL || pAssocRet == NULL)
		return NULL;
	
	ASSERT(pAssocRet != (CAssoc*)BEFORE_START_POSITION );

	// find next association
	ASSERT(AfxIsValidAddress(pAssocRet, sizeof(CAssoc)));
	CAssoc* pAssocNext;
	if ((pAssocNext = pAssocRet->pNext) == NULL)
	{
		// go to next bucket
		for (UINT nBucket = (pAssocRet->nHashValue % m_nHashTableSize) + 1;
		  nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
				break;
	}

	return pAssocNext;
}


/////////////////////////////////////////////////////////////////////////////
// Serialization

void CMapStringToString::Serialize(CArchive& ar)
{
	ASSERT_VALID(this);

	CObject::Serialize(ar);

	if (ar.IsStoring())
	{
		ar.WriteCount(m_nCount);
		if (m_nCount == 0)
			return;  // nothing more to do

		ASSERT(m_pHashTable != NULL);
		for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
		{
			CAssoc* pAssoc;
			for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
			  pAssoc = pAssoc->pNext)
			{
				ar << pAssoc->key;
				ar << pAssoc->value;
			}
		}
	}
	else
	{
		DWORD_PTR nNewCount = ar.ReadCount();
		CString newKey;
		CString newValue;
		while (nNewCount--)
		{
			ar >> newKey;
			ar >> newValue;
			SetAt(newKey, newValue);
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// Diagnostics

#ifdef _DEBUG
void CMapStringToString::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	dc << "with " << LONGLONG(m_nCount) << " elements";
	if (dc.GetDepth() > 0)
	{
		// Dump in format "[key] -> value"
		CString key;
		CString val;

		POSITION pos = GetStartPosition();
		while (pos != NULL)
		{
			GetNextAssoc(pos, key, val);
			dc << "\n\t[" << key << "] = " << val;
		}
	}

	dc << "\n";
}

void CMapStringToString::AssertValid() const
{
	CObject::AssertValid();

	ASSERT(m_nHashTableSize > 0);
	ASSERT(m_nCount == 0 || m_pHashTable != NULL);
		// non-empty map should have hash table
}
#endif //_DEBUG



IMPLEMENT_SERIAL(CMapStringToString, CObject, 0)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\map_so.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
//
// Implementation of parmeterized Map from CString to value
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#include "elements.h"  // used for special creation

#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////

CMapStringToOb::CMapStringToOb(INT_PTR nBlockSize)
{
	ASSERT(nBlockSize > 0);
	if (nBlockSize <= 0)
		nBlockSize = 10;	// default size

	m_pHashTable = NULL;
	m_nHashTableSize = 17;  // default size
	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks = NULL;
	m_nBlockSize = nBlockSize;
}

inline UINT CMapStringToOb::HashKey(LPCTSTR key) const
{
	if (key == NULL)
	{
		AfxThrowInvalidArgException();
	}

	// hash key to UINT value by pseudorandomizing transform
	// (algorithm copied from STL string hash in xfunctional)
	UINT uHashVal = 2166136261U;
	UINT uFirst = 0;
	UINT uLast = (UINT)_tcslen(key);
	UINT uStride = 1 + uLast / 10;

	for(; uFirst < uLast; uFirst += uStride)
	{
		uHashVal = 16777619U * uHashVal ^ (UINT)key[uFirst];
	}

	return(uHashVal);
}

void CMapStringToOb::InitHashTable(
	UINT nHashSize, BOOL bAllocNow)
//
// Used to force allocation of a hash table or to override the default
//   hash table size of (which is fairly small)
{
	ASSERT_VALID(this);
	ASSERT(m_nCount == 0);
	ASSERT(nHashSize > 0);
	if (nHashSize == 0)
		nHashSize = 17;	// default value

	if (m_pHashTable != NULL)
	{
		// free hash table
		delete[] m_pHashTable;
		m_pHashTable = NULL;
	}

	if (bAllocNow)
	{
		m_pHashTable = new CAssoc* [nHashSize];
		memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);
	}
	m_nHashTableSize = nHashSize;
}

void CMapStringToOb::RemoveAll()
{
	ASSERT_VALID(this);

	if (m_pHashTable != NULL)
	{
		// destroy elements
		for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
		{
			CAssoc* pAssoc;
			for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
			  pAssoc = pAssoc->pNext)
			{
				DestructElement(&pAssoc->key);  // free up string data

			}
		}

		// free hash table
		delete [] m_pHashTable;
		m_pHashTable = NULL;
	}

	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
}

CMapStringToOb::~CMapStringToOb()
{
	RemoveAll();
	ASSERT(m_nCount == 0);
}

/////////////////////////////////////////////////////////////////////////////
// Assoc helpers
// same as CList implementation except we store CAssoc's not CNode's
//    and CAssoc's are singly linked all the time

CMapStringToOb::CAssoc*
CMapStringToOb::NewAssoc()
{
	if (m_pFreeList == NULL)
	{
		// add another block
		CPlex* newBlock = CPlex::Create(m_pBlocks, m_nBlockSize,
							sizeof(CMapStringToOb::CAssoc));
		// chain them into free list
		CMapStringToOb::CAssoc* pAssoc =
				(CMapStringToOb::CAssoc*) newBlock->data();
		// free in reverse order to make it easier to debug
		pAssoc += m_nBlockSize - 1;
		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pAssoc--)
		{
			pAssoc->pNext = m_pFreeList;
			m_pFreeList = pAssoc;
		}
	}
	ASSERT(m_pFreeList != NULL);  // we must have something

	CMapStringToOb::CAssoc* pAssoc = m_pFreeList;
	m_pFreeList = m_pFreeList->pNext;
	m_nCount++;
	ASSERT(m_nCount > 0);  // make sure we don't overflow
#pragma push_macro("new")
#undef new
	new( &pAssoc->key ) CString;
#pragma pop_macro("new")



	pAssoc->value = 0;

	return pAssoc;
}

void CMapStringToOb::FreeAssoc(CMapStringToOb::CAssoc* pAssoc)
{
	DestructElement(&pAssoc->key);  // free up string data

	pAssoc->pNext = m_pFreeList;
	m_pFreeList = pAssoc;
	m_nCount--;
	ASSERT(m_nCount >= 0);  // make sure we don't underflow

	// if no more elements, cleanup completely
	if (m_nCount == 0)
		RemoveAll();
}

CMapStringToOb::CAssoc*
CMapStringToOb::GetAssocAt(LPCTSTR key, UINT& nHashBucket, UINT& nHashValue) const
// find association (or return NULL)
{
	nHashValue = HashKey(key);
	nHashBucket = nHashValue % m_nHashTableSize;

	if (m_pHashTable == NULL)
		return NULL;

	// see if it exists
	CAssoc* pAssoc;
	for (pAssoc = m_pHashTable[nHashBucket]; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if (pAssoc->nHashValue == nHashValue && pAssoc->key == key)
			return pAssoc;
	}
	return NULL;
}

/////////////////////////////////////////////////////////////////////////////

BOOL CMapStringToOb::Lookup(LPCTSTR key, CObject*& rValue) const
{
	ASSERT_VALID(this);

	UINT nHashBucket, nHashValue;
	CAssoc* pAssoc = GetAssocAt(key, nHashBucket, nHashValue);
	if (pAssoc == NULL)
		return FALSE;  // not in map

	rValue = pAssoc->value;
	return TRUE;
}

BOOL CMapStringToOb::LookupKey(LPCTSTR key, LPCTSTR& rKey) const
{
	ASSERT_VALID(this);

	UINT nHashBucket, nHashValue;
	CAssoc* pAssoc = GetAssocAt(key, nHashBucket, nHashValue);
	if (pAssoc == NULL)
		return FALSE;  // not in map

	rKey = pAssoc->key;
	return TRUE;
}

CObject*& CMapStringToOb::operator[](LPCTSTR key)
{
	ASSERT_VALID(this);

	UINT nHashBucket, nHashValue;
	CAssoc* pAssoc;
	if ((pAssoc = GetAssocAt(key, nHashBucket, nHashValue)) == NULL)
	{
		if (m_pHashTable == NULL)
			InitHashTable(m_nHashTableSize);

		// it doesn't exist, add a new Association
		pAssoc = NewAssoc();
		pAssoc->nHashValue = nHashValue;
		pAssoc->key = key;
		// 'pAssoc->value' is a constructed object, nothing more

		// put into hash table
		pAssoc->pNext = m_pHashTable[nHashBucket];
		m_pHashTable[nHashBucket] = pAssoc;
	}
	return pAssoc->value;  // return new reference
}


BOOL CMapStringToOb::RemoveKey(LPCTSTR key)
// remove key - return TRUE if removed
{
	ASSERT_VALID(this);

	if (m_pHashTable == NULL)
		return FALSE;  // nothing in the table

	CAssoc** ppAssocPrev;
	UINT nHashValue;
	nHashValue = HashKey(key);
	ppAssocPrev = &m_pHashTable[nHashValue%m_nHashTableSize];

	CAssoc* pAssoc;
	for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if ((pAssoc->nHashValue == nHashValue) && (pAssoc->key == key))
		{
			// remove it
			*ppAssocPrev = pAssoc->pNext;  // remove from list
			FreeAssoc(pAssoc);
			return TRUE;
		}
		ppAssocPrev = &pAssoc->pNext;
	}
	return FALSE;  // not found
}


/////////////////////////////////////////////////////////////////////////////
// Iterating

void CMapStringToOb::GetNextAssoc(POSITION& rNextPosition,
	CString& rKey, CObject*& rValue) const
{
	ASSERT_VALID(this);
	ASSERT(m_pHashTable != NULL);  // never call on empty map

	CAssoc* pAssocRet = (CAssoc*)rNextPosition;
	ASSERT(pAssocRet != NULL);
	if (pAssocRet == NULL)
		return;

	if (pAssocRet == (CAssoc*) BEFORE_START_POSITION)
	{
		// find the first association
		for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
		{
			if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
			{
				break;
			}
		}
		ENSURE(pAssocRet != NULL);  // must find something
	}

	// find next association
	ASSERT(AfxIsValidAddress(pAssocRet, sizeof(CAssoc)));
	CAssoc* pAssocNext;
	if ((pAssocNext = pAssocRet->pNext) == NULL)
	{
		// go to next bucket
		for (UINT nBucket = (pAssocRet->nHashValue % m_nHashTableSize) + 1;
		  nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
				break;
	}

	rNextPosition = (POSITION) pAssocNext;

	// fill in return data
	rKey = pAssocRet->key;
	rValue = pAssocRet->value;
}


/////////////////////////////////////////////////////////////////////////////
// Serialization

void CMapStringToOb::Serialize(CArchive& ar)
{
	ASSERT_VALID(this);

	CObject::Serialize(ar);

	if (ar.IsStoring())
	{
		ar.WriteCount(m_nCount);
		if (m_nCount == 0)
			return;  // nothing more to do

		ASSERT(m_pHashTable != NULL);
		for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
		{
			CAssoc* pAssoc;
			for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
			  pAssoc = pAssoc->pNext)
			{
				ar << pAssoc->key;
				ar << pAssoc->value;
			}
		}
	}
	else
	{
		DWORD_PTR nNewCount = ar.ReadCount();
		CString newKey;
		CObject* newValue;
		while (nNewCount--)
		{
			ar >> newKey;
			ar >> newValue;
			SetAt(newKey, newValue);
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// Diagnostics

#ifdef _DEBUG
void CMapStringToOb::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	dc << "with " << LONGLONG(m_nCount) << " elements";
	if (dc.GetDepth() > 0)
	{
		// Dump in format "[key] -> value"
		CString key;
		CObject* val;

		POSITION pos = GetStartPosition();
		while (pos != NULL)
		{
			GetNextAssoc(pos, key, val);
			dc << "\n\t[" << key << "] = " << val;
		}
	}

	dc << "\n";
}

void CMapStringToOb::AssertValid() const
{
	CObject::AssertValid();

	ASSERT(m_nHashTableSize > 0);
	ASSERT(m_nCount == 0 || m_pHashTable != NULL);
		// non-empty map should have hash table
}
#endif //_DEBUG



IMPLEMENT_SERIAL(CMapStringToOb, CObject, 0)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\map_wo.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
//
// Implementation of parmeterized Map
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <afxtempl.h>

#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////

CMapWordToOb::CMapWordToOb(INT_PTR nBlockSize)
{
	ASSERT(nBlockSize > 0);
	if (nBlockSize <= 0)
		nBlockSize = 10;	// default size

	m_pHashTable = NULL;
	m_nHashTableSize = 17;  // default size
	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks = NULL;
	m_nBlockSize = nBlockSize;
}

inline UINT CMapWordToOb::HashKey(WORD key) const
{
	return (::HashKey<WORD>(key));
}

void CMapWordToOb::InitHashTable(
	UINT nHashSize, BOOL bAllocNow)
//
// Used to force allocation of a hash table or to override the default
//   hash table size of (which is fairly small)
{
	ASSERT_VALID(this);
	ASSERT(m_nCount == 0);
	ASSERT(nHashSize > 0);
	if (nHashSize == 0)
		nHashSize = 17;	// default value

	if (m_pHashTable != NULL)
	{
		// free hash table
		delete[] m_pHashTable;
		m_pHashTable = NULL;
	}

	if (bAllocNow)
	{
		m_pHashTable = new CAssoc* [nHashSize];
		memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);
	}
	m_nHashTableSize = nHashSize;
}

void CMapWordToOb::RemoveAll()
{
	ASSERT_VALID(this);



	if (m_pHashTable != NULL)
	{
		// free hash table
		delete[] m_pHashTable;
		m_pHashTable = NULL;
	}

	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
}

CMapWordToOb::~CMapWordToOb()
{
	RemoveAll();
	ASSERT(m_nCount == 0);
}

/////////////////////////////////////////////////////////////////////////////
// Assoc helpers
// same as CList implementation except we store CAssoc's not CNode's
//    and CAssoc's are singly linked all the time

CMapWordToOb::CAssoc*
CMapWordToOb::NewAssoc()
{
	if (m_pFreeList == NULL)
	{
		// add another block
		CPlex* newBlock = CPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CMapWordToOb::CAssoc));
		// chain them into free list
		CMapWordToOb::CAssoc* pAssoc = (CMapWordToOb::CAssoc*) newBlock->data();
		// free in reverse order to make it easier to debug
		pAssoc += m_nBlockSize - 1;
		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pAssoc--)
		{
			pAssoc->pNext = m_pFreeList;
			m_pFreeList = pAssoc;
		}
	}
	ASSERT(m_pFreeList != NULL);  // we must have something

	CMapWordToOb::CAssoc* pAssoc = m_pFreeList;
	m_pFreeList = m_pFreeList->pNext;
	m_nCount++;
	ASSERT(m_nCount > 0);  // make sure we don't overflow


	pAssoc->key = 0;




	pAssoc->value = 0;

	return pAssoc;
}

void CMapWordToOb::FreeAssoc(CMapWordToOb::CAssoc* pAssoc)
{

	pAssoc->pNext = m_pFreeList;
	m_pFreeList = pAssoc;
	m_nCount--;
	ASSERT(m_nCount >= 0);  // make sure we don't underflow

	// if no more elements, cleanup completely
	if (m_nCount == 0)
		RemoveAll();
}

CMapWordToOb::CAssoc*
CMapWordToOb::GetAssocAt(WORD key, UINT& nHashBucket, UINT& nHashValue) const
// find association (or return NULL)
{
	nHashValue = HashKey(key);
	nHashBucket = nHashValue % m_nHashTableSize;

	if (m_pHashTable == NULL)
		return NULL;

	// see if it exists
	CAssoc* pAssoc;
	for (pAssoc = m_pHashTable[nHashBucket]; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{

		if (pAssoc->key == key)
			return pAssoc;

	}
	return NULL;
}



/////////////////////////////////////////////////////////////////////////////

BOOL CMapWordToOb::Lookup(WORD key, CObject*& rValue) const
{
	ASSERT_VALID(this);

	UINT nHashBucket, nHashValue;
	CAssoc* pAssoc = GetAssocAt(key, nHashBucket, nHashValue);
	if (pAssoc == NULL)
		return FALSE;  // not in map

	rValue = pAssoc->value;
	return TRUE;
}

CObject*& CMapWordToOb::operator[](WORD key)
{
	ASSERT_VALID(this);

	UINT nHashBucket, nHashValue;
	CAssoc* pAssoc;
	if ((pAssoc = GetAssocAt(key, nHashBucket, nHashValue)) == NULL)
	{
		if (m_pHashTable == NULL)
			InitHashTable(m_nHashTableSize);

		// it doesn't exist, add a new Association
		pAssoc = NewAssoc();

		pAssoc->key = key;
		// 'pAssoc->value' is a constructed object, nothing more

		// put into hash table
		pAssoc->pNext = m_pHashTable[nHashBucket];
		m_pHashTable[nHashBucket] = pAssoc;
	}
	return pAssoc->value;  // return new reference
}


BOOL CMapWordToOb::RemoveKey(WORD key)
// remove key - return TRUE if removed
{
	ASSERT_VALID(this);

	if (m_pHashTable == NULL)
		return FALSE;  // nothing in the table

	CAssoc** ppAssocPrev;
	ppAssocPrev = &m_pHashTable[HashKey(key) % m_nHashTableSize];

	CAssoc* pAssoc;
	for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if (pAssoc->key == key)
		{
			// remove it
			*ppAssocPrev = pAssoc->pNext;  // remove from list
			FreeAssoc(pAssoc);
			return TRUE;
		}
		ppAssocPrev = &pAssoc->pNext;
	}
	return FALSE;  // not found
}


/////////////////////////////////////////////////////////////////////////////
// Iterating

void CMapWordToOb::GetNextAssoc(POSITION& rNextPosition,
	WORD& rKey, CObject*& rValue) const
{
	ASSERT_VALID(this);
	ASSERT(m_pHashTable != NULL);  // never call on empty map

	CAssoc* pAssocRet = (CAssoc*)rNextPosition;
	ASSERT(pAssocRet != NULL);
	if (pAssocRet == NULL)
		return;

	if (pAssocRet == (CAssoc*) BEFORE_START_POSITION)
	{
		// find the first association
		for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
		{
			if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
			{
				break;
			}
		}
		ENSURE(pAssocRet != NULL);  // must find something
	}

	// find next association
	ASSERT(AfxIsValidAddress(pAssocRet, sizeof(CAssoc)));
	CAssoc* pAssocNext;
	if ((pAssocNext = pAssocRet->pNext) == NULL)
	{
		// go to next bucket

		for (UINT nBucket = (HashKey(pAssocRet->key) % m_nHashTableSize) + 1;

		  nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
				break;
	}

	rNextPosition = (POSITION) pAssocNext;

	// fill in return data
	rKey = pAssocRet->key;
	rValue = pAssocRet->value;
}


/////////////////////////////////////////////////////////////////////////////
// Serialization

void CMapWordToOb::Serialize(CArchive& ar)
{
	ASSERT_VALID(this);

	CObject::Serialize(ar);

	if (ar.IsStoring())
	{
		ar.WriteCount(m_nCount);
		if (m_nCount == 0)
			return;  // nothing more to do

		ASSERT(m_pHashTable != NULL);
		for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
		{
			CAssoc* pAssoc;
			for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
			  pAssoc = pAssoc->pNext)
			{
				ar << pAssoc->key;
				ar << pAssoc->value;
			}
		}
	}
	else
	{
		DWORD_PTR nNewCount = ar.ReadCount();
		WORD newKey;
		CObject* newValue;
		while (nNewCount--)
		{
			ar >> newKey;
			ar >> newValue;
			SetAt(newKey, newValue);
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// Diagnostics

#ifdef _DEBUG
void CMapWordToOb::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	dc << "with " << LONGLONG(m_nCount) << " elements";
	if (dc.GetDepth() > 0)
	{
		// Dump in format "[key] -> value"
		WORD key;
		CObject* val;

		POSITION pos = GetStartPosition();
		while (pos != NULL)
		{
			GetNextAssoc(pos, key, val);
			dc << "\n\t[" << key << "] = " << val;
		}
	}

	dc << "\n";
}

void CMapWordToOb::AssertValid() const
{
	CObject::AssertValid();

	ASSERT(m_nHashTableSize > 0);
	ASSERT(m_nCount == 0 || m_pHashTable != NULL);
		// non-empty map should have hash table
}
#endif //_DEBUG



IMPLEMENT_SERIAL(CMapWordToOb, CObject, 0)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\mtcore.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"


#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// Basic synchronization object

CSyncObject::CSyncObject(LPCTSTR pstrName)
{
	UNUSED(pstrName);   // unused in release builds

	m_hObject = NULL;

#ifdef _DEBUG
	m_strName = pstrName;
#endif
}

CSyncObject::~CSyncObject()
{
	if (m_hObject != NULL)
	{
		::CloseHandle(m_hObject);
		m_hObject = NULL;
	}
}

BOOL CSyncObject::Lock(DWORD dwTimeout)
{
	DWORD dwRet = ::WaitForSingleObject(m_hObject, dwTimeout);
	if (dwRet == WAIT_OBJECT_0 || dwRet == WAIT_ABANDONED)
		return TRUE;
	else
		return FALSE;
}

#ifdef _DEBUG

void CSyncObject::Dump(CDumpContext& dc) const
{
	dc << "Object ";
	dc << m_hObject;
	dc << " named " << m_strName << "\n";
	CObject::Dump(dc);
}

void CSyncObject::AssertValid() const
{
	CObject::AssertValid();
}

#endif

//////////////////////////////////////////////////////////////////////////////
// Inline function declarations expanded out-of-line

#ifndef _AFX_ENABLE_INLINES

#define _AFXMT_INLINE
#include "afxmt.inl"

#endif


IMPLEMENT_DYNAMIC(CCriticalSection, CSyncObject)
IMPLEMENT_DYNAMIC(CSyncObject, CObject)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\mtex.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"


#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CSemaphore

CSemaphore::CSemaphore(LONG lInitialCount, LONG lMaxCount,
	LPCTSTR pstrName, LPSECURITY_ATTRIBUTES lpsaAttributes)
	:  CSyncObject(pstrName)
{
	ASSERT(lMaxCount > 0);
	ASSERT(lInitialCount <= lMaxCount);

	m_hObject = ::CreateSemaphore(lpsaAttributes, lInitialCount, lMaxCount,
		pstrName);
	if (m_hObject == NULL)
		AfxThrowResourceException();
}

CSemaphore::~CSemaphore()
{
}

BOOL CSemaphore::Unlock(LONG lCount, LPLONG lpPrevCount /* =NULL */)
{
	return ::ReleaseSemaphore(m_hObject, lCount, lpPrevCount);
}

/////////////////////////////////////////////////////////////////////////////
// CMutex

CMutex::CMutex(BOOL bInitiallyOwn, LPCTSTR pstrName,
	LPSECURITY_ATTRIBUTES lpsaAttribute /* = NULL */)
	: CSyncObject(pstrName)
{
	m_hObject = ::CreateMutex(lpsaAttribute, bInitiallyOwn, pstrName);
	if (m_hObject == NULL)
		AfxThrowResourceException();
}

CMutex::~CMutex()
{
}

BOOL CMutex::Unlock()
{
	return ::ReleaseMutex(m_hObject);
}

/////////////////////////////////////////////////////////////////////////////
// CEvent

CEvent::CEvent(BOOL bInitiallyOwn, BOOL bManualReset, LPCTSTR pstrName,
	LPSECURITY_ATTRIBUTES lpsaAttribute)
	: CSyncObject(pstrName)
{
	m_hObject = ::CreateEvent(lpsaAttribute, bManualReset,
		bInitiallyOwn, pstrName);
	if (m_hObject == NULL)
		AfxThrowResourceException();
}

CEvent::~CEvent()
{
}

BOOL CEvent::Unlock()
{
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CSingleLock

CSingleLock::CSingleLock(CSyncObject* pObject, BOOL bInitialLock)
{
	ASSERT(pObject != NULL);
	ASSERT(pObject->IsKindOf(RUNTIME_CLASS(CSyncObject)));

	if(pObject == NULL)
		AfxThrowInvalidArgException();
		
	m_pObject = pObject;
	m_hObject = pObject->m_hObject;
	m_bAcquired = FALSE;

	if (bInitialLock)
		Lock();
}

BOOL CSingleLock::Lock(DWORD dwTimeOut /* = INFINITE */)
{
	ASSERT(m_pObject != NULL || m_hObject != NULL);
	ASSERT(!m_bAcquired);

	m_bAcquired = m_pObject->Lock(dwTimeOut);
	return m_bAcquired;
}

BOOL CSingleLock::Unlock()
{
	ASSERT(m_pObject != NULL);
	if (m_bAcquired)
		m_bAcquired = !m_pObject->Unlock();

	// successfully unlocking means it isn't acquired
	return !m_bAcquired;
}

BOOL CSingleLock::Unlock(LONG lCount, LPLONG lpPrevCount /* = NULL */)
{
	ASSERT(m_pObject != NULL);
	if (m_bAcquired)
		m_bAcquired = !m_pObject->Unlock(lCount, lpPrevCount);

	// successfully unlocking means it isn't acquired
	return !m_bAcquired;
}

/////////////////////////////////////////////////////////////////////////////
// CMultiLock

CMultiLock::CMultiLock(CSyncObject* pObjects[], DWORD dwCount,
	BOOL bInitialLock)
{
	ASSERT(dwCount > 0 && dwCount <= MAXIMUM_WAIT_OBJECTS);
	ASSERT(pObjects != NULL);
	
	if(pObjects == NULL)
		AfxThrowInvalidArgException();
		
	m_ppObjectArray = pObjects;
	m_dwCount = dwCount;

	// as an optimization, skip allocating array if
	// we can use a small, preallocated bunch of handles

	if (m_dwCount > _countof(m_hPreallocated))
	{
		ATL::CAutoVectorPtr<HANDLE> spHandleArray(new HANDLE[m_dwCount]);
		ATL::CAutoVectorPtr<BOOL> spLockedArray(new BOOL[m_dwCount]);
		m_pHandleArray = spHandleArray.Detach();
		m_bLockedArray = spLockedArray.Detach();
	}
	else
	{
		m_pHandleArray = m_hPreallocated;
		m_bLockedArray = m_bPreallocated;
	}

	// get list of handles from array of objects passed
	for (DWORD i = 0; i <m_dwCount; i++)
	{
		ASSERT_VALID(pObjects[i]);
		if(pObjects[i] == NULL)
			AfxThrowInvalidArgException();		
			
		ASSERT(pObjects[i]->IsKindOf(RUNTIME_CLASS(CSyncObject)));

		// can't wait for critical sections

		ASSERT(!pObjects[i]->IsKindOf(RUNTIME_CLASS(CCriticalSection)));

		m_pHandleArray[i] = pObjects[i]->m_hObject;
		m_bLockedArray[i] = FALSE;
	}

	if (bInitialLock)
		Lock();
}

CMultiLock::~CMultiLock()
{
	Unlock();
	if (m_pHandleArray != m_hPreallocated)
	{
		delete[] m_bLockedArray;
		delete[] m_pHandleArray;
	}
}

DWORD CMultiLock::Lock(DWORD dwTimeOut /* = INFINITE */,
		BOOL bWaitForAll /* = TRUE */, DWORD dwWakeMask /* = 0 */)
{
	DWORD dwResult;
	if (dwWakeMask == 0)
		dwResult = ::WaitForMultipleObjects(m_dwCount,
			m_pHandleArray, bWaitForAll, dwTimeOut);
	else
		dwResult = ::MsgWaitForMultipleObjectsEx(m_dwCount,
			m_pHandleArray, dwTimeOut, dwWakeMask, bWaitForAll ? MWMO_WAITALL : MWMO_INPUTAVAILABLE);

	DWORD dwUpperBound = (DWORD)WAIT_OBJECT_0 + m_dwCount;
	if (dwResult >= WAIT_OBJECT_0 && dwResult < dwUpperBound)
	{
		if (dwUpperBound >= m_dwCount && dwUpperBound >= WAIT_OBJECT_0)
		{
			if (bWaitForAll)
			{
				for (DWORD i = 0; i < m_dwCount; i++)
					m_bLockedArray[i] = TRUE;
			}
			else
			{
				ASSERT((dwResult >= WAIT_OBJECT_0) && ((dwResult - WAIT_OBJECT_0) <= dwResult));
				if ((dwResult >= WAIT_OBJECT_0) && ((dwResult - WAIT_OBJECT_0) <= dwResult))
					m_bLockedArray[dwResult - WAIT_OBJECT_0] = TRUE;
			}
		}
	}
	return dwResult;
}

BOOL CMultiLock::Unlock()
{
	for (DWORD i=0; i < m_dwCount; i++)
	{
		if (m_bLockedArray[i])
			m_bLockedArray[i] = !m_ppObjectArray[i]->Unlock();
	}
	return TRUE;
}

BOOL CMultiLock::Unlock(LONG lCount, LPLONG lpPrevCount /* =NULL */)
{
	BOOL bGotOne = FALSE;
	for (DWORD i=0; i < m_dwCount; i++)
	{
		if (m_bLockedArray[i])
		{
			CSemaphore* pSemaphore = STATIC_DOWNCAST(CSemaphore, m_ppObjectArray[i]);
			if (pSemaphore != NULL)
			{
				bGotOne = TRUE;
				m_bLockedArray[i] = !m_ppObjectArray[i]->Unlock(lCount, lpPrevCount);
			}
		}
	}

	return bGotOne;
}


IMPLEMENT_DYNAMIC(CEvent, CSyncObject)
IMPLEMENT_DYNAMIC(CSemaphore, CSyncObject)
IMPLEMENT_DYNAMIC(CMutex, CSyncObject)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\nolib.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////
// global data

// The following symbol used to force inclusion of this module
#ifdef _X86_
extern "C" { int _afxForceEXCLUDE; }
#else
extern "C" { int __afxForceEXCLUDE; }
#endif

// Win32 library excludes
#ifndef _AFXDLL
	#pragma comment(linker, "/disallowlib:mfc" _MFC_FILENAME_VER "d.lib")
	#pragma comment(linker, "/disallowlib:mfcs" _MFC_FILENAME_VER "d.lib")
	#pragma comment(linker, "/disallowlib:mfc" _MFC_FILENAME_VER ".lib")
	#pragma comment(linker, "/disallowlib:mfcs" _MFC_FILENAME_VER ".lib")
	#pragma comment(linker, "/disallowlib:mfc" _MFC_FILENAME_VER "ud.lib")
	#pragma comment(linker, "/disallowlib:mfcs" _MFC_FILENAME_VER "ud.lib")
	#pragma comment(linker, "/disallowlib:mfc" _MFC_FILENAME_VER "u.lib")
	#pragma comment(linker, "/disallowlib:mfcs" _MFC_FILENAME_VER "u.lib")
	#ifndef _UNICODE
		#pragma comment(linker, "/disallowlib:uafxcwd.lib")
		#pragma comment(linker, "/disallowlib:uafxcw.lib")
		#ifdef _DEBUG
			#pragma comment(linker, "/disallowlib:nafxcw.lib")
		#else
			#pragma comment(linker, "/disallowlib:nafxcwd.lib")
		#endif
	#else
		#pragma comment(linker, "/disallowlib:nafxcwd.lib")
		#pragma comment(linker, "/disallowlib:nafxcw.lib")
		#ifdef _DEBUG
			#pragma comment(linker, "/disallowlib:uafxcw.lib")
		#else
			#pragma comment(linker, "/disallowlib:uafxcwd.lib")
		#endif
	#endif
#else
	#pragma comment(linker, "/disallowlib:nafxcwd.lib")
	#pragma comment(linker, "/disallowlib:nafxcw.lib")
	#pragma comment(linker, "/disallowlib:uafxcwd.lib")
	#pragma comment(linker, "/disallowlib:uafxcw.lib")
	#ifndef _UNICODE
		#pragma comment(linker, "/disallowlib:mfc" _MFC_FILENAME_VER "ud.lib")
		#pragma comment(linker, "/disallowlib:mfcs" _MFC_FILENAME_VER "ud.lib")
		#pragma comment(linker, "/disallowlib:mfc" _MFC_FILENAME_VER "u.lib")
		#pragma comment(linker, "/disallowlib:mfcs" _MFC_FILENAME_VER "u.lib")
		#ifdef _DEBUG
			#pragma comment(linker, "/disallowlib:mfc" _MFC_FILENAME_VER ".lib")
			#pragma comment(linker, "/disallowlib:mfcs" _MFC_FILENAME_VER ".lib")
		#else
			#pragma comment(linker, "/disallowlib:mfc" _MFC_FILENAME_VER "d.lib")
			#pragma comment(linker, "/disallowlib:mfcs" _MFC_FILENAME_VER "d.lib")
		#endif
	#else
		#pragma comment(linker, "/disallowlib:mfc" _MFC_FILENAME_VER "d.lib")
		#pragma comment(linker, "/disallowlib:mfcs" _MFC_FILENAME_VER "d.lib")
		#pragma comment(linker, "/disallowlib:mfc" _MFC_FILENAME_VER ".lib")
		#pragma comment(linker, "/disallowlib:mfcs" _MFC_FILENAME_VER ".lib")
		#ifdef _DEBUG
			#pragma comment(linker, "/disallowlib:mfc" _MFC_FILENAME_VER "u.lib")
			#pragma comment(linker, "/disallowlib:mfcs" _MFC_FILENAME_VER "u.lib")
		#else
			#pragma comment(linker, "/disallowlib:mfc" _MFC_FILENAME_VER "ud.lib")
			#pragma comment(linker, "/disallowlib:mfcs" _MFC_FILENAME_VER "ud.lib")
		#endif
	#endif
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\map_wp.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
//
// Implementation of parmeterized Map
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <afxtempl.h>

#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////

CMapWordToPtr::CMapWordToPtr(INT_PTR nBlockSize)
{
	ASSERT(nBlockSize > 0);
	if (nBlockSize <= 0)
		nBlockSize = 10;	// default size

	m_pHashTable = NULL;
	m_nHashTableSize = 17;  // default size
	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks = NULL;
	m_nBlockSize = nBlockSize;
}

inline UINT CMapWordToPtr::HashKey(WORD key) const
{
	return (::HashKey<WORD>(key));
}

void CMapWordToPtr::InitHashTable(
	UINT nHashSize, BOOL bAllocNow)
//
// Used to force allocation of a hash table or to override the default
//   hash table size of (which is fairly small)
{
	ASSERT_VALID(this);
	ASSERT(m_nCount == 0);
	ASSERT(nHashSize > 0);
	if (nHashSize == 0)
		nHashSize = 17;	// default value

	if (m_pHashTable != NULL)
	{
		// free hash table
		delete[] m_pHashTable;
		m_pHashTable = NULL;
	}

	if (bAllocNow)
	{
		m_pHashTable = new CAssoc* [nHashSize];
		memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);
	}
	m_nHashTableSize = nHashSize;
}

void CMapWordToPtr::RemoveAll()
{
	ASSERT_VALID(this);



	if (m_pHashTable != NULL)
	{
		// free hash table
		delete[] m_pHashTable;
		m_pHashTable = NULL;
	}

	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
}

CMapWordToPtr::~CMapWordToPtr()
{
	RemoveAll();
	ASSERT(m_nCount == 0);
}

/////////////////////////////////////////////////////////////////////////////
// Assoc helpers
// same as CList implementation except we store CAssoc's not CNode's
//    and CAssoc's are singly linked all the time

CMapWordToPtr::CAssoc*
CMapWordToPtr::NewAssoc()
{
	if (m_pFreeList == NULL)
	{
		// add another block
		CPlex* newBlock = CPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CMapWordToPtr::CAssoc));
		// chain them into free list
		CMapWordToPtr::CAssoc* pAssoc = (CMapWordToPtr::CAssoc*) newBlock->data();
		// free in reverse order to make it easier to debug
		pAssoc += m_nBlockSize - 1;
		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pAssoc--)
		{
			pAssoc->pNext = m_pFreeList;
			m_pFreeList = pAssoc;
		}
	}
	ASSERT(m_pFreeList != NULL);  // we must have something

	CMapWordToPtr::CAssoc* pAssoc = m_pFreeList;
	m_pFreeList = m_pFreeList->pNext;
	m_nCount++;
	ASSERT(m_nCount > 0);  // make sure we don't overflow


	pAssoc->key = 0;




	pAssoc->value = 0;

	return pAssoc;
}

void CMapWordToPtr::FreeAssoc(CMapWordToPtr::CAssoc* pAssoc)
{

	pAssoc->pNext = m_pFreeList;
	m_pFreeList = pAssoc;
	m_nCount--;
	ASSERT(m_nCount >= 0);  // make sure we don't underflow

	// if no more elements, cleanup completely
	if (m_nCount == 0)
		RemoveAll();
}

CMapWordToPtr::CAssoc*
CMapWordToPtr::GetAssocAt(WORD key, UINT& nHashBucket, UINT& nHashValue) const
// find association (or return NULL)
{
	nHashValue = HashKey(key);
	nHashBucket = nHashValue % m_nHashTableSize;

	if (m_pHashTable == NULL)
		return NULL;

	// see if it exists
	CAssoc* pAssoc;
	for (pAssoc = m_pHashTable[nHashBucket]; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{

		if (pAssoc->key == key)
			return pAssoc;

	}
	return NULL;
}



/////////////////////////////////////////////////////////////////////////////

BOOL CMapWordToPtr::Lookup(WORD key, void*& rValue) const
{
	ASSERT_VALID(this);

	UINT nHashBucket, nHashValue;
	CAssoc* pAssoc = GetAssocAt(key, nHashBucket, nHashValue);
	if (pAssoc == NULL)
		return FALSE;  // not in map

	rValue = pAssoc->value;
	return TRUE;
}

void*& CMapWordToPtr::operator[](WORD key)
{
	ASSERT_VALID(this);

	UINT nHashBucket, nHashValue;
	CAssoc* pAssoc;
	if ((pAssoc = GetAssocAt(key, nHashBucket, nHashValue)) == NULL)
	{
		if (m_pHashTable == NULL)
			InitHashTable(m_nHashTableSize);

		// it doesn't exist, add a new Association
		pAssoc = NewAssoc();

		pAssoc->key = key;
		// 'pAssoc->value' is a constructed object, nothing more

		// put into hash table
		pAssoc->pNext = m_pHashTable[nHashBucket];
		m_pHashTable[nHashBucket] = pAssoc;
	}
	return pAssoc->value;  // return new reference
}


BOOL CMapWordToPtr::RemoveKey(WORD key)
// remove key - return TRUE if removed
{
	ASSERT_VALID(this);

	if (m_pHashTable == NULL)
		return FALSE;  // nothing in the table

	CAssoc** ppAssocPrev;
	ppAssocPrev = &m_pHashTable[HashKey(key) % m_nHashTableSize];

	CAssoc* pAssoc;
	for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if (pAssoc->key == key)
		{
			// remove it
			*ppAssocPrev = pAssoc->pNext;  // remove from list
			FreeAssoc(pAssoc);
			return TRUE;
		}
		ppAssocPrev = &pAssoc->pNext;
	}
	return FALSE;  // not found
}


/////////////////////////////////////////////////////////////////////////////
// Iterating

void CMapWordToPtr::GetNextAssoc(POSITION& rNextPosition,
	WORD& rKey, void*& rValue) const
{
	ASSERT_VALID(this);
	ASSERT(m_pHashTable != NULL);  // never call on empty map

	CAssoc* pAssocRet = (CAssoc*)rNextPosition;
	ASSERT(pAssocRet != NULL);
	if (pAssocRet == NULL)
		return;

	if (pAssocRet == (CAssoc*) BEFORE_START_POSITION)
	{
		// find the first association
		for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
		{
			if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
			{
				break;
			}
		}
		ENSURE(pAssocRet != NULL);  // must find something
	}

	// find next association
	ASSERT(AfxIsValidAddress(pAssocRet, sizeof(CAssoc)));
	CAssoc* pAssocNext;
	if ((pAssocNext = pAssocRet->pNext) == NULL)
	{
		// go to next bucket

		for (UINT nBucket = (HashKey(pAssocRet->key) % m_nHashTableSize) + 1;

		  nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
				break;
	}

	rNextPosition = (POSITION) pAssocNext;

	// fill in return data
	rKey = pAssocRet->key;
	rValue = pAssocRet->value;
}


/////////////////////////////////////////////////////////////////////////////
// Diagnostics

#ifdef _DEBUG
void CMapWordToPtr::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	dc << "with " << LONGLONG(m_nCount) << " elements";
	if (dc.GetDepth() > 0)
	{
		// Dump in format "[key] -> value"
		WORD key;
		void* val;

		POSITION pos = GetStartPosition();
		while (pos != NULL)
		{
			GetNextAssoc(pos, key, val);
			dc << "\n\t[" << key << "] = " << val;
		}
	}

	dc << "\n";
}

void CMapWordToPtr::AssertValid() const
{
	CObject::AssertValid();

	ASSERT(m_nHashTableSize > 0);
	ASSERT(m_nCount == 0 || m_pHashTable != NULL);
		// non-empty map should have hash table
}
#endif //_DEBUG



IMPLEMENT_DYNAMIC(CMapWordToPtr, CObject)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\objcore.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



/////////////////////////////////////////////////////////////////////////////
// Runtime Typing

// special runtime-class structure for CObject (no base class)
const struct CRuntimeClass CObject::classCObject =
	{ "CObject", sizeof(CObject), 0xffff, NULL, NULL, NULL };

CRuntimeClass* CObject::GetRuntimeClass() const
{
	return _RUNTIME_CLASS(CObject);
}

#ifdef _AFXDLL
CRuntimeClass* PASCAL CObject::_GetBaseClass()
{
	return NULL;
}
CRuntimeClass* PASCAL CObject::GetThisClass()
{
	return _RUNTIME_CLASS(CObject);
}
#endif

BOOL CObject::IsKindOf(const CRuntimeClass* pClass) const
{
	ENSURE(this != NULL);
	// it better be in valid memory, at least for CObject size
	ASSERT(AfxIsValidAddress(this, sizeof(CObject)));

	// simple SI case
	CRuntimeClass* pClassThis = GetRuntimeClass();

	ENSURE(pClassThis);
	return pClassThis->IsDerivedFrom(pClass);
}

CObject* AFX_CDECL AfxDynamicDownCast(CRuntimeClass* pClass, CObject* pObject)
{
	if (pObject != NULL && pObject->IsKindOf(pClass))
		return pObject;
	else
		return NULL;
}

#ifdef _DEBUG
CObject* AFX_CDECL AfxStaticDownCast(CRuntimeClass* pClass, CObject* pObject)
{
	ASSERT(pObject == NULL || pObject->IsKindOf(pClass));
	return pObject;
}
#endif

/////////////////////////////////////////////////////////////////////////////
// Diagnostic Support

#ifdef _DEBUG
void AFXAPI AfxAssertValidObject(const CObject* pOb,
	LPCSTR lpszFileName, int nLine)
{
	if (pOb == NULL)
	{
		TRACE(traceAppMsg, 0, "ASSERT_VALID fails with NULL pointer.\n");
		if (AfxAssertFailedLine(lpszFileName, nLine))
			AfxDebugBreak();
		return;     // quick escape
	}
	if (!AfxIsValidAddress(pOb, sizeof(CObject)))
	{
		TRACE(traceAppMsg, 0, "ASSERT_VALID fails with illegal pointer.\n");
		if (AfxAssertFailedLine(lpszFileName, nLine))
			AfxDebugBreak();
		return;     // quick escape
	}

	// check to make sure the VTable pointer is valid
	ASSERT(sizeof(CObject) == sizeof(void*));
	if (!AfxIsValidAddress(*(void**)pOb, sizeof(void*), FALSE))
	{
		TRACE(traceAppMsg, 0, "ASSERT_VALID fails with illegal vtable pointer.\n");
		if (AfxAssertFailedLine(lpszFileName, nLine))
			AfxDebugBreak();
		return;     // quick escape
	}

	if (!AfxIsValidAddress(pOb, pOb->GetRuntimeClass()->m_nObjectSize, FALSE))
	{
		TRACE(traceAppMsg, 0, "ASSERT_VALID fails with illegal pointer.\n");
		if (AfxAssertFailedLine(lpszFileName, nLine))
			AfxDebugBreak();
		return;     // quick escape
	}
	pOb->AssertValid();
}

void CObject::AssertValid() const
{
	ASSERT(this != NULL);
}

void CObject::Dump(CDumpContext& dc) const
{
	dc << "a " << GetRuntimeClass()->m_lpszClassName <<
		" at " << (void*)this << "\n";

	UNUSED(dc); // unused in release build
}
#endif //_DEBUG

////////////////////////////////////////////////////////////////////////////
// Allocation/Creation

CObject* CRuntimeClass::CreateObject()
{
	ENSURE(this);

	if (m_pfnCreateObject == NULL)
	{
		TRACE(traceAppMsg, 0,
			_T("Error: Trying to create object which is not ")
			_T("DECLARE_DYNCREATE \nor DECLARE_SERIAL: %hs.\n"),
			m_lpszClassName);
		return NULL;
	}

	CObject* pObject = NULL;
	TRY
	{
		pObject = (*m_pfnCreateObject)();
	}
	END_TRY

	return pObject;
}

////////////////////////////////////////////////////////////////////////////
// Class loader & class serialization

BOOL CObject::IsSerializable() const
{
	return (GetRuntimeClass()->m_wSchema != 0xffff);
}

void AFXAPI AfxClassInit(CRuntimeClass* pNewClass)
{
	AFX_MODULE_STATE* pModuleState = AfxGetModuleState();
	AfxLockGlobals(CRIT_RUNTIMECLASSLIST);
	pModuleState->m_classList.AddHead(pNewClass);
	AfxUnlockGlobals(CRIT_RUNTIMECLASSLIST);
}

BOOL CRuntimeClass::IsDerivedFrom(const CRuntimeClass* pBaseClass) const
{
	ENSURE(this != NULL);
	ASSERT(AfxIsValidAddress(this, sizeof(CRuntimeClass), FALSE));
	ENSURE(pBaseClass != NULL);
	ASSERT(AfxIsValidAddress(pBaseClass, sizeof(CRuntimeClass), FALSE));

	// simple SI case
	const CRuntimeClass* pClassThis = this;
#ifdef _AFXDLL
	for (;;)
#else
	while (pClassThis != NULL)
#endif
	{
		if (pClassThis == pBaseClass)
			return TRUE;
#ifdef _AFXDLL
		if (pClassThis->m_pfnGetBaseClass == NULL)
			break;
		pClassThis = (*pClassThis->m_pfnGetBaseClass)();
#else
		pClassThis = pClassThis->m_pBaseClass;
#endif
	}
	return FALSE;       // walked to the top, no match
}

////////////////////////////////////////////////////////////////////////////
// CRuntimeClass special diagnostics

#ifdef _DEBUG
void AFXAPI AfxDoForAllClasses(void (AFX_CDECL *pfn)(const CRuntimeClass*, void*),
	void* pContext)
{
	// just walk through the simple list of registered classes
	AFX_MODULE_STATE* pModuleState = AfxGetModuleState();
	AfxLockGlobals(CRIT_RUNTIMECLASSLIST);
	CRuntimeClass* pClass;
	for (pClass = pModuleState->m_classList; pClass != NULL;
		pClass = pClass->m_pNextClass)
	{
		(*pfn)(pClass, pContext);
	}
	AfxUnlockGlobals(CRIT_RUNTIMECLASSLIST);
#ifdef _AFXDLL
	// walk through the list of dynlink library registered classes
	AfxLockGlobals(CRIT_DYNLINKLIST);
	for (CDynLinkLibrary* pDLL = pModuleState->m_libraryList; pDLL != NULL;
		pDLL = pDLL->m_pNextDLL)
	{
        for (CRuntimeClass* pDLLClass = pDLL->m_classList; pDLLClass != NULL;
			pDLLClass = pDLLClass->m_pNextClass)
		{
			(*pfn)(pDLLClass, pContext);
		}
	}
	AfxUnlockGlobals(CRIT_DYNLINKLIST);
#endif
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\occcont.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "occimpl.h"
#include "sal.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CWnd support for OLE Control containment

BOOL CWnd::CreateControl(LPCTSTR lpszClass, LPCTSTR lpszWindowName,
	DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID,
	CFile* pPersist, BOOL bStorage, BSTR bstrLicKey)
{
	ASSERT(lpszClass != NULL);

	CLSID clsid;
	HRESULT hr = AfxGetClassIDFromString(lpszClass, &clsid);
	if (FAILED(hr))
		return FALSE;

	return CreateControl(clsid, lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey);
}

BOOL CWnd::CreateControl( REFCLSID clsid, LPCTSTR lpszWindowName,
   DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID,
   CFile* pPersist, BOOL bStorage, BSTR bstrLicKey )
{
   CRect rect2( rect );
   CPoint pt;
   CSize size;

   pt = rect2.TopLeft();
   size = rect2.Size();

   return( CreateControl( clsid, lpszWindowName, dwStyle, &pt, &size,
	  pParentWnd, nID, pPersist, bStorage, bstrLicKey ) );
}

BOOL CWnd::CreateControl(REFCLSID clsid, LPCTSTR lpszWindowName, DWORD dwStyle,
	const POINT* ppt, const SIZE* psize, CWnd* pParentWnd, UINT nID,
   CFile* pPersist, BOOL bStorage, BSTR bstrLicKey)
{
	ASSERT(pParentWnd != NULL);

#ifdef _DEBUG
	if (afxOccManager == NULL)
	{
		TRACE(traceOle, 0, "Warning: AfxEnableControlContainer has not been called yet.\n");
		TRACE(traceOle, 0, ">>> You should call it in your app's InitInstance function.\n");
	}
#endif

	if ((pParentWnd == NULL) || !pParentWnd->InitControlContainer())
		return FALSE;

	return pParentWnd->m_pCtrlCont->CreateControl(this, clsid, lpszWindowName,
		dwStyle, ppt, psize, nID, pPersist, bStorage, bstrLicKey);
}

BOOL CWnd::CreateControl(const CControlCreationInfo& creationInfo, DWORD dwStyle,
	const POINT* ppt, const SIZE* psize, CWnd* pParentWnd, UINT nID)
{
	ASSERT(pParentWnd != NULL);

#ifdef _DEBUG
	if (afxOccManager == NULL)
	{
		TRACE(traceOle, 0, "Warning: AfxEnableControlContainer has not been called yet.\n");
		TRACE(traceOle, 0, ">>> You should call it in your app's InitInstance function.\n");
	}
#endif

	if ((pParentWnd == NULL) || !pParentWnd->InitControlContainer())
		return FALSE;

	return pParentWnd->m_pCtrlCont->CreateControl(this, creationInfo, dwStyle, ppt, psize, nID);
}


BOOL CWnd::InitControlContainer(BOOL bCreateFromResource)
{
   if (m_pCtrlCont == NULL)
   {
	  BOOL bSuccess;

	  bSuccess = CreateControlContainer( &m_pCtrlCont );
	  if (bSuccess && (m_pCtrlCont == NULL))
	  {
		 // The window wants to use the default control container.
		  TRY
		  {
			m_pCtrlCont = afxOccManager->CreateContainer(this);
		  }
		  END_TRY
	  }
	  //When Container is created and it is not during creation from resources, 
	  //populate the list with all resource created Win32 controls.
	  if (!bCreateFromResource)
	  {
			m_pCtrlCont->FillListSitesOrWnds(GetOccDialogInfo());		
	  }
   }

	// Mark all ancestor windows as containing OLE controls.
	if (m_pCtrlCont != NULL)
	{
		CWnd* pWnd = this;
		while ((pWnd != NULL) && !(pWnd->m_nFlags & WF_OLECTLCONTAINER))
		{
			pWnd->m_nFlags |= WF_OLECTLCONTAINER;
			pWnd = pWnd->GetParent();
			if (! (GetWindowLong(pWnd->GetSafeHwnd(), GWL_STYLE) & WS_CHILD))
				break;
		}
	}
	
	return (m_pCtrlCont != NULL);
}

/////////////////////////////////////////////////////////////////////////////
// COleControlContainer

BEGIN_INTERFACE_MAP(COleControlContainer, CCmdTarget)
	INTERFACE_PART(COleControlContainer, IID_IOleInPlaceFrame, OleIPFrame)
	INTERFACE_PART(COleControlContainer, IID_IOleContainer, OleContainer)
END_INTERFACE_MAP()

BEGIN_DISPATCH_MAP(COleControlContainer, CCmdTarget)
END_DISPATCH_MAP()


COleControlSiteOrWnd::COleControlSiteOrWnd()
: m_hWnd(NULL), m_pSite(NULL), m_bAutoRadioButton(FALSE)
{
}
COleControlSiteOrWnd::COleControlSiteOrWnd(COleControlSite *pSite)
		: m_hWnd(NULL), m_pSite(pSite), m_bAutoRadioButton(FALSE)
{
}
COleControlSiteOrWnd::COleControlSiteOrWnd(HWND hWnd, BOOL bAutoRadioButton)
		: m_hWnd(hWnd), m_pSite(NULL), m_bAutoRadioButton(bAutoRadioButton)
{
}


COleControlSiteOrWnd::~COleControlSiteOrWnd()
{	
	delete m_pSite;
}

COleControlContainer::COleControlContainer(CWnd* pWnd) :
	m_pWnd(pWnd),
	m_crBack((COLORREF)-1),
	m_crFore((COLORREF)-1),
	m_pOleFont(NULL),
	m_pSiteUIActive(NULL),
   m_pSiteCapture(NULL),
   m_pSiteFocus(NULL),
   m_nWindowlessControls(0)
{
}

COleControlContainer::~COleControlContainer()
{
	COleControlSiteOrWnd* pSiteOrWnd;
	POSITION pos;
	POSITION posFollow;

	pos = m_listSitesOrWnds.GetHeadPosition();
	while( pos != NULL )
	{
		posFollow = pos;
		pSiteOrWnd = m_listSitesOrWnds.GetNext( pos );
		ASSERT( pSiteOrWnd != NULL );
		if (pSiteOrWnd && pSiteOrWnd->m_pSite && 
			pSiteOrWnd->m_pSite->m_pDataSourceControl == NULL )
		{
			m_listSitesOrWnds.RemoveAt( posFollow );
			delete pSiteOrWnd;
		}
	}

	while( !m_listSitesOrWnds.IsEmpty() )
	{
		pSiteOrWnd = m_listSitesOrWnds.RemoveHead();
		delete pSiteOrWnd;
	}

	m_siteMap.RemoveAll();

	RELEASE(m_pOleFont);

	// Tell the GC to release references on 'this' object.

	// This check is necessary to make sure the spIUnknown->Release() does not
	// cause the same object to be deleted while it is already being deleted.
	if( m_dwRef > 0 )
	{
		HRESULT hr = S_OK;
		REFIID iid = IID_IUnknown;
		CComPtr<IUnknown> spIUnknown = NULL;

		hr = this->InternalQueryInterface(&iid, reinterpret_cast<void**>(&spIUnknown) );
		if( SUCCEEDED( hr ) )
		{
			_AfxReleaseManagedRefs( spIUnknown );
		}
	}
}

void COleControlContainer::BroadcastAmbientPropertyChange(DISPID dispid)
{
	POSITION pos;
	COleControlSiteOrWnd* pSiteOrWnd;
	IOleControl* pControl;

	pos = m_listSitesOrWnds.GetHeadPosition();
	while( pos != NULL )
	{
		pSiteOrWnd = m_listSitesOrWnds.GetNext( pos );
		ASSERT( pSiteOrWnd != NULL );
		if( pSiteOrWnd->m_pSite && pSiteOrWnd->m_pSite->m_pObject != NULL )
		{
			pControl = NULL;
			pSiteOrWnd->m_pSite->m_pObject->QueryInterface( IID_IOleControl, (void**)&pControl );
			if( pControl != NULL )
			{
				pControl->OnAmbientPropertyChange( dispid );
				pControl->Release();
			}
		}
	}
}

BOOL COleControlContainer::CreateControl( CWnd* pWndCtrl, REFCLSID clsid,
	LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, UINT nID,
	CFile* pPersist, BOOL bStorage, BSTR bstrLicKey,
	COleControlSite** ppNewSite )
{
   CRect rect2( rect );
   CPoint pt;
   CSize size;

   pt = rect2.TopLeft();
   size = rect2.Size();

   return( CreateControl( pWndCtrl, clsid, lpszWindowName, dwStyle, &pt, &size,
	  nID, pPersist, bStorage, bstrLicKey, ppNewSite ) );
}

BOOL COleControlContainer::CreateControl(CWnd* pWndCtrl,const CControlCreationInfo& creationInfo,
	DWORD dwStyle, const POINT* ppt, const SIZE* psize,UINT nID)
{
	return CreateControlCommon(pWndCtrl, creationInfo.m_clsid,creationInfo,NULL, 
								dwStyle, ppt, psize,nID, NULL, FALSE, NULL,
								NULL);
}

BOOL COleControlContainer::CreateControlCommon(CWnd* pWndCtrl, REFCLSID clsid,
	const CControlCreationInfo& creationInfo,
	LPCTSTR lpszWindowName, DWORD dwStyle, const POINT* ppt, const SIZE* psize,
   UINT nID, CFile* pPersist, BOOL bStorage, BSTR bstrLicKey,
   COleControlSite** ppNewSite)
{
	COleControlSite* pSite = NULL;
	COleControlSiteOrWnd *pSiteOrWnd = NULL;

	TRY
	{
	  BOOL bSuccess;
	  bSuccess = m_pWnd->CreateControlSite(this, &pSite, nID, clsid);
	  if (bSuccess && (pSite == NULL))
	  {
		 ENSURE(afxOccManager!=NULL);
		 // Use the default site.
		 pSite = afxOccManager->CreateSite(this,creationInfo);
	  }
	}
	END_TRY

	if (pSite == NULL)
		return FALSE;

	BOOL bCreated = FALSE;
	//If creation information, call that overload, else, call the CLSID overload
	if (creationInfo.IsManaged())
	{
		bCreated = SUCCEEDED( pSite->CreateControl(pWndCtrl, creationInfo,
			dwStyle, ppt, psize, nID) );
	} else
	{
		bCreated = SUCCEEDED( pSite->CreateControl(pWndCtrl, clsid,
		lpszWindowName, dwStyle, ppt, psize, nID, pPersist, bStorage, bstrLicKey ) );
	}

	if (bCreated)
	{
		//WinForms control on CDialog Visible=False --> The handle is not yet created.
		ASSERT( (pSite->m_hWnd != NULL) || pSite->m_bIsWindowless );
		pSiteOrWnd = new COleControlSiteOrWnd(pSite);
		m_listSitesOrWnds.AddTail(pSiteOrWnd);
		if( pSite->m_hWnd != NULL )
		{
		   m_siteMap.SetAt(pSite->m_hWnd, pSite);
		}
		if (ppNewSite != NULL)
			*ppNewSite = pSite;
	}
	else
	{
		delete pSite;
	}

	return bCreated;
}



BOOL COleControlContainer::CreateControl(CWnd* pWndCtrl, REFCLSID clsid,
	LPCTSTR lpszWindowName, DWORD dwStyle, const POINT* ppt, const SIZE* psize,
   UINT nID, CFile* pPersist, BOOL bStorage, BSTR bstrLicKey,
   COleControlSite** ppNewSite)
{
	CControlCreationInfo controlInfo;
	controlInfo.m_clsid=clsid;
	return CreateControlCommon(pWndCtrl, clsid,controlInfo,lpszWindowName, 
								dwStyle, ppt, psize,nID, pPersist, bStorage, bstrLicKey,
								ppNewSite);
}

COleControlSite* COleControlContainer::FindItem(UINT nID) const
{
	POSITION pos = m_listSitesOrWnds.GetHeadPosition();
	while (pos != NULL)
	{
		COleControlSiteOrWnd* pSiteOrWnd;

		pSiteOrWnd = m_listSitesOrWnds.GetNext( pos );
		ENSURE( pSiteOrWnd != NULL );
		if( pSiteOrWnd->m_pSite && pSiteOrWnd->m_pSite->GetDlgCtrlID() == int(nID) )
		{
			return( pSiteOrWnd->m_pSite );
		}
	}
	return NULL;
}

BOOL COleControlContainer::GetAmbientProp(COleControlSite* pSite, DISPID dispid,
	VARIANT* pvarResult)
{
	switch (dispid)
	{
	case DISPID_AMBIENT_AUTOCLIP:
	case DISPID_AMBIENT_MESSAGEREFLECT:
	case DISPID_AMBIENT_SUPPORTSMNEMONICS:
	case DISPID_AMBIENT_USERMODE:
		V_VT(pvarResult) = VT_BOOL;
		V_BOOL(pvarResult) = (VARIANT_BOOL)-1;
		return TRUE;

	case DISPID_AMBIENT_SHOWGRABHANDLES:
	case DISPID_AMBIENT_SHOWHATCHING:
	case DISPID_AMBIENT_UIDEAD:
		V_VT(pvarResult) = VT_BOOL;
		V_BOOL(pvarResult) = 0;
		return TRUE;

	case DISPID_AMBIENT_APPEARANCE:     // ambient appearance is 3D
		V_VT(pvarResult) = VT_I2;
		V_I2(pvarResult) = 1;
		return TRUE;

	case DISPID_AMBIENT_BACKCOLOR:
	case DISPID_AMBIENT_FORECOLOR:
		if (m_crBack == (COLORREF)-1)   // ambient colors not initialized
		{
			CWindowDC dc(m_pWnd);
			m_pWnd->SendMessage(WM_CTLCOLORSTATIC, (WPARAM)dc.m_hDC,
				(LPARAM)m_pWnd->m_hWnd);
			m_crBack = dc.GetBkColor();
			m_crFore = dc.GetTextColor();
		}

		V_VT(pvarResult) = VT_COLOR;
		V_I4(pvarResult) = (dispid == DISPID_AMBIENT_BACKCOLOR) ?
			m_crBack : m_crFore;
		return TRUE;

	case DISPID_AMBIENT_FONT:
		if (m_pOleFont == NULL)         // ambient font not initialized
			CreateOleFont(m_pWnd->GetFont());

		ASSERT(m_pOleFont != NULL);
		if (m_pOleFont == NULL)         // failed to create font
			return FALSE;

		V_VT(pvarResult) = VT_FONT;
		m_pOleFont->AddRef();
		V_DISPATCH(pvarResult) = m_pOleFont;
		return TRUE;

	case DISPID_AMBIENT_DISPLAYASDEFAULT:
		V_VT(pvarResult) = VT_BOOL;
		V_BOOL(pvarResult) = (VARIANT_BOOL)(pSite->IsDefaultButton() ? -1 : 0);
		return TRUE;

	case DISPID_AMBIENT_LOCALEID:
		V_VT(pvarResult) = VT_I4;
		V_I4(pvarResult) = GetThreadLocale();
		return TRUE;

	case DISPID_AMBIENT_DISPLAYNAME:
		{
			CString str;                // return blank string
			V_VT(pvarResult) = VT_BSTR;
			V_BSTR(pvarResult) = str.AllocSysString();
		}
		return TRUE;

	case DISPID_AMBIENT_SCALEUNITS:
		{
			CString str;
			str.LoadString(AFX_IDS_OCC_SCALEUNITS_PIXELS);
			V_VT(pvarResult) = VT_BSTR;
			V_BSTR(pvarResult) = str.AllocSysString();
		}
		return TRUE;
	}

	return FALSE;
}

void COleControlContainer::CreateOleFont(CFont* pFont)
{
	CFont fontSys;
	if ((pFont == NULL) || (pFont->m_hObject == NULL))
	{
		// no font was provided, so use the system font
		if (fontSys.CreateStockObject(DEFAULT_GUI_FONT) ||
			fontSys.CreateStockObject(SYSTEM_FONT))
		{
			pFont = &fontSys;
		}
		else
		{
			m_pOleFont = NULL;
			return;
		}
	}

	LOGFONT logfont;
	pFont->GetLogFont(&logfont);

	FONTDESC fd;
	fd.cbSizeofstruct = sizeof(FONTDESC);
	CStringW strFaceName(logfont.lfFaceName);
	fd.lpstrName = const_cast<LPOLESTR>(strFaceName.GetString());
	fd.sWeight = (short)logfont.lfWeight;
	fd.sCharset = logfont.lfCharSet;
	fd.fItalic = logfont.lfItalic;
	fd.fUnderline = logfont.lfUnderline;
	fd.fStrikethrough = logfont.lfStrikeOut;

	long lfHeight = logfont.lfHeight;
	if (lfHeight < 0)
		lfHeight = -lfHeight;

	CWindowDC dc(m_pWnd);
	int ppi = dc.GetDeviceCaps(LOGPIXELSY);
	fd.cySize.Lo = lfHeight * 720000 / ppi;
	fd.cySize.Hi = 0;

	RELEASE(m_pOleFont);

	if (FAILED(::OleCreateFontIndirect(&fd, IID_IFontDisp, (void**)&m_pOleFont)))
		m_pOleFont = NULL;
}

void COleControlContainer::FreezeAllEvents(BOOL bFreeze)
{
	COleControlSiteOrWnd* pSiteOrWnd;
	POSITION pos = m_listSitesOrWnds.GetHeadPosition();
	while (pos != NULL)
	{
		pSiteOrWnd = m_listSitesOrWnds.GetNext( pos );
		ASSERT(pSiteOrWnd);
		if(pSiteOrWnd->m_pSite)
			pSiteOrWnd->m_pSite->FreezeEvents(bFreeze);
	}
}

void COleControlContainer::ScrollChildren(int dx, int dy)
{
	COleControlSiteOrWnd* pSiteOrWnd;
	POSITION pos = m_listSitesOrWnds.GetHeadPosition();
	while (pos != NULL)
	{
		pSiteOrWnd = m_listSitesOrWnds.GetNext( pos );
		ASSERT(pSiteOrWnd);
		if(pSiteOrWnd->m_pSite)
		{
			ASSERT(pSiteOrWnd->m_pSite->m_pInPlaceObject != NULL);
			ASSERT(pSiteOrWnd->m_pSite->m_pObject != NULL);
			pSiteOrWnd->m_pSite->m_rect.OffsetRect(dx, dy);
			pSiteOrWnd->m_pSite->m_pInPlaceObject->SetObjectRects(
				pSiteOrWnd->m_pSite->m_rect, pSiteOrWnd->m_pSite->m_rect);
		}
	}
}

void COleControlContainer::OnUIActivate(COleControlSite* pSite)
{
	// deactivate currently active site if it isn't the site
	// making the activation request.
	if (m_pSiteUIActive != NULL && m_pSiteUIActive != pSite)
		m_pSiteUIActive->m_pInPlaceObject->UIDeactivate();

	m_pSiteUIActive = pSite;
}

void COleControlContainer::OnUIDeactivate(COleControlSite* pSite)
{
	UNUSED(pSite);

	if (m_pSiteUIActive == pSite)
	{
		m_pSiteUIActive = NULL;
	
	}
	if (m_pSiteFocus == pSite)
	{		
		m_pSiteFocus = NULL;
	}
}

/////////////////////////////////////////////////////////////////////////////
// special cases for CWnd functions

void COleControlContainer::CheckDlgButton(int nIDButton, UINT nCheck)
{
	CWnd* pWnd = GetDlgItem(nIDButton);
	if (pWnd == NULL)
		return;

	if (pWnd->m_pCtrlSite == NULL)
	{
		pWnd->SendMessage(BM_SETCHECK, nCheck, 0);
		return;
	}

	pWnd->m_pCtrlSite->SafeSetProperty(DISPID_VALUE, VT_I4, (DWORD)nCheck);
}

void COleControlContainer::CheckRadioButton(int nIDFirstButton, int nIDLastButton,
	int nIDCheckButton)
{
	ASSERT(nIDFirstButton <= nIDCheckButton);
	ASSERT(nIDCheckButton <= nIDLastButton);

	// the following code is for OLE control containers only
	for (int nID = nIDFirstButton; nID <= nIDLastButton; nID++)
		CheckDlgButton(nID, (nID == nIDCheckButton));
}

CWnd* COleControlContainer::GetDlgItem(int nID) const
{
	HWND hWnd;
	GetDlgItem(nID, &hWnd);
	return CWnd::FromHandle(hWnd);
}

void COleControlContainer::GetDlgItem(int nID, HWND* phWnd) const
{
	// first, look for a non-OLE control
	HWND hWnd = ::GetDlgItem(m_pWnd->GetSafeHwnd(), nID);
	if (hWnd == NULL)
	{
		// now, look for an OLE control
		COleControlSite* pSite = FindItem(nID);
		if (pSite != NULL)
			hWnd = pSite->m_hWnd;
	}

	*phWnd = hWnd;
}

UINT COleControlContainer::GetDlgItemInt(int nID, BOOL* lpTrans, BOOL bSigned) const
{
	TCHAR szText[256];
	if (GetDlgItemText(nID, szText, 256) == 0)
	{
		if (lpTrans != NULL)
			*lpTrans = FALSE;
		return 0;
	}

	// Quick check for valid number
	LPTSTR pch = szText;

	while (_istspace(static_cast<_TUCHAR>(*pch)))
		pch = CharNext(pch);    // skip whitespace

	if ((*pch) == '+' || (*pch) == '-')
		pch = CharNext(pch);    // skip sign

	BOOL bTrans = _istdigit(static_cast<_TUCHAR>(*pch));    // did we find a digit?

	if (lpTrans != NULL)
		*lpTrans = bTrans;

	if (!bTrans)
		return 0;

	if (bSigned)
		return _tcstol(szText, NULL, 10);
	else
		return _tcstoul(szText, NULL, 10);
}

int COleControlContainer::GetDlgItemText(_In_ int nID, _Out_cap_post_count_(nMaxCount, return + 1) _Pre_notnull_ _Post_z_ LPTSTR lpStr, _In_ int nMaxCount) const
{
	CWnd* pWnd = GetDlgItem(nID);
	if (pWnd == NULL)
		return 0;

	return pWnd->GetWindowText(lpStr, nMaxCount);
}

LRESULT COleControlContainer::SendDlgItemMessage(int nID, UINT message, WPARAM wParam,
	LPARAM lParam)
{
	CWnd* pWnd = GetDlgItem(nID);
	if (pWnd == NULL)
		return 0;

	return pWnd->SendMessage(message, wParam, lParam);
}

void COleControlContainer::SetDlgItemInt(int nID, UINT nValue, BOOL bSigned)
{
	TCHAR szText[34];
	if (bSigned)
	{
		Checked::ltot_s((long)nValue, szText, 34, 10);
	}
	else
	{
		Checked::ultot_s((unsigned long)nValue, szText, 34, 10);
	}

	SetDlgItemText(nID, szText);
}

void COleControlContainer::SetDlgItemText(int nID, LPCTSTR lpszString)
{
	CWnd* pWnd = GetDlgItem(nID);
	if (pWnd == NULL)
		return;

	pWnd->SetWindowText(lpszString);
}

UINT COleControlContainer::IsDlgButtonChecked(int nIDButton) const
{
	CWnd* pWnd = GetDlgItem(nIDButton);
	if (pWnd == NULL)
		return 0;

	if (pWnd->m_pCtrlSite == NULL)
		return UINT(pWnd->SendMessage(BM_GETCHECK, 0, 0));

	DWORD dwValue;

	TRY
	{
		pWnd->GetProperty(DISPID_VALUE, VT_I4, &dwValue);
	}
	CATCH_ALL(e)
	{
		DELETE_EXCEPTION(e);
		dwValue = 0;
	}
	END_CATCH_ALL

	if (dwValue == 0x0000ffff)  // VARIANT_BOOL TRUE
		dwValue = 1;

	return dwValue;
}


BOOL COleControlContainer::HandleSetFocus()
{
   if( m_pSiteFocus != NULL )
   {
	  return( TRUE );
   }
   else
   {
	  return( FALSE );
   }
}

BOOL COleControlContainer::HandleWindowlessMessage(UINT message, WPARAM wParam, LPARAM lParam, LRESULT* plResult)
{
   HRESULT hResult;
   POSITION pos;
   COleControlSiteOrWnd* pSiteOrWnd;
   COleControlSite* pMouseMessageSite;

   ASSERT( plResult != NULL );
   *plResult = 0;

   switch (message)
   {
   case WM_MOUSEMOVE:
   case WM_LBUTTONDOWN:
   case WM_LBUTTONUP:
   case WM_LBUTTONDBLCLK:
   case WM_RBUTTONDOWN:
   case WM_RBUTTONUP:
   case WM_RBUTTONDBLCLK:
   case WM_MBUTTONDOWN:
   case WM_MBUTTONUP:
   case WM_MBUTTONDBLCLK:
	  if (m_pSiteCapture != NULL)
	  {
		 ASSERT( m_pSiteCapture->m_pWindowlessObject != NULL );
		 pMouseMessageSite = m_pSiteCapture;
	  }
	  else
	  {
		 pMouseMessageSite = NULL;
		 pos = m_listSitesOrWnds.GetHeadPosition();
		 while ((pos != NULL) && (pMouseMessageSite == NULL))
		 {
			pSiteOrWnd = m_listSitesOrWnds.GetNext(pos);
			ASSERT(pSiteOrWnd);
			if (pSiteOrWnd->m_pSite && pSiteOrWnd->m_pSite->m_bIsWindowless)
			{
			   ASSERT( pSiteOrWnd->m_pSite->m_pWindowlessObject != NULL );

			   CPoint point((DWORD)lParam);

			   if (pSiteOrWnd->m_pSite->m_rect.PtInRect(point))
			   {
				  pMouseMessageSite = pSiteOrWnd->m_pSite;
				  break;
			   }
			}
		 }
	  }
	  if (pMouseMessageSite != NULL)
	  {
		 hResult = pMouseMessageSite->m_pWindowlessObject->OnWindowMessage(
			message, wParam, lParam, plResult);
		 return hResult == S_OK;
	  }
	  break;

   case WM_KEYDOWN:
   case WM_KEYUP:
   case WM_CHAR:
   case WM_DEADCHAR:
   case WM_SYSKEYDOWN:
   case WM_SYSKEYUP:
   case WM_SYSDEADCHAR:
   case WM_HELP:
   case WM_CANCELMODE:
   case WM_IME_STARTCOMPOSITION:
   case WM_IME_ENDCOMPOSITION:
   case WM_IME_COMPOSITION:
   case WM_IME_SETCONTEXT:
   case WM_IME_NOTIFY:
   case WM_IME_CONTROL:
   case WM_IME_COMPOSITIONFULL:
   case WM_IME_SELECT:
   case WM_IME_CHAR:
//   case WM_IME_REQUEST:
   case WM_IME_KEYDOWN:
   case WM_IME_KEYUP:
	  //Call OnWindowMessage in case a Windowless ActiveX is in focus.
	  //m_pSiteFocus contains the current ActiveX site in focus (not necessarily windowless).
	  if (m_pSiteFocus != NULL && m_pSiteFocus->m_pWindowlessObject != NULL)
	  {
		 
		 hResult = m_pSiteFocus->m_pWindowlessObject->OnWindowMessage(
			message, wParam, lParam, plResult);
		 if (hResult == S_OK)
		 {
			return TRUE;
		 }
		 else
		 {
			return FALSE;
		 }
	  }
	  break;
   }

   return FALSE;
}

BOOL COleControlContainer::OnPaint( CDC* pDC )
{
   POSITION pos;
   COleControlSiteOrWnd* pSiteOrWnd;
   IViewObject* pViewObject;

   pos = m_listSitesOrWnds.GetHeadPosition();
   HRESULT hr = E_NOTIMPL;
   BOOL bRet = FALSE;

   while( pos != NULL )
   {
	  pSiteOrWnd = m_listSitesOrWnds.GetNext( pos );
	  if( pSiteOrWnd->m_pSite && pSiteOrWnd->m_pSite->m_bIsWindowless )
	  {
		 pViewObject = NULL;
		 pSiteOrWnd->m_pSite->m_pObject->QueryInterface( IID_IViewObject, (void**)&pViewObject );
		 if( pViewObject != NULL )
		 {
			hr = pViewObject->Draw( DVASPECT_CONTENT, -1, NULL, NULL, NULL, *pDC, NULL, NULL, NULL, 0 );
			if (SUCCEEDED(hr))
            {
				bRet = TRUE;
            }
            pViewObject->Release();
            pViewObject = NULL;
		 }
	  }
   }

   return bRet;
}

//Searches a child window with nID in z-order list, starting from hwndStart.
AFX_STATIC HWND AfxGetDlgItemStartFromHWND(int nID,HWND hwndStart)
{	
	//Search start from one after hwndStart (As opposed to 
	//::GetDlgItem, which always start at the first child).
	HWND hwndFound = hwndStart;
	while (hwndFound!=NULL)
	{
		if (GetDlgCtrlID(hwndFound) == nID)
		{
			break;
		}
		hwndFound=GetWindow(hwndFound,GW_HWNDNEXT);
	}		
	return hwndFound;
}

BOOL COleControlContainer::FillListSitesOrWnds(_AFX_OCC_DIALOG_INFO* pOccDlgInfo)
{
	if (pOccDlgInfo==NULL) { return FALSE; }
	COleControlSiteOrWnd *pSiteOrWnd = NULL;
	//When this function is called, the m_listSitesOrWnds contains only ActiveX controls
	//created by MFC from resource, or by user who called CreateControl.
	//The code inserts the Win32 controls (found in dialog template resource) into
	//the list, before, in between or after the ActiveX controls, according to the 
	//order in the dialog template.
	POSITION pos = m_listSitesOrWnds.GetHeadPosition();
	POSITION posOld = pos;
	if(pos)
	{
		pSiteOrWnd = m_listSitesOrWnds.GetNext(pos);
	}

	HWND hwndStart=NULL;
	for(unsigned i = 0; i < pOccDlgInfo->m_cItems; i++)
	{
		ASSERT(!pSiteOrWnd || pSiteOrWnd->m_pSite); //pSiteOrWnd must point at either ActiveX or NULL (list end).
		if(pSiteOrWnd!=NULL && pSiteOrWnd->m_pSite!=NULL &&
			pSiteOrWnd->m_pSite->m_nID == pOccDlgInfo->m_pItemInfo[i].nId)
		{
			//If not Windowless control, update the starting position in z-order search.
			if (pSiteOrWnd->m_pSite->m_hWnd != NULL)
			{
				hwndStart = pSiteOrWnd->m_pSite->m_hWnd;
			}
			posOld = pos;
			pSiteOrWnd = pos ? m_listSitesOrWnds.GetNext(pos) :	NULL;
		}
		else
		{
			if(pOccDlgInfo->m_pItemInfo[i].nId)
			{
				//AfxGetDlgItemStartFromHWND fix , is to handle non-unique ids 
				//of resource items (IDC_STATIC), that causes ::GetDlgItem
				//to always find the first (in Win32 z-order child list) window with
				//this id, and thus m_listSitesOrWnds contained several instances of the same hwnd.
				
				//First time start searching from first z-order, else
				//search from 1 after the previous window.
				HWND hwndSearchFrom= (hwndStart == NULL) ? 
									 GetWindow(m_pWnd->GetSafeHwnd(),GW_CHILD) :
									 ::GetWindow(hwndStart,GW_HWNDNEXT);
				
				HWND hwndCtrl=AfxGetDlgItemStartFromHWND(pOccDlgInfo->m_pItemInfo[i].nId, hwndSearchFrom);
				//If not found, revert to prev method of GetDlgItem, this means Win32 children list and 
				//resource item array are out of sync
				if (hwndCtrl == NULL)
				{
					hwndCtrl = ::GetDlgItem(m_pWnd->GetSafeHwnd(),pOccDlgInfo->m_pItemInfo[i].nId);
					TRACE(traceAppMsg, 0, "Warning: Resource items and Win32 Z-order lists are out of sync. Tab order may be not defined well.\n");
				}
				COleControlSiteOrWnd *pTemp =
					new COleControlSiteOrWnd(
						hwndCtrl,
						pOccDlgInfo->m_pItemInfo[i].bAutoRadioButton);
				ASSERT(IsWindow(pTemp->m_hWnd));
				if (IsWindow(pTemp->m_hWnd))
				{
					hwndStart = pTemp->m_hWnd;
					// These transfer inserts will ensure pTemp is freed if insertion fails
					if(posOld)
					{
						m_listSitesOrWnds.TransferInsertBefore(posOld, pTemp);
					}
					else
					{
						m_listSitesOrWnds.TransferAddTail(pTemp);
					}
				}
			}
		}
	}
	return TRUE;
}
/////////////////////////////////////////////////////////////////////////////
// COleControlContainer::XOleIPFrame

STDMETHODIMP COleControlContainer::XOleIPFrame::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(COleControlContainer, OleIPFrame)
	return (HRESULT)pThis->InternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP_(ULONG) COleControlContainer::XOleIPFrame::AddRef()
{
	METHOD_PROLOGUE_EX_(COleControlContainer, OleIPFrame)
	return (ULONG)pThis->InternalAddRef();
}

STDMETHODIMP_(ULONG) COleControlContainer::XOleIPFrame::Release()
{
	METHOD_PROLOGUE_EX_(COleControlContainer, OleIPFrame)
	return (ULONG)pThis->InternalRelease();
}

STDMETHODIMP COleControlContainer::XOleIPFrame::GetWindow(HWND* phWnd)
{
	METHOD_PROLOGUE_EX_(COleControlContainer, OleIPFrame)

	*phWnd = pThis->m_pWnd->m_hWnd;
	return S_OK;
}

STDMETHODIMP COleControlContainer::XOleIPFrame::ContextSensitiveHelp(BOOL)
{
	return E_NOTIMPL;
}

STDMETHODIMP COleControlContainer::XOleIPFrame::GetBorder(LPRECT)
{
	return E_NOTIMPL;
}

STDMETHODIMP COleControlContainer::XOleIPFrame::RequestBorderSpace(
	LPCBORDERWIDTHS)
{
	return E_NOTIMPL;
}

STDMETHODIMP COleControlContainer::XOleIPFrame::SetBorderSpace(
	LPCBORDERWIDTHS)
{
	return E_NOTIMPL;
}

STDMETHODIMP COleControlContainer::XOleIPFrame::SetActiveObject(
	LPOLEINPLACEACTIVEOBJECT pActiveObject, LPCOLESTR)
{
	METHOD_PROLOGUE_EX_(COleControlContainer, OleIPFrame)

	if (pThis->m_pSiteUIActive != NULL)
	{
		LPOLEINPLACEACTIVEOBJECT pOldActiveObject = pThis->m_pSiteUIActive->m_pActiveObject;
		if (pActiveObject != NULL)
			pActiveObject->AddRef();
		pThis->m_pSiteUIActive->m_pActiveObject = pActiveObject;
		if (pOldActiveObject != NULL)
			pOldActiveObject->Release();
	}
	return S_OK;
}

STDMETHODIMP COleControlContainer::XOleIPFrame::InsertMenus(HMENU,
	LPOLEMENUGROUPWIDTHS)
{
	return E_NOTIMPL;
}

STDMETHODIMP COleControlContainer::XOleIPFrame::SetMenu(HMENU, HOLEMENU, HWND)
{
	return E_NOTIMPL;
}

STDMETHODIMP COleControlContainer::XOleIPFrame::RemoveMenus(HMENU)
{
	return E_NOTIMPL;
}

STDMETHODIMP COleControlContainer::XOleIPFrame::SetStatusText(LPCOLESTR)
{
	return E_NOTIMPL;
}

STDMETHODIMP COleControlContainer::XOleIPFrame::EnableModeless(BOOL)
{
   // As long as we don't create any modeless dialogs, we can just return S_OK.
	return S_OK;
}

STDMETHODIMP COleControlContainer::XOleIPFrame::TranslateAccelerator(LPMSG,
	WORD)
{
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CEnumUnknown - enumerator for IUnknown pointers

class CEnumUnknown : public CEnumArray
{
public:
	CEnumUnknown(const void* pvEnum, UINT nSize) :
		CEnumArray(sizeof(LPUNKNOWN), pvEnum, nSize, TRUE) {}
	~CEnumUnknown();

protected:
	virtual BOOL OnNext(void* pv);

	DECLARE_INTERFACE_MAP()
};

BEGIN_INTERFACE_MAP(CEnumUnknown, CEnumArray)
	INTERFACE_PART(CEnumUnknown, IID_IEnumUnknown, EnumVOID)
END_INTERFACE_MAP()

CEnumUnknown::~CEnumUnknown()
{
	if (m_pClonedFrom == NULL)
	{
		LPUNKNOWN* ppUnk = (LPUNKNOWN*)(void*)m_pvEnum;
		for (UINT i = 0; i < m_nSize; i++)
		{
			ASSERT(ppUnk[i] != NULL);
			ppUnk[i]->Release();
		}
	}
	// destructor will free the actual array (if it was not a clone)
}

BOOL CEnumUnknown::OnNext(void* pv)
{
	if (!CEnumArray::OnNext(pv))
		return FALSE;

	// AddRef the pointer (the caller has responsibility to Release it)
	ASSERT(*(LPUNKNOWN*)pv != NULL);
	(*(LPUNKNOWN*)pv)->AddRef();

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// COleControlContainer::XOleContainer

STDMETHODIMP COleControlContainer::XOleContainer::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(COleControlContainer, OleContainer)
	return (HRESULT)pThis->InternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP_(ULONG) COleControlContainer::XOleContainer::Release()
{
	METHOD_PROLOGUE_EX_(COleControlContainer, OleContainer)
	return (ULONG)pThis->InternalRelease();
}

STDMETHODIMP_(ULONG) COleControlContainer::XOleContainer::AddRef()
{
	METHOD_PROLOGUE_EX_(COleControlContainer, OleContainer)
	return (ULONG)pThis->InternalAddRef();
}

STDMETHODIMP COleControlContainer::XOleContainer::ParseDisplayName(LPBINDCTX,
	LPOLESTR, ULONG*, LPMONIKER*)
{
	return E_NOTIMPL;
}

STDMETHODIMP COleControlContainer::XOleContainer::EnumObjects(DWORD dwFlags,
	LPENUMUNKNOWN* ppEnumUnknown)
{
	METHOD_PROLOGUE_EX_(COleControlContainer, OleContainer)

	*ppEnumUnknown = NULL;
	HRESULT hr = S_OK;
	CEnumUnknown* pEnum = NULL;
	UINT_PTR cObjects = 0;
	LPUNKNOWN* ppUnk = NULL;

	TRY
	{
		if (dwFlags & OLECONTF_EMBEDDINGS)
		{
			ppUnk = new LPUNKNOWN[pThis->m_listSitesOrWnds.GetCount()];
			POSITION pos = pThis->m_listSitesOrWnds.GetHeadPosition();
			COleControlSiteOrWnd* pSiteOrWnd;
			while (pos != NULL)
			{
				pSiteOrWnd = pThis->m_listSitesOrWnds.GetNext( pos );
				ASSERT(pSiteOrWnd);
				if(pSiteOrWnd->m_pSite)
				{
					ASSERT(pSiteOrWnd->m_pSite->m_pObject != NULL);
					pSiteOrWnd->m_pSite->m_pObject->AddRef();
					ppUnk[cObjects++] = pSiteOrWnd->m_pSite->m_pObject;
				}
			}
		}
		pEnum = new CEnumUnknown(ppUnk, (UINT)cObjects);
	}
	CATCH_ALL(e)
	{
		// Note: DELETE_EXCEPTION(e) not necessary
		hr = E_OUTOFMEMORY;
	}
	END_CATCH_ALL

	// clean up in case of failure
	if (SUCCEEDED(hr))
	{
		ASSERT(pEnum != NULL);
		*ppEnumUnknown = (IEnumUnknown*)&pEnum->m_xEnumVOID;
	}
	else
	{
		ASSERT(pEnum == NULL);
		ASSERT(*ppEnumUnknown == NULL);

		if (ppUnk != NULL)
		{
			for (UINT_PTR i = 0; i < cObjects; i++)
			{
				ASSERT(ppUnk[i] != NULL);
				ppUnk[i]->Release();
			}
		}
	}

	return hr;
}

STDMETHODIMP COleControlContainer::XOleContainer::LockContainer(BOOL)
{
	return E_NOTIMPL;
}
//////////////////////////////////////
//CControlCreationInfo
CControlCreationInfo::CControlCreationInfo()
{
	m_hk = NullHandle;
	m_nHandle = 0;
}
BOOL CControlCreationInfo::IsManaged() const
{
	ASSERT((m_hk == NullHandle && m_nHandle == 0) ||(m_hk != NullHandle && m_nHandle != 0));
	return m_hk != NullHandle;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\occddxf.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "occimpl.h"



#define new DEBUG_NEW

#ifndef _AFX_NO_OCC_SUPPORT

void AFXAPI DDX_OCFloat(CDataExchange* pDX, int nIDC, DISPID dispid,
	float &value)
{
	ENSURE_ARG(pDX!=NULL);
	COleControlSite* pControl = pDX->PrepareOleCtrl(nIDC);
	ENSURE(pControl!=NULL);
	if (pDX->m_bSaveAndValidate)
		pControl->GetProperty(dispid, VT_R4, &value);
	else
		pControl->SetProperty(dispid, VT_R4, value);
}

void AFXAPI DDX_OCFloatRO(CDataExchange* pDX, int nIDC, DISPID dispid,
	float &value)
{
	ENSURE_ARG(pDX!=NULL);
	if (pDX->m_bSaveAndValidate)
	{
		COleControlSite* pControl = pDX->PrepareOleCtrl(nIDC);
		ENSURE(pControl!=NULL);
		pControl->GetProperty(dispid, VT_R4, &value);
	}
}

void AFXAPI DDX_OCFloat(CDataExchange* pDX, int nIDC, DISPID dispid,
	double &value)
{
	ENSURE_ARG(pDX!=NULL);
	COleControlSite* pControl = pDX->PrepareOleCtrl(nIDC);
	ENSURE(pControl!=NULL);
	if (pDX->m_bSaveAndValidate)
		pControl->GetProperty(dispid, VT_R8, &value);
	else
		pControl->SetProperty(dispid, VT_R8, value);
}

void AFXAPI DDX_OCFloatRO(CDataExchange* pDX, int nIDC, DISPID dispid,
	double &value)
{
	ENSURE_ARG(pDX!=NULL);
	if (pDX->m_bSaveAndValidate)
	{
		COleControlSite* pControl = pDX->PrepareOleCtrl(nIDC);
		ENSURE(pControl!=NULL);
		pControl->GetProperty(dispid, VT_R8, &value);
	}
}

#endif // !_AFX_NO_OCC_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\occdlg.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "occimpl.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////

#define CH_SYSMENU ' '

#define WS_TYPEMASK 0xC0000000
#ifndef BS_TYPEMASK
#define BS_TYPEMASK 0x0000000FL
#endif

static inline DWORD TestStyle(CWnd* pWnd, DWORD dwStyle)
	{ return GetWindowLong(pWnd->m_hWnd, GWL_STYLE) & dwStyle; }

static inline DWORD TestExStyle(CWnd* pWnd, DWORD dwExStyle)
	{ return GetWindowLong(pWnd->m_hWnd, GWL_EXSTYLE) & dwExStyle; }

static inline BOOL HasChildStyle(CWnd* pWnd)
	{ return TestStyle(pWnd, WS_TYPEMASK) == WS_CHILD; }

static inline BOOL IsControlParent(CWnd* pWnd)
	{ return TestExStyle(pWnd, WS_EX_CONTROLPARENT); }

AFX_STATIC DWORD AFXAPI _AfxGetDlgCode(CWnd* pWnd, LPMSG lpMsg=NULL)
{
	if (pWnd == NULL)
		return 0;

	WPARAM wParam = (lpMsg == NULL) ? 0 : lpMsg->wParam;

	return (DWORD)SendMessage(pWnd->m_hWnd, WM_GETDLGCODE,
		wParam, (LPARAM)(LPMSG)lpMsg);
}

AFX_STATIC void AFXAPI _AfxDlgSetFocus(CWnd* pWnd)
{
	// Select all text in an edit control.
	if (_AfxGetDlgCode(pWnd) & DLGC_HASSETSEL)
		pWnd->SendMessage(EM_SETSEL, 0, -1);

	// Set focus as normal.
	pWnd->SetFocus();
}

AFX_STATIC CWnd* AFXAPI _AfxGetChildControl(CWnd* pWndRoot, CWnd* pWndChild)
{
	CWnd* pWndControl = NULL;

	while ((pWndChild != NULL) && HasChildStyle(pWndChild) &&
		(pWndChild != pWndRoot))
	{
		pWndControl = pWndChild;
		pWndChild = pWndChild->GetParent();

		if (IsControlParent(pWndChild))
			break;
	}
	return pWndControl;
}

AFX_STATIC CWnd* AFXAPI _AfxNextControl(CWnd* pWndRoot, CWnd* pWndStart, UINT uFlags)
{
	// if pWndStart is already equal to pWndRoot, this confuses this function
	// badly.
	ASSERT(pWndRoot != pWndStart);
	CWnd* pWndStartOriginal = pWndStart;

	if (pWndStart == NULL)
	{
FirstChild:
		pWndStart = pWndRoot->GetTopWindow();
		if (pWndStart == NULL)
			return pWndRoot;

		goto Found;
	}
	else
	{
		// Are we at the last control within some parent?  If so, pop back up.
		while (pWndStart->GetNextWindow() == NULL)
		{
			// Popup to previous real ancestor.  pWndStart will be NULL,
			// pWndRoot, or the child of a recursive dialog.
			pWndStart = _AfxGetChildControl(pWndRoot, pWndStart->GetParent());
			if ((pWndStart == NULL) || (pWndStart == pWndRoot))
			{
				goto FirstChild;
			}
		}

		ASSERT(pWndStart != NULL);
		pWndStart = pWndStart->GetNextWindow();
	}

Found:
	if (IsControlParent(pWndStart))
	{
		if (((uFlags & CWP_SKIPINVISIBLE) && !pWndStart->IsWindowVisible()) ||
			((uFlags & CWP_SKIPDISABLED) && !pWndStart->IsWindowEnabled()))
		{
			if (pWndStart != pWndStartOriginal)
			{
				pWndStart = _AfxNextControl(pWndRoot, pWndStart, uFlags);
			}
			else
			{
				return NULL;
			}
		}
		else
		{
			pWndStart = _AfxNextControl(pWndStart, NULL, uFlags);
		}
	}

	return pWndStart;
}

BOOL AFX_CDECL COccManager::IsMatchingMnemonic(CWnd* pWnd, LPMSG lpMsg)
{
	ENSURE_ARG(pWnd!=NULL);
	return (pWnd->m_pCtrlSite != NULL) &&
		pWnd->m_pCtrlSite->IsMatchingMnemonic(lpMsg);
}

BOOL AFX_CDECL COccManager::IsMatchingMnemonic(COleControlSiteOrWnd* pSiteOrWnd, LPMSG lpMsg)
{
	return (pSiteOrWnd->m_pSite != NULL) &&
		pSiteOrWnd->m_pSite->IsMatchingMnemonic(lpMsg);
}

COleControlSiteOrWnd* AFXAPI _AfxFindSiteOrWnd(CWnd *pWndDlg, CWnd *pWnd)
{
	COleControlContainer *pCtrlCont = pWndDlg->GetControlContainer();
	if (pCtrlCont == NULL) 
		return NULL;
		
	POSITION pos = pCtrlCont->m_listSitesOrWnds.GetHeadPosition();
	while (pos != NULL)
	{
		COleControlSiteOrWnd* pSiteOrWnd = pCtrlCont->m_listSitesOrWnds.GetNext(pos);
		if ((pSiteOrWnd->m_pSite && pSiteOrWnd->m_pSite->m_hWnd == pWnd->m_hWnd) ||
			(pSiteOrWnd->m_hWnd == pWnd->m_hWnd))
			return pSiteOrWnd;
	}
	return NULL;
}

AFX_STATIC COleControlSiteOrWnd* AFXAPI _AfxFindNextMnem(CWnd* pWndDlg, COleControlSiteOrWnd* pSiteOrWnd, LPMSG lpMsg)
{
	ENSURE_ARG(pWndDlg!=NULL);
	COleControlSiteOrWnd* pWndStart = pSiteOrWnd;
	COleControlSiteOrWnd* pWndT;
	int i = 0;

	// Check if we are in a group box so we can find local mnemonics.
	HWND hWnd = NULL;
	if (pSiteOrWnd != NULL)
	{
		hWnd = pSiteOrWnd->m_pSite ? pSiteOrWnd->m_pSite->m_hWnd : pSiteOrWnd->m_hWnd;
	}

	if (hWnd != NULL)
	{
		CWnd *pTemp = _AfxGetChildControl(pWndDlg, CWnd::FromHandle(hWnd));
		if (pTemp)
			pWndStart = _AfxFindSiteOrWnd(pWndDlg, pTemp);
	}

	while ((pWndT = pWndDlg->GetNextDlgGroupItem(pWndStart)) != NULL)
	{
		i++;

		// Avoid infinite looping.
		if (pWndT == pSiteOrWnd || i > 60)
			break;

		pWndStart = pWndT;

		if (COccManager::IsMatchingMnemonic(pWndT, lpMsg))
			return pWndT;
	}

	// walk list to find pSiteOrWnd
	COleControlContainer *pCtrlCont = pWndDlg->GetControlContainer();
	if (pCtrlCont == NULL) 
		return NULL;
		
	POSITION pos = pCtrlCont->m_listSitesOrWnds.GetHeadPosition();

	if (pSiteOrWnd)
	{
		pWndT = NULL;
		while (pos != NULL && pWndT != pSiteOrWnd)
			pWndT = pCtrlCont->m_listSitesOrWnds.GetNext(pos);
	}
	else
		pWndT = pSiteOrWnd = pCtrlCont->m_listSitesOrWnds.GetNext(pos);

	if (!pWndT)
		return NULL;

	// walk list from pSiteOrWnd checking for matching mnemonic
	pWndT = NULL;
	while (pWndT != pSiteOrWnd)
	{
		if (!pos)
			pos = pCtrlCont->m_listSitesOrWnds.GetHeadPosition();

		pWndT = pCtrlCont->m_listSitesOrWnds.GetNext(pos);
		if (COccManager::IsMatchingMnemonic(pWndT, lpMsg))
		{
			HWND hWndSiteOrWnd = NULL;
			if (pWndT != NULL)
			{
				hWndSiteOrWnd = pWndT->m_pSite ? pWndT->m_pSite->m_hWnd : pWndT->m_hWnd;
			}

			if (hWndSiteOrWnd)
			{
				if (::IsWindowEnabled(hWndSiteOrWnd))
					return pWndT;
			}
			else
			{
				ENSURE_VALID(pWndT->m_pSite);
				DWORD dwStyle = pWndT->m_pSite->GetStyle();
				if (!(dwStyle & WS_DISABLED))
					return pWndT;
			}
		}
	}
	return NULL;
}

BOOL AFX_CDECL COccManager::IsLabelControl(CWnd* pWnd)
{
	ENSURE_ARG(pWnd!=NULL);
	return pWnd->IsWindowEnabled() && (pWnd->m_pCtrlSite != NULL) &&
		pWnd->m_pCtrlSite->m_dwMiscStatus & OLEMISC_ACTSLIKELABEL;
}

BOOL AFX_CDECL COccManager::IsLabelControl(COleControlSiteOrWnd* pSiteOrWnd)
{
	HWND hWnd = NULL;
    if(pSiteOrWnd==NULL)
    {
        return FALSE;
    }

	hWnd = pSiteOrWnd->m_pSite ? pSiteOrWnd->m_pSite->m_hWnd : pSiteOrWnd->m_hWnd;

	if (hWnd)
	{
		if (!::IsWindowEnabled(hWnd))
			return FALSE;
	}
	else
	{
		if (pSiteOrWnd->m_pSite)
		{
			DWORD dwStyle = pSiteOrWnd->m_pSite->GetStyle();
			if (dwStyle & WS_DISABLED)
				return FALSE;
		}
	}
	return ((pSiteOrWnd->m_pSite != NULL) && 
			(pSiteOrWnd->m_pSite->m_dwMiscStatus & OLEMISC_ACTSLIKELABEL));
}

AFX_STATIC COleControlSiteOrWnd* AFXAPI _AfxGetNextMnem(CWnd* pWndDlg, CWnd* pWnd, LPMSG lpMsg)
{
	COleControlSiteOrWnd* pWndFirstFound = NULL;
	COleControlSiteOrWnd* pSiteOrWnd = _AfxFindSiteOrWnd(pWndDlg, pWnd);

	// set pSiteOrWnd to control with focus
	if (!pSiteOrWnd)
	{
		COleControlContainer *pCtrlCont = pWndDlg->GetControlContainer();
		if (pCtrlCont)
		{
			POSITION pos = pCtrlCont->m_listSitesOrWnds.GetHeadPosition();
			while(pos)
			{
				COleControlSiteOrWnd *pSiteOrWndFocus = pCtrlCont->m_listSitesOrWnds.GetNext(pos);
				// Find control with focus in m_listSitesOrWnds
				if((pSiteOrWndFocus->m_pSite && pSiteOrWndFocus->m_pSite == pCtrlCont->m_pSiteFocus) ||
					(pSiteOrWndFocus->m_hWnd && pSiteOrWndFocus->m_hWnd == ::GetFocus()))
				{
					pSiteOrWnd = pSiteOrWndFocus;
					break;
				}
			}
		}
	}

	// Loop for a long time but not long enough so we hang...
	for (int count = 0; count < 256*2; count++)
	{
		// If the dialog box doesn't have the mnemonic specified, return NULL.
		if ((pSiteOrWnd = _AfxFindNextMnem(pWndDlg, pSiteOrWnd, lpMsg)) == NULL)
			return NULL;

		// If a non-disabled static item, then jump ahead to nearest tabstop.
		if (COccManager::IsLabelControl(pSiteOrWnd))
		{
			pSiteOrWnd = pWndDlg->GetNextDlgTabItem(pSiteOrWnd, FALSE);
			if (pSiteOrWnd == NULL)
				return NULL;
		}

		HWND hWnd = NULL;
		if (pSiteOrWnd != NULL)
		{
			hWnd = pSiteOrWnd->m_pSite ? pSiteOrWnd->m_pSite->m_hWnd : pSiteOrWnd->m_hWnd;
		}

		if (hWnd)
		{
			if (::IsWindowEnabled(hWnd))
				return pSiteOrWnd;
		}
		else
		{
			ENSURE_VALID(pSiteOrWnd->m_pSite);
			DWORD dwStyle = pSiteOrWnd->m_pSite->GetStyle();
			if (!(dwStyle & WS_DISABLED))
				return pSiteOrWnd;
		}

		// Stop if we've looped back to the first item we checked
		if (pSiteOrWnd == pWndFirstFound)
			return NULL;

		if (pWndFirstFound == NULL)
			pWndFirstFound = pSiteOrWnd;
	}

	return NULL;
}

void AFX_CDECL COccManager::UIActivateControl(CWnd* pWndNewFocus)
{
	if (pWndNewFocus == NULL)
		return;

	// Find the nearest control in the window parent chain.
	CWnd* pWndCtrl = pWndNewFocus;
	COleControlContainer* pCtrlCont = NULL;
	COleControlSite* pCtrlSite = NULL;
	while ((pWndCtrl != NULL) &&
		((pCtrlCont = pWndCtrl->m_pCtrlCont) == NULL) &&
		((pCtrlSite = pWndCtrl->m_pCtrlSite) == NULL))
	{
		pWndCtrl = pWndCtrl->GetParent();
	}

	if ((pWndCtrl == NULL) || (pCtrlCont != NULL))
		return;

	// This will UI Activate the control.
	pCtrlSite->SetFocus();

	// Make sure focus gets set to correct child of control, if any.
	if ((CWnd::GetFocus() != pWndNewFocus) && ::IsWindow(pWndNewFocus->GetSafeHwnd()))
		pWndNewFocus->SetFocus();
}

void AFX_CDECL COccManager::UIDeactivateIfNecessary(CWnd* pWndOldFocus,
	CWnd* pWndNewFocus)
{
	if (pWndOldFocus == NULL || !::IsWindow(pWndOldFocus->m_hWnd))
		return;

	if(pWndOldFocus == pWndNewFocus)
		return;

	// Find the nearest control container in the window parent chain.
	CWnd* pWndCtrlCont = pWndOldFocus;
	COleControlContainer* pCtrlCont = NULL;

	while(pWndCtrlCont && (pCtrlCont = pWndCtrlCont->m_pCtrlCont) == NULL)
	{
		pWndCtrlCont = pWndCtrlCont->GetParent();
	}

	if(!pCtrlCont)
		return;

	// Get the current UI Active control (if any).
	CWnd* pWndUIActive = NULL;
	COleControlSite* pSite = pCtrlCont->m_pSiteUIActive;
	if(pSite && !pSite->m_bIsWindowless)
	{
		pWndUIActive = CWnd::FromHandle(pSite->m_hWnd);
		if (pWndUIActive == NULL)
			return;
	}

	// Ignore if the control getting the focus is the same control.
	if (pWndNewFocus && pWndUIActive &&
		(pWndNewFocus == pWndUIActive || pWndUIActive->IsChild(pWndNewFocus)))
		return;

	// Tell the container to UI Deactivate the UI Active control.
	pCtrlCont->OnUIActivate(NULL);
}

CWnd* AFXAPI _AfxFindDlgItem(CWnd* pWndParent, DWORD id)
{
	CWnd* pWndChild;
	CWnd* pWndOrig;

	// QUICK TRY:
	pWndChild = pWndParent->GetDlgItem(id);
	if (pWndChild != NULL)
		return pWndChild;

	pWndOrig = _AfxNextControl(pWndParent, NULL, CWP_SKIPINVISIBLE);
	if (pWndOrig == pWndParent)
		return NULL;

	pWndChild = pWndOrig;

	do
	{
		if ((DWORD)pWndChild->GetDlgCtrlID() == id)
			return(pWndChild);

		pWndChild = _AfxNextControl(pWndParent, pWndChild, CWP_SKIPINVISIBLE);
	}
	while ((pWndChild != NULL) && (pWndChild != pWndOrig));

	return NULL;
}

void COccManager::SetDefaultButton(CWnd* pWnd, BOOL bDefault)
{
	if (pWnd->m_pCtrlSite != NULL)
	{
		pWnd->m_pCtrlSite->SetDefaultButton(bDefault);
	}
	else
	{
		DWORD code = _AfxGetDlgCode(pWnd);
		if (code & (bDefault ? DLGC_UNDEFPUSHBUTTON : DLGC_DEFPUSHBUTTON))
			pWnd->SendMessage(BM_SETSTYLE,
				(WPARAM)(bDefault ? BS_DEFPUSHBUTTON : BS_PUSHBUTTON),
				(LPARAM)(DWORD)TRUE);
	}
}

DWORD AFX_CDECL COccManager::GetDefBtnCode(CWnd* pWnd)
{
	if (pWnd == NULL)
		return 0;

	if (pWnd->m_pCtrlSite != NULL)
		return pWnd->m_pCtrlSite->GetDefBtnCode();

	return _AfxGetDlgCode(pWnd) & (DLGC_UNDEFPUSHBUTTON | DLGC_DEFPUSHBUTTON);
}

AFX_STATIC void AFXAPI _AfxRemoveDefaultButton(CWnd* pWndRoot, CWnd* pWndStart)
{
	if ((pWndStart == NULL) || IsControlParent(pWndStart))
		pWndStart = _AfxNextControl(pWndRoot, NULL, CWP_SKIPINVISIBLE | CWP_SKIPDISABLED);
	else
		pWndStart = _AfxGetChildControl(pWndRoot, pWndStart);

	if (pWndStart == NULL)
		return;

	CWnd* pWnd = pWndStart;
	CWnd* pWndNext;

	do
	{
		COccManager::SetDefaultButton(pWnd, FALSE);
		pWndNext = _AfxNextControl(pWndRoot, pWnd, 0);
		pWnd = pWndNext;
	}
	while ((pWnd != NULL) && (pWnd != pWndStart));
}

AFX_STATIC int AFXAPI _AfxOriginalDefButton(CWnd* pWndRoot)
{
	LRESULT lResult = pWndRoot->SendMessage(DM_GETDEFID, 0, 0L);
	return HIWORD(lResult) == DC_HASDEFID ? LOWORD(lResult) : IDOK;
}

AFX_STATIC void AFXAPI _AfxCheckDefPushButton(CWnd* pWndRoot, CWnd* pWndOldFocus,
	CWnd* pWndNewFocus)
{
	DWORD code = 0;
	CWnd* pWndT;

	// If the focus has gone to a totally separate window, bail out.
	if (!pWndRoot->IsChild(pWndNewFocus))
		return;

	if (pWndNewFocus != NULL)
	{
		// Do nothing if clicking on dialog background or recursive dialog
		// background.
		if (IsControlParent(pWndNewFocus))
			return;

		code = COccManager::GetDefBtnCode(pWndNewFocus);
	}

	if (pWndOldFocus == pWndNewFocus)
	{
		// Check the default ID and see if is the same as pwndOldFocus' ID.
		// If not, find it and use it as pwndOldFocus
		if (code & DLGC_UNDEFPUSHBUTTON)
		{
			if (pWndOldFocus != NULL)
			{
				pWndOldFocus = _AfxFindDlgItem(pWndRoot, _AfxOriginalDefButton(pWndRoot));
				if ((pWndOldFocus != NULL) && (pWndOldFocus != pWndNewFocus))
				{
					if (COccManager::GetDefBtnCode(pWndOldFocus) & DLGC_DEFPUSHBUTTON)
					{
						_AfxRemoveDefaultButton(pWndRoot, pWndOldFocus);
						goto SetNewDefault;
					}
				}
			}

			COccManager::SetDefaultButton(pWndNewFocus, TRUE);
		}
		return;
	}

	// If the focus is changing to or from a pushbutton, then remove the
	// default style from the current default button
	if (((pWndOldFocus != NULL) && (COccManager::GetDefBtnCode(pWndOldFocus) != 0)) ||
		((pWndNewFocus != NULL) && (code != 0)))
	{
		_AfxRemoveDefaultButton(pWndRoot, pWndNewFocus);
	}

SetNewDefault:
	// If moving to a button, make that button the default.
	if (code & (DLGC_UNDEFPUSHBUTTON | DLGC_DEFPUSHBUTTON))
	{
		COccManager::SetDefaultButton(pWndNewFocus, TRUE);
	}
	else
	{
		// Otherwise, make sure the original default button is default

		// Get the original default button
		pWndT = _AfxFindDlgItem(pWndRoot, _AfxOriginalDefButton(pWndRoot));

		if ((COccManager::GetDefBtnCode(pWndT) & DLGC_UNDEFPUSHBUTTON) &&
			pWndT->IsWindowEnabled())
		{
			COccManager::SetDefaultButton(pWndT, TRUE);
		}
	}
}

BOOL COccManager::IsDialogMessage(CWnd* pWndDlg, LPMSG lpMsg)
{
	ASSERT(pWndDlg);

	// If an OLE Control has the focus, then give it the first crack at key
	// and mouse messages.
	HWND hWndDlg = pWndDlg->GetSafeHwnd();
	UINT uMsg = lpMsg->message;
	HWND hWndFocus = NULL;
	CWnd* pWndFocus = NULL;
	COleControlSiteOrWnd *pSiteOrWnd;

	hWndFocus = ::GetFocus();
	pWndFocus= CWnd::FromHandle(hWndFocus);

	if (((uMsg >= WM_KEYFIRST) && (uMsg <= WM_KEYLAST)) ||
		((uMsg >= WM_MOUSEFIRST) && (uMsg <= AFX_WM_MOUSELAST)))
	{
		if(pWndFocus)
		{
			CWnd* pWndCtrl = pWndFocus;

			// Walk up the parent chain, until we find an OLE control.
			while ((pWndCtrl != NULL) && (pWndCtrl->m_pCtrlSite == NULL) &&
				(pWndCtrl->GetParent() != pWndDlg))
			{
				pWndCtrl = pWndCtrl->GetParent();
			}

			// let the control attempt to translate the message
			if (pWndCtrl != NULL && pWndCtrl->m_pCtrlSite != NULL &&
				pWndCtrl->m_pCtrlSite->m_pActiveObject != NULL &&
				pWndCtrl->m_pCtrlSite->m_pActiveObject->TranslateAccelerator(lpMsg) == S_OK)
			{
				return TRUE;
			}

			// handle CTRLINFO_EATS_RETURN and CTRLINFO_EATS_ESCAPE flags
			if ((uMsg == WM_KEYUP || uMsg == WM_KEYDOWN || uMsg == WM_CHAR) &&
				pWndCtrl != NULL && pWndCtrl->m_pCtrlSite != NULL &&
				((LOWORD(lpMsg->wParam) == VK_RETURN && 
				 (pWndCtrl->m_pCtrlSite->m_ctlInfo.dwFlags & CTRLINFO_EATS_RETURN)) ||
				(LOWORD(lpMsg->wParam) == VK_ESCAPE &&
				 (pWndCtrl->m_pCtrlSite->m_ctlInfo.dwFlags & CTRLINFO_EATS_ESCAPE))))
			{
				return FALSE;
			}
		}
	}

	BOOL bResult = FALSE;
	CWnd* pWndMsg = CWnd::FromHandle(lpMsg->hwnd);
	CWnd* pWndNext = NULL;
	DWORD code;
	BOOL bBack = FALSE;
	int iOK = IDCANCEL;

	switch (uMsg)
	{
	case WM_SYSCHAR:
		// If no control has focus, and Alt not down, then ignore.
		if ((pWndFocus == NULL) && (GetKeyState(VK_MENU) >= 0))
			break;

		// If alt+menuchar, process as menu.
		if (LOWORD(lpMsg->wParam) == CH_SYSMENU)
			break;

		// FALL THRU

	case WM_CHAR:
		code = _AfxGetDlgCode(pWndMsg, lpMsg);

		// If the control wants to process the message, then don't check
		// for possible mnemonic key.
		if (uMsg == WM_CHAR && (code & (DLGC_WANTCHARS|DLGC_WANTMESSAGE)))
			break;

		// If the control wants tabs, then don't let tab fall thru here
		if (LOWORD(lpMsg->wParam) == VK_TAB && (code & DLGC_WANTTAB))
			break;

		// Don't handle space as a mnemonic
		if (LOWORD(lpMsg->wParam) == VK_SPACE)
			return FALSE;  // Let the control have a chance to handle the space key

		if ((pSiteOrWnd = _AfxGetNextMnem(pWndDlg, pWndMsg, lpMsg)) != NULL)
		{
			if (pSiteOrWnd->m_pSite != NULL)
			{
				// UI Activate new control, and send the mnemonic to it.
				pSiteOrWnd->m_pSite->SendMnemonic(lpMsg);
				bResult = TRUE;
			}
		}
		break;

	case WM_KEYDOWN:
		code = _AfxGetDlgCode(pWndMsg, lpMsg);
		switch (LOWORD(lpMsg->wParam))
		{
		case VK_TAB:
			{
				if (code & DLGC_WANTTAB)    // If control wants tabs, bail out.
					break;

				bBack = GetKeyState(VK_SHIFT) < 0;
				pSiteOrWnd = pWndDlg->GetNextDlgTabItem((COleControlSiteOrWnd*)NULL, bBack);
				if(pSiteOrWnd)
				{
					if(pSiteOrWnd->m_pSite)
					{						
						pSiteOrWnd->m_pSite->SetFocus(lpMsg);
					}
					else
					{
						// If we failed to find the next window fall back
						// on the tried-and-true method.
						pWndNext = pSiteOrWnd->m_hWnd ?
							CWnd::FromHandle(pSiteOrWnd->m_hWnd) :
							pWndDlg->GetNextDlgTabItem(pWndMsg, bBack);

						if(pWndNext)
						{
							pWndDlg->m_pCtrlCont->m_pSiteFocus = NULL;
							_AfxDlgSetFocus(pWndNext);
							UIDeactivateIfNecessary(pWndFocus, pWndNext);
						}
					}
					bResult = TRUE;
				}
			}
			break;

		case VK_LEFT:
		case VK_UP:
			bBack = TRUE;
			// FALL THRU

		case VK_RIGHT:
		case VK_DOWN:
			if (_AfxGetDlgCode(pWndFocus, lpMsg) & DLGC_WANTARROWS)
				break;

			if(bBack)
				pSiteOrWnd = pWndDlg->GetPrevDlgGroupItem();
			else
				pSiteOrWnd = pWndDlg->GetNextDlgGroupItem();

			if(pSiteOrWnd)
			{
				// If the control is an auto-check radio button we
				// need to uncheck the currently checked radio button.
				if(pSiteOrWnd->m_bAutoRadioButton)
					pWndDlg->RemoveRadioCheckFromGroup(pSiteOrWnd);

				if(pSiteOrWnd->m_pSite)
				{
					pSiteOrWnd->m_pSite->SetFocus(lpMsg);
					bResult = TRUE;
				}
				else
				{
					// Just in case, beyond all hope we failed to find then next
					// control, fall back on the tried and true method...
					pWndNext = pSiteOrWnd->m_hWnd ?
						CWnd::FromHandle(pSiteOrWnd->m_hWnd) :
						pWndDlg->GetNextDlgGroupItem(pWndFocus, bBack);

					if(pWndNext)
					{
						// If the old control was an ActiveX control, clear it.
						pWndDlg->m_pCtrlCont->m_pSiteFocus = NULL;
						_AfxDlgSetFocus(pWndNext);

						// If the new control is an auto-check radio button, set
						// the check.
						if(pSiteOrWnd->m_bAutoRadioButton)
							pWndNext->SendMessage(BM_SETCHECK, BST_CHECKED, 0);
						bResult = TRUE;
					}
				}
			}
			break;

		case VK_EXECUTE:
		case VK_RETURN:
			// Return was pressed.
		 if (code&DLGC_WANTALLKEYS)
			break;

		 // Find default button and click it.
			if (GetDefBtnCode(pWndFocus) & DLGC_DEFPUSHBUTTON)
			{
				pWndNext = pWndFocus;
				iOK = (DWORD)pWndNext->GetDlgCtrlID();
			}
			else
			{
				iOK = _AfxOriginalDefButton(pWndDlg);
			}
			// FALL THRU

		case VK_ESCAPE:
		case VK_CANCEL:
			if (pWndNext == NULL)
			{
				pWndNext = _AfxFindDlgItem(pWndDlg, iOK);
				if (pWndNext == NULL)
					break;
			}
			ASSERT(pWndNext != NULL);

			// Make sure button is not disabled.
			if (!pWndNext->IsWindowEnabled())
			{
				MessageBeep(0);
			}
			else if (pWndNext->m_pCtrlSite != NULL)
			{
				// "push" the pWndNext control.
				TRY
				{
					pWndNext->InvokeHelper(DISPID_DOCLICK, DISPATCH_METHOD,
						VT_EMPTY, NULL, VTS_NONE);
				}
				END_TRY
				bResult = TRUE;
			}
			break;
		}
		break;
	}

	// As a last resort, delegate to the Windows implementation
	if (!bResult && (pWndDlg->m_nFlags & WF_ISWINFORMSVIEWWND)==0)
	{
		bResult = ::IsDialogMessage(pWndDlg->m_hWnd, lpMsg);
		if (bResult && (CWnd::GetFocus() != pWndFocus))
			UIActivateControl(CWnd::GetFocus());
	}

	if (::IsWindow(hWndFocus))
	{
		UIDeactivateIfNecessary(pWndFocus, CWnd::GetFocus());
		if (::IsWindow(hWndDlg))
			_AfxCheckDefPushButton(pWndDlg, pWndFocus, CWnd::GetFocus());
	}
	return bResult;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\occimpl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef _AFX_NO_OCC_SUPPORT

// MFC doesn't use the OLEDB 1.5 features of ATL and it causes
// compile problems, so just make ATL think it's not version 1.5
#if (OLEDBVER >= 0x0150)
#undef OLEDBVER
#define OLEDBVER 0x0100
#endif

#include "atldbcli.h"

class CDataSourceControl;
class CDataBoundProperty;

// CCmdTarget
	class COleControlContainer;
	class COleControlSite;

class COccManager;
struct _AFX_OCC_DIALOG_INFO;

#define DISPID_DATASOURCE   0x80010001
#define DISPID_DATAFIELD    0x80010002

interface AFX_NOVTABLE IDataSourceListener : public IUnknown
{
public:
	virtual HRESULT STDMETHODCALLTYPE OnDataMemberChanged(BSTR bstrDM) = 0;
	virtual HRESULT STDMETHODCALLTYPE OnDataMemberAdded(BSTR bstrDM) = 0;
	virtual HRESULT STDMETHODCALLTYPE OnDataMemberRemoved(BSTR bstrDM) = 0;
};

interface AFX_NOVTABLE IDataSource : public IUnknown
{
public:
	virtual HRESULT STDMETHODCALLTYPE GetDataMember(BSTR bstrDM, const GUID __RPC_FAR* riid, IUnknown __RPC_FAR* __RPC_FAR* ppunk) = 0;
	virtual HRESULT STDMETHODCALLTYPE GetDataMemberName(long lIndex, BSTR __RPC_FAR *pbstrDM) = 0;
	virtual HRESULT STDMETHODCALLTYPE GetDataMemberCount(long __RPC_FAR *plCount) = 0;
	virtual HRESULT STDMETHODCALLTYPE AddDataSourceListener(IDataSourceListener __RPC_FAR *pDSL) = 0;
	virtual HRESULT STDMETHODCALLTYPE RemoveDataSourceListener(IDataSourceListener __RPC_FAR *pDSL) = 0;
};

/////////////////////////////////////////////////////////////////////////////
// OLE Databinding support class for data sources

interface IRowPosition;

class CDataSourceControl
{
private:
	CDataSourceControl() {};
public:
	struct METAROWTYPE
	{
		DBCOLUMNID idColumnID;
		DWORD dwColumnID;
		LPSTR lpstrName;
		DWORD dwName;
		CPtrList* m_pClientList;
	};

	CDataSourceControl(COleControlSite *pClientSite);
	~CDataSourceControl();
	HRESULT Initialize();
	virtual IUnknown* GetCursor();
	HRESULT GetMetaData();
	virtual void BindProp(COleControlSite* pClientSite, BOOL bBind = TRUE);
	virtual void BindProp(CDataBoundProperty* pProperty, BOOL bBind = TRUE);
	virtual void BindColumns();
	BOOL CopyColumnID(DBCOLUMNID* pcidDst, DBCOLUMNID const *pcidSrc);
	HRESULT GetBoundClientRow();
	virtual HRESULT UpdateControls();
	virtual HRESULT UpdateCursor();
	COleVariant ToVariant(int nCol);

	COleControlSite *m_pClientSite;  // Back ptr to containing site
	ICursorMove* m_pCursorMove;
	ICursorUpdateARow* m_pCursorUpdateARow;
	INT_PTR m_nColumns;
	METAROWTYPE* m_pMetaRowData;
	CPtrList m_CursorBoundProps;
	void* m_pVarData;
	INT_PTR m_nBindings;
	DBCOLUMNBINDING *m_pColumnBindings;
	VARIANT* m_pValues;
	BOOL m_bUpdateInProgress;

// OLE/DB stuff
	IDataSource*            m_pDataSource;
	IRowPosition*           m_pRowPosition;
	ATL::CRowset<>*         m_pRowset;
	ATL::CDynamicAccessor*  m_pDynamicAccessor;

	DWORD m_dwRowsetNotify; // IRowsetNotify cookie
};

/////////////////////////////////////////////////////////////////////////////
// OLE Databinding support class for bound controls

class CDataBoundProperty
{
protected:
	CDataBoundProperty() {};
public:
	CDataBoundProperty(CDataBoundProperty* pLast, DISPID dispid, WORD ctlid);
	~CDataBoundProperty() {};
	void SetClientSite(COleControlSite *pClientSite);
	void SetDSCSite(COleControlSite *pDSCSite);
	void RemoveSource();
	void Notify();
	IUnknown* GetCursor();
	CDataBoundProperty* GetNext();

	COleControlSite *m_pClientSite;  // Back ptr to containing site
	WORD m_ctlid;
	DISPID m_dispid;
	COleControlSite *m_pDSCSite;
	BOOL m_bOwnXferOut;
	BOOL m_bIsDirty;
	CDataBoundProperty* m_pNext;
};

#endif // !_AFX_NO_OCC_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\occevent.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "occimpl.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// OLE event sink handler

typedef BOOL (AFX_MSG_CALL CCmdTarget::*PFN_CHANGED)();
typedef BOOL (AFX_MSG_CALL CCmdTarget::*PFN_REQUEST)(BOOL*);
typedef BOOL (AFX_MSG_CALL CCmdTarget::*PFN_DSCNOTIFY)(DSCSTATE, DSCREASON, BOOL*);
typedef BOOL (AFX_MSG_CALL CCmdTarget::*PFN_CHANGED_RANGE)(UINT);
typedef BOOL (AFX_MSG_CALL CCmdTarget::*PFN_REQUEST_RANGE)(UINT, BOOL*);
typedef BOOL (AFX_MSG_CALL CCmdTarget::*PFN_DSCNOTIFY_RANGE)(UINT, DSCSTATE, DSCREASON, BOOL*);

BOOL CCmdTarget::OnEvent(UINT idCtrl, AFX_EVENT* pEvent,
	AFX_CMDHANDLERINFO* pHandlerInfo)
{
	HRESULT hResult = S_OK;
	UINT uArgError = (UINT)-1;    // no error yet
	const AFX_EVENTSINKMAP_ENTRY* pEntry = GetEventSinkEntry(idCtrl, pEvent);

	// no handler for this event
	if (pEntry == NULL)
		return FALSE;

	if (pHandlerInfo != NULL)
	{
		// just fill in the information, don't do it
		pHandlerInfo->pTarget = this;
		switch (pEvent->m_eventKind)
		{
		case AFX_EVENT::event:
		case AFX_EVENT::propRequest:
			pHandlerInfo->pmf = pEntry->dispEntry.pfn;
			break;

		case AFX_EVENT::propChanged:
			pHandlerInfo->pmf = pEntry->dispEntry.pfnSet;
			break;

		default:
			ASSERT(FALSE);  // bogus value for pEvent->m_eventKind
		}

		return (pHandlerInfo->pmf != NULL);
	}

	BOOL bRange = (pEntry->nCtrlIDLast != (UINT)-1);
	BOOL bHandled = FALSE;

	TRY
	{
		switch (pEvent->m_eventKind)
		{
		case AFX_EVENT::event:
			// do standard method call
			VARIANT var;
			AfxVariantInit(&var);

			DISPPARAMS dispparams;
			dispparams.rgvarg = NULL;

			if (bRange)
			{
				Checked::memcpy_s(&dispparams, sizeof(DISPPARAMS), 
					pEvent->m_pDispParams, sizeof(DISPPARAMS));

				dispparams.rgvarg = new VARIANT[++dispparams.cArgs];
				Checked::memcpy_s(dispparams.rgvarg, dispparams.cArgs * sizeof(VARIANT), 
					pEvent->m_pDispParams->rgvarg, sizeof(VARIANT) * (dispparams.cArgs-1));

				VARIANT* pvarID = &dispparams.rgvarg[dispparams.cArgs-1];
				V_VT(pvarID) = VT_I4;
				V_I4(pvarID) = idCtrl;
			}

			hResult = CallMemberFunc(&pEntry->dispEntry, DISPATCH_METHOD, &var,
				(bRange ? &dispparams : pEvent->m_pDispParams), &uArgError);
			ASSERT(FAILED(hResult) || (V_VT(&var) == VT_BOOL));
			bHandled = V_BOOL(&var);

			if (bRange)
				delete [] dispparams.rgvarg;

			break;

		case AFX_EVENT::propChanged:
			{
				if (bRange)
				{
					PFN_CHANGED_RANGE pfn = (PFN_CHANGED_RANGE)pEntry->dispEntry.pfnSet;
					bHandled = (this->*pfn)(idCtrl);
				}
				else
				{
					PFN_CHANGED pfn = (PFN_CHANGED)pEntry->dispEntry.pfnSet;
					bHandled = (this->*pfn)();
				}

				hResult = S_OK;
			}
			break;

		case AFX_EVENT::propRequest:
			{
				BOOL bAllow = TRUE;

				if (bRange)
				{
					PFN_REQUEST_RANGE pfn = (PFN_REQUEST_RANGE)pEntry->dispEntry.pfn;
					bHandled = (this->*pfn)(idCtrl, &bAllow);
				}
				else
				{
					PFN_REQUEST pfn = (PFN_REQUEST)pEntry->dispEntry.pfn;
					bHandled = (this->*pfn)(&bAllow);
				}

				hResult = bAllow ? S_OK : S_FALSE;
			}
			break;

		case AFX_EVENT::propDSCNotify:
			{
				BOOL bAllow = TRUE;

				if (bRange)
				{
					PFN_DSCNOTIFY_RANGE pfn = (PFN_DSCNOTIFY_RANGE)pEntry->dispEntry.pfn;
					bHandled = (this->*pfn)(idCtrl, pEvent->m_nDSCState,
						pEvent->m_nDSCReason, &bAllow);
				}
				else
				{
					PFN_DSCNOTIFY pfn = (PFN_DSCNOTIFY)pEntry->dispEntry.pfn;
					bHandled = (this->*pfn)(pEvent->m_nDSCState,
						pEvent->m_nDSCReason, &bAllow);
				}

				hResult = bAllow ? S_OK : S_FALSE;
			}
			break;

		default:
			ASSERT(FALSE);  // bogus value for pEvent->m_eventKind
		}
	}
	CATCH_ALL(e)
	{
		if (pEvent->m_pExcepInfo != NULL)
		{
			// fill exception with translation of MFC exception
			COleDispatchException::Process(pEvent->m_pExcepInfo, e);
		}
		DELETE_EXCEPTION(e);
		hResult = DISP_E_EXCEPTION;
	}
	END_CATCH_ALL

	// fill error argument if one is available
	if (FAILED(hResult) && pEvent->m_puArgError != NULL && uArgError != -1)
		*pEvent->m_puArgError = uArgError;

	// fill result code
	pEvent->m_hResult = hResult;

	return bHandled;
}

/////////////////////////////////////////////////////////////////////////////
// Locate event sink map entry

const AFX_EVENTSINKMAP_ENTRY* PASCAL CCmdTarget::GetEventSinkEntry(
	UINT idCtrl, AFX_EVENT* pEvent)
{
	ENSURE_ARG(pEvent != NULL);
	const AFX_EVENTSINKMAP* pSinkMap = GetEventSinkMap();
	const AFX_EVENTSINKMAP_ENTRY* pEntry;
	size_t flag = (pEvent->m_eventKind != AFX_EVENT::event);

#ifdef _AFXDLL
	for (;;)
#else
	while (pSinkMap != NULL)
#endif
	{
		// find matching AFX_EVENTSINKMAP_ENTRY
		pEntry = pSinkMap->lpEntries;
		while (pEntry->dispEntry.nPropOffset != -1)
		{
			if ((pEntry->dispEntry.lDispID == pEvent->m_dispid) &&
				(pEntry->dispEntry.nPropOffset == flag))
			{
				if (pEntry->nCtrlIDLast == (UINT)-1)
				{
					// check for wildcard match or exact match
					if ((pEntry->nCtrlIDFirst == (UINT)-1) ||
						(pEntry->nCtrlIDFirst == idCtrl))
						return pEntry;
				}
				else
				{
					// check for range match
					if ((pEntry->nCtrlIDFirst <= idCtrl) &&
						(idCtrl <= pEntry->nCtrlIDLast))
						return pEntry;
				}
			}

			++pEntry;
		}
		// check base class
#ifdef _AFXDLL
		if (pSinkMap->pfnGetBaseMap == NULL)
			break;
		pSinkMap = (*pSinkMap->pfnGetBaseMap)();
#else
		pSinkMap = pSinkMap->pBaseMap;
#endif
	}

	return NULL;    // no matching entry
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\occddx.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "occimpl.h"



#define new DEBUG_NEW

#ifndef _AFX_NO_OCC_SUPPORT

/////////////////////////////////////////////////////////////////////////////
// Private helper for read-only property exchange with OLE controls

static void DDX_OCPropertyRO(CDataExchange* pDX, int nIDC,
	DISPID dispid, VARTYPE vt, void* pValue)
{
	ENSURE_ARG(pDX!=NULL);
	if (pDX->m_bSaveAndValidate)
	{
		COleControlSite* pControl = pDX->PrepareOleCtrl(nIDC);
		ENSURE(pControl!=NULL);
		pControl->GetProperty(dispid, vt, pValue);
	}
}

/////////////////////////////////////////////////////////////////////////////
// Simple formatting to text item

void AFXAPI DDX_OCText(CDataExchange* pDX, int nIDC, DISPID dispid,
	CString& value)
{
	ENSURE_ARG(pDX!=NULL);
	COleControlSite* pControl = pDX->PrepareOleCtrl(nIDC);
	ENSURE(pControl!=NULL);
	if (pDX->m_bSaveAndValidate)
		pControl->GetProperty(dispid, VT_BSTR, &value);
	else
		pControl->SetProperty(dispid, VT_BSTR, (LPCTSTR)value);
}

void AFXAPI DDX_OCTextRO(CDataExchange* pDX, int nIDC, DISPID dispid,
	CString& value)
{
	ENSURE_ARG(pDX!=NULL);
	DDX_OCPropertyRO(pDX, nIDC, dispid, VT_BSTR, &value);
}

/////////////////////////////////////////////////////////////////////////////
// non-text properties

void AFXAPI DDX_OCBool(CDataExchange* pDX, int nIDC, DISPID dispid,
	BOOL& value)
{
	ENSURE_ARG(pDX!=NULL);
	COleControlSite* pControl = pDX->PrepareOleCtrl(nIDC);
	ENSURE(pControl!=NULL);
	if (pDX->m_bSaveAndValidate)
		pControl->GetProperty(dispid, VT_BOOL, &value);
	else
		pControl->SetProperty(dispid, VT_BOOL, value);
}

void AFXAPI DDX_OCBoolRO(CDataExchange* pDX, int nIDC, DISPID dispid,
	BOOL& value)
{
	ENSURE_ARG(pDX!=NULL);
	DDX_OCPropertyRO(pDX, nIDC, dispid, VT_BOOL, &value);
}

void AFXAPI DDX_OCInt(CDataExchange* pDX, int nIDC, DISPID dispid,
	int &value)
{
	ENSURE_ARG(pDX!=NULL);
	COleControlSite* pControl = pDX->PrepareOleCtrl(nIDC);
	ENSURE(pControl!=NULL);
	if (pDX->m_bSaveAndValidate)
		pControl->GetProperty(dispid, VT_I4, &value);
	else
		pControl->SetProperty(dispid, VT_I4, value);
}

void AFXAPI DDX_OCIntRO(CDataExchange* pDX, int nIDC, DISPID dispid,
	int &value)
{
	ENSURE_ARG(pDX!=NULL);
	DDX_OCPropertyRO(pDX, nIDC, dispid, VT_I4, &value);
}

void AFXAPI DDX_OCInt(CDataExchange* pDX, int nIDC, DISPID dispid,
	long &value)
{
	ENSURE_ARG(pDX!=NULL);
	COleControlSite* pControl = pDX->PrepareOleCtrl(nIDC);
	ENSURE(pControl!=NULL);
	if (pDX->m_bSaveAndValidate)
		pControl->GetProperty(dispid, VT_I4, &value);
	else
		pControl->SetProperty(dispid, VT_I4, value);
}

void AFXAPI DDX_OCIntRO(CDataExchange* pDX, int nIDC, DISPID dispid,
	long &value)
{
	ENSURE_ARG(pDX!=NULL);
	DDX_OCPropertyRO(pDX, nIDC, dispid, VT_I4, &value);
}

void AFXAPI DDX_OCShort(CDataExchange* pDX, int nIDC, DISPID dispid,
	short& value)
{
	ENSURE_ARG(pDX!=NULL);
	COleControlSite* pControl = pDX->PrepareOleCtrl(nIDC);
	ENSURE(pControl!=NULL);
	if (pDX->m_bSaveAndValidate)
		pControl->GetProperty(dispid, VT_I2, &value);
	else
		pControl->SetProperty(dispid, VT_I2, value);
}

void AFXAPI DDX_OCShortRO(CDataExchange* pDX, int nIDC, DISPID dispid,
	short& value)
{
	ENSURE_ARG(pDX!=NULL);
	DDX_OCPropertyRO(pDX, nIDC, dispid, VT_I2, &value);
}

void AFXAPI DDX_OCColor(CDataExchange* pDX, int nIDC, DISPID dispid,
	OLE_COLOR& value)
{
	ENSURE_ARG(pDX!=NULL);
	COleControlSite* pControl = pDX->PrepareOleCtrl(nIDC);
	ENSURE(pControl!=NULL);
	if (pDX->m_bSaveAndValidate)
		pControl->GetProperty(dispid, VT_COLOR, &value);
	else
		pControl->SetProperty(dispid, VT_COLOR, value);
}

void AFXAPI DDX_OCColorRO(CDataExchange* pDX, int nIDC, DISPID dispid,
	OLE_COLOR& value)
{
	ENSURE_ARG(pDX!=NULL);
	DDX_OCPropertyRO(pDX, nIDC, dispid, VT_COLOR, &value);
}

#endif // !_AFX_NO_OCC_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\olebind.h ===
/*****************************************************************************\
*                                                                             *
* olebind.h     Data binding interfaces for OLE                               *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) Microsoft Corp. All rights reserved.            *
*                                                                             *
\*****************************************************************************/

#if !defined( _OLEBIND_H_ )
#define _OLEBIND_H_

#if !defined( INITGUID )
#include <olectl.h>
#endif

DEFINE_GUID(IID_IBoundObject,
	0x9BFBBC00,0xEFF1,0x101A,0x84,0xED,0x00,0xAA,0x00,0x34,0x1D,0x07);
DEFINE_GUID(IID_IBoundObjectSite,
	0x9BFBBC01,0xEFF1,0x101A,0x84,0xED,0x00,0xAA,0x00,0x34,0x1D,0x07);

typedef interface IBoundObject FAR* LPBOUNDOBJECT;
typedef interface IBoundObjectSite FAR* LPBOUNDOBJECTSITE;

typedef interface ICursor FAR* LPCURSOR;
typedef interface ICursor FAR* FAR* LPLPCURSOR;
typedef interface ICursorMove FAR* LPCURSORMOVE;
typedef interface ICursorScroll FAR* LPCURSORSCROLL;
typedef interface ICursorFind FAR* LPCURSORFIND;
typedef interface ICursorUpdateARow FAR* LPCURSORUPDATEAROW;

//////////////////////////////////////////////////////////////////////////////
//
//  IBoundObject interface
//
//////////////////////////////////////////////////////////////////////////////

#undef  INTERFACE
#define INTERFACE IBoundObject

DECLARE_INTERFACE_(IBoundObject, IUnknown)
{
	//
	//  IUnknown methods
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	//
	//  IBoundObject methods
	//
	STDMETHOD(OnSourceChanged)(THIS_ DISPID dispid, BOOL fBound, BOOL FAR* lpfOwnXferOut) PURE;
	STDMETHOD(IsDirty)(THIS_ DISPID dispid) PURE;
};
//////////////////////////////////////////////////////////////////////////////
//
//  IBoundObjectSite interface
//
//////////////////////////////////////////////////////////////////////////////

#undef  INTERFACE
#define INTERFACE IBoundObjectSite

DECLARE_INTERFACE_(IBoundObjectSite, IUnknown)
{
	//
	//  IUnknown methods
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	//
	//  IBoundObjectSite methods
	//
	STDMETHOD(GetCursor)(THIS_ DISPID dispid, LPLPCURSOR ppCursor, LPVOID FAR* ppcidOut) PURE;
};


#endif // !defined( _OLEBIND_H_ )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\occmgr.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#ifdef MACOCX
#define DBINITCONSTANTS
#endif
#include "occimpl.h"
#include "ocdb.h"



#define new DEBUG_NEW

#ifndef _AFX_NO_OCC_SUPPORT

/////////////////////////////////////////////////////////////////////////////
// AfxEnableControlContainer - wire up control container functions

PROCESS_LOCAL(COccManager, _afxOccManager)

PROCESS_LOCAL(CControlSiteFactoryMgr, _afxControlFactoryMgr)

void AFX_CDECL AfxEnableControlContainer(COccManager* pOccManager)
{
	if (pOccManager == NULL)
		afxOccManager = _afxOccManager.GetData();
	else
		afxOccManager = pOccManager;
}

/////////////////////////////////////////////////////////////////////////////
// Helper functions for cracking dialog templates

static inline BOOL IsDialogEx(const DLGTEMPLATE* pTemplate)
{
	ENSURE_ARG(pTemplate!=NULL);
	return ((DLGTEMPLATEEX*)pTemplate)->signature == 0xFFFF;
}

static inline WORD& DlgTemplateItemCount(DLGTEMPLATE* pTemplate)
{
	if (IsDialogEx(pTemplate))
		return reinterpret_cast<DLGTEMPLATEEX*>(pTemplate)->cDlgItems;
	else
		return pTemplate->cdit;
}

static inline const WORD& DlgTemplateItemCount(const DLGTEMPLATE* pTemplate)
{
	if (IsDialogEx(pTemplate))
		return reinterpret_cast<const DLGTEMPLATEEX*>(pTemplate)->cDlgItems;
	else
		return pTemplate->cdit;
}

AFX_STATIC DLGITEMTEMPLATE* AFXAPI _AfxFindFirstDlgItem(const DLGTEMPLATE* pTemplate)
{
	DWORD dwStyle = pTemplate->style;
	BOOL bDialogEx = IsDialogEx(pTemplate);

	WORD* pw;
	if (bDialogEx)
	{
		pw = (WORD*)((DLGTEMPLATEEX*)pTemplate + 1);
		dwStyle = ((DLGTEMPLATEEX*)pTemplate)->style;
	}
	else
	{
		pw = (WORD*)(pTemplate + 1);
	}

	if (*pw == (WORD)-1)        // Skip menu name ordinal or string
		pw += 2; // WORDs
	else
		while (*pw++);

	if (*pw == (WORD)-1)        // Skip class name ordinal or string
		pw += 2; // WORDs
	else
		while (*pw++);

	while (*pw++);              // Skip caption string

	if (dwStyle & DS_SETFONT)
	{
		pw += bDialogEx ? 3 : 1;    // Skip font size, weight, (italic, charset)
		while (*pw++);              // Skip font name
	}

	// Dword-align and return
	return (DLGITEMTEMPLATE*)(((DWORD_PTR)pw + 3) & ~DWORD_PTR(3));
}

AFX_STATIC DLGITEMTEMPLATE* AFXAPI _AfxFindNextDlgItem(DLGITEMTEMPLATE* pItem, BOOL bDialogEx)
{
	WORD* pw;

	if (bDialogEx)
		pw = (WORD*)((DLGITEMTEMPLATEEX*)pItem + 1);
	else
		pw = (WORD*)(pItem + 1);

	if (*pw == (WORD)-1)            // Skip class name ordinal or string
		pw += 2; // WORDs
	else
		while (*pw++);

	if (*pw == (WORD)-1)            // Skip text ordinal or string
		pw += 2; // WORDs
	else
		while (*pw++);

	WORD cbExtra = *pw++;           // Skip extra data

	if (cbExtra != 0 && !bDialogEx)
		cbExtra -=2;

	// Dword-align and return
	return (DLGITEMTEMPLATE*)(((DWORD_PTR)pw + cbExtra + 3) & ~DWORD_PTR(3));
}

/////////////////////////////////////////////////////////////////////////////
// COccManager

BOOL COccManager::OnEvent(CCmdTarget* pCmdTarget, UINT idCtrl,
	AFX_EVENT* pEvent, AFX_CMDHANDLERINFO* pHandlerInfo)
{
	return pCmdTarget->OnEvent(idCtrl, pEvent, pHandlerInfo);
}

COleControlContainer* COccManager::CreateContainer(CWnd* pWnd)
{
	// advanced control container apps may want to override
	return new COleControlContainer(pWnd);
}


//For backward compatibility with user code that overrides CreateSite. 
COleControlSite* COccManager::CreateSite(COleControlContainer* pCtrlCont)
{
	pCtrlCont; // unused
	return NULL;
}


COleControlSite* COccManager::CreateSite(COleControlContainer* pCtrlCont,const CControlCreationInfo& creationInfo)
{
	COleControlSite* pSite=CreateSite(pCtrlCont);
	if (pSite!=NULL && creationInfo.IsManaged())
	{
		TRACE(traceOle, 0, "Warning: User overrides COccManager::CreateSite that prevent CControlCreationInfo (WinForms control) special site to be created.\nCan fix by overriding the new COccManager::CreateSite(COleControlContainer* pCtrlCont,const CControlCreationInfo& creationInfo) and allowing WinForms site to get created.");
		return NULL;
	}

	if (pSite==NULL)
	{
		//Search among the registered control site factories, one that wants to create the 
		//control site for this clsid. If none is found, default to COleControlSite.	
		pSite=_afxControlFactoryMgr->CreateSite(pCtrlCont,creationInfo);
		ENSURE(pSite != NULL); //At least the default factory (COleControlSite) must be registered.
	}
	return pSite;
}

const DLGTEMPLATE* COccManager::PreCreateDialog(_AFX_OCC_DIALOG_INFO* pDlgInfo,
	const DLGTEMPLATE* pOrigTemplate)
{
	ASSERT(pDlgInfo != NULL);

	pDlgInfo->m_ppOleDlgItems =
		(DLGITEMTEMPLATE**)calloc(sizeof(DLGITEMTEMPLATE*),
			(DlgTemplateItemCount(pOrigTemplate) + 1));

	if (pDlgInfo->m_ppOleDlgItems == NULL)
		return NULL;

	DLGTEMPLATE* pNewTemplate = SplitDialogTemplate(pOrigTemplate,
		pDlgInfo->m_ppOleDlgItems);
	pDlgInfo->m_pNewTemplate = pNewTemplate;

	DLGITEMTEMPLATE *pItem = _AfxFindFirstDlgItem(pOrigTemplate);
	DLGITEMTEMPLATE *pNextItem;
	BOOL bDialogEx = IsDialogEx(pOrigTemplate);

	int iItem, iItems = DlgTemplateItemCount(pOrigTemplate);
	pDlgInfo->m_pItemInfo = new _AFX_OCC_DIALOG_INFO::ItemInfo[iItems];
	memset(pDlgInfo->m_pItemInfo, 0,
		sizeof(_AFX_OCC_DIALOG_INFO::ItemInfo) * iItems);
	pDlgInfo->m_cItems = iItems;
	LPCWSTR pszClass;
	DWORD dwStyle;

	for(iItem = 0; iItem < iItems; iItem++)
	{
		pNextItem = _AfxFindNextDlgItem(pItem, bDialogEx);
		if(bDialogEx)
		{
			DLGITEMTEMPLATEEX *pItemEx = (DLGITEMTEMPLATEEX *) pItem;
			pDlgInfo->m_pItemInfo[iItem].nId = pItemEx->id;
			pszClass = (LPCWSTR) (pItemEx + 1);
			dwStyle = pItemEx->style;
		}
		else
		{
			pDlgInfo->m_pItemInfo[iItem].nId = pItem->id;
			pszClass = (LPCWSTR) (pItem + 1);
			dwStyle = pItem->style;
		}

		// this is a good place to store for later use gobs 'o info
		// about the controls on the dialog.
		pDlgInfo->m_pItemInfo[iItem].bAutoRadioButton =
			pszClass[0] == 0xffff && pszClass[1] == 0x0080 &&
			(dwStyle & 0x0f) == BS_AUTORADIOBUTTON;

		pItem = pNextItem;
	}

	return (pNewTemplate != NULL) ? pNewTemplate : pOrigTemplate;
}

void COccManager::PostCreateDialog(_AFX_OCC_DIALOG_INFO* pDlgInfo)
{
	if (pDlgInfo->m_pNewTemplate != NULL)
		GlobalFree(pDlgInfo->m_pNewTemplate);

	if (pDlgInfo->m_ppOleDlgItems != NULL)
		free(pDlgInfo->m_ppOleDlgItems);

	delete[] pDlgInfo->m_pItemInfo;
}

DLGTEMPLATE* COccManager::SplitDialogTemplate(const DLGTEMPLATE* pTemplate,
	DLGITEMTEMPLATE** ppOleDlgItems)
{
	DLGITEMTEMPLATE* pFirstItem = _AfxFindFirstDlgItem(pTemplate);
	ULONG cbHeader = ULONG((BYTE*)pFirstItem - (BYTE*)pTemplate);
	ULONG cbNewTemplate = cbHeader;

	BOOL bDialogEx = IsDialogEx(pTemplate);

	int iItem;
	int nItems = (int)DlgTemplateItemCount(pTemplate);
	DLGITEMTEMPLATE* pItem = pFirstItem;
	DLGITEMTEMPLATE* pNextItem = pItem;
	LPWSTR pszClassName;
	BOOL bHasOleControls = FALSE;

	// Make first pass through the dialog template.  On this pass, we're
	// interested in determining:
	//    1. Does this template contain any OLE controls?
	//    2. If so, how large a buffer is needed for a template containing
	//       only the non-OLE controls?

	for (iItem = 0; iItem < nItems; iItem++)
	{
		pNextItem = _AfxFindNextDlgItem(pItem, bDialogEx);

		pszClassName = bDialogEx ?
			(LPWSTR)(((DLGITEMTEMPLATEEX*)pItem) + 1) :
			(LPWSTR)(pItem + 1);

		if (pszClassName[0] == L'{')
		{
			// Item is an OLE control.
			bHasOleControls = TRUE;
		}
		else
		{
			// Item is not an OLE control: make room for it in new template.
			cbNewTemplate += ULONG((BYTE*)pNextItem - (BYTE*)pItem);
		}

		pItem = pNextItem;
	}

	// No OLE controls were found, so there's no reason to go any further.
	if (!bHasOleControls)
	{
		ppOleDlgItems[0] = (DLGITEMTEMPLATE*)(-1);
		return NULL;
	}

	// Copy entire header into new template.
	BYTE* pNew = (BYTE*)GlobalAlloc(GMEM_FIXED, cbNewTemplate);
	ENSURE_THROW(pNew!=NULL	, ::AfxThrowMemoryException() );
	DLGTEMPLATE* pNewTemplate = (DLGTEMPLATE*)pNew;
	Checked::memcpy_s(pNew, cbNewTemplate, pTemplate, cbHeader);
	pNew += cbHeader;

	// Initialize item count in new header to zero.
	DlgTemplateItemCount(pNewTemplate) = 0;

	pItem = pFirstItem;
	pNextItem = pItem;

	// Second pass through the dialog template.  On this pass, we want to:
	//    1. Copy all the non-OLE controls into the new template.
	//    2. Build an array of item templates for the OLE controls.

	for (iItem = 0; iItem < nItems; iItem++)
	{
		pNextItem = _AfxFindNextDlgItem(pItem, bDialogEx);

		pszClassName = bDialogEx ?
			(LPWSTR)(((DLGITEMTEMPLATEEX*)pItem) + 1) :
			(LPWSTR)(pItem + 1);

		if (pszClassName[0] == L'{')
		{
			// Item is OLE control: add it to the array.
			ppOleDlgItems[iItem] = pItem;
		}
		else
		{
			// Item is not an OLE control: copy it to the new template.
			ULONG cbItem = ULONG((BYTE*)pNextItem - (BYTE*)pItem);
			ASSERT(cbItem >= (size_t)(bDialogEx ?
				sizeof(DLGITEMTEMPLATEEX) :
				sizeof(DLGITEMTEMPLATE)));

			Checked::memcpy_s(pNew, cbItem, pItem, cbItem);
			pNew += cbItem;

			// Incrememt item count in new header.
			++DlgTemplateItemCount(pNewTemplate);

			// Put placeholder in OLE item array.
			ppOleDlgItems[iItem] = NULL;
		}

		pItem = pNextItem;
	}
	ppOleDlgItems[nItems] = (DLGITEMTEMPLATE*)(-1);

	return pNewTemplate;
}

BOOL COccManager::CreateDlgControls(CWnd* pWndParent, LPCTSTR lpszResourceName,
	_AFX_OCC_DIALOG_INFO* pOccDlgInfo)
{
	// find resource handle
	void* lpResource = NULL;
	HGLOBAL hResource = NULL;
	if (lpszResourceName != NULL)
	{
		HINSTANCE hInst = AfxFindResourceHandle(lpszResourceName, RT_DLGINIT);
		HRSRC hDlgInit = ::FindResource(hInst, lpszResourceName, RT_DLGINIT);
		if (hDlgInit != NULL)
		{
			// load it
			hResource = LoadResource(hInst, hDlgInit);
			if (hResource == NULL)
			{
				TRACE(traceOle, 0, "DLGINIT resource was found, but could not be loaded.\n");
				return FALSE;
			}

			// lock it
			lpResource = LockResource(hResource);
			ASSERT(lpResource != NULL);
		}
#ifdef _DEBUG
		else
		{
			// If we didn't find a DLGINIT resource, check whether we were
			// expecting to find one
			DLGITEMTEMPLATE** ppOleDlgItems = pOccDlgInfo->m_ppOleDlgItems;
			ASSERT(ppOleDlgItems != NULL);

			while (*ppOleDlgItems != (DLGITEMTEMPLATE*)-1)
			{
				if (*ppOleDlgItems != NULL)
				{
					TRACE(traceOle, 0, "Dialog has OLE controls, but no matching DLGINIT resource.\n");
					break;
				}
				++ppOleDlgItems;
			}
		}
#endif
	}

	// execute it
	BOOL bResult = TRUE;
	if (lpResource != NULL)
		bResult = CreateDlgControls(pWndParent, lpResource, pOccDlgInfo);

	// cleanup
	if (lpResource != NULL && hResource != NULL)
	{
		UnlockResource(hResource);
		FreeResource(hResource);
	}

	if(pWndParent->m_pCtrlCont)
	{
		pWndParent->m_pCtrlCont->FillListSitesOrWnds(pOccDlgInfo);
	}

	return bResult;
}

BOOL COccManager::CreateDlgControls(CWnd* pWndParent, void* lpResource,
	_AFX_OCC_DIALOG_INFO* pOccDlgInfo)
{
	// if there are no OLE controls in this dialog, then there's nothing to do
	if (pOccDlgInfo->m_pNewTemplate == NULL)
		return TRUE;

	ASSERT(pWndParent != NULL);
	HWND hwParent = pWndParent->GetSafeHwnd();

	BOOL bDialogEx = IsDialogEx(pOccDlgInfo->m_pNewTemplate);
	BOOL bSuccess = TRUE;
	if (lpResource != NULL)
	{
		ASSERT(pOccDlgInfo != NULL);
		ASSERT(pOccDlgInfo->m_ppOleDlgItems != NULL);

		DLGITEMTEMPLATE** ppOleDlgItems = pOccDlgInfo->m_ppOleDlgItems;

		UNALIGNED WORD* lpnRes = (WORD*)lpResource;
		int iItem = 0;
		HWND hwAfter = HWND_TOP;
		while (bSuccess && *lpnRes != 0)
		{
			WORD nIDC = *lpnRes++;
			WORD nMsg = *lpnRes++;
			DWORD dwLen = *((UNALIGNED DWORD*&)lpnRes)++;

			#define WIN16_LB_ADDSTRING  0x0401
			#define WIN16_CB_ADDSTRING  0x0403

			ASSERT(nMsg == LB_ADDSTRING || nMsg == CB_ADDSTRING ||
				nMsg == WIN16_LB_ADDSTRING || nMsg == WIN16_CB_ADDSTRING ||
				nMsg == WM_MFC_INITCTRL ||
				nMsg == WM_OCC_LOADFROMSTREAM ||
				nMsg == WM_OCC_LOADFROMSTREAM_EX ||
				nMsg == WM_OCC_LOADFROMSTORAGE ||
				nMsg == WM_OCC_LOADFROMSTORAGE_EX ||
				nMsg == WM_OCC_INITNEW);

			if (nMsg == WM_OCC_LOADFROMSTREAM ||
				nMsg == WM_OCC_LOADFROMSTREAM_EX ||
				nMsg == WM_OCC_LOADFROMSTORAGE ||
				nMsg == WM_OCC_LOADFROMSTORAGE_EX ||
				nMsg == WM_OCC_INITNEW)
			{
				// Locate the DLGITEMTEMPLATE for the new control, and the control
				// that should precede it in z-order.
				DLGITEMTEMPLATE* pDlgItem;
				while (((pDlgItem = ppOleDlgItems[iItem++]) == NULL) &&
					(pDlgItem != (DLGITEMTEMPLATE*)(-1)))
				{
					if (hwAfter == HWND_TOP)
						hwAfter = GetWindow(hwParent, GW_CHILD);
					else
						hwAfter = GetWindow(hwAfter, GW_HWNDNEXT);

					ASSERT(hwAfter != NULL);  // enough non-OLE controls?
				}

				ASSERT(pDlgItem != NULL);   // enough dialog item templates?

				HWND hwNew = NULL;
			BOOL bCreated = FALSE;
				if (pDlgItem != (DLGITEMTEMPLATE*)(-1))
				{
#ifdef _DEBUG
					WORD id = bDialogEx ?
						(WORD)((DLGITEMTEMPLATEEX*)pDlgItem)->id :
						pDlgItem->id;
					ASSERT(id == nIDC); // make sure control IDs match!
#endif

					// Create the OLE control now.
					bCreated = CreateDlgControl(pWndParent, hwAfter, bDialogEx,
						pDlgItem, nMsg, (BYTE*)lpnRes, dwLen, &hwNew);
				}

			if (bCreated)
			{
				   if (hwNew != NULL)
				   {
					   if (bDialogEx)
						   SetWindowContextHelpId(hwNew,
							   ((DLGITEMTEMPLATEEX*)pDlgItem)->helpID);
					   if (GetParent(hwNew) == hwParent)
						   hwAfter = hwNew;
				   }
			}
				else
					bSuccess = FALSE;
			}

			// skip past data
			lpnRes = (WORD*)((LPBYTE)lpnRes + (UINT)dwLen);
		}
	}

	if (bSuccess)
	{
		// unfreeze events now that all controls are loaded
		if (pWndParent->m_pCtrlCont != NULL)
			pWndParent->m_pCtrlCont->FreezeAllEvents(FALSE);

		BindControls(pWndParent);
	}

	return bSuccess;
}


void COccManager::BindControls(CWnd* pWndParent)
{
	COleControlSiteOrWnd* pSiteOrWnd;

	if (pWndParent->m_pCtrlCont != NULL)
	{
		// Now initialize bound controls
		POSITION pos = pWndParent->m_pCtrlCont->m_listSitesOrWnds.GetHeadPosition();
		while (pos != NULL)
		{
			pSiteOrWnd = pWndParent->m_pCtrlCont->m_listSitesOrWnds.GetNext( pos );
			ASSERT(pSiteOrWnd);

			if(pSiteOrWnd->m_pSite)
			{
				// For each cursor bound property initialize pClientSite ptr and bind to DSC
				CDataBoundProperty* pBinding = pSiteOrWnd->m_pSite->m_pBindings;
				while(pBinding)
				{
					pBinding->SetClientSite(pSiteOrWnd->m_pSite);
					if (pBinding->m_ctlid != 0)
					{
						CWnd* pWnd = pWndParent->GetDlgItem(pBinding->m_ctlid);
						ASSERT(pWnd);
						ASSERT(pWnd->m_pCtrlSite);
						pBinding->SetDSCSite(pWnd->m_pCtrlSite);
					}
					pBinding = pBinding->GetNext();
				}

				// Bind default bound property
				if (pSiteOrWnd->m_pSite->m_ctlidRowSource != NULL)
				{
					CWnd* pWnd = pWndParent->GetDlgItem(pSiteOrWnd->m_pSite->m_ctlidRowSource);
					ASSERT(pWnd);  // gotta be a legitimate control id
					ASSERT(pWnd->m_pCtrlSite);  // and it has to be an OLE Control

					pWnd->m_pCtrlSite->EnableDSC();

					ASSERT(pWnd->m_pCtrlSite->m_pDataSourceControl);  // and a Data Source Control
					pSiteOrWnd->m_pSite->m_pDSCSite = pWnd->m_pCtrlSite;
					pWnd->m_pCtrlSite->m_pDataSourceControl->BindProp(pSiteOrWnd->m_pSite);
				}
			}
		}

		// Finally, set up bindings on all DataSource controls
		pos = pWndParent->m_pCtrlCont->m_listSitesOrWnds.GetHeadPosition();
		while (pos != NULL)
		{
			pSiteOrWnd = pWndParent->m_pCtrlCont->m_listSitesOrWnds.GetNext( pos );
			ASSERT(pSiteOrWnd);
			if (pSiteOrWnd->m_pSite && pSiteOrWnd->m_pSite->m_pDataSourceControl)
				pSiteOrWnd->m_pSite->m_pDataSourceControl->BindColumns();
		}
	}
}


BOOL COccManager::CreateDlgControl(CWnd* pWndParent, HWND hwAfter,
	BOOL bDialogEx, LPDLGITEMTEMPLATE pItem, WORD nMsg, BYTE* lpData, DWORD cb, HWND* phWnd)
{
	LPWSTR pszClass = (LPWSTR)(pItem + 1);
	DLGITEMTEMPLATE dlgItemTmp;

	if (bDialogEx)
	{
		// We have an extended dialog template: copy relevant parts into an
		// ordinary dialog template, because their layouts are different
		DLGITEMTEMPLATEEX* pItemEx = (DLGITEMTEMPLATEEX*)pItem;
		dlgItemTmp.style = pItemEx->style;
		dlgItemTmp.dwExtendedStyle = pItemEx->exStyle;
		dlgItemTmp.x = pItemEx->x;
		dlgItemTmp.y = pItemEx->y;
		dlgItemTmp.cx = pItemEx->cx;
		dlgItemTmp.cy = pItemEx->cy;
		dlgItemTmp.id = (WORD)pItemEx->id;
		pItem = &dlgItemTmp;
		pszClass = (LPWSTR)(pItemEx + 1);
	}

	CRect rect(pItem->x, pItem->y, pItem->x + pItem->cx, pItem->y + pItem->cy);
	::MapDialogRect(pWndParent->m_hWnd, &rect);

	BSTR bstrLicKey = NULL;

	// extract license key data, if any
	if (cb >= sizeof(ULONG))
	{
		ULONG cchLicKey = *(UNALIGNED ULONG*)lpData;
		lpData += sizeof(ULONG);
		cb -= sizeof(ULONG);
		if (cchLicKey > 0)
		{
			bstrLicKey = SysAllocStringLen((LPCOLESTR)lpData, cchLicKey);
			lpData += cchLicKey * sizeof(WCHAR);
			cb -= cchLicKey * sizeof(WCHAR);
		}
	}

	// If WM_OCC_INITNEW, we should have exhausted all of the data by now.
	ASSERT((nMsg != WM_OCC_INITNEW) || (cb == 0));

	CDataBoundProperty* pBindings = NULL;
	CString strDataField;
	WORD ctlidRowSource = 0;
	DISPID defdispid = 0;
	UINT dwType = 0;

	if (nMsg == WM_OCC_LOADFROMSTREAM_EX ||
		nMsg == WM_OCC_LOADFROMSTORAGE_EX)
	{
		// Read the size of the section
		ULONG cbOffset = *(UNALIGNED ULONG*)lpData;
		ULONG cbBindInfo = cbOffset - sizeof(DWORD);
		lpData += sizeof(DWORD);

		ULONG dwFlags = *(UNALIGNED ULONG*)lpData;
		cbBindInfo -= sizeof(DWORD);
		lpData += sizeof(DWORD);
		ASSERT(dwFlags == 1);

		// ULONG cbBinding = *(UNALIGNED ULONG*)lpData;
		cbBindInfo -= sizeof(DWORD);
		lpData += sizeof(DWORD);

		while (cbBindInfo > 0)
		{
			DISPID dispid;
			WORD ctlid;

			dispid = *(UNALIGNED DISPID *)lpData;
			lpData += sizeof(DISPID);
			cbBindInfo -= sizeof(DISPID);
			ctlid =  *(UNALIGNED WORD *)lpData;
			lpData += sizeof(WORD);
			cbBindInfo -= sizeof(WORD);

			if(dispid == DISPID_DATASOURCE)
			{
				defdispid = *(UNALIGNED ULONG*)lpData;
				cbBindInfo -= sizeof(DISPID);
				lpData += sizeof(DISPID);
				dwType = *(UNALIGNED ULONG*)lpData;
				cbBindInfo -= sizeof(DWORD);
				lpData += sizeof(DWORD);

				ASSERT(*(UNALIGNED DISPID *)lpData == DISPID_DATAFIELD);
				lpData += sizeof(DISPID);
				cbBindInfo -= sizeof(DISPID);
				// Skip the string length
				lpData += sizeof(DWORD);
				cbBindInfo -= sizeof(DWORD);
				strDataField = (char *)lpData;
				lpData += strDataField.GetLength()+1;
				cbBindInfo -= ULONG(strDataField.GetLength()+1);
				ctlidRowSource = ctlid;
			} else
				pBindings = new CDataBoundProperty(pBindings, dispid, ctlid);
		}
		cb -= cbOffset;

		// From now on act as a regular type
		nMsg -= (WM_OCC_LOADFROMSTREAM_EX - WM_OCC_LOADFROMSTREAM);
	}

	GUID clsid;
	HRESULT hr;
	if (pszClass[0] == L'{')
		hr = CLSIDFromString(pszClass, &clsid);
	else
		hr = CLSIDFromProgID(pszClass, &clsid);

#ifdef _DEBUG
	if (FAILED(hr))
	{
		TRACE(traceOle, 0, "Unable to convert \"%ls\" to a class ID.\n", pszClass);
		TRACE(traceOle, 0, ">>> Result code: 0x%08lx\n", hr);
		if (pszClass[0] != L'{')
			TRACE(traceOle, 0, ">>> Is the control properly registered?\n");
	}
#endif

	CMemFile memFile(lpData, cb);
	CMemFile* pMemFile = (nMsg == WM_OCC_INITNEW) ? NULL : &memFile;

	COleControlSite* pSite = NULL;

	if (SUCCEEDED(hr) &&
		pWndParent->InitControlContainer(/*bCreateFromResource=*/TRUE) &&
		pWndParent->m_pCtrlCont->CreateControl(NULL, clsid, NULL, pItem->style,
			rect, pItem->id, pMemFile, (nMsg == WM_OCC_LOADFROMSTORAGE),
			bstrLicKey, &pSite))
	{
		ASSERT(pSite != NULL);

		// freeze events until all controls are loaded
		pSite->FreezeEvents(TRUE);

		// set ZOrder only!
		SetWindowPos(pSite->m_hWnd, hwAfter, 0, 0, 0, 0,
			SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

		pSite->m_pBindings = pBindings;
		pSite->m_strDataField = strDataField;
		pSite->m_ctlidRowSource = ctlidRowSource;
		pSite->m_defdispid = defdispid;
		pSite->m_dwType = dwType;
	}

	if (bstrLicKey != NULL)
		SysFreeString(bstrLicKey);

   if (pSite != NULL)
   {
	  *phWnd = pSite->m_hWnd;
	  return TRUE;
   }
   else
   {
	  *phWnd = NULL;
	  return FALSE;
   }
}

/////////////////////////////////////////////////////////////////////////////
// CDataExchange::PrepareOleCtrl

COleControlSite* CDataExchange::PrepareOleCtrl(int nIDC)
{
	ASSERT(nIDC != 0);
	ASSERT(nIDC != -1); // not allowed
   COleControlSite* pSite;
   pSite = m_pDlgWnd->GetOleControlSite(nIDC);
	if (pSite == NULL)
	{
		TRACE(traceOle, 0, "Error: no data exchange control with ID 0x%04X\n", nIDC);
		ASSERT(FALSE);
		AfxThrowNotSupportedException();
	}
	m_idLastControl = nIDC;
	m_bEditLastControl = FALSE; // not an edit item by default
   return pSite;
}

/////////////////////////////////////////////////////////////////////
// COleControlSiteFactory - new COleControlSite for ActiveX controls.
// This is the default factory if none are registered or rejected the 
//site instantiation request.
class COleControlSiteFactory : public IControlSiteFactory
{
public:
	COleControlSiteFactory() { }
	COleControlSite* CreateSite(COleControlContainer* pCtrlCont,const CControlCreationInfo&)
	{
		return new COleControlSite(pCtrlCont);
	}	
};

CControlSiteFactoryMgr::CControlSiteFactoryMgr()
{
	//The last item in the list is the default factory
	m_pOleControlSiteDefaultFactory = new COleControlSiteFactory();
	try
	{
		RegisterSiteFactory(m_pOleControlSiteDefaultFactory);
	}
	catch(...)
	{
		delete m_pOleControlSiteDefaultFactory;
		m_pOleControlSiteDefaultFactory=NULL;
	}
}


CControlSiteFactoryMgr::~CControlSiteFactoryMgr()
{
	delete m_pOleControlSiteDefaultFactory;
	m_lstFactory.RemoveAll();
}

//Search for factory interested in creating the site.

COleControlSite* CControlSiteFactoryMgr::CreateSite(COleControlContainer* pCtrlCont,const CControlCreationInfo& creationInfo)
{
	COleControlSite* pSite=NULL;
	POSITION pos = m_lstFactory.GetHeadPosition();
	while( pos != NULL )
	{		
		IControlSiteFactory* pFactory = m_lstFactory.GetNext( pos );	
		if(pFactory!=NULL)
		{
			pSite=pFactory->CreateSite(pCtrlCont,creationInfo);
			if (pSite!=NULL)
			{
				break;
			}
		}
	}	
	return pSite;
}

//Add if not exists
BOOL CControlSiteFactoryMgr::RegisterSiteFactory(IControlSiteFactory* pFactory)
{
	ENSURE_ARG(pFactory!=NULL);
	POSITION position=NULL;
	position=m_lstFactory.Find(pFactory);
	BOOL bAdded=FALSE;
	if (position==NULL)
	{
		m_lstFactory.AddHead(pFactory);
	}
	return bAdded;
}
//Remove if exists.
BOOL CControlSiteFactoryMgr::UnregisterSiteFactory(IControlSiteFactory* pFactory)
{
	ENSURE_ARG(pFactory!=NULL);
	POSITION position=NULL;
	position=m_lstFactory.Find(pFactory);
	BOOL bRemoved=FALSE;
	if (position!=NULL)
	{
		m_lstFactory.RemoveAt(position);
		bRemoved=TRUE;
	}
	return bRemoved;
}


BOOL AFXAPI AfxRegisterSiteFactory(IControlSiteFactory* pFactory)
{
	return _afxControlFactoryMgr->RegisterSiteFactory(pFactory);
}

BOOL AFXAPI AfxUnregisterSiteFactory(IControlSiteFactory* pFactory)
{
	return _afxControlFactoryMgr->UnregisterSiteFactory(pFactory);
}



#endif //!_AFX_NO_OCC_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\occlock.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "occimpl.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////

COleControlLock::COleControlLock(REFCLSID clsid)
{
	// initialize the object
	m_pNextLock = NULL;
	m_clsid = clsid;
	m_pClassFactory = NULL;

	// initialize OLE, if necessary
	_AFX_THREAD_STATE* pState = AfxGetThreadState();
	if (!pState->m_bNeedTerm && !AfxOleInit())
		return;

	// attempt to lock the class factory of the control
	if (SUCCEEDED(::CoGetClassObject(clsid,
		CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER, NULL, IID_IClassFactory,
		(void**)&m_pClassFactory)))
	{
		ASSERT(m_pClassFactory != NULL);
		if (FAILED(m_pClassFactory->LockServer(TRUE)))
		{
			m_pClassFactory->Release();
			m_pClassFactory = NULL;
		}
	}
}

COleControlLock::~COleControlLock()
{
	if (m_pClassFactory != NULL)
	{
		m_pClassFactory->LockServer(FALSE);
		m_pClassFactory->Release();
		m_pClassFactory = NULL;
	}
}

BOOL AFXAPI AfxOleLockControl(REFCLSID clsid)
{
	COleControlLock* pLock = NULL;

	TRY
	{
		pLock = new COleControlLock(clsid);
		if (pLock->m_pClassFactory == NULL)
		{
			delete pLock;
			pLock = NULL;
		}
		else
		{
			AFX_MODULE_STATE* pModuleState = AfxGetModuleState();
			AfxLockGlobals(CRIT_CTLLOCKLIST);
			pModuleState->m_lockList.AddHead(pLock);
			AfxUnlockGlobals(CRIT_CTLLOCKLIST);
		}
	}
	CATCH_ALL (e)
	{
		// Note: DELETE_EXCEPTION(e) not necessary
		pLock = NULL;
	}
	END_CATCH_ALL

	return pLock != NULL;
}

BOOL AFXAPI AfxOleLockControl(LPCTSTR lpszProgID)
{
	// map prog id to CLSID
	CLSID clsid;
	HRESULT hr = AfxGetClassIDFromString(lpszProgID, &clsid);
	if (FAILED(hr))
		return FALSE;

	return AfxOleLockControl(clsid);
}

BOOL AFXAPI AfxOleUnlockControl(LPCTSTR lpszProgID)
{
	// map prog id to CLSID
	CLSID clsid;
	HRESULT hr = AfxGetClassIDFromString(lpszProgID, &clsid);
	if (FAILED(hr))
		return FALSE;

	return AfxOleUnlockControl(clsid);
}

BOOL AFXAPI AfxOleUnlockControl(REFCLSID clsid)
{
	AFX_MODULE_STATE* pModuleState = AfxGetModuleState();
	AfxLockGlobals(CRIT_CTLLOCKLIST);
	COleControlLock* pLock = pModuleState->m_lockList;
	BOOL bResult = FALSE;
	while (pLock != NULL)
	{
		COleControlLock* pNext = pLock->m_pNextLock;
		if (clsid == pLock->m_clsid)
		{
			// remove lock from list and delete it
			pModuleState->m_lockList.Remove(pLock);
			delete pLock;
			bResult = TRUE;
		}
		pLock = pNext;
	}
	AfxUnlockGlobals(CRIT_CTLLOCKLIST);
	return bResult;
}

void AFXAPI AfxOleUnlockAllControls()
{
	AFX_MODULE_STATE* pModuleState = AfxGetModuleState();
	COleControlLock* pLock;
	AfxLockGlobals(CRIT_CTLLOCKLIST);
	while ((pLock = pModuleState->m_lockList) != NULL)
	{
		pModuleState->m_lockList.Remove(pLock);
		delete pLock;
	}
	ASSERT(pModuleState->m_lockList.IsEmpty());
	AfxUnlockGlobals(CRIT_CTLLOCKLIST);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\olebar.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// COleResizeBar

COleResizeBar::COleResizeBar()
{
	// setup the state flags to do resize handles outside with hatched border
	m_tracker.m_nStyle =
		CRectTracker::hatchedBorder|CRectTracker::resizeOutside|
		CRectTracker::solidLine;

	// the actual rectangle is updated in COleResizeBar::OnSize
}

COleResizeBar::~COleResizeBar()
{
}

BOOL COleResizeBar::Create(CWnd* pParentWnd, DWORD dwStyle, UINT nID)
{
	ASSERT_VALID(this);

	if (pParentWnd != NULL)
		ASSERT_VALID(pParentWnd);   // must have a parent

	// force WS_CLIPSIBLINGS (avoids SetWindowPos bugs)
	dwStyle |= WS_CLIPSIBLINGS;

	VERIFY(AfxDeferRegisterClass(AFX_WNDCONTROLBAR_REG));

	// create the HWND
	CRect rect;
	rect.SetRectEmpty();
	// Note: Parent must resize itself for control bar to be resized
	return CWnd::Create(AFX_WNDCONTROLBAR, NULL, dwStyle, rect, pParentWnd, nID);
}

/////////////////////////////////////////////////////////////////////////////
// COleResizeBar message handling

BEGIN_MESSAGE_MAP(COleResizeBar, CControlBar)
	//{{AFX_MSG_MAP(COleResizeBar)
	ON_WM_ERASEBKGND()
	ON_WM_PAINT()
	ON_WM_SIZE()
	ON_WM_SETCURSOR()
	ON_WM_LBUTTONDOWN()
	ON_MESSAGE(WM_SIZEPARENT, &COleResizeBar::OnSizeParent)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL COleResizeBar::OnEraseBkgnd(CDC*)
{
	return TRUE;    // no erasing necessary
}

void COleResizeBar::OnPaint()
{
	CPaintDC dc(this);

	// always use the same brush origin
	CRect rect;
	GetWindowRect(&rect);
	dc.SetBrushOrg(rect.left & 7, rect.top & 7);

	// draw it
	m_tracker.Draw(&dc);
}

void COleResizeBar::OnSize(UINT /*nType*/, int /*cx*/, int /*cy*/)
{
	GetClientRect(&m_tracker.m_rect);
	int nHandleSize = m_tracker.m_nHandleSize;
	m_tracker.m_rect.InflateRect(-nHandleSize, -nHandleSize);
}

BOOL COleResizeBar::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message)
{
	// hit-test the tracker -- we only care about hits on handles
	CPoint point;
	::GetCursorPos(&point);
	ScreenToClient(&point);
	int hit = m_tracker.HitTest(point);
	if (hit < 0)
		return CControlBar::OnSetCursor(pWnd, nHitTest, message);

	// let the tracker handle setting the cursor
	return m_tracker.SetCursor(pWnd, nHitTest);
}

void COleResizeBar::OnLButtonDown(UINT /*nFlags*/, CPoint point)
{
	// track to parent of the parent
	CWnd* pFrameWnd = EnsureParentFrame();
	CWnd* pParent = pFrameWnd->GetParent();

	pFrameWnd->UpdateWindow();  // update ourselves

	// limit tracking to parent client rectangle
	if (pParent != NULL)
	{
		pParent->UpdateWindow();    // always update before tracking

		// clip cursor to parent window
		CRect rect;
		pParent->GetClientRect(&rect);
		pParent->ClientToScreen(&rect);
		::ClipCursor(&rect);
	}

	// save the rect, track, then restore
	CRect rectSave = m_tracker.m_rect;
	BOOL bNotify = m_tracker.Track(this, point, FALSE, pParent);
	CRect rectNew = m_tracker.m_rect;
	m_tracker.m_rect = rectSave;

	// allow full mouse movement again
	::ClipCursor(NULL);

	// notify owner window if tracker changed
	if (bNotify)
	{
		CWnd* pOwner = GetOwner();
		ASSERT_VALID(pOwner);

		// convert relative to parent coordinates
		ClientToScreen(&rectNew);
		pOwner->ScreenToClient(&rectNew);

		// send notification to owner
		pOwner->SendMessage(WM_SIZECHILD, (WPARAM)_AfxGetDlgCtrlID(m_hWnd),
			(LPARAM)(LPCRECT)&rectNew);
	}
}

LRESULT COleResizeBar::OnSizeParent(WPARAM, LPARAM lParam)
{
	AFX_SIZEPARENTPARAMS* lpLayout = (AFX_SIZEPARENTPARAMS*)lParam;

	// only resize the window if doing layout and not just rect query
	if (lpLayout->hDWP != NULL)
		AfxRepositionWindow(lpLayout, m_hWnd, &lpLayout->rect);

	// always adjust the rectangle after the resize
	int nHandleSize = m_tracker.m_nHandleSize;
	::InflateRect(&lpLayout->rect, -nHandleSize, -nHandleSize);

	return 0;
}

void COleResizeBar::OnUpdateCmdUI(CFrameWnd* /*pTarget*/,
	BOOL /*bDisableIfNoHndler*/)
{
	// just do nothing
}


IMPLEMENT_DYNAMIC(COleResizeBar, CControlBar)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\oleasmon.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

#pragma inline_depth(0)

/////////////////////////////////////////////////////////////////////////////
// _AfxBindStatusCallback for CAsyncMonikerFile implementation

class _AfxBindStatusCallback: public IBindStatusCallback
{
private:
	class CInnerUnknown : public IUnknown
	{
	protected:
		_AfxBindStatusCallback* m_pThis;
		friend class _AfxBindStatusCallback;

	public:
		inline CInnerUnknown() { }
		inline void SetpThis(_AfxBindStatusCallback* pThis) { ASSERT(pThis != NULL); m_pThis = pThis; }

		STDMETHOD_(ULONG, AddRef)()
		{
			return InterlockedIncrement((long*)&m_pThis->m_dwRef);
		}

		STDMETHOD_(ULONG, Release)()
		{
			unsigned long lResult = InterlockedDecrement((long*)&m_pThis->m_dwRef);
			if (lResult == 0)
				delete m_pThis;
			return lResult;
		}

		STDMETHOD(QueryInterface)(REFIID iid, void** ppvObject)
		{
			if (!ppvObject)
				return E_POINTER;

			// check for the interfaces this object knows about
			if (iid == IID_IUnknown)
			{
				*ppvObject = (IUnknown*)this;
				AddRef();
				return S_OK;
			}
			if (iid == IID_IBindStatusCallback)
			{
				*ppvObject = (IBindStatusCallback*)m_pThis;
				m_pThis->AddRef();
				return S_OK;
			}

			// otherwise, incorrect IID, and thus error
			return E_NOINTERFACE;
		}
	};

public:
	inline _AfxBindStatusCallback(CAsyncMonikerFile* pOwner, IUnknown* pUnkControlling)
		: m_pOwner(pOwner), m_dwRef(0)
	{
		m_UnkInner.SetpThis(this);
		ASSERT(pOwner);
		m_pModuleState = AfxGetModuleState();
		ASSERT(m_pModuleState != NULL);
		m_pUnkControlling = pUnkControlling ? pUnkControlling : (IUnknown*)&m_UnkInner;

		AfxOleLockApp();
	}

	inline ~_AfxBindStatusCallback()
	{
		AFX_MANAGE_STATE(m_pModuleState);
		AfxOleUnlockApp();
	}

	inline void Orphan() { m_pOwner = NULL; }

	STDMETHOD_(ULONG, AddRef)()
		{ return m_pUnkControlling->AddRef(); }
	STDMETHOD_(ULONG, Release)()
		{ return m_pUnkControlling->Release(); }
	STDMETHOD(QueryInterface)(REFIID iid, void** ppvObject)
		{ return m_pUnkControlling->QueryInterface(iid, ppvObject); }


	const CAsyncMonikerFile* GetOwner() const{ return m_pOwner; }
	DWORD GetRefcount() const { return m_dwRef; }
	const IUnknown* GetControllingUnknown() const { return m_pUnkControlling; }
	IUnknown* GetControllingUnknown() { return m_pUnkControlling; }
	const IUnknown* GetInnerUnknown() const { return &m_UnkInner; }
	IUnknown* GetInnerUnknown() { return &m_UnkInner; }
	const _AfxBindStatusCallback* GetpThisOfInnerUnknown() const { return m_UnkInner.m_pThis; }
	const AFX_MODULE_STATE* GetModuleState() const { return m_pModuleState; }
protected:
	friend class CInnerUnknown;
	DWORD m_dwRef;
private:
	IUnknown* m_pUnkControlling;
	CInnerUnknown m_UnkInner;
	CAsyncMonikerFile* m_pOwner;
	AFX_MODULE_STATE* m_pModuleState;

	STDMETHOD(GetBindInfo)(
		DWORD __RPC_FAR *pgrfBINDF, BINDINFO __RPC_FAR *pbindinfo)
	{
		ASSERT(m_pOwner);
		if (!pgrfBINDF || !pbindinfo)
			return E_POINTER;
		if (pbindinfo->cbSize<sizeof(BINDINFO))
			return E_INVALIDARG;
		if (!m_pOwner)
			return E_FAIL;

		AFX_MANAGE_STATE(m_pModuleState);
		pbindinfo->szExtraInfo = NULL;
		TRY
		{
			*pgrfBINDF = m_pOwner->GetBindInfo();
		}
		CATCH_ALL(e)
		{
			HRESULT hr = ResultFromScode(COleException::Process(e));
			DELETE_EXCEPTION(e);
			return hr;
		}
		END_CATCH_ALL
		return S_OK;
	}

	STDMETHOD(OnStartBinding)(
		DWORD dwReserved, IBinding __RPC_FAR *pBinding)
	{
		ASSERT(m_pOwner);
		UNUSED_ALWAYS(dwReserved);
		if (!pBinding)
			return E_POINTER;
		if (!m_pOwner)
			return E_FAIL;

		AFX_MANAGE_STATE(m_pModuleState);
		TRY
		{
			m_pOwner->SetBinding(pBinding);
			m_pOwner->OnStartBinding();
		}
		CATCH_ALL(e)
		{
			HRESULT hr = ResultFromScode(COleException::Process(e));
			DELETE_EXCEPTION(e);
			return hr;
		}
		END_CATCH_ALL
		return S_OK;
	}

	STDMETHOD(GetPriority)(LONG __RPC_FAR *pnPriority)
	{
		ASSERT(m_pOwner);
		if (!pnPriority)
			return E_POINTER;
		if (!m_pOwner)
			return E_FAIL;
		AFX_MANAGE_STATE(m_pModuleState);
		TRY
		{
			*pnPriority = m_pOwner->GetPriority();
		}
		CATCH_ALL(e)
		{
			HRESULT hr = ResultFromScode(COleException::Process(e));
			DELETE_EXCEPTION(e);
			return hr;
		}
		END_CATCH_ALL
		return S_OK;
	}

	STDMETHOD(OnProgress)(
		ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode,
		LPCOLESTR szStatusText)
	{
		ASSERT(m_pOwner);
		if (!m_pOwner)
			return E_FAIL;
		AFX_MANAGE_STATE(m_pModuleState);
		TRY
		{
			const CString strStatusText(szStatusText);			
			m_pOwner->OnProgress(ulProgress, ulProgressMax, ulStatusCode, szStatusText ? strStatusText.GetString() : NULL);
		}
		CATCH_ALL(e)
		{
			HRESULT hr = ResultFromScode(COleException::Process(e));
			DELETE_EXCEPTION(e);
			return hr;
		}
		END_CATCH_ALL
		return S_OK;
	}

	STDMETHOD(OnDataAvailable)(
		DWORD grfBSCF, DWORD dwSize, FORMATETC __RPC_FAR *pformatetc,
		STGMEDIUM __RPC_FAR *pstgmed)
	{
		ASSERT(m_pOwner);
		if (!m_pOwner)
			return E_FAIL;
		AFX_MANAGE_STATE(m_pModuleState);
		TRY
		{
			m_pOwner->SetFormatEtc(pformatetc);
			if (grfBSCF&BSCF_FIRSTDATANOTIFICATION)
			{
				if (!pstgmed || !pformatetc)
					return E_POINTER;
				if ((pstgmed->tymed != TYMED_ISTREAM) ||
					!pstgmed->pstm)
					return E_UNEXPECTED;
				ASSERT(!m_pOwner->GetStream());
				m_pOwner->COleStreamFile::Attach(pstgmed->pstm);
				pstgmed->pstm->AddRef();
			}

			m_pOwner->OnDataAvailable(dwSize, grfBSCF);
		}
		CATCH_ALL(e)
		{
			m_pOwner->SetFormatEtc(NULL);
			HRESULT hr = ResultFromScode(COleException::Process(e));
			DELETE_EXCEPTION(e);
			return hr;
		}
		END_CATCH_ALL
		m_pOwner->SetFormatEtc(NULL);
		return S_OK;
	}

	STDMETHOD(OnLowResource)(DWORD dwReserved)
	{
		ASSERT(m_pOwner);
		if (!m_pOwner)
			return E_FAIL;
		AFX_MANAGE_STATE(m_pModuleState);
		UNUSED_ALWAYS(dwReserved);
		TRY
		{
			m_pOwner->OnLowResource();
		}
		CATCH_ALL(e)
		{
			HRESULT hr = ResultFromScode(COleException::Process(e));
			DELETE_EXCEPTION(e);
			return hr;
		}
		END_CATCH_ALL
		return S_OK;
	}

	STDMETHOD(OnStopBinding)(HRESULT hresult, LPCOLESTR szError)
	{
		//Does not ASSERT(m_pOwner) because this can be called
		//after it has been Orphan()ed.
		if (!m_pOwner)
			return E_FAIL;
		AFX_MANAGE_STATE(m_pModuleState);
		ASSERT(m_pOwner->GetBinding());
		TRY
		{	
			m_pOwner->m_bStopBindingReceived = TRUE;					
			const CString strError(szError);
			m_pOwner->OnStopBinding(hresult, szError ? strError.GetString() : NULL );
			if (m_pOwner)
			{
				// Calling EndCallbacks will result in a inner Release. Our
				// caller has an inner refcount on us, possibly through the
				// controlling unknown, and we have an inner refcount from
				// m_pOwner, so m_dwRef > 1 and it's safe to call EndCallbacks.
				ASSERT(m_dwRef > 1);
				m_pOwner->EndCallbacks();
			}
		}
		CATCH_ALL(e)
		{
			HRESULT hr = ResultFromScode(COleException::Process(e));
			DELETE_EXCEPTION(e);
			return hr;
		}
		END_CATCH_ALL
		return S_OK;
	}

	STDMETHOD(OnObjectAvailable)(REFIID riid, IUnknown __RPC_FAR *punk)
	{
#ifdef _DEBUG
		AFX_MANAGE_STATE(m_pModuleState);
		ASSERT(FALSE);  // This function should never be called.
#endif //_DEBUG
		UNUSED_ALWAYS(riid);
		UNUSED_ALWAYS(punk);
		return E_UNEXPECTED;
	}
};

/////////////////////////////////////////////////////////////////////////////
// Helper functions for CAsyncMonikerFile implementation

AFX_STATIC inline IBindHost* AFXAPI _AfxTrySPForBindHost(IServiceProvider* pServiceProvider)
{
	ASSERT(pServiceProvider);
	IBindHost* pBindHost;
	HRESULT hr=pServiceProvider->QueryService(SID_IBindHost, IID_IBindHost,
		(void**)&pBindHost);
	if (SUCCEEDED(hr))
		return pBindHost;
	else
		return NULL;
}

AFX_STATIC inline IBindHost* AFXAPI _AfxTryQIForBindHost(IUnknown* pUnk)
{
	ASSERT(pUnk);
	IPTR(IBindHost) pBindHost;
	HRESULT hr = pBindHost.QueryInterface(pUnk);
	if (SUCCEEDED(hr))
		return pBindHost;
	else
		return NULL;
}

/////////////////////////////////////////////////////////////////////////////
// CAsyncMonikerFile implementation

CAsyncMonikerFile::CAsyncMonikerFile() : m_pFormatEtc(NULL),
	m_pAfxBSCCurrent(NULL)
{
}

CAsyncMonikerFile::~CAsyncMonikerFile()
{
	AFX_BEGIN_DESTRUCTOR

	CAsyncMonikerFile::Close();

	AFX_END_DESTRUCTOR
}

void CAsyncMonikerFile::EndCallbacks()
{
	if (m_pAfxBSCCurrent)
	{
		m_pAfxBSCCurrent->Orphan();
		IUnknown* pUnkInner = m_pAfxBSCCurrent->GetInnerUnknown();
		ASSERT(pUnkInner != NULL);
		pUnkInner->Release();
		m_pAfxBSCCurrent = NULL;
	}
}

UINT CAsyncMonikerFile::Read(void* lpBuf, UINT nCount)
{
	ASSERT_VALID(this);
	ASSERT(m_lpStream != NULL);

	DWORD dwBytesRead;
	HRESULT hr = _AfxReadFromStream(m_lpStream, lpBuf, nCount, dwBytesRead);

	if ((hr != S_OK) && (hr != S_ASYNCHRONOUS) && (hr != E_PENDING))
		_AfxThrowOleFileException(hr);

	// always return number of bytes read
	return (UINT)dwBytesRead;
}

void CAsyncMonikerFile::Close()
{
	ASSERT_VALID(this);
	if (m_Binding.GetInterfacePtr())
	{
		if (!m_bStopBindingReceived)
			m_Binding->Abort();
		m_Binding.Release();
	}
	EndCallbacks();
	CMonikerFile::Close();
}

BOOL CAsyncMonikerFile::Open(IMoniker* pMoniker, IBindHost* pBindHost, CFileException* pError)
{
	if (!pBindHost)
		return CAsyncMonikerFile::Open(pMoniker, pError);
	Close();
	IPTR(IBindCtx) pBindCtx(CreateBindContext(pError), FALSE);
	if (pError && (pError->m_cause != CFileException::none))
		return FALSE;
	IPTR(IUnknown) pBSCUnk(CreateBindStatusCallback(NULL), FALSE);
	IPTR(IBindStatusCallback) pBSC;
	pBSC.QueryInterface(pBSCUnk);

	m_bStopBindingReceived = FALSE;
	return Attach(pMoniker, pBindHost, pBSC, pBindCtx, pError);
}

BOOL CAsyncMonikerFile::Open(LPCTSTR lpszURL, IBindHost* pBindHost, CFileException* pError)
{
	if (!pBindHost)
		return CAsyncMonikerFile::Open(lpszURL, pError);
	Close();
	IPTR(IBindCtx) pBindCtx(CreateBindContext(pError), FALSE);
	if (pError && (pError->m_cause != CFileException::none))
		return FALSE;
	IPTR(IUnknown) pBSCUnk(CreateBindStatusCallback(NULL), FALSE);
	IPTR(IBindStatusCallback) pBSC;
	pBSC.QueryInterface(pBSCUnk);

	m_bStopBindingReceived = FALSE;
	return Attach(lpszURL, pBindHost, pBSC, pBindCtx, pError);
}

BOOL CAsyncMonikerFile::Open(LPCTSTR lpszURL, CFileException* pError)
{
	IPTR(IBindHost) pBindHost(CreateBindHost(), FALSE);

	return Open(lpszURL, static_cast<IBindHost*>(pBindHost), pError);
}

BOOL CAsyncMonikerFile::Open(IMoniker* pMoniker, CFileException* pError)
{
	IPTR(IBindHost) pBindHost(CreateBindHost(), FALSE);

	return Open(pMoniker, (IBindHost*)pBindHost, pError);
}

BOOL CAsyncMonikerFile::Open(LPCTSTR lpszURL,
	IServiceProvider* pServiceProvider, CFileException* pError)
{
	if (!pServiceProvider)
		return CAsyncMonikerFile::Open(lpszURL, pError);
	IPTR(IBindHost) pBindHost;
	pBindHost = _AfxTrySPForBindHost(pServiceProvider);
	if (!pBindHost.GetInterfacePtr())
		pBindHost = _AfxTryQIForBindHost(pServiceProvider);
	if (pBindHost.GetInterfacePtr())
		return Open(lpszURL, (IBindHost*)pBindHost, pError);
	return CAsyncMonikerFile::Open(lpszURL, pError);
}

BOOL CAsyncMonikerFile::Open(LPCTSTR lpszURL,
	IUnknown* pUnknown, CFileException* pError)
{
	if (!pUnknown)
		return CAsyncMonikerFile::Open(lpszURL, pError);
	IPTR(IBindHost) pBindHost;
	IPTR(IServiceProvider) pServiceProvider;
	HRESULT hr=pServiceProvider.QueryInterface(pUnknown);
	if (SUCCEEDED(hr) && pServiceProvider.GetInterfacePtr())
		pBindHost = _AfxTrySPForBindHost(pServiceProvider);
	if (!pBindHost.GetInterfacePtr())
		pBindHost = _AfxTryQIForBindHost(pUnknown);
	if (pBindHost.GetInterfacePtr())
		return Open(lpszURL, (IBindHost*)pBindHost, pError);

	return CAsyncMonikerFile::Open(lpszURL, pError);
}

BOOL CAsyncMonikerFile::Open(IMoniker* pMoniker,
	IServiceProvider* pServiceProvider, CFileException* pError)
{
	if (!pServiceProvider)
		return Open(pMoniker, pError);
	IPTR(IBindHost) pBindHost;
	pBindHost = _AfxTrySPForBindHost(pServiceProvider);
	if (!pBindHost.GetInterfacePtr())
		pBindHost = _AfxTryQIForBindHost(pServiceProvider);
	if (pBindHost.GetInterfacePtr())
		return Open(pMoniker, (IBindHost*)pBindHost, pError);
	return Open(pMoniker, pError);
}

BOOL CAsyncMonikerFile::Open(IMoniker* pMoniker,
	IUnknown* pUnknown, CFileException* pError)
{
	if (!pUnknown)
		return Open(pMoniker, pError);
	IPTR(IBindHost) pBindHost;
	IPTR(IServiceProvider) pServiceProvider;
	HRESULT hr=pServiceProvider.QueryInterface(pUnknown);
	if (SUCCEEDED(hr) && pServiceProvider.GetInterfacePtr())
		pBindHost = _AfxTrySPForBindHost(pServiceProvider);
	if (!pBindHost.GetInterfacePtr())
		pBindHost = _AfxTryQIForBindHost(pServiceProvider);
	if (pBindHost.GetInterfacePtr())
		return Open(pMoniker, (IBindHost*)pBindHost, pError);
	return Open(pMoniker, pError);
}

BOOL CAsyncMonikerFile::PostBindToStream(CFileException* pError)
{
	if (S_OK == IsAsyncMoniker(GetMoniker()))
		return TRUE;
	return CMonikerFile::PostBindToStream(pError);
}

IUnknown* CAsyncMonikerFile::CreateBindStatusCallback(IUnknown* pUnkControlling)
{
	ASSERT(NULL == m_pAfxBSCCurrent); // Set by Close()
	m_pAfxBSCCurrent = new _AfxBindStatusCallback(this, pUnkControlling);
	IUnknown* pUnkInner = m_pAfxBSCCurrent->GetInnerUnknown();
	ASSERT(pUnkInner != NULL);
	//Reference inner unknown for m_pAfxBSCCurrent
	pUnkInner->AddRef();
	//Reference inner unknown for return value.
	pUnkInner->AddRef();
	return pUnkInner;
}

DWORD CAsyncMonikerFile::GetBindInfo() const
{
	return BINDF_ASYNCHRONOUS|BINDF_ASYNCSTORAGE;
}

LONG CAsyncMonikerFile::GetPriority() const
{
	return THREAD_PRIORITY_NORMAL;
}

void CAsyncMonikerFile::OnDataAvailable(DWORD dwSize, DWORD bscfFlag)
{
	UNUSED_ALWAYS(dwSize);
	UNUSED_ALWAYS(bscfFlag);
}

void CAsyncMonikerFile::OnLowResource()
{
}

void CAsyncMonikerFile::OnStartBinding()
{
}

void CAsyncMonikerFile::OnStopBinding(HRESULT hresult, LPCTSTR szError)
{
	UNUSED_ALWAYS(hresult);
	UNUSED_ALWAYS(szError);
}

void CAsyncMonikerFile::OnProgress(ULONG ulProgress, ULONG ulProgressMax,
		ULONG ulStatusCode, LPCTSTR szStatusText)
{
	UNUSED_ALWAYS(ulProgress);
	UNUSED_ALWAYS(ulProgressMax);
	UNUSED_ALWAYS(ulStatusCode);
	UNUSED_ALWAYS(szStatusText);
}

/////////////////////////////////////////////////////////////////////////////
// CAsyncMonikerFile diagnostics

#ifdef _DEBUG
void CAsyncMonikerFile::AssertValid() const
{
	if (m_pAfxBSCCurrent)
	{
		ASSERT(m_pAfxBSCCurrent->GetOwner() == this);
		ASSERT(m_pAfxBSCCurrent->GetRefcount() > 0);
#ifdef _AFXDLL
		ASSERT(m_pAfxBSCCurrent->GetModuleState() == AfxGetModuleState());
#endif
		ASSERT(m_pAfxBSCCurrent->GetpThisOfInnerUnknown() == m_pAfxBSCCurrent);
	}
	CMonikerFile::AssertValid();
}

void CAsyncMonikerFile::Dump(CDumpContext& dc) const
{
	CMonikerFile::Dump(dc);

	dc << "\nm_Binding = " << m_Binding.GetInterfacePtr();
	dc << "\nm_pFormatEtc = " << m_pFormatEtc;
	dc << "\nm_pAfxBSCCurrent = " << m_pAfxBSCCurrent;
	if (m_pAfxBSCCurrent)
	{
		dc << "\nm_pAfxBSCCurrent->GetOwner() = " << m_pAfxBSCCurrent->GetOwner();
		dc << "\nm_pAfxBSCCurrent->GetRefcount() = " << m_pAfxBSCCurrent->GetRefcount();
		dc << "\nm_pAfxBSCCurrent->GetControllingUnknown() = " << m_pAfxBSCCurrent->GetControllingUnknown();
		dc << "\nm_pAfxBSCCurrent->GetInnerUnknown() = " << m_pAfxBSCCurrent->GetInnerUnknown();
		dc << "\nm_pAfxBSCCurrent->GetpThisOfInnerUnknown() = " << m_pAfxBSCCurrent->GetpThisOfInnerUnknown();
#ifdef _AFXDLL
		dc << "\nm_pAfxBSCCurrent->GetModuleState() = " << m_pAfxBSCCurrent->GetModuleState();
#endif
	}
	dc << "\n";
}
#endif

////////////////////////////////////////////////////////////////////////////


IMPLEMENT_DYNAMIC(CAsyncMonikerFile, CMonikerFile)

////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\occsite.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "occimpl.h"
#include "msdadc.h"



#define new DEBUG_NEW

#define S_QUICKACTIVATED S_FALSE

#include "initguid.h"
#define DBINITCONSTANTS
#define INITGUID

DEFINE_GUID(IID_IDataSourceListener,0x7C0FFAB2L,0xCD84,0x11D0,0x94,0x9A,0x00,0xA0,0xC9,0x11,0x10,0xED);
DEFINE_GUID(IID_IDataSource,0x7c0ffab3L, 0xcd84, 0x11d0, 0x94, 0x9a, 0x00, 0xa0, 0xc9, 0x11, 0x10, 0xed);

/////////////////////////////////////////////////////////////////////////////
// COleControlSite


BEGIN_INTERFACE_MAP(COleControlSite, CCmdTarget)
	INTERFACE_PART(COleControlSite, IID_IOleClientSite, OleClientSite)
	INTERFACE_PART(COleControlSite, IID_IOleInPlaceSite, OleIPSite)
   INTERFACE_PART(COleControlSite, IID_IOleInPlaceSiteEx, OleIPSite)
   INTERFACE_PART(COleControlSite, IID_IOleInPlaceSiteWindowless, OleIPSite)
	INTERFACE_PART(COleControlSite, IID_IOleControlSite, OleControlSite)
	INTERFACE_PART(COleControlSite, IID_IDispatch, AmbientProps)
	INTERFACE_PART(COleControlSite, IID_IBoundObjectSite, BoundObjectSite)
	INTERFACE_PART(COleControlSite, IID_INotifyDBEvents, NotifyDBEvents)
	INTERFACE_PART(COleControlSite, IID_IRowsetNotify, RowsetNotify)
END_INTERFACE_MAP()

COleControlSite::COleControlSite(COleControlContainer* pCtrlCont) :
	m_pCtrlCont(pCtrlCont),
	m_pWndCtrl(NULL),
   m_pDC(NULL),
	m_nID((UINT)-1),
	m_pObject(NULL),
	m_pInPlaceObject(NULL),
	m_pActiveObject(NULL),
   m_pWindowlessObject(NULL),
	m_dwEventSink(0),
	m_dwPropNotifySink(0),
	m_dwMiscStatus(0),
	m_dwNotifyDBEvents(0),
	m_pDataSourceControl(NULL),
	m_pDSCSite(NULL),
	m_defdispid(0),
	m_dwType(0),
	m_pBindings(NULL),
	m_bIgnoreNotify(FALSE),
	m_bIsDirty(FALSE),
   m_bIsWindowless(FALSE)
{
	memset(&m_varResult, 0, sizeof(VARIANT));
	m_varResult.vt = VT_EMPTY;
}

COleControlSite::~COleControlSite()
{
   if (m_pCtrlCont && m_pCtrlCont->m_pSiteCapture == this)
   {
	  m_pCtrlCont->m_pSiteCapture = NULL;
   }

	delete m_pDataSourceControl;

	DetachWindow();

	DisconnectSink(m_iidEvents, m_dwEventSink);
	DisconnectSink(IID_IPropertyNotifySink, m_dwPropNotifySink);
	DisconnectSink(IID_INotifyDBEvents, m_dwNotifyDBEvents);

   if (m_pWindowlessObject != NULL)
   {
	  m_pWindowlessObject->Release();
	  m_pWindowlessObject = NULL;
   }

	if (m_pInPlaceObject != NULL)
	{
		m_pInPlaceObject->InPlaceDeactivate();
		m_pInPlaceObject->Release();
		m_pInPlaceObject = NULL;
	}

	if (m_pActiveObject != NULL)
	{
		m_pActiveObject->Release();
		m_pActiveObject = NULL;
	}

	if (m_pObject != NULL)
	{
		m_pObject->SetClientSite(NULL);
		m_pObject->Close(OLECLOSE_NOSAVE);
		m_pObject->Release();
		m_pObject = NULL;
	}

	::VariantClear(&m_varResult);

	BindProperty(DISPID_UNKNOWN, NULL);  // gets rid of complex bindings

	if (m_defdispid != 0 && m_pDSCSite != NULL && 
		m_pDSCSite->m_pDataSourceControl != NULL)
	{
		// get rid of simple bindings
		m_pDSCSite->m_pDataSourceControl->BindProp(this, FALSE);  
	}

	if (m_pCtrlCont && m_bIsWindowless)
	{
	   m_pCtrlCont->m_nWindowlessControls--;
	   ASSERT(m_pCtrlCont->m_nWindowlessControls >= 0);
	}

	// Tell the GC to release references on objects about to go away...
	HRESULT hr = S_OK;

	CComPtr<IUnknown> spPropertyIUnknown = NULL;
	hr = m_xPropertyNotifySink.QueryInterface(IID_IUnknown, reinterpret_cast<void**>(&spPropertyIUnknown) );
	if( SUCCEEDED( hr ) )
	{
		_AfxReleaseManagedRefs( spPropertyIUnknown );
	}

	CComPtr<IUnknown> spEventIUnknown = NULL;
	hr = m_xEventSink.QueryInterface(IID_IUnknown, reinterpret_cast<void**>(&spEventIUnknown) );
	if( SUCCEEDED( hr ) )
	{
		_AfxReleaseManagedRefs( spEventIUnknown );
	}
}

BOOL COleControlSite::SetExtent()
{
	CSize size(m_rect.Size());
	CClientDC dc(NULL);
	dc.DPtoHIMETRIC(&size);

	ENSURE(m_pObject!=NULL);
	HRESULT hr;
	if (SUCCEEDED(hr = m_pObject->SetExtent(DVASPECT_CONTENT, (SIZEL*)&size)))
	{
		if (SUCCEEDED(m_pObject->GetExtent(DVASPECT_CONTENT, (SIZEL*)&size)))
		{
			dc.HIMETRICtoDP(&size);
			m_rect.right = m_rect.left + size.cx;
			m_rect.bottom = m_rect.top + size.cy;
		}
	}

	return SUCCEEDED(hr);
}

HRESULT COleControlSite::CreateControl(CWnd* pWndCtrl, REFCLSID clsid,
	LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, UINT nID,
	CFile* pPersist, BOOL bStorage, BSTR bstrLicKey)
{
   CRect rect2( rect );
   CPoint pt;
   CSize size;

   pt = rect2.TopLeft();
   size = rect2.Size();

   return( CreateControl( pWndCtrl, clsid, lpszWindowName, dwStyle, &pt, &size,
	  nID, pPersist, bStorage, bstrLicKey ) );
}

HRESULT COleControlSite::CreateControl(CWnd* pWndCtrl, REFCLSID clsid,
	LPCTSTR lpszWindowName, DWORD dwStyle, const POINT* ppt, const SIZE* psize,
   UINT nID, CFile* pPersist, BOOL bStorage, BSTR bstrLicKey)
{
	CControlCreationInfo creationInfo;
	return CreateControlCommon(pWndCtrl, clsid,creationInfo,
		lpszWindowName, dwStyle, ppt, psize,
		nID, pPersist, bStorage, bstrLicKey);
}
HRESULT COleControlSite::CreateControl(CWnd* pWndCtrl, const CControlCreationInfo& creationInfo,
			 DWORD dwStyle, const POINT* ppt, const SIZE* psize,UINT nID)
{
	return CreateControlCommon(pWndCtrl, creationInfo.m_clsid,creationInfo,
		NULL, dwStyle, ppt, psize,
		nID, NULL,FALSE,NULL);
}


HRESULT COleControlSite::CreateControlCommon(CWnd* pWndCtrl, REFCLSID clsid,const CControlCreationInfo& creationInfo,
	LPCTSTR lpszWindowName, DWORD dwStyle, const POINT* ppt, const SIZE* psize,
   UINT nID, CFile* pPersist, BOOL bStorage, BSTR bstrLicKey)
{
	HRESULT hr = E_FAIL;
	m_hWnd = NULL;
   CSize size;

	// Connect the OLE Control with its proxy CWnd object
	if (pWndCtrl != NULL)
	{
		ASSERT(pWndCtrl->m_pCtrlSite == NULL);
		m_pWndCtrl = pWndCtrl;
		pWndCtrl->m_pCtrlSite = this;
	}

	// Initialize OLE, if necessary
	_AFX_THREAD_STATE* pState = AfxGetThreadState();
	if (!pState->m_bNeedTerm && !AfxOleInit())
		return hr;

	if (creationInfo.IsManaged())
	{
		hr=CreateOrLoad(creationInfo);
	} else
	{
		hr=CreateOrLoad(clsid, pPersist, bStorage, bstrLicKey);
	}

	if (SUCCEEDED(hr))
	{
		ENSURE(m_pObject != NULL);
		m_nID = nID;

		ENSURE_ARG(ppt!=NULL);
		if (psize == NULL)
		{
			// If psize is NULL, ask the object how big it wants to be.
			CClientDC dc(NULL);

			m_pObject->GetExtent(DVASPECT_CONTENT, &size);
			dc.HIMETRICtoDP(&size);
			m_rect = CRect(*ppt, size);
		}
		else
		{
			m_rect = CRect(*ppt, *psize);
		}

		m_dwStyleMask = WS_GROUP | WS_TABSTOP;

		if (m_dwMiscStatus & OLEMISC_ACTSLIKEBUTTON)
			m_dwStyleMask |= BS_DEFPUSHBUTTON;

		if (m_dwMiscStatus & OLEMISC_INVISIBLEATRUNTIME)
			dwStyle &= ~WS_VISIBLE;

		m_dwStyle = dwStyle & m_dwStyleMask;

		// If control wasn't quick-activated, then connect sinks now.
		if (hr != S_QUICKACTIVATED)
		{
			m_dwEventSink = ConnectSink(m_iidEvents, &m_xEventSink);
			m_dwPropNotifySink = ConnectSink(IID_IPropertyNotifySink,
				&m_xPropertyNotifySink);
		}
		m_dwNotifyDBEvents = ConnectSink(IID_INotifyDBEvents, &m_xNotifyDBEvents);

		// Now that the object has been created, attempt to
		// in-place activate it.

		SetExtent();

		if (SUCCEEDED(hr = m_pObject->QueryInterface(IID_IOleInPlaceObject,
				(LPVOID*)&m_pInPlaceObject)))
		{
			if (dwStyle & WS_VISIBLE)
			{
				// control is visible: just activate it
				hr = DoVerb(OLEIVERB_INPLACEACTIVATE);
			}
			else
			{
				// control is not visible: activate off-screen, hide, then move
				m_rect.OffsetRect(-32000, -32000);
				if (SUCCEEDED(hr = DoVerb(OLEIVERB_INPLACEACTIVATE)) &&
					SUCCEEDED(hr = DoVerb(OLEIVERB_HIDE)))
				{
					m_rect.OffsetRect(32000, 32000);
					hr = m_pInPlaceObject->SetObjectRects(m_rect, m_rect);
				}
			}

			//Newly created control gets the focus.
			if (SUCCEEDED(hr))
			{
				m_pCtrlCont->m_pSiteFocus = this; 
			}
		}
		else
		{
			TRACE(traceOle, 0, "IOleInPlaceObject not supported on OLE control (dialog ID %d).\n", nID);
			TRACE(traceOle, 0, ">>> Result code: 0x%08lx\n", hr);
		}

		if (SUCCEEDED(hr))
			GetControlInfo();

		// if QueryInterface or activation failed, cleanup everything
		if (FAILED(hr))
		{
			if (m_pInPlaceObject != NULL)
			{
				m_pInPlaceObject->Release();
				m_pInPlaceObject = NULL;
			}
			DisconnectSink(m_iidEvents, m_dwEventSink);
			DisconnectSink(IID_IPropertyNotifySink, m_dwPropNotifySink);
			DisconnectSink(IID_INotifyDBEvents, m_dwNotifyDBEvents);
			m_dwEventSink = 0;
			m_dwPropNotifySink = 0;
			m_dwNotifyDBEvents = 0;
			m_pObject->Release();
			m_pObject = NULL;
		}
	}

	if (SUCCEEDED(hr))
	{
		AttachWindow();

		// Initialize the control's Caption or Text property, if any
		if (lpszWindowName != NULL)
			SetWindowText(lpszWindowName);		

		// Initialize styles
		ModifyStyle(0, m_dwStyle | (dwStyle & (WS_DISABLED|WS_BORDER)), 0);		
	}

	return hr;
}


BOOL COleControlSite::DestroyControl()
{
	POSITION pos;

	if( m_hWnd != NULL )
		m_pCtrlCont->m_siteMap.RemoveKey(m_hWnd);

	//VBBUG: VB controls will crash if IOleObject::Close is called on them
	//	when they have focus (and unfortunately, deactivating them does not
	//	always move the focus).  To work around this problem, we always hide
	//	the control before closing it.
	ShowWindow(SW_HIDE);

	pos = m_pCtrlCont->m_listSitesOrWnds.GetHeadPosition();
	COleControlSiteOrWnd *pSiteOrWnd = NULL;
	while(pos)
	{
		POSITION posTemp = pos;
		pSiteOrWnd = m_pCtrlCont->m_listSitesOrWnds.GetNext(pos);
		ASSERT(pSiteOrWnd);
		if (pSiteOrWnd->m_pSite == this)
		{
			pos = posTemp;
			break;
		}
	}

	if (pos && pSiteOrWnd)
	{
		m_pCtrlCont->m_listSitesOrWnds.RemoveAt(pos);
		delete pSiteOrWnd;
	}
	else
		delete this;

	return TRUE;
}

AFX_STATIC HRESULT AFXAPI _AfxCoCreateInstanceLic(REFCLSID clsid, LPUNKNOWN pUnkOuter,
	DWORD dwClsCtx, REFIID iid, LPVOID* ppv, BSTR bstrLicKey)
{
	HRESULT hr;

    if (::SysStringLen(bstrLicKey) == 0)
	{
		LPCLASSFACTORY pClassFactory = NULL;

		if (SUCCEEDED(hr = CoGetClassObject(clsid, dwClsCtx, NULL,
			IID_IClassFactory, (void**)&pClassFactory)))
		{
			ASSERT(pClassFactory != NULL);
			hr = pClassFactory->CreateInstance(pUnkOuter, iid, ppv);
			pClassFactory->Release();
		}
	}
	else
	{
		LPCLASSFACTORY2 pClassFactory = NULL;

		if (SUCCEEDED(hr = CoGetClassObject(clsid, dwClsCtx, NULL,
			IID_IClassFactory2, (void**)&pClassFactory)))
		{
			ASSERT(pClassFactory != NULL);
			hr = pClassFactory->CreateInstanceLic(pUnkOuter, NULL, iid,
				bstrLicKey, ppv);
			pClassFactory->Release();
		}
	}

	return hr;
}

AFX_STATIC_DATA const struct { DISPID dwDispID; DWORD dwFlag; } _afxAmbients[] =
{
	{ DISPID_AMBIENT_USERMODE,          QACONTAINER_USERMODE },
	{ DISPID_AMBIENT_UIDEAD,            QACONTAINER_UIDEAD },
	{ DISPID_AMBIENT_SHOWGRABHANDLES,   QACONTAINER_SHOWGRABHANDLES },
	{ DISPID_AMBIENT_SHOWHATCHING,      QACONTAINER_SHOWHATCHING },
	{ DISPID_AMBIENT_DISPLAYASDEFAULT,  QACONTAINER_DISPLAYASDEFAULT },
	{ DISPID_AMBIENT_AUTOCLIP,          QACONTAINER_AUTOCLIP },
	{ DISPID_AMBIENT_MESSAGEREFLECT,    QACONTAINER_MESSAGEREFLECT },
	{ DISPID_AMBIENT_SUPPORTSMNEMONICS, QACONTAINER_SUPPORTSMNEMONICS },
};

BOOL COleControlSite::QuickActivate()
{
	ENSURE(m_pObject!=NULL);
	BOOL bQuickActivated = FALSE;
	IQuickActivate* pQuick = NULL;
	if (SUCCEEDED(m_pObject->QueryInterface(IID_IQuickActivate,
		reinterpret_cast<void**>(&pQuick))))
	{
		ENSURE(pQuick != NULL);

		// Initialize QACONTAINER structure.
		QACONTAINER qaContainer;
		qaContainer.cbSize = sizeof(QACONTAINER);
		qaContainer.pClientSite = &m_xOleClientSite;
		qaContainer.pAdviseSink = NULL;
		qaContainer.pPropertyNotifySink = &m_xPropertyNotifySink;
		qaContainer.pUnkEventSink = &m_xEventSink;
		qaContainer.pUndoMgr = NULL;
		qaContainer.hpal = NULL;
		qaContainer.pBindHost = NULL;

		// Fill ambient property values in QACONTAINER.
		COleVariant var;
		ENSURE(m_pCtrlCont!=NULL);
		CWnd* pWndContain = m_pCtrlCont->m_pWnd;

		qaContainer.dwAmbientFlags = 0;
		ENSURE(pWndContain!=NULL);
		for (int i = 0; i < _countof(_afxAmbients); i++)
		{
			pWndContain->OnAmbientProperty(this, _afxAmbients[i].dwDispID, &var);
			if (V_BOOL(&var))
				qaContainer.dwAmbientFlags |= _afxAmbients[i].dwFlag;
		}

		pWndContain->OnAmbientProperty(this, DISPID_AMBIENT_FORECOLOR, &var);
		qaContainer.colorFore = V_I4(&var);
		pWndContain->OnAmbientProperty(this, DISPID_AMBIENT_BACKCOLOR, &var);
		qaContainer.colorBack = V_I4(&var);
		pWndContain->OnAmbientProperty(this, DISPID_AMBIENT_APPEARANCE, &var);
		qaContainer.dwAppearance = V_I2(&var);
		pWndContain->OnAmbientProperty(this, DISPID_AMBIENT_LOCALEID, &var);
		qaContainer.lcid = V_I4(&var);
		pWndContain->OnAmbientProperty(this, DISPID_AMBIENT_FONT, &var);
		if (FAILED(V_DISPATCH(&var)->QueryInterface(IID_IFont,
			reinterpret_cast<void**>(&qaContainer.pFont))))
		{
			qaContainer.pFont = NULL;
		}

		// Initialize QACONTROL structure.
		QACONTROL qaControl;
		qaControl.cbSize = sizeof(QACONTROL);

		// Do the quick activation.
		if (SUCCEEDED(pQuick->QuickActivate(&qaContainer, &qaControl)))
		{
			// Extract return values from QACONTROL structure.
			m_dwMiscStatus = qaControl.dwMiscStatus;
			m_dwEventSink = qaControl.dwEventCookie;
			m_dwPropNotifySink = qaControl.dwPropNotifyCookie;
			bQuickActivated = TRUE;
		}
		pQuick->Release();

		if (qaContainer.pFont != NULL)
			qaContainer.pFont->Release();
	}

	return bQuickActivated;
}


HRESULT COleControlSite::CreateOrLoad(const CControlCreationInfo&)
{
	//Implement for special ActiveX control types. The other overloads should
	//handle the regular ActiveX case.
	ASSERT(FALSE);
	return E_UNEXPECTED;
}


HRESULT COleControlSite::CreateOrLoad(REFCLSID clsid, CFile* pFile,
	BOOL bStorage, BSTR bstrLicKey)

{	
#ifdef _DEBUG
	OLECHAR wszClsid[40];
	StringFromGUID2(clsid, wszClsid, 40);
#endif //_DEBUG

	HRESULT hr=S_OK;

	if (m_pObject == NULL)
	{
		if (FAILED(hr = _AfxCoCreateInstanceLic(clsid, NULL,
			CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER, IID_IOleObject,
			(void**)&m_pObject, bstrLicKey)))
		{
	#ifdef _DEBUG
			TRACE(traceOle, 0, "CoCreateInstance of OLE control %ls failed.\n", wszClsid);
			TRACE(traceOle, 0, ">>> Result code: 0x%08lx\n", hr);
			TRACE(traceOle, 0, ">>> Is the control is properly registered?\n");
	#endif
			return hr;
		}
	}

	LPPERSISTSTREAMINIT pPersStm = NULL;
	LPPERSISTSTORAGE pPersStg = NULL;
	LPPERSISTMEMORY pPersMem = NULL;

	GetEventIID(&m_iidEvents);
	// Try to quick-activate first
	BOOL bQuickActivated = QuickActivate();

	if (!bQuickActivated)
	{
		m_pObject->GetMiscStatus(DVASPECT_CONTENT, &m_dwMiscStatus);

		// set client site first, if appropriate
		if (m_dwMiscStatus & OLEMISC_SETCLIENTSITEFIRST)
		{
			if (FAILED(hr = m_pObject->SetClientSite(&m_xOleClientSite)))
			{
#ifdef _DEBUG
				TRACE(traceOle, 0, "SetClientSite on OLE control %ls failed.\n", wszClsid);
				TRACE(traceOle, 0, ">>> Result code: 0x%08lx\n", hr);
#endif
				goto CreateOrLoadFailed;
			}
		}
	}

	ASSERT(!bStorage || pFile != NULL);

	// initialize via IPersistMemory (direct buffering)
	if (pFile != NULL && !bStorage &&
		SUCCEEDED(m_pObject->QueryInterface(IID_IPersistMemory, (void**)&pPersMem)) &&
		pFile->GetBufferPtr(CFile::bufferCheck) != 0)
	{
		ASSERT(pPersMem != NULL);

		// file supports direct buffering, get its buffer pointer and size
		LPVOID pvBuffer = NULL;
		LPVOID pvEnd;
		ULONG cbBuffer = pFile->GetBufferPtr(
			CFile::bufferRead, (UINT)-1, &pvBuffer, &pvEnd);
		ASSERT(((LPBYTE)pvEnd - (LPBYTE)pvBuffer) == (int)cbBuffer);

		// and then load it directly
		hr = pPersMem->Load(pvBuffer, cbBuffer);
		pPersMem->Release();
		pPersMem = NULL;
		if (FAILED(hr))
			goto CreateOrLoadFailed;
	}
	// initialize via IPersistStreamInit
	else if (!bStorage && SUCCEEDED(m_pObject->QueryInterface(
		IID_IPersistStreamInit, (void**)&pPersStm)))
	{
		ASSERT(pPersStm != NULL);

		if (pFile == NULL)
		{
			// just call InitNew
			hr = pPersStm->InitNew();
		}
		else
		{
			// open an IStream on the data and pass it to Load
			CArchive ar(pFile, CArchive::load);
			CArchiveStream stm(&ar);
			hr = pPersStm->Load(&stm);
		}
		pPersStm->Release();

		if (FAILED(hr))
		{
#ifdef _DEBUG
			TRACE(traceOle, 0, "InitNew or Load on OLE control %ls failed.\n", wszClsid);
			TRACE(traceOle, 0, ">>> Result code: 0x%08lx\n", hr);
#endif
			goto CreateOrLoadFailed;
		}
	}
	// initialize via IPersistStorage
	else if (SUCCEEDED(m_pObject->QueryInterface(
		IID_IPersistStorage, (void**)&pPersStg)))
	{
		ASSERT(pPersStg != NULL);

		if (pFile == NULL)
		{
			// create a scratch IStorage and pass it to InitNew
			LPLOCKBYTES pLockBytes = NULL;
			if (SUCCEEDED(hr = CreateILockBytesOnHGlobal(NULL, TRUE,
				&pLockBytes)))
			{
				ASSERT(pLockBytes != NULL);
				LPSTORAGE pStorage = NULL;
				if (SUCCEEDED(hr = StgCreateDocfileOnILockBytes(pLockBytes,
					STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0,
					&pStorage)))
				{
					ASSERT(pStorage != NULL);
					hr = pPersStg->InitNew(pStorage);
					pStorage->Release();
				}
				pLockBytes->Release();
			}
		}
		else if (bStorage)
		{
			// copy data to an HGLOBAL, so we can build an IStorage on it
			ULONGLONG cb = pFile->GetLength();
			HGLOBAL hGlobal;
			BYTE* pbData;

			if ((cb < ULONG_MAX) &&
			((hGlobal = GlobalAlloc(GMEM_FIXED, ULONG(cb))) != NULL) &&
				((pbData = (BYTE*)GlobalLock(hGlobal)) != NULL))
			{
				pFile->Read(pbData, ULONG(cb));
				GlobalUnlock(hGlobal);
			}
			else
			{
				hr = E_OUTOFMEMORY;
				hGlobal = NULL;
			}

			// open an IStorage on the data and pass it to Load
			LPLOCKBYTES pLockBytes = NULL;
			if ((hGlobal != NULL) &&
				SUCCEEDED(hr = CreateILockBytesOnHGlobal(hGlobal, TRUE,
				&pLockBytes)))
			{
				ASSERT(pLockBytes != NULL);
				LPSTORAGE pStorage = NULL;
				if (SUCCEEDED(hr = StgOpenStorageOnILockBytes(pLockBytes, NULL,
					STGM_READWRITE | STGM_SHARE_EXCLUSIVE, NULL, 0, &pStorage)))
				{
					ASSERT(pStorage != NULL);
					hr = pPersStg->Load(pStorage);
					pStorage->Release();
				}
				pLockBytes->Release();
			}
		}
		else
		{
			hr = E_UNEXPECTED;
		}
		pPersStg->Release();

		if (FAILED(hr))
		{
#ifdef _DEBUG
			TRACE(traceOle, 0, "InitNew or Load on OLE control %ls failed.\n", wszClsid);
			TRACE(traceOle, 0, ">>> Result code: 0x%08lx\n", hr);
#endif
			goto CreateOrLoadFailed;
		}
	}
	else
	{
#ifdef _DEBUG
		TRACE(traceOle, 0, "Persistence not supported on OLE control %ls.\n", wszClsid);
		TRACE(traceOle, 0, ">>> Result code: 0x%08lx\n", hr);
#endif
		goto CreateOrLoadFailed;
	}

	if (!bQuickActivated)
	{
		// set client site last, if appropriate
		if (!(m_dwMiscStatus & OLEMISC_SETCLIENTSITEFIRST))
		{
			if (FAILED(hr = m_pObject->SetClientSite(&m_xOleClientSite)))
			{
#ifdef _DEBUG
				TRACE(traceOle, 0, "SetClientSite on OLE control %ls failed.\n", wszClsid);
				TRACE(traceOle, 0, ">>> Result code: 0x%08lx\n", hr);
#endif
				goto CreateOrLoadFailed;
			}
		}
	}

CreateOrLoadFailed:
	if (FAILED(hr) && (m_pObject != NULL))
	{
		m_pObject->Close(OLECLOSE_NOSAVE);
		m_pObject->Release();
		m_pObject = NULL;
	}

	if (pPersMem != NULL)
		pPersMem->Release();

	if (bQuickActivated && SUCCEEDED(hr))
		hr = S_QUICKACTIVATED;

	return hr;
}

HRESULT COleControlSite::DoVerb(LONG nVerb, LPMSG lpMsg)
{
	ENSURE(m_pObject!=NULL && m_pCtrlCont!=NULL && m_pCtrlCont->m_pWnd!=NULL);
	return m_pObject->DoVerb(nVerb, lpMsg, &m_xOleClientSite, 0,
		m_pCtrlCont->m_pWnd->m_hWnd, m_rect);
}

BOOL COleControlSite::IsDefaultButton()
{
	return ((m_dwMiscStatus & OLEMISC_ACTSLIKEBUTTON) &&
		(m_dwStyle & BS_DEFPUSHBUTTON));
}

DWORD COleControlSite::GetDefBtnCode()
{
	if (m_dwMiscStatus & OLEMISC_ACTSLIKEBUTTON)
		return (m_dwStyle & BS_DEFPUSHBUTTON) ?
			DLGC_DEFPUSHBUTTON :
			DLGC_UNDEFPUSHBUTTON;
	else
		return 0;
}

void COleControlSite::SetDefaultButton(BOOL bDefault)
{
	if (!(m_dwMiscStatus & OLEMISC_ACTSLIKEBUTTON))
		return;

	if (((m_dwStyle & BS_DEFPUSHBUTTON) != 0) == (bDefault != FALSE))
		return;

	m_dwStyle ^= BS_DEFPUSHBUTTON;

	// Notify control that its "defaultness" has changed.
	LPOLECONTROL pOleCtl = NULL;
	ENSURE(m_pObject!=NULL);
	if (SUCCEEDED(m_pObject->QueryInterface(IID_IOleControl,
		(LPVOID*)&pOleCtl)))
	{
		ASSERT(pOleCtl != NULL);
		pOleCtl->OnAmbientPropertyChange(DISPID_AMBIENT_DISPLAYASDEFAULT);
		pOleCtl->Release();
	}
}

DWORD COleControlSite::ConnectSink(REFIID iid, LPUNKNOWN punkSink)
{
	ASSERT(m_pObject != NULL);

	LPCONNECTIONPOINTCONTAINER pConnPtCont;

	if ((m_pObject != NULL) &&
		SUCCEEDED(m_pObject->QueryInterface(IID_IConnectionPointContainer,
			(LPVOID*)&pConnPtCont)))
	{
		ASSERT(pConnPtCont != NULL);
		LPCONNECTIONPOINT pConnPt = NULL;
		DWORD dwCookie = 0;

		if (SUCCEEDED(pConnPtCont->FindConnectionPoint(iid, &pConnPt)))
		{
			ASSERT(pConnPt != NULL);
			pConnPt->Advise(punkSink, &dwCookie);
			pConnPt->Release();
		}

		pConnPtCont->Release();
		return dwCookie;
	}

	return 0;
}

void COleControlSite::DisconnectSink(REFIID iid, DWORD dwCookie)
{
	if (dwCookie == 0 || m_pObject == NULL)
		return;

	LPCONNECTIONPOINTCONTAINER pConnPtCont;

	if (SUCCEEDED(m_pObject->QueryInterface(IID_IConnectionPointContainer,
			(LPVOID*)&pConnPtCont)))
	{
		ASSERT(pConnPtCont != NULL);
		LPCONNECTIONPOINT pConnPt = NULL;

		if (SUCCEEDED(pConnPtCont->FindConnectionPoint(iid, &pConnPt)))
		{
			ASSERT(pConnPt != NULL);
			pConnPt->Unadvise(dwCookie);
			pConnPt->Release();
		}

		pConnPtCont->Release();
	}
}

#define IMPLTYPE_MASK \
	(IMPLTYPEFLAG_FDEFAULT | IMPLTYPEFLAG_FSOURCE | IMPLTYPEFLAG_FRESTRICTED)

#define IMPLTYPE_DEFAULTSOURCE \
	(IMPLTYPEFLAG_FDEFAULT | IMPLTYPEFLAG_FSOURCE)

BOOL COleControlSite::GetEventIID(IID* piid)
{
	*piid = GUID_NULL;

	ASSERT(m_pObject != NULL);

	// Use IProvideClassInfo2, if control supports it.
	LPPROVIDECLASSINFO2 pPCI2 = NULL;

	if (SUCCEEDED(m_pObject->QueryInterface(IID_IProvideClassInfo2,
		(LPVOID*)&pPCI2)))
	{
		ASSERT(pPCI2 != NULL);

		if (SUCCEEDED(pPCI2->GetGUID(GUIDKIND_DEFAULT_SOURCE_DISP_IID, piid)))
			ASSERT(!IsEqualIID(*piid, GUID_NULL));
		else
			ASSERT(IsEqualIID(*piid, GUID_NULL));

		pPCI2->Release();
	}

	// Fall back on IProvideClassInfo, if IProvideClassInfo2 not supported.
	LPPROVIDECLASSINFO pPCI = NULL;

	if (IsEqualIID(*piid, GUID_NULL) &&
		SUCCEEDED(m_pObject->QueryInterface(IID_IProvideClassInfo,
		(LPVOID*)&pPCI)))
	{
		ASSERT(pPCI != NULL);

		LPTYPEINFO pClassInfo = NULL;

		if (SUCCEEDED(pPCI->GetClassInfo(&pClassInfo)))
		{
			ASSERT(pClassInfo != NULL);

			LPTYPEATTR pClassAttr;
			if (SUCCEEDED(pClassInfo->GetTypeAttr(&pClassAttr)))
			{
				ASSERT(pClassAttr != NULL);
				ASSERT(pClassAttr->typekind == TKIND_COCLASS);

				// Search for typeinfo of the default events interface.

				int nFlags;
				HREFTYPE hRefType;

				for (unsigned int i = 0; i < pClassAttr->cImplTypes; i++)
				{
					if (SUCCEEDED(pClassInfo->GetImplTypeFlags(i, &nFlags)) &&
						((nFlags & IMPLTYPE_MASK) == IMPLTYPE_DEFAULTSOURCE))
					{
						// Found it.  Now look at its attributes to get IID.

						LPTYPEINFO pEventInfo = NULL;

						if (SUCCEEDED(pClassInfo->GetRefTypeOfImplType(i,
								&hRefType)) &&
							SUCCEEDED(pClassInfo->GetRefTypeInfo(hRefType,
								&pEventInfo)))
						{
							ASSERT(pEventInfo != NULL);

							LPTYPEATTR pEventAttr;

							if (SUCCEEDED(pEventInfo->GetTypeAttr(&pEventAttr)))
							{
								ASSERT(pEventAttr != NULL);
								*piid = pEventAttr->guid;
								pEventInfo->ReleaseTypeAttr(pEventAttr);
							}

							pEventInfo->Release();
						}

						break;
					}
				}

				pClassInfo->ReleaseTypeAttr(pClassAttr);
			}

			pClassInfo->Release();
		}

		pPCI->Release();
	}

	return (!IsEqualIID(*piid, GUID_NULL));
}

void COleControlSite::GetControlInfo()
{
	memset(&m_ctlInfo, 0, sizeof(CONTROLINFO));
	m_ctlInfo.cb = sizeof(CONTROLINFO);
	LPOLECONTROL pOleCtl = NULL;
	ENSURE(m_pObject!=NULL);
	if (SUCCEEDED(m_pObject->QueryInterface(IID_IOleControl,
		(LPVOID*)&pOleCtl)))
	{
		ASSERT(pOleCtl != NULL);
		pOleCtl->GetControlInfo(&m_ctlInfo);
		pOleCtl->Release();
	}
}

BOOL COleControlSite::IsMatchingMnemonic(LPMSG lpMsg)
{
//  return IsAccelerator(m_ctlInfo.hAccel, m_ctlInfo.cAccel, lpMsg, NULL);

	if ((m_ctlInfo.cAccel == 0) || (m_ctlInfo.hAccel == NULL))
		return FALSE;

	ACCEL* pAccel = new ACCEL[m_ctlInfo.cAccel];
	int cAccel = CopyAcceleratorTable(m_ctlInfo.hAccel, pAccel, m_ctlInfo.cAccel);
	ASSERT(cAccel == m_ctlInfo.cAccel);

	BOOL bMatch = FALSE;
	for (int i = 0; i < cAccel; i++)
	{
		ENSURE_ARG(lpMsg!=NULL);
		BOOL fVirt = (lpMsg->message == WM_SYSCHAR ? FALT : 0);
		WORD key = LOWORD(lpMsg->wParam);
		if (((pAccel[i].fVirt & ~FNOINVERT) == fVirt) &&
			(pAccel[i].key == key))
		{
			bMatch = TRUE;
			break;
		}
	}

	delete [] pAccel;
	return bMatch;
}

void COleControlSite::SendMnemonic(LPMSG lpMsg)
{
	if (!(m_dwMiscStatus & OLEMISC_NOUIACTIVATE))
		SetFocus();

	LPOLECONTROL pOleCtl = NULL;

	ENSURE(m_pObject!=NULL);
	if (SUCCEEDED(m_pObject->QueryInterface(IID_IOleControl,
		(LPVOID*)&pOleCtl)))
	{
		ENSURE(pOleCtl != NULL);
		pOleCtl->OnMnemonic(lpMsg);
		pOleCtl->Release();
	}
}

void COleControlSite::FreezeEvents(BOOL bFreeze)
{
	ENSURE(m_pObject!=NULL);
	LPOLECONTROL pOleCtl = NULL;
	if (SUCCEEDED(m_pObject->QueryInterface(IID_IOleControl,
		(LPVOID*)&pOleCtl)))
	{
		ENSURE(pOleCtl != NULL);
		pOleCtl->FreezeEvents(bFreeze);
		pOleCtl->Release();
	}
}

void COleControlSite::AttachWindow()
{
	ENSURE_ARG(m_pInPlaceObject!=NULL);
	HWND hWnd = NULL;
	if (SUCCEEDED(m_pInPlaceObject->GetWindow(&hWnd)))
	{
		ASSERT(hWnd != NULL);
		if (m_hWnd != hWnd)
		{
			m_hWnd = hWnd;

			if (m_pWndCtrl != NULL)
			{
				ASSERT(m_pWndCtrl->m_hWnd == NULL); // Window already attached?
				m_pWndCtrl->Attach(m_hWnd);

				ASSERT(m_pWndCtrl->m_pCtrlSite == NULL ||
					m_pWndCtrl->m_pCtrlSite == this);
				m_pWndCtrl->m_pCtrlSite = this;
			}
		}
	}
}

void COleControlSite::DetachWindow()
{
	m_hWnd = NULL;

	if (m_pWndCtrl != NULL)
	{
		if (m_pWndCtrl->m_hWnd != NULL)
		{
			WNDPROC* lplpfn = m_pWndCtrl->GetSuperWndProcAddr();
			ASSERT(lplpfn != NULL);
			if (::IsWindow(m_pWndCtrl->m_hWnd) && *lplpfn != NULL)
				m_pWndCtrl->UnsubclassWindow();

			m_pWndCtrl->Detach();
		}

		m_pWndCtrl->m_pCtrlSite = NULL;
	}
}

BOOL COleControlSite::OnEvent(AFX_EVENT* pEvent)
{
	// If this control has a proxy CWnd, look for a matching ON_*_REFLECT
	// entry for this event in its event map.
	if ((m_pWndCtrl != NULL) &&
		m_pWndCtrl->OnCmdMsg(m_nID, CN_EVENT, pEvent, NULL))
	{
		return TRUE;
	}

	// Proxy CWnd isn't interested, so pass the event along to the container.
	ENSURE(m_pCtrlCont!=NULL && m_pCtrlCont->m_pWnd!=NULL);
	return m_pCtrlCont->m_pWnd->OnCmdMsg(m_nID, CN_EVENT, pEvent, NULL);
}

/////////////////////////////////////////////////////////////////////////////
// invoke helpers

void COleControlSite::InvokeHelperV(DISPID dwDispID, WORD wFlags,
	VARTYPE vtRet, void* pvRet, const BYTE* pbParamInfo, va_list argList)
{
	if (m_dispDriver.m_lpDispatch == NULL)
	{
		// no dispatch pointer yet; find it now
		LPDISPATCH pDispatch;

		if ((m_pObject != NULL) &&
			SUCCEEDED(m_pObject->QueryInterface(IID_IDispatch,
				(LPVOID*)&pDispatch)))
		{
			ASSERT(pDispatch != NULL);
			m_dispDriver.AttachDispatch(pDispatch);
		}
	}

	if (m_dispDriver.m_lpDispatch == NULL)
	{
		// couldn't find dispatch pointer
		TRACE(traceOle, 0, "Warning: control has no IDispatch interface.");
		return;
	}

	// delegate call to m_dispDriver
	m_dispDriver.InvokeHelperV(dwDispID, wFlags, vtRet, pvRet, pbParamInfo,
		argList);
}

void COleControlSite::SetPropertyV(DISPID dwDispID, VARTYPE vtProp, va_list argList)
{
	BYTE rgbParams[2];
	if (vtProp & VT_BYREF)
	{
		vtProp &= ~VT_BYREF;
		vtProp |= VT_MFCBYREF;
	}

#if !defined(_UNICODE)
	if (vtProp == VT_BSTR)
		vtProp = VT_BSTRA;
#endif

	WORD wFlags;
	if (vtProp & VT_MFCFORCEPUTREF)
	{
		wFlags = DISPATCH_PROPERTYPUTREF;
		vtProp &= ~VT_MFCFORCEPUTREF;
	}
	else
	{
		if (vtProp == VT_DISPATCH)
			wFlags = DISPATCH_PROPERTYPUTREF;
		else
			wFlags = DISPATCH_PROPERTYPUT;
	}

	rgbParams[0] = (BYTE)vtProp;
	rgbParams[1] = 0;
	InvokeHelperV(dwDispID, wFlags, VT_EMPTY, NULL, rgbParams, argList);
}

void AFX_CDECL COleControlSite::InvokeHelper(DISPID dwDispID, WORD wFlags, VARTYPE vtRet,
	void* pvRet, const BYTE* pbParamInfo, ...)
{
	va_list argList;
	va_start(argList, pbParamInfo);
	InvokeHelperV(dwDispID, wFlags, vtRet, pvRet, pbParamInfo, argList);
	va_end(argList);
}

void COleControlSite::GetProperty(DISPID dwDispID, VARTYPE vtProp,
	void* pvProp) const
{
	const_cast<COleControlSite*>(this)->InvokeHelper(dwDispID,
		DISPATCH_PROPERTYGET, vtProp, pvProp, NULL);
}

void AFX_CDECL COleControlSite::SetProperty(DISPID dwDispID, VARTYPE vtProp, ...)
{
	va_list argList;    // really only one arg, but...
	va_start(argList, vtProp);
	SetPropertyV(dwDispID, vtProp, argList);
	va_end(argList);
}

BOOL AFX_CDECL COleControlSite::SafeSetProperty(DISPID dwDispID, VARTYPE vtProp, ...)
{
	va_list argList;    // really only one arg, but...
	va_start(argList, vtProp);

	BOOL bSuccess;

	TRY
	{
		SetPropertyV(dwDispID, vtProp, argList);
		bSuccess = TRUE;
	}
	CATCH_ALL(e)
	{
		DELETE_EXCEPTION(e);
		bSuccess = FALSE;
	}
	END_CATCH_ALL

	va_end(argList);
	return bSuccess;
}

/////////////////////////////////////////////////////////////////////////////
// special cases for CWnd functions

DWORD COleControlSite::GetStyle() const
{
	DWORD dwStyle = m_dwStyle;

	//For windowed ActiveX controls, get visible and disabled styles from Win32 HWND.
	if(!m_bIsWindowless)
	{
		dwStyle |= (::GetWindowLong(m_hWnd, GWL_STYLE) & (WS_VISIBLE|WS_DISABLED) );
	}

	TRY
	{
		//Override Win32 with DISPID_ENABLED, if control implement it.
		BOOL bEnabled = TRUE;
		GetProperty(DISPID_ENABLED, VT_BOOL, &bEnabled);
		dwStyle = bEnabled ? dwStyle & ~WS_DISABLED : dwStyle | WS_DISABLED;		
	}
	END_TRY

	TRY
	{
		short sBorderStyle = 0;
		GetProperty(DISPID_BORDERSTYLE, VT_I2, &sBorderStyle);
		if (sBorderStyle == 1)
			dwStyle |= WS_BORDER;
	}
	END_TRY

	return dwStyle;
}

DWORD COleControlSite::GetExStyle() const
{
	DWORD dwExStyle = ::GetWindowLong(m_hWnd, GWL_EXSTYLE);

	TRY
	{
		short sAppearance = 0;
		GetProperty(DISPID_APPEARANCE, VT_I2, &sAppearance);
		if (sAppearance == 1)
			dwExStyle |= WS_EX_CLIENTEDGE;
	}
	END_TRY

	return dwExStyle;
}

BOOL COleControlSite::ModifyStyle(DWORD dwRemove, DWORD dwAdd, UINT nFlags)
{
	m_dwStyle = ((m_dwStyle & ~dwRemove) | dwAdd) & m_dwStyleMask;

	// Enabled property
	if ((dwRemove & WS_DISABLED) || (dwAdd & WS_DISABLED))
	{
		if (SafeSetProperty(DISPID_ENABLED, VT_BOOL, (~dwAdd & WS_DISABLED)))
		{
			dwRemove &= ~WS_DISABLED;
			dwAdd &= ~WS_DISABLED;
		}
	}

	// BorderStyle property
	if ((dwRemove & WS_BORDER) || (dwAdd & WS_BORDER))
	{
		if (SafeSetProperty(DISPID_BORDERSTYLE, VT_I2, (dwAdd & WS_BORDER)))
		{
			dwRemove &= ~WS_BORDER;
			dwAdd &= ~WS_BORDER;
		}
	}

   if( m_hWnd != NULL )
   {
	  return CWnd::ModifyStyle(m_hWnd, dwRemove, dwAdd, nFlags);
   }
   else
   {
	  return TRUE;
   }
}

BOOL COleControlSite::ModifyStyleEx(DWORD dwRemove, DWORD dwAdd, UINT nFlags)
{
	// BorderStyle property
	if ((dwRemove & WS_EX_CLIENTEDGE) || (dwAdd & WS_EX_CLIENTEDGE))
	{
		if (SafeSetProperty(DISPID_APPEARANCE, VT_I2, (dwAdd & WS_EX_CLIENTEDGE)))
		{
			dwRemove &= ~WS_EX_CLIENTEDGE;
			dwAdd &= ~WS_EX_CLIENTEDGE;
		}
	}

   if( m_hWnd != NULL )
   {
	   return CWnd::ModifyStyleEx(m_hWnd, dwRemove, dwAdd, nFlags);
   }
   else
   {
	  return TRUE;
   }
}

void COleControlSite::SetWindowText(LPCTSTR lpszString)
{
	// We do not assert m_hWnd is non-null since this is a valid case
	ENSURE(lpszString);

	if (!SafeSetProperty(DISPID_CAPTION, VT_BSTR, lpszString))
		SafeSetProperty(DISPID_TEXT, VT_BSTR, lpszString);
}

void COleControlSite::GetWindowText(CString& str) const
{
//	ASSERT(::IsWindow(m_hWnd));

	TRY
	{
		GetProperty(DISPID_CAPTION, VT_BSTR, &str);
	}
	CATCH_ALL(e)
	{
		DELETE_EXCEPTION(e);

		TRY
		{
			GetProperty(DISPID_TEXT, VT_BSTR, &str);
		}
		END_TRY
	}
	END_CATCH_ALL
}

int COleControlSite::GetDlgCtrlID() const
{
	return (int)m_nID;
}

int COleControlSite::SetDlgCtrlID(int nID)
{
	int nPrevID = (int)m_nID;
	m_nID = (UINT)nID;
	return nPrevID;
}

void COleControlSite::MoveWindow(int x, int y, int nWidth, int nHeight)
{
	ENSURE(m_pInPlaceObject != NULL);
	ENSURE(m_pObject != NULL);

	CRect rectOld(m_rect);
	m_rect.SetRect(x, y, x + nWidth, y + nHeight);
	if (SetExtent())
	{
		m_rect.SetRect(x, y, x + m_rect.Width(), y + m_rect.Height());
		m_pInPlaceObject->SetObjectRects(m_rect, m_rect);
	}
	else
	{
		m_rect = rectOld;
	}
}

BOOL COleControlSite::SetWindowPos(const CWnd* pWndInsertAfter, int x, int y, int cx,
	int cy, UINT nFlags)
{
	if (nFlags & SWP_HIDEWINDOW)
		ShowWindow(SW_HIDE);

	if ((nFlags & (SWP_NOMOVE|SWP_NOSIZE)) != (SWP_NOMOVE|SWP_NOSIZE))
	{
		int xNew;
		int yNew;
		if (nFlags & SWP_NOMOVE)
		{
			xNew = m_rect.left;
			yNew = m_rect.top;
		}
		else
		{
			xNew = x;
			yNew = y;
		}

		int cxNew;
		int cyNew;
		if (nFlags & SWP_NOSIZE)
		{
			cxNew = m_rect.Width();
			cyNew = m_rect.Height();
		}
		else
		{
			cxNew = cx;
			cyNew = cy;
		}

		MoveWindow(xNew, yNew, cxNew, cyNew);
	}

	if (nFlags & SWP_SHOWWINDOW)
		ShowWindow(SW_SHOW);

	// we've handled hide, move, size, and show; let Windows do the rest
	nFlags &= ~(SWP_HIDEWINDOW|SWP_SHOWWINDOW);
	nFlags |= (SWP_NOMOVE|SWP_NOSIZE);
	return ::SetWindowPos(m_hWnd, pWndInsertAfter->GetSafeHwnd(),
		x, y, cx, cy, nFlags);
}

BOOL COleControlSite::ShowWindow(int nCmdShow)
{
	BOOL bReturn = ::IsWindowVisible(m_hWnd);
	int iVerb = 0;
	switch (nCmdShow)
	{
	case SW_SHOW:
	case SW_SHOWNORMAL:
	case SW_SHOWNOACTIVATE:
		iVerb = OLEIVERB_SHOW;
		break;

	case SW_HIDE:
		iVerb = OLEIVERB_HIDE;
		break;
	}

	if (iVerb != 0)
		DoVerb(iVerb);

	return bReturn;
}

BOOL COleControlSite::IsWindowEnabled() const
{
	BOOL bEnabled = TRUE;
	if(!m_bIsWindowless)
	{
		bEnabled = ::IsWindowEnabled(m_hWnd);
	}
	TRY
		GetProperty(DISPID_ENABLED, VT_BOOL, &bEnabled);
	END_TRY

	return bEnabled;
}

BOOL COleControlSite::EnableWindow(BOOL bEnable)
{
	BOOL bResult;
	TRY
	{
		GetProperty(DISPID_ENABLED, VT_BOOL, &bResult);
		bResult=!bResult; // return TRUE if previously disabled - as ::EnableWindow does.
		SetProperty(DISPID_ENABLED, VT_BOOL, bEnable);
	}
	CATCH(COleException, e)
	{
		//If Control doesn't implement DISPID_ENABLED and it is windowed ActiveX,
		//Use Win32.
		if (e->m_sc == DISP_E_MEMBERNOTFOUND &&
			!m_bIsWindowless)
		{
			bResult=::EnableWindow(m_hWnd,bEnable);
		}
		DELETE_EXCEPTION(e);
	}
	CATCH_ALL(e)
	{
		DELETE_EXCEPTION(e);
		bResult = TRUE;
	}
	END_CATCH_ALL

	return bResult;    
}

CWnd* COleControlSite::SetFocus()
{
	if (m_dwMiscStatus & OLEMISC_NOUIACTIVATE)
   {
	  if (!m_bIsWindowless)
	  {
		   return CWnd::FromHandle(::SetFocus(m_hWnd));
	  }
   }

	CWnd* pWndPrev = CWnd::GetFocus();
	// don't UI-activate controls that are supposed to be invisible at runtime.
	if (0 == (m_dwMiscStatus & OLEMISC_INVISIBLEATRUNTIME))
	{
		HRESULT hr=	DoVerb(OLEIVERB_UIACTIVATE);
		if (SUCCEEDED(hr))
		{
			m_pCtrlCont->m_pSiteFocus = this;
		}
	}
	return pWndPrev;
}

CWnd* COleControlSite::SetFocus(LPMSG lpmsg)
{
	if (m_dwMiscStatus & OLEMISC_NOUIACTIVATE)
   {
	  if (!m_bIsWindowless)
	  {
		   return CWnd::FromHandle(::SetFocus(m_hWnd));
	  }
   }

	CWnd* pWndPrev = CWnd::GetFocus();
	// don't UI-activate controls that are supposed to be invisible at runtime.
	if (0 == (m_dwMiscStatus & OLEMISC_INVISIBLEATRUNTIME))
	{
		HRESULT hr=DoVerb(OLEIVERB_UIACTIVATE, lpmsg);
		if (SUCCEEDED(hr))
		{
			m_pCtrlCont->m_pSiteFocus = this;
		}
	}
	return pWndPrev;
}

void COleControlSite::EnableDSC()
{
	if (m_pDataSourceControl == NULL)
	{
		m_pDataSourceControl = new CDataSourceControl(this);
		m_pDataSourceControl->Initialize();
	}
}

void COleControlSite::BindDefaultProperty(DISPID dwDispID, VARTYPE vtProp, LPCTSTR szFieldName, CWnd* pDSCWnd)
{
	// Remove any previous binding
	if (m_pDSCSite != NULL)
	{
		m_pDSCSite->m_pDataSourceControl->BindProp(this, FALSE);
		m_pDSCSite->m_pDataSourceControl->BindColumns();
		m_pDSCSite = NULL;
	}

	if (pDSCWnd != NULL)
	{
		ASSERT(pDSCWnd->m_pCtrlSite);  // must be an OLE control
		pDSCWnd->m_pCtrlSite->EnableDSC();
		m_pDSCSite = pDSCWnd->m_pCtrlSite;
		m_defdispid = dwDispID;
		m_dwType = vtProp;
		m_strDataField = szFieldName;
		m_pDSCSite->m_pDataSourceControl->BindProp(this, TRUE);
		if (m_pDSCSite != NULL)
			m_pDSCSite->m_pDataSourceControl->BindColumns();
	}
}

void COleControlSite::BindProperty(DISPID dwDispId, CWnd* pWndDSC)
{
	ASSERT(pWndDSC == NULL || pWndDSC->m_pCtrlSite);
	if (pWndDSC != NULL && dwDispId != DISPID_UNKNOWN)
	{
		m_pBindings = new CDataBoundProperty(m_pBindings, dwDispId, 0);
		m_pBindings->m_pDSCSite = pWndDSC->m_pCtrlSite;
		m_pBindings->m_pClientSite = this;
		m_pBindings->m_pDSCSite->EnableDSC();
		m_pBindings->m_pDSCSite->m_pDataSourceControl->BindProp(m_pBindings, TRUE);
	}
	else
	{
		// Try and locate the particular property to unbind
		// if dwDispId == DISPID_UNKNOWN && pWndDSC == NULL it unbinds all properties
		// if dwDispId == DISPID_UNKNOWN && pWndDSC != NULL it unbinds properties for that DSC
		CDataBoundProperty *pCurrent = m_pBindings;
		CDataBoundProperty* pPrev = NULL;
		while (pCurrent != NULL)
		{
			CDataBoundProperty* pNext = pCurrent->GetNext();
			if (dwDispId == DISPID_UNKNOWN || pCurrent->m_dispid == dwDispId)
			{
				if (pWndDSC == NULL || pWndDSC->m_pCtrlSite == pCurrent->m_pDSCSite)
				{
					if (pPrev != NULL)
						pPrev->m_pNext = pNext;
					else
						m_pBindings = pNext;
					if (pCurrent->m_pDSCSite != NULL && pCurrent->m_pDSCSite->m_pDataSourceControl != NULL)
						pCurrent->m_pDSCSite->m_pDataSourceControl->BindProp(pCurrent, FALSE);
					delete pCurrent;
					break; // found, unbound, deleted, now exit
				}
			}
			pPrev = pCurrent;
			pCurrent = pNext;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// COleControlSite::XOleClientSite

STDMETHODIMP_(ULONG) COleControlSite::XOleClientSite::AddRef()
{
	METHOD_PROLOGUE_EX_(COleControlSite, OleClientSite)
	return (ULONG)pThis->InternalAddRef();
}

STDMETHODIMP_(ULONG) COleControlSite::XOleClientSite::Release()
{
	METHOD_PROLOGUE_EX_(COleControlSite, OleClientSite)
	return (ULONG)pThis->InternalRelease();
}

STDMETHODIMP COleControlSite::XOleClientSite::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(COleControlSite, OleClientSite)
	return (HRESULT)pThis->InternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP COleControlSite::XOleClientSite::SaveObject()
{
	return E_NOTIMPL;
}

STDMETHODIMP COleControlSite::XOleClientSite::GetMoniker(DWORD, DWORD,
	LPMONIKER*)
{
	return E_NOTIMPL;
}

STDMETHODIMP COleControlSite::XOleClientSite::GetContainer(
	LPOLECONTAINER* ppContainer)
{
	METHOD_PROLOGUE_EX_(COleControlSite, OleClientSite)
	return (HRESULT)pThis->m_pCtrlCont->InternalQueryInterface(
		&IID_IOleContainer, (LPVOID*)ppContainer);
}

STDMETHODIMP COleControlSite::XOleClientSite::ShowObject()
{
	METHOD_PROLOGUE_EX(COleControlSite, OleClientSite)
	pThis->AttachWindow();
	return S_OK;
}

STDMETHODIMP COleControlSite::XOleClientSite::OnShowWindow(BOOL)
{
	return S_OK;
}

STDMETHODIMP COleControlSite::XOleClientSite::RequestNewObjectLayout()
{
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// COleControlSite::XOleIPSite

STDMETHODIMP_(ULONG) COleControlSite::XOleIPSite::AddRef()
{
	METHOD_PROLOGUE_EX_(COleControlSite, OleIPSite)
	return (ULONG)pThis->InternalAddRef();
}

STDMETHODIMP_(ULONG) COleControlSite::XOleIPSite::Release()
{
	METHOD_PROLOGUE_EX_(COleControlSite, OleIPSite)
	return (ULONG)pThis->InternalRelease();
}

STDMETHODIMP COleControlSite::XOleIPSite::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(COleControlSite, OleIPSite)
	return (HRESULT)pThis->InternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP COleControlSite::XOleIPSite::GetWindow(HWND* phWnd)
{
	METHOD_PROLOGUE_EX_(COleControlSite, OleIPSite)
	*phWnd = pThis->m_pCtrlCont->m_pWnd->GetSafeHwnd();
	return *phWnd != NULL ? S_OK : E_FAIL;
}

STDMETHODIMP COleControlSite::XOleIPSite::ContextSensitiveHelp(BOOL)
{
	return E_NOTIMPL;
}

STDMETHODIMP COleControlSite::XOleIPSite::CanInPlaceActivate()
{
	return S_OK;
}

STDMETHODIMP COleControlSite::XOleIPSite::OnInPlaceActivate()
{
	return S_OK;
}

STDMETHODIMP COleControlSite::XOleIPSite::OnUIActivate()
{
	METHOD_PROLOGUE_EX_(COleControlSite, OleIPSite)
	ENSURE(pThis->m_pCtrlCont!=NULL);
	pThis->m_pCtrlCont->OnUIActivate(pThis);
	return S_OK;
}

STDMETHODIMP COleControlSite::XOleIPSite::GetWindowContext(
	LPOLEINPLACEFRAME* ppFrame, LPOLEINPLACEUIWINDOW* ppDoc, LPRECT prectPos,
	LPRECT prectClip, LPOLEINPLACEFRAMEINFO pFrameInfo)
{
	METHOD_PROLOGUE_EX(COleControlSite, OleIPSite)
	ASSERT_VALID(pThis->m_pCtrlCont);
	ASSERT_VALID(pThis->m_pCtrlCont->m_pWnd);

	ASSERT(AfxIsValidAddress(ppFrame, sizeof(LPOLEINPLACEFRAME)));
	ASSERT((ppDoc == NULL) ||
		AfxIsValidAddress(ppDoc, sizeof(LPOLEINPLACEUIWINDOW)));
	ASSERT(AfxIsValidAddress(prectPos, sizeof(RECT)));
	ASSERT(AfxIsValidAddress(prectClip, sizeof(RECT)));
	ASSERT(AfxIsValidAddress(pFrameInfo, pFrameInfo->cb));

	// This is a temporary patch for IE3 beta.  When IE3 is fixed, this
	// assert can be re-enabled.  Otherwise it fires everytime you browse via
	// the CWebBrowser control.
	//
	//  ASSERT(pFrameInfo->cb >= offsetof(OLEINPLACEFRAMEINFO, cAccelEntries) +
	//          sizeof(int));

	// There is no separate doc window
	if (ppDoc != NULL)
		*ppDoc = NULL;

	// Set pointer to frame
	if (FAILED(pThis->m_pCtrlCont->InternalQueryInterface(
		&IID_IOleInPlaceFrame, (LPVOID*)ppFrame)))
		return E_FAIL;

	// Fill in position and clip rectangles
	CWnd* pWndContainer = pThis->m_pCtrlCont->m_pWnd;
	CopyRect(prectPos, pThis->m_rect);
	pWndContainer->GetClientRect(prectClip);

	// Fill in frame info
	pFrameInfo->fMDIApp = FALSE;
	pFrameInfo->hwndFrame = pWndContainer->GetSafeHwnd();
	pFrameInfo->haccel = NULL;
	pFrameInfo->cAccelEntries = 0;

	return S_OK;
}

STDMETHODIMP COleControlSite::XOleIPSite::Scroll(SIZE)
{
	return S_FALSE;
}

STDMETHODIMP COleControlSite::XOleIPSite::OnUIDeactivate(BOOL)
{
	METHOD_PROLOGUE_EX_(COleControlSite, OleIPSite)
	pThis->m_pCtrlCont->OnUIDeactivate(pThis);
	return S_OK;
}

STDMETHODIMP COleControlSite::XOleIPSite::OnInPlaceDeactivate()
{
	METHOD_PROLOGUE_EX(COleControlSite, OleIPSite)
	pThis->DetachWindow();

   if (pThis->m_bIsWindowless)
   {
	  if (pThis->m_pWindowlessObject != NULL)
	  {
		 pThis->m_pWindowlessObject->Release();
		 pThis->m_pWindowlessObject = NULL;
	  }
	  pThis->m_pCtrlCont->m_nWindowlessControls--;
	  pThis->m_bIsWindowless = FALSE;
   }

	return S_OK;
}

STDMETHODIMP COleControlSite::XOleIPSite::DiscardUndoState()
{
	return S_OK;
}

STDMETHODIMP COleControlSite::XOleIPSite::DeactivateAndUndo()
{
	METHOD_PROLOGUE_EX_(COleControlSite, OleIPSite)
	ENSURE(pThis->m_pInPlaceObject!=NULL);
	pThis->m_pInPlaceObject->UIDeactivate();
	return S_OK;
}

STDMETHODIMP COleControlSite::XOleIPSite::OnPosRectChange(LPCRECT lprcPosRect)
{
	METHOD_PROLOGUE_EX_(COleControlSite, OleIPSite)
	ENSURE(pThis->m_pCtrlCont!=NULL && pThis->m_pCtrlCont->m_pWnd!=NULL);
	ENSURE(pThis->m_pInPlaceObject!=NULL);
	CRect rectClip;
	pThis->m_pCtrlCont->m_pWnd->GetClientRect(rectClip);
	pThis->m_rect = lprcPosRect;
	return pThis->m_pInPlaceObject->SetObjectRects(pThis->m_rect, rectClip);
}

STDMETHODIMP COleControlSite::XOleIPSite::
   OnInPlaceActivateEx( BOOL* ptNoRedraw, DWORD dwFlags )
{
   METHOD_PROLOGUE( COleControlSite, OleIPSite );

   ASSERT( !pThis->m_bIsWindowless );

   if( dwFlags&ACTIVATE_WINDOWLESS )
   {
	  ASSERT( pThis->m_pWindowlessObject == NULL );

	  pThis->m_pObject->QueryInterface(IID_IOleInPlaceObjectWindowless, 
		 (void**)&pThis->m_pWindowlessObject);
	  ASSERT( pThis->m_pWindowlessObject != NULL );
	  pThis->m_bIsWindowless = TRUE;
	 pThis->m_pCtrlCont->m_nWindowlessControls++;
//	  hResult = pThis->m_lpObject->QueryInterface(
//		 IID_IOleInPlaceObjectWindowless,
//		 (void**)&pThis->m_pOleInPlaceObjectWindowless );
//	  ASSERT( SUCCEEDED( hResult ) );
   }

   if( ptNoRedraw != NULL )
   {
	  *ptNoRedraw = FALSE;
   }

   return( S_OK );
}

STDMETHODIMP COleControlSite::XOleIPSite::
   OnInPlaceDeactivateEx( BOOL /* tNoRedraw */ )
{
   return( OnInPlaceDeactivate() );
}

STDMETHODIMP COleControlSite::XOleIPSite::
   RequestUIActivate()
{
   METHOD_PROLOGUE( COleControlSite, OleIPSite );

   return( S_OK );
}

STDMETHODIMP COleControlSite::XOleIPSite::AdjustRect(
   LPRECT /* prect */ )
{
   METHOD_PROLOGUE( COleControlSite, OleIPSite );

   return( E_NOTIMPL );
}

STDMETHODIMP COleControlSite::XOleIPSite::
   CanWindowlessActivate()
{
   METHOD_PROLOGUE( COleControlSite, OleIPSite );

   TRACE(traceOle, 0,  "Control wants to be windowless\n" );

	return( S_OK );
}

STDMETHODIMP COleControlSite::XOleIPSite::GetCapture()
{
   METHOD_PROLOGUE( COleControlSite, OleIPSite );

   if (pThis->m_pCtrlCont->m_pSiteCapture == pThis)
   {
	  return( S_OK );
   }
   else
   {
	  return( S_FALSE );
   }
}

STDMETHODIMP COleControlSite::XOleIPSite::GetDC(
   LPCRECT prect, DWORD /* dwFlags */, HDC* phDC )
{
   CWnd* pWnd;
   CRgn rgn;
   CRect rect;

   METHOD_PROLOGUE( COleControlSite, OleIPSite );

   ENSURE_ARG( phDC != NULL );
   *phDC = NULL;

   if( pThis->m_pDC != NULL )
   {
	  return( E_FAIL );
   }

   pWnd = pThis->m_pCtrlCont->m_pWnd;
   ASSERT( pWnd != NULL );

   pThis->m_pDC = pWnd->GetDC();
   if( pThis->m_pDC == NULL )
   {
	  return( E_FAIL );
   }

   if( prect == NULL )
   {
	  rect = pThis->m_rect;
   }
   else
   {
	  rect.IntersectRect( &pThis->m_rect, prect );
   }

   rgn.CreateRectRgnIndirect( &rect );
   pThis->m_pDC->SelectClipRgn( &rgn, RGN_AND );

   *phDC = pThis->m_pDC->GetSafeHdc();

   return( S_OK );
}

STDMETHODIMP COleControlSite::XOleIPSite::GetFocus()
{
   METHOD_PROLOGUE( COleControlSite, OleIPSite );

   return( E_NOTIMPL );
}

STDMETHODIMP COleControlSite::XOleIPSite::InvalidateRect(
   LPCRECT prect, BOOL bErase )
{
   CRect rect;

   METHOD_PROLOGUE( COleControlSite, OleIPSite );

   if( prect == NULL )
   {
	  rect = pThis->m_rect;
   }
   else
   {
	  // Intersect the given rectangle with the bounds of the object.
	  rect.IntersectRect( prect, &pThis->m_rect );

	  if( rect != *prect )
	  {
		 TRACE(traceOle, 0,  "Control tried to invalidate pixels outside its bounds.\n" );
	  }
   }

   if( !rect.IsRectEmpty() )
   {
	  pThis->m_pCtrlCont->m_pWnd->InvalidateRect( &rect, bErase );
   }

   return( S_OK );
}

STDMETHODIMP COleControlSite::XOleIPSite::InvalidateRgn(
   HRGN hRgn, BOOL bErase )
{
   CRgn rgn;
   CRgn* pRgn;
   CRect rectRgn;
   CRect rect;

   METHOD_PROLOGUE( COleControlSite, OleIPSite );

   if( hRgn == NULL )
   {
	  // The object wants its full extent invalidated.  It's much easier to do
	  // this with a rect than a region.
	  return( InvalidateRect( NULL, bErase ) );
   }

   pRgn = CRgn::FromHandle( hRgn );
   pRgn->GetRgnBox( &rectRgn );
   rect.IntersectRect( &rectRgn, &pThis->m_rect );
   if( rect != rectRgn )
   {
	  TRACE(traceOle, 0,  "Control tried to invalidate pixels outside its bounds.\n" );
	  return( InvalidateRect( NULL, bErase ) );
   }

   pThis->m_pCtrlCont->m_pWnd->InvalidateRgn( pRgn, bErase );

   return( S_OK );
}

STDMETHODIMP COleControlSite::XOleIPSite::
   OnDefWindowMessage( UINT /* nMessage */, WPARAM /* wParam */, LPARAM /* lParam */,
   LRESULT* /* plResult */ )
{
   METHOD_PROLOGUE( COleControlSite, OleIPSite );

   return( E_NOTIMPL );
}

STDMETHODIMP COleControlSite::XOleIPSite::ReleaseDC(
   HDC hDC )
{
   CWnd* pWnd;
   UNUSED( hDC );

   METHOD_PROLOGUE( COleControlSite, OleIPSite );

   pWnd = pThis->m_pCtrlCont->m_pWnd;
   ASSERT( pWnd != NULL );

   ASSERT( hDC == pThis->m_pDC->GetSafeHdc() );

   pWnd->ReleaseDC( pThis->m_pDC );
   pThis->m_pDC = NULL;

   return( S_OK );
}

STDMETHODIMP COleControlSite::XOleIPSite::ScrollRect(
   int /* dx */, int /* dy */, LPCRECT /* prectScroll */, LPCRECT /* prectClip */ )
{
   METHOD_PROLOGUE( COleControlSite, OleIPSite );

   return( E_NOTIMPL );
}

STDMETHODIMP COleControlSite::XOleIPSite::SetCapture(
   BOOL bCapture )
{
   METHOD_PROLOGUE( COleControlSite, OleIPSite );

   if (bCapture)
   {
	  pThis->m_pCtrlCont->m_pWnd->SetCapture();
	  pThis->m_pCtrlCont->m_pSiteCapture = pThis;
   }
   else
   {
	  pThis->m_pCtrlCont->m_pSiteCapture = NULL;
	  ReleaseCapture();
   }

   return( S_OK );
}

STDMETHODIMP COleControlSite::XOleIPSite::SetFocus(
   BOOL bFocus )
{
   METHOD_PROLOGUE( COleControlSite, OleIPSite );

   if (bFocus)
   {
	  pThis->m_pCtrlCont->m_pSiteFocus = pThis;
	  pThis->m_pCtrlCont->m_pWnd->SetFocus();
   }
   else
   {
	  pThis->m_pCtrlCont->m_pSiteFocus = NULL;
   }

   return( S_OK );
}


/////////////////////////////////////////////////////////////////////////////
// COleControlSite::XOleControlSite

STDMETHODIMP_(ULONG) COleControlSite::XOleControlSite::AddRef()
{
	METHOD_PROLOGUE_EX_(COleControlSite, OleControlSite)
	return (ULONG)pThis->InternalAddRef();
}

STDMETHODIMP_(ULONG) COleControlSite::XOleControlSite::Release()
{
	METHOD_PROLOGUE_EX_(COleControlSite, OleControlSite)
	return (ULONG)pThis->InternalRelease();
}

STDMETHODIMP COleControlSite::XOleControlSite::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(COleControlSite, OleControlSite)
	return (HRESULT)pThis->InternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP COleControlSite::XOleControlSite::OnControlInfoChanged()
{
	METHOD_PROLOGUE_EX_(COleControlSite, OleControlSite)
	pThis->GetControlInfo();
	return NOERROR;
}

STDMETHODIMP COleControlSite::XOleControlSite::LockInPlaceActive(BOOL)
{
	return E_NOTIMPL;
}

STDMETHODIMP COleControlSite::XOleControlSite::GetExtendedControl(
	LPDISPATCH*)
{
	return E_NOTIMPL;
}

STDMETHODIMP COleControlSite::XOleControlSite::TransformCoords(
	POINTL* pptHimetric, POINTF* pptContainer, DWORD dwFlags)
{
	METHOD_PROLOGUE_EX_(COleControlSite, OleControlSite)
	HRESULT hr = NOERROR;

	CDC dc;
	dc.Attach(::GetDC(pThis->m_hWnd));
	SIZE sz;

	if (dwFlags & XFORMCOORDS_HIMETRICTOCONTAINER)
	{
		sz.cx = pptHimetric->x;
		sz.cy = pptHimetric->y;
		dc.HIMETRICtoDP(&sz);

		if (dwFlags & XFORMCOORDS_SIZE)
		{
			pptContainer->x = (float)abs(sz.cx);
			pptContainer->y = (float)abs(sz.cy);
		}
		else if (dwFlags & XFORMCOORDS_POSITION)
		{
			pptContainer->x = (float)sz.cx;
			pptContainer->y = (float)sz.cy;
		}
		else
		{
			hr = E_INVALIDARG;
		}
	}
	else if (dwFlags & XFORMCOORDS_CONTAINERTOHIMETRIC)
	{
		sz.cx = (int)(pptContainer->x);
		sz.cy = (int)(pptContainer->y);
		dc.DPtoHIMETRIC(&sz);

		if (dwFlags & XFORMCOORDS_SIZE)
		{
			pptHimetric->x = abs(sz.cx);
			pptHimetric->y = abs(sz.cy);
		}
		else if (dwFlags & XFORMCOORDS_POSITION)
		{
			pptHimetric->x = sz.cx;
			pptHimetric->y = sz.cy;
		}
		else
		{
			hr = E_INVALIDARG;
		}
	}
	else
	{
		hr = E_INVALIDARG;
	}
	return hr;
}

STDMETHODIMP COleControlSite::XOleControlSite::TranslateAccelerator(
	LPMSG, DWORD)
{
	return E_NOTIMPL;
}

STDMETHODIMP COleControlSite::XOleControlSite::OnFocus(BOOL)
{
	return S_OK;
}

STDMETHODIMP COleControlSite::XOleControlSite::ShowPropertyFrame()
{
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// COleControlSite::XAmbientProps

STDMETHODIMP_(ULONG) COleControlSite::XAmbientProps::AddRef()
{
	METHOD_PROLOGUE_EX_(COleControlSite, AmbientProps)
	return (ULONG)pThis->InternalAddRef();
}

STDMETHODIMP_(ULONG) COleControlSite::XAmbientProps::Release()
{
	METHOD_PROLOGUE_EX_(COleControlSite, AmbientProps)
	return (ULONG)pThis->InternalRelease();
}

STDMETHODIMP COleControlSite::XAmbientProps::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(COleControlSite, AmbientProps)
	return (HRESULT)pThis->InternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP COleControlSite::XAmbientProps::GetTypeInfoCount(
	unsigned int*)
{
	return E_NOTIMPL;
}

STDMETHODIMP COleControlSite::XAmbientProps::GetTypeInfo(
	unsigned int, LCID, ITypeInfo**)
{
	return E_NOTIMPL;
}

STDMETHODIMP COleControlSite::XAmbientProps::GetIDsOfNames(
	REFIID, LPOLESTR*, unsigned int, LCID, DISPID*)
{
	return E_NOTIMPL;
}

STDMETHODIMP COleControlSite::XAmbientProps::Invoke(
	DISPID dispid, REFIID, LCID, unsigned short wFlags,
	DISPPARAMS* pDispParams, VARIANT* pvarResult,
	EXCEPINFO*, unsigned int*)
{
	UNUSED(wFlags);
	UNUSED(pDispParams);

	METHOD_PROLOGUE_EX(COleControlSite, AmbientProps)
	ASSERT(wFlags & DISPATCH_PROPERTYGET);
	ASSERT(pDispParams->cArgs == 0);

	ENSURE(pThis->m_pCtrlCont != NULL);
	ENSURE(pThis->m_pCtrlCont->m_pWnd != NULL);

	return pThis->m_pCtrlCont->m_pWnd->OnAmbientProperty(pThis, dispid, pvarResult) ?
		S_OK : DISP_E_MEMBERNOTFOUND;
}


/////////////////////////////////////////////////////////////////////////////
// COleControlSite::XPropertyNotifySink

STDMETHODIMP COleControlSite::XPropertyNotifySink::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(COleControlSite, PropertyNotifySink)

	if (IsEqualIID(iid, IID_IUnknown) ||
		IsEqualIID(iid, IID_IPropertyNotifySink))
	{
		*ppvObj = this;
		AddRef();
		return S_OK;
	}
	else
	{
		return E_NOINTERFACE;
	}
}

STDMETHODIMP_(ULONG) COleControlSite::XPropertyNotifySink::AddRef()
{
	return 1;
}

STDMETHODIMP_(ULONG) COleControlSite::XPropertyNotifySink::Release()
{
	return 0;
}

STDMETHODIMP COleControlSite::XPropertyNotifySink::OnChanged(
	DISPID dispid)
{
	METHOD_PROLOGUE_EX(COleControlSite, PropertyNotifySink)

	// If we are currently updating the control ignore notifications
	if (pThis->m_bIgnoreNotify)
		return S_OK;

	// Give user chance to override
	if (!pThis->m_pDataSourceControl)
	{
		AFX_EVENT event(AFX_EVENT::propChanged, dispid);
		pThis->OnEvent(&event);
		if (event.m_hResult != S_OK)
			return event.m_hResult;
	}

	if (pThis->m_defdispid == dispid)
	{
		::VariantClear(&pThis->m_varResult);

		HRESULT hRes;
		LPDISPATCH pDispatch = NULL;
		ENSURE(pThis->m_pObject!=NULL);
		hRes = pThis->m_pObject->QueryInterface(IID_IDispatch, (LPVOID *) &pDispatch);
		if (FAILED(hRes))
			return S_OK;

		EXCEPINFO excepinfo;
		memset(&excepinfo, 0, sizeof(EXCEPINFO));
		UINT uArgErr;
		DISPPARAMS dispparamsGetProp;
		memset (&dispparamsGetProp, 0, sizeof(DISPPARAMS));
		ENSURE(pDispatch!=NULL);
		hRes = pDispatch->Invoke(dispid, IID_NULL, 0, INVOKE_PROPERTYGET, &dispparamsGetProp,
				&pThis->m_varResult, &excepinfo, &uArgErr); //Get bound control property

		if (excepinfo.bstrSource)
			SysFreeString(excepinfo.bstrSource);
		if (excepinfo.bstrDescription)
			SysFreeString(excepinfo.bstrDescription);
		if (excepinfo.bstrHelpFile)
			SysFreeString(excepinfo.bstrHelpFile);

		pDispatch->Release();

		if (FAILED(hRes))
			return S_OK;

		pThis->m_bIsDirty = TRUE;
	}

	return S_OK;
}

STDMETHODIMP COleControlSite::XPropertyNotifySink::OnRequestEdit(
	DISPID dispid)
{
	METHOD_PROLOGUE_EX(COleControlSite, PropertyNotifySink)

	// If we are currently updating the control ignore notifications
	if (pThis->m_bIgnoreNotify)
		return S_OK;

	// If not bound fire regular MFC event
	if (!pThis->m_pDataSourceControl)
	{
		AFX_EVENT event(AFX_EVENT::propRequest, dispid);
		pThis->OnEvent(&event);
		if (event.m_hResult != S_OK)
			return event.m_hResult;
	}

	// Currently we only support Optimistic binding ala VB4
	// In this model, requests always succeed
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// COleControlSite::XEventSink

STDMETHODIMP_(ULONG) COleControlSite::XEventSink::AddRef()
{
	return 1;
}

STDMETHODIMP_(ULONG) COleControlSite::XEventSink::Release()
{
	return 0;
}

STDMETHODIMP COleControlSite::XEventSink::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(COleControlSite, EventSink)

	if (IsEqualIID(iid, IID_IUnknown) ||
		IsEqualIID(iid, IID_IDispatch) ||
		IsEqualIID(iid, pThis->m_iidEvents))
	{
		*ppvObj = this;
		AddRef();
		return S_OK;
	}
	else
	{
		return E_NOINTERFACE;
	}
}

STDMETHODIMP COleControlSite::XEventSink::GetTypeInfoCount(
	unsigned int*)
{
	return E_NOTIMPL;
}

STDMETHODIMP COleControlSite::XEventSink::GetTypeInfo(
	unsigned int, LCID, ITypeInfo**)
{
	return E_NOTIMPL;
}

STDMETHODIMP COleControlSite::XEventSink::GetIDsOfNames(
	REFIID, LPOLESTR*, unsigned int, LCID, DISPID*)
{
	return E_NOTIMPL;
}

STDMETHODIMP COleControlSite::XEventSink::Invoke(
	DISPID dispid, REFIID, LCID, unsigned short wFlags,
	DISPPARAMS* pDispParams, VARIANT* pvarResult,
	EXCEPINFO* pExcepInfo, unsigned int* puArgError)
{
	UNUSED(wFlags);

	METHOD_PROLOGUE_EX(COleControlSite, EventSink)
	ASSERT(pThis->m_pCtrlCont != NULL);
	ASSERT(pThis->m_pCtrlCont->m_pWnd != NULL);
	ASSERT(wFlags == DISPATCH_METHOD);

	AFX_EVENT event(AFX_EVENT::event, dispid, pDispParams, pExcepInfo,
		puArgError);

	pThis->OnEvent(&event);

	if (pvarResult != NULL)
		::VariantClear(pvarResult);

	return event.m_hResult;
}

/////////////////////////////////////////////////////////////////////////////
// CDataSourceControl


CDataSourceControl::CDataSourceControl(COleControlSite *pClientSite) :
	m_pClientSite(pClientSite),
	m_pCursorMove(NULL),
	m_pCursorUpdateARow(NULL),
	m_pMetaRowData(NULL),
	m_pVarData(NULL),
	m_nColumns(0),
	m_nBindings(0),
	m_pColumnBindings(NULL),
	m_pValues(NULL),
	m_bUpdateInProgress(FALSE),
	m_pDataSource(NULL),
	m_pRowPosition(NULL),
	m_pRowset(NULL),
	m_pDynamicAccessor(NULL),
	m_dwRowsetNotify(0)
{
	ASSERT(pClientSite);
}

CDataSourceControl::~CDataSourceControl()
{
	// cancel ole/db notifications
	if (m_dwRowsetNotify != 0 && m_pRowset != NULL)
	{
		LPCONNECTIONPOINTCONTAINER pConnPtCont;
		if (SUCCEEDED(m_pRowset->m_spRowset->QueryInterface(IID_IConnectionPointContainer,
				(LPVOID*)&pConnPtCont)) && pConnPtCont)
		{
			LPCONNECTIONPOINT pConnPt = NULL;

			if (SUCCEEDED(pConnPtCont->FindConnectionPoint(IID_IRowsetNotify, 
					&pConnPt)) && pConnPt)
			{
				pConnPt->Unadvise(m_dwRowsetNotify);
				pConnPt->Release();
			}
			pConnPtCont->Release();
		}
	}

	// Now go through all cursor bound properties
	while (!m_CursorBoundProps.IsEmpty())
	{
		CDataBoundProperty* pProp = (CDataBoundProperty*) m_CursorBoundProps.GetHead();
		if (!pProp || !pProp->m_pClientSite)
			break;
		pProp->m_pClientSite->BindProperty(pProp->m_dispid, NULL);
		pProp->m_pClientSite->m_pDSCSite = NULL;
	}
	m_CursorBoundProps.RemoveAll();

	if (m_pValues)
	{
		for (int i=0; i<m_nBindings; i++)
			::VariantClear(&m_pValues[i]);
		if (m_nBindings)
		{
			delete[] m_pColumnBindings;
			delete[] m_pValues;
		}
	}

	if (m_pCursorMove)
		m_pCursorMove->Release();

	if (m_pCursorUpdateARow)
		m_pCursorUpdateARow->Release();

	if (m_pMetaRowData)
	{
		for (int nCol = 0; nCol < m_nColumns; nCol++)
		{
			POSITION pos = m_pMetaRowData[nCol].m_pClientList->GetHeadPosition();
			while (pos)
			{
				COleControlSite* pSite = (COleControlSite *)
					m_pMetaRowData[nCol].m_pClientList->GetNext(pos);
				pSite->m_pDSCSite = NULL;
			}
			m_pMetaRowData[nCol].m_pClientList->RemoveAll();
			delete m_pMetaRowData[nCol].m_pClientList;
		}
		::CoTaskMemFree(m_pMetaRowData);
	}
	if (m_pVarData)
		::CoTaskMemFree(m_pVarData);

	if(m_pDynamicAccessor != NULL)
	{
		m_pDynamicAccessor->ReleaseAccessors(m_pRowset->m_spRowset);
		m_pDynamicAccessor->Close();
	}
	delete m_pDynamicAccessor;
	delete m_pRowset;
	if (m_pRowPosition != NULL)
		m_pRowPosition->Release();
	if (m_pDataSource != NULL)
		m_pDataSource->Release();
}

interface IVBDSC : public IUnknown
{
public:
	virtual HRESULT STDMETHODCALLTYPE CancelUnload(BOOL __RPC_FAR* pfCancel) = 0;
	virtual HRESULT STDMETHODCALLTYPE Error(DWORD dwErr, BOOL __RPC_FAR* pfShowError) = 0;
	virtual HRESULT STDMETHODCALLTYPE CreateCursor(ICursor __RPC_FAR* __RPC_FAR* ppCursor) = 0;
};

const IID IID_IVBDSC = {0x1ab42240,0x8c70,0x11ce,{0x94,0x21,0x0,0xaa,0x0,0x62,0xbe,0x57}};
const IID CLSID_DataAdapter = {0x3A08E130L,0x8F65,0x11D0,{0x94,0x84,0x00,0xA0,0xC9,0x11,0x10,0xED}};

HRESULT CDataSourceControl::Initialize()
{
	// The following is a work around for RDC behaviour when on an invisible dlg
	// When the dlg is invisible it cannot display the ODBC connect dialog
	// So check if visible, if not make it so and move it to the center
	// of the screen with null size. Then do the connect dialog
	// Finally put it all back like it was.
	ENSURE(m_pClientSite);
	ENSURE(m_pClientSite->m_pWndCtrl);
	CWnd* pParent = m_pClientSite->m_pWndCtrl->EnsureTopLevelParent();
	BOOL bHidden = !pParent->IsWindowVisible();
	CRect rcParent;
	if (bHidden)
	{
		CRect rcDesktop;
		CWnd::GetDesktopWindow()->GetWindowRect(&rcDesktop);
		pParent->GetWindowRect(&rcParent);
		pParent->MoveWindow((rcDesktop.right - rcDesktop.left)/2, (rcDesktop.bottom - rcDesktop.top)/2, 0, 0, FALSE);
		pParent->ShowWindow(SW_SHOWNORMAL);
	}
	IVBDSC* pDSC;
	HRESULT hRes;

	hRes = m_pClientSite->m_pObject->QueryInterface(IID_IDataSource, (void**)&m_pDataSource);
	if (SUCCEEDED(hRes))
	{
		hRes = m_pDataSource->GetDataMember(NULL, &IID_IRowPosition, (IUnknown**)&m_pRowPosition);
		if (m_pRowPosition == NULL)
			hRes = E_POINTER;

		if (FAILED(hRes))
		{
			if (bHidden)
			{
				pParent->MoveWindow(rcParent.left, rcParent.top, rcParent.right - rcParent.left, rcParent.bottom - rcParent.top, FALSE);
				pParent->ShowWindow(SW_HIDE);
			}
			return hRes;
		}
	}
	else
	{
		hRes = m_pClientSite->m_pObject->QueryInterface(IID_IVBDSC, (void**)&pDSC);
		if (FAILED(hRes))
			return hRes;
		ICursor* pCursor;
		pDSC->CreateCursor(&pCursor);
		pDSC->Release();
		if (!pCursor)
			return E_FAIL;

		hRes = pCursor->QueryInterface(IID_ICursorMove,
			(LPVOID *)&m_pCursorMove);

		pCursor->Release();

		if (FAILED(hRes))
			return hRes;

		hRes = m_pCursorMove->QueryInterface(IID_ICursorUpdateARow,
			(LPVOID *)&m_pCursorUpdateARow);
	}

	hRes = GetMetaData();

	if (bHidden)
	{
		pParent->MoveWindow(rcParent.left, rcParent.top, rcParent.right - rcParent.left, rcParent.bottom - rcParent.top, FALSE);
		pParent->ShowWindow(SW_HIDE);
	}

	return hRes;
}

IUnknown* CDataSourceControl::GetCursor()
{
	ASSERT(m_pClientSite != NULL);

	if (m_pDataSource != NULL)
	{
		if(m_pRowset != NULL)
			return m_pDataSource;
		return NULL;
	}

	ICursor* pCursor;
	if (!m_pCursorMove)
	{
		IVBDSC* pDSC;
		HRESULT hRes;
		hRes = m_pClientSite->m_pObject->QueryInterface(IID_IVBDSC, (void**)&pDSC);
		if (FAILED(hRes))
			return NULL;
		pDSC->CreateCursor(&pCursor);
		pDSC->Release();
		if (!pCursor)
			return NULL;
		return pCursor;
	}
	if (SUCCEEDED(m_pCursorMove->QueryInterface(IID_ICursor, (LPVOID *) &pCursor)))
			return pCursor;

	ASSERT(FALSE); // DSC Cursor Not Found
	return NULL;
}

HRESULT CDataSourceControl::GetMetaData()
{
	HRESULT hRes;
	METAROWTYPE* pOldMetaData = m_pMetaRowData;
	INT_PTR nOldColumns = m_nColumns;

	if (m_pDataSource != NULL)
	{
		IRowset* pRowset;

		hRes = m_pRowPosition->GetRowset(IID_IRowset, reinterpret_cast<IUnknown**>(&pRowset));
		if (FAILED(hRes))
			return hRes;

		{
			LPCONNECTIONPOINTCONTAINER pConnPtCont;

			if (SUCCEEDED(pRowset->QueryInterface(IID_IConnectionPointContainer,
					(LPVOID*)&pConnPtCont)))
			{
				ASSERT(pConnPtCont != NULL);
				LPCONNECTIONPOINT pConnPt = NULL;

				if (SUCCEEDED(pConnPtCont->FindConnectionPoint(IID_IRowsetNotify, &pConnPt)))
				{
					ASSERT(pConnPt != NULL);
					pConnPt->Advise(&m_pClientSite->m_xRowsetNotify, &m_dwRowsetNotify);
					pConnPt->Release();
				}

				pConnPtCont->Release();
			}
		}

		m_pRowset = new CRowset<>(pRowset);
		pRowset->Release();
		m_pRowset->SetupOptionalRowsetInterfaces();
		m_pDynamicAccessor = new CDynamicAccessor;
		m_pDynamicAccessor->BindColumns(m_pRowset->m_spRowset);
		m_pRowset->SetAccessor(m_pDynamicAccessor);
		m_nColumns = m_pDynamicAccessor->GetColumnCount();
		if (m_nColumns > (INT_MAX / sizeof(METAROWTYPE)))
		{
			return E_OUTOFMEMORY;
		}
		m_pMetaRowData = (METAROWTYPE*)::CoTaskMemAlloc(sizeof(METAROWTYPE) * m_nColumns);
		ENSURE_THROW(m_pMetaRowData != NULL, ::AfxThrowMemoryException() );
		memset(m_pMetaRowData, 0, sizeof(METAROWTYPE) * m_nColumns);
		m_pRowset->MoveFirst();
		m_pRowset->ReleaseRows();
	}
	else
	{
		ULONG_PTR nRows;
		ICursor* pCursor = (LPCURSOR)m_pCursorMove;
		ICursor* pColumnCursor;

		if (pCursor == NULL)
			return S_OK;

		hRes = pCursor->GetColumnsCursor(IID_ICursor, (IUnknown **) &pColumnCursor, &nRows);
		if (FAILED(hRes))
			return hRes;

		DBCOLUMNBINDING MetaColumns[2];
		CopyColumnID(&MetaColumns[0].columnID, &COLUMN_COLUMNID);
		MetaColumns[0].obData = offsetof(METAROWTYPE, idColumnID);
		MetaColumns[0].cbMaxLen = DB_NOMAXLENGTH;
		MetaColumns[0].obInfo = offsetof(METAROWTYPE, dwColumnID);
		MetaColumns[0].obVarDataLen = DB_NOVALUE;
		MetaColumns[0].dwBinding = DBBINDING_DEFAULT;
		MetaColumns[0].dwDataType = DBTYPE_COLUMNID;

		CopyColumnID(&MetaColumns[1].columnID, &COLUMN_NAME);
		MetaColumns[1].obData = offsetof(METAROWTYPE, lpstrName);
		MetaColumns[1].cbMaxLen = DB_NOMAXLENGTH;
		MetaColumns[1].obInfo = offsetof(METAROWTYPE, dwName);
		MetaColumns[1].obVarDataLen = DB_NOVALUE;
		MetaColumns[1].dwBinding = DBBINDING_DEFAULT;
		MetaColumns[1].dwDataType = VT_LPSTR;

		hRes = pColumnCursor->SetBindings(2, MetaColumns, sizeof(METAROWTYPE),
			DBCOLUMNBINDOPTS_REPLACE);
		if (FAILED(hRes))
		{
			pColumnCursor->Release();
			return hRes;
		}

		DBFETCHROWS FetchRows;
		FetchRows.cRowsRequested = nRows;
		FetchRows.dwFlags = DBROWFETCH_CALLEEALLOCATES;
		FetchRows.pData = NULL;
		FetchRows.pVarData = NULL;
		FetchRows.cbVarData = 0;

		LARGE_INTEGER dlZero;
		dlZero.QuadPart = 0;
		hRes = pColumnCursor->GetNextRows(dlZero, &FetchRows);
		if (FAILED(hRes))
		{
			pColumnCursor->Release();
			return hRes;
		}

		m_pMetaRowData = (METAROWTYPE *)FetchRows.pData;
		ASSERT(m_pMetaRowData);
		nRows = FetchRows.cRowsReturned;       // in case it changed
		m_pVarData = FetchRows.pVarData;

		m_nColumns = nRows;

		pColumnCursor->Release();
	}

	for (int nCol=0; nCol<m_nColumns; nCol++)
		m_pMetaRowData[nCol].m_pClientList = new CPtrList;

	// re-establish all bound property sites and then delete old meta-data
	if (pOldMetaData != NULL)
	{
		for (int nCol=0; nCol<nOldColumns; nCol++)
		{
			POSITION pos = pOldMetaData[nCol].m_pClientList->GetHeadPosition();
			while (pos)
			{
				COleControlSite* pSite = (COleControlSite *)
					m_pMetaRowData[nCol].m_pClientList->GetNext(pos);
				BindProp(pSite, TRUE);
			}
			pOldMetaData[nCol].m_pClientList->RemoveAll();
			delete pOldMetaData[nCol].m_pClientList;
		}
		::CoTaskMemFree(pOldMetaData);
	}

	return hRes;
}

BOOL CDataSourceControl::CopyColumnID(
	DBCOLUMNID* pcidDst, DBCOLUMNID const *pcidSrc)
{
	pcidDst->dwKind = pcidSrc->dwKind;

	switch (pcidSrc->dwKind)
	{
	case DBCOLKIND_GUID_NUMBER:
		pcidDst->guid = pcidSrc->guid;
		pcidDst->lNumber = pcidSrc->lNumber;
		break;
	case DBCOLKIND_GUID_NAME:
		pcidDst->guid = pcidSrc->guid;
		// fall through
	case DBCOLKIND_NAME:
		{
			size_t cch = ldbstrlen(pcidSrc->lpdbsz) + 1;
			if(cch>ULONG_MAX)
			{
				return FALSE;
			}
			ULONG ulChars=static_cast<ULONG>(cch);		
			pcidDst->lpdbsz = (LPDBSTR) ::ATL::AtlCoTaskMemCAlloc(static_cast<ULONG>(sizeof(DBCHAR)), ulChars);
			if (!pcidDst->lpdbsz)
				return FALSE;
			ldbstrcpy_s(pcidDst->lpdbsz, cch, pcidSrc->lpdbsz);
			break;
		}
	}
	return TRUE;
}

// Make a bound control/bound property a consumer to a particular column in this DSC
void CDataSourceControl::BindProp(COleControlSite* pClientSite, BOOL bBind)
{
	ASSERT(pClientSite);

	if (bBind)
	{
		BindProp(pClientSite, FALSE);
		ASSERT(pClientSite->m_pDSCSite == m_pClientSite);
		if (m_pDataSource != NULL)
		{
			for (int nCol=0; nCol<m_nColumns; nCol++)
			{
				if (pClientSite->m_strDataField == CString(m_pDynamicAccessor->GetColumnName(nCol + 1)))
				{
					m_pMetaRowData[nCol].m_pClientList->AddTail(pClientSite);
					return;
				}
			}
		}
		else
		{
			for (int nCol=0; nCol<m_nColumns; nCol++)
			{
				if (m_pMetaRowData[nCol].lpstrName == NULL)
					continue;
				if (pClientSite->m_strDataField == CString(m_pMetaRowData[nCol].lpstrName))
				{
					m_pMetaRowData[nCol].m_pClientList->AddTail(pClientSite);
					return;
				}
			}
		}
		pClientSite->m_pDSCSite = NULL;
		return;
	}
	UpdateCursor();
	// UnBind
	for (int nCol=0; nCol<m_nColumns; nCol++)
	{
		POSITION pos = m_pMetaRowData[nCol].m_pClientList->GetHeadPosition();
		POSITION prev;
		while (pos)
		{
			prev = pos;
			COleControlSite* pSite = (COleControlSite *)
				m_pMetaRowData[nCol].m_pClientList->GetNext(pos);
			if (pSite == pClientSite)
			{
				m_pMetaRowData[nCol].m_pClientList->RemoveAt(prev);
				return;
			}
		}
	}
}

// Make a cursor bound control property a client to this control
void CDataSourceControl::BindProp(CDataBoundProperty* pProperty, BOOL bBind)
{
	ASSERT(pProperty);

	if (bBind)
	{
		BindProp(pProperty, FALSE);
		m_CursorBoundProps.AddTail(pProperty);
	}
	else
	{
		UpdateCursor();
		POSITION pos = m_CursorBoundProps.Find(pProperty);
		if (pos != NULL)
			m_CursorBoundProps.RemoveAt(pos);
	}
}

void CDataSourceControl::BindColumns()
{
	if (m_pDataSource != NULL)
	{
		// this is done automatically by CDynamicAccessor
		GetBoundClientRow();
		UpdateControls();
		return;
	}
	if (m_pValues)
	{
		for (INT_PTR i=0; i<m_nBindings; i++)
			::VariantClear(&m_pValues[i]);
		if (m_nBindings > 0)
		{
			delete[] m_pValues;
			delete[] m_pColumnBindings;
		}
		m_pValues = NULL;
	}
	m_nBindings = 0;
	INT_PTR nCol;
	for (nCol=0; nCol<m_nColumns; nCol++)
	{
		m_nBindings += m_pMetaRowData[nCol].m_pClientList->GetCount();
	}
	if (m_nBindings > 0)
		m_pColumnBindings = new DBCOLUMNBINDING[m_nBindings];
	int nItem = 0;
	for (nCol=0; nCol<m_nColumns; nCol++)
	{
		POSITION pos = m_pMetaRowData[nCol].m_pClientList->GetHeadPosition();
		while (pos)
		{
			COleControlSite* pSite = (COleControlSite *)
				m_pMetaRowData[nCol].m_pClientList->GetNext(pos);
			CopyColumnID(&m_pColumnBindings[nItem].columnID, &m_pMetaRowData[nCol].idColumnID);
			m_pColumnBindings[nItem].obData = sizeof(VARIANT) * nItem;
			m_pColumnBindings[nItem].cbMaxLen = DB_NOMAXLENGTH;
			m_pColumnBindings[nItem].obInfo = DB_NOVALUE;
			m_pColumnBindings[nItem].obVarDataLen = DB_NOVALUE;
			m_pColumnBindings[nItem].dwBinding = DBBINDING_VARIANT;
			m_pColumnBindings[nItem].dwDataType = pSite->m_dwType;
			nItem++;
		}
	}
	m_pCursorMove->SetBindings(m_nBindings, m_pColumnBindings,
		sizeof(VARIANT) * m_nBindings, DBCOLUMNBINDOPTS_REPLACE);

	if (m_nBindings)
		m_pValues = new VARIANT[m_nBindings];

	for (int i=0; i<m_nBindings; i++)
	{
		memset(&m_pValues[i], 0, sizeof(VARIANT));
		m_pValues[i].vt = VT_EMPTY;
	}

	GetBoundClientRow();
	UpdateControls();
}

HRESULT CDataSourceControl::GetBoundClientRow()
{
	DBFETCHROWS FetchRows;

	if (m_pDataSource != NULL)
	{
		if(m_pRowset == NULL)
			return S_OK;

		if(m_pRowset->m_hRow == NULL)
			return S_OK;

		return m_pRowset->GetData();
	}

	if (m_nBindings == 0)
		return S_OK;

	FetchRows.pData = m_pValues;
	FetchRows.pVarData = NULL;
	FetchRows.cbVarData = NULL;
	FetchRows.cRowsRequested = 1;
	FetchRows.dwFlags = 0;

	LARGE_INTEGER dl = { 0, 0};

	return m_pCursorMove->Move(1, (LPVOID)&DBBMK_CURRENT, dl, &FetchRows);
}

COleVariant CDataSourceControl::ToVariant(int nCol)
{
	ENSURE(m_pDataSource != NULL);
	ENSURE(m_pDynamicAccessor != NULL);
	COleVariant vt;
	DBSTATUS dbStatus=DBSTATUS_S_ISNULL;
	DBTYPE dbType;

	m_pDynamicAccessor->GetStatus(nCol, &dbStatus);
	if(dbStatus == DBSTATUS_S_ISNULL)
		return vt;                      // just return a blank variant

	if(!m_pDynamicAccessor->GetColumnType(nCol, &dbType))
		return vt;
	switch (dbType)
	{
	case DBTYPE_VARIANT:
		vt = COleVariant((LPCVARIANT)m_pDynamicAccessor->GetValue(nCol));
		break;
	case DBTYPE_STR:
		vt = COleVariant(CString((LPCSTR)m_pDynamicAccessor->GetValue(nCol)), VT_BSTR);
		break;
	case DBTYPE_WSTR:
	case DBTYPE_BSTR:
		vt = COleVariant(CString((LPCWSTR)m_pDynamicAccessor->GetValue(nCol)), VT_BSTR);
		break;
	case DBTYPE_I1:
	case DBTYPE_UI1:
		vt = COleVariant(*((BYTE*)m_pDynamicAccessor->GetValue(nCol)));
		break;
	case DBTYPE_I2:
	case DBTYPE_UI2:
		vt = COleVariant(*((short*)m_pDynamicAccessor->GetValue(nCol)));
		break;
	case DBTYPE_I4:
	case DBTYPE_UI4:
		vt = COleVariant(*((long*)m_pDynamicAccessor->GetValue(nCol)));
		break;
	case DBTYPE_R4:
		vt = COleVariant(*((float*)m_pDynamicAccessor->GetValue(nCol)));
		break;
	case DBTYPE_R8:
		vt = COleVariant(*((double*)m_pDynamicAccessor->GetValue(nCol)));
		break;
	case DBTYPE_BOOL:
		vt = COleVariant((short)*(BOOL*)m_pDynamicAccessor->GetValue(nCol), VT_BOOL);
		break;
	case DBTYPE_DATE:
		{
			COleDateTime dt(*((DATE*)m_pDynamicAccessor->GetValue(nCol)));
			vt = COleVariant(dt);
		}
		break;
	case DBTYPE_CY:
		{
			COleCurrency cy(*((CURRENCY*)m_pDynamicAccessor->GetValue(nCol)));
			vt = COleVariant(cy);
		}
		break;
	case DBTYPE_NUMERIC:
		{
			DB_NUMERIC num;

			if(m_pDynamicAccessor->GetValue(nCol, &num))
			{
				double dbl;

				dbl = (double)*((__int64*)num.val);
				while(num.scale-- > 0)
					dbl /= 10;
				if(num.sign == 0)
					dbl = -dbl;
				vt = COleVariant(dbl);
			}
		}
		break;
	case DBTYPE_DBDATE:
		{
			DBDATE dbDate;

			if(m_pDynamicAccessor->GetValue(nCol, &dbDate))
			{
				COleDateTime dt;

				dt.SetDate(dbDate.year, dbDate.month, dbDate.day);
				vt = COleVariant(dt);
			}
		}
		break;
	case DBTYPE_DBTIME:
		{
			DBTIME dbTime;

			if(m_pDynamicAccessor->GetValue(nCol, &dbTime))
			{
				COleDateTime dt;

				dt.SetTime(dbTime.hour, dbTime.minute, dbTime.second);
				vt = COleVariant(dt);
			}
		}
		break;
	case DBTYPE_DBTIMESTAMP:
		{
			DBTIMESTAMP dbTimeStamp;

			if(m_pDynamicAccessor->GetValue(nCol, &dbTimeStamp))
			{
				vt = COleVariant(COleDateTime(dbTimeStamp.year, dbTimeStamp.month, dbTimeStamp.day,
											  dbTimeStamp.hour, dbTimeStamp.minute, dbTimeStamp.second));
			}
		}
		break;
	case DBTYPE_NULL:
	case DBTYPE_EMPTY:
		break;
	default:
		TRACE(traceOle, 0, "Unsupported DBTYPE (%d) in column %d\n", dbType, nCol);
		break;
	}
	return vt;
}

HRESULT CDataSourceControl::UpdateControls()
{
	m_bUpdateInProgress = TRUE;
	int nItem = 0;
	for (int nCol = 0; nCol < m_nColumns; nCol++)
	{
		if (m_pMetaRowData[nCol].m_pClientList != NULL)
		{
			POSITION pos = m_pMetaRowData[nCol].m_pClientList->GetHeadPosition();
			while (pos)
			{
				COleControlSite* pSite = (COleControlSite *)
					m_pMetaRowData[nCol].m_pClientList->GetNext(pos);

				DISPPARAMS dispparamsSetProp;
				DISPID dispidNamed = DISPID_PROPERTYPUT;
				EXCEPINFO excepinfo;
				memset(&excepinfo, 0, sizeof(EXCEPINFO));

				UINT uArgErr;
					COleVariant vt;
					if (m_pDataSource != NULL)
					{
						 vt = ToVariant(nCol + 1);
						 dispparamsSetProp.rgvarg = &vt;
					}
					else
					{
						 dispparamsSetProp.rgvarg = &m_pValues[nItem];
					}
				dispparamsSetProp.rgdispidNamedArgs = &dispidNamed;
				dispparamsSetProp.cArgs = 1;
				dispparamsSetProp.cNamedArgs = 1;
				HRESULT hRes;
				LPDISPATCH pDispatch;
				pSite->m_bIgnoreNotify = TRUE;
				if (pSite->m_pObject == NULL)
					continue;

				hRes = pSite->m_pObject->QueryInterface(IID_IDispatch, (LPVOID *) &pDispatch);
				if (FAILED(hRes))
					continue;

				hRes = pDispatch->Invoke(pSite->m_defdispid, IID_NULL, 0, INVOKE_PROPERTYPUT, &dispparamsSetProp,
					NULL, &excepinfo, &uArgErr);    //Set the bound control property
				pDispatch->Release();
				pSite->m_bIgnoreNotify = FALSE;

				if (excepinfo.bstrSource)
					SysFreeString(excepinfo.bstrSource);
				if (excepinfo.bstrDescription)
					SysFreeString(excepinfo.bstrDescription);
				if (excepinfo.bstrHelpFile)
					SysFreeString(excepinfo.bstrHelpFile);

				nItem++;
			}
		}
	}
	m_bUpdateInProgress = FALSE;
	return S_OK;
}

HRESULT CDataSourceControl::UpdateCursor()
{
	HRESULT hRes;
	int nVariant = 0;
	int nDirtyField = 0;

	if (m_pDataSource != NULL)
	{
		if(m_pDynamicAccessor == NULL)
			return S_OK;
		// First go through all simple bound properties
		for (int nCol=1; nCol<=m_nColumns; nCol++)
		{
			if (m_pMetaRowData[nCol-1].m_pClientList != NULL)
			{
				POSITION pos = m_pMetaRowData[nCol - 1].m_pClientList->GetHeadPosition();
				while (pos)
				{
					COleControlSite* pSite = (COleControlSite *)
						m_pMetaRowData[nCol - 1].m_pClientList->GetNext(pos);
					DBTYPE dbType;

					if (pSite->m_bIsDirty)
					{
						pSite->m_bIsDirty = FALSE;

						nDirtyField++;
						if (nDirtyField == 1)
						{
							// UpdateinProgress semaphore - unexpected state
							ASSERT(!m_bUpdateInProgress);
							m_bUpdateInProgress = TRUE;
						}

						if (m_pDynamicAccessor->GetColumnType(nCol, &dbType) == FALSE)
						{
							// Control bound to a record source, but
							// not bound to a field(s)
							TRACE(traceOle, 0, "Column %d not bound\n", nCol);
							ASSERT(FALSE);
							continue;
						}

						COleVariant var(pSite->m_varResult);
						CManualAccessor accessor;

						// Create accessor for output column
						accessor.CreateAccessor(1, m_pDynamicAccessor->GetValue(nCol), m_pDynamicAccessor->m_pColumnInfo[nCol].ulColumnSize);
						accessor.AddBindEntry(m_pDynamicAccessor->m_pColumnInfo[nCol].iOrdinal,
							m_pDynamicAccessor->m_pColumnInfo[nCol].wType,
							m_pDynamicAccessor->m_pColumnInfo[nCol].ulColumnSize,
							m_pDynamicAccessor->GetValue(nCol));
						accessor.BindColumns(m_pRowset->m_spRowset);

						switch(dbType)
						{
						case DBTYPE_I2:
							var.ChangeType(VT_I2);
							m_pDynamicAccessor->SetValue(nCol, var.iVal);
							break;
						case DBTYPE_I4:
							var.ChangeType(VT_I4);
							m_pDynamicAccessor->SetValue(nCol, var.lVal);
							break;
						case DBTYPE_R4:
							var.ChangeType(VT_R4);
							m_pDynamicAccessor->SetValue(nCol, var.fltVal);
							break;
						case DBTYPE_R8:
							var.ChangeType(VT_R8);
							m_pDynamicAccessor->SetValue(nCol, var.dblVal);
							break;
						case DBTYPE_CY:
							var.ChangeType(VT_CY);
							*(CY*)m_pDynamicAccessor->GetValue(nCol) = var.cyVal;
							break;
						case DBTYPE_DATE:
							var.ChangeType(VT_DATE);
							m_pDynamicAccessor->SetValue(nCol, var.date);
							break;
						case DBTYPE_BSTR:
							{
								var.ChangeType(VT_BSTR);
								BSTR bstrTemp = NULL;
								m_pDynamicAccessor->GetValue(nCol, &bstrTemp);
                                ::SysFreeString(bstrTemp);
								BSTR bstrNewString = SysAllocString( var.bstrVal );
								m_pDynamicAccessor->SetValue(nCol, bstrNewString);
							}
							break;
						case DBTYPE_WSTR:
							{
								var.ChangeType(VT_BSTR);
								wchar_t* pwszData = (wchar_t*)m_pDynamicAccessor->GetValue(nCol);
								size_t dwColSize = m_pDynamicAccessor->m_pColumnInfo[nCol].ulColumnSize / sizeof(wchar_t);
								ATL_CRT_ERRORCHECK(wcsncpy_s(pwszData, dwColSize, var.bstrVal, dwColSize - 1));
							}
							break;
						case DBTYPE_BOOL:
							var.ChangeType(VT_BOOL);
							m_pDynamicAccessor->SetValue(nCol, var.boolVal);
							break;
						case DBTYPE_DECIMAL:
							var.ChangeType(VT_DECIMAL);
							m_pDynamicAccessor->SetValue(nCol, var.decVal);
							break;
						case DBTYPE_UI1:
							var.ChangeType(VT_UI1);
							m_pDynamicAccessor->SetValue(nCol, var.bVal);
							break;
						case DBTYPE_I1:
							var.ChangeType(VT_I1);
							m_pDynamicAccessor->SetValue(nCol, (signed char)var.cVal);
							break;
						case DBTYPE_UI2:
							var.ChangeType(VT_UI2);
							m_pDynamicAccessor->SetValue(nCol, var.uiVal);
							break;
						case DBTYPE_UI4:
							var.ChangeType(VT_UI4);
							m_pDynamicAccessor->SetValue(nCol, var.ulVal);
							break;
						case DBTYPE_STR:
							var.ChangeType(VT_BSTR);
							WideCharToMultiByte(CP_ACP, 0, var.bstrVal, -1, (char*)m_pDynamicAccessor->GetValue(nCol),
								(int)m_pDynamicAccessor->m_pColumnInfo[nCol].ulColumnSize, NULL, NULL);
							break;
						default:
							TRACE(traceOle, 0, "Unsupported DBTYPE (%d) in column %d\n", dbType, nCol);
							break;
						}

						m_pRowset->SetAccessor(&accessor);
						m_pRowset->SetData();
						m_pRowset->SetAccessor(m_pDynamicAccessor);

						::VariantClear(&pSite->m_varResult);
					}
					nVariant++;
				}
			}
		}
		if (nDirtyField > 0)
		{
			m_bUpdateInProgress = FALSE;
		}
		return S_OK;
	}
	// Do we have an updateable cursor?
	if (m_pCursorUpdateARow == NULL)
	{
		// If not attempt to get one
		hRes = m_pCursorMove->QueryInterface(IID_ICursorUpdateARow,
			(LPVOID *)&m_pCursorUpdateARow);

		if (FAILED(hRes))
			return S_OK; // no update cursor, so forget updating
	}

	// First go through all simple bound properties
	for (int nCol=0; nCol<m_nColumns; nCol++)
	{
		POSITION pos = m_pMetaRowData[nCol].m_pClientList->GetHeadPosition();
		while (pos)
		{
			COleControlSite* pSite = (COleControlSite *)
				m_pMetaRowData[nCol].m_pClientList->GetNext(pos);

			if (pSite->m_bIsDirty)
			{
				pSite->m_bIsDirty = FALSE;

				nDirtyField++;
				if (nDirtyField == 1)
				{
					DWORD dwEdit;
					hRes = m_pCursorUpdateARow->GetEditMode(&dwEdit);
					if (FAILED(hRes))
						return hRes;
					if (dwEdit == DBEDITMODE_NONE)
					{
						hRes = m_pCursorUpdateARow->BeginUpdate(DBROWACTION_UPDATE);
						if (FAILED(hRes))
							return hRes;
					}
					// UpdateinProgress semaphore - unexpected state
					ASSERT(!m_bUpdateInProgress);
					m_bUpdateInProgress = TRUE;
				}
				DBBINDPARAMS bpBindParams;
				DWORD dwIndicator = sizeof(VARIANT);
				COleVariant vt;
				switch (V_VT(&pSite->m_varResult))
				{
				case VT_EMPTY:
				case VT_NULL:
				case VT_ERROR:
					dwIndicator = DB_NULL;
					vt = pSite->m_varResult;
					break;
				case VT_BSTR:
					if(*pSite->m_varResult.bstrVal == 0)
					{
						dwIndicator = DB_NULL;
						break;
					}
				default:
					vt = pSite->m_varResult;
					break;
				}
				bpBindParams.cbMaxLen     = 0L;
				bpBindParams.dwBinding    = DBBINDING_VARIANT;
				bpBindParams.dwDataType   = m_pColumnBindings[nVariant].dwDataType;
				bpBindParams.cbVarDataLen = 0L;
				bpBindParams.dwInfo       = dwIndicator;
				bpBindParams.pData        = &vt;

				hRes = m_pCursorUpdateARow->SetColumn(&m_pColumnBindings[nVariant].columnID, &bpBindParams);

				::VariantClear(&pSite->m_varResult);
			}
			nVariant++;
		}
	}
	// Now go through all cursor bound properties
	POSITION pos = m_CursorBoundProps.GetHeadPosition();
	while (pos != NULL)
	{
		CDataBoundProperty* pProp = (CDataBoundProperty*) m_CursorBoundProps.GetNext(pos);
		if (pProp->m_pClientSite->m_pObject == NULL)
			continue;
		IBoundObject *pBO;
		if (SUCCEEDED(pProp->m_pClientSite->m_pObject->QueryInterface(IID_IBoundObject,
			(LPVOID *) &pBO)))
		{
			if (pBO->IsDirty(pProp->m_dispid) == S_OK)
			{
				nDirtyField++;
				if (nDirtyField == 1)
				{
					DWORD dwEdit;
					hRes = m_pCursorUpdateARow->GetEditMode(&dwEdit);
					if (FAILED(hRes))
						return hRes;
					if (dwEdit == DBEDITMODE_NONE)
					{
						hRes = m_pCursorUpdateARow->BeginUpdate(DBROWACTION_UPDATE);
						if (FAILED(hRes))
							return hRes;
					}
					// UpdateinProgress semaphore - unexpected state
					ASSERT(!m_bUpdateInProgress);
					m_bUpdateInProgress = TRUE;
				}
			}
			pBO->Release();
		}
	}

	if (nDirtyField > 0)
	{
		hRes = m_pCursorUpdateARow->Update(0,0,0);
		m_bUpdateInProgress = FALSE;
		if (FAILED(hRes))
		{
			// Update failed w/dirty controls
			ASSERT(hRes!= S_OK);
			UpdateControls();
			return hRes;
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDataBoundProperty Handles Databound Controls

CDataBoundProperty::CDataBoundProperty(CDataBoundProperty* pLast, DISPID dispid, WORD ctlid) :
	m_dispid(dispid),
	m_ctlid(ctlid),
	m_pClientSite(NULL),
	m_pDSCSite(NULL),
	m_bIsDirty(FALSE),
	m_pNext(pLast)
{
}

void CDataBoundProperty::SetClientSite(COleControlSite *pClientSite)
{
	m_pClientSite = pClientSite;
}


// (Re)bind a cursor bound property to a DSC
void CDataBoundProperty::SetDSCSite(COleControlSite *pDSCSite)
{
	if (m_pDSCSite == pDSCSite)
		return;
	m_pDSCSite = pDSCSite;
	Notify();
}

CDataBoundProperty* CDataBoundProperty::GetNext()
{
	return m_pNext;
}

void CDataBoundProperty::RemoveSource()
{
	m_pDSCSite = NULL;
	Notify();
}

void CDataBoundProperty::Notify()
{
	if (m_dispid != DISPID_DATASOURCE)
	{
		IBoundObject *pBO;
		if (m_pClientSite != NULL)
		{
			ENSURE(m_pClientSite->m_pObject!=NULL);
			if (SUCCEEDED(m_pClientSite->m_pObject->QueryInterface(IID_IBoundObject,
				(LPVOID *) &pBO)))
			{
				pBO->OnSourceChanged(m_dispid, m_pDSCSite != NULL, &m_bOwnXferOut);
				pBO->Release();
			}
			else
			{
				IUnknown* pUnk = GetCursor();
				if (pUnk != NULL)
				{
					VARTYPE vt = VT_UNKNOWN;
					if (m_pDSCSite->m_pDataSourceControl != NULL)
						vt |= VT_MFCFORCEPUTREF;
					m_pClientSite->SetProperty(m_dispid, vt, pUnk);
				}
			}
		}
	}
}

IUnknown* CDataBoundProperty::GetCursor()
{
	if(m_pDSCSite == NULL)
		return NULL;

	m_pDSCSite->EnableDSC();

	ASSERT(m_pDSCSite->m_pDataSourceControl);

	m_pDSCSite->m_pDataSourceControl->BindProp(this);

	return m_pDSCSite->m_pDataSourceControl->GetCursor();
}

/////////////////////////////////////////////////////////////////////////////
// COleControlSite::XBoundObjectSite

HRESULT COleControlSite::GetCursor(
	DISPID dispid, LPUNKNOWN* ppcursorOut, LPVOID *ppcidOut)
{
	if (ppcidOut != NULL)
		*ppcidOut = NULL;

	CDataBoundProperty* pBinding = m_pBindings;
	while (pBinding != NULL)
	{
		if (pBinding->m_dispid == dispid)
		{
			*ppcursorOut = pBinding->GetCursor();
			return S_OK;
		}
		pBinding = pBinding->GetNext();
	}
	return S_OK;
}

STDMETHODIMP_(ULONG) COleControlSite::XBoundObjectSite::AddRef()
{
	METHOD_PROLOGUE_EX(COleControlSite, BoundObjectSite)
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) COleControlSite::XBoundObjectSite::Release()
{
	METHOD_PROLOGUE_EX(COleControlSite, BoundObjectSite)
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP COleControlSite::XBoundObjectSite::QueryInterface(
	REFIID iid, LPVOID far * ppvObj)
{
	METHOD_PROLOGUE_EX(COleControlSite, BoundObjectSite)
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP COleControlSite::XBoundObjectSite::GetCursor(
	DISPID dispid, LPLPCURSOR ppcursorOut, LPVOID *ppcidOut)
{
	METHOD_PROLOGUE_EX(COleControlSite, BoundObjectSite)
	return pThis->GetCursor(dispid, (LPUNKNOWN*)ppcursorOut, ppcidOut);
}


/////////////////////////////////////////////////////////////////////////////
// COleControlSite::XNotifyDBEvents

STDMETHODIMP_(ULONG) COleControlSite::XNotifyDBEvents::AddRef()
{
	return 1;
}

STDMETHODIMP_(ULONG) COleControlSite::XNotifyDBEvents::Release()
{
	return 0;
}

STDMETHODIMP COleControlSite::XNotifyDBEvents::QueryInterface(
	REFIID iid, LPVOID far * ppvObj)
{
	METHOD_PROLOGUE_EX_(COleControlSite, NotifyDBEvents)

	if (IsEqualIID(iid, IID_IUnknown) ||
		IsEqualIID(iid, IID_INotifyDBEvents))
	{
		*ppvObj = this;
		AddRef();
		return S_OK;
	}
	else
	{
		return E_NOINTERFACE;
	}
}

STDMETHODIMP COleControlSite::XNotifyDBEvents::OKToDo(
	DWORD dwEventWhat, ULONG cReasons, DBNOTIFYREASON rgReasons[])
{
	METHOD_PROLOGUE_EX(COleControlSite, NotifyDBEvents)

	HRESULT hRes = FireEvent(dwEventWhat, cReasons, rgReasons,
		dscOKToDo);
	if (FAILED(hRes))
		return hRes;

	DWORD reason = rgReasons[0].dwReason;

	if (reason == DBREASON_SETCOLUMN ||
		reason == DBREASON_INSERTED ||
		reason == DBREASON_MODIFIED)
		return S_OK;

	// Mask out all notifications except as currency changes and update
	if (!(dwEventWhat & DBEVENT_CURRENT_ROW_CHANGED) &&
		reason != DBREASON_INSERTED &&
		reason != DBREASON_MODIFIED &&
		reason != DBREASON_DELETED &&
		reason != DBREASON_ADDNEW)
		return S_OK;

	CDataSourceControl* pDSC = pThis->m_pDataSourceControl;
	if (pDSC == NULL)
		return S_OK;

	if (!(dwEventWhat & DBEVENT_CURRENT_ROW_CHANGED))
		return S_OK;

	return pDSC->UpdateCursor();
}

STDMETHODIMP COleControlSite::XNotifyDBEvents::Cancelled(
	DWORD dwEventWhat, ULONG cReasons, DBNOTIFYREASON rgReasons[])
{
	METHOD_PROLOGUE_EX(COleControlSite, NotifyDBEvents)

	HRESULT hRes = FireEvent(dwEventWhat, cReasons, rgReasons,
		dscCancelled);
	if (FAILED(hRes))
		return hRes;

	return S_OK;
}

STDMETHODIMP COleControlSite::XNotifyDBEvents::SyncBefore(
	DWORD dwEventWhat, ULONG cReasons, DBNOTIFYREASON rgReasons[])
{
	METHOD_PROLOGUE_EX(COleControlSite, NotifyDBEvents)

	HRESULT hRes = FireEvent(dwEventWhat, cReasons, rgReasons,
		dscSyncBefore);
	if (FAILED(hRes))
		return hRes;

	DWORD reason = rgReasons[0].dwReason;

	// Mask out all notifications except as shown
	if (reason != DBREASON_INSERTED &&
		reason != DBREASON_MODIFIED &&
		reason != DBREASON_ADDNEW)
		return S_OK;

	CDataSourceControl* pDSC = pThis->m_pDataSourceControl;
	if (pDSC == NULL)
		return S_OK;

	if (dwEventWhat & DBEVENT_METADATA_CHANGED)
	{
		pDSC->UpdateCursor();
	}

	return S_OK;
}

STDMETHODIMP COleControlSite::XNotifyDBEvents::AboutToDo(
	DWORD dwEventWhat, ULONG cReasons, DBNOTIFYREASON rgReasons[])
{
	METHOD_PROLOGUE_EX(COleControlSite, NotifyDBEvents)

	HRESULT hRes = FireEvent(dwEventWhat, cReasons, rgReasons,
		dscAboutToDo);
	if (FAILED(hRes))
		return hRes;

	return S_OK;
}

STDMETHODIMP COleControlSite::XNotifyDBEvents::FailedToDo(
	DWORD dwEventWhat, ULONG cReasons, DBNOTIFYREASON rgReasons[])
{
	METHOD_PROLOGUE_EX(COleControlSite, NotifyDBEvents)

	HRESULT hRes = FireEvent(dwEventWhat, cReasons, rgReasons,
		dscFailedToDo);
	if (FAILED(hRes))
		return hRes;

	return S_OK;
}

STDMETHODIMP COleControlSite::XNotifyDBEvents::SyncAfter(
	DWORD dwEventWhat, ULONG cReasons, DBNOTIFYREASON rgReasons[])
{
	METHOD_PROLOGUE_EX(COleControlSite, NotifyDBEvents)

	HRESULT hRes = FireEvent(dwEventWhat, cReasons, rgReasons,
		dscSyncAfter);
	if (FAILED(hRes))
		return hRes;

	DWORD reason = rgReasons[0].dwReason;

	CDataSourceControl* pDSC = pThis->m_pDataSourceControl;
	if (pDSC == NULL)
		return S_OK;

	//Check semaphore - don't want to collect data during Update if it was due to a Move (it's a NOP!)
	if (pDSC->m_bUpdateInProgress ||
		reason == DBREASON_EDIT ||
		reason == DBREASON_SETCOLUMN)
		return S_OK;

	//Mask out all notifications except as shown
	if (!(dwEventWhat & (DBEVENT_CURRENT_ROW_CHANGED | DBEVENT_CURRENT_ROW_DATA_CHANGED)))
		return S_OK;

	if (reason != DBREASON_INSERTED &&
		reason != DBREASON_MODIFIED)
	{
		BOOL bUpdateInProgress = pDSC->m_bUpdateInProgress;
		pDSC->m_bUpdateInProgress = TRUE;
		pDSC->GetBoundClientRow();
		pDSC->m_bUpdateInProgress = bUpdateInProgress;
		pDSC->UpdateControls();
	}

	return S_OK;
}

STDMETHODIMP COleControlSite::XNotifyDBEvents::DidEvent(
	DWORD dwEventWhat, ULONG cReasons, DBNOTIFYREASON rgReasons[])
{
	METHOD_PROLOGUE_EX(COleControlSite, NotifyDBEvents)

	HRESULT hRes = FireEvent(dwEventWhat, cReasons, rgReasons,
		dscDidEvent);
	if (FAILED(hRes))
		return hRes;

	CDataSourceControl* pDSC = pThis->m_pDataSourceControl;
	if (pDSC == NULL)
		return S_OK;

	if (dwEventWhat & DBEVENT_METADATA_CHANGED)
	{
		BOOL bUpdateInProgress = pDSC->m_bUpdateInProgress;
		pDSC->m_bUpdateInProgress = TRUE;
		pDSC->GetBoundClientRow();
		pDSC->m_bUpdateInProgress = bUpdateInProgress;
		pDSC->UpdateControls();
	}

	return S_OK;
}


HRESULT COleControlSite::XNotifyDBEvents::FireEvent(
	DWORD dwEventWhat, ULONG cReasons, DBNOTIFYREASON rgReasons[], DSCSTATE nState)
{
	METHOD_PROLOGUE_EX_(COleControlSite, NotifyDBEvents)

	if (dwEventWhat & DBEVENT_CURRENT_ROW_CHANGED
		|| dwEventWhat & DBEVENT_CURRENT_ROW_DATA_CHANGED)
	{
		for (UINT i=0; i<cReasons; i++)
		{
			DSCREASON nReason = dscNoReason;
			switch (rgReasons[i].dwReason)
			{
			case DBREASON_CLOSE:
				nReason = dscClose;
				break;
			case DBREASON_FIND:
			case DBREASON_MOVE:
			case DBREASON_MOVEPERCENT:
			case DBREASON_NEWINDEX:
			case DBREASON_NEWPARAMETERS:
			case DBREASON_QUERYSPECCHANGED:
			case DBREASON_REFRESH:
			case DBREASON_SEEK:
			case DBREASON_SETRANGECHANGED:
				nReason = dscMove;
				break;
			case DBREASON_ADDNEW:
			case DBREASON_INSERTED:
				nReason = dscInsert;
				break;
			case DBREASON_EDIT:
				nReason = dscEdit;
				break;
			case DBREASON_MODIFIED:
			case DBREASON_RECALC:
			case DBREASON_ROLLBACK:
			case DBREASON_ROWFIXUP:
				nReason = dscModify;
				break;
			case DBREASON_DELETED:
				nReason = dscDelete;
				break;
			case DBREASON_COMMIT:
				nReason = dscCommit;
				break;
			}
			if (nReason != dscNoReason)
			{
				AFX_EVENT event(AFX_EVENT::propDSCNotify);
				event.m_nDSCState = nState;
				event.m_nDSCReason = nReason;
				pThis->OnEvent(&event);
				return event.m_hResult;
			}
		}
		return S_OK;
	}
	return S_OK;
}

STDMETHODIMP_(ULONG) COleControlSite::XRowsetNotify::AddRef()
{
	return 1;
}

STDMETHODIMP_(ULONG) COleControlSite::XRowsetNotify::Release()
{
	return 0;
}

STDMETHODIMP COleControlSite::XRowsetNotify::QueryInterface(
	REFIID iid, LPVOID far * ppvObj)
{
	METHOD_PROLOGUE_EX_(COleControlSite, RowsetNotify)

	if (IsEqualIID(iid, IID_IUnknown) ||
		IsEqualIID(iid, IID_IRowsetNotify))
	{
		*ppvObj = this;
		AddRef();
		return S_OK;
	}
	return E_NOINTERFACE;
}

STDMETHODIMP COleControlSite::XRowsetNotify::OnFieldChange(
	IRowset* /*pRowset*/, HROW /*hRow*/, DBORDINAL /*cColumns*/, DBORDINAL /*rgColumns*/[],
	DBREASON /*eReason*/, DBEVENTPHASE ePhase, BOOL /*fCantDeny*/)
{
	METHOD_PROLOGUE_EX(COleControlSite, RowsetNotify)

	DSCSTATE nState = dscNoState;
	switch(ePhase)
	{
	case DBEVENTPHASE_OKTODO:
		nState = dscOKToDo;
		break;
	case DBEVENTPHASE_ABOUTTODO:
		nState = dscAboutToDo;
		break;
	case DBEVENTPHASE_SYNCHAFTER:
		nState = dscSyncAfter;
		break;
	case DBEVENTPHASE_FAILEDTODO:
		nState = dscFailedToDo;
		break;
	case DBEVENTPHASE_DIDEVENT:
		nState = dscDidEvent;
		break;
	}
	if(nState == dscDidEvent)
	{
		CDataSourceControl* pDSC = pThis->m_pDataSourceControl;
		if (pDSC == NULL)
			return S_OK;

		if(pDSC->m_bUpdateInProgress == FALSE)
		{
			ASSERT(pDSC->m_pRowset);

			BOOL bUpdateInProgress = pDSC->m_bUpdateInProgress;
			pDSC->m_bUpdateInProgress = TRUE;
			pDSC->GetBoundClientRow();
			pDSC->m_bUpdateInProgress = bUpdateInProgress;
			pDSC->UpdateControls();
		}
	}

	AFX_EVENT event(AFX_EVENT::propDSCNotify);
	event.m_nDSCState = nState;
	event.m_nDSCReason = dscModify;
	pThis->OnEvent(&event);
	return event.m_hResult;
}

STDMETHODIMP COleControlSite::XRowsetNotify::OnRowChange(
	IRowset* /*pRowset*/, DBCOUNTITEM cRows, const HROW rghRows[],
	DBREASON eReason, DBEVENTPHASE ePhase, BOOL /*fCantDeny*/)
{
	METHOD_PROLOGUE_EX(COleControlSite, RowsetNotify)

	HRESULT hRes = S_OK;

	DSCSTATE nState = dscNoState;
	switch(ePhase)
	{
	case DBEVENTPHASE_OKTODO:
		nState = dscOKToDo;
		break;
	case DBEVENTPHASE_ABOUTTODO:
		nState = dscAboutToDo;
		break;
	case DBEVENTPHASE_SYNCHAFTER:
		nState = dscSyncAfter;
		break;
	case DBEVENTPHASE_FAILEDTODO:
		nState = dscFailedToDo;
		break;
	case DBEVENTPHASE_DIDEVENT:
		nState = dscDidEvent;
		break;
	}
	DSCREASON nReason = dscNoReason;
	switch(eReason)
	{
	case DBREASON_ROW_ACTIVATE:
		nReason = dscMove;
		break;
	case DBREASON_ROW_DELETE:
		nReason = dscDelete;
		break;
	case DBREASON_ROW_INSERT:
		nReason = dscInsert;
		break;
	case DBREASON_ROW_UPDATE:
		nReason = dscCommit;
		break;
	}
	CDataSourceControl* pDSC = pThis->m_pDataSourceControl;
	if (pDSC == NULL)
		return S_OK;

	ASSERT(pDSC->m_pRowset);

	if (nReason == dscCommit && nState == dscAboutToDo)
	{
		pDSC->UpdateCursor();
	}
	else if ((nReason == dscMove && cRows == 1) || (nState == dscSyncAfter && nReason == dscInsert))
	{
		pDSC->UpdateCursor();
		pDSC->m_pRowset->m_hRow = rghRows[0];

		BOOL bUpdateInProgress = pDSC->m_bUpdateInProgress;
		pDSC->m_bUpdateInProgress = TRUE;
		pDSC->GetBoundClientRow();
		pDSC->m_bUpdateInProgress = bUpdateInProgress;
		if(!pDSC->m_bUpdateInProgress)
			pDSC->UpdateControls();
	}
	if (nReason != dscNoReason)
	{
		AFX_EVENT event(AFX_EVENT::propDSCNotify);
		event.m_nDSCState = nState;
		event.m_nDSCReason = nReason;
		pThis->OnEvent(&event);
		hRes = event.m_hResult;
		if(FAILED(hRes))
			return hRes;
	}
	return S_OK;
}

STDMETHODIMP COleControlSite::XRowsetNotify::OnRowsetChange(
	IRowset* /*pRowset*/, DBREASON eReason, DBEVENTPHASE /*ePhase*/, BOOL /*fCantDeny*/)
{
	METHOD_PROLOGUE_EX(COleControlSite, RowsetNotify)

	if(eReason == DBREASON_ROWSET_CHANGED)
	{
		CDataSourceControl* pDSC = pThis->m_pDataSourceControl;
		if (pDSC == NULL)
			return S_OK;

		ENSURE(pDSC->m_pRowset);
		ENSURE(pDSC->m_pDynamicAccessor);

		pDSC->m_pDynamicAccessor->ReleaseAccessors(pDSC->m_pRowset->m_spRowset);
		pDSC->m_pDynamicAccessor->Close();
		pDSC->m_pDynamicAccessor->BindColumns(pDSC->m_pRowset->m_spRowset);
		if( pDSC->m_nColumns != (int)pDSC->m_pDynamicAccessor->GetColumnCount() )
		{
			pDSC->m_nColumns = pDSC->m_pDynamicAccessor->GetColumnCount();
			::CoTaskMemFree(pDSC->m_pMetaRowData);
            pDSC->m_pMetaRowData = (CDataSourceControl::METAROWTYPE*)::ATL::AtlCoTaskMemCAlloc(static_cast<ULONG>(sizeof(CDataSourceControl::METAROWTYPE)), static_cast<ULONG>(pDSC->m_nColumns));
			ASSERT(pDSC->m_pMetaRowData);
			memset(pDSC->m_pMetaRowData, 0, sizeof(CDataSourceControl::METAROWTYPE) * pDSC->m_nColumns);
		}
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\olecli2.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// COleFrameHook Construction & Destruction

COleFrameHook::COleFrameHook(CFrameWnd* pFrameWnd, COleClientItem* pItem)
{
	ASSERT_VALID(pItem);
	ASSERT_VALID(pFrameWnd);

	m_lpActiveObject = NULL;
	m_pActiveItem = pItem;
	m_pFrameWnd = pFrameWnd;
	m_hWnd = pFrameWnd->m_hWnd;
	m_bToolBarHidden = FALSE;
	m_hAccelTable = NULL;
	m_bInModalState = FALSE;
	m_nModelessCount = 0;
	pFrameWnd->m_pNotifyHook = this;    // assume start out hooked

	ASSERT_VALID(this);
}

COleFrameHook::~COleFrameHook()
{
	if (m_pFrameWnd != NULL)
	{
		ASSERT_VALID(m_pFrameWnd);
		if (m_pFrameWnd->m_pNotifyHook == this)
			m_pFrameWnd->m_pNotifyHook = NULL;
	}

	ASSERT_VALID(this);
}

/////////////////////////////////////////////////////////////////////////////
// COleFrameHook overrides

void COleFrameHook::OnRecalcLayout()
{
	ASSERT_VALID(this);

	if (m_lpActiveObject == NULL)
		return;

	// get current border size (without current server control bars)
	RECT rectBorder;
	m_pFrameWnd->NegotiateBorderSpace(CFrameWnd::borderGet, &rectBorder);

	// allow server to resize/move its control bars
	m_lpActiveObject->ResizeBorder(&rectBorder, &m_xOleInPlaceFrame,
		m_pActiveItem->m_pInPlaceFrame == this);
}

BOOL COleFrameHook::OnDocActivate(BOOL bActive)
{
	ASSERT_VALID(this);

	if (m_lpActiveObject == NULL)
		return TRUE;

	// allow server to do document activation related actions
	m_lpActiveObject->OnDocWindowActivate(bActive);

	// make sure window caption gets updated later
	COleFrameHook* pNotifyHook = m_pActiveItem->m_pInPlaceFrame;
	pNotifyHook->m_pFrameWnd->DelayUpdateFrameTitle();

	if (!bActive)
	{
		// clear border space
		pNotifyHook->m_xOleInPlaceFrame.SetBorderSpace(NULL);
		if (m_pActiveItem->m_pInPlaceDoc != NULL)
			m_pActiveItem->m_pInPlaceDoc->m_xOleInPlaceFrame.SetBorderSpace(NULL);

		// remove the menu hook when the doc is not active
		pNotifyHook->m_xOleInPlaceFrame.SetMenu(NULL, NULL, NULL);

		// unhook top-level frame if not needed
		if (pNotifyHook != this)
		{
			// shouldn't be removing some other hook
			ASSERT(pNotifyHook->m_pFrameWnd->m_pNotifyHook == pNotifyHook);
			pNotifyHook->m_pFrameWnd->m_pNotifyHook = NULL;
		}
	}
	else
	{
		// rehook top-level frame if necessary (no effect if top-level == doc-level)
		pNotifyHook->m_pFrameWnd->m_pNotifyHook = pNotifyHook;
	}

	// don't do default if activating
	return bActive;
}

BOOL COleFrameHook::OnContextHelp(BOOL bEnter)
{
	ASSERT_VALID(this);
	if (m_lpActiveObject == NULL || m_pActiveItem->m_pInPlaceFrame != this)
		return TRUE;

	// allow all servers to enter/exit context sensitive help mode
	return NotifyAllInPlace(bEnter, &COleFrameHook::DoContextSensitiveHelp);
}

/////////////////////////////////////////////////////////////////////////////
// COleFrameHook callbacks for the top-level frame

BOOL COleFrameHook::OnMenuSelect(UINT nItemID, UINT nFlags, HMENU hSysMenu)
{
	UNUSED_ALWAYS(nFlags);
	UNUSED_ALWAYS(nItemID);

	// if we're over a docobject item, we need to reflect messages

	COleDocObjectItem* pActiveDocObjectItem = DYNAMIC_DOWNCAST(COleDocObjectItem, m_pActiveItem);
	if (pActiveDocObjectItem != NULL)
	{
		CWnd* pWnd = pActiveDocObjectItem->GetInPlaceWindow();

		// if we're popping up a menu, figure out what menu is
		// apparing; if it's in the help menu and it's not the
		// first element, it's the object's menu.

		if (nFlags & MF_POPUP)
		{
			if (pActiveDocObjectItem->m_pHelpPopupMenu->GetSafeHmenu() ==
					hSysMenu)
			{
				pActiveDocObjectItem->m_bInHelpMenu = (nItemID != 0);

				if (pActiveDocObjectItem->m_bInHelpMenu && pWnd != NULL)
				{
					pWnd->SendMessage(WM_MENUSELECT,
						MAKEWPARAM(nItemID, nFlags), (LPARAM) hSysMenu);
					return TRUE;
				}
			}
		}
		else
		{
			if (pActiveDocObjectItem->m_bInHelpMenu && pWnd != NULL)
			{
				pWnd->SendMessage(WM_MENUSELECT,
					MAKEWPARAM(nItemID, nFlags), (LPARAM) hSysMenu);
				return TRUE;
			}
		}
	}

	return FALSE;
}

void COleFrameHook::OnInitMenu(CMenu* pMenu)
{
	UNUSED_ALWAYS(pMenu);

	// reset the help menu flag when a new menu is opening

	COleDocObjectItem* pActiveDocObjectItem = DYNAMIC_DOWNCAST(COleDocObjectItem, m_pActiveItem);
	if (pActiveDocObjectItem != NULL)
		pActiveDocObjectItem->m_bInHelpMenu = FALSE;

	return;
}

BOOL COleFrameHook::OnInitMenuPopup(CMenu* pMenu, int nIndex, BOOL bSysMenu)
{
	UNUSED_ALWAYS(nIndex);

	if (bSysMenu)
		return FALSE;

	COleDocObjectItem* pActiveDocObjectItem = DYNAMIC_DOWNCAST(COleDocObjectItem, m_pActiveItem);
	if (pActiveDocObjectItem == NULL)
		return FALSE;

	// if we're popping up a new menu, for the object,
	// reflect the message and don't let MFC handle it
	// with ON_COMMAND_UI stuff

	if (pActiveDocObjectItem->m_bInHelpMenu)
	{
		CWnd* pWnd = pActiveDocObjectItem->GetInPlaceWindow();
		if (pWnd != NULL)
		{
			pWnd->SendMessage(WM_INITMENUPOPUP, (WPARAM) pMenu->m_hMenu,
				MAKELPARAM(nIndex, bSysMenu));
			return TRUE;
		}
	}

	return FALSE;
}

BOOL COleFrameHook::OnPreTranslateMessage(MSG* pMsg)
{
	ASSERT_VALID(this);

	if (m_lpActiveObject == NULL || m_pActiveItem->m_pInPlaceFrame != this)
		return FALSE;

	// allow server to translate accelerators
	if (pMsg->message >= WM_KEYFIRST && pMsg->message <= WM_KEYLAST)
		return m_lpActiveObject->TranslateAccelerator(pMsg) == S_OK;

	// if we've finally gotten a WM_COMMAND message, make sure
	// that it is appropriately reflected to the docobject

	if (pMsg->message == WM_COMMAND)
	{
		COleDocObjectItem* pActiveDocObjectItem = DYNAMIC_DOWNCAST(COleDocObjectItem, m_pActiveItem);
		if (pActiveDocObjectItem != NULL)
		{
			LRESULT lResult = 0;
			if (pActiveDocObjectItem->m_bInHelpMenu)
			{
				CWnd* pWnd = pActiveDocObjectItem->GetInPlaceWindow();
				if (pWnd != NULL)
					lResult = pWnd->SendNotifyMessage(WM_COMMAND, pMsg->wParam, pMsg->lParam);
			}
			return (lResult != 0);
		}
	}

	return FALSE;
}

void COleFrameHook::OnActivate(BOOL bActive)
{
	ASSERT_VALID(this);

	if (m_lpActiveObject == NULL || m_pActiveItem->m_pInPlaceFrame != this)
		return;

	if (m_pFrameWnd->IsWindowEnabled())
	{
		// allow active server to do frame level activation
		m_lpActiveObject->OnFrameWindowActivate(bActive);
	}
}

void COleFrameHook::OnEnableModeless(BOOL bEnable)
{
	ASSERT_VALID(this);

	if (m_lpActiveObject == NULL || m_pActiveItem->m_pInPlaceFrame != this)
		return;

	// allow server to disable/enable modeless dialogs
	NotifyAllInPlace(bEnable, &COleFrameHook::DoEnableModeless);
}

BOOL COleFrameHook::OnUpdateFrameTitle()
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pActiveItem);

	if (m_lpActiveObject == NULL || m_pActiveItem->m_pInPlaceFrame != this)
		return FALSE;

	return m_pActiveItem->OnUpdateFrameTitle();
}

void COleFrameHook::OnPaletteChanged(CWnd* pFocusWnd)
{
	CWnd* pWnd = m_pActiveItem->GetInPlaceWindow();
	if (pWnd != NULL)
		pWnd->SendMessage(WM_PALETTECHANGED, (WPARAM)pFocusWnd->GetSafeHwnd());
}

BOOL COleFrameHook::OnQueryNewPalette()
{
	CWnd* pWnd = m_pActiveItem->GetInPlaceWindow();
	if (pWnd != NULL)
		return (pWnd->SendMessage(WM_QUERYNEWPALETTE) != 0);
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Helpers for notifications that have to affect all in-place windows

BOOL COleFrameHook::NotifyAllInPlace(
	BOOL bParam, BOOL (COleFrameHook::*pNotifyFunc)(BOOL bParam))
{
	ASSERT_VALID(this);
	HWND hWndFrame = m_hWnd;
	CWinApp* pApp = AfxGetApp();

	// no doc manager - no templates
	if (pApp->m_pDocManager == NULL)
		return TRUE;

	// walk all templates in the application
	CDocTemplate* pTemplate;
	POSITION pos = pApp->m_pDocManager->GetFirstDocTemplatePosition();
	while (pos != NULL)
	{
		pTemplate = pApp->m_pDocManager->GetNextDocTemplate(pos);
		ASSERT_VALID(pTemplate);
		ASSERT_KINDOF(CDocTemplate, pTemplate);

		// walk all documents in the template
		POSITION pos2 = pTemplate->GetFirstDocPosition();
		while (pos2)
		{
			COleDocument* pDoc = (COleDocument*)pTemplate->GetNextDoc(pos2);
			ASSERT_VALID(pDoc);
			if (pDoc->IsKindOf(RUNTIME_CLASS(COleDocument)))
			{
				// walk all COleClientItem objects in the document
				COleClientItem* pItem;
				POSITION pos3 = pDoc->GetStartPosition();
				while ((pItem = pDoc->GetNextClientItem(pos3)) != NULL)
				{
					if (pItem->m_pInPlaceFrame != NULL &&
						pItem->m_pInPlaceFrame->m_lpActiveObject != NULL &&
						pItem->m_pView != NULL &&
						AfxIsDescendant(hWndFrame, pItem->m_pView->m_hWnd))
					{
						// Whew!  Found an in-place active item that is
						//  part of this frame window hierarchy.
						COleFrameHook* pNotifyHook = pItem->m_pInPlaceFrame;
						if (!(pNotifyHook->*pNotifyFunc)(bParam))
							return FALSE;
					}
				}
			}
		}
	}
	return TRUE;
}

BOOL COleFrameHook::DoContextSensitiveHelp(BOOL bEnter)
{
	ASSERT_VALID(this);
	ASSERT(m_lpActiveObject != NULL);

	return !FAILED(m_lpActiveObject->ContextSensitiveHelp(bEnter));
}

BOOL COleFrameHook::DoEnableModeless(BOOL bEnable)
{
	ASSERT_VALID(this);
	ASSERT(m_lpActiveObject != NULL);

	// allow server to enable/disable any modeless windows
	if (!bEnable)
	{
		if (m_nModelessCount++ == 0)
			m_lpActiveObject->EnableModeless(FALSE);
	}
	else
	{
		if (m_nModelessCount != 0 && --m_nModelessCount == 0)
			m_lpActiveObject->EnableModeless(TRUE);
	}
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// COleClientItem - default in-place activation implementation

BOOL COleClientItem::CanActivate()
{
	// don't allow in-place activations with iconic aspect items
	if (m_nDrawAspect == DVASPECT_ICON)
		return FALSE;

	// if no view has been set, attempt to find suitable one.
	//  (necessary to get links to embeddings to work correctly)
	if (m_pView == NULL)
	{
		// only use pActivateView if this item is in same document
		_AFX_OLE_STATE* pOleState = _afxOleState;
		if (pOleState->m_pActivateView != NULL &&
			pOleState->m_pActivateView->GetDocument() != GetDocument())
		{
			pOleState->m_pActivateView = NULL;   // not in same document
		}

		CView* pView = pOleState->m_pActivateView;
		if (pView == NULL)
		{
			// no routing view available - try to use the one with focus
			CWnd* pWnd = CWnd::GetFocus();
			while (pWnd != NULL && !pWnd->IsKindOf(RUNTIME_CLASS(CView)))
				pWnd = pWnd->GetParent();
			pView = STATIC_DOWNCAST(CView, pWnd);

			if (pView == NULL)
			{
				// still no routing view available - just use first one
				COleDocument* pDoc = GetDocument();
				POSITION pos = pDoc->GetFirstViewPosition();
				pView = pDoc->GetNextView(pos);
			}
		}
		m_pView = pView;
	}

	return m_pView->GetSafeHwnd() != NULL;
}

void COleClientItem::OnActivate()
{
	ASSERT_VALID(this);

	// it is necessary to lock the object when it is in-place
	//  (without this, a link to an embedding may disconnect unexpectedly)
	if (!m_bLocked)
	{
		OleLockRunning(m_lpObject, TRUE, FALSE);
		m_bLocked = TRUE;
	}

	// notify the item of the state change
	if (m_nItemState != activeState)
	{
		OnChange(OLE_CHANGED_STATE, (DWORD)activeState);
		m_nItemState = activeState;
	}
}

void COleClientItem::OnActivateUI()
{
	ASSERT_VALID(this);

	CFrameWnd* pMainFrame;
	CFrameWnd* pDocFrame = NULL;
	if (OnGetWindowContext(&pMainFrame, &pDocFrame, NULL))
	{
		m_dwFrameMenuBarVisibility = pMainFrame->GetMenuBarVisibility();
		pMainFrame->SetMenuBarVisibility(AFX_MBV_KEEPVISIBLE);
	}

	// notify the item of the state change
	if (m_nItemState != activeUIState)
	{
		OnChange(OLE_CHANGED_STATE, (DWORD)activeUIState);
		m_nItemState = activeUIState;
	}

	// the container window must have WS_CLIPCHILDREN set
	ASSERT_VALID(m_pView);
	m_dwContainerStyle = m_pView->GetStyle();
	m_pView->ModifyStyle(0, WS_CLIPCHILDREN);

	// cache the server's HWND for later
	LPOLEINPLACEOBJECT lpInPlaceObject =
		QUERYINTERFACE(m_lpObject, IOleInPlaceObject);
	ASSERT(lpInPlaceObject != NULL);

	// get the HWND for the in-place active object
	HWND hWnd;
	if (lpInPlaceObject->GetWindow(&hWnd) != S_OK)
		hWnd = NULL;
	lpInPlaceObject->Release();
	m_hWndServer = hWnd;

	// make sure top-level frame is hooked
	if (m_pInPlaceFrame != NULL)
	{
		ASSERT_VALID(m_pInPlaceFrame->m_pFrameWnd);
		m_pInPlaceFrame->m_pFrameWnd->m_pNotifyHook = m_pInPlaceFrame;
	}
	// make sure doc-level frame is hooked
	if (m_pInPlaceDoc != NULL)
	{
		ASSERT_VALID(m_pInPlaceDoc->m_pFrameWnd);
		m_pInPlaceDoc->m_pFrameWnd->m_pNotifyHook = m_pInPlaceDoc;
	}
}

BOOL COleClientItem::OnShowControlBars(CFrameWnd* pFrameWnd, BOOL bShow)
{
	ASSERT_VALID(pFrameWnd);
	ASSERT_VALID(this);

	// show/hide all bars marked with CBRS_HIDE_INPLACE style
	BOOL bResult = FALSE;
	if (bShow)
	{
		POSITION pos = pFrameWnd->m_listControlBars.GetHeadPosition();
		while (pos)
		{
			CControlBar* pBar =
				(CControlBar*)pFrameWnd->m_listControlBars.GetNext(pos);
			ASSERT_VALID(pBar);
			if ((pBar->GetBarStyle() & CBRS_HIDE_INPLACE) &&
				(pBar->m_nStateFlags & CControlBar::tempHide))
			{
				pBar->m_nStateFlags &= ~CControlBar::tempHide;
				pFrameWnd->ShowControlBar(pBar, TRUE, TRUE);
				bResult = TRUE;
			}
		}
	}
	else
	{
		POSITION pos = pFrameWnd->m_listControlBars.GetHeadPosition();
		while (pos)
		{
			CControlBar* pBar =
				(CControlBar*)pFrameWnd->m_listControlBars.GetNext(pos);
			ASSERT_VALID(pBar);
			if (pBar->IsVisible() && (pBar->GetBarStyle() & CBRS_HIDE_INPLACE))
			{
				pBar->m_nStateFlags |= CControlBar::tempHide;
				pFrameWnd->ShowControlBar(pBar, FALSE, TRUE);
				bResult = TRUE;
			}
		}
	}
	return bResult;
}

BOOL COleClientItem::OnGetWindowContext(
	CFrameWnd** ppMainFrame, CFrameWnd** ppDocFrame,
	LPOLEINPLACEFRAMEINFO pFrameInfo)
{
	ASSERT(AfxIsValidAddress(ppMainFrame, sizeof(CFrameWnd*)));
	ASSERT(AfxIsValidAddress(ppDocFrame, sizeof(CFrameWnd*)));
	ASSERT(pFrameInfo == NULL ||
		AfxIsValidAddress(pFrameInfo, sizeof(OLEINPLACEFRAMEINFO)));
	ASSERT_VALID(this);
	ASSERT_VALID(m_pView);

	// get main window of application
	*ppMainFrame = m_pView->GetTopLevelFrame();
	ENSURE_VALID(*ppMainFrame);
	ASSERT_KINDOF(CFrameWnd, *ppMainFrame);

	// get document window (if there is one)
	CFrameWnd* pDocFrame = m_pView->GetParentFrame();
	if (pDocFrame != *ppMainFrame)
	{
		*ppDocFrame = pDocFrame;
		ASSERT_VALID(*ppDocFrame);
		ASSERT_KINDOF(CFrameWnd, *ppDocFrame);
	}

	if (pFrameInfo != NULL)
	{
		// get accelerator table
		CDocTemplate* pTemplate = GetDocument()->GetDocTemplate();
		HACCEL hAccel = pTemplate != NULL ? pTemplate->m_hAccelInPlace : NULL;
		pFrameInfo->cAccelEntries =
			hAccel != NULL ? CopyAcceleratorTable(hAccel, NULL, 0) : 0;
		pFrameInfo->haccel = pFrameInfo->cAccelEntries != 0 ? hAccel : NULL;
		pFrameInfo->hwndFrame = (*ppMainFrame)->m_hWnd;
		pFrameInfo->fMDIApp = *ppDocFrame != NULL;
	}
	return TRUE;
}

BOOL COleClientItem::OnScrollBy(CSize sizeExtent)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pView);

	// scroll through splitter or view
	CSplitterWnd* pSplitter = CView::GetParentSplitter(m_pView, FALSE);
	BOOL bResult;
	if (pSplitter != NULL)
		bResult = pSplitter->DoScrollBy(m_pView, sizeExtent);
	else
		bResult = m_pView->OnScrollBy(sizeExtent);

	return bResult;
}

void COleClientItem::OnDeactivateUI(BOOL /*bUndoable*/)
{
	ASSERT_VALID(this);

	// notify the item of the state change
	if (m_nItemState != activeState)
	{
		OnChange(OLE_CHANGED_STATE, (DWORD)activeState);
		m_nItemState = activeState;
	}

	if (m_pView != NULL && m_pDocument->GetFirstViewPosition())
	{
		// restore container window's WS_CLIPCHILDREN bit...
		ASSERT_VALID(m_pView);
		m_pView->ModifyStyle(WS_CLIPCHILDREN, m_dwContainerStyle & WS_CLIPCHILDREN);
	}

	// restore original user interface on the frame window
	CFrameWnd* pMainFrame;
	CFrameWnd* pDocFrame = NULL;
	if (OnGetWindowContext(&pMainFrame, &pDocFrame, NULL))
	{
		ENSURE(pMainFrame->GetMenuBarVisibility() == AFX_MBV_KEEPVISIBLE);
		pMainFrame->SetMenuBarVisibility(m_dwFrameMenuBarVisibility);

		ASSERT_VALID(pMainFrame);
		pMainFrame->DelayUpdateFrameTitle();
		if (pMainFrame->NegotiateBorderSpace(CFrameWnd::borderSet, NULL))
			pMainFrame->DelayRecalcLayout();

		// restore original user interface on the document window
		if (pDocFrame != NULL)
		{
			pDocFrame->DelayUpdateFrameTitle();
			if (pDocFrame->NegotiateBorderSpace(CFrameWnd::borderSet, NULL))
				pDocFrame->DelayRecalcLayout();
		}
	}

	// cleanup frame interfaces allocated in GetWindowContext
	if (m_pInPlaceFrame != NULL)
	{
		OnShowControlBars(m_pInPlaceFrame->m_pFrameWnd, TRUE);

		// release OLE frame window hooks and allow menu update
		::OleSetMenuDescriptor(NULL, m_pInPlaceFrame->m_pFrameWnd->m_hWnd,
			NULL, NULL, NULL);
		if (m_pInPlaceDoc != NULL)
		{
			::OleSetMenuDescriptor(NULL, m_pInPlaceDoc->m_pFrameWnd->m_hWnd,
				NULL, NULL, NULL);
		}
		m_pInPlaceFrame->m_pFrameWnd->DelayUpdateFrameMenu(NULL);

		// unhook from frame window
		if (m_pInPlaceFrame->m_pFrameWnd->m_pNotifyHook == m_pInPlaceFrame)
			m_pInPlaceFrame->m_pFrameWnd->m_pNotifyHook = NULL;

		// cleanup document interfaces allocated in GetWindowContext
		if (m_pInPlaceDoc != NULL)
		{
			OnShowControlBars(m_pInPlaceDoc->m_pFrameWnd, TRUE);

			// unhook from frame window
			if (m_pInPlaceDoc->m_pFrameWnd->m_pNotifyHook == m_pInPlaceDoc)
				m_pInPlaceDoc->m_pFrameWnd->m_pNotifyHook = NULL;
		}
	}

	// reset server HWND -- no longer necessary
	m_hWndServer = NULL;

	CWnd* pWnd = AfxGetMainWnd();
	if (pWnd != NULL)
	{
		// set focus back to the container
		pWnd = pWnd->EnsureTopLevelParent();
		if (::GetActiveWindow() == pWnd->m_hWnd)
		{
			pWnd->SetFocus();
		}
	}
}

void COleClientItem::OnDeactivate()
{
	ASSERT_VALID(this);

	// notify the item of the state change
	if (m_nItemState != loadedState)
	{
		OnChange(OLE_CHANGED_STATE, (DWORD)loadedState);
		m_nItemState = loadedState;
	}

	// cleanup frame interfaces allocated in GetWindowContext
	if (m_pInPlaceFrame != NULL)
	{
		// release in place frame
		if (m_pInPlaceFrame->m_pFrameWnd->m_pNotifyHook == m_pInPlaceFrame)
			m_pInPlaceFrame->m_pFrameWnd->m_pNotifyHook =  NULL;
		m_pInPlaceFrame->InternalRelease();
		m_pInPlaceFrame = NULL;

		// cleanup document interfaces allocated in GetWindowContext
		if (m_pInPlaceDoc != NULL)
		{
			// release in place document
			if (m_pInPlaceDoc->m_pFrameWnd->m_pNotifyHook == m_pInPlaceDoc)
				m_pInPlaceDoc->m_pFrameWnd->m_pNotifyHook = NULL;
			m_pInPlaceDoc->InternalRelease();
			m_pInPlaceDoc = NULL;
		}
	}

	// both frame-level and doc-level interfaces should be cleaned up
	ASSERT(m_pInPlaceFrame == NULL);
	ASSERT(m_pInPlaceDoc == NULL);

	// no longer need the container window
	m_pView = NULL;
}

void COleClientItem::OnDiscardUndoState()
{
	ASSERT_VALID(this);

	// default does nothing
}

void COleClientItem::OnDeactivateAndUndo()
{
	ASSERT_VALID(this);

	DeactivateUI(); // default is to UI deactivate
}

BOOL COleClientItem::OnChangeItemPosition(const CRect& rectPos)
{
	if (!IsInPlaceActive())
		return FALSE;

	ASSERT_VALID(this);
	ASSERT(AfxIsValidAddress(&rectPos, sizeof(CRect), FALSE));
	ASSERT_VALID(m_pView);

	// determine the visible rect based on intersection between client rect
	CRect clipRect;
	OnGetClipRect(clipRect);
	CRect visRect;
	visRect.IntersectRect(clipRect, rectPos);

	// advise the server of the new visible rectangle
	if (!visRect.IsRectEmpty())
		return SetItemRects(&rectPos, &clipRect);

	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// IOleInPlaceFrame notifications (default implementation)

void COleClientItem::OnInsertMenus(CMenu* pMenuShared,
	LPOLEMENUGROUPWIDTHS lpMenuWidths)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pMenuShared);
	ASSERT(AfxIsValidAddress(lpMenuWidths, sizeof(OLEMENUGROUPWIDTHS)));

	// initialize the group widths array
	lpMenuWidths->width[0] = 0;
	lpMenuWidths->width[2] = 0;
	lpMenuWidths->width[4] = 0;

	// get menu from document template
	CDocTemplate* pTemplate = GetDocument()->GetDocTemplate();
	HMENU hMenuOLE = pTemplate->m_hMenuInPlace;

	// only copy the popups if there is a menu loaded
	if (hMenuOLE == NULL)
		return;

	// insert our menu items and adjust group widths array
	AfxMergeMenus(pMenuShared->GetSafeHmenu(), hMenuOLE, &lpMenuWidths->width[0], 0);
}

void COleClientItem::OnSetMenu(CMenu* pMenuShared, HOLEMENU holemenu,
	HWND hwndActiveObject)
{
	ASSERT_VALID(this);
	ASSERT(m_pInPlaceFrame != NULL);
	ASSERT(m_pInPlaceFrame->m_pFrameWnd != NULL);

	// don't set the doc is active
	CFrameWnd* pFrameWnd = m_pInPlaceFrame->m_pFrameWnd;
	ASSERT_VALID(pFrameWnd);
	if (m_pInPlaceDoc != NULL &&
		m_pInPlaceDoc->m_pFrameWnd != pFrameWnd->GetActiveFrame())
	{
		return;
	}

	// update the menu
	pFrameWnd->DelayUpdateFrameMenu(pMenuShared->GetSafeHmenu());

	// enable/disable the OLE command routing hook
	::OleSetMenuDescriptor(holemenu, pFrameWnd->m_hWnd,
		hwndActiveObject, NULL, NULL);
	if (m_pInPlaceDoc != NULL)
	{
		pFrameWnd = m_pInPlaceDoc->m_pFrameWnd;
		ASSERT_VALID(pFrameWnd);
		::OleSetMenuDescriptor(holemenu, pFrameWnd->m_hWnd,
			hwndActiveObject, NULL, NULL);
	}
}

void COleClientItem::OnRemoveMenus(CMenu* pMenuShared)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pMenuShared);

	// get menu from document template
	CDocTemplate* pTemplate = GetDocument()->GetDocTemplate();
	HMENU hMenuOLE = pTemplate->m_hMenuInPlace;
	if (hMenuOLE == NULL)
		return;

	// remove any menu popups originally added in OnInsertMenus
	AfxUnmergeMenus(pMenuShared->GetSafeHmenu(), hMenuOLE);
}

BOOL COleClientItem::OnUpdateFrameTitle()
{
	ASSERT_VALID(this);
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// In-place Activation operations

void COleClientItem::Deactivate()
{
	ASSERT_VALID(this);
	ASSERT(m_lpObject != NULL);
	ASSERT(IsInPlaceActive());

	// get IOleInPlaceObject interface
	LPOLEINPLACEOBJECT lpInPlaceObject =
		QUERYINTERFACE(m_lpObject, IOleInPlaceObject);
	if (lpInPlaceObject == NULL)
	{
		Close();    // handle rare failure cases by calling Close
		return;
	}

	// call IOleInPlaceObject::InPlaceDeactivate
	m_scLast = lpInPlaceObject->InPlaceDeactivate();
	lpInPlaceObject->Release();
	if (FAILED(m_scLast))
	{
		Close();    // handle rare failure cases by calling Close
		return;
	}
	m_nItemState = loadedState; // just in case server has crashed
}

void COleClientItem::DeactivateUI()
{
	ASSERT_VALID(this);
	ASSERT(m_lpObject != NULL);
	ASSERT(GetItemState() == activeUIState);

	// get IOleInPlaceObject interface
	LPOLEINPLACEOBJECT lpInPlaceObject =
		QUERYINTERFACE(m_lpObject, IOleInPlaceObject);
	if (lpInPlaceObject == NULL)
	{
		Close();    // handle rare failure cases by calling Close
		return;
	}

	// call IOleInPlaceObject::UIDeactivate
	m_scLast = lpInPlaceObject->UIDeactivate();
	lpInPlaceObject->Release();
	if (FAILED(m_scLast))
	{
		Close();    // handle rare failure cases by calling Close
		return;
	}
	if (m_nItemState == activeUIState)
		m_nItemState = activeState; // just in case server has crashed
}

BOOL COleClientItem::SetItemRects(LPCRECT lpPosRect, LPCRECT lpClipRect)
{
	ASSERT_VALID(this);
	ASSERT(m_lpObject != NULL);
	ASSERT(IsInPlaceActive());
	ASSERT(lpPosRect == NULL ||
		AfxIsValidAddress(lpPosRect, sizeof(RECT), FALSE));
	ASSERT(lpClipRect == NULL ||
		AfxIsValidAddress(lpClipRect, sizeof(RECT), FALSE));

	// get IOleInPlaceObject interface
	LPOLEINPLACEOBJECT lpInPlaceObject =
		QUERYINTERFACE(m_lpObject, IOleInPlaceObject);
	if (lpInPlaceObject == NULL)
		return FALSE;   // perhaps server crashed?

	// use OnGetPosRect if rectangle not specified
	CRect rectPos;
	if (lpPosRect == NULL)
	{
		ASSERT(lpClipRect == NULL);
		OnGetItemPosition(rectPos);
		lpPosRect = &rectPos;
	}

	// use OnGetClipRect if clipping rectangle not specified
	CRect rectClip;
	if (lpClipRect == NULL)
	{
		OnGetClipRect(rectClip);
		lpClipRect = &rectClip;
	}
	ASSERT(lpPosRect != NULL);
	ASSERT(lpClipRect != NULL);

	// notify the server of the new item rectangles
	m_scLast = lpInPlaceObject->SetObjectRects(lpPosRect, lpClipRect);
	lpInPlaceObject->Release();

	// remember position rectangle as cached position
	return !FAILED(m_scLast);
}

BOOL COleClientItem::ReactivateAndUndo()
{
	ASSERT_VALID(this);
	ASSERT(m_lpObject != NULL);
	ASSERT(IsInPlaceActive());

	// get IOleInPlaceObject interface
	LPOLEINPLACEOBJECT lpInPlaceObject =
		QUERYINTERFACE(m_lpObject, IOleInPlaceObject);
	if (lpInPlaceObject == NULL)
	{
		Close();    // handle rare failure cases by calling Close
		return FALSE;
	}

	// call IOleInPlaceObject::ReactivateAndUndo
	m_scLast = lpInPlaceObject->ReactivateAndUndo();
	lpInPlaceObject->Release();
	if (FAILED(m_scLast))
	{
		Close();    // handle rare failure cases by calling Close
		return FALSE;
	}
	return TRUE;
}

CWnd* COleClientItem::GetInPlaceWindow()
{
	ASSERT_VALID(this);
	ASSERT(m_lpObject != NULL);

	// only inplace active items should be asking for the window handle
	if (GetItemState() != activeUIState)
		return NULL;

	// handle case of server that just disappears
	if (m_hWndServer != NULL && !::IsWindow(m_hWndServer))
	{
		Close();
		return NULL;
	}

	ASSERT(m_hWndServer == NULL || ::IsWindow(m_hWndServer));
	return CWnd::FromHandle(m_hWndServer);
}

/////////////////////////////////////////////////////////////////////////////
// COleFrameHook OLE interface implementation

BEGIN_INTERFACE_MAP(COleFrameHook, CCmdTarget)
	INTERFACE_PART(COleFrameHook, IID_IOleWindow, OleInPlaceFrame)
	INTERFACE_PART(COleFrameHook, IID_IOleInPlaceUIWindow, OleInPlaceFrame)
	INTERFACE_PART(COleFrameHook, IID_IOleInPlaceFrame, OleInPlaceFrame)
	INTERFACE_PART(COleFrameHook, IID_IOleCommandTarget, OleCommandTarget)
END_INTERFACE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COleFrameHook::XOleCommandTarget implementation

STDMETHODIMP_(ULONG) COleFrameHook::XOleCommandTarget::AddRef()
{
	METHOD_PROLOGUE_EX_(COleFrameHook, OleCommandTarget)
	return pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) COleFrameHook::XOleCommandTarget::Release()
{
	METHOD_PROLOGUE_EX_(COleFrameHook, OleCommandTarget)
	return pThis->ExternalRelease();
}

STDMETHODIMP COleFrameHook::XOleCommandTarget::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(COleFrameHook, OleCommandTarget)
	return pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP COleFrameHook::XOleCommandTarget::Exec(
   const GUID* pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt,
   VARIANTARG* pvarargIn, VARIANTARG* pvarargOut)
{
	HRESULT hResult = OLECMDERR_E_UNKNOWNGROUP;
	METHOD_PROLOGUE_EX_(COleFrameHook, OleCommandTarget)

	COleDocObjectItem* pActiveDocObjectItem =
		DYNAMIC_DOWNCAST(COleDocObjectItem, pThis->m_pActiveItem);
	if (pActiveDocObjectItem != NULL)
	{
		hResult = _AfxExecOleCommandHelper(pActiveDocObjectItem,
			pguidCmdGroup, nCmdID, nCmdExecOpt, pvarargIn, pvarargOut);
	}

	return hResult;
}

STDMETHODIMP COleFrameHook::XOleCommandTarget::QueryStatus(
   const GUID* pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[],
   OLECMDTEXT* pcmdtext)
{
	HRESULT hResult = OLECMDERR_E_UNKNOWNGROUP;
	METHOD_PROLOGUE_EX_(COleFrameHook, OleCommandTarget)

	COleDocObjectItem* pActiveDocObjectItem =
		DYNAMIC_DOWNCAST(COleDocObjectItem, pThis->m_pActiveItem);
	if (pActiveDocObjectItem != NULL)
	{
		hResult = _AfxQueryStatusOleCommandHelper(pActiveDocObjectItem,
		   pguidCmdGroup, cCmds, rgCmds, pcmdtext);
	}

	return hResult;
}

/////////////////////////////////////////////////////////////////////////////
// COleFrameHook::XOleInPlaceFrame implementation

STDMETHODIMP_(ULONG) COleFrameHook::XOleInPlaceFrame::AddRef()
{
	METHOD_PROLOGUE_EX_(COleFrameHook, OleInPlaceFrame)
	return pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) COleFrameHook::XOleInPlaceFrame::Release()
{
	METHOD_PROLOGUE_EX_(COleFrameHook, OleInPlaceFrame)
	return pThis->ExternalRelease();
}

STDMETHODIMP COleFrameHook::XOleInPlaceFrame::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(COleFrameHook, OleInPlaceFrame)
	return pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP COleFrameHook::XOleInPlaceFrame::GetWindow(
	HWND* lphwnd)
{
	METHOD_PROLOGUE_EX_(COleFrameHook, OleInPlaceFrame)

	*lphwnd = pThis->m_hWnd;
	return *lphwnd != NULL ? S_OK : E_FAIL;
}

STDMETHODIMP COleFrameHook::XOleInPlaceFrame::ContextSensitiveHelp(
	BOOL fEnterMode)
{
	METHOD_PROLOGUE_EX(COleFrameHook, OleInPlaceFrame)
	ASSERT_VALID(pThis);

	// document frame windows should not be put in help mode, so we get the
	//  top-level frame window and check it first
	CFrameWnd* pFrameWnd = pThis->m_pFrameWnd->GetTopLevelFrame();
	ENSURE_VALID(pFrameWnd);

	if (fEnterMode)
	{
		if (!pFrameWnd->m_bHelpMode)
		{
			// check if help mode probable
			if (!pFrameWnd->CanEnterHelpMode())
				return E_UNEXPECTED;

			// attempt to enter context help
			if (!pThis->OnContextHelp(TRUE) ||
				!pFrameWnd->PostMessage(WM_COMMAND, ID_CONTEXT_HELP))
			{
				return E_UNEXPECTED;
			}
		}
	}
	else
	{
		// just exit help mode
		pFrameWnd->ExitHelpMode();
	}

	return S_OK;
}

STDMETHODIMP COleFrameHook::XOleInPlaceFrame::GetBorder(LPRECT lpRectBorder)
{
	METHOD_PROLOGUE_EX(COleFrameHook, OleInPlaceFrame)
	ASSERT_VALID(pThis);

	COleClientItem* pItem = pThis->m_pActiveItem;
	ASSERT_VALID(pItem);
	CFrameWnd* pFrameWnd = pThis->m_pFrameWnd;
	ASSERT_VALID(pFrameWnd);

	// hide the control bars temporarily
	BOOL bHidden = pItem->OnShowControlBars(pFrameWnd, FALSE);

	// determine border space assuming that we'll remove our control bars
	CRect rectSave = pFrameWnd->m_rectBorder;
	pFrameWnd->NegotiateBorderSpace(CFrameWnd::borderSet, NULL);
	pFrameWnd->NegotiateBorderSpace(CFrameWnd::borderGet, lpRectBorder);
	pFrameWnd->NegotiateBorderSpace(CFrameWnd::borderSet, &rectSave);

	// restore control bars
	if (bHidden)
		pItem->OnShowControlBars(pFrameWnd, TRUE);

	return S_OK;
}

STDMETHODIMP COleFrameHook::XOleInPlaceFrame::RequestBorderSpace(
	LPCRECT lpRectWidths)
{
	METHOD_PROLOGUE_EX(COleFrameHook, OleInPlaceFrame)
	ASSERT_VALID(pThis);

	CFrameWnd* pFrameWnd = pThis->m_pFrameWnd;
	ASSERT_VALID(pFrameWnd);

	if (!pFrameWnd->NegotiateBorderSpace(
		CFrameWnd::borderRequest, (LPRECT)lpRectWidths))
	{
		return INPLACE_E_NOTOOLSPACE;
	}

	return S_OK;
}

STDMETHODIMP COleFrameHook::XOleInPlaceFrame::SetBorderSpace(
	LPCRECT lpRectWidths)
{
	METHOD_PROLOGUE_EX(COleFrameHook, OleInPlaceFrame)
	ASSERT_VALID(pThis);

	CFrameWnd* pFrameWnd = pThis->m_pFrameWnd;

	if (pFrameWnd->NegotiateBorderSpace(
		CFrameWnd::borderSet, (LPRECT)lpRectWidths))
	{
		// We have to turn off the notify and idlelayout flags so RecalcLayout
		// doesn't call back into the object and tell it to resize it's borders
		// while we are in the middle of setting the border space.
		pFrameWnd->m_nIdleFlags &= ~(CFrameWnd::idleLayout|CFrameWnd::idleNotify);

		// synchronously re-layout borders.
		pFrameWnd->RecalcLayout(FALSE);
	}
	pThis->m_pActiveItem->OnShowControlBars(pFrameWnd, lpRectWidths == NULL);

	return S_OK;
}

STDMETHODIMP COleFrameHook::XOleInPlaceFrame::SetActiveObject(
	LPOLEINPLACEACTIVEOBJECT lpActiveObject, LPCOLESTR lpszObjName)
{
	METHOD_PROLOGUE_EX(COleFrameHook, OleInPlaceFrame)
	ASSERT_VALID(pThis);

	SCODE sc = E_UNEXPECTED;
	TRY
	{
		// release the old active object
		RELEASE(pThis->m_lpActiveObject);

		// set the new active object
		pThis->m_lpActiveObject = lpActiveObject;
		if (lpActiveObject != NULL)
			lpActiveObject->AddRef();

		// update caption if necessary
		pThis->m_strObjName.Empty();
		if (lpszObjName != NULL && lpActiveObject != NULL)
		{
			pThis->m_strObjName = lpszObjName;
			pThis->m_pActiveItem->OnUpdateFrameTitle();
		}
		sc = S_OK;
	}
	END_TRY

	return sc;
}

STDMETHODIMP COleFrameHook::XOleInPlaceFrame::InsertMenus(
	HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths)
{
	METHOD_PROLOGUE_EX(COleFrameHook, OleInPlaceFrame)
	ASSERT_VALID(pThis);

	// get the associated COleClientItem object
	COleClientItem* pItem = pThis->m_pActiveItem;
	ASSERT_VALID(pItem);

	SCODE sc = E_UNEXPECTED;
	TRY
	{
		pItem->OnInsertMenus(CMenu::FromHandle(hmenuShared), lpMenuWidths);
		sc = S_OK;
	}
	END_TRY

	return sc;
}

STDMETHODIMP COleFrameHook::XOleInPlaceFrame::SetMenu(
	HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject)
{
	METHOD_PROLOGUE_EX(COleFrameHook, OleInPlaceFrame)
	ASSERT_VALID(pThis);

	// get the associated COleClientItem object
	COleClientItem* pItem = pThis->m_pActiveItem;
	ASSERT_VALID(pItem);

	SCODE sc = E_UNEXPECTED;
	TRY
	{
		pItem->OnSetMenu(CMenu::FromHandle(hmenuShared), holemenu,
			hwndActiveObject);
		sc = S_OK;
	}
	END_TRY

	return sc;
}

STDMETHODIMP COleFrameHook::XOleInPlaceFrame::RemoveMenus(
	HMENU hmenuShared)
{
	METHOD_PROLOGUE_EX(COleFrameHook, OleInPlaceFrame)
	ASSERT_VALID(pThis);

	// get the associated COleClientItem object
	COleClientItem* pItem = pThis->m_pActiveItem;
	ASSERT_VALID(pItem);

	SCODE sc = E_UNEXPECTED;
	TRY
	{
		pItem->OnRemoveMenus(CMenu::FromHandle(hmenuShared));
		sc = S_OK;
	}
	END_TRY

	return sc;
}

STDMETHODIMP COleFrameHook::XOleInPlaceFrame::SetStatusText(
	LPCOLESTR lpszStatusText)
{
	METHOD_PROLOGUE_EX_(COleFrameHook, OleInPlaceFrame)
	LPARAM lParam;
	CString strText;
	if (lpszStatusText)
	{
		strText = lpszStatusText;
		lParam = reinterpret_cast<LPARAM>(strText.GetString());
	}
	else
	{
		lParam = 0;
	}
	pThis->m_pFrameWnd->SendMessage(WM_SETMESSAGESTRING, 0, lParam);
	return S_OK;
}

STDMETHODIMP COleFrameHook::XOleInPlaceFrame::EnableModeless(BOOL fEnable)
{
	METHOD_PROLOGUE_EX(COleFrameHook, OleInPlaceFrame)
	ASSERT_VALID(pThis);
	ASSERT_VALID(pThis->m_pFrameWnd);

	SCODE sc = E_UNEXPECTED;
	TRY
	{
		if (!fEnable)
			pThis->m_pFrameWnd->BeginModalState();
		else
			pThis->m_pFrameWnd->EndModalState();
		sc = S_OK;
	}
	END_TRY

	return sc;
}

STDMETHODIMP COleFrameHook::XOleInPlaceFrame::TranslateAccelerator(
	LPMSG lpmsg, WORD /*wID*/)
{
	METHOD_PROLOGUE_EX(COleFrameHook, OleInPlaceFrame)
	ASSERT_VALID(pThis);

	SCODE sc = E_UNEXPECTED;
	TRY
	{
		// swap accel tables and call PreTranslateMessage
		CFrameWnd* pFrameWnd = pThis->m_pFrameWnd;
		HACCEL hAccelSave = pFrameWnd->m_hAccelTable;
		pFrameWnd->m_hAccelTable = pThis->m_hAccelTable;
		ASSERT(lpmsg != NULL);
		MSG msg = *lpmsg;
		sc = pFrameWnd->PreTranslateMessage(&msg) ? S_OK : S_FALSE;
		*lpmsg = msg;
		pFrameWnd->m_hAccelTable = hAccelSave;
	}
	END_TRY

	return sc;
}

/////////////////////////////////////////////////////////////////////////////
// COleClientItem::XOleIPSite implementation

STDMETHODIMP_(ULONG) COleClientItem::XOleIPSite::AddRef()
{
	METHOD_PROLOGUE_EX_(COleClientItem, OleIPSite)
	return pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) COleClientItem::XOleIPSite::Release()
{
	METHOD_PROLOGUE_EX_(COleClientItem, OleIPSite)
	return pThis->ExternalRelease();
}

STDMETHODIMP COleClientItem::XOleIPSite::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(COleClientItem, OleIPSite)
	return pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP COleClientItem::XOleIPSite::GetWindow(HWND* lphwnd)
{
	METHOD_PROLOGUE_EX_(COleClientItem, OleIPSite)

	*lphwnd = pThis->m_pView->GetSafeHwnd();
	return *lphwnd != NULL ? S_OK : E_FAIL;
}

STDMETHODIMP COleClientItem::XOleIPSite::ContextSensitiveHelp(
	BOOL fEnterMode)
{
	METHOD_PROLOGUE_EX_(COleClientItem, OleIPSite)

	if (pThis->m_pInPlaceFrame == NULL)
		return E_UNEXPECTED;

	// simply delegate to frame window implementation
	return pThis->m_pInPlaceFrame->
		m_xOleInPlaceFrame.ContextSensitiveHelp(fEnterMode);
}

STDMETHODIMP COleClientItem::XOleIPSite::CanInPlaceActivate()
{
	METHOD_PROLOGUE_EX(COleClientItem, OleIPSite)

	return pThis->CanActivate() ? S_OK : S_FALSE;
}

STDMETHODIMP COleClientItem::XOleIPSite::OnInPlaceActivate()
{
	METHOD_PROLOGUE_EX(COleClientItem, OleIPSite)
	ASSERT_VALID(pThis);

	SCODE sc = E_UNEXPECTED;
	TRY
	{
		pThis->OnActivate();
		sc = S_OK;
	}
	END_TRY

	return sc;
}

STDMETHODIMP COleClientItem::XOleIPSite::OnUIActivate()
{
	METHOD_PROLOGUE_EX(COleClientItem, OleIPSite)
	ASSERT_VALID(pThis);

	SCODE sc = E_UNEXPECTED;
	TRY
	{
		pThis->OnActivateUI();
		sc = S_OK;
	}
	END_TRY

	return sc;
}

STDMETHODIMP COleClientItem::XOleIPSite::GetWindowContext(
	LPOLEINPLACEFRAME* lplpFrame,
	LPOLEINPLACEUIWINDOW* lplpDoc,
	LPRECT lpPosRect, LPRECT lpClipRect,
	LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
	METHOD_PROLOGUE_EX(COleClientItem, OleIPSite)
	ASSERT_VALID(pThis);

	*lplpFrame = NULL;  // init these in-case of mem-alloc failure
	*lplpDoc = NULL;

	CFrameWnd* pMainFrame = NULL;
	CFrameWnd* pDocFrame = NULL;

	SCODE sc = E_UNEXPECTED;
	TRY
	{
		// get position of the item relative to activation view
		CRect rect;
		pThis->OnGetItemPosition(rect);
		::CopyRect(lpPosRect, &rect);
		pThis->OnGetClipRect(rect);
		::CopyRect(lpClipRect, &rect);

		// get the window context information
		if (pThis->OnGetWindowContext(&pMainFrame, &pDocFrame, lpFrameInfo))
		{
			// hook IOleInPlaceFrame interface to pMainFrame
			if (pThis->m_pInPlaceFrame == NULL)
				pThis->m_pInPlaceFrame = new COleFrameHook(pMainFrame, pThis);
			pThis->m_pInPlaceFrame->InternalAddRef();
			*lplpFrame = (LPOLEINPLACEFRAME)pThis->m_pInPlaceFrame->
				GetInterface(&IID_IOleInPlaceFrame);

			// save accel table for IOleInPlaceFrame::TranslateAccelerators
			pThis->m_pInPlaceFrame->m_hAccelTable = lpFrameInfo->haccel;

			// hook IOleInPlaceUIWindow to pDocFrame
			if (pDocFrame != NULL)
			{
				if (pThis->m_pInPlaceDoc == NULL)
					pThis->m_pInPlaceDoc = new COleFrameHook(pDocFrame, pThis);
				pThis->m_pInPlaceDoc->InternalAddRef();
				*lplpDoc = (LPOLEINPLACEUIWINDOW)pThis->m_pInPlaceDoc->
					GetInterface(&IID_IOleInPlaceUIWindow);
			}
			sc = S_OK;
		}
	}
	CATCH_ALL(e)
	{
		// cleanup memory that may be partially allocated
		delete *lplpFrame;
		ASSERT(*lplpDoc == NULL);
		DELETE_EXCEPTION(e);
	}
	END_CATCH_ALL

	return sc;
}

STDMETHODIMP COleClientItem::XOleIPSite::Scroll(SIZE scrollExtent)
{
	METHOD_PROLOGUE_EX(COleClientItem, OleIPSite)
	ASSERT_VALID(pThis);

	SCODE sc = E_UNEXPECTED;
	TRY
	{
		if (!pThis->OnScrollBy(CSize(scrollExtent)))
			sc = S_FALSE;
		else
			sc = S_OK;
	}
	END_TRY

	return sc;
}

STDMETHODIMP COleClientItem::XOleIPSite::OnUIDeactivate(BOOL fUndoable)
{
	METHOD_PROLOGUE_EX(COleClientItem, OleIPSite)
	ASSERT_VALID(pThis);

	SCODE sc = E_UNEXPECTED;
	TRY
	{
		pThis->OnDeactivateUI(fUndoable);
		sc = S_OK;
	}
	END_TRY

	return sc;
}

STDMETHODIMP COleClientItem::XOleIPSite::OnInPlaceDeactivate()
{
	METHOD_PROLOGUE_EX(COleClientItem, OleIPSite)
	ASSERT_VALID(pThis);

	SCODE sc = E_UNEXPECTED;
	TRY
	{
		pThis->OnDeactivate();
		sc = S_OK;
	}
	END_TRY

	return sc;
}

STDMETHODIMP COleClientItem::XOleIPSite::DiscardUndoState()
{
	METHOD_PROLOGUE_EX(COleClientItem, OleIPSite)
	ASSERT_VALID(pThis);

	SCODE sc = E_UNEXPECTED;
	TRY
	{
		pThis->OnDiscardUndoState();
		sc = S_OK;
	}
	END_TRY

	return sc;
}

STDMETHODIMP COleClientItem::XOleIPSite::DeactivateAndUndo()
{
	METHOD_PROLOGUE_EX(COleClientItem, OleIPSite)
	ASSERT_VALID(pThis);

	SCODE sc = E_UNEXPECTED;
	TRY
	{
		pThis->OnDeactivateAndUndo();
		sc = S_OK;
	}
	END_TRY

	return sc;
}

STDMETHODIMP COleClientItem::XOleIPSite::OnPosRectChange(
	LPCRECT lpPosRect)
{
	METHOD_PROLOGUE_EX(COleClientItem, OleIPSite)
	ASSERT_VALID(pThis);

	SCODE sc = E_UNEXPECTED;
	TRY
	{
		CRect rect;
		rect.CopyRect(lpPosRect);
		pThis->OnChangeItemPosition(rect);
		sc = S_OK;
	}
	END_TRY

	return sc;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\olecall.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"


// Note: because of the nature of these functions, it is not possible
//  to create a 'C' or 'C++' version of them.  These functions are used
//  for the lowest level of the OLE IDispatch implementation, and need
//  to be ported to each supported platform.

extern "C" {

/////////////////////////////////////////////////////////////////////////////
// Intel 386 version

#ifdef _X86_

__declspec(naked) void AFXAPI
_AfxDispatchCall(AFX_PMSG /*pfn*/, void* /*pArgs*/, UINT /*nSizeArgs*/)
{
	_asm
	{
		pop     edx         // edx = return address
		pop     eax         // eax = pfn
		pop     ecx         // ecx = pArgs
		add     ecx,[esp]   // ecx += nSizeArgs (=scratch area)
		mov     [ecx],edx   // scratch[0] = return address
		sub     ecx,[esp]   // ecx = pArgs (again)
		mov     esp,ecx     // esp = pArgs (usually already correct)
		pop     ecx         // ecx = this pointer (the CCmdTarget*)
		call    eax         // call member function
		ret                 // esp[0] should = scratch[0] = return address
	}
}
#endif // _X86_

/////////////////////////////////////////////////////////////////////////////
// AMD 64 version

#ifdef _AMD64_

// Note: AMD64 version is in src\x8664\olecall_.s

// The AMD64 compiler does not support inline assembly, so it
//  must be built separately with the MASM assembler.

#endif // _AMD64_

/////////////////////////////////////////////////////////////////////////////
// MIPS R4000 version

#ifdef _MIPS_

extern "C" void _asm(char *, ...);
void AFXAPI
_AfxDispatchCall(AFX_PMSG /*pfn*/, void* /*pArgs*/, UINT /*nSizeArgs*/)
{
	_asm("addiu     %sp,%a1,0x0");      // sp = pArgs
	_asm("addiu     %t6,%a0,0x0");      // t6 = pfn (save it)
	_asm("lw        %a0,0x0(%sp)");     // a0 = param0
	_asm("lw        %a1,0x4(%sp)");     // a1 = param1
	_asm("lw        %a2,0x8(%sp)");     // a2 = param2
	_asm("lw        %a3,0xc(%sp)");     // a3 = param3
	_asm("j         %t6");              // ip = pfn (jump to target function)
}

#endif // _MIPS_

} // end extern "C" block

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\olecli1.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "sal.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// COleClientItem - Container view of IOleObject and related interfaces

COleClientItem::COleClientItem(COleDocument* pContainerDoc)
{
	if (pContainerDoc != NULL)
		ASSERT_VALID(pContainerDoc);

	// initialize OLE client side view of IOleObject
	m_lpObject = NULL;
	m_lpViewObject = NULL;
	m_dwConnection = 0;
	m_lpStorage = NULL;
	m_lpLockBytes = NULL;
	m_scLast = S_OK;
	m_pView = NULL;
	m_pInPlaceFrame = NULL;
	m_pInPlaceDoc = NULL;
	m_nItemState = emptyState;  // initially empty until OleLoad, OleCreate
	m_bMoniker = FALSE;
	m_nDrawAspect = DVASPECT_CONTENT;   // default draw aspect
	m_dwItemNumber = 0;
	m_bLinkUnavail = FALSE; // set to TRUE on failed DoVerb, or in links dialog
	m_nItemType = OT_UNKNOWN;       // type unknown so far
	m_hWndServer = NULL;
	m_dwFrameMenuBarVisibility = AFX_MBV_KEEPVISIBLE;
	m_bClosing = FALSE; // COleClientItem::Close in process
	m_bLocked = FALSE;  // need CoLockObjectExternal(..., FALSE, ...)

	// initialize compound file support
	m_lpNewStorage = NULL;
	m_bNeedCommit = FALSE;

	if (pContainerDoc != NULL)
		pContainerDoc->AddItem(this);

	ASSERT(m_pDocument == pContainerDoc);
	ASSERT_VALID(this);

	AfxOleLockApp();
}

COleClientItem::~COleClientItem()
{
	AFX_BEGIN_DESTRUCTOR

	ASSERT_VALID(this);

	// release any references we may have to other objects
	Release();

	// only remove it from the associated document if it hasn't been detached
	//  from the document already!
	if (m_pDocument != NULL)
		m_pDocument->RemoveItem(this);

	// make sure all outside connections are disconnected
	ExternalDisconnect();
	AfxOleUnlockApp();

	AFX_END_DESTRUCTOR
}

void COleClientItem::Delete(BOOL bAutoDelete)
{
	ASSERT_VALID(this);

	Release();      // first close it

	COleDocument* pDoc = GetDocument();
	if (pDoc != NULL && pDoc->m_bCompoundFile)
	{
		// cleanup docfile storage first
		ASSERT_VALID(pDoc);

		if (pDoc->m_lpRootStg != NULL)
		{
			// get item name
			TCHAR szItemName[OLE_MAXITEMNAME];
			GetItemName(szItemName, _countof(szItemName));

			// attempt to remove it from the storage, ignore errors
			CStringW strItemName(szItemName);
			pDoc->m_lpRootStg->DestroyElement(strItemName.GetString());
		}
	}

	if (bAutoDelete)
	{
		// remove item from document
		if (pDoc != NULL)
			pDoc->RemoveItem(this);

		InternalRelease();  // remove the item from memory
	}
}

void COleClientItem::Release(OLECLOSE dwCloseOption)
{
	ASSERT_VALID(this);

	m_scLast = S_OK;

	// cleanup view advise
	if (m_lpViewObject != NULL)
	{
		DWORD dwAspect;
	  IAdviseSink* pAdviseSink;

	  pAdviseSink = NULL;
		VERIFY(m_lpViewObject->GetAdvise(&dwAspect, NULL, &pAdviseSink) == S_OK);
	  if( pAdviseSink != NULL )
	  {
		 RELEASE( pAdviseSink );
	  }
		VERIFY(m_lpViewObject->SetAdvise(dwAspect, 0, NULL) == S_OK);
		RELEASE(m_lpViewObject);
	}

	// cleanup the OLE object itself
	if (m_lpObject != NULL)
	{
		// cleanup object advise
		if (m_dwConnection != 0)
		{
			VERIFY(m_lpObject->Unadvise(m_dwConnection) == S_OK);
			m_dwConnection = 0;
		}

		// close object and save (except now when called from destructor)
		//  (NOTE: errors are _not_ reported as an exception)
		m_scLast = m_lpObject->Close(dwCloseOption);
		RELEASE(m_lpObject);
	}

	// cleanup storage related data
	RELEASE(m_lpStorage);
	RELEASE(m_lpLockBytes);

	// cleanup in-place editing data
	if (m_pInPlaceFrame != NULL)
	{
		m_pInPlaceFrame->InternalRelease();
		m_pInPlaceFrame = NULL;
		if (m_pInPlaceDoc != NULL)
		{
			m_pInPlaceDoc->InternalRelease();
			m_pInPlaceDoc = NULL;
		}
	}
	ASSERT(m_pInPlaceFrame == NULL);
	ASSERT(m_pInPlaceDoc == NULL);
}

void COleClientItem::Close(OLECLOSE dwCloseOption)
{
	ASSERT_VALID(this);
	ASSERT(m_lpObject != NULL);

	// gaurd against re-entry
	if (m_bClosing)
		return;

	m_bClosing = TRUE;

	// attempt to close the object
	m_scLast = m_lpObject->Close(dwCloseOption);

	// remove external lock placed on item during in-place activation
	if (m_bLocked)
	{
		OleLockRunning(m_lpObject, FALSE, TRUE);
		m_bLocked = FALSE;
	}

	// handle failure cases -- COleClientItem::Close can be used to
	//  robustly handle a server crashing (ie. something unexpected happens,
	//  we'll call COleClientItem::Close to attempt safe shutdown)
	if (GetItemState() != loadedState)
	{
		// We'll call COleClientItem::Close anywhere a catastrophe
		//  happens inside of other portions of COleClientItem.  We must
		//  completely exit from any in-place/open state.

		// force transition from activeUIState to activeState
		if (GetItemState() == activeUIState)
			OnDeactivateUI(FALSE);

		// force transition from activeState to loadedState
		if (GetItemState() == activeState)
			OnDeactivate();

		if (m_nItemState != loadedState)
		{
			// in case of extreme failure, force loadedState
			OnChange(OLE_CHANGED_STATE, (DWORD)loadedState);
			m_nItemState = loadedState; // force it to loaded state
		}
	}

	m_bClosing = FALSE; // now safe for further close calls
}

/////////////////////////////////////////////////////////////////////////////
// COleClientItem name management

DWORD COleClientItem::GetNewItemNumber()
{
	ASSERT_VALID(this);

	COleDocument* pDoc = GetDocument();
	ASSERT_VALID(pDoc);
	DWORD dwNextItemNumber = pDoc->m_dwNextItemNumber;

	for (;;)
	{
		// make sure that m_dwNextItemNumber is not used in another item first
		POSITION pos = pDoc->GetStartPosition();
		COleClientItem* pItem;
		while ((pItem = pDoc->GetNextClientItem(pos)) != NULL)
		{
			if (pItem->m_dwItemNumber == dwNextItemNumber)
				break;
		}
		if (pItem == NULL)
			break;  // no item using m_dwNextItemNumber

		// m_dwNextItemNumber is in use, bump to next one!
		++dwNextItemNumber;
	}

	pDoc->m_dwNextItemNumber = dwNextItemNumber + 1;
	return dwNextItemNumber;
}

//
// Note: this function assumes the incoming buffer is at least OLE_MAXITEMNAME characters long
// If it is shorter than that, buffer overrun occurs
//
void COleClientItem::GetItemName(_Out_ _Pre_notnull_ _Post_z_ LPTSTR lpszItemName) const
{
	ASSERT_VALID(this);
	ASSERT(lpszItemName != NULL);
	ASSERT(AfxIsValidAddress(lpszItemName, OLE_MAXITEMNAME));

	GetItemName(lpszItemName, OLE_MAXITEMNAME);
	ASSERT(lstrlen(lpszItemName) < OLE_MAXITEMNAME);
}

void COleClientItem::GetItemName(_Out_z_cap_(cchItemName) _Pre_notnull_ _Post_z_ LPTSTR lpszItemName, UINT cchItemName ) const
{
	ASSERT_VALID(this);
	ASSERT(lpszItemName != NULL);

	_stprintf_s(lpszItemName, cchItemName, _T("Embedding %lu"), m_dwItemNumber);
}

// extracts icon resource ID and path name from registry "file.exe,35" format
//
// Note: lpszImagePath must point to a buffer no shorter than lpszRegInfo
//
static void AfxGetIconInfo(LPCTSTR lpszRegInfo, _Out_ LPTSTR lpszImagePath,
	UINT& nIndex)
{
	LPTSTR pstrTarget = lpszImagePath;
	LPCTSTR pstrSource = lpszRegInfo;
	while (*pstrSource != ',' && *pstrSource != '\0')
	{
		*pstrTarget = *pstrSource;
		pstrTarget = _tcsinc(pstrTarget);
		pstrSource = _tcsinc(pstrSource);
	}
	*pstrTarget = '\0';

	// extract the index
	if (*pstrSource != '\0')
	{
		LPTSTR pstrIndex = _tcsinc(pstrSource);
		nIndex = (UINT) _ttol(pstrIndex);
	}
	else
		nIndex = 0;
}

HICON COleClientItem::GetIconFromRegistry() const
{
	CLSID clsid;
	GetClassID(&clsid);
	if (clsid == CLSID_NULL)
		return NULL;

	return GetIconFromRegistry(clsid);
}

HICON COleClientItem::GetIconFromRegistry(CLSID& clsid)
{
	// This function will extract the icon registered as the DefaultIcon
	// for the server referred to by clsid.  We get the ProgID for the server
	// and then extract \\hkcr\progid\DefaultIcon.  If that doesn't exist, we
	// get a default icon from \\hkcr\DocShortcut\DefaultIcon and if that fails
	// we just return 0.

	HICON hIcon = NULL;
	HRESULT hr;
	OLECHAR *szCLSID;
	DWORD dwType = 0;
	TCHAR szName[MAX_PATH+1];
	TCHAR szPathName[MAX_PATH+1];
	HKEY hkeyObj;
	HKEY hkeyDefIcon;
	HKEY hkeyCLSID;
	UINT nIndex;

	hr = ::StringFromCLSID(clsid, &szCLSID);
	if (!SUCCEEDED(hr))
		return NULL;

	// first, try for the real icon
	if (RegOpenKeyExW(HKEY_CLASSES_ROOT, L"CLSID", 0, KEY_READ, &hkeyCLSID) == ERROR_SUCCESS)
	{
		CString strCLSID(szCLSID);
		if (RegOpenKeyEx(hkeyCLSID, strCLSID.GetString(), 0, KEY_READ, &hkeyObj) == ERROR_SUCCESS)
		{
			if (RegOpenKeyExW(hkeyObj, L"DefaultIcon", 0, KEY_READ, &hkeyDefIcon) == ERROR_SUCCESS)
			{
				DWORD dwCount;
				dwCount = sizeof(szName);
				if (RegQueryValueEx(hkeyDefIcon, NULL, NULL, &dwType, (BYTE*) szName, &dwCount) == ERROR_SUCCESS)
				{
					AfxGetIconInfo(szName, szPathName, nIndex);

					// Load the icon
					hIcon = ::ExtractIcon(AfxGetApp()->m_hInstance, szPathName, nIndex);

					// ExtractIcon() failure case means NULL return
					if (INT_PTR(hIcon) == 1)
						hIcon = NULL;
				}
				RegCloseKey(hkeyDefIcon);
			}
			RegCloseKey(hkeyObj);
		}
		RegCloseKey(hkeyCLSID);
	}

	// if we didn't get the real icon, try the default icon
	if (hIcon == NULL)
	{
		if (RegOpenKeyExW(HKEY_CLASSES_ROOT, L"DocShortcut", 0, KEY_READ,&hkeyObj) == ERROR_SUCCESS)
		{
			if (RegOpenKeyExW(hkeyObj, L"DefaultIcon", 0, KEY_READ, &hkeyDefIcon) == ERROR_SUCCESS)
			{
				DWORD dwCount;
				dwCount = sizeof(szName);
				if (RegQueryValueEx(hkeyDefIcon, NULL, NULL, &dwType, (BYTE*) szName, &dwCount) == ERROR_SUCCESS)
				{
					AfxGetIconInfo(szName, szPathName, nIndex);

					// Load the icon
					hIcon = ::ExtractIcon(AfxGetApp()->m_hInstance, szPathName, nIndex);

					// ExtractIcon() failure case means NULL return
					if (INT_PTR(hIcon) == 1)
						hIcon = NULL;
				}
				RegCloseKey(hkeyDefIcon);
			}
			RegCloseKey(hkeyObj);
		}
	}

	::CoTaskMemFree(szCLSID);
	return hIcon;
}

/////////////////////////////////////////////////////////////////////////////
// COleClientItem creation helpers

void COleClientItem::UpdateItemType()
{
	ASSERT_VALID(this);
	ASSERT(m_lpObject != NULL);

	// check for linked object
	LPOLELINK lpOleLink = QUERYINTERFACE(m_lpObject, IOleLink);
	if (lpOleLink != NULL)
	{
		lpOleLink->Release();
		m_nItemType = OT_LINK;
		return;
	}

	// check for static object
	DWORD dwStatus;
	if (m_lpObject->GetMiscStatus(DVASPECT_CONTENT, &dwStatus) == S_OK
		&& (dwStatus & OLEMISC_STATIC) == 0)
	{
		m_nItemType = OT_EMBEDDED;
		return;
	}

	// not not link, not embedding -- must be static
	m_nItemType = OT_STATIC;
}

BOOL COleClientItem::FinishCreate(SCODE sc)
{
	ASSERT_VALID(this);
	ASSERT(m_pView == NULL);

	TRY
	{
		// m_lpObject is currently an IUnknown, convert to IOleObject
		if (m_lpObject != NULL)
		{
			LPUNKNOWN lpUnk = m_lpObject;
			m_lpObject = QUERYINTERFACE(lpUnk, IOleObject);
			lpUnk->Release();
			if (m_lpObject == NULL)
				AfxThrowOleException(E_OUTOFMEMORY);
		}

		// check return code from create function
		CheckGeneral(sc);

		UpdateItemType();

		// cache the IViewObject interface
		m_lpViewObject = QUERYINTERFACE(m_lpObject, IViewObject2);
		if (m_lpViewObject == NULL)
			CheckGeneral(E_NOINTERFACE);
		ASSERT(m_lpViewObject != NULL);

		if (GetType() != OT_STATIC)
		{
			// setup for advises; we assume that OLE cleans them up properly
			LPADVISESINK lpAdviseSink =
				(LPADVISESINK)GetInterface(&IID_IAdviseSink);
			ASSERT(lpAdviseSink != NULL);
			CheckGeneral(m_lpObject->Advise(lpAdviseSink, &m_dwConnection));
			ASSERT(m_dwConnection != 0);

			// set up view advise
			VERIFY(m_lpViewObject->SetAdvise(DVASPECT_CONTENT, 0, lpAdviseSink)
				== S_OK);

			// the server shows these in its user-interface
			//  (as document title and in File Exit menu)
			CStringW strAppName(AfxGetAppName()), strTitle(m_pDocument->GetTitle());
			LPCOLESTR lpTitle = m_pDocument->GetTitle() ? strTitle.GetString() : 0;
			m_lpObject->SetHostNames(strAppName.GetString(), lpTitle);
		}

		// all items are "contained" -- this makes our reference to this object
		//  weak -- which is needed for links to embedding silent update.
		OleSetContainedObject(m_lpObject, TRUE);

		// considered loaded at this point
		m_nItemState = loadedState;
	}
	CATCH_ALL(e)
	{
		Release();  // release the object just in case
		ASSERT_VALID(this);
		DELETE_EXCEPTION(e);
		return FALSE;
	}
	END_CATCH_ALL

	// set state to loaded
	ASSERT(m_nItemState != emptyState);

	// otherwise no errors, return success!
	ASSERT_VALID(this);
	return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
// COleClientItem create API variants

BOOL COleClientItem::CreateFromClipboard(
	OLERENDER render, CLIPFORMAT cfFormat, LPFORMATETC lpFormatEtc)
{
	ASSERT_VALID(this);
	ASSERT(m_lpObject == NULL);     // one time only
	ASSERT(m_pDocument != NULL);
	ASSERT(lpFormatEtc == NULL ||
		AfxIsValidAddress(lpFormatEtc, sizeof(FORMATETC), FALSE));

	// get clipboard contents
	COleDataObject dataObject;
	if (!dataObject.AttachClipboard())
		return FALSE;

	// create from IDataObject
	BOOL bResult = CreateFromData(&dataObject, render, cfFormat, lpFormatEtc);

	ASSERT_VALID(this);
	return bResult;
}

BOOL COleClientItem::CreateLinkFromClipboard(
	OLERENDER render, CLIPFORMAT cfFormat, LPFORMATETC lpFormatEtc)
{
	ASSERT_VALID(this);
	ASSERT(m_lpObject == NULL);     // one time only
	ASSERT(m_pDocument != NULL);
	ASSERT(lpFormatEtc == NULL ||
		AfxIsValidAddress(lpFormatEtc, sizeof(FORMATETC), FALSE));

	// get clipboard contents
	COleDataObject dataObject;
	if (!dataObject.AttachClipboard())
		return FALSE;

	// create from IDataObject
	BOOL bResult = CreateLinkFromData(&dataObject, render, cfFormat, lpFormatEtc);
	ASSERT_VALID(this);

	return bResult;
}

BOOL COleClientItem::CreateStaticFromClipboard(
	OLERENDER render, CLIPFORMAT cfFormat, LPFORMATETC lpFormatEtc)
{
	ASSERT_VALID(this);
	ASSERT(m_lpObject == NULL);     // one time only
	ASSERT(m_pDocument != NULL);
	ASSERT(lpFormatEtc == NULL ||
		AfxIsValidAddress(lpFormatEtc, sizeof(FORMATETC), FALSE));

	// get clipboard contents
	COleDataObject dataObject;
	if (!dataObject.AttachClipboard())
		return FALSE;

	// create from IDataObject
	BOOL bResult = CreateStaticFromData(&dataObject, render, cfFormat,
		lpFormatEtc);

	ASSERT_VALID(this);
	return bResult;
}

// Creation from IDataObject (used for drag-drop)
BOOL COleClientItem::CreateFromData(COleDataObject* pDataObject,
	OLERENDER render, CLIPFORMAT cfFormat, LPFORMATETC lpFormatEtc)
{
	ASSERT_VALID(this);
	ASSERT(m_lpObject == NULL);     // one time only
	ASSERT(m_pDocument != NULL);
	ASSERT(lpFormatEtc == NULL ||
		AfxIsValidAddress(lpFormatEtc, sizeof(FORMATETC), FALSE));

	// get storage for the object via virtual function call
	m_dwItemNumber = GetNewItemNumber();
	GetItemStorage();
	ASSERT(m_lpStorage != NULL);

	// fill in FORMATETC struct
	FORMATETC formatEtc;
	lpFormatEtc = _AfxFillFormatEtc(lpFormatEtc, cfFormat, &formatEtc);

	// attempt to create the object
	LPOLECLIENTSITE lpClientSite = GetClientSite();
	LPDATAOBJECT lpDataObject = pDataObject->GetIDataObject(FALSE);
	SCODE sc = ::OleCreateFromData(lpDataObject, IID_IUnknown, render,
		lpFormatEtc, lpClientSite, m_lpStorage, (LPLP)&m_lpObject);
	BOOL bResult = FinishCreate(sc);

	ASSERT_VALID(this);
	return bResult;
}

BOOL COleClientItem::CreateLinkFromData(COleDataObject* pDataObject,
	OLERENDER render, CLIPFORMAT cfFormat, LPFORMATETC lpFormatEtc)
{
	ASSERT_VALID(this);
	ASSERT(m_lpObject == NULL);     // one time only
	ASSERT(m_pDocument != NULL);
	ASSERT(lpFormatEtc == NULL ||
		AfxIsValidAddress(lpFormatEtc, sizeof(FORMATETC), FALSE));

	// get storage for the object via virtual function call
	m_dwItemNumber = GetNewItemNumber();
	GetItemStorage();
	ASSERT(m_lpStorage != NULL);

	// fill in FORMATETC struct
	FORMATETC formatEtc;
	lpFormatEtc = _AfxFillFormatEtc(lpFormatEtc, cfFormat, &formatEtc);

	// attempt to create the link
	LPOLECLIENTSITE lpClientSite = GetClientSite();
	LPDATAOBJECT lpDataObject = pDataObject->GetIDataObject(FALSE);
	SCODE sc = ::OleCreateLinkFromData(lpDataObject, IID_IUnknown,
		render, lpFormatEtc, lpClientSite, m_lpStorage, (LPLP)&m_lpObject);
	BOOL bResult = FinishCreate(sc);

	ASSERT_VALID(this);
	return bResult;
}

BOOL COleClientItem::CreateStaticFromData(COleDataObject* pDataObject,
	OLERENDER render, CLIPFORMAT cfFormat, LPFORMATETC lpFormatEtc)
{
	ASSERT_VALID(this);
	ASSERT(m_lpObject == NULL);     // one time only
	ASSERT(m_pDocument != NULL);
	ASSERT(lpFormatEtc == NULL ||
		AfxIsValidAddress(lpFormatEtc, sizeof(FORMATETC), FALSE));

	// get storage for the object via virtual function call
	m_dwItemNumber = GetNewItemNumber();
	GetItemStorage();
	ASSERT(m_lpStorage != NULL);

	// fill in FORMATETC struct
	FORMATETC formatEtc;
	lpFormatEtc = _AfxFillFormatEtc(lpFormatEtc, cfFormat, &formatEtc);

	// attempt to create the link
	LPOLECLIENTSITE lpClientSite = GetClientSite();
	LPDATAOBJECT lpDataObject = pDataObject->GetIDataObject(FALSE);
	SCODE sc = ::OleCreateStaticFromData(lpDataObject, IID_IUnknown,
		render, lpFormatEtc, lpClientSite, m_lpStorage, (LPLP)&m_lpObject);
	BOOL bResult = FinishCreate(sc);

	ASSERT_VALID(this);
	return bResult;
}

// Creation from files (in OLE 1.0, the user did this through packager)
BOOL COleClientItem::CreateFromFile(LPCTSTR lpszFileName, REFCLSID clsid,
	OLERENDER render, CLIPFORMAT cfFormat, LPFORMATETC lpFormatEtc)
{
	ASSERT_VALID(this);
	ASSERT(m_lpObject == NULL);     // one time only
	ASSERT(m_pDocument != NULL);
	ASSERT(lpFormatEtc == NULL ||
		AfxIsValidAddress(lpFormatEtc, sizeof(FORMATETC), FALSE));

	// get storage for the object via virtual function call
	m_dwItemNumber = GetNewItemNumber();
	GetItemStorage();
	ASSERT(m_lpStorage != NULL);

	// fill in FORMATETC struct
	FORMATETC formatEtc;
	lpFormatEtc = _AfxFillFormatEtc(lpFormatEtc, cfFormat, &formatEtc);

	// attempt to create the object
	LPOLECLIENTSITE lpClientSite = GetClientSite();
	CStringW strFileName(lpszFileName);
	SCODE sc = ::OleCreateFromFile(clsid, strFileName.GetString(),
		IID_IUnknown, render, lpFormatEtc, lpClientSite, m_lpStorage,
		(LPLP)&m_lpObject);

	BOOL bResult = FinishCreate(sc);

	ASSERT_VALID(this);
	return bResult;
}

BOOL COleClientItem::CreateLinkFromFile(LPCTSTR lpszFileName,
	OLERENDER render, CLIPFORMAT cfFormat, LPFORMATETC lpFormatEtc)
{
	ASSERT_VALID(this);
	ASSERT(m_lpObject == NULL);     // one time only
	ASSERT(m_pDocument != NULL);
	ASSERT(lpFormatEtc == NULL ||
		AfxIsValidAddress(lpFormatEtc, sizeof(FORMATETC), FALSE));

	// get storage for the object via virtual function call
	m_dwItemNumber = GetNewItemNumber();
	GetItemStorage();
	ASSERT(m_lpStorage != NULL);

	// fill in FORMATETC struct
	FORMATETC formatEtc;
	lpFormatEtc = _AfxFillFormatEtc(lpFormatEtc, cfFormat, &formatEtc);

	// attempt to create the link
	LPOLECLIENTSITE lpClientSite = GetClientSite();
	CStringW strFileName(lpszFileName);
	SCODE sc = ::OleCreateLinkToFile(strFileName.GetString(),
		IID_IUnknown, render, lpFormatEtc, lpClientSite, m_lpStorage,
		(LPLP)&m_lpObject);

	BOOL bResult = FinishCreate(sc);

	ASSERT_VALID(this);
	return bResult;
}

// create from class name (for insert item dialog)
BOOL COleClientItem::CreateNewItem(REFCLSID clsid,
	OLERENDER render, CLIPFORMAT cfFormat, LPFORMATETC lpFormatEtc)
{
	ASSERT_VALID(this);
	ASSERT(m_lpObject == NULL);     // one time only
	ASSERT(m_pDocument != NULL);
	ASSERT(lpFormatEtc == NULL ||
		AfxIsValidAddress(lpFormatEtc, sizeof(FORMATETC), FALSE));

	// get storage for the object via virtual function call
	m_dwItemNumber = GetNewItemNumber();
	GetItemStorage();
	ASSERT(m_lpStorage != NULL);

	// fill in FORMATETC struct
	FORMATETC formatEtc;
	lpFormatEtc = _AfxFillFormatEtc(lpFormatEtc, cfFormat, &formatEtc);

	// attempt to create the object
	LPOLECLIENTSITE lpClientSite = GetClientSite();
	SCODE sc = ::OleCreate(clsid, IID_IUnknown,
		render, lpFormatEtc, lpClientSite, m_lpStorage, (LPLP)&m_lpObject);
	BOOL bResult = FinishCreate(sc);

	ASSERT_VALID(this);
	return bResult;
}

/////////////////////////////////////////////////////////////////////////////
// More advanced creation

BOOL COleClientItem::CreateCloneFrom(const COleClientItem* pSrcItem)
{
	ASSERT_VALID(this);
	ASSERT(m_lpObject == NULL);     // one time only
	ASSERT_VALID(pSrcItem);
	ASSERT(m_pDocument != NULL);

	// create storage for the item
	m_dwItemNumber = GetNewItemNumber();
	GetItemStorage();
	ASSERT(m_lpStorage != NULL);

	// save the object first
	LPPERSISTSTORAGE lpPersistStorage =
		QUERYINTERFACE(pSrcItem->m_lpObject, IPersistStorage);
	ASSERT(lpPersistStorage != NULL);
	SCODE sc = ::OleSave(lpPersistStorage, m_lpStorage, FALSE);
	lpPersistStorage->SaveCompleted(NULL);
	lpPersistStorage->Release();
	if (sc != S_OK)
	{
		// failed the save, do not attempt to create clone
		m_scLast = sc;
		return FALSE;
	}

	// get information on the view advise type
	ASSERT(pSrcItem->m_lpViewObject != NULL);
	DWORD dwAspect;
   IAdviseSink* pAdviseSink;
   pAdviseSink = NULL;
	VERIFY(pSrcItem->m_lpViewObject->GetAdvise(&dwAspect, NULL, &pAdviseSink) ==
	  S_OK);
   if( pAdviseSink != NULL )
   {
	  RELEASE(pAdviseSink);
   }

	// then load the new object from the new storage
	LPOLECLIENTSITE lpClientSite = GetClientSite();
	sc = ::OleLoad(m_lpStorage, IID_IUnknown,
		lpClientSite, (LPLP)&m_lpObject);
	BOOL bResult = FinishCreate(sc);

	ASSERT_VALID(this);
	return bResult;
}

/////////////////////////////////////////////////////////////////////////////
// Storage for COleClientItem objects (memory and compound files)

BOOL COleClientItem::IsModified() const
{
   SCODE sc;

	ASSERT_VALID(this);
	ASSERT(m_lpObject != NULL);

	// get IPersistStorage interface, and call IsDirty
	LPPERSISTSTORAGE lpPersistStorage =
		QUERYINTERFACE(m_lpObject, IPersistStorage);
   if( lpPersistStorage != NULL )
   {
	   sc = lpPersistStorage->IsDirty();
	   lpPersistStorage->Release();
   }
   else
   {
	  LPPERSISTSTREAMINIT lpPersistStreamInit;
	  lpPersistStreamInit = QUERYINTERFACE( m_lpObject, IPersistStreamInit );
	  if( lpPersistStreamInit != NULL )
	  {
		 sc = lpPersistStreamInit->IsDirty();
		 lpPersistStreamInit->Release();
	  }
	  else
	  {
		 LPPERSISTSTREAM lpPersistStream;
		 lpPersistStream = QUERYINTERFACE( m_lpObject, IPersistStream );
		 if( lpPersistStream != NULL )
		 {
			sc = lpPersistStream->IsDirty();
			lpPersistStream->Release();
		 }
		 else
		 {
			sc = E_NOINTERFACE;
		 }
	  }
   }

	// S_OK == S_TRUE, therefore object dirty!
	return sc == S_OK || FAILED(sc);
}

void COleClientItem::GetItemStorageFlat()
{
	ASSERT_VALID(this);
	ASSERT(m_lpStorage == NULL);
	ASSERT(m_lpLockBytes == NULL);

	SCODE sc = ::CreateILockBytesOnHGlobal(NULL, TRUE, &m_lpLockBytes);
	if (sc != S_OK)
		AfxThrowOleException(sc);
	ASSERT(m_lpLockBytes != NULL);

	sc = ::StgCreateDocfileOnILockBytes(m_lpLockBytes,
		STGM_SHARE_EXCLUSIVE|STGM_CREATE|STGM_READWRITE, 0, &m_lpStorage);
	if (sc != S_OK)
	{
		VERIFY(m_lpLockBytes->Release() == 0);
		m_lpLockBytes = NULL;
		AfxThrowOleException(sc);
	}
	ASSERT(m_lpStorage != NULL);

	ASSERT_VALID(this);
}

void COleClientItem::ReadItemFlat(CArchive& ar)
{
	ASSERT_VALID(this);
	ASSERT(m_lpStorage == NULL);
	ASSERT(m_lpLockBytes == NULL);

	// read number of bytes in the ILockBytes
	DWORD dwBytes;
	ar >> dwBytes;

	// allocate enough memory to read entire block
	HGLOBAL hStorage = ::GlobalAlloc(GMEM_SHARE|GMEM_MOVEABLE, dwBytes);
	if (hStorage == NULL)
		AfxThrowMemoryException();

	LPVOID lpBuf = ::GlobalLock(hStorage);
	ASSERT(lpBuf != NULL);
	DWORD dwBytesRead = ar.Read(lpBuf, dwBytes);
	::GlobalUnlock(hStorage);

	// throw exception in case of partial object
	if (dwBytesRead != dwBytes)
	{
		::GlobalFree(hStorage);
		AfxThrowArchiveException(CArchiveException::endOfFile);
	}

	SCODE sc = CreateILockBytesOnHGlobal(hStorage, TRUE, &m_lpLockBytes);
	if (sc != S_OK)
	{
		::GlobalFree(hStorage);
		AfxThrowOleException(sc);
	}
	ASSERT(m_lpLockBytes != NULL);
	ASSERT(::StgIsStorageILockBytes(m_lpLockBytes) == S_OK);

	sc = ::StgOpenStorageOnILockBytes(m_lpLockBytes, NULL,
		STGM_SHARE_EXCLUSIVE|STGM_READWRITE, NULL, 0, &m_lpStorage);
	if (sc != S_OK)
	{
		VERIFY(m_lpLockBytes->Release() == 0);
		m_lpLockBytes = NULL;
			// ILockBytes::Release will GlobalFree the hStorage
		AfxThrowOleException(sc);
	}

	// attempt to load the object from the storage
	LPUNKNOWN lpUnk = NULL;
	sc = ::OleLoad(m_lpStorage, IID_IUnknown, GetClientSite(),
		(LPLP)&lpUnk);
	CheckGeneral(sc);

	ASSERT(lpUnk != NULL);
	m_lpObject = QUERYINTERFACE(lpUnk, IOleObject);
	lpUnk->Release();
	if (m_lpObject == NULL)
		AfxThrowOleException(E_OUTOFMEMORY);

	ASSERT_VALID(this);
}

void COleClientItem::WriteItemFlat(CArchive& ar)
{
	ASSERT_VALID(this);
	ASSERT(m_lpStorage != NULL);
	ASSERT(m_lpLockBytes != NULL);

	// save the OLE object to its storage first
	LPPERSISTSTORAGE lpPersistStorage =
		QUERYINTERFACE(m_lpObject, IPersistStorage);
	ASSERT(lpPersistStorage != NULL);
	SCODE sc;
	if (GetDocument()->m_bCompoundFile || lpPersistStorage->IsDirty() == S_OK)
	{
		sc = ::OleSave(lpPersistStorage, m_lpStorage,
			!GetDocument()->m_bCompoundFile);
		lpPersistStorage->SaveCompleted(NULL);
	}
	lpPersistStorage->Release();
	m_lpStorage->Commit(STGC_OVERWRITE);
	ASSERT(::StgIsStorageILockBytes(m_lpLockBytes) == S_OK);

	// attempt to get the handle to the global memory
	HGLOBAL hStorage;
	sc = ::GetHGlobalFromILockBytes(m_lpLockBytes, &hStorage);
	if (sc != S_OK)
		AfxThrowOleException(sc);

	// first write a byte count
	STATSTG statstg;
	sc = m_lpLockBytes->Stat(&statstg, STATFLAG_NONAME);
	if (sc != S_OK)
		AfxThrowOleException(sc);
	ASSERT(statstg.cbSize.HighPart == 0);   // don't support >4GB objects
	DWORD dwBytes = statstg.cbSize.LowPart;
	ar << dwBytes;

	// write the contents of the block
	LPVOID lpBuf = GlobalLock(hStorage);
	ASSERT(lpBuf != NULL);
	ar.Write(lpBuf, (UINT)dwBytes);
	::GlobalUnlock(hStorage);
}

void COleClientItem::GetItemStorageCompound()
{
	COleDocument* pDoc = GetDocument();
	ASSERT_VALID(pDoc);
	ASSERT(pDoc->m_bCompoundFile);
	if (pDoc->m_lpRootStg == NULL)
	{
		ASSERT(pDoc->m_bEmbedded);
		pDoc->m_bEmbedded = FALSE;
		if (!pDoc->OnNewDocument())
		{
			TRACE(traceOle, 0, "Warning OnNewDocument failed during COleClientItem::CreateXXXX\n");
			AfxThrowMemoryException();
		}
	}
	ASSERT(pDoc->m_lpRootStg != NULL);

	// get item name
	TCHAR szItemName[OLE_MAXITEMNAME];
	GetItemName(szItemName, _countof(szItemName));

	// create storage for this item
	LPSTORAGE lpStorage;
	CStringW strItemName(szItemName);
	SCODE sc = pDoc->m_lpRootStg->CreateStorage(strItemName.GetString(),
		STGM_CREATE|STGM_READWRITE|STGM_TRANSACTED|STGM_SHARE_EXCLUSIVE,
		0, 0, &lpStorage);
	if (sc != S_OK)
	{
		TRACE(traceOle, 0, _T("Warning: unable to create child storage %s.\n"), szItemName);
		// upon failure throw file exception (item will be cleaned up)
		AfxThrowOleException(sc);
	}
	ASSERT(lpStorage != NULL);

	// everything should have worked
	m_lpStorage = lpStorage;
	ASSERT(m_lpStorage != NULL);
}

void COleClientItem::ReadItemCompound(CArchive& ar)
{
	COleDocument* pDoc = GetDocument();
	ASSERT_VALID(pDoc);
	ASSERT(pDoc->m_lpRootStg != NULL);
	ASSERT(pDoc->m_bCompoundFile);
	ASSERT(m_lpStorage == NULL);
	ASSERT(m_lpLockBytes == NULL);

	if (ar.m_bForceFlat)
	{
		ReadItemFlat(ar);
		RELEASE(m_lpStorage);
		RELEASE(m_lpLockBytes);

		// change the number to something definitely unique
		m_dwItemNumber = GetNewItemNumber();

		// create new storage
		GetItemStorageCompound();
		LPPERSISTSTORAGE lpPersistStorage =
			QUERYINTERFACE(m_lpObject, IPersistStorage);
		ASSERT(lpPersistStorage != NULL);
		SCODE sc = ::OleSave(lpPersistStorage, m_lpStorage, FALSE);
		if (FAILED(sc))
		{
			lpPersistStorage->Release();
			CheckGeneral(sc);
		}
		VERIFY(lpPersistStorage->SaveCompleted(m_lpStorage) == S_OK);
		lpPersistStorage->Release();
	}
	else
	{
		// get item name
		TCHAR szItemName[OLE_MAXITEMNAME];
		GetItemName(szItemName, _countof(szItemName));

		// open storage for this item
		LPSTORAGE lpStorage;
		CStringW strItemName(szItemName);
		DWORD grfMode = STGM_READWRITE | STGM_SHARE_EXCLUSIVE;

		if (!pDoc->IsSearchAndOrganizeHandler())
			grfMode |= STGM_TRANSACTED;

		SCODE sc = pDoc->m_lpRootStg->OpenStorage(strItemName.GetString(), NULL,
			grfMode, 0, 0, &lpStorage);

		if (sc != S_OK)
		{
			TRACE(traceOle, 0, _T("Warning: unable to open child storage for write. Opening for read only %s.\n"), szItemName);
			sc = pDoc->m_lpRootStg->OpenStorage(strItemName.GetString(), NULL,
				STGM_READ | STGM_SHARE_EXCLUSIVE, 0, 0, &lpStorage);
		}

		if (sc != S_OK)
		{
			TRACE(traceOle, 0, _T("Warning: unable to open child storage %s.\n"), szItemName);
			// upon failure throw file exception (item will be cleaned up)
			AfxThrowOleException(sc);
		}
		ASSERT(lpStorage != NULL);

		// remember the storage
		m_lpStorage = lpStorage;
		ASSERT(m_lpStorage != NULL);

		// attempt to load the object from the storage
		LPUNKNOWN lpUnk = NULL;
		sc = ::OleLoad(m_lpStorage, IID_IUnknown, GetClientSite(),
			(LPLP)&lpUnk);
		CheckGeneral(sc);

		// get IOleObject interface for the newly loaded object
		ASSERT(lpUnk != NULL);
		m_lpObject = QUERYINTERFACE(lpUnk, IOleObject);
		lpUnk->Release();
		if (m_lpObject == NULL)
			AfxThrowOleException(E_OUTOFMEMORY);
	}
}

void COleClientItem::WriteItemCompound(CArchive& ar)
{
	COleDocument* pDoc = GetDocument();
	ASSERT_VALID(pDoc);
	ASSERT(pDoc->m_lpRootStg != NULL);
	ASSERT(pDoc->m_bCompoundFile);
	ASSERT(m_lpNewStorage == NULL);

	if (ar.m_bForceFlat)
	{
		LPSTORAGE pTempStorage = m_lpStorage;
		LPLOCKBYTES pTempLockBytes = m_lpLockBytes;
		m_lpStorage = NULL;
		m_lpLockBytes = NULL;
		GetItemStorageFlat();
		WriteItemFlat(ar);
		RELEASE(m_lpStorage);
		RELEASE(m_lpLockBytes);
		m_lpStorage = pTempStorage;
		m_lpLockBytes = pTempLockBytes;
		return;
	}

	// get item name
	TCHAR szItemName[OLE_MAXITEMNAME];
	GetItemName(szItemName, _countof(szItemName));

	// determine destination storage
	ASSERT(m_lpStorage != NULL);
	LPSTORAGE lpStorage = m_lpStorage;
	if (!pDoc->m_bSameAsLoad)
	{
		// need to create new storage for this item
		CStringW strItemName(szItemName);
		SCODE sc = pDoc->m_lpRootStg->CreateStorage(strItemName.GetString(),
			STGM_CREATE|STGM_READWRITE|STGM_TRANSACTED|STGM_SHARE_EXCLUSIVE,
			0, 0, &lpStorage);
		if (sc != S_OK)
		{
			TRACE(traceOle, 0, _T("Warning: unable to create child storage %s.\n"),
				szItemName);
			AfxThrowOleException(sc);
		}
		// remember the storage for CommitItem stage
		m_lpNewStorage = lpStorage;
		m_bNeedCommit = TRUE;
	}
	ASSERT(lpStorage != NULL);

	// save dirty object
	LPPERSISTSTORAGE lpPersistStorage =
		QUERYINTERFACE(m_lpObject, IPersistStorage);
	ASSERT(lpPersistStorage != NULL);
	SCODE sc = S_OK;
	if (!pDoc->m_bSameAsLoad || lpPersistStorage->IsDirty() == S_OK)
	{
		// call OleSave now and IPersistStorage::SaveCompleted later
		sc = ::OleSave(lpPersistStorage, lpStorage, pDoc->m_bSameAsLoad);
	}
	lpPersistStorage->Release();

	// if it fails, abort the save
	if (FAILED(sc))
		AfxThrowOleException(sc);

	// now will need to call CommitItem for this item
	m_bNeedCommit = TRUE;
	lpStorage->Commit(STGC_ONLYIFCURRENT);
}

void COleClientItem::GetItemStorage()
{
	if (GetDocument()->m_bCompoundFile)
		GetItemStorageCompound();
	else
		GetItemStorageFlat();
}

void COleClientItem::ReadItem(CArchive& ar)
{
	if (GetDocument()->m_bCompoundFile)
		ReadItemCompound(ar);
	else
		ReadItemFlat(ar);
}

void COleClientItem::WriteItem(CArchive& ar)
{
	if (GetDocument()->m_bCompoundFile)
		WriteItemCompound(ar);
	else
		WriteItemFlat(ar);
}

void COleClientItem::CommitItem(BOOL bSuccess)
{
	ASSERT_VALID(this);
	ASSERT(m_lpObject != NULL);

	if (!m_bNeedCommit)
		return;
	
	// forget about new storage if save failed along the way...
	if (m_lpNewStorage != NULL && !bSuccess)
		RELEASE(m_lpNewStorage);

	LPPERSISTSTORAGE lpPersistStorage =
		QUERYINTERFACE(m_lpObject, IPersistStorage);
	ENSURE(lpPersistStorage != NULL);

	// let the object remember the new storage (can be null - see !bSuccess above).
	//Calling SaveCompleted without IPersistStorage::Save ( or ::OleSave) returns E_UNEXPECTED,
	//but shouldn't change the state of the object.
	HRESULT hr=lpPersistStorage->SaveCompleted(m_lpNewStorage);
	ASSERT(SUCCEEDED(hr) || hr==E_UNEXPECTED);
	lpPersistStorage->Release();

	// determine/remember new storage
	if (m_lpNewStorage != NULL)
	{
		m_lpStorage->Release();
		m_lpStorage = m_lpNewStorage;
		m_lpNewStorage = NULL;
	}

	m_bNeedCommit = FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// COleClientItem serialization

void COleClientItem::Serialize(CArchive& ar)
{
	ASSERT_VALID(this);

	CDocItem::Serialize(ar);
	ASSERT(m_pDocument != NULL);  // must 'SetDocument' first

	if (ar.IsStoring())
	{
		ASSERT(m_lpObject != NULL);

		// first, save the type flag (this is used for versioning)
		ar << (DWORD)OT_OLE2;

		ar << m_dwItemNumber;   // save the item number

		// write the view advise type to storage
		ASSERT(m_lpViewObject != NULL);
		DWORD dwAspect;
	  IAdviseSink* pAdviseSink;
	  pAdviseSink = NULL;
		VERIFY(m_lpViewObject->GetAdvise(&dwAspect, NULL, &pAdviseSink) == S_OK);
	  if( pAdviseSink != NULL )
	  {
		 RELEASE(pAdviseSink);
	  }
		ar << dwAspect;         // save the display aspect

		// write flag indicating whether to create moniker upon load
		ar << (WORD)m_bMoniker;

		// save current default display aspect
		ar << (DWORD)m_nDrawAspect;

		// save object to storage (calls OleSave)
		WriteItem(ar);
	}
	else
	{
		ASSERT(m_lpObject == NULL);

		// first, get the type flag (for OLE 1.0 compatible reading)
		DWORD dwType;
		ar >> dwType;
		if (dwType != OT_OLE2)
			AfxThrowArchiveException(CArchiveException::genericException);

		ar >> m_dwItemNumber;   // get the item number

		DWORD dwAspect; // read the display aspect (aspects that are cached)
		ar >> dwAspect;

		WORD bMoniker;  // see if we should create & set the moniker
		ar >> bMoniker;

		DWORD nDrawAspect;  // read the default display aspect
		ar >> nDrawAspect;
		m_nDrawAspect = (DVASPECT)nDrawAspect;

		// read the OLE object from storage (calls OleLoad)
		ReadItem(ar);

		// finish OLE object creation process, setup advises, etc.
		if (!FinishCreate(S_OK))
			AfxThrowArchiveException(CArchiveException::genericException);

		if (bMoniker)
		{
			// force moniker creation by calling GetMoniker
			LPMONIKER lpMoniker;
			if (GetClientSite()->GetMoniker(OLEGETMONIKER_FORCEASSIGN,
				OLEWHICHMK_OBJREL, &lpMoniker) == S_OK)
			{
				ASSERT(lpMoniker != NULL);
				lpMoniker->Release();
				ASSERT(m_bMoniker); // moniker should have been assigned
			}
		}

		// fix up the document's m_dwNextItemNumber
		if (m_dwItemNumber >= GetDocument()->m_dwNextItemNumber)
			GetDocument()->m_dwNextItemNumber = m_dwItemNumber + 1;
	}
}

/////////////////////////////////////////////////////////////////////////////
// default callback implementation

void COleClientItem::OnChange(OLE_NOTIFICATION nCode, DWORD /*dwParam*/)
{
	ASSERT_VALID(this);

	switch (nCode)
	{
	case OLE_CLOSED:
		break;  // no default implementation

	case OLE_CHANGED:
	case OLE_SAVED:
		ASSERT(m_pDocument != NULL);
		m_pDocument->SetModifiedFlag();
		break;

	case OLE_CHANGED_STATE:
	case OLE_CHANGED_ASPECT:
		break;  // no default implementation

	default:
		ASSERT(FALSE);
	}

	ASSERT_VALID(this);
}

void COleClientItem::OnDataChange(
	LPFORMATETC /*lpFormatEtc*/, LPSTGMEDIUM /*lpStgMedium*/)
{
	ASSERT(FALSE);  // derivative must override -- must not call base class
}

void COleClientItem::OnGetItemPosition(CRect& /*rPosition*/)
{
	// default does nothing
}

void COleClientItem::OnGetClipRect(CRect& rClipRect)
{
	ASSERT_VALID(this);
	ASSERT(AfxIsValidAddress(&rClipRect, sizeof(RECT)));

	// default clips rectClip to client area of the active view
	ASSERT_VALID(m_pView);
	m_pView->GetClientRect(&rClipRect);
}

void COleClientItem::OnShowItem()
{
	ASSERT_VALID(this);

	CDocument* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	// attempt to use m_pView set during activation
	CView* pView = m_pView;
	if (pView == NULL)
	{
		// otherwise, find the first view of this document
		POSITION pos = pDoc->GetFirstViewPosition();
		if (pos == NULL || (pView = pDoc->GetNextView(pos)) == NULL)
			return;
	}

	CFrameWnd* pFrameWnd = pView->GetParentFrame();
	if (pFrameWnd != NULL)
	{
		// activate frame holding view
		pFrameWnd->ActivateFrame();
		pFrameWnd->OnUpdateFrameTitle(TRUE);

		// activate app frame if necessary
		pFrameWnd = pFrameWnd->GetParentFrame();
		if (pFrameWnd != NULL)
		{
			ASSERT_KINDOF(CFrameWnd, pFrameWnd);
			pFrameWnd->ActivateFrame();
			pFrameWnd->OnUpdateFrameTitle(TRUE);
		}
	}

	if (!pDoc->GetPathName().IsEmpty())
	{
		// user is also in control of the application, when a file-based
		//  document becomes visible.
		AfxOleSetUserCtrl(TRUE);
	}
}

/////////////////////////////////////////////////////////////////////////////
// COleClientItem - attributes

void COleClientItem::GetClassID(CLSID* pClassID) const
{
	ASSERT_VALID(this);
	ASSERT(m_lpObject != NULL);
	ASSERT(AfxIsValidAddress(pClassID, sizeof(CLSID)));

	if (m_lpObject->GetUserClassID(pClassID) != S_OK)
		*pClassID = CLSID_NULL;
}

BOOL COleClientItem::GetExtent(LPSIZE lpSize, DVASPECT nDrawAspect)
{
	ASSERT_VALID(this);
	ASSERT(m_lpObject != NULL);
	ASSERT(AfxIsValidAddress(lpSize, sizeof(CSize)));

	// use current default aspect if specific one not specified
	if (nDrawAspect == -1)
		nDrawAspect = m_nDrawAspect;

	// get the extent
	m_scLast = m_lpObject->GetExtent(nDrawAspect, lpSize);
	return m_scLast == S_OK;
}

BOOL COleClientItem::GetCachedExtent(LPSIZE lpSize, DVASPECT nDrawAspect)
{
	ASSERT_VALID(this);
	ASSERT(m_lpViewObject != NULL);
	ASSERT(AfxIsValidAddress(lpSize, sizeof(CSize)));

	// use current default aspect if specific one not specified
	if (nDrawAspect == -1)
		nDrawAspect = m_nDrawAspect;

	COleDocument* pDoc = (COleDocument*)GetDocument();
	ASSERT_VALID(pDoc);

	// get the extent
	m_scLast = m_lpViewObject->GetExtent(nDrawAspect, -1, pDoc->m_ptd, lpSize);
	return m_scLast == S_OK;
}

BOOL COleClientItem::SetIconicMetafile(HGLOBAL hMetaPict)
{
	ASSERT_VALID(this);
	ASSERT(m_lpObject != NULL);

	// get IOleCache interface
	LPOLECACHE lpOleCache = QUERYINTERFACE(m_lpObject, IOleCache);
	if (lpOleCache == NULL)
	{
		TRACE(traceOle, 0, "Warning: object does not support IOleCache interface.\n");
		return FALSE;
	}
	ASSERT(lpOleCache != NULL);

	// new cache is for CF_METAFILEPICT, DVASPECT_ICON
	FORMATETC formatEtc;
	formatEtc.cfFormat = CF_METAFILEPICT;
	formatEtc.ptd = NULL;
	formatEtc.dwAspect = DVASPECT_ICON;
	formatEtc.lindex = -1;
	formatEtc.tymed = TYMED_MFPICT;

	// setup the cache so iconic aspect is now included
	DWORD dwConnection;
	SCODE sc = lpOleCache->Cache(&formatEtc,
		ADVF_NODATA|ADVF_PRIMEFIRST|ADVF_ONLYONCE, &dwConnection);
	if (FAILED(sc))
	{
		lpOleCache->Release();
		return FALSE;
	}

	// set data if iconic image provided
	if (hMetaPict != NULL)
	{
		STGMEDIUM stgMedium;
		stgMedium.tymed = TYMED_MFPICT;
		stgMedium.hGlobal = hMetaPict;
		stgMedium.pUnkForRelease = NULL;

		sc = lpOleCache->SetData(&formatEtc, &stgMedium, FALSE);
		if (FAILED(sc))
		{
			lpOleCache->Release();
			return FALSE;
		}
	}
	lpOleCache->Release();

	return TRUE;
}

HGLOBAL COleClientItem::GetIconicMetafile()
{
	ASSERT_VALID(this);
	ASSERT(m_lpObject != NULL);

	// get IDataObject interface
	LPDATAOBJECT lpDataObject = QUERYINTERFACE(m_lpObject, IDataObject);
	ASSERT(lpDataObject != NULL);

	// cache is for CF_METAFILEPICT, DVASPECT_ICON
	FORMATETC formatEtc;
	formatEtc.cfFormat = CF_METAFILEPICT;
	formatEtc.ptd = NULL;
	formatEtc.dwAspect = DVASPECT_ICON;
	formatEtc.lindex = -1;
	formatEtc.tymed = TYMED_MFPICT;

	// attempt to get the icon picture
	STGMEDIUM stgMedium;
	if (lpDataObject->GetData(&formatEtc, &stgMedium) != S_OK)
	{
		lpDataObject->Release();

		// no current picture, attempt to get from class ID
		CLSID clsid;
		if (m_lpObject->GetUserClassID(&clsid) != S_OK)
			return NULL;

		TCHAR szTemp[_MAX_PATH];
		LPTSTR lpszLabel = NULL;
		if (GetType() == OT_LINK)
		{
			// it is a link, attempt to get link name
			LPOLELINK lpOleLink = QUERYINTERFACE(m_lpObject, IOleLink);
			if (lpOleLink != NULL)
			{
				LPOLESTR lpszDisplayName = NULL;
				lpOleLink->GetSourceDisplayName(&lpszDisplayName);
				if (lpszDisplayName != NULL)
				{
					szTemp[0] = 0;
					CString strDisplayName(lpszDisplayName);
					AfxGetFileTitle(strDisplayName.GetString(), szTemp, _countof(szTemp));
					if (szTemp[0] != '\0')
						lpszLabel = szTemp;
					CoTaskMemFree(lpszDisplayName);
				}
				lpOleLink->Release();
			}
		}

		HGLOBAL hMetaPict;
		if (lpszLabel != NULL)
		{
			CStringW strLabel(lpszLabel);
			hMetaPict = OleGetIconOfClass(clsid, const_cast<LPOLESTR>(strLabel.GetString()), FALSE);
		}
		else
		{
			hMetaPict = OleGetIconOfClass(clsid, NULL, TRUE);
		}
		if (hMetaPict != NULL)
		{
			// cache it for later GetData (or drawing)
			SetIconicMetafile(hMetaPict);
			return hMetaPict;
		}
		return NULL;
	}
	lpDataObject->Release();

	// can't handle data where punkForRelease is set
	if (stgMedium.pUnkForRelease != NULL)
	{
		::ReleaseStgMedium(&stgMedium);
		return NULL;
	}
	ASSERT(stgMedium.tymed == TYMED_MFPICT);
	ASSERT(stgMedium.hGlobal != NULL);

	return stgMedium.hGlobal;   // return HGLOBAL to METAFILEPICT
}

void COleClientItem::SetDrawAspect(DVASPECT nDrawAspect)
{
	ASSERT_VALID(this);

	// prime iconic cache (in case object has never displayed iconic)
	if (nDrawAspect == DVASPECT_ICON)
	{
		SetIconicMetafile(NULL);    // allow object to provide own icon
		HGLOBAL hMetaPict = GetIconicMetafile();
		_AfxDeleteMetafilePict(hMetaPict);
	}

	// Note: the aspect you are setting may be uncached and therefore blank.
	//  To make sure it is cached use SetIconPicture or use IOleCache to
	//  set the cache yourself.
	m_nDrawAspect = nDrawAspect;

	// mark document as dirty (m_nDrawAspect is part of persistent state)
	ASSERT_VALID(m_pDocument);
	m_pDocument->SetModifiedFlag();
}

// Helper used to get the DVTARGETDEVICE pointer for the first printer.
BOOL COleClientItem::GetPrintDeviceInfo(
	LPOLECACHE* plpOleCache, DVTARGETDEVICE** pptd, DWORD* pdwConnection)
{
	*plpOleCache = NULL;
	*pptd = NULL;

	// get IOleCache interface
	LPOLECACHE lpOleCache = QUERYINTERFACE(m_lpObject, IOleCache);
	if (lpOleCache == NULL)
	{
		TRACE(traceOle, 0, "Warning: object does not support IOleCache interface.\n");
		return FALSE;   // no cache -- no possible print device
	}
	ASSERT(lpOleCache != NULL);

	// get enumerator for the cache
	LPENUMSTATDATA lpEnumSTATDATA;
	if (lpOleCache->EnumCache(&lpEnumSTATDATA) != S_OK || lpEnumSTATDATA == NULL)
	{
		lpOleCache->Release();
		return FALSE;
	}
	// enumerate entries in the cache (look for one with ptd != NULL)
	STATDATA statData;
	while (lpEnumSTATDATA->Next(1, &statData, NULL) == S_OK)
	{
		ASSERT(statData.pAdvSink == NULL);

		// return first non-NULL ptd (we assume this is a printer cache)
		if (statData.formatetc.ptd != NULL)
		{
			if (pdwConnection != NULL)
				*pdwConnection = statData.dwConnection;
			*pptd = statData.formatetc.ptd;
			lpEnumSTATDATA->Release();

			*plpOleCache = lpOleCache;
			return TRUE;    // Note: lpOleCache pointer is still alive
		}
	}
	// release interfaces
	lpEnumSTATDATA->Release();
	lpOleCache->Release();
	return FALSE;   // data not found
}

void COleClientItem::AttachDataObject(COleDataObject& rDataObject) const
{
	ASSERT_VALID(this);
	ASSERT(m_lpObject != NULL);

	// get the IDataObject interface for the item
	LPDATAOBJECT lpDataObject = QUERYINTERFACE(m_lpObject, IDataObject);
	ASSERT(lpDataObject != NULL);

	// return it by attaching it
	rDataObject.Attach(lpDataObject, TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// COleClientItem - general operations

BOOL COleClientItem::Draw(CDC* pDC, LPCRECT lpBounds, DVASPECT nDrawAspect)
{
	ENSURE_VALID(this);
	ENSURE(lpBounds);
	ENSURE_VALID(pDC);

	ASSERT(AfxIsValidAddress(lpBounds, sizeof(RECT), FALSE));

	if (m_lpObject == NULL || m_lpViewObject == NULL)
		return FALSE;   // partially created COleClientItem object

	// use current draw aspect if aspect is -1 (default)
	if (nDrawAspect == -1)
		nDrawAspect = m_nDrawAspect;

	// convert RECT lpBounds to RECTL rclBounds
	RECTL rclBounds;
	rclBounds.left = lpBounds->left;
	rclBounds.top = lpBounds->top;
	rclBounds.right = lpBounds->right;
	rclBounds.bottom = lpBounds->bottom;

	// get RECTL describing window extents and origin
	RECTL rclWBounds;
	CPoint ptOrg = pDC->GetWindowOrg();
	CSize sizeExt = pDC->GetWindowExt();
	rclWBounds.left = ptOrg.x;
	rclWBounds.top = ptOrg.y;
	rclWBounds.right = sizeExt.cx;
	rclWBounds.bottom = sizeExt.cy;

	// get target device to use for draw
	COleDocument* pDoc = GetDocument();
	const DVTARGETDEVICE* ptd = NULL;
	HDC hdcTarget = NULL;
	if (pDC->IsPrinting() && pDoc->m_ptd != NULL)
	{
		ptd = pDoc->m_ptd;
		hdcTarget = pDC->m_hAttribDC;
	}

	// attempt draw with target device
	SCODE sc = m_lpViewObject->Draw(nDrawAspect, -1, NULL,
		(DVTARGETDEVICE*)ptd, hdcTarget, pDC->m_hDC,
		&rclBounds, &rclWBounds, NULL, 0);
	if (ptd != NULL && sc == OLE_E_BLANK)
	{
		// attempt draw without target device
		sc = m_lpViewObject->Draw(nDrawAspect, -1, NULL,
			NULL, NULL, pDC->m_hDC,
			&rclBounds, &rclWBounds, NULL, 0);
	}

	if (sc != S_OK && sc == OLE_E_BLANK)
		return FALSE;   // return FALSE if the object is blank

	CheckGeneral(sc);   // otherwise, may throw exception on error
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// COleClientItem clipboard helpers

void COleClientItem::GetEmbeddedItemData(LPSTGMEDIUM lpStgMedium)
{
	ASSERT_VALID(this);
	ASSERT(AfxIsValidAddress(lpStgMedium, sizeof(STGMEDIUM)));

	LPLOCKBYTES lpLockBytes;
	SCODE sc = ::CreateILockBytesOnHGlobal(NULL, TRUE, &lpLockBytes);
	if (sc != S_OK)
		AfxThrowOleException(sc);
	ASSERT(lpLockBytes != NULL);

	LPSTORAGE lpStorage;
	sc = ::StgCreateDocfileOnILockBytes(lpLockBytes,
		STGM_SHARE_EXCLUSIVE|STGM_CREATE|STGM_READWRITE, 0, &lpStorage);
	if (sc != S_OK)
	{
		VERIFY(lpLockBytes->Release() == 0);
		AfxThrowOleException(sc);
	}
	ASSERT(lpStorage != NULL);
	lpLockBytes->Release();

	// save the object into the storage
	LPPERSISTSTORAGE lpPersistStorage =
		QUERYINTERFACE(m_lpObject, IPersistStorage);
	ASSERT(lpPersistStorage != NULL);
	sc = ::OleSave(lpPersistStorage, lpStorage, FALSE);
	lpPersistStorage->SaveCompleted(NULL);
	lpPersistStorage->Release();
	if (sc != S_OK)
	{
		VERIFY(lpStorage->Release() == 0);
		AfxThrowOleException(sc);
	}

	// add it to the data source
	lpStgMedium->tymed = TYMED_ISTORAGE;
	lpStgMedium->pstg = lpStorage;
	lpStgMedium->pUnkForRelease = NULL;
}

void COleClientItem::AddCachedData(COleDataSource* pDataSource)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDataSource);

	// get IOleCache interface
	LPOLECACHE lpOleCache = QUERYINTERFACE(m_lpObject, IOleCache);
	if (lpOleCache == NULL)
	{
		TRACE(traceOle, 0, "Warning: object does not support IOleCache interface.\n");
		return;
	}
	ASSERT(lpOleCache != NULL);

	// Get IEnumSTATDATA interface for IOleCache
	LPENUMSTATDATA lpEnumSTATDATA;
	if (lpOleCache->EnumCache(&lpEnumSTATDATA) != S_OK || lpEnumSTATDATA == NULL)
	{
		lpOleCache->Release();
		return;
	}

	// get IDataObject interface
	LPDATAOBJECT lpDataObject = QUERYINTERFACE(m_lpObject, IDataObject);
	ASSERT(lpDataObject != NULL);

	// enumerate all of the cached formats
	STATDATA statData;
	while (lpEnumSTATDATA->Next(1, &statData, NULL) == S_OK)
	{
		ASSERT(statData.pAdvSink == NULL);

		// for each format supported, attempt to get copy of the data
		STGMEDIUM stgMedium;
		if (lpDataObject->GetData(&statData.formatetc, &stgMedium) != S_OK)
		{
			// data is not available
			CoTaskMemFree(statData.formatetc.ptd);
		}
		else if (stgMedium.pUnkForRelease != NULL)
		{
			// don't cache data with pUnkForRelease != NULL
			::ReleaseStgMedium(&stgMedium);
			CoTaskMemFree(statData.formatetc.ptd);
		}
		else
		{
			// format was acceptable -- add it to the clipboard
			pDataSource->CacheData(0, &stgMedium, &statData.formatetc);
		}
	}

	// release interfaces
	lpEnumSTATDATA->Release();
	lpDataObject->Release();
	lpOleCache->Release();
}

BOOL COleClientItem::GetLinkSourceData(LPSTGMEDIUM lpStgMedium)
{
	ASSERT_VALID(this);
	ASSERT(AfxIsValidAddress(lpStgMedium, sizeof(STGMEDIUM)));

	LPMONIKER lpMoniker = NULL;
	LPOLELINK lpOleLink = QUERYINTERFACE(m_lpObject, IOleLink);
	if (lpOleLink == NULL)
	{
		// get moniker from client site
		LPOLECLIENTSITE lpClientSite = GetClientSite();
		ASSERT(lpClientSite != NULL);
		SCODE sc = lpClientSite->GetMoniker(OLEGETMONIKER_TEMPFORUSER,
			OLEWHICHMK_OBJFULL, &lpMoniker);
		if (sc != S_OK)
		{
			TRACE(traceOle, 0, "Warning: unable to get moniker from client site.\n");
			return FALSE;
		}
		ASSERT(lpMoniker != NULL);
	}
	else
	{
		// get moniker from the link object itself
		SCODE sc = lpOleLink->GetSourceMoniker(&lpMoniker);
		lpOleLink->Release();
		if (sc != S_OK)
		{
			TRACE(traceOle, 0, "Warning: unable to get moniker from link source.\n");
			return FALSE;
		}
		ASSERT(lpMoniker != NULL);
	}

	// create a memory based stream to write the moniker to
	LPSTREAM lpStream;
	if (::CreateStreamOnHGlobal(NULL, TRUE, &lpStream) != S_OK)
	{
		lpMoniker->Release();
		AfxThrowMemoryException();
	}
	ASSERT(lpStream != NULL);

	// write the moniker to the stream, and add it to the clipboard
	SCODE sc = ::OleSaveToStream(lpMoniker, lpStream);
	lpMoniker->Release();
	if (sc != S_OK)
	{
		lpStream->Release();
		AfxThrowOleException(sc);
	}

	// write the class ID of the document to the stream as well
	CLSID clsid;
	sc = m_lpObject->GetUserClassID(&clsid);
	if (sc != S_OK)
	{
		lpStream->Release();
		AfxThrowOleException(sc);
	}
	sc = WriteClassStm(lpStream, clsid);
	if (sc != S_OK)
	{
		lpStream->Release();
		AfxThrowOleException(sc);
	}

	// add it to the data source
	lpStgMedium->tymed = TYMED_ISTREAM;
	lpStgMedium->pstm = lpStream;
	lpStgMedium->pUnkForRelease = NULL;
	return TRUE;
}

void COleClientItem::GetObjectDescriptorData(
	LPPOINT lpOffset, LPSIZE lpSize, LPSTGMEDIUM lpStgMedium)
{
	ASSERT_VALID(this);
	ASSERT(AfxIsValidAddress(lpStgMedium, sizeof(STGMEDIUM)));
	ASSERT(lpOffset == NULL ||
		AfxIsValidAddress(lpOffset, sizeof(CPoint), FALSE));

	POINTL pointT;
	if (lpOffset != NULL)
	{
		pointT.x = lpOffset->x;
		pointT.y = lpOffset->y;
		((CDC*)NULL)->DPtoHIMETRIC((SIZE*)&pointT);
	}
	else
	{
		pointT.x = 0;
		pointT.y = 0;
	}

	SIZE sizeT;
	if (lpSize != NULL)
	{
		sizeT.cx = lpSize->cx;
		sizeT.cy = lpSize->cy;
		((CDC*)NULL)->DPtoHIMETRIC(&sizeT);
	}
	else
	{
		sizeT.cx = 0;
		sizeT.cy = 0;
	}

	COleDocument* pDoc = GetDocument();

	// get the object descriptor for the IOleObject
	InterlockedIncrement(&m_dwRef);
	CStringW strDocPathName(pDoc->GetPathName());
	LPCOLESTR lpDocPathName(pDoc->GetPathName() ? strDocPathName.GetString() : NULL);
	HGLOBAL hGlobal = _AfxOleGetObjectDescriptorData(
		m_lpObject, lpDocPathName, m_nDrawAspect, pointT, &sizeT);
	InterlockedDecrement(&m_dwRef);

	if (hGlobal == NULL)
		AfxThrowMemoryException();

	// setup the STGMEDIUM
	lpStgMedium->tymed = TYMED_HGLOBAL;
	lpStgMedium->hGlobal = hGlobal;
	lpStgMedium->pUnkForRelease = NULL;
}

/////////////////////////////////////////////////////////////////////////////
// Embedded COleClientItem operations

void COleClientItem::SetHostNames(LPCTSTR lpszHost, LPCTSTR lpszHostObj)
{
	ASSERT_VALID(this);
	ASSERT(m_lpObject != NULL);
	ASSERT(AfxIsValidString(lpszHost));

	ASSERT(AfxIsValidString(lpszHostObj));
	CStringW strHost(lpszHost), strHostObj(lpszHostObj);
	CheckGeneral(m_lpObject->SetHostNames(strHost.GetString(),
		strHostObj.GetString()));
}

void COleClientItem::SetExtent(const CSize& size, DVASPECT nDrawAspect)
{
	ASSERT_VALID(this);
	ASSERT(m_lpObject != NULL);

	CheckGeneral(m_lpObject->SetExtent(nDrawAspect, (SIZE*)&size));
}

/////////////////////////////////////////////////////////////////////////////
// COleClientItem OLE interface implementation

BEGIN_INTERFACE_MAP(COleClientItem, CDocItem)
	INTERFACE_PART(COleClientItem, IID_IOleClientSite, OleClientSite)
	INTERFACE_PART(COleClientItem, IID_IAdviseSink, AdviseSink)
	INTERFACE_PART(COleClientItem, IID_IOleWindow, OleIPSite)
	INTERFACE_PART(COleClientItem, IID_IOleInPlaceSite, OleIPSite)
END_INTERFACE_MAP()

/////////////////////////////////////////////////////////////////////////////
// Implementation of IOleClientSite

STDMETHODIMP_(ULONG) COleClientItem::XOleClientSite::AddRef()
{
	METHOD_PROLOGUE_EX_(COleClientItem, OleClientSite)
	return pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) COleClientItem::XOleClientSite::Release()
{
	METHOD_PROLOGUE_EX_(COleClientItem, OleClientSite)
	return pThis->ExternalRelease();
}

STDMETHODIMP COleClientItem::XOleClientSite::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(COleClientItem, OleClientSite)
	return pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP COleClientItem::XOleClientSite::SaveObject()
{
	METHOD_PROLOGUE_EX(COleClientItem, OleClientSite)
	ASSERT_VALID(pThis);

	LPPERSISTSTORAGE lpPersistStorage =
		QUERYINTERFACE(pThis->m_lpObject, IPersistStorage);
	ASSERT(lpPersistStorage != NULL);
	SCODE sc = S_OK;
	if (lpPersistStorage->IsDirty() == S_OK)
	{
		// S_OK == S_TRUE != S_FALSE, therefore object is dirty!
		sc = ::OleSave(lpPersistStorage, pThis->m_lpStorage, TRUE);
		if (sc == S_OK)
			sc = lpPersistStorage->SaveCompleted(NULL);

		// mark the document as dirty, if save sucessful.
		pThis->m_pDocument->SetModifiedFlag();
	}
	lpPersistStorage->Release();
	return sc;
}

STDMETHODIMP COleClientItem::XOleClientSite::GetMoniker(
	DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER* ppMoniker)
{
	METHOD_PROLOGUE_EX(COleClientItem, OleClientSite)
	ASSERT_VALID(pThis);

	COleDocument* pDoc = pThis->GetDocument();
	ASSERT_VALID(pDoc);
	ASSERT(ppMoniker != NULL);
	*ppMoniker = NULL;

	switch (dwWhichMoniker)
	{
	case OLEWHICHMK_CONTAINER:
		// return the current moniker for the document
		*ppMoniker = pDoc->GetMoniker((OLEGETMONIKER)dwAssign);
		break;

	case OLEWHICHMK_OBJREL:
		{
			if (!pDoc->IsKindOf(RUNTIME_CLASS(COleLinkingDoc)))
				break;

			// don't return relative moniker if no document moniker
			LPMONIKER lpMoniker = pDoc->GetMoniker((OLEGETMONIKER)dwAssign);
			if (lpMoniker == NULL)
				break;
			lpMoniker->Release();

			// relative monikers have to handle assignment correctly
			switch (dwAssign)
			{
			case OLEGETMONIKER_ONLYIFTHERE:
				if (!pThis->m_bMoniker)
					break;  // no moniker assigned, don't return one
				// fall through...

			case OLEGETMONIKER_TEMPFORUSER:
			case OLEGETMONIKER_FORCEASSIGN:
				{
					// create item moniker from item name
					TCHAR szItemName[OLE_MAXITEMNAME];
					pThis->GetItemName(szItemName, _countof(szItemName));
					CStringW strItemName(szItemName);
					CreateItemMoniker(OLESTDDELIMOLE, strItemName.GetString(),
						ppMoniker);

					// notify the object of the assignment
					if (dwAssign != OLEGETMONIKER_TEMPFORUSER &&
						*ppMoniker != NULL && !pThis->m_bMoniker)
					{
						pThis->m_bMoniker = TRUE;
						VERIFY(pThis->m_lpObject->SetMoniker(
							OLEWHICHMK_OBJREL, *ppMoniker) == S_OK);
						ASSERT_VALID(pThis->m_pDocument);
						pThis->m_pDocument->SetModifiedFlag();
					}
				}
				break;

			case OLEGETMONIKER_UNASSIGN:
				pThis->m_bMoniker = FALSE;
				break;
			}
		}
		break;

	case OLEWHICHMK_OBJFULL:
		{
			// get each sub-moniker: item & document
			LPMONIKER lpMoniker1, lpMoniker2;
			GetMoniker(dwAssign, OLEWHICHMK_CONTAINER, &lpMoniker1);
			GetMoniker(dwAssign, OLEWHICHMK_OBJREL, &lpMoniker2);

			// create composite moniker
			if (lpMoniker1 != NULL && lpMoniker2 != NULL)
				::CreateGenericComposite(lpMoniker1, lpMoniker2, ppMoniker);

			// release sub-monikers
			RELEASE(lpMoniker1);
			RELEASE(lpMoniker2);
		}
		break;
	}

	return *ppMoniker != NULL ? S_OK : E_FAIL;
}

STDMETHODIMP COleClientItem::XOleClientSite::GetContainer(
	LPOLECONTAINER* ppContainer)
{
#ifdef _DEBUG
	METHOD_PROLOGUE_EX(COleClientItem, OleClientSite)
#else
	METHOD_PROLOGUE_EX_(COleClientItem, OleClientSite)
#endif

	// return the IOleItemContainer interface in the document
	COleDocument* pDoc = pThis->GetDocument();
	ASSERT_VALID(pDoc);
	*ppContainer = pDoc->GetContainer();

	return *ppContainer != NULL ? S_OK : E_NOINTERFACE;
}

STDMETHODIMP COleClientItem::XOleClientSite::ShowObject()
{
	METHOD_PROLOGUE_EX(COleClientItem, OleClientSite)
	ASSERT_VALID(pThis);

	TRY
	{
		pThis->OnShowItem();
	}
	END_TRY

	return S_OK;
}

STDMETHODIMP COleClientItem::XOleClientSite::OnShowWindow(BOOL fShow)
{
	METHOD_PROLOGUE_EX(COleClientItem, OleClientSite)
	ASSERT_VALID(pThis);

	// ignore this if the item is already in-place
	if (pThis->IsInPlaceActive())
		return S_OK;

	TRY
	{
		// store new state of object -- determines how object may be drawn
		COleClientItem::ItemState uNewState;
		uNewState = fShow ? COleClientItem::openState :
			COleClientItem::loadedState;
		if (uNewState != pThis->m_nItemState)
		{
			pThis->OnChange(OLE_CHANGED_STATE, (DWORD)uNewState);
			pThis->m_nItemState = uNewState;
		}
	}
	END_TRY

	return S_OK;
}

STDMETHODIMP COleClientItem::XOleClientSite::RequestNewObjectLayout()
{
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// Implementation of IAdviseSink

STDMETHODIMP_(ULONG) COleClientItem::XAdviseSink::AddRef()
{
	METHOD_PROLOGUE_EX_(COleClientItem, AdviseSink)
	return pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) COleClientItem::XAdviseSink::Release()
{
	METHOD_PROLOGUE_EX_(COleClientItem, AdviseSink)
	return pThis->ExternalRelease();
}

STDMETHODIMP COleClientItem::XAdviseSink::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(COleClientItem, AdviseSink)
	return pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP_(void) COleClientItem::XAdviseSink::OnDataChange(
	LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium)
{
	METHOD_PROLOGUE_EX(COleClientItem, AdviseSink)
	ASSERT_VALID(pThis);

	// Only interesting for advanced containers.  Forward it such that
	// containers do not have to implement the entire interface.
	pThis->OnDataChange(lpFormatEtc, lpStgMedium);
}

STDMETHODIMP_(void) COleClientItem::XAdviseSink::OnViewChange(
	DWORD aspects, LONG /*lindex*/)
{
	METHOD_PROLOGUE_EX(COleClientItem, AdviseSink)
	ASSERT_VALID(pThis);

	pThis->OnChange(OLE_CHANGED, (DVASPECT)aspects);
}

STDMETHODIMP_(void) COleClientItem::XAdviseSink::OnRename(
	LPMONIKER /*lpMoniker*/)
{
	// only interesting to the OLE link object.  Containers ignore this.
}

STDMETHODIMP_(void) COleClientItem::XAdviseSink::OnSave()
{
	METHOD_PROLOGUE_EX(COleClientItem, AdviseSink)
	ASSERT_VALID(pThis);

	pThis->OnChange(OLE_SAVED, (DVASPECT)0);
}

STDMETHODIMP_(void) COleClientItem::XAdviseSink::OnClose()
{
	METHOD_PROLOGUE_EX(COleClientItem, AdviseSink)
	ASSERT_VALID(pThis);

	pThis->OnChange(OLE_CLOSED, (DVASPECT)0);
}

/////////////////////////////////////////////////////////////////////////////
// COleClientItem diagnostics

#ifdef _DEBUG
void COleClientItem::AssertValid() const
{
	CDocItem::AssertValid();
	if (m_lpNewStorage != NULL)
		ASSERT(m_bNeedCommit);
	if (m_pView != NULL)
		m_pView->AssertValid();
	if (m_pInPlaceFrame != NULL)
		m_pInPlaceFrame->AssertValid();
	if (m_pInPlaceDoc != NULL)
		m_pInPlaceDoc->AssertValid();
}

void COleClientItem::Dump(CDumpContext& dc) const
{
	CDocItem::Dump(dc);

	// shallow dump
	dc << "m_lpObject = " << (void*)m_lpObject;
	dc << "\nm_dwItemNumber = " << m_dwItemNumber;
	dc << "\nm_nDrawAspect = " << (int)m_nDrawAspect;
	dc << "\nm_scLast = " << m_scLast;
	dc << "\nm_lpStorage = " << m_lpStorage;
	dc << "\nm_lpLockBytes = " << m_lpLockBytes;
	dc << "\nm_dwConnection = " << m_dwConnection;
	dc << "\nm_bLinkUnavail = " << m_bLinkUnavail;
	dc << "\nm_bMoniker = " << m_bMoniker;
	dc << "\nm_lpNewStorage = " << m_lpNewStorage;
	dc << "\nm_bNeedCommit = " << m_bNeedCommit;
	dc << "\nm_nItemState = " << (int)m_nItemState;
	dc << "\nm_pView = " << (void*)m_pView;
	dc << "\nm_dwContainerStyle = " << m_dwContainerStyle;
	dc << "\nm_pInPlaceFrame = " << (void*)m_pInPlaceFrame;
	dc << "\nm_hWndServer = " << m_hWndServer;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations expanded out-of-line

#ifndef _AFX_ENABLE_INLINES

// expand inlines for OLE client APIs
#define _AFXOLECLI_INLINE
#define _AFXOLEDOBJ_INLINE
#include "afxole.inl"

#endif //!_AFX_ENABLE_INLINES


// IMPLEMENT_DYNAMIC for COleLinkingDoc here for better .OBJ granularity
IMPLEMENT_DYNAMIC(COleLinkingDoc, COleDocument)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\olecnvrt.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// OLE UNICODE conversion support

void AFXAPI AfxBSTR2CString(CString* pStr, BSTR bstr)
{
	ASSERT(pStr != NULL);
	if (pStr == NULL)
	{
		return;
	}

	int nLen = SysStringLen(bstr);
#if defined(_UNICODE)
	LPTSTR lpsz = pStr->GetBufferSetLength(nLen);
	ASSERT(lpsz != NULL);
	Checked::memcpy_s(lpsz, nLen*sizeof(TCHAR), bstr, nLen*sizeof(TCHAR));
	pStr->ReleaseBuffer(nLen);
#else
	int nBytes = WideCharToMultiByte(CP_ACP, 0, bstr, nLen, NULL, NULL, NULL,
		NULL);
	LPSTR lpsz = pStr->GetBufferSetLength(nBytes);
	ASSERT(lpsz != NULL);
	WideCharToMultiByte(CP_ACP, 0, bstr, nLen, lpsz, nBytes, NULL, NULL);
	pStr->ReleaseBuffer(nBytes);
#endif
	
}

#if !defined(_UNICODE)
// this function creates a BSTR but it actually has an ANSI string inside
BSTR AFXAPI AfxBSTR2ABSTR(BSTR bstrW)
{
#pragma warning(push)
#pragma warning(disable:4068)
#pragma prefast(push)
#pragma prefast(disable:325, "We want to duplicate NULL semantics on the way out of this function")
	if (bstrW == NULL)
		return NULL;
#pragma prefast(pop)
#pragma warning(pop)

	int nLen = SysStringLen(bstrW); //not including NULL
	int nBytes = WideCharToMultiByte(CP_ACP, 0, bstrW, nLen,
		NULL, NULL, NULL, NULL); //number of bytes not including NULL
	BSTR bstrA = SysAllocStringByteLen(NULL, nBytes); // allocates nBytes
	if(!bstrA)
	{
		AfxThrowMemoryException();
	}
	VERIFY(WideCharToMultiByte(CP_ACP, 0, bstrW, nLen, (LPSTR)bstrA, nBytes, NULL,
		NULL) == nBytes);
	return bstrA;
}

LPWSTR AFXAPI AfxTaskStringA2W(LPCSTR lpa)
{
	LPWSTR lpw = AtlAllocTaskWideString(lpa);
	CoTaskMemFree((void*)lpa);
	return lpw;
}

LPSTR AFXAPI AfxTaskStringW2A(LPCWSTR lpw)
{
	LPSTR lpa = AtlAllocTaskAnsiString(lpw);
	CoTaskMemFree((void*)lpw);
	return lpa;
}

LPDEVMODEW AFXAPI AfxDevModeA2W(LPDEVMODEW lpDevModeW, LPDEVMODEA lpDevModeA)
{
	if (lpDevModeA == NULL)
		return NULL;
	ASSERT(lpDevModeW != NULL);
	AfxA2WHelper(lpDevModeW->dmDeviceName, (LPCSTR)lpDevModeA->dmDeviceName, CCHDEVICENAME);
	Checked::memcpy_s(&lpDevModeW->dmSpecVersion, offsetof(DEVMODEW, dmFormName) - offsetof(DEVMODEW, dmSpecVersion),
		&lpDevModeA->dmSpecVersion, offsetof(DEVMODEW, dmFormName) - offsetof(DEVMODEW, dmSpecVersion));
	AfxA2WHelper(lpDevModeW->dmFormName, (LPCSTR)lpDevModeA->dmFormName, CCHFORMNAME);
	Checked::memcpy_s(&lpDevModeW->dmLogPixels, sizeof(DEVMODEW) - offsetof(DEVMODEW, dmLogPixels), 
		&lpDevModeA->dmLogPixels, sizeof(DEVMODEW) - offsetof(DEVMODEW, dmLogPixels));

	if (lpDevModeA->dmDriverExtra != 0)
	{
		Checked::memcpy_s(lpDevModeW+1, lpDevModeA->dmDriverExtra, 
			lpDevModeA+1, lpDevModeA->dmDriverExtra);
	}
	lpDevModeW->dmSize = sizeof(DEVMODEW);
	return lpDevModeW;
}

LPDEVMODEA AFXAPI AfxDevModeW2A(LPDEVMODEA lpDevModeA, LPDEVMODEW lpDevModeW)
{
	if (lpDevModeW == NULL)
		return NULL;
	ASSERT(lpDevModeA != NULL);
	AfxW2AHelper((LPSTR)lpDevModeA->dmDeviceName, lpDevModeW->dmDeviceName, CCHDEVICENAME*sizeof(char));
	Checked::memcpy_s(&lpDevModeA->dmSpecVersion, offsetof(DEVMODEA, dmFormName) - offsetof(DEVMODEA, dmSpecVersion), 
		&lpDevModeW->dmSpecVersion, offsetof(DEVMODEA, dmFormName) - offsetof(DEVMODEA, dmSpecVersion));
	AfxW2AHelper((LPSTR)lpDevModeA->dmFormName, lpDevModeW->dmFormName, CCHFORMNAME*sizeof(char));
	Checked::memcpy_s(&lpDevModeA->dmLogPixels, sizeof(DEVMODEA) - offsetof(DEVMODEA, dmLogPixels), 
		&lpDevModeW->dmLogPixels, sizeof(DEVMODEA) - offsetof(DEVMODEA, dmLogPixels));

	if (lpDevModeW->dmDriverExtra != 0)
	{
		Checked::memcpy_s(lpDevModeA+1, lpDevModeW->dmDriverExtra, 
			lpDevModeW+1, lpDevModeW->dmDriverExtra);
	}
	lpDevModeA->dmSize = sizeof(DEVMODEA);
	return lpDevModeA;
}

LPTEXTMETRICW AFXAPI AfxTextMetricA2W(LPTEXTMETRICW lptmW, LPTEXTMETRICA lptmA)
{
	if (lptmA == NULL)
		return NULL;
	ASSERT(lptmW != NULL);
	Checked::memcpy_s(lptmW, sizeof(LONG) * 11, lptmA, sizeof(LONG) * 11);
	Checked::memcpy_s(&lptmW->tmItalic, sizeof(BYTE) * 5, &lptmA->tmItalic, sizeof(BYTE) * 5);
	MultiByteToWideChar(CP_ACP, 0, (LPCSTR)&lptmA->tmFirstChar, 1, &lptmW->tmFirstChar, 1);
	MultiByteToWideChar(CP_ACP, 0, (LPCSTR)&lptmA->tmLastChar, 1, &lptmW->tmLastChar, 1);
	MultiByteToWideChar(CP_ACP, 0, (LPCSTR)&lptmA->tmDefaultChar, 1, &lptmW->tmDefaultChar, 1);
	MultiByteToWideChar(CP_ACP, 0, (LPCSTR)&lptmA->tmBreakChar, 1, &lptmW->tmBreakChar, 1);
	return lptmW;
}

LPTEXTMETRICA AFXAPI AfxTextMetricW2A(LPTEXTMETRICA lptmA, LPTEXTMETRICW lptmW)
{
	if (lptmW == NULL)
		return NULL;
	ASSERT(lptmA != NULL);
	Checked::memcpy_s(lptmA, sizeof(LONG) * 11, lptmW, sizeof(LONG) * 11);
	Checked::memcpy_s(&lptmA->tmItalic, sizeof(BYTE) * 5, &lptmW->tmItalic, sizeof(BYTE) * 5);
	WideCharToMultiByte(CP_ACP, 0, &lptmW->tmFirstChar, 1, (LPSTR)&lptmA->tmFirstChar, 1, NULL, NULL);
	WideCharToMultiByte(CP_ACP, 0, &lptmW->tmLastChar, 1, (LPSTR)&lptmA->tmLastChar, 1, NULL, NULL);
	WideCharToMultiByte(CP_ACP, 0, &lptmW->tmDefaultChar, 1, (LPSTR)&lptmA->tmDefaultChar, 1, NULL, NULL);
	WideCharToMultiByte(CP_ACP, 0, &lptmW->tmBreakChar, 1, (LPSTR)&lptmA->tmBreakChar, 1, NULL, NULL);
	return lptmA;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\oledata.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#ifdef CoRegisterClassObject
#undef CoRegisterClassObject
#endif


#pragma comment(lib, "ole32.lib")
#pragma comment(lib, "oleaut32.lib")
#pragma comment(lib, "oledlg.lib")
#pragma comment(lib, "urlmon.lib")

/////////////////////////////////////////////////////////////////////////////
// _AFX_OLE_STATE implementation

_AFX_OLE_STATE::_AFX_OLE_STATE()
{
	// Note: it is only necessary to intialize non-zero data.
}

_AFX_OLE_STATE::~_AFX_OLE_STATE()
{
}

#pragma warning(disable: 4074)
#pragma init_seg(lib)

PROCESS_LOCAL(_AFX_OLE_STATE, _afxOleState)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\oleconn.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW


#define GetConnectionPtr(pTarget, pEntry) \
	(LPCONNECTIONPOINT)((char*)pTarget + pEntry->nOffset + \
			offsetof(CConnectionPoint, m_xConnPt))


/////////////////////////////////////////////////////////////////////////////
// CConnectionPoint

CConnectionPoint::CConnectionPoint() :
	m_pUnkFirstConnection(NULL),
	m_pConnections(NULL)
{
}

CConnectionPoint::~CConnectionPoint()
{
	AFX_BEGIN_DESTRUCTOR

		POSITION pos = GetStartPosition();
		while (pos != NULL)
		{
			LPUNKNOWN pUnk = GetNextConnection(pos);
			if (pUnk)
				pUnk->Release();
		}

		if (m_pConnections != NULL)
			delete m_pConnections;

	AFX_END_DESTRUCTOR
}

POSITION CConnectionPoint::GetStartPosition() const
{
	ASSERT(m_pConnections == NULL || m_pUnkFirstConnection == NULL);

	if (m_pUnkFirstConnection != NULL)
		return (POSITION)-1;

	if (m_pConnections == NULL || m_pConnections->GetSize() == 0)
		return NULL;

	return (POSITION)1;
}

LPUNKNOWN CConnectionPoint::GetNextConnection(POSITION& pos) const
{
	ASSERT(pos != NULL);

	if (pos == (POSITION)-1)
	{
		ASSERT(m_pUnkFirstConnection != NULL);
		ASSERT(m_pConnections == NULL);

		pos = NULL;
		return m_pUnkFirstConnection;
	}

	ASSERT(m_pConnections != NULL);
	ASSERT((LONG_PTR)pos > 0 && (LONG_PTR)pos <= m_pConnections->GetSize());

	int nIndex = int((LONG_PTR)pos - 1);
	pos = (POSITION)((LONG_PTR)pos + 1);
	if ((LONG_PTR)pos > m_pConnections->GetSize())
		pos = NULL;
	return (LPUNKNOWN)m_pConnections->GetAt(nIndex);
}

const CPtrArray* CConnectionPoint::GetConnections()
{
	ASSERT_VALID(this);
	if (m_pConnections == NULL)
		CreateConnectionArray();

	ASSERT(m_pConnections != NULL);
	return m_pConnections;
}

void CConnectionPoint::OnAdvise(BOOL)
{
	ASSERT_VALID(this);
}

int CConnectionPoint::GetMaxConnections()
{
	ASSERT_VALID(this);

	// May be overridden by subclass.
	return -1;
}

LPCONNECTIONPOINTCONTAINER CConnectionPoint::GetContainer()
{
	CCmdTarget* pCmdTarget = (CCmdTarget*)((BYTE*)this - m_nOffset);
#ifdef _DEBUG
	pCmdTarget->CCmdTarget::AssertValid();
#endif

	LPCONNECTIONPOINTCONTAINER pCPC = NULL;
	if (SUCCEEDED((HRESULT)pCmdTarget->ExternalQueryInterface(
			&IID_IConnectionPointContainer, (LPVOID*)&pCPC)))
	{
		ASSERT(pCPC != NULL);
	}

	return pCPC;
}

void CConnectionPoint::CreateConnectionArray()
{
	ASSERT(m_pConnections == NULL);

	m_pConnections = new CPtrArray;
	if (m_pUnkFirstConnection != NULL)
	{
		m_pConnections->Add(m_pUnkFirstConnection);
		m_pUnkFirstConnection = NULL;
	}

	ASSERT(m_pConnections != NULL);
	ASSERT(m_pUnkFirstConnection == NULL);
}

int CConnectionPoint::GetConnectionCount()
{
	if (m_pUnkFirstConnection != NULL)
		return 1;

	if (m_pConnections == NULL)
		return 0;

	UINT nCount = 0;
	POSITION posConnection = GetStartPosition();
	while (posConnection)
		if (GetNextConnection(posConnection))
			nCount++;
	return nCount;
}

HRESULT CConnectionPoint::QuerySinkInterface(LPUNKNOWN pUnkSink, 
	void** ppInterface)
{
	HRESULT hResult;

	ASSERT(ppInterface != NULL);
	if (ppInterface == NULL)
	{
		return E_POINTER;
	}
	*ppInterface = NULL;

	hResult = pUnkSink->QueryInterface(GetIID(), ppInterface);

	return hResult;
}

STDMETHODIMP_(ULONG) CConnectionPoint::XConnPt::Release()
{
	METHOD_PROLOGUE_EX_(CConnectionPoint, ConnPt)
	// get parent class that contains connection point
	CCmdTarget* pParent = (CCmdTarget*)((BYTE*)pThis - pThis->m_nOffset);
	return (ULONG)pParent->ExternalRelease();
}

STDMETHODIMP_(ULONG) CConnectionPoint::XConnPt::AddRef()
{
	METHOD_PROLOGUE_EX_(CConnectionPoint, ConnPt)
	// get parent class that contains connection point
	CCmdTarget* pParent = (CCmdTarget*)((BYTE*)pThis - pThis->m_nOffset);
	return (ULONG)pParent->ExternalAddRef();
}

STDMETHODIMP CConnectionPoint::XConnPt::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(CConnectionPoint, ConnPt)

	ASSERT(AfxIsValidAddress(ppvObj, sizeof(LPVOID), FALSE));

	if (IsEqualIID(iid, IID_IUnknown) ||
		IsEqualIID(iid, IID_IConnectionPoint))
	{
		*ppvObj = this;
		AddRef();
		return S_OK;
	}

	*ppvObj = NULL;
	return E_NOINTERFACE;
}

STDMETHODIMP CConnectionPoint::XConnPt::GetConnectionInterface(IID* pIID)
{
	METHOD_PROLOGUE_EX_(CConnectionPoint, ConnPt)
	ASSERT(AfxIsValidAddress(pIID, sizeof(IID)));

	*pIID = pThis->GetIID();
	return S_OK;
}

STDMETHODIMP CConnectionPoint::XConnPt::GetConnectionPointContainer(
	IConnectionPointContainer** ppCPC)
{
	METHOD_PROLOGUE_EX_(CConnectionPoint, ConnPt)
	ASSERT(AfxIsValidAddress(ppCPC, sizeof(LPCONNECTIONPOINT)));

	if ((*ppCPC = pThis->GetContainer()) != NULL)
		return S_OK;

	return E_FAIL;
}

STDMETHODIMP CConnectionPoint::XConnPt::Advise(
	LPUNKNOWN pUnkSink, DWORD* pdwCookie)
{
	METHOD_PROLOGUE_EX_(CConnectionPoint, ConnPt)
	ASSERT(AfxIsValidAddress(pUnkSink, sizeof(IUnknown), FALSE));
	ASSERT((pdwCookie == NULL) || AfxIsValidAddress(pdwCookie, sizeof(DWORD)));

	if (pUnkSink == NULL)
		return E_POINTER;

	LPUNKNOWN lpInterface;
	DWORD dwCookie;

	int cMaxConn = pThis->GetMaxConnections();
	if ((cMaxConn >= 0) && (pThis->GetConnectionCount() == cMaxConn))
	{
		return CONNECT_E_ADVISELIMIT;
	}

	HRESULT hResult;
	hResult = pThis->QuerySinkInterface(pUnkSink, (void**)&lpInterface);
	if (SUCCEEDED( hResult ))
	{
		if (pThis->m_pUnkFirstConnection == NULL &&
			pThis->m_pConnections == NULL)
		{
			pThis->m_pUnkFirstConnection = lpInterface;
			dwCookie = 1;
		}
		else
		{
			if (pThis->m_pConnections == NULL)
				pThis->CreateConnectionArray();

			dwCookie = 0;
			int i;
			for (i = 0; (i < pThis->m_pConnections->GetSize()) && (dwCookie == 0); i++)
			{
				if (pThis->m_pConnections->GetAt(i) == NULL)
				{
					pThis->m_pConnections->SetAt(i, lpInterface);
					dwCookie = i+1;
				}
			}
			if (dwCookie == 0)
			{
				dwCookie = (DWORD)pThis->m_pConnections->Add(lpInterface);
				dwCookie++;
			}
		}

		pThis->OnAdvise(TRUE);
		if (pdwCookie != NULL)
			*pdwCookie = dwCookie;
		return S_OK;
	}

	return hResult;
}

STDMETHODIMP CConnectionPoint::XConnPt::Unadvise(DWORD dwCookie)
{
	METHOD_PROLOGUE_EX_(CConnectionPoint, ConnPt)

	if (pThis->m_pUnkFirstConnection != NULL)
	{
		if (dwCookie == 1)
		{
			pThis->m_pUnkFirstConnection->Release();
			pThis->m_pUnkFirstConnection = NULL;
			pThis->OnAdvise(FALSE);
			return S_OK;
		}
		else
		{
			return CONNECT_E_NOCONNECTION;
		}
	}

	if (pThis->m_pConnections == NULL)
		return CONNECT_E_NOCONNECTION;

	LPUNKNOWN pUnkSink;
	int cConnections = (int)pThis->m_pConnections->GetSize();
	int i = dwCookie-1;
	if ((i >= 0) && (i < cConnections))
	{
		pUnkSink = (LPUNKNOWN)pThis->m_pConnections->GetAt(i);
		if (pUnkSink != NULL)
		{
			pUnkSink->Release();
			pThis->m_pConnections->SetAt(i, NULL);
			pThis->OnAdvise(FALSE);
			return S_OK;
		}
	}

	return CONNECT_E_NOCONNECTION;
}

/////////////////////////////////////////////////////////////////////////////
// CEnumConnections

class CEnumConnections : public CEnumArray
{
public:
	CEnumConnections(const void* pvEnum, UINT nSize);
	~CEnumConnections();
	void AddConnection(CONNECTDATA* pConn);

protected:
	virtual BOOL OnNext(void* pv);
	virtual CEnumArray* OnClone();

	UINT m_nMaxSize;    // number of items allocated (>= m_nSize)

	DECLARE_INTERFACE_MAP()
};

BEGIN_INTERFACE_MAP(CEnumConnections, CEnumArray)
	INTERFACE_PART(CEnumConnections, IID_IEnumConnections, EnumVOID)
END_INTERFACE_MAP()


CEnumConnections::CEnumConnections(const void* pvEnum, UINT nSize) :
	CEnumArray(sizeof(CONNECTDATA), pvEnum, nSize, TRUE)
{
	m_nMaxSize = 0;
}

CEnumConnections::~CEnumConnections()
{
	if (m_pClonedFrom == NULL)
	{
		UINT iCP;
		CONNECTDATA* ppCP = (CONNECTDATA*)(VOID *)m_pvEnum;
		for (iCP = 0; iCP < m_nSize; iCP++)
			RELEASE(ppCP[iCP].pUnk);
	}
	// destructor will free the actual array (if it was not a clone)
}

BOOL CEnumConnections::OnNext(void* pv)
{
	if (!CEnumArray::OnNext(pv))
		return FALSE;

	// outgoing connection point needs to be AddRef'ed
	//  (the caller has responsibility to release it)

	((CONNECTDATA*)pv)->pUnk->AddRef();
	return TRUE;
}

CEnumArray* CEnumConnections::OnClone()
{
	ASSERT_VALID(this);
	CEnumConnections* pClone;
	pClone = new CEnumConnections(m_pvEnum, m_nSize);
	pClone->m_bNeedFree = FALSE;
	ASSERT(pClone != NULL);
	ASSERT(!pClone->m_bNeedFree);   // clones should never free themselves
	pClone->m_nCurPos = m_nCurPos;

	// finally, return the clone to OLE
	ASSERT_VALID(pClone);
	return pClone;
}

void CEnumConnections::AddConnection(CONNECTDATA* pConn)
{
	ASSERT(m_nSize <= m_nMaxSize);

	if (m_nSize == m_nMaxSize)
	{
		// not enough space for new item -- allocate more
		CONNECTDATA* pListNew = new CONNECTDATA[m_nSize+2];
		m_nMaxSize += 2;
		if (m_nSize > 0)
		{
			Checked::memcpy_s(pListNew, m_nMaxSize*sizeof(CONNECTDATA), 
				m_pvEnum, m_nSize*sizeof(CONNECTDATA));
		}
		delete m_pvEnum;
		m_pvEnum = (BYTE*)pListNew;
	}

	// add this item to the list
	ASSERT(m_nSize < m_nMaxSize);
	((CONNECTDATA*)m_pvEnum)[m_nSize] = *pConn;
	pConn->pUnk->AddRef();
	++m_nSize;
}

STDMETHODIMP CConnectionPoint::XConnPt::EnumConnections(LPENUMCONNECTIONS* ppEnum)
{
	METHOD_PROLOGUE_EX(CConnectionPoint, ConnPt)
	CEnumConnections* pEnum = NULL;
	CONNECTDATA cd;

	TRY
	{
		pEnum = new CEnumConnections(NULL, 0);

		if (pThis->m_pUnkFirstConnection != NULL)
		{
			cd.pUnk = pThis->m_pUnkFirstConnection;
			cd.dwCookie = 1;
			pEnum->AddConnection(&cd);
		}

		if (pThis->m_pConnections != NULL)
		{
			int cConnections = (int)pThis->m_pConnections->GetSize();
			for (int i = 0; i < cConnections; i++)
			{
				cd.pUnk = (LPUNKNOWN)(pThis->m_pConnections->GetAt(i));
				cd.dwCookie = i+1;
				if (cd.pUnk != NULL)
				{
					pEnum->AddConnection(&cd);
				}
			}
		}
	}
	CATCH (CException, e)
	{
		delete pEnum;
		pEnum = NULL;
	}
	END_CATCH

	if (pEnum != NULL)
	{
		// create and return the IEnumConnectionPoints object
		*ppEnum = (IEnumConnections*)&pEnum->m_xEnumVOID;
	}
	else
	{
		// no connections: return NULL
		*ppEnum = NULL;
	}
	return (pEnum != NULL) ? S_OK : E_OUTOFMEMORY;
}


/////////////////////////////////////////////////////////////////////////////
// CEnumConnPoints

class CEnumConnPoints : public CEnumArray
{
public:
	CEnumConnPoints(const void* pvEnum, UINT nSize);
	~CEnumConnPoints();
	void AddConnPoint(LPCONNECTIONPOINT pConnPt);

protected:
	virtual BOOL OnNext(void* pv);

	UINT m_nMaxSize;    // number of items allocated (>= m_nSize)

	DECLARE_INTERFACE_MAP()
};

BEGIN_INTERFACE_MAP(CEnumConnPoints, CEnumArray)
	INTERFACE_PART(CEnumConnPoints, IID_IEnumConnectionPoints, EnumVOID)
END_INTERFACE_MAP()


CEnumConnPoints::CEnumConnPoints(const void* pvEnum, UINT nSize) :
	CEnumArray(sizeof(LPCONNECTIONPOINT), pvEnum, nSize, TRUE)
{
	m_nMaxSize = 0;
}

CEnumConnPoints::~CEnumConnPoints()
{
	if (m_pClonedFrom == NULL)
	{
		UINT iCP;
		LPCONNECTIONPOINT* ppCP =
			(LPCONNECTIONPOINT*)(VOID *)m_pvEnum;
		for (iCP = 0; iCP < m_nSize; iCP++)
			RELEASE(ppCP[iCP]);
	}
	// destructor will free the actual array (if it was not a clone)
}

BOOL CEnumConnPoints::OnNext(void* pv)
{
	if (!CEnumArray::OnNext(pv))
		return FALSE;

	// outgoing connection point needs to be AddRef'ed
	//  (the caller has responsibility to release it)

	(*(LPCONNECTIONPOINT*)pv)->AddRef();
	return TRUE;
}

void CEnumConnPoints::AddConnPoint(LPCONNECTIONPOINT pConnPt)
{
	ASSERT(m_nSize <= m_nMaxSize);

	if (m_nSize == m_nMaxSize)
	{
		// not enough space for new item -- allocate more
		LPCONNECTIONPOINT* pListNew = new LPCONNECTIONPOINT[m_nSize+2];
		m_nMaxSize += 2;
		if (m_nSize > 0)
		{
			Checked::memcpy_s(pListNew, m_nMaxSize*sizeof(LPCONNECTIONPOINT), 
				m_pvEnum, m_nSize*sizeof(LPCONNECTIONPOINT));
		}
		delete m_pvEnum;
		m_pvEnum = (BYTE*)pListNew;
	}

	// add this item to the list
	ASSERT(m_nSize < m_nMaxSize);
	((LPCONNECTIONPOINT*)m_pvEnum)[m_nSize] = pConnPt;
	pConnPt->AddRef();
	++m_nSize;
}


/////////////////////////////////////////////////////////////////////////////
// COleConnPtContainer

class COleConnPtContainer : public IConnectionPointContainer
{
public:
#ifndef _AFX_NO_NESTED_DERIVATION
	// required for METHOD_PROLOGUE_EX
	size_t m_nOffset;
	COleConnPtContainer::COleConnPtContainer()
		{ m_nOffset = offsetof(CCmdTarget, m_xConnPtContainer); }
#endif

	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();
	STDMETHOD(QueryInterface)(REFIID, LPVOID*);

	STDMETHOD(EnumConnectionPoints)(LPENUMCONNECTIONPOINTS* ppEnum);
	STDMETHOD(FindConnectionPoint)(REFIID iid, LPCONNECTIONPOINT* ppCP);
};

STDMETHODIMP_(ULONG) COleConnPtContainer::AddRef()
{
	METHOD_PROLOGUE_EX_(CCmdTarget, ConnPtContainer)
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) COleConnPtContainer::Release()
{
	METHOD_PROLOGUE_EX_(CCmdTarget, ConnPtContainer)
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP COleConnPtContainer::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(CCmdTarget, ConnPtContainer)
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP COleConnPtContainer::EnumConnectionPoints(
	LPENUMCONNECTIONPOINTS* ppEnum)
{
	METHOD_PROLOGUE_EX_(CCmdTarget, ConnPtContainer)

	CEnumConnPoints* pEnum = NULL;

	TRY
	{
		pEnum = new CEnumConnPoints(NULL, 0);

		// Add connection points that aren't in the connection map
		CPtrArray ptrArray;
		if (pThis->GetExtraConnectionPoints(&ptrArray))
		{
			for (int i = 0; i < ptrArray.GetSize(); i++)
				pEnum->AddConnPoint((LPCONNECTIONPOINT)ptrArray.GetAt(i));
		}

		// walk the chain of connection maps
		const AFX_CONNECTIONMAP* pMap = pThis->GetConnectionMap();
		const AFX_CONNECTIONMAP_ENTRY* pEntry;

#ifdef _AFXDLL
		for (;;)
#else
		while (pMap != NULL)
#endif
		{
			pEntry = pMap->pEntry;

			while (pEntry->piid != NULL)
			{
				pEnum->AddConnPoint(GetConnectionPtr(pThis, pEntry));
				++pEntry;
			}
#ifdef _AFXDLL
			if (pMap->pfnGetBaseMap == NULL)
				break;
			pMap = (*pMap->pfnGetBaseMap)();
#else
			pMap = pMap->pBaseMap;
#endif
		}
	}
	CATCH (CException, e)
	{
		delete pEnum;
		pEnum = NULL;
	}
	END_CATCH

	if (pEnum != NULL)
	{
		// create and return the IEnumConnectionPoints object
		*ppEnum = (IEnumConnectionPoints*)&pEnum->m_xEnumVOID;
	}
	else
	{
		// no connection points: return NULL
		*ppEnum = NULL;
	}

	return (pEnum != NULL) ? S_OK : CONNECT_E_NOCONNECTION;
}

STDMETHODIMP COleConnPtContainer::FindConnectionPoint(
	REFIID iid, LPCONNECTIONPOINT* ppCP)
{
	METHOD_PROLOGUE_EX_(CCmdTarget, ConnPtContainer)
	ASSERT(ppCP != NULL);

	if ((*ppCP = pThis->GetConnectionHook(iid)) != NULL)
	{
		(*ppCP)->AddRef();
		return S_OK;
	}

	const AFX_CONNECTIONMAP* pMap = pThis->GetConnectionMap();
	const AFX_CONNECTIONMAP_ENTRY* pEntry;

#ifdef _AFXDLL
	for (;;)
#else
	while (pMap != NULL)
#endif
	{
		pEntry = pMap->pEntry;

		while (pEntry->piid != NULL)
		{
			if (IsEqualIID(iid, *(IID*)(pEntry->piid)))
			{
				*ppCP = GetConnectionPtr(pThis, pEntry);
				(*ppCP)->AddRef();
				return S_OK;
			}
			++pEntry;
		}
#ifdef _AFXDLL
		if (pMap->pfnGetBaseMap == NULL)
			break;
		pMap = (*pMap->pfnGetBaseMap)();
#else
		pMap = pMap->pBaseMap;
#endif
	}

	return CONNECT_E_NOCONNECTION;
}


/////////////////////////////////////////////////////////////////////////////
// Wiring CCmdTarget to COleConnPtContainer

// enable this object for OLE connections, called from derived class ctor
void CCmdTarget::EnableConnections()
{
	ASSERT(GetConnectionMap() != NULL);   // must have DECLARE_DISPATCH_MAP

	// construct an COleConnPtContainer instance just to get to the vtable
	COleConnPtContainer cpc;

	// vtable pointer should be already set to same or NULL
	ASSERT(m_xConnPtContainer.m_vtbl == NULL||
		*(DWORD_PTR*)&cpc == m_xConnPtContainer.m_vtbl);
	// verify that sizes match
	ASSERT(sizeof(m_xConnPtContainer) == sizeof(COleConnPtContainer));

	// copy the vtable (and other data) to make sure it is initialized
	m_xConnPtContainer.m_vtbl = *(DWORD_PTR*)&cpc;
	*(COleConnPtContainer*)&m_xConnPtContainer = cpc;
}

/////////////////////////////////////////////////////////////////////////////
// Force any extra compiler-generated code into AFX_INIT_SEG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\oledisp1.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "dispimpl.h"
#include <atlconv.h>
#include "sal.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// Helpers and main implementation for CCmdTarget::IDispatch
void CCmdTarget::GetStandardProp(const AFX_DISPMAP_ENTRY* pEntry,
	VARIANT* pvarResult, UINT* puArgErr)
{
	ASSERT(pEntry != NULL);
	ASSERT(*puArgErr != 0);

	// it is a DISPATCH_PROPERTYGET (for standard, non-function property)
	void* pProp = (BYTE*)this + pEntry->nPropOffset;
	if (pEntry->vt != VT_VARIANT)
		pvarResult->vt = pEntry->vt;
	switch (pEntry->vt)
	{
	case VT_I1:
	case VT_UI1:
		pvarResult->bVal = *(BYTE*)pProp;
		break;
	case VT_I2:
	case VT_UI2:
		pvarResult->iVal = *(short*)pProp;
		break;
	case VT_I4:
	case VT_UI4:
		pvarResult->lVal = *(long*)pProp;
		break;
	case VT_I8:
	case VT_UI8:
		pvarResult->llVal = *(LONGLONG*)pProp;
		break;
	case VT_R4:
		pvarResult->fltVal = *(float*)pProp;
		break;
	case VT_R8:
		pvarResult->dblVal = *(double*)pProp;
		break;
	case VT_DATE:
		pvarResult->date = *(double*)pProp;
		break;
	case VT_CY:
		pvarResult->cyVal = *(CY*)pProp;
		break;
	case VT_BSTR:
		{
			CString* pString = (CString*)pProp;
			pvarResult->bstrVal = pString->AllocSysString();
		}
		break;
	case VT_ERROR:
		pvarResult->scode = *(SCODE*)pProp;
		break;
	case VT_BOOL:
		V_BOOL(pvarResult) = (VARIANT_BOOL)(*(BOOL*)pProp != 0 ? -1 : 0);
		break;
	case VT_VARIANT:
		if (VariantCopy(pvarResult, (LPVARIANT)pProp) != S_OK)
			*puArgErr = 0;
		break;
	case VT_DISPATCH:
	case VT_UNKNOWN:
		pvarResult->punkVal = *(LPDISPATCH*)pProp;
		if (pvarResult->punkVal != NULL)
			pvarResult->punkVal->AddRef();
		break;

	default:
		*puArgErr = 0;
	}
}

SCODE CCmdTarget::SetStandardProp(const AFX_DISPMAP_ENTRY* pEntry,
	DISPPARAMS* pDispParams, UINT* puArgErr)
{
	ASSERT(pEntry != NULL);
	ASSERT(*puArgErr != 0);

	// it is a DISPATCH_PROPERTYSET (for standard, non-function property)
	SCODE sc = S_OK;
	VARIANT va;
	AfxVariantInit(&va);
	VARIANT* pArg = &pDispParams->rgvarg[0];
	if (pEntry->vt != VT_VARIANT && pArg->vt != pEntry->vt)
	{
		// argument is not of appropriate type, attempt to coerce it
		sc = VariantChangeType(&va, pArg, 0, pEntry->vt);
		if (FAILED(sc))
		{
			TRACE(traceOle, 0, "Warning: automation property coercion failed.\n");
			*puArgErr = 0;
			return sc;
		}
		ASSERT(va.vt == pEntry->vt);
		pArg = &va;
	}

	void* pProp = (BYTE*)this + pEntry->nPropOffset;
	switch (pEntry->vt)
	{
	case VT_I1:
	case VT_UI1:
		*(BYTE*)pProp = pArg->bVal;
		break;
	case VT_I2:
	case VT_UI2:
		*(short*)pProp = pArg->iVal;
		break;
	case VT_I4:
	case VT_UI4:
		*(long*)pProp = pArg->lVal;
		break;
	case VT_I8:
	case VT_UI8:
		*(LONGLONG*)pProp = pArg->llVal;
		break;
	case VT_R4:
		*(float*)pProp = pArg->fltVal;
		break;
	case VT_R8:
		*(double*)pProp = pArg->dblVal;
		break;
	case VT_DATE:
		*(double*)pProp = pArg->date;
		break;
	case VT_CY:
		*(CY*)pProp = pArg->cyVal;
		break;
	case VT_BSTR:
		AfxBSTR2CString((CString*)pProp, pArg->bstrVal);
		break;
	case VT_ERROR:
		*(SCODE*)pProp = pArg->scode;
		break;
	case VT_BOOL:
		*(BOOL*)pProp = (V_BOOL(pArg) != 0);
		break;
	case VT_VARIANT:
		if (VariantCopy((LPVARIANT)pProp, pArg) != S_OK)
			*puArgErr = 0;
		break;
	case VT_DISPATCH:
	case VT_UNKNOWN:
		if (pArg->punkVal != NULL)
			pArg->punkVal->AddRef();
		_AfxRelease((LPUNKNOWN*)pProp);
		*(LPUNKNOWN*)pProp = pArg->punkVal;
		break;

	default:
		*puArgErr = 0;
		sc = DISP_E_BADVARTYPE;
	}
	VariantClear(&va);

	// if property was a DISP_PROPERTY_NOTIFY type, call pfnSet after setting
	if (!FAILED(sc) && pEntry->pfnSet != NULL)
	{
		AFX_MANAGE_STATE(m_pModuleState);
		(this->*pEntry->pfnSet)();
	}

	return sc;
}

UINT PASCAL CCmdTarget::GetEntryCount(const AFX_DISPMAP* pDispMap)
{
	ASSERT(pDispMap->lpEntryCount != NULL);

	// compute entry count cache if not available
	if (*pDispMap->lpEntryCount == -1)
	{
		// count them
		const AFX_DISPMAP_ENTRY* pEntry = pDispMap->lpEntries;
		while (pEntry->nPropOffset != -1)
			++pEntry;

		// store it
		*pDispMap->lpEntryCount = UINT(pEntry - pDispMap->lpEntries);
	}

	ASSERT(*pDispMap->lpEntryCount != -1);
	return *pDispMap->lpEntryCount;
}

MEMBERID PASCAL CCmdTarget::MemberIDFromName(
	const AFX_DISPMAP* pDispMap, LPCTSTR lpszName)
{
	// search all maps and their base maps
	UINT nInherit = 0;
#ifdef _AFXDLL
	for (;;)
#else
	while (pDispMap != NULL)
#endif
	{
		// search all entries in this map
		const AFX_DISPMAP_ENTRY* pEntry = pDispMap->lpEntries;
		UINT nEntryCount = GetEntryCount(pDispMap);
		for (UINT nIndex = 0; nIndex < nEntryCount; nIndex++)
		{
			if (pEntry->vt != VT_MFCVALUE &&
				::AfxInvariantStrICmp(pEntry->lpszName, lpszName) == 0)
			{
				if (pEntry->lDispID == DISPID_UNKNOWN)
				{
					// the MEMBERID is combination of nIndex & nInherit
					ASSERT(MAKELONG(nIndex+1, nInherit) != DISPID_UNKNOWN);
					return MAKELONG(nIndex+1, nInherit);
				}
				// the MEMBERID is specified as the lDispID
				return pEntry->lDispID;
			}
			++pEntry;
		}
#ifdef _AFXDLL
		if (pDispMap->pfnGetBaseMap == NULL)
			break;
		pDispMap = (*pDispMap->pfnGetBaseMap)();
#else
		pDispMap = pDispMap->pBaseMap;
#endif
		++nInherit;
	}
	return DISPID_UNKNOWN;  // name not found
}

const AFX_DISPMAP_ENTRY* PASCAL CCmdTarget::GetDispEntry(MEMBERID memid)
{
	const AFX_DISPMAP* pDerivMap = GetDispatchMap();
	const AFX_DISPMAP* pDispMap;
	const AFX_DISPMAP_ENTRY* pEntry;

	if (memid == DISPID_VALUE)
	{
		// DISPID_VALUE is a special alias (look for special alias entry)
		pDispMap = pDerivMap;
#ifdef _AFXDLL
		for (;;)
#else
		while (pDispMap != NULL)
#endif
		{
			// search for special entry with vt == VT_MFCVALUE
			pEntry = pDispMap->lpEntries;
			while (pEntry->nPropOffset != -1)
			{
				if (pEntry->vt == VT_MFCVALUE)
				{
					memid = pEntry->lDispID;
					if (memid == DISPID_UNKNOWN)
					{
						// attempt to map alias name to member ID
						memid = MemberIDFromName(pDerivMap, pEntry->lpszName);
						if (memid == DISPID_UNKNOWN)
							return NULL;
					}
					// break out and map the member ID to an entry
					goto LookupDispID;
				}
				++pEntry;
			}
#ifdef _AFXDLL
			if (pDispMap->pfnGetBaseMap == NULL)
				break;
			pDispMap = (*pDispMap->pfnGetBaseMap)();
#else
			pDispMap = pDispMap->pBaseMap;
#endif
		}
	}

LookupDispID:
	if ((long)memid > 0)
	{
		// find AFX_DISPMAP corresponding to HIWORD(memid)
		UINT nTest = 0;
		pDispMap = pDerivMap;
#ifdef _AFXDLL
		while (nTest < (UINT)HIWORD(memid))
#else
		while (pDispMap != NULL && nTest < (UINT)HIWORD(memid))
#endif
		{
#ifdef _AFXDLL
			if (pDispMap->pfnGetBaseMap == NULL)
				break;
			pDispMap = (*pDispMap->pfnGetBaseMap)();
#else
			pDispMap = pDispMap->pBaseMap;
#endif
			++nTest;
		}
		if (pDispMap != NULL)
		{
			UINT nEntryCount = GetEntryCount(pDispMap);
			if ((UINT)LOWORD(memid) <= nEntryCount)
			{
				pEntry = pDispMap->lpEntries + LOWORD(memid)-1;

				// must have automatic DISPID or same ID
				// if not then look manually
				if (pEntry->lDispID == DISPID_UNKNOWN ||
					pEntry->lDispID == memid)
				{
					return pEntry;
				}
			}
		}
	}

	// second pass, look for DISP_XXX_ID entries
	pDispMap = pDerivMap;
#ifdef _AFXDLL
	for (;;)
#else
	while (pDispMap != NULL)
#endif
	{
		// find AFX_DISPMAP_ENTRY where (pEntry->lDispID == memid)
		pEntry = pDispMap->lpEntries;
		while (pEntry->nPropOffset != -1)
		{
			if (pEntry->lDispID == memid)
				return pEntry;

			++pEntry;
		}
		// check base class
#ifdef _AFXDLL
		if (pDispMap->pfnGetBaseMap == NULL)
			break;
		pDispMap = (*pDispMap->pfnGetBaseMap)();
#else
		pDispMap = pDispMap->pBaseMap;
#endif
	}

	return NULL;    // no matching entry
}

/////////////////////////////////////////////////////////////////////////////
// Standard automation methods

void CCmdTarget::GetNotSupported()
{
	AfxThrowOleDispatchException(
		AFX_IDP_GET_NOT_SUPPORTED, AFX_IDP_GET_NOT_SUPPORTED);
}

void CCmdTarget::SetNotSupported()
{
	AfxThrowOleDispatchException(
		AFX_IDP_SET_NOT_SUPPORTED, AFX_IDP_SET_NOT_SUPPORTED);
}

/////////////////////////////////////////////////////////////////////////////
// Wiring to CCmdTarget

// enable this object for OLE automation, called from derived class ctor
void CCmdTarget::EnableAutomation()
{
	ASSERT(GetDispatchMap() != NULL);   // must have DECLARE_DISPATCH_MAP

	// construct an COleDispatchImpl instance just to get to the vtable
	COleDispatchImpl dispatch;

	// vtable pointer should be already set to same or NULL
	ASSERT(m_xDispatch.m_vtbl == NULL||
		*(DWORD_PTR*)&dispatch == m_xDispatch.m_vtbl);
	// sizeof(COleDispatchImpl) should be just a DWORD (vtable pointer)
	ASSERT(sizeof(m_xDispatch) == sizeof(COleDispatchImpl));

	// copy the vtable (and other data) to make sure it is initialized
	m_xDispatch.m_vtbl = *(DWORD_PTR*)&dispatch;
	*(COleDispatchImpl*)&m_xDispatch = dispatch;
}

// return addref'd IDispatch part of CCmdTarget object
LPDISPATCH CCmdTarget::GetIDispatch(BOOL bAddRef)
{
	ASSERT_VALID(this);
	ASSERT(m_xDispatch.m_vtbl != 0);    // forgot to call EnableAutomation?

	// AddRef the object if requested
	if (bAddRef)
		ExternalAddRef();

	// return pointer to IDispatch implementation
	return (LPDISPATCH)GetInterface(&IID_IDispatch);
}

// retrieve CCmdTarget* from IDispatch* (return NULL if not MFC IDispatch)
CCmdTarget* PASCAL CCmdTarget::FromIDispatch(LPDISPATCH lpDispatch)
{
	// construct an COleDispatchImpl instance just to get to the vtable
	COleDispatchImpl dispatch;

	ASSERT(*(DWORD*)&dispatch != 0);    // null vtable ptr?
	if (*(DWORD*)lpDispatch != *(DWORD*)&dispatch)
		return NULL;    // not our IDispatch*

	// vtable ptrs match, so must have originally been retrieved with
	//  CCmdTarget::GetIDispatch.
#ifndef _AFX_NO_NESTED_DERIVATION
	CCmdTarget* pTarget = (CCmdTarget*)
		((BYTE*)lpDispatch - ((COleDispatchImpl*)lpDispatch)->m_nOffset);
#else
	CCmdTarget* pTarget = (CCmdTarget*)
		((BYTE*)lpDispatch - offsetof(CCmdTarget, m_xDispatch));
#endif
	ASSERT_VALID(pTarget);
	return pTarget;
}

BOOL CCmdTarget::IsResultExpected()
{
	BOOL bResultExpected = m_bResultExpected;
	m_bResultExpected = TRUE;   // can only ask once
	return bResultExpected;
}

void COleDispatchImpl::Disconnect()
{
	METHOD_PROLOGUE_EX_(CCmdTarget, Dispatch)

	pThis->ExternalDisconnect();    // always disconnect the object
}

///////////////////////////////////////////////////////////////////////////////
// OLE BSTR support


/////////////////////////////////////////////////////////////////////////////
// Specifics of METHOD->C++ member function invocation

// Note: Although this code is written in C++, it is very dependent on the
//  specific compiler and target platform.  The current code below assumes
//  that the stack grows down, and that arguments are pushed last to first.

// calculate size of pushed arguments + retval reference

// size of arguments on stack when pushed by value
AFX_STATIC_DATA const UINT _afxByValue[] =
{
	0,                          // VTS_EMPTY
	0,                          // VTS_NULL
	sizeof(_STACK_SHORT),       // VTS_I2
	sizeof(_STACK_LONG),        // VTS_I4
	sizeof(_STACK_FLOAT),       // VTS_R4
	sizeof(_STACK_DOUBLE),      // VTS_R8
	sizeof(CY),                 // VTS_CY
	sizeof(DATE),               // VTS_DATE
	sizeof(LPCOLESTR),          // VTS_WBSTR (VT_BSTR)
	sizeof(LPDISPATCH),         // VTS_DISPATCH
	sizeof(SCODE),              // VTS_SCODE
	sizeof(BOOL),               // VTS_BOOL
	sizeof(const VARIANT*),     // VTS_VARIANT
	sizeof(LPUNKNOWN),           // VTS_UNKNOWN
	sizeof(LPCSTR),             // VTS_BSTR (VT_BSTRA -- MFC defined)
	0,
	sizeof(_STACK_CHAR),        // VTS_I1
	sizeof(_STACK_CHAR),        // VTS_UI1
	sizeof(_STACK_SHORT),       // VTS_UI2
	sizeof(_STACK_LONG),        // VTS_UI4
	sizeof(_STACK_LONGLONG),    // VTS_I8
	sizeof(_STACK_LONGLONG)     // VTS_UI8
};

// size of arguments on stack when pushed by reference
AFX_STATIC_DATA const UINT _afxByRef[] =
{
	0,                          // VTS_PEMPTY
	0,                          // VTS_PNULL
	sizeof(short*),             // VTS_PI2
	sizeof(long*),              // VTS_PI4
	sizeof(float*),             // VTS_PR4
	sizeof(double*),            // VTS_PR8
	sizeof(CY*),                // VTS_PCY
	sizeof(DATE*),              // VTS_PDATE
	sizeof(BSTR*),              // VTS_PBSTR
	sizeof(LPDISPATCH*),        // VTS_PDISPATCH
	sizeof(SCODE*),             // VTS_PSCODE
	sizeof(VARIANT_BOOL*),      // VTS_PBOOL
	sizeof(VARIANT*),           // VTS_PVARIANT
	sizeof(LPUNKNOWN*),         // VTS_PUNKNOWN
	sizeof(LPCSTR*),            // VTS_BSTRA
	0,
	sizeof(char*),              // VTS_PI1
	sizeof(BYTE*),              // VTS_PUI1
	sizeof(WORD*),              // VTS_PUI2
	sizeof(DWORD*),             // VTS_PUI4
	sizeof(LONGLONG*),          // VTS_PI8
	sizeof(ULONGLONG*)          // VTS_PUI8
};

AFX_STATIC_DATA const UINT _afxRetVal[] =
{
	0,                          // VT_EMPTY
	0,                          // VT_NULL
	0,                          // VT_I2
	0,                          // VT_I4
	0,                          // VT_R4
	0,                          // VT_R8
	sizeof(CY*),                // VT_CY
	0,                          // VT_DATE (same as VT_R8)
	0,                          // VT_BSTR
	0,                          // VT_DISPATCH
	0,                          // VT_SCODE
	0,                          // VT_BOOL
	sizeof(VARIANT*),           // VT_VARIANT
	0,                          // VT_UNKNOWN
	0,                          // VT_BSTRA
	0,
	0,                          // VT_I1
	0,                          // VT_UI1
	0,                          // VT_UI2
	0,                          // VT_UI4
	0,                          // VT_I8
	0                           // VT_UI8
};

UINT PASCAL CCmdTarget::GetStackSize(const BYTE* pbParams, VARTYPE vtResult)
{
	// sizeof 'this' pointer
	UINT nCount = sizeof(CCmdTarget*);
#ifdef _ALIGN_STACK
	nCount = (nCount + (_ALIGN_STACK-1)) & ~(_ALIGN_STACK-1);
#endif

	// count bytes in return value
	ENSURE((UINT)vtResult < _countof(_afxRetVal));
	nCount += _afxRetVal[vtResult];
#ifdef _ALIGN_STACK
	nCount = (nCount + (_ALIGN_STACK-1)) & ~(_ALIGN_STACK-1);
#endif

	// count arguments
	ASSERT(pbParams != NULL);
	while (*pbParams != 0)
	{
		if (*pbParams != VT_MFCMARKER)
		{
			// align if necessary
			// get and add appropriate byte count
			const UINT* rgnBytes;
			if (*pbParams & VT_MFCBYREF)
				rgnBytes = _afxByRef;
			else
				rgnBytes = _afxByValue;
			ENSURE(((BYTE)(*pbParams & ~VT_MFCBYREF)) < _countof(_afxByValue));
#ifdef _ALIGN_DOUBLES
			// align doubles on 8 byte for some platforms
			if (*pbParams == VT_R8)
				nCount = (nCount + _ALIGN_DOUBLES-1) & ~(_ALIGN_DOUBLES-1);
#endif
			
			nCount += rgnBytes[(BYTE)(*pbParams & ~VT_MFCBYREF)];
#ifdef _ALIGN_STACK
			nCount = (nCount + (_ALIGN_STACK-1)) & ~(_ALIGN_STACK-1);
#endif
		}
		++pbParams;
	}
#if defined(_ALIGN_DOUBLES) && defined(_SHADOW_DOUBLES)
	// align doubles on 8 byte for some platforms
	nCount = (nCount + _ALIGN_DOUBLES-1) & ~(_ALIGN_DOUBLES-1);
#endif
	return nCount;
}

// push arguments on stack appropriate for C++ call (compiler dependent)
#ifndef _SHADOW_DOUBLES
SCODE CCmdTarget::PushStackArgs(BYTE* pStack, const BYTE* pbParams,
	void* pResult, VARTYPE vtResult, DISPPARAMS* pDispParams, UINT* puArgErr,
	VARIANT* rgTempVars,CVariantBoolConverter* pTempStackArgs)
#else
SCODE CCmdTarget::PushStackArgs(BYTE* pStack, const BYTE* pbParams,
	void* pResult, VARTYPE vtResult, DISPPARAMS* pDispParams, UINT* puArgErr,
	VARIANT* rgTempVars, UINT nSizeArgs,CVariantBoolConverter* pTempStackArgs)
#endif
{
	ASSERT(pStack != NULL);
	ASSERT(pResult != NULL);
	ASSERT(pDispParams != NULL);
	ASSERT(puArgErr != NULL);

#ifdef _SHADOW_DOUBLES
	double* pDoubleShadow = (double*)(pStack + nSizeArgs);
	double* pDoubleShadowMax = pDoubleShadow + _SHADOW_DOUBLES;
#endif

	// C++ member functions use the __thiscall convention, where parameters
	//  are pushed last to first.  Assuming the stack grows down, this means
	//  that the first parameter is at the lowest memory address in the
	//  stack frame and the last parameter is at the highest address.


#ifdef _RETVAL_FIRST
	// push any necessary return value stuff on the stack (pre args)
	//  (an ambient pointer is pushed to stack relative data)
	if (vtResult == VT_CY || vtResult == VT_VARIANT)
	{
#ifdef _ALIGN_STACK
		ASSERT(((DWORD_PTR)pStack & (_ALIGN_STACK-1)) == 0);
#endif
		*(_STACK_PTR*)pStack = (_STACK_PTR)pResult;
		pStack += sizeof(_STACK_PTR);
#ifdef _ALIGN_STACK
		ASSERT(((DWORD_PTR)pStack & (_ALIGN_STACK-1)) == 0);
#endif
	}
#endif //_RETVAL_FIRST

	// push the 'this' pointer
#ifdef _ALIGN_STACK
	ASSERT(((DWORD_PTR)pStack & (_ALIGN_STACK-1)) == 0);
#endif
	*(_STACK_PTR*)pStack = (_STACK_PTR)this;
	pStack += sizeof(_STACK_PTR);
#ifdef _ALIGN_STACK
	ASSERT(((DWORD_PTR)pStack & (_ALIGN_STACK-1)) == 0);
#endif

#ifndef _RETVAL_FIRST
	// push any necessary return value stuff on the stack (post args)
	//  (an ambient pointer is pushed to stack relative data)
	if (vtResult == VT_CY || vtResult == VT_VARIANT)
	{
#ifdef _ALIGN_STACK
		ASSERT(((DWORD_PTR)pStack & (_ALIGN_STACK-1)) == 0);
#endif
		*(_STACK_PTR*)pStack = (_STACK_PTR)pResult;
		pStack += sizeof(_STACK_PTR);
#ifdef _ALIGN_STACK
		ASSERT(((DWORD_PTR)pStack & (_ALIGN_STACK-1)) == 0);
#endif
	}
#endif //!_RETVAL_FIRST

	// push the arguments (first to last, low address to high address)
	VARIANT* pArgs = pDispParams->rgvarg;
	BOOL bNamedArgs = FALSE;
	int iArg = pDispParams->cArgs; // start with positional arguments
	int iArgMin = pDispParams->cNamedArgs;

	ASSERT(pbParams != NULL);
	const BYTE* pb;
	for (pb = pbParams; *pb != '\0'; ++pb)
	{
		--iArg; // move to next arg

		// convert MFC parameter type to IDispatch VARTYPE
		VARTYPE vt = *pb;
		if (vt != VT_MFCMARKER && (vt & VT_MFCBYREF))
			vt = (VARTYPE)((vt & ~VT_MFCBYREF) | VT_BYREF);

		VARIANT* pArg;
		if (iArg >= iArgMin)
		{
			// hit named args before using all positional args?
			if (vt == VT_MFCMARKER)
				break;

			// argument specified by caller -- use it
			pArg = &pArgs[iArg];
			if (vt != VT_VARIANT && vt != pArg->vt)
			{
				// argument is not of appropriate type, attempt to coerce it
				VARIANT* pArgTemp = &rgTempVars[iArg];
				ASSERT(pArgTemp->vt == VT_EMPTY);
#if defined(_UNICODE)
				VARTYPE vtTarget = vt;
#else
				VARTYPE vtTarget = (VARTYPE) ((vt == VT_BSTRA) ? VT_BSTR : vt);
#endif
				if (pArg->vt != vtTarget)
				{
					SCODE sc = VariantChangeType(pArgTemp, pArg, 0, vtTarget);
					if (FAILED(sc))
					{
						TRACE(traceOle, 0, "Warning: automation argument coercion failed.\n");
						*puArgErr = iArg;
						return sc;
					}
					ASSERT(pArgTemp->vt == vtTarget);
				}

#if !defined(_UNICODE)
				if (vt == VT_BSTRA)
				{
					if (pArg->vt != vtTarget)
					{
						// coerce above created a new string
						// convert it to ANSI and free it
						ASSERT(pArgTemp->vt == VT_BSTR);
						BSTR bstrW = pArgTemp->bstrVal;
						pArgTemp->bstrVal = AfxBSTR2ABSTR(bstrW);
						SysFreeString(bstrW);
					}
					else
					{
						// convert the string to ANSI from original
						pArgTemp->bstrVal = AfxBSTR2ABSTR(pArg->bstrVal);
						pArgTemp->vt = VT_BSTR;
					}
					vt = VT_BSTR;
				}
#endif
				pArg = pArgTemp;
			}
		}
		else
		{
			if (vt == VT_MFCMARKER)
			{
				// start processing named arguments
				iArg = pDispParams->cNamedArgs;
				iArgMin = 0;
				bNamedArgs = TRUE;
				continue;
			}

			if (bNamedArgs || vt != VT_VARIANT)
				break;  // function not expecting optional argument

			// argument not specified by caller -- provide default variant
			static VARIANT vaDefault;   // Note: really is 'const'
			vaDefault.vt = VT_ERROR;
			vaDefault.scode = DISP_E_PARAMNOTFOUND;
			pArg = &vaDefault;
		}

		// push parameter value on the stack
		if (vt&VT_BYREF)
		{
			_STACK_PTR pByRef=NULL;
			if (vt == (VT_BOOL|VT_BYREF) && pTempStackArgs!=NULL)
			{
				BOOL bVal=(*V_BOOLREF(pArg))==VARIANT_FALSE ? FALSE : TRUE;
				BOOL* pb=new BOOL(bVal);
				pTempStackArgs->AddPair( CVariantBoolPair(pb,V_BOOLREF(pArg)) );
				pByRef=pb;
			} else
			{
				pByRef=pArg->byref;
			}
			// by reference parameter
			*(_STACK_PTR*)pStack = pByRef;
			pStack += sizeof(_STACK_PTR);
		}
		else
		{
			// by value parameters
			switch (vt)
			{
			case VT_I1:
				*(_STACK_CHAR*)pStack = (signed char)pArg->cVal;
				pStack += sizeof(_STACK_CHAR);
				break;

			case VT_UI1:
				*(_STACK_CHAR*)pStack = pArg->bVal; // 'BYTE' is passed as 'int'
				pStack += sizeof(_STACK_CHAR);
				break;

			case VT_I2:
				*(_STACK_SHORT*)pStack = pArg->iVal;
				pStack += sizeof(_STACK_SHORT);   // 'short' is passed as 'int'
				break;

			case VT_UI2:
				*(_STACK_SHORT*)pStack = pArg->uiVal;
				pStack += sizeof(_STACK_SHORT);
				break;

			case VT_I4:
				*(_STACK_LONG*)pStack = pArg->lVal;
				pStack += sizeof(_STACK_LONG);
				break;

			case VT_UI4:
				*(_STACK_LONG*)pStack = pArg->ulVal;
				pStack += sizeof(_STACK_LONG);
				break;

			case VT_I8:
				*(_STACK_LONGLONG*)pStack = pArg->llVal;
				pStack += sizeof(_STACK_LONGLONG);
				break;

			case VT_UI8:
				*(_STACK_LONGLONG*)pStack = pArg->ullVal;
				pStack += sizeof(_STACK_LONGLONG);
				break;

			case VT_R4:
				*(_STACK_FLOAT*)pStack = (_STACK_FLOAT)pArg->fltVal;
				pStack += sizeof(_STACK_FLOAT);
	#ifdef _SHADOW_DOUBLES
				if (pDoubleShadow < pDoubleShadowMax)
					*pDoubleShadow++ = (double)pArg->fltVal;
	#endif
				break;

			case VT_R8:
	#ifdef _ALIGN_DOUBLES
				// align doubles on 8 byte for some platforms
				pStack = (BYTE*)(((DWORD_PTR)pStack + _ALIGN_DOUBLES-1) &
					~(_ALIGN_DOUBLES-1));
	#endif
				*(_STACK_DOUBLE*)pStack = (_STACK_DOUBLE)pArg->dblVal;
				pStack += sizeof(_STACK_DOUBLE);
	#ifdef _SHADOW_DOUBLES
				if (pDoubleShadow < pDoubleShadowMax)
					*pDoubleShadow++ = pArg->dblVal;
	#endif
				break;

			case VT_DATE:
	#ifdef _ALIGN_DOUBLES
				// align doubles on 8 byte for some platforms
				pStack = (BYTE*)(((DWORD_PTR)pStack + _ALIGN_DOUBLES-1) &
					~(_ALIGN_DOUBLES-1));
	#endif
				*(_STACK_DOUBLE*)pStack = (_STACK_DOUBLE)pArg->date;
				pStack += sizeof(_STACK_DOUBLE);
	#ifdef _SHADOW_DOUBLES
				if (pDoubleShadow < pDoubleShadowMax)
					*pDoubleShadow++ = pArg->date;
	#endif
				break;

			case VT_CY:
				*(CY*)pStack = pArg->cyVal;
				pStack += sizeof(CY);
				break;

			case VT_BSTR:
				*(_STACK_PTR*)pStack = (_STACK_PTR)pArg->bstrVal;
				pStack += sizeof(_STACK_PTR);
				break;

			case VT_ERROR:
				*(_STACK_LONG*)pStack = (_STACK_LONG)pArg->scode;
				pStack += sizeof(_STACK_LONG);
				break;

			case VT_BOOL:
				*(_STACK_LONG*)pStack = (_STACK_LONG)(V_BOOL(pArg) != 0);
				pStack += sizeof(_STACK_LONG);
				break;

			case VT_VARIANT:
				*(_STACK_PTR*)pStack = (_STACK_PTR)pArg;
				pStack += sizeof(_STACK_PTR);
				break;

			case VT_DISPATCH:
			case VT_UNKNOWN:
				*(_STACK_PTR*)pStack = (_STACK_PTR)pArg->punkVal;
				pStack += sizeof(_STACK_PTR);
				break;

			default:
				ASSERT(FALSE);
				break;
			}
		}

#ifdef _ALIGN_STACK
		// align stack as appropriate for next parameter
		pStack = (BYTE*)(((DWORD_PTR)pStack + (_ALIGN_STACK-1)) &
			~(_ALIGN_STACK-1));
		ASSERT(((DWORD_PTR)pStack & (_ALIGN_STACK-1)) == 0);
#endif
	}

	// check that all source arguments were consumed
	if (iArg > 0)
	{
		*puArgErr = iArg;
		return DISP_E_BADPARAMCOUNT;
	}
	// check that all target arguments were filled
	if (*pb != '\0')
	{
		*puArgErr = pDispParams->cArgs;
		return DISP_E_PARAMNOTOPTIONAL;
	}
	return S_OK;    // success!
}

// indirect call helper (see OLECALL.CPP for implementation)

extern "C" DWORD_PTR AFXAPI
_AfxDispatchCall(AFX_PMSG pfn, void* pArgs, UINT nSizeArgs);

// invoke standard method given IDispatch parameters/return value, etc.
SCODE CCmdTarget::CallMemberFunc(const AFX_DISPMAP_ENTRY* pEntry, WORD wFlags,
	VARIANT* pvarResult, DISPPARAMS* pDispParams, UINT* puArgErr)
{
	AFX_MANAGE_STATE(m_pModuleState);

	ASSERT(pEntry != NULL);
	ASSERT(pEntry->pfn != NULL);

	// special union used only to hold largest return value possible
	union AFX_RESULT
	{
		VARIANT vaVal;
		CY cyVal;
		float fltVal;
		double dblVal;
		DWORD nVal;
		ULONGLONG ullVal;
	};

	// get default function and parameters
	BYTE bNoParams = 0;
	const BYTE* pbParams = (const BYTE*)pEntry->lpszParams;
	if (pbParams == NULL)
		pbParams = &bNoParams;
	UINT nParams = lstrlenA((LPCSTR)pbParams);

	// get default function and return value information
	AFX_PMSG pfn = pEntry->pfn;
	VARTYPE vtResult = pEntry->vt;

	// make DISPATCH_PROPERTYPUT look like call with one extra parameter
	if (wFlags & (DISPATCH_PROPERTYPUT|DISPATCH_PROPERTYPUTREF))
	{
		if(!ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable(nParams+3))
			return E_OUTOFMEMORY;
 #pragma warning(push)
 #pragma warning(disable:4068) //Disable unknown pragma warning that prefast pragma causes.
 #pragma prefast(push)
 #pragma prefast(disable:255, "Already validated that there is enough space on the stack for this allocation")
		BYTE* pbPropSetParams = (BYTE*)_alloca(nParams+3);
 #pragma prefast(pop)
 #pragma warning(pop)
			
		ASSERT(pbPropSetParams != NULL);    // stack overflow?

		ASSERT(!(pEntry->vt & VT_BYREF));
		Checked::memcpy_s(pbPropSetParams, nParams+3, pbParams, nParams);
		pbParams = pbPropSetParams;

		VARTYPE vtProp = pEntry->vt;
#if !defined(_UNICODE)
		if (vtProp == VT_BSTR)
			vtProp = VT_BSTRA;
#endif
		// VT_MFCVALUE serves serves as marker denoting start of named params
		pbPropSetParams[nParams++] = (BYTE)VT_MFCMARKER;
		pbPropSetParams[nParams++] = (BYTE)vtProp;
		pbPropSetParams[nParams] = 0;

		// call "set" function instead of "get"
		ASSERT(pEntry->pfnSet != NULL);
		pfn = pEntry->pfnSet;
		vtResult = VT_EMPTY;
	}

	// allocate temporary space for VARIANT temps created by VariantChangeType
	if(!ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable(pDispParams->cArgs * sizeof(VARIANT)))
			return E_OUTOFMEMORY;
	if (pDispParams->cArgs > (INT_MAX / sizeof(VARIANT)))
			return E_OUTOFMEMORY;
#pragma warning(push)
#pragma warning(disable:4068) //Disable unknown pragma warning that prefast pragma causes.
#pragma prefast(push)
#pragma prefast(disable:255, "Already validated that there is enough space on the stack for this allocation")
	VARIANT* rgTempVars =
		(VARIANT*)_alloca(pDispParams->cArgs * sizeof(VARIANT));
#pragma prefast(pop)
#pragma warning(pop)

	
	memset(rgTempVars, 0, pDispParams->cArgs * sizeof(VARIANT));

	// determine size of arguments and allocate stack space
	UINT nSizeArgs = GetStackSize(pbParams, vtResult);
	ASSERT(nSizeArgs != 0);
#pragma warning( push )
#pragma warning( disable: 4296 )
	if (nSizeArgs < _STACK_MIN)
#pragma warning( pop )
		nSizeArgs = _STACK_MIN;
	
	if(!ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable(nSizeArgs + _SCRATCH_SIZE))
			return E_OUTOFMEMORY;
#pragma warning(push)
#pragma warning(disable:4068) //Disable unknown pragma warning that prefast pragma causes.
#pragma prefast(push)
#pragma prefast(disable:255, "Already validated that there is enough space on the stack for this allocation")
	BYTE* pStack = (BYTE*)_alloca(nSizeArgs + _SCRATCH_SIZE);
#pragma prefast(pop)
#pragma warning(pop)

	

	// push all the args on to the stack allocated memory
	AFX_RESULT result;
	CVariantBoolConverter tempArgs;	
#ifndef _SHADOW_DOUBLES
	SCODE sc = PushStackArgs(pStack, pbParams, &result, vtResult,
		pDispParams, puArgErr, rgTempVars,&tempArgs);
#else
	SCODE sc = PushStackArgs(pStack, pbParams, &result, vtResult,
		pDispParams, puArgErr, rgTempVars, nSizeArgs,&tempArgs);
#endif
	pStack += _STACK_OFFSET;

	DWORD_PTR dwResult = 0;
	if (sc == S_OK)
	{
		TRY
		{
			// PushStackArgs will fail on argument mismatches
			DWORD_PTR (AFXAPI *pfnDispatch)(AFX_PMSG, void*, UINT) =
				&_AfxDispatchCall;

			// floating point return values are a special case
			switch (vtResult)
			{
			case VT_R4:
				result.fltVal = ((float (AFXAPI*)(AFX_PMSG, void*, UINT))
					pfnDispatch)(pfn, pStack, nSizeArgs);
				break;
			case VT_R8:
				result.dblVal = ((double (AFXAPI*)(AFX_PMSG, void*, UINT))
					pfnDispatch)(pfn, pStack, nSizeArgs);
				break;
			case VT_DATE:
				result.dblVal = ((DATE (AFXAPI*)(AFX_PMSG, void*, UINT))
					pfnDispatch)(pfn, pStack, nSizeArgs);
				break;

			case VT_I8:
			case VT_UI8:
				result.ullVal = ((ULONGLONG (AFXAPI*)(AFX_PMSG, void*, UINT))
					pfnDispatch)(pfn, pStack, nSizeArgs);
				break;

			default:
				dwResult = pfnDispatch(pfn, pStack, nSizeArgs);
				break;
			}
		}
		CATCH_ALL(e)
		{
			// free temporaries created by VariantChangeType
			for (UINT iArg = 0; iArg < pDispParams->cArgs; ++iArg)
				VariantClear(&rgTempVars[iArg]);

			THROW_LAST();
		}
		END_CATCH_ALL
	}

	// free temporaries created by VariantChangeType
	for (UINT iArg = 0; iArg < pDispParams->cArgs; ++iArg)
		VariantClear(&rgTempVars[iArg]);

	// handle error during PushStackParams
	if (sc != S_OK)
		return sc;

	//Copy the values from BOOL* stack params into the VARIANT_BOOLs passed
	//in DISPPARAMS.
	tempArgs.CopyBOOLsIntoVarBools();
	// property puts don't touch the return value
	if (pvarResult != NULL)
	{
		// clear pvarResult just in case
		pvarResult->vt = vtResult;

		// build return value VARIANT from result union
		switch (vtResult)
		{
		case VT_I1:
		case VT_UI1:
			pvarResult->bVal = (BYTE)dwResult;
			break;
		case VT_I2:
		case VT_UI2:
			pvarResult->iVal = (short)dwResult;
			break;
		case VT_I4:
		case VT_UI4:
			pvarResult->lVal = (long)dwResult;
			break;

		case VT_I8:
		case VT_UI8:
			pvarResult->ullVal = result.ullVal;
			break;

		case VT_R4:
			pvarResult->fltVal = result.fltVal;
			break;
		case VT_R8:
			pvarResult->dblVal = result.dblVal;
			break;
		case VT_CY:
			pvarResult->cyVal = result.cyVal;
			break;
		case VT_DATE:
			pvarResult->date = result.dblVal;
			break;
		case VT_BSTR:
			pvarResult->bstrVal = reinterpret_cast<BSTR>(dwResult);
			break;
		case VT_ERROR:
			pvarResult->scode = (SCODE)dwResult;
			break;
		case VT_BOOL:
			{
			//VT_BOOL return value may be BOOL (4 bytes) or VARIANT_BOOL (2 bytes).
			//Test only lower 2 bytes (0 - false, otherwise - true).
			//BOOL users should return only TRUE or FALSE.
			VARIANT_BOOL sBool=(VARIANT_BOOL)dwResult;
			V_BOOL(pvarResult) = (sBool != 0 ? VARIANT_TRUE : VARIANT_FALSE);			
			break;
			}
		case VT_VARIANT:
			*pvarResult = result.vaVal;
			break;
		case VT_DISPATCH:
		case VT_UNKNOWN:
			pvarResult->punkVal = reinterpret_cast<LPUNKNOWN>(dwResult); // already AddRef
			break;
		}
	}
	else
	{
		// free unused return value
		switch (vtResult)
		{
		case VT_BSTR:
            ::SysFreeString(reinterpret_cast<BSTR>(dwResult));
			break;
		case VT_DISPATCH:
		case VT_UNKNOWN:
			if (reinterpret_cast<LPUNKNOWN>(dwResult) != 0)
				reinterpret_cast<LPUNKNOWN>(dwResult)->Release();
			break;
		case VT_VARIANT:
			VariantClear(&result.vaVal);
			break;
		}
	}

	return S_OK;    // success!
}

/////////////////////////////////////////////////////////////////////////////
// CCmdTarget::XDispatch implementation

STDMETHODIMP_(ULONG) COleDispatchImpl::AddRef()
{
	METHOD_PROLOGUE_EX_(CCmdTarget, Dispatch)
	return pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) COleDispatchImpl::Release()
{
	METHOD_PROLOGUE_EX_(CCmdTarget, Dispatch)
	return pThis->ExternalRelease();
}

STDMETHODIMP COleDispatchImpl::QueryInterface(REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(CCmdTarget, Dispatch)
	return pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP COleDispatchImpl::GetTypeInfoCount(UINT* pctinfo)
{
	METHOD_PROLOGUE_EX_(CCmdTarget, Dispatch)
	*pctinfo = pThis->GetTypeInfoCount();
	return S_OK;
}

STDMETHODIMP COleDispatchImpl::GetTypeInfo(UINT itinfo, LCID lcid,
	ITypeInfo** pptinfo)
{
	METHOD_PROLOGUE_EX_(CCmdTarget, Dispatch)
	ASSERT_POINTER(pptinfo, LPTYPEINFO);

	if (itinfo != 0)
		return DISP_E_BADINDEX;

	IID iid;
	if (!pThis->GetDispatchIID(&iid))
		return DISP_E_BADINDEX;

	return pThis->GetTypeInfoOfGuid(lcid, iid, pptinfo);
}

STDMETHODIMP COleDispatchImpl::GetIDsOfNames(
	REFIID riid, LPOLESTR* rgszNames, UINT cNames, LCID lcid, DISPID* rgdispid)
{
	METHOD_PROLOGUE_EX_(CCmdTarget, Dispatch)
	ASSERT_POINTER(rgszNames, char*);
	ASSERT_POINTER(rgdispid, DISPID);

	// check arguments
	if (riid != IID_NULL)
		return DISP_E_UNKNOWNINTERFACE;

	if (cNames == 0)
		return E_INVALIDARG;

	SCODE sc = DISP_E_UNKNOWNNAME;
	LPTYPEINFO lpTypeInfo = NULL;
	if (lcid != 0 && SUCCEEDED(sc = GetTypeInfo(0, lcid, &lpTypeInfo)))
	{
		// For non-zero lcid, let typeinfo do the work (when available)
		ASSERT(lpTypeInfo != NULL);
		sc = lpTypeInfo->GetIDsOfNames(rgszNames, cNames, rgdispid);
		lpTypeInfo->Release();
		if (sc == TYPE_E_ELEMENTNOTFOUND)
			sc = DISP_E_UNKNOWNNAME;
	}
	else
	{
		// fill in the member name
		const AFX_DISPMAP* pDerivMap = pThis->GetDispatchMap();
		CString strName(rgszNames[0]);
		rgdispid[0] = pThis->MemberIDFromName(pDerivMap, strName.GetString());
		if (rgdispid[0] == DISPID_UNKNOWN)
			sc = DISP_E_UNKNOWNNAME;
		else if (cNames == 1)
			sc = S_OK;

		// argument names are always DISPID_UNKNOWN (for this implementation)
		for (UINT nIndex = 1; nIndex < cNames; nIndex++)
			rgdispid[nIndex] = DISPID_UNKNOWN;
	}

	return sc;
}

STDMETHODIMP COleDispatchImpl::Invoke(
	DISPID dispid, REFIID riid, LCID lcid,
	WORD wFlags, DISPPARAMS* pDispParams, LPVARIANT pvarResult,
	LPEXCEPINFO pexcepinfo, UINT* puArgErr)
{
	METHOD_PROLOGUE_EX_(CCmdTarget, Dispatch)
	ASSERT_NULL_OR_POINTER(pvarResult, VARIANT);
	ASSERT_NULL_OR_POINTER(pexcepinfo, EXCEPINFO);
	ASSERT_NULL_OR_POINTER(puArgErr, UINT);
	ASSERT(pDispParams != NULL);

	// check argument
	if(pDispParams == NULL)
	{
		return E_INVALIDARG;
	}

	// make sure pvarResult is initialized
	if (pvarResult != NULL)
		AfxVariantInit(pvarResult);

	// check arguments
	if (riid != IID_NULL)
		return DISP_E_UNKNOWNINTERFACE;

	// allow subclass to disable Invoke
	if (!pThis->IsInvokeAllowed(dispid))
		return E_UNEXPECTED;

	// copy param block for safety
	DISPPARAMS params = *pDispParams;
	pDispParams = &params;

	// most of the time, named arguments are not supported
	if (pDispParams->cNamedArgs != 0)
	{
		// only special PROPERTYPUT named argument is allowed
		if (pDispParams->cNamedArgs != 1 ||
			pDispParams->rgdispidNamedArgs[0] != DISPID_PROPERTYPUT)
		{
			return DISP_E_NONAMEDARGS;
		}
	}

	// get entry for the member ID
	const AFX_DISPMAP_ENTRY* pEntry = pThis->GetDispEntry(dispid);
	if (pEntry == NULL)
		return DISP_E_MEMBERNOTFOUND;

	// treat member calls on properties just like property get/set
	if ((wFlags == DISPATCH_METHOD) &&
		((pEntry->pfn == NULL && pEntry->pfnSet == NULL) ||
		 (pEntry->pfn == NULL && pEntry->pfnSet != NULL) ||
		 (pEntry->pfn != NULL && pEntry->pfnSet != NULL)))
	{
		// the entry describes a property but a method call is being
		//  attempted -- change it to a property get/set based on the
		//  number of parameters being passed.
		wFlags &= ~DISPATCH_METHOD;
		UINT nExpectedArgs = pEntry->lpszParams != NULL ?
			(UINT)lstrlenA(pEntry->lpszParams) : 0;
		if (pDispParams->cArgs <= nExpectedArgs)
		{
			// no extra param -- so treat as property get
			wFlags |= DISPATCH_PROPERTYGET;
		}
		else
		{
			// extra params -- treat as property set
			wFlags |= DISPATCH_PROPERTYPUTREF;
			pDispParams->cNamedArgs = 1;
		}
	}

	// property puts should not require a return value
	if (wFlags & (DISPATCH_PROPERTYPUTREF|DISPATCH_PROPERTYPUT))
	{
		pvarResult = NULL;
		// catch attempt to do property set on method
		if (pEntry->pfn != NULL && pEntry->pfnSet == NULL)
			return DISP_E_TYPEMISMATCH;
	}

	UINT uArgErr = (UINT)-1;    // no error yet
	SCODE sc = S_OK;

	// handle special cases of DISPATCH_PROPERTYPUT
	VARIANT* pvarParamSave = NULL;
	VARIANT vaParamSave;
	vaParamSave.vt = VT_ERROR;

	DISPPARAMS paramsTemp;
	VARIANT vaTemp;
	AfxVariantInit(&vaTemp);

	if (wFlags == DISPATCH_PROPERTYPUT)
	{
		// with PROPERTYPUT (no REF), the right hand side may need fixup
		if (pDispParams->rgvarg[0].vt == VT_DISPATCH &&
			pDispParams->rgvarg[0].pdispVal != NULL)
		{
			// remember old value for restore later
			pvarParamSave = &pDispParams->rgvarg[0];
			vaParamSave = pDispParams->rgvarg[0];
			AfxVariantInit(&pDispParams->rgvarg[0]);

			// get default value of right hand side
			memset(&paramsTemp, 0, sizeof(DISPPARAMS));
			sc = vaParamSave.pdispVal->Invoke(
				DISPID_VALUE, riid, lcid, DISPATCH_PROPERTYGET, &paramsTemp,
				&pDispParams->rgvarg[0], pexcepinfo, puArgErr);
		}

		// special handling for PROPERTYPUT (no REF), left hand side
		if (sc == S_OK && pEntry->vt == VT_DISPATCH)
		{
			memset(&paramsTemp, 0, sizeof(DISPPARAMS));

			// parameters are distributed depending on what the Get expects
			if (pEntry->lpszParams == NULL)
			{
				// paramsTemp is already setup for no parameters
				sc = Invoke(dispid, riid, lcid,
					DISPATCH_PROPERTYGET|DISPATCH_METHOD, &paramsTemp,
					&vaTemp, pexcepinfo, puArgErr);
				if (sc == S_OK &&
					(vaTemp.vt != VT_DISPATCH || vaTemp.pdispVal == NULL))
					sc = DISP_E_TYPEMISMATCH;
				else if (sc == S_OK)
				{
					ASSERT(vaTemp.vt == VT_DISPATCH && vaTemp.pdispVal != NULL);
					// we have the result, now call put on the default property
					sc = vaTemp.pdispVal->Invoke(
						DISPID_VALUE, riid, lcid, wFlags, pDispParams,
						pvarResult, pexcepinfo, puArgErr);
				}
			}
			else
			{
				// pass all but named params
				paramsTemp.rgvarg = &pDispParams->rgvarg[1];
				paramsTemp.cArgs = pDispParams->cArgs - 1;
				sc = Invoke(dispid, riid, lcid,
					DISPATCH_PROPERTYGET|DISPATCH_METHOD, &paramsTemp,
					&vaTemp, pexcepinfo, puArgErr);
				if (sc == S_OK &&
					(vaTemp.vt != VT_DISPATCH || vaTemp.pdispVal == NULL))
					sc = DISP_E_TYPEMISMATCH;
				else if (sc == S_OK)
				{
					ASSERT(vaTemp.vt == VT_DISPATCH && vaTemp.pdispVal != NULL);

					// we have the result, now call put on the default property
					paramsTemp = *pDispParams;
					paramsTemp.cArgs = paramsTemp.cNamedArgs;
					sc = vaTemp.pdispVal->Invoke(
						DISPID_VALUE, riid, lcid, wFlags, &paramsTemp,
						pvarResult, pexcepinfo, puArgErr);
				}
			}
			VariantClear(&vaTemp);

			if (sc != DISP_E_MEMBERNOTFOUND)
				goto Cleanup;
		}

		if (sc != S_OK && sc != DISP_E_MEMBERNOTFOUND)
			goto Cleanup;
	}

	// ignore DISP_E_MEMBERNOTFOUND from above
	ASSERT(sc == DISP_E_MEMBERNOTFOUND || sc == S_OK);

	// undo implied default value on right hand side on error
	if (sc != S_OK && pvarParamSave != NULL)
	{
		// default value stuff failed -- so try without default value
		pvarParamSave = NULL;
		VariantClear(&pDispParams->rgvarg[0]);
		pDispParams->rgvarg[0] = vaParamSave;
	}
	sc = S_OK;

	// check arguments against this entry
	UINT nOrigArgs; nOrigArgs = pDispParams->cArgs;
	if (wFlags & (DISPATCH_PROPERTYGET|DISPATCH_METHOD))
	{
		if (!(wFlags & DISPATCH_METHOD))
		{
			if (pEntry->vt == VT_EMPTY)
				return DISP_E_BADPARAMCOUNT;
			if (pvarResult == NULL)
				return DISP_E_PARAMNOTOPTIONAL;
		}
		if (pEntry->lpszParams == NULL && pDispParams->cArgs > 0)
		{
			if (pEntry->vt != VT_DISPATCH)
				return DISP_E_BADPARAMCOUNT;

			// it is VT_DISPATCH property/method but too many arguments supplied
			// transfer those arguments to the default property of the return value
			// after getting the return value from this call.  This is referred
			// to as collection lookup.
			pDispParams->cArgs = 0;
			if (pvarResult == NULL)
				pvarResult = &vaTemp;
		}
	}

	// make sure that parameters are not passed to a simple property
	if (pDispParams->cArgs > 1 &&
		(wFlags & (DISPATCH_PROPERTYPUT|DISPATCH_PROPERTYPUTREF)) &&
		pEntry->pfn == NULL)
	{
		sc = DISP_E_BADPARAMCOUNT;
		goto Cleanup;
	}

	// make sure that pvarResult is set for simple property get
	if (pEntry->pfn == NULL && pDispParams->cArgs == 0 && pvarResult == NULL)
	{
		sc = DISP_E_PARAMNOTOPTIONAL;
		goto Cleanup;
	}

	// make sure IsExpectingResult returns FALSE as appropriate
	BOOL bResultExpected;
	bResultExpected = pThis->m_bResultExpected;
	pThis->m_bResultExpected = pvarResult != NULL;

	TRY
	{
		if (pEntry->pfn == NULL)
		{
			// do standard property get/set
			if (pDispParams->cArgs == 0)
				pThis->GetStandardProp(pEntry, pvarResult, &uArgErr);
			else
				sc = pThis->SetStandardProp(pEntry, pDispParams, &uArgErr);
		}
		else
		{
			// do standard method call
			sc = pThis->CallMemberFunc(pEntry, wFlags,
				pvarResult, pDispParams, &uArgErr);
		}
	}
	CATCH(COleException, e)
	{
		sc = e->m_sc;
		DELETE_EXCEPTION(e);
	}
	AND_CATCH_ALL(e)
	{
		AFX_MANAGE_STATE(pThis->m_pModuleState);
		if (pexcepinfo != NULL)
		{
			// fill exception with translation of MFC exception
			COleDispatchException::Process(pexcepinfo, e);
		}
		DELETE_EXCEPTION(e);
		sc = DISP_E_EXCEPTION;
	}
	END_CATCH_ALL

	// restore original m_bResultExpected flag
	pThis->m_bResultExpected = bResultExpected;

	// handle special DISPATCH_PROPERTYGET collection lookup case
	if (sc == S_OK && nOrigArgs > pDispParams->cArgs)
	{
		ASSERT(wFlags & (DISPATCH_PROPERTYGET|DISPATCH_METHOD));
		ASSERT(pvarResult != NULL);
		// must be non-NULL dispatch, otherwise type mismatch
		if (pvarResult->vt != VT_DISPATCH || pvarResult->pdispVal == NULL)
		{
			sc = DISP_E_TYPEMISMATCH;
			goto Cleanup;
		}
		// otherwise, valid VT_DISPATCH was returned
		pDispParams->cArgs = nOrigArgs;
		LPDISPATCH lpTemp = pvarResult->pdispVal;
		if (pvarResult != &vaTemp)
			AfxVariantInit(pvarResult);
		else
			pvarResult = NULL;
		sc = lpTemp->Invoke(DISPID_VALUE, riid, lcid, wFlags,
			pDispParams, pvarResult, pexcepinfo, puArgErr);
		lpTemp->Release();
	}

Cleanup:
	// restore any arguments which were modified
	if (pvarParamSave != NULL)
	{
		VariantClear(&pDispParams->rgvarg[0]);
		pDispParams->rgvarg[0] = vaParamSave;
	}

	// fill error argument if one is available
	if (sc != S_OK && puArgErr != NULL && uArgErr != -1)
		*puArgErr = uArgErr;

	return sc;
}

/////////////////////////////////////////////////////////////////////////////
// IDispatch specific exception

COleDispatchException::~COleDispatchException()
{
	// destructor code is compiler generated
}

void PASCAL COleDispatchException::Process(
	EXCEPINFO* pInfo, const CException* pAnyException)
{

	ASSERT(AfxIsValidAddress(pInfo, sizeof(EXCEPINFO)));
	ASSERT_VALID(pAnyException);

	// zero default & reserved members
	memset(pInfo, 0, sizeof(EXCEPINFO));

	// get description based on type of exception
	TCHAR szDescription[256];
	LPCTSTR pszDescription = szDescription;
	if (pAnyException->IsKindOf(RUNTIME_CLASS(COleDispatchException)))
	{
		// specific IDispatch style exception
		COleDispatchException* e = (COleDispatchException*)pAnyException;
		pszDescription = e->m_strDescription;
		pInfo->wCode = e->m_wCode;
		pInfo->dwHelpContext = e->m_dwHelpContext;
		pInfo->scode = e->m_scError;

		// propagate source and help file if present
		if (!e->m_strHelpFile.IsEmpty())
			pInfo->bstrHelpFile = ::SysAllocString(CStringW(e->m_strHelpFile).GetString());
		if (!e->m_strSource.IsEmpty())
			pInfo->bstrSource = ::SysAllocString(CStringW(e->m_strSource).GetString());
	}
	else if (pAnyException->IsKindOf(RUNTIME_CLASS(CMemoryException)))
	{
		// failed memory allocation
		AfxLoadString(AFX_IDP_FAILED_MEMORY_ALLOC, szDescription);
		pInfo->wCode = AFX_IDP_FAILED_MEMORY_ALLOC;
	}
	else
	{
		// other unknown/uncommon error
		AfxLoadString(AFX_IDP_INTERNAL_FAILURE, szDescription);
		pInfo->wCode = AFX_IDP_INTERNAL_FAILURE;
	}

	// build up rest of EXCEPINFO struct
	pInfo->bstrDescription = ::SysAllocString(CStringW(pszDescription).GetString());
	if (pInfo->bstrSource == NULL)
		pInfo->bstrSource = ::SysAllocString(CStringW(AfxGetAppName()).GetString());
	if (pInfo->bstrHelpFile == NULL && pInfo->dwHelpContext != 0)
		pInfo->bstrHelpFile = ::SysAllocString(CStringW(AfxGetApp()->m_pszHelpFilePath).GetString());
}

COleDispatchException::COleDispatchException(
	LPCTSTR lpszDescription, UINT nHelpID, WORD wCode)
{
	m_dwHelpContext = nHelpID != 0 ? HID_BASE_DISPATCH+nHelpID : 0;
	m_wCode = wCode;
	if (lpszDescription != NULL)
		m_strDescription = lpszDescription;
	m_scError = wCode != 0 ? NOERROR : E_UNEXPECTED;
}

BOOL COleDispatchException::GetErrorMessage(_Out_z_cap_(nMaxError) LPTSTR lpszError, _In_ UINT nMaxError,
	_Out_opt_ PUINT pnHelpContext) const
{
	ASSERT(lpszError != NULL && AfxIsValidString(lpszError, nMaxError));

	if (pnHelpContext != NULL)
		*pnHelpContext = 0;

	Checked::tcsncpy_s(lpszError, nMaxError, m_strDescription, _TRUNCATE);
	return TRUE;
}

void AFXAPI AfxThrowOleDispatchException(WORD wCode, LPCTSTR lpszDescription,
	UINT nHelpID)
{
	ASSERT(AfxIsValidString(lpszDescription));
	THROW(new COleDispatchException(lpszDescription, nHelpID, wCode));
}

void AFXAPI AfxThrowOleDispatchException(WORD wCode, UINT nDescriptionID,
	UINT nHelpID)
{
	TCHAR szBuffer[256];
	VERIFY(AfxLoadString(nDescriptionID, szBuffer) != 0);
	if (nHelpID == -1)
		nHelpID = nDescriptionID;
	THROW(new COleDispatchException(szBuffer, nHelpID, wCode));
}


IMPLEMENT_DYNAMIC(COleDispatchException, CException)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\olecli3.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// COleClientItem activation

// helper to get client site -- this is called from a number of places
LPOLECLIENTSITE COleClientItem::GetClientSite()
{
	ASSERT_VALID(this);

	LPOLECLIENTSITE lpClientSite =
		(LPOLECLIENTSITE)GetInterface(&IID_IOleClientSite);
	ASSERT(lpClientSite != NULL);
	return lpClientSite;
}

void COleClientItem::Activate(LONG nVerb, CView* pView, LPMSG lpMsg)
{
	ASSERT_VALID(this);
	ASSERT(m_lpObject != NULL);
	if (pView != NULL)
		ASSERT_VALID(pView);
	if (lpMsg != NULL)
		ASSERT(AfxIsValidAddress(lpMsg, sizeof(MSG), FALSE));

	// store the container HWND for in place activation then do the verb
	if (m_pView == NULL)
		m_pView = pView;

	_AFX_OLE_STATE* pOleState = _afxOleState;
	CView* pViewSave = pOleState->m_pActivateView;
	pOleState->m_pActivateView = NULL;

	// get item rectangle for in-place players
	//  (that may not support in-place activation)
	LPCRECT lpPosRect = NULL;
	CRect rectPos;
	if (pView != NULL)
	{
		ASSERT_VALID(pView);
		rectPos.SetRectEmpty();
		OnGetItemPosition(rectPos);
		if (!rectPos.IsRectEmpty())
		{
			lpPosRect = &rectPos;
			pOleState->m_pActivateView = pView;
		}
	}

	// prepare DoVerb parameters and call into the server
	LPOLECLIENTSITE lpClientSite = GetClientSite();
	HWND hWnd = pView->GetSafeHwnd();
	SCODE sc = m_lpObject->DoVerb(nVerb, lpMsg, lpClientSite, -1,
		hWnd, lpPosRect);

	pOleState->m_pActivateView = pViewSave;

	// clear out m_pView in case in-place activation only partially worked
	if (!IsInPlaceActive())
		m_pView = NULL;

	// update available status based on the results of DoVerb
	//  (this is used in the links dialog).
	m_bLinkUnavail = (BYTE)FAILED(sc);

	CheckGeneral(sc);
}

//////////////////////////////////////////////////////////////////////////////
// Create error handling

void COleClientItem::CheckGeneral(SCODE sc)
	// set 'm_scLast'
	// throw exception if not ok to continue
{
	ASSERT_VALID(this);

	m_scLast = S_OK;    // assume things are ok

	// then, check for error
	if (sc != S_OK)
	{
		m_scLast = sc;
		if (!FAILED(sc))
		{
#ifdef _DEBUG
			// warn about non-NULL success codes
			TRACE(traceOle, 0, _T("Warning: operation returned scode = %s.\n"),
				AfxGetFullScodeString(m_scLast));
#endif
			return;
		}
		// this error wasn't expected, so throw an exception
		AfxThrowOleException(sc);
	}
}

/////////////////////////////////////////////////////////////////////////////
// COleClientItem clipboard support

void COleClientItem::CopyToClipboard(BOOL bIncludeLink)
{
	ASSERT_VALID(this);
	ASSERT(m_lpObject != NULL);

	// get clipboard data for this item
	COleDataSource* pDataSource = OnGetClipboardData(bIncludeLink, NULL, NULL);
	TRY
	{
		// put it on the clipboard
		pDataSource->SetClipboard();
	}
	CATCH_ALL(e)
	{
		delete pDataSource;
		THROW_LAST();
	}
	END_CATCH_ALL
}

COleDataSource* COleClientItem::OnGetClipboardData(
	BOOL bIncludeLink, LPPOINT lpOffset, LPSIZE lpSize)
{
	ASSERT_VALID(this);

	COleDataSource* pDataSource = new COleDataSource;
	TRY
	{
		GetClipboardData(pDataSource, bIncludeLink, lpOffset, lpSize);
	}
	CATCH_ALL(e)
	{
		delete pDataSource;
		THROW_LAST();
	}
	END_CATCH_ALL

	ASSERT_VALID(pDataSource);
	return pDataSource;
}


DROPEFFECT COleClientItem::DoDragDrop(LPCRECT lpItemRect, CPoint ptOffset,
	BOOL bIncludeLink, DWORD dwEffects, LPCRECT lpRectStartDrag)
{
	ASSERT(AfxIsValidAddress(lpItemRect, sizeof(RECT)));
	ASSERT_VALID(this);
	ASSERT(m_lpObject != NULL);

	DROPEFFECT dropEffect = DROPEFFECT_NONE;
	COleDataSource *pDataSource = NULL;
	TRY
	{
		// get clipboard data object for the item
		CSize sizeItem(
			lpItemRect->right - lpItemRect->left,
			lpItemRect->bottom - lpItemRect->top);
		pDataSource = OnGetClipboardData(bIncludeLink, &ptOffset, &sizeItem);

		// add DROPEFFECT_LINK only if link source is available
		LPDATAOBJECT lpDataObject = (LPDATAOBJECT)
			pDataSource->GetInterface(&IID_IDataObject);
		ASSERT(lpDataObject != NULL);
		FORMATETC formatEtc;
		formatEtc.cfFormat = (CLIPFORMAT)_oleData.cfLinkSource;
		formatEtc.ptd = NULL;
		formatEtc.dwAspect = DVASPECT_CONTENT;
		formatEtc.lindex = -1;
		formatEtc.tymed = (DWORD) -1;
		if (lpDataObject->QueryGetData(&formatEtc) == S_OK)
			dwEffects |= DROPEFFECT_LINK;

		// calculate default sensitivity rectangle
		CRect rectDrag;
		if (lpRectStartDrag == NULL)
		{
			rectDrag.SetRect(lpItemRect->left, lpItemRect->bottom,
				lpItemRect->left, lpItemRect->bottom);
			lpRectStartDrag = &rectDrag;
		}

		// do drag drop operation
		dropEffect = pDataSource->DoDragDrop(dwEffects, lpRectStartDrag);
		pDataSource->InternalRelease();
	}
	CATCH_ALL(e)
	{
		if (pDataSource != NULL)
			pDataSource->InternalRelease();

		THROW_LAST();
	}
	END_CATCH_ALL

	return dropEffect;
}

void COleClientItem::GetClipboardData(COleDataSource* pDataSource,
	BOOL bIncludeLink, LPPOINT lpOffset, LPSIZE lpSize)
{
	ASSERT_VALID(this);
	ASSERT(m_lpObject != NULL);
	ASSERT_VALID(pDataSource);

	// add CF_EMBEDDEDOBJECT by creating memory storage copy of the object
	STGMEDIUM stgMedium;
	GetEmbeddedItemData(&stgMedium);
	pDataSource->CacheData((CLIPFORMAT)_oleData.cfEmbeddedObject, &stgMedium);

	// add CF_OBJECTDESCRIPTOR
	GetObjectDescriptorData(lpOffset, lpSize, &stgMedium);
	pDataSource->CacheData((CLIPFORMAT)_oleData.cfObjectDescriptor,
		&stgMedium);

	// add any presentation entries in the object's cache
	AddCachedData(pDataSource);

	// add CF_LINKSOURCE if supporting links to embeddings
	if (bIncludeLink && GetLinkSourceData(&stgMedium))
	{
		pDataSource->CacheData((CLIPFORMAT)_oleData.cfLinkSource, &stgMedium);

		// add CF_LINKSOURCEDESCRIPTOR
		GetObjectDescriptorData(lpOffset, lpSize, &stgMedium);
		pDataSource->CacheData((CLIPFORMAT)_oleData.cfLinkSourceDescriptor,
			&stgMedium);
	}
}

BOOL PASCAL COleClientItem::CanPaste()
{
	// it is faster and more reliable to use the Windows clipboard
	//  APIs instead of OleQueryCreateFromData.
	return IsClipboardFormatAvailable(_oleData.cfEmbedSource) ||
		IsClipboardFormatAvailable(_oleData.cfEmbeddedObject) ||
		IsClipboardFormatAvailable(_oleData.cfFileName) ||
		IsClipboardFormatAvailable(_oleData.cfFileNameW) ||
		IsClipboardFormatAvailable(CF_METAFILEPICT) ||
		IsClipboardFormatAvailable(CF_DIB) ||
		IsClipboardFormatAvailable(CF_BITMAP) ||
		(IsClipboardFormatAvailable(_oleData.cfOwnerLink) &&
			IsClipboardFormatAvailable(_oleData.cfNative));
}

BOOL PASCAL COleClientItem::CanPasteLink()
{
	// it is faster and more reliable to use the Windows clipboard
	//  APIs instead of OleQueryCreateFromData.
	return IsClipboardFormatAvailable(_oleData.cfLinkSource) ||
		IsClipboardFormatAvailable(_oleData.cfFileName) ||
		IsClipboardFormatAvailable(_oleData.cfFileNameW) ||
		IsClipboardFormatAvailable(_oleData.cfObjectLink);
}

BOOL PASCAL
COleClientItem::CanCreateFromData(const COleDataObject* pDataObject)
{
	if (pDataObject->m_bClipboard)
		return COleClientItem::CanPaste();

	((COleDataObject*)pDataObject)->EnsureClipboardObject();
	if (pDataObject->m_lpDataObject == NULL)
		return FALSE;

	SCODE sc = ::OleQueryCreateFromData(pDataObject->m_lpDataObject);
	return !FAILED(sc) && sc != S_FALSE;
}

BOOL PASCAL
COleClientItem::CanCreateLinkFromData(const COleDataObject* pDataObject)
{
	if (pDataObject->m_bClipboard)
		return COleClientItem::CanPasteLink();

	((COleDataObject*)pDataObject)->EnsureClipboardObject();
	if (pDataObject->m_lpDataObject == NULL)
		return FALSE;

	SCODE sc = ::OleQueryLinkFromData(pDataObject->m_lpDataObject);
	return !FAILED(sc) && sc != S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Conversion & Activate As support

BOOL COleClientItem::ConvertTo(REFCLSID clsidNew)
{
	ASSERT_VALID(this);
	ASSERT(m_lpObject != NULL);

	// first, close the object
	Close();

	// convert it
	m_scLast = _AfxOleDoConvert(m_lpStorage, clsidNew);
	if (FAILED(m_scLast))
		return FALSE;

	// save IOleObject and IViewObject2 pointers
	LPOLEOBJECT lpObject = m_lpObject;
	LPVIEWOBJECT2 lpViewObject = m_lpViewObject;
	DWORD dwConnection = m_dwConnection;

	// NULL out IOleObject and IViewObject2 cached pointers
	m_lpObject = NULL;
	m_lpViewObject = NULL;
	m_dwConnection = 0;

	// then load the new object from the new storage
	BOOL bResult = FinishCreate(::OleLoad(m_lpStorage, IID_IUnknown,
		NULL, (LPLP)&m_lpObject));

	if (bResult)
	{
		RELEASE(lpObject);
		RELEASE(lpViewObject);
	}
	else
	{
		m_lpObject = lpObject;
		m_lpViewObject = lpViewObject;
		m_dwConnection = dwConnection;
		UpdateItemType();
	}
	ASSERT_VALID(this);

	return bResult;
}

BOOL COleClientItem::Reload()
{
	// first, close the object
	Close();

	// release any pointers we have to the object
	RELEASE(m_lpObject);
	RELEASE(m_lpViewObject);

	// then reload the object with OleLoad and finish creation process
	BOOL bResult = FinishCreate(::OleLoad(m_lpStorage, IID_IUnknown,
		NULL, (LPLP)&m_lpObject));

	ASSERT_VALID(this);
	return bResult;
}

BOOL COleClientItem::ActivateAs(LPCTSTR lpszUserType,
	REFCLSID clsidOld, REFCLSID clsidNew)
{
	ASSERT_VALID(this);
	ASSERT(lpszUserType == NULL || AfxIsValidString(lpszUserType));
	ASSERT(m_lpObject != NULL);

	// enable activate as
	m_scLast = _AfxOleDoTreatAsClass(lpszUserType, clsidOld, clsidNew);
	if (FAILED(m_scLast))
		return FALSE;

	// reload all items in this doucment
	COleDocument* pDoc = GetDocument();
	ASSERT_VALID(pDoc);
	POSITION pos = pDoc->GetStartPosition();
	COleClientItem* pItem;
	while ((pItem = pDoc->GetNextClientItem(pos)) != NULL)
	{
		// reload it, so activate as works as appropriate
		pItem->Reload();
	}

	ASSERT_VALID(this);
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// COleClientItem printing support

BOOL COleClientItem::SetPrintDevice(const DVTARGETDEVICE* ptd)
{
	ASSERT(ptd == NULL ||
		AfxIsValidAddress(ptd, sizeof(DVTARGETDEVICE), FALSE));

	// get printer device information from cache
	LPOLECACHE lpOleCache;
	DVTARGETDEVICE* ptdCur = NULL;
	DWORD dwConnection;
	if (!GetPrintDeviceInfo(&lpOleCache, &ptdCur, &dwConnection))
	{
		lpOleCache = QUERYINTERFACE(m_lpObject, IOleCache);
		if (lpOleCache == NULL)
			return FALSE;   // no print device info available
	}
	ASSERT(lpOleCache != NULL);

	// both may have no target device (considered equal)
	if (ptd == NULL && ptdCur == NULL)
	{
		lpOleCache->Release();
		CoTaskMemFree(ptdCur);
		return TRUE;
	}

	if (ptd != NULL && ptdCur != NULL)
	{
		// should be non-NULL and valid addresses
		ASSERT(AfxIsValidAddress(ptd, (size_t)ptd->tdSize));
		ASSERT(AfxIsValidAddress(ptdCur, (size_t)ptdCur->tdSize));
		// see if they compare equal
		if (ptdCur->tdSize == ptd->tdSize &&
			memcmp(ptdCur, ptd, (size_t)ptd->tdSize) == 0)
		{
			lpOleCache->Release();
			CoTaskMemFree(ptdCur);
			return TRUE;
		}
	}

	// calling this with NULL will just remove the prevous printer cache
	if (ptd != NULL)
	{
		// new cache is for CF_METAFILEPICT, DVASPECT_CONTENT
		FORMATETC formatEtc;
		formatEtc.cfFormat = CF_METAFILEPICT;
		formatEtc.ptd = (DVTARGETDEVICE*)ptd;
		formatEtc.dwAspect = DVASPECT_CONTENT;
		formatEtc.lindex = -1;
		formatEtc.tymed = TYMED_MFPICT;

		// attempt to cache new format
		DWORD dwNewConnection;
		if (lpOleCache->Cache(&formatEtc, ADVFCACHE_ONSAVE,
			&dwNewConnection) != S_OK)
		{
			lpOleCache->Release();
			CoTaskMemFree(ptdCur);
			return FALSE;
		}
	}
	// new format is cached successfully, uncache old format
	if (ptdCur != NULL)
	{
		lpOleCache->Uncache(dwConnection);
		CoTaskMemFree(ptdCur);
	}
	// cleanup & return
	lpOleCache->Release();
	return TRUE;
}

BOOL COleClientItem::SetPrintDevice(const PRINTDLG* ppd)
{
	ASSERT(ppd == NULL || AfxIsValidAddress(ppd, sizeof(*ppd), FALSE));
	DVTARGETDEVICE* ptd = NULL;
	if (ppd != NULL)
		ptd = _AfxOleCreateTargetDevice((PRINTDLG*)ppd);

	BOOL bResult = SetPrintDevice(ptd);
	CoTaskMemFree(ptd);
	return bResult;
}

/////////////////////////////////////////////////////////////////////////////
// other advanced COleClientItem support

void COleClientItem::GetUserType(
	USERCLASSTYPE nUserClassType, CString& rString)
{
	ASSERT_VALID(this);
	ASSERT(m_lpObject != NULL);

	LPOLESTR lpszUserType;
	CheckGeneral(m_lpObject->GetUserType(nUserClassType, &lpszUserType));
	ASSERT(lpszUserType != NULL);
	ASSERT(AfxIsValidString(lpszUserType));
	rString = lpszUserType;
	CoTaskMemFree(lpszUserType);
}

void COleClientItem::Run()
{
	ASSERT_VALID(this);
	ASSERT(m_lpObject != NULL);

	// is object already in running state?
	if (::OleIsRunning(m_lpObject))
		return;

	// run the object -- throw exception on errors
	SCODE sc = ::OleRun(m_lpObject);
	CheckGeneral(sc);

	// should be running now
	ASSERT(::OleIsRunning(m_lpObject));
}

/////////////////////////////////////////////////////////////////////////////
// Linked COleClientItem operations

BOOL COleClientItem::UpdateLink()
{
	ASSERT_VALID(this);
	ASSERT(m_lpObject != NULL);

	m_scLast = S_OK;
	if (!IsLinkUpToDate())
	{
		m_scLast = m_lpObject->Update();
		ASSERT_VALID(m_pDocument);
		m_pDocument->SetModifiedFlag();
	}
	return m_scLast == S_OK;
}

BOOL COleClientItem::FreezeLink()
{
	ASSERT_VALID(this);
	ASSERT(m_lpObject != NULL);
	ASSERT(m_pDocument != NULL);
	ASSERT(GetType() == OT_LINK);

	// first save & close the item
	Close();

	// get IDataObject interface
	LPDATAOBJECT lpDataObject = QUERYINTERFACE(m_lpObject, IDataObject);
	ASSERT(lpDataObject != NULL);
	COleDataObject dataObject;
	dataObject.Attach(lpDataObject, TRUE);

	// save important state of original item
	LPOLEOBJECT lpObject = m_lpObject;
	LPSTORAGE lpStorage = m_lpStorage;
	LPLOCKBYTES lpLockBytes = m_lpLockBytes;
	LPVIEWOBJECT2 lpViewObject = m_lpViewObject;
	DWORD dwConnection = m_dwConnection;
	DWORD dwItemNumber = m_dwItemNumber;
	m_lpObject = NULL;
	m_lpStorage = NULL;
	m_lpLockBytes = NULL;
	m_lpViewObject = NULL;
	m_dwConnection = 0;

	// attempt to create new object from data
	if (!CreateStaticFromData(&dataObject))
	{
		m_lpObject = lpObject;
		m_lpStorage = lpStorage;
		m_lpLockBytes = lpLockBytes;
		m_lpViewObject = lpViewObject;
		m_dwConnection = dwConnection;
		return FALSE;
	}
#ifdef _DEBUG
	UpdateItemType();
	ASSERT(GetType() == OT_STATIC);
#endif

	// save new state of that item
	LPOLEOBJECT lpNewObject = m_lpObject;
	LPSTORAGE lpNewStorage = m_lpStorage;
	LPLOCKBYTES lpNewLockBytes = m_lpLockBytes;
	LPVIEWOBJECT2 lpNewViewObject = m_lpViewObject;
	DWORD dwNewConnection = m_dwConnection;
	DWORD dwNewItemNumber = m_dwItemNumber;

	// shut down old item
	m_lpObject = lpObject;
	m_lpStorage = lpStorage;
	m_lpLockBytes = lpLockBytes;
	m_lpViewObject = lpViewObject;
	m_dwConnection = dwConnection;
	m_dwItemNumber = dwItemNumber;
#ifdef _DEBUG
	UpdateItemType();
	ASSERT(GetType() == OT_LINK);
#endif
	Delete(FALSE);  // revokes item & removes storage

	// switch to new item
	m_lpObject = lpNewObject;
	m_lpStorage = lpNewStorage;
	m_lpLockBytes = lpNewLockBytes;
	m_lpViewObject = lpNewViewObject;
	m_dwConnection = dwNewConnection;
	m_dwItemNumber = dwNewItemNumber;
	UpdateItemType();
	ASSERT(GetType() == OT_STATIC);

	// send an on changed with same state to invalidate the item
	OnChange(OLE_CHANGED_STATE, (DWORD)GetItemState());
	ASSERT_VALID(m_pDocument);
	m_pDocument->SetModifiedFlag();

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// Special link attributes

OLEUPDATE COleClientItem::GetLinkUpdateOptions()
{
	ASSERT_VALID(this);
	ASSERT(m_lpObject != NULL);

	LPOLELINK lpOleLink = QUERYINTERFACE(m_lpObject, IOleLink);
	ASSERT(lpOleLink != NULL);  // perhaps not a link?

	DWORD dwUpdateOpt;
	SCODE sc = lpOleLink->GetUpdateOptions(&dwUpdateOpt);
	lpOleLink->Release();
	CheckGeneral(sc);   // may throw an exception

	return (OLEUPDATE)dwUpdateOpt;
}

void COleClientItem::SetLinkUpdateOptions(OLEUPDATE dwUpdateOpt)
{
	ASSERT_VALID(this);
	ASSERT(m_lpObject != NULL);

	LPOLELINK lpOleLink = QUERYINTERFACE(m_lpObject, IOleLink);
	ASSERT(lpOleLink != NULL);  // perhaps not a link?

	SCODE sc = lpOleLink->SetUpdateOptions(dwUpdateOpt);
	lpOleLink->Release();
	CheckGeneral(sc);
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\oledisp2.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include <stdarg.h>



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// COleDispatchDriver constructors/destructors

HRESULT AFXAPI AfxGetClassIDFromString(LPCTSTR lpsz, LPCLSID lpClsID)
{
	HRESULT hr;
	const CStringW strClsID(lpsz);
	if (lpsz[0] == '{')
	{		
		hr = CLSIDFromString(const_cast<LPOLESTR>(strClsID.GetString()), lpClsID);
	}
	else
	{
		hr = CLSIDFromProgID(strClsID.GetString(), lpClsID);
	}
	return hr;

}

COleDispatchDriver::COleDispatchDriver()
{
	m_lpDispatch = NULL;
	m_bAutoRelease = TRUE;
}

COleDispatchDriver::COleDispatchDriver(LPDISPATCH lpDispatch, BOOL bAutoRelease)
{
	m_lpDispatch = lpDispatch;
	m_bAutoRelease = bAutoRelease;
}

COleDispatchDriver::COleDispatchDriver(const COleDispatchDriver& dispatchSrc)
{
	ASSERT(this != &dispatchSrc);   // constructing from self?

	m_lpDispatch = dispatchSrc.m_lpDispatch;
	if (m_lpDispatch != NULL)
		m_lpDispatch->AddRef();
	m_bAutoRelease = TRUE;
}

const COleDispatchDriver&
COleDispatchDriver::operator=(const COleDispatchDriver& dispatchSrc)
{
	if (this != &dispatchSrc)
	{
		LPDISPATCH lpTemp = m_lpDispatch;
		m_lpDispatch = dispatchSrc.m_lpDispatch;
		if (m_lpDispatch != NULL)
			m_lpDispatch->AddRef();
		if (lpTemp != NULL && m_bAutoRelease)
			lpTemp->Release();
		m_bAutoRelease = TRUE;
	}
	return *this;
}

BOOL COleDispatchDriver::CreateDispatch(REFCLSID clsid, COleException* pError)
{
	ASSERT(m_lpDispatch == NULL);

	m_bAutoRelease = TRUE;  // good default is to auto-release

	// create an instance of the object
	LPUNKNOWN lpUnknown = NULL;
	SCODE sc = CoCreateInstance(clsid, NULL, CLSCTX_ALL | CLSCTX_REMOTE_SERVER,
		IID_IUnknown, (LPLP)&lpUnknown);
	if (sc == E_INVALIDARG)
	{
		// may not support CLSCTX_REMOTE_SERVER, so try without
		sc = CoCreateInstance(clsid, NULL, CLSCTX_ALL & ~CLSCTX_REMOTE_SERVER,
			IID_IUnknown, (LPLP)&lpUnknown);
	}
	if (FAILED(sc))
		goto Failed;

	// make sure it is running
	sc = OleRun(lpUnknown);
	if (FAILED(sc))
		goto Failed;

	// query for IDispatch interface
	m_lpDispatch = QUERYINTERFACE(lpUnknown, IDispatch);
	if (m_lpDispatch == NULL)
		goto Failed;

	lpUnknown->Release();
	ASSERT(m_lpDispatch != NULL);
	return TRUE;

Failed:
	RELEASE(lpUnknown);
	if (pError != NULL)
		pError->m_sc = sc;

#ifdef _DEBUG
	TRACE(traceOle, 0, _T("Warning: CreateDispatch returning scode = %s.\n"),
		AfxGetFullScodeString(sc));
#endif

	return FALSE;
}

BOOL COleDispatchDriver::CreateDispatch(LPCTSTR lpszProgID,
	COleException* pError)
{
	ASSERT(m_lpDispatch == NULL);

	// map prog id to CLSID
	CLSID clsid;
	SCODE sc = AfxGetClassIDFromString(lpszProgID, &clsid);
	if (FAILED(sc))
	{
		if (pError != NULL)
			pError->m_sc = sc;
		return FALSE;
	}

	// create with CLSID
	return CreateDispatch(clsid, pError);
}

void COleDispatchDriver::AttachDispatch(LPDISPATCH lpDispatch,
	BOOL bAutoRelease)
{
	ASSERT(lpDispatch != NULL);

	ReleaseDispatch();  // detach previous
	m_lpDispatch = lpDispatch;
	m_bAutoRelease = bAutoRelease;
}

void COleDispatchDriver::ReleaseDispatch()
{
	if (m_lpDispatch != NULL)
	{
		if (m_bAutoRelease)
			m_lpDispatch->Release();
		m_lpDispatch = NULL;
	}
}

LPDISPATCH COleDispatchDriver::DetachDispatch()
{
	LPDISPATCH lpDispatch = m_lpDispatch;
	m_lpDispatch = NULL;    // detach without Release
	return lpDispatch;
}

/////////////////////////////////////////////////////////////////////////////
// COleDispatchDriver implementation
class COleDispParams : public DISPPARAMS {
public:
	COleDispParams()
	{
		rgvarg = NULL;
		rgdispidNamedArgs = NULL;
		cArgs=0;
		cNamedArgs = 0;
	}
	~COleDispParams()
	{
		if (rgvarg)
		{
			delete [] rgvarg;
			rgvarg = NULL;
		}
	}
};
void COleDispatchDriver::InvokeHelperV(DISPID dwDispID, WORD wFlags,
	VARTYPE vtRet, void* pvRet, const BYTE* pbParamInfo, va_list argList)
{
	if (m_lpDispatch == NULL)
	{
		TRACE(traceOle, 0, "Warning: attempt to call Invoke with NULL m_lpDispatch!\n");
		return;
	}

	COleDispParams dispparams;
	memset(&dispparams, 0, sizeof dispparams);

	// determine number of arguments
	if (pbParamInfo != NULL)
		dispparams.cArgs = lstrlenA((LPCSTR)pbParamInfo);

	DISPID dispidNamed = DISPID_PROPERTYPUT;
	if (wFlags & (DISPATCH_PROPERTYPUT|DISPATCH_PROPERTYPUTREF))
	{
		ASSERT(dispparams.cArgs > 0);
		dispparams.cNamedArgs = 1;
		dispparams.rgdispidNamedArgs = &dispidNamed;
	}
	CVariantBoolConverter tempArgs; //Used to convert VARIANT_BOOL | VT_BYREF --> BOOL*.
	if (dispparams.cArgs != 0)
	{
		// allocate memory for all VARIANT parameters
		VARIANT* pArg = new VARIANT[dispparams.cArgs];
		ASSERT(pArg != NULL);   // should have thrown exception
		dispparams.rgvarg = pArg;
		memset(pArg, 0, sizeof(VARIANT) * dispparams.cArgs);

		// get ready to walk vararg list
		const BYTE* pb = pbParamInfo;
		pArg += dispparams.cArgs - 1;   // params go in opposite order

		while (*pb != 0)
		{
			ASSERT(pArg >= dispparams.rgvarg);

			pArg->vt = *pb; // set the variant type
			if (pArg->vt & VT_MFCBYREF)
			{
				pArg->vt &= ~VT_MFCBYREF;
				pArg->vt |= VT_BYREF;
			}
			switch (pArg->vt)
			{
			case VT_UI1:
				pArg->bVal = va_arg(argList, BYTE);
				break;
			case VT_UI2:
				pArg->uiVal = va_arg(argList, USHORT);
				break;
			case VT_UI4:
				pArg->ulVal = va_arg(argList, ULONG);
				break;
			case VT_UI8:
				pArg->ullVal = va_arg(argList, ULONGLONG);
				break;
			case VT_I1:
				pArg->cVal = va_arg(argList, char);
				break;
			case VT_I2:
				pArg->iVal = va_arg(argList, short);
				break;
			case VT_I4:
				pArg->lVal = va_arg(argList, long);
				break;
			case VT_I8:
				pArg->llVal = va_arg(argList, LONGLONG);
				break;
			case VT_R4:
				pArg->fltVal = (float)va_arg(argList, double);
				break;
			case VT_R8:
				pArg->dblVal = va_arg(argList, double);
				break;
			case VT_DATE:
				pArg->date = va_arg(argList, DATE);
				break;
			case VT_CY:
				//CY is always passed by ref
				pArg->cyVal = *va_arg(argList, CY*);
				break;
			case VT_BSTR:
				{
					LPCOLESTR lpsz = va_arg(argList, LPOLESTR);
					pArg->bstrVal = ::SysAllocString(lpsz);
					if (lpsz != NULL && pArg->bstrVal == NULL)
					{						
						AfxThrowMemoryException();
					}
				}
				break;
#if !defined(_UNICODE)
			case VT_BSTRA:
				{
					LPCSTR lpsz = va_arg(argList, LPSTR);
					CStringW strMBToUnicode(lpsz);
					pArg->bstrVal = ::SysAllocString(static_cast<LPCWSTR>(strMBToUnicode));
					if (lpsz != NULL && pArg->bstrVal == NULL)
						AfxThrowMemoryException();
					pArg->vt = VT_BSTR;
				}
				break;
#endif
			case VT_DISPATCH:
				pArg->pdispVal = va_arg(argList, LPDISPATCH);
				break;
			case VT_ERROR:
				pArg->scode = va_arg(argList, SCODE);
				break;
			case VT_BOOL:
				V_BOOL(pArg) = (VARIANT_BOOL)(va_arg(argList, BOOL) ? -1 : 0);
				break;
			case VT_VARIANT:
				//VARIANT is always passed by ref
				*pArg = *va_arg(argList, VARIANT*);
				break;
			case VT_UNKNOWN:
				pArg->punkVal = va_arg(argList, LPUNKNOWN);
				break;

			case VT_UI1|VT_BYREF:
				pArg->pbVal = va_arg(argList, BYTE*);
				break;
			case VT_UI2|VT_BYREF:
				pArg->puiVal = va_arg(argList, USHORT*);
				break;
			case VT_UI4|VT_BYREF:
				pArg->pulVal = va_arg(argList, ULONG*);
				break;
			case VT_UI8|VT_BYREF:
				pArg->pullVal = va_arg(argList, ULONGLONG*);
				break;
			case VT_I1|VT_BYREF:
				pArg->pcVal = va_arg(argList, char*);
				break;
			case VT_I2|VT_BYREF:
				pArg->piVal = va_arg(argList, short*);
				break;
			case VT_I4|VT_BYREF:
				pArg->plVal = va_arg(argList, long*);
				break;
			case VT_I8|VT_BYREF:
				pArg->pllVal = va_arg(argList, LONGLONG*);
				break;
			case VT_R4|VT_BYREF:
				pArg->pfltVal = va_arg(argList, float*);
				break;
			case VT_R8|VT_BYREF:
				pArg->pdblVal = va_arg(argList, double*);
				break;
			case VT_DATE|VT_BYREF:
				pArg->pdate = va_arg(argList, DATE*);
				break;
			case VT_CY|VT_BYREF:
				pArg->pcyVal = va_arg(argList, CY*);
				break;
			case VT_BSTR|VT_BYREF:
				pArg->pbstrVal = va_arg(argList, BSTR*);
				break;
			case VT_DISPATCH|VT_BYREF:
				pArg->ppdispVal = va_arg(argList, LPDISPATCH*);
				break;
			case VT_ERROR|VT_BYREF:
				pArg->pscode = va_arg(argList, SCODE*);
				break;
			case VT_BOOL|VT_BYREF:
				{
					// coerce BOOL into VARIANT_BOOL
					BOOL* pboolVal = va_arg(argList, BOOL*);
					*pboolVal = *pboolVal ? MAKELONG(0xffff, 0) : 0;
					pArg->pboolVal = (VARIANT_BOOL*)pboolVal;
					tempArgs.AddPair( CVariantBoolPair(pboolVal,pArg->pboolVal,FALSE) );
				}
				break;
			case VT_VARIANT|VT_BYREF:
				pArg->pvarVal = va_arg(argList, VARIANT*);
				break;
			case VT_UNKNOWN|VT_BYREF:
				pArg->ppunkVal = va_arg(argList, LPUNKNOWN*);
				break;

			default:
				ASSERT(FALSE);  // unknown type!
				break;
			}

			--pArg; // get ready to fill next argument
			++pb;
		}
	}

	// initialize return value
	VARIANT* pvarResult = NULL;
	VARIANT vaResult;
	AfxVariantInit(&vaResult);
	if (vtRet != VT_EMPTY)
		pvarResult = &vaResult;

	// initialize EXCEPINFO struct
	EXCEPINFO excepInfo;
	memset(&excepInfo, 0, sizeof excepInfo);

	UINT nArgErr = (UINT)-1;  // initialize to invalid arg

	// make the call
	SCODE sc = m_lpDispatch->Invoke(dwDispID, IID_NULL, 0, wFlags,
		&dispparams, pvarResult, &excepInfo, &nArgErr);

	//When VT_BOOL | VT_BYREF is passed to com server, after Invoke returns - 
	//Convert VARIANT_TRUE[FALSE] --> BOOL TRUE[FALSE].	
	tempArgs.CopyVarBoolsIntoBOOLs();
	// cleanup any arguments that need cleanup
	if (dispparams.cArgs != 0)
	{
		VARIANT* pArg = dispparams.rgvarg + dispparams.cArgs - 1;
		const BYTE* pb = pbParamInfo;
		while (*pb != 0)
		{
			switch ((VARTYPE)*pb)
			{
#if !defined(_UNICODE)
			case VT_BSTRA:
#endif
			case VT_BSTR:
				VariantClear(pArg);
				break;
			}
			--pArg;
			++pb;
		}
	}
	delete[] dispparams.rgvarg;
	dispparams.rgvarg = NULL;

	// throw exception on failure
	if (FAILED(sc))
	{
		VariantClear(&vaResult);
		if (sc != DISP_E_EXCEPTION)
		{
			// non-exception error code
			AfxThrowOleException(sc);
		}

		// make sure excepInfo is filled in
		if (excepInfo.pfnDeferredFillIn != NULL)
			excepInfo.pfnDeferredFillIn(&excepInfo);

		// allocate new exception, and fill it
		COleDispatchException* pException =
			new COleDispatchException(NULL, 0, excepInfo.wCode);
		ASSERT(pException->m_wCode == excepInfo.wCode);
        if (::SysStringLen(excepInfo.bstrSource))
		{
			pException->m_strSource = excepInfo.bstrSource;
		}
        ::SysFreeString(excepInfo.bstrSource);
		if (::SysStringLen(excepInfo.bstrDescription))
		{
			pException->m_strDescription = excepInfo.bstrDescription;
		}
        ::SysFreeString(excepInfo.bstrDescription);
        if (::SysStringLen(excepInfo.bstrHelpFile))
		{
			pException->m_strHelpFile = excepInfo.bstrHelpFile;
		}
        ::SysFreeString(excepInfo.bstrHelpFile);
		pException->m_dwHelpContext = excepInfo.dwHelpContext;
		pException->m_scError = excepInfo.scode;

		// then throw the exception
		THROW(pException);
	}

	if (vtRet != VT_EMPTY)
	{
		// convert return value
		if (vtRet != VT_VARIANT)
		{
			SCODE scChangeType = VariantChangeType(&vaResult, &vaResult, 0, vtRet);
			if (FAILED(scChangeType))
			{
				TRACE(traceOle, 0, "Warning: automation return value coercion failed.\n");
				VariantClear(&vaResult);
				AfxThrowOleException(scChangeType);
			}
			ASSERT(vtRet == vaResult.vt);
		}

		// copy return value into return spot!
		switch (vtRet)
		{
		case VT_UI1:
			*(BYTE*)pvRet = vaResult.bVal;
			break;
		case VT_UI2:
			*(USHORT*)pvRet = vaResult.uiVal;
			break;
		case VT_UI4:
			*(ULONG*)pvRet = vaResult.ulVal;
			break;
		case VT_UI8:
			*(ULONGLONG*)pvRet = vaResult.ullVal;
			break;
		case VT_I1:
			*(char*)pvRet = vaResult.cVal;
			break;
		case VT_I2:
			*(short*)pvRet = vaResult.iVal;
			break;
		case VT_I4:
			*(long*)pvRet = vaResult.lVal;
			break;
		case VT_I8:
			*(LONGLONG*)pvRet = vaResult.llVal;
			break;
		case VT_R4:
			*(float*)pvRet = vaResult.fltVal;
			break;
		case VT_R8:
			*(double*)pvRet = vaResult.dblVal;
			break;
		case VT_DATE:
			*(double*)pvRet = *(double*)&vaResult.date;
			break;
		case VT_CY:
			*(CY*)pvRet = vaResult.cyVal;
			break;
		case VT_BSTR:
			AfxBSTR2CString((CString*)pvRet, vaResult.bstrVal);
			SysFreeString(vaResult.bstrVal);
			break;
		case VT_DISPATCH:
			*(LPDISPATCH*)pvRet = vaResult.pdispVal;
			break;
		case VT_ERROR:
			*(SCODE*)pvRet = vaResult.scode;
			break;
		case VT_BOOL:
			*(BOOL*)pvRet = (V_BOOL(&vaResult) != 0);
			break;
		case VT_VARIANT:
			*(VARIANT*)pvRet = vaResult;
			break;
		case VT_UNKNOWN:
			*(LPUNKNOWN*)pvRet = vaResult.punkVal;
			break;

		default:
			ASSERT(FALSE);  // invalid return type specified
		}
	}
}

void AFX_CDECL COleDispatchDriver::InvokeHelper(DISPID dwDispID, WORD wFlags,
	VARTYPE vtRet, void* pvRet, const BYTE* pbParamInfo, ...)
{
	va_list argList;
	va_start(argList, pbParamInfo);

	InvokeHelperV(dwDispID, wFlags, vtRet, pvRet, pbParamInfo, argList);

	va_end(argList);
}

void COleDispatchDriver::GetProperty(DISPID dwDispID, VARTYPE vtProp,
	void* pvProp) const
{
	((COleDispatchDriver*)this)->InvokeHelper(dwDispID,
		DISPATCH_PROPERTYGET, vtProp, pvProp, NULL);
}

void AFX_CDECL COleDispatchDriver::SetProperty(DISPID dwDispID, VARTYPE vtProp, ...)
{
	va_list argList;    // really only one arg, but...
	va_start(argList, vtProp);

	BYTE rgbParams[2];
	if (vtProp & VT_BYREF)
	{
		vtProp &= ~VT_BYREF;
		vtProp |= VT_MFCBYREF;
	}

#if !defined(_UNICODE)
		if (vtProp == VT_BSTR)
			vtProp = VT_BSTRA;
#endif

	rgbParams[0] = (BYTE)vtProp;
	rgbParams[1] = 0;
	WORD wFlags = (WORD)(vtProp == VT_DISPATCH ?
		DISPATCH_PROPERTYPUTREF : DISPATCH_PROPERTYPUT);
	InvokeHelperV(dwDispID, wFlags, VT_EMPTY, NULL, rgbParams, argList);

	va_end(argList);
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\oledlgs2.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// Common code for all OLE UI dialogs

UINT CALLBACK
AfxOleHookProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	if (message == WM_INITDIALOG)
		return (UINT)AfxDlgProc(hWnd, message, wParam, lParam);

	if (message == WM_COMMAND && LOWORD(wParam) == IDC_OLEUIHELP)
	{
		// just translate the message into the AFX standard help command.
		SendMessage(hWnd, WM_COMMAND, ID_HELP, 0);
		return TRUE;
	}
	return 0;
}

/////////////////////////////////////////////////////////////////////////////

COleDialog::COleDialog(CWnd* pParentWnd) : CCommonDialog(pParentWnd)
{
	m_nLastError = (UINT)-1;       // no error
}

int COleDialog::MapResult(UINT nResult)
{
	// store it for GetLastError()
	m_nLastError = nResult;

	// map OLEUI_OK & OLEUI_CANCEL to IDOK & IDCANCEL
	if (nResult == OLEUI_OK)
		return IDOK;
	if (nResult == OLEUI_CANCEL)
		return IDCANCEL;

	// otherwise, some sort of error
	return -1;
}

/////////////////////////////////////////////////////////////////////////////
// COleDialog diagnostics

#ifdef _DEBUG
void COleDialog::Dump(CDumpContext& dc) const
{
	CDialog::Dump(dc);

	dc << "m_nLastError = " << m_nLastError;
	dc << "\n";
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// COleBusyDialog implementation

COleBusyDialog::COleBusyDialog(HTASK htaskBlocking, BOOL bNotResponding,
	DWORD dwFlags, CWnd* pParentWnd) : COleDialog(pParentWnd)
{
	memset(&m_bz, 0, sizeof(m_bz)); // initialize structure to 0/NULL

	// fill in common part
	m_bz.cbStruct = sizeof(m_bz);
	m_bz.dwFlags = dwFlags;
	if (bNotResponding)
		m_bz.dwFlags |= BZ_NOTRESPONDINGDIALOG;
	m_bz.lpfnHook = AfxOleHookProc;

	// specific for this dialog
	m_bz.hTask = htaskBlocking;

	ASSERT_VALID(this);
}

COleBusyDialog::~COleBusyDialog()
{
}

INT_PTR COleBusyDialog::DoModal()
{
	// Note: we don't call EnableModeless because that in itself implies
	//  outgoing calls.  This dialog is normally brought up when an outgoing
	//  call cannot be made.

	// find parent HWND
	HWND hWndTop;
	HWND hParent = CWnd::GetSafeOwner_(m_pParentWnd->GetSafeHwnd(), &hWndTop);
	m_bz.hWndOwner = hParent;

	// run the dialog
	AfxHookWindowCreate(this);
	int iResult = ::OleUIBusy(&m_bz);
	AfxUnhookWindowCreate();   // just in case
	Detach();   // just in case

	// enable top level window
	if (hWndTop != NULL)
		::EnableWindow(hWndTop, TRUE);

	// map the result
	if (iResult == OLEUI_CANCEL)
		return IDCANCEL;

	if (iResult == OLEUI_BZ_SWITCHTOSELECTED)
		m_selection = switchTo;
	else if (iResult == OLEUI_BZ_RETRYSELECTED)
		m_selection = retry;
	else if (iResult == OLEUI_BZ_CALLUNBLOCKED)
		m_selection = callUnblocked;
	else
		m_selection = (Selection)MapResult(iResult);

	return IDOK;
}

/////////////////////////////////////////////////////////////////////////////
// COleBusyDialog diagnostics

#ifdef _DEBUG
void COleBusyDialog::Dump(CDumpContext& dc) const
{
	COleDialog::Dump(dc);

	dc << "m_bz.cbStruct = " << m_bz.cbStruct;
	dc << "\nm_bz.dwFlags = ";
	dc.DumpAsHex(m_bz.dwFlags);
	dc << "\nm_bz.hWndOwner = " << m_bz.hWndOwner;
	dc << "\nm_bz.lpszCaption = " << m_bz.lpszCaption;
	dc << "\nm_bz.lCustData = " << (LPVOID)m_bz.lCustData;
	dc << "\nm_bz.hInstance = " << (void*)m_bz.hInstance;
	dc << "\nm_bz.lpszTemplate = " << (void*)m_bz.lpszTemplate;
	dc << "\nm_bz.hResource = " << (void*)m_bz.hResource;
	if (m_bz.lpfnHook == AfxOleHookProc)
		dc << "\nhook function set to standard MFC hook function";
	else
		dc << "\nhook function set to non-standard hook function";
	dc << "\nm_bz.hTask = " << (UINT_PTR)m_bz.hTask;

	dc << "\n";
}
#endif


IMPLEMENT_DYNAMIC(COleDialog, CDialog)
IMPLEMENT_DYNAMIC(COleBusyDialog, COleDialog)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\oledlgs3.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

#pragma warning( disable: 4312 )

UINT CALLBACK
AfxOleHookProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);

////////////////////////////////////////////////////////////////////////////
// EditProperties dialog wrapper

COlePropertiesDialog::COlePropertiesDialog(
	COleClientItem* pItem, UINT nScaleMin, UINT nScaleMax, CWnd* pParentWnd)
	: COleDialog(pParentWnd), m_xLinkInfo(pItem)
{
	ASSERT_VALID(pItem);

	memset(&m_op, 0, sizeof(m_op)); // initialize structure to 0/NULL

	// fill in common part
	m_op.cbStruct = sizeof(m_op);
	m_op.dwFlags = 0;
	if (AfxHelpEnabled())
		m_op.dwFlags |= OPF_SHOWHELP;
	m_nIDHelp = AFX_IDD_OBJECTPROPERTIES;

	// specific to this dialog
	memset(&m_gp, 0, sizeof(m_gp));
	m_gp.cbStruct = sizeof(m_gp);
	m_gp.lpfnHook = AfxOleHookProc;
	m_gp.dwFlags = 0;

	memset(&m_vp, 0, sizeof(m_vp));
	m_vp.cbStruct = sizeof(m_vp);
	m_vp.lpfnHook = AfxOleHookProc;
	m_vp.dwFlags = 0;
	m_vp.nScaleMin = nScaleMin;
	m_vp.nScaleMax = nScaleMax;

	memset(&m_lp, 0, sizeof(m_lp));
	m_lp.cbStruct = sizeof(m_lp);
	m_lp.lpfnHook = AfxOleHookProc;
	m_lp.dwFlags = 0;

	m_op.lpObjInfo = &m_xOleUIObjInfo;
	m_op.lpLinkInfo = &m_xLinkInfo;
	DWORD dwItem = 0;
	COleDocument* pDoc = pItem->GetDocument();
	m_pDoc = pDoc;
	if (pDoc != NULL)
	{
		POSITION posItem = pDoc->GetStartPosition();
		ULONG iItem = 1;
		while ((posItem != NULL) && (dwItem == 0))
		{
			COleClientItem* pSearchItem = pDoc->GetNextClientItem(posItem);
			if (pSearchItem == pItem)
			{
				dwItem = iItem;
			}
			iItem++;
		}
	}
	m_op.dwLink = dwItem;
	m_op.dwObject = dwItem;
	m_op.lpGP = &m_gp; m_op.lpVP = &m_vp;
	if (pItem->GetType() == OT_LINK)
	{
		m_op.dwFlags |= OPF_OBJECTISLINK;
		m_op.lpLP = &m_lp;
	}
	memset(&m_psh, 0, sizeof(m_psh));
	m_psh.dwSize = sizeof(PROPSHEETHEADER);
	m_op.lpPS = &m_psh;
}

INT_PTR COlePropertiesDialog::DoModal()
{
	ASSERT_VALID(this);
	ASSERT(m_gp.lpfnHook != NULL);  // can still be a user hook
	ASSERT(m_vp.lpfnHook != NULL);  // can still be a user hook
	ASSERT(m_lp.lpfnHook != NULL);  // can still be a user hook

	// disable scale if OnApplyScale not implemented
	if (!OnApplyScale(NULL, -1, FALSE))
		m_op.lpVP->dwFlags |= VPF_DISABLESCALE;

	// invoke the dialog
	m_op.lpPS->hwndParent = PreModal();
	INT_PTR iResult = MapResult(::OleUIObjectProperties(&m_op));
	PostModal();
	return iResult;
}

BOOL COlePropertiesDialog::OnInitDialog()
{
	BOOL bResult = COleDialog::OnInitDialog();

	// automatic centering doesn't work for this dialog
	if (!(GetStyle() & WS_CHILD))
		CenterWindow();

	return bResult;
}

STDMETHODIMP_(ULONG) COlePropertiesDialog::XOleUIObjInfo::AddRef()
{
	return 0;
}

STDMETHODIMP_(ULONG) COlePropertiesDialog::XOleUIObjInfo::Release()
{
	return 0;
}

STDMETHODIMP COlePropertiesDialog::XOleUIObjInfo::QueryInterface(
	REFIID, LPVOID*)
{
	return E_NOTIMPL;
}

STDMETHODIMP COlePropertiesDialog::XOleUIObjInfo::GetObjectInfo(
	DWORD dwObject, DWORD* lpdwObjSize, LPTSTR* lplpszLabel,
	LPTSTR* lplpszType, LPTSTR* lplpszShortType, LPTSTR* lplpszLocation)
{
	METHOD_PROLOGUE_EX_(COlePropertiesDialog, OleUIObjInfo)
	COleClientItem* pItem = NULL;
	ASSERT_VALID( pThis->m_pDoc );
	if( pThis->m_pDoc != NULL )
	{
		POSITION posItem = pThis->m_pDoc->GetStartPosition();
		for (ULONG iLink = 0; iLink < dwObject; ++iLink)
		{
			pItem = pThis->m_pDoc->GetNextClientItem(posItem);
		}
	}
	ENSURE_VALID(pItem);
	BOOL bIsLink = (pItem->GetType() == OT_LINK);

	if (lpdwObjSize != NULL)
	{
		ASSERT(pItem->m_lpStorage != NULL);

		// try ILockBytes first, then IStorage
		STATSTG statStg;
		if ((pItem->m_lpLockBytes == NULL ||
			pItem->m_lpLockBytes->Stat(&statStg, STATFLAG_NONAME) != S_OK) &&
			pItem->m_lpStorage->Stat(&statStg, STATFLAG_NONAME) != S_OK)
		{
			*lpdwObjSize = 0xFFFFFFFF;
		}
		else
		{
			ASSERT(statStg.pwcsName == NULL);
			if (statStg.cbSize.HighPart > 0)
				*lpdwObjSize = 0xFFFFFFFE;
			else if (statStg.cbSize.LowPart == 0)
				*lpdwObjSize = 0xFFFFFFFF;
			else
				*lpdwObjSize = statStg.cbSize.LowPart;
		}
	}

	if (lplpszLabel != NULL)
	{
		TCHAR szFormatLink[128];
		AfxLoadString(AFX_IDS_PASTELINKEDTYPE, szFormatLink, _countof(szFormatLink));
		TCHAR szFormatObj[] = _T("%s");
		LPTSTR lpszFormat = bIsLink ? szFormatLink : szFormatObj;
		CString strType;
		pItem->GetUserType(USERCLASSTYPE_FULL, strType);
		CString strResult;
		strResult.Format(lpszFormat, (LPCTSTR)strType);
		*lplpszLabel = AtlAllocTaskString(strResult);
	}

	if (lplpszType != NULL)
	{
		LPOLESTR lpOleStr;
		pItem->m_lpObject->GetUserType(USERCLASSTYPE_FULL, &lpOleStr);
		*lplpszType = TASKSTRINGOLE2T(lpOleStr);
	}

	if (lplpszShortType != NULL)
	{
		LPOLESTR lpOleStr;
		pItem->m_lpObject->GetUserType(USERCLASSTYPE_SHORT, &lpOleStr);
		*lplpszShortType = TASKSTRINGOLE2T(lpOleStr);
	}

	if (lplpszLocation != NULL)
	{
		if (bIsLink)
		{
			LPOLELINK lpOleLink = NULL;
			pItem->m_lpObject->QueryInterface(IID_IOleLink, (LPVOID*)&lpOleLink);
			ASSERT(lpOleLink != NULL);
			LPOLESTR lpOleStr;
			lpOleLink->GetSourceDisplayName(&lpOleStr);
			*lplpszLocation = TASKSTRINGOLE2T(lpOleStr);
			lpOleLink->Release();
		}
		else
		{
			CDocument* pDoc = (CDocument*)pItem->GetDocument();
			CString strLocation = pDoc->GetPathName();
			if (strLocation.IsEmpty())
				strLocation = pDoc->GetTitle();
			*lplpszLocation = AtlAllocTaskString(strLocation);
		}
	}

	return S_OK;
}

STDMETHODIMP COlePropertiesDialog::XOleUIObjInfo::GetConvertInfo(
	DWORD dwObject, CLSID* lpClassID, WORD* lpwFormat,
	CLSID*, LPCLSID*, UINT*)
{
	METHOD_PROLOGUE_EX_(COlePropertiesDialog, OleUIObjInfo)
	COleClientItem* pItem = NULL;
	ASSERT_VALID( pThis->m_pDoc );
	if( pThis->m_pDoc != NULL )
	{
		POSITION posItem = pThis->m_pDoc->GetStartPosition();
		for (ULONG iLink = 0; iLink < dwObject; ++iLink)
		{
			pItem = pThis->m_pDoc->GetNextClientItem(posItem);
		}
	}
	ENSURE_VALID(pItem);

	if (lpClassID != NULL)
	{
		if (pItem->GetType() == OT_LINK ||
			S_OK != ReadClassStg(pItem->m_lpStorage, lpClassID))
		{
			pItem->GetClassID(lpClassID);
		}
	}
	if (lpwFormat != NULL)
	{
		*lpwFormat = 0;
		CLIPFORMAT cf;
		if (ReadFmtUserTypeStg(pItem->m_lpStorage, &cf, NULL) == S_OK)
			*lpwFormat = (WORD)cf;
	}

	// Note: leave rest at default

	return S_OK;
}

STDMETHODIMP COlePropertiesDialog::XOleUIObjInfo::ConvertObject(
	DWORD dwObject, REFCLSID clsidNew)
{
	METHOD_PROLOGUE_EX_(COlePropertiesDialog, OleUIObjInfo)
	COleClientItem* pItem = NULL;
	ASSERT_VALID( pThis->m_pDoc );
	if( pThis->m_pDoc != NULL )
	{
		POSITION posItem = pThis->m_pDoc->GetStartPosition();
		for (ULONG iLink = 0; iLink < dwObject; ++iLink)
		{
			pItem = pThis->m_pDoc->GetNextClientItem(posItem);
		}
	}
	ENSURE_VALID(pItem);

	if (!pItem->ConvertTo(clsidNew))
	{
		AfxMessageBox(AFX_IDP_FAILED_TO_CONVERT,
			MB_OK | MB_ICONEXCLAMATION);
		return E_FAIL;
	}
	return S_OK;
}

STDMETHODIMP COlePropertiesDialog::XOleUIObjInfo::GetViewInfo(
	DWORD dwObject, HGLOBAL* phMetaPict, DWORD* pdvAspect, int* pnCurrentScale)
{
	METHOD_PROLOGUE_EX_(COlePropertiesDialog, OleUIObjInfo)
	COleClientItem* pItem = NULL;
	ASSERT_VALID( pThis->m_pDoc );
	if( pThis->m_pDoc != NULL )
	{
		POSITION posItem = pThis->m_pDoc->GetStartPosition();
		for (ULONG iLink = 0; iLink < dwObject; ++iLink)
		{
			pItem = pThis->m_pDoc->GetNextClientItem(posItem);
		}
	}
	ENSURE_VALID(pItem);

	if (phMetaPict != NULL)
		*phMetaPict = pItem->GetIconicMetafile();

	if (pdvAspect != NULL)
		*pdvAspect = pItem->GetDrawAspect();

	if (pnCurrentScale != NULL)
		*pnCurrentScale = 100;  // 100% (arbitrary for now)

	return S_OK;
}

STDMETHODIMP COlePropertiesDialog::XOleUIObjInfo::SetViewInfo(
	DWORD dwObject, HGLOBAL hMetaPict, DWORD dvAspect,
	int nCurrentScale, BOOL bRelativeToOrig)
{
	METHOD_PROLOGUE_EX_(COlePropertiesDialog, OleUIObjInfo)
	COleClientItem* pItem = NULL;
	ASSERT_VALID( pThis->m_pDoc );
	if( pThis->m_pDoc != NULL )
	{
		POSITION posItem = pThis->m_pDoc->GetStartPosition();
		for (ULONG iLink = 0; iLink < dwObject; ++iLink)
		{
			pItem = pThis->m_pDoc->GetNextClientItem(posItem);
		}
	}
	ENSURE_VALID(pItem);

	// handle aspect changes
	if (dvAspect != -1)
	{
		pItem->OnChange(OLE_CHANGED_ASPECT, dvAspect);
		pItem->SetDrawAspect((DVASPECT)dvAspect);

		// force scale to 100% when changing aspects
		if (dvAspect == DVASPECT_ICON)
		{
			nCurrentScale = 100;
			bRelativeToOrig = TRUE;
		}
		else if (nCurrentScale == -1)
		{
			nCurrentScale = 100;
			bRelativeToOrig = FALSE;
		}
	}

	// handle icon representation changes
	if (hMetaPict != NULL)
	{
		pItem->SetIconicMetafile(hMetaPict);
		if (pItem->GetDrawAspect() == DVASPECT_ICON)
			pItem->OnChange(OLE_CHANGED, (DWORD)DVASPECT_ICON);
	}

	// handle scale changes
	if (nCurrentScale != -1)
	{
		pThis->OnApplyScale(pItem, nCurrentScale, bRelativeToOrig);
	}

	return S_OK;
}

BOOL COlePropertiesDialog::OnApplyScale(COleClientItem*, int, BOOL)
{
	// Note: no default implementation. Must override or scaling
	//  controls will be disabled during the DoModal call.

	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// COlePropertiesDialog diagnostics

#ifdef _DEBUG

void COlePropertiesDialog::Dump(CDumpContext& dc) const
{
	COleDialog::Dump(dc);
}

void COlePropertiesDialog::AssertValid() const
{
	COleDialog::AssertValid();
	ASSERT(m_op.cbStruct == sizeof(m_op));
	ASSERT(m_gp.cbStruct == sizeof(m_gp));
	ASSERT(m_vp.cbStruct == sizeof(m_vp));
	ASSERT(m_lp.cbStruct == sizeof(m_lp));
}

#endif

////////////////////////////////////////////////////////////////////////////
// ChangeSource dialog wrapper

COleChangeSourceDialog::COleChangeSourceDialog(COleClientItem* pItem,
	CWnd* pParentWnd) : COleDialog(pParentWnd), m_xLinkInfo(pItem)
{
	ASSERT_VALID(pItem);

	memset(&m_cs, 0, sizeof(m_cs)); // initialize structure to 0/NULL

	// fill in common part
	m_cs.cbStruct = sizeof(m_cs);
	m_cs.dwFlags = 0;
	if (AfxHelpEnabled())
		m_cs.dwFlags |= CSF_SHOWHELP;
	m_cs.lpfnHook = AfxOleHookProc;
	m_nIDHelp = AFX_IDD_CHANGESOURCE;

	// specific to this dialog
	m_cs.lpOleUILinkContainer = &m_xLinkInfo;
	COleDocument* pDoc = pItem->GetDocument();
	DWORD dwItem = 0;
	if (pDoc != NULL)
	{
		POSITION posItem = pDoc->GetStartPosition();
		ULONG iItem = 1;
		while ((posItem != NULL) && (dwItem == 0))
		{
			COleClientItem* pSearchItem = pDoc->GetNextClientItem(posItem);
			if (pSearchItem == pItem)
			{
				dwItem = iItem;
			}
			iItem++;
		}
	}
	m_cs.dwLink = dwItem;
}

INT_PTR COleChangeSourceDialog::DoModal()
{
	ASSERT_VALID(this);
	ASSERT(m_cs.lpfnHook != NULL);  // can still be a user hook

	m_cs.hWndOwner = PreModal();
	INT_PTR iResult = MapResult(::OleUIChangeSource(&m_cs));
	PostModal();
	return iResult;
}

void COleChangeSourceDialog::PreInitDialog()
{
	// automatic centering doesn't work for this dialog
	if (!(GetStyle() & WS_CHILD))
		CenterWindow();
}

COleChangeSourceDialog::~COleChangeSourceDialog()
{
	CoTaskMemFree(m_cs.lpszTo);
	CoTaskMemFree(m_cs.lpszFrom);
	CoTaskMemFree(m_cs.lpszDisplayName);
}

/////////////////////////////////////////////////////////////////////////////
// COleChangeSourceDialog diagnostics

#ifdef _DEBUG

void COleChangeSourceDialog::Dump(CDumpContext& dc) const
{
	COleDialog::Dump(dc);

	dc << "m_cs.cbStruct = " << m_cs.cbStruct;
	dc << "\nm_cs.dwFlags = " << (LPVOID)m_cs.dwFlags;
	dc << "\nm_cs.hWndOwner = " << (UINT_PTR)m_cs.hWndOwner;
	dc << "\nm_cs.lpszCaption = " << m_cs.lpszCaption;
	dc << "\nm_cs.lCustData = " << (LPVOID)m_cs.lCustData;
	dc << "\nm_cs.hInstance = " << (UINT_PTR)m_cs.hInstance;
	dc << "\nm_cs.lpszTemplate = " << (LPVOID)m_cs.lpszTemplate;
	dc << "\nm_cs.hResource = " << (UINT_PTR)m_cs.hResource;
	if (m_cs.lpfnHook == AfxOleHookProc)
		dc << "\nhook function set to standard MFC hook function";
	else
		dc << "\nhook function set to non-standard hook function";

	dc << "\n";
}

void COleChangeSourceDialog::AssertValid() const
{
	COleDialog::AssertValid();
	ASSERT(m_cs.cbStruct == sizeof(m_cs));
	ASSERT(m_cs.lpfnHook != NULL);
}

#endif


IMPLEMENT_DYNAMIC(COlePropertiesDialog, COleDialog)
IMPLEMENT_DYNAMIC(COleChangeSourceDialog, COleDialog)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\oledll.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



/////////////////////////////////////////////////////////////////////////////
// Support for MFC/COM in DLLs

SCODE AFXAPI AfxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	*ppv = NULL;
	DWORD lData1 = rclsid.Data1;

	// search factories defined in the application
	AFX_MODULE_STATE* pModuleState = AfxGetModuleState();
	AfxLockGlobals(CRIT_OBJECTFACTORYLIST);
	COleObjectFactory* pFactory;
	for (pFactory = pModuleState->m_factoryList;
		pFactory != NULL; pFactory = pFactory->m_pNextFactory)
	{
		if (pFactory->m_bRegistered != 0 &&
			lData1 == pFactory->m_clsid.Data1 &&
			((DWORD*)&rclsid)[1] == ((DWORD*)&pFactory->m_clsid)[1] &&
			((DWORD*)&rclsid)[2] == ((DWORD*)&pFactory->m_clsid)[2] &&
			((DWORD*)&rclsid)[3] == ((DWORD*)&pFactory->m_clsid)[3])
		{
			// found suitable class factory -- query for correct interface
			SCODE sc = pFactory->InternalQueryInterface(&riid, ppv);
			AfxUnlockGlobals(CRIT_OBJECTFACTORYLIST);
			return sc;
		}
	}
	AfxUnlockGlobals(CRIT_OBJECTFACTORYLIST);
#ifdef _AFXDLL
	AfxLockGlobals(CRIT_DYNLINKLIST);
	// search factories defined in extension DLLs
	CDynLinkLibrary* pDLL;
	for (pDLL = pModuleState->m_libraryList; pDLL != NULL;
		pDLL = pDLL->m_pNextDLL)
	{
		for (COleObjectFactory* pDLLFactory = pDLL->m_factoryList;
			pDLLFactory != NULL; pDLLFactory = pDLLFactory->m_pNextFactory)
		{
			if (pDLLFactory->m_bRegistered != 0 &&
				lData1 == pDLLFactory->m_clsid.Data1 &&
				((DWORD*)&rclsid)[1] == ((DWORD*)&pDLLFactory->m_clsid)[1] &&
				((DWORD*)&rclsid)[2] == ((DWORD*)&pDLLFactory->m_clsid)[2] &&
				((DWORD*)&rclsid)[3] == ((DWORD*)&pDLLFactory->m_clsid)[3])
			{
				// found suitable class factory -- query for correct interface
				SCODE sc = pDLLFactory->InternalQueryInterface(&riid, ppv);
				AfxUnlockGlobals(CRIT_DYNLINKLIST);
				return sc;
			}
		}
	}
	AfxUnlockGlobals(CRIT_DYNLINKLIST);
#endif

	// factory not registered -- return error
	return CLASS_E_CLASSNOTAVAILABLE;
}

SCODE AFXAPI AfxDllCanUnloadNow(void)
{
	// return S_OK only if no outstanding objects active
	if (!AfxOleCanExitApp())
		return S_FALSE;

	// check if any class factories with >1 reference count
	AFX_MODULE_STATE* pModuleState = AfxGetModuleState();
	AfxLockGlobals(CRIT_OBJECTFACTORYLIST);
	COleObjectFactory* pFactory;
	for (pFactory = pModuleState->m_factoryList;
		pFactory != NULL; pFactory = pFactory->m_pNextFactory)
	{
		if (pFactory->m_dwRef > 1)
		{
			AfxUnlockGlobals(CRIT_OBJECTFACTORYLIST);
			return S_FALSE;
		}
	}
	AfxUnlockGlobals(CRIT_OBJECTFACTORYLIST);
#ifdef _AFXDLL
	AfxLockGlobals(CRIT_DYNLINKLIST);
	// search factories defined in extension DLLs
	for (CDynLinkLibrary* pDLL = pModuleState->m_libraryList; pDLL != NULL;
		pDLL = pDLL->m_pNextDLL)
	{
		for (COleObjectFactory* pDLLFactory = pDLL->m_factoryList;
			pDLLFactory != NULL; pDLLFactory = pDLLFactory->m_pNextFactory)
		{
			if (pDLLFactory->m_dwRef > 1)
			{
				AfxUnlockGlobals(CRIT_DYNLINKLIST);
				return S_FALSE;
			}
		}
	}
	AfxUnlockGlobals(CRIT_DYNLINKLIST);
#endif

	TRACE(traceOle, 0, "Info: AfxDllCanUnloadNow returning S_OK\n");
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\oledlgs1.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "sal.h"



#define new DEBUG_NEW


UINT CALLBACK
AfxOleHookProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);

////////////////////////////////////////////////////////////////////////////
// implementation helpers

BOOL AFXAPI _AfxOlePropertiesEnabled()
{
	// edit properties is enabled if there is a handler
	//  for ID_OLE_EDIT_PROPERTIES
	AFX_CMDHANDLERINFO info;

	// check main window first
	CWnd* pWnd = AfxGetMainWnd();
	if (pWnd != NULL && pWnd->OnCmdMsg(ID_OLE_EDIT_PROPERTIES, CN_COMMAND, NULL, &info))
		return TRUE;

	// check app last
	return AfxGetApp()->OnCmdMsg(ID_OLE_EDIT_PROPERTIES, CN_COMMAND, NULL, &info);
}

SCODE _AfxParseDisplayName(LPMONIKER lpmk, LPBC lpbc, _In_z_ LPTSTR lpszRemainder,
						   ULONG* cchEaten, LPMONIKER* plpmkOut)
{
	ASSERT(lpmk != NULL);
	ASSERT(AfxIsValidString(lpszRemainder));
	ASSERT(cchEaten != NULL);
	ASSERT(plpmkOut != NULL);

	SCODE sc;
	if (lpbc != NULL)
	{
		// ask moniker to parse the display name itself
		CStringW strRemainder(lpszRemainder);
		sc = lpmk->ParseDisplayName(lpbc, NULL, const_cast<LPOLESTR>(strRemainder.GetString()), 
			cchEaten, plpmkOut);
	}
	else
	{
		// skip leading delimiters
		int cEaten = 0;
		LPTSTR lpszSrc = lpszRemainder;
		while (*lpszSrc != '\0' && (*lpszSrc == '\\' || *lpszSrc == '/' ||
			*lpszSrc == ':' || *lpszSrc == '!' || *lpszSrc == '['))
		{
			if (_istlead(*lpszSrc))
				++lpszSrc, ++cEaten;
			++lpszSrc;
			++cEaten;
		}

		// parse next token in lpszRemainder
		TCHAR szItemName[_MAX_PATH];
		LPTSTR lpszDest = szItemName;
		while (*lpszSrc != '\0' && *lpszSrc != '\\' && *lpszSrc != '/' &&
			*lpszSrc != ':' && *lpszSrc != '!' && *lpszSrc != '[' &&
			cEaten < _MAX_PATH-1)
		{
			if (_istlead(*lpszSrc))
				*lpszDest++ = *lpszSrc++, ++cEaten;
			*lpszDest++ = *lpszSrc++;
			++cEaten;
		}
		*cchEaten = cEaten;
		CStringW strItemName(szItemName);
		sc = CreateItemMoniker(OLESTDDELIMOLE, strItemName.GetString(), plpmkOut);
	}

	return sc;
}

////////////////////////////////////////////////////////////////////////////
// COleUILinkInfo

COleUILinkInfo::COleUILinkInfo(COleDocument* pDocument)
{
	ASSERT(pDocument == NULL ||
		pDocument->IsKindOf(RUNTIME_CLASS(COleDocument)));
	m_pDocument = pDocument;
	m_pItem = NULL;
	m_pSelectedItem = NULL;
	m_pos = NULL;
	m_bUpdateLinks = FALSE;
	m_bUpdateEmbeddings = FALSE;
}

COleUILinkInfo::COleUILinkInfo(COleClientItem *pItem)
{
	m_pDocument = NULL;
	m_pItem = pItem;
	m_pSelectedItem = NULL;
	m_pos = NULL;
	m_bUpdateLinks = FALSE;
	m_bUpdateEmbeddings = FALSE;
}

STDMETHODIMP_(ULONG) COleUILinkInfo::AddRef()
{
	return 0;
}

STDMETHODIMP_(ULONG) COleUILinkInfo::Release()
{
	return 0;
}

STDMETHODIMP COleUILinkInfo::QueryInterface(
	REFIID, LPVOID*)
{
	return E_NOTIMPL;
}

STDMETHODIMP_(DWORD) COleUILinkInfo::GetNextLink(
	DWORD dwLink)
{
	ASSERT(m_pDocument != NULL);

	if (m_pDocument != NULL)
	{
		POSITION posItem = m_pDocument->GetStartPosition();
		COleClientItem* pItem;
		// Skip to first item after dwLink
		for( ULONG iSkipLink = 0; iSkipLink < dwLink; ++iSkipLink )
		{
			pItem = m_pDocument->GetNextClientItem(posItem);
		}

		ULONG iLink = dwLink+1;
		while (posItem != NULL)
		{
			pItem = m_pDocument->GetNextClientItem(posItem);
			if (NULL == pItem)
			{
				break; //m_DocItemList may contain COleServerItem(s) and not COleClientItem(s)
			}
			OLE_OBJTYPE objType = pItem->GetType();
			if ((m_bUpdateLinks && objType == OT_LINK) || (m_bUpdateEmbeddings && objType == OT_EMBEDDED))
			{
				return iLink;
			}
			iLink++;
		}
	}

	// End of list
	return 0;
}

COleClientItem* COleUILinkInfo::GetLinkItem( DWORD dwLink )
{
	COleClientItem* pItem = NULL;

	if (m_pDocument != NULL)
	{
		POSITION posItem = m_pDocument->GetStartPosition();
		for (ULONG iLink = 0; iLink < dwLink; ++iLink)
		{
			pItem = m_pDocument->GetNextClientItem(posItem);
		}
	}
	else
	{
		pItem = m_pItem;
	}

	return pItem;
}

STDMETHODIMP COleUILinkInfo::SetLinkUpdateOptions(
	DWORD dwLink, DWORD dwUpdateOpt)
{
	SCODE sc;
	TRY
	{
		COleClientItem* pItem = GetLinkItem(dwLink);;
		ENSURE_VALID(pItem);
		ASSERT_KINDOF(COleClientItem, pItem);
		ASSERT(pItem->GetType() == OT_LINK);

		// item is a link -- get its link options
		pItem->SetLinkUpdateOptions((OLEUPDATE)dwUpdateOpt);
		sc = S_OK;
	}
	CATCH_ALL(e)
	{
		sc = COleException::Process(e);
		DELETE_EXCEPTION(e);
	}
	END_CATCH_ALL

	return sc;
}

STDMETHODIMP COleUILinkInfo::GetLinkUpdateOptions(
	DWORD dwLink, DWORD* lpdwUpdateOpt)
{
	SCODE sc;
	TRY
	{
		COleClientItem* pItem = GetLinkItem(dwLink);
		ENSURE_VALID(pItem);
		ASSERT_KINDOF(COleClientItem, pItem);

		if (pItem->GetType() == OT_LINK)
			*lpdwUpdateOpt = pItem->GetLinkUpdateOptions();
		else
			*lpdwUpdateOpt = OLEUPDATE_ALWAYS;  // make believe it is auto-link
		sc = S_OK;
	}
	CATCH_ALL(e)
	{
		sc = COleException::Process(e);
		DELETE_EXCEPTION(e);
	}
	END_CATCH_ALL

	return sc;
}

STDMETHODIMP COleUILinkInfo::SetLinkSource(
	DWORD dwLink, LPTSTR lpszDisplayName, ULONG lenFileName,
	ULONG* pchEaten, BOOL  fValidateSource)
{
	if (lenFileName >= _MAX_PATH)
		return E_INVALIDARG;

	COleClientItem* pItem = GetLinkItem(dwLink);
	ASSERT_VALID(pItem);
	ASSERT_KINDOF(COleClientItem, pItem);
	ASSERT(pItem->GetType() == OT_LINK);

	LPOLEOBJECT lpObject = NULL;
	CLSID clsid;

	// parse the portion known to be a file name into a file moniker
	TCHAR szName[_MAX_PATH];

	if(lenFileName > _MAX_PATH - 1)
		return E_INVALIDARG;

	Checked::tcsncpy_s(szName, _countof(szName), lpszDisplayName, _TRUNCATE);
	LPMONIKER lpmk = NULL;
	CStringW strName(szName);
	SCODE sc = CreateFileMoniker(strName.GetString(), &lpmk);
	if (lpmk == NULL)
		return sc;

	LPBC lpbc = NULL;
	if (fValidateSource)
	{
		sc = CreateBindCtx(0, &lpbc);
		if (sc != S_OK)
		{
			lpmk->Release();
			return sc;
		}
	}

	// nUneaten is the number of chars left to parse
	UINT nUneaten = lstrlen(lpszDisplayName) - lenFileName;

	// lpszRemainder is the left over display name
	LPTSTR lpszRemainder = lpszDisplayName + lenFileName;
	*pchEaten = lenFileName;

	// parse the rest of the display name
	while (nUneaten > 0)
	{
		// attempt to parse next moniker
		ULONG nEaten = 0;
		LPMONIKER lpmkNext = NULL;
		sc = _AfxParseDisplayName(lpmk, lpbc, lpszRemainder, &nEaten, &lpmkNext);
		if (sc != S_OK)
		{
			lpmk->Release();
			lpbc->Release();
			return sc;
		}

		// advance through the display name
		nUneaten -= nEaten;
		*pchEaten += nEaten;
		lpszRemainder += nEaten;

		if (lpmkNext != NULL)
		{
			// create composite out of current and next
			LPMONIKER lpmkTemp = NULL;
			sc = CreateGenericComposite(lpmk, lpmkNext, &lpmkTemp);
			if (FAILED(sc))
			{
				lpmk->Release();
				lpmkNext->Release();
				lpbc->Release();
				return sc;
			}

			// make current = next
			lpmkNext->Release();
			lpmk->Release();
			lpmk = lpmkTemp;
		}
	}

	if (fValidateSource)
	{
		// attempt to bind the the object
		sc = lpmk->BindToObject(lpbc, NULL, IID_IOleObject, (LPLP)&lpObject);
		if (FAILED(sc))
		{
			pItem->m_bLinkUnavail = TRUE;
			lpbc->Release();
			lpmk->Release();
			RELEASE(lpObject);
			return sc;
		}
		ASSERT(lpObject != NULL);

		// call GetUserClassID while bound so default handler updates
		lpObject->GetUserClassID(&clsid);
		pItem->m_bLinkUnavail = FALSE;
	}

	// get IOleLink interface
	LPOLELINK lpOleLink = QUERYINTERFACE(pItem->m_lpObject, IOleLink);
	ASSERT(lpOleLink != NULL);

	// set source from moniker
	sc = lpOleLink->SetSourceMoniker(lpmk, clsid);

	// update the cache if object was successfully bound
	if (lpObject != NULL)
	{
		lpObject->Update();
		lpObject->Release();
	}

	// cleanup
	lpOleLink->Release();
	RELEASE(lpmk);
	RELEASE(lpbc);

	return sc;
}

STDMETHODIMP COleUILinkInfo::GetLinkSource(
	DWORD dwLink, _Deref_out_ LPTSTR* lplpszDisplayName, ULONG* lplenFileName,
	_Deref_out_ LPTSTR* lplpszFullLinkType, _Deref_out_ LPTSTR* lplpszShortLinkType,
	BOOL* lpfSourceAvailable, BOOL* lpfIsSelected)
{
	SCODE sc=S_OK;
	TRY
	{
		COleClientItem* pItem = GetLinkItem(dwLink);
		ENSURE_VALID(pItem);
		ASSERT_KINDOF(COleClientItem, pItem);
		ASSERT(pItem->GetType() == OT_LINK);

		// set OUT params to NULL
		ASSERT(lplpszDisplayName != NULL);
		*lplpszDisplayName  = NULL;
		if (lplpszFullLinkType != NULL)
			*lplpszFullLinkType = NULL;
		if (lplpszShortLinkType != NULL)
			*lplpszShortLinkType = NULL;
		if (lplenFileName != NULL)
			*lplenFileName = 0;
		if (lpfSourceAvailable != NULL)
			*lpfSourceAvailable = !pItem->m_bLinkUnavail;

		// get IOleLink interface
		LPOLELINK lpOleLink = QUERYINTERFACE(pItem->m_lpObject, IOleLink);
		ASSERT(lpOleLink != NULL);

		// get moniker & object information
		LPMONIKER lpmk;
		if (lpOleLink->GetSourceMoniker(&lpmk) == S_OK)
		{
			if (lplenFileName != NULL)
				*lplenFileName = _AfxOleGetLenFilePrefixOfMoniker(lpmk);
			lpmk->Release();
		}


		// attempt to get the type names of the link
		if (lplpszFullLinkType != NULL)
		{
			LPOLESTR lpOleStr = NULL;
			pItem->m_lpObject->GetUserType(USERCLASSTYPE_FULL, &lpOleStr);
			*lplpszFullLinkType = TASKSTRINGOLE2T(lpOleStr);
			if (*lplpszFullLinkType == NULL)
			{
				TCHAR szUnknown[256];
				VERIFY(AfxLoadString(AFX_IDS_UNKNOWNTYPE, szUnknown, _countof(szUnknown)) != 0);
				*lplpszFullLinkType = AtlAllocTaskString(szUnknown);
			}
		}
		if (lplpszShortLinkType != NULL)
		{
			LPOLESTR lpOleStr = NULL;
			pItem->m_lpObject->GetUserType(USERCLASSTYPE_SHORT, &lpOleStr);
			*lplpszShortLinkType = TASKSTRINGOLE2T(lpOleStr);
			if (*lplpszShortLinkType == NULL)
			{
				TCHAR szUnknown[256];
				VERIFY(AfxLoadString(AFX_IDS_UNKNOWNTYPE, szUnknown, _countof(szUnknown)) != 0);
				*lplpszShortLinkType = AtlAllocTaskString(szUnknown);
			}
		}

		// get source display name for moniker
		LPOLESTR lpOleStr = NULL;
		SCODE sc = lpOleLink->GetSourceDisplayName(&lpOleStr);
		*lplpszDisplayName = TASKSTRINGOLE2T(lpOleStr);
		lpOleLink->Release();
		if (sc != S_OK)
			return sc;

		// see if item is selected if specified
		if (lpfIsSelected)
		{
			*lpfIsSelected = (m_pSelectedItem == pItem);
		}
	}
	CATCH_ALL(e)
	{
		sc = COleException::Process(e);
		DELETE_EXCEPTION(e);
	}
	END_CATCH_ALL

	return sc;
}

STDMETHODIMP COleUILinkInfo::OpenLinkSource(DWORD dwLink)
{
	SCODE sc;
	TRY
	{
		COleClientItem* pItem = GetLinkItem(dwLink);
		ENSURE_VALID(pItem);
		ASSERT_KINDOF(COleClientItem, pItem);
		ASSERT(pItem->GetType() == OT_LINK);

		// Note: no need for valid CView* since links don't activate inplace
		pItem->DoVerb(OLEIVERB_SHOW, NULL);
		sc = S_OK;
	}
	CATCH_ALL(e)
	{
		sc = COleException::Process(e);
		DELETE_EXCEPTION(e);
	}
	END_CATCH_ALL

	return sc;
}

STDMETHODIMP COleUILinkInfo::UpdateLink(
										DWORD dwLink, BOOL /*fErrorMessage*/, BOOL /*fErrorAction*/)
{
	COleClientItem* pItem=NULL;
	SCODE sc=E_FAIL;
	TRY
	{
		pItem = GetLinkItem(dwLink);
		ENSURE_VALID(pItem);
		ASSERT_KINDOF(COleClientItem, pItem);

		// link not up-to-date, attempt to update it
		if (!pItem->UpdateLink())
			AfxThrowOleException(pItem->GetLastStatus());
		pItem->m_bLinkUnavail = FALSE;
		sc = S_OK;
	}
	CATCH_ALL(e)
	{
		if(pItem)
		{
			pItem->m_bLinkUnavail = TRUE;
		}

		sc = COleException::Process(e);
		if(pItem)
		{
			pItem->ReportError(sc);
		}
		DELETE_EXCEPTION(e);
	}
	END_CATCH_ALL

	return sc;
}

STDMETHODIMP COleUILinkInfo::CancelLink(DWORD dwLink)
{
	COleClientItem* pItem = GetLinkItem(dwLink);
	ASSERT_VALID(pItem);
	ASSERT_KINDOF(COleClientItem, pItem);
	ASSERT(pItem->GetType() == OT_LINK);

	SCODE sc = E_FAIL;
	TRY
	{
		if (pItem->FreezeLink())
			sc = S_OK;
	}
	CATCH_ALL(e)
	{
		sc = COleException::Process(e);
		DELETE_EXCEPTION(e);
	}
	END_CATCH_ALL

	// report error
	if (sc != S_OK)
		pItem->ReportError(sc);

	return S_OK;
}

STDMETHODIMP COleUILinkInfo::GetLastUpdate(DWORD dwLink, FILETIME*)
{
	COleClientItem* pItem = GetLinkItem(dwLink);
	ASSERT_VALID(pItem);

	// Note: leave last update time at unknown!

	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
// InsertObject dialog wrapper

COleInsertDialog::COleInsertDialog(DWORD dwFlags, CWnd* pParentWnd)
: COleDialog(pParentWnd)
{
	memset(&m_io, 0, sizeof(m_io)); // initialize structure to 0/NULL

	// fill in common part
	m_io.cbStruct = sizeof(m_io);
	m_io.dwFlags = dwFlags;
	if (_AfxOlePropertiesEnabled())
		m_io.dwFlags |= IOF_HIDECHANGEICON;
	m_io.lpfnHook = AfxOleHookProc;
	m_nIDHelp = AFX_IDD_INSERTOBJECT;

	// specific to this dialog
	m_io.lpszFile = m_szFileName;
	m_io.cchFile = _countof(m_szFileName);
	m_szFileName[0] = '\0';
}

COleInsertDialog::~COleInsertDialog()
{
	_AfxDeleteMetafilePict(m_io.hMetaPict);
}

void COleInsertDialog::AddClassIDToList(LPCLSID& lpList,
										int& nListCount, int& nBufferLen, LPCLSID lpNewID)
{
	// if the list doesn't exist, create it

	if (lpList == NULL)
	{
		nListCount = 0;
		nBufferLen = 16;
		lpList = new CLSID[nBufferLen];
	}

	// if the list isn't big enough grow it by twice

	if (nListCount == nBufferLen)
	{
		LPCLSID lpOldList = lpList;
		nBufferLen <<= 2;
		lpList = new CLSID[nBufferLen];
		Checked::memcpy_s(lpList, nBufferLen * sizeof(CLSID), 
			lpOldList, sizeof(CLSID) * nListCount);
		delete [] lpOldList;
	}

	lpList[nListCount] = *lpNewID;
	nListCount++;

	return;
}

INT_PTR COleInsertDialog::DoModal(DWORD dwFlags)
{
	LPCLSID lpNewExcludeList = NULL;
	int nNewExcludeCount = 0;
	int nNewExcludeLen = 0;

	// support for controls is built-in
	// support doc objects by filtering what the dialog shows

	if (dwFlags == ControlsOnly)
		m_io.dwFlags |= IOF_SELECTCREATECONTROL | IOF_SHOWINSERTCONTROL;
	else if (dwFlags == DocObjectsOnly)
	{
		m_io.dwFlags |= IOF_DISABLEDISPLAYASICON | IOF_DISABLELINK;

		HKEY hkClassesRoot;
		HKEY hkCLSID;
		HKEY hkItem;
		HKEY hkDocObject;
		DWORD dwIndex = 0;
		TCHAR szName[MAX_PATH+1];

		if (RegOpenKeyExW(HKEY_CLASSES_ROOT, NULL, 0, KEY_READ,
			&hkClassesRoot) == ERROR_SUCCESS)
		{
			if(RegOpenKeyExW(hkClassesRoot, L"CLSID", 0,
				KEY_ENUMERATE_SUB_KEYS, &hkCLSID) == ERROR_SUCCESS)
			{
				while(RegEnumKey(hkCLSID, dwIndex++,
					szName, sizeof(szName)/sizeof(TCHAR)) == ERROR_SUCCESS)
				{
					if (RegOpenKeyEx(hkCLSID, szName, 0,
						KEY_READ, &hkItem) == ERROR_SUCCESS)
					{
						if ((RegOpenKeyExW(hkItem, L"Insertable", 0,
							KEY_READ, &hkDocObject) == ERROR_SUCCESS) ||
							(RegOpenKeyExW(hkItem, L"Ole1Class",0,
							KEY_READ, &hkDocObject) == ERROR_SUCCESS))
						{
							RegCloseKey(hkDocObject);
							if ((RegOpenKeyExW(hkItem, L"DocObject", 0,
								KEY_READ, &hkDocObject) != ERROR_SUCCESS ) )
							{
								CLSID clsid;
								CStringW ws(szName);
								CLSIDFromString((LPOLESTR)ws.GetString(), &clsid);
								AddClassIDToList(lpNewExcludeList,
									nNewExcludeCount, nNewExcludeLen, &clsid);
								RegCloseKey(hkItem);
							}
							RegCloseKey(hkDocObject);
						}
					}
				}
				RegCloseKey(hkCLSID);
			}
			RegCloseKey(hkClassesRoot);
		}
	}

	UINT cOldClsidExclude = m_io.cClsidExclude;
	LPCLSID lpOldClsidExclude = m_io.lpClsidExclude;

	if (lpNewExcludeList != NULL)
	{
		m_io.lpClsidExclude = lpNewExcludeList;
		m_io.cClsidExclude = nNewExcludeCount;
	}

QueryAgain:
	INT_PTR nDisposition = DoModal();

	if (nDisposition == IDOK && GetSelectionType() == insertFromFile &&
		dwFlags == DocObjectsOnly)
	{
		// Double-check that the requested file really is serviced by a
		// DocObject server.

		CLSID clsidFile;
		BOOL bIsDocObject = FALSE;
		CStringW strFile(m_io.lpszFile);
		if (GetClassFile(strFile.GetString(), &clsidFile) == S_OK)
		{
			CString strKey;
			CString strCLSID = AfxStringFromCLSID(clsidFile);
			strKey.Format(_T("CLSID\\%s\\DocObject"), strCLSID);

			HKEY hKey;
			if (ERROR_SUCCESS ==
				RegOpenKeyEx(HKEY_CLASSES_ROOT, strKey, 0, KEY_QUERY_VALUE, &hKey))
			{
				RegCloseKey(hKey);
				bIsDocObject = TRUE;
			}
		}

		if (!bIsDocObject)
		{
			nDisposition =
				AfxMessageBox(AFX_IDS_NOT_DOCOBJECT, MB_RETRYCANCEL | MB_ICONHAND);
			if (nDisposition == IDRETRY)
				goto QueryAgain;
			else
				nDisposition = IDCANCEL;
		}
	}

	delete [] lpNewExcludeList;

	m_io.cClsidExclude = cOldClsidExclude;
	m_io.lpClsidExclude = lpOldClsidExclude;

	return nDisposition;
}

INT_PTR COleInsertDialog::DoModal()
{
	ASSERT_VALID(this);
	ASSERT(m_io.lpfnHook != NULL);  // can still be a user hook

	m_io.hWndOwner = PreModal();
	INT_PTR iResult = MapResult(::OleUIInsertObject(&m_io));
	PostModal();
	return iResult;
}

UINT COleInsertDialog::GetSelectionType() const
{
	ASSERT_VALID(this);

	if (m_io.dwFlags & IOF_SELECTCREATEFROMFILE)
	{
		if (m_io.dwFlags & IOF_CHECKLINK)
			return linkToFile;
		else
			return insertFromFile;
	}
	ASSERT(m_io.dwFlags & IOF_SELECTCREATENEW);
	return createNewItem;
}

// allocate an item first, then call this fuction to create it
BOOL COleInsertDialog::CreateItem(COleClientItem* pNewItem)
{
	ASSERT_VALID(pNewItem);

	// switch on selection type
	UINT selType = GetSelectionType();
	BOOL bResult;

	switch (selType)
	{
	case linkToFile:
		// link to file selected
		ASSERT(m_szFileName[0] != 0);
		bResult = pNewItem->CreateLinkFromFile(m_szFileName);
		break;
	case insertFromFile:
		// insert file selected
		ASSERT(m_szFileName[0] != 0);
		bResult = pNewItem->CreateFromFile(m_szFileName);
		break;
	default:
		// otherwise must be create new
		ASSERT(selType == createNewItem);
		bResult = pNewItem->CreateNewItem(m_io.clsid);
		break;
	}

	// deal with Display As Iconic option
	if (bResult && GetDrawAspect() == DVASPECT_ICON)
	{
		// setup iconic cache (it will draw iconic by default as well)
		if (!pNewItem->SetIconicMetafile(m_io.hMetaPict))
		{
			TRACE(traceOle, 0, "Warning: failed to set iconic aspect in CreateItem.\n");
			return TRUE;
		}

		// since picture was set OK, draw as iconic as well...
		pNewItem->SetDrawAspect(DVASPECT_ICON);
	}
	return bResult;
}

/////////////////////////////////////////////////////////////////////////////
// COleInsertDialog diagnostics

#ifdef _DEBUG
void COleInsertDialog::Dump(CDumpContext& dc) const
{
	COleDialog::Dump(dc);

	dc << "m_szFileName = " << m_szFileName;
	dc << "\nm_io.cbStruct = " << m_io.cbStruct;
	dc << "\nm_io.dwFlags = ";
	dc.DumpAsHex( m_io.dwFlags );
	dc << "\nm_io.hWndOwner = " << m_io.hWndOwner;
	dc << "\nm_io.lpszCaption = " << m_io.lpszCaption;
	dc << "\nm_io.lCustData = " << (LPVOID)m_io.lCustData;
	dc << "\nm_io.hInstance = " << m_io.hInstance;
	dc << "\nm_io.lpszTemplate = " << (LPVOID)m_io.lpszTemplate;
	dc << "\nm_io.hResource = " << m_io.hResource;
	if (m_io.lpfnHook == AfxOleHookProc)
		dc << "\nhook function set to standard MFC hook function";
	else
		dc << "\nhook function set to non-standard hook function";
	dc << "\nm_io.hMetaPict = " << m_io.hMetaPict;

	dc << "\n";
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// COleConvertDialog

COleConvertDialog::COleConvertDialog(COleClientItem* pItem, DWORD dwFlags,
									 CLSID* pClassID, CWnd* pParentWnd) : COleDialog(pParentWnd)
{
	if (pItem != NULL)
		ASSERT_VALID(pItem);
	ASSERT(pClassID == NULL || AfxIsValidAddress(pClassID, sizeof(CLSID), FALSE));

	memset(&m_cv, 0, sizeof(m_cv)); // initialize structure to 0/NULL
	if (pClassID != NULL)
		m_cv.clsid = *pClassID;

	// fill in common part
	m_cv.cbStruct = sizeof(m_cv);
	m_cv.dwFlags = dwFlags;
	m_cv.lpfnHook = AfxOleHookProc;
	m_nIDHelp = AFX_IDD_CONVERT;

	// specific to this dialog
	m_cv.fIsLinkedObject = pItem->GetType() == OT_LINK;
	m_cv.dvAspect = pItem->GetDrawAspect();
	if (pClassID == NULL && !m_cv.fIsLinkedObject)
	{
		// for embeddings, attempt to get class ID from the storage
		if (ReadClassStg(pItem->m_lpStorage, &m_cv.clsid) == S_OK)
			pClassID = &m_cv.clsid;

		// attempt to get user type from storage
		CLIPFORMAT cf = 0;
		LPOLESTR lpOleStr = NULL;
		ReadFmtUserTypeStg(pItem->m_lpStorage, &cf, &lpOleStr);
		m_cv.lpszUserType = TASKSTRINGOLE2T(lpOleStr);

		m_cv.wFormat = (WORD)cf;
	}
	// get class id if neded
	if (pClassID == NULL)
	{
		// no class ID in the storage, use class ID of the object
		pItem->GetClassID(&m_cv.clsid);
	}

	// get user type if needed
	if (m_cv.lpszUserType == NULL)
	{
		// no user type in storge, get user type from class ID
		LPTSTR lpszUserType = NULL;
		LPOLESTR lpOleStr = NULL;
		if (OleRegGetUserType(m_cv.clsid, USERCLASSTYPE_FULL,
			&lpOleStr) == S_OK)
		{
			lpszUserType = TASKSTRINGOLE2T(lpOleStr);
		}
		else
		{
			const int nStrSize = 256;
			lpszUserType = (LPTSTR)::ATL::AtlCoTaskMemCAlloc(nStrSize, sizeof(TCHAR));
			if (lpszUserType != NULL)
			{
				lpszUserType[0] = '?';
				lpszUserType[1] = 0;
				VERIFY(AfxLoadString(AFX_IDS_UNKNOWNTYPE, lpszUserType, nStrSize) != 0);
			}
		}
		m_cv.lpszUserType = lpszUserType;
	}
	m_cv.hMetaPict = pItem->GetIconicMetafile();
}

COleConvertDialog::~COleConvertDialog()
{
	_AfxDeleteMetafilePict(m_cv.hMetaPict);
}

INT_PTR COleConvertDialog::DoModal()
{
	ASSERT_VALID(this);
	ASSERT(m_cv.lpfnHook != NULL);  // can still be a user hook

	m_cv.hWndOwner = PreModal();
	INT_PTR iResult = MapResult(::OleUIConvert(&m_cv));
	PostModal();
	return iResult;
}

BOOL COleConvertDialog::DoConvert(COleClientItem* pItem)
{
	ASSERT_VALID(pItem);

	CWaitCursor wait;

	UINT selType = GetSelectionType();
	BOOL bResult = TRUE;

	if (m_cv.clsidNew != CLSID_NULL)
	{
		switch (selType)
		{
		case convertItem:
			bResult = pItem->ConvertTo(m_cv.clsidNew);
			break;
		case activateAs:
			bResult = pItem->ActivateAs(m_cv.lpszUserType, m_cv.clsid,
				m_cv.clsidNew);
			break;
		default:
			ASSERT(selType == noConversion);
			break;
		}
	}

	if (!bResult)
	{
		// if unable to convert the object show message box
		AfxMessageBox(AFX_IDP_FAILED_TO_CONVERT);
		return FALSE;
	}

	// change to iconic/content view if changed
	if ((DVASPECT)m_cv.dvAspect != pItem->GetDrawAspect())
	{
		pItem->OnChange(OLE_CHANGED_ASPECT, (DWORD)m_cv.dvAspect);
		pItem->SetDrawAspect((DVASPECT)m_cv.dvAspect);
	}

	// change the actual icon as well
	if (m_cv.fObjectsIconChanged)
	{
		pItem->SetIconicMetafile(m_cv.hMetaPict);
		if (pItem->GetDrawAspect() == DVASPECT_ICON)
			pItem->OnChange(OLE_CHANGED, (DWORD)DVASPECT_ICON);
	}

	return TRUE;
}

UINT COleConvertDialog::GetSelectionType() const
{
	ASSERT_VALID(this);

	if (m_cv.clsid != m_cv.clsidNew)
	{
		if (m_cv.dwFlags & CF_SELECTCONVERTTO)
			return convertItem;
		else if (m_cv.dwFlags & CF_SELECTACTIVATEAS)
			return activateAs;
	}
	return noConversion;
}

/////////////////////////////////////////////////////////////////////////////
// COleConvertDialog diagnostics

#ifdef _DEBUG
void COleConvertDialog::Dump(CDumpContext& dc) const
{
	COleDialog::Dump(dc);

	dc << "m_cv.cbStruct = " << m_cv.cbStruct;
	dc << "\nm_cv.dwFlags = ";
	dc.DumpAsHex(m_cv.dwFlags);
	dc << "\nm_cv.hWndOwner = " << m_cv.hWndOwner;
	dc << "\nm_cv.lpszCaption = " << m_cv.lpszCaption;
	dc << "\nm_cv.lCustData = " << (LPVOID)m_cv.lCustData;
	dc << "\nm_cv.hInstance = " << m_cv.hInstance;
	dc << "\nm_cv.lpszTemplate = " << (LPVOID)m_cv.lpszTemplate;
	dc << "\nm_cv.hResource = " << m_cv.hResource;
	if (m_cv.lpfnHook == AfxOleHookProc)
		dc << "\nhook function set to standard MFC hook function";
	else
		dc << "\nhook function set to non-standard hook function";
	dc << "\nm_cv.dvAspect = " << (UINT)m_cv.dvAspect;
	dc << "\nm_cv.wFormat = " << (UINT)m_cv.wFormat;
	dc << "\nm_cv.fIsLinkedObject = " << m_cv.fIsLinkedObject;
	dc << "\nm_cv.hMetaPict = " << m_cv.hMetaPict;
	dc << "\nm_cv.lpszUserType = " << m_cv.lpszUserType;
	dc << "\nm_cv.fObjectsIconChanged = " << m_cv.fObjectsIconChanged;

	dc << "\n";
}
#endif

/////////////////////////////////////////////////////////////////////////////
// COleChangeIconDialog

COleChangeIconDialog::COleChangeIconDialog(COleClientItem* pItem,
										   DWORD dwFlags, CWnd* pParentWnd) : COleDialog(pParentWnd)
{
	if (pItem != NULL)
		ASSERT_VALID(pItem);

	memset(&m_ci, 0, sizeof(m_ci)); // initialize structure to 0/NULL

	// fill in common part
	m_ci.cbStruct = sizeof(m_ci);
	m_ci.dwFlags = dwFlags;
	m_ci.lpfnHook = AfxOleHookProc;
	m_nIDHelp = AFX_IDD_CHANGEICON;

	// specific to this dialog
	if (pItem != NULL)
	{
		pItem->GetClassID(&m_ci.clsid);
		m_ci.hMetaPict = pItem->GetIconicMetafile();
	}
}

COleChangeIconDialog::~COleChangeIconDialog()
{
	_AfxDeleteMetafilePict(m_ci.hMetaPict);
}

INT_PTR COleChangeIconDialog::DoModal()
{
	ASSERT_VALID(this);
	ASSERT(m_ci.lpfnHook != NULL);  // can still be a user hook

	m_ci.hWndOwner = PreModal();
	INT_PTR iResult = MapResult(::OleUIChangeIcon(&m_ci));
	PostModal();
	return iResult;
}

BOOL COleChangeIconDialog::DoChangeIcon(COleClientItem* pItem)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pItem);

	// set the picture
	if (!pItem->SetIconicMetafile(GetIconicMetafile()))
		return FALSE;

	// notify the item of the change if the current draw aspect is ICON
	if (pItem->GetDrawAspect() == DVASPECT_ICON)
		pItem->OnChange(OLE_CHANGED, (DWORD)DVASPECT_ICON);

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// COleChangeIconDialog diagnostics

#ifdef _DEBUG
void COleChangeIconDialog::Dump(CDumpContext& dc) const
{
	COleDialog::Dump(dc);

	dc << "m_ci.cbStruct = " << m_ci.cbStruct;
	dc << "\nm_ci.dwFlags = ";
	dc.DumpAsHex(m_ci.dwFlags);
	dc << "\nm_ci.hWndOwner = " << m_ci.hWndOwner;
	dc << "\nm_ci.lpszCaption = " << m_ci.lpszCaption;
	dc << "\nm_ci.lCustData = " << (LPVOID)m_ci.lCustData;
	dc << "\nm_ci.hInstance = " << m_ci.hInstance;
	dc << "\nm_ci.lpszTemplate = " << (LPVOID)m_ci.lpszTemplate;
	dc << "\nm_ci.hResource = " << m_ci.hResource;
	if (m_ci.lpfnHook == AfxOleHookProc)
		dc << "\nhook function set to standard MFC hook function";
	else
		dc << "\nhook function set to non-standard hook function";
	dc << "\nm_ci.hMetaPict = " << m_ci.hMetaPict;

	dc << "\n";
}
#endif

/////////////////////////////////////////////////////////////////////////////
// COleLinksDialog

COleLinksDialog::COleLinksDialog(COleDocument* pDoc, CView* pView,
								 DWORD dwFlags, CWnd* pParentWnd) : COleDialog(pParentWnd),
								 m_xLinkInfo(pDoc)
{
	ASSERT_VALID(pDoc);
	if (pView != NULL)
		ASSERT_VALID(pView);

	memset(&m_el, 0, sizeof(m_el)); // initialize structure to 0/NULL

	// fill in common part
	m_el.cbStruct = sizeof(m_el);
	m_el.dwFlags = dwFlags;
	m_el.lpfnHook = AfxOleHookProc;
	m_nIDHelp = AFX_IDD_EDITLINKS;

	// specific to this dialog
	if (pView != NULL)
		m_xLinkInfo.m_pSelectedItem = pDoc->GetPrimarySelectedItem(pView);
	else
		m_xLinkInfo.m_pSelectedItem = NULL;
	m_el.lpOleUILinkContainer = &m_xLinkInfo;
}

COleLinksDialog::~COleLinksDialog()
{
}

INT_PTR COleLinksDialog::DoModal()
{
	ASSERT_VALID(this);
	ASSERT(m_el.lpfnHook != NULL);  // can still be a user hook

	// this function is always used for updating links
	m_xLinkInfo.m_bUpdateLinks = TRUE;

	m_el.hWndOwner = PreModal();
	INT_PTR iResult = MapResult(::OleUIEditLinks(&m_el));
	PostModal();
	return iResult;
}

/////////////////////////////////////////////////////////////////////////////
// COleLinksDialog diagnostics

#ifdef _DEBUG
void COleLinksDialog::Dump(CDumpContext& dc) const
{
	COleDialog::Dump(dc);

	dc << "\nm_el.cbStruct = " << m_el.cbStruct;
	dc << "\nm_el.dwFlags = ";
	dc.DumpAsHex(m_el.dwFlags);
	dc << "\nm_el.hWndOwner = " << m_el.hWndOwner;
	dc << "\nm_el.lpszCaption = " << m_el.lpszCaption;
	dc << "\nm_el.lCustData = " << (void*)m_el.lCustData;
	dc << "\nm_el.hInstance = " << m_el.hInstance;
	dc << "\nm_el.lpszTemplate = " << (void*)m_el.lpszTemplate;
	dc << "\nm_el.hResource = " << m_el.hResource;
	if (m_el.lpfnHook == AfxOleHookProc)
		dc << "\nhook function set to standard MFC hook function";
	else
		dc << "\nhook function set to non-standard hook function";

	dc << "\n";
}

void COleLinksDialog::AssertValid() const
{
	COleDialog::AssertValid();
}
#endif

/////////////////////////////////////////////////////////////////////////////
// COleUpdateDialog

COleUpdateDialog::COleUpdateDialog(COleDocument* pDoc,
								   BOOL bUpdateLinks, BOOL bUpdateEmbeddings, CWnd* pParentWnd)
								   : COleLinksDialog(pDoc, NULL, 0, pParentWnd)
{
	ASSERT_VALID(pDoc);
	ASSERT(bUpdateLinks || bUpdateEmbeddings);

	// non-base class parameters
	m_xLinkInfo.m_bUpdateLinks = bUpdateLinks;
	m_xLinkInfo.m_bUpdateEmbeddings = bUpdateEmbeddings;
	m_strCaption.LoadString(AFX_IDS_UPDATING_ITEMS);
}

COleUpdateDialog::~COleUpdateDialog()
{
}

INT_PTR COleUpdateDialog::DoModal()
{
	ASSERT_VALID(this);

	// first count number of links/embeddings to be updated
	DWORD dwLink = 0;
	int cLinks = 0;
	while ((dwLink = m_el.lpOleUILinkContainer->GetNextLink(dwLink)) != 0)
		++cLinks;
	// when no links are out-of-date, don't bother
	if (cLinks == 0)
		return IDCANCEL;

	// bring up the dialog that processes all the links
	HWND hWndParent = PreModal();
	BOOL bResult = OleUIUpdateLinks(m_el.lpOleUILinkContainer,
		hWndParent, (LPTSTR)(LPCTSTR)m_strCaption, cLinks);
	PostModal();
	return bResult ? IDOK : -1;
}

/////////////////////////////////////////////////////////////////////////////
// COleUpdateDialog diagnostics

#ifdef _DEBUG
void COleUpdateDialog::Dump(CDumpContext& dc) const
{
	COleLinksDialog::Dump(dc);

	dc << "m_strCaption = " << m_strCaption;
	dc << "\n";
}
#endif

/////////////////////////////////////////////////////////////////////////////
// COlePasteSpecialDialog

COlePasteSpecialDialog::COlePasteSpecialDialog(DWORD dwFlags,
											   COleDataObject* pDataObject, CWnd* pParentWnd) : COleDialog(pParentWnd)
{
	memset(&m_ps, 0, sizeof(m_ps)); // initialize structure to 0/NULL

	// fill in common part
	m_ps.cbStruct = sizeof(m_ps);
	m_ps.dwFlags = dwFlags | PSF_STAYONCLIPBOARDCHANGE;
	if (_AfxOlePropertiesEnabled())
		m_ps.dwFlags |= PSF_HIDECHANGEICON;
	m_ps.lpfnHook = AfxOleHookProc;
	m_nIDHelp = AFX_IDD_PASTESPECIAL;

	// get LPDATAOBJECT for paste special dialog
	COleDataObject dataObject;
	if (pDataObject == NULL)
	{
		VERIFY(dataObject.AttachClipboard());
		pDataObject = &dataObject;
	}
	ASSERT(pDataObject != NULL);
	m_ps.lpSrcDataObj = pDataObject->GetIDataObject(TRUE);

	// complete initialization
	m_ps.arrPasteEntries = NULL;
	m_ps.cPasteEntries = 0;
	m_ps.arrLinkTypes = m_arrLinkTypes;
	m_ps.cLinkTypes = 0;
}

COlePasteSpecialDialog::~COlePasteSpecialDialog()
{
	_AfxDeleteMetafilePict(m_ps.hMetaPict);

	for (int i = 0; i < m_ps.cPasteEntries; i++)
	{
		free((void*)m_ps.arrPasteEntries[i].lpstrFormatName);
		free((void*)m_ps.arrPasteEntries[i].lpstrResultText);
	}
	free(m_ps.arrPasteEntries);

	RELEASE(m_ps.lpSrcDataObj);
}

INT_PTR COlePasteSpecialDialog::DoModal()
{
	ASSERT_VALID(this);
	ASSERT(m_ps.lpfnHook != NULL);  // can still be a user hook

	// return error if IDataObject* not available
	if (m_ps.lpSrcDataObj == NULL)
		return -1;

	m_ps.hWndOwner = PreModal();
	INT_PTR iResult = MapResult(::OleUIPasteSpecial(&m_ps));
	PostModal();
	return iResult;
}

UINT COlePasteSpecialDialog::GetSelectionType() const
{
	ASSERT_VALID(this);
	ASSERT(m_ps.dwFlags & (PSF_SELECTPASTE|PSF_SELECTPASTELINK));

	UINT cf = m_ps.arrPasteEntries[m_ps.nSelectedIndex].fmtetc.cfFormat;
	Selection selType = pasteOther;
	if (m_ps.dwFlags & PSF_SELECTPASTELINK)
	{
		selType = pasteLink;
	}
	else if (cf == _oleData.cfEmbedSource || cf == _oleData.cfEmbeddedObject ||
		cf == _oleData.cfLinkSource)
	{
		selType = pasteNormal;
	}
	else if (cf == CF_METAFILEPICT || cf == CF_DIB || cf == CF_BITMAP)
	{
		selType = pasteStatic;
	}
	return selType;
}

/////////////////////////////////////////////////////////////////////////////
// COlePasteSpecialDialog diagnostics

#ifdef _DEBUG
void COlePasteSpecialDialog::Dump(CDumpContext& dc) const
{
	COleDialog::Dump(dc);

	dc << "m_ps.cbStruct = " << m_ps.cbStruct;
	dc << "\nm_ps.dwFlags = ";
	dc.DumpAsHex(m_ps.dwFlags);
	dc << "\nm_ps.hWndOwner = " << m_ps.hWndOwner;
	dc << "\nm_ps.lpszCaption = " << m_ps.lpszCaption;
	dc << "\nm_ps.lCustData = " << (LPVOID)m_ps.lCustData;
	dc << "\nm_ps.hInstance = " << m_ps.hInstance;
	dc << "\nm_ps.lpszTemplate = " << (LPVOID)m_ps.lpszTemplate;
	dc << "\nm_ps.hResource = " << m_ps.hResource;
	if (m_ps.lpfnHook == AfxOleHookProc)
		dc << "\nhook function set to standard MFC hook function";
	else
		dc << "\nhook function set to non-standard hook function";
	dc << "\nm_ps.lpSrcDataObj = " << (LPVOID)m_ps.lpSrcDataObj;
	dc << "\nm_ps.cPasteEntries = " << m_ps.cPasteEntries;
	dc << "\nm_ps.cLinkTypes = " << m_ps.cLinkTypes;
	dc << "\nm_ps.nSelectedIndex = " << m_ps.nSelectedIndex;
	dc << "\nm_ps.fLink = " << m_ps.fLink;

	dc << "\n";
}

void COlePasteSpecialDialog::AssertValid() const
{
	COleDialog::AssertValid();
	ASSERT(m_ps.cPasteEntries == 0 || m_ps.arrPasteEntries != NULL);
	ASSERT(m_ps.arrLinkTypes != NULL);
	ASSERT(m_ps.cLinkTypes <= 8);
}
#endif

////////////////////////////////////////////////////////////////////////////

OLEUIPASTEFLAG COlePasteSpecialDialog::AddLinkEntry(UINT cf)
{
	ASSERT_VALID(this);
	ASSERT(m_ps.cLinkTypes <= 8);
	int i;
	for (i = 0; i < m_ps.cLinkTypes; i++)
	{
		if (m_ps.arrLinkTypes[i] == cf)
			break;
	}
	if (i == 8)
		return (OLEUIPASTEFLAG)0;
	m_ps.arrLinkTypes[i] = cf;
	if (i == m_ps.cLinkTypes)
		m_ps.cLinkTypes++;
	return (OLEUIPASTEFLAG) (OLEUIPASTE_LINKTYPE1 << i);
}

void COlePasteSpecialDialog::AddFormat(UINT cf, DWORD tymed, UINT nFormatID,
									   BOOL bEnableIcon, BOOL bLink)
{
	TCHAR szFormat[256];
	if (AfxLoadString(nFormatID, szFormat, _countof(szFormat)) == 0)
		AfxThrowResourceException();

	// the format and result strings are delimited by a newline
	LPTSTR lpszResult = _tcschr(szFormat, '\n');
	ENSURE(lpszResult != NULL);  // must contain a newline
	*lpszResult = '\0';
	++lpszResult;    // one char past newline

	// add it to the array of acceptable formats
	if ((m_ps.cPasteEntries + 1 < m_ps.cPasteEntries) || (m_ps.cPasteEntries + 1) > (INT_MAX / sizeof(OLEUIPASTEENTRY)))
		AfxThrowMemoryException();
	OLEUIPASTEENTRY *p = (OLEUIPASTEENTRY *)realloc(m_ps.arrPasteEntries,
		sizeof(OLEUIPASTEENTRY) * (m_ps.cPasteEntries +1));
	if (p == NULL)
		AfxThrowMemoryException();

	m_ps.arrPasteEntries = p;

	OLEUIPASTEENTRY* pEntry = &m_ps.arrPasteEntries[m_ps.cPasteEntries];
	pEntry->fmtetc.cfFormat = (CLIPFORMAT)cf;
	pEntry->fmtetc.dwAspect = DVASPECT_CONTENT;
	pEntry->fmtetc.ptd = NULL;
	pEntry->fmtetc.tymed = tymed;
	pEntry->fmtetc.lindex = -1;
	pEntry->lpstrFormatName = _tcsdup(szFormat);
	pEntry->lpstrResultText = _tcsdup(lpszResult);
	pEntry->dwFlags = OLEUIPASTE_PASTE;

	if (bEnableIcon)
		pEntry->dwFlags |= OLEUIPASTE_ENABLEICON;
	if (bLink)
		pEntry->dwFlags |= AddLinkEntry(cf);
	if (pEntry->dwFlags == OLEUIPASTE_PASTE)
		pEntry->dwFlags = OLEUIPASTE_PASTEONLY;
	pEntry->dwScratchSpace = NULL;
	m_ps.cPasteEntries++;
}

// if the flags parameter includes a LINKTYPE# flag, it should be obtained
// from AddLinkEntry
void COlePasteSpecialDialog::AddFormat(const FORMATETC& formatEtc,
									   _In_z_ LPTSTR lpszFormat, _In_z_ LPTSTR lpszResult, DWORD dwFlags)
{
	ASSERT_VALID(this);

	if ((m_ps.cPasteEntries + 1 < m_ps.cPasteEntries) || (m_ps.cPasteEntries + 1) > (INT_MAX / sizeof(OLEUIPASTEENTRY)))
		AfxThrowMemoryException();
	OLEUIPASTEENTRY *p = (OLEUIPASTEENTRY *)realloc(
		m_ps.arrPasteEntries, sizeof(OLEUIPASTEENTRY) * (m_ps.cPasteEntries +1));
	if (p == NULL)
		AfxThrowMemoryException();

	m_ps.arrPasteEntries = p;
	OLEUIPASTEENTRY* pEntry = &m_ps.arrPasteEntries[m_ps.cPasteEntries];
	pEntry->fmtetc = formatEtc;
	pEntry->lpstrFormatName = _tcsdup(lpszFormat);
	pEntry->lpstrResultText = _tcsdup(lpszResult);
	pEntry->dwFlags = dwFlags;
	pEntry->dwScratchSpace = NULL;
	m_ps.cPasteEntries++;
}

void COlePasteSpecialDialog::AddStandardFormats(BOOL bEnableLink)
{
	// Note: only need to add Embedded Object because Embed Source is
	//  automatically recognized by the paste special dialog implementation.
	ASSERT(_oleData.cfEmbeddedObject != NULL);
	AddFormat(_oleData.cfEmbeddedObject, TYMED_ISTORAGE, AFX_IDS_EMBED_FORMAT,
		TRUE, FALSE);

	// add link source if requested
	if (bEnableLink)
	{
		ASSERT(_oleData.cfLinkSource != NULL);
		AddFormat(_oleData.cfLinkSource, TYMED_ISTREAM, AFX_IDS_LINKSOURCE_FORMAT,
			TRUE, TRUE);
	}

	// add formats that can be used for 'static' items
	AddFormat(CF_METAFILEPICT, TYMED_MFPICT, AFX_IDS_METAFILE_FORMAT,
		FALSE, FALSE);
	AddFormat(CF_DIB, TYMED_HGLOBAL, AFX_IDS_DIB_FORMAT, FALSE, FALSE);
	AddFormat(CF_BITMAP, TYMED_GDI, AFX_IDS_BITMAP_FORMAT, FALSE, FALSE);
}

BOOL COlePasteSpecialDialog::CreateItem(COleClientItem *pNewItem)
{
	ASSERT_VALID(this);
	ASSERT(pNewItem != NULL);
	ASSERT(m_ps.lpSrcDataObj != NULL);

	CWaitCursor wait;

	COleDataObject dataObject;
	dataObject.Attach(m_ps.lpSrcDataObj, FALSE);

	UINT selType = GetSelectionType();
	BOOL bResult = TRUE;

	switch (selType)
	{
	case pasteLink:
		// paste link
		if (!pNewItem->CreateLinkFromData(&dataObject))
		{
			TRACE(traceOle, 0, "Warning: CreateLinkFromData failed.\n");
			bResult = FALSE;
		}
		break;
	case pasteStatic:
		if (!pNewItem->CreateStaticFromData(&dataObject))
		{
			TRACE(traceOle, 0, "Warning: CreateStaticFromData failed.\n");
			bResult = FALSE;
		}
		break;
	default:
		ASSERT(selType == pasteNormal);
		if (!pNewItem->CreateFromData(&dataObject))
		{
			TRACE(traceOle, 0, "Warning: CreateFromData failed.\n");
			bResult = FALSE;
		}
		break;
	}

	// deal with Display As Iconic option
	if (bResult && GetDrawAspect() == DVASPECT_ICON)
	{
		// setup iconic cache (it will draw iconic by default as well)
		if (!pNewItem->SetIconicMetafile(m_ps.hMetaPict))
		{
			TRACE(traceOle, 0, "Warning: failed to set iconic aspect.\n");
			bResult = FALSE;
		}
		else
		{
			// since picture was set OK, draw as iconic as well...
			pNewItem->SetDrawAspect(DVASPECT_ICON);
		}
	}
	return bResult;
}

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations expanded out-of-line

#ifndef _AFX_ENABLE_INLINES

// expand inlines for OLE dialog APIs
#define _AFXODLGS_INLINE
#include "afxole.inl"

#endif //!_AFX_ENABLE_INLINES


IMPLEMENT_DYNAMIC(COleInsertDialog, COleDialog)
IMPLEMENT_DYNAMIC(COleConvertDialog, COleDialog)
IMPLEMENT_DYNAMIC(COleChangeIconDialog, COleDialog)
IMPLEMENT_DYNAMIC(COleLinksDialog, COleDialog)
IMPLEMENT_DYNAMIC(COleUpdateDialog, COleLinksDialog)
IMPLEMENT_DYNAMIC(COlePasteSpecialDialog, COleDialog)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\oledobj2.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// COleDataSource implementation

struct AFX_DATACACHE_ENTRY
{
	FORMATETC m_formatEtc;
	STGMEDIUM m_stgMedium;
	DATADIR m_nDataDir;
};

/////////////////////////////////////////////////////////////////////////////
// COleDataSource construction & destruction

COleDataSource::COleDataSource()
{
	m_pDataCache = NULL;
	m_nMaxSize = 0;
	m_nSize = 0;
	m_nGrowBy = 10;
}

COleDataSource::~COleDataSource()
{
	// clear clipboard source if this object was on the clipboard
	_AFX_OLE_STATE* pOleState = _afxOleState;
	if (this == pOleState->m_pClipboardSource)
		pOleState->m_pClipboardSource = NULL;

	// free the clipboard data cache
	Empty();
}

void COleDataSource::Empty()
{
	if (m_pDataCache != NULL)
	{
		ASSERT(m_nMaxSize != 0);
		ASSERT(m_nSize != 0);

		// release all of the STGMEDIUMs and FORMATETCs
		for (UINT nIndex = 0; nIndex < m_nSize; nIndex++)
		{
			CoTaskMemFree(m_pDataCache[nIndex].m_formatEtc.ptd);
			::ReleaseStgMedium(&m_pDataCache[nIndex].m_stgMedium);
		}

		// delete the cache
		delete[] m_pDataCache;
		m_pDataCache = NULL;
		m_nMaxSize = 0;
		m_nSize = 0;
	}
	ASSERT(m_pDataCache == NULL);
	ASSERT(m_nMaxSize == 0);
	ASSERT(m_nSize == 0);
}

/////////////////////////////////////////////////////////////////////////////
// COleDataSource clipboard API wrappers

void COleDataSource::SetClipboard()
{
	ASSERT_VALID(this);

	// attempt OLE set clipboard operation
	LPDATAOBJECT lpDataObject = (LPDATAOBJECT)GetInterface(&IID_IDataObject);
	SCODE sc = ::OleSetClipboard(lpDataObject);
	if (sc != S_OK)
		AfxThrowOleException(sc);

	// success - set as current clipboard source
	_afxOleState->m_pClipboardSource = this;
	ASSERT(::OleIsCurrentClipboard(lpDataObject) == S_OK);
	InternalRelease();
}

void PASCAL COleDataSource::FlushClipboard()
{
	if (GetClipboardOwner() != NULL)
	{
		// active clipboard source and it is on the clipboard - flush it
		::OleFlushClipboard();

		// shouldn't be clipboard owner any more...
		ASSERT(GetClipboardOwner() == NULL);
	}
}

COleDataSource* PASCAL COleDataSource::GetClipboardOwner()
{
	_AFX_OLE_STATE* pOleState = _afxOleState;
	if (pOleState->m_pClipboardSource == NULL)
		return NULL;    // can't own the clipboard if pClipboardSource isn't set

	ASSERT_VALID(pOleState->m_pClipboardSource);
	LPDATAOBJECT lpDataObject = (LPDATAOBJECT)
		pOleState->m_pClipboardSource->GetInterface(&IID_IDataObject);
	if (::OleIsCurrentClipboard(lpDataObject) != S_OK)
	{
		pOleState->m_pClipboardSource = NULL;
		return NULL;    // don't own the clipboard anymore
	}

	// return current clipboard source
	return pOleState->m_pClipboardSource;
}

/////////////////////////////////////////////////////////////////////////////
// COleDataSource cache allocation

AFX_DATACACHE_ENTRY* COleDataSource::GetCacheEntry(
	LPFORMATETC lpFormatEtc, DATADIR nDataDir)
{
	AFX_DATACACHE_ENTRY* pEntry = Lookup(lpFormatEtc, nDataDir);
	if (pEntry != NULL)
	{
		// cleanup current entry and return it
		CoTaskMemFree(pEntry->m_formatEtc.ptd);
		::ReleaseStgMedium(&pEntry->m_stgMedium);
	}
	else
	{
		// allocate space for item at m_nSize (at least room for 1 item)
		if (m_pDataCache == NULL || m_nSize == m_nMaxSize)
		{
			ASSERT(m_nGrowBy != 0);
			AFX_DATACACHE_ENTRY* pCache = new AFX_DATACACHE_ENTRY[m_nMaxSize+m_nGrowBy];
			m_nMaxSize += m_nGrowBy;
			if (m_pDataCache != NULL)
			{
				Checked::memcpy_s(pCache, (m_nMaxSize+m_nGrowBy)*sizeof(AFX_DATACACHE_ENTRY), 
					m_pDataCache, m_nSize * sizeof(AFX_DATACACHE_ENTRY));
				delete[] m_pDataCache;
			}
			m_pDataCache = pCache;
		}
		ASSERT(m_pDataCache != NULL);
		ASSERT(m_nMaxSize != 0);

		pEntry = &m_pDataCache[m_nSize++];
	}

	// fill the cache entry with the format and data direction and return it
	pEntry->m_nDataDir = nDataDir;
	pEntry->m_formatEtc = *lpFormatEtc;
	return pEntry;
}

/////////////////////////////////////////////////////////////////////////////
// COleDataSource operations

// for HGLOBAL based cached render
void COleDataSource::CacheGlobalData(CLIPFORMAT cfFormat, HGLOBAL hGlobal,
	LPFORMATETC lpFormatEtc)
{
    ASSERT(hGlobal != NULL);
	ASSERT(lpFormatEtc == NULL ||
		AfxIsValidAddress(lpFormatEtc, sizeof(FORMATETC), FALSE));

	// fill in FORMATETC struct
	FORMATETC formatEtc;
	lpFormatEtc = _AfxFillFormatEtc(lpFormatEtc, cfFormat, &formatEtc);
	lpFormatEtc->tymed = TYMED_HGLOBAL;

	// add it to the cache
	AFX_DATACACHE_ENTRY* pEntry = GetCacheEntry(lpFormatEtc, DATADIR_GET);
	pEntry->m_stgMedium.tymed = TYMED_HGLOBAL;
	pEntry->m_stgMedium.hGlobal = hGlobal;
	pEntry->m_stgMedium.pUnkForRelease = NULL;
}

// for raw LPSTGMEDIUM cached render
void COleDataSource::CacheData(CLIPFORMAT cfFormat, LPSTGMEDIUM lpStgMedium,
	LPFORMATETC lpFormatEtc)
{
	ENSURE(lpStgMedium);
    ASSERT(AfxIsValidAddress(lpStgMedium, sizeof(STGMEDIUM), FALSE));
	ASSERT(lpStgMedium->tymed != TYMED_NULL);
	ASSERT(lpFormatEtc == NULL ||
		AfxIsValidAddress(lpFormatEtc, sizeof(FORMATETC), FALSE));

	// fill in FORMATETC struct
	FORMATETC formatEtc;
	lpFormatEtc = _AfxFillFormatEtc(lpFormatEtc, cfFormat, &formatEtc);

	// Only these TYMED_GDI formats can be copied, so can't serve as
	//  cache content (you must use DelayRenderData instead)
	// When using COleServerItem::CopyToClipboard this means providing an
	//  override of COleServerItem::OnGetClipboardData to provide a custom
	//  delayed rendering clipboard object.
	ASSERT(lpStgMedium->tymed != TYMED_GDI ||
		lpFormatEtc->cfFormat == CF_METAFILEPICT ||
		lpFormatEtc->cfFormat == CF_PALETTE ||
		lpFormatEtc->cfFormat == CF_BITMAP);
	lpFormatEtc->tymed = lpStgMedium->tymed;

	// add it to the cache
	AFX_DATACACHE_ENTRY* pEntry = GetCacheEntry(lpFormatEtc, DATADIR_GET);
	pEntry->m_stgMedium = *lpStgMedium;
}

// for CFile* based delayed render
void COleDataSource::DelayRenderFileData(CLIPFORMAT cfFormat,
	LPFORMATETC lpFormatEtc)
{
	ASSERT(lpFormatEtc == NULL ||
		AfxIsValidAddress(lpFormatEtc, sizeof(FORMATETC), FALSE));

	// fill in FORMATETC struct
	FORMATETC formatEtc;
	lpFormatEtc = _AfxFillFormatEtc(lpFormatEtc, cfFormat, &formatEtc);
	lpFormatEtc->tymed = TYMED_ISTREAM|TYMED_HGLOBAL;

	// add it to the cache
	AFX_DATACACHE_ENTRY* pEntry = GetCacheEntry(lpFormatEtc, DATADIR_GET);
	pEntry->m_stgMedium.tymed = TYMED_NULL;
	pEntry->m_stgMedium.hGlobal = NULL;
	pEntry->m_stgMedium.pUnkForRelease = NULL;
}

// for LPSTGMEDIUM or HGLOBAL based delayed render
void COleDataSource::DelayRenderData(CLIPFORMAT cfFormat, LPFORMATETC lpFormatEtc)
{
	ASSERT(lpFormatEtc == NULL ||
		AfxIsValidAddress(lpFormatEtc, sizeof(FORMATETC), FALSE));

	// fill in FORMATETC struct
	FORMATETC formatEtc;
	if (lpFormatEtc == NULL)
	{
		lpFormatEtc = _AfxFillFormatEtc(lpFormatEtc, cfFormat, &formatEtc);
		lpFormatEtc->tymed = TYMED_HGLOBAL;
	}
	// insure that cfFormat member is set
	if (cfFormat != 0)
		lpFormatEtc->cfFormat = cfFormat;

	// add it to the cache
	AFX_DATACACHE_ENTRY* pEntry = GetCacheEntry(lpFormatEtc, DATADIR_GET);
	memset(&pEntry->m_stgMedium, 0, sizeof pEntry->m_stgMedium);
}

// DelaySetData -- used to allow SetData on given LPFORMATETC
void COleDataSource::DelaySetData(CLIPFORMAT cfFormat, LPFORMATETC lpFormatEtc)
{
	ASSERT(lpFormatEtc == NULL ||
		AfxIsValidAddress(lpFormatEtc, sizeof(FORMATETC), FALSE));

	// fill in FORMATETC struct
	FORMATETC formatEtc;
	lpFormatEtc = _AfxFillFormatEtc(lpFormatEtc, cfFormat, &formatEtc);

	// add it to the cache
	AFX_DATACACHE_ENTRY* pEntry = GetCacheEntry(lpFormatEtc, DATADIR_SET);
	pEntry->m_stgMedium.tymed = TYMED_NULL;
	pEntry->m_stgMedium.hGlobal = NULL;
	pEntry->m_stgMedium.pUnkForRelease = NULL;
}

/////////////////////////////////////////////////////////////////////////////
// COleDataSource cache implementation

AFX_DATACACHE_ENTRY* COleDataSource::Lookup(
	LPFORMATETC lpFormatEtc, DATADIR nDataDir) const
{
	AFX_DATACACHE_ENTRY* pLast = NULL;

	// look for suitable match to lpFormatEtc in cache
	for (UINT nIndex = 0; nIndex < m_nSize; nIndex++)
	{
		// get entry from cache at nIndex
		AFX_DATACACHE_ENTRY* pCache = &m_pDataCache[nIndex];
		FORMATETC *pCacheFormat = &pCache->m_formatEtc;

		// check for match
		// we threat lindex == 0 and lindex == -1 as equivalent
		if (pCacheFormat->cfFormat == lpFormatEtc->cfFormat &&
			(pCacheFormat->tymed & lpFormatEtc->tymed) != 0 &&
			(pCacheFormat->dwAspect == DVASPECT_THUMBNAIL ||
			 pCacheFormat->dwAspect == DVASPECT_ICON ||
			 pCache->m_stgMedium.tymed == TYMED_NULL ||
			 pCacheFormat->lindex == lpFormatEtc->lindex ||
			 (pCacheFormat->lindex == 0 && lpFormatEtc->lindex == -1) ||
			 (pCacheFormat->lindex == -1 && lpFormatEtc->lindex == 0)) &&
			pCacheFormat->dwAspect == lpFormatEtc->dwAspect &&
			pCache->m_nDataDir == nDataDir)
		{
			// for backward compatibility we match even if we never
			// find an exact match for the DVTARGETDEVICE
			pLast = pCache;
			DVTARGETDEVICE* ptd1 = pCacheFormat->ptd;
			DVTARGETDEVICE* ptd2 = lpFormatEtc->ptd;

			if (ptd1 == NULL && ptd2 == NULL)
			{
				// both target devices are NULL (exact match), so return it
				break;
			}
			if (ptd1 != NULL && ptd2 != NULL &&
				ptd1->tdSize == ptd2->tdSize &&
				memcmp(ptd1, ptd2, ptd1->tdSize) == 0)
			{
				// exact match, so return it
				break;
			}
			// continue looking for better match
		}
	}

	return pLast;    // not found
}

/////////////////////////////////////////////////////////////////////////////
// COleDataSource overidable default implementation

BOOL COleDataSource::OnRenderGlobalData(
	LPFORMATETC /*lpFormatEtc*/, HGLOBAL* /*phGlobal*/)
{
	return FALSE;   // default does nothing
}

BOOL COleDataSource::OnRenderFileData(
	LPFORMATETC /*lpFormatEtc*/, CFile* /*pFile*/)
{
	return FALSE;   // default does nothing
}

BOOL COleDataSource::OnRenderData(
	LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium)
{
	// attempt TYMED_HGLOBAL as prefered format
	if (lpFormatEtc->tymed & TYMED_HGLOBAL)
	{
		// attempt HGLOBAL delay render hook
		HGLOBAL hGlobal = lpStgMedium->hGlobal;
		if (OnRenderGlobalData(lpFormatEtc, &hGlobal))
		{
			ASSERT(lpStgMedium->tymed != TYMED_HGLOBAL ||
				(lpStgMedium->hGlobal == hGlobal));
			ASSERT(hGlobal != NULL);
			lpStgMedium->tymed = TYMED_HGLOBAL;
			lpStgMedium->hGlobal = hGlobal;
			return TRUE;
		}

		// attempt CFile* based delay render hook
		CSharedFile file;
		if (lpStgMedium->tymed == TYMED_HGLOBAL)
		{
			ASSERT(lpStgMedium->hGlobal != NULL);
			file.SetHandle(lpStgMedium->hGlobal, FALSE);
		}
		if (OnRenderFileData(lpFormatEtc, &file))
		{
			lpStgMedium->tymed = TYMED_HGLOBAL;
			lpStgMedium->hGlobal = file.Detach();
			ASSERT(lpStgMedium->hGlobal != NULL);
			return TRUE;
		}
		if (lpStgMedium->tymed == TYMED_HGLOBAL)
			file.Detach();
	}

	// attempt TYMED_ISTREAM format
	if (lpFormatEtc->tymed & TYMED_ISTREAM)
	{
		COleStreamFile file;
		if (lpStgMedium->tymed == TYMED_ISTREAM)
		{
			ASSERT(lpStgMedium->pstm != NULL);
			file.Attach(lpStgMedium->pstm);
		}
		else
		{
			if (!file.CreateMemoryStream())
				AfxThrowMemoryException();
		}
		// get data into the stream
		if (OnRenderFileData(lpFormatEtc, &file))
		{
			lpStgMedium->tymed = TYMED_ISTREAM;
			lpStgMedium->pstm = file.Detach();
			return TRUE;
		}
		if (lpStgMedium->tymed == TYMED_ISTREAM)
			file.Detach();
	}

	return FALSE;   // default does nothing
}

BOOL COleDataSource::OnSetData(
	LPFORMATETC /*lpFormatEtc*/, LPSTGMEDIUM /*lpStgMedium*/, BOOL /*bRelease*/)
{
	return FALSE;   // default does nothing
}

/////////////////////////////////////////////////////////////////////////////
// CEnumFormatEtc - enumerator for array for FORMATETC structures

class CEnumFormatEtc : public CEnumArray
{
// Constructors
public:
	CEnumFormatEtc();

// Operations
	void AddFormat(const FORMATETC* lpFormatEtc);

// Implementation
public:
	virtual ~CEnumFormatEtc();

protected:
	virtual BOOL OnNext(void* pv);

	UINT m_nMaxSize;    // number of items allocated (>= m_nSize)
	DECLARE_INTERFACE_MAP()
};

BEGIN_INTERFACE_MAP(CEnumFormatEtc, CEnumArray)
	INTERFACE_PART(CEnumFormatEtc, IID_IEnumFORMATETC, EnumVOID)
END_INTERFACE_MAP()

CEnumFormatEtc::CEnumFormatEtc()
	: CEnumArray(sizeof(FORMATETC), NULL, 0, TRUE)
{
	m_nMaxSize = 0;
}

CEnumFormatEtc::~CEnumFormatEtc()
{
	if (m_pClonedFrom == NULL)
	{
		// release all of the pointers to DVTARGETDEVICE
		LPFORMATETC lpFormatEtc = (LPFORMATETC)m_pvEnum;
		for (UINT nIndex = 0; nIndex < m_nSize; nIndex++)
			CoTaskMemFree(lpFormatEtc[nIndex].ptd);
	}
	// destructor will free the actual array (if it was not a clone)
}

BOOL CEnumFormatEtc::OnNext(void* pv)
{
	if (!CEnumArray::OnNext(pv))
		return FALSE;

	// any outgoing formatEtc may require the DVTARGETDEVICE to
	//  be copied (the caller has responsibility to free it)
	LPFORMATETC lpFormatEtc = (LPFORMATETC)pv;
	if (lpFormatEtc->ptd != NULL)
	{
		lpFormatEtc->ptd = _AfxOleCopyTargetDevice(lpFormatEtc->ptd);
		if (lpFormatEtc->ptd == NULL)
			AfxThrowMemoryException();
	}
	// otherwise, copying worked...
	return TRUE;
}

void CEnumFormatEtc::AddFormat(const FORMATETC* lpFormatEtc)
{
	ASSERT(m_nSize <= m_nMaxSize);

	if (m_nSize == m_nMaxSize)
	{
		// not enough space for new item -- allocate more
		FORMATETC* pListNew = new FORMATETC[m_nSize+10];
		m_nMaxSize += 10;
		Checked::memcpy_s(pListNew, (m_nSize+10)*sizeof(FORMATETC),
			m_pvEnum, m_nSize*sizeof(FORMATETC));
		delete m_pvEnum;
		m_pvEnum = (BYTE*)pListNew;
	}

	// add this item to the list
	ASSERT(m_nSize < m_nMaxSize);
	FORMATETC* pFormat = &((FORMATETC*)m_pvEnum)[m_nSize];
	pFormat->cfFormat = lpFormatEtc->cfFormat;
	pFormat->ptd = lpFormatEtc->ptd;
		// Note: ownership of lpFormatEtc->ptd is transfered with this call.
	pFormat->dwAspect = lpFormatEtc->dwAspect;
	pFormat->lindex = lpFormatEtc->lindex;
	pFormat->tymed = lpFormatEtc->tymed;
	++m_nSize;
}

/////////////////////////////////////////////////////////////////////////////
// COleDataSource::XDataObject

BEGIN_INTERFACE_MAP(COleDataSource, CCmdTarget)
	INTERFACE_PART(COleDataSource, IID_IDataObject, DataObject)
END_INTERFACE_MAP()

STDMETHODIMP_(ULONG) COleDataSource::XDataObject::AddRef()
{
	METHOD_PROLOGUE_EX_(COleDataSource, DataObject)
	return pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) COleDataSource::XDataObject::Release()
{
	METHOD_PROLOGUE_EX_(COleDataSource, DataObject)
	return pThis->ExternalRelease();
}

STDMETHODIMP COleDataSource::XDataObject::QueryInterface(REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(COleDataSource, DataObject)
	return pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP COleDataSource::XDataObject::GetData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium)
{
	METHOD_PROLOGUE_EX(COleDataSource, DataObject)
	ASSERT_VALID(pThis);

	if (lpFormatEtc == NULL || lpStgMedium == NULL)
	{
		return E_INVALIDARG;
	}

	// attempt to find match in the cache
	AFX_DATACACHE_ENTRY* pCache = pThis->Lookup(lpFormatEtc, DATADIR_GET);
	if (pCache == NULL)
	{
		return DATA_E_FORMATETC;
	}

	// use cache if entry is not delay render
	memset(lpStgMedium, 0, sizeof(STGMEDIUM));
	if (pCache->m_stgMedium.tymed != TYMED_NULL)
	{
		// Copy the cached medium into the lpStgMedium provided by caller.
		if (!_AfxCopyStgMedium(lpFormatEtc->cfFormat, lpStgMedium, &pCache->m_stgMedium))
		{
			return DATA_E_FORMATETC;
		}

		// format was supported for copying
		return S_OK;
	}

	SCODE sc = DATA_E_FORMATETC;
	TRY
	{
		// attempt LPSTGMEDIUM based delay render
		if (pThis->OnRenderData(lpFormatEtc, lpStgMedium))
		{
			sc = S_OK;
		}
	}
	CATCH_ALL(e)
	{
		sc = COleException::Process(e);
		DELETE_EXCEPTION(e);
	}
	END_CATCH_ALL

	return sc;
}

STDMETHODIMP COleDataSource::XDataObject::GetDataHere(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium)
{
	METHOD_PROLOGUE_EX(COleDataSource, DataObject)
	ASSERT_VALID(pThis);

	if (lpFormatEtc == NULL || lpStgMedium == NULL)
	{
		return E_INVALIDARG;
	}

	// these two must be the same
	ASSERT(lpFormatEtc->tymed == lpStgMedium->tymed);
	lpFormatEtc->tymed = lpStgMedium->tymed;    // but just in case...

	// attempt to find match in the cache
	AFX_DATACACHE_ENTRY* pCache = pThis->Lookup(lpFormatEtc, DATADIR_GET);
	if (pCache == NULL)
	{
		return DATA_E_FORMATETC;
	}

	// handle cached medium and copy
	if (pCache->m_stgMedium.tymed != TYMED_NULL)
	{
		// found a cached format -- copy it to dest medium
		ASSERT(pCache->m_stgMedium.tymed == lpStgMedium->tymed);
		if (!_AfxCopyStgMedium(lpFormatEtc->cfFormat, lpStgMedium, &pCache->m_stgMedium))
		{
			return DATA_E_FORMATETC;
		}

		// format was supported for copying
		return S_OK;
	}

	SCODE sc = DATA_E_FORMATETC;
	TRY
	{
		// attempt LPSTGMEDIUM based delay render
		if (pThis->OnRenderData(lpFormatEtc, lpStgMedium))
		{
			sc = S_OK;
		}
	}
	CATCH_ALL(e)
	{
		sc = COleException::Process(e);
		DELETE_EXCEPTION(e);
	}
	END_CATCH_ALL

	return sc;
}

STDMETHODIMP COleDataSource::XDataObject::QueryGetData(LPFORMATETC lpFormatEtc)
{
	METHOD_PROLOGUE_EX_(COleDataSource, DataObject)

	if (lpFormatEtc == NULL)
	{
		return E_INVALIDARG;
	}

	// attempt to find match in the cache
	AFX_DATACACHE_ENTRY* pCache = pThis->Lookup(lpFormatEtc, DATADIR_GET);
	if (pCache == NULL)
	{
		return DATA_E_FORMATETC;
	}

	// it was found in the cache or can be rendered -- success
	return S_OK;
}

STDMETHODIMP COleDataSource::XDataObject::GetCanonicalFormatEtc(LPFORMATETC /*lpFormatEtcIn*/, LPFORMATETC /*lpFormatEtcOut*/)
{
	// because we support the target-device (ptd) for server metafile format,
	//  all members of the FORMATETC are significant.

	return DATA_S_SAMEFORMATETC;
}

STDMETHODIMP COleDataSource::XDataObject::SetData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium, BOOL bRelease)
{
	METHOD_PROLOGUE_EX(COleDataSource, DataObject)
	ASSERT_VALID(pThis);

	if (lpFormatEtc == NULL || lpStgMedium == NULL)
	{
		return E_INVALIDARG;
	}

	ASSERT(lpFormatEtc->tymed == lpStgMedium->tymed);

	// attempt to find match in the cache
	AFX_DATACACHE_ENTRY* pCache = pThis->Lookup(lpFormatEtc, DATADIR_SET);
	if (pCache == NULL)
	{
		return DATA_E_FORMATETC;
	}

	ASSERT(pCache->m_stgMedium.tymed == TYMED_NULL);

	SCODE sc = E_UNEXPECTED;
	TRY
	{
		// attempt LPSTGMEDIUM based SetData
		if (pThis->OnSetData(lpFormatEtc, lpStgMedium, bRelease))
		{
			sc = S_OK;
		}
	}
	CATCH_ALL(e)
	{
		sc = COleException::Process(e);
		DELETE_EXCEPTION(e);
	}
	END_CATCH_ALL

	return sc;
}

STDMETHODIMP COleDataSource::XDataObject::EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC* ppenumFormatEtc)
{
	METHOD_PROLOGUE_EX_(COleDataSource, DataObject)

	if (ppenumFormatEtc == NULL)
	{
		return E_POINTER;
	}

	*ppenumFormatEtc = NULL;

	CEnumFormatEtc* pFormatList = NULL;
	SCODE sc = E_OUTOFMEMORY;
	TRY
	{
		// generate a format list from the cache
		pFormatList = new CEnumFormatEtc;
		for (UINT nIndex = 0; nIndex < pThis->m_nSize; nIndex++)
		{
			AFX_DATACACHE_ENTRY* pCache = &pThis->m_pDataCache[nIndex];
			if ((DWORD)pCache->m_nDataDir & dwDirection)
			{
				// entry should be enumerated -- add it to the list
				FORMATETC formatEtc;
				_AfxOleCopyFormatEtc(&formatEtc, &pCache->m_formatEtc);
				pFormatList->AddFormat(&formatEtc);
			}
		}

		// give it away to OLE (ref count is already 1)
		*ppenumFormatEtc = (LPENUMFORMATETC)&pFormatList->m_xEnumVOID;
		sc = S_OK;
	}
	END_TRY

	return sc;
}

STDMETHODIMP COleDataSource::XDataObject::DAdvise(FORMATETC* /*pFormatetc*/, DWORD /*advf*/, LPADVISESINK /*pAdvSink*/, DWORD* pdwConnection)
{
	*pdwConnection = 0;
	return OLE_E_ADVISENOTSUPPORTED;
}

STDMETHODIMP COleDataSource::XDataObject::DUnadvise(DWORD /*dwConnection*/)
{
	return OLE_E_ADVISENOTSUPPORTED;
}

STDMETHODIMP COleDataSource::XDataObject::EnumDAdvise(LPENUMSTATDATA* ppenumAdvise)
{
	*ppenumAdvise = NULL;
	return OLE_E_ADVISENOTSUPPORTED;
}

/////////////////////////////////////////////////////////////////////////////
// COleDataSource diagnostics

#ifdef _DEBUG
void COleDataSource::AssertValid() const
{
	CCmdTarget::AssertValid();
	ASSERT(m_nSize <= m_nMaxSize);
	ASSERT(m_nMaxSize != 0 || m_pDataCache == NULL);
}

void COleDataSource::Dump(CDumpContext& dc) const
{
	CCmdTarget::Dump(dc);

	dc << "m_nMaxSize = " << m_nMaxSize;
	dc << "\nm_nSize = " << m_nSize;
	dc << "\nm_pDataCache = " << m_pDataCache;

	for (UINT n = 0; n < m_nSize; n++)
	{
		dc << "\n\tentry [" << n << "] = {";
		AFX_DATACACHE_ENTRY& rEntry = m_pDataCache[n];
		dc << "\n\t m_formatEtc.cfFormat = " << rEntry.m_formatEtc.cfFormat;
		dc << "\n\t m_formatEtc.pdt = " << rEntry.m_formatEtc.ptd;
		dc << "\n\t m_formatEtc.dwAspect = " << rEntry.m_formatEtc.dwAspect;
		dc << "\n\t m_formatEtc.lindex = " << rEntry.m_formatEtc.lindex;
		dc << "\n\t m_formatEtc.tymed = " << rEntry.m_formatEtc.tymed;
		dc << "\n\t m_stgMedium.tymed = " << rEntry.m_stgMedium.tymed;
		dc << "\n\t m_nDataDir = " << (UINT)rEntry.m_nDataDir;
		dc << "\n\t}";
	}

	dc << "\n";
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\oledobj1.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// COleDataObject constructors

COleDataObject::COleDataObject()
{
	m_lpEnumerator = NULL;
	m_lpDataObject = NULL;
	m_bAutoRelease = TRUE;
	m_bClipboard = FALSE;
}

void COleDataObject::Attach(LPDATAOBJECT lpDataObject, BOOL bAutoRelease)
{
	ASSERT(lpDataObject != NULL);

	Release();  // detach previous
	m_lpDataObject = lpDataObject;
	m_bAutoRelease = bAutoRelease;
}

void COleDataObject::Release()
{
	RELEASE(m_lpEnumerator);

	if (m_lpDataObject != NULL)
	{
		if (m_bAutoRelease)
			m_lpDataObject->Release();
		m_lpDataObject = NULL;
	}
	m_bClipboard = FALSE;
}

LPDATAOBJECT COleDataObject::Detach()
{
	EnsureClipboardObject();

	LPDATAOBJECT lpDataObject = m_lpDataObject;
	m_lpDataObject = NULL;  // detach without Release
	m_bClipboard = FALSE;

	return lpDataObject;
}

LPDATAOBJECT COleDataObject::GetIDataObject(BOOL bAddRef)
{
	EnsureClipboardObject();

	LPDATAOBJECT lpDataObject = m_lpDataObject;
	if (bAddRef && lpDataObject != NULL)
		lpDataObject->AddRef();

	return lpDataObject;
}

/////////////////////////////////////////////////////////////////////////////
// COleDataObject attributes

void COleDataObject::BeginEnumFormats()
{
	EnsureClipboardObject();
	ASSERT(m_bClipboard || m_lpDataObject != NULL);

	// release old enumerator
	RELEASE(m_lpEnumerator);
	if (m_lpDataObject == NULL)
	{
		return;
	}

	// get the new enumerator
	SCODE sc = m_lpDataObject->EnumFormatEtc(DATADIR_GET, &m_lpEnumerator);
	ASSERT(sc != S_OK || m_lpEnumerator != NULL);
	if (sc != S_OK)
	{
		m_lpEnumerator = NULL;
	}
}

BOOL COleDataObject::GetNextFormat(LPFORMATETC lpFormatEtc)
{
	ASSERT(m_bClipboard || m_lpDataObject != NULL);
	ASSERT(AfxIsValidAddress(lpFormatEtc, sizeof(FORMATETC), FALSE));

	// return FALSE if enumerator is already NULL
	if (m_lpEnumerator == NULL)
	{
		return FALSE;
	}

	// attempt to retrieve the next format with the enumerator
	SCODE sc = m_lpEnumerator->Next(1, lpFormatEtc, NULL);

	// if enumerator fails, stop the enumeration
	if (sc != S_OK)
	{
		RELEASE(m_lpEnumerator);
		return FALSE;   // enumeration has ended
	}

	// otherwise, continue
	return TRUE;
}

CFile* COleDataObject::GetFileData(CLIPFORMAT cfFormat, LPFORMATETC lpFormatEtc)
{
	EnsureClipboardObject();
	ASSERT(m_bClipboard || m_lpDataObject != NULL);
	if (m_lpDataObject == NULL)
	{
		return NULL;
	}

	ASSERT(lpFormatEtc == NULL || AfxIsValidAddress(lpFormatEtc, sizeof(FORMATETC), FALSE));

	if ((cfFormat == 0) && (lpFormatEtc == NULL))
	{
		return NULL;
	}

	// fill in FORMATETC struct
	FORMATETC formatEtc;
	lpFormatEtc = _AfxFillFormatEtc(lpFormatEtc, cfFormat, &formatEtc);
	formatEtc.tymed = TYMED_FILE|TYMED_MFPICT|TYMED_HGLOBAL|TYMED_ISTREAM;

	// attempt to get the data
	STGMEDIUM stgMedium;
	SCODE sc = m_lpDataObject->GetData(lpFormatEtc, &stgMedium);
	if (FAILED(sc))
	{
		return NULL;
	}

	// STGMEDIUMs with pUnkForRelease need to be copied first
	if (stgMedium.pUnkForRelease != NULL)
	{
		STGMEDIUM stgMediumDest;
		stgMediumDest.tymed = TYMED_NULL;
		stgMediumDest.pUnkForRelease = NULL;
		if (lpFormatEtc==NULL || !_AfxCopyStgMedium(lpFormatEtc->cfFormat, &stgMediumDest, &stgMedium))
		{
			::ReleaseStgMedium(&stgMedium);
			return FALSE;
		}

		// release original and replace with new
		::ReleaseStgMedium(&stgMedium);
		stgMedium = stgMediumDest;
	}

	// convert it to a file, depending on data
	CString strFileName;
	CFile* pFile = NULL;
	TRY
	{
		switch (stgMedium.tymed)
		{
		case TYMED_FILE:
			strFileName = stgMedium.lpszFileName;
			pFile = new CFile;
			if (!pFile->Open(strFileName,
				CFile::modeReadWrite|CFile::shareExclusive))
			{
				delete pFile;
				pFile = NULL;
				break;
			}
			// caller is responsible for deleting the actual file,
			//  but we free the file name.
			CoTaskMemFree(stgMedium.lpszFileName);
			break;

		case TYMED_MFPICT:
		case TYMED_HGLOBAL:
			pFile = new CSharedFile;
			((CSharedFile*)pFile)->SetHandle(stgMedium.hGlobal);
			break;

		case TYMED_ISTREAM:
			pFile = new COleStreamFile(stgMedium.pstm);
			break;

		default:
			// type not supported, so return error
			::ReleaseStgMedium(&stgMedium);
			break;
		}
	}
	CATCH_ALL(e)
	{
		delete pFile;
		pFile = NULL;
		DELETE_EXCEPTION(e);
	}
	END_CATCH_ALL

	// store newly created CFile* and return
	return pFile;
}

HGLOBAL COleDataObject::GetGlobalData(CLIPFORMAT cfFormat, LPFORMATETC lpFormatEtc)
{
	EnsureClipboardObject();
	ASSERT(m_bClipboard || m_lpDataObject != NULL);
	if (m_lpDataObject == NULL)
	{
		return NULL;
	}

	ASSERT(lpFormatEtc == NULL || AfxIsValidAddress(lpFormatEtc, sizeof(FORMATETC), FALSE));

	if ((cfFormat == 0) && (lpFormatEtc == NULL))
	{
		return NULL;
	}

	// fill in FORMATETC struct
	FORMATETC formatEtc;
	BOOL bFillFormatEtc = (lpFormatEtc == NULL);
	lpFormatEtc = _AfxFillFormatEtc(lpFormatEtc, cfFormat, &formatEtc);
	if (bFillFormatEtc)
	{
		lpFormatEtc->tymed = TYMED_HGLOBAL|TYMED_MFPICT;
	}
	ASSERT((lpFormatEtc->tymed & (TYMED_HGLOBAL|TYMED_MFPICT)) != 0);

	// attempt to get the data
	STGMEDIUM stgMedium;
	SCODE sc = m_lpDataObject->GetData(lpFormatEtc, &stgMedium);
	if (FAILED(sc))
	{
		return NULL;
	}

	// handle just hGlobal types
	switch (stgMedium.tymed)
	{
	case TYMED_MFPICT:
	case TYMED_HGLOBAL:
		if (stgMedium.pUnkForRelease == NULL)
		{
			return stgMedium.hGlobal;
		}

		STGMEDIUM stgMediumDest;
		stgMediumDest.tymed = TYMED_NULL;
		stgMediumDest.pUnkForRelease = NULL;
		if (!_AfxCopyStgMedium(lpFormatEtc->cfFormat, &stgMediumDest, &stgMedium))
		{
			::ReleaseStgMedium(&stgMedium);
			return NULL;
		}

		::ReleaseStgMedium(&stgMedium);
		return stgMediumDest.hGlobal;

	// default -- falls through to error condition...
	}

	::ReleaseStgMedium(&stgMedium);
	return NULL;
}

BOOL COleDataObject::GetData(CLIPFORMAT cfFormat, LPSTGMEDIUM lpStgMedium, LPFORMATETC lpFormatEtc)
{
	EnsureClipboardObject();
	ASSERT(m_bClipboard || m_lpDataObject != NULL);
	if (m_lpDataObject == NULL)
	{
		return FALSE;
	}

	ASSERT(AfxIsValidAddress(lpStgMedium, sizeof(STGMEDIUM), FALSE));

	if ((cfFormat == 0) && (lpFormatEtc == NULL))
	{
		return FALSE;
	}

	// fill in FORMATETC struct
	FORMATETC formatEtc;
	lpFormatEtc = _AfxFillFormatEtc(lpFormatEtc, cfFormat, &formatEtc);

	// attempt to get the data
	SCODE sc = m_lpDataObject->GetData(lpFormatEtc, lpStgMedium);
	if (FAILED(sc))
	{
		return FALSE;
	}

	return TRUE;
}

BOOL COleDataObject::IsDataAvailable(CLIPFORMAT cfFormat, LPFORMATETC lpFormatEtc)
{
	if (m_bClipboard)
	{
		// it is faster and more reliable to ask the real Win32 clipboard
		//  instead of the OLE clipboard.
		return ::IsClipboardFormatAvailable(cfFormat);
	}
	else
	{
		ASSERT(m_lpDataObject != NULL);
		ASSERT(lpFormatEtc == NULL || AfxIsValidAddress(lpFormatEtc, sizeof(FORMATETC), FALSE));

		if ((cfFormat == 0) && (lpFormatEtc == NULL))
		{
			return FALSE;
		}

		// fill in FORMATETC struct
		FORMATETC formatEtc;
		lpFormatEtc = _AfxFillFormatEtc(lpFormatEtc, cfFormat, &formatEtc);

		// attempt to get the data
		return m_lpDataObject->QueryGetData(lpFormatEtc) == S_OK;
	}
}

/////////////////////////////////////////////////////////////////////////////
// clipboard API wrappers

BOOL COleDataObject::AttachClipboard()
{
	ASSERT(AfxIsValidAddress(this, sizeof(COleDataObject)));
	ASSERT(m_lpDataObject == NULL); // need to call release?
	ASSERT(!m_bClipboard); // already attached to clipboard?

	// set special "clipboard" flag for optimizations
	m_bClipboard = TRUE;
	return TRUE;
}

void COleDataObject::EnsureClipboardObject()
{
	ASSERT(AfxIsValidAddress(this, sizeof(COleDataObject)));

	if (m_bClipboard && m_lpDataObject == NULL)
	{
		// get clipboard using OLE API
		LPDATAOBJECT lpDataObject;
		SCODE sc = ::OleGetClipboard(&lpDataObject);

		// attach COleDataObject wrapper to IDataObject from clipboard
		if (sc == S_OK)
			Attach(lpDataObject, TRUE);
	}
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\oledoccl.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#ifdef _DEBUG

#endif

#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// COleDocObjectItem

IMPLEMENT_DYNAMIC(COleDocObjectItem, COleClientItem)

BEGIN_INTERFACE_MAP(COleDocObjectItem, COleClientItem)
	INTERFACE_PART(COleDocObjectItem, IID_IOleDocumentSite, OleDocumentSite)
END_INTERFACE_MAP()


COleDocObjectItem::COleDocObjectItem(COleDocument* pContainerDoc)
	: COleClientItem(pContainerDoc)
{
	m_pHelpPopupMenu = NULL;
	m_pActiveView = NULL;
	m_pIPrint = NULL;
	m_bInHelpMenu = FALSE;
}

COleDocObjectItem::~COleDocObjectItem()
{
	if (m_pHelpPopupMenu != NULL)
		m_pHelpPopupMenu->RemoveMenu(0, MF_BYPOSITION);
	delete m_pHelpPopupMenu;
}


/////////////////////////////////////////////////////////////////////////////
// IOleDocumentSite interface

STDMETHODIMP_(ULONG) COleDocObjectItem::XOleDocumentSite::AddRef()
{
	METHOD_PROLOGUE_EX(COleDocObjectItem, OleDocumentSite)
	return pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) COleDocObjectItem::XOleDocumentSite::Release()
{
	METHOD_PROLOGUE_EX(COleDocObjectItem, OleDocumentSite)
	return pThis->ExternalRelease();
}

STDMETHODIMP COleDocObjectItem::XOleDocumentSite::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX(COleDocObjectItem, OleDocumentSite)
	return pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP COleDocObjectItem::XOleDocumentSite::ActivateMe(
	LPOLEDOCUMENTVIEW pViewToActivate)
{
	METHOD_PROLOGUE_EX(COleDocObjectItem, OleDocumentSite)

	LPOLEDOCUMENT lpDocument;
	LPOLECLIENTSITE lpClientSite = pThis->GetClientSite();
	LPOLEINPLACESITE lpInPlaceSite =
		(LPOLEINPLACESITE) pThis->GetInterface(&IID_IOleInPlaceSite);

	if (lpClientSite == NULL || lpInPlaceSite == NULL)
		return E_FAIL;

	// if we've gotten a NULL view, we're to create one ourselves

	if (pViewToActivate == NULL)
	{
		// if we already have a view, we can simply activate it

		if (pThis->m_pActiveView != NULL && pThis->m_pView != NULL)
		{
			pThis->ActivateAndShow();
			return NOERROR;
		}

		ASSERT(pThis->m_lpObject != NULL);
		if (pThis->m_lpObject == NULL)
			return E_FAIL;

		lpDocument = QUERYINTERFACE(pThis->m_lpObject, IOleDocument);
		if (lpDocument == NULL)
			return E_FAIL;

		if (FAILED(
			lpDocument->CreateView(lpInPlaceSite, NULL, 0, &pViewToActivate)))
		{
			lpDocument->Release();
		return E_OUTOFMEMORY;
		}

		// we're done with the document pointer
		lpDocument->Release();
	}
	else if (pThis->m_pActiveView != NULL && pThis->m_pActiveView == pViewToActivate)
	{
		// we already own this view, so no need to addref
		// simply make it visible and resize it

		pThis->ActivateAndShow();
		return NOERROR;
	}
	else
	{
		// set the in-place site
		pViewToActivate->SetInPlaceSite(lpInPlaceSite);
		pViewToActivate->AddRef();
	}

	// it must've created
	ASSERT(pThis->m_pView != NULL);

	// if we had an old one, release it
	if (pThis->m_pActiveView != NULL)
	{
		pThis->m_pActiveView->Show(FALSE);
		pThis->m_pActiveView->UIActivate(FALSE);
		pThis->m_pActiveView->Release();

		if (pThis->m_pIPrint != (IPrint*) -1 && pThis->m_pIPrint != NULL)
			pThis->m_pIPrint->Release();
		pThis->m_pIPrint = NULL;
	}

	// remember it for later
	pThis->m_pActiveView = pViewToActivate;

	// activate and position it
	pThis->ActivateAndShow();

	return NOERROR;
}

/////////////////////////////////////////////////////////////////////////////
// IOleDocumentSite implementation helper

void COleDocObjectItem::ActivateAndShow()
{
	// set up toolbars and menus for the object
	m_pActiveView->UIActivate(TRUE);

	// set the window size, avoiding new toolbars
	RECT rc;
	m_pView->GetClientRect(&rc);
	m_pActiveView->SetRect(&rc);

	// make everything visible
	m_pActiveView->Show(TRUE);

	return;
}

void COleDocObjectItem::OnGetItemPosition(CRect& rPosition)
{
	ASSERT_VALID(this);
	ASSERT(AfxIsValidAddress(&rPosition, sizeof(RECT)));

	// doc objects [almost] always in the exact rect of the view
	ASSERT_VALID(m_pView);
	m_pView->GetClientRect(&rPosition);
}

LPOLEDOCUMENTVIEW COleDocObjectItem::GetActiveView() const
{
	return m_pActiveView;
}

void COleDocObjectItem::Release(OLECLOSE dwCloseOption)
{
	RELEASE(m_pActiveView);
	if (m_pIPrint != (IPrint*) -1)
		RELEASE(m_pIPrint);
	COleClientItem::Release(dwCloseOption);
}

HRESULT COleDocObjectItem::ExecCommand(DWORD nCmdID,
	DWORD nCmdExecOpt /* = OLECMDEXECOPT_DONTPROMPTUSER */,
	const GUID* pguidCmdGroup /* = NULL */)
{
	LPOLECOMMANDTARGET lpCt = QUERYINTERFACE(m_lpObject, IOleCommandTarget);
	HRESULT hr = E_NOTIMPL;

	if (lpCt != NULL)
		hr = lpCt->Exec(pguidCmdGroup, nCmdID, nCmdExecOpt, NULL, NULL);

	RELEASE(lpCt);
	return hr;
}

HRESULT COleDocObjectItem::QueryCommand(ULONG nCmdID,
			DWORD* pdwStatus,
			OLECMDTEXT* pCmdText /*=NULL*/,
			const GUID* pguidCmdGroup /*=NULL*/)
{
	LPOLECOMMANDTARGET lpCt = QUERYINTERFACE(m_lpObject, IOleCommandTarget);
	HRESULT hr = E_NOTIMPL;

	if (lpCt != NULL)
	{
		OLECMD cmd;
		cmd.cmdID = nCmdID;
		cmd.cmdf = 0;
		hr = lpCt->QueryStatus(pguidCmdGroup, 1, &cmd, pCmdText);
		if (hr == S_OK)
			*pdwStatus = cmd.cmdf;
	}

	RELEASE(lpCt);
	return hr;
}

BOOL COleDocObjectItem::SupportsIPrint()
{
	// did someone already ask? -1 means we know it doesn't,
	// non-NULL means we know it does (and we point at it)
	// NULL means we don't know

	if (m_pIPrint == NULL)
	{
		// QI for it
		m_pIPrint = QUERYINTERFACE(m_lpObject, IPrint);

		if (m_pIPrint == NULL)
		{
			// if the server isn't running, we'll need to
			// start it in order to print

			if (FAILED(::OleRun(m_lpObject)))
				m_pIPrint = (IPrint*) -1;
			else
				m_pIPrint = QUERYINTERFACE(m_lpObject, IPrint);
		}
	}

	return (m_pIPrint != NULL && m_pIPrint != (IPrint*) -1);
}

BOOL COleDocObjectItem::GetPageCount(LPLONG pnFirstPage, LPLONG pcPages)
{
	if (!SupportsIPrint())
		return FALSE;

	// The proxy in DOCOBJ.DLL is broken; it doesn't allow
	// NULL parameters to IPrint::GetPageInfo(), even though the spec
	// says it should.

	LONG lPages;
	LONG lFirstPage;

	HRESULT hr = m_pIPrint->GetPageInfo(&lFirstPage, &lPages);

	if (pnFirstPage != NULL)
		*pnFirstPage = lFirstPage;
	if (pcPages != NULL)
		*pcPages = lPages;

	if (SUCCEEDED(hr))
		return TRUE;
	else
		return FALSE;
}


CMenu* COleDocObjectItem::GetHelpMenu(UINT& nPosition)
{
	CFrameWnd* pFrame = m_pView->GetTopLevelFrame();
	ENSURE(pFrame);
	CMenu* pMenuFrame = CMenu::FromHandle(pFrame->m_hMenuDefault);

	if (pMenuFrame != NULL)
		nPosition = pMenuFrame->GetMenuItemCount() -1;

	return pMenuFrame;
}

void COleDocObjectItem::OnInsertMenus(CMenu* pMenuShared,
	LPOLEMENUGROUPWIDTHS lpMenuWidths)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pMenuShared);
	ASSERT(AfxIsValidAddress(lpMenuWidths, sizeof(OLEMENUGROUPWIDTHS)));

	// initialize the group widths array
	lpMenuWidths->width[0] = 1;
	lpMenuWidths->width[2] = 0;
	lpMenuWidths->width[4] = 0;
	lpMenuWidths->width[1] = lpMenuWidths->width[1] == 0xFFFFFFFF ? 0 : lpMenuWidths->width[1];
	lpMenuWidths->width[3] = lpMenuWidths->width[3] == 0xFFFFFFFF ? 0 : lpMenuWidths->width[3];
	lpMenuWidths->width[5] = lpMenuWidths->width[5] == 0xFFFFFFFF ? 0 : lpMenuWidths->width[5];

	// get menu from document template
	CDocTemplate* pTemplate = GetDocument()->GetDocTemplate();
	HMENU hMenuOLE = pTemplate->m_hMenuInPlace;

	// only copy the popups if there is a menu loaded
	if (hMenuOLE == NULL)
		return;

	UINT nItem;
	CMenu* pMenuFrame = GetHelpMenu(nItem);

	if (pMenuFrame != NULL)
	{
		CString strHelpMenuName;
		int nSeparator = pMenuFrame->GetMenuString(nItem,
				strHelpMenuName, MF_BYPOSITION);
		if (nSeparator == 0)
		{
			TRACE(traceOle, 0, "Error: COleDocObjectItem::OnInsertMenus() found no help menu!\n");
			return;
		}

		CString strTearOffName;
		strTearOffName.Format(_T("%s %s"), AfxGetAppName(), strHelpMenuName);
		strTearOffName.Remove('&');

		// get the normal frame menu
		int nCount = pMenuFrame->GetMenuItemCount();
		HMENU hMenu = GetSubMenu(pMenuFrame->m_hMenu, nCount-1);

		// clean up old menu and allocate a new one
		if (m_pHelpPopupMenu == NULL)
		{
			m_pHelpPopupMenu = new CMenu;

			// create new sub-popup menu and add container's Help tearoff
			// then add help menu from main window
			m_pHelpPopupMenu->CreateMenu();
			m_pHelpPopupMenu->InsertMenu((UINT) -1, MF_BYPOSITION | MF_POPUP,
				(DWORD_PTR)hMenu, strTearOffName);
		}

		pMenuShared->InsertMenu((unsigned int)-1, MF_BYPOSITION | MF_POPUP,
			(UINT_PTR) m_pHelpPopupMenu->m_hMenu, strHelpMenuName);

		// tell the object we added our Help menu
		lpMenuWidths->width[5] = 1;
	}

	// insert our menu items and adjust group widths array
	AfxMergeMenus(pMenuShared->GetSafeHmenu(), hMenuOLE,
		&lpMenuWidths->width[0], 0, TRUE);
}

void COleDocObjectItem::OnRemoveMenus(CMenu *pMenuShared)
{
	int cItemsShared = pMenuShared->GetMenuItemCount();
	if (cItemsShared != 0)
	{
		CMenu *pMenuHelp = pMenuShared->GetSubMenu(cItemsShared - 1);

		if(pMenuHelp)
		{
			int cItemsHelp = pMenuHelp->GetMenuItemCount();

			int nItem;
			//remove everything but our help popup!
			for (nItem = 1;nItem<cItemsHelp; nItem++)
			{
				pMenuHelp->DeleteMenu(nItem, MF_BYPOSITION);
			}
		}

		pMenuShared->RemoveMenu(cItemsShared - 1, MF_BYPOSITION);
	}

	// get menu from document template
	COleClientItem::OnRemoveMenus(pMenuShared);
}

BOOL COleDocObjectItem::OnPreparePrinting(CView* pCaller,
	CPrintInfo* pInfo, BOOL bPrintAll)
{
	LONG lDocObjectPages = 0;

	CDocument* pDoc = pCaller->GetDocument();
	COleDocument* pOleDoc = DYNAMIC_DOWNCAST(COleDocument, pDoc);
	if (pOleDoc == NULL)
		return FALSE;

	POSITION pos = pOleDoc->GetStartPosition();
	while (pos != NULL)
	{
		COleClientItem* pItem = pOleDoc->GetNextClientItem(pos);
		COleDocObjectItem* pDocItem =
			DYNAMIC_DOWNCAST(COleDocObjectItem, pItem);
		if (pDocItem == NULL)
			continue;

		// if this isn't the view, continue
		if (!bPrintAll)
		{
			if (pItem->m_pView == NULL ||
				 pItem->m_pView->m_hWnd != pCaller->m_hWnd)
				continue;
		}

		if (pDocItem->SupportsIPrint())
		{
			LONG lThisObjectPages;
			if (pDocItem->GetPageCount(NULL, &lThisObjectPages))
				lDocObjectPages += lThisObjectPages;
			pInfo->m_bDocObject = TRUE;
		}
		else
			lDocObjectPages++;

		if (!bPrintAll)
			break;
	}

	if (lDocObjectPages > 0)
	{
		UINT nMaxPage = pInfo->GetMaxPage();

		// set the page count; increment it if previously set
		if (nMaxPage == 0xFFFF)
			pInfo->SetMaxPage(lDocObjectPages);
		else
			pInfo->SetMaxPage(nMaxPage + lDocObjectPages);
		pInfo->m_bDocObject = TRUE;
	}

	if (pInfo->m_bDocObject)
	{
		// we can't show the "selection" button for DocObjects
		pInfo->m_pPD->m_pd.Flags |= PD_NOSELECTION;

		// if it's a doc object, and we're printing all, then we
		// shouldn't show the selection
		if (bPrintAll)
			pInfo->m_pPD->m_pd.Flags |= PD_NOPAGENUMS;
	}

	return TRUE;
}

void COleDocObjectItem::OnPrint(CView* pCaller, CPrintInfo* pInfo,
	BOOL bPrintAll)
{
	// Note that this function ignores pInfo->m_nCurPage, and will always
	// print the whole range of pages in the CPrintInfo object. That's
	// because DocObjects don't support any mechanism to _continue_
	// printing to an existing print job.

	CDocument* pDoc = pCaller->GetDocument();
	COleDocument* pOleDoc = DYNAMIC_DOWNCAST(COleDocument, pDoc);
	if (pOleDoc == NULL)
		return;

	POSITION pos = pOleDoc->GetStartPosition();
	while (pos != NULL)
	{
		COleClientItem* pItem = pOleDoc->GetNextClientItem(pos);
		COleDocObjectItem* pDocItem = DYNAMIC_DOWNCAST(COleDocObjectItem, pItem);
		if (pDocItem == NULL)
			continue;

		// if this isn't the view, continue
		if (!bPrintAll)
		{
			if (pItem->m_pView == NULL || pItem->m_pView->m_hWnd != pCaller->m_hWnd)
				continue;
		}

		HRESULT hrThisPage = E_UNEXPECTED;

		if (pDocItem->SupportsIPrint())
		{
			DVTARGETDEVICE* pTargetDevice = NULL;
			LPDEVNAMES lpDevNames = NULL;
			LPDEVMODE lpDevMode = NULL;

			lpDevNames = (LPDEVNAMES) GlobalLock(pInfo->m_pPD->m_pd.hDevNames);
			if (lpDevNames != NULL)
			{
				lpDevMode = (LPDEVMODE) GlobalLock(pInfo->m_pPD->m_pd.hDevMode);
				if (lpDevMode != NULL)
				{
					pTargetDevice = _AfxOleCreateTargetDevice(lpDevNames, lpDevMode);
					if (pTargetDevice != NULL)
					{
						PAGESET* pps = (PAGESET*) CoTaskMemAlloc(sizeof(PAGESET));
						if (pps != NULL)
						{
							pps->cbStruct = sizeof(PAGESET);
							ASSERT((pps->cbStruct % 4) == 0);
							pps->fOddPages = TRUE;
							pps->fEvenPages = TRUE;
							pps->cPageRange = 1;
							pps->rgPages[0].nFromPage = pInfo->GetFromPage();
							pps->rgPages[0].nToPage = pInfo->GetToPage();

							LONG lLastPage = pps->rgPages[0].nFromPage;
							LONG lPagesPrinted;

							DWORD dwFlags = PRINTFLAG_RECOMPOSETODEVICE;

							if (pInfo->m_pPD->m_pd.Flags & PD_PRINTTOFILE)
								dwFlags |= PRINTFLAG_PRINTTOFILE;

							hrThisPage = pDocItem->m_pIPrint->Print(dwFlags,
									&pTargetDevice, &pps, NULL, NULL,
									pInfo->m_nCurPage, &lPagesPrinted,
									&lLastPage);

							if (!SUCCEEDED(hrThisPage))
								TRACE(traceOle, 0, "IPrint::Print() returned %8.8X\n", hrThisPage);
							CoTaskMemFree(pps);
						}
						CoTaskMemFree(pTargetDevice);
					}
					GlobalUnlock(pInfo->m_pPD->m_pd.hDevMode);
				}
				GlobalUnlock(pInfo->m_pPD->m_pd.hDevNames);
			}
		}
		else
		{
			// try through IOleCommandTarget

			hrThisPage = pDocItem->ExecCommand(OLECMDID_PRINT);
			if (!SUCCEEDED(hrThisPage))
				TRACE(traceOle, 0, "IOleCommandTarget::Exec() returned %8.8X\n", hrThisPage);
		}
	}

	return;
}

HRESULT COleDocObjectItem::DoDefaultPrinting(CView *pCaller, CPrintInfo *pInfo)
{
	ENSURE_VALID(pCaller);
	ENSURE_ARG(pInfo != NULL);
	COleDocObjectItem* pDocItem = NULL;
	HRESULT hr = E_FAIL;
	CDocument* pDoc = pCaller->GetDocument();
	COleDocument* pOleDoc = DYNAMIC_DOWNCAST(COleDocument, pDoc);
	if (pOleDoc == NULL)
		return hr;

	POSITION pos = pOleDoc->GetStartPosition();
	while (pos != NULL)
	{
		COleClientItem* pItem = pOleDoc->GetNextClientItem(pos);
		pDocItem = DYNAMIC_DOWNCAST(COleDocObjectItem, pItem);
		if (pDocItem != NULL)
			break;
	}

	if (!pDocItem)
		return hr;

	IOleCommandTarget *pCmdTarget = NULL;
	if (pDocItem && pDocItem->m_lpObject)
	{
		if (S_OK == (hr = pDocItem->m_lpObject->QueryInterface(IID_IOleCommandTarget, 
			(void**)&pCmdTarget)))
		{

			OLECMD cmd;
			cmd.cmdID = pInfo->m_bPreview ? OLECMDID_PRINTPREVIEW : OLECMDID_PRINT;

			if (S_OK == (hr = pCmdTarget->QueryStatus(NULL, 1, &cmd, NULL)))
			{
				if ((cmd.cmdf & (OLECMDF_SUPPORTED|OLECMDF_ENABLED)) 
					== (OLECMDF_SUPPORTED|OLECMDF_ENABLED))
				{
					hr = pCmdTarget->Exec(NULL, cmd.cmdID, OLECMDEXECOPT_PROMPTUSER,
						NULL, NULL);
					if (hr == OLECMDERR_E_CANCELED || hr == S_OK)
						hr = S_OK;
				}
			}
			pCmdTarget->Release();
		}
	}
	return hr;
}

BEGIN_OLECMD_MAP(COleDocObjectItem, COleClientItem)
END_OLECMD_MAP()

BOOL COleDocObjectItem::OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo)
{
	if (m_pView && m_pView->OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
		return TRUE;
	return COleClientItem::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\oledoc1.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// COleDocument - enables both server and client

COleDocument::COleDocument()
{
	ASSERT(m_viewList.IsEmpty());
	ASSERT(m_docItemList.IsEmpty());

#ifdef _DEBUG
	// check for common mistake of not initializing OLE libraries before
	//  creating an OLE document.
	LPMALLOC lpMalloc = NULL;
	if (::CoGetMalloc(MEMCTX_TASK, &lpMalloc) != S_OK)
	{
		TRACE(traceOle, 0, "Warning: CoGetMalloc(MEMCTX_TASK, ...) failed --\n");
		TRACE(traceOle, 0, "\tperhaps AfxOleInit() has not been called.\n");
	}
	RELEASE(lpMalloc);
#endif

	m_dwNextItemNumber = 1; // item number for first item in document
	m_bLastVisible = FALSE;

	m_bRemember = TRUE;
	m_bSameAsLoad = TRUE;
	m_lpRootStg = NULL;
	m_ptd = NULL;       // default to screen target device
	m_bCompoundFile = FALSE;

	AfxOleLockApp();
}

COleDocument::~COleDocument()
{
	ASSERT_VALID(this);

#ifdef _DEBUG
	if (!m_docItemList.IsEmpty())
		TRACE(traceOle, 0, "Warning: destroying COleDocument with %d doc items.\n",
			m_docItemList.GetCount());
#endif

	// remove all doc-items from the list before shutting down the storage
	POSITION pos = GetStartPosition();
	while (pos != NULL)
	{
		CDocItem* pItem = GetNextItem(pos);
		ASSERT(pItem != NULL);
		delete pItem;
	}

	// release the hold on the document storage
	RELEASE(m_lpRootStg);
	CoTaskMemFree(m_ptd);

	AfxOleUnlockApp();
}

/////////////////////////////////////////////////////////////////////////////
// DocItem management

void COleDocument::AddItem(CDocItem* pItem)
{
	// don't do an ASSERT_VALID until after we've added it !
	ASSERT_KINDOF(CDocItem, pItem);

	ASSERT(pItem->m_pDocument == NULL);     // not yet initialized
	m_docItemList.AddTail(pItem);
	pItem->m_pDocument = this;

	ASSERT_VALID(pItem);    // now it must be valid
}

void COleDocument::RemoveItem(CDocItem* pItem)
{
	ASSERT_VALID(pItem);    // must be valid before detach
	ASSERT_KINDOF(CDocItem, pItem);
	ASSERT(pItem->m_pDocument == this);     // formerly attached

	ASSERT(m_docItemList.Find(pItem) != NULL);  // must be in list
	m_docItemList.RemoveAt(m_docItemList.Find(pItem));
	ASSERT(m_docItemList.Find(pItem) == NULL);  // must not be in list now
	pItem->m_pDocument = NULL;
}

POSITION COleDocument::GetStartPosition() const
{
	ASSERT_VALID(this);
	return m_docItemList.GetHeadPosition();
}

CDocItem* COleDocument::GetNextItem(POSITION& pos) const
{
	// handle special case of !pos -- makes enumeration code smaller
	if (pos == NULL)
		return NULL;

	// otherwise get next item from list
	ASSERT_VALID(this);
	CDocItem* pItem = (CDocItem*)m_docItemList.GetNext(pos);
	ASSERT(pItem != NULL);
	ASSERT_KINDOF(CDocItem, pItem);
	ASSERT(pItem->m_pDocument == this);     // must be ours
	return pItem;
}

CDocItem*
COleDocument::GetNextItemOfKind(POSITION& pos, CRuntimeClass* pClass) const
{
	while (pos != NULL)
	{
		CDocItem* pItem = GetNextItem(pos);
		ASSERT_VALID(pItem);
		if (pItem->IsKindOf(pClass))
			return pItem;
	}
	return NULL;    // no suitable item found
}

COleClientItem* COleDocument::GetNextClientItem(POSITION& pos) const
{
	COleClientItem *pItem =
		(COleClientItem*)GetNextItemOfKind(pos, RUNTIME_CLASS(COleClientItem));
	return pItem;
}

COleServerItem* COleDocument::GetNextServerItem(POSITION& pos) const
{
	COleServerItem *pItem =
		(COleServerItem*)GetNextItemOfKind(pos, RUNTIME_CLASS(COleServerItem));
	return pItem;
}

void COleDocument::DeleteContents()
{
	// deletes all COleClientItem objects in the doc item list
	//  (Note: doesn't touch server items or other docitems)

	POSITION pos = GetStartPosition();
	COleClientItem* pItem;
	while ((pItem = GetNextClientItem(pos)) != NULL)
	{
		if (pItem->m_lpObject != NULL)
		{
			pItem->Release(OLECLOSE_NOSAVE);    // release OLE object
			RemoveItem(pItem);  // disconnect from document
			pItem->InternalRelease();   // may 'delete pItem'
		}
	}

	if (IsSearchAndOrganizeHandler())
	{
		// disconnect the storage
		RELEASE(m_lpRootStg);
		m_lpRootStg = NULL;
	}
}

void COleDocument::SetPathName(LPCTSTR lpszPathName, BOOL bAddToMRU)
{
	// if storage path changes, next save needs to create a new doc storage
	m_bSameAsLoad = AfxComparePath(m_strStorageName, lpszPathName);

	CDocument::SetPathName(lpszPathName, bAddToMRU);

	// update all of the objects' host names
	POSITION pos = GetStartPosition();
	COleClientItem* pItem;
	while ((pItem = GetNextClientItem(pos)) != NULL)
	{
		ENSURE(pItem->m_lpObject);

		// update that item's host names
		const CStringW strAppName(AfxGetAppName());
		const CStringW strTitle(m_strTitle);
		pItem->m_lpObject->SetHostNames(strAppName.GetString(),strTitle.GetString());
	}
}

void COleDocument::Serialize(CArchive& ar)
{
	ASSERT_VALID(this);

	// serialize all items in the doc item list
	if (ar.IsStoring())
	{
		DWORD dwCount = 0;
		POSITION pos = GetStartPosition();
		while (pos != NULL)
		{
			CDocItem* pDocItem = GetNextItem(pos);
			ASSERT_VALID(pDocItem);

			// only count non-blank ones
			if (!pDocItem->IsBlank())
				++dwCount;
		}
		ar << dwCount;  // write count of objects

		// serialize all the items in the list
		pos = GetStartPosition();
		while (pos != NULL)
		{
			CDocItem* pDocItem = GetNextItem(pos);
			ASSERT_VALID(pDocItem);

			// only write non-blank ones
			if (!pDocItem->IsBlank())
				ar << pDocItem;
		}
	}
	else
	{
		// read number of items in the file
		DWORD dwCount;
		ar >> dwCount;

		// read all of them into the list
		while (dwCount--)
		{
			CDocItem* pDocItem;
			ar >> pDocItem;     // as they are serialized, they are added!
		}
	}
}

void COleDocument::CommitItems(BOOL bSuccess, LPSTORAGE pNewStorage)
{
	// special 'Commit' phase for COleClientItem items
	POSITION pos = GetStartPosition();
	COleClientItem* pItem;
	while ((pItem = GetNextClientItem(pos)) != NULL)
	{
		// Set m_lpNewStorage so we can pass it to IPersistStorage::SaveCompleted
		// in COleClientItem::CommitItem. m_bNeedCommit was set in
		// HandsOffStorage.
		if (pItem->m_bNeedCommit && pNewStorage)
		{
			if (pItem->m_lpNewStorage)
				pItem->m_lpNewStorage->Release();
			pNewStorage->AddRef();
			pItem->m_lpNewStorage = pNewStorage;
		}
		// calling CommitItem with FALSE causes the object to revert
		//  to the original storage.  Calling CommitItem TRUE causes
		//  the item to adopt the new storage created in the Serialize
		//  function.
		pItem->CommitItem(bSuccess);
	}
}

BOOL COleDocument::HasBlankItems() const
{
	ASSERT_VALID(this);

	POSITION pos = GetStartPosition();
	while (pos != NULL)
	{
		CDocItem* pDocItem = GetNextItem(pos);
		ASSERT_VALID(pDocItem);
		if (pDocItem->IsBlank())
			return TRUE;    // blank item found
	}
	return FALSE;   // no items found that were blank
}

void COleDocument::UpdateModifiedFlag()
{
	ASSERT_VALID(this);

	POSITION pos = GetStartPosition();
	COleClientItem* pItem;
	while ((pItem = GetNextClientItem(pos)) != NULL)
	{
		if (pItem->IsModified())
		{
			SetModifiedFlag();
			break;
		}
	}
}

void COleDocument::PreCloseFrame(CFrameWnd* pFrameArg)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pFrameArg);

	// deactivate any inplace active items on this frame
	COleClientItem* pItem = GetInPlaceActiveItem(pFrameArg);
	if (pItem != NULL)
	{
		pItem->Deactivate();
		pItem->Close(OLECLOSE_NOSAVE);
	}

	// should not have any inplace active items
	ASSERT(GetInPlaceActiveItem(pFrameArg) == NULL);
}

BOOL COleDocument::DoSave(LPCTSTR lpszPathName, BOOL bReplace)
{
	BOOL bRemember = m_bRemember;
	m_bRemember = bReplace;
	BOOL bRet = CDocument::DoSave(lpszPathName, bReplace);
	m_bRemember = bRemember;
	return bRet;
}

BOOL COleDocument::SaveModified()
{
	// determine if necessary to discard changes
	if (::InSendMessage())
	{
		POSITION pos = GetStartPosition();
		COleClientItem* pItem;
		while ((pItem = GetNextClientItem(pos)) != NULL)
		{
			ASSERT(pItem->m_lpObject != NULL);
			SCODE sc = pItem->m_lpObject->IsUpToDate();
			if (sc != OLE_E_NOTRUNNING && FAILED(sc))
			{
				// inside inter-app SendMessage limits the user's choices
				CString name = m_strPathName;
				if (name.IsEmpty())
					VERIFY(name.LoadString(AFX_IDS_UNTITLED));

				CString prompt;
				AfxFormatString1(prompt, AFX_IDP_ASK_TO_DISCARD, name);
				return AfxMessageBox(prompt, MB_OKCANCEL|MB_DEFBUTTON2,
					AFX_IDP_ASK_TO_DISCARD) == IDOK;
			}
		}
	}

	// sometimes items change without a notification, so we have to
	//  update the document's modified flag before calling
	//  CDocument::SaveModified.
	UpdateModifiedFlag();

	return CDocument::SaveModified();
}

void COleDocument::OnShowViews(BOOL /*bVisible*/)
{
	// no default implementation
}

void COleDocument::OnIdle()
{
	ASSERT_VALID(this);

	if (IsSearchAndOrganizeHandler())
	{
		// do nothing for Search and Organize handlers
		return;
	}

	// Call the base class.  If autosave is enabled for the
	// application, the base class handles the autosaving.
	CDocument::OnIdle();

	// determine if any visible views are on this document
	BOOL bVisible = FALSE;
	POSITION pos = GetFirstViewPosition();
	while (pos != NULL)
	{
		CView* pView = GetNextView(pos);
		ENSURE_VALID(pView);
		CFrameWnd* pFrameWnd = pView->EnsureParentFrame();
		if (pFrameWnd->GetStyle() & WS_VISIBLE)
		{
			bVisible = TRUE;
			break;
		}
	}

	// when state has changed, call OnShowViews
	if (bVisible != m_bLastVisible)
	{
		OnShowViews(bVisible);
		m_bLastVisible = bVisible;
	}
}

/////////////////////////////////////////////////////////////////////////////
// COleDocument -> window mapping

CFrameWnd* COleDocument::GetFirstFrame()
{
	ASSERT_VALID(this);

	// get position of first view in the document
	POSITION pos = GetFirstViewPosition();

	// get view at that position
	CView* pView = GetNextView(pos);
	if (pView == NULL)
		return NULL;
	ASSERT_VALID(pView);

	// return the first frame window that is a parent of that view
	CFrameWnd* pFrameWnd = (CFrameWnd*)pView->GetParentFrame();
	ASSERT_VALID(pFrameWnd);
	ASSERT_KINDOF(CFrameWnd, pFrameWnd);
	return pFrameWnd;
}

/////////////////////////////////////////////////////////////////////////////
// COleDocument helpers

LPMONIKER COleDocument::GetMoniker(OLEGETMONIKER /*nAssign*/)
{
	ASSERT_VALID(this);

	// no moniker for untitled documents
	if (m_strPathName.IsEmpty())
		return NULL;

	// return file moniker based on current path name
	const CStringW strPathNameW(m_strPathName);
	LPMONIKER lpMoniker;
	CreateFileMoniker(strPathNameW.GetString(), &lpMoniker);
	return lpMoniker;
}

LPOLEITEMCONTAINER COleDocument::GetContainer()
{
	// COleDocument doesn't support IOleClientSite::GetContainer

	return NULL;
}

/////////////////////////////////////////////////////////////////////////////
// 'Compound File' enabling in COleDocument

BOOL COleDocument::OnNewDocument()
{
	// call base class, which destroys all items
	if (!CDocument::OnNewDocument())
		return FALSE;

	// for file-based compound files, need to create temporary file
	if (m_bCompoundFile && !m_bEmbedded)
	{
		// abort changes to the current docfile
		RELEASE(m_lpRootStg);

		// create new temporary docfile
		LPSTORAGE lpStorage;
		SCODE sc = ::StgCreateDocfile(NULL, STGM_DELETEONRELEASE|
			STGM_READWRITE|STGM_TRANSACTED|STGM_SHARE_EXCLUSIVE|STGM_CREATE,
			0, &lpStorage);
		if (sc != S_OK)
			return FALSE;

		ASSERT(lpStorage != NULL);
		m_lpRootStg = lpStorage;
	}

	return TRUE;
}

BOOL COleDocument::OnOpenDocument(LPCTSTR lpszPathName)
{
	ASSERT(lpszPathName == NULL || AfxIsValidString(lpszPathName));

	// just use default implementation if 'docfile' not enabled
	if (!m_bCompoundFile && m_lpRootStg == NULL)
	{
		ASSERT(lpszPathName != NULL);
		return CDocument::OnOpenDocument(lpszPathName);
	}

	if (IsModified())
		TRACE(traceOle, 0, "Warning: OnOpenDocument replaces an unsaved document.\n");

	// abort changes to current docfile
	if (lpszPathName != NULL)
	{
		DeleteContents();
		RELEASE(m_lpRootStg);
	}
	SetModifiedFlag();  // dirty during de-serialize

	BOOL bResult = FALSE;
	TRY
	{
		if (m_lpRootStg == NULL)
		{
			const CStringW strPathName(lpszPathName);
			LPCOLESTR lpsz = lpszPathName ? strPathName.GetString() : NULL;

			// use STGM_CONVERT if necessary
			SCODE sc;
			LPSTORAGE lpStorage = NULL;
			if (StgIsStorageFile(lpsz) == S_FALSE)
			{
				// convert existing storage file
				sc = StgCreateDocfile(lpsz, STGM_READWRITE|
					STGM_TRANSACTED|STGM_SHARE_DENY_WRITE|STGM_CONVERT,
					0, &lpStorage);
			}
			else
			{
				// open new storage file
				sc = StgOpenStorage(lpsz, NULL, STGM_READWRITE|STGM_TRANSACTED|STGM_SHARE_DENY_WRITE,0, 0, &lpStorage);
				if (FAILED(sc) || lpStorage == NULL)
					sc = StgOpenStorage(lpsz, NULL, STGM_READ|STGM_TRANSACTED, 0, 0, &lpStorage);
				if (FAILED(sc) || lpStorage == NULL)
					sc = StgOpenStorage(lpsz, NULL, STGM_READ|STGM_PRIORITY, 0, 0, &lpStorage);
			}
			if (FAILED(sc))
				AfxThrowOleException(sc);

			ASSERT(lpStorage != NULL);
			m_lpRootStg = lpStorage;
		}

		// use helper to read document from storage
		LoadFromStorage();

		SetModifiedFlag(FALSE); // start off with unmodified
		bResult = TRUE;
	}
	CATCH_ALL(e)
	{
		DeleteContents();   // removed failed contents
		RELEASE(m_lpRootStg);

		// if not file-based load, return exceptions to the caller
		if (lpszPathName == NULL)
		{
			THROW_LAST();
		}

		TRY
		{
			ReportSaveLoadException(lpszPathName, e,
				FALSE, AFX_IDP_FAILED_TO_OPEN_DOC);
		}
		END_TRY
		DELETE_EXCEPTION(e);
	}
	END_CATCH_ALL

	m_strPathName = lpszPathName;
	m_strStorageName = lpszPathName;
	return bResult;
}

BOOL COleDocument::OnSaveDocument(LPCTSTR lpszPathName)
	// lpszPathName must be fully qualified
{
	ASSERT(lpszPathName == NULL || AfxIsValidString(lpszPathName));

	// use default implementation if 'docfile' not enabled
	if (!m_bCompoundFile && m_lpRootStg == NULL)
	{
		ASSERT(lpszPathName != NULL);
		return CDocument::OnSaveDocument(lpszPathName);
	}

	LPSTORAGE lpOrigStg = NULL;

	if (lpszPathName != NULL)
	{
		m_bSameAsLoad = AfxComparePath(m_strPathName, lpszPathName);
	}

	BOOL bResult = FALSE;
	TRY
	{
		// open new root storage if necessary
		if (lpszPathName != NULL && !m_bSameAsLoad)
		{
			// temporarily detach current storage
			lpOrigStg = m_lpRootStg;
			m_lpRootStg = NULL;

			LPSTORAGE lpStorage;
			const CStringW strPathName(lpszPathName);
			SCODE sc = ::StgCreateDocfile(strPathName.GetString(),
				STGM_READWRITE|STGM_TRANSACTED|STGM_SHARE_DENY_WRITE|STGM_CREATE,
				0, &lpStorage);
			if (sc != S_OK)
				AfxThrowOleException(sc);

			ASSERT(lpStorage != NULL);
			m_lpRootStg = lpStorage;
		}
		ASSERT(m_lpRootStg != NULL);

		// use helper to save to root storage
		SaveToStorage();

		if (lpszPathName != NULL)
		{
			// commit each of the items
			CommitItems(m_bRemember && !m_bSameAsLoad);

			// mark document as clean if remembering the storage
			if (m_bRemember)
			{
				SetModifiedFlag(FALSE);
				m_strPathName = lpszPathName;
				m_strStorageName = lpszPathName;
			}

			// remember correct storage or release save copy as storage
			if (!m_bSameAsLoad)
			{
				if (m_bRemember)
				{
					// Save As case -- m_stgRoot is new storage, forget old storage
					lpOrigStg->Release();
				}
				else
				{
					// Save Copy As case -- m_stgRoot should hook up to m_stgOrig.
					m_lpRootStg->Release();
					m_lpRootStg = lpOrigStg;
				}
			}
		}

		bResult = TRUE;
	}
	CATCH_ALL(e)
	{
		if (lpOrigStg != NULL)
		{
			// save as failed: abort new storage, and re-attach original
			RELEASE(m_lpRootStg);
			m_lpRootStg = lpOrigStg;
		}

		if (lpszPathName == NULL)
		{
			THROW_LAST();
		}

		TRY
		{
			ReportSaveLoadException(lpszPathName, e,
				TRUE, AFX_IDP_FAILED_TO_SAVE_DOC);
		}
		END_TRY
		DELETE_EXCEPTION(e);
	}
	END_CATCH_ALL

	// cleanup
	m_bSameAsLoad = TRUE;
	m_bRemember = TRUE;

	return bResult;
}

void COleDocument::OnCloseDocument()
{
	// SO handler (rich preview) can be destroyed only from FinalRelease 
	if (IsSearchAndOrganizeHandler() && !m_bFinalRelease)
	{
		return;
	}
	// close the document without deleting the memory
	BOOL bAutoDelete = m_bAutoDelete;
	m_bAutoDelete = FALSE;
	CDocument::OnCloseDocument();

	// release storage since document has been closed
	RELEASE(m_lpRootStg);

	// delete the document if necessary
	if (bAutoDelete)
		delete this;
}

/////////////////////////////////////////////////////////////////////////////
// Helpers for saving to IStorage based files
//  (these are used in the 'docfile' implementation as well as for servers)

void COleDocument::SaveToStorage(CObject* pObject)
{
	ASSERT(m_lpRootStg != NULL);

	// create Contents stream
	COleStreamFile file;
	CFileException fe;
	if (!file.CreateStream(m_lpRootStg, _T("Contents"),
			CFile::modeReadWrite|CFile::shareExclusive|CFile::modeCreate, &fe))
	{
		if (fe.m_cause == CFileException::fileNotFound)
			AfxThrowArchiveException(CArchiveException::badSchema);
		else
			AfxThrowFileException(fe.m_cause, fe.m_lOsError);
	}

	// save to Contents stream
	CArchive saveArchive(&file, CArchive::store | CArchive::bNoFlushOnDelete);
	saveArchive.m_pDocument = this;
	saveArchive.m_bForceFlat = FALSE;

	TRY
	{
		// save the contents
		if (pObject != NULL)
			pObject->Serialize(saveArchive);
		else
			Serialize(saveArchive);
		saveArchive.Close();
		file.Close();

		// commit the root storage
		SCODE sc = m_lpRootStg->Commit(STGC_ONLYIFCURRENT);
		if (sc != S_OK)
			AfxThrowOleException(sc);
	}
	CATCH_ALL(e)
	{
		file.Abort();   // will not throw an exception
		CommitItems(FALSE); // abort save in progress
		NO_CPP_EXCEPTION(saveArchive.Abort());
		THROW_LAST();
	}
	END_CATCH_ALL
}

void COleDocument::LoadFromStorage()
{
	ASSERT(m_lpRootStg != NULL);

	// open Contents stream
	COleStreamFile file;
	CFileException fe;
	if (!file.OpenStream(m_lpRootStg, _T("Contents"),
			CFile::modeRead|CFile::shareExclusive, &fe) &&
		!file.CreateStream(m_lpRootStg, _T("Contents"),
			CFile::modeRead|CFile::shareExclusive|CFile::modeCreate, &fe))
	{
		if (fe.m_cause == CFileException::fileNotFound)
			AfxThrowArchiveException(CArchiveException::badSchema);
		else
			AfxThrowFileException(fe.m_cause, fe.m_lOsError);
	}

	// load it with CArchive (loads from Contents stream)
	CArchive loadArchive(&file, CArchive::load | CArchive::bNoFlushOnDelete);
	loadArchive.m_pDocument = this;
	loadArchive.m_bForceFlat = FALSE;

	TRY
	{
		if (file.GetLength() != 0)
			Serialize(loadArchive);     // load main contents
		loadArchive.Close();
		file.Close();
	}
	CATCH_ALL(e)
	{
		file.Abort();   // will not throw an exception
		DeleteContents();   // removed failed contents
		NO_CPP_EXCEPTION(loadArchive.Abort());
		THROW_LAST();
	}
	END_CATCH_ALL
}

HRESULT COleDocument::OnLoadDocumentFromStream(IStream* pStream, DWORD grfMode)
{
	UNREFERENCED_PARAMETER(grfMode);
	ASSERT(pStream != NULL);

	if (pStream == NULL)
	{
		TRACE0("Error: COleDocument::OnLoadDocumentFromStream failed with pStream = NULL.");
		return E_INVALIDARG;
	}

	if (!m_bCompoundFile)
	{
		COleStreamFile file;
		file.Attach(pStream);

		CArchive ar(&file, CArchive::load);
		Serialize(ar);

		file.Detach();
		return S_OK;
	}

	HRESULT hr = S_OK;

	LPSTORAGE lpStorage     = NULL;
	LPLOCKBYTES lpLockBytes = NULL;

	TRY
	{
		SCODE sc;
		{
			COleStreamFile file;
			file.Attach(pStream);
			ULONGLONG length = file.GetLength();
			if (length != 0)
			{
				HGLOBAL hGlobal = ::GlobalAlloc(GMEM_MOVEABLE | GMEM_NODISCARD, (SIZE_T)length);
				if (hGlobal != NULL)
				{
					LPVOID pBuffer = ::GlobalLock(hGlobal);
					ASSERT(pBuffer != NULL);

					file.Read(pBuffer, (UINT)length);
					::GlobalUnlock(hGlobal);

					sc = ::CreateILockBytesOnHGlobal(hGlobal, TRUE, &lpLockBytes);
					if (FAILED(sc))
					{
						TRACE1("Error: CreateILockBytesOnHGlobal failed with code: %d", sc);
						::GlobalFree(hGlobal);
						AfxThrowOleException(sc);
					}
				}
			}
			file.Detach();
		}

		if (lpLockBytes != NULL)
		{
			sc = ::StgOpenStorageOnILockBytes(lpLockBytes, NULL,
				STGM_READ | STGM_PRIORITY, NULL, 0, &lpStorage);

			if (FAILED(sc))
			{
				TRACE1("Error: StgOpenStorageOnILockBytes failed with code: %d", sc);
				lpLockBytes->Release();
				lpLockBytes = NULL;
				AfxThrowOleException(sc);
			}
		}

		if (lpStorage != NULL)
		{
			m_lpRootStg = lpStorage;
			LoadFromStorage();
		}
	}
	CATCH_ALL(e)
	{
		DELETE_EXCEPTION(e);
		hr = E_FAIL;
	}
	END_CATCH_ALL
	
	if (lpLockBytes != NULL)
	{
		lpLockBytes->Release();
		lpLockBytes = NULL;
	}

	return hr;
}
/////////////////////////////////////////////////////////////////////////////
// COleDocument diagnostics

#ifdef _DEBUG
void COleDocument::AssertValid() const
{
	CDocument::AssertValid();

	ASSERT(m_ptd == NULL || AfxIsValidAddress(m_ptd, (size_t)m_ptd->tdSize, FALSE));
	ASSERT_VALID(&m_docItemList);
	ASSERT(!m_bEmbedded || m_strPathName.IsEmpty());
}

void COleDocument::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);

	dc << "with " << m_docItemList.GetCount() << " doc items";
	dc << "\nm_dwNextItemNumber = " << m_dwNextItemNumber;
	dc << "\nm_bLastVisible = " << m_bLastVisible;
	dc << "\nm_bEmbedded = " << m_bEmbedded;
	dc << "\nm_lpRootStg = " << m_lpRootStg;
	dc << "\nm_bSameAsLoad = " << m_bSameAsLoad;
	dc << "\nm_bRemember = " << m_bRemember;
	dc << "\nm_ptd = " << m_ptd;

	dc << "\n";
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CDocItem

CDocItem::CDocItem()
{
	m_pDocument = NULL;
}

CDocItem::~CDocItem()
{
	ASSERT(m_pDocument == NULL);    // must be detached from document
}

void CDocItem::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
		ASSERT_VALID(m_pDocument);
		// nothing to do, there is no data
	}
	else
	{
		// if no document connected yet, attach it from the archive
		if (m_pDocument == NULL)
		{
			COleDocument* pContainerDoc = (COleDocument*)ar.m_pDocument;
			ASSERT_VALID(pContainerDoc);
			ASSERT_KINDOF(COleDocument, pContainerDoc);
			pContainerDoc->AddItem(this);
			ASSERT(pContainerDoc == m_pDocument);
		}
	}
	// perform ASSERT_VALID at the end because COleServerItem::AssertValid
	// checks the validity of the m_pDocument pointer
	ASSERT_VALID(this);
}

BOOL CDocItem::IsBlank() const
{
	// by default, a CDocItem is not blank. COleClientItem is sometimes blank!
	//  (a COleServerItem is blank by default)
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CDocItem diagnostics

#ifdef _DEBUG
void CDocItem::AssertValid() const
{
	CObject::AssertValid();
	if (m_pDocument != NULL)
		m_pDocument->AssertValid();
}

void CDocItem::Dump(CDumpContext& dc) const
{
	CCmdTarget::Dump(dc);

	dc << "m_pDocument = " << (void*)m_pDocument;
	dc << "\n";
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations expanded out-of-line

#ifndef _AFX_ENABLE_INLINES

// expand inlines for OLE general APIs
#define _AFXOLE_INLINE
#include "afxole.inl"

#endif //!_AFX_ENABLE_INLINES


IMPLEMENT_SERIAL(CDocItem, CCmdTarget, 0)
IMPLEMENT_DYNAMIC(COleDocument, CDocument)

// These IMPLEMENT_DYNAMICs here for .OBJ granularity reasons.
IMPLEMENT_DYNAMIC(COleClientItem, CDocItem)
IMPLEMENT_DYNAMIC(COleServerItem, CDocItem)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\oledoc2.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



/////////////////////////////////////////////////////////////////////////////
// COleDocument printing support

BOOL COleDocument::ApplyPrintDevice(const DVTARGETDEVICE* ptd)
{
	ASSERT_VALID(this);
	ASSERT(ptd == NULL || AfxIsValidAddress(ptd, (size_t)ptd->tdSize, FALSE));

	// allocate copy of target device
	if (ptd != NULL)
	{
		DVTARGETDEVICE* ptdNew = _AfxOleCopyTargetDevice((DVTARGETDEVICE*)ptd);
		if (ptdNew == NULL)
			return FALSE;
		ptd = ptdNew;
	}
	// remove old target device from memory
	CoTaskMemFree(m_ptd);
	m_ptd = (DVTARGETDEVICE*)ptd;

	// Note: updating all the client items does not refresh the pres. cache
	POSITION pos = GetStartPosition();
	COleClientItem* pItem;
	while ((pItem = GetNextClientItem(pos)) != NULL)
	{
		// update all the client items with new target device
		pItem->SetPrintDevice(ptd);
	}
	return TRUE;
}

BOOL COleDocument::ApplyPrintDevice(const PRINTDLG* ppd)
{
	ASSERT_VALID(this);
	ASSERT(ppd == NULL || AfxIsValidAddress(ppd, sizeof(*ppd), FALSE));
	DVTARGETDEVICE* ptd = NULL;
	if (ppd != NULL)
		ptd = _AfxOleCreateTargetDevice((PRINTDLG*)ppd);

	BOOL bResult = ApplyPrintDevice(ptd);
	CoTaskMemFree(ptd);
	return bResult;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\oledocip.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#ifdef _DEBUG

#endif

#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// COleDocIPFrameWnd

IMPLEMENT_DYNCREATE(COleDocIPFrameWnd, COleIPFrameWnd)

BEGIN_MESSAGE_MAP(COleDocIPFrameWnd, COleIPFrameWnd)
	//{{AFX_MSG_MAP(COleDocIPFrameWnd)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

COleDocIPFrameWnd::COleDocIPFrameWnd()
{
	m_hMenuHelpPopup = NULL;
}

COleDocIPFrameWnd::~COleDocIPFrameWnd()
{
}

void COleDocIPFrameWnd::OnRequestPositionChange(LPCRECT lpRect)
{
	COleServerDoc* pDoc = (COleServerDoc*) GetActiveDocument();
	ASSERT_VALID(pDoc);
	ASSERT_KINDOF(COleServerDoc, pDoc);

	// DocObjects don't need to generate OnPosRectChange calls, so we
	// just return if this is a DocObject.

	if (pDoc->IsDocObject())
		return;

	// The default behavior is to not affect the extent during the
	//  call to RequestPositionChange.  This results in consistent
	//  scaling behavior.
	pDoc->RequestPositionChange(lpRect);
}

void COleDocIPFrameWnd::RecalcLayout(BOOL /*bNotify*/)
{
	ASSERT_VALID(this);

	COleServerDoc* pDoc = (COleServerDoc*) GetActiveDocument();
	if (pDoc != NULL)
	{
		ASSERT_VALID(pDoc);
		ASSERT_KINDOF(COleServerDoc, pDoc);
	}

	// Normal in-place objects put scrollbars on the outside,
	//  DocObjects put them inside
	UINT nAdjustType = (pDoc != NULL && pDoc->IsDocObject())
								? CWnd::adjustBorder : CWnd::adjustOutside;

	// better have a parent window (only used for inplace)
	CWnd* pParentWnd = GetParent();
	ASSERT_VALID(pParentWnd);

	// first call reposition bars with arbitarily large rect just to
	//  see how much space the bars will take up
	CRect rectBig(0, 0, INT_MAX/2, INT_MAX/2);
	CRect rectLeft;
	RepositionBars(0, 0xffff, AFX_IDW_PANE_FIRST, reposQuery,
		&rectLeft, &rectBig);

	// grow the rect by the size of the control bars
	CRect rect = m_rectPos;
	rect.left -= rectLeft.left;
	rect.top -= rectLeft.top;
	rect.right += INT_MAX/2 - rectLeft.right;
	rect.bottom += INT_MAX/2 - rectLeft.bottom;

	// see how much extra space for non-client areas (such as scrollbars)
	//  that the view needs.
	CWnd* pLeftOver = GetDlgItem(AFX_IDW_PANE_FIRST);
	if (pLeftOver != NULL)
	{
		rectBig = m_rectPos;
		pLeftOver->CalcWindowRect(&rectBig, nAdjustType);
		rect.left -= m_rectPos.left - rectBig.left;
		rect.top -= m_rectPos.top - rectBig.top;
		rect.right += rectBig.right - m_rectPos.right;
		rect.bottom += rectBig.bottom - m_rectPos.bottom;
	}

	// adjust for non-client area on the frame window
	CalcWindowRect(&rect, nAdjustType);

	// the frame window must be clipped to the visible part in the container
	CRect rectVis;
	rectVis.IntersectRect(&rect, &m_rectClip);

	// move the window
	AfxRepositionWindow(NULL, m_hWnd, &rectVis);

	// now resize the control bars relative to the (now moved) frame
	pParentWnd->ClientToScreen(&rect);
	ScreenToClient(&rect);
	RepositionBars(0, 0xffff, AFX_IDW_PANE_FIRST,
		CWnd::reposDefault, NULL, &rect);
}

BOOL COleDocIPFrameWnd::BuildSharedMenu()
{
	HMENU hMenu = GetInPlaceMenu();

	// create shared menu
	ASSERT(m_hSharedMenu == NULL);
	if ((m_hSharedMenu = ::CreateMenu()) == NULL)
		return FALSE;

	// start out by getting menu from container
	memset(&m_menuWidths, 0, sizeof m_menuWidths);
	if (m_lpFrame->InsertMenus(m_hSharedMenu, &m_menuWidths) != NOERROR)
	{
		::DestroyMenu(m_hSharedMenu);
		m_hSharedMenu = NULL;
		return FALSE;
	}

	// only copy the popups if there is a menu loaded
	if (hMenu == NULL)
		return TRUE;

	// insert our menu popups amongst the container menus
	m_hMenuHelpPopup = AfxMergeMenus(m_hSharedMenu, hMenu,
		&m_menuWidths.width[0], 1, TRUE);

	// finally create the special OLE menu descriptor
	m_hOleMenu = ::OleCreateMenuDescriptor(m_hSharedMenu, &m_menuWidths);

	return m_hOleMenu != NULL;
}

void COleDocIPFrameWnd::DestroySharedMenu()
{
	if (m_hSharedMenu == NULL)
	{
		ASSERT(m_hOleMenu == NULL);
		ASSERT(m_hMenuHelpPopup == NULL);
		return;
	}

	// get in-place menu to be unmerged (must be same as during activation)
	HMENU hMenu = GetInPlaceMenu();
	if (hMenu == NULL)
		return;

	// remove our menu popups from the shared menu
	AfxUnmergeMenus(m_hSharedMenu, hMenu, m_hMenuHelpPopup);

	// allow container to remove its items from the menu
	ASSERT(m_lpFrame != NULL);
	VERIFY(m_lpFrame->RemoveMenus(m_hSharedMenu) == NOERROR);

	// now destroy the menu
	::DestroyMenu(m_hSharedMenu);
	m_hSharedMenu = NULL;
	if (m_hOleMenu != NULL)
	{
		VERIFY(::OleDestroyMenuDescriptor(m_hOleMenu) == NOERROR);
		m_hOleMenu = NULL;
	}
	m_hMenuHelpPopup = NULL;
}

/////////////////////////////////////////////////////////////////////////////
// COleDocIPFrameWnd diagnostics

#ifdef _DEBUG
void COleDocIPFrameWnd::AssertValid() const
{
	COleIPFrameWnd::AssertValid();
}

void COleDocIPFrameWnd::Dump(CDumpContext& dc) const
{
	COleIPFrameWnd::Dump(dc);
}
#endif //_DEBUG


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\oledrop1.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// COleDropSource implementation

AFX_DATADEF UINT COleDropSource::nDragMinDist = 0;
AFX_DATADEF UINT COleDropSource::nDragDelay = 0;

COleDropSource::COleDropSource()
{
	m_bDragStarted = FALSE;
	m_dwButtonCancel = 0;
	m_dwButtonDrop = 0;

	AfxLockGlobals(CRIT_DROPSOURCE);
	static BOOL bInitialized;
	if (!bInitialized)
	{
		// get drag metrics from win.ini
		static const TCHAR szWindows[] = _T("windows");
		static const TCHAR szDragMinDist[] = _T("DragMinDist");
		static const TCHAR szDragDelay[] = _T("DragDelay");

		nDragMinDist = GetProfileInt(szWindows, szDragMinDist, DD_DEFDRAGMINDIST);
		nDragDelay = GetProfileInt(szWindows, szDragDelay, DD_DEFDRAGDELAY);

		// now initialized, no need to call Initialize any more
		bInitialized = TRUE;
	}
	AfxUnlockGlobals(CRIT_DROPSOURCE);

	ASSERT_VALID(this);
}

SCODE COleDropSource::QueryContinueDrag(BOOL bEscapePressed, DWORD dwKeyState)
{
	ASSERT_VALID(this);

	// check escape key or right button -- and cancel
	if (bEscapePressed || (dwKeyState & m_dwButtonCancel) != 0)
	{
		m_bDragStarted = FALSE; // avoid unecessary cursor setting
		return DRAGDROP_S_CANCEL;
	}

	// check left-button up to end drag/drop and do the drop
	if ((dwKeyState & m_dwButtonDrop) == 0)
		return m_bDragStarted ? DRAGDROP_S_DROP : DRAGDROP_S_CANCEL;

	// otherwise, keep polling...
	return S_OK;
}

SCODE COleDropSource::GiveFeedback(DROPEFFECT /*dropEffect*/)
{
	ASSERT_VALID(this);

	// don't change the cursor until drag is officially started
	return m_bDragStarted ? DRAGDROP_S_USEDEFAULTCURSORS : S_OK;
}

BOOL COleDropSource::OnBeginDrag(CWnd* pWnd)
{
	ASSERT_VALID(this);

	m_bDragStarted = FALSE;

	// opposite button cancels drag operation
	m_dwButtonCancel = 0;
	m_dwButtonDrop = 0;
	if (GetKeyState(VK_LBUTTON) < 0)
	{
		m_dwButtonDrop |= MK_LBUTTON;
		m_dwButtonCancel |= MK_RBUTTON;
	}
	else if (GetKeyState(VK_RBUTTON) < 0)
	{
		m_dwButtonDrop |= MK_RBUTTON;
		m_dwButtonCancel |= MK_LBUTTON;
	}

	DWORD dwLastTick = GetTickCount();
	pWnd->SetCapture();

	while (!m_bDragStarted)
	{
		// some applications steal capture away at random times
		if (CWnd::GetCapture() != pWnd)
			break;

		// peek for next input message
		MSG msg;
		if (PeekMessage(&msg, NULL, WM_MOUSEFIRST, AFX_WM_MOUSELAST, PM_REMOVE) ||
			PeekMessage(&msg, NULL, WM_KEYFIRST, WM_KEYLAST, PM_REMOVE))
		{
			// check for button cancellation (any button down will cancel)
			if (msg.message == WM_LBUTTONUP || msg.message == WM_RBUTTONUP ||
				msg.message == WM_LBUTTONDOWN || msg.message == WM_RBUTTONDOWN)
				break;

			// check for keyboard cancellation
			if (msg.message == WM_KEYDOWN && msg.wParam == VK_ESCAPE)
				break;

			// check for drag start transition
			m_bDragStarted = !m_rectStartDrag.PtInRect(msg.pt);
		}

		// if the user sits here long enough, we eventually start the drag
		if (GetTickCount() - dwLastTick > nDragDelay)
			m_bDragStarted = TRUE;
	}
	ReleaseCapture();

	return m_bDragStarted;
}

BEGIN_INTERFACE_MAP(COleDropSource, CCmdTarget)
	INTERFACE_PART(COleDropSource, IID_IDropSource, DropSource)
END_INTERFACE_MAP()

STDMETHODIMP_(ULONG) COleDropSource::XDropSource::AddRef()
{
	METHOD_PROLOGUE_EX_(COleDropSource, DropSource)
	return pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) COleDropSource::XDropSource::Release()
{
	METHOD_PROLOGUE_EX_(COleDropSource, DropSource)
	return pThis->ExternalRelease();
}

STDMETHODIMP COleDropSource::XDropSource::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(COleDropSource, DropSource)
	return pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP COleDropSource::XDropSource::QueryContinueDrag(
	THIS_ BOOL fEscapePressed, DWORD dwKeyState)
{
	METHOD_PROLOGUE_EX_(COleDropSource, DropSource)

	return pThis->QueryContinueDrag(fEscapePressed, dwKeyState);
}

STDMETHODIMP COleDropSource::XDropSource::GiveFeedback(THIS_ DWORD dwEffect)
{
	METHOD_PROLOGUE_EX(COleDropSource, DropSource)
	ASSERT_VALID(pThis);

	return pThis->GiveFeedback(dwEffect);
}

/////////////////////////////////////////////////////////////////////////////
// helper for doing drag/drop with COleDataSource object

DROPEFFECT COleDataSource::DoDragDrop(DWORD dwEffects,
	LPCRECT lpRectStartDrag, COleDropSource* pDropSource)
{
	ASSERT_VALID(this);
	if (pDropSource != NULL)
		ASSERT_VALID(pDropSource);
	ASSERT(lpRectStartDrag == NULL ||
		AfxIsValidAddress(lpRectStartDrag, sizeof(RECT), FALSE));

	// use standard drop source implementation if one not provided
	COleDropSource dropSource;
	if (pDropSource == NULL)
		pDropSource = &dropSource;

	// setup drag/drop sensitivity rect
	pDropSource->m_bDragStarted = FALSE;

	if (lpRectStartDrag != NULL)
	{
		// set drop source drag start rect to parameter provided
		pDropSource->m_rectStartDrag.CopyRect(lpRectStartDrag);
	}
	else
	{
		// otherwise start with default empty rectangle around current point
		CPoint ptCursor;
		GetCursorPos(&ptCursor);
		pDropSource->m_rectStartDrag.SetRect(
			ptCursor.x, ptCursor.y, ptCursor.x, ptCursor.y);
	}

	if (pDropSource->m_rectStartDrag.IsRectNull())
	{
		// null rect specifies no OnBeginDrag wait loop
		pDropSource->m_bDragStarted = TRUE;
	}
	else if (pDropSource->m_rectStartDrag.IsRectEmpty())
	{
		// empty rect specifies drag drop around starting point
		pDropSource->m_rectStartDrag.InflateRect(
			COleDropSource::nDragMinDist, COleDropSource::nDragMinDist);
	}
	ASSERT_VALID(pDropSource);

	// before calling OLE drag/drop code, wait for mouse to move outside
	//  the rectangle
	ASSERT_VALID(AfxGetMainWnd());
	if (!pDropSource->OnBeginDrag(AfxGetMainWnd()))
		return DROPEFFECT_NONE;

	// call global OLE api to do the drag drop
	LPDATAOBJECT lpDataObject = (LPDATAOBJECT)GetInterface(&IID_IDataObject);
	LPDROPSOURCE lpDropSource =
		(LPDROPSOURCE)pDropSource->GetInterface(&IID_IDropSource);
	DWORD dwResultEffect = DROPEFFECT_NONE;
	::DoDragDrop(lpDataObject, lpDropSource, dwEffects, &dwResultEffect);
	return dwResultEffect;
}

/////////////////////////////////////////////////////////////////////////////
// COleDropSource diagnostics

#ifdef _DEBUG
void COleDropSource::Dump(CDumpContext& dc) const
{
	CCmdTarget::Dump(dc);

	dc << "m_bDragStarted = " << m_bDragStarted;
	dc << "\nm_rectStartDrag.left = " << m_rectStartDrag.left;
	dc << "\nm_rectStartDrag.top = " << m_rectStartDrag.top;
	dc << "\nm_rectStartDrag.right = " << m_rectStartDrag.right;
	dc << "\nm_rectStartDrag.bottom = " << m_rectStartDrag.bottom;

	dc << "\n";
}
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\oledoctg.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#ifdef _DEBUG

#endif

#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// COleCmdUI class

COleCmdUI::COleCmdUI(OLECMD* rgCmds, ULONG cCmds, const GUID* pGroup)
{
	m_rgCmds = rgCmds;
	m_nIndexMax = cCmds;
	m_pguidCmdGroup = pGroup;
}

void COleCmdUI::Enable(BOOL bOn)
{
   if (m_rgCmds != NULL)
   {
	  ASSERT(m_nIndex < m_nIndexMax);

	  if (bOn)
		 m_rgCmds[m_nIndex].cmdf |= OLECMDF_ENABLED;
	  else
		 m_rgCmds[m_nIndex].cmdf &= ~OLECMDF_ENABLED;
	  m_bEnableChanged = TRUE;
   }
}

void COleCmdUI::SetCheck(int nCheck)
{
   if (m_rgCmds != NULL)
   {
	  ASSERT(m_nIndex < m_nIndexMax);

	  m_rgCmds[m_nIndex].cmdf &= ~(OLECMDF_LATCHED|OLECMDF_NINCHED);
	  if (nCheck == 1)
		 m_rgCmds[m_nIndex].cmdf |= OLECMDF_LATCHED;
	  else if (nCheck == 2)
		 m_rgCmds[m_nIndex].cmdf |= OLECMDF_NINCHED;
   }
}

void COleCmdUI::SetText(LPCTSTR lpszText)
{
	m_strText = lpszText;
}

BOOL COleCmdUI::DoUpdate(CCmdTarget* pTarget, BOOL bDisableIfNoHandler)
{
   BOOL bResult;
   ASSERT_VALID(pTarget);

	// fire off an OLECOMMNAD message to translate the OLECMD ID
	// to a real WM_COMMAND ID via the message maps
	// if we find a translation, fire a UPDATE_COMMAND_UI request to
	// see if the command should be enabled or not

   m_bEnableChanged = FALSE;
   bResult = pTarget->OnCmdMsg(m_nID, CN_OLECOMMAND, this, NULL);
   if (!bResult)
	  ASSERT(!m_bEnableChanged);
   else
	  bResult = pTarget->OnCmdMsg(m_nID, CN_UPDATE_COMMAND_UI, this, NULL);

   if (bDisableIfNoHandler && !m_bEnableChanged)
   {
	  AFX_CMDHANDLERINFO info;
	  info.pTarget = NULL;
	  bResult = pTarget->OnCmdMsg(m_nID, CN_COMMAND, this, &info);

	  if (bResult || m_bEnableChanged)
		 m_rgCmds[m_nIndex].cmdf |= OLECMDF_SUPPORTED;
	  else
		 m_rgCmds[m_nIndex].cmdf &= ~OLECMDF_SUPPORTED;
	  Enable(bResult);
   }
   else
   {
	  if (m_bEnableChanged)
		 m_rgCmds[m_nIndex].cmdf |= OLECMDF_SUPPORTED;
	  else
		 m_rgCmds[m_nIndex].cmdf &= ~OLECMDF_SUPPORTED;
   }
   return bResult;
}

/////////////////////////////////////////////////////////////////////////////
// IOleCommandTarget implementation

STDMETHODIMP_(ULONG) CDocObjectServer::XOleCommandTarget::AddRef()
{
	METHOD_PROLOGUE_EX(CDocObjectServer, OleCommandTarget)
	return pThis->m_pOwner->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CDocObjectServer::XOleCommandTarget::Release()
{
	METHOD_PROLOGUE_EX(CDocObjectServer, OleCommandTarget)
	return pThis->m_pOwner->ExternalRelease();
}

STDMETHODIMP CDocObjectServer::XOleCommandTarget::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX(CDocObjectServer, OleCommandTarget)
	return pThis->m_pOwner->ExternalQueryInterface(&iid, ppvObj);
}

HRESULT AFXAPI _AfxQueryStatusOleCommandHelper(CCmdTarget* pTarget,
   const GUID* pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[],
   OLECMDTEXT* pcmdtext)
{
	HRESULT hr = E_POINTER;

	if (rgCmds != NULL)
	{
		hr = NOERROR;
		if (pTarget == NULL)
		{
			ULONG nIndex;
			for (nIndex = 0; nIndex < cCmds; nIndex++)
				rgCmds[nIndex].cmdf = 0;
		}
		else
		{
			COleCmdUI state(rgCmds, cCmds, pguidCmdGroup);
			if (pcmdtext == NULL)
				state.m_nCmdTextFlag = 0;
			else
				state.m_nCmdTextFlag = pcmdtext->cmdtextf;
			for (state.m_nIndex = 0; state.m_nIndex < cCmds; state.m_nIndex++)
			{
				state.m_nID = rgCmds[state.m_nIndex].cmdID;
				state.DoUpdate(pTarget, TRUE);
			}

			if (pcmdtext != NULL && pcmdtext->rgwz != NULL &&
				(pcmdtext->cmdtextf != OLECMDTEXTF_NONE))
			{
				ASSERT(cCmds == 1);
				state.m_strText = state.m_strText.Right(pcmdtext->cwBuf-1);
				pcmdtext->cwActual = (DWORD)min((ULONG)state.m_strText.GetLength(),pcmdtext->cwBuf - 1);

				Checked::wcsncpy_s(pcmdtext->rgwz, pcmdtext->cwBuf, CFixedStringT<CStringW, 256>(state.m_strText).GetString(), _TRUNCATE);
			}
		}
	}

	return hr;
}

STDMETHODIMP CDocObjectServer::XOleCommandTarget::QueryStatus(
   const GUID* pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[],
   OLECMDTEXT* pcmdtext)
{
	METHOD_PROLOGUE_EX(CDocObjectServer, OleCommandTarget)
	ASSERT_VALID(pThis);

	COleDocIPFrameWnd* pFrame = pThis->GetControllingFrame();
	return _AfxQueryStatusOleCommandHelper(pFrame,
		pguidCmdGroup, cCmds, rgCmds, pcmdtext);
}

HRESULT AFXAPI _AfxExecOleCommandHelper(CCmdTarget* pTarget,
   const GUID* pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt,
   VARIANTARG* pvarargIn, VARIANTARG* pvarargOut)
{
	HRESULT hr = OLECMDERR_E_NOHELP;

	UNUSED(pvarargIn);
	UNUSED(pvarargOut);
#ifdef _DEBUG
	// MFC doesn't support commands with arguments
	// You must handle argument commands by overriding OnExecOleCmd()

	if (pvarargIn != NULL || pvarargOut != NULL)
		TRACE(traceOle, 0, "Warning: IOleCommandTarget::Exec() received parameterized command #%d\n", nCmdID);
#endif

	if (pTarget != NULL)
	{
		OLECMD cmd;

		COleCmdUI state(&cmd, 1, pguidCmdGroup);
		state.m_nIndex = 0;
		cmd.cmdf = 0;
		cmd.cmdID = nCmdID;
		state.m_nID = nCmdID;

		// help via Doc Object targeting is not supported

		if (nCmdExecOpt == OLECMDEXECOPT_SHOWHELP)
			hr = OLECMDERR_E_DISABLED;
		else
		{
			// is the command supported?

			if (!state.DoUpdate(pTarget, TRUE))
				hr = OLECMDERR_E_NOTSUPPORTED;
			else
			{
				if (cmd.cmdf & OLECMDF_ENABLED)
				{
					if (pTarget->OnCmdMsg(state.m_nID, CN_COMMAND, NULL, NULL))
						hr = S_OK;
					else
						hr = E_FAIL;
				}
				else
					hr = OLECMDERR_E_DISABLED;
			}
		}
	}

	return hr;
}

STDMETHODIMP CDocObjectServer::XOleCommandTarget::Exec(
   const GUID* pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt,
   VARIANTARG* pvarargIn, VARIANTARG* pvarargOut)
{
	METHOD_PROLOGUE_EX(CDocObjectServer, OleCommandTarget)
	ASSERT_VALID(pThis);

	// Offer the command to the document, first

	HRESULT hr = pThis->OnExecOleCmd(pguidCmdGroup, nCmdID,
			nCmdExecOpt, pvarargIn, pvarargOut);
	if (hr == E_NOTIMPL)
	{
		COleDocIPFrameWnd* pFrame = pThis->GetControllingFrame();
		hr = _AfxExecOleCommandHelper(pFrame,
			pguidCmdGroup, nCmdID, nCmdExecOpt, pvarargIn, pvarargOut);
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\oledocvw.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#ifdef _DEBUG

#endif

#define new DEBUG_NEW

void CDocObjectServer::OnSaveViewState(CArchive& /* ar */)
{
	// user can override to save some state or do something neat
}

void CDocObjectServer::OnApplyViewState(CArchive& /* ar */)
{
	// user can override to restore state or do something neat
}


HRESULT CDocObjectServer::OnActivateView()
{
	ASSERT_VALID(this);

	HRESULT hr = E_FAIL;

	// Can't in-place activate without a client site
	if (m_pOwner->m_lpClientSite == NULL)
		return NOERROR;

	// build object title/name (the container may use this in its caption)
	CString strFileType, strTitle;
	CStringW wstrTitle;
	if (!m_pOwner->GetFileTypeString(strFileType))
		return E_FAIL;
	AfxFormatString2(strTitle, AFX_IDS_OBJ_TITLE_INPLACE,
		AfxGetAppName(), strFileType);

	// Find our view site
	LPOLEINPLACESITE lpInPlaceSite = NULL;
	lpInPlaceSite = m_pViewSite;
	if (lpInPlaceSite == NULL)
		return E_FAIL;
	lpInPlaceSite->AddRef();

	// start activation sequence...
	if ((hr = lpInPlaceSite->OnInPlaceActivate()) != NOERROR)
		goto ReleaseAndFail;

	// we'll need the parent window to create the CDocObjectIPFrameWnd
	HWND hWnd;
	VERIFY(lpInPlaceSite->GetWindow(&hWnd) == NOERROR);
	CWnd* pParentWnd;
	pParentWnd = CWnd::FromHandle(hWnd);

	// create the inplace frame window
	COleIPFrameWnd* pFrameWnd;

	// if we've not been activate before, we'll need
	// to create our frame at this time

	if (m_pOwner->m_pInPlaceFrame != NULL)
		pFrameWnd = m_pOwner->m_pInPlaceFrame;
	else
	{
		pFrameWnd = (COleIPFrameWnd*) m_pOwner->CreateInPlaceFrame(pParentWnd);
		if (pFrameWnd == NULL)
		{
			ASSERT(lpInPlaceSite != NULL);
			lpInPlaceSite->OnInPlaceDeactivate();
			goto ReleaseAndFail;
		}

		ASSERT(pFrameWnd->GetParent() == pParentWnd);
		m_pOwner->m_pInPlaceFrame = pFrameWnd;

		// need to get frame & doc window interfaces as well as other info
		RECT rcPosRect, rcClipRect;
		if ((hr = lpInPlaceSite->GetWindowContext(
			&pFrameWnd->m_lpFrame, &pFrameWnd->m_lpDocFrame,
			&rcPosRect, &rcClipRect, &pFrameWnd->m_frameInfo)) != NOERROR)
		{
			goto DestroyFrameAndFail;
		}
		ASSERT(pFrameWnd->m_lpFrame != NULL);

		// send activate notification
		if ((hr = lpInPlaceSite->OnUIActivate()) != NOERROR)
			goto DestroyFrameAndFail;

		// setup the shared menu
		if (!pFrameWnd->BuildSharedMenu())
			goto DeactivateUIAndFail;

		// allow server to install frame controls in container

		VERIFY(pFrameWnd->m_lpFrame->GetWindow(&hWnd) == NOERROR);

		pFrameWnd->m_pMainFrame = new COleCntrFrameWnd(pFrameWnd);
		pFrameWnd->m_pMainFrame->Attach(hWnd);

		if (pFrameWnd->m_lpDocFrame != NULL)
		{
			VERIFY(pFrameWnd->m_lpDocFrame->GetWindow(&hWnd) == NOERROR);
			pFrameWnd->m_pDocFrame = new COleCntrFrameWnd(pFrameWnd);
			pFrameWnd->m_pDocFrame->Attach(hWnd);
		}
		// update zoom factor information before creating control bars
		pFrameWnd->m_rectPos.CopyRect(&rcPosRect);
		pFrameWnd->m_rectClip.CopyRect(&rcClipRect);
		if (!pFrameWnd->OnCreateControlBars(pFrameWnd->m_pMainFrame,
			pFrameWnd->m_pDocFrame))
		{
			goto DeactivateUIAndFail;
		}
	}

	// set the active object
	ASSERT(pFrameWnd->m_lpFrame != NULL);
	LPOLEINPLACEACTIVEOBJECT lpActiveObject;
	lpActiveObject = (LPOLEINPLACEACTIVEOBJECT)
		m_pOwner->GetInterface(&IID_IOleInPlaceActiveObject);

	wstrTitle = strTitle;

	pFrameWnd->m_lpFrame->SetActiveObject(lpActiveObject,
		wstrTitle.GetString());

	if (pFrameWnd->m_lpDocFrame != NULL)
	{
		pFrameWnd->m_lpDocFrame->SetActiveObject(lpActiveObject,
			wstrTitle.GetString());
	}

	// add frame & document level frame controls
	ASSERT(m_pOwner->m_pInPlaceFrame == pFrameWnd);
	ASSERT(pFrameWnd->m_lpFrame != NULL);
	m_pOwner->OnShowControlBars(pFrameWnd->m_pMainFrame, TRUE);
	if (pFrameWnd->m_lpDocFrame != NULL)
		m_pOwner->OnShowControlBars(pFrameWnd->m_pDocFrame, TRUE);

	// show any hidden modeless dialogs as well...
	pFrameWnd->ShowOwnedWindows(TRUE);

	// attempt toolbar negotiation
	m_pOwner->OnResizeBorder(NULL, pFrameWnd->m_lpFrame, TRUE);
	if (pFrameWnd->m_lpDocFrame != NULL)
		m_pOwner->OnResizeBorder(NULL, pFrameWnd->m_lpDocFrame, FALSE);

	// install the menu (also installs a hook which forwards messages from
	//  the menu to the inplace frame window)
	pFrameWnd->m_lpFrame->SetMenu(pFrameWnd->m_hSharedMenu,
		pFrameWnd->m_hOleMenu, pFrameWnd->m_hWnd);

	// finally -- show the inplace frame window and set focus
	pFrameWnd->ShowWindow(SW_SHOW);
	pFrameWnd->SetFocus();
	pFrameWnd->UpdateWindow();

	// allow the main window to be set
	m_pOwner->OnFrameWindowActivate(TRUE);
	pFrameWnd->m_bUIActive = TRUE;

	// cleanup and return
	lpInPlaceSite->Release();
	return hr;

DeactivateUIAndFail:
	ASSERT(lpInPlaceSite != NULL);
	lpInPlaceSite->OnUIDeactivate(FALSE);

DestroyFrameAndFail:
	if (m_pOwner->m_pInPlaceFrame != NULL)
	{
		ASSERT(pFrameWnd != NULL);
		m_pOwner->DestroyInPlaceFrame(pFrameWnd);
		m_pOwner->m_pInPlaceFrame = NULL;

		// also need to send OnInPlaceDeactivate notification
		ASSERT(lpInPlaceSite != NULL);
		lpInPlaceSite->OnInPlaceDeactivate();
	}
ReleaseAndFail:
	ASSERT(lpInPlaceSite != NULL);
	lpInPlaceSite->Release();

	return hr;
}

STDMETHODIMP_(ULONG) CDocObjectServer::XOleDocumentView::AddRef()
{
	METHOD_PROLOGUE_EX(CDocObjectServer, OleDocumentView)
	return pThis->m_pOwner->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CDocObjectServer::XOleDocumentView::Release()
{
	METHOD_PROLOGUE_EX(CDocObjectServer, OleDocumentView)
	return pThis->m_pOwner->ExternalRelease();
}

STDMETHODIMP CDocObjectServer::XOleDocumentView::QueryInterface(REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX(CDocObjectServer, OleDocumentView)
	return pThis->m_pOwner->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP CDocObjectServer::XOleDocumentView::SetInPlaceSite(
	LPOLEINPLACESITE pIPSite)
{
	METHOD_PROLOGUE_EX(CDocObjectServer, OleDocumentView)
	ASSERT_VALID(pThis);

	// if currently inplace active, then do normal inplace deactivation
	if (pThis->m_pOwner->IsInPlaceActive())
		pThis->m_pOwner->m_xOleInPlaceObject.InPlaceDeactivate();

	// release the view site pointer
	if (pThis->m_pViewSite)
		pThis->m_pViewSite->Release();

	// remember the new view site pointer and addref it, if it is non-NULL
	pThis->m_pViewSite = pIPSite;
	if (pThis->m_pViewSite != NULL)
		pThis->m_pViewSite->AddRef();

	return NOERROR;
}

STDMETHODIMP CDocObjectServer::XOleDocumentView::GetInPlaceSite(LPOLEINPLACESITE* ppIPSite)
{
	METHOD_PROLOGUE_EX(CDocObjectServer, OleDocumentView)
	ASSERT_VALID(pThis);
	ASSERT(ppIPSite != NULL);

	if (pThis->m_pViewSite)
		pThis->m_pViewSite->AddRef();
	*ppIPSite = pThis->m_pViewSite;

	return NOERROR;
}

STDMETHODIMP CDocObjectServer::XOleDocumentView::GetDocument(LPUNKNOWN* ppUnk)
{
	METHOD_PROLOGUE_EX(CDocObjectServer, OleDocumentView)
	ASSERT_VALID(pThis);
	ASSERT(ppUnk != NULL);

	HRESULT hr = pThis->m_xOleDocument.QueryInterface(IID_IUnknown,
		(LPVOID*)ppUnk);
	ASSERT(*ppUnk != NULL);

	return hr;
}

void CDocObjectServer::OnSetItemRects(LPRECT lprcPosRect, LPRECT lprcClipRect)
{
	m_pOwner->OnSetItemRects(lprcPosRect, lprcClipRect);
}

STDMETHODIMP CDocObjectServer::XOleDocumentView::SetRect(LPRECT lprcView)
{
	METHOD_PROLOGUE_EX(CDocObjectServer, OleDocumentView)
	ASSERT_VALID(pThis);
	ASSERT(lprcView != NULL);

	HRESULT hr = E_UNEXPECTED;
	TRY
	{
		pThis->OnSetItemRects(lprcView, lprcView);
		hr = NOERROR;
	}
	END_TRY

	return hr;
}

STDMETHODIMP CDocObjectServer::XOleDocumentView::GetRect(LPRECT lprcView)
{
	METHOD_PROLOGUE_EX(CDocObjectServer, OleDocumentView)
	ASSERT_VALID(pThis);
	ASSERT(lprcView != NULL);

	pThis->m_pOwner->GetItemPosition(lprcView);
	return NOERROR;
}

STDMETHODIMP CDocObjectServer::XOleDocumentView::SetRectComplex(
	LPRECT lprcView, LPRECT lprcHScroll,
	LPRECT lprcVScroll, LPRECT lprcSizeBox)
{
	METHOD_PROLOGUE_EX(CDocObjectServer, OleDocumentView)
	ASSERT_VALID(pThis);

	UNUSED_ALWAYS(lprcView);
	UNUSED_ALWAYS(lprcHScroll);
	UNUSED_ALWAYS(lprcVScroll);
	UNUSED_ALWAYS(lprcSizeBox);

	// We don't support complex rectangles, so return error
	return E_NOTIMPL;
}

STDMETHODIMP CDocObjectServer::XOleDocumentView::Show(BOOL bShow)
{
	METHOD_PROLOGUE_EX(CDocObjectServer, OleDocumentView)
	ASSERT_VALID(pThis);

	HRESULT hr = NOERROR;

	if (bShow)
	{
		// in-place but don't UI activate; give the view focus
		hr = (pThis->m_pOwner->ActivateInPlace()) ? S_OK : E_FAIL;
	}
	else
	{
		// Call IOleInPlaceObject::InPlaceDeactivate on this view
		hr = pThis->m_pOwner->m_xOleInPlaceObject.InPlaceDeactivate();
	}

	return hr;
}

STDMETHODIMP CDocObjectServer::XOleDocumentView::UIActivate(BOOL bUIActivate)
{
	METHOD_PROLOGUE_EX(CDocObjectServer, OleDocumentView)
	ASSERT_VALID(pThis);

	HRESULT hr = NOERROR;

	if (bUIActivate)
	{
		// UI Activate the view then take focus and bring the view forward
		hr = pThis->OnActivateView();
	}
	else
	{
		// Call IOleInPlaceObject::UIDeactivate on this view
		hr = pThis->m_pOwner->m_xOleInPlaceObject.UIDeactivate();
	}
	return hr;
}

STDMETHODIMP CDocObjectServer::XOleDocumentView::Open()
{
	METHOD_PROLOGUE_EX(CDocObjectServer, OleDocumentView)
	ASSERT_VALID(pThis);

	return pThis->m_pOwner->m_xOleObject.DoVerb(OLEIVERB_OPEN, NULL,
		NULL, 0, NULL, NULL);
}

STDMETHODIMP CDocObjectServer::XOleDocumentView::CloseView(DWORD /* dwReserved */)
{
	METHOD_PROLOGUE_EX(CDocObjectServer, OleDocumentView)
	ASSERT_VALID(pThis);

	// Call IOleDocumentView::Show(FALSE) to hide the view
	Show(FALSE);

	// Call IOleDocumentView::SetInPlaceSite(NULL) to deactivate the object
	HRESULT hr = SetInPlaceSite(NULL);

	return hr;
}

STDMETHODIMP CDocObjectServer::XOleDocumentView::SaveViewState(LPSTREAM pstm)
{
	METHOD_PROLOGUE_EX(CDocObjectServer, OleDocumentView)
	ASSERT_VALID(pThis);

	HRESULT hr = NOERROR;

	// Attach the stream to an MFC file object
	COleStreamFile file;
	file.Attach(pstm);
	CFileException fe;

	// save it via a CArchive
	CArchive saveArchive(&file, CArchive::store | CArchive::bNoFlushOnDelete);
	TRY
	{
		pThis->OnSaveViewState(saveArchive);
		saveArchive.Close();
		file.Detach();
	}
	CATCH(COleException, pOE)
	{
		hr = pOE->m_sc;
	}
	AND_CATCH_ALL(e)
	{
		hr = E_UNEXPECTED;
	}
	END_CATCH_ALL

	return hr;
}

STDMETHODIMP CDocObjectServer::XOleDocumentView::ApplyViewState(LPSTREAM pstm)
{
	METHOD_PROLOGUE_EX(CDocObjectServer, OleDocumentView)
	ASSERT_VALID(pThis);

	HRESULT hr = NOERROR;

	// Attach the stream to an MFC file object
	COleStreamFile file;
	file.Attach(pstm);
	CFileException fe;

	// load it with CArchive
	CArchive loadArchive(&file, CArchive::load | CArchive::bNoFlushOnDelete);
	TRY
	{
		pThis->OnApplyViewState(loadArchive);
		loadArchive.Close();
		file.Detach();
	}
	CATCH(COleException, pOE)
	{
		hr = pOE->m_sc;
	}
	AND_CATCH_ALL(e)
	{
		hr = E_UNEXPECTED;
	}
	END_CATCH_ALL

	return hr;
}

STDMETHODIMP CDocObjectServer::XOleDocumentView::Clone(
	LPOLEINPLACESITE pipsiteNew, LPOLEDOCUMENTVIEW* ppviewNew)
{
	METHOD_PROLOGUE_EX(CDocObjectServer, OleDocumentView)
	ASSERT_VALID(pThis);

	UNUSED_ALWAYS(pipsiteNew);
	UNUSED_ALWAYS(ppviewNew);

	// In order to support this, we would need to support multiple views,
	// which we do not.  So we will return an error.
	return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\oledocob.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#ifdef _DEBUG

#endif

#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CDocObjectServer

IMPLEMENT_DYNAMIC(CDocObjectServer, CCmdTarget)

BEGIN_MESSAGE_MAP(CDocObjectServer, CCmdTarget)
	//{{AFX_MSG_MAP(CDocObjectServer)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_INTERFACE_MAP(CDocObjectServer, CCmdTarget)
	INTERFACE_PART(CDocObjectServer, IID_IOleObject, OleObject)
	INTERFACE_PART(CDocObjectServer, IID_IOleDocument, OleDocument)
	INTERFACE_PART(CDocObjectServer, IID_IOleDocumentView, OleDocumentView)
	INTERFACE_PART(CDocObjectServer, IID_IOleCommandTarget, OleCommandTarget)
	INTERFACE_PART(CDocObjectServer, IID_IPrint, Print)
END_INTERFACE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CDocObjectServer implementation

CDocObjectServer::CDocObjectServer(COleServerDoc* pDoc,
	LPOLEDOCUMENTSITE pDocSite /* = NULL */)
{
	// Initialize DocObject data
	m_pDocSite  = pDocSite;
	m_pViewSite = NULL;

	m_pOwner = pDoc;
	ASSERT(m_pOwner != NULL);

	m_nFirstPage = 1;

	// All Binder-Compatible documents use Compound Files as their
	// storage mechanism
	m_pOwner->EnableCompoundFile(TRUE);

	m_nFirstPage = -1;
}

CDocObjectServer::~CDocObjectServer()
{
	ReleaseDocSite();
}

void CDocObjectServer::ReleaseDocSite()
{
	if (m_pDocSite != NULL)
	{
		m_pDocSite->Release();
		m_pDocSite = NULL;
	}
}

void CDocObjectServer::SetDocSite(LPOLEDOCUMENTSITE pNewSite)
{
	ReleaseDocSite();
	m_pDocSite = pNewSite;
}

void CDocObjectServer::OnCloseDocument()
{
	// Clean up pointer to document site, if any
	ReleaseDocSite();
	m_pOwner->OnCloseDocument();
}

void CDocObjectServer::ActivateDocObject()
{
	ASSERT(m_pOwner != NULL);
	if (m_pOwner->IsDocObject())
	{
		ASSERT(m_pDocSite != NULL);
		m_pDocSite->ActivateMe(NULL);
	}
}

STDMETHODIMP CDocObjectServer::OnExecOleCmd(
   const GUID* pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt,
   VARIANTARG* pvarargIn, VARIANTARG* pvarargOut)
{
	ASSERT(m_pOwner != NULL);
	if (m_pOwner == NULL)
		return E_NOTIMPL;
	else
		return m_pOwner->OnExecOleCmd(pguidCmdGroup, nCmdID,
			nCmdExecOpt, pvarargIn, pvarargOut);
}

COleDocIPFrameWnd* CDocObjectServer::GetControllingFrame() const
{
	COleDocIPFrameWnd* pFrame = NULL;
	POSITION pos = m_pOwner->GetFirstViewPosition();
	if (pos != NULL)
	{
		CView* pView = m_pOwner->GetNextView(pos);
		if (pView != NULL)
		{
			CWnd* pParent = pView->GetParentFrame();
			pFrame = DYNAMIC_DOWNCAST(COleDocIPFrameWnd, pParent);
		}
	}

#ifdef _DEBUG
	// This TRACE will trip if you've not converted your application to
	// use a COleDocIPFrameWnd, or if you've incorrectly hooked up
	// DocObject support in your application.

	if (pFrame == NULL)
		TRACE(traceOle, 0, "Error: An appropriate DocObject frame could not be found.\n");
#endif

	return pFrame;
}

BOOL CDocObjectServer::DoPreparePrinting(CView* pView, CPrintInfo* printInfo)
{
	return pView->OnPreparePrinting(printInfo);
}

void CDocObjectServer::DoPrepareDC(CView* pView, CDC* pdcPrint,
	CPrintInfo* pprintInfo)
{
	pView->OnPrepareDC(pdcPrint, pprintInfo);
}

void CDocObjectServer::DoPrint(CView* pView, CDC* pdcPrint,
	CPrintInfo* pprintInfo)
{
	pView->OnPrint(pdcPrint, pprintInfo);
}

void CDocObjectServer::DoBeginPrinting(CView* pView,
	CDC* pDC, CPrintInfo* pprintInfo)
{
	pView->OnBeginPrinting(pDC, pprintInfo);
}

void CDocObjectServer::DoEndPrinting(CView* pView,
	CDC* pDC, CPrintInfo* pprintInfo)
{
	pView->OnEndPrinting(pDC, pprintInfo);
}


/////////////////////////////////////////////////////////////////////////////
// IPrint interface

extern BOOL CALLBACK _AfxAbortProc(HDC, int);   // from VIEWPRNT.CPP

STDMETHODIMP_(ULONG) CDocObjectServer::XPrint::AddRef()
{
	METHOD_PROLOGUE_EX(CDocObjectServer, Print)
	return pThis->m_pOwner->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CDocObjectServer::XPrint::Release()
{
	METHOD_PROLOGUE_EX(CDocObjectServer, Print)
	return pThis->m_pOwner->ExternalRelease();
}

STDMETHODIMP CDocObjectServer::XPrint::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX(CDocObjectServer, Print)
	return pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP CDocObjectServer::XPrint::SetInitialPageNum(
   LONG nFirstPage)
{
	METHOD_PROLOGUE_EX(CDocObjectServer, Print)
	ASSERT_VALID(pThis);
	pThis->m_nFirstPage = nFirstPage;

	return S_OK;
}

STDMETHODIMP CDocObjectServer::XPrint::GetPageInfo(
   LPLONG pnFirstPage, LPLONG pcPages)
{
	METHOD_PROLOGUE_EX(CDocObjectServer, Print)
	ASSERT_VALID(pThis);

	// find the view we need to print

	CView* pView = NULL;
	POSITION pos = pThis->m_pOwner->GetFirstViewPosition();
	if (pos != NULL)
		pView = pThis->m_pOwner->GetNextView(pos);

	if (pView == NULL)
		return E_UNEXPECTED;

	// tell the view that we're not actually printing
	// and just need to measure the print job

	CPrintInfo printInfo;
	printInfo.m_bDocObject = TRUE;
	printInfo.m_dwFlags = PRINTFLAG_DONTACTUALLYPRINT;

	// ask the view about it

	if (!pThis->DoPreparePrinting(pView, &printInfo))
		return E_UNEXPECTED;

	// pnFirstPage and pcPages are allowed to be NULL
	// if NULL, don't return results to caller

	if (pnFirstPage != NULL)
	{
		if (pThis->m_nFirstPage == -1)
			*pnFirstPage = printInfo.GetMinPage();
		else
			*pnFirstPage = pThis->m_nFirstPage;
	}

	if (pcPages != NULL)
	{
		if (printInfo.GetToPage() == 0xFFFF)
			*pcPages = 0xFFFF;
		else
			*pcPages = printInfo.GetToPage() - printInfo.GetFromPage() +1;
	}

	return S_OK;
}

STDMETHODIMP CDocObjectServer::XPrint::Print(
   DWORD grfFlags, DVTARGETDEVICE** ppTD, PAGESET** ppPageSet,
   LPSTGMEDIUM pstgmOptions, LPCONTINUECALLBACK pCallback, LONG nFirstPage,
   LPLONG pcPagesPrinted, LPLONG pnLastPage)
{
	METHOD_PROLOGUE_EX(CDocObjectServer, Print)
	ASSERT_VALID(pThis);
	UNUSED_ALWAYS(pstgmOptions);
	UNUSED_ALWAYS(pnLastPage);

	// try to get out of this without doing any work

	if (pcPagesPrinted == NULL || ppTD == NULL || ppPageSet == NULL)
		return E_POINTER;

	if (*ppTD == NULL)
		return E_INVALIDARG;

	// get initialized

	DVTARGETDEVICE* ptd = *ppTD;
	pThis->m_nFirstPage = nFirstPage;
	*pcPagesPrinted = 0;

	// find the view we need to print

	CView* pView = NULL;
	POSITION pos = pThis->m_pOwner->GetFirstViewPosition();
	if (pos != NULL)
		pView = pThis->m_pOwner->GetNextView(pos);

	if (pView == NULL)
		return E_UNEXPECTED;

	// get default print info
	CPrintInfo printInfo;
	ASSERT(printInfo.m_pPD != NULL);    // must be set
	printInfo.m_bDocObject = TRUE;
	printInfo.m_dwFlags = grfFlags;
	printInfo.m_nOffsetPage = nFirstPage;

	printInfo.m_pPD->m_pd.hDC = _AfxOleCreateDC(*ppTD);
	if (printInfo.m_pPD->m_pd.hDC == NULL)
	{
		if (grfFlags & PRINTFLAG_MAYBOTHERUSER)
			AfxMessageBox(AFX_IDP_FAILED_TO_START_PRINT);
		return E_UNEXPECTED;
	}

	if (pThis->DoPreparePrinting(pView, &printInfo))
	{
		// hDC must be set (did you remember to call DoPreparePrinting?)
		ASSERT(printInfo.m_pPD->m_pd.hDC != NULL);

		// set file to print to if print-to-file selected
		CString strOutput;
		if (grfFlags & PRINTFLAG_PRINTTOFILE)
			strOutput = (LPOLESTR)((BYTE*)ptd + ptd->tdPortNameOffset);

		// if we were to prompt, we'll need to copy info from the
		// user back to the client

		if (grfFlags & PRINTFLAG_PROMPTUSER)
		{
			if (grfFlags & PRINTFLAG_USERMAYCHANGEPRINTER)
			{
				LPDEVNAMES lpDevNames =
					(LPDEVNAMES) GlobalLock(printInfo.m_pPD->m_pd.hDevNames);
				LPDEVMODE lpDevMode =
					(LPDEVMODE) GlobalLock(printInfo.m_pPD->m_pd.hDevMode);

				if (lpDevNames == NULL || lpDevMode == NULL)
					*ppTD = NULL;
				else
					*ppTD = _AfxOleCreateTargetDevice(lpDevNames, lpDevMode);

				GlobalUnlock(printInfo.m_pPD->m_pd.hDevNames);
				GlobalUnlock(printInfo.m_pPD->m_pd.hDevMode);
			}

			// MFC page ranges (for now) only have one PAGERANGE

			LPMALLOC pMalloc = NULL;

			// if the caller didn't supply a buffer, allocate one
			// else, make sure the buffer is big enough

			if (*ppPageSet == NULL)
			{
				HRESULT hrCopying = CoGetMalloc(1, &pMalloc);
				if (FAILED(hrCopying))
					return hrCopying;

				*ppPageSet =
					(PAGESET*) pMalloc->Alloc(sizeof(PAGESET) + sizeof(PAGERANGE));
			}
			else
			{
				if ((*ppPageSet)->cPageRange < 1 ||
					(*ppPageSet)->cbStruct != sizeof(PAGESET))
				{
					return E_INVALIDARG;
				}
			}

			if (*ppPageSet != NULL)
			{
				(*ppPageSet)->cbStruct = sizeof(PAGESET);
				(*ppPageSet)->fOddPages = TRUE;
				(*ppPageSet)->fEvenPages = TRUE;
				(*ppPageSet)->cPageRange = 1;

				(*ppPageSet)->rgPages[0].nFromPage = printInfo.GetFromPage();
				(*ppPageSet)->rgPages[0].nToPage = printInfo.GetToPage();
			}

			RELEASE(pMalloc);

			if (*ppTD == NULL || *ppPageSet == NULL)
				return E_UNEXPECTED;
		}

		// if the client didn't really want to print,
		// we've collected all the information we need
		if (grfFlags & PRINTFLAG_DONTACTUALLYPRINT)
			return S_OK;

		// set up document info and start the document printing process
		CString strTitle;
		CDocument* pDoc = pThis->m_pOwner;
		if (pDoc != NULL)
		{
			strTitle = pDoc->GetTitle();
		}
		else
		{
			pView->EnsureParentFrame()->GetWindowText(strTitle);
		}

		if (strTitle.GetLength() > 31)
			strTitle.ReleaseBuffer(31);

		DOCINFO docInfo;
		memset(&docInfo, 0, sizeof(DOCINFO));
		docInfo.cbSize = sizeof(DOCINFO);
		docInfo.lpszDocName = strTitle;
		CString strPortName;
		int nFormatID;
		if (strOutput.IsEmpty())
		{
			docInfo.lpszOutput = NULL;
			strPortName = (LPOLESTR)((BYTE*)ptd + ptd->tdPortNameOffset);
			nFormatID = AFX_IDS_PRINTONPORT;
		}
		else
		{
			docInfo.lpszOutput = strOutput;
			AfxGetFileTitle(strOutput,
				strPortName.GetBuffer(_MAX_PATH), _MAX_PATH);
			nFormatID = AFX_IDS_PRINTTOFILE;
		}

		// setup the printing DC
		CDC dcPrint;
		dcPrint.Attach(printInfo.m_pPD->m_pd.hDC);  // attach printer dc
		dcPrint.m_bPrinting = TRUE;
		pThis->DoBeginPrinting(pView, &dcPrint, &printInfo);
		dcPrint.SetAbortProc(_AfxAbortProc);

		// disable main window while printing & init printing status dialog
		AfxGetMainWnd()->EnableWindow(FALSE);

		CString strTemp;

		// start document printing process
		printInfo.m_nJobNumber = dcPrint.StartDoc(&docInfo);
		if (printInfo.m_nJobNumber == SP_ERROR)
		{
			// enable main window before proceeding
			AfxGetMainWnd()->EnableWindow(TRUE);

			// cleanup and show error message
			pThis->DoEndPrinting(pView, &dcPrint, &printInfo);
			dcPrint.Detach();   // will be cleaned up by CPrintInfo destructor
			AfxMessageBox(AFX_IDP_FAILED_TO_START_PRINT);
			return E_UNEXPECTED;
		}

		// Guarantee values are in the valid range
		UINT nEndPage = printInfo.GetToPage();
		UINT nStartPage = printInfo.GetFromPage();

		if (nEndPage < printInfo.GetMinPage())
			nEndPage = printInfo.GetMinPage();
		if (nEndPage > printInfo.GetMaxPage())
			nEndPage = printInfo.GetMaxPage();

		if (nStartPage < printInfo.GetMinPage())
			nStartPage = printInfo.GetMinPage();
		if (nStartPage > printInfo.GetMaxPage())
			nStartPage = printInfo.GetMaxPage();

		int nStep = (nEndPage >= nStartPage) ? 1 : -1;
		nEndPage = (nEndPage == 0xffff) ? 0xffff : nEndPage + nStep;

		VERIFY(strTemp.LoadString(AFX_IDS_PRINTPAGENUM));

		// begin page printing loop
		BOOL bError = FALSE;
		HRESULT hrContinue = S_OK;

		for (printInfo.m_nCurPage = nStartPage;
			printInfo.m_nCurPage != nEndPage; printInfo.m_nCurPage += nStep)
		{
			// check even/odd filter
			if (printInfo.m_nCurPage % 2 == 1 && !(*ppPageSet)->fOddPages)
				continue;
			if (printInfo.m_nCurPage % 2 == 0 && !(*ppPageSet)->fEvenPages)
				continue;

			// check PAGERANGE if supplied
			if (ppPageSet != NULL && (*ppPageSet)->cPageRange > 0)
			{
				ULONG nCheckRange;
				BOOL bFound = FALSE;
				for (nCheckRange = 0; (nCheckRange < (*ppPageSet)->cPageRange) && !bFound; nCheckRange++)
				{
					if ( ((*ppPageSet)->rgPages[nCheckRange].nFromPage <= (LONG) printInfo.m_nCurPage ) &&
						 ((*ppPageSet)->rgPages[nCheckRange].nToPage >= (LONG) printInfo.m_nCurPage) )
					{
						bFound = TRUE;
					}
				}

				if (!bFound)
					continue;
			}

			pThis->DoPrepareDC(pView, &dcPrint, &printInfo);

			// check for end of print
			if (!printInfo.m_bContinuePrinting)
				break;

			// set up drawing rect to entire page (in logical coordinates)
			printInfo.m_rectDraw.SetRect(0, 0,
				dcPrint.GetDeviceCaps(HORZRES),
				dcPrint.GetDeviceCaps(VERTRES));
			dcPrint.DPtoLP(&printInfo.m_rectDraw);

			// attempt to start the current page
			if (dcPrint.StartPage() < 0)
			{
				bError = TRUE;
				break;
			}

			// must call OnPrepareDC on newer versions of Windows because
			// StartPage now resets the device attributes.
			pThis->DoPrepareDC(pView, &dcPrint, &printInfo);

			ASSERT(printInfo.m_bContinuePrinting);

			hrContinue = S_OK;

			if (pCallback != NULL)
			{
				hrContinue = pCallback->FContinuePrinting(printInfo.m_nCurPage,
					printInfo.m_nCurPage + printInfo.m_nOffsetPage, NULL);
			}

			// page successfully started, so now render the page
			pThis->DoPrint(pView, &dcPrint, &printInfo);
			if (dcPrint.EndPage() < 0 ||
				!_AfxAbortProc(dcPrint.m_hDC, 0) ||
				hrContinue != S_OK)
			{
				bError = TRUE;
				break;
			}

			// increment count
			(*pcPagesPrinted)++;
		}

		// cleanup document printing process
		if (!bError)
			dcPrint.EndDoc();
		else
			dcPrint.AbortDoc();

		AfxGetMainWnd()->EnableWindow();    // enable main window

		// clean up after printing
		pThis->DoEndPrinting(pView, &dcPrint, &printInfo);
		dcPrint.Detach();   // will be cleaned up by CPrintInfo destructor

		if (bError)
		{
			if (hrContinue != S_OK)
				return PRINT_E_CANCELLED;
			else
				return E_UNEXPECTED;
		}
	}

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IOleDocument interface

STDMETHODIMP_(ULONG) CDocObjectServer::XOleDocument::AddRef()
{
	METHOD_PROLOGUE_EX(CDocObjectServer, OleDocument)
	return pThis->m_pOwner->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CDocObjectServer::XOleDocument::Release()
{
	METHOD_PROLOGUE_EX(CDocObjectServer, OleDocument)
	return pThis->m_pOwner->ExternalRelease();
}

STDMETHODIMP CDocObjectServer::XOleDocument::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX(CDocObjectServer, OleDocument)
	return pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP CDocObjectServer::XOleDocument::CreateView(
   LPOLEINPLACESITE pipsite, LPSTREAM pstm,
   DWORD dwReserved, LPOLEDOCUMENTVIEW* ppview)
{
   METHOD_PROLOGUE_EX(CDocObjectServer, OleDocument)
   ASSERT_VALID(pThis);

   *ppview = NULL;

   HRESULT hr = E_FAIL;

   if (dwReserved == 0 && pThis->m_pDocSite != NULL)
   {
	  // We only support a single view...so if view site is already
	  // set, fail.
	  if (pThis->m_pViewSite == NULL)
	  {
		 LPOLEDOCUMENTVIEW pView =
			(LPOLEDOCUMENTVIEW)pThis->GetInterface(&IID_IOleDocumentView);
		 ASSERT(pView != NULL);

		 // Set the site for the view
		 hr = pView->SetInPlaceSite(pipsite);
		 if (hr == NOERROR)
		 {
			// Return the IOleDocumentView pointer
			pView->AddRef();
			*ppview = pView;
		 }

		 // If a saved view state is provided, restore the view state
		 if (pstm)
			hr = pView->ApplyViewState(pstm);
	  }
	  else
		 TRACE(traceOle, 0, "CDocObjectServer::XOleDocument::CreateView view already exists!\n");
   }

   return hr;
}

STDMETHODIMP CDocObjectServer::XOleDocument::GetDocMiscStatus(
   LPDWORD pdwStatus)
{
   METHOD_PROLOGUE_EX(CDocObjectServer, OleDocument)
   ASSERT_VALID(pThis);
   ASSERT(pdwStatus != NULL);

   // Our implementation of DocObjects can't create multiple views,
   // does not support complex rectangles, supports open editing,
   // and supports read/write to a file. Thus DOCMISC == 0.
   *pdwStatus = 0;

   return NOERROR;
}

STDMETHODIMP CDocObjectServer::XOleDocument::EnumViews(
   LPENUMOLEDOCUMENTVIEWS* ppEnumView, LPOLEDOCUMENTVIEW* ppView)
{
   METHOD_PROLOGUE_EX(CDocObjectServer, OleDocument)
   ASSERT_VALID(pThis);
   ASSERT(ppEnumView != NULL);
   ASSERT(ppView != NULL);

   // We only support a single view
   *ppEnumView = NULL;
   HRESULT hr = QueryInterface(IID_IOleDocumentView, (LPVOID*)ppView);

   // The QueryInterface increased ref count on CDocObjectServer, rather
   // than XOleDocument.
   // When releasing the view, MFC will decrease the ref count of XOleDocument,
   // this is due to the designment of Doc-View architecture.
   // So we need to change the ref count manually by adding the ref count on
   // XOleDocument instead of CDocObjectServer.
   this->AddRef();
   ::InterlockedDecrement(&pThis->m_dwRef);

   return hr;
}

/////////////////////////////////////////////////////////////////////////////
// IOleObject interface

STDMETHODIMP_(ULONG) CDocObjectServer::XOleObject::AddRef()
{
	METHOD_PROLOGUE_EX(CDocObjectServer, OleObject)
	return pThis->m_pOwner->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CDocObjectServer::XOleObject::Release()
{
	METHOD_PROLOGUE_EX(CDocObjectServer, OleObject)
	return pThis->m_pOwner->ExternalRelease();
}

STDMETHODIMP CDocObjectServer::XOleObject::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX(CDocObjectServer, OleObject)
	return pThis->m_pOwner->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP CDocObjectServer::XOleObject::SetClientSite(
	LPOLECLIENTSITE pClientSite)
{
	METHOD_PROLOGUE_EX(CDocObjectServer, OleObject)
	ASSERT_VALID(pThis);
	HRESULT hr = NOERROR;

	// Perform normal SetClientSite processing.
	hr = pThis->m_pOwner->m_xOleObject.SetClientSite(pClientSite);
	if (hr != S_OK)
		return hr;

	// If we currently have a document site pointer,
	// release it.

	pThis->ReleaseDocSite();

	// Check to see whether this object should act
	// as a document object by querying for
	// IOleDocumentSite.
	if (pClientSite != NULL)
		hr = pClientSite->QueryInterface(IID_IOleDocumentSite,
			(LPVOID*)&pThis->m_pDocSite);
	return hr;
}

STDMETHODIMP CDocObjectServer::XOleObject::GetClientSite(
	LPOLECLIENTSITE* ppClientSite)
{
	METHOD_PROLOGUE_EX(CDocObjectServer, OleObject)
	ASSERT_VALID(pThis);
	return pThis->m_pOwner->m_xOleObject.GetClientSite(ppClientSite);
}

STDMETHODIMP CDocObjectServer::XOleObject::SetHostNames(
	LPCOLESTR lpszContainerApp, LPCOLESTR lpszContainerObj)
{
	METHOD_PROLOGUE_EX(CDocObjectServer, OleObject)
	ASSERT_VALID(pThis);
	return pThis->m_pOwner->m_xOleObject.SetHostNames(lpszContainerApp,
										   lpszContainerObj);
}

STDMETHODIMP CDocObjectServer::XOleObject::Close(DWORD dwSaveOption)
{
	METHOD_PROLOGUE_EX(CDocObjectServer, OleObject)
	ASSERT_VALID(pThis);
	return pThis->m_pOwner->m_xOleObject.Close(dwSaveOption);
}

STDMETHODIMP CDocObjectServer::XOleObject::SetMoniker(
	DWORD dwWhichMoniker, LPMONIKER pmk)
{
	METHOD_PROLOGUE_EX(CDocObjectServer, OleObject)
	ASSERT_VALID(pThis);
	return pThis->m_pOwner->m_xOleObject.SetMoniker(dwWhichMoniker, pmk);
}

STDMETHODIMP CDocObjectServer::XOleObject::GetMoniker(
	DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER* ppMoniker)
{
	METHOD_PROLOGUE_EX(CDocObjectServer, OleObject)
	ASSERT_VALID(pThis);
	return pThis->m_pOwner->m_xOleObject.GetMoniker(dwAssign, dwWhichMoniker,
										 ppMoniker);
}

STDMETHODIMP CDocObjectServer::XOleObject::InitFromData(
	LPDATAOBJECT pDataObject, BOOL bCreation, DWORD dwReserved)
{
	METHOD_PROLOGUE_EX(CDocObjectServer, OleObject)
	ASSERT_VALID(pThis);
	return pThis->m_pOwner->m_xOleObject.InitFromData(pDataObject, bCreation,
										   dwReserved);
}

STDMETHODIMP CDocObjectServer::XOleObject::GetClipboardData(
	DWORD dwReserved, LPDATAOBJECT* ppDataObject)
{
	METHOD_PROLOGUE_EX(CDocObjectServer, OleObject)
	ASSERT_VALID(pThis);
	return pThis->m_pOwner->m_xOleObject.GetClipboardData(dwReserved,
											   ppDataObject);

}

STDMETHODIMP CDocObjectServer::XOleObject::DoVerb(
	LONG iVerb, LPMSG lpmsg, LPOLECLIENTSITE pActiveSite, LONG lindex,
	HWND hwndParent, LPCRECT lpPosRect)
{
	METHOD_PROLOGUE_EX(CDocObjectServer, OleObject)
	ASSERT_VALID(pThis);
	return pThis->m_pOwner->m_xOleObject.DoVerb(iVerb, lpmsg,
		pActiveSite, lindex, hwndParent, lpPosRect);
}

STDMETHODIMP CDocObjectServer::XOleObject::EnumVerbs(
	IEnumOLEVERB** ppenumOleVerb)
{
	METHOD_PROLOGUE_EX(CDocObjectServer, OleObject)
	ASSERT_VALID(pThis);
	return pThis->m_pOwner->m_xOleObject.EnumVerbs(ppenumOleVerb);
}

STDMETHODIMP CDocObjectServer::XOleObject::Update()
{
	METHOD_PROLOGUE_EX(CDocObjectServer, OleObject)
	ASSERT_VALID(pThis);
	return pThis->m_pOwner->m_xOleObject.Update();
}

STDMETHODIMP CDocObjectServer::XOleObject::IsUpToDate()
{
	METHOD_PROLOGUE_EX(CDocObjectServer, OleObject)
	ASSERT_VALID(pThis);
	return pThis->m_pOwner->m_xOleObject.IsUpToDate();
}

STDMETHODIMP CDocObjectServer::XOleObject::GetUserClassID(CLSID* lpClassID)
{
	METHOD_PROLOGUE_EX(CDocObjectServer, OleObject)
	ASSERT_VALID(pThis);
	return pThis->m_pOwner->m_xOleObject.GetUserClassID(lpClassID);
}

STDMETHODIMP CDocObjectServer::XOleObject::GetUserType(
	DWORD dwFormOfType, LPOLESTR* ppszUserType)
{
	METHOD_PROLOGUE_EX(CDocObjectServer, OleObject)
	ASSERT_VALID(pThis);
	return pThis->m_pOwner->m_xOleObject.GetUserType(dwFormOfType, ppszUserType);
}

STDMETHODIMP CDocObjectServer::XOleObject::SetExtent(
	DWORD dwDrawAspect, LPSIZEL lpsizel)
{
	METHOD_PROLOGUE_EX(CDocObjectServer, OleObject)
	ASSERT_VALID(pThis);

	// DocObjects ignore SetExtent calls, so returne E_FAIL
	if (pThis->m_pOwner->IsDocObject())
		return E_FAIL;

	// Otherwise, just do the normal processing
	return pThis->m_pOwner->m_xOleObject.SetExtent(dwDrawAspect, lpsizel);
}

STDMETHODIMP CDocObjectServer::XOleObject::GetExtent(
	DWORD dwDrawAspect, LPSIZEL lpsizel)
{
	METHOD_PROLOGUE_EX(CDocObjectServer, OleObject)
	ASSERT_VALID(pThis);
	return pThis->m_pOwner->m_xOleObject.GetExtent(dwDrawAspect, lpsizel);
}

STDMETHODIMP CDocObjectServer::XOleObject::Advise(
	LPADVISESINK pAdvSink, DWORD* pdwConnection)
{
	METHOD_PROLOGUE_EX(CDocObjectServer, OleObject)
	ASSERT_VALID(pThis);
	return pThis->m_pOwner->m_xOleObject.Advise(pAdvSink, pdwConnection);
}

STDMETHODIMP CDocObjectServer::XOleObject::Unadvise(DWORD dwConnection)
{
	METHOD_PROLOGUE_EX(CDocObjectServer, OleObject)
	ASSERT_VALID(pThis);
	return pThis->m_pOwner->m_xOleObject.Unadvise(dwConnection);
}

STDMETHODIMP CDocObjectServer::XOleObject::EnumAdvise(
	LPENUMSTATDATA* ppenumStatData)
{
	METHOD_PROLOGUE_EX(CDocObjectServer, OleObject)
	ASSERT_VALID(pThis);
	return pThis->m_pOwner->m_xOleObject.EnumAdvise(ppenumStatData);
}

STDMETHODIMP CDocObjectServer::XOleObject::GetMiscStatus(
	DWORD dwAspect, DWORD* pdwStatus)
{
	METHOD_PROLOGUE_EX(CDocObjectServer, OleObject)
	ASSERT_VALID(pThis);
	return pThis->m_pOwner->m_xOleObject.GetMiscStatus(dwAspect, pdwStatus);
}

STDMETHODIMP CDocObjectServer::XOleObject::SetColorScheme(LPLOGPALETTE lpLogpal)
{
	METHOD_PROLOGUE_EX(CDocObjectServer, OleObject)
	ASSERT_VALID(pThis);
	return pThis->m_pOwner->m_xOleObject.SetColorScheme(lpLogpal);
}


/////////////////////////////////////////////////////////////////////////////
// CDocObjectServer diagnostics

#ifdef _DEBUG
void CDocObjectServer::AssertValid() const
{
	ASSERT(m_pOwner != NULL);
	CCmdTarget::AssertValid();
}

void CDocObjectServer::Dump(CDumpContext& dc) const
{
	CCmdTarget::Dump(dc);
	dc << "m_pDocSite = " << m_pDocSite << "\n";
	dc << "m_pViewSite = " << m_pViewSite << "\n";
}
#endif //_DEBUG


/////////////////////////////////////////////////////////////////////////////
// CDocObjectServerItem implementation

IMPLEMENT_DYNAMIC(CDocObjectServerItem, COleServerItem)

CDocObjectServerItem::CDocObjectServerItem(COleServerDoc* pServerDoc, BOOL bAutoDelete)
	: COleServerItem(pServerDoc, bAutoDelete)
{
}

CDocObjectServerItem::~CDocObjectServerItem()
{
}

void CDocObjectServerItem::OnDoVerb(LONG iVerb)
{
   COleServerDoc* pDoc = GetDocument();
   ASSERT_VALID(pDoc);

   if (pDoc->IsDocObject() && (iVerb == OLEIVERB_INPLACEACTIVATE || iVerb == OLEIVERB_SHOW) )
	  OnShow();
   else
	  COleServerItem::OnDoVerb(iVerb);
}

void CDocObjectServerItem::OnHide()
{
   COleServerDoc* pDoc = GetDocument();
   ASSERT_VALID(pDoc);

   if (pDoc->IsDocObject())
	  AfxThrowOleException(OLEOBJ_E_INVALIDVERB);
   else
	  COleServerItem::OnHide();
}

void CDocObjectServerItem::OnShow()
{
   COleServerDoc* pDoc = GetDocument();
   ASSERT_VALID(pDoc);

   if (pDoc->IsDocObject())
	  pDoc->ActivateDocObject();
   else
	  COleServerItem::OnShow();
}

#ifdef _DEBUG
void CDocObjectServerItem::AssertValid() const
{
	COleServerItem::AssertValid();
}

void CDocObjectServerItem::Dump(CDumpContext& dc) const
{
	COleServerItem::Dump(dc);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\oleexp.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"


#define new DEBUG_NEW


/////////////////////////////////////////////////////////////////////////////
// DllGetClassObject

extern "C"
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return AfxDllGetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllCanUnloadNow

extern "C"
STDAPI DllCanUnloadNow(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return AfxDllCanUnloadNow();
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\oledrop2.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// COleDropTarget implementation

AFX_DATADEF int COleDropTarget::nScrollInset = 0;
AFX_DATADEF UINT COleDropTarget::nScrollDelay = 0;
AFX_DATADEF UINT COleDropTarget::nScrollInterval = 0;

COleDropTarget::COleDropTarget()
{
	// initialize local state
	m_hWnd = NULL;
	m_lpDataObject = NULL;
	m_nTimerID = 0xffff;

	AfxLockGlobals(CRIT_DROPTARGET);
	static BOOL bInitialized;
	if (!bInitialized)
	{
		// get scroll metrics from win.ini
		static const TCHAR szWindows[] = _T("windows");
		static const TCHAR szScrollDelay[] = _T("DragScrollDelay");
		static const TCHAR szScrollInset[] = _T("DragScrollInset");
		static const TCHAR szScrollInterval[] = _T("DragScrollInterval");

		nScrollInset = GetProfileInt(szWindows, szScrollInset, DD_DEFSCROLLINSET);
		nScrollDelay = GetProfileInt(szWindows, szScrollDelay, DD_DEFSCROLLDELAY);
		nScrollInterval = GetProfileInt(szWindows, szScrollInterval,
			DD_DEFSCROLLINTERVAL);

		// now initialized, no need to call Initialize any more
		bInitialized = TRUE;
	}
	AfxUnlockGlobals(CRIT_DROPTARGET);

	ASSERT_VALID(this);
}

COleDropTarget::~COleDropTarget()
{
	AFX_BEGIN_DESTRUCTOR

	ASSERT_VALID(this);

	if (m_hWnd != NULL)
	{
		TRACE(traceOle, 0, "COleDropTarget::Revoke not called before destructor --\n");
		TRACE(traceOle, 0, "\tmay cause RIPs under debug Windows.\n");
		Revoke();
	}

	AFX_END_DESTRUCTOR
}

BOOL COleDropTarget::Register(CWnd* pWnd)
{
	ASSERT_VALID(this);
	ASSERT(m_hWnd == NULL);     // registering drop target twice?
	ASSERT_VALID(pWnd);

	LPUNKNOWN lpUnknown = (LPUNKNOWN)GetInterface(&IID_IUnknown);
	ASSERT(lpUnknown != NULL);

	// the object must be locked externally to keep LRPC connections alive
	if (CoLockObjectExternal(lpUnknown, TRUE, FALSE) != S_OK)
		return FALSE;

	// connect the HWND to the IDropTarget implementation
	if (RegisterDragDrop(pWnd->m_hWnd,
		(LPDROPTARGET)GetInterface(&IID_IDropTarget)) != S_OK)
	{
		CoLockObjectExternal(lpUnknown, FALSE, FALSE);
		return FALSE;
	}

	// connect internal data
	m_hWnd = pWnd->m_hWnd;
	ASSERT(pWnd->m_pDropTarget == NULL);
	pWnd->m_pDropTarget = this;

	return TRUE;
}

void COleDropTarget::Revoke()
{
	ASSERT_VALID(this);
	ASSERT(m_lpDataObject == NULL);

	if (m_hWnd == NULL)
	{
		ASSERT(m_nTimerID == 0xffff);
		return;
	}

	// disconnect from OLE
	RevokeDragDrop(m_hWnd);
	CoLockObjectExternal((LPUNKNOWN)GetInterface(&IID_IUnknown), FALSE, TRUE);

	// disconnect internal data
	CWnd::FromHandle(m_hWnd)->m_pDropTarget = NULL;
	m_hWnd = NULL;
}

/////////////////////////////////////////////////////////////////////////////
// default implementation of drag/drop scrolling

DROPEFFECT COleDropTarget::OnDragScroll(CWnd* pWnd, DWORD dwKeyState,
	CPoint point)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pWnd);

	// CWnds are allowed, but don't support autoscrolling
	if (!pWnd->IsKindOf(RUNTIME_CLASS(CView)))
		return DROPEFFECT_NONE;
	CView* pView = (CView*)pWnd;
	DROPEFFECT dropEffect = pView->OnDragScroll(dwKeyState, point);

	// DROPEFFECT_SCROLL means do the default
	if (dropEffect != DROPEFFECT_SCROLL)
		return dropEffect;

	// get client rectangle of destination window
	CRect rectClient;
	pWnd->GetClientRect(&rectClient);
	CRect rect = rectClient;

	// hit-test against inset region
	UINT nTimerID = 0xffff;
	rect.InflateRect(-nScrollInset, -nScrollInset);
	CSplitterWnd* pSplitter = NULL;
	if (rectClient.PtInRect(point) && !rect.PtInRect(point))
	{
		// determine which way to scroll along both X & Y axis
		if (point.x < rect.left)
			nTimerID = MAKEWORD(SB_LINEUP, HIBYTE(nTimerID));
		else if (point.x >= rect.right)
			nTimerID = MAKEWORD(SB_LINEDOWN, HIBYTE(nTimerID));
		if (point.y < rect.top)
			nTimerID = MAKEWORD(LOBYTE(nTimerID), SB_LINEUP);
		else if (point.y >= rect.bottom)
			nTimerID = MAKEWORD(LOBYTE(nTimerID), SB_LINEDOWN);
		ASSERT(nTimerID != 0xffff);

		// check for valid scroll first
		pSplitter = CView::GetParentSplitter(pView, FALSE);
		BOOL bEnableScroll = FALSE;
		if (pSplitter != NULL)
			bEnableScroll = pSplitter->DoScroll(pView, nTimerID, FALSE);
		else
			bEnableScroll = pView->OnScroll(nTimerID, 0, FALSE);
		if (!bEnableScroll)
			nTimerID = 0xffff;
	}

	if (nTimerID == 0xffff)
	{
		if (m_nTimerID != 0xffff)
		{
			// send fake OnDragEnter when transition from scroll->normal
			COleDataObject dataObject;
			dataObject.Attach(m_lpDataObject, FALSE);
			OnDragEnter(pWnd, &dataObject, dwKeyState, point);
			m_nTimerID = 0xffff;
		}
		return DROPEFFECT_NONE;
	}

	// save tick count when timer ID changes
	DWORD dwTick = GetTickCount();
	if (nTimerID != m_nTimerID)
	{
		m_dwLastTick = dwTick;
		m_nScrollDelay = nScrollDelay;
	}

	// scroll if necessary
	if (dwTick - m_dwLastTick > m_nScrollDelay)
	{
		if (pSplitter != NULL)
			pSplitter->DoScroll(pView, nTimerID, TRUE);
		else
			pView->OnScroll(nTimerID, 0, TRUE);
		m_dwLastTick = dwTick;
		m_nScrollDelay = nScrollInterval;
	}
	if (m_nTimerID == 0xffff)
	{
		// send fake OnDragLeave when transitioning from normal->scroll
		OnDragLeave(pWnd);
	}

	m_nTimerID = nTimerID;
	// check for force link
	if ((dwKeyState & (MK_CONTROL|MK_SHIFT)) == (MK_CONTROL|MK_SHIFT))
		dropEffect = DROPEFFECT_SCROLL|DROPEFFECT_LINK;
	// check for force copy
	else if ((dwKeyState & MK_CONTROL) == MK_CONTROL)
		dropEffect = DROPEFFECT_SCROLL|DROPEFFECT_COPY;
	// check for force move
	else if ((dwKeyState & MK_ALT) == MK_ALT ||
		(dwKeyState & MK_SHIFT) == MK_SHIFT)
		dropEffect = DROPEFFECT_SCROLL|DROPEFFECT_MOVE;
	// default -- recommended action is move
	else
		dropEffect = DROPEFFECT_SCROLL|DROPEFFECT_MOVE;
	return dropEffect;
}

/////////////////////////////////////////////////////////////////////////////
// COleDropTarget drop/ drop query handling

DROPEFFECT COleDropTarget::OnDragEnter(CWnd* pWnd, COleDataObject* pDataObject,
	DWORD dwKeyState, CPoint point)
{
	ASSERT_VALID(this);

	if (!pWnd->IsKindOf(RUNTIME_CLASS(CView)))
		return DROPEFFECT_NONE;

	// default delegates to view
	CView* pView = (CView*)pWnd;
	ASSERT_VALID(pView);
	return pView->OnDragEnter(pDataObject, dwKeyState, point);
}

DROPEFFECT COleDropTarget::OnDragOver(CWnd* pWnd, COleDataObject* pDataObject,
	DWORD dwKeyState, CPoint point)
{
	ASSERT_VALID(this);

	if (!pWnd->IsKindOf(RUNTIME_CLASS(CView)))
		return DROPEFFECT_NONE;

	// default delegates to view
	CView* pView = (CView*)pWnd;
	ASSERT_VALID(pView);
	return pView->OnDragOver(pDataObject, dwKeyState, point);
}

BOOL COleDropTarget::OnDrop(CWnd* pWnd, COleDataObject* pDataObject,
	DROPEFFECT dropEffect, CPoint point)
{
	ASSERT_VALID(this);

	if (!pWnd->IsKindOf(RUNTIME_CLASS(CView)))
		return DROPEFFECT_NONE;

	// default delegates to view
	CView* pView = (CView*)pWnd;
	ASSERT_VALID(pView);
	return pView->OnDrop(pDataObject, dropEffect, point);
}

DROPEFFECT COleDropTarget::OnDropEx(CWnd* pWnd, COleDataObject* pDataObject,
	DROPEFFECT dropEffect, DROPEFFECT dropEffectList, CPoint point)
{
	ASSERT_VALID(this);

	if (!pWnd->IsKindOf(RUNTIME_CLASS(CView)))
		return (DROPEFFECT)-1;  // not implemented

	// default delegates to view
	CView* pView = (CView*)pWnd;
	ASSERT_VALID(pView);
	return pView->OnDropEx(pDataObject, dropEffect, dropEffectList, point);
}

void COleDropTarget::OnDragLeave(CWnd* pWnd)
{
	ASSERT_VALID(this);

	if (!pWnd->IsKindOf(RUNTIME_CLASS(CView)))
		return;

	// default delegates to view
	CView* pView = (CView*)pWnd;
	ASSERT_VALID(pView);
	pView->OnDragLeave();
	return;
}

/////////////////////////////////////////////////////////////////////////////
// COleDropTarget::COleDropTarget implementation

BEGIN_INTERFACE_MAP(COleDropTarget, CCmdTarget)
	INTERFACE_PART(COleDropTarget, IID_IDropTarget, DropTarget)
END_INTERFACE_MAP()

STDMETHODIMP_(ULONG) COleDropTarget::XDropTarget::AddRef()
{
	METHOD_PROLOGUE_EX_(COleDropTarget, DropTarget)
	return pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) COleDropTarget::XDropTarget::Release()
{
	METHOD_PROLOGUE_EX_(COleDropTarget, DropTarget)
	return pThis->ExternalRelease();
}

STDMETHODIMP COleDropTarget::XDropTarget::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(COleDropTarget, DropTarget)
	return pThis->ExternalQueryInterface(&iid, ppvObj);
}

// helper to filter out invalid DROPEFFECTs
AFX_STATIC DROPEFFECT AFXAPI _AfxFilterDropEffect(DROPEFFECT dropEffect, DROPEFFECT dwEffects)
{
	// return allowed dropEffect and DROPEFFECT_NONE
	if ((dropEffect & dwEffects) != 0)
		return dropEffect;

	// map common operations (copy/move) to alternates, but give negative
	//  feedback for DROPEFFECT_LINK.
	switch (dropEffect)
	{
	case DROPEFFECT_COPY:
		if (dwEffects & DROPEFFECT_MOVE)
			return DROPEFFECT_MOVE;
		else if (dwEffects & DROPEFFECT_LINK)
			return DROPEFFECT_LINK;
		break;

	case DROPEFFECT_MOVE:
		if (dwEffects & DROPEFFECT_COPY)
			return DROPEFFECT_COPY;
		else if (dwEffects & DROPEFFECT_LINK)
			return DROPEFFECT_LINK;
		break;

	case DROPEFFECT_LINK:
		break;
	}

	return DROPEFFECT_NONE;
}

STDMETHODIMP COleDropTarget::XDropTarget::DragEnter(THIS_ LPDATAOBJECT lpDataObject, DWORD dwKeyState, POINTL pt, LPDWORD pdwEffect)
{
	METHOD_PROLOGUE_EX(COleDropTarget, DropTarget)
	ASSERT_VALID(pThis);

	ASSERT(pdwEffect != NULL);
	ASSERT(lpDataObject != NULL);

	if (lpDataObject == NULL || pdwEffect == NULL)
	{
		return E_INVALIDARG;
	}

	SCODE sc = E_UNEXPECTED;
	TRY
	{
		// cache lpDataObject
		lpDataObject->AddRef();
		RELEASE(pThis->m_lpDataObject);
		pThis->m_lpDataObject = lpDataObject;

		CWnd* pWnd = CWnd::FromHandle(pThis->m_hWnd);
		ASSERT_VALID(pWnd);
		CPoint point((int)pt.x, (int)pt.y);
		pWnd->ScreenToClient(&point);

		// check first for entering scroll area
		DROPEFFECT dropEffect = pThis->OnDragScroll(pWnd, dwKeyState, point);
		if ((dropEffect & DROPEFFECT_SCROLL) == 0)
		{
			// funnel through OnDragEnter since not in scroll region
			COleDataObject dataObject;
			dataObject.Attach(lpDataObject, FALSE);
			dropEffect = pThis->OnDragEnter(pWnd, &dataObject, dwKeyState, point);
		}

		*pdwEffect = _AfxFilterDropEffect(dropEffect, *pdwEffect);
		sc = S_OK;
	}
	END_TRY

	return sc;
}

STDMETHODIMP COleDropTarget::XDropTarget::DragOver(THIS_ DWORD dwKeyState, POINTL pt, LPDWORD pdwEffect)
{
	METHOD_PROLOGUE_EX(COleDropTarget, DropTarget)
	ASSERT_VALID(pThis);

	ASSERT(pdwEffect != NULL);
	ASSERT(pThis->m_lpDataObject != NULL);

	if (pdwEffect == NULL)
	{
		return E_INVALIDARG;
	}

	SCODE sc = E_UNEXPECTED;
	TRY
	{
		CWnd* pWnd = CWnd::FromHandle(pThis->m_hWnd);
		ASSERT_VALID(pWnd);
		CPoint point((int)pt.x, (int)pt.y);
		pWnd->ScreenToClient(&point);

		// check first for entering scroll area
		DROPEFFECT dropEffect = pThis->OnDragScroll(pWnd, dwKeyState, point);
		if ((dropEffect & DROPEFFECT_SCROLL) == 0)
		{
			// funnel through OnDragOver
			COleDataObject dataObject;
			dataObject.Attach(pThis->m_lpDataObject, FALSE);
			dropEffect = pThis->OnDragOver(pWnd, &dataObject, dwKeyState, point);
		}

		*pdwEffect = _AfxFilterDropEffect(dropEffect, *pdwEffect);
		sc = S_OK;
	}
	END_TRY

	return sc;
}

STDMETHODIMP COleDropTarget::XDropTarget::DragLeave(THIS)
{
	METHOD_PROLOGUE_EX(COleDropTarget, DropTarget)
	ASSERT_VALID(pThis);

	CWnd* pWnd = CWnd::FromHandle(pThis->m_hWnd);
	ASSERT_VALID(pWnd);

	// cancel drag scrolling
	pThis->m_nTimerID = 0xffff;

	// allow derivative to do own cleanup
	COleDataObject dataObject;
	dataObject.Attach(pThis->m_lpDataObject, FALSE);
	pThis->OnDragLeave(pWnd);

	// release cached data object
	RELEASE(pThis->m_lpDataObject);

	return S_OK;
}

STDMETHODIMP COleDropTarget::XDropTarget::Drop(THIS_ LPDATAOBJECT lpDataObject, DWORD dwKeyState, POINTL pt, LPDWORD pdwEffect)
{
	METHOD_PROLOGUE_EX(COleDropTarget, DropTarget)
	ASSERT_VALID(pThis);

	ASSERT(pdwEffect != NULL);
	ASSERT(lpDataObject != NULL);

	if (lpDataObject == NULL || pdwEffect == NULL)
	{
		return E_INVALIDARG;
	}

	SCODE sc = E_UNEXPECTED;
	TRY
	{
		// cancel drag scrolling
		pThis->m_nTimerID = 0xffff;

		// prepare for call to OnDragOver
		CWnd* pWnd = CWnd::FromHandle(pThis->m_hWnd);
		ASSERT_VALID(pWnd);
		COleDataObject dataObject;
		dataObject.Attach(lpDataObject, FALSE);
		CPoint point((int)pt.x, (int)pt.y);
		pWnd->ScreenToClient(&point);

		// verify that drop is legal
		DROPEFFECT dropEffect = _AfxFilterDropEffect(pThis->OnDragOver(pWnd, &dataObject, dwKeyState, point), *pdwEffect);

		// execute the drop (try OnDropEx then OnDrop for backward compatibility)
		DROPEFFECT temp = pThis->OnDropEx(pWnd, &dataObject, dropEffect, *pdwEffect, point);
		if (temp != -1)
		{
			// OnDropEx was implemented, return its drop effect
			dropEffect = temp;
		}
		else if (dropEffect != DROPEFFECT_NONE)
		{
			// OnDropEx not implemented
			if (!pThis->OnDrop(pWnd, &dataObject, dropEffect, point))
				dropEffect = DROPEFFECT_NONE;
		}
		else
		{
			// drop not accepted, allow cleanup
			pThis->OnDragLeave(pWnd);
		}

		// release potentially cached data object
		RELEASE(pThis->m_lpDataObject);
		*pdwEffect = dropEffect;
		sc = S_OK;
	}
	END_TRY

	return sc;
}

/////////////////////////////////////////////////////////////////////////////
// COleDropTarget diagnostics

#ifdef _DEBUG
void COleDropTarget::AssertValid() const
{
	CCmdTarget::AssertValid();
	if (m_lpDataObject != NULL)
		CWnd::FromHandle(m_hWnd)->AssertValid();
}

void COleDropTarget::Dump(CDumpContext& dc) const
{
	CCmdTarget::Dump(dc);

	dc << "m_hWnd = " << m_hWnd;
	dc << "\nm_lpDataObject = " << m_lpDataObject;
	dc << "\nm_nTimerID = " << m_nTimerID;
	dc << "\nm_dwLastTick = " << m_dwLastTick;

	dc << "\n";
}
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\olefact.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// COleObjectFactory implementation

BEGIN_INTERFACE_MAP(COleObjectFactory, CCmdTarget)
	INTERFACE_PART(COleObjectFactory, IID_IClassFactory, ClassFactory)
	INTERFACE_PART(COleObjectFactory, IID_IClassFactory2, ClassFactory)
END_INTERFACE_MAP()


COleObjectFactory::COleObjectFactory(REFCLSID clsid,
	CRuntimeClass* pRuntimeClass, BOOL bMultiInstance, LPCTSTR lpszProgID)
{
	CommonConstruct(clsid, pRuntimeClass, bMultiInstance,
		afxRegDefault, lpszProgID);
}

COleObjectFactory::COleObjectFactory(REFCLSID clsid,
	CRuntimeClass* pRuntimeClass, BOOL bMultiInstance, int nFlags,
	LPCTSTR lpszProgID)
{
	CommonConstruct(clsid, pRuntimeClass, bMultiInstance,
		nFlags, lpszProgID);
}

void COleObjectFactory::CommonConstruct(REFCLSID clsid,
	CRuntimeClass* pRuntimeClass, BOOL bMultiInstance, int nFlags,
	LPCTSTR lpszProgID)
{
	ASSERT(pRuntimeClass == NULL ||
		pRuntimeClass->IsDerivedFrom(RUNTIME_CLASS(CCmdTarget)));
	ASSERT(AfxIsValidAddress(&clsid, sizeof(CLSID), FALSE));
	ASSERT(lpszProgID == NULL || AfxIsValidString(lpszProgID));

	// initialize to unregistered state
	m_dwRegister = 0;   // not registered yet
	m_bRegistered = FALSE;
	m_clsid = clsid;
	m_pRuntimeClass = pRuntimeClass;
	m_bMultiInstance = bMultiInstance;
	m_nFlags = nFlags;

	m_lpszProgID = lpszProgID;
	m_bOAT = (BYTE) OAT_UNKNOWN;

	// licensing information
	m_bLicenseChecked = FALSE;
	m_bLicenseValid = FALSE;

	// add this factory to the list of factories
	m_pNextFactory = NULL;
	AFX_MODULE_STATE* pModuleState = _AFX_CMDTARGET_GETSTATE();
	AfxLockGlobals(CRIT_OBJECTFACTORYLIST);
	pModuleState->m_factoryList.AddHead(this);
	AfxUnlockGlobals(CRIT_OBJECTFACTORYLIST);

	ASSERT_VALID(this);
}


COleObjectFactory::~COleObjectFactory()
{
	AFX_BEGIN_DESTRUCTOR

	ASSERT_VALID(this);

	if (m_pModuleState == NULL)
		return;

	// deregister this class factory
	Revoke();

	// remove this class factory from the list of active class factories
#ifdef _AFXDLL
	AFX_MODULE_STATE* pModuleState = m_pModuleState;
#else
	AFX_MODULE_STATE* pModuleState = _AFX_CMDTARGET_GETSTATE();
#endif
	AfxLockGlobals(CRIT_OBJECTFACTORYLIST);
	BOOL bResult = pModuleState->m_factoryList.Remove(this);
	AfxUnlockGlobals(CRIT_OBJECTFACTORYLIST);
	if (bResult)
		return;

	// check CDynLinkLibrary objects in case it was transfered during init
#ifdef _AFXDLL
	AfxLockGlobals(CRIT_DYNLINKLIST);
	for (CDynLinkLibrary* pDLL = pModuleState->m_libraryList; pDLL != NULL;
		pDLL = pDLL->m_pNextDLL)
	{
		if (pDLL->m_factoryList.Remove(this))
		{
			AfxUnlockGlobals(CRIT_DYNLINKLIST);
			return;
		}
	}
	AfxUnlockGlobals(CRIT_DYNLINKLIST);
#endif

	AFX_END_DESTRUCTOR
}


BOOL COleObjectFactory::Unregister()
{
	return TRUE;
}

BOOL COleObjectFactory::Register()
{
	ASSERT_VALID(this);
	ASSERT(!m_bRegistered);  // registering server/factory twice?
	ASSERT(m_clsid != CLSID_NULL);

	if (!afxContextIsDLL)
	{
		// In the application variants, the IClassFactory is registered
		//  with the OLE DLLs.

		SCODE sc = ::CoRegisterClassObject(m_clsid, &m_xClassFactory,
			CLSCTX_LOCAL_SERVER,
			m_bMultiInstance ? REGCLS_SINGLEUSE : REGCLS_MULTIPLEUSE,
			&m_dwRegister);
		if (sc != S_OK)
		{
#ifdef _DEBUG
			TRACE(traceOle, 0, _T("Warning: CoRegisterClassObject failed scode = %s.\n"),
				::AfxGetFullScodeString(sc));
#endif
			// registration failed.
			return FALSE;
		}
		ASSERT(m_dwRegister != 0);
	}

	++m_bRegistered;
	return TRUE;
}

BOOL PASCAL COleObjectFactory::UnregisterAll()
{
	BOOL bResult = TRUE;
	// register application factories
	AFX_MODULE_STATE* pModuleState = AfxGetModuleState();
	AfxLockGlobals(CRIT_OBJECTFACTORYLIST);
	for (COleObjectFactory* pFactory = pModuleState->m_factoryList;
		pFactory != NULL; pFactory = pFactory->m_pNextFactory)
	{
		// unregister any registered, non-doctemplate factories
		if (pFactory->IsRegistered() && !pFactory->Unregister())
		{
			bResult = FALSE;
		}
	}
	AfxUnlockGlobals(CRIT_OBJECTFACTORYLIST);
	return bResult;
}

BOOL PASCAL COleObjectFactory::RegisterAll()
{
	BOOL bResult = TRUE;
	// register application factories
	AFX_MODULE_STATE* pModuleState = AfxGetModuleState();
	AfxLockGlobals(CRIT_OBJECTFACTORYLIST);
	COleObjectFactory* pFactory;
	for (pFactory = pModuleState->m_factoryList;
		pFactory != NULL; pFactory = pFactory->m_pNextFactory)
	{
		// register any non-registered, non-doctemplate factories
		if (!pFactory->IsRegistered() &&
			pFactory->m_clsid != CLSID_NULL && !pFactory->Register())
		{
			bResult = FALSE;
		}
	}
	AfxUnlockGlobals(CRIT_OBJECTFACTORYLIST);
#ifdef _AFXDLL
	// register extension DLL factories
	AfxLockGlobals(CRIT_DYNLINKLIST);
	for (CDynLinkLibrary* pDLL = pModuleState->m_libraryList; pDLL != NULL;
		pDLL = pDLL->m_pNextDLL)
	{
		for (COleObjectFactory* pDLLFactory = pDLL->m_factoryList;
			pDLLFactory != NULL; pDLLFactory = pDLLFactory->m_pNextFactory)
		{
			// register any non-registered, non-doctemplate factories
			if (!pDLLFactory->IsRegistered() &&
				pDLLFactory->m_clsid != CLSID_NULL && !pDLLFactory->Register())
			{
				bResult = FALSE;
			}
		}
	}
	AfxUnlockGlobals(CRIT_DYNLINKLIST);
#endif
	return bResult;
}


void COleObjectFactory::Revoke()
{
	ASSERT_VALID(this);

	if (m_bRegistered)
	{
		// revoke the registration of the class itself
		if (m_dwRegister != 0)
		{
			::CoRevokeClassObject(m_dwRegister);
			m_dwRegister = 0;
		}
		m_bRegistered = FALSE;
	}
}

void PASCAL COleObjectFactory::RevokeAll()
{
	AFX_MODULE_STATE* pModuleState = AfxGetModuleState();
	AfxLockGlobals(CRIT_OBJECTFACTORYLIST);
	COleObjectFactory* pFactory;
	for (pFactory = pModuleState->m_factoryList;
		pFactory != NULL; pFactory = pFactory->m_pNextFactory)
	{
		pFactory->Revoke();
	}
	AfxUnlockGlobals(CRIT_OBJECTFACTORYLIST);
#ifdef _AFXDLL
	AfxLockGlobals(CRIT_DYNLINKLIST);
	// register extension DLL factories
	for (CDynLinkLibrary* pDLL = pModuleState->m_libraryList; pDLL != NULL;
		pDLL = pDLL->m_pNextDLL)
	{
		for (COleObjectFactory* pDLLFactory = pDLL->m_factoryList;
			pDLLFactory != NULL; pDLLFactory = pDLLFactory->m_pNextFactory)
		{
			pDLLFactory->Revoke();
		}
	}
	AfxUnlockGlobals(CRIT_DYNLINKLIST);
#endif
}


void COleObjectFactory::UpdateRegistry(LPCTSTR lpszProgID)
{
	ASSERT_VALID(this);
	ASSERT(lpszProgID == NULL || AfxIsValidString(lpszProgID));

	// use default prog-id if specific prog-id not given
	if (lpszProgID == NULL)
	{
		lpszProgID = m_lpszProgID;
		if (lpszProgID == NULL) // still no valid progID?
			return;
	}

	// call global helper to modify system registry
	//  (progid, shortname, and long name are all equal in this case)
	AfxOleRegisterServerClass(m_clsid, lpszProgID, lpszProgID, lpszProgID,
		OAT_DISPATCH_OBJECT);
}

BOOL PASCAL COleObjectFactory::UpdateRegistryAll(BOOL bRegister)
{
	AFX_MODULE_STATE* pModuleState = AfxGetModuleState();
	AfxLockGlobals(CRIT_OBJECTFACTORYLIST);

	COleObjectFactory* pFactory;
	BOOL bRegisterSucceeded = TRUE;

	for (pFactory = pModuleState->m_factoryList;
		pFactory != NULL; pFactory = pFactory->m_pNextFactory)
	{
		if (!pFactory->UpdateRegistry(bRegister))
		{
			bRegisterSucceeded = FALSE;
		}
	}
	AfxUnlockGlobals(CRIT_OBJECTFACTORYLIST);

#ifdef _AFXDLL
	AfxLockGlobals(CRIT_DYNLINKLIST);
	// register extension DLL factories
	for (CDynLinkLibrary* pDLL = pModuleState->m_libraryList; pDLL != NULL;
		pDLL = pDLL->m_pNextDLL)
	{
		for (COleObjectFactory* pDLLFactory = pDLL->m_factoryList;
			pDLLFactory != NULL; pDLLFactory = pDLLFactory->m_pNextFactory)
		{
			if (!pDLLFactory->UpdateRegistry(bRegister))
			{
				bRegisterSucceeded = FALSE;
			}
		}
	}
	AfxUnlockGlobals(CRIT_DYNLINKLIST);
#endif

	return bRegisterSucceeded;
}

CCmdTarget* COleObjectFactory::OnCreateObject()
{
	ASSERT_VALID(this);
	ASSERT(AfxIsValidAddress(m_pRuntimeClass, sizeof(CRuntimeClass), FALSE));
		// this implementation needs a runtime class

	// allocate object, throw exception on failure
	CCmdTarget* pTarget = (CCmdTarget*)m_pRuntimeClass->CreateObject();
	if (pTarget == NULL)
		AfxThrowMemoryException();

	// make sure it is a CCmdTarget
	ASSERT_KINDOF(CCmdTarget, pTarget);
	ASSERT_VALID(pTarget);

	// return the new CCmdTarget object
	return pTarget;
}

BOOL COleObjectFactory::IsLicenseValid()
{
	if (!m_bLicenseChecked)
	{
		m_bLicenseValid = (BYTE)VerifyUserLicense();
		m_bLicenseChecked = TRUE;
	}
	return m_bLicenseValid;
}

BOOL COleObjectFactory::UpdateRegistry(BOOL bRegister)
{
	if (m_lpszProgID == NULL)
		return FALSE;

	BOOL bResult = FALSE;

	if (bRegister)
	{
		// call global helper to modify system registry
		// progid, shortname, and long name are all equal in this case
		bResult = AfxOleRegisterServerClass(m_clsid, m_lpszProgID, m_lpszProgID,
											m_lpszProgID, OAT_DISPATCH_OBJECT);
		if (bResult == TRUE)
		{
			bResult = FALSE;
			const int nBufSize = 1024;
			TCHAR szScratch[nBufSize];
			HKEY hkeyClassID;

			LPOLESTR lpszClassID = NULL;
			if (SUCCEEDED(StringFromCLSID(m_clsid, &lpszClassID)))
			{
				CString strClassID(lpszClassID);

				int nLen;
				ATL_CRT_ERRORCHECK_SPRINTF(nLen = _sntprintf_s(szScratch, _countof(szScratch), _countof(szScratch) - 1, _T("CLSID\\%s"), strClassID.GetString()));
				if (nLen >= 0 && nLen < _countof(szScratch))
				{
					if (AfxRegOpenKeyEx(HKEY_CLASSES_ROOT, szScratch, 0,
						KEY_READ|KEY_WRITE, &hkeyClassID) == ERROR_SUCCESS)
					{
						bResult = AfxOleInprocRegisterHelper(NULL, hkeyClassID, m_nFlags);
						::RegCloseKey(hkeyClassID);
					}
				}
				
				CoTaskMemFree(lpszClassID);
			}
			if (!bResult)
			{
				AfxOleUnregisterServerClass(m_clsid, m_lpszProgID, m_lpszProgID,
					m_lpszProgID, OAT_DISPATCH_OBJECT);
			}
		}
	}
	else
	{
		bResult = AfxOleUnregisterServerClass(m_clsid, m_lpszProgID, m_lpszProgID,
											m_lpszProgID, OAT_DISPATCH_OBJECT);
	}
	return bResult;
}

BOOL COleObjectFactory::VerifyUserLicense()
{
	// May be overridden by subclass
	return TRUE;
}

BOOL COleObjectFactory::GetLicenseKey(DWORD, BSTR*)
{
	// May be overridden by subclass
	return FALSE;
}

BOOL COleObjectFactory::VerifyLicenseKey(BSTR bstrKey)
{
	// May be overridden by subclass

	BOOL bLicensed = FALSE;
	BSTR bstr = NULL;

    if (::SysStringLen(bstrKey) != 0 && GetLicenseKey(0, &bstr))
	{
        ASSERT(::SysStringLen(bstr) != 0);

		// if length and content match, it's good!

		UINT cch = SysStringByteLen(bstr);
		if ((cch == SysStringByteLen(bstrKey)) &&
			(memcmp(bstr, bstrKey, cch) == 0))
		{
			bLicensed = TRUE;
		}

		SysFreeString(bstr);
	}

	return bLicensed;
}

/////////////////////////////////////////////////////////////////////////////
// Implementation of COleObjectFactory::IClassFactory interface

STDMETHODIMP_(ULONG) COleObjectFactory::XClassFactory::AddRef()
{
	METHOD_PROLOGUE_EX_(COleObjectFactory, ClassFactory)
	return pThis->InternalAddRef();
}

STDMETHODIMP_(ULONG) COleObjectFactory::XClassFactory::Release()
{
	METHOD_PROLOGUE_EX_(COleObjectFactory, ClassFactory)
	return pThis->InternalRelease();
}

STDMETHODIMP COleObjectFactory::XClassFactory::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(COleObjectFactory, ClassFactory)
	return pThis->InternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP COleObjectFactory::XClassFactory::CreateInstance(
	IUnknown* pUnkOuter, REFIID riid, LPVOID* ppvObject)
{
	return CreateInstanceLic(pUnkOuter, NULL, riid, NULL, ppvObject);
}

STDMETHODIMP COleObjectFactory::XClassFactory::LockServer(BOOL fLock)
{
	METHOD_PROLOGUE_EX(COleObjectFactory, ClassFactory)
	ASSERT_VALID(pThis);

	SCODE sc = E_UNEXPECTED;
	TRY
	{
		if (fLock)
			AfxOleLockApp();
		else
			AfxOleUnlockApp();
		sc = S_OK;
	}
	END_TRY

	return sc;
}

STDMETHODIMP COleObjectFactory::XClassFactory::GetLicInfo(
	LPLICINFO pLicInfo)
{
	METHOD_PROLOGUE_EX(COleObjectFactory, ClassFactory)
	ASSERT_VALID(pThis);

	BSTR bstr = NULL;
	pLicInfo->fLicVerified = pThis->IsLicenseValid();
	pLicInfo->fRuntimeKeyAvail = pThis->GetLicenseKey(0, &bstr);
    ::SysFreeString(bstr);

	return S_OK;
}

STDMETHODIMP COleObjectFactory::XClassFactory::RequestLicKey(
	DWORD dwReserved, BSTR* pbstrKey)
{
	METHOD_PROLOGUE_EX(COleObjectFactory, ClassFactory)
	ASSERT_VALID(pThis);

	ASSERT(pbstrKey != NULL);

	*pbstrKey = NULL;

	if (pThis->IsLicenseValid())
	{
		if (pThis->GetLicenseKey(dwReserved, pbstrKey))
			return S_OK;
		else
			return E_FAIL;
	}
	else
		return CLASS_E_NOTLICENSED;
}

STDMETHODIMP COleObjectFactory::XClassFactory::CreateInstanceLic(
	LPUNKNOWN pUnkOuter, LPUNKNOWN /* pUnkReserved */, REFIID riid,
	BSTR bstrKey, LPVOID* ppvObject)
{
	METHOD_PROLOGUE_EX(COleObjectFactory, ClassFactory)
	ASSERT_VALID(pThis);

	if (ppvObject == NULL)
		return E_POINTER;
	*ppvObject = NULL;

    if (((::SysStringLen(bstrKey)!=0) && !pThis->VerifyLicenseKey(bstrKey)) ||
		((::SysStringLen(bstrKey)==0) && !pThis->IsLicenseValid()))
    {
		return CLASS_E_NOTLICENSED;
    }

	// outer objects must ask for IUnknown only
	if (pUnkOuter != NULL && riid != IID_IUnknown)
		return CLASS_E_NOAGGREGATION;

	// attempt to create the object
	CCmdTarget* pTarget = NULL;
	SCODE sc = E_OUTOFMEMORY;
	TRY
	{
		// attempt to create the object
		pTarget = pThis->OnCreateObject();
		if (pTarget != NULL)
		{
			// check for aggregation on object not supporting it
			sc = CLASS_E_NOAGGREGATION;
			if (pUnkOuter == NULL || pTarget->m_xInnerUnknown != 0)
			{
				// create aggregates used by the object
				pTarget->m_pOuterUnknown = pUnkOuter;
				sc = E_OUTOFMEMORY;
				if (pTarget->OnCreateAggregates())
					sc = S_OK;
			}
		}
	}
	END_TRY

	// finish creation
	if (sc == S_OK)
	{
		DWORD dwRef = 1;
		if (pUnkOuter != NULL)
		{
			// return inner unknown instead of IUnknown
			*ppvObject = &pTarget->m_xInnerUnknown;
		}
		else
		{
			// query for requested interface
			sc = pTarget->InternalQueryInterface(&riid, ppvObject);
			if (sc == S_OK)
			{
				dwRef = pTarget->InternalRelease();
				ASSERT(dwRef != 0);
			}
		}
		if (dwRef != 1)
			TRACE(traceOle, 0, "Warning: object created with reference of %ld\n", dwRef);
	}

	// cleanup in case of errors
	if (sc != S_OK)
		delete pTarget;

	return sc;
}

//////////////////////////////////////////////////////////////////////////////
// Diagnostics

#ifdef _DEBUG
void COleObjectFactory::AssertValid() const
{
	CCmdTarget::AssertValid();
	ASSERT(m_lpszProgID == NULL || AfxIsValidString(m_lpszProgID));
	ASSERT(m_pRuntimeClass == NULL ||
		AfxIsValidAddress(m_pRuntimeClass, sizeof(CRuntimeClass), FALSE));
	ASSERT(m_pNextFactory == NULL ||
		AfxIsValidAddress(m_pNextFactory, sizeof(COleObjectFactory)));
}

void COleObjectFactory::Dump(CDumpContext& dc) const
{
	USES_CONVERSION;

	CCmdTarget::Dump(dc);

	dc << "m_pNextFactory = " << (void*)m_pNextFactory;
	dc << "\nm_dwRegister = " << m_dwRegister;
	dc << "\nm_bRegistered = " << m_bRegistered;
	LPOLESTR lpszClassID = NULL;
	if (StringFromCLSID(m_clsid, &lpszClassID) == S_OK)
	{
		dc << "\nm_clsid = " << CString(lpszClassID);
		CoTaskMemFree(lpszClassID);
	}
	dc << "\nm_pRuntimeClass = " << m_pRuntimeClass;
	dc << "\nm_bMultiInstance = " << m_bMultiInstance;
	dc << "\nm_lpszProgID = " << m_lpszProgID;
	dc << "\nm_bLicenseChecked = " << m_bLicenseChecked;
	dc << "\nm_bLicenseValid = " << m_bLicenseValid;

	dc << "\n";
}
#endif //_DEBUG


IMPLEMENT_DYNAMIC(COleObjectFactory, CCmdTarget)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\oleenum.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CEnumArray (provides OLE enumerator for arbitrary items in an array)

CEnumArray::CEnumArray(size_t nSizeElem, const void* pvEnum, UINT nSize,
	BOOL bNeedFree)
{
	m_nSizeElem = nSizeElem;
	m_pClonedFrom = NULL;

	m_nCurPos = 0;
	m_nSize = nSize;
	m_pvEnum = (BYTE*)pvEnum;
	m_bNeedFree = bNeedFree;

	ASSERT_VALID(this);
}

CEnumArray::~CEnumArray()
{
	ASSERT_VALID(this);

	// release the clone pointer (only for clones)
	if (m_pClonedFrom != NULL)
	{
		m_pClonedFrom->InternalRelease();
		ASSERT(!m_bNeedFree);
	}

	// release the pointer (should only happen on non-clones)
	if (m_bNeedFree)
	{
		ASSERT(m_pClonedFrom == NULL);
		delete m_pvEnum;
	}
}

BOOL CEnumArray::OnNext(void* pv)
{
	ASSERT_VALID(this);

	if (m_nCurPos >= m_nSize)
		return FALSE;

	Checked::memcpy_s(pv, m_nSizeElem, 
		&m_pvEnum[m_nCurPos*m_nSizeElem], m_nSizeElem);

	++m_nCurPos;
	return TRUE;
}

BOOL CEnumArray::OnSkip()
{
	ASSERT_VALID(this);

	if (m_nCurPos >= m_nSize)
		return FALSE;

	return ++m_nCurPos < m_nSize;
}

void CEnumArray::OnReset()
{
	ASSERT_VALID(this);

	m_nCurPos = 0;
}

CEnumArray* CEnumArray::OnClone()
{
	ASSERT_VALID(this);

	// set up an exact copy of this object
	//  (derivatives may have to replace this code)
	CEnumArray* pClone;
	pClone = new CEnumArray(m_nSizeElem, m_pvEnum, m_nSize);
	ASSERT(pClone != NULL);
	ASSERT(!pClone->m_bNeedFree);   // clones should never free themselves
	pClone->m_nCurPos = m_nCurPos;

	// finally, return the clone to OLE
	ASSERT_VALID(pClone);
	return pClone;
}

/////////////////////////////////////////////////////////////////////////////
// CEnumArray::XEnumVOID implementation

STDMETHODIMP_(ULONG) CEnumArray::XEnumVOID::AddRef()
{
	METHOD_PROLOGUE_EX_(CEnumArray, EnumVOID)
	return pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CEnumArray::XEnumVOID::Release()
{
	METHOD_PROLOGUE_EX_(CEnumArray, EnumVOID)
	return pThis->ExternalRelease();
}

STDMETHODIMP CEnumArray::XEnumVOID::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(CEnumArray, EnumVOID)
	return pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP CEnumArray::XEnumVOID::Next(
	ULONG celt, void* reelt, ULONG* pceltFetched)
{
	METHOD_PROLOGUE_EX(CEnumArray, EnumVOID);
	ASSERT_VALID(pThis);

	if (pceltFetched != NULL)
		*pceltFetched = 0;

	ASSERT(celt > 0);
	ASSERT(celt == 1 || pceltFetched != NULL);

	BYTE* pchCur = (BYTE*)reelt;

	ULONG celtT = celt;
	SCODE sc = E_UNEXPECTED;
	TRY
	{
		while (celtT != 0 && pThis->OnNext((void*)pchCur))
		{
			pchCur += pThis->m_nSizeElem;
			--celtT;
		}
		if (pceltFetched != NULL)
			*pceltFetched = celt - celtT;
		sc = celtT == 0 ? S_OK : S_FALSE;
	}
	END_TRY

	return sc;
}

STDMETHODIMP CEnumArray::XEnumVOID::Skip(ULONG celt)
{
	METHOD_PROLOGUE_EX(CEnumArray, EnumVOID);
	ASSERT_VALID(pThis);

	ULONG celtT = celt;
	SCODE sc = E_UNEXPECTED;
	TRY
	{
		while (celtT != 0 && pThis->OnSkip())
			--celtT;
		sc = celtT == 0 ? S_OK : S_FALSE;
	}
	END_TRY

	return celtT != 0 ? S_FALSE : S_OK;
}

STDMETHODIMP CEnumArray::XEnumVOID::Reset()
{
	METHOD_PROLOGUE_EX(CEnumArray, EnumVOID);
	ASSERT_VALID(pThis);

	pThis->OnReset();
	return S_OK;
}

STDMETHODIMP CEnumArray::XEnumVOID::Clone(IEnumVOID** ppenm)
{
	METHOD_PROLOGUE_EX(CEnumArray, EnumVOID);
	ASSERT_VALID(pThis);

	*ppenm = NULL;

	SCODE sc = E_UNEXPECTED;
	TRY
	{
		CEnumArray* pEnumHelper = pThis->OnClone();
		ASSERT_VALID(pEnumHelper);

		// we use an extra reference to keep the original object alive
		//  (the extra reference is removed in the clone's destructor)
		if (pThis->m_pClonedFrom != NULL)
			pEnumHelper->m_pClonedFrom = pThis->m_pClonedFrom;
		else
			pEnumHelper->m_pClonedFrom = pThis;
		pEnumHelper->m_pClonedFrom->InternalAddRef();
		*ppenm = &pEnumHelper->m_xEnumVOID;

		sc = S_OK;
	}
	END_TRY

	return sc;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\oleipfrm.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// COleCntrFrameWnd implementation

COleCntrFrameWnd::COleCntrFrameWnd(COleIPFrameWnd* pInPlaceFrame)
{
	m_pInPlaceFrame = pInPlaceFrame;
	RemoveFrameWnd();
}

COleCntrFrameWnd::~COleCntrFrameWnd()
{
	AFX_BEGIN_DESTRUCTOR

		AddFrameWnd();
		Detach();

	AFX_END_DESTRUCTOR
}

void COleCntrFrameWnd::RecalcLayout(BOOL /*bNotify*/)
{
	if (!m_bInRecalcLayout)
	{
		m_bInRecalcLayout = TRUE;
		m_nIdleFlags &= ~(idleLayout|idleNotify);

		ASSERT_VALID(m_pInPlaceFrame);
		COleServerDoc* pDoc = (COleServerDoc*)m_pInPlaceFrame->GetActiveDocument();
		CWinThread *pThread = AfxGetThread();
		ENSURE_VALID(pThread);
		if (pDoc != NULL && pThread->m_pActiveWnd == m_pInPlaceFrame)
		{
			ASSERT_VALID(pDoc);
			ASSERT_KINDOF(COleServerDoc, pDoc);

			if (this == m_pInPlaceFrame->m_pMainFrame)
				pDoc->OnResizeBorder(NULL, m_pInPlaceFrame->m_lpFrame, TRUE);
			if (this == m_pInPlaceFrame->m_pDocFrame)
				pDoc->OnResizeBorder(NULL, m_pInPlaceFrame->m_lpDocFrame, FALSE);
		}
		m_bInRecalcLayout = FALSE;
	}
}

void COleCntrFrameWnd::OnIdleUpdateCmdUI()
{
	// do frame delayed recalc
	if (m_nIdleFlags & idleLayout)
		RecalcLayout(m_nIdleFlags & idleNotify);

	// update control bars
	POSITION pos = m_listControlBars.GetHeadPosition();
	while (pos != NULL)
	{
		CControlBar* pBar = (CControlBar*)m_listControlBars.GetNext(pos);
		ASSERT(pBar != NULL);
		ASSERT_VALID(pBar);
		AfxCallWndProc(pBar, pBar->m_hWnd, WM_IDLEUPDATECMDUI, TRUE, 0);
	}
}

BOOL COleCntrFrameWnd::OnCmdMsg(UINT nID, int nCode, void* pExtra,
	AFX_CMDHANDLERINFO* pHandlerInfo)
{
	ASSERT_VALID(m_pInPlaceFrame);

	// pump through inplace frame
	CPushRoutingFrame push(this);
	return m_pInPlaceFrame->OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
}

void COleCntrFrameWnd::PostNcDestroy()
{
	// do nothing to avoid destroying window
}

#ifdef _DEBUG
void COleCntrFrameWnd::AssertValid() const
{
	// COleCntrFrameWnd bends the CWnd rules just a little bit.

	ASSERT(m_hWnd == NULL || ::IsWindow(m_hWnd));
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// COleIPFrameWnd implementation

BEGIN_MESSAGE_MAP(COleIPFrameWnd, CFrameWnd)
	//{{AFX_MSG_MAP(COleIPFrameWnd)
	ON_WM_SIZE()
	ON_MESSAGE(WM_RECALCPARENT, &COleIPFrameWnd::OnRecalcParent)
	ON_MESSAGE_VOID(WM_IDLEUPDATECMDUI, COleIPFrameWnd::OnIdleUpdateCmdUI)
	ON_WM_WINDOWPOSCHANGING()
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_MESSAGE(WM_SIZECHILD, &COleIPFrameWnd::OnResizeChild)
	ON_MESSAGE(WM_SETMESSAGESTRING, &COleIPFrameWnd::OnSetMessageString)
	ON_UPDATE_COMMAND_UI(ID_VIEW_STATUS_BAR, &COleIPFrameWnd::OnUpdateControlBarMenu)
	ON_COMMAND_EX(ID_VIEW_STATUS_BAR, &COleIPFrameWnd::OnBarCheck)
	ON_UPDATE_COMMAND_UI(ID_VIEW_TOOLBAR, &COleIPFrameWnd::OnUpdateControlBarMenu)
	ON_COMMAND_EX(ID_VIEW_TOOLBAR, &COleIPFrameWnd::OnBarCheck)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

COleIPFrameWnd::COleIPFrameWnd()
{
	// initialize OLEINPLACEFRAMEINFO struct
	memset(&m_frameInfo, 0, sizeof(m_frameInfo));
	m_frameInfo.cb = sizeof m_frameInfo;

	// initialize in-place state
	m_bUIActive = FALSE;
	m_lpFrame = NULL;
	m_lpDocFrame = NULL;
	m_hOleMenu = NULL;
	m_rectPos.SetRectEmpty();
	m_rectClip.SetRectEmpty();
	m_bInsideRecalc = FALSE;
	m_hSharedMenu = NULL;
	m_pMainFrame = NULL;
	m_pDocFrame = NULL;
	m_bPreviewMode = FALSE;
	m_hMenuHelpPopup = NULL;
	ASSERT_VALID(this);
}

COleIPFrameWnd::~COleIPFrameWnd()
{
	ASSERT_VALID(this);

	// destroy wrappers of container's frames
	delete m_pMainFrame;
	delete m_pDocFrame;

	// destroy shared menu
	if (m_hSharedMenu != NULL)
		::DestroyMenu(m_hSharedMenu);

	// interfaces to the container should already be released
	RELEASE(m_lpFrame);
	RELEASE(m_lpDocFrame);
}

int COleIPFrameWnd::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	ASSERT_VALID(this);

	if (CFrameWnd::OnCreate(lpCreateStruct) < 0)
		return -1;

	// remove WS_EX_CLIENTEDGE style if present
	ModifyStyleEx(WS_EX_CLIENTEDGE, 0, 0);

	// need to remove the pending WM_SETMESSAGESTRING from the queue
	MSG msg;
	PeekMessage(&msg, m_hWnd, WM_SETMESSAGESTRING, WM_SETMESSAGESTRING,
		PM_REMOVE|PM_NOYIELD);

	ASSERT_VALID(this);
	return 0;
}

void COleIPFrameWnd::OnDestroy()
{
	// notify the container that the rectangle has changed!
	COleServerDoc* pDoc = (COleServerDoc*)GetActiveDocument();
	if (pDoc != NULL)
	{
		ASSERT_KINDOF(COleServerDoc, pDoc);

		// close and abort changes to the document
		pDoc->DisconnectViews();
		pDoc->OnCloseDocument();
	}

	// explicitly destroy all of the dock bars since this window
	// is actually in the container and will not be destroyed
	if (m_pMainFrame != NULL)
		m_pMainFrame->DestroyDockBars();
	if (m_pDocFrame != NULL)
		m_pDocFrame->DestroyDockBars();

	CFrameWnd::OnDestroy();
}

BOOL COleIPFrameWnd::OnCreateControlBars(CWnd* pWndFrame, CWnd* /*pWndDoc*/)
{
	ASSERT(pWndFrame != NULL);
	UNUSED(pWndFrame);  // not used in release builds

	return TRUE;
}

BOOL COleIPFrameWnd::OnCreateControlBars(CFrameWnd* pWndFrame,
	CFrameWnd* pWndDoc)
{
	return OnCreateControlBars((CWnd*)pWndFrame, (CWnd*)pWndDoc);
}

void COleIPFrameWnd::OnIdleUpdateCmdUI()
{
	// update toolbars which may be on the container
	// and allow delayed recalc layouts to execute
	if (m_pMainFrame != NULL)
		m_pMainFrame->OnIdleUpdateCmdUI();
	if (m_pDocFrame != NULL)
		m_pDocFrame->OnIdleUpdateCmdUI();
}

void COleIPFrameWnd::OnWindowPosChanging(LPWINDOWPOS lpWndPos)
{
	MSG msg;
	if (!::PeekMessage(&msg, NULL, WM_KICKIDLE, WM_KICKIDLE, PM_NOREMOVE))
		::PostThreadMessage(GetCurrentThreadId(), WM_KICKIDLE, 0, 0);

	CFrameWnd::OnWindowPosChanging(lpWndPos);
}

LRESULT COleIPFrameWnd::OnSetMessageString(WPARAM wParam, LPARAM lParam)
{
	if (m_lpFrame != NULL)
	{
		LPCTSTR lpsz = NULL;
		CString strMessage;

		// set the message bar text
		if (lParam != NULL)
		{
			ASSERT(wParam == 0);    // can't have both an ID and a string
			lpsz = (LPCTSTR)lParam; // set an explicit string
		}
		else if (wParam != 0)
		{
			// get message associated with the ID indicated by wParam
			GetMessageString((UINT)wParam, strMessage);
			lpsz = strMessage;
		}

		// notify container of new status text
		if (lpsz == NULL)
			lpsz = _T("");
		m_lpFrame->SetStatusText(CStringW(lpsz).GetString());
	}

	UINT nIDLast = m_nIDLastMessage;
	m_nIDLastMessage = (UINT)wParam;    // new ID (or 0)
	m_nIDTracking = (UINT)wParam;       // so F1 on toolbar buttons work
	return nIDLast;
}

BOOL COleIPFrameWnd::LoadFrame(UINT nIDResource, DWORD dwDefaultStyle,
	CWnd* pParentWnd, CCreateContext* pContext)
{
	if (pParentWnd != NULL)
		ASSERT_VALID(pParentWnd);

	// only do this once
	ASSERT_VALID_IDR(nIDResource);
	ASSERT(m_nIDHelp == 0 || m_nIDHelp == nIDResource);

	m_nIDHelp = nIDResource;    // ID for help context (+HID_BASE_RESOURCE)

	// create the window (use child window style create)
	CRect rect(0, 0, 0, 0);
	if (!CWnd::Create(NULL, NULL, dwDefaultStyle, rect, pParentWnd,
		nIDResource, pContext))
	{
		return FALSE;   // will self destruct on failure normally
	}

	// load accelerator resource
	LoadAccelTable(MAKEINTRESOURCE(nIDResource));

	return TRUE;
}

void COleIPFrameWnd::OnSize(UINT /*nType*/, int /*cx*/, int /*cy*/)
{
	// recalc layout is not called in OnSize since COleIPFrameWnd does
	//  "inside out" recalc -- which is driven by the size of the
	//  inner most window changing, not the outer most!
}

LRESULT COleIPFrameWnd::OnResizeChild(WPARAM, LPARAM lParam)
{
	// notify the container that the rectangle has changed!
	COleServerDoc* pDoc = (COleServerDoc*)GetActiveDocument();
	if (pDoc == NULL)
		return 0;

	ASSERT_KINDOF(COleServerDoc, pDoc);

	// get new rect and parent
	CRect rectNew;
	rectNew.CopyRect((LPCRECT)lParam);
	CWnd* pParentWnd = GetParent();
	ASSERT_VALID(pParentWnd);

	// convert rectNew relative to pParentWnd
	ClientToScreen(&rectNew);
	pParentWnd->ScreenToClient(&rectNew);

	// adjust the new rectangle for the current control bars
	CWnd* pLeftOver = GetDlgItem(AFX_IDW_PANE_FIRST);
	ASSERT(pLeftOver != NULL);
	CRect rectCur = m_rectPos;
	pLeftOver->CalcWindowRect(&rectCur, CWnd::adjustOutside);
	rectNew.left += m_rectPos.left - rectCur.left;
	rectNew.top += m_rectPos.top - rectCur.top;
	rectNew.right -= rectCur.right - m_rectPos.right;
	rectNew.bottom -= rectCur.bottom - m_rectPos.bottom;
	OnRequestPositionChange(rectNew);

	return 0;
}

void COleIPFrameWnd::OnRequestPositionChange(LPCRECT lpRect)
{
	COleServerDoc* pDoc = (COleServerDoc*)GetActiveDocument();
	ASSERT_VALID(pDoc);
	ASSERT_KINDOF(COleServerDoc, pDoc);

	// DocObjects don't need to generate OnPosRectChange calls,
	// so we can just return if this is a DoCobject

	if (pDoc->IsDocObject())
		return;

	// The default behavior is to not affect the extent during the
	//  call to RequestPositionChange.  This results in consistent
	//  scaling behavior.

	pDoc->RequestPositionChange(lpRect);
}

LRESULT COleIPFrameWnd::OnRecalcParent(WPARAM, LPARAM lParam)
{
	// simply call recalc layout
	RepositionFrame(&m_rectPos, &m_rectClip);

	// fill in the new rectangle if specified
	if ((LPRECT)lParam != NULL)
		*(LPRECT)lParam = m_rectPos;

	return TRUE;
}

void COleIPFrameWnd::RecalcLayout(BOOL /*bNotify*/)
{
	ASSERT_VALID(this);

	// better have a parent window (only used for inplace)
	CWnd* pParentWnd = GetParent();
	ASSERT_VALID(pParentWnd);

	// see if this frame is supporting a normal in-place object or
	// a DocObject. DocObjects put scrollbars on the inside of the rect

	UINT nAdjustType = CWnd::adjustBorder;
	COleServerDoc* pDoc = (COleServerDoc*) GetActiveDocument();
	if (pDoc != NULL)
	{
		ASSERT_VALID(pDoc);
		if (pDoc->IsDocObject())
			nAdjustType = CWnd::adjustOutside;
	}

	// first call reposition bars with arbitarily large rect just to
	//  see how much space the bars will take up
	CRect rectBig(0, 0, INT_MAX/2, INT_MAX/2);
	CRect rectLeft;
	RepositionBars(0, 0xffff, AFX_IDW_PANE_FIRST, reposQuery,
		&rectLeft, &rectBig);

	// grow the rect by the size of the control bars
	CRect rect = m_rectPos;
	rect.left -= rectLeft.left;
	rect.top -= rectLeft.top;
	rect.right += INT_MAX/2 - rectLeft.right;
	rect.bottom += INT_MAX/2 - rectLeft.bottom;

	// see how much extra space for non-client areas (such as scrollbars)
	//  that the view needs.
	CWnd* pLeftOver = GetDlgItem(AFX_IDW_PANE_FIRST);
	if (pLeftOver != NULL)
	{
		rectBig = m_rectPos;
		pLeftOver->CalcWindowRect(&rectBig, CWnd::adjustOutside);
		rect.left -= m_rectPos.left - rectBig.left;
		rect.top -= m_rectPos.top - rectBig.top;
		rect.right += rectBig.right - m_rectPos.right;
		rect.bottom += rectBig.bottom - m_rectPos.bottom;
	}

	// adjust for non-client area on the frame window
	CalcWindowRect(&rect, nAdjustType);

	// the frame window must be clipped to the visible part in the container
	CRect rectVis;
	rectVis.IntersectRect(&rect, &m_rectClip);

	// move the window
	AfxRepositionWindow(NULL, m_hWnd, &rectVis);

	// now resize the control bars relative to the (now moved) frame
	pParentWnd->ClientToScreen(&rect);
	ScreenToClient(&rect);
	RepositionBars(0, 0xffff, AFX_IDW_PANE_FIRST,
		CWnd::reposDefault, NULL, &rect);
}

void COleIPFrameWnd::RepositionFrame(LPCRECT lpPosRect, LPCRECT lpClipRect)
{
	ASSERT(AfxIsValidAddress(lpPosRect, sizeof(RECT), FALSE));
	ASSERT(AfxIsValidAddress(lpClipRect, sizeof(RECT), FALSE));

	// gaurd against recursion
	if (m_bInsideRecalc)
		return;
	m_bInsideRecalc = TRUE;

	// remember the client area for later
	m_rectPos.CopyRect(lpPosRect);
	m_rectClip.CopyRect(lpClipRect);

	// recalc layout based on new position & clipping rectangles
	RecalcLayout();

	// remove recursion lockout
	m_bInsideRecalc = FALSE;
}

BOOL COleIPFrameWnd::PreTranslateMessage(MSG* pMsg)
{
	// check server's accelerators first
	if (CFrameWnd::PreTranslateMessage(pMsg))
		return TRUE;

	if (pMsg->message >= WM_KEYFIRST && pMsg->message <= WM_KEYLAST)
	{
		// always check to see if they exist in the default accel table
		//  (they may exist but not be translated when disabled)
		HACCEL hAccel = GetDefaultAccelerator();
		if (hAccel != NULL && IsAccelerator(hAccel,
			CopyAcceleratorTable(hAccel, NULL, 0), pMsg, NULL))
		{
			return TRUE;
		}

		// check container's accelerators as last chance
		OLEINPLACEFRAMEINFO frameInfo = m_frameInfo;
		if (::OleTranslateAccelerator(m_lpFrame, &frameInfo, pMsg) == S_OK)
			return TRUE;
	}

	return FALSE;   // keystroke not processed.
}

void COleIPFrameWnd::OnUpdateControlBarMenu(CCmdUI* pCmdUI)
{
	if (GetControlBar(pCmdUI->m_nID) != NULL)
		CFrameWnd::OnUpdateControlBarMenu(pCmdUI);
	else if (m_pMainFrame != NULL &&
		m_pMainFrame->GetControlBar(pCmdUI->m_nID) != NULL)
	{
		m_pMainFrame->OnUpdateControlBarMenu(pCmdUI);
	}
	else if (m_pDocFrame != NULL &&
		m_pDocFrame->GetControlBar(pCmdUI->m_nID) != NULL)
	{
		m_pDocFrame->OnUpdateControlBarMenu(pCmdUI);
	}
	else
		pCmdUI->ContinueRouting();
}

BOOL COleIPFrameWnd::OnBarCheck(UINT nID)
{
	if (GetControlBar(nID) != NULL)
		return CFrameWnd::OnBarCheck(nID);
	else if (m_pMainFrame != NULL && m_pMainFrame->GetControlBar(nID) != NULL)
		return m_pMainFrame->OnBarCheck(nID);
	else if (m_pDocFrame != NULL && m_pDocFrame->GetControlBar(nID) != NULL)
		return m_pDocFrame->OnBarCheck(nID);
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Special-case context sensitive help

void COleIPFrameWnd::OnContextHelp()
{
	if (m_bHelpMode == HELP_ACTIVE || !CanEnterHelpMode())
		return;

	// notify container that we are entering context sensitive help
	BOOL bHelpMode = m_bHelpMode;
	m_bHelpMode = HELP_ACTIVE;
	ASSERT(m_lpFrame != NULL);
	if (m_lpFrame->ContextSensitiveHelp(TRUE) != S_OK ||
		(m_lpDocFrame != NULL && m_lpDocFrame->ContextSensitiveHelp(TRUE) != S_OK))
	{
		m_bHelpMode = HELP_INACTIVE;
		return;
	}
	m_bHelpMode = bHelpMode;

	// echo help mode to top-level frame
	CFrameWnd* pFrameWnd = GetTopLevelFrame();
	ENSURE(pFrameWnd);
	if (pFrameWnd != this)
	{
		pFrameWnd->m_bHelpMode = HELP_ACTIVE;
	}

	// now enter context sensitive help mode ourselves
	CFrameWnd::OnContextHelp();

	// echo help mode to top-level frame
	if (pFrameWnd != this)
		pFrameWnd->m_bHelpMode = m_bHelpMode;

	if (m_bHelpMode == HELP_INACTIVE)
	{
		// make sure container exits context sensitive help mode
		m_lpFrame->ContextSensitiveHelp(FALSE);
		if (m_lpDocFrame != NULL)
			m_lpDocFrame->ContextSensitiveHelp(FALSE);
	}
}

/////////////////////////////////////////////////////////////////////////////
// In-place activation startup

HMENU COleIPFrameWnd::GetInPlaceMenu()
{
	// get active document associated with this frame window
	CDocument* pDoc = GetActiveDocument();
	ASSERT_VALID(pDoc);

	// get in-place menu from the doc template
	CDocTemplate* pTemplate = pDoc->GetDocTemplate();
	ASSERT_VALID(pTemplate);
	return pTemplate->m_hMenuInPlaceServer;
}

BOOL COleIPFrameWnd::BuildSharedMenu()
{
	HMENU hMenu = GetInPlaceMenu();

	// create shared menu
	ASSERT(m_hSharedMenu == NULL);
	if ((m_hSharedMenu = ::CreateMenu()) == NULL)
		return FALSE;

	// start out by getting menu from container
	memset(&m_menuWidths, 0, sizeof m_menuWidths);
	if (m_lpFrame->InsertMenus(m_hSharedMenu, &m_menuWidths) != S_OK)
	{
		::DestroyMenu(m_hSharedMenu);
		m_hSharedMenu = NULL;
		return FALSE;
	}

	// only copy the popups if there is a menu loaded
	if (hMenu == NULL)
		return TRUE;

	BOOL bMergeHelpMenus = FALSE;
	// special case - we're embedded in a docobject server that's in a docobject container	
	if (m_menuWidths.width[5] != 0)
		bMergeHelpMenus = TRUE;
	// insert our menu popups amongst the container menus
	m_hMenuHelpPopup = AfxMergeMenus(m_hSharedMenu, hMenu, &m_menuWidths.width[0], 1, bMergeHelpMenus);

	// finally create the special OLE menu descriptor
	m_hOleMenu = ::OleCreateMenuDescriptor(m_hSharedMenu, &m_menuWidths);

	return m_hOleMenu != NULL;
}

void COleIPFrameWnd::DestroySharedMenu()
{
	if (m_hSharedMenu == NULL)
	{
		ASSERT(m_hOleMenu == NULL);
		ASSERT(m_hMenuHelpPopup == NULL);
		return;
	}

	// get in-place menu to be unmerged (must be same as during activation)
	HMENU hMenu = GetInPlaceMenu();
	if (hMenu == NULL)
		return;

	// remove our menu popups from the shared menu
	AfxUnmergeMenus(m_hSharedMenu, hMenu, m_hMenuHelpPopup);

	// allow container to remove its items from the menu
	ASSERT(m_lpFrame != NULL);
	VERIFY(m_lpFrame->RemoveMenus(m_hSharedMenu) == S_OK);

	// now destroy the menu
	::DestroyMenu(m_hSharedMenu);
	m_hSharedMenu = NULL;

	if (m_hOleMenu != NULL)
	{
		VERIFY(::OleDestroyMenuDescriptor(m_hOleMenu) == S_OK);
		m_hOleMenu = NULL;
	}
	m_hMenuHelpPopup = NULL;
}

/////////////////////////////////////////////////////////////////////////////
// COleIPFrameWnd diagnostics

#ifdef _DEBUG
void COleIPFrameWnd::AssertValid() const
{
	CFrameWnd::AssertValid();
	if (m_hSharedMenu != NULL)
		ASSERT(::IsMenu(m_hSharedMenu));
}

void COleIPFrameWnd::Dump(CDumpContext& dc) const
{
	CFrameWnd::Dump(dc);

	dc << "m_lpFrame = " << m_lpFrame;
	dc << "\nm_lpDocFrame = " << m_lpDocFrame;
	dc << "\nm_hOleMenu = " << m_hOleMenu;
	dc << "\nm_rectPos = " << m_rectPos;
	dc << "\nm_rectClip = " << m_rectClip;
	dc << "\nm_bInsideRecalc = " << m_bInsideRecalc;
	dc << "\nm_hSharedMenu = " << m_hSharedMenu;

	dc << "\n";
}
#endif //_DEBUG


IMPLEMENT_DYNCREATE(COleIPFrameWnd, CFrameWnd)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\olelock.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



/////////////////////////////////////////////////////////////////////////////
// Global functions which handle app shutdown

// Note: these functions can be replaced by replacing this module in its
//  entirety (although doing so would be rare).

void AFXAPI AfxOleOnReleaseAllObjects()
{
	// don't shut down the application if user is in control of the app
	if (AfxOleGetUserCtrl())
		return;

	AfxOleSetUserCtrl(TRUE);    // avoid re-entry

	// shut down the application
	CWinApp* pApp = AfxGetApp();
	if (pApp != NULL && pApp->m_pMainWnd != NULL)
	{
		// destroy the main window (only if enabled)
		if (pApp->m_pMainWnd->IsWindowEnabled())
		{
			// the main window will post WM_QUIT as part of its shutdown
			pApp->m_pMainWnd->DestroyWindow();
		}
	}
	else if (!afxContextIsDLL)
	{
		// no main window, so just post WM_QUIT.
		AfxPostQuitMessage(0);
	}
}

BOOL AFXAPI AfxOleCanExitApp()
{
	AFX_MODULE_STATE* pModuleState = AfxGetModuleState();
	return pModuleState->m_nObjectCount == 0;
}

void AFXAPI AfxOleLockApp()
{
	AFX_MODULE_STATE* pModuleState = AfxGetModuleState();
	InterlockedIncrement(&pModuleState->m_nObjectCount);
}

void AFXAPI AfxOleUnlockApp()
{
	AFX_MODULE_STATE* pModuleState = AfxGetModuleState();
	ASSERT(pModuleState->m_nObjectCount != 0);
	if (InterlockedDecrement(&pModuleState->m_nObjectCount) == 0)
	{
		// allow application to shut down when all the objects have
		//  been released
		::AfxOleOnReleaseAllObjects();
	}
}

/////////////////////////////////////////////////////////////////////////////
// Access to "user-control" state

void AFXAPI AfxOleSetUserCtrl(BOOL bUserCtrl)
{
	AFX_MODULE_STATE* pModuleState = AfxGetModuleState();
#ifdef _DEBUG
	CWinApp* pApp = AfxGetApp();
	if (bUserCtrl && !pModuleState->m_bUserCtrl &&
		(pApp == NULL || pApp->m_pMainWnd == NULL ||
		!pApp->m_pMainWnd->IsWindowVisible()))
	{
		// If the user gets control while the application window is
		//  not visible, the application may not shutdown when the object
		//  count reaches zero.
		TRACE(traceOle, 0, "Warning: AfxOleSetUserCtrl(TRUE) called with application window hidden.\n");
	}
#endif
	pModuleState->m_bUserCtrl = bUserCtrl;
}

BOOL AFXAPI AfxOleGetUserCtrl()
{
	AFX_MODULE_STATE* pModuleState = AfxGetModuleState();
	return pModuleState->m_bUserCtrl;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\olemisc.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "sal.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// Debug diagnostics for SCODEs

#ifdef _DEBUG
LPCTSTR AFXAPI AfxGetScodeString(SCODE sc)
{
	struct SCODE_ENTRY
	{
		SCODE sc;
		LPCTSTR lpszName;
	};
	#define MAKE_SCODE_ENTRY(sc)    { sc, _T(#sc) }
	static const SCODE_ENTRY scNameTable[] =
	{
		MAKE_SCODE_ENTRY(S_OK),
		MAKE_SCODE_ENTRY(S_FALSE),

		MAKE_SCODE_ENTRY(CACHE_S_FORMATETC_NOTSUPPORTED),
		MAKE_SCODE_ENTRY(CACHE_S_SAMECACHE),
		MAKE_SCODE_ENTRY(CACHE_S_SOMECACHES_NOTUPDATED),
		MAKE_SCODE_ENTRY(CONVERT10_S_NO_PRESENTATION),
		MAKE_SCODE_ENTRY(DATA_S_SAMEFORMATETC),
		MAKE_SCODE_ENTRY(DRAGDROP_S_CANCEL),
		MAKE_SCODE_ENTRY(DRAGDROP_S_DROP),
		MAKE_SCODE_ENTRY(DRAGDROP_S_USEDEFAULTCURSORS),
		MAKE_SCODE_ENTRY(INPLACE_S_TRUNCATED),
		MAKE_SCODE_ENTRY(MK_S_HIM),
		MAKE_SCODE_ENTRY(MK_S_ME),
		MAKE_SCODE_ENTRY(MK_S_MONIKERALREADYREGISTERED),
		MAKE_SCODE_ENTRY(MK_S_REDUCED_TO_SELF),
		MAKE_SCODE_ENTRY(MK_S_US),
		MAKE_SCODE_ENTRY(OLE_S_MAC_CLIPFORMAT),
		MAKE_SCODE_ENTRY(OLE_S_STATIC),
		MAKE_SCODE_ENTRY(OLE_S_USEREG),
		MAKE_SCODE_ENTRY(OLEOBJ_S_CANNOT_DOVERB_NOW),
		MAKE_SCODE_ENTRY(OLEOBJ_S_INVALIDHWND),
		MAKE_SCODE_ENTRY(OLEOBJ_S_INVALIDVERB),
		MAKE_SCODE_ENTRY(OLEOBJ_S_LAST),
		MAKE_SCODE_ENTRY(STG_S_CONVERTED),
		MAKE_SCODE_ENTRY(VIEW_S_ALREADY_FROZEN),

		MAKE_SCODE_ENTRY(E_UNEXPECTED),
		MAKE_SCODE_ENTRY(E_NOTIMPL),
		MAKE_SCODE_ENTRY(E_OUTOFMEMORY),
		MAKE_SCODE_ENTRY(E_INVALIDARG),
		MAKE_SCODE_ENTRY(E_NOINTERFACE),
		MAKE_SCODE_ENTRY(E_POINTER),
		MAKE_SCODE_ENTRY(E_HANDLE),
		MAKE_SCODE_ENTRY(E_ABORT),
		MAKE_SCODE_ENTRY(E_FAIL),
		MAKE_SCODE_ENTRY(E_ACCESSDENIED),

		MAKE_SCODE_ENTRY(CACHE_E_NOCACHE_UPDATED),
		MAKE_SCODE_ENTRY(CLASS_E_CLASSNOTAVAILABLE),
		MAKE_SCODE_ENTRY(CLASS_E_NOAGGREGATION),
		MAKE_SCODE_ENTRY(CLIPBRD_E_BAD_DATA),
		MAKE_SCODE_ENTRY(CLIPBRD_E_CANT_CLOSE),
		MAKE_SCODE_ENTRY(CLIPBRD_E_CANT_EMPTY),
		MAKE_SCODE_ENTRY(CLIPBRD_E_CANT_OPEN),
		MAKE_SCODE_ENTRY(CLIPBRD_E_CANT_SET),
		MAKE_SCODE_ENTRY(CO_E_ALREADYINITIALIZED),
		MAKE_SCODE_ENTRY(CO_E_APPDIDNTREG),
		MAKE_SCODE_ENTRY(CO_E_APPNOTFOUND),
		MAKE_SCODE_ENTRY(CO_E_APPSINGLEUSE),
		MAKE_SCODE_ENTRY(CO_E_BAD_PATH),
		MAKE_SCODE_ENTRY(CO_E_CANTDETERMINECLASS),
		MAKE_SCODE_ENTRY(CO_E_CLASS_CREATE_FAILED),
		MAKE_SCODE_ENTRY(CO_E_CLASSSTRING),
		MAKE_SCODE_ENTRY(CO_E_DLLNOTFOUND),
		MAKE_SCODE_ENTRY(CO_E_ERRORINAPP),
		MAKE_SCODE_ENTRY(CO_E_ERRORINDLL),
		MAKE_SCODE_ENTRY(CO_E_IIDSTRING),
		MAKE_SCODE_ENTRY(CO_E_NOTINITIALIZED),
		MAKE_SCODE_ENTRY(CO_E_OBJISREG),
		MAKE_SCODE_ENTRY(CO_E_OBJNOTCONNECTED),
		MAKE_SCODE_ENTRY(CO_E_OBJNOTREG),
		MAKE_SCODE_ENTRY(CO_E_OBJSRV_RPC_FAILURE),
		MAKE_SCODE_ENTRY(CO_E_SCM_ERROR),
		MAKE_SCODE_ENTRY(CO_E_SCM_RPC_FAILURE),
		MAKE_SCODE_ENTRY(CO_E_SERVER_EXEC_FAILURE),
		MAKE_SCODE_ENTRY(CO_E_SERVER_STOPPING),
		MAKE_SCODE_ENTRY(CO_E_WRONGOSFORAPP),
		MAKE_SCODE_ENTRY(CONVERT10_E_OLESTREAM_BITMAP_TO_DIB),
		MAKE_SCODE_ENTRY(CONVERT10_E_OLESTREAM_FMT),
		MAKE_SCODE_ENTRY(CONVERT10_E_OLESTREAM_GET),
		MAKE_SCODE_ENTRY(CONVERT10_E_OLESTREAM_PUT),
		MAKE_SCODE_ENTRY(CONVERT10_E_STG_DIB_TO_BITMAP),
		MAKE_SCODE_ENTRY(CONVERT10_E_STG_FMT),
		MAKE_SCODE_ENTRY(CONVERT10_E_STG_NO_STD_STREAM),
		MAKE_SCODE_ENTRY(DISP_E_ARRAYISLOCKED),
		MAKE_SCODE_ENTRY(DISP_E_BADCALLEE),
		MAKE_SCODE_ENTRY(DISP_E_BADINDEX),
		MAKE_SCODE_ENTRY(DISP_E_BADPARAMCOUNT),
		MAKE_SCODE_ENTRY(DISP_E_BADVARTYPE),
		MAKE_SCODE_ENTRY(DISP_E_EXCEPTION),
		MAKE_SCODE_ENTRY(DISP_E_MEMBERNOTFOUND),
		MAKE_SCODE_ENTRY(DISP_E_NONAMEDARGS),
		MAKE_SCODE_ENTRY(DISP_E_NOTACOLLECTION),
		MAKE_SCODE_ENTRY(DISP_E_OVERFLOW),
		MAKE_SCODE_ENTRY(DISP_E_PARAMNOTFOUND),
		MAKE_SCODE_ENTRY(DISP_E_PARAMNOTOPTIONAL),
		MAKE_SCODE_ENTRY(DISP_E_TYPEMISMATCH),
		MAKE_SCODE_ENTRY(DISP_E_UNKNOWNINTERFACE),
		MAKE_SCODE_ENTRY(DISP_E_UNKNOWNLCID),
		MAKE_SCODE_ENTRY(DISP_E_UNKNOWNNAME),
		MAKE_SCODE_ENTRY(DRAGDROP_E_ALREADYREGISTERED),
		MAKE_SCODE_ENTRY(DRAGDROP_E_INVALIDHWND),
		MAKE_SCODE_ENTRY(DRAGDROP_E_NOTREGISTERED),
		MAKE_SCODE_ENTRY(DV_E_CLIPFORMAT),
		MAKE_SCODE_ENTRY(DV_E_DVASPECT),
		MAKE_SCODE_ENTRY(DV_E_DVTARGETDEVICE),
		MAKE_SCODE_ENTRY(DV_E_DVTARGETDEVICE_SIZE),
		MAKE_SCODE_ENTRY(DV_E_FORMATETC),
		MAKE_SCODE_ENTRY(DV_E_LINDEX),
		MAKE_SCODE_ENTRY(DV_E_NOIVIEWOBJECT),
		MAKE_SCODE_ENTRY(DV_E_STATDATA),
		MAKE_SCODE_ENTRY(DV_E_STGMEDIUM),
		MAKE_SCODE_ENTRY(DV_E_TYMED),
		MAKE_SCODE_ENTRY(INPLACE_E_NOTOOLSPACE),
		MAKE_SCODE_ENTRY(INPLACE_E_NOTUNDOABLE),
		MAKE_SCODE_ENTRY(MEM_E_INVALID_LINK),
		MAKE_SCODE_ENTRY(MEM_E_INVALID_ROOT),
		MAKE_SCODE_ENTRY(MEM_E_INVALID_SIZE),
		MAKE_SCODE_ENTRY(MK_E_CANTOPENFILE),
		MAKE_SCODE_ENTRY(MK_E_CONNECTMANUALLY),
		MAKE_SCODE_ENTRY(MK_E_ENUMERATION_FAILED),
		MAKE_SCODE_ENTRY(MK_E_EXCEEDEDDEADLINE),
		MAKE_SCODE_ENTRY(MK_E_INTERMEDIATEINTERFACENOTSUPPORTED),
		MAKE_SCODE_ENTRY(MK_E_INVALIDEXTENSION),
		MAKE_SCODE_ENTRY(MK_E_MUSTBOTHERUSER),
		MAKE_SCODE_ENTRY(MK_E_NEEDGENERIC),
		MAKE_SCODE_ENTRY(MK_E_NO_NORMALIZED),
		MAKE_SCODE_ENTRY(MK_E_NOINVERSE),
		MAKE_SCODE_ENTRY(MK_E_NOOBJECT),
		MAKE_SCODE_ENTRY(MK_E_NOPREFIX),
		MAKE_SCODE_ENTRY(MK_E_NOSTORAGE),
		MAKE_SCODE_ENTRY(MK_E_NOTBINDABLE),
		MAKE_SCODE_ENTRY(MK_E_NOTBOUND),
		MAKE_SCODE_ENTRY(MK_E_SYNTAX),
		MAKE_SCODE_ENTRY(MK_E_UNAVAILABLE),
		MAKE_SCODE_ENTRY(OLE_E_ADVF),
		MAKE_SCODE_ENTRY(OLE_E_ADVISENOTSUPPORTED),
		MAKE_SCODE_ENTRY(OLE_E_BLANK),
		MAKE_SCODE_ENTRY(OLE_E_CANT_BINDTOSOURCE),
		MAKE_SCODE_ENTRY(OLE_E_CANT_GETMONIKER),
		MAKE_SCODE_ENTRY(OLE_E_CANTCONVERT),
		MAKE_SCODE_ENTRY(OLE_E_CLASSDIFF),
		MAKE_SCODE_ENTRY(OLE_E_ENUM_NOMORE),
		MAKE_SCODE_ENTRY(OLE_E_INVALIDHWND),
		MAKE_SCODE_ENTRY(OLE_E_INVALIDRECT),
		MAKE_SCODE_ENTRY(OLE_E_NOCACHE),
		MAKE_SCODE_ENTRY(OLE_E_NOCONNECTION),
		MAKE_SCODE_ENTRY(OLE_E_NOSTORAGE),
		MAKE_SCODE_ENTRY(OLE_E_NOT_INPLACEACTIVE),
		MAKE_SCODE_ENTRY(OLE_E_NOTRUNNING),
		MAKE_SCODE_ENTRY(OLE_E_OLEVERB),
		MAKE_SCODE_ENTRY(OLE_E_PROMPTSAVECANCELLED),
		MAKE_SCODE_ENTRY(OLE_E_STATIC),
		MAKE_SCODE_ENTRY(OLE_E_WRONGCOMPOBJ),
		MAKE_SCODE_ENTRY(OLEOBJ_E_INVALIDVERB),
		MAKE_SCODE_ENTRY(OLEOBJ_E_NOVERBS),
		MAKE_SCODE_ENTRY(REGDB_E_CLASSNOTREG),
		MAKE_SCODE_ENTRY(REGDB_E_IIDNOTREG),
		MAKE_SCODE_ENTRY(REGDB_E_INVALIDVALUE),
		MAKE_SCODE_ENTRY(REGDB_E_KEYMISSING),
		MAKE_SCODE_ENTRY(REGDB_E_READREGDB),
		MAKE_SCODE_ENTRY(REGDB_E_WRITEREGDB),
		MAKE_SCODE_ENTRY(RPC_E_ATTEMPTED_MULTITHREAD),
		MAKE_SCODE_ENTRY(RPC_E_CALL_CANCELED),
		MAKE_SCODE_ENTRY(RPC_E_CALL_REJECTED),
		MAKE_SCODE_ENTRY(RPC_E_CANTCALLOUT_AGAIN),
		MAKE_SCODE_ENTRY(RPC_E_CANTCALLOUT_INASYNCCALL),
		MAKE_SCODE_ENTRY(RPC_E_CANTCALLOUT_INEXTERNALCALL),
		MAKE_SCODE_ENTRY(RPC_E_CANTCALLOUT_ININPUTSYNCCALL),
		MAKE_SCODE_ENTRY(RPC_E_CANTPOST_INSENDCALL),
		MAKE_SCODE_ENTRY(RPC_E_CANTTRANSMIT_CALL),
		MAKE_SCODE_ENTRY(RPC_E_CHANGED_MODE),
		MAKE_SCODE_ENTRY(RPC_E_CLIENT_CANTMARSHAL_DATA),
		MAKE_SCODE_ENTRY(RPC_E_CLIENT_CANTUNMARSHAL_DATA),
		MAKE_SCODE_ENTRY(RPC_E_CLIENT_DIED),
		MAKE_SCODE_ENTRY(RPC_E_CONNECTION_TERMINATED),
		MAKE_SCODE_ENTRY(RPC_E_DISCONNECTED),
		MAKE_SCODE_ENTRY(RPC_E_FAULT),
		MAKE_SCODE_ENTRY(RPC_E_INVALID_CALLDATA),
		MAKE_SCODE_ENTRY(RPC_E_INVALID_DATA),
		MAKE_SCODE_ENTRY(RPC_E_INVALID_DATAPACKET),
		MAKE_SCODE_ENTRY(RPC_E_INVALID_PARAMETER),
		MAKE_SCODE_ENTRY(RPC_E_INVALIDMETHOD),
		MAKE_SCODE_ENTRY(RPC_E_NOT_REGISTERED),
		MAKE_SCODE_ENTRY(RPC_E_OUT_OF_RESOURCES),
		MAKE_SCODE_ENTRY(RPC_E_RETRY),
		MAKE_SCODE_ENTRY(RPC_E_SERVER_CANTMARSHAL_DATA),
		MAKE_SCODE_ENTRY(RPC_E_SERVER_CANTUNMARSHAL_DATA),
		MAKE_SCODE_ENTRY(RPC_E_SERVER_DIED),
		MAKE_SCODE_ENTRY(RPC_E_SERVER_DIED_DNE),
		MAKE_SCODE_ENTRY(RPC_E_SERVERCALL_REJECTED),
		MAKE_SCODE_ENTRY(RPC_E_SERVERCALL_RETRYLATER),
		MAKE_SCODE_ENTRY(RPC_E_SERVERFAULT),
		MAKE_SCODE_ENTRY(RPC_E_SYS_CALL_FAILED),
		MAKE_SCODE_ENTRY(RPC_E_THREAD_NOT_INIT),
		MAKE_SCODE_ENTRY(RPC_E_UNEXPECTED),
		MAKE_SCODE_ENTRY(RPC_E_WRONG_THREAD),
		MAKE_SCODE_ENTRY(STG_E_ABNORMALAPIEXIT),
		MAKE_SCODE_ENTRY(STG_E_ACCESSDENIED),
		MAKE_SCODE_ENTRY(STG_E_CANTSAVE),
		MAKE_SCODE_ENTRY(STG_E_DISKISWRITEPROTECTED),
		MAKE_SCODE_ENTRY(STG_E_EXTANTMARSHALLINGS),
		MAKE_SCODE_ENTRY(STG_E_FILEALREADYEXISTS),
		MAKE_SCODE_ENTRY(STG_E_FILENOTFOUND),
		MAKE_SCODE_ENTRY(STG_E_INSUFFICIENTMEMORY),
		MAKE_SCODE_ENTRY(STG_E_INUSE),
		MAKE_SCODE_ENTRY(STG_E_INVALIDFLAG),
		MAKE_SCODE_ENTRY(STG_E_INVALIDFUNCTION),
		MAKE_SCODE_ENTRY(STG_E_INVALIDHANDLE),
		MAKE_SCODE_ENTRY(STG_E_INVALIDHEADER),
		MAKE_SCODE_ENTRY(STG_E_INVALIDNAME),
		MAKE_SCODE_ENTRY(STG_E_INVALIDPARAMETER),
		MAKE_SCODE_ENTRY(STG_E_INVALIDPOINTER),
		MAKE_SCODE_ENTRY(STG_E_LOCKVIOLATION),
		MAKE_SCODE_ENTRY(STG_E_MEDIUMFULL),
		MAKE_SCODE_ENTRY(STG_E_NOMOREFILES),
		MAKE_SCODE_ENTRY(STG_E_NOTCURRENT),
		MAKE_SCODE_ENTRY(STG_E_NOTFILEBASEDSTORAGE),
		MAKE_SCODE_ENTRY(STG_E_OLDDLL),
		MAKE_SCODE_ENTRY(STG_E_OLDFORMAT),
		MAKE_SCODE_ENTRY(STG_E_PATHNOTFOUND),
		MAKE_SCODE_ENTRY(STG_E_READFAULT),
		MAKE_SCODE_ENTRY(STG_E_REVERTED),
		MAKE_SCODE_ENTRY(STG_E_SEEKERROR),
		MAKE_SCODE_ENTRY(STG_E_SHAREREQUIRED),
		MAKE_SCODE_ENTRY(STG_E_SHAREVIOLATION),
		MAKE_SCODE_ENTRY(STG_E_TOOMANYOPENFILES),
		MAKE_SCODE_ENTRY(STG_E_UNIMPLEMENTEDFUNCTION),
		MAKE_SCODE_ENTRY(STG_E_UNKNOWN),
		MAKE_SCODE_ENTRY(STG_E_WRITEFAULT),
		MAKE_SCODE_ENTRY(TYPE_E_AMBIGUOUSNAME),
		MAKE_SCODE_ENTRY(TYPE_E_BADMODULEKIND),
		MAKE_SCODE_ENTRY(TYPE_E_BUFFERTOOSMALL),
		MAKE_SCODE_ENTRY(TYPE_E_CANTCREATETMPFILE),
		MAKE_SCODE_ENTRY(TYPE_E_CANTLOADLIBRARY),
		MAKE_SCODE_ENTRY(TYPE_E_CIRCULARTYPE),
		MAKE_SCODE_ENTRY(TYPE_E_DLLFUNCTIONNOTFOUND),
		MAKE_SCODE_ENTRY(TYPE_E_DUPLICATEID),
		MAKE_SCODE_ENTRY(TYPE_E_ELEMENTNOTFOUND),
		MAKE_SCODE_ENTRY(TYPE_E_INCONSISTENTPROPFUNCS),
		MAKE_SCODE_ENTRY(TYPE_E_INVALIDSTATE),
		MAKE_SCODE_ENTRY(TYPE_E_INVDATAREAD),
		MAKE_SCODE_ENTRY(TYPE_E_IOERROR),
		MAKE_SCODE_ENTRY(TYPE_E_LIBNOTREGISTERED),
		MAKE_SCODE_ENTRY(TYPE_E_NAMECONFLICT),
		MAKE_SCODE_ENTRY(TYPE_E_OUTOFBOUNDS),
		MAKE_SCODE_ENTRY(TYPE_E_QUALIFIEDNAMEDISALLOWED),
		MAKE_SCODE_ENTRY(TYPE_E_REGISTRYACCESS),
		MAKE_SCODE_ENTRY(TYPE_E_SIZETOOBIG),
		MAKE_SCODE_ENTRY(TYPE_E_TYPEMISMATCH),
		MAKE_SCODE_ENTRY(TYPE_E_UNDEFINEDTYPE),
		MAKE_SCODE_ENTRY(TYPE_E_UNKNOWNLCID),
		MAKE_SCODE_ENTRY(TYPE_E_UNSUPFORMAT),
		MAKE_SCODE_ENTRY(TYPE_E_WRONGTYPEKIND),
		MAKE_SCODE_ENTRY(VIEW_E_DRAW),
	};
	#undef MAKE_SCODE_ENTRY

	// look for it in the table
	for (int i = 0; i < _countof(scNameTable); i++)
	{
		if (sc == scNameTable[i].sc)
			return scNameTable[i].lpszName;
	}
	return NULL;    // not found
}

LPCTSTR AFXAPI AfxGetScodeRangeString(SCODE sc)
{
	struct RANGE_ENTRY
	{
		SCODE scFirst;
		SCODE scLast;
		LPCTSTR lpszName;
	};
	#define MAKE_RANGE_ENTRY(scRange) \
		{ scRange##_FIRST, scRange##_LAST, \
			_T(#scRange) _T("_FIRST...") _T(#scRange) _T("_LAST") }

	static const RANGE_ENTRY scRangeTable[] =
	{
		MAKE_RANGE_ENTRY(CACHE_E),
		MAKE_RANGE_ENTRY(CACHE_S),
		MAKE_RANGE_ENTRY(CLASSFACTORY_E),
		MAKE_RANGE_ENTRY(CLASSFACTORY_S),
		MAKE_RANGE_ENTRY(CLIENTSITE_E),
		MAKE_RANGE_ENTRY(CLIENTSITE_S),
		MAKE_RANGE_ENTRY(CLIPBRD_E),
		MAKE_RANGE_ENTRY(CLIPBRD_S),
		MAKE_RANGE_ENTRY(CONVERT10_E),
		MAKE_RANGE_ENTRY(CONVERT10_S),
		MAKE_RANGE_ENTRY(CO_E),
		MAKE_RANGE_ENTRY(CO_S),
		MAKE_RANGE_ENTRY(DATA_E),
		MAKE_RANGE_ENTRY(DATA_S),
		MAKE_RANGE_ENTRY(DRAGDROP_E),
		MAKE_RANGE_ENTRY(DRAGDROP_S),
		MAKE_RANGE_ENTRY(ENUM_E),
		MAKE_RANGE_ENTRY(ENUM_S),
		MAKE_RANGE_ENTRY(INPLACE_E),
		MAKE_RANGE_ENTRY(INPLACE_S),
		MAKE_RANGE_ENTRY(MARSHAL_E),
		MAKE_RANGE_ENTRY(MARSHAL_S),
		MAKE_RANGE_ENTRY(MK_E),
		MAKE_RANGE_ENTRY(MK_S),
		MAKE_RANGE_ENTRY(OLEOBJ_E),
		MAKE_RANGE_ENTRY(OLEOBJ_S),
		MAKE_RANGE_ENTRY(OLE_E),
		MAKE_RANGE_ENTRY(OLE_S),
		MAKE_RANGE_ENTRY(REGDB_E),
		MAKE_RANGE_ENTRY(REGDB_S),
		MAKE_RANGE_ENTRY(VIEW_E),
		MAKE_RANGE_ENTRY(VIEW_S),
	};
	#undef MAKE_RANGE_ENTRY

	// look for it in the table
	for (int i = 0; i < _countof(scRangeTable); i++)
	{
		if (sc >= scRangeTable[i].scFirst && sc <= scRangeTable[i].scLast)
			return scRangeTable[i].lpszName;
	}
	return NULL;    // not found
}

LPCTSTR AFXAPI AfxGetSeverityString(SCODE sc)
{
	static const TCHAR* rgszSEVERITY[] =
	{
		_T("SEVERITY_SUCCESS"),
		_T("SEVERITY_ERROR"),
	};
	return rgszSEVERITY[SCODE_SEVERITY(sc)];
}

LPCTSTR AFXAPI AfxGetFacilityString(SCODE sc)
{
	static const TCHAR* rgszFACILITY[] =
	{
		_T("FACILITY_NULL"),
		_T("FACILITY_RPC"),
		_T("FACILITY_DISPATCH"),
		_T("FACILITY_STORAGE"),
		_T("FACILITY_ITF"),
		_T("FACILITY_0x05"),
		_T("FACILITY_0x06"),
		_T("FACILITY_WIN32"),
		_T("FACILITY_WINDOWS"),
	};
	if (SCODE_FACILITY(sc) >= _countof(rgszFACILITY))
		return _T("<Unknown Facility>");

	return rgszFACILITY[SCODE_FACILITY(sc)];
}

LPCTSTR AFXAPI AfxGetFullScodeString(SCODE sc)
{
	static TCHAR szBuf[128] = _T("<scode string too long>");

	LPCTSTR lpsz;
	if ((lpsz = AfxGetScodeString(sc)) != NULL)
	{
		// found exact match
		static const TCHAR szFormat[] = _T("%s ($%08lX)");
		if( lstrlen(lpsz) + _countof(szFormat) - 2 /*%s*/ - 6 /*$%08lX*/ + 8 /*size of long value*/ < _countof(szBuf) )
		{
			_stprintf_s(szBuf, _countof(szBuf), szFormat, lpsz, sc);
		}
	}
	else if ((lpsz = AfxGetScodeRangeString(sc)) != NULL)
	{
		// found suitable range
		static const TCHAR szFormat[] = _T("range: %s ($%08lX)");
		if( lstrlen(lpsz) + _countof(szFormat) - 2 /*%s*/ - 6 /*$%08lX*/ + 8 /*size of long value*/ < _countof(szBuf) )
		{
			_stprintf_s(szBuf, _countof(szBuf), szFormat, lpsz, sc);
		}
	}
	else
	{
		// not found at all -- split it up into its parts
		LPCTSTR lpszSeverity = AfxGetSeverityString(sc);
		LPCTSTR lpszFacility = AfxGetFacilityString(sc);
		static const TCHAR szFormat[] = _T("severity: %s, facility: %s ($%08lX)");

		if( lstrlen(lpszSeverity) + lstrlen(lpszFacility) + _countof(szFormat) - 2 /*%s*/ - 6 /*$%08lX*/ + 8 /*size of long value*/ < _countof(szBuf) )
		{
			_stprintf_s(szBuf, _countof(szBuf), szFormat, lpszSeverity, lpszFacility, sc);
		}
	}
	return szBuf;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// Exceptions for OLE Support

void __declspec(noreturn) AFXAPI AfxThrowOleException(SCODE sc)
{
#ifdef _DEBUG
	TRACE(traceOle, 0, _T("Warning: constructing COleException, scode = %s.\n"),
		AfxGetFullScodeString(sc));
#endif
	COleException* pException = new COleException;
	pException->m_sc = sc;
	THROW(pException);
}

BOOL COleException::GetErrorMessage(_Out_z_cap_(nMaxError) LPTSTR lpszError, _In_ UINT nMaxError,
		_Out_opt_ PUINT pnHelpContext) const
{
	ASSERT(lpszError != NULL && AfxIsValidString(lpszError, nMaxError));

	if (pnHelpContext != NULL)
		*pnHelpContext = 0;

	LPTSTR lpBuffer;
	if (::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
				FORMAT_MESSAGE_FROM_SYSTEM,
				NULL, m_sc,
				MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),
				(LPTSTR) &lpBuffer, 0, NULL) == 0)
	{
		*lpszError = '\0';
		return FALSE;
	}
	else
	{
		Checked::tcsncpy_s(lpszError, nMaxError, lpBuffer, _TRUNCATE);
		LocalFree(lpBuffer);
		return TRUE;
	}
}

/////////////////////////////////////////////////////////////////////////////
// Turn a caught exception into an OLE return code

SCODE PASCAL COleException::Process(const CException* pAnyException)
{
	SCODE sc;
	if (pAnyException->IsKindOf(RUNTIME_CLASS(COleException)))
		sc = ((COleException*)pAnyException)->m_sc;
	else if (pAnyException->IsKindOf(RUNTIME_CLASS(CMemoryException)))
		sc = E_OUTOFMEMORY;
	else if (pAnyException->IsKindOf(RUNTIME_CLASS(CNotSupportedException)))
		sc = E_NOTIMPL;
	else
		sc = E_UNEXPECTED;  // some other problem

	return sc;
}

/////////////////////////////////////////////////////////////////////////////
// Implementation helpers

HMENU AFXAPI AfxMergeMenus(HMENU hMenuShared, HMENU hMenuSource,
	LONG* lpMenuWidths, int iWidthIndex, BOOL bMergeHelpMenus /* = FALSE */)
{
	ASSERT(hMenuShared != NULL && IsMenu(hMenuShared));
	ASSERT(hMenuSource != NULL && IsMenu(hMenuSource));

	BOOL bHelpMergedAsSubMenu = FALSE;
	HMENU hHelpSubMenu = NULL;

	// copy the popups from the pMenuSource
	int cMenuItems = GetMenuItemCount(hMenuSource);
	int cGroupWidth = 0;
	int nPosition = 0;

	// insert at appropriate spot depending on iWidthIndex
	ASSERT(iWidthIndex == 0 || iWidthIndex == 1);
	if (iWidthIndex == 1)
		nPosition = (int)lpMenuWidths[0];

	for (int i = 0; i < cMenuItems; i++)
	{
		// get the HMENU of the popup
		HMENU hMenuPopup = ::GetSubMenu(hMenuSource, i);

		// separators move us to next group
		UINT state = GetMenuState(hMenuSource, i, MF_BYPOSITION);
		if (hMenuPopup == NULL && (state & MF_SEPARATOR) != 0)
		{
			ASSERT(iWidthIndex <= 5);   // servers should not touch past 5
			lpMenuWidths[iWidthIndex] = cGroupWidth;
			cGroupWidth = 0;
			if (iWidthIndex < 5)
				nPosition += (int)lpMenuWidths[iWidthIndex+1];
			iWidthIndex += 2;
		}
		else
		{
			HMENU hHelpMenu = NULL;

			// are we processing the help menu group?

			if (bMergeHelpMenus && iWidthIndex == 5)
			{
				// if so, see if the container has Help any menu items
				if (lpMenuWidths[iWidthIndex] == 1)
				{
					// get the help menu from the container
					hHelpMenu = GetSubMenu(hMenuShared, nPosition);
				}
			}

			// get the menu item text
			TCHAR szItemText[256];
			int nLen = GetMenuString(hMenuSource, i, szItemText,
				sizeof(szItemText)/sizeof(TCHAR), MF_BYPOSITION);

			// popups are handled differently than normal menu items
			if (hMenuPopup != NULL)
			{
				if (hHelpMenu != NULL)
				{
					CString strTearOff = AfxGetAppName();
					if (!strTearOff.IsEmpty())
						strTearOff += ' ';
					strTearOff += szItemText;

					// container has help items -- add ours to its submenu
					AppendMenu(hHelpMenu, MF_STRING | MF_POPUP,
						(UINT_PTR)hMenuPopup, strTearOff);

					// clear the count of Help group items and add
					// the help menu to the window group

					lpMenuWidths[iWidthIndex] = 0;
					lpMenuWidths[iWidthIndex-1]++;

					bHelpMergedAsSubMenu = TRUE;
					hHelpSubMenu = hMenuPopup;
				}
				else if (::GetMenuItemCount(hMenuPopup) != 0)
				{
					// strip the HIBYTE because it contains a count of items
					state = LOBYTE(state) | MF_POPUP;   // must be popup

					// non-empty popup -- add it to the shared menu bar
					InsertMenu(hMenuShared, nPosition, state | MF_BYPOSITION,
						(DWORD_PTR)hMenuPopup, szItemText);
					++nPosition;
					++cGroupWidth;
				}
			}
			else if (nLen > 0)
			{
				// only non-empty items are added
				ASSERT(szItemText[0] != 0);

				// here the state does not contain a count in the HIBYTE
				InsertMenu(hMenuShared, nPosition, state | MF_BYPOSITION,
					GetMenuItemID(hMenuSource, i), szItemText);
				++nPosition;
				++cGroupWidth;
			}
		}
	}

	// set the last group width

	if (!bHelpMergedAsSubMenu)
	{
		ASSERT(iWidthIndex <= 5);   // servers should not touch past 5
		lpMenuWidths[iWidthIndex] = cGroupWidth;
	}

	return hHelpSubMenu;
}

void AFXAPI AfxUnmergeMenus(HMENU hMenuShared, HMENU hMenuSource,
	HMENU hHelpMenuPopup /* = NULL */)
{
	ASSERT(hMenuShared != NULL && IsMenu(hMenuShared));
	ASSERT(hMenuSource != NULL && IsMenu(hMenuSource));
	ASSERT(hHelpMenuPopup == NULL || IsMenu(hHelpMenuPopup));

	int cOurItems = GetMenuItemCount(hMenuSource);
	int cMenuItems = GetMenuItemCount(hMenuShared);

	for (int i = cMenuItems-1; i >= 0; i--)
	{
		// check out the popup menus
		HMENU hMenuPopup = ::GetSubMenu(hMenuShared, i);
		if (hMenuPopup != NULL)
		{
			// if we have a Help submenu, check to see if it appears in this
			// submenu someplace... this normally happens only in
			// DocObject frame windows

			if (hHelpMenuPopup != NULL)
			{
				int cPopupItems = ::GetMenuItemCount(hMenuPopup);
				for (int k = 0; k < cPopupItems; k++)
				{
					if (::GetSubMenu(hMenuPopup, k) == hHelpMenuPopup)
					{
						::RemoveMenu(hMenuPopup, k, MF_BYPOSITION);
						hHelpMenuPopup = NULL;  // can only have one
						break;
					}
				}
			}
			else
			{
				// if it is one of ours, remove it from the pMenuShared
				for (int j = 0; j < cOurItems; j++)
				{
					if (::GetSubMenu(hMenuSource, j) == hMenuPopup)
					{
						// remove the menu from pMenuShared
						RemoveMenu(hMenuShared, i, MF_BYPOSITION);
						break;
					}
				}
			}
		}
	}
}

// Helper for creating default FORMATETC from cfFormat
LPFORMATETC AFXAPI _AfxFillFormatEtc(
	LPFORMATETC lpFormatEtc, CLIPFORMAT cfFormat, LPFORMATETC lpFormatEtcFill)
{
	ENSURE(lpFormatEtcFill != NULL);
	if (lpFormatEtc == NULL && cfFormat!=0)
	{
		lpFormatEtc = lpFormatEtcFill;
		lpFormatEtc->cfFormat = cfFormat;
		lpFormatEtc->ptd = NULL;
		lpFormatEtc->dwAspect = DVASPECT_CONTENT;
		lpFormatEtc->lindex = -1;
		lpFormatEtc->tymed = (DWORD) -1;
	}
	return lpFormatEtc;
}

AFX_STATIC HGLOBAL AFXAPI _AfxCopyGlobalMemory(HGLOBAL hDest, HGLOBAL hSource)
{
	ASSERT(hSource != NULL);

	// make sure we have suitable hDest
	ULONG_PTR nSize = ::GlobalSize(hSource);
	if (hDest == NULL)
	{
		hDest = ::GlobalAlloc(GMEM_SHARE|GMEM_MOVEABLE, nSize);
		if (hDest == NULL)
			return NULL;
	}
	else if (nSize > ::GlobalSize(hDest))
	{
		// hDest is not large enough
		return NULL;
	}

	// copy the bits
	LPVOID lpSource = ::GlobalLock(hSource);
	LPVOID lpDest = ::GlobalLock(hDest);
	ASSERT(lpDest != NULL);
	ASSERT(lpSource != NULL);
	Checked::memcpy_s(lpDest, (ULONG)::GlobalSize(hDest), lpSource, (ULONG)nSize);
	::GlobalUnlock(hDest);
	::GlobalUnlock(hSource);

	// success -- return hDest
	return hDest;
}

BOOL AFXAPI _AfxCopyStgMedium(
	CLIPFORMAT cfFormat, LPSTGMEDIUM lpDest, LPSTGMEDIUM lpSource)
{
	if (lpDest->tymed == TYMED_NULL)
	{
		ASSERT(lpSource->tymed != TYMED_NULL);
		switch (lpSource->tymed)
		{
		case TYMED_ENHMF:
		case TYMED_HGLOBAL:
			ASSERT(sizeof(HGLOBAL) == sizeof(HENHMETAFILE));
			lpDest->tymed = lpSource->tymed;
			lpDest->hGlobal = NULL;
			break;  // fall through to CopyGlobalMemory case

		case TYMED_ISTREAM:
			lpDest->pstm = lpSource->pstm;
			lpDest->pstm->AddRef();
			lpDest->tymed = TYMED_ISTREAM;
			return TRUE;

		case TYMED_ISTORAGE:
			lpDest->pstg = lpSource->pstg;
			lpDest->pstg->AddRef();
			lpDest->tymed = TYMED_ISTORAGE;
			return TRUE;

		case TYMED_MFPICT:
			{
				// copy LPMETAFILEPICT struct + embedded HMETAFILE
				HGLOBAL hDest = _AfxCopyGlobalMemory(NULL, lpSource->hGlobal);
				if (hDest == NULL)
					return FALSE;
				LPMETAFILEPICT lpPict = (LPMETAFILEPICT)::GlobalLock(hDest);
				ASSERT(lpPict != NULL);
				lpPict->hMF = ::CopyMetaFile(lpPict->hMF, NULL);
				if (lpPict->hMF == NULL)
				{
					::GlobalUnlock(hDest);
					::GlobalFree(hDest);
					return FALSE;
				}
				::GlobalUnlock(hDest);

				// fill STGMEDIUM struct
				lpDest->hGlobal = hDest;
				lpDest->tymed = TYMED_MFPICT;
			}
			return TRUE;

		case TYMED_GDI:
			lpDest->tymed = TYMED_GDI;
			lpDest->hGlobal = NULL;
			break;

		case TYMED_FILE:
			{
				lpDest->tymed = TYMED_FILE;
				ASSERT(lpSource->lpszFileName != NULL);
				if (lpSource->lpszFileName == NULL)
				{
					AfxThrowInvalidArgException();
				}
				UINT cbSrc = lstrlenW(lpSource->lpszFileName);
				LPOLESTR szFileName = (LPOLESTR)::ATL::AtlCoTaskMemCAlloc((cbSrc+1),sizeof(OLECHAR));
				lpDest->lpszFileName = szFileName;
				if (szFileName == NULL)
					return FALSE;

				Checked::memcpy_s(szFileName, (cbSrc+1)*sizeof(OLECHAR), 
					lpSource->lpszFileName,  (cbSrc+1)*sizeof(OLECHAR));
				return TRUE;
			}

		// unable to create + copy other TYMEDs
		default:
			return FALSE;
		}
	}
	ASSERT(lpDest->tymed == lpSource->tymed);

	switch (lpSource->tymed)
	{
	case TYMED_HGLOBAL:
		{
			HGLOBAL hDest = _AfxCopyGlobalMemory(lpDest->hGlobal,
				lpSource->hGlobal);
			if (hDest == NULL)
				return FALSE;

			lpDest->hGlobal = hDest;
		}
		return TRUE;

	case TYMED_ISTREAM:
		{
			ASSERT(lpDest->pstm != NULL);
			ASSERT(lpSource->pstm != NULL);

			// get the size of the source stream
			STATSTG stat;
			if (lpSource->pstm->Stat(&stat, STATFLAG_NONAME) != S_OK)
			{
				// unable to get size of source stream
				return FALSE;
			}
			ASSERT(stat.pwcsName == NULL);

			// always seek to zero before copy
			LARGE_INTEGER zero = { 0, 0 };
			lpDest->pstm->Seek(zero, STREAM_SEEK_SET, NULL);
			lpSource->pstm->Seek(zero, STREAM_SEEK_SET, NULL);

			// copy source to destination
			if (lpSource->pstm->CopyTo(lpDest->pstm, stat.cbSize,
				NULL, NULL) != NULL)
			{
				// copy from source to dest failed
				return FALSE;
			}

			// always seek to zero after copy
			lpDest->pstm->Seek(zero, STREAM_SEEK_SET, NULL);
			lpSource->pstm->Seek(zero, STREAM_SEEK_SET, NULL);
		}
		return TRUE;

	case TYMED_ISTORAGE:
		{
			ASSERT(lpDest->pstg != NULL);
			ASSERT(lpSource->pstg != NULL);

			// just copy source to destination
			if (lpSource->pstg->CopyTo(0, NULL, NULL, lpDest->pstg) != S_OK)
				return FALSE;
		}
		return TRUE;

	case TYMED_FILE:
		{
			ASSERT(lpSource->lpszFileName != NULL);
			ASSERT(lpDest->lpszFileName != NULL);
			CString strSource(lpSource->lpszFileName);
			CString strDest(lpDest->lpszFileName);
			return CopyFile(lpSource->lpszFileName ? strSource.GetString() : NULL,
				lpDest->lpszFileName ? strDest.GetString() : NULL, FALSE);
		}


	case TYMED_ENHMF:
	case TYMED_GDI:
		{
			ASSERT(sizeof(HGLOBAL) == sizeof(HENHMETAFILE));

			// with TYMED_GDI cannot copy into existing HANDLE
			if (lpDest->hGlobal != NULL)
				return FALSE;

			// otherwise, use OleDuplicateData for the copy
			lpDest->hGlobal = OleDuplicateData(lpSource->hGlobal, cfFormat, 0);
			if (lpDest->hGlobal == NULL)
				return FALSE;
		}
		return TRUE;

	// other TYMEDs cannot be copied
	default:
		return FALSE;
	}
}

/////////////////////////////////////////////////////////////////////////////
// OLE utility functions (some borrowed from OLE2UI library)

HGLOBAL AFXAPI _AfxOleGetObjectDescriptorData(
	CLSID       clsid,
	DWORD       dwDrawAspect,
	SIZEL       sizel,
	POINTL      pointl,
	DWORD       dwStatus,
	LPCOLESTR   lpszFullUserTypeName,
	LPCOLESTR   lpszSrcOfCopy)
{
	HGLOBAL     hMem = NULL;
	LPOBJECTDESCRIPTOR lpOD;
	DWORD       dwObjectDescSize, dwFullUserTypeNameLen, dwSrcOfCopyLen;

	// Get the length of Full User Type Name; Add 1 for the null terminator
	dwFullUserTypeNameLen = lpszFullUserTypeName ?
		ocslen(lpszFullUserTypeName)+1 : 0;

	// Get the Source of Copy string and it's length;
	//  Add 1 for the null terminator
	if (lpszSrcOfCopy && lpszSrcOfCopy[0] != '\0')
	   dwSrcOfCopyLen = lstrlenW(lpszSrcOfCopy)+1;
	else
	{
	   // No src moniker so use user type name as source string.
	   lpszSrcOfCopy =  lpszFullUserTypeName;
	   dwSrcOfCopyLen = dwFullUserTypeNameLen;
	}

	// Allocate space for OBJECTDESCRIPTOR and the additional string data
	dwObjectDescSize = sizeof(OBJECTDESCRIPTOR);
	hMem = GlobalAlloc(GMEM_MOVEABLE | GMEM_SHARE | GMEM_ZEROINIT,
	   dwObjectDescSize + (dwFullUserTypeNameLen + dwSrcOfCopyLen) *
		sizeof(OLECHAR));
	if (!hMem)
		return NULL;

	// Get pointer to memory from handle
	lpOD = (LPOBJECTDESCRIPTOR)GlobalLock(hMem);

	// Set the FullUserTypeName offset and copy the string
	if (lpszFullUserTypeName)
	{
		lpOD->dwFullUserTypeName = dwObjectDescSize;
		Checked::wcscpy_s((LPOLESTR)((LPBYTE)lpOD+lpOD->dwFullUserTypeName), 
			dwFullUserTypeNameLen, lpszFullUserTypeName);
	}
	else
	{
		// zero offset indicates that string is not present
		lpOD->dwFullUserTypeName = 0;  
	}

	// Set the SrcOfCopy offset and copy the string
	if (lpszSrcOfCopy)
	{
		lpOD->dwSrcOfCopy = dwObjectDescSize + dwFullUserTypeNameLen * sizeof(OLECHAR);
		Checked::wcscpy_s((LPOLESTR)((LPBYTE)lpOD+lpOD->dwSrcOfCopy), 
			dwSrcOfCopyLen, lpszSrcOfCopy);
	}
	else
	{
		// zero offset indicates that string is not present
		lpOD->dwSrcOfCopy = 0;  
	}

	// Initialize the rest of the OBJECTDESCRIPTOR
	lpOD->cbSize       = dwObjectDescSize +
		(dwFullUserTypeNameLen + dwSrcOfCopyLen) * sizeof(OLECHAR);
	lpOD->clsid        = clsid;
	lpOD->dwDrawAspect = dwDrawAspect;
	lpOD->sizel        = sizel;
	lpOD->pointl       = pointl;
	lpOD->dwStatus     = dwStatus;

	GlobalUnlock(hMem);
	return hMem;
}

HGLOBAL AFXAPI _AfxOleGetObjectDescriptorData(
	LPOLEOBJECT     lpOleObj,
	LPCOLESTR       lpszSrcOfCopy,
	DWORD           dwDrawAspect,
	POINTL          pointl,
	LPSIZEL         lpSizelHim)
{
	CLSID							clsid;
	::ATL::CComHeapPtr<OLECHAR>		sposzFullUserTypeName;
	::ATL::CComPtr<IMoniker>			spSrcMonikerOfCopy;
	HGLOBAL							hObjDesc = NULL;
	SCODE							sc;
	SIZEL							sizelHim;
	BOOL							bFreeSrcOfCopy = FALSE;
	::ATL::CComQIPtr<IViewObject2>	spViewObj2(lpOleObj);
	::ATL::CComQIPtr<IOleLink>		spOleLink(lpOleObj);
	BOOL							fIsLink;
	DWORD							dwStatus = 0;

	// query for IOleLink
	fIsLink = (spOleLink != NULL);

	// Get CLSID
	sc = lpOleObj->GetUserClassID(&clsid);
	if (sc != S_OK)
		clsid = CLSID_NULL;

	// Get FullUserTypeName
	sc = lpOleObj->GetUserType(USERCLASSTYPE_FULL, &sposzFullUserTypeName);

	// if object is a link, then expand usertypename to be "Linked %s"
	if (fIsLink && sposzFullUserTypeName)
	{
		// Note: If this LoadString call fails, it is likely that
		//  _AFX_NO_OLE_RESOURCES is defined in your .RC file.
		// To correct the situation remove the following line from your
		//  resource script:
		//      #define _AFX_NO_OLE_RESOURCES
		// This should be done using the Resource.Set Includes... command.
		CStringW strLinkedTypeFmt;
		ENSURE(strLinkedTypeFmt.LoadString(AFX_IDS_PASTELINKEDTYPE));

		int nBuf = ocslen(sposzFullUserTypeName) + strLinkedTypeFmt.GetLength() + 1;
		::ATL::CComHeapPtr<OLECHAR>	sposzNewFullUserTypeName;
		if(sposzNewFullUserTypeName.Allocate(nBuf))
		{
			ATL_CRT_ERRORCHECK_SPRINTF(_snwprintf_s(sposzNewFullUserTypeName, nBuf, nBuf - 1, strLinkedTypeFmt.GetString(), sposzFullUserTypeName));
			sposzFullUserTypeName.Attach(sposzNewFullUserTypeName.Detach());
		}
	}

	// get source of copy
	if (fIsLink)
	{
		sc = spOleLink->GetSourceDisplayName((LPOLESTR*)&lpszSrcOfCopy);
		bFreeSrcOfCopy = TRUE;
	}
	else if (lpszSrcOfCopy == NULL)
	{
		sc = lpOleObj->GetMoniker(
			OLEGETMONIKER_TEMPFORUSER, OLEWHICHMK_OBJFULL, &spSrcMonikerOfCopy);
		if (sc == S_OK)
		{
			::ATL::CComPtr<IBindCtx>		spbc;
			CreateBindCtx(0, &spbc);
			spSrcMonikerOfCopy->GetDisplayName(spbc, NULL,
				(LPOLESTR*)&lpszSrcOfCopy);
			bFreeSrcOfCopy = TRUE;
		}
	}

	if (lpSizelHim)
	{
		// Use extents passed by the caller
		sizelHim = *lpSizelHim;
	}
	else if (spViewObj2)
	{
		// Get the current extents from the object
		sc = spViewObj2->GetExtent(dwDrawAspect, -1, NULL,
			(LPSIZEL)&sizelHim);
		if (sc != S_OK)
			sizelHim.cx = sizelHim.cy = 0;
	}
	else
	{
		sizelHim.cx = sizelHim.cy = 0;
	}

	// Get dwStatus
	sc = lpOleObj->GetMiscStatus(dwDrawAspect, &dwStatus);
	if (sc != S_OK)
		dwStatus = 0;

	// Get OBJECTDESCRIPTOR
	hObjDesc = _AfxOleGetObjectDescriptorData(clsid, dwDrawAspect, sizelHim,
		pointl, dwStatus, sposzFullUserTypeName, lpszSrcOfCopy);

	// Clean up
	if (bFreeSrcOfCopy)
		CoTaskMemFree((LPOLESTR)lpszSrcOfCopy);

	return hObjDesc;
}

SCODE AFXAPI _AfxOleDoConvert(LPSTORAGE lpStg, REFCLSID rClsidNew)
{
	SCODE sc;
	CLSID clsidOld;
	if ((sc = ReadClassStg(lpStg, &clsidOld)) != S_OK)
	{
		clsidOld = CLSID_NULL;
		return sc;
	}

	// read old fmt/old user type; sets out params to NULL on error
	CLIPFORMAT cfOld;
	LPOLESTR lpszOld = NULL;
	sc = ReadFmtUserTypeStg(lpStg, &cfOld, &lpszOld);
	ASSERT(sc == S_OK || (cfOld == 0 && lpszOld == NULL));

	// get new user type name; if error, set to NULL string
	OLECHAR chZero = 0;
	LPOLESTR lpszNew = NULL;
	if (OleRegGetUserType(rClsidNew, USERCLASSTYPE_FULL, &lpszNew) != S_OK)
		lpszNew = &chZero;

	// write class stg
	if ((sc = WriteClassStg(lpStg, rClsidNew)) != S_OK)
		goto ErrorReturn;

	// write old fmt/new user type;
	if ((sc = WriteFmtUserTypeStg(lpStg, cfOld, lpszNew)) != S_OK)
		goto RewriteInfo;

	// set convert bit
	if ((sc = SetConvertStg(lpStg, TRUE)) != S_OK)
		goto RewriteInfo;

	goto ErrorReturn;

RewriteInfo:
	WriteClassStg(lpStg, clsidOld);
	WriteFmtUserTypeStg(lpStg, cfOld, lpszOld);

ErrorReturn:
	if (lpszNew != &chZero)
		CoTaskMemFree(lpszNew);

	CoTaskMemFree(lpszOld);
	return sc;
}

SCODE AFXAPI _AfxOleDoTreatAsClass(
	LPCTSTR lpszUserType, REFCLSID rclsid, REFCLSID rclsidNew)
{
	LPTSTR  lpszCLSID = NULL;
	HKEY    hKey;

	SCODE sc = CoTreatAsClass(rclsid, rclsidNew);
	if (sc != S_OK && lpszUserType != NULL)
	{
		AfxRegOpenKeyEx(HKEY_CLASSES_ROOT, _T("CLSID"), 0, KEY_SET_VALUE, &hKey);
		LPOLESTR lpOleStr = NULL;
		StringFromCLSID(rclsid, &lpOleStr);
		lpszCLSID = TASKSTRINGOLE2T(lpOleStr);
		RegSetValue(hKey, lpszCLSID, REG_SZ, lpszUserType,
			lstrlen(lpszUserType) * sizeof(TCHAR));

		CoTaskMemFree(lpszCLSID);
		sc = CoTreatAsClass(rclsid, rclsidNew);
		RegCloseKey(hKey);
	}
	return sc;
}

#define DEVNAMEPART(pdn, x) (pdn->x == 0 ? NULL : (LPCTSTR)pdn + pdn->x)

DVTARGETDEVICE* AFXAPI _AfxOleCreateTargetDevice(LPDEVNAMES pDN, LPDEVMODE pDM)
{
    USES_CONVERSION_EX;

	DVTARGETDEVICE* ptd = NULL;
	DWORD dwDevNamesSize, dwDevModeSize, dwPtdSize;

	LPCTSTR lpszDriverName = DEVNAMEPART(pDN, wDriverOffset);
	LPCTSTR lpszDeviceName = DEVNAMEPART(pDN, wDeviceOffset);
	LPCTSTR lpszPortName = DEVNAMEPART(pDN, wOutputOffset);

	ENSURE(lpszDriverName);
	ENSURE(lpszDeviceName);
	ENSURE(lpszPortName);
	CStringW strDriverNameOle(lpszDriverName);
	CStringW strDeviceNameOle(lpszDeviceName);
	CStringW strPortNameOle(lpszPortName);
	int nDriverNameSize = (int)((lpszDriverName == NULL) ? 0 : (strDriverNameOle.GetLength()+1)*sizeof(OLECHAR));
	int nDeviceNameSize = (int)((lpszDeviceName == NULL) ? 0 : (strDeviceNameOle.GetLength()+1)*sizeof(OLECHAR));
	int nPortNameSize = (int)((lpszPortName == NULL) ? 0 : (strPortNameOle.GetLength()+1)*sizeof(OLECHAR));

	LPDEVMODEOLE lpDevModeOle = DEVMODET2OLE_EX(pDM);
	ENSURE(lpDevModeOle);

	dwDevNamesSize = nDriverNameSize + nDeviceNameSize + nPortNameSize;
	dwDevModeSize = (DWORD)(lpDevModeOle->dmSize + lpDevModeOle->dmDriverExtra);

	dwPtdSize = sizeof(DVTARGETDEVICE) + dwDevNamesSize + dwDevModeSize;

	if ((ptd = (DVTARGETDEVICE*)CoTaskMemAlloc(dwPtdSize)) != NULL)
	{
		// copy in the info
		ptd->tdSize = (UINT)dwPtdSize;
		ptd->tdDriverNameOffset = sizeof(DVTARGETDEVICE);

		if(nDriverNameSize > 0)
		{
			Checked::wcscpy_s((LPOLESTR)((BYTE*)ptd + ptd->tdDriverNameOffset),
				(strDriverNameOle.GetLength()+1), strDriverNameOle.GetString());
		}

		ptd->tdDeviceNameOffset = (WORD)(ptd->tdDriverNameOffset + nDriverNameSize);
		if(nDeviceNameSize > 0)
		{
			Checked::wcscpy_s((LPOLESTR)((BYTE*)ptd + ptd->tdDeviceNameOffset), 
				(strDeviceNameOle.GetLength()+1), strDeviceNameOle.GetString());
		}

		ptd->tdPortNameOffset = (WORD)(ptd->tdDeviceNameOffset + nDeviceNameSize);
		if(nPortNameSize)
		{
			Checked::wcscpy_s((LPOLESTR)((BYTE*)ptd + ptd->tdPortNameOffset), 
				(strPortNameOle.GetLength()+1), strPortNameOle.GetString());
		}

		ptd->tdExtDevmodeOffset = (WORD)(ptd->tdPortNameOffset + nPortNameSize);
		Checked::memcpy_s((BYTE*)ptd + ptd->tdExtDevmodeOffset, dwPtdSize-ptd->tdExtDevmodeOffset, 
			lpDevModeOle, sizeof(DEVMODEOLE)+lpDevModeOle->dmDriverExtra);
	}
	return ptd;
}

DVTARGETDEVICE* AFXAPI _AfxOleCreateTargetDevice(LPPRINTDLG lpPrintDlg)
{
	DVTARGETDEVICE* ptd=NULL;
	LPDEVNAMES pDN;
	LPDEVMODE pDM;

	if ((pDN = (LPDEVNAMES)GlobalLock(lpPrintDlg->hDevNames)) == NULL)
		return NULL;

	if ((pDM = (LPDEVMODE)GlobalLock(lpPrintDlg->hDevMode)) == NULL)
	{
		GlobalUnlock(lpPrintDlg->hDevNames);
		return NULL;
	}

	ptd = _AfxOleCreateTargetDevice(pDN, pDM);

	GlobalUnlock(lpPrintDlg->hDevNames);
	GlobalUnlock(lpPrintDlg->hDevMode);

	return ptd;
}

LPMONIKER AFXAPI _AfxOleGetFirstMoniker(LPMONIKER lpmk)
{
	if (lpmk == NULL)
		return NULL;

	DWORD dwMksys;
	if (lpmk->IsSystemMoniker(&dwMksys) == S_OK
		&& dwMksys == MKSYS_GENERICCOMPOSITE)
	{
		LPENUMMONIKER lpenumMoniker = NULL;
		SCODE sc = lpmk->Enum(TRUE, &lpenumMoniker);
		if (sc != S_OK)
			return NULL;

		ASSERT(lpenumMoniker != NULL);
		LPMONIKER lpmkFirst = NULL;
		sc = lpenumMoniker->Next(1, &lpmkFirst, NULL);
		RELEASE(lpenumMoniker);
		return lpmkFirst;
	}

	// otherwise -- return the moniker itself
	lpmk->AddRef();
	return lpmk;
}

DWORD AFXAPI _AfxOleGetLenFilePrefixOfMoniker(LPMONIKER lpmk)
{
	if (lpmk == NULL)
		return 0;

	DWORD nLen = 0;
	LPMONIKER lpmkFirst = _AfxOleGetFirstMoniker(lpmk);
	if (lpmkFirst != NULL)
	{
		DWORD  dwMksys;
		if (lpmkFirst->IsSystemMoniker(&dwMksys) == S_OK &&
			dwMksys == MKSYS_FILEMONIKER)
		{
			LPBC lpbc = NULL;
			SCODE sc = CreateBindCtx(0, &lpbc);
			if (sc == S_OK)
			{
				LPOLESTR lpw = NULL;
				sc = lpmkFirst->GetDisplayName(lpbc, NULL, &lpw);
				if (sc == S_OK && lpw != NULL)
				{
					nLen = static_cast<DWORD>(wcslen(lpw));
					CoTaskMemFree(lpw);
				}
				RELEASE(lpbc);
			}
		}
		RELEASE(lpmkFirst);
	}
	return nLen;
}

DVTARGETDEVICE* AFXAPI _AfxOleCopyTargetDevice(DVTARGETDEVICE* ptdSrc)
{
	if (ptdSrc == NULL)
		return NULL;

	DVTARGETDEVICE* ptdDest =
		(DVTARGETDEVICE*)CoTaskMemAlloc(ptdSrc->tdSize);
	if (ptdDest == NULL)
		return NULL;

	Checked::memcpy_s(ptdDest, (size_t)ptdSrc->tdSize, 
		ptdSrc, (size_t)ptdSrc->tdSize);
	return ptdDest;
}

void AFXAPI _AfxOleCopyFormatEtc(LPFORMATETC petcDest, LPFORMATETC petcSrc)
{
	ASSERT(petcDest != NULL);
	ASSERT(petcSrc != NULL);

	petcDest->cfFormat = petcSrc->cfFormat;
	petcDest->ptd = _AfxOleCopyTargetDevice(petcSrc->ptd);
	petcDest->dwAspect = petcSrc->dwAspect;
	petcDest->lindex = petcSrc->lindex;
	petcDest->tymed = petcSrc->tymed;
}

HDC WINAPI _AfxOleCreateDC(DVTARGETDEVICE* ptd)
{
    USES_CONVERSION_EX;
	// return screen DC for NULL target device
	if (ptd == NULL)
		return ::CreateDC(_T("DISPLAY"), NULL, NULL, NULL);

	LPDEVMODEOLE lpDevMode;
	LPOLESTR lpszDriverName;
	LPOLESTR lpszDeviceName;
	LPOLESTR lpszPortName;

	if (ptd->tdExtDevmodeOffset == 0)
		lpDevMode = NULL;
	else
		lpDevMode  = (LPDEVMODEOLE) ((LPSTR)ptd + ptd->tdExtDevmodeOffset);

	lpszDriverName = (LPOLESTR)((BYTE*)ptd + ptd->tdDriverNameOffset);
	lpszDeviceName = (LPOLESTR)((BYTE*)ptd + ptd->tdDeviceNameOffset);
	lpszPortName   = (LPOLESTR)((BYTE*)ptd + ptd->tdPortNameOffset);

	return ::CreateDC(CString(lpszDriverName), CString(lpszDeviceName),
		CString(lpszPortName), DEVMODEOLE2T_EX(lpDevMode));
}

void AFXAPI _AfxDeleteMetafilePict(HGLOBAL hMetaPict)
{
	if (hMetaPict != NULL)
	{
		STGMEDIUM stgMedium;
		stgMedium.hGlobal = hMetaPict;
		stgMedium.tymed = TYMED_MFPICT;
		stgMedium.pUnkForRelease = NULL;
		ReleaseStgMedium(&stgMedium);
	}
}

#define HIMETRIC_PER_INCH   2540
#define MAP_PIX_TO_LOGHIM(x,ppli)   MulDiv(HIMETRIC_PER_INCH, (x), (ppli))
#define MAP_LOGHIM_TO_PIX(x,ppli)   MulDiv((ppli), (x), HIMETRIC_PER_INCH)

void AFXAPI _AfxXformSizeInPixelsToHimetric(
	HDC hDC, LPSIZEL lpSizeInPix, LPSIZEL lpSizeInHiMetric)
{
	int cxPPI;
	int cyPPI;

	if ((NULL == hDC) || (GetDeviceCaps(hDC, LOGPIXELSX) == 0))
	{
		cxPPI = afxData.cxPixelsPerInch;
		cyPPI = afxData.cyPixelsPerInch;
	}
	else
	{
		cxPPI = GetDeviceCaps(hDC, LOGPIXELSX);
		cyPPI = GetDeviceCaps(hDC, LOGPIXELSY);
	}

	lpSizeInHiMetric->cx = (long)MAP_PIX_TO_LOGHIM((int)lpSizeInPix->cx, cxPPI);
	lpSizeInHiMetric->cy = (long)MAP_PIX_TO_LOGHIM((int)lpSizeInPix->cy, cyPPI);
}

void AFXAPI _AfxXformSizeInHimetricToPixels(
	HDC hDC, LPSIZEL lpSizeInHiMetric, LPSIZEL lpSizeInPix)
{
	int cxPPI;
	int cyPPI;

	if ((NULL == hDC) || (GetDeviceCaps(hDC, LOGPIXELSX) == 0))
	{
		cxPPI = afxData.cxPixelsPerInch;
		cyPPI = afxData.cyPixelsPerInch;
	}
	else
	{
		cxPPI = GetDeviceCaps(hDC, LOGPIXELSX);
		cyPPI = GetDeviceCaps(hDC, LOGPIXELSY);
	}

	lpSizeInPix->cx = (long)MAP_LOGHIM_TO_PIX((int)lpSizeInHiMetric->cx, cxPPI);
	lpSizeInPix->cy = (long)MAP_LOGHIM_TO_PIX((int)lpSizeInHiMetric->cy, cyPPI);
}


IMPLEMENT_DYNAMIC(COleException, CException)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\olelink.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

#define OLE_MAXNAMESIZE     (256)

/////////////////////////////////////////////////////////////////////////////
// COleLinkingDoc - enables linking to embeddings (basis for server)

COleLinkingDoc::COleLinkingDoc()
{
	m_dwRegister = 0;
	m_pFactory = NULL;
	m_bVisibleLock = FALSE;
	m_bDeferErrors = FALSE;
	m_pLastException = NULL;
	m_lpMonikerROT = NULL;

	ASSERT_VALID(this);
}

COleLinkingDoc::~COleLinkingDoc()
{
	AFX_BEGIN_DESTRUCTOR

		ASSERT_VALID(this);

		ASSERT(!m_bVisibleLock);

		DisconnectViews();
		ASSERT(m_viewList.IsEmpty());

		Revoke();   // cleanup naming support

		ExternalDisconnect();

	AFX_END_DESTRUCTOR
}

/////////////////////////////////////////////////////////////////////////////
// COleLinkingDoc moniker handling

LPMONIKER COleLinkingDoc::GetMoniker(OLEGETMONIKER nAssign)
{
	ASSERT_VALID(this);

	// use base class implementation if no registered moniker
	if (m_strMoniker.IsEmpty())
		return COleDocument::GetMoniker(nAssign);

	// return file moniker based on current path name
	LPMONIKER lpMoniker;
	CreateFileMoniker(CStringW(m_strMoniker), &lpMoniker);
	return lpMoniker;
}

BOOL COleLinkingDoc::Register(COleObjectFactory* pFactory, LPCTSTR lpszPathName)
{
	ASSERT_VALID(this);
	ASSERT(pFactory == NULL ||
		AfxIsValidAddress(pFactory, sizeof(COleObjectFactory)));
	ASSERT(lpszPathName == NULL || AfxIsValidString(lpszPathName));
	ASSERT(m_dwRegister == 0);

	// attach the document to the server
	ASSERT(m_pFactory == NULL || m_pFactory == pFactory);
	m_pFactory = pFactory;

	BOOL bResult = TRUE;

	// create file moniker based on path name
	RELEASE(m_lpMonikerROT);
	m_strMoniker.Empty();
	if (lpszPathName != NULL)
	{
		if (CreateFileMoniker(CStringW(lpszPathName), &m_lpMonikerROT) != S_OK)
			bResult = FALSE;
	}

	// register file moniker as running
	if (m_lpMonikerROT != NULL)
	{
		// see if the object is already running in the ROT
		LPRUNNINGOBJECTTABLE lpROT = NULL;
		VERIFY(GetRunningObjectTable(0, &lpROT) == S_OK);
		ASSERT(lpROT != NULL);
		LPUNKNOWN lpUnk;
		if (lpROT->GetObject(m_lpMonikerROT, &lpUnk) == S_OK)
		{
			// fatal error -- can't register same moniker twice!
			lpUnk->Release();
			RELEASE(m_lpMonikerROT);
			return FALSE;
		}
		// not already running -- so ok to attempt registration
		SCODE sc = lpROT->Register(NULL, (LPUNKNOWN)
			GetInterface(&IID_IUnknown), m_lpMonikerROT, &m_dwRegister);
		lpROT->Release();
		m_strMoniker = lpszPathName;
		if (sc != S_OK)
			bResult = FALSE;
	}

	// update all objects with new moniker
	POSITION pos = GetStartPosition();
	COleClientItem* pItem;
	while ((pItem = GetNextClientItem(pos)) != NULL)
	{
		if (pItem->m_bMoniker)
		{
			ASSERT(pItem->m_lpObject != NULL);
			pItem->m_lpObject->SetMoniker(OLEWHICHMK_CONTAINER,
				m_lpMonikerROT);
		}
	}

	return bResult;
}

void COleLinkingDoc::Revoke()
{
	ASSERT_VALID(this);

	// revoke current registration
	if (m_dwRegister != 0)
	{
		LPRUNNINGOBJECTTABLE lpROT = NULL;
		GetRunningObjectTable(0, &lpROT);
		if (lpROT != NULL)
		{
			lpROT->Revoke(m_dwRegister);
			lpROT->Release();
		}
		m_dwRegister = 0;
	}
	RELEASE(m_lpMonikerROT);
	m_strMoniker = _T("");
}

BOOL COleLinkingDoc::OnNewDocument()
{
	ASSERT_VALID(this);

	Revoke();
	RegisterIfServerAttached(NULL, TRUE);

	if (!COleDocument::OnNewDocument())
		return FALSE;

	// user is not "in control" of the application in case of Search and Organize handler
	if (!IsSearchAndOrganizeHandler())
		AfxOleSetUserCtrl(TRUE);

	return TRUE;
}

BOOL COleLinkingDoc::OnOpenDocument(LPCTSTR lpszPathName)
{
	ASSERT_VALID(this);

	// always register the document before opening it
	Revoke();
	if (!RegisterIfServerAttached(lpszPathName, FALSE))
	{
		// always output a trace (it is just an FYI -- not generally fatal)
		TRACE(traceOle, 0, _T("Warning: Unable to register moniker '%s' as running\n"), lpszPathName);
	}

	if (!COleDocument::OnOpenDocument(lpszPathName))
	{
		Revoke();
		return FALSE;
	}

	// if the app was started only to print, don't set user control

	CWinApp* pApp = AfxGetApp();
	ASSERT(pApp != NULL);
	if (pApp->m_pCmdInfo == NULL ||
		(pApp->m_pCmdInfo->m_nShellCommand != CCommandLineInfo::FileDDE &&
		 pApp->m_pCmdInfo->m_nShellCommand != CCommandLineInfo::FilePrint))
	{
		AfxOleSetUserCtrl(TRUE);
	}

	return TRUE;
}

BOOL COleLinkingDoc::OnSaveDocument(LPCTSTR lpszPathName)
{
	ASSERT_VALID(this);

	BOOL bRemember = m_bRemember;
	if (!COleDocument::OnSaveDocument(lpszPathName))
		return FALSE;

	if (bRemember && (m_strMoniker != lpszPathName))
	{
		// update the moniker/registration since the name has changed
		Revoke();
		RegisterIfServerAttached(lpszPathName, TRUE);
	}
	return TRUE;
}

void COleLinkingDoc::OnCloseDocument()
{
	// SO handler (rich preview) can be destroyed only from FinalRelease 
	if (IsSearchAndOrganizeHandler() && !m_bFinalRelease)
	{
		return;
	}
	InternalAddRef();   // protect document during shutdown

	// update lock count before sending notifications
	UpdateVisibleLock(FALSE, FALSE);

	Revoke();   // cleanup naming support

	// remove visible lock if present
	if (m_bVisibleLock)
	{
		m_bVisibleLock = FALSE;
		LockExternal(FALSE, FALSE);
	}

	// cleanup the document but don't delete yet
	BOOL bAutoDelete = m_bAutoDelete;
	m_bAutoDelete = FALSE;
	COleDocument::OnCloseDocument();
	ASSERT_VALID(this);

	// remove extra reference count and destroy
	InterlockedDecrement(&m_dwRef);
	if (bAutoDelete)
		delete this;    // now safe to destroy document
}

void COleLinkingDoc::UpdateVisibleLock(BOOL bVisible, BOOL bRemoveRefs)
{
	ASSERT_VALID(this);

	if (bVisible != m_bVisibleLock)
	{
		InternalAddRef();   // make sure document is stable
		m_bVisibleLock = bVisible;
		LockExternal(bVisible, bRemoveRefs);
		InternalRelease();  // may Release the document!
	}
}

void COleLinkingDoc::OnShowViews(BOOL bVisible)
{
	if (bVisible)
		UpdateVisibleLock(bVisible, TRUE);
}

void COleLinkingDoc::SaveToStorage(CObject* pObject)
{
	ASSERT_VALID(this);
	if (pObject != NULL)
		ASSERT_VALID(pObject);

	// write the classID of the application to the root storage
	if (m_pFactory != NULL)
	{
		ASSERT(m_lpRootStg != NULL);
		WriteClassStg(m_lpRootStg, m_pFactory->GetClassID());
	}
	COleDocument::SaveToStorage(pObject);
}

BOOL COleLinkingDoc::RegisterIfServerAttached(LPCTSTR lpszPathName, BOOL bMessage)
{
	ASSERT_VALID(this);
	ASSERT(lpszPathName == NULL || AfxIsValidString(lpszPathName));

	CDocTemplate* pTemplate = GetDocTemplate();

	if (IsSearchAndOrganizeHandler() && pTemplate == NULL)
	{
		// a document template can be missing in case of S&O handler implemented in DLL
		return TRUE;
	}

	ASSERT_VALID(pTemplate);

	COleObjectFactory* pFactory =
		(COleObjectFactory*)pTemplate->m_pAttachedFactory;
	if (pFactory != NULL)
	{
		// always attach the document to the server at this time
		ASSERT_KINDOF(COleObjectFactory, pFactory);
		m_pFactory = pFactory;

		// register with OLE Server
		if (!Register(pFactory, lpszPathName))
		{
			if (bMessage)
			{
				// only report error when message box allowed
				ReportSaveLoadException(lpszPathName, NULL, FALSE,
					AFX_IDP_FAILED_TO_NOTIFY);
			}
			return FALSE;
		}
	}
	return TRUE;
}

LPOLEITEMCONTAINER COleLinkingDoc::GetContainer()
{
	ASSERT_VALID(this);

	// get the IOleItemContainer interface via QueryInterface
	LPOLEITEMCONTAINER lpContainer;
	InternalQueryInterface(&IID_IOleItemContainer, (LPLP)&lpContainer);
	return lpContainer;
}

/////////////////////////////////////////////////////////////////////////////
// COleLinkingDoc default implementation

COleServerItem* COleLinkingDoc::OnGetLinkedItem(LPCTSTR /*lpszItemName*/)
{
	ASSERT_VALID(this);

	// default implementation is in COleServerDoc
	return NULL;
}

COleClientItem* COleLinkingDoc::OnFindEmbeddedItem(LPCTSTR lpszItemName)
{
	ASSERT_VALID(this);
	ASSERT(AfxIsValidString(lpszItemName));

	// default implementation walks list of client items looking for
	//  a case sensitive match

	POSITION pos = GetStartPosition();
	COleClientItem* pItem;
	while ((pItem = GetNextClientItem(pos)) != NULL)
	{
		// a client item is running if there is a match in name
		//  and the m_lpObject is also running.
		TCHAR szItemName[OLE_MAXITEMNAME];
		pItem->GetItemName(szItemName, _countof(szItemName));
		if (lstrcmp(szItemName, lpszItemName) == 0)
			return pItem;
	}

	TRACE(traceOle, 1, "Warning: default COleLinkingDoc::OnFindEmbeddedItem\n");
	TRACE(traceOle, 1, _T("\timplementation failed to find item '%s'.\n"), lpszItemName);

	return NULL;    // no matching item found
}

void COleLinkingDoc::LockExternal(BOOL bLock, BOOL bRemoveRefs)
{
	// when an item binding is successful, the original document
	//  is released.  To keep it alive and the RPC stubs that make
	//  it available to the external world (via the running object
	//  table), we need to place a lock on it.

	// a lock created with CoLockObjectExternal adds a reference
	//  to the object itself (with IUnknown::AddRef) as well
	//  as keeping the RPC stub alive.

	::CoLockObjectExternal((LPUNKNOWN)GetInterface(&IID_IUnknown),
		bLock, bRemoveRefs);

	if (bLock)
	{
		// avoid "dead" objects in the running object table (ROT), by
		//  re-registering this object in the ROT.
		if (!m_strPathName.IsEmpty())
		{
			Revoke();
			RegisterIfServerAttached(m_strPathName, FALSE);
		}
	}
}

void COleLinkingDoc::ReportSaveLoadException(LPCTSTR lpszPathName,
	CException* e, BOOL bSaving, UINT nIDPDefault)
{
	// watch out for special mode
	if (m_bDeferErrors)
	{
		// Note: CException::Delete does not treat m_bAutoDelete as a
		// traditional  BOOL. Only if it is greater than zero does it
		// take on a TRUE quality.  (that is, all tests are for
		// m_bAutoDelete > 0).  So, if m_bAutoDelete is already "true"
		// (1) this will make it false, and if it is already "false"
		//  it is still considered "false".  Valid values for
		// m_bAutoDelete are thus negative, 0, and 1.  Values greater
		// than 1, although not explicitly asserted in CException,
		// would be invalid.  In short, by using increment  and
		// decrement operations, we enable this to work with both
		// self-deleting and non-self-deleting CException classes.

		// protect the case when e == NULL, OK now.
		if (e)
		{
			--e->m_bAutoDelete;
		}

		// save the exception for later
		m_pLastException = e;
		return;
	}

	// otherwise, just call base class
	COleDocument::ReportSaveLoadException(lpszPathName, e, bSaving,
		nIDPDefault);
}

SCODE COleLinkingDoc::EndDeferErrors(SCODE sc)
{
	ASSERT(m_bDeferErrors != 0);
	--m_bDeferErrors;
	if (m_pLastException != NULL)
	{
		ASSERT_VALID(m_pLastException);
		if (sc == S_OK)
			sc = COleException::Process(m_pLastException);

		// Note: See note above in ReportSaveLoadException for
		// a comment regarding the special treatment of m_bAutoDelete.

		++m_pLastException->m_bAutoDelete;

		// now get rid of the exception that we saved
		m_pLastException->Delete();
		m_pLastException = NULL;
	}
	return sc;
}

/////////////////////////////////////////////////////////////////////////////
// COleLinkingDoc OLE interface implementation

BEGIN_INTERFACE_MAP(COleLinkingDoc, COleDocument)
	INTERFACE_PART(COleLinkingDoc, IID_IPersist, PersistFile)
	INTERFACE_PART(COleLinkingDoc, IID_IPersistFile, PersistFile)
	INTERFACE_PART(COleLinkingDoc, IID_IParseDisplayName, OleItemContainer)
	INTERFACE_PART(COleLinkingDoc, IID_IOleContainer, OleItemContainer)
	INTERFACE_PART(COleLinkingDoc, IID_IOleItemContainer, OleItemContainer)
END_INTERFACE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COleLinkingDoc::XPersistFile implementation

STDMETHODIMP_(ULONG) COleLinkingDoc::XPersistFile::AddRef()
{
	METHOD_PROLOGUE_EX_(COleLinkingDoc, PersistFile)
	return pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) COleLinkingDoc::XPersistFile::Release()
{
	METHOD_PROLOGUE_EX_(COleLinkingDoc, PersistFile)
	return pThis->ExternalRelease();
}

STDMETHODIMP COleLinkingDoc::XPersistFile::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(COleLinkingDoc, PersistFile)
	return pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP COleLinkingDoc::XPersistFile::GetClassID(LPCLSID lpClassID)
{
	METHOD_PROLOGUE_EX_(COleLinkingDoc, PersistFile)

	// this is sometimes called for documents not attached to servers!
	if (pThis->m_pFactory == NULL)
	{
		*lpClassID = CLSID_NULL;
		return E_FAIL;
	}

	// get the class ID from the connected server object
	ASSERT_VALID(pThis->m_pFactory);
	*lpClassID = pThis->m_pFactory->GetClassID();
	return S_OK;
}

STDMETHODIMP COleLinkingDoc::XPersistFile::IsDirty()
{
	METHOD_PROLOGUE_EX(COleLinkingDoc, PersistFile)
	return pThis->IsModified() ? S_OK : S_FALSE;
}

STDMETHODIMP COleLinkingDoc::XPersistFile::Load(
	LPCOLESTR lpszFileName, DWORD /*dwMode*/)
{
	METHOD_PROLOGUE_EX(COleLinkingDoc, PersistFile)
	ASSERT_VALID(pThis);

	SCODE sc = E_FAIL;
	pThis->BeginDeferErrors();
	CString strFileName(lpszFileName);
	TRY
	{
		BOOL bUserCtrl = AfxOleGetUserCtrl();

		// delegate to file-based Open implementation
		if (!pThis->OnOpenDocument(strFileName))
		{
			AfxOleSetUserCtrl(bUserCtrl);
			return sc;
		}
		pThis->SendInitialUpdate();

		// set the path name, but don't add to MRU list
		pThis->SetPathName(strFileName, FALSE);
		AfxOleSetUserCtrl(bUserCtrl);

		sc = S_OK;
	}
	END_TRY
	sc = pThis->EndDeferErrors(sc);

	ASSERT_VALID(pThis);
	return sc;
}

STDMETHODIMP COleLinkingDoc::XPersistFile::Save(
	LPCOLESTR lpszFileName, BOOL fRemember)
{
	METHOD_PROLOGUE_EX(COleLinkingDoc, PersistFile)
	ASSERT_VALID(pThis);

	SCODE sc = E_FAIL;
	pThis->BeginDeferErrors();
	TRY
	{
		// delegate to file-based Save/Save As implementation
		ASSERT(pThis->m_bRemember);
		pThis->m_bRemember = fRemember;
		pThis->OnSaveDocument(CString(lpszFileName));
		sc = S_OK;
	}
	END_TRY
	sc = pThis->EndDeferErrors(sc);

	ASSERT_VALID(pThis);
	return sc;
}

STDMETHODIMP COleLinkingDoc::XPersistFile::SaveCompleted(LPCOLESTR lpszFileName)
{
	METHOD_PROLOGUE_EX(COleLinkingDoc, PersistFile)
	ASSERT_VALID(pThis);

	TRY
	{
		// set the path name, but don't add to MRU list
		pThis->SetPathName(CString(lpszFileName), FALSE);
	}
	END_TRY

	ASSERT_VALID(pThis);
	return S_OK;
}

STDMETHODIMP COleLinkingDoc::XPersistFile::GetCurFile(LPOLESTR* lplpszFileName)
{
	METHOD_PROLOGUE_EX_(COleLinkingDoc, PersistFile)

	*lplpszFileName = NULL;

	// use title if no document
	LPCTSTR lpszResult;
	if (pThis->m_strPathName.IsEmpty())
		lpszResult = pThis->m_strTitle;
	else
		lpszResult = pThis->m_strPathName;
	ASSERT(lpszResult != NULL);

	// allocate memory for the file name
	*lplpszFileName = AtlAllocTaskOleString(lpszResult);
	if (*lplpszFileName == NULL)
		return E_OUTOFMEMORY;

	ASSERT_VALID(pThis);
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// Implementation of IOleItemContainer
//  (supports linking to embeddings and linking to pseudo-objects)

STDMETHODIMP_(ULONG) COleLinkingDoc::XOleItemContainer::AddRef()
{
	METHOD_PROLOGUE_EX_(COleLinkingDoc, OleItemContainer)
	return pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) COleLinkingDoc::XOleItemContainer::Release()
{
	METHOD_PROLOGUE_EX_(COleLinkingDoc, OleItemContainer)
	return pThis->ExternalRelease();
}

STDMETHODIMP COleLinkingDoc::XOleItemContainer::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(COleLinkingDoc, OleItemContainer)
	return pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP COleLinkingDoc::XOleItemContainer::EnumObjects(
	DWORD /*grfFlags*/, LPENUMUNKNOWN* ppEnumUnknown)
{
	*ppEnumUnknown = NULL;
	return E_NOTIMPL;
}

STDMETHODIMP COleLinkingDoc::XOleItemContainer::ParseDisplayName(LPBC lpbc,
	LPOLESTR lpszDisplayName, ULONG* cchEaten, LPMONIKER* ppMoniker)
{
	METHOD_PROLOGUE_EX_(COleLinkingDoc, OleItemContainer)

	// reset all OUT parameters
	*ppMoniker = NULL;

	TCHAR szItemName[OLE_MAXNAMESIZE];
	LPTSTR lpszDest = szItemName;
	CString strSrc(lpszDisplayName);
	LPCTSTR lpszSrc = strSrc.GetString();

	// skip leading delimiters
	int cEaten = 0;
	while (*lpszSrc != '\0' && (*lpszSrc == '\\' || *lpszSrc == '/' ||
		*lpszSrc == ':' || *lpszSrc == '!' || *lpszSrc == '['))
	{
		if (_istlead(*lpszSrc))
			++lpszSrc, ++cEaten;
		++lpszSrc;
		++cEaten;
	}

	// parse next token in szItemName
	while (*lpszSrc != '\0' && *lpszSrc != '\\' && *lpszSrc != '/' &&
		*lpszSrc != ':' && *lpszSrc != '!' && *lpszSrc != '[' &&
		cEaten < OLE_MAXNAMESIZE-1)
	{
		if (_istlead(*lpszSrc))
			*lpszDest++ = *lpszSrc++, ++cEaten;
		*lpszDest++ = *lpszSrc++;
		++cEaten;
	}
	*cchEaten = cEaten;
	*lpszDest = 0;

	// attempt to get the object
	LPUNKNOWN lpUnknown;
	SCODE sc = GetObject((LPOLESTR)CStringW(szItemName).GetString(), BINDSPEED_INDEFINITE, lpbc,
		IID_IUnknown, (LPLP)&lpUnknown);
	if (sc != S_OK)
		return sc;

	// item name found -- create item moniker for it
	lpUnknown->Release();
	return CreateItemMoniker(OLESTDDELIMOLE, CStringW(szItemName), ppMoniker);
}

STDMETHODIMP COleLinkingDoc::XOleItemContainer::LockContainer(BOOL fLock)
{
	METHOD_PROLOGUE_EX_(COleLinkingDoc, OleItemContainer)

	pThis->LockExternal(fLock, TRUE);
	return S_OK;
}

STDMETHODIMP COleLinkingDoc::XOleItemContainer::GetObject(
	LPOLESTR lpszItem, DWORD dwSpeedNeeded, LPBINDCTX /*pbc*/, REFIID riid,
	LPVOID* ppvObject)
{
	METHOD_PROLOGUE_EX(COleLinkingDoc, OleItemContainer)
	ASSERT_VALID(pThis);

	*ppvObject = NULL;

	SCODE sc = MK_E_NOOBJECT;
	TRY
	{
		CString strItemT(lpszItem);
		// check for link to embedding
		COleClientItem* pClientItem = pThis->OnFindEmbeddedItem(strItemT);
		if (pClientItem != NULL)
		{
			ASSERT_VALID(pClientItem);
			sc = S_OK;

			// item found -- make sure it is running
			if (!::OleIsRunning(pClientItem->m_lpObject))
			{
				// should not run the object if bind-speed is immediate
				if (dwSpeedNeeded != BINDSPEED_INDEFINITE)
					sc = MK_E_EXCEEDEDDEADLINE;
				else
				{
					// bind speed is not immediate -- so run the object
					sc = OleRun(pClientItem->m_lpObject);
				}
			}

			if (sc == S_OK)
			{
				// return the object with appropriate interface
				sc = pClientItem->m_lpObject->QueryInterface(riid, ppvObject);
			}
		}
		else
		{
			// check for link to pseudo object
			COleServerItem* pServerItem = pThis->OnGetLinkedItem(strItemT);
			if (pServerItem != NULL)
			{
				if (!pServerItem->m_bNeedUnlock)
				{
					// when a link is bound, the document must be kept alive
					pThis->LockExternal(TRUE, FALSE);
					pServerItem->m_bNeedUnlock = TRUE;
				}

				// matching item found -- query for the requested interface
				sc = pServerItem->ExternalQueryInterface(&riid, ppvObject);
			}
		}
	}
	END_TRY

	return sc;
}

STDMETHODIMP COleLinkingDoc::XOleItemContainer::GetObjectStorage(
	LPOLESTR lpszItem, LPBINDCTX /*pbc*/, REFIID riid, LPVOID* ppvStorage)
{
	METHOD_PROLOGUE_EX(COleLinkingDoc, OleItemContainer)
	ASSERT_VALID(pThis);

	*ppvStorage = NULL;

	// only IStorage is supported
	if (riid != IID_IStorage)
		return E_UNEXPECTED;

	// check for link to embedding
	COleClientItem* pClientItem = pThis->OnFindEmbeddedItem(CString(lpszItem));
	if (pClientItem != NULL)
	{
		ASSERT_VALID(pClientItem);

		// if object has no storage, can't return it!
		if (pClientItem->m_lpStorage != NULL)
		{
			// found matching item -- return the storage
			*ppvStorage = pClientItem->m_lpStorage;
			pClientItem->m_lpStorage->AddRef();
			return S_OK;
		}
	}
	return MK_E_NOSTORAGE;
}

STDMETHODIMP COleLinkingDoc::XOleItemContainer::IsRunning(LPOLESTR lpszItem)
{
	METHOD_PROLOGUE_EX(COleLinkingDoc, OleItemContainer)
	ASSERT_VALID(pThis);

	// check for link to embedding
	CString strItemT(lpszItem);
	COleClientItem* pClientItem = pThis->OnFindEmbeddedItem(strItemT);
	if (pClientItem != NULL)
	{
		ASSERT_VALID(pClientItem);
		if (!::OleIsRunning(pClientItem->m_lpObject))
			return S_FALSE;

		return S_OK; // item is in document and is running
	}

	// check for link to pseudo object
	SCODE sc = MK_E_NOOBJECT;
	TRY
	{
		COleServerItem* pServerItem = pThis->OnGetLinkedItem(strItemT);
		if (pServerItem != NULL)
			sc = S_OK;
	}
	END_TRY

	return sc;
}

/////////////////////////////////////////////////////////////////////////////
// COleLinkingDoc diagnostics

#ifdef _DEBUG
void COleLinkingDoc::AssertValid() const
{
	COleDocument::AssertValid();
	if (m_pFactory != NULL)
		m_pFactory->AssertValid();
}

void COleLinkingDoc::Dump(CDumpContext& dc) const
{
	COleDocument::Dump(dc);

	dc << "\nm_dwRegister = " << m_dwRegister;
	dc << "\nm_bVisibleLock = " << m_bVisibleLock;
	if (m_pFactory != NULL)
		dc << "\nwith factory: " << m_pFactory;
	else
		dc << "\nwith no factory";

	dc << "\n";
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\oleimpl2.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Note: Must include AFXOLE.H first

#pragma once

#undef AFX_DATA
#define AFX_DATA AFX_OLE_DATA

/////////////////////////////////////////////////////////////////////////////
// COleFrameHook - AFX_INTERNAL

class COleFrameHook : public CCmdTarget
{
// Construction & Destruction
public:
	COleFrameHook(CFrameWnd* pFrameWnd, COleClientItem* pItem);

// Implementation
public:
	~COleFrameHook();

	CFrameWnd* m_pFrameWnd;
	LPOLEINPLACEACTIVEOBJECT m_lpActiveObject;
	COleClientItem* m_pActiveItem;  // item this COleFrameHook is for
	HWND m_hWnd;            // actual HWND this hook is attached to
	BOOL m_bInModalState;   // TRUE if EnableModeless(FALSE) has been called
	BOOL m_bToolBarHidden;  // TRUE if toolbar needs to be shown OnUIDeactivate
	HACCEL m_hAccelTable;   // accelerator to be used while in-place object active
	UINT m_nModelessCount;  // !0 if server's EnableModeless has been called
	CString m_strObjName;   // name of the active in-place object

// Overrides for implementation
public:
	virtual void OnRecalcLayout();  // for border space re-negotiation
	virtual BOOL OnPreTranslateMessage(MSG* pMsg);
	virtual void OnActivate(BOOL bActive); // for OnFrameWindowActivate
	virtual BOOL OnDocActivate(BOOL bActive);   // for OnDocWindowActivate
	virtual BOOL OnContextHelp(BOOL bEnter);
	virtual void OnEnableModeless(BOOL bEnable);
	virtual BOOL OnUpdateFrameTitle();
	virtual void OnPaletteChanged(CWnd* pFocusWnd);
	virtual BOOL OnQueryNewPalette();
	virtual BOOL OnInitMenuPopup(CMenu* pMenu, int nIndex, BOOL bSysMenu);
	virtual void OnInitMenu(CMenu* pMenu);
	virtual BOOL OnMenuSelect(UINT nItemID, UINT nFlags, HMENU hSysMenu);

	// implementation helpers
	BOOL NotifyAllInPlace(
		BOOL bParam, BOOL (COleFrameHook::*pNotifyFunc)(BOOL bParam));
	BOOL DoContextSensitiveHelp(BOOL bEnter);
	BOOL DoEnableModeless(BOOL bEnable);

// Interface Maps
public:
	BEGIN_INTERFACE_PART(OleInPlaceFrame, IOleInPlaceFrame)
		INIT_INTERFACE_PART(COleFrameHook, OleInPlaceFrame)
		STDMETHOD(GetWindow)(HWND*);
		STDMETHOD(ContextSensitiveHelp)(BOOL);
		STDMETHOD(GetBorder)(LPRECT);
		STDMETHOD(RequestBorderSpace)(LPCBORDERWIDTHS);
		STDMETHOD(SetBorderSpace)(LPCBORDERWIDTHS);
		STDMETHOD(SetActiveObject)(LPOLEINPLACEACTIVEOBJECT, LPCOLESTR);
		STDMETHOD(InsertMenus)(HMENU, LPOLEMENUGROUPWIDTHS);
		STDMETHOD(SetMenu)(HMENU, HOLEMENU, HWND);
		STDMETHOD(RemoveMenus)(HMENU);
		STDMETHOD(SetStatusText)(LPCOLESTR);
		STDMETHOD(EnableModeless)(BOOL);
		STDMETHOD(TranslateAccelerator)(LPMSG, WORD);
	END_INTERFACE_PART(OleInPlaceFrame)

	// this interface is here because some applications
	// are broken and require IOleCommandTarget to be
	// implemented before they'll properly activate
	BEGIN_INTERFACE_PART(OleCommandTarget, IOleCommandTarget)
		INIT_INTERFACE_PART(COleFrameHook, OleCommandTarget)
		STDMETHOD(Exec)(const GUID*, DWORD, DWORD,
		   VARIANTARG*, VARIANTARG*);
		STDMETHOD(QueryStatus)(const GUID*, ULONG, OLECMD foo[], OLECMDTEXT*);
	END_INTERFACE_PART(OleCommandTarget)

	DECLARE_INTERFACE_MAP()

	friend COleClientItem;
};

/////////////////////////////////////////////////////////////////////////////
// Helper for implementing OLE enumerators

// Note: the following interface is not an actual OLE interface, but is useful
//  for describing an abstract (not typesafe) enumerator.

#undef  INTERFACE
#define INTERFACE   IEnumVOID

DECLARE_INTERFACE_(IEnumVOID, IUnknown)
{
	STDMETHOD(QueryInterface)(REFIID, LPVOID*) PURE;
	STDMETHOD_(ULONG,AddRef)()  PURE;
	STDMETHOD_(ULONG,Release)() PURE;
	STDMETHOD(Next)(ULONG, void*, ULONG*) PURE;
	STDMETHOD(Skip)(ULONG) PURE;
	STDMETHOD(Reset)() PURE;
	STDMETHOD(Clone)(IEnumVOID**) PURE;
};

class CEnumArray : public CCmdTarget
{
// Constructors
public:
	CEnumArray(size_t nSize,
		const void* pvEnum, UINT nCount, BOOL bNeedFree = FALSE);

// Implementation
public:
	virtual ~CEnumArray();

protected:
	size_t m_nSizeElem;     // size of each item in the array
	CCmdTarget* m_pClonedFrom;  // used to keep original alive for clones

	BYTE* m_pvEnum;     // pointer data to enumerate
	UINT m_nCurPos;     // current position in m_pvEnum
	UINT m_nSize;       // total number of items in m_pvEnum
	BOOL m_bNeedFree;   // free on release?

	virtual BOOL OnNext(void* pv);
	virtual BOOL OnSkip();
	virtual void OnReset();
	virtual CEnumArray* OnClone();

// Interface Maps
public:
	BEGIN_INTERFACE_PART(EnumVOID, IEnumVOID)
		INIT_INTERFACE_PART(CEnumArray, EnumVOID)
		STDMETHOD(Next)(ULONG, void*, ULONG*);
		STDMETHOD(Skip)(ULONG);
		STDMETHOD(Reset)();
		STDMETHOD(Clone)(IEnumVOID**);
	END_INTERFACE_PART(EnumVOID)
};

/////////////////////////////////////////////////////////////////////////////
// COleDispatchImpl - IDispatch implementation

// Note: This class is only designed to be used as a CCmdTarget member
//  (at the offset specified by CCmdTarget::m_xDispatch))
// It WILL NOT work in other classes or at different offsets!

class COleDispatchImpl : public IDispatch
{
public:
#ifndef _AFX_NO_NESTED_DERIVATION
	// required for METHOD_PROLOGUE_EX
	size_t m_nOffset;
	COleDispatchImpl::COleDispatchImpl()
		{ m_nOffset = offsetof(CCmdTarget, m_xDispatch); }
#endif

	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();
	STDMETHOD(QueryInterface)(REFIID, LPVOID*);

	STDMETHOD(GetTypeInfoCount)(UINT*);
	STDMETHOD(GetTypeInfo)(UINT, LCID, LPTYPEINFO*);
	STDMETHOD(GetIDsOfNames)(REFIID, _In_count_(cNames) LPOLESTR*, UINT cNames, LCID, DISPID*);
	STDMETHOD(Invoke)(DISPID, REFIID, LCID, WORD, DISPPARAMS*, LPVARIANT,
		LPEXCEPINFO, UINT*);

	// special method for disconnect
	virtual void Disconnect();
};

/////////////////////////////////////////////////////////////////////////////
// OLE data (like AUX_DATA)

struct OLE_DATA
{
	// OLE 1.0 clipboard formats
	UINT    cfNative, cfOwnerLink, cfObjectLink;

	// OLE 2.0 clipboard formats
	UINT    cfEmbeddedObject, cfEmbedSource, cfLinkSource;
	UINT    cfObjectDescriptor, cfLinkSourceDescriptor;
	UINT    cfFileName, cfFileNameW;

	//RichEdit formats
	UINT    cfRichTextFormat;
	UINT    cfRichTextAndObjects;

	OLE_DATA();
};

extern OLE_DATA _oleData;

/////////////////////////////////////////////////////////////////////////////
// _AFX_OLE_STATE

#undef AFX_DATA
#define AFX_DATA

class _AFX_OLE_STATE : public CNoTrackObject
{
public:
	_AFX_OLE_STATE();
	virtual ~_AFX_OLE_STATE();

	CView* m_pActivateView;         // activation view
	COleDataSource* m_pClipboardSource;

	DWORD m_dwReserved;             // was "parking space" window
#ifdef _AFXDLL
	HINSTANCE m_hInstOLE;       // handle of OLE32.DLL
	HINSTANCE m_hInstOLEAUT;    // handle of OLEAUT32.DLL
	HINSTANCE m_hInstOLEDLG;    // handle of OLEDLG.DLL
	HINSTANCE m_hInstUrlMon;
#endif
	long m_nReserved;           // was reference count on parking window
};

EXTERN_PROCESS_LOCAL(_AFX_OLE_STATE, _afxOleState)

/////////////////////////////////////////////////////////////////////////////
// Global helper functions

// menu merging/unmerging
HMENU AFXAPI AfxMergeMenus(HMENU hMenuShared, HMENU hMenuSource,
	LONG* lpMenuWidths, int iWidthIndex, BOOL bMergeHelpMenus = FALSE);
void AFXAPI AfxUnmergeMenus(HMENU hMenuShared, HMENU hMenuSource,
	HMENU hHelpMenuPopup = NULL);

// helpers for IOleCommandTarget

HRESULT AFXAPI _AfxQueryStatusOleCommandHelper(CCmdTarget* pTarget,
	const GUID* pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[],
   OLECMDTEXT* pcmdtext);
HRESULT AFXAPI _AfxExecOleCommandHelper(CCmdTarget* pTarget,
   const GUID* pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt,
   VARIANTARG* pvarargIn, VARIANTARG* pvarargOut);

// helpers for exceptions
void AFXAPI _AfxFillOleFileException(CFileException*, SCODE sc);
void AFXAPI _AfxThrowOleFileException(SCODE sc);

// helper used during object creation
LPFORMATETC AFXAPI _AfxFillFormatEtc(LPFORMATETC lpFormatEtc,
	CLIPFORMAT cfFormat, LPFORMATETC lpFormatEtcFill);

// helper to copy clipboard data
BOOL AFXAPI _AfxCopyStgMedium(
	CLIPFORMAT cfFormat, LPSTGMEDIUM lpDest, LPSTGMEDIUM lpSource);

// helper for reliable and small Release calls
DWORD AFXAPI _AfxRelease(LPUNKNOWN* plpUnknown);
#ifndef _DEBUG
// generate smaller code in release build
#define RELEASE(lpUnk) _AfxRelease((LPUNKNOWN*)&lpUnk)
#else
// generate larger but typesafe code in debug build
#define RELEASE(lpUnk) do \
	{ if ((lpUnk) != NULL) { (lpUnk)->Release(); (lpUnk) = NULL; } } while (0)
#endif

// helper to ensure the release of any CLR references
void AFXAPI _AfxReleaseManagedRefs(LPUNKNOWN lpUnk);

// helpers from OLESTD.C (from original OLE2UI sample)
HGLOBAL AFXAPI _AfxOleGetObjectDescriptorData(CLSID clsid, DWORD dwDrawAspect,
	SIZEL sizel, POINTL pointl, DWORD dwStatus, LPCOLESTR lpszFullUserTypeName,
	LPCOLESTR lpszSrcOfCopy);
HGLOBAL AFXAPI _AfxOleGetObjectDescriptorData(LPOLEOBJECT lpOleObj,
	LPCOLESTR lpszSrcOfCopy, DWORD dwDrawAspect, POINTL pointl, LPSIZEL lpSizelHim);
SCODE AFXAPI _AfxOleDoConvert(LPSTORAGE lpStg, REFCLSID rClsidNew);
SCODE AFXAPI _AfxOleDoTreatAsClass(
	LPCTSTR lpszUserType, REFCLSID rclsid, REFCLSID rclsidNew);
DVTARGETDEVICE* AFXAPI _AfxOleCreateTargetDevice(LPPRINTDLG lpPrintDlg);
DVTARGETDEVICE* AFXAPI _AfxOleCreateTargetDevice(LPDEVNAMES pDN, LPDEVMODE pDM);
DWORD AFXAPI _AfxOleGetLenFilePrefixOfMoniker(LPMONIKER lpmk);
DVTARGETDEVICE* AFXAPI _AfxOleCopyTargetDevice(DVTARGETDEVICE* ptdSrc);
void AFXAPI _AfxOleCopyFormatEtc(LPFORMATETC petcDest, LPFORMATETC petcSrc);
HDC AFXAPI _AfxOleCreateDC(DVTARGETDEVICE* ptd);
void AFXAPI _AfxDeleteMetafilePict(HGLOBAL hMetaPict);
BOOL AFXAPI _AfxOlePropertiesEnabled();

// helper(s) for reliable and small QueryInterface calls
LPUNKNOWN AFXAPI _AfxQueryInterface(LPUNKNOWN lpUnknown, REFIID riid);
#define QUERYINTERFACE(lpUnknown, iface) \
	(iface*)_AfxQueryInterface(lpUnknown, IID_##iface)

// helpers for conversion between himetric and pixels
#define HIMETRIC_PER_INCH   2540
#define MAP_PIX_TO_LOGHIM(x,ppli)   MulDiv(HIMETRIC_PER_INCH, (x), (ppli))
#define MAP_LOGHIM_TO_PIX(x,ppli)   MulDiv((ppli), (x), HIMETRIC_PER_INCH)

// helper for GUID comparison
inline BOOL _AfxIsEqualGUID(REFGUID guid1, REFGUID guid2)
{
	return ((DWORD*)&guid1)[0] == ((DWORD*)&guid2)[0] &&
		((DWORD*)&guid1)[1] == ((DWORD*)&guid2)[1] &&
		((DWORD*)&guid1)[2] == ((DWORD*)&guid2)[2] &&
		((DWORD*)&guid1)[3] == ((DWORD*)&guid2)[3];
}

HRESULT AFXAPI _AfxReadFromStream(LPSTREAM pStream, void* lpBuf, UINT nCount, DWORD& nRead);

/////////////////////////////////////////////////////////////////////////////
// implementation types and constants

#define OLE_MAXITEMNAME (_countof("Embedding ")+_countof("4294967295")-_countof(""))

typedef LPVOID* LPLP;

#undef AFX_DATA
#define AFX_DATA

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\oleinit.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include <wchar.h>
#include "sal.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// OLE OLE_DATA init structure

OLE_DATA _oleData;

OLE_DATA::OLE_DATA()
{
	// OLE 1.0 Clipboard formats
	cfNative = ::RegisterClipboardFormat(_T("Native"));
	cfOwnerLink = ::RegisterClipboardFormat(_T("OwnerLink"));
	cfObjectLink = ::RegisterClipboardFormat(_T("ObjectLink"));

	// OLE 2.0 Clipboard formats
	cfEmbeddedObject = ::RegisterClipboardFormat(_T("Embedded Object"));
	cfEmbedSource = ::RegisterClipboardFormat(_T("Embed Source"));
	cfLinkSource = ::RegisterClipboardFormat(_T("Link Source"));
	cfObjectDescriptor = ::RegisterClipboardFormat(_T("Object Descriptor"));
	cfLinkSourceDescriptor = ::RegisterClipboardFormat(_T("Link Source Descriptor"));
	cfFileName = ::RegisterClipboardFormat(_T("FileName"));
	cfFileNameW = ::RegisterClipboardFormat(_T("FileNameW"));
	cfRichTextFormat = ::RegisterClipboardFormat(_T("Rich Text Format"));
	cfRichTextAndObjects = ::RegisterClipboardFormat(_T("RichEdit Text and Objects"));
}

/////////////////////////////////////////////////////////////////////////////
// OLE initialization & termination

BOOL AFXAPI AfxOleInit()
{
	_AFX_THREAD_STATE* pState = AfxGetThreadState();
	ASSERT(!pState->m_bNeedTerm);    // calling it twice?

	// Special case DLL context to assume that the calling app initializes OLE.
	// For DLLs where this is not the case, those DLLs will need to initialize
	// OLE for themselves via OleInitialize.  This is done since MFC cannot provide
	// automatic uninitialize for DLLs because it is not valid to shutdown OLE
	// during a DLL_PROCESS_DETACH.
	if (afxContextIsDLL)
	{
		pState->m_bNeedTerm = -1;  // -1 is a special flag
		return TRUE;
	}

	// first, initialize OLE
	SCODE sc = ::OleInitialize(NULL);
	if (FAILED(sc))
	{
		// warn about non-NULL success codes
#ifdef _DEBUG
		TRACE(traceOle, 0, _T("Warning: OleInitialize returned scode = %s.\n"),
			AfxGetFullScodeString(sc));
#endif
		goto InitFailed;
	}
	// termination required when OleInitialize does not fail
	pState->m_bNeedTerm = TRUE;

	// hook idle time and exit time for required OLE cleanup
	CWinThread* pThread; pThread = AfxGetThread();
	ASSERT(pThread);
	pThread->m_lpfnOleTermOrFreeLib = AfxOleTermOrFreeLib;

	// allocate and initialize default message filter
	if (pThread->m_pMessageFilter == NULL)
	{
		pThread->m_pMessageFilter = new COleMessageFilter;
		ASSERT(AfxOleGetMessageFilter() != NULL);
		AfxOleGetMessageFilter()->Register();
	}
	return TRUE;

InitFailed:
	AfxOleTerm();
	return FALSE;
}

void AFXAPI AfxOleTerm(BOOL bJustRevoke)
{
	// release clipboard ownership
	COleDataSource::FlushClipboard();

	// revoke all class factories
	COleObjectFactory::RevokeAll();

#ifndef _AFX_NO_OCC_SUPPORT
	AfxOleUnlockAllControls();
#endif

	if (!bJustRevoke)
	{
		CWinThread* pThread = AfxGetThread();
		if (pThread != NULL)
		{
			// destroy message filter (may be derived class)
			delete pThread->m_pMessageFilter;
			pThread->m_pMessageFilter = NULL;
		}

		// terminate OLE last
		_AFX_THREAD_STATE* pState = AfxGetThreadState();
		// -1 is special case, so need to compare against TRUE
		if (pState->m_bNeedTerm == TRUE)
		{
			CoFreeUnusedLibraries();
			::OleUninitialize();
			pState->m_bNeedTerm = FALSE;
		}
	}
}

AFX_STATIC_DATA DWORD _afxTickCount = (DWORD)-1;
AFX_STATIC_DATA BOOL _afxTickInit = FALSE;

void AFXAPI AfxOleTermOrFreeLib(BOOL bTerm, BOOL bJustRevoke)
{
	if (bTerm)
	{
		AfxOleTerm(bJustRevoke);
	}
	else
	{
		// initialize _afxTickCount if necessary
		if (!_afxTickInit)
		{
			_afxTickCount = ::GetTickCount();
			++_afxTickInit;
		}

		// only call CoFreeUnusedLibraries if one minute has gone by
		if (GetTickCount() - _afxTickCount > 60000)
		{
			CoFreeUnusedLibraries();
			_afxTickCount = ::GetTickCount();
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CWinApp support for parsing OLE command line

AFX_STATIC BOOL AFXAPI _AfxParseOption(_Inout_ LPTSTR lpszCmdLine, LPCTSTR lpszOption)
{
	int nLen = lstrlen(lpszOption);
	while (*lpszCmdLine != 0)
	{
		if ((*lpszCmdLine == '-' || *lpszCmdLine == '/') &&
			_tcsncmp(lpszOption, lpszCmdLine+1, nLen) == 0)
		{
			// remove the option from the command line
			int nCmdLen = lstrlen(lpszCmdLine);
			Checked::memmove_s(lpszCmdLine, nCmdLen * sizeof(TCHAR), 
				lpszCmdLine + nLen + 1, (nCmdLen - nLen) * sizeof(TCHAR));
			return TRUE;
		}
		lpszCmdLine++;
	}
	return FALSE;
}

BOOL CWinApp::RunEmbedded()
{
	ASSERT(m_lpCmdLine != NULL);

	// hard coded non-localized name
	if (_AfxParseOption(m_lpCmdLine, _T("Embedding")))
	{
		AfxOleSetUserCtrl(FALSE);
		return TRUE;
	}
	return FALSE;   // not run with /Embedding
}

BOOL CWinApp::RunAutomated()
{
	ASSERT(m_lpCmdLine != NULL);

	// hard coded non-localized name
	if (_AfxParseOption(m_lpCmdLine, _T("Automation")))
	{
		AfxOleSetUserCtrl(FALSE);
		return TRUE;
	}
	return FALSE;   // not run with /Automation
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\olemon.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

#pragma inline_depth(0)

/////////////////////////////////////////////////////////////////////////////
// _AfxBindHost for CMonikerFile implementation

class _AfxBindHost: public IBindHost
{
private:
	long m_dwRef;
public:
	inline _AfxBindHost() : m_dwRef(0) {}

	inline ~_AfxBindHost() { ASSERT(m_dwRef == 0); }

	STDMETHOD_(ULONG, AddRef)()
	{
		return InterlockedIncrement(&m_dwRef);
	}

	STDMETHOD_(ULONG, Release)()
	{
		unsigned long lResult = InterlockedDecrement(&m_dwRef);
		if (lResult == 0)
			delete this;
		return lResult;
	}

	STDMETHOD(QueryInterface)(REFIID iid, void** ppvObject)
	{
		if (!ppvObject)
			return E_POINTER;

		// check for the interfaces this object knows about
		if (iid == IID_IUnknown || iid == IID_IBindHost)
		{
			*ppvObject = (IBindHost*)this;
			InterlockedIncrement(&m_dwRef);
			return S_OK;
		}

		// otherwise, incorrect IID, and thus error
		return E_NOINTERFACE;
	}

	STDMETHOD(CreateMoniker)(
	/* [in] */ LPOLESTR szName,
	/* [in] */ IBindCtx __RPC_FAR *pBC,
	/* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmk,
	/* [in] */ DWORD dwReserved)
	{
		UNUSED_ALWAYS(dwReserved);
		UNUSED_ALWAYS(pBC);

		if (!szName || !ppmk) return E_POINTER;
		if (!*szName) return E_INVALIDARG;

		*ppmk = NULL;
		HRESULT hr = S_OK;

		hr = CreateURLMoniker(NULL, szName, ppmk);
		if (SUCCEEDED(hr) && !*ppmk)
			hr = E_FAIL;
		return hr;
	}

	STDMETHOD(MonikerBindToStorage)(
	/* [in] */ IMoniker __RPC_FAR *pMk,
	/* [in] */ IBindCtx __RPC_FAR *pBC,
	/* [in] */ IBindStatusCallback __RPC_FAR *pBSC,
	/* [in] */ REFIID riid,
	/* [out] */ void __RPC_FAR *__RPC_FAR *ppvObj)
	{
		if (!pMk || !ppvObj) return E_POINTER;

		*ppvObj = NULL;
		HRESULT hr = S_OK;
		IPTR(IBindCtx) BindCtx;
		if (pBC)
		{
			BindCtx = pBC;
			if (pBSC)
			{
#ifdef _DEBUG
				IPTR(IBindStatusCallback) pBSCPrev;
#endif
				hr = RegisterBindStatusCallback(BindCtx, pBSC,
#ifdef _DEBUG
					&pBSCPrev,
#else
					NULL,
#endif
					0);
				ASSERT(!pBSCPrev);
				if (FAILED(hr))
					return hr;
			}
		}
		else
		{
			if (pBSC)
				hr = CreateAsyncBindCtx(0, pBSC, NULL, &BindCtx);
			else
				hr = CreateBindCtx(0, &BindCtx);
			if (SUCCEEDED(hr) && !BindCtx)
				hr = E_FAIL;
			if (FAILED(hr))
				return hr;
		}
		return pMk->BindToStorage(BindCtx, NULL, riid, ppvObj);
	}

private:
	STDMETHOD(MonikerBindToObject)(
	/* [in] */ IMoniker __RPC_FAR *pMk,
	/* [in] */ IBindCtx __RPC_FAR *pBC,
	/* [in] */ IBindStatusCallback __RPC_FAR *pBSC,
	/* [in] */ REFIID riid,
	/* [out] */ void __RPC_FAR *__RPC_FAR *ppvObj)
	{
		ASSERT(FALSE);
		UNUSED_ALWAYS(pMk);
		UNUSED_ALWAYS(pBC);
		UNUSED_ALWAYS(pBSC);
		UNUSED_ALWAYS(riid);
		UNUSED_ALWAYS(ppvObj);
		return E_NOTIMPL;
	}
};

/////////////////////////////////////////////////////////////////////////////
// CMonikerFile implementation

CMonikerFile::~CMonikerFile()
{
	AFX_BEGIN_DESTRUCTOR

	ASSERT_VALID(this);
	Close();

	AFX_END_DESTRUCTOR
}

void CMonikerFile::Flush()
{
	ASSERT_VALID(this);
	ENSURE(GetStream() != NULL);

	GetStream()->Commit(0);
}

BOOL CMonikerFile::Open(LPCTSTR lpszUrl, IBindHost* pBindHost,
	IBindStatusCallback* pBSC, IBindCtx* pBindCtx, CFileException* pError)
{
	ASSERT_VALID(this);
	Close(); // These objects are reopenable
	return Attach(lpszUrl, pBindHost, pBSC, pBindCtx, pError);
}

BOOL CMonikerFile::Attach(LPCTSTR lpszUrl, IBindHost* pBindHost,
	IBindStatusCallback* pBSC, IBindCtx* pBindCtx, CFileException* pError)
{
	ASSERT(!m_Moniker);
	ASSERT(!GetStream());
	USES_CONVERSION_EX;

	ASSERT(NULL == lpszUrl || AfxIsValidString(lpszUrl));
	ASSERT(NULL == pError ||
		AfxIsValidAddress(pError, sizeof(CFileException)));
	ASSERT(NULL != pBindHost);

	if (pBindHost == NULL)
	{
		// Throwing exception here instead of returning FALSE because we cannot
		// fill pError here. So we need to indicate to the caller that 
		// something really bad has happened. Previously the code would AV.
		AfxThrowInvalidArgException();	
	}

	// Check for empty path
	if (!lpszUrl || !*lpszUrl)
	{
		if (pError)
		{
			pError->m_cause = CFileException::badPath;
			pError->m_strFileName = lpszUrl;
		}
		return FALSE;
	}

	// Create the moniker
	HRESULT hr;
	IPTR(IMoniker) pMoniker;

	LPOLESTR lpoleszUrl = T2OLE_EX((LPTSTR) lpszUrl, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
	if (lpoleszUrl == NULL)
	{
		// OUT OF MEMORY
		if (pError)
		{
			pError->m_cause = CFileException::none; // Because there is no error code for out of memory here and its not something wrong with the file
			pError->m_strFileName = lpszUrl;
		}
	}
	
	hr = pBindHost->CreateMoniker(lpoleszUrl, pBindCtx,
		reinterpret_cast<IMoniker**>(&pMoniker), 0);

	if (FAILED(hr))
	{
		if (pError) _AfxFillOleFileException(pError, hr);
		return FALSE;
	}

	return Attach(pMoniker, pBindHost, pBSC, pBindCtx, pError);
}

BOOL CMonikerFile::Open(LPCTSTR lpszUrl, CFileException* pError)
{
	IPTR(IBindHost) pBindHost(CreateBindHost(), FALSE);
	IPTR(IBindCtx) pBindCtx(CreateBindContext(pError), FALSE);

	return Open(lpszUrl, pBindHost, NULL, pBindCtx, pError);
}

BOOL CMonikerFile::Open(IMoniker* pMoniker, CFileException* pError)
{
	Close(); // These objects are reopenable
	IPTR(IBindHost) pBindHost(CreateBindHost(), FALSE);
	IPTR(IBindCtx) pBindCtx(CreateBindContext(pError), FALSE);

	return Attach(pMoniker, pBindHost, NULL, pBindCtx, pError);
}

BOOL CMonikerFile::Open(IMoniker* pMoniker, IBindHost* pBindHost,
	IBindStatusCallback* pBSC, IBindCtx* pBindCtx, CFileException* pError)
{
	Close();
	return Attach(pMoniker, pBindHost, pBSC, pBindCtx, pError);
}

BOOL CMonikerFile::Attach(IMoniker* pMoniker, IBindHost* pBindHost,
	IBindStatusCallback* pBSC, IBindCtx* pBindCtx, CFileException* pError)
{
	ASSERT_VALID(this);
	ASSERT(pMoniker);
	ASSERT(!m_Moniker);
	ASSERT(!GetStream());
	m_Moniker=pMoniker;

	IPTR(IStream) pStream;
	if (pBindHost == NULL)
	{
		// Throwing exception here instead of returning FALSE because we cannot
		// fill pError here. So we need to indicate to the caller that 
		// something really bad has happened. Previously the code would AV.
		AfxThrowInvalidArgException();
	}
	HRESULT hr=pBindHost->MonikerBindToStorage(pMoniker, pBindCtx, pBSC,
		IID_IStream, reinterpret_cast<void**>(&pStream));
	if (FAILED(hr))
	{
		if (pError) _AfxFillOleFileException(pError, hr);
		return FALSE;
	}

	// If this is really a CAsyncMonikerFile, then we may have attached to the stream
	// within MonikerBindToStorage, in which case we want to avoid doing so here.
	if (pStream.GetInterfacePtr() && !GetStream())
	{
		// Attach this to the stream, transferring the reference
		// COleStreamFile::Attach doesn't increment pStream's refcount
		COleStreamFile::Attach(pStream);
		pStream.Detach();
	}

	return PostBindToStream(pError);
}

void CMonikerFile::Close()
{
	if (m_Moniker.GetInterfacePtr())
		m_Moniker.Release();
	COleStreamFile::Close();
}

BOOL CMonikerFile::Detach(CFileException* pError)
{
	ASSERT_VALID(this);
	ASSERT(!!m_Moniker);

	TRY
	{
		Close();
	}
	CATCH (CFileException, e)
	{
		if (pError)
		{
			pError->m_cause=e->m_cause;
			pError->m_lOsError=e->m_lOsError;
			pError->m_strFileName=e->m_strFileName;
		}
		DELETE_EXCEPTION(e);
		return FALSE;
	}
	END_CATCH;

	return TRUE;
}

IBindHost* CMonikerFile::CreateBindHost()
{
	IBindHost* pBindHost = new _AfxBindHost();
	pBindHost->AddRef();
	return pBindHost;
}

IBindCtx* CMonikerFile::CreateBindContext(CFileException* pError)
{
	UNUSED_ALWAYS(pError);
	return NULL;
}

// So that CMonikerFile can check for a null pStream and CAsyncMonikerFile can ignore it
BOOL CMonikerFile::PostBindToStream(CFileException* pError)
{
	if (!GetStream())
	{
		if (pError) _AfxFillOleFileException(pError, E_UNEXPECTED);
		TRY
		{
			Close();
		}
		CATCH_ALL(e)
		{
			DELETE_EXCEPTION(e);
		}
		END_CATCH_ALL
		return FALSE;
	}
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CMonikerFile diagnostics

#ifdef _DEBUG
void CMonikerFile::AssertValid() const
{
	COleStreamFile::AssertValid();
}

void CMonikerFile::Dump(CDumpContext& dc) const
{
	COleStreamFile::Dump(dc);

	dc << "\nm_Moniker = " << m_Moniker.GetInterfacePtr();
	dc << "\n";
}
#endif

////////////////////////////////////////////////////////////////////////////

#ifndef _AFX_ENABLE_INLINES

// expand inlines for OLE general APIs
#define _AFXOLEMONIKER_INLINE
#include "afxole.inl"

#endif //!_AFX_ENABLE_INLINES


IMPLEMENT_DYNAMIC(CMonikerFile, COleStreamFile)

////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\olemsgf.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// COleMessageFilter::IMessageFilter implementation


COleMessageFilter::COleMessageFilter()
{
	// begin in not-busy state
	m_nBusyCount = 0;

	// dialogs are enabled by default
	m_bEnableBusy = TRUE;
	m_bEnableNotResponding = TRUE;

	m_nBusyReply = SERVERCALL_RETRYLATER;
		// effective only when m_nBusyCount != 0

	m_nRetryReply = 10000;  // default is 10 sec
	m_nTimeout = 8000;  // default is 8 sec

	m_bUnblocking = FALSE;
		// TRUE to avoid re-entrancy when busy dialog is up

	m_bRegistered = FALSE;

	ASSERT_VALID(this);
}


COleMessageFilter::~COleMessageFilter()
{
	ASSERT_VALID(this);

	Revoke();
}

/////////////////////////////////////////////////////////////////////////////
// Busy state management


void COleMessageFilter::BeginBusyState()
{
	ASSERT_VALID(this);
	++m_nBusyCount;
}

void COleMessageFilter::EndBusyState()
{
	ASSERT_VALID(this);
	if (m_nBusyCount != 0)
		--m_nBusyCount;
}

/////////////////////////////////////////////////////////////////////////////
// COleMessageFilter operations


BOOL COleMessageFilter::Register()
{
	ASSERT_VALID(this);
	ASSERT(!m_bRegistered); // calling Register twice?

	if (::CoRegisterMessageFilter(&m_xMessageFilter, NULL) == S_OK)
	{
		m_bRegistered = TRUE;
		return TRUE;
	}
	return FALSE;
}


void COleMessageFilter::Revoke()
{
	ASSERT_VALID(this);

	if (m_bRegistered)
	{
		::CoRegisterMessageFilter(NULL, NULL);
		m_bRegistered = FALSE;
	}
}

/////////////////////////////////////////////////////////////////////////////
// COleMessageFilter standard implementation of callbacks


BOOL COleMessageFilter::OnMessagePending(const MSG* /*pMsg*/)
{
	// By default we rely on OLE's default message handling for every message
	//  except WM_PAINT messages.  WM_PAINT messages should not generate
	//  out-going calls.

	BOOL bEatMessage = FALSE;
	MSG msg;
	while (::PeekMessage(&msg, NULL, WM_PAINT, WM_PAINT, PM_REMOVE|PM_NOYIELD))
	{
		bEatMessage = TRUE;
		DispatchMessage(&msg);
	}
	return bEatMessage;
}

AFX_STATIC_DATA const UINT _afxSignificantMsgs[] =
{
	WM_KEYDOWN, WM_SYSKEYDOWN,  WM_TIMER,
	WM_LBUTTONDOWN, WM_RBUTTONDOWN, WM_MBUTTONDOWN,
	WM_NCLBUTTONDOWN, WM_NCRBUTTONDOWN, WM_NCMBUTTONDOWN,
	WM_LBUTTONDBLCLK, WM_RBUTTONDBLCLK, WM_MBUTTONDBLCLK,
	WM_NCLBUTTONDBLCLK, WM_NCRBUTTONDBLCLK, WM_NCMBUTTONDBLCLK
};

BOOL COleMessageFilter::IsSignificantMessage(MSG*)
{
	// check for "significant" messages in the queue
	MSG msg;
	for (int i = 0; i < _countof(_afxSignificantMsgs); i++)
	{
		if (::PeekMessage(&msg, NULL, _afxSignificantMsgs[i], _afxSignificantMsgs[i],
			PM_NOREMOVE|PM_NOYIELD))
		{
			if ((msg.message == WM_KEYDOWN || msg.message == WM_SYSKEYDOWN) &&
				(HIWORD(msg.lParam) & KF_REPEAT))
			{
				// a key-repeat is a non-significant message
				continue;
			}

			// "significant" message is waiting in the queue
			return TRUE;
		}
	}

	// no significant messages in the queue
	return FALSE;
}

int COleMessageFilter::OnBusyDialog(HTASK htaskBusy)
{
	COleBusyDialog dlg(htaskBusy, FALSE);

	int nResult = -1;
	TRY
	{
		if (dlg.DoModal() == IDOK)
			nResult = dlg.GetSelectionType();
	}
	END_TRY

	return nResult;
}

int COleMessageFilter::OnNotRespondingDialog(HTASK htaskBusy)
{
	COleBusyDialog dlg(htaskBusy, TRUE);

	int nResult = -1;
	TRY
	{
		if (dlg.DoModal() == IDOK)
			nResult = dlg.GetSelectionType();
	}
	END_TRY

	return nResult;
}

/////////////////////////////////////////////////////////////////////////////
// COleMessageFilter OLE interface implementation

BEGIN_INTERFACE_MAP(COleMessageFilter, CCmdTarget)
	INTERFACE_PART(COleMessageFilter, IID_IMessageFilter, MessageFilter)
END_INTERFACE_MAP()

STDMETHODIMP_(ULONG) COleMessageFilter::XMessageFilter::AddRef()
{
	METHOD_PROLOGUE_EX_(COleMessageFilter, MessageFilter)
	return pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) COleMessageFilter::XMessageFilter::Release()
{
	METHOD_PROLOGUE_EX_(COleMessageFilter, MessageFilter)
	return pThis->ExternalRelease();
}

STDMETHODIMP COleMessageFilter::XMessageFilter::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(COleMessageFilter, MessageFilter)
	return pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP_(DWORD) COleMessageFilter::XMessageFilter::HandleInComingCall(
	DWORD dwCallType, HTASK /*htaskCaller*/,
	DWORD /*dwTickCount*/, LPINTERFACEINFO /*lpInterfaceInfo*/)
{
	METHOD_PROLOGUE_EX_(COleMessageFilter, MessageFilter)

	// check for application busy first...
	if (pThis->m_nBusyCount == 0)
	{
		if (dwCallType == CALLTYPE_TOPLEVEL ||
			dwCallType == CALLTYPE_TOPLEVEL_CALLPENDING)
		{
			// make sure CWinThread::OnIdle has a chance to run later
			MSG msg;
			if (!::PeekMessage(&msg, NULL, WM_KICKIDLE, WM_KICKIDLE, PM_NOREMOVE))
				::PostThreadMessage(GetCurrentThreadId(), WM_KICKIDLE, 0, 0);
		}
		return SERVERCALL_ISHANDLED;
	}

	if (dwCallType == CALLTYPE_TOPLEVEL ||
		dwCallType == CALLTYPE_TOPLEVEL_CALLPENDING)
	{
		// application is busy and we have rejectable CALLTYPE
		return pThis->m_nBusyReply;
	}

	// application is busy, but CALLTYPE indicates that it *must* be handled
	return SERVERCALL_ISHANDLED;
}

STDMETHODIMP_(DWORD) COleMessageFilter::XMessageFilter::RetryRejectedCall(
	HTASK htaskCallee, DWORD dwTickCount, DWORD dwRejectType)
{
	METHOD_PROLOGUE_EX(COleMessageFilter, MessageFilter)
	ASSERT_VALID(pThis);

	// rejected calls get cancelled regardless of timeout
	if (dwRejectType == SERVERCALL_REJECTED)
		return (DWORD)-1;

	// if insignificant time has passed, don't panic -- just retry
	if (dwTickCount <= pThis->m_nRetryReply)
		return 0;   // retry right away (0-100 are retry immediate)

	// too much time has passed, do something more drastic
	if (pThis->m_bEnableBusy)
	{
		// show busy dialog
		int selType = pThis->OnBusyDialog(htaskCallee);

		// take action depending on selection
		switch (selType)
		{
		case -1:
			return (DWORD)-1;   // cancel outgoing call

		case COleBusyDialog::retry:
			return 0;           // retry immediately
		}
	}
	return pThis->m_nRetryReply;    // use standard retry timeout
}

STDMETHODIMP_(DWORD) COleMessageFilter::XMessageFilter::MessagePending(
	HTASK htaskCallee, DWORD dwTickCount, DWORD /*dwPendingType*/)
{
	METHOD_PROLOGUE_EX(COleMessageFilter, MessageFilter)
	ASSERT_VALID(pThis);

	MSG msg;
	if (dwTickCount > pThis->m_nTimeout && !pThis->m_bUnblocking &&
		pThis->IsSignificantMessage(&msg))
	{
		if (pThis->m_bEnableNotResponding)
		{
			pThis->m_bUnblocking = TRUE;    // avoid reentrant calls

			// eat all mouse messages in our queue
			while (PeekMessage(&msg, NULL, WM_MOUSEFIRST, AFX_WM_MOUSELAST,
				PM_REMOVE|PM_NOYIELD))
				;
			// eat all keyboard messages in our queue
			while (PeekMessage(&msg, NULL, WM_KEYFIRST, WM_KEYLAST,
				PM_REMOVE|PM_NOYIELD))
				;

			// show not responding dialog
			pThis->OnNotRespondingDialog(htaskCallee);
			pThis->m_bUnblocking = FALSE;

			return PENDINGMSG_WAITNOPROCESS;
		}
	}

	// don't process re-entrant messages
	if (pThis->m_bUnblocking)
		return PENDINGMSG_WAITDEFPROCESS;

	// allow application to process pending message
	if (::PeekMessage(&msg, NULL, NULL, NULL, PM_NOREMOVE|PM_NOYIELD))
		pThis->OnMessagePending(&msg);

	// by default we return pending MSG wait
	return PENDINGMSG_WAITNOPROCESS;
}

/////////////////////////////////////////////////////////////////////////////
// COleMessageFilter diagnostics

#ifdef _DEBUG
void COleMessageFilter::AssertValid() const
{
	CCmdTarget::AssertValid();
}

void COleMessageFilter::Dump(CDumpContext& dc) const
{
	CCmdTarget::Dump(dc);

	dc << "m_bRegistered = " << m_bRegistered;
	dc << "\nm_nBusyCount = " << m_nBusyCount;
	dc << "\nm_bEnableBusy = " << m_bEnableBusy;
	dc << "\nm_bEnableNotResponding = " << m_bEnableNotResponding;
	dc << "\nm_bUnblocking = " << m_bUnblocking;
	dc << "\nm_nRetryReply = " << m_nRetryReply;
	dc << "\nm_nBusyReply = " << m_nBusyReply;
	dc << "\nm_nTimeout = " << m_nTimeout;

	dc << "\n";
}
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\olesvr2.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

//////////////////////////////////////////////////////////////////////////////
// COleServerItem implementation

COleServerItem::COleServerItem(COleServerDoc* pServerDoc, BOOL bAutoDelete)
{
	if (pServerDoc != NULL)
		ASSERT_VALID(pServerDoc);

	m_dwRef = 0;    // always start in disconnected state
	m_bAutoDelete = bAutoDelete;
	m_bNeedUnlock = FALSE;

	// initially, item does not have an extent
	m_sizeExtent.cx = 0;
	m_sizeExtent.cy = 0;

	// initialize advise holders
	m_lpOleAdviseHolder = NULL;
	m_lpDataAdviseHolder = NULL;

	// add presentation formats to the data source
	m_dataSource.m_nGrowBy = 1;
	FORMATETC formatEtc;
	formatEtc.ptd = NULL;
	formatEtc.dwAspect = DVASPECT_CONTENT;
	formatEtc.lindex = -1;

	// by default, a COleServerItem supports CF_METAFILEPICT
	formatEtc.cfFormat = CF_METAFILEPICT;
	formatEtc.tymed = TYMED_MFPICT;
	m_dataSource.DelayRenderData(0, &formatEtc);

	// add item to server document
	m_pDocument = NULL;
	if (pServerDoc != NULL)
		pServerDoc->AddItem(this);
	ASSERT(m_pDocument == pServerDoc);

	AfxOleLockApp();
}

COleServerItem::~COleServerItem()
{
	m_bAutoDelete = FALSE;  // no delete during destructor

	// release any advise holders
	RELEASE(m_lpOleAdviseHolder);
	RELEASE(m_lpDataAdviseHolder);

	ExternalDisconnect();

	// disconnect from the document
	COleServerDoc* pDoc = GetDocument();
	if (pDoc != NULL)
	{
		// remove external lock from it
		if (m_bNeedUnlock)
		{
			pDoc->LockExternal(FALSE, TRUE);
			m_bNeedUnlock = FALSE;
		}

		// reset m_pEmbeddedItem if destroying embedded item
		if (pDoc->m_pEmbeddedItem == this)
			pDoc->m_pEmbeddedItem = NULL;

		// remove from list
		pDoc->RemoveItem(this);
	}

	// cleanup any references
	AfxOleUnlockApp();
}

BOOL COleServerItem::IsBlank() const
{
	// server items are blank in order to keep them from serializing when
	//  COleDocument::Serialize is called.

	return TRUE;
}

BOOL COleServerItem::IsConnected() const
{
	// if item is connected in any way, return TRUE
	if (m_dwRef != 0)
		return TRUE;

	// otherwise check if embedded item and document is connected
	if (!IsLinkedItem() && GetDocument()->m_lpClientSite != NULL)
		return TRUE;

	return FALSE;   // not connected
}

void COleServerItem::NotifyClient(OLE_NOTIFICATION nCode, DWORD_PTR dwParam)
{
	switch (nCode)
	{
	// IDataObject notifications
	case OLE_CHANGED:
		if (m_lpDataAdviseHolder != NULL)
			m_lpDataAdviseHolder->SendOnDataChange(GetDataObject(), (DWORD)dwParam, 0);
		break;

	// IOleObject notifications
	case OLE_SAVED:
		if (m_lpOleAdviseHolder != NULL)
			m_lpOleAdviseHolder->SendOnSave();
		break;
	case OLE_CLOSED:
		if (m_lpOleAdviseHolder != NULL)
			m_lpOleAdviseHolder->SendOnClose();
		break;
	case OLE_RENAMED:
		if (m_lpOleAdviseHolder != NULL)
		{
			// Note: the moniker should already be updated for this to work
			LPMONIKER lpMoniker = (LPMONIKER)dwParam;
			m_lpOleAdviseHolder->SendOnRename(lpMoniker);
		}
		break;

	default:
		ASSERT(FALSE);
	}
}

/////////////////////////////////////////////////////////////////////////////
// Helpers for getting commonly used interfaces through interface map

LPDATAOBJECT COleServerItem::GetDataObject()
{
	LPDATAOBJECT lpDataObject =
		(LPDATAOBJECT)GetInterface(&IID_IDataObject);
	ASSERT(lpDataObject != NULL);
	return lpDataObject;
}

LPOLEOBJECT COleServerItem::GetOleObject()
{
	LPOLEOBJECT lpOleObject =
		(LPOLEOBJECT)GetInterface(&IID_IOleObject);
	ASSERT(lpOleObject != NULL);
	return lpOleObject;
}

/////////////////////////////////////////////////////////////////////////////
// COleServerItem overrides

BOOL COleServerItem::OnQueryUpdateItems()
{
	COleDocument* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	// update all of the embedded objects
	POSITION pos = pDoc->GetStartPosition();
	COleClientItem* pItem;
	while ((pItem = pDoc->GetNextClientItem(pos)) != NULL)
	{
		// if any item is out-of-date, then this item is out-of-date
		if (pItem->m_lpObject->IsUpToDate() != NULL)
			return TRUE;    // update needed
	}
	return FALSE;   // update not needed
}

void COleServerItem::OnUpdateItems()
{
	COleDocument* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	// update all of the embedded objects
	POSITION pos = pDoc->GetStartPosition();
	COleClientItem* pItem;
	while ((pItem = pDoc->GetNextClientItem(pos)) != NULL)
	{
		// update any out-of-date item
		if (pItem->m_lpObject->IsUpToDate() != NULL)
			pItem->m_lpObject->Update();
	}
}

BOOL COleServerItem::OnSetExtent(DVASPECT dwDrawAspect, const CSize& size)
{
	ASSERT_VALID(this);

	if (dwDrawAspect == DVASPECT_CONTENT)
	{
		m_sizeExtent = size;    // simply remember the extent
		return TRUE;
	}
	return FALSE;   // not implemented for that dwDrawAspect
}

BOOL COleServerItem::OnGetExtent(DVASPECT /*dwDrawAspect*/, CSize& rSize)
{
	ASSERT_VALID(this);
	ASSERT(AfxIsValidAddress(&rSize, sizeof(CSize)));

	// the default implementation doesn't know what the extent is

	rSize.cx = 0;
	rSize.cy = 0;

	return FALSE;
}

void COleServerItem::OnDoVerb(LONG iVerb)
{
	switch (iVerb)
	{
	// open - maps to OnOpen
	case OLEIVERB_OPEN:
	case -OLEIVERB_OPEN-1:  // allows positive OLEIVERB_OPEN-1 in registry
		OnOpen();
		break;

	// primary, show, and unknown map to OnShow
	case OLEIVERB_PRIMARY:  // OLEIVERB_PRIMARY is 0 and "Edit" in registry
	case OLEIVERB_SHOW:
		OnShow();
		break;

	// hide maps to OnHide
	case OLEIVERB_HIDE:
	case -OLEIVERB_HIDE-1:  // allows positive OLEIVERB_HIDE-1 in registry
		OnHide();
		break;

	default:
		// negative verbs not understood should return E_NOTIMPL
		if (iVerb < 0)
			AfxThrowOleException(E_NOTIMPL);

		// positive verb not processed --
		//  according to OLE spec, primary verb should be executed
		//  instead.
		OnDoVerb(OLEIVERB_PRIMARY);

		// also, OLEOBJ_S_INVALIDVERB should be returned.
		AfxThrowOleException(OLEOBJ_S_INVALIDVERB);
	}
}

BOOL COleServerItem::OnDrawEx(CDC* pDC, DVASPECT nDrawAspect, CSize& rSize)
{
	ASSERT_VALID(pDC);
	ASSERT(AfxIsValidAddress(&rSize, sizeof(CSize)));

	if (nDrawAspect != DVASPECT_CONTENT)
		return FALSE;

	return OnDraw(pDC, rSize);
}

void COleServerItem::OnShow()
{
	ASSERT_VALID(this);

	// attempt in place activation (if not supported, fall back on "Open")
	COleServerDoc* pDoc = GetDocument();
	if (!pDoc->ActivateInPlace())
	{
		// by default OnShow() maps to OnOpen() if in-place activation
		//  not supported
		OnOpen();
	}
}

void COleServerItem::OnOpen()
{
	ASSERT_VALID(this);

	// default implementation shows the document
	COleServerDoc* pDoc = GetDocument();
	ASSERT(pDoc != NULL);
	pDoc->OnShowDocument(TRUE);
}

void COleServerItem::OnHide()
{
	ASSERT_VALID(this);

	// default implementation hides the document
	COleServerDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);
	pDoc->OnShowDocument(FALSE);
}

BOOL COleServerItem::GetMetafileData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium)
{
	ASSERT_VALID(this);
	ASSERT(AfxIsValidAddress(lpFormatEtc, sizeof(FORMATETC), FALSE));
	ASSERT(AfxIsValidAddress(lpStgMedium, sizeof(STGMEDIUM)));
	ASSERT(lpStgMedium->tymed == TYMED_NULL);   // GetDataHere not valid
	ASSERT(lpStgMedium->pUnkForRelease == NULL);

	// medium must be TYMED_MFPICT -- cannot fill in existing HGLOBAL
	if (!(lpFormatEtc->tymed & TYMED_MFPICT) || lpStgMedium->hGlobal != NULL)
		return FALSE;

	// create appropriate memory metafile DC
	CMetaFileDC dc;
	if (!dc.Create())
		return FALSE;

	// create attribute DC according to lpFormatEtc->ptd
	HDC hAttribDC = _AfxOleCreateDC(lpFormatEtc->ptd);
	if (hAttribDC == NULL)
		return FALSE;
	dc.SetAttribDC(hAttribDC);

	// Paint directly into the metafile.
	CSize size(0, 0);
	BOOL bResult = OnDrawEx(&dc, (DVASPECT)lpFormatEtc->dwAspect, size);

	// attribute DC is no longer necessary
	dc.SetAttribDC(NULL);
	::DeleteDC(hAttribDC);

	if (!bResult)
	{
		TRACE(traceOle, 1, "calling COleServerItem::OnDrawEx()failed.\n");
		return FALSE;
	}

	HMETAFILE hMF = dc.Close();
	if (hMF == NULL)
		return FALSE;

	HGLOBAL hPict;
	if ((hPict =
		::GlobalAlloc(GMEM_SHARE|GMEM_MOVEABLE, sizeof(METAFILEPICT))) == NULL)
	{
		DeleteMetaFile(hMF);
		return FALSE;
	}
	LPMETAFILEPICT lpPict;
	if ((lpPict = (LPMETAFILEPICT)::GlobalLock(hPict)) == NULL)
	{
		DeleteMetaFile(hMF);
		::GlobalFree(hPict);
		return FALSE;
	}

	// set the metafile size
	lpPict->mm = MM_ANISOTROPIC;
	lpPict->hMF = hMF;
	if (size.cx == 0 && size.cy == 0 &&
		!OnGetExtent((DVASPECT)lpFormatEtc->dwAspect, size))
	{
		TRACE(traceOle, 0, "Warning: OnGetExtent failed during OnDrawEx --\n");
		TRACE(traceOle, 0, "\tpresentation metafile may be badly formed!\n");
	}
	lpPict->xExt = size.cx;
	lpPict->yExt = size.cy;  // HIMETRIC height
	if (lpPict->yExt < 0)
	{
		TRACE(traceOle, 0, "Warning: HIMETRIC natural size is negative.\n");
		lpPict->yExt = -lpPict->yExt;   // backward compatibility fix
	}

#ifdef _DEBUG
	if (lpPict->xExt == 0 || lpPict->yExt == 0)
	{
		// usually the natural extent is set to something interesting
		TRACE(traceOle, 0, "Warning: COleServerItem has no natural size --\n");
		TRACE(traceOle, 0, "\twill not work with some apps like MS Write.\n");
	}
#endif

	// return the medium with the hGlobal to the METAFILEPICT
	::GlobalUnlock(hPict);
	lpStgMedium->hGlobal = hPict;
	lpStgMedium->tymed = TYMED_MFPICT;
	return TRUE;
}

BOOL COleServerItem::OnSetColorScheme(const LOGPALETTE* /*lpLogPalette*/)
{
	ASSERT_VALID(this);

	return FALSE;   // default does nothing
}

BOOL COleServerItem::OnInitFromData(
	COleDataObject* /*pDataObject*/, BOOL /*bCreation*/)
{
	ASSERT_VALID(this);

	AfxThrowOleException(E_NOTIMPL);
}

void COleServerItem::CopyToClipboard(BOOL bIncludeLink)
{
	ASSERT_VALID(this);

	COleDataSource* pDataSource = OnGetClipboardData(bIncludeLink, NULL, NULL);

	// put it on the clipboard
	pDataSource->SetClipboard();
}

COleDataSource* COleServerItem::OnGetClipboardData(BOOL bIncludeLink,
	LPPOINT lpOffset, LPSIZE lpSize)
{
	ASSERT_VALID(this);

	COleDataSource* pDataSource = new COleDataSource;
	TRY
	{
		GetClipboardData(pDataSource, bIncludeLink, lpOffset, lpSize);
	}
	CATCH_ALL(e)
	{
		delete pDataSource;
		THROW_LAST();
	}
	END_CATCH_ALL

	ASSERT_VALID(pDataSource);
	return pDataSource;
}

DROPEFFECT COleServerItem::DoDragDrop(LPCRECT lpItemRect, CPoint ptOffset,
	BOOL bIncludeLink, DWORD dwEffects, LPCRECT lpRectStartDrag)
{
	ASSERT(AfxIsValidAddress(lpItemRect, sizeof(RECT)));
	ASSERT_VALID(this);

	ASSERT_VALID(this);

	DROPEFFECT dropEffect = DROPEFFECT_NONE;
	COleDataSource *pDataSource = NULL;
	TRY
	{
		// get clipboard data for this item
		CSize sizeItem(
			lpItemRect->right - lpItemRect->left,
			lpItemRect->bottom - lpItemRect->top);
		pDataSource = OnGetClipboardData(bIncludeLink, &ptOffset, &sizeItem);

		// add DROPEFFECT_LINK if link source is available
		LPDATAOBJECT lpDataObject = (LPDATAOBJECT)
			pDataSource->GetInterface(&IID_IDataObject);
		ASSERT(lpDataObject != NULL);
		FORMATETC formatEtc;
		formatEtc.cfFormat = (CLIPFORMAT)_oleData.cfLinkSource;
		formatEtc.ptd = NULL;
		formatEtc.dwAspect = DVASPECT_CONTENT;
		formatEtc.lindex = -1;
		formatEtc.tymed = (DWORD) -1;
		if (lpDataObject->QueryGetData(&formatEtc) == S_OK)
			dwEffects |= DROPEFFECT_LINK;

		// calculate default sensitivity rectangle
		CRect rectDrag;
		if (lpRectStartDrag == NULL)
		{
			rectDrag.SetRect(lpItemRect->left, lpItemRect->top, lpItemRect->left,
				lpItemRect->top);
			lpRectStartDrag = &rectDrag;
		}

		// do drag drop operation
		dropEffect = pDataSource->DoDragDrop(dwEffects, lpRectStartDrag);
		pDataSource->InternalRelease();
	}
	CATCH_ALL(e)
	{
		if (pDataSource != NULL)
			pDataSource->InternalRelease();

		THROW_LAST();
	}
	END_CATCH_ALL

	return dropEffect;
}

void COleServerItem::GetClipboardData(COleDataSource* pDataSource,
	BOOL bIncludeLink, LPPOINT lpOffset, LPSIZE lpSize)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDataSource);
	ASSERT(lpOffset == NULL ||
		AfxIsValidAddress(lpOffset, sizeof(POINT), FALSE));

	// add CF_EMBEDDEDOBJECT by creating memory storage copy of the object
	STGMEDIUM stgMedium;
	GetEmbedSourceData(&stgMedium);
	pDataSource->CacheData((CLIPFORMAT)_oleData.cfEmbedSource, &stgMedium);

	// add CF_OBJECTDESCRIPTOR
	GetObjectDescriptorData(lpOffset, lpSize, &stgMedium);
	pDataSource->CacheData((CLIPFORMAT)_oleData.cfObjectDescriptor,
		&stgMedium);

	// add any presentation entries/conversion formats that the item
	//  can produce.
	AddOtherClipboardData(pDataSource);

	// add CF_LINKSOURCE if supporting links to pseudo objects
	if (bIncludeLink && GetLinkSourceData(&stgMedium))
	{
		pDataSource->CacheData((CLIPFORMAT)_oleData.cfLinkSource, &stgMedium);

		// add CF_LINKSOURCEDESCRIPTOR
		GetObjectDescriptorData(lpOffset, lpSize, &stgMedium);
		pDataSource->CacheData((CLIPFORMAT)_oleData.cfLinkSourceDescriptor,
			&stgMedium);
	}
}

void COleServerItem::GetEmbedSourceData(LPSTGMEDIUM lpStgMedium)
{
	ASSERT_VALID(this);
	ASSERT(AfxIsValidAddress(lpStgMedium, sizeof(STGMEDIUM)));

	LPLOCKBYTES lpLockBytes;
	SCODE sc = ::CreateILockBytesOnHGlobal(NULL, TRUE, &lpLockBytes);
	if (sc != S_OK)
		AfxThrowOleException(sc);
	ASSERT(lpLockBytes != NULL);

	LPSTORAGE lpStorage;
	sc = ::StgCreateDocfileOnILockBytes(lpLockBytes,
		STGM_SHARE_EXCLUSIVE|STGM_CREATE|STGM_READWRITE, 0, &lpStorage);
	if (sc != S_OK)
	{
		VERIFY(lpLockBytes->Release() == 0);
		AfxThrowOleException(sc);
	}
	ASSERT(lpStorage != NULL);

	// setup for save copy as
	COleServerDoc* pDoc = GetDocument();
	pDoc->m_bSameAsLoad = FALSE;
	pDoc->m_bRemember = FALSE;

	TRY
	{
		OnSaveEmbedding(lpStorage);
		pDoc->CommitItems(FALSE);
	}
	CATCH_ALL(e)
	{
		// release storage and lock bytes
		VERIFY(lpStorage->Release() == 0);
		VERIFY(lpLockBytes->Release() == 0);
		pDoc->m_bSameAsLoad = TRUE;
		pDoc->m_bRemember = TRUE;
		THROW_LAST();
	}
	END_CATCH_ALL

	pDoc->m_bSameAsLoad = TRUE;
	pDoc->m_bRemember = TRUE;
	lpLockBytes->Release();

	// add it to the data source
	lpStgMedium->tymed = TYMED_ISTORAGE;
	lpStgMedium->pstg = lpStorage;
	lpStgMedium->pUnkForRelease = NULL;
}

void COleServerItem::AddOtherClipboardData(COleDataSource* pDataSource)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDataSource);

	// get IEnumFORMATETC interface for the IDataObject
	LPDATAOBJECT lpDataObject = GetDataObject();
	LPENUMFORMATETC lpEnumFORMATETC;
	if (lpDataObject->EnumFormatEtc(DATADIR_GET, &lpEnumFORMATETC) != S_OK)
		return;
	ASSERT(lpEnumFORMATETC != NULL);

	// get all formats that the object will give us
	FORMATETC formatEtc;
	while (lpEnumFORMATETC->Next(1, &formatEtc, NULL) == S_OK)
	{
		STGMEDIUM stgMedium;
		if (lpDataObject->GetData(&formatEtc, &stgMedium) != S_OK)
		{
			// data is not available
			CoTaskMemFree(formatEtc.ptd);
		}
		else if (stgMedium.pUnkForRelease != NULL)
		{
			// don't cache data with pUnkForRelease != NULL
			::ReleaseStgMedium(&stgMedium);
			CoTaskMemFree(formatEtc.ptd);
		}
		else
		{
			// cache the data (now we own the stgMedium)
			pDataSource->CacheData(0, &stgMedium, &formatEtc);
		}
	}

	// cleanup
	lpEnumFORMATETC->Release();
}

LPMONIKER COleServerItem::GetMoniker(OLEGETMONIKER nAssign)
{
	// get IOleObject interface for this item
	LPOLEOBJECT lpOleObject = GetOleObject();
	ASSERT(lpOleObject != NULL);

	// get moniker from OLE object
	LPMONIKER lpMoniker = NULL;
	lpOleObject->GetMoniker(nAssign, OLEWHICHMK_OBJFULL, &lpMoniker);
	return lpMoniker;
}

BOOL COleServerItem::GetLinkSourceData(LPSTGMEDIUM lpStgMedium)
{
	ASSERT_VALID(this);
	ASSERT(AfxIsValidAddress(lpStgMedium, sizeof(STGMEDIUM)));

	LPOLEOBJECT lpOleObject = GetOleObject();
	ASSERT(lpOleObject != NULL);

	// get moniker from ole object
	LPMONIKER lpMoniker;
	SCODE sc = lpOleObject->GetMoniker(OLEGETMONIKER_TEMPFORUSER,
		OLEWHICHMK_OBJFULL, &lpMoniker);
	if (sc != S_OK)
	{
		TRACE(traceOle, 0, "Warning: unable to get moniker for object.\n");
		return FALSE;
	}
	ASSERT(lpMoniker != NULL);

	// create a memory based stream to write the moniker to
	LPSTREAM lpStream;
	if (::CreateStreamOnHGlobal(NULL, TRUE, &lpStream) != S_OK)
	{
		lpMoniker->Release();
		AfxThrowMemoryException();
	}
	ASSERT(lpStream != NULL);

	// write the moniker to the stream, and add it to the clipboard
	sc = ::OleSaveToStream(lpMoniker, lpStream);
	lpMoniker->Release();
	if (sc != S_OK)
	{
		lpStream->Release();
		AfxThrowOleException(sc);
	}

	// write the class ID of the document to the stream as well
	COleLinkingDoc* pDoc = GetDocument();
	ASSERT(pDoc->m_pFactory != NULL);
	sc = WriteClassStm(lpStream, pDoc->m_pFactory->GetClassID());
	if (sc != S_OK)
	{
		lpStream->Release();
		AfxThrowOleException(sc);
	}

	// setup the STGMEDIUM
	lpStgMedium->tymed = TYMED_ISTREAM;
	lpStgMedium->pstm = lpStream;
	lpStgMedium->pUnkForRelease = NULL;
	return TRUE;
}

void COleServerItem::GetObjectDescriptorData(
	LPPOINT lpOffset, LPSIZE lpSize, LPSTGMEDIUM lpStgMedium)
{
	ASSERT_VALID(this);
	ASSERT(AfxIsValidAddress(lpStgMedium, sizeof(STGMEDIUM)));
	ASSERT(lpOffset == NULL ||
		AfxIsValidAddress(lpOffset, sizeof(POINT), FALSE));

	LPOLEOBJECT lpOleObject = GetOleObject();
	ASSERT(lpOleObject != NULL);

	// get the object descriptor for the IOleObject
	POINTL pointl = { 0, 0 };
	if (lpOffset != NULL)
	{
		CSize ptOffset(lpOffset->x, lpOffset->y);
		((CDC*)NULL)->DPtoHIMETRIC(&ptOffset);
		pointl.x = ptOffset.cx;
		pointl.y = ptOffset.cy;
	}
	SIZEL sizel;
	if (lpSize != NULL)
	{
		sizel.cx = lpSize->cx;
		sizel.cy = lpSize->cy;
		((CDC*)NULL)->DPtoHIMETRIC(&sizel);
	}
	else
	{
		sizel.cx = 0;
		sizel.cy = 0;
	}

	InterlockedIncrement(&m_dwRef);  // protect against destruction during this call
	HGLOBAL hGlobal = _AfxOleGetObjectDescriptorData(
		lpOleObject, NULL, DVASPECT_CONTENT, pointl, &sizel);
	InterlockedDecrement(&m_dwRef);

	if (hGlobal == NULL)
		AfxThrowMemoryException();

	// setup the STGMEDIUM
	lpStgMedium->tymed = TYMED_HGLOBAL;
	lpStgMedium->hGlobal = hGlobal;
	lpStgMedium->pUnkForRelease = NULL;
}

void COleServerItem::OnSaveEmbedding(LPSTORAGE lpStorage)
{
	ASSERT(lpStorage != NULL);

	// always (logically) a "File.Save Copy As" operation
	COleServerDoc* pDoc = GetDocument();
	LPSTORAGE lpOrigStg = pDoc->m_lpRootStg;
	pDoc->m_lpRootStg = lpStorage;

	TRY
	{
		ASSERT(pDoc->m_lpRootStg != NULL);
		pDoc->SaveToStorage(this);  // use helper to serialize to storage
	}
	CATCH_ALL(e)
	{
		// save as failed: re-attach original storage
		pDoc->m_lpRootStg = lpOrigStg;
		THROW_LAST();
	}
	END_CATCH_ALL

	// re-attach original storage
	pDoc->m_lpRootStg = lpOrigStg;
}

/////////////////////////////////////////////////////////////////////////////
// COleServerItem data-object callback default implementation

BOOL COleServerItem::OnRenderGlobalData(
	LPFORMATETC /*lpFormatEtc*/, HGLOBAL* /*phGlobal*/)
{
	ASSERT_VALID(this);

	return FALSE;   // default does nothing
}

BOOL COleServerItem::OnRenderFileData(
	LPFORMATETC /*lpFormatEtc*/, CFile* /*pFile*/)
{
	ASSERT_VALID(this);

	return FALSE;   // default does nothing
}

BOOL COleServerItem::OnRenderData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium)
{
	ASSERT_VALID(this);
	ASSERT(AfxIsValidAddress(lpFormatEtc, sizeof(FORMATETC), FALSE));
	ASSERT(AfxIsValidAddress(lpStgMedium, sizeof(STGMEDIUM)));

	// default implementation does not support extended layout
	if (lpFormatEtc->lindex != -1)
		return FALSE;

	// default implementation supports both types of metafiles
	if (lpFormatEtc->cfFormat == CF_METAFILEPICT)
		return GetMetafileData(lpFormatEtc, lpStgMedium);

	return FALSE;   // cfFormat not supported
}

BOOL COleServerItem::OnSetData(
	LPFORMATETC /*lpFormatEtc*/, LPSTGMEDIUM /*lpStgMedium*/, BOOL /*bRelease*/)
{
	ASSERT_VALID(this);

	return FALSE;   // default does nothing
}

/////////////////////////////////////////////////////////////////////////////
// COleServerItem OLE interface implementation

BEGIN_INTERFACE_MAP(COleServerItem, CDocItem)
	INTERFACE_PART(COleServerItem, IID_IOleObject, OleObject)
	INTERFACE_PART(COleServerItem, IID_IDataObject, DataObject)
END_INTERFACE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COleServerItem::XOleObject

STDMETHODIMP_(ULONG) COleServerItem::XOleObject::AddRef()
{
	METHOD_PROLOGUE_EX_(COleServerItem, OleObject)
	return pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) COleServerItem::XOleObject::Release()
{
	METHOD_PROLOGUE_EX_(COleServerItem, OleObject)
	return pThis->ExternalRelease();
}

STDMETHODIMP COleServerItem::XOleObject::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(COleServerItem, OleObject)
	return pThis->ExternalQueryInterface(&iid, ppvObj);
}

// COleServerItem has special Release semantics.  In particular, the item
//  is only deleted from memory if m_bAutoDelete is TRUE.
//  Also, it unlocks the document if the reference count reaches zero.

void COleServerItem::OnFinalRelease()
{
	ASSERT_VALID(this);

	COleServerDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	pDoc->InternalAddRef(); // make document stable

	// if connected to a document -- remove external lock from it
	if (m_bNeedUnlock)
	{
		pDoc->LockExternal(FALSE, TRUE);
		m_bNeedUnlock = FALSE;
	}

	// delete this item if no longer needed
	if (m_bAutoDelete)
		delete this;

	// release artificial reference (may destroy the document)
	pDoc->InternalRelease();
}

STDMETHODIMP COleServerItem::XOleObject::SetClientSite(
	LPOLECLIENTSITE /*pClientSite*/)
{
	// linked objects do not support SetClientSite

	return E_NOTIMPL;
}

STDMETHODIMP COleServerItem::XOleObject::GetClientSite(
	LPOLECLIENTSITE* ppClientSite)
{
	// linked objects do not support GetClientSite

	*ppClientSite = NULL;
	return E_NOTIMPL;
}

STDMETHODIMP COleServerItem::XOleObject::SetHostNames(
	LPCOLESTR /*szContainerApp*/, LPCOLESTR /*szContainerObj*/)
{
	// linked objects do not support SetHostNames

	return E_NOTIMPL;
}

STDMETHODIMP COleServerItem::XOleObject::Close(DWORD /*dwSaveOption*/)
{
	// linked objects do not support close

	return E_NOTIMPL;
}

STDMETHODIMP COleServerItem::XOleObject::SetMoniker(
	DWORD /*dwWhichMoniker*/, LPMONIKER /*pmk*/)
{
	// linked objects do not support SetMoniker

	return E_NOTIMPL;
}

STDMETHODIMP COleServerItem::XOleObject::GetMoniker(
	DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER* ppMoniker)
{
	METHOD_PROLOGUE_EX(COleServerItem, OleObject)
	ASSERT_VALID(pThis);

	COleServerDoc* pDoc = pThis->GetDocument();
	ASSERT_VALID(pDoc);
	ASSERT_KINDOF(COleServerDoc, pDoc);
	ASSERT(ppMoniker != NULL);
	*ppMoniker = NULL;

	switch (dwWhichMoniker)
	{
	case OLEWHICHMK_CONTAINER:
		// simply return the moniker of the container document
		*ppMoniker = pDoc->GetMoniker((OLEGETMONIKER)dwAssign);
		break;

	case OLEWHICHMK_OBJREL:
		{
			// no relative moniker if no item name
			if (pThis->m_strItemName.IsEmpty())
				break;

			// don't return relative moniker if no document moniker
			LPMONIKER lpMoniker = pDoc->GetMoniker((OLEGETMONIKER)dwAssign);
			if (lpMoniker == NULL)
				break;
			lpMoniker->Release();   // don't need document moniker

			// relative monikers have to handle assignment correctly
			switch (dwAssign)
			{
			case OLEGETMONIKER_TEMPFORUSER:
			case OLEGETMONIKER_ONLYIFTHERE:
			case OLEGETMONIKER_FORCEASSIGN:
			{
				// create item moniker from name
				const CStringW strItemName(pThis->m_strItemName);
				CreateItemMoniker(OLESTDDELIMOLE, strItemName.GetString(),
					ppMoniker);
				break;
			}

			case OLEGETMONIKER_UNASSIGN:
				ASSERT(FALSE);  // should never get UNASSIGN
				break;
			}
		}
		break;

	case OLEWHICHMK_OBJFULL:
		{
			// get each sub-moniker: item & document
			LPMONIKER lpMoniker1, lpMoniker2;
			GetMoniker(dwAssign, OLEWHICHMK_CONTAINER, &lpMoniker1);
			GetMoniker(dwAssign, OLEWHICHMK_OBJREL, &lpMoniker2);

			if (lpMoniker1 != NULL && lpMoniker2 != NULL)
			{
				// create composite from two parts
				::CreateGenericComposite(lpMoniker1, lpMoniker2, ppMoniker);
			}
			else if (lpMoniker1 != NULL)
			{
				// just use container moniker
				*ppMoniker = lpMoniker1;
				lpMoniker1 = NULL;
			}

			// release sub-monikers
			RELEASE(lpMoniker1);
			RELEASE(lpMoniker2);
		}
		break;
	}

	return *ppMoniker == NULL ? E_FAIL : S_OK;
}

STDMETHODIMP COleServerItem::XOleObject::InitFromData(
	LPDATAOBJECT /*pDataObject*/, BOOL /*fCreation*/, DWORD /*dwReserved*/)
{
	// linked objects do not support InitFromData

	return E_NOTIMPL;
}

STDMETHODIMP COleServerItem::XOleObject::GetClipboardData(
	DWORD /*dwReserved*/, LPDATAOBJECT* ppDataObject)
{
	METHOD_PROLOGUE_EX(COleServerItem, OleObject)
	ASSERT_VALID(pThis);

	*ppDataObject = NULL;

	SCODE sc;
	TRY
	{
		COleDataSource* pDataSource = pThis->OnGetClipboardData(TRUE, NULL, NULL);
		ASSERT(pDataSource != NULL);

		*ppDataObject =
			(LPDATAOBJECT)pDataSource->GetInterface(&IID_IDataObject);
		ASSERT(*ppDataObject != NULL);
		sc = S_OK;
	}
	CATCH_ALL(e)
	{
		sc = COleException::Process(e);
		DELETE_EXCEPTION(e);
	}
	END_CATCH_ALL

	return sc;
}

STDMETHODIMP COleServerItem::XOleObject::DoVerb(
	LONG iVerb, LPMSG /*lpmsg*/, LPOLECLIENTSITE /*pActiveSite*/, LONG /*lindex*/,
	HWND /*hwndParent*/, LPCRECT /*lpPosRect*/)
{
	METHOD_PROLOGUE_EX(COleServerItem, OleObject)
	ASSERT_VALID(pThis);

	pThis->InternalAddRef();    // protect this object

	SCODE sc;
	TRY
	{
		pThis->OnDoVerb(iVerb);
		sc = S_OK;
	}
	CATCH_ALL(e)
	{
		sc = COleException::Process(e);
		DELETE_EXCEPTION(e);
	}
	END_CATCH_ALL

	pThis->InternalRelease();   // may 'delete this'

	return sc;
}

STDMETHODIMP COleServerItem::XOleObject::EnumVerbs(
	IEnumOLEVERB** ppenumOleVerb)
{
	METHOD_PROLOGUE_EX_(COleServerItem, OleObject)

	*ppenumOleVerb = NULL;

	CLSID clsid;
	pThis->GetOleObject()->GetUserClassID(&clsid);
	return OleRegEnumVerbs(clsid, ppenumOleVerb);
}

STDMETHODIMP COleServerItem::XOleObject::Update()
{
	METHOD_PROLOGUE_EX(COleServerItem, OleObject)
	ASSERT_VALID(pThis);

	SCODE sc;
	TRY
	{
		pThis->OnUpdateItems();
		sc = S_OK;
	}
	CATCH_ALL(e)
	{
		sc = COleException::Process(e);
		DELETE_EXCEPTION(e);
	}
	END_CATCH_ALL

	return sc;
}

STDMETHODIMP COleServerItem::XOleObject::IsUpToDate()
{
	METHOD_PROLOGUE_EX(COleServerItem, OleObject)
	ASSERT_VALID(pThis);

	SCODE sc;
	TRY
	{
		sc = pThis->OnQueryUpdateItems() ? S_FALSE : S_OK;
	}
	CATCH_ALL(e)
	{
		sc = COleException::Process(e);
		DELETE_EXCEPTION(e);
	}
	END_CATCH_ALL

	return sc;
}

STDMETHODIMP COleServerItem::XOleObject::GetUserClassID(CLSID* pClsid)
{
	METHOD_PROLOGUE_EX_(COleServerItem, OleObject)

	COleServerDoc* pDoc = pThis->GetDocument();
	return pDoc->m_xPersistFile.GetClassID(pClsid);
}

STDMETHODIMP COleServerItem::XOleObject::GetUserType(
	DWORD dwFormOfType, LPOLESTR* ppszUserType)
{
	METHOD_PROLOGUE_EX_(COleServerItem, OleObject)

	*ppszUserType = NULL;

	CLSID clsid;
	pThis->GetOleObject()->GetUserClassID(&clsid);
	return OleRegGetUserType(clsid, dwFormOfType, ppszUserType);
}

STDMETHODIMP COleServerItem::XOleObject::SetExtent(
	DWORD /*dwDrawAspect*/, LPSIZEL /*lpsizel*/)
{
	// linked objects do not support SetExtent

	return E_FAIL;
}

STDMETHODIMP COleServerItem::XOleObject::GetExtent(
	DWORD dwDrawAspect, LPSIZEL lpsizel)
{
	METHOD_PROLOGUE_EX(COleServerItem, OleObject)
	ASSERT_VALID(pThis);

	SCODE sc = E_INVALIDARG;
	TRY
	{
		// call to get regular windows size
		CSize size;
		if (pThis->OnGetExtent((DVASPECT)dwDrawAspect, size))
		{
			if (size.cy < 0)
				size.cy = -size.cy; // extents are always positive
			lpsizel->cx = size.cx;
			lpsizel->cy = size.cy;

			sc = S_OK;
		}
	}
	CATCH_ALL(e)
	{
		sc = COleException::Process(e);
		DELETE_EXCEPTION(e);
	}
	END_CATCH_ALL

	return sc;
}

STDMETHODIMP COleServerItem::XOleObject::Advise(
	IAdviseSink* pAdvSink, DWORD* pdwConnection)
{
	METHOD_PROLOGUE_EX_(COleServerItem, OleObject)

	*pdwConnection = 0;

	if (pThis->m_lpOleAdviseHolder == NULL &&
		::CreateOleAdviseHolder(&pThis->m_lpOleAdviseHolder) != S_OK)
	{
		return E_OUTOFMEMORY;
	}
	ASSERT(pThis->m_lpOleAdviseHolder != NULL);
	return pThis->m_lpOleAdviseHolder->Advise(pAdvSink, pdwConnection);
}

STDMETHODIMP COleServerItem::XOleObject::Unadvise(DWORD dwConnection)
{
	METHOD_PROLOGUE_EX_(COleServerItem, OleObject)

	if (pThis->m_lpOleAdviseHolder == NULL)
		return E_FAIL;

	ASSERT(pThis->m_lpOleAdviseHolder != NULL);
	return pThis->m_lpOleAdviseHolder->Unadvise(dwConnection);
}

STDMETHODIMP COleServerItem::XOleObject::EnumAdvise(
	LPENUMSTATDATA* ppenumAdvise)
{
	METHOD_PROLOGUE_EX_(COleServerItem, OleObject)

	*ppenumAdvise = NULL;

	if (pThis->m_lpOleAdviseHolder == NULL)
		return E_FAIL;

	ASSERT(pThis->m_lpOleAdviseHolder != NULL);
	return pThis->m_lpOleAdviseHolder->EnumAdvise(ppenumAdvise);
}

STDMETHODIMP COleServerItem::XOleObject::GetMiscStatus(
	DWORD dwAspect, DWORD* pdwStatus)
{
	METHOD_PROLOGUE_EX_(COleServerItem, OleObject)

	*pdwStatus = 0;

	CLSID clsid;
	pThis->GetOleObject()->GetUserClassID(&clsid);
	return OleRegGetMiscStatus(clsid, dwAspect, pdwStatus);
}

STDMETHODIMP COleServerItem::XOleObject::SetColorScheme(LPLOGPALETTE lpLogpal)
{
	METHOD_PROLOGUE_EX(COleServerItem, OleObject)
	ASSERT_VALID(pThis);

	SCODE sc = E_NOTIMPL;
	TRY
	{
		// delegate to embedded item
		if (pThis->OnSetColorScheme(lpLogpal))
			sc = S_OK;
	}
	END_TRY

	return sc;
}

/////////////////////////////////////////////////////////////////////////////
// COleServerItem::XDataObject

STDMETHODIMP_(ULONG) COleServerItem::XDataObject::AddRef()
{
	METHOD_PROLOGUE_EX_(COleServerItem, DataObject)
	return pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) COleServerItem::XDataObject::Release()
{
	METHOD_PROLOGUE_EX_(COleServerItem, DataObject)
	return pThis->ExternalRelease();
}

STDMETHODIMP COleServerItem::XDataObject::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(COleServerItem, DataObject)
	return pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP COleServerItem::XDataObject::GetData(
	LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium)
{
	METHOD_PROLOGUE_EX_(COleServerItem, DataObject)

	return pThis->m_dataSource.m_xDataObject.GetData(lpFormatEtc, lpStgMedium);
}

STDMETHODIMP COleServerItem::XDataObject::GetDataHere(
	LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium)
{
	METHOD_PROLOGUE_EX_(COleServerItem, DataObject)

	return pThis->m_dataSource.m_xDataObject.GetDataHere(
		lpFormatEtc, lpStgMedium);
}

STDMETHODIMP COleServerItem::XDataObject::QueryGetData(LPFORMATETC lpFormatEtc)
{
	METHOD_PROLOGUE_EX_(COleServerItem, DataObject)

	return pThis->m_dataSource.m_xDataObject.QueryGetData(lpFormatEtc);
}

STDMETHODIMP COleServerItem::XDataObject::GetCanonicalFormatEtc(
	LPFORMATETC /*lpFormatEtcIn*/, LPFORMATETC /*lpFormatEtcOut*/)
{
	// because we support the target-device (ptd) for server metafile format,
	//  all members of the FORMATETC are significant.

	return DATA_S_SAMEFORMATETC;
}

STDMETHODIMP COleServerItem::XDataObject::SetData(
	LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium, BOOL bRelease)
{
	METHOD_PROLOGUE_EX_(COleServerItem, DataObject)

	return pThis->m_dataSource.m_xDataObject.SetData(
		lpFormatEtc, lpStgMedium, bRelease);
}

STDMETHODIMP COleServerItem::XDataObject::EnumFormatEtc(
	DWORD dwDirection, LPENUMFORMATETC* ppenumFormatEtc)
{
	METHOD_PROLOGUE_EX_(COleServerItem, DataObject)

	return pThis->m_dataSource.m_xDataObject.EnumFormatEtc(
		dwDirection, ppenumFormatEtc);
}

STDMETHODIMP COleServerItem::XDataObject::DAdvise(
	FORMATETC* pFormatEtc, DWORD advf,
	LPADVISESINK pAdvSink, DWORD* pdwConnection)
{
	METHOD_PROLOGUE_EX_(COleServerItem, DataObject)

	*pdwConnection = 0;

	// this special case is for apps like Excel which ask for DAdvise
	// on CF_METAFILEPICT, DVASPECT_ICON for insert as icon.
	FORMATETC formatEtc = *pFormatEtc;
	if (formatEtc.cfFormat == CF_METAFILEPICT &&
		formatEtc.dwAspect == DVASPECT_ICON)
	{
		formatEtc.dwAspect = DVASPECT_CONTENT;
	}

	// make sure the FORMATETC is valid
	if (!(pFormatEtc->cfFormat == 0 && pFormatEtc->ptd == NULL &&
		  pFormatEtc->dwAspect == -1 && pFormatEtc->lindex == -1 &&
		  pFormatEtc->tymed == -1) &&
		pThis->GetDataObject()->QueryGetData(&formatEtc) != S_OK)
	{
		// it is not a wildcard advise -and- the format is not acceptable
		return DATA_E_FORMATETC;
	}

	// create the advise holder, if necessary
	if (pThis->m_lpDataAdviseHolder == NULL &&
		CreateDataAdviseHolder(&pThis->m_lpDataAdviseHolder) != S_OK)
	{
		return E_OUTOFMEMORY;
	}
	ASSERT(pThis->m_lpDataAdviseHolder != NULL);
	return pThis->m_lpDataAdviseHolder->Advise(this, pFormatEtc, advf,
		pAdvSink, pdwConnection);
}

STDMETHODIMP COleServerItem::XDataObject::DUnadvise(DWORD dwConnection)
{
	METHOD_PROLOGUE_EX_(COleServerItem, DataObject)

	if (pThis->m_lpDataAdviseHolder == NULL)
		return E_FAIL;

	ASSERT(pThis->m_lpDataAdviseHolder != NULL);
	return pThis->m_lpDataAdviseHolder->Unadvise(dwConnection);
}

STDMETHODIMP COleServerItem::XDataObject::EnumDAdvise(
	LPENUMSTATDATA* ppenumAdvise)
{
	METHOD_PROLOGUE_EX_(COleServerItem, DataObject)

	*ppenumAdvise = NULL;

	if (pThis->m_lpDataAdviseHolder == NULL)
		return E_FAIL;

	ASSERT(pThis->m_lpDataAdviseHolder != NULL);
	return pThis->m_lpDataAdviseHolder->EnumAdvise(ppenumAdvise);
}

//////////////////////////////////////////////////////////////////////////////
// special CItemDataSource implementation

BOOL COleServerItem::CItemDataSource::OnRenderGlobalData(
	LPFORMATETC lpFormatEtc, HGLOBAL* phGlobal)
{
	ASSERT_VALID(this);
	COleServerItem* pItem = (COleServerItem*)
		((BYTE*)this - offsetof(COleServerItem, m_dataSource));

	return pItem->OnRenderGlobalData(lpFormatEtc, phGlobal);
		// Note: COleDataSource has no implementation
}

BOOL COleServerItem::CItemDataSource::OnRenderFileData(
	LPFORMATETC lpFormatEtc, CFile* pFile)
{
	ASSERT_VALID(this);
	COleServerItem* pItem = (COleServerItem*)
		((BYTE*)this - offsetof(COleServerItem, m_dataSource));

	return pItem->OnRenderFileData(lpFormatEtc, pFile);
		// Note: COleDataSource has no implementation
}

BOOL COleServerItem::CItemDataSource::OnRenderData(
	LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium)
{
	ASSERT_VALID(this);
	COleServerItem* pItem = (COleServerItem*)
		((BYTE*)this - offsetof(COleServerItem, m_dataSource));

	if (pItem->OnRenderData(lpFormatEtc, lpStgMedium))
		return TRUE;

	return COleDataSource::OnRenderData(lpFormatEtc, lpStgMedium);
}

BOOL COleServerItem::CItemDataSource::OnSetData(
	LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium, BOOL bRelease)
{
	ASSERT_VALID(this);
	COleServerItem* pItem = (COleServerItem*)
		((BYTE*)this - offsetof(COleServerItem, m_dataSource));

	return pItem->OnSetData(lpFormatEtc, lpStgMedium, bRelease);
		// Note: COleDataSource has no implementation
}

//////////////////////////////////////////////////////////////////////////////
// COleServerItem Diagnostics

#ifdef _DEBUG
void COleServerItem::AssertValid() const
{
	CDocItem::AssertValid();

	// must be attached to a document
	ASSERT(m_pDocument != NULL);
	m_dataSource.AssertValid();
}

void COleServerItem::Dump(CDumpContext& dc) const
{
	CDocItem::Dump(dc);

	dc << "m_bNeedUnlock = " << m_bNeedUnlock;
	dc << "\nm_bAutoDelete = " << m_bAutoDelete;
	dc << "\nm_strItemName = " << m_strItemName;
	dc << "\nm_lpOleAdviseHolder = " << m_lpOleAdviseHolder;
	dc << "\nm_lpDataAdviseHolder = " << m_lpDataAdviseHolder;
	dc << "\nwith m_dataSource: " << &m_dataSource;
}
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\olepset.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include <malloc.h>
#include <ole2.h>
#include <oleauto.h>



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// Helper functions used by CProperty, CPropertySection, CPropertySet classes

AFX_STATIC LPVOID AFXAPI _AfxCountPrefixedStringA(LPCSTR lpsz)
{
	DWORD cb = (lstrlenA(lpsz) + 1);
	LPDWORD lp = (LPDWORD)malloc((int)cb + sizeof(DWORD));
	if (lp)
	{
		*lp = cb;
		Checked::strcpy_s((LPSTR)(lp+1), cb, lpsz);
	}

	return (LPVOID)lp;
}


AFX_STATIC LPVOID AFXAPI _AfxCountPrefixedStringW(LPCWSTR lpsz)
{
	DWORD cb = (lpsz == NULL ? 0 : DWORD(wcslen(lpsz))) + 1;
	LPDWORD lp = (LPDWORD)malloc(::ATL::AtlAddThrow(::ATL::AtlMultiplyThrow(static_cast<size_t>(cb), sizeof(WCHAR)), sizeof(DWORD)));
	if (lp)
	{
		*lp = cb;
		if (lpsz == NULL)
		{
			*(LPWSTR)(lp + 1) = '\0';
		}
		else
		{
			Checked::wcscpy_s((LPWSTR)(lp+1), cb, lpsz);
		}
	}

	return (LPVOID)lp;
}

#ifdef _UNICODE
#define _AfxCountPrefixedString _AfxCountPrefixedStringW
#else
#define _AfxCountPrefixedString _AfxCountPrefixedStringA
#endif


#ifdef _UNICODE

#define MAX_STRLEN 1024

AFX_STATIC LPBYTE AFXAPI _AfxConvertStringProp(LPBYTE pbProp, DWORD dwType, ULONG nReps,
	UINT cbCharSize)
{
	LPBYTE pbResult = NULL; // Return value
	ULONG cbResult = 0;     // Number of bytes in pbResult
	LPBYTE pbBuffer;        // Temporary holding space
	ULONG cchOrig;          // Number of characters in original string
	ULONG cchCopy;          // Number of characters to copy
	ULONG cbCopy;           // Number of bytes to copy
	LPBYTE pbResultNew;     // Used for realloc of pbResult

	pbBuffer = (LPBYTE)calloc(MAX_STRLEN, cbCharSize);
	if (pbBuffer == NULL)
		return NULL;

	// If it's a vector, the count goes first.
	if (dwType & VT_VECTOR)
	{
		pbResult = (LPBYTE)malloc(sizeof(DWORD));
		if (pbResult == NULL)
		{
			free(pbBuffer);
			return NULL;
		}
		*(LPDWORD)pbResult = nReps;
		cbResult = sizeof(DWORD);
	}

	while (nReps--)
	{
		cchOrig = *(LPDWORD)pbProp;
		pbProp += sizeof(DWORD);

		// Convert multibyte string to Unicode.
		if (cbCharSize == sizeof(WCHAR))
		{
			cchCopy = _mbstowcsz((LPWSTR)pbBuffer, (LPSTR)pbProp,
				min(cchOrig, MAX_STRLEN));
		}
		else
		{
			cchCopy = _wcstombsz((LPSTR)pbBuffer, (LPWSTR)pbProp,
				min(cchOrig, MAX_STRLEN));
		}

		// Allocate space to append string.
		cbCopy = cchCopy * cbCharSize;
		ULONG cbNewResult = cbResult + sizeof(DWORD) + cbCopy;
		if ((cbNewResult < cbResult) || (cbNewResult < cbCopy) || (cbNewResult < sizeof(DWORD)))
		{
			// allocation failed due overflow: cleanup and return NULL
			free(pbResult);
			free(pbBuffer);
			return NULL;
		}

		pbResultNew = (LPBYTE)realloc(pbResult, cbNewResult);

		// If allocation failed, cleanup and return NULL;
		if (pbResultNew == NULL)
		{
			free(pbResult);
			free(pbBuffer);
			return NULL;
		}

		pbResult = pbResultNew;

		// Copy character count and converted string into place,
		// then update the total size.
		memcpy(pbResult + cbResult, (LPBYTE)&cchCopy, sizeof(DWORD));
		memcpy(pbResult + cbResult + sizeof(DWORD), pbBuffer, cbCopy);
		cbResult += sizeof(DWORD) + cbCopy;

		// Advance to the next vector element
		pbProp += (cchOrig * cbCharSize);
	}

	free(pbBuffer);
	return pbResult;
}

#endif // _UNICODE

/////////////////////////////////////////////////////////////////////////////
// Implementation of the CProperty class

CProperty::CProperty()
{
	m_dwPropID = 0;

	m_dwType = VT_EMPTY;
	m_pValue = NULL;       // must init to NULL
}

CProperty::CProperty(DWORD dwID, const LPVOID pValue, DWORD dwType)
{
	m_dwPropID = dwID;
	m_dwType = dwType;
	m_pValue = NULL;       // must init to NULL
	Set(dwID, pValue, dwType);
}

CProperty::~CProperty()
{
	FreeValue();
}

BOOL CProperty::Set(DWORD dwID, const LPVOID pValue, DWORD dwType)
{
	m_dwType = dwType;
	m_dwPropID = dwID;

	return Set(pValue);
}

BOOL CProperty::Set(const LPVOID pValue, DWORD dwType)
{
	m_dwType = dwType;
	return Set(pValue);
}

BOOL CProperty::Set(const  LPVOID pVal)
{
	ULONG           cb;
	ULONG           cbItem;
	ULONG           cbValue;
	ULONG           nReps;
	LPBYTE          pCur;
	LPVOID          pValue = pVal;
	DWORD           dwType = m_dwType;
	BOOL            bShouldFreeValue = FALSE;

	if (m_pValue != NULL)
	{
		FreeValue();
	}

	if (pValue == NULL || m_dwType == 0)
		return TRUE;

	// Given pValue, determine how big it is
	// Then allocate a new buffer for m_pValue and copy...
	nReps = 1;
	cbValue = 0;
	pCur = (LPBYTE)pValue;

	if (m_dwType & VT_VECTOR)
	{
		// The next DWORD is a count of the elements
		nReps = *(LPDWORD)pValue;
		cb = sizeof(nReps);
		pCur += cb;
		cbValue += cb;
		dwType &= ~VT_VECTOR;
	}
	else
	{
		// If we get any of the string-like types,
		// and we are not a vector create a count-prefixed
		// buffer.

		// flag whether or not pValue == NULL is an error
		// this occurs whenever we allocate a new pValue,
		// i.e., when we call a _AfxCountPrefixedString[A|W]()
		// this defaults to true since almost all of the cases
		// in the following switch() block will allocate.
		bool fCheckValue = true;
		switch (dwType)
		{
			case VT_LPSTR:          // null terminated string
				bShouldFreeValue = TRUE;
				pValue = _AfxCountPrefixedStringA((LPSTR)pValue);
				pCur = (LPBYTE)pValue;
				break;

			case VT_BSTR:           // binary string
			case VT_STREAM:         // Name of the stream follows
			case VT_STORAGE:        // Name of the storage follows
			case VT_STREAMED_OBJECT:// Stream contains an object
			case VT_STORED_OBJECT:  // Storage contains an object
				bShouldFreeValue = TRUE;
				pValue = _AfxCountPrefixedString((LPTSTR)pValue);
				pCur = (LPBYTE)pValue;
				break;

			case VT_LPWSTR:         // UNICODE string
				bShouldFreeValue = TRUE;
				pValue = _AfxCountPrefixedStringW((LPWSTR)pValue);
				pCur = (LPBYTE)pValue;
				break;
			default:
				// don't check, since we didn't allocate.
				fCheckValue = false;
				break;
		}
		if (fCheckValue && (!pValue)) {
			// don't have to free, since allocation failed.
			// return false since we couldn't create a count-prefixed
			// copy of the input.
			return FALSE;
		}
	}

	// Since a value can be made up of a vector (VT_VECTOR) of
	// items, we first seek through the value, picking out
	// each item, getting it's size.
	//
	cbItem = 0;        // Size of the current item
	while (nReps--)
	{
		switch (dwType)
		{
			case VT_EMPTY:          // nothing
				cbItem = 0;
				break;

			case VT_I2:             // 2 byte signed int
			case VT_BOOL:           // True=-1, False=0
				cbItem = 2;
				break;

			case VT_I4:             // 4 byte signed int
			case VT_R4:             // 4 byte real
				cbItem = 4;
				break;

			case VT_R8:             // 8 byte real
			case VT_CY:             // currency
			case VT_DATE:           // date
			case VT_I8:             // signed 64-bit int
			case VT_FILETIME:       // FILETIME
				cbItem = 8;
				break;

			case VT_CLSID:          // A Class ID
				cbItem = sizeof(CLSID);
				break;

#ifndef _UNICODE
			case VT_BSTR:           // binary string
			case VT_STREAM:         // Name of the stream follows
			case VT_STORAGE:        // Name of the storage follows
			case VT_STREAMED_OBJECT:// Stream contains an object
			case VT_STORED_OBJECT:  // Storage contains an object
			case VT_STREAMED_PROPSET:// Stream contains a propset
			case VT_STORED_PROPSET: // Storage contains a propset
#endif // _UNICODE
			case VT_LPSTR:          // null terminated string
			case VT_BLOB_OBJECT:    // Blob contains an object
			case VT_BLOB_PROPSET:   // Blob contains a propset
			case VT_BLOB:           // Length prefixed bytes
			case VT_CF:             // Clipboard format
				// Get the DWORD that gives us the size, making
				// sure we increment cbValue.
				cbItem = *(LPDWORD)pCur;
				cb = sizeof(cbItem);
				pCur += cb;
				cbValue += cb;
				break;

#ifdef _UNICODE
			case VT_BSTR:           // binary string
			case VT_STREAM:         // Name of the stream follows
			case VT_STORAGE:        // Name of the storage follows
			case VT_STREAMED_OBJECT:// Stream contains an object
			case VT_STORED_OBJECT:  // Storage contains an object
			case VT_STREAMED_PROPSET:// Stream contains a propset
			case VT_STORED_PROPSET: // Storage contains a propset
#endif // _UNICODE
			case VT_LPWSTR:         // UNICODE string
				cbItem = *(LPDWORD)pCur * ULONG(sizeof(WCHAR));
				cb = sizeof(cbItem);
				pCur += cb;
				cbValue += cb;
				break;

			default:
				//pValue may point at input param pVal or buffer allocated in _AfxCountPrefixedString.
				//Free only if was allocated by _AfxCountPrefixedString.
				if (bShouldFreeValue && pValue)
				{
					free(pValue);
				}
				return FALSE;
		}

		// Seek to the next item
		pCur += cbItem;
		cbValue += cbItem;
	}

	
	BOOL bOK=TRUE;
	if (AllocValue(cbValue))
	{
		Checked::memcpy_s(m_pValue, (size_t)cbValue, pValue, (size_t)cbValue);
	} 
	else
	{
		TRACE(traceOle, 0, "CProperty::AllocValue failed");
		bOK=FALSE;
	}

	//pValue may point at input param pVal or buffer allocated in _AfxCountPrefixedString.
	//Free only if was allocated by _AfxCountPrefixedString.
	if (bShouldFreeValue && pValue)
	{
		free(pValue);
	}				
	return bOK;
}

LPVOID CProperty::Get()
{   return Get((DWORD*)NULL);   }

LPVOID CProperty::Get(DWORD* pcb)
{
	ULONG   cbValue;
	ULONG   cbItem;
	ULONG   nReps;
	LPBYTE  pCur;
	LPBYTE  pValue = NULL;
	DWORD   dwType = m_dwType;

	pValue = (LPBYTE)m_pValue;

	nReps = 1;
	cbValue = 0;
	pCur = (LPBYTE)pValue;

	if (m_dwType & VT_VECTOR)
	{
		// Value is a DWORD count of elements followed by
		// that many repetitions of the value.
		nReps = *(LPDWORD)m_pValue;
		cbValue += sizeof(nReps);
		dwType &= ~VT_VECTOR;
		pCur += sizeof(DWORD);
	}

	// Since a value can be made up of a vector (VT_VECTOR) of
	// items, we first seek through the value, picking out
	// each item, getting it's size.
	//
	cbItem = 0;        // Size of the current item
	while (nReps--)
	{
		switch (dwType)
		{
		case VT_EMPTY:          // nothing
			cbItem = 0;
			break;

		case VT_I2:             // 2 byte signed int
		case VT_BOOL:           // True=-1, False=0
			cbItem = 2;
			break;

		case VT_I4:             // 4 byte signed int
		case VT_R4:             // 4 byte real
			cbItem = 4;
			break;

		case VT_R8:             // 8 byte real
		case VT_CY:             // currency
		case VT_DATE:           // date
		case VT_I8:             // signed 64-bit int
		case VT_FILETIME:       // FILETIME
			cbItem = 8;
			break;

		case VT_CLSID:          // A Class ID
			cbItem = sizeof(CLSID);
			break;

#ifndef _UNICODE
		case VT_BSTR:           // binary string
		case VT_STREAM:         // Name of the stream follows
		case VT_STORAGE:        // Name of the storage follows
		case VT_STREAMED_OBJECT:// Stream contains an object
		case VT_STORED_OBJECT:  // Storage contains an object
		case VT_STREAMED_PROPSET:// Stream contains a propset
		case VT_STORED_PROPSET: // Storage contains a propset
#endif // UNICODE
		case VT_LPSTR:          // null terminated string
		case VT_BLOB:           // Length prefixed bytes
		case VT_BLOB_OBJECT:    // Blob contains an object
		case VT_BLOB_PROPSET:   // Blob contains a propset
		case VT_CF:             // Clipboard format
			// Read the DWORD that gives us the size, making
			// sure we increment cbValue.
			cbItem = *(LPDWORD)pCur;
			pCur += sizeof(DWORD);
			if (m_dwType & VT_VECTOR)
			{
				cbValue += sizeof(DWORD);
			}
			if ((dwType == VT_LPSTR) && ((m_dwType & VT_VECTOR) == 0))
			{
				pValue = pCur;
			}
			break;

#ifdef _UNICODE
		case VT_BSTR:           // binary string
		case VT_STREAM:         // Name of the stream follows
		case VT_STORAGE:        // Name of the storage follows
		case VT_STREAMED_OBJECT:// Stream contains an object
		case VT_STORED_OBJECT:  // Storage contains an object
		case VT_STREAMED_PROPSET:// Stream contains a propset
		case VT_STORED_PROPSET: // Storage contains a propset
#endif // _UNICODE
		case VT_LPWSTR:         // UNICODE string
			cbItem = *(LPDWORD)pCur * ULONG(sizeof(WCHAR));
			pCur += sizeof(DWORD);
			if (m_dwType & VT_VECTOR)
			{
				cbValue += sizeof(DWORD);
			}
			if ((dwType == VT_LPWSTR) && ((m_dwType & VT_VECTOR) == 0))
			{
				pValue = pCur;
			}
			break;

		default:
			return NULL;
		}

		// Seek to the next item
		pCur += cbItem;
		cbValue += cbItem;
	}

	if (pcb != NULL)
		*pcb = cbValue;

	return pValue;
}

DWORD  CProperty::GetType()
{   return m_dwType;  }

void   CProperty::SetType(DWORD dwType)
{   m_dwType = dwType; }

DWORD CProperty::GetID()
{   return m_dwPropID;   }

void CProperty::SetID(DWORD dwPropID)
{    m_dwPropID = dwPropID;   }

LPVOID CProperty::GetRawValue()
{   return m_pValue; }

BOOL CProperty::WriteToStream(IStream* pIStream)
{
	ULONG           cb;
	ULONG           cbTotal; // Total size of the whole value
	DWORD           dwType = m_dwType;
	DWORD           nReps;
	LPBYTE          pValue;
	LPBYTE          pCur;
	BOOL            bSuccess = FALSE;
	BYTE            b = 0;

	nReps = 1;
	pValue = (LPBYTE)m_pValue;
	pCur = pValue;
	cbTotal = 0;
	if (m_dwType & VT_VECTOR)
	{
		// Value is a DWORD count of elements followed by
		// that many repititions of the value.
		//
		nReps = *(LPDWORD)pCur;
		cbTotal = sizeof(DWORD);
		pCur += cbTotal;
		dwType &= ~VT_VECTOR;
	}

#ifdef _UNICODE
	switch (dwType)
	{
		case VT_BSTR:           // binary string
		case VT_STREAM:         // Name of the stream follows
		case VT_STORAGE:        // Name of the storage follows
		case VT_STREAMED_OBJECT:// Stream contains an object
		case VT_STORED_OBJECT:  // Storage contains an object
		case VT_STREAMED_PROPSET:// Stream contains a propset
		case VT_STORED_PROPSET: // Storage contains a propset
			pValue = _AfxConvertStringProp(pCur, m_dwType, nReps, sizeof(char));
			if (m_dwType & VT_VECTOR)
				pCur = pValue + sizeof(DWORD);
			break;
	}
#endif // _UNICODE

	// Figure out how big the data is.
	while (nReps--)
	{
		switch (dwType)
		{
			case VT_EMPTY:          // nothing
				cb = 0;
				break;

			case VT_I2:             // 2 byte signed int
			case VT_BOOL:           // True=-1, False=0
				cb = 2;
				break;

			case VT_I4:             // 4 byte signed int
			case VT_R4:             // 4 byte real
				cb = 4;
				break;

			case VT_R8:             // 8 byte real
			case VT_CY:             // currency
			case VT_DATE:           // date
			case VT_I8:             // signed 64-bit int
			case VT_FILETIME:       // FILETIME
				cb = 8;
				break;

			case VT_LPSTR:          // null terminated string
			case VT_BSTR:           // binary string
			case VT_STREAM:         // Name of the stream follows
			case VT_STORAGE:        // Name of the storage follows
			case VT_STREAMED_OBJECT:// Stream contains an object
			case VT_STORED_OBJECT:  // Storage contains an object
			case VT_STREAMED_PROPSET:// Stream contains a propset
			case VT_STORED_PROPSET: // Storage contains a propset
			case VT_BLOB:           // Length prefixed bytes
			case VT_BLOB_OBJECT:    // Blob contains an object
			case VT_BLOB_PROPSET:   // Blob contains a propset
			case VT_CF:             // Clipboard format
				cb = ULONG(sizeof(DWORD)) + *(LPDWORD)pCur;
				break;

			case VT_LPWSTR:         // UNICODE string
				cb = ULONG(sizeof(DWORD)) + (*(LPDWORD)pCur * ULONG(sizeof(WCHAR)));
				break;

			case VT_CLSID:          // A Class ID
				cb = sizeof(CLSID);
				break;

			default:
				return FALSE;
		}

		pCur += cb;
		cbTotal+= cb;
	}

	// Write the type
	pIStream->Write((LPVOID)&m_dwType, sizeof(m_dwType), &cb);
	if (cb != sizeof(m_dwType))
		goto Cleanup;

	// Write the value
	pIStream->Write((LPVOID)pValue, cbTotal, &cb);
	if (cb != cbTotal)
		goto Cleanup;

	// Make sure we are 32 bit aligned
	cbTotal = (((cbTotal + 3) >> 2) << 2) - cbTotal;
	while (cbTotal--)
	{
		pIStream->Write((LPVOID)&b, 1, &cb);
		if (cb != sizeof(BYTE))
			goto Cleanup;
	}

	bSuccess = TRUE;

Cleanup:
	if (pValue != m_pValue)
		free(pValue);

	return bSuccess;
}

BOOL CProperty::ReadFromStream(IStream* pIStream)
{
	ULONG           cb;
	ULONG           cbItem;
	ULONG           cbValue;
	DWORD           dwType;
	ULONG           nReps;
	ULONG           iReps;
	LPSTREAM        pIStrItem;
	LARGE_INTEGER	li;

	// All properties are made up of a type/value pair.
	// The obvious first thing to do is to get the type...
	pIStream->Read((LPVOID)&m_dwType, sizeof(m_dwType), &cb);
	if (cb != sizeof(m_dwType))
		return FALSE;

	dwType = m_dwType;
	nReps = 1;
	cbValue = 0;
	pIStream->Clone(&pIStrItem);
	if (m_dwType & VT_VECTOR)
	{
		// The next DWORD in the stream is a count of the
		// elements
		pIStrItem->Read((LPVOID)&nReps, sizeof(nReps), &cb);
		if (cb != sizeof(nReps))
			return FALSE;
		cbValue += cb;
		dwType &= ~VT_VECTOR;
	}

	// Since a value can be made up of a vector (VT_VECTOR) of
	// items, we first seek through the value, picking out
	// each item, getting it's size.  We use a cloned
	// stream for this (pIStrItem).
	// We then use our pIStream to read the entire 'blob' into
	// the allocated buffer.
	//
	cb=0;
	cbItem = 0;        // Size of the current item
	ASSERT(pIStrItem != NULL);
	iReps = nReps;
	while (iReps--)
	{
		switch (dwType)
		{
			case VT_EMPTY:          // nothing
				cbItem = 0;
				break;

			case VT_I2:             // 2 byte signed int
			case VT_BOOL:           // True=-1, False=0
				cbItem = 2;
				break;

			case VT_I4:             // 4 byte signed int
			case VT_R4:             // 4 byte real
				cbItem = 4;
				break;

			case VT_R8:             // 8 byte real
			case VT_CY:             // currency
			case VT_DATE:           // date
			case VT_I8:             // signed 64-bit int
			case VT_FILETIME:       // FILETIME
				cbItem = 8;
				break;

			case VT_LPSTR:          // null terminated string
			case VT_BSTR:           // binary string
			case VT_STREAM:         // Name of the stream follows
			case VT_STORAGE:        // Name of the storage follows
			case VT_STREAMED_OBJECT:// Stream contains an object
			case VT_STORED_OBJECT:  // Storage contains an object
			case VT_STREAMED_PROPSET:// Stream contains a propset
			case VT_STORED_PROPSET: // Storage contains a propset
			case VT_BLOB:           // Length prefixed bytes
			case VT_BLOB_OBJECT:    // Blob contains an object
			case VT_BLOB_PROPSET:   // Blob contains a propset
			case VT_CF:             // Clipboard format
				// Read the DWORD that gives us the size, making
				// sure we increment cbValue.
				pIStrItem->Read((LPVOID)&cbItem, sizeof(cbItem), &cb);
				if (cb != sizeof(cbItem))
					return FALSE;
				li.QuadPart = -(LONG)cb;
				pIStrItem->Seek(li, STREAM_SEEK_CUR, NULL);
				cbValue += cb;
				break;

			case VT_LPWSTR:         // UNICODE string
				pIStrItem->Read((LPVOID)&cbItem, sizeof(cbItem), &cb);
				if (cb != sizeof(cbItem))
					return FALSE;
				li.QuadPart = -(LONG)cb;
				pIStrItem->Seek(li, STREAM_SEEK_CUR, NULL);
				cbValue += cb;
				cbItem *= sizeof(WCHAR);
				break;

			case VT_CLSID:          // A Class ID
				cbItem = sizeof(CLSID);
				break;

			default:
				pIStrItem->Release();
				return FALSE;
		}

		// Seek to the next item
		li.QuadPart = cbItem+cb;
		pIStrItem->Seek(li, STREAM_SEEK_CUR, NULL);
		cbValue += cbItem;
	}

	pIStrItem->Release();

#ifdef _UNICODE
	LPBYTE pTmp;

	switch (dwType)
	{
		case VT_BSTR:           // binary string
		case VT_STREAM:         // Name of the stream follows
		case VT_STORAGE:        // Name of the storage follows
		case VT_STREAMED_OBJECT:// Stream contains an object
		case VT_STORED_OBJECT:  // Storage contains an object
		case VT_STREAMED_PROPSET:// Stream contains a propset
		case VT_STORED_PROPSET: // Storage contains a propset
			pTmp = (LPBYTE)malloc((int)cbValue);
			pIStream->Read(pTmp, cbValue, &cb);
			m_pValue = _AfxConvertStringProp(pTmp, m_dwType, nReps, sizeof(WCHAR));
			free(pTmp);
			break;

		default:
#endif // _UNICODE
			// Allocate cbValue bytes
			if (NULL == AllocValue(cbValue))
				return FALSE;

			// Read the buffer from pIStream
			pIStream->Read(m_pValue, cbValue, &cb);
		  
			if (cb != cbValue)
				return FALSE;
#ifdef _UNICODE
			break;
	}
#endif // _UNICODE

	// Done!
	return TRUE;
}


LPVOID CProperty::AllocValue(ULONG cb)
{
	return m_pValue = malloc((int)cb);
}


void CProperty::FreeValue()
{
	if (m_pValue != NULL)
	{
		free(m_pValue);
		m_pValue = NULL;
	}
}

/////////////////////////////////////////////////////////////////////////////
// Implementation of the CPropertySection class

CPropertySection::CPropertySection()
{
	m_FormatID = GUID_NULL;
	m_SH.cbSection = 0;
	m_SH.cProperties = 0;
}

CPropertySection::CPropertySection(CLSID FormatID)
{
	m_FormatID = FormatID;
	m_SH.cbSection = 0;
	m_SH.cProperties = 0;
}

CPropertySection::~CPropertySection()
{
	RemoveAll();
	return;
}

CLSID CPropertySection::GetFormatID()
{   return m_FormatID; }

void CPropertySection::SetFormatID(CLSID FormatID)
{   m_FormatID = FormatID; }

BOOL CPropertySection::Set(DWORD dwPropID, LPVOID pValue, DWORD dwType)
{
	CProperty* pProp = GetProperty(dwPropID);
	if (pProp == NULL)
	{
		if ((pProp = new CProperty(dwPropID, pValue, dwType)) != NULL)
			AddProperty(pProp);
		return (pProp != NULL);
	}

	pProp->Set(dwPropID, pValue, dwType);
	return TRUE;
}

BOOL CPropertySection::Set(DWORD dwPropID, LPVOID pValue)
{
	// Since no dwType was specified, the property is assumed
	// to exist.   Fail if it does not.
	CProperty* pProp = GetProperty(dwPropID);
	if (pProp != NULL && pProp->m_dwType)
	{
		pProp->Set(dwPropID, pValue, pProp->m_dwType);
		return TRUE;
	}
	else
		return FALSE;
}

LPVOID CPropertySection::Get(DWORD dwPropID)
{   return Get(dwPropID, (DWORD*)NULL);  }

LPVOID CPropertySection::Get(DWORD dwPropID, DWORD* pcb)
{
	CProperty* pProp = GetProperty(dwPropID);
	if (pProp)
		return pProp->Get(pcb);
	else
		return NULL;
}

void CPropertySection::Remove(DWORD dwID)
{
	POSITION pos = m_PropList.GetHeadPosition();
	CProperty* pProp;
	while (pos != NULL)
	{
		POSITION posRemove = pos;
		pProp = (CProperty*)m_PropList.GetNext(pos);
		if (pProp->m_dwPropID == dwID)
		{
			m_PropList.RemoveAt(posRemove);
			delete pProp;
			m_SH.cProperties--;
			return;
		}
	}
}

void CPropertySection::RemoveAll()
{
	POSITION pos = m_PropList.GetHeadPosition();
	while (pos != NULL)
		delete (CProperty*)m_PropList.GetNext(pos);
	m_PropList.RemoveAll();
	m_SH.cProperties = 0;
}


CProperty* CPropertySection::GetProperty(DWORD dwPropID)
{
	POSITION pos = m_PropList.GetHeadPosition();
	CProperty* pProp;
	while (pos != NULL)
	{
		pProp= (CProperty*)m_PropList.GetNext(pos);
		if (pProp->m_dwPropID == dwPropID)
			return pProp;
	}
	return NULL;
}

void CPropertySection::AddProperty(CProperty* pProp)
{
	m_PropList.AddTail(pProp);
	m_SH.cProperties++;
}

DWORD CPropertySection::GetSize()
{   return m_SH.cbSection; }

DWORD CPropertySection::GetCount()
{   return (DWORD)m_PropList.GetCount();  }

CPtrList* CPropertySection::GetList()
{   return &m_PropList;  }

BOOL CPropertySection::WriteToStream(IStream* pIStream)
{
	// Create a dummy property entry for the name dictionary (ID == 0).
	Set(0, NULL, VT_EMPTY);

	ULONG           cb;
	ULARGE_INTEGER  ulSeekOld;
	ULARGE_INTEGER  ulSeek;
	LPSTREAM        pIStrPIDO;
	PROPERTYIDOFFSET  pido;
	LARGE_INTEGER		li;

	// The Section header contains the number of bytes in the
	// section.  Thus we need  to go back to where we should
	// write the count of bytes
	// after we write all the property sets..
	// We accomplish this by saving the seek pointer to where
	// the size should be written in ulSeekOld
	m_SH.cbSection = 0;
	m_SH.cProperties = (ULONG)m_PropList.GetCount();
	li.QuadPart = 0;
	pIStream->Seek(li, STREAM_SEEK_CUR, &ulSeekOld);

	pIStream->Write((LPVOID)&m_SH, sizeof(m_SH), &cb);
	if (sizeof(m_SH) != cb)
	{
		TRACE(traceOle, 0, "Write of section header failed (1).\n");
		return FALSE;
	}

	if (m_PropList.IsEmpty())
	{
		TRACE(traceOle, 0, "Warning: Wrote empty property section.\n");
		return TRUE;
	}

	// After the section header is the list of property ID/Offset pairs
	// Since there is an ID/Offset pair for each property and we
	// need to write the ID/Offset pair as we write each property
	// we clone the stream and use the clone to access the
	// table of ID/offset pairs (PIDO)...
	//
	pIStream->Clone(&pIStrPIDO);

	// Now seek pIStream past the PIDO list
	//
	li.QuadPart = m_SH.cProperties * sizeof(PROPERTYIDOFFSET);
	pIStream->Seek(li, STREAM_SEEK_CUR, &ulSeek);

	// Now write each section to pIStream.
	CProperty* pProp = NULL;
	POSITION pos = m_PropList.GetHeadPosition();
	while (pos != NULL)
	{
		// Get next element (note cast)
		pProp = (CProperty*)m_PropList.GetNext(pos);

		if (pProp->m_dwPropID != 0)
		{
			// Write it
			if (!pProp->WriteToStream(pIStream))
			{
				pIStrPIDO->Release();
				return FALSE;
			}
		}
		else
		{
			if (!WriteNameDictToStream(pIStream))
			{
				pIStrPIDO->Release();
				return FALSE;
			}
		}

		// Using our cloned stream write the Format ID / Offset pair
		// The offset to this property is the current seek pointer
		// minus the pointer to the beginning of the section
		pido.dwOffset = ulSeek.LowPart - ulSeekOld.LowPart;
		pido.propertyID = pProp->m_dwPropID;
		pIStrPIDO->Write((LPVOID)&pido, sizeof(pido), &cb);
		if (sizeof(pido) != cb)
		{
			TRACE(traceOle, 0, "Write of 'pido' failed\n");
			pIStrPIDO->Release();
			return FALSE;
		}

		// Get the seek offset after the write
		li.QuadPart = 0;
		pIStream->Seek(li, STREAM_SEEK_CUR, &ulSeek);
	}

	pIStrPIDO->Release();

	// Now go back to ulSeekOld and write the section header.
	// Size of section is current seek point minus old seek point
	//
	m_SH.cbSection = ulSeek.LowPart - ulSeekOld.LowPart;

	// Seek to beginning of this section and write the section header.
	li.QuadPart = ulSeekOld.QuadPart;
	pIStream->Seek(li, STREAM_SEEK_SET, NULL);
	pIStream->Write((LPVOID)&m_SH, sizeof(m_SH), &cb);
	if (sizeof(m_SH) != cb)
	{
		TRACE(traceOle, 0, "Write of section header failed (2).\n");
		return FALSE;
	}

	// Now seek to end of of the now written section
	li.QuadPart = ulSeek.QuadPart;
	pIStream->Seek(li, STREAM_SEEK_SET, NULL);

	return TRUE;
}

BOOL CPropertySection::ReadFromStream(IStream* pIStream,
	LARGE_INTEGER liPropSet)
{
	ULONG               cb;
	PROPERTYIDOFFSET    pido;
	ULONG               cProperties;
	LPSTREAM            pIStrPIDO;
	ULARGE_INTEGER      ulSectionStart;
	LARGE_INTEGER		li;
	CProperty*          pProp;

	if (m_SH.cProperties || !m_PropList.IsEmpty())
		RemoveAll();

	// pIStream is pointing to the beginning of the section we
	// are to read.  First there is a DWORD that is the count
	// of bytes in this section, then there is a count
	// of properties, followed by a list of propertyID/offset pairs,
	// followed by type/value pairs.
	//
	li.QuadPart = 0;
	pIStream->Seek(li, STREAM_SEEK_CUR, &ulSectionStart);
	pIStream->Read((LPVOID)&m_SH, sizeof(m_SH), &cb);
	if (cb != sizeof(m_SH))
		return FALSE;

	// Now we're pointing at the first of the PropID/Offset pairs
	// (PIDOs).   To get to each property we use a cloned stream
	// to stay back and point at the PIDOs (pIStrPIDO).  We seek
	// pIStream to each of the Type/Value pairs, creating CProperites
	// and so forth as we go...
	//
	pIStream->Clone(&pIStrPIDO);

	cProperties = m_SH.cProperties;
	while (cProperties--)
	{
		pIStrPIDO->Read((LPVOID)&pido, sizeof(pido), &cb);
		if (cb != sizeof(pido))
		{
			pIStrPIDO->Release();
			return FALSE;
		}

		// Do a seek from the beginning of the property set.
		li.QuadPart = ulSectionStart.QuadPart + pido.dwOffset;
		pIStream->Seek(liPropSet, STREAM_SEEK_SET, NULL);
		pIStream->Seek(li, STREAM_SEEK_CUR, NULL);

		// Now pIStream is at the type/value pair
		if (pido.propertyID != 0)
		{
			pProp = new CProperty(pido.propertyID, NULL, 0);
			pProp->ReadFromStream(pIStream);
			m_PropList.AddTail(pProp);
		}
		else
		{
			ReadNameDictFromStream(pIStream);
		}
	}

	pIStrPIDO->Release();

	return TRUE;
}

BOOL CPropertySection::GetID(LPCTSTR pszName, DWORD* pdwPropID)
{
	CString strName(pszName);
	strName.MakeLower();        // Dictionary stores all names in lowercase

	void* pvID;
	if (m_NameDict.Lookup(strName, pvID))
	{
		*pdwPropID = (DWORD)(DWORD_PTR)pvID;
		return TRUE;
	}

	// Failed to find entry in dictionary
	return FALSE;
}

BOOL CPropertySection::SetName(DWORD dwPropID, LPCTSTR pszName)
{
	BOOL bSuccess = TRUE;
	CString strName(pszName);
	strName.MakeLower();        // Dictionary stores all names in lowercase

	TRY
	{
		void* pDummy;
		BOOL bNameExists = m_NameDict.Lookup(strName, pDummy);

		ASSERT(!bNameExists);  // Property names must be unique.

		if (bNameExists)
			bSuccess = FALSE;
		else
			m_NameDict.SetAt(strName, (void*)(DWORD_PTR)dwPropID);
	}
	CATCH (CException, e)
	{
		TRACE(traceOle, 0, "Failed to add entry to dictionary.\n");
		bSuccess = FALSE;
	}
	END_CATCH

	return bSuccess;
}

struct DICTENTRYHEADER
{
	DWORD dwPropID;
	DWORD cb;
};

struct DICTENTRY
{
	DICTENTRYHEADER hdr;
	char sz[256];
};

BOOL CPropertySection::ReadNameDictFromStream(IStream* pIStream)
{
	ULONG cb;
	ULONG cbRead = 0;

	// Read dictionary header (count).
	ULONG cProperties = 0;
	pIStream->Read((LPVOID)&cProperties, sizeof(cProperties), &cb);
	if (sizeof(cProperties) != cb)
	{
		TRACE(traceOle, 0, "Read of dictionary header failed.\n");
		return FALSE;
	}

	ULONG iProp;
	DICTENTRY entry;

	for (iProp = 0; iProp < cProperties; iProp++)
	{
		// Read entry header (dwPropID, cch).
		if (FAILED(pIStream->Read((LPVOID)&entry, sizeof(DICTENTRYHEADER),
			&cbRead)) ||
			(sizeof(DICTENTRYHEADER) != cbRead))
		{
			TRACE(traceOle, 0, "Read of dictionary entry failed.\n");
			return FALSE;
		}

		// Read entry data (name).

		cb = entry.hdr.cb;

		if (FAILED(pIStream->Read((LPVOID)&entry.sz, cb, &cbRead)) ||
			(cbRead != cb))
		{
			TRACE(traceOle, 0, "Read of dictionary entry failed.\n");
			return FALSE;
		}

		LPTSTR pszName;

#ifdef _UNICODE
		// Persistent form is always ANSI/DBCS.  Convert to Unicode.
		WCHAR wszName[256];
		_mbstowcsz(wszName, entry.sz, 256);
		pszName = wszName;
#else // _UNICODE
		pszName = entry.sz;
#endif // _UNICODE

		// Section's "name" appears first in list and has dwPropID == 0.
		if ((iProp == 0) && (entry.hdr.dwPropID == 0))
			m_strSectionName = pszName;             // Section name
		else
			SetName(entry.hdr.dwPropID, pszName);   // Some other property
	}

	return TRUE;
}

AFX_STATIC BOOL AFXAPI _AfxWriteNameDictEntry(IStream* pIStream, DWORD dwPropID, CString& strName)
{
	ULONG cb;
	ULONG cbWritten = 0;
	DICTENTRY entry;

	entry.hdr.dwPropID = dwPropID;
	entry.hdr.cb = min(strName.GetLength() + 1, 255);
#ifdef _UNICODE
	// Persistent form is always ANSI/DBCS.  Convert from Unicode.
	_wcstombsz(entry.sz, (LPCWSTR)strName, 256);
#else // _UNICODE
	Checked::memcpy_s(entry.sz, (size_t)entry.hdr.cb, 
		(LPCSTR)strName, (size_t)entry.hdr.cb);
#endif // _UNICODE

	cb = sizeof(DICTENTRYHEADER) + entry.hdr.cb;

	if (FAILED(pIStream->Write((LPVOID)&entry, cb, &cbWritten)) ||
		(cbWritten != cb))
	{
		TRACE(traceOle, 0, "Write of dictionary entry failed.\n");
		return FALSE;
	}

	return TRUE;
}

BOOL CPropertySection::WriteNameDictToStream(IStream* pIStream)
{
	ULONG cb;

	// Write dictionary header (count).
	ULONG cProperties = (ULONG)m_NameDict.GetCount() + 1;
	pIStream->Write((LPVOID)&cProperties, sizeof(cProperties), &cb);
	if (sizeof(cProperties) != cb)
	{
		TRACE(traceOle, 0, "Write of dictionary header failed.\n");
		return FALSE;
	}

	POSITION pos;
	CString strName;
	void* pvID;

	// Write out section's "name" with dwPropID == 0 first
	if (!_AfxWriteNameDictEntry(pIStream, 0, m_strSectionName))
		return FALSE;

	// Enumerate contents of dictionary and write out (dwPropID, cb, name).
	pos = m_NameDict.GetStartPosition();
	while (pos != NULL)
	{
		m_NameDict.GetNextAssoc(pos, strName, pvID);
		if (!_AfxWriteNameDictEntry(pIStream, (DWORD)(DWORD_PTR)pvID, strName))
			return FALSE;
	}

	return TRUE;
}

BOOL CPropertySection::SetSectionName(LPCTSTR pszName)
{
	m_strSectionName = pszName;
	return TRUE;
}

LPCTSTR CPropertySection::GetSectionName()
{
	return (LPCTSTR)m_strSectionName;
}

/////////////////////////////////////////////////////////////////////////////
// Implementation of the CPropertySet class

CPropertySet::CPropertySet()
{
	m_PH.wByteOrder = 0xFFFE;
	m_PH.wFormat = 0;
	m_PH.dwOSVer = (DWORD)MAKELONG(LOWORD(GetVersion()), 2);
	m_PH.clsID =  GUID_NULL;
	m_PH.cSections = 0;

}

CPropertySet::CPropertySet(CLSID clsID)
{
	m_PH.wByteOrder = 0xFFFE;
	m_PH.wFormat = 0;
	m_PH.dwOSVer = (DWORD)MAKELONG(LOWORD(GetVersion()), 2);
	m_PH.clsID = clsID;
	m_PH.cSections = 0;
}

CPropertySet::~CPropertySet()
{   RemoveAll();  }

BOOL CPropertySet::Set(CLSID FormatID, DWORD dwPropID, LPVOID pValue, DWORD dwType)
{
	CPropertySection* pSect = GetSection(FormatID);
	if (pSect == NULL)
	{
		if ((pSect = new CPropertySection(FormatID)) != NULL)
			AddSection(pSect);
	}
	ENSURE(pSect != NULL);
	pSect->Set(dwPropID, pValue, dwType);
	return TRUE;
}

BOOL CPropertySet::Set(CLSID FormatID, DWORD dwPropID, LPVOID pValue)
{
	// Since there is no dwType, we have to assume that the property
	// already exists.  If it doesn't, fail.
	CPropertySection* pSect = GetSection(FormatID);
	if (pSect != NULL)
		return pSect->Set(dwPropID, pValue);
	else
		return FALSE;
}

LPVOID CPropertySet::Get(CLSID FormatID, DWORD dwPropID, DWORD* pcb)
{
	CPropertySection* pSect = GetSection(FormatID);
	if (pSect)
		return pSect->Get(dwPropID, pcb);
	else
		return NULL;
}

LPVOID CPropertySet::Get(CLSID FormatID, DWORD dwPropID)
{   return Get(FormatID, dwPropID, (DWORD*)NULL); }

void CPropertySet::Remove(CLSID FormatID, DWORD dwPropID)
{
	CPropertySection*  pSect = GetSection(FormatID);
	if (pSect)
		pSect->Remove(dwPropID);
}

void CPropertySet::Remove(CLSID FormatID)
{
	CPropertySection* pSect;
	POSITION posRemove = m_SectionList.GetHeadPosition();
	POSITION pos = posRemove;
	while (posRemove != NULL)
	{
		pSect = (CPropertySection*)m_SectionList.GetNext(pos);
		if (IsEqualCLSID(pSect->m_FormatID, FormatID))
		{
			m_SectionList.RemoveAt(posRemove);
			delete pSect;
			m_PH.cSections--;
			return;
		}
		posRemove = pos;
	}
}

void CPropertySet::RemoveAll()
{
	POSITION pos = m_SectionList.GetHeadPosition();
	while (pos != NULL)
	{
		delete (CPropertySection*)m_SectionList.GetNext(pos);
	}
	m_SectionList.RemoveAll();
	m_PH.cSections = 0;
}

CPropertySection* CPropertySet::GetSection(CLSID FormatID)
{
	POSITION pos = m_SectionList.GetHeadPosition();
	CPropertySection* pSect;
	while (pos != NULL)
	{
		pSect = (CPropertySection*)m_SectionList.GetNext(pos);
		if (IsEqualCLSID(pSect->m_FormatID, FormatID))
			return pSect;
	}
	return NULL;
}

CPropertySection* CPropertySet::AddSection(CLSID FormatID)
{
	CPropertySection* pSect = GetSection(FormatID);
	if (pSect)
		return pSect;

	pSect = new CPropertySection(FormatID);
	if (pSect)
		AddSection(pSect);
	return pSect;
}

void CPropertySet::AddSection(CPropertySection* pSect)
{
	m_SectionList.AddTail(pSect);
	m_PH.cSections++;
}

CProperty* CPropertySet::GetProperty(CLSID FormatID, DWORD dwPropID)
{
	CPropertySection* pSect = GetSection(FormatID);
	if (pSect)
		return pSect->GetProperty(dwPropID);
	else
		return NULL;
}

void CPropertySet::AddProperty(CLSID FormatID, CProperty* pProp)
{
	CPropertySection* pSect = GetSection(FormatID);
	if (pSect)
		pSect->AddProperty(pProp);
}

WORD CPropertySet::GetByteOrder()
{   return m_PH.wByteOrder;  }

WORD CPropertySet::GetFormatVersion()
{   return m_PH.wFormat;  }

void CPropertySet::SetFormatVersion(WORD wFmtVersion)
{   m_PH.wFormat = wFmtVersion;  }

DWORD CPropertySet::GetOSVersion()
{   return m_PH.dwOSVer;  }

void CPropertySet::SetOSVersion(DWORD dwOSVer)
{   m_PH.dwOSVer = dwOSVer;  }

CLSID CPropertySet::GetClassID()
{   return m_PH.clsID;  }

void CPropertySet::SetClassID(CLSID clsID)
{   m_PH.clsID = clsID;  }

DWORD CPropertySet::GetCount()
{   return (DWORD)m_SectionList.GetCount();  }

CPtrList* CPropertySet::GetList()
{   return &m_SectionList;  }


BOOL CPropertySet::WriteToStream(IStream* pIStream)
{
	LPSTREAM        pIStrFIDO;
	FORMATIDOFFSET  fido;
	ULONG           cb;
	ULARGE_INTEGER  ulSeek;
	LARGE_INTEGER	li;

	// Write the Property List Header
	m_PH.cSections = (DWORD)m_SectionList.GetCount();
	pIStream->Write((LPVOID)&m_PH, sizeof(m_PH), &cb);
	if (sizeof(m_PH) != cb)
	{
		TRACE(traceOle, 0, "Write of Property Set Header failed.\n");
		return FALSE;
	}

	if (m_SectionList.IsEmpty())
	{
		TRACE(traceOle, 0, "Warning: Wrote empty property set.\n");
		return TRUE;
	}

	// After the header is the list of Format ID/Offset pairs
	// Since there is an ID/Offset pair for each section and we
	// need to write the ID/Offset pair as we write each section
	// we clone the stream and use the clone to access the
	// table of ID/offset pairs (FIDO)...
	//
	pIStream->Clone(&pIStrFIDO);

	// Now seek pIStream past the FIDO list
	//
	li.QuadPart = m_PH.cSections * sizeof(FORMATIDOFFSET);
	pIStream->Seek(li, STREAM_SEEK_CUR, &ulSeek);

	// Write each section.
	CPropertySection*   pSect = NULL;
	POSITION            pos = m_SectionList.GetHeadPosition();
	while (pos != NULL)
	{
		// Get next element (note cast)
		pSect = (CPropertySection*)m_SectionList.GetNext(pos);

		// Write it
		if (!pSect->WriteToStream(pIStream))
		{
			pIStrFIDO->Release();
			return FALSE;
		}

		// Using our cloned stream write the Format ID / Offset pair
		fido.formatID = pSect->m_FormatID;
		fido.dwOffset = ulSeek.LowPart;
		pIStrFIDO->Write((LPVOID)&fido, sizeof(fido), &cb);
		if (sizeof(fido) != cb)
		{
			TRACE(traceOle, 0, "Write of 'fido' failed.\n");
			pIStrFIDO->Release();
			return FALSE;
		}

		// Get the seek offset (for pIStream) after the write
		li.QuadPart = 0;
		pIStream->Seek(li, STREAM_SEEK_CUR, &ulSeek);
	}

	pIStrFIDO->Release();

	return TRUE;
}

BOOL CPropertySet::ReadFromStream(IStream* pIStream)
{
	ULONG               cb;
	FORMATIDOFFSET      fido;
	ULONG               cSections;
	LPSTREAM            pIStrFIDO;
	CPropertySection*   pSect;
	LARGE_INTEGER		li;
	LARGE_INTEGER       liPropSet;

	// Save the stream position at which the property set starts.
	LARGE_INTEGER liZero = {0,0};
	pIStream->Seek(liZero, STREAM_SEEK_CUR, (ULARGE_INTEGER*)&liPropSet);

	if (m_PH.cSections || !m_SectionList.IsEmpty())
		 RemoveAll();

	// The stream starts like this:
	//  wByteOrder   wFmtVer   dwOSVer   clsID  cSections
	// Which is nice, because our PROPHEADER is the same!
	pIStream->Read((LPVOID)&m_PH, sizeof(m_PH), &cb);
	if (cb != sizeof(m_PH))
		return FALSE;

	// Now we're pointing at the first of the FormatID/Offset pairs
	// (FIDOs).   To get to each section we use a cloned stream
	// to stay back and point at the FIDOs (pIStrFIDO).  We seek
	// pIStream to each of the sections, creating CProperitySection
	// and so forth as we go...
	//
	pIStream->Clone(&pIStrFIDO);

	cSections = m_PH.cSections;
	while (cSections--)
	{
		pIStrFIDO->Read((LPVOID)&fido, sizeof(fido), &cb);
		if (cb != sizeof(fido))
		{
			pIStrFIDO->Release();
			return FALSE;
		}

		// Do a seek from the beginning of the property set.
		li.QuadPart = fido.dwOffset;
		pIStream->Seek(liPropSet, STREAM_SEEK_SET, NULL);
		pIStream->Seek(li, STREAM_SEEK_CUR, NULL);

		// Now pIStream is at the type/value pair
		pSect = new CPropertySection;
		pSect->SetFormatID(fido.formatID);
		pSect->ReadFromStream(pIStream, liPropSet);
		m_SectionList.AddTail(pSect);
	}

	pIStrFIDO->Release();
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// Force any extra compiler-generated code into AFX_INIT_SEG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\oletsvr.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// COleTemplateServer

COleTemplateServer::COleTemplateServer()
	: COleObjectFactory(CLSID_NULL, NULL, FALSE, NULL)
{
	m_pDocTemplate = NULL;
}

BOOL COleTemplateServer::Register()
{
	return COleObjectFactory::Register();
}

BOOL COleTemplateServer::OnCmdMsg(UINT nID, int nCode, void* pExtra,
	AFX_CMDHANDLERINFO* pHandlerInfo)
{
	BOOL bReturn;
	if (nCode == CN_OLE_UNREGISTER)
		bReturn = Unregister();
	else
		bReturn = COleObjectFactory::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);

	return bReturn;
}

BOOL COleTemplateServer::Unregister()
{
	BOOL bReturn = COleObjectFactory::Unregister();
	if (!bReturn)
		return FALSE;

	// get registration info from doc template string
	CString strServerName;
	CString strLocalServerName;
	CString strLocalShortName;

	if (!m_pDocTemplate->GetDocString(strServerName,
	   CDocTemplate::regFileTypeId) || strServerName.IsEmpty())
	{
		TRACE(traceOle, 0, "Error: not enough information in DocTemplate to unregister OLE server.\n");
		return FALSE;
	}
	if (!m_pDocTemplate->GetDocString(strLocalServerName,
	   CDocTemplate::regFileTypeName))
		strLocalServerName = strServerName;     // use non-localized name
	if (!m_pDocTemplate->GetDocString(strLocalShortName,
		CDocTemplate::fileNewName))
		strLocalShortName = strLocalServerName; // use long name

	ASSERT(strServerName.Find(' ') == -1);  // no spaces allowed

	// place entries in system registry
	if (!AfxOleUnregisterServerClass(m_clsid, strServerName,
		strLocalShortName, strLocalServerName, (OLE_APPTYPE) m_bOAT))
	{
		bReturn = FALSE;
	}

	return bReturn;
}

void COleTemplateServer::ConnectTemplate(
	REFCLSID clsid, CDocTemplate* pDocTemplate, BOOL bMultiInstance, BOOL bRegisterRichPreviewHandler)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDocTemplate);
	ASSERT(pDocTemplate->m_pAttachedFactory == NULL);

	// setup initial state of underlying COleObjectFactory
	m_clsid = clsid;
	ASSERT(m_pRuntimeClass == NULL);
	m_bMultiInstance = bMultiInstance;

	// attach the doc template to the factory
	m_pDocTemplate = pDocTemplate;
	m_pDocTemplate->m_pAttachedFactory = this;

	if (bRegisterRichPreviewHandler)
	{
		LPTSTR lpszClassID;
		LPOLESTR lpOleStr;
		::StringFromCLSID(clsid, &lpOleStr);
		lpszClassID = TASKSTRINGOLE2T(lpOleStr);
		if (lpszClassID == NULL)
		{
			TRACE(traceOle, 0, "Warning: StringFromCLSID failed in COleTemplateServer::ConnectTemplate --\n");
			TRACE(traceOle, 0, "\tperhaps AfxOleInit() has not been called.\n");
			return;
		}

		m_pDocTemplate->m_strCLSID = lpszClassID;
		m_pDocTemplate->m_clsid = clsid;

		// free memory for class ID
		ASSERT(lpszClassID != NULL);
		CoTaskMemFree(lpszClassID);
	}
}

void COleTemplateServer::UpdateRegistry(OLE_APPTYPE nAppType, 
	LPCTSTR* rglpszRegister, LPCTSTR* rglpszOverwrite, BOOL bRegister)
{
	ASSERT(m_pDocTemplate != NULL);
	ASSERT(m_bOAT == (BYTE) OAT_UNKNOWN);
	m_bOAT = (BYTE) nAppType;

	// We just want to set m_bOAT during unregistration.  Actual unregistration
	// occurs in ProcessShellCommand.
	if (FALSE == bRegister)
		return;

	// get registration info from doc template string
	CString strServerName;
	CString strLocalServerName;
	CString strLocalShortName;
	CString strLocalFilterName;
	CString strLocalFilterExt;

	if (!m_pDocTemplate->GetDocString(strServerName,
	   CDocTemplate::regFileTypeId) || strServerName.IsEmpty())
	{
		TRACE(traceOle, 0, "Error: not enough information in DocTemplate to register OLE server.\n");
		return;
	}
	if (!m_pDocTemplate->GetDocString(strLocalServerName,
	   CDocTemplate::regFileTypeName))
		strLocalServerName = strServerName;     // use non-localized name
	if (!m_pDocTemplate->GetDocString(strLocalShortName,
		CDocTemplate::fileNewName))
		strLocalShortName = strLocalServerName; // use long name
	if (!m_pDocTemplate->GetDocString(strLocalFilterName,
		CDocTemplate::filterName))
		ASSERT(nAppType != OAT_DOC_OBJECT_SERVER);
	if (!m_pDocTemplate->GetDocString(strLocalFilterExt,
		CDocTemplate::filterExt))
		ASSERT(nAppType != OAT_DOC_OBJECT_SERVER);

	ASSERT(strServerName.Find(' ') == -1);  // no spaces allowed

	int nIconIndex = 0;
	POSITION pos = AfxGetApp()->GetFirstDocTemplatePosition();
	for (int nIndex = 1; pos != NULL; nIndex++)
	{
		CDocTemplate* pTemplate = AfxGetApp()->GetNextDocTemplate(pos);
		if (pTemplate == m_pDocTemplate)
		{
			nIconIndex = nIndex;
			pos = NULL; // set exit condition
		}
	}

	// place entries in system registry
	if (!AfxOleRegisterServerClass(m_clsid, strServerName,
		strLocalShortName, strLocalServerName, nAppType,
		rglpszRegister, rglpszOverwrite, nIconIndex,
		strLocalFilterName, strLocalFilterExt))
	{
		// not fatal (don't fail just warn)
		AfxMessageBox(AFX_IDP_FAILED_TO_AUTO_REGISTER);
	}
}

CCmdTarget* COleTemplateServer::OnCreateObject()
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pDocTemplate);

	// save application user control status
	BOOL bUserCtrl = AfxOleGetUserCtrl();

	// create invisible doc/view/frame set
	CDocument* pDoc = m_pDocTemplate->OpenDocumentFile(NULL, FALSE, FALSE);

	// restore application's user control status
	AfxOleSetUserCtrl(bUserCtrl);

	if (pDoc != NULL)
	{
		ASSERT_VALID(pDoc);
		ASSERT_KINDOF(CDocument, pDoc);

		// all new documents created by OLE start out modified
		pDoc->SetModifiedFlag();
	}
	return pDoc;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\olereg.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include <shellapi.h>



#define new DEBUG_NEW

// from docmgr.cpp
extern BOOL AFXAPI _AfxDeleteRegKey(LPCTSTR lpszKey);


//////////////////////////////////////////////////////////////////////////////
// data for UpdateRegistry functionality

// %1 - class ID
// %2 - class name
// %3 - SFN executable path
// %4 - short type name
// %5 - long type name
// %6 - long application name
// %7 - icon index
// %8 - Creator(xxxxxxxx) [mac-only]
// %8 - File extension Description [non-mac only]
// %9 - (not used yet) [mac-only]
// %9 - File extension *.TLA [non-mac only]
// %A - (not used yet)
#define NUM_REG_VARS 10

class _AFX_OLESYMBOLTABLE
{
protected:
	LPTSTR* m_strEntries;
	int m_nEntries;

public:
	_AFX_OLESYMBOLTABLE(int nEntries);
	~_AFX_OLESYMBOLTABLE();

	LPCTSTR* GetArray() { return (LPCTSTR*) m_strEntries; }
	LPCTSTR GetAt(int nIndex) const;
	void SetAt(int nIndex, LPCTSTR pstr);
	LPCTSTR operator[](int nIndex) const { return GetAt(nIndex); }
};

_AFX_OLESYMBOLTABLE::_AFX_OLESYMBOLTABLE(int nEntries)
{
	m_strEntries = new LPTSTR[nEntries];
	memset(m_strEntries, 0, sizeof(LPTSTR) * nEntries);
	m_nEntries = nEntries;
}

_AFX_OLESYMBOLTABLE::~_AFX_OLESYMBOLTABLE()
{
	int nIndex;
	for (nIndex = 0; nIndex < m_nEntries; nIndex++)
		free(m_strEntries[nIndex]);
	delete [] m_strEntries;
}

void _AFX_OLESYMBOLTABLE::SetAt(int nIndex, LPCTSTR pstr)
{
	ASSERT(nIndex < m_nEntries && nIndex >= 0);

	free(m_strEntries[nIndex]);
	m_strEntries[nIndex] = pstr ? _tcsdup(pstr) : NULL;
}

LPCTSTR _AFX_OLESYMBOLTABLE::GetAt(int nIndex) const
{
	if (nIndex < m_nEntries || nIndex < 0)
		return m_strEntries[nIndex];
	else
		return NULL;
}

static const TCHAR sz00[] = _T("%2\0") _T("%5");
static const TCHAR sz01[] = _T("%2\\CLSID\0") _T("%1");
static const TCHAR sz02[] = _T("%2\\Insertable\0") _T("");
static const TCHAR sz03[] = _T("%2\\protocol\\StdFileEditing\\verb\\0\0") _T("&Edit");
static const TCHAR sz04[] = _T("%2\\protocol\\StdFileEditing\\server\0") _T("%3");
static const TCHAR sz05[] = _T("CLSID\\%1\0") _T("%5");
static const TCHAR sz06[] = _T("CLSID\\%1\\ProgID\0") _T("%2");
static const TCHAR sz07[] = _T("CLSID\\%1\\InprocHandler32\0") _T("ole32.dll");
static const TCHAR sz08[] = _T("CLSID\\%1\\LocalServer32\0") _T("%3");
static const TCHAR sz09[] = _T("CLSID\\%1\\Verb\\0\0") _T("&Edit,0,2");
static const TCHAR sz10[] = _T("CLSID\\%1\\Verb\\1\0") _T("&Open,0,2");
static const TCHAR sz11[] = _T("CLSID\\%1\\Insertable\0") _T("");
static const TCHAR sz12[] = _T("CLSID\\%1\\AuxUserType\\2\0") _T("%4");
static const TCHAR sz13[] = _T("CLSID\\%1\\AuxUserType\\3\0") _T("%6");
static const TCHAR sz14[] = _T("CLSID\\%1\\DefaultIcon\0") _T("%3,%7");
static const TCHAR sz15[] = _T("CLSID\\%1\\MiscStatus\0") _T("32");
static const TCHAR sz16[] = _T("\0") _T("");
static const TCHAR sz17[] = _T("CLSID\\%1\\InProcServer32\0") _T("%3");
static const TCHAR sz18[] = _T("CLSID\\%1\\DocObject\0" _T("0")); // CLSIDDocObject
static const TCHAR sz19[] = _T("%2\\DocObject\0" _T("0")); // ProgIDDocObject
static const TCHAR sz20[] = _T("CLSID\\%1\\Printable\0"); // szPrintable
static const TCHAR sz21[] = _T("CLSID\\%1\\DefaultExtension\0%9, %8"); // szDefaultExt

// registration for OAT_INPLACE_SERVER
static const LPCTSTR rglpszInPlaceRegister[] =
{
	sz00, sz02, sz03, sz05, sz09, sz10, sz11, sz12,
	sz13, sz15,
	NULL
};

// registration for OAT_SERVER
static const LPCTSTR rglpszServerRegister[] =
{
	sz00, sz02, sz03, sz05, sz09, sz11, sz12,
	sz13, sz15,
	NULL
};

// registration for OAT_DOC_OBJECT_SERVER
static const LPCTSTR rglpszDocObjectRegister[] =
{
	sz00, sz02, sz03, sz05, sz09, sz10, sz11, sz12,
	sz13, sz15, sz18, sz19, sz20,
	NULL
};

// overwrite entries for OAT_SERVER & OAT_INPLACE_SERVER
static const LPCTSTR rglpszServerOverwrite[] =
{
	sz01, sz04, sz06, sz07, sz08, sz14, NULL
};
// overwrite entries for OAT_SERVER & OAT_INPLACE_SERVER (dll)
static const LPCTSTR rglpszServerOverwriteDLL[] =
{
	sz01, sz04, sz06,
	sz17,
	sz14,
	NULL
};

// registration for OAT_CONTAINER
static const LPCTSTR rglpszContainerRegister[] =
{
	sz00, sz05, NULL
};
// overwrite entries for OAT_CONTAINER
static const LPCTSTR rglpszContainerOverwrite[] =
{
	sz01, sz06, sz07, sz08, sz14, NULL
};

// registration for OAT_DISPATCH_OBJECT
static const LPCTSTR rglpszDispatchRegister[] =
{
	sz00, sz05, NULL
};
// overwrite entries for OAT_DISPATCH_OBJECT
static const LPCTSTR rglpszDispatchOverwrite[] =
{
	sz01, sz06, sz07, sz08, NULL
};
// overwrite entries for OAT_DISPATCH_OBJECT (dll)
static const LPCTSTR rglpszDispatchOverwriteDLL[] =
{
	sz01, sz06,
	sz17,
	NULL
};

// overwrite entries for OAT_DOC_OBJECT_SERVER
static const LPCTSTR rglpszDocObjectOverwrite[] =
{
	sz01, sz04, sz06, sz07, sz08, sz14, sz21,
	NULL
};

struct STANDARD_ENTRY
{
	const LPCTSTR* rglpszRegister;
	const LPCTSTR* rglpszOverwrite;
};

static const STANDARD_ENTRY rgStdEntries[] =
{
	{ rglpszInPlaceRegister, rglpszServerOverwrite },
	{ rglpszServerRegister, rglpszServerOverwrite },
	{ rglpszContainerRegister, rglpszContainerOverwrite },
	{ rglpszDispatchRegister, rglpszDispatchOverwrite },
	{ rglpszDocObjectRegister, rglpszDocObjectOverwrite },
};

static const STANDARD_ENTRY rgStdEntriesDLL[] =
{
	{ rglpszInPlaceRegister, rglpszServerOverwriteDLL },
	{ rglpszServerRegister, rglpszServerOverwriteDLL },
	{ rglpszContainerRegister, rglpszContainerOverwrite },
	{ rglpszDispatchRegister, rglpszDispatchOverwriteDLL },
	{ rglpszDocObjectRegister, rglpszDocObjectOverwrite },
};

/////////////////////////////////////////////////////////////////////////////
// Special registration for apps that wish not to use REGLOAD

AFX_STATIC BOOL AFXAPI _AfxOleMakeSymbolTable(_AFX_OLESYMBOLTABLE& refTable,
	REFCLSID clsid, LPCTSTR lpszClassName, LPCTSTR lpszShortTypeName,
	LPCTSTR lpszLongTypeName, int nIconIndex,
	LPCTSTR lpszFilterName, LPCTSTR lpszFilterExt)
{
	// 0 - class ID
	// 1 - class name
	// 2 - SFN executable path
	// 3 - short type name
	// 4 - long type name
	// 5 - long application name
	// 6 - icon index
	// 7 - Creator(xxxxxxxx) [Mac only]
	// 8 - Creator(xxxxxxxx) [mac-only]
	// 9 - Filter description

	// convert the CLSID to a string
	LPTSTR lpszClassID;
	LPOLESTR lpOleStr;
	::StringFromCLSID(clsid, &lpOleStr);
	lpszClassID = TASKSTRINGOLE2T(lpOleStr);
	if (lpszClassID == NULL)
	{
		TRACE(traceOle, 0, "Warning: StringFromCLSID failed in AfxOleRegisterServerName --\n");
		TRACE(traceOle, 0, "\tperhaps AfxOleInit() has not been called.\n");
		return FALSE;
	}
	refTable.SetAt(0, lpszClassID);
	refTable.SetAt(1, lpszClassName);

	// free memory for class ID
	ASSERT(lpszClassID != NULL);
	CoTaskMemFree(lpszClassID);

	// get path name to server
	CString strPathName;
	AfxGetModuleFileName(AfxGetInstanceHandle(), strPathName);
	refTable.SetAt(2, strPathName);

	// fill in rest of symbols
	refTable.SetAt(3, lpszShortTypeName);
	refTable.SetAt(4, lpszLongTypeName);
	refTable.SetAt(5, AfxGetAppName()); // will usually be long, readable name

	CString strIconIndex;
	if (nIconIndex != 0)
	{
		HICON hIcon = ::ExtractIcon(AfxGetInstanceHandle(), strPathName, nIconIndex);
		if (hIcon != NULL)
			DestroyIcon(hIcon);
		else
			nIconIndex = 0; // couldn't find specified icon so use default
	}
	strIconIndex.Format(_T("%d"), nIconIndex);
	refTable.SetAt(6, strIconIndex);

	refTable.SetAt(7, lpszFilterName);

	CString strFileExtension;
	if (lpszFilterExt != NULL && *lpszFilterExt != 0)
	{
		// use file extension provided
		strFileExtension = lpszFilterExt;
	}
	else
	{
		// otherwise, try to find the extension from the description

		// parse the actual extension (eg "*.TLA") from the
		// filter name (eg, "Three Letter Acronym Files (*.TLA)")

		strFileExtension = lpszFilterName;
		int nBeginning = strFileExtension.Find('(');
		if (nBeginning == -1)
			strFileExtension.Empty();
		else
		{
			strFileExtension = strFileExtension.Mid(1+nBeginning);
			nBeginning = strFileExtension.Find('.');
			if (nBeginning == -1)
				strFileExtension.Empty();
			else
			{
				strFileExtension = strFileExtension.Mid(nBeginning);

				int nEnd = strFileExtension.Find(')');
				if (nEnd == -1)
					strFileExtension.Empty();
				else
					strFileExtension = strFileExtension.Left(nEnd);
			}
		}
	}
	refTable.SetAt(8, strFileExtension);
	return TRUE;
}

BOOL AFXAPI AfxOleRegisterServerClass(
	REFCLSID clsid, LPCTSTR lpszClassName, LPCTSTR lpszShortTypeName,
	LPCTSTR lpszLongTypeName, OLE_APPTYPE nAppType, LPCTSTR* rglpszRegister,
	LPCTSTR* rglpszOverwrite, int nIconIndex,
	LPCTSTR lpszFilterName)
{
	return AfxOleRegisterServerClass(clsid, lpszClassName, lpszShortTypeName,
		lpszLongTypeName, nAppType, rglpszRegister, rglpszOverwrite, nIconIndex,
		lpszFilterName, NULL);
}


BOOL AFXAPI AfxOleRegisterServerClass(
	REFCLSID clsid, LPCTSTR lpszClassName, LPCTSTR lpszShortTypeName,
	LPCTSTR lpszLongTypeName, OLE_APPTYPE nAppType, LPCTSTR* rglpszRegister,
	LPCTSTR* rglpszOverwrite, int nIconIndex,
	LPCTSTR lpszFilterName, LPCTSTR lpszFilterExt)
{
	ASSERT(AfxIsValidString(lpszClassName));
	ASSERT(AfxIsValidString(lpszShortTypeName));
	ASSERT(*lpszShortTypeName != 0);
	ASSERT(AfxIsValidString(lpszLongTypeName));
	ASSERT(*lpszLongTypeName != 0);
	ASSERT(nAppType == OAT_INPLACE_SERVER || nAppType == OAT_SERVER ||
		nAppType == OAT_CONTAINER || nAppType == OAT_DISPATCH_OBJECT ||
		nAppType == OAT_DOC_OBJECT_SERVER);
	ASSERT(nAppType >= 0 && nAppType < _countof(rgStdEntries));

	// use standard registration entries if non given
	if (rglpszRegister == NULL)
		rglpszRegister = (LPCTSTR*)rgStdEntries[nAppType].rglpszRegister;
	if (rglpszOverwrite == NULL)
	{
		// DLL contexts have special strings
		if (!afxContextIsDLL)
			rglpszOverwrite = (LPCTSTR*)rgStdEntries[nAppType].rglpszOverwrite;
		else
			rglpszOverwrite = (LPCTSTR*)rgStdEntriesDLL[nAppType].rglpszOverwrite;
	}

	_AFX_OLESYMBOLTABLE table(NUM_REG_VARS);

	if (!_AfxOleMakeSymbolTable(table, clsid, lpszClassName,
				lpszShortTypeName, lpszLongTypeName,
				nIconIndex, lpszFilterName, lpszFilterExt))
	{
		return FALSE;
	}

	// protect against registering an invalid DocObject server
	ASSERT(nAppType != OAT_DOC_OBJECT_SERVER ||
		(lstrlen(table.GetAt(8)) != 0 && lstrcmp(table.GetAt(8), _T(".*")) != 0));

	// update the registry with helper function
	BOOL bResult;
	bResult = AfxOleRegisterHelper(rglpszRegister, table.GetArray(),
		NUM_REG_VARS, FALSE);
	if (bResult && rglpszOverwrite != NULL)
	{
		bResult = AfxOleRegisterHelper(rglpszOverwrite, table.GetArray(),
			NUM_REG_VARS, TRUE);
	}

	// free memory for class ID
	return bResult;
}

BOOL AFXAPI AfxOleUnregisterServerClass(
	REFCLSID clsid, LPCTSTR lpszClassName, LPCTSTR lpszShortTypeName,
	LPCTSTR lpszLongTypeName, OLE_APPTYPE nAppType, LPCTSTR* rglpszRegister,
	LPCTSTR* rglpszOverwrite)
{
	if (nAppType < 0 || nAppType >= _countof(rgStdEntries))
	{
		return FALSE;
	}
	// use standard registration entries if non given
	if (rglpszRegister == NULL)
		rglpszRegister = (LPCTSTR*)rgStdEntries[nAppType].rglpszRegister;
	if (rglpszOverwrite == NULL)
	{
		// DLL contexts have special strings
		if (!afxContextIsDLL)
			rglpszOverwrite = (LPCTSTR*)rgStdEntries[nAppType].rglpszOverwrite;
		else
			rglpszOverwrite = (LPCTSTR*)rgStdEntriesDLL[nAppType].rglpszOverwrite;
	}

	_AFX_OLESYMBOLTABLE table(NUM_REG_VARS);

	if (!_AfxOleMakeSymbolTable(table, clsid, lpszClassName, lpszShortTypeName, lpszLongTypeName, 0, NULL, NULL))
	{
		return FALSE;
	}

	// clean up the the registry with helper function
	BOOL bResult;
	bResult = AfxOleUnregisterHelper(rglpszRegister, table.GetArray(), NUM_REG_VARS);
	if (bResult && rglpszOverwrite != NULL)
	{
		bResult = AfxOleUnregisterHelper(rglpszOverwrite, table.GetArray(), NUM_REG_VARS);
	}

	return bResult;
}

// removes key/value pairs from system registry
BOOL AFXAPI AfxOleUnregisterHelper(LPCTSTR const* rglpszRegister,
	LPCTSTR const* rglpszSymbols, int nSymbols,
	HKEY hKeyRoot /* = HKEY_CLASSES_ROOT */)
{
	ASSERT(rglpszRegister != NULL);
	ASSERT(nSymbols == 0 || rglpszSymbols != NULL);

	CString strKey;
	CString strValue;

	// keeping a key open makes this go a bit faster
	HKEY hKeyTemp = NULL;
	if (hKeyRoot == HKEY_CLASSES_ROOT)
	{
		AfxRegOpenKeyEx(HKEY_CLASSES_ROOT, _T("CLSID"), 0, KEY_READ, &hKeyTemp);
	}
	::ATL::CRegKey rkTemp(hKeyTemp);

	BOOL bResult = TRUE;
	while (*rglpszRegister != NULL)
	{
		LPCTSTR lpszKey = *rglpszRegister++;
		if ((hKeyRoot == HKEY_CLASSES_ROOT) && (*lpszKey == '\0'))
			continue;

		AfxFormatStrings(strKey, lpszKey, rglpszSymbols, nSymbols);

		if ((hKeyRoot == HKEY_CLASSES_ROOT) && strKey.IsEmpty())
		{
			TRACE(traceOle, 0, _T("Warning: skipping empty key '%s'.\n"), lpszKey);
			continue;
		}

		_AfxDeleteRegKey(strKey);
	}

	return bResult;
}

// writes key/value pairs to system registry
BOOL AFXAPI AfxOleRegisterHelper(LPCTSTR const* rglpszRegister,
	LPCTSTR const* rglpszSymbols, int nSymbols, BOOL bReplace,
	HKEY hKeyRoot /* = HKEY_CLASSES_ROOT */)
{
	ASSERT(rglpszRegister != NULL);
	ASSERT(nSymbols == 0 || rglpszSymbols != NULL);

	CString strKey;
	CString strValue;

	// keeping a key open makes this go a bit faster
	HKEY hKeyTemp = NULL;
	if (hKeyRoot == HKEY_CLASSES_ROOT)
	{
		AfxRegOpenKeyEx(HKEY_CLASSES_ROOT, _T("CLSID"), 0, KEY_READ, &hKeyTemp);
	}
	::ATL::CRegKey rkTemp(hKeyTemp);

	BOOL bResult = TRUE;
	while (*rglpszRegister != NULL)
	{
		LPCTSTR lpszKey = *rglpszRegister++;
		if ((hKeyRoot == HKEY_CLASSES_ROOT) && (*lpszKey == '\0'))
			continue;

		LPCTSTR lpszValue = lpszKey + lstrlen(lpszKey) + 1;

		AfxFormatStrings(strKey, lpszKey, rglpszSymbols, nSymbols);
		AfxFormatStrings(strValue, lpszValue, rglpszSymbols, nSymbols);

		if ((hKeyRoot == HKEY_CLASSES_ROOT) && strKey.IsEmpty())
		{
			TRACE(traceOle, 0, _T("Warning: skipping empty key '%s'.\n"), lpszKey);
			continue;
		}

		if (!bReplace)
		{
			TCHAR szBuffer[256];
			LONG lSize = sizeof(szBuffer);
			if (AfxRegQueryValue(hKeyRoot, strKey, szBuffer, &lSize) == ERROR_SUCCESS)
			{
#ifdef _DEBUG
				if (strValue != szBuffer)
				{
					TRACE(traceOle, 0, _T("Warning: Leaving value '%s' for key '%s' in registry\n"), szBuffer, (LPCTSTR)strKey);
					TRACE(traceOle, 0, _T("\tintended value was '%s'.\n"), (LPCTSTR)strValue);
				}
#endif
				continue;
			}
		}

		LONG lResult = AfxRegSetValue(hKeyRoot, strKey, REG_SZ, strValue, lstrlen(strValue) * sizeof(TCHAR));
		if(lResult != ERROR_SUCCESS)
		{
			TRACE(traceOle, 0, _T("Error: failed setting key '%s' to value '%s'.\n"), (LPCTSTR)strKey, (LPCTSTR)strValue);

			if(lResult != ERROR_ACCESS_DENIED)
			{
				bResult = FALSE;
			}
			break;
		}
	}

	return bResult;
}

AFX_STATIC_DATA const TCHAR _afxPreviewHostCLSID [] = _T("{8895b1c6-b41f-4c1c-a562-0d564250836f}");
AFX_STATIC_DATA const TCHAR _afxThumbnailHostCLSID [] = _T("{E357FCCD-A995-4576-B01F-234630154E96}");
AFX_STATIC_DATA const TCHAR _afxPreviewHandlersRegPath [] = _T("Software\\Microsoft\\Windows\\CurrentVersion\\PreviewHandlers");
AFX_STATIC_DATA const TCHAR _afxShellExFormat [] = _T("%s\\ShellEx\\%s");
AFX_STATIC_DATA const TCHAR _afxTreatmentValueName [] = _T("Treatment");

BOOL AFXAPI AfxRegisterPreviewHandler(LPCTSTR lpszCLSID, LPCTSTR lpszShortTypeName, LPCTSTR lpszFilterExt)
{
	CString strData = lpszShortTypeName;
	strData.Append(_T(" Preview Handler"));

	CRegKey regPreviewHandlersKey(HKEY_LOCAL_MACHINE);
	regPreviewHandlersKey.Create(HKEY_LOCAL_MACHINE, _afxPreviewHandlersRegPath);

	if (regPreviewHandlersKey.SetStringValue(lpszCLSID, strData) != ERROR_SUCCESS)
	{
		TRACE(traceOle, 0, _T("Error: failed setting value '%s' for key HKEY_LOCAL_MACHINE\\'%s'.\n"), lpszCLSID, _afxPreviewHandlersRegPath);
		return FALSE;
	}

	CString strShellExKey;
	strShellExKey.Format(_afxShellExFormat, lpszFilterExt, _afxPreviewHostCLSID);

	CRegKey regKey(HKEY_CLASSES_ROOT);
	regKey.Create(HKEY_CLASSES_ROOT, strShellExKey);

	if (regKey.SetValue(NULL, REG_SZ, (LPCVOID)lpszCLSID, (ULONG)(_tcslen(lpszCLSID) * sizeof(TCHAR))) != ERROR_SUCCESS)
	{
		TRACE(traceOle, 0, _T("Error: failed setting value '%s' for key HKEY_CLASSES_ROOT\\'%s'.\n"), lpszCLSID, strShellExKey);
		return FALSE;
	}

	return TRUE;
}
BOOL AFXAPI AfxUnRegisterPreviewHandler(LPCTSTR lpszCLSID)
{
	CRegKey regKey(HKEY_LOCAL_MACHINE);
	if (regKey.Open (HKEY_LOCAL_MACHINE, _afxPreviewHandlersRegPath) == ERROR_SUCCESS)
	{
		regKey.DeleteValue (lpszCLSID);
		regKey.Close();
	}
	
	if (regKey.Open(HKEY_CLASSES_ROOT, _T("CLSID")) == ERROR_SUCCESS)
	{
		regKey.RecurseDeleteKey(lpszCLSID);
		regKey.Close();
	}

	return TRUE;
}

BOOL AFXAPI AfxRegisterThumbnailHandler(LPCTSTR lpszCLSID, LPCTSTR lpszFilterExt, DWORD nTreatment)
{
	CString strShellExKey;
	strShellExKey.Format(_afxShellExFormat, lpszFilterExt, _afxThumbnailHostCLSID);

	CRegKey regKey(HKEY_CLASSES_ROOT);
	regKey.Create(HKEY_CLASSES_ROOT, strShellExKey);

	if (regKey.SetValue(NULL, REG_SZ, (LPCVOID) lpszCLSID, (ULONG)(_tcslen(lpszCLSID) * sizeof(TCHAR))) != ERROR_SUCCESS)
	{
		TRACE(traceOle, 0, _T("Error: failed setting value '%s' for key HKEY_CLASSES_ROOT\\'%s'.\n"), lpszCLSID, strShellExKey);
		return FALSE;
	}
	else
	{
		regKey.Close ();
		regKey.Open(HKEY_CLASSES_ROOT, lpszFilterExt);
		// set Treatment value - default to 1. Other possible values advanced users can set calling this method directly
		regKey.SetValue(_T("Treatment"), REG_DWORD, (LPVOID)&nTreatment, sizeof(DWORD));
	}

	return TRUE;
}

static TCHAR szApartment[] = _T("Apartment");
static TCHAR szBoth[] = _T("Both");
static TCHAR szFree[] = _T("Free");

BOOL AFXAPI AfxOleInprocRegisterHelper(HKEY hkeyProgID,
	HKEY hkeyClassID, int nRegFlags)
{
	BOOL bSuccess = TRUE;

	if (nRegFlags & afxRegInsertable)
	{
		ASSERT(hkeyProgID != NULL);
		::ATL::CRegKey hkeyProgIDInsertable;
		::ATL::CRegKey hkeyClassIDInsertable;
		bSuccess =
			(hkeyProgIDInsertable.Create(hkeyProgID, _T("Insertable"), NULL, 0, KEY_READ | KEY_WRITE, NULL, NULL) == ERROR_SUCCESS) &&
			(hkeyClassIDInsertable.Create(hkeyClassID, _T("Insertable"), NULL, 0, KEY_READ | KEY_WRITE, NULL, NULL) == ERROR_SUCCESS);
	}
	if (!bSuccess)
		goto Error;

	LPTSTR pstrThreadingModel = NULL;

	if (nRegFlags & afxRegApartmentThreading)
		pstrThreadingModel = szApartment;

	if (nRegFlags & afxRegFreeThreading)
		pstrThreadingModel = szFree;

	if ((nRegFlags & (afxRegFreeThreading | afxRegApartmentThreading)) ==
			(afxRegFreeThreading | afxRegApartmentThreading))
	{
		pstrThreadingModel = szBoth;
	}

	if (pstrThreadingModel != NULL)
	{
		HKEY hkeyInprocServer32;
		bSuccess = (::RegOpenKeyExW(hkeyClassID, L"InprocServer32", 0, KEY_WRITE,
			&hkeyInprocServer32) == ERROR_SUCCESS);
		if (bSuccess)
		{
			ASSERT(hkeyInprocServer32 != NULL);
			bSuccess = (::RegSetValueEx(hkeyInprocServer32, _T("ThreadingModel"), 0,
				REG_SZ, (const BYTE*) pstrThreadingModel, 
				(lstrlen(pstrThreadingModel)+1) * sizeof(TCHAR)) == ERROR_SUCCESS);
			::RegCloseKey(hkeyInprocServer32);
		}
		else
		{
			if (!afxContextIsDLL)
			{
				bSuccess = TRUE; //ignore failure to find InprocServer32 in exe context.
			}
		}
	}
	if (bSuccess)
	{
		return TRUE;
	}
Error:
	// Cleanup any values set in the registry
	if (nRegFlags & afxRegInsertable)
	{
		RegDeleteKey(hkeyClassID, _T("Insertable"));
		RegDeleteKey(hkeyProgID, _T("Insertable"));
	}
	return bSuccess;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\olesvr1.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include <shellapi.h>



#define new DEBUG_NEW

//////////////////////////////////////////////////////////////////////////////
// COleServerDoc implementation

COleServerDoc::COleServerDoc()
{
	m_lpClientSite = NULL;  // will be non-NULL when document is embedding
	m_bCntrVisible = FALSE;
	m_pInPlaceFrame = NULL; // will be non-NULL when in-place active
	m_pOrigParent = NULL;
	m_dwOrigStyle = 0;
	m_dwOrigStyleEx = 0;
	m_bClosing = FALSE;
	m_pEmbeddedItem = NULL; // will be non-NULL if embedded item needed
	m_pDocObjectServer = NULL;      // becomes non-NULL if DocObject support enabled
}

COleServerDoc::~COleServerDoc()
{
	DeleteContents();   // Note: will not call derived class

	if (m_pEmbeddedItem != NULL)
	{
		m_pEmbeddedItem->ExternalRelease();
		m_pEmbeddedItem = NULL;
	}

	// disconnect (remove) all items from the document
	POSITION pos = GetStartPosition();
	COleServerItem* pItem;
	while ((pItem = GetNextServerItem(pos)) != NULL)
		RemoveItem(pItem);

	// release doc object manager, if any
	if (m_pDocObjectServer != NULL)
	{
		delete m_pDocObjectServer;
		m_pDocObjectServer = NULL;
	}

	// should not be in-place active when doc is destroyed!
	ASSERT(m_pInPlaceFrame == NULL);

	// Note: this must be done before the client site is released
	RELEASE(m_lpRootStg);

	// release client-site pointer
	RELEASE(m_lpClientSite);
}

void COleServerDoc::DeleteContents()
{
	COleLinkingDoc::DeleteContents();

	// protect all server items with an extra reference count
	POSITION pos = GetStartPosition();
	COleServerItem* pItem;
	while ((pItem = GetNextServerItem(pos)) != NULL)
		pItem->InternalAddRef();

	// delete any autodelete server items
	pos = GetStartPosition();
	while ((pItem = GetNextServerItem(pos)) != NULL)
	{
		if (pItem->m_bAutoDelete)
			delete pItem;
	}

	// remove extra reference added above
	pos = GetStartPosition();
	while ((pItem = GetNextServerItem(pos)) != NULL)
		pItem->InternalRelease();
}

COleServerItem* COleServerDoc::GetEmbeddedItem()
{
	// allocate embedded item if necessary
	if (m_pEmbeddedItem == NULL)
	{
		m_pEmbeddedItem = OnGetEmbeddedItem();
		m_pEmbeddedItem->ExternalAddRef();
	}

	ASSERT_VALID(m_pEmbeddedItem);
	return m_pEmbeddedItem;
}

CDocObjectServer* COleServerDoc::GetDocObjectServer(LPOLEDOCUMENTSITE pDocSite)
{
	// by default, we're not DocObject enabled
	UNUSED_ALWAYS(pDocSite);
	return NULL;
}

HRESULT COleServerDoc::OnExecOleCmd(const GUID* pguidCmdGroup, DWORD nCmdID,
		DWORD nCmdExecOpt, VARIANTARG* pvarargIn, VARIANTARG* pvarargOut)
{
	UNUSED_ALWAYS(pguidCmdGroup);
	UNUSED_ALWAYS(nCmdID);
	UNUSED_ALWAYS(nCmdExecOpt);
	UNUSED_ALWAYS(pvarargIn);
	UNUSED_ALWAYS(pvarargOut);

	return E_NOTIMPL;
}

LPUNKNOWN COleServerDoc::GetInterfaceHook(const void* piid)
{
	LPUNKNOWN lpUnk = NULL;

	// are we Doc Object supporters?
	if (m_pDocObjectServer != NULL)
	{
		// don't be tricked into handing out a different IUnknown
		DWORD lData1 = ((IID*)piid)->Data1;
		BOOL bUnknown = ((DWORD*)&IID_IUnknown)[0] == lData1 &&
			((DWORD*)piid)[1] == ((DWORD*)&IID_IUnknown)[1] &&
			((DWORD*)piid)[2] == ((DWORD*)&IID_IUnknown)[2] &&
			((DWORD*)piid)[3] == ((DWORD*)&IID_IUnknown)[3];

		if (bUnknown)
			return NULL;

		lpUnk = m_pDocObjectServer->GetInterface(piid);
	}

	// failing that, try the base class
	if (lpUnk == NULL)
		lpUnk = COleLinkingDoc::GetInterfaceHook(piid);

	return lpUnk;
}

void COleServerDoc::ActivateDocObject()
{
	if (m_pDocObjectServer != NULL)
		m_pDocObjectServer->ActivateDocObject();
}

/////////////////////////////////////////////////////////////////////////////
// COleServerDoc client notifications

void COleServerDoc::NotifyRename(LPCTSTR lpszNewName)
{
	ASSERT_VALID(this);
	ASSERT(AfxIsValidString(lpszNewName));

	if (m_pFactory != NULL)
	{
		// update running object table with new moniker
		Revoke();
		Register(m_pFactory, lpszNewName);

		// notify all items of the new moniker
		POSITION pos = GetStartPosition();
		COleServerItem* pItem;
		while ((pItem = GetNextServerItem(pos)) != NULL)
		{
			// notify client directly
			LPMONIKER lpMoniker = pItem->GetMoniker(OLEGETMONIKER_ONLYIFTHERE);
			pItem->NotifyClient(OLE_RENAMED, reinterpret_cast<DWORD_PTR>(lpMoniker));
			RELEASE(lpMoniker);
		}
	}
}

void COleServerDoc::NotifyAllItems(OLE_NOTIFICATION nCode, DWORD_PTR dwParam)
{
	ASSERT_VALID(this);

	POSITION pos = GetStartPosition();
	COleServerItem* pItem;
	while ((pItem = GetNextServerItem(pos)) != NULL)
	{
		// notify client directly
		pItem->NotifyClient(nCode, dwParam);
	}
}

// UpdateAllItems is much like UpdateAllViews, but for server items
void COleServerDoc::UpdateAllItems(COleServerItem* pSender,
	LPARAM lHint, CObject* pHint, DVASPECT nDrawAspect)
{
	ASSERT_VALID(this);

	POSITION pos = GetStartPosition();
	COleServerItem* pItem;
	while ((pItem = GetNextServerItem(pos)) != NULL)
	{
		// notify client indirectly through OnUpdate
		if (pItem != pSender)
			pItem->OnUpdate(pSender, lHint, pHint, nDrawAspect);
	}
}

void COleServerItem::OnUpdate(COleServerItem* /*pSender*/,
	LPARAM /*lHint*/, CObject* /*pHint*/, DVASPECT nDrawAspect)
{
	// the default implementation always notifies the container, regardless
	//  of the specific hint or sender.

	NotifyChanged(nDrawAspect);
}

/////////////////////////////////////////////////////////////////////////////
// COleServerDoc attributes

BOOL COleServerDoc::GetZoomFactor(LPSIZE lpSizeNum, LPSIZE lpSizeDenom,
	LPCRECT lpPosRect) const
{
	ASSERT_VALID(this);
	ASSERT(lpSizeNum == NULL || AfxIsValidAddress(lpSizeNum, sizeof(SIZE)));
	ASSERT(lpSizeDenom == NULL || AfxIsValidAddress(lpSizeDenom, sizeof(SIZE)));
	ASSERT(lpPosRect == NULL ||
		AfxIsValidAddress(lpPosRect, sizeof(RECT), FALSE));

	if (!IsInPlaceActive())
	{
		if (lpSizeNum != NULL)
		{
			ASSERT(lpSizeDenom != NULL);
			lpSizeNum->cx = 1;
			lpSizeNum->cy = 1;
			*lpSizeDenom = *lpSizeNum;
		}
		return FALSE;
	}
	ASSERT_VALID(m_pInPlaceFrame);

	// the zoom factor is (Size(position-rect) / m_sizeExtent)
	CSize sizeNum;
	if (lpPosRect == NULL)
	{
		// use current position rect
		sizeNum = m_pInPlaceFrame->m_rectPos.Size();
	}
	else
	{
		// use new position rect
		sizeNum.cx = lpPosRect->right - lpPosRect->left;
		sizeNum.cy = lpPosRect->bottom - lpPosRect->top;
	}

	// m_sizeExtent is in HIMETRIC units -- need to convert to pixels.
	CSize sizeDenom(0, 0);
	COleServerItem* pItem = ((COleServerDoc*)this)->GetEmbeddedItem();
	ASSERT_VALID(pItem);
	ASSERT_KINDOF(COleServerItem, pItem);

	// get zoom denominator, which is based on the current extent
	((COleServerItem*)pItem)->OnGetExtent(DVASPECT_CONTENT, sizeDenom);
	if (sizeDenom.cx == 0 || sizeDenom.cy == 0)
	{
		// no extent from container available, so use natural extent instead
		pItem->OnGetExtent(DVASPECT_CONTENT, sizeDenom);
	}
	// convert extent to pixels first
	((CDC*)NULL)->HIMETRICtoDP(&sizeDenom);

	// might be bad to have zoom denominator of zero!
	if (sizeDenom.cy == 0 || sizeDenom.cx == 0)
	{
		TRACE(traceOle, 0, "Warning: zero 'zoom denominator', using 100%% zoom instead.\n");
		sizeDenom = sizeNum;
	}

	// store the results
	if (lpSizeNum != NULL)
	{
		ASSERT(lpSizeDenom != NULL);
		*lpSizeNum = sizeNum;
		*lpSizeDenom = sizeDenom;
	}

	// if 100% scaling, return FALSE
	return sizeNum != sizeDenom;
}

void COleServerDoc::GetItemPosition(LPRECT lpPosRect) const
{
	ASSERT_VALID(this);
	ASSERT(AfxIsValidAddress(lpPosRect, sizeof(RECT)));
	ASSERT(IsInPlaceActive());
	ASSERT_VALID(m_pInPlaceFrame);

	// copy the current rectangle
	*lpPosRect = m_pInPlaceFrame->m_rectPos;
}

void COleServerDoc::GetItemClipRect(LPRECT lpClipRect) const
{
	ASSERT_VALID(this);
	ASSERT(AfxIsValidAddress(lpClipRect, sizeof(RECT)));
	ASSERT(IsInPlaceActive());
	ASSERT_VALID(m_pInPlaceFrame);

	// copy the current rectangle
	*lpClipRect = m_pInPlaceFrame->m_rectClip;
}

/////////////////////////////////////////////////////////////////////////////
// COleServerDoc overrideables

COleServerItem* COleServerDoc::OnGetLinkedItem(LPCTSTR lpszItemName)
{
	ASSERT_VALID(this);
	ASSERT(AfxIsValidString(lpszItemName));

	// default implementation walks list of server items looking for
	//  a case sensitive match

	POSITION pos = GetStartPosition();
	COleServerItem* pItem;
	while ((pItem = GetNextServerItem(pos)) != NULL)
	{
		// return item if name matches (case sensitive)
		if (lstrcmp(pItem->GetItemName(), lpszItemName) == 0)
			return pItem;
	}

	TRACE(traceOle, 1, "Warning: default COleServerDoc::OnGetLinkedItem implementation\n");
	TRACE(traceOle, 1, _T("\tfailed to find item '%s'.\n"), lpszItemName);

	return NULL;        // not found (no link found)
}

void COleServerDoc::OnClose(OLECLOSE dwCloseOption)
{
	ASSERT_VALID(this);

	// do nothing if already in the process of closing the document
	if (m_bClosing)
		return;

	// OLECLOSE_PROMPTSAVE is handled like OLECLOSE_SAVEIFDIRTY if invisible
	CFrameWnd* pFrameWnd = GetFirstFrame();
	if (pFrameWnd != NULL && pFrameWnd->IsWindowVisible())
		dwCloseOption = OLECLOSE_SAVEIFDIRTY;

	// handle modified document and special dwCloseOption flags
	TRY
	{
		if (IsModified())
		{
			switch (dwCloseOption)
			{
			case OLECLOSE_PROMPTSAVE:
				if (!SaveModifiedPrompt())
					AfxThrowOleException(OLE_E_PROMPTSAVECANCELLED);
				break;

			case OLECLOSE_SAVEIFDIRTY:
				SaveEmbedding();
				break;
			}
		}
	}
	END_TRY

	// deactivate in-place session
	if (m_pInPlaceFrame != NULL)
	{
		OnDeactivate();
		ASSERT(m_pInPlaceFrame == NULL);
	}

	// close the document
	BOOL bAutoDelete = m_bAutoDelete;
	m_bAutoDelete = FALSE;
	OnCloseDocument();
	m_bAutoDelete = bAutoDelete;
}

BOOL COleServerDoc::SaveModifiedPrompt()
{
	ASSERT_VALID(this);

	if (m_lpClientSite == NULL)
		return SaveModified();

	UpdateModifiedFlag();   // check for modified client items

	if (!IsModified())
		return TRUE;        // ok to continue

	CString prompt;
	AfxFormatString1(prompt, AFX_IDP_ASK_TO_UPDATE, m_strTitle);
	switch (AfxMessageBox(prompt, MB_YESNOCANCEL, AFX_IDP_ASK_TO_UPDATE))
	{
	case IDCANCEL:
		return FALSE;       // don't continue

	case IDYES:
		if (!OnUpdateDocument())
		{
			TRACE(traceOle, 0, "Warning: OnUpdateDocument failed to update.\n");
			// keep going, close will flush it
		}
		break;
	}
	return TRUE;    // keep going
}

BOOL COleServerDoc::CanCloseFrame(CFrameWnd* pFrame)
{
	m_bClosing = TRUE;
	if (!COleLinkingDoc::CanCloseFrame(pFrame))
	{
		m_bClosing = FALSE;
		return FALSE;
	}
	return TRUE;
}

BOOL COleServerDoc::GetFileTypeString(CString& rString)
{
	ASSERT_VALID(this);

	CDocTemplate* pTemplate = GetDocTemplate();
	if (pTemplate == NULL)
		return FALSE;

	pTemplate->GetDocString(rString, CDocTemplate::fileNewName);
	return !rString.IsEmpty();
}

void COleServerDoc::OnSetHostNames(LPCTSTR lpszHost, LPCTSTR lpszHostObj)
{
	ASSERT_VALID(this);
	ASSERT(lpszHost == NULL || AfxIsValidString(lpszHost));
	ASSERT(lpszHostObj == NULL || AfxIsValidString(lpszHostObj));
	UNUSED(lpszHost);    // unused in release builds

	// only change the title for embedded documents
	if (m_lpClientSite != NULL)
	{
		// save name of document for File.Exit update
		if (lpszHostObj == NULL)
			m_strHostObj.LoadString(AFX_IDS_UNTITLED);
		else
			m_strHostObj = lpszHostObj;

		// attempt to get the document name from the document template
		CString strFileType;
		if (!GetFileTypeString(strFileType))
			return;

		// format the string into <server-name> in <docname>
		CString strTitle;
		AfxFormatString2(strTitle, AFX_IDS_APP_TITLE_EMBEDDING,
			strFileType, m_strHostObj);

		// change title of document to that for an embedded item
		//  (this call will update all of the frames)
		SetTitle(strTitle);
	}
}

void COleServerDoc::SaveEmbedding()
{
	ASSERT_VALID(this);

	// tell the client site to save the object
	if (m_lpClientSite != NULL && !::InSendMessage())
	{
		SCODE sc = m_lpClientSite->SaveObject();
		if (sc != S_OK)
			AfxThrowOleException(sc);
	}
	ASSERT_VALID(this);
}

BOOL COleServerDoc::OnUpdateDocument()
{
	ASSERT_VALID(this);

	// don't save if already up-to-date
	if (!IsModified())
		return TRUE;

	// save a server document -> update
	TRY
	{
		SaveEmbedding();
	}
	CATCH_ALL(e)
	{
		AfxMessageBox(AFX_IDP_FAILED_TO_UPDATE);
		DELETE_EXCEPTION(e);
		return FALSE;
	}
	END_CATCH_ALL

	return TRUE;
}

LPMONIKER COleServerDoc::GetMoniker(OLEGETMONIKER nAssign)
{
	ASSERT_VALID(this);

	if (m_lpClientSite != NULL)
	{
		// get moniker from client site instead of from document
		LPMONIKER lpMoniker = NULL;
		m_lpClientSite->GetMoniker(nAssign, OLEWHICHMK_OBJFULL, &lpMoniker);
		return lpMoniker;
	}

	return COleLinkingDoc::GetMoniker(nAssign);
}

/////////////////////////////////////////////////////////////////////////////
// COleServerDoc document handling

BOOL COleServerDoc::SaveModified()
{
	ASSERT_VALID(this);

	if (m_lpClientSite != NULL)
	{
		if (m_pInPlaceFrame == NULL)
		{
			UpdateModifiedFlag();   // check for modified items
			OnUpdateDocument();
		}
		return TRUE;
	}
	return COleLinkingDoc::SaveModified();
}

HMENU COleServerDoc::GetDefaultMenu()
{
	ASSERT_VALID(this);

	CDocTemplate* pTemplate = GetDocTemplate();
	if (pTemplate == NULL)
		return NULL;    // no doc template -- use default

	ASSERT_VALID(pTemplate);
	if (m_pInPlaceFrame != NULL)
		return pTemplate->m_hMenuInPlaceServer; // return special in-place menu
	else if (m_lpClientSite != NULL)
		return pTemplate->m_hMenuEmbedding; // return special embedding menu

	return NULL;    // no special mode, use default menu
}

HACCEL COleServerDoc::GetDefaultAccelerator()
{
	ASSERT_VALID(this);

	CDocTemplate* pTemplate = GetDocTemplate();
	if (pTemplate == NULL)
		return NULL;    // no doc template -- use default

	ASSERT_VALID(pTemplate);
	if (m_pInPlaceFrame != NULL)
		return pTemplate->m_hAccelInPlaceServer;    // return special in-place accel
	else if (m_lpClientSite != NULL)
		return pTemplate->m_hAccelEmbedding;// return special embedding accel

	return NULL;    // no special mode, use default menu
}

/////////////////////////////////////////////////////////////////////////////
// COleServerDoc default command handling

BEGIN_MESSAGE_MAP(COleServerDoc, COleLinkingDoc)
	//{{AFX_MSG_MAP(COleServerDoc)
	ON_COMMAND(ID_FILE_UPDATE, &COleServerDoc::OnFileUpdate)
	ON_COMMAND(ID_FILE_SAVE_COPY_AS, &COleServerDoc::OnFileSaveCopyAs)
	ON_UPDATE_COMMAND_UI(ID_APP_EXIT, &COleServerDoc::OnUpdateFileExit)
	ON_UPDATE_COMMAND_UI(ID_FILE_UPDATE, &COleServerDoc::OnUpdateFileUpdate)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void COleServerDoc::OnFileUpdate()
{
	ASSERT_VALID(this);
	ASSERT(m_lpClientSite != NULL);

	UpdateModifiedFlag();
	OnUpdateDocument();
}

void COleServerDoc::OnFileSaveCopyAs()
{
	ASSERT_VALID(this);
	ASSERT(m_bRemember);
	ASSERT(m_lpClientSite != NULL);

	LPSTORAGE lpOrigStg = m_lpRootStg;
	m_lpRootStg = NULL; // ignore embedded storage for now

	TRY
	{
		// call DoSave to perform Save Copy As...
		m_bRemember = FALSE;
		DoSave(NULL, FALSE);
	}
	END_TRY

	m_lpRootStg = lpOrigStg;
	m_bRemember = TRUE;
}

void COleServerDoc::UpdateUsingHostObj(UINT nIDS, CCmdUI* pCmdUI)
{
	ASSERT_VALID(this);
	ASSERT(pCmdUI != NULL);

	if (m_lpClientSite == NULL)
		return;

	// update menu item using m_strHostObj
	CString str;
	AfxFormatString1(str, nIDS, m_strHostObj);
	if (!str.IsEmpty())
		pCmdUI->SetText(str);
}

void COleServerDoc::OnUpdateFileExit(CCmdUI* pCmdUI)
{
	ASSERT_VALID(this);
	ASSERT(pCmdUI != NULL);

	UpdateUsingHostObj(AFX_IDS_EXIT_MENU, pCmdUI);
}

void COleServerDoc::OnUpdateFileUpdate(CCmdUI* pCmdUI)
{
	ASSERT_VALID(this);
	ASSERT(pCmdUI != NULL);

	UpdateUsingHostObj(AFX_IDS_UPDATE_MENU, pCmdUI);
}

BOOL COleServerDoc::OnSaveDocument(LPCTSTR lpszPathName)
{
	ASSERT_VALID(this);
	ASSERT(lpszPathName == NULL || AfxIsValidString(lpszPathName));

	BOOL bModified = IsModified();
	BOOL bRemember = m_bRemember;
	if (!COleLinkingDoc::OnSaveDocument(lpszPathName))
		return FALSE;

	if (!bRemember)
		SetModifiedFlag(bModified);

	if (lpszPathName != NULL && bRemember)
	{
		if (AfxComparePath(GetPathName(), lpszPathName))
			NotifySaved();
	}
	return TRUE;
}

void COleServerDoc::OnCloseDocument()
{
	ASSERT_VALID(this);

	// SO handler (rich preview) can be destroyed only from FinalRelease 
	if (IsSearchAndOrganizeHandler() && !m_bFinalRelease)
	{
		return;
	}

	// don't allow in-place active documents to be closed without first
	//  deactivating them!
	if (m_pInPlaceFrame != NULL)
	{
		if (GetFirstViewPosition() != NULL)
			return;

		// no views but currently in-place active indicates that
		//  a WM_ENDSESSION is being processed.
		m_pInPlaceFrame = NULL;
	}

	InternalAddRef();   // keep document stable during shutdown

	// update lock count before sending notifications
	UpdateVisibleLock(FALSE, FALSE);

	// send some notifications to the container
	if (m_lpClientSite != NULL && m_bCntrVisible)
	{
		// allow the container to unshade the object appropriately
		m_lpClientSite->OnShowWindow(FALSE);
		m_bCntrVisible = FALSE;
	}

	// send close notification
	NotifyClosed();

	// finish closing the document (before m_lpClientSite->Release)
	BOOL bAutoDelete = m_bAutoDelete;
	m_bAutoDelete = FALSE;
	COleLinkingDoc::OnCloseDocument();
	ASSERT_VALID(this);

	// release client-site pointer
	RELEASE(m_lpClientSite);

	// disconnect the object
	LPUNKNOWN lpUnknown = (LPUNKNOWN)GetInterface(&IID_IUnknown);
	ASSERT(lpUnknown != NULL);
	CoDisconnectObject(lpUnknown, 0);

	// destroy the document if allowed
	InterlockedDecrement(&m_dwRef);              // remove InternalAddRef above
	if (bAutoDelete)
		delete this;
}

/////////////////////////////////////////////////////////////////////////////
// COleServerDoc show/hide

void COleServerDoc::OnShowDocument(BOOL bShow)
{
	ASSERT_VALID(this);

	CWinApp* pApp = AfxGetApp();
	if (bShow)
	{
		// deactivate in-place session if active
		if (m_pInPlaceFrame != NULL)
		{
			OnDeactivate();
			ASSERT(m_pInPlaceFrame == NULL);
		}

		// find the first view of this document
		CFrameWnd* pFrameWnd;
		if ((pFrameWnd = GetFirstFrame()) != NULL)
		{
			// allow container to show & scroll to the object
			if (!pFrameWnd->IsWindowVisible() && m_lpClientSite != NULL)
				m_lpClientSite->ShowObject();

			// activate frame holding view
			ASSERT_VALID(pFrameWnd);
			pFrameWnd->ActivateFrame();

			// activate application if necessary
			CFrameWnd* pAppFrame = pFrameWnd->GetParentFrame();
			if (pAppFrame != NULL)
			{
				pFrameWnd = pAppFrame;
				ASSERT_VALID(pFrameWnd);
				ASSERT_KINDOF(CFrameWnd, pFrameWnd);
				pFrameWnd->ActivateFrame();
			}
			pFrameWnd->GetLastActivePopup()->SetForegroundWindow();

			// update the menu and title as appropriate for this document
			pFrameWnd->OnUpdateFrameMenu(NULL);
			pFrameWnd->OnUpdateFrameTitle(TRUE);
		}
		else if (pApp->m_pMainWnd != NULL)
		{
			// otherwise, just show the main window (for simple servers)
			CWnd* pWnd = AfxGetMainWnd();

			// allow container to show & scroll to the object
			if (!pWnd->IsWindowVisible() && m_lpClientSite != NULL)
				m_lpClientSite->ShowObject();

			pWnd->ShowWindow(SW_SHOW);
			pWnd->SetActiveWindow();
			pWnd->SetForegroundWindow();
		}

		// for file based documents, showing the document puts user in control.
		if (!m_bEmbedded)
			AfxOleSetUserCtrl(TRUE);
	}
	else
	{
		if (m_pInPlaceFrame != NULL)
		{
			// hide has semantics of DeactivateUI if the item is active
			if (m_pInPlaceFrame->m_bUIActive)
				OnDeactivateUI(FALSE);

			// and then hide the frame itself
			if (m_pInPlaceFrame != NULL)
				m_pInPlaceFrame->ActivateFrame(SW_HIDE);
			return;
		}

		// find the first view of this document
		POSITION pos = GetFirstViewPosition();
		if (pos != NULL)
		{
			CFrameWnd* pDocFrame = GetFirstFrame();
			CFrameWnd* pActiveFrame = NULL;
			CFrameWnd* pMainFrame = NULL;
			CView* pView = GetNextView(pos);
			ASSERT_VALID(pView);

			// destroy or hide all the frames for this document
			//  (the main for the document is hidden, where the alternate
			//   frames are simply destroyed)
			do
			{
				// hide frame holding view
				CFrameWnd* pFrame = pView->EnsureParentFrame();

				// determine next valid view before destroying the frame
				while ((pView = GetNextView(pos)) != NULL)
				{
					if (pView->GetParentFrame() != pFrame)
						break;
				}

				pMainFrame = pFrame->GetParentFrame();
				if (pMainFrame != NULL && pMainFrame->GetActiveFrame() == pFrame)
				{
					// don't destroy the active frame until later
					pActiveFrame = pFrame;
				}
				else
				{
					// not the active frame -- destroy/hide it now
					PreCloseFrame(pFrame);
					if (pDocFrame == pFrame)
						pFrame->ActivateFrame(SW_HIDE);
					else
						pFrame->DestroyWindow();
				}

			} while (pView != NULL);

			// hide the active frame last
			if (pActiveFrame != NULL)
			{
				PreCloseFrame(pActiveFrame);
				if (pDocFrame == pActiveFrame)
					pActiveFrame->ActivateFrame(SW_HIDE);
				else
					pActiveFrame->DestroyWindow();

				// should leave at least one frame
				ASSERT_VALID(this);
				ASSERT_VALID(GetFirstFrame());
			}
		}

		CFrameWnd* pMainFrame = (CFrameWnd*)pApp->m_pMainWnd;
		if (!AfxOleGetUserCtrl() && pMainFrame != NULL &&
			pMainFrame->IsWindowEnabled() && pMainFrame->IsFrameWnd() &&
			pMainFrame->GetActiveFrame() == pMainFrame)
		{
			// hide the entire application -- no visible documents left
			pApp->HideApplication();
		}
	}

	// send OnShowWindow notifications to the container
	if (m_lpClientSite != NULL && (bShow || m_bCntrVisible != bShow))
	{
		// allow the container to shade the object appropriately
		m_lpClientSite->OnShowWindow(bShow);
		m_bCntrVisible = bShow;
	}

	// force update visible lock
	if (bShow)
		UpdateVisibleLock(TRUE, FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// COleServerDoc storage implementation

void COleServerDoc::OnNewEmbedding(LPSTORAGE lpStorage)
{
	ASSERT_VALID(this);
	ASSERT(lpStorage != NULL);

	// save state
	BOOL bUserCtrl = AfxOleGetUserCtrl();

	TRY
	{
		// remember new storage
		DeleteContents();
		lpStorage->AddRef();
		RELEASE(m_lpRootStg);
		m_lpRootStg = lpStorage;
		m_strPathName.Empty();
		m_bEmbedded = TRUE;

		// do document initialization by calling OnNewDocument
		if (!OnNewDocument())
			AfxThrowMemoryException();
	}
	CATCH_ALL(e)
	{
		// restore state
		AfxOleSetUserCtrl(bUserCtrl);
		THROW_LAST();
	}
	END_CATCH_ALL

	// restore state
	AfxOleSetUserCtrl(bUserCtrl);

	SetModifiedFlag();  // new storage-based documents are dirty!
	SendInitialUpdate();
}

void COleServerDoc::OnOpenEmbedding(LPSTORAGE lpStorage)
{
	ASSERT_VALID(this);
	ASSERT(lpStorage != NULL);

	// save state
	BOOL bUserCtrl = AfxOleGetUserCtrl();

	TRY
	{
		// abort changes to current document
		DeleteContents();
		lpStorage->AddRef();
		RELEASE(m_lpRootStg);
		m_lpRootStg = lpStorage;

		// open document from the sub-storage
		if (!OnOpenDocument(NULL))
			AfxThrowMemoryException();

		// now document is storage based
		m_strPathName.Empty();
		m_bEmbedded = TRUE;
	}
	CATCH_ALL(e)
	{
		// restore state
		AfxOleSetUserCtrl(bUserCtrl);
		THROW_LAST();
	}
	END_CATCH_ALL

	// restore state
	AfxOleSetUserCtrl(bUserCtrl);

	SetModifiedFlag(FALSE); // start off with unmodified
	SendInitialUpdate();
}

void COleServerDoc::OnSaveEmbedding(LPSTORAGE lpStorage)
{
	ASSERT_VALID(this);
	ASSERT(lpStorage != NULL);

	// save state
	BOOL bUserCtrl = AfxOleGetUserCtrl();

	// check for save as
	LPSTORAGE lpOrigStg = m_lpRootStg;
	if (!m_bSameAsLoad)
	{
		// File Save[Copy] As (saving to different file)
		ASSERT(lpStorage != NULL);
		m_lpRootStg = lpStorage;
	}

	TRY
	{
		// save document to the sub-storage
		if (!OnSaveDocument(NULL))
			AfxThrowMemoryException();
	}
	CATCH_ALL(e)
	{
		// restore state
		AfxOleSetUserCtrl(bUserCtrl);
		// re-attach original storage
		m_lpRootStg = lpOrigStg;
		THROW_LAST();
	}
	END_CATCH_ALL

	// restore state
	AfxOleSetUserCtrl(bUserCtrl);

	// re-attach original storage
	m_lpRootStg = lpOrigStg;
}

/////////////////////////////////////////////////////////////////////////////
// COleServerDoc in-place activation implementation

AFX_STATIC HWND AFXAPI _AfxGetWindow32(HWND hWnd)
{
	// don't bother if hWnd is already a 32-bit HWND
	if (DWORD_PTR(hWnd) > 0xffff)
		return hWnd;

	// otherwise convert by getting a DC...
	HDC hDC = ::GetDC(hWnd);
	if (hDC == NULL)
		return hWnd;

	// then, getting the HWND from the DC...
	HWND hWnd32 = ::WindowFromDC(hDC);
	if (hWnd32 == NULL)
		hWnd32 = hWnd;

	// then releasing the DC itself
	::ReleaseDC(hWnd, hDC);

	return hWnd32;  // return full 32-bit HWND
}

BOOL COleServerDoc::ActivateInPlace()
{
	ASSERT_VALID(this);
	if (m_lpClientSite == NULL)
		return FALSE;   // no client-side (may be a link)

	// activate already in-place window if currently in-place active
	if (m_pInPlaceFrame != NULL)
	{
		if (m_pInPlaceFrame->m_bUIActive)
		{
			m_lpClientSite->ShowObject();   // object should get focus
			return TRUE;
		}
		// deactivate in-place session entirely before continuing
		OnDeactivate();
	}

	// fail if already fully open
	CFrameWnd *pFirstFrameWnd=GetFirstFrame();
	ENSURE(pFirstFrameWnd);
	if (pFirstFrameWnd->IsWindowVisible())
		return FALSE;

	// build object title/name (the container may use this in its caption)
	CString strFileType, strTitle;
	CStringW strTitleW;
	if (!GetFileTypeString(strFileType))
		return FALSE;
	AfxFormatString2(strTitle, AFX_IDS_OBJ_TITLE_INPLACE,
		AfxGetAppName(), strFileType);

	// attempt to get in-place client-site interface
	LPOLEINPLACESITE lpInPlaceSite =
		QUERYINTERFACE(m_lpClientSite, IOleInPlaceSite);
	if (lpInPlaceSite == NULL)
	{
		// unable to get in-place client site interface
		return FALSE;
	}

	// see if the container wants to go in-place right now
	if (lpInPlaceSite->CanInPlaceActivate() != S_OK)
		goto ReleaseAndFail;

	// start activation sequence...

	if (lpInPlaceSite->OnInPlaceActivate() != S_OK)
		goto ReleaseAndFail;

	// we'll need the parent window to create the COleIPFrameWnd
	HWND hWnd;
	VERIFY(lpInPlaceSite->GetWindow(&hWnd) == S_OK);
	CWnd* pParentWnd;
	pParentWnd = CWnd::FromHandle(hWnd);

	// create the inplace frame window
	COleIPFrameWnd* pFrameWnd;
	pFrameWnd = CreateInPlaceFrame(pParentWnd);
	if (pFrameWnd == NULL)
	{
		ASSERT(lpInPlaceSite != NULL);
		lpInPlaceSite->OnInPlaceDeactivate();
		goto ReleaseAndFail;
	}
	ASSERT(pFrameWnd->GetParent() == pParentWnd);
	m_pInPlaceFrame = pFrameWnd;

	// send activate notification.
	if (lpInPlaceSite->OnUIActivate() != S_OK)
		goto DestroyFrameAndFail;

	// need to get frame & doc window interfaces as well as other info
	RECT rcPosRect, rcClipRect;
	if (lpInPlaceSite->GetWindowContext(
		&pFrameWnd->m_lpFrame, &pFrameWnd->m_lpDocFrame,
		&rcPosRect, &rcClipRect, &pFrameWnd->m_frameInfo) != S_OK)
	{
		goto DeactivateUIAndFail;
	}
	ASSERT(pFrameWnd->m_lpFrame != NULL);

	// setup the shared menu
	if (!pFrameWnd->BuildSharedMenu())
		goto DeactivateUIAndFail;

	// allow server to install frame controls in container
	VERIFY(pFrameWnd->m_lpFrame->GetWindow(&hWnd) == S_OK);

	// some containers (Works 4.0, for example) return only the lower
	// 16-bits of the HWND and that confuses us; to work around this
	// we convert the 16-bit HWND into the full 32-bit HWND.
	hWnd = _AfxGetWindow32(hWnd);

	pFrameWnd->m_pMainFrame = new COleCntrFrameWnd(pFrameWnd);
	pFrameWnd->m_pMainFrame->Attach(hWnd);
	if (pFrameWnd->m_lpDocFrame != NULL)
	{
		HWND hWndDocument;
		VERIFY(pFrameWnd->m_lpDocFrame->GetWindow(&hWndDocument) == S_OK);
		if (hWndDocument != hWnd)
		{
			pFrameWnd->m_pDocFrame = new COleCntrFrameWnd(pFrameWnd);
			pFrameWnd->m_pDocFrame->Attach(hWndDocument);
		}
		else
		{
			RELEASE(pFrameWnd->m_lpDocFrame);
			pFrameWnd->m_lpDocFrame = NULL;
		}
	}

	// update zoom factor information before creating control bars

	// some clients send an empty rectangle and expect the
	// server to use the ClipRect for the PosRect
	if (IsRectEmpty(&rcPosRect))
		pFrameWnd->m_rectPos.CopyRect(&rcClipRect);
	else
		pFrameWnd->m_rectPos.CopyRect(&rcPosRect);
	pFrameWnd->m_rectClip.CopyRect(&rcClipRect);

	if (!pFrameWnd->OnCreateControlBars(pFrameWnd->m_pMainFrame,
		pFrameWnd->m_pDocFrame))
	{
		goto DeactivateUIAndFail;
	}

	// resize the window to match the object

	// some clients send an empty rectangle and expect the
	// server to use the ClipRect for the PosRect
	if (IsRectEmpty(&rcPosRect))
		OnSetItemRects(&rcClipRect, &rcClipRect);
	else
		OnSetItemRects(&rcPosRect, &rcClipRect);

	// set the active object
	ASSERT(pFrameWnd->m_lpFrame != NULL);
	LPOLEINPLACEACTIVEOBJECT lpActiveObject;
	lpActiveObject = (LPOLEINPLACEACTIVEOBJECT)
		GetInterface(&IID_IOleInPlaceActiveObject);
	strTitleW = strTitle;
	pFrameWnd->m_lpFrame->SetActiveObject(lpActiveObject, strTitleW.GetString());
	if (pFrameWnd->m_lpDocFrame != NULL)
		pFrameWnd->m_lpDocFrame->SetActiveObject(lpActiveObject, strTitleW);

	// add frame & document level frame controls
	ASSERT(m_pInPlaceFrame->m_lpFrame != NULL);
	OnShowControlBars(m_pInPlaceFrame->m_pMainFrame, TRUE);
	if (m_pInPlaceFrame->m_lpDocFrame != NULL)
		OnShowControlBars(m_pInPlaceFrame->m_pDocFrame, TRUE);

	// show any hidden modeless dialogs as well...
	m_pInPlaceFrame->ShowOwnedWindows(TRUE);

	// attempt toolbar negotiation
	OnResizeBorder(NULL, pFrameWnd->m_lpFrame, TRUE);
	if (pFrameWnd->m_lpDocFrame != NULL)
		OnResizeBorder(NULL, pFrameWnd->m_lpDocFrame, FALSE);

	// install the menu (also installs a hook which forwards messages from
	//  the menu to the inplace frame window)
	pFrameWnd->m_lpFrame->SetMenu(pFrameWnd->m_hSharedMenu,
		pFrameWnd->m_hOleMenu, pFrameWnd->m_hWnd);

	// make sure object is scrolled into view
	m_lpClientSite->ShowObject();   // object should get focus

	// finally -- show the inplace frame window and set focus
	pFrameWnd->ShowWindow(SW_SHOW);
	pFrameWnd->SetFocus();
	pFrameWnd->UpdateWindow();
	UpdateVisibleLock(TRUE, FALSE);

	// allow the main window to be set
	OnFrameWindowActivate(TRUE);
	pFrameWnd->m_bUIActive = TRUE;

	// cleanup and return
	lpInPlaceSite->Release();
	return TRUE;

DeactivateUIAndFail:
	ASSERT(lpInPlaceSite != NULL);
	lpInPlaceSite->OnUIDeactivate(FALSE);

DestroyFrameAndFail:
	if (m_pInPlaceFrame != NULL)
	{
		ASSERT(pFrameWnd != NULL);
		DestroyInPlaceFrame(pFrameWnd);
		m_pInPlaceFrame = NULL;

		// also need to send OnInPlaceDeactivate notification
		ASSERT(lpInPlaceSite != NULL);
		lpInPlaceSite->OnInPlaceDeactivate();
	}

ReleaseAndFail:
	ASSERT(lpInPlaceSite != NULL);
	lpInPlaceSite->Release();
	return FALSE;
}

COleIPFrameWnd* COleServerDoc::CreateInPlaceFrame(CWnd* pParentWnd)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pParentWnd);

	// get runtime class from the doc template
	CDocTemplate* pTemplate = GetDocTemplate();
	ASSERT_VALID(pTemplate);

	// use existing view if possible
	CWnd* pViewParent = NULL;
	CView* pView = NULL;
	CFrameWnd* pFrame = GetFirstFrame();
	if (pFrame != NULL)
	{
		pView = (CView*)pFrame->GetDescendantWindow(AFX_IDW_PANE_FIRST, TRUE);
		if (pView != NULL)
		{
			ASSERT_KINDOF(CView, pView);
			pViewParent = pView->GetParent();
			m_dwOrigStyle = pView->GetStyle();
			m_dwOrigStyleEx = pView->GetExStyle();
		}
	}

	// create the frame from the template
	COleIPFrameWnd* pFrameWnd = (COleIPFrameWnd*)
		pTemplate->CreateOleFrame(pParentWnd, this, pView == NULL);
	if (pFrameWnd == NULL)
		return NULL;

	// connect the view to the frame window, if necessary
	if (pView != NULL)
	{
		ConnectView(pFrameWnd, pView);
		pView->ModifyStyleEx(WS_EX_CLIENTEDGE, 0, SWP_DRAWFRAME);
	}

	// remember original parent window for deactivate
	m_pOrigParent = pViewParent;

	// send OnInitialUpdate if new view was created
	if (pView == NULL)
		pTemplate->InitialUpdateFrame(pFrameWnd, this, FALSE);

	// verify the type
	ASSERT_VALID(pFrameWnd);
	ASSERT_KINDOF(COleIPFrameWnd, pFrameWnd);
	return pFrameWnd;
}

void COleServerDoc::DestroyInPlaceFrame(COleIPFrameWnd* pFrameWnd)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pFrameWnd);

	// connect view to original, if existing view was used
	if (m_pOrigParent != NULL)
	{
		CView* pView = (CView*)pFrameWnd->GetDescendantWindow(
			AFX_IDW_PANE_FIRST, TRUE);
		ENSURE_VALID(pView);

		// leaving the focus on an MDI child or one of its child windows
		// causes Windows to get confused when the child window is
		// destroyed, not to mention the fact that the focus will be
		// out of sync with activation.
		if (::GetFocus() == pView->m_hWnd)
		{
			// move focus to somewhere safe
			HWND hWnd = ::GetParent(pFrameWnd->m_hWnd);
			if (hWnd != NULL)
				::SetFocus(hWnd);

			// check again
			if (::GetFocus() == pView->m_hWnd)
				SetFocus(NULL); // last ditch effort
		}

		ConnectView(m_pOrigParent, pView);
		m_pOrigParent = NULL;

		// remove any scrollbars added because of in-place activation
		if ((m_dwOrigStyle & (WS_HSCROLL|WS_VSCROLL)) == 0 &&
			(pView->GetStyle() & (WS_HSCROLL|WS_VSCROLL)) != 0)
		{
			::SetScrollRange(pView->m_hWnd, SB_HORZ, 0, 0, TRUE);
			::SetScrollRange(pView->m_hWnd, SB_VERT, 0, 0, TRUE);
		}

		// restore old 3D style
		pView->ModifyStyleEx(0, m_dwOrigStyleEx & WS_EX_CLIENTEDGE,
			SWP_DRAWFRAME);

		// force recalc layout on splitter window
		CSplitterWnd* pSplitter = CView::GetParentSplitter(pView, TRUE);
		if (pSplitter != NULL)
			pSplitter->RecalcLayout();
	}

	// no active view or document during destroy
	pFrameWnd->SetActiveView(NULL);

	// destroy in-place frame window
	pFrameWnd->DestroyWindow();
}

void COleServerDoc::ConnectView(CWnd* pParentWnd, CView* pView)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pParentWnd);
	ASSERT_VALID(pView);

	// move the view to the new parent
	pView->SetParent(pParentWnd);

	// Note: The currently active view on the original frame window is
	//  kept active, because some controls, especially Windows controls,
	//  continue to send notification messages to the original parent
	//  window of the control.  So, the original frame window is kept
	//  alive with the original active view pointer intact, such that
	//  these notification messages do not get lost.

	// set the active view of the new frame to newly moved view
	CFrameWnd* pFrameWnd = pParentWnd->IsFrameWnd() ? (CFrameWnd*)pParentWnd : pParentWnd->EnsureParentFrame();
	pFrameWnd->SetActiveView(pView, FALSE);
	pFrameWnd->RecalcLayout();
}

void COleServerDoc::OnFrameWindowActivate(BOOL bActivate)
{
	ASSERT_VALID(this);

	CFrameWnd* pFrameWnd = m_pInPlaceFrame;
	ASSERT_VALID(pFrameWnd);

	CWinThread* pThread = AfxGetThread();
	ASSERT(pThread);
	if (bActivate)
	{
		// activating -- so set the main window
		pThread->m_pActiveWnd = pFrameWnd;

		// send activation notification messages
		pFrameWnd->SendMessage(WM_ACTIVATEAPP, (WPARAM)TRUE);
		pFrameWnd->SendMessage(WM_ACTIVATE, WA_ACTIVE);
	}
	else if (pFrameWnd == pThread->m_pActiveWnd)
	{
		// send deactivation notification messages
		pFrameWnd->SendMessage(WM_ACTIVATEAPP, (WPARAM)FALSE);
		pFrameWnd->SendMessage(WM_ACTIVATE, WA_INACTIVE);

		// simulate deactivation notification messages
		CView* pActiveView = pFrameWnd->GetActiveView();
		if (pActiveView != NULL)
			pActiveView->OnActivateView(FALSE, pActiveView, pActiveView);

		// deactivating and was previously active -- reset the main window
		pThread->m_pActiveWnd = NULL;
	}
}

void COleServerDoc::OnDocWindowActivate(BOOL bActivate)
{
	ASSERT_VALID(this);

	CWinThread* pThread = AfxGetApp();
	COleIPFrameWnd* pFrameWnd = m_pInPlaceFrame;

	if (bActivate)
	{
		// attach frame windows back in the permanent map
		pFrameWnd->m_pMainFrame->Attach(pFrameWnd->m_pMainFrame->Detach());
		if (pFrameWnd->m_pDocFrame != NULL)
			pFrameWnd->m_pDocFrame->Attach(pFrameWnd->m_pDocFrame->Detach());

		// set active main window
		pThread->m_pActiveWnd = pFrameWnd;

		// show frame level controls
		if (pFrameWnd->m_pDocFrame)
			OnShowControlBars(pFrameWnd->m_pDocFrame, TRUE);
		OnShowControlBars(pFrameWnd->m_pMainFrame, TRUE);
		pFrameWnd->ShowOwnedWindows(TRUE);

		// attempt toolbar negotiation
		if (pFrameWnd->m_lpDocFrame)
			OnResizeBorder(NULL, pFrameWnd->m_lpDocFrame, FALSE);
		OnResizeBorder(NULL, pFrameWnd->m_lpFrame, TRUE);


		// install the menu (also installs a hook which forwards messages from
		//  the menu to the inplace frame window)
		pFrameWnd->m_lpFrame->SetMenu(
			pFrameWnd->m_hSharedMenu, pFrameWnd->m_hOleMenu,
			pFrameWnd->m_hWnd);

		// set focus to the frame (it will probably set focus to the view)
		//  (by simulating normal application activate messages)
		pFrameWnd->SendMessage(WM_ACTIVATE, WA_ACTIVE);
	}
	else
	{
		// clear active window for app if this object is active
		if (pThread->m_pActiveWnd == pFrameWnd)
			pThread->m_pActiveWnd = NULL;

		// hide frame level controls -- this does not destroy them
		pFrameWnd->ShowOwnedWindows(FALSE);
		if (pFrameWnd->m_pDocFrame)
			OnShowControlBars(pFrameWnd->m_pDocFrame, FALSE);
		OnShowControlBars(pFrameWnd->m_pMainFrame, FALSE);

		// attempt toolbar negotiation
		if (pFrameWnd->m_lpDocFrame)
			OnResizeBorder(NULL, pFrameWnd->m_lpDocFrame, FALSE);
		OnResizeBorder(NULL, pFrameWnd->m_lpFrame, TRUE);

		// simulate deactivation notification messages
		CView* pActiveView = pFrameWnd->GetActiveView();
		if (pActiveView != NULL)
			pActiveView->OnActivateView(FALSE, pActiveView, pActiveView);
		pFrameWnd->SendMessage(WM_ACTIVATE, WA_INACTIVE);

		// set the m_hWnd members, but remove them from the maps
		pFrameWnd->m_pMainFrame->m_hWnd = pFrameWnd->m_pMainFrame->Detach();
		if (pFrameWnd->m_pDocFrame != NULL)
			pFrameWnd->m_pDocFrame->m_hWnd = pFrameWnd->m_pDocFrame->Detach();
	}
}

void COleServerDoc::OnShowControlBars(CFrameWnd* pFrameWnd, BOOL bShow)
{
	ASSERT_VALID(this);
	ASSERT(pFrameWnd == m_pInPlaceFrame->m_pMainFrame ||
		pFrameWnd == m_pInPlaceFrame->m_pDocFrame);
	ASSERT_VALID(pFrameWnd);

	// show/hide all control bars
	POSITION pos = pFrameWnd->m_listControlBars.GetHeadPosition();
	while (pos != NULL)
	{
		// show/hide the next control bar
		CControlBar* pBar =
			(CControlBar*)pFrameWnd->m_listControlBars.GetNext(pos);
		ASSERT_VALID(pBar);
		if (bShow)
		{
			if (!m_pInPlaceFrame->m_bPreviewMode && 
				(pBar->m_nStateFlags & CControlBar::tempHide))
			{
				pBar->m_nStateFlags &= ~CControlBar::tempHide;
				pFrameWnd->ShowControlBar(pBar, bShow, TRUE);
			}
		}
		else
		{
			if (pBar->IsVisible() && !pBar->IsFloating())
			{
				pBar->m_nStateFlags |= CControlBar::tempHide;
				pFrameWnd->ShowControlBar(pBar, bShow, TRUE);
			}
		}
	}
}

void COleServerDoc::OnResizeBorder(
	LPCRECT lpRectBorder, LPOLEINPLACEUIWINDOW lpUIWindow, BOOL bFrame)
{
	ASSERT_VALID(this);
	ENSURE_ARG(lpRectBorder == NULL ||
		AfxIsValidAddress(lpRectBorder, sizeof(RECT), FALSE));
	ENSURE_ARG(lpUIWindow != NULL);

	// use IOleInPlaceUIWindow::GetBorder if no border given
	CRect rectBorder;
	if (lpRectBorder != NULL)
	{
		// use border space passed in
		rectBorder.CopyRect(lpRectBorder);
	}
	else
	{
		// GetBorderSpace may fail (WinWord6, for example)
		if (lpUIWindow->GetBorder(&rectBorder) != S_OK)
		{
			// in that case, always call SetBorderSpace(NULL), but
			// ignore the return value.
			lpUIWindow->SetBorderSpace(NULL);
			return;
		}
	}

	// get CWnd* for the OLE window
	CFrameWnd* pFrameWnd = bFrame ?
		m_pInPlaceFrame->m_pMainFrame : m_pInPlaceFrame->m_pDocFrame;

	// if this is the active document clear temphide bits from bars
	CWinThread *pThread = AfxGetThread();
	ENSURE_VALID(pThread);
	if (pThread->m_pActiveWnd == m_pInPlaceFrame)
		OnShowControlBars(pFrameWnd, TRUE);

	// see how much space we need by calling reposition bars
	CRect rectNeeded = rectBorder;
	pFrameWnd->RepositionBars(0, 0xFFFF, 0, CWnd::reposQuery, &rectNeeded,
		&rectBorder);

	// request the border space from the container
	CRect rectRequest(
		rectNeeded.left - rectBorder.left,
		rectNeeded.top - rectBorder.top,
		rectBorder.right - rectNeeded.right,
		rectBorder.bottom - rectNeeded.bottom);
	CRect rectTemp;
	rectTemp = rectRequest;

	// if no border space, just call SetBorderSpace
	if ((!rectRequest.IsRectNull() ||
		 !pFrameWnd->m_listControlBars.IsEmpty()) &&
		lpUIWindow->RequestBorderSpace(&rectTemp) == S_OK)
	{
		// set the border space -- now this object owns it
		VERIFY(lpUIWindow->SetBorderSpace(&rectRequest) == S_OK);

		// move the bars into position after committing the space
		pFrameWnd->RepositionBars(0, 0xFFFF, 0, CWnd::reposDefault, NULL,
			&rectBorder);

		// redraw all control bars
		POSITION pos = pFrameWnd->m_listControlBars.GetHeadPosition();
		while (pos != NULL)
		{
			CControlBar* pBar =
				(CControlBar*)pFrameWnd->m_listControlBars.GetNext(pos);
			ASSERT_VALID(pBar);
			if (!pBar->IsFloating())
				pBar->UpdateWindow();
		}
	}
	else
	{
		// hide any toolbars (since we couldn't get border space for any)
		OnShowControlBars(pFrameWnd, FALSE);

		// make sure border space is cleared
		CRect rect(0,0,0,0);
		lpUIWindow->SetBorderSpace(&rect);
	}
}

void COleServerDoc::OnDeactivate()
{
	ASSERT_VALID(this);

	ASSERT(m_pInPlaceFrame != NULL);

	// do UI deactivate first -- this hides everything
	if (m_pInPlaceFrame->m_bUIActive)
	{
		OnDeactivateUI(FALSE);

		// some containers call OnDeactivate during OnDeactivateUI
		if (m_pInPlaceFrame == NULL)
			return;
	}
	ASSERT(m_pInPlaceFrame != NULL);
	ASSERT(!m_pInPlaceFrame->m_bUIActive);

	// now safe to destroy the shared menu
	m_pInPlaceFrame->DestroySharedMenu();

	// no longer need doc & frame window interfaces
	RELEASE(m_pInPlaceFrame->m_lpFrame);
	RELEASE(m_pInPlaceFrame->m_lpDocFrame);
	DestroyInPlaceFrame(m_pInPlaceFrame);
	m_pInPlaceFrame = NULL;
		// destructor for COleIPFrameWnd or derivative should cleanup any
		//   toolbars etc. created during in-place activation

	// last of all, call IOleClientSite::InPlaceDeactivate
	ASSERT(m_lpClientSite != NULL);
	LPOLEINPLACESITE lpInPlaceSite =
		QUERYINTERFACE(m_lpClientSite, IOleInPlaceSite);
	if (lpInPlaceSite != NULL)
	{
		lpInPlaceSite->OnInPlaceDeactivate();
		lpInPlaceSite->Release();
	}
}

void COleServerDoc::OnDeactivateUI(BOOL bUndoable)
{
	ASSERT_VALID(this);
	COleIPFrameWnd* pFrameWnd = m_pInPlaceFrame;

	if (pFrameWnd == NULL || !pFrameWnd->m_bUIActive)
		return;

	// reset active object pointers
	ASSERT(pFrameWnd->m_lpFrame != NULL);
	pFrameWnd->m_lpFrame->SetActiveObject(NULL, NULL);
	if (pFrameWnd->m_lpDocFrame != NULL)
		pFrameWnd->m_lpDocFrame->SetActiveObject(NULL, NULL);

	// remove frame & document level frame controls
	ASSERT(pFrameWnd->m_lpFrame != NULL);
	OnShowControlBars(pFrameWnd->m_pMainFrame, FALSE);
	if (pFrameWnd->m_lpDocFrame != NULL)
		OnShowControlBars(pFrameWnd->m_pDocFrame, FALSE);

	if (m_pDocObjectServer == NULL)
	{
		// hide the frame and any popups owned by the frame
		pFrameWnd->ShowOwnedWindows(FALSE);
		pFrameWnd->ShowWindow(SW_HIDE);
		pFrameWnd->m_nShowDelay = SW_HIDE;
		pFrameWnd->m_pMainFrame->m_nShowDelay = SW_HIDE;
	}

	// set the m_hWnd members, but remove them from the maps
	pFrameWnd->m_pMainFrame->m_hWnd = pFrameWnd->m_pMainFrame->Detach();
	if (pFrameWnd->m_pDocFrame != NULL)
		pFrameWnd->m_pDocFrame->m_hWnd = pFrameWnd->m_pDocFrame->Detach();

	// no longer UI active...
	pFrameWnd->m_bUIActive = FALSE;
	CWinThread* pThread = AfxGetApp();
	if (pThread->m_pActiveWnd == pFrameWnd)
		pThread->m_pActiveWnd = NULL;

	// call IOleClientSite::OnUIDeactivate
	ASSERT(m_lpClientSite != NULL);
	LPOLEINPLACESITE lpInPlaceSite =
		QUERYINTERFACE(m_lpClientSite, IOleInPlaceSite);
	if (lpInPlaceSite != NULL)
	{
		lpInPlaceSite->OnUIDeactivate(bUndoable);
		lpInPlaceSite->Release();
	}
}

void COleServerDoc::OnSetItemRects(LPCRECT lpPosRect, LPCRECT lpClipRect)
{
	ASSERT_VALID(this);
	ASSERT(AfxIsValidAddress(lpPosRect, sizeof(RECT), FALSE));
	ASSERT(AfxIsValidAddress(lpClipRect, sizeof(RECT), FALSE));

	if (m_pInPlaceFrame == NULL)
		return;
	ASSERT_VALID(m_pInPlaceFrame);

	// tell the frame to position itself such that the view is at the given
	//  rectangle (relative to the frame's parent)
	m_pInPlaceFrame->RepositionFrame(lpPosRect, lpClipRect);
}

BOOL COleServerDoc::OnReactivateAndUndo()
{
	// default implementation doesn't support undo

	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// COleServerDoc special APIs for in-place editing

void COleServerDoc::RequestPositionChange(LPCRECT lpPosRect)
{
	ASSERT_VALID(this);
	ASSERT(AfxIsValidAddress(lpPosRect, sizeof(RECT), FALSE));

	// get IOleInPlaceSite interface
	ASSERT(m_lpClientSite != NULL);
	LPOLEINPLACESITE lpInPlaceSite =
		QUERYINTERFACE(m_lpClientSite, IOleInPlaceSite);

	if (lpInPlaceSite != NULL)
	{
		// call IOleInPlaceSite::OnPosRectChange
		lpInPlaceSite->OnPosRectChange(lpPosRect);
		lpInPlaceSite->Release();
	}
}

BOOL COleServerDoc::ScrollContainerBy(CSize sizeScroll)
{
	ASSERT_VALID(this);

	// get IOleInPlaceSite interface
	ASSERT(m_lpClientSite != NULL);
	LPOLEINPLACESITE lpInPlaceSite =
		QUERYINTERFACE(m_lpClientSite, IOleInPlaceSite);
	if (lpInPlaceSite == NULL)
		return FALSE;

	// call IOleInPlaceSite::Scroll
	BOOL bResult = lpInPlaceSite->Scroll(sizeScroll) == S_OK;
	lpInPlaceSite->Release();
	return bResult;
}

BOOL COleServerDoc::DeactivateAndUndo()
{
	ASSERT_VALID(this);

	// get IOleInPlaceSite interface
	ASSERT(m_lpClientSite != NULL);
	LPOLEINPLACESITE lpInPlaceSite =
		QUERYINTERFACE(m_lpClientSite, IOleInPlaceSite);
	if (lpInPlaceSite == NULL)
		return FALSE;

	// call IOleInPlaceSite::DeactivateAndUndo
	BOOL bResult = lpInPlaceSite->DeactivateAndUndo() == S_OK;
	lpInPlaceSite->Release();
	return bResult;
}

BOOL COleServerDoc::DiscardUndoState()
{
	ASSERT_VALID(this);

	// get IOleInPlaceSite interface
	ASSERT(m_lpClientSite != NULL);
	LPOLEINPLACESITE lpInPlaceSite =
		QUERYINTERFACE(m_lpClientSite, IOleInPlaceSite);
	if (lpInPlaceSite == NULL)
		return FALSE;

	// call IOleInPlaceSite::DiscardUndoState
	BOOL bResult = lpInPlaceSite->DiscardUndoState() == S_OK;
	lpInPlaceSite->Release();
	return bResult;
}

/////////////////////////////////////////////////////////////////////////////
// COleServerDoc OLE interface implementation

BEGIN_INTERFACE_MAP(COleServerDoc, COleLinkingDoc)
	INTERFACE_PART(COleServerDoc, IID_IPersistStorage, PersistStorage)
	INTERFACE_PART(COleServerDoc, IID_IOleObject, OleObject)
	INTERFACE_PART(COleServerDoc, IID_IDataObject, DataObject)
	INTERFACE_PART(COleServerDoc, IID_IOleWindow, OleInPlaceObject)
	INTERFACE_PART(COleServerDoc, IID_IOleInPlaceObject, OleInPlaceObject)
	INTERFACE_PART(COleServerDoc, IID_IOleInPlaceActiveObject, OleInPlaceActiveObject)
END_INTERFACE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COleServerDoc::CPersistStorage

STDMETHODIMP_(ULONG) COleServerDoc::XPersistStorage::AddRef()
{
	METHOD_PROLOGUE_EX_(COleServerDoc, PersistStorage)
	return pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) COleServerDoc::XPersistStorage::Release()
{
	METHOD_PROLOGUE_EX_(COleServerDoc, PersistStorage)
	return pThis->ExternalRelease();
}

STDMETHODIMP COleServerDoc::XPersistStorage::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(COleServerDoc, PersistStorage)
	return pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP COleServerDoc::XPersistStorage::GetClassID(LPCLSID lpClassID)
{
	METHOD_PROLOGUE_EX_(COleServerDoc, PersistStorage)

	LPPERSISTFILE lpPersistFile = (LPPERSISTFILE)
		pThis->GetInterface(&IID_IPersistFile);
	return lpPersistFile->GetClassID(lpClassID);
}

STDMETHODIMP COleServerDoc::XPersistStorage::IsDirty()
{
	METHOD_PROLOGUE_EX_(COleServerDoc, PersistStorage)

	LPPERSISTFILE lpPersistFile = (LPPERSISTFILE)
		pThis->GetInterface(&IID_IPersistFile);

	return lpPersistFile->IsDirty();
}

STDMETHODIMP COleServerDoc::XPersistStorage::InitNew(LPSTORAGE pStg)
{
	METHOD_PROLOGUE_EX(COleServerDoc, PersistStorage)
	ASSERT_VALID(pThis);

	SCODE sc = S_OK;
	TRY
	{
		// delegate to member function in the document
		pThis->OnNewEmbedding(pStg);
	}
	CATCH_ALL(e)
	{
		sc = COleException::Process(e);
		DELETE_EXCEPTION(e);
	}
	END_CATCH_ALL

	ASSERT_VALID(pThis);
	return sc;
}

STDMETHODIMP COleServerDoc::XPersistStorage::Load(LPSTORAGE pStg)
{
	METHOD_PROLOGUE_EX(COleServerDoc, PersistStorage)
	ASSERT_VALID(pThis);

	SCODE sc = S_OK;
	pThis->BeginDeferErrors();
	TRY
	{
		// delegate to member function in the document
		pThis->OnOpenEmbedding(pStg);
	}
	CATCH_ALL(e)
	{
		sc = COleException::Process(e);
		DELETE_EXCEPTION(e);
	}
	END_CATCH_ALL
	sc = pThis->EndDeferErrors(sc);

	ASSERT_VALID(pThis);
	return sc;
}

STDMETHODIMP COleServerDoc::XPersistStorage::Save(
	LPSTORAGE pStgSave, BOOL fSameAsLoad)
{
	METHOD_PROLOGUE_EX(COleServerDoc, PersistStorage)
	ASSERT_VALID(pThis);

	// don't bother saving if destination is up-to-date
	if (fSameAsLoad && !pThis->IsModified())
		return S_OK;

	SCODE sc = S_OK;
	pThis->BeginDeferErrors();
	TRY
	{
		// delegate through the document
		ASSERT(pThis->m_bRemember);
		pThis->m_bRemember = FALSE;
		pThis->m_bSameAsLoad = fSameAsLoad;
		pThis->OnSaveEmbedding(pStgSave);

		// clear dirty flag since save to same storage successful
		if (fSameAsLoad)
		{
			pThis->SetModifiedFlag(FALSE);

			// notify clients that object has been saved
			pThis->NotifySaved();
		}
	}
	CATCH_ALL(e)
	{
		sc = COleException::Process(e);
		DELETE_EXCEPTION(e);
	}
	END_CATCH_ALL
	sc = pThis->EndDeferErrors(sc);

	// restore default state
	pThis->m_bRemember = TRUE;

	ASSERT_VALID(pThis);
	return sc;
}

STDMETHODIMP COleServerDoc::XPersistStorage::SaveCompleted(LPSTORAGE pStgSaved)
{
	METHOD_PROLOGUE_EX(COleServerDoc, PersistStorage)
	ASSERT_VALID(pThis);

	// call SaveCompleted on any embedded items
	pThis->CommitItems(pStgSaved != NULL, pStgSaved);

	// update state to reflect new storage
	if (pStgSaved != NULL)
	{
		// attach new storage
		pStgSaved->AddRef();
		RELEASE(pThis->m_lpRootStg);
		pThis->m_lpRootStg = pStgSaved;

		// now this document is storage based
		pThis->m_strPathName.Empty();
		pThis->m_bEmbedded = TRUE;

		// notify clients that object has been saved
		pThis->NotifySaved();
	}

	ASSERT_VALID(pThis);
	return S_OK;
}

STDMETHODIMP COleServerDoc::XPersistStorage::HandsOffStorage()
{
	METHOD_PROLOGUE_EX_(COleServerDoc, PersistStorage)

	if (pThis->m_lpRootStg != NULL)
	{
		// first call HandsOffStorage for all the embedded client items
		POSITION pos = pThis->GetStartPosition();
		COleClientItem* pItem;
		while ((pItem = pThis->GetNextClientItem(pos)) != NULL)
		{
			ASSERT(pItem->m_lpObject != NULL);
			LPPERSISTSTORAGE lpPersistStorage =
				QUERYINTERFACE(pItem->m_lpObject, IPersistStorage);
			ASSERT(lpPersistStorage != NULL);
			lpPersistStorage->HandsOffStorage();
			lpPersistStorage->Release();
			pItem->m_bNeedCommit = TRUE;

		}

		// for now, can't access the storage
		RELEASE(pThis->m_lpRootStg);
	}

	ASSERT_VALID(pThis);
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// COleServerDoc::XOleObject

STDMETHODIMP_(ULONG) COleServerDoc::XOleObject::AddRef()
{
	METHOD_PROLOGUE_EX_(COleServerDoc, OleObject)
	return pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) COleServerDoc::XOleObject::Release()
{
	METHOD_PROLOGUE_EX_(COleServerDoc, OleObject)
	return pThis->ExternalRelease();
}

STDMETHODIMP COleServerDoc::XOleObject::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(COleServerDoc, OleObject)
	return pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP COleServerDoc::XOleObject::SetClientSite(
	LPOLECLIENTSITE pClientSite)
{
	METHOD_PROLOGUE_EX_(COleServerDoc, OleObject)

	// maintain reference counts
	if (pClientSite != NULL)
		pClientSite->AddRef();
	RELEASE(pThis->m_lpClientSite);
	pThis->m_lpClientSite = pClientSite;

	// do we already have doc object support enabled?
	if (pThis->m_pDocObjectServer != NULL)
	{
		// If we currently have a document site pointer,
		// release it.
		pThis->m_pDocObjectServer->ReleaseDocSite();
	}

	if (pClientSite != NULL)
	{
		LPOLEDOCUMENTSITE pDocSite;

		if (SUCCEEDED(pClientSite->QueryInterface(IID_IOleDocumentSite,
			(LPVOID*) &pDocSite)))
		{
			if (pThis->m_pDocObjectServer != NULL)
				pThis->m_pDocObjectServer->SetDocSite(pDocSite);
			else
			{
				pThis->m_pDocObjectServer =
					pThis->GetDocObjectServer(pDocSite);
			}
		}
	}
	else
	{
		if (pThis->m_pDocObjectServer != NULL)
		{
			delete pThis->m_pDocObjectServer;
			pThis->m_pDocObjectServer = NULL;
		}
	}

	return S_OK;
}

STDMETHODIMP COleServerDoc::XOleObject::GetClientSite(
	LPOLECLIENTSITE* ppClientSite)
{
	METHOD_PROLOGUE_EX_(COleServerDoc, OleObject)

	if (pThis->m_lpClientSite == NULL)
	{
		*ppClientSite = NULL;
		return E_FAIL;
	}

	*ppClientSite = pThis->m_lpClientSite;
	pThis->m_lpClientSite->AddRef();
	return S_OK;
}

STDMETHODIMP COleServerDoc::XOleObject::SetHostNames(
	LPCOLESTR lpszContainerApp, LPCOLESTR lpszContainerObj)
{
	METHOD_PROLOGUE_EX(COleServerDoc, OleObject)
	ASSERT_VALID(pThis);

	TRY
	{
		CString strContainerApp(lpszContainerApp);
		CString strContainerObj(lpszContainerObj);
		pThis->OnSetHostNames(lpszContainerApp ? strContainerApp.GetString() : NULL,
							  lpszContainerObj ? strContainerObj.GetString() : NULL);
	}
	END_TRY

	return S_OK;
}

STDMETHODIMP COleServerDoc::XOleObject::Close(DWORD dwSaveOption)
{
	METHOD_PROLOGUE_EX(COleServerDoc, OleObject)
	ASSERT_VALID(pThis);

	pThis->InternalAddRef();    // protect this object

	SCODE sc = S_OK;
	TRY
	{
		// delegate through document for most of the work
		pThis->OnClose((OLECLOSE)dwSaveOption);
	}
	CATCH_ALL(e)
	{
		sc = COleException::Process(e);
		DELETE_EXCEPTION(e);
	}
	END_CATCH_ALL

	pThis->InternalRelease();   // may 'delete this'

	return sc;
}

STDMETHODIMP COleServerDoc::XOleObject::SetMoniker(
	DWORD /*dwWhichMoniker*/, LPMONIKER /*pmk*/)
{
	METHOD_PROLOGUE_EX_(COleServerDoc, OleObject)

	if (pThis->m_lpClientSite == NULL)
		return E_FAIL;

	// get current full moniker from client-site
	LPMONIKER lpMoniker = NULL;
	if (pThis->m_lpClientSite->GetMoniker(OLEGETMONIKER_ONLYIFTHERE,
		OLEWHICHMK_OBJFULL, &lpMoniker) != S_OK)
	{
		// just to make sure -- always set moniker to NULL on failure
		lpMoniker = NULL;
	}

	// update all embedded items with new moniker
	POSITION pos = pThis->GetStartPosition();
	COleClientItem* pItem;
	while ((pItem = pThis->GetNextClientItem(pos)) != NULL)
	{
		if (pItem->m_bMoniker)
			pItem->m_lpObject->SetMoniker(OLEWHICHMK_CONTAINER, lpMoniker);
	}

	// send Rename advises
	pThis->NotifyAllItems(OLE_RENAMED, reinterpret_cast<DWORD_PTR>(lpMoniker));
	RELEASE(lpMoniker);

	return S_OK;
}

STDMETHODIMP COleServerDoc::XOleObject::GetMoniker(
	DWORD dwAssign, DWORD /*dwWhichMoniker*/, LPMONIKER* ppMoniker)
{
	METHOD_PROLOGUE_EX_(COleServerDoc, OleObject)

	*ppMoniker = pThis->GetMoniker((OLEGETMONIKER)dwAssign);
	return *ppMoniker == NULL ? E_FAIL : S_OK;
}

STDMETHODIMP COleServerDoc::XOleObject::InitFromData(
	LPDATAOBJECT pDataObject, BOOL fCreation, DWORD /*dwReserved*/)
{
	METHOD_PROLOGUE_EX(COleServerDoc, OleObject)
	ASSERT_VALID(pThis);

	COleServerItem* pItem;
	SCODE sc;
	TRY
	{
		// delegate through item
		pItem = pThis->GetEmbeddedItem();
		ASSERT_VALID(pItem);
		ASSERT_KINDOF(COleServerItem, pItem);

		COleDataObject dataObject;
		dataObject.Attach(pDataObject,  FALSE);
		sc = pItem->OnInitFromData(&dataObject, fCreation) ? S_OK : S_FALSE;
	}
	CATCH_ALL(e)
	{
		sc = COleException::Process(e);
		DELETE_EXCEPTION(e);
	}
	END_CATCH_ALL

	return sc;
}

STDMETHODIMP COleServerDoc::XOleObject::GetClipboardData(
	DWORD /*dwReserved*/, LPDATAOBJECT* ppDataObject)
{
	METHOD_PROLOGUE_EX(COleServerDoc, OleObject)
	ASSERT_VALID(pThis);

	*ppDataObject = NULL;

	COleServerItem* pItem;
	SCODE sc = S_OK;
	TRY
	{
		// delegate through item
		pItem = pThis->GetEmbeddedItem();
		ASSERT_VALID(pItem);
		ASSERT_KINDOF(COleServerItem, pItem);

		COleDataSource* pDataSource =
			pItem->OnGetClipboardData(TRUE, NULL, NULL);
		ASSERT(pDataSource != NULL);

		*ppDataObject =
			(LPDATAOBJECT)pDataSource->GetInterface(&IID_IDataObject);
		ASSERT(*ppDataObject != NULL);
	}
	CATCH_ALL(e)
	{
		sc = COleException::Process(e);
		DELETE_EXCEPTION(e);
	}
	END_CATCH_ALL

	return sc;
}

STDMETHODIMP COleServerDoc::XOleObject::DoVerb(
	LONG iVerb, LPMSG /*lpmsg*/, LPOLECLIENTSITE /*pActiveSite*/, LONG /*lindex*/,
	HWND /*hwndParent*/, LPCRECT /*lpPosRect*/)
{
	METHOD_PROLOGUE_EX(COleServerDoc, OleObject)
	ASSERT_VALID(pThis);

	pThis->InternalAddRef();    // protect this object

	COleServerItem* pItem;
	SCODE sc = S_OK;
	TRY
	{
		// delegate through item
		pItem = pThis->GetEmbeddedItem();
		ASSERT_VALID(pItem);
		ASSERT_KINDOF(COleServerItem, pItem);
		pItem->OnDoVerb(iVerb);
	}
	CATCH_ALL(e)
	{
		sc = COleException::Process(e);
		DELETE_EXCEPTION(e);
	}
	END_CATCH_ALL
	pThis->InternalRelease();   // may 'delete this'

	return sc;
}

STDMETHODIMP COleServerDoc::XOleObject::EnumVerbs(
	IEnumOLEVERB** ppenumOleVerb)
{
	METHOD_PROLOGUE_EX_(COleServerDoc, OleObject)

	*ppenumOleVerb = NULL;

	LPOLEOBJECT lpObject = (LPOLEOBJECT)pThis->GetInterface(&IID_IOleObject);
	ASSERT(lpObject != NULL);
	CLSID clsid;
	lpObject->GetUserClassID(&clsid);

	return OleRegEnumVerbs(clsid, ppenumOleVerb);
}

STDMETHODIMP COleServerDoc::XOleObject::Update()
{
	METHOD_PROLOGUE_EX(COleServerDoc, OleObject)
	ASSERT_VALID(pThis);

	COleServerItem* pItem;
	SCODE sc = S_OK;
	TRY
	{
		// delegate through item
		pItem = pThis->GetEmbeddedItem();
		ASSERT_VALID(pItem);
		ASSERT_KINDOF(COleServerItem, pItem);
		pItem->OnUpdateItems();
	}
	CATCH_ALL(e)
	{
		sc = COleException::Process(e);
		DELETE_EXCEPTION(e);
	}
	END_CATCH_ALL

	return sc;
}

STDMETHODIMP COleServerDoc::XOleObject::IsUpToDate()
{
	METHOD_PROLOGUE_EX(COleServerDoc, OleObject)
	ASSERT_VALID(pThis);

	COleServerItem* pItem;
	SCODE sc;
	TRY
	{
		// delegate through item
		pItem = pThis->GetEmbeddedItem();
		ASSERT_VALID(pItem);
		ASSERT_KINDOF(COleServerItem, pItem);

		sc = pItem->OnQueryUpdateItems() ? S_FALSE : S_OK;
	}
	CATCH_ALL(e)
	{
		sc = COleException::Process(e);
		DELETE_EXCEPTION(e);
	}
	END_CATCH_ALL

	return sc;
}

STDMETHODIMP COleServerDoc::XOleObject::GetUserClassID(CLSID* lpClassID)
{
	METHOD_PROLOGUE_EX_(COleServerDoc, OleObject)

	LPPERSISTFILE lpPersistFile = (LPPERSISTFILE)
		pThis->GetInterface(&IID_IPersistFile);
	return lpPersistFile->GetClassID(lpClassID);
}

STDMETHODIMP COleServerDoc::XOleObject::GetUserType(
	DWORD dwFormOfType, LPOLESTR* ppszUserType)
{
	METHOD_PROLOGUE_EX_(COleServerDoc, OleObject)

	*ppszUserType = NULL;

	LPOLEOBJECT lpObject = (LPOLEOBJECT)pThis->GetInterface(&IID_IOleObject);
	ASSERT(lpObject != NULL);
	CLSID clsid;
	lpObject->GetUserClassID(&clsid);

	return OleRegGetUserType(clsid, dwFormOfType, ppszUserType);
}

STDMETHODIMP COleServerDoc::XOleObject::SetExtent(
	DWORD dwDrawAspect, LPSIZEL lpsizel)
{
	METHOD_PROLOGUE_EX(COleServerDoc, OleObject)
	ASSERT_VALID(pThis);

	COleServerItem* pItem;
	SCODE sc = E_FAIL;
	TRY
	{
		// convert rectangle to a CSize and call item OnSetExtent
		pItem = pThis->GetEmbeddedItem();
		ASSERT_VALID(pItem);
		ASSERT_KINDOF(COleServerItem, pItem);

		CSize size((int)lpsizel->cx, (int)lpsizel->cy);
		if (pItem->OnSetExtent((DVASPECT)dwDrawAspect, size))
			sc = S_OK;
	}
	CATCH_ALL(e)
	{
		sc = COleException::Process(e);
		DELETE_EXCEPTION(e);
	}
	END_CATCH_ALL

	return sc;
}

STDMETHODIMP COleServerDoc::XOleObject::GetExtent(
	DWORD dwDrawAspect, LPSIZEL lpsizel)
{
	METHOD_PROLOGUE_EX(COleServerDoc, OleObject)
	ASSERT_VALID(pThis);

	COleServerItem* pItem;
	SCODE sc = E_INVALIDARG;
	TRY
	{
		pItem = pThis->GetEmbeddedItem();
		ASSERT_VALID(pItem);
		ASSERT_KINDOF(COleServerItem, pItem);

		// call to get regular windows CSize
		CSize size;
		if (pItem->OnGetExtent((DVASPECT)dwDrawAspect, size))
		{
			if (size.cy < 0)
				size.cy = -size.cy; // extents are always positive
			lpsizel->cx = size.cx;
			lpsizel->cy = size.cy;

			sc = S_OK;
		}
	}
	CATCH_ALL(e)
	{
		sc = COleException::Process(e);
		DELETE_EXCEPTION(e);
	}
	END_CATCH_ALL

	return sc;
}

STDMETHODIMP COleServerDoc::XOleObject::Advise(
	IAdviseSink* pAdvSink, DWORD* pdwConnection)
{
	METHOD_PROLOGUE_EX(COleServerDoc, OleObject)

	COleServerItem* pItem = NULL;
	SCODE sc = E_OUTOFMEMORY;
	TRY
	{
		pItem = pThis->GetEmbeddedItem();
		ASSERT_VALID(pItem);
		ASSERT_KINDOF(COleServerItem, pItem);
		sc = S_OK;
	}
	END_TRY

	if (sc != S_OK)
		return sc;

	return pItem->GetOleObject()->Advise(pAdvSink, pdwConnection);
}

STDMETHODIMP COleServerDoc::XOleObject::Unadvise(DWORD dwConnection)
{
	METHOD_PROLOGUE_EX(COleServerDoc, OleObject)

	COleServerItem* pItem = NULL;
	SCODE sc = E_OUTOFMEMORY;
	TRY
	{
		pItem = pThis->GetEmbeddedItem();
		ASSERT_VALID(pItem);
		ASSERT_KINDOF(COleServerItem, pItem);
		sc = S_OK;
	}
	END_TRY

	if (sc != S_OK)
		return sc;

	return pItem->GetOleObject()->Unadvise(dwConnection);
}

STDMETHODIMP COleServerDoc::XOleObject::EnumAdvise(
	LPENUMSTATDATA* ppenumAdvise)
{
	METHOD_PROLOGUE_EX(COleServerDoc, OleObject)

	COleServerItem* pItem = NULL;
	SCODE sc = E_OUTOFMEMORY;
	TRY
	{
		pItem = pThis->GetEmbeddedItem();
		ASSERT_VALID(pItem);
		ASSERT_KINDOF(COleServerItem, pItem);
		sc = S_OK;
	}
	END_TRY

	if (sc != S_OK)
		return sc;

	return pItem->GetOleObject()->EnumAdvise(ppenumAdvise);
}

STDMETHODIMP COleServerDoc::XOleObject::GetMiscStatus(
	DWORD dwAspect, DWORD* pdwStatus)
{
	METHOD_PROLOGUE_EX_(COleServerDoc, OleObject)

	*pdwStatus = 0;

	LPOLEOBJECT lpObject = (LPOLEOBJECT)pThis->GetInterface(&IID_IOleObject);
	ASSERT(lpObject != NULL);
	CLSID clsid;
	lpObject->GetUserClassID(&clsid);

	return OleRegGetMiscStatus(clsid, dwAspect, pdwStatus);
}

STDMETHODIMP COleServerDoc::XOleObject::SetColorScheme(LPLOGPALETTE lpLogpal)
{
	METHOD_PROLOGUE_EX(COleServerDoc, OleObject)
	ASSERT_VALID(pThis);

	COleServerItem* pItem;
	SCODE sc = E_NOTIMPL;
	TRY
	{
		pItem = pThis->GetEmbeddedItem();
		ASSERT_VALID(pItem);
		ASSERT_KINDOF(COleServerItem, pItem);

		// delegate to embedded item
		if (pItem->OnSetColorScheme(lpLogpal))
			sc = S_OK;
	}
	END_TRY

	return sc;
}

/////////////////////////////////////////////////////////////////////////////
// COleServerDoc::XDataObject

STDMETHODIMP_(ULONG) COleServerDoc::XDataObject::AddRef()
{
	METHOD_PROLOGUE_EX_(COleServerDoc, DataObject)
	return pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) COleServerDoc::XDataObject::Release()
{
	METHOD_PROLOGUE_EX_(COleServerDoc, DataObject)
	return pThis->ExternalRelease();
}

STDMETHODIMP COleServerDoc::XDataObject::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(COleServerDoc, DataObject)
	return pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP COleServerDoc::XDataObject::GetData(
	LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium)
{
	METHOD_PROLOGUE_EX(COleServerDoc, DataObject)

	COleServerItem* pItem = NULL;
	SCODE sc = E_OUTOFMEMORY;
	TRY
	{
		pItem = pThis->GetEmbeddedItem();
		ASSERT_VALID(pItem);
		ASSERT_KINDOF(COleServerItem, pItem);
		sc = S_OK;
	}
	END_TRY

	if (sc != S_OK)
		return sc;

	return pItem->GetDataObject()->GetData(lpFormatEtc, lpStgMedium);
}

STDMETHODIMP COleServerDoc::XDataObject::GetDataHere(
	LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium)
{
	METHOD_PROLOGUE_EX(COleServerDoc, DataObject)

	COleServerItem* pItem = NULL;
	SCODE sc = E_OUTOFMEMORY;
	TRY
	{
		pItem = pThis->GetEmbeddedItem();
		ASSERT_VALID(pItem);
		ASSERT_KINDOF(COleServerItem, pItem);
		sc = S_OK;
	}
	END_TRY

	if (sc != S_OK)
		return sc;

	return pItem->GetDataObject()->GetDataHere(lpFormatEtc, lpStgMedium);
}

STDMETHODIMP COleServerDoc::XDataObject::QueryGetData(
	LPFORMATETC lpFormatEtc)
{
	METHOD_PROLOGUE_EX(COleServerDoc, DataObject)

	COleServerItem* pItem = NULL;
	SCODE sc = E_OUTOFMEMORY;
	TRY
	{
		pItem = pThis->GetEmbeddedItem();
		ASSERT_VALID(pItem);
		ASSERT_KINDOF(COleServerItem, pItem);
		sc = S_OK;
	}
	END_TRY

	if (sc != S_OK)
		return sc;

	return pItem->GetDataObject()->QueryGetData(lpFormatEtc);
}

STDMETHODIMP COleServerDoc::XDataObject::GetCanonicalFormatEtc(
	LPFORMATETC /*lpFormatEtcIn*/, LPFORMATETC /*lpFormatEtcOut*/)
{
	// because we support the target-device (ptd) for server metafile format,
	//  all members of the FORMATETC are significant.

	return DATA_S_SAMEFORMATETC;
}

STDMETHODIMP COleServerDoc::XDataObject::SetData(
	LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium, BOOL bRelease)
{
	METHOD_PROLOGUE_EX(COleServerDoc, DataObject)

	COleServerItem* pItem = NULL;
	SCODE sc = E_OUTOFMEMORY;
	TRY
	{
		pItem = pThis->GetEmbeddedItem();
		ASSERT_VALID(pItem);
		ASSERT_KINDOF(COleServerItem, pItem);
		sc = S_OK;
	}
	END_TRY

	if (sc != S_OK)
		return sc;

	return pItem->GetDataObject()->SetData(lpFormatEtc, lpStgMedium, bRelease);
}

STDMETHODIMP COleServerDoc::XDataObject::EnumFormatEtc(
	DWORD dwDirection, LPENUMFORMATETC* ppenumFormatEtc)
{
	METHOD_PROLOGUE_EX(COleServerDoc, DataObject)

	COleServerItem* pItem = NULL;
	SCODE sc = E_OUTOFMEMORY;
	TRY
	{
		pItem = pThis->GetEmbeddedItem();
		ASSERT_VALID(pItem);
		ASSERT_KINDOF(COleServerItem, pItem);
		sc = S_OK;
	}
	END_TRY

	if (sc != S_OK)
		return sc;

	return pItem->GetDataObject()->EnumFormatEtc(dwDirection, ppenumFormatEtc);
}

STDMETHODIMP COleServerDoc::XDataObject::DAdvise(
	FORMATETC* pFormatetc, DWORD advf,
	LPADVISESINK pAdvSink, DWORD* pdwConnection)
{
	METHOD_PROLOGUE_EX(COleServerDoc, DataObject)

	COleServerItem* pItem = NULL;
	SCODE sc = E_OUTOFMEMORY;
	TRY
	{
		pItem = pThis->GetEmbeddedItem();
		ASSERT_VALID(pItem);
		ASSERT_KINDOF(COleServerItem, pItem);
		sc = S_OK;
	}
	END_TRY

	if (sc != S_OK)
		return sc;

	return pItem->GetDataObject()->DAdvise(pFormatetc, advf, pAdvSink,
		pdwConnection);
}

STDMETHODIMP COleServerDoc::XDataObject::DUnadvise(DWORD dwConnection)
{
	METHOD_PROLOGUE_EX(COleServerDoc, DataObject)

	COleServerItem* pItem = NULL;
	SCODE sc = E_OUTOFMEMORY;
	TRY
	{
		pItem = pThis->GetEmbeddedItem();
		ASSERT_VALID(pItem);
		ASSERT_KINDOF(COleServerItem, pItem);
		sc = S_OK;
	}
	END_TRY

	if (sc != S_OK)
		return sc;

	return pItem->GetDataObject()->DUnadvise(dwConnection);
}

STDMETHODIMP COleServerDoc::XDataObject::EnumDAdvise(
	LPENUMSTATDATA* ppenumAdvise)
{
	METHOD_PROLOGUE_EX(COleServerDoc, DataObject)

	COleServerItem* pItem = NULL;
	SCODE sc = E_OUTOFMEMORY;
	TRY
	{
		pItem = pThis->GetEmbeddedItem();
		ASSERT_VALID(pItem);
		ASSERT_KINDOF(COleServerItem, pItem);
		sc = S_OK;
	}
	END_TRY

	if (sc != S_OK)
		return sc;

	return pItem->GetDataObject()->EnumDAdvise(ppenumAdvise);
}

/////////////////////////////////////////////////////////////////////////////
// COleServerDoc::COleInPlaceObject

STDMETHODIMP_(ULONG) COleServerDoc::XOleInPlaceObject::AddRef()
{
	METHOD_PROLOGUE_EX_(COleServerDoc, OleInPlaceObject)
	return pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) COleServerDoc::XOleInPlaceObject::Release()
{
	METHOD_PROLOGUE_EX_(COleServerDoc, OleInPlaceObject)
	return pThis->ExternalRelease();
}

STDMETHODIMP COleServerDoc::XOleInPlaceObject::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(COleServerDoc, OleInPlaceObject)
	return pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP COleServerDoc::XOleInPlaceObject::GetWindow(HWND* lphwnd)
{
	METHOD_PROLOGUE_EX_(COleServerDoc, OleInPlaceObject)

	LPOLEINPLACEACTIVEOBJECT lpActiveObject = (LPOLEINPLACEACTIVEOBJECT)
		pThis->GetInterface(&IID_IOleInPlaceActiveObject);
	return lpActiveObject->GetWindow(lphwnd);
}

STDMETHODIMP COleServerDoc::XOleInPlaceObject::ContextSensitiveHelp(
	BOOL fEnterMode)
{
	METHOD_PROLOGUE_EX_(COleServerDoc, OleInPlaceObject)

	LPOLEINPLACEACTIVEOBJECT lpActiveObject = (LPOLEINPLACEACTIVEOBJECT)
		pThis->GetInterface(&IID_IOleInPlaceActiveObject);
	return lpActiveObject->ContextSensitiveHelp(fEnterMode);
}

STDMETHODIMP COleServerDoc::XOleInPlaceObject::InPlaceDeactivate()
{
	METHOD_PROLOGUE_EX(COleServerDoc, OleInPlaceObject)
	ASSERT_VALID(pThis);

	pThis->InternalAddRef();    // protect this object

	SCODE sc = E_UNEXPECTED;
	TRY
	{
		// only call deactivate if necessary
		if (pThis->m_pInPlaceFrame != NULL)
			pThis->OnDeactivate();

		// should be completely inactive
		ASSERT(pThis->m_pInPlaceFrame == NULL);
		sc = S_OK;
	}
	END_TRY

	pThis->InternalRelease();   // may 'delete this'
	return sc;
}

STDMETHODIMP COleServerDoc::XOleInPlaceObject::UIDeactivate()
{
	METHOD_PROLOGUE_EX(COleServerDoc, OleInPlaceObject)
	ASSERT_VALID(pThis);

	pThis->InternalAddRef();    // protect this object

	SCODE sc = E_UNEXPECTED;
	TRY
	{
		// only call OnUIDeactivate if necessary
		if (pThis->m_pInPlaceFrame != NULL &&
			pThis->m_pInPlaceFrame->m_bUIActive)
		{
			pThis->OnDeactivateUI(FALSE);   // default to not undoable
		}

		// should not be ui active
		ASSERT(pThis->m_pInPlaceFrame == NULL ||
			!pThis->m_pInPlaceFrame->m_bUIActive);
		sc = S_OK;
	}
	END_TRY

	pThis->InternalRelease();   // may 'delete this'
	return sc;
}

STDMETHODIMP COleServerDoc::XOleInPlaceObject::SetObjectRects(
	LPCRECT lpPosRect, LPCRECT lpClipRect)
{
	METHOD_PROLOGUE_EX(COleServerDoc, OleInPlaceObject)
	ASSERT_VALID(pThis);

	SCODE sc = E_UNEXPECTED;
	TRY
	{
		pThis->OnSetItemRects(lpPosRect, lpClipRect);
		sc = S_OK;
	}
	END_TRY

	return sc;
}

STDMETHODIMP COleServerDoc::XOleInPlaceObject::ReactivateAndUndo()
{
	METHOD_PROLOGUE_EX(COleServerDoc, OleInPlaceObject)
	ASSERT_VALID(pThis);

	SCODE sc = E_UNEXPECTED;
	TRY
	{
		sc = pThis->OnReactivateAndUndo() ? S_OK : INPLACE_E_NOTUNDOABLE;
	}
	END_TRY

	return sc;
}

/////////////////////////////////////////////////////////////////////////////
// COleServerDoc::XOleInPlaceActiveObject

STDMETHODIMP_(ULONG) COleServerDoc::XOleInPlaceActiveObject::AddRef()
{
	METHOD_PROLOGUE_EX_(COleServerDoc, OleInPlaceActiveObject)
	return pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) COleServerDoc::XOleInPlaceActiveObject::Release()
{
	METHOD_PROLOGUE_EX_(COleServerDoc, OleInPlaceActiveObject)
	return pThis->ExternalRelease();
}

STDMETHODIMP COleServerDoc::XOleInPlaceActiveObject::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(COleServerDoc, OleInPlaceActiveObject)
	return pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP COleServerDoc::XOleInPlaceActiveObject::GetWindow(
	HWND* lphwnd)
{
	METHOD_PROLOGUE_EX_(COleServerDoc, OleInPlaceActiveObject)

	*lphwnd = pThis->m_pInPlaceFrame->GetSafeHwnd();
	return *lphwnd != NULL ? S_OK : E_FAIL;
}

STDMETHODIMP COleServerDoc::XOleInPlaceActiveObject::ContextSensitiveHelp(
	BOOL fEnterMode)
{
	METHOD_PROLOGUE_EX(COleServerDoc, OleInPlaceActiveObject)
	ASSERT_VALID(pThis);

	if (fEnterMode)
	{
		if (!pThis->m_pInPlaceFrame->m_bHelpMode)
		{
			// check if help mode probable
			if (!pThis->m_pInPlaceFrame->CanEnterHelpMode())
				return E_UNEXPECTED;

			// attempt to enter context help
			if (!pThis->m_pInPlaceFrame->PostMessage(WM_COMMAND, ID_CONTEXT_HELP))
				return E_UNEXPECTED;
		}
	}
	else
	{
		// just exit help mode
		pThis->m_pInPlaceFrame->ExitHelpMode();
	}

	return S_OK;
}

STDMETHODIMP COleServerDoc::XOleInPlaceActiveObject::TranslateAccelerator(
	LPMSG lpmsg)
{
	METHOD_PROLOGUE_EX(COleServerDoc, OleInPlaceActiveObject)
	ASSERT_VALID(pThis);

	pThis->InternalAddRef();    // protect this object

	SCODE sc = E_UNEXPECTED;
	TRY
	{
		// get frame window for this document
		CFrameWnd* pFrameWnd = pThis->m_pInPlaceFrame;
		ASSERT_VALID(pFrameWnd);

		// attempt translate accelerator
		MSG msg = *lpmsg;
		sc = pFrameWnd->PreTranslateMessage(&msg) ? S_OK : S_FALSE;
		*lpmsg = msg;
	}
	END_TRY

	pThis->InternalRelease();   // may 'delete this'

	return sc;
}

STDMETHODIMP COleServerDoc::XOleInPlaceActiveObject::OnFrameWindowActivate(
	BOOL fActivate)
{
	METHOD_PROLOGUE_EX(COleServerDoc, OleInPlaceActiveObject)
	ASSERT_VALID(pThis);

	SCODE sc = E_UNEXPECTED;
	TRY
	{
		pThis->OnFrameWindowActivate(fActivate);
		sc = S_OK;
	}
	END_TRY

	return sc;
}

STDMETHODIMP COleServerDoc::XOleInPlaceActiveObject::OnDocWindowActivate(
	BOOL fActivate)
{
	METHOD_PROLOGUE_EX(COleServerDoc, OleInPlaceActiveObject)
	ASSERT_VALID(pThis);

	SCODE sc = E_UNEXPECTED;
	TRY
	{
		pThis->OnDocWindowActivate(fActivate);
		sc = S_OK;
	}
	END_TRY

	return sc;
}

STDMETHODIMP COleServerDoc::XOleInPlaceActiveObject::ResizeBorder(
	LPCRECT lprectBorder, LPOLEINPLACEUIWINDOW lpUIWindow, BOOL fFrameWindow)
{
	METHOD_PROLOGUE_EX(COleServerDoc, OleInPlaceActiveObject)
	ASSERT_VALID(pThis);

	SCODE sc = E_UNEXPECTED;
	TRY
	{
		pThis->OnResizeBorder(lprectBorder, lpUIWindow, fFrameWindow);
		sc = S_OK;
	}
	END_TRY

	return sc;
}

STDMETHODIMP COleServerDoc::XOleInPlaceActiveObject::EnableModeless(
	BOOL fEnable)
{
	METHOD_PROLOGUE_EX(COleServerDoc, OleInPlaceActiveObject)
	ASSERT_VALID(pThis);

	SCODE sc = E_UNEXPECTED;
	TRY
	{
		if (!fEnable)
		{
			// start modal state if not in modal state
			if (!pThis->m_pInPlaceFrame->InModalState())
			{
				CWnd* pTemp = pThis->m_pInPlaceFrame->EnsureTopLevelParent();
				BOOL bEnabled = pTemp->IsWindowEnabled();
				pThis->m_pInPlaceFrame->BeginModalState();
				pTemp->EnableWindow(bEnabled);
			}
		}
		else
		{
			// end modal state if in modal state
			if (pThis->m_pInPlaceFrame->InModalState())
				pThis->m_pInPlaceFrame->EndModalState();
		}
		sc = S_OK;
	}
	END_TRY

	return sc;
}

//////////////////////////////////////////////////////////////////////////////
// Diagnostics

#ifdef _DEBUG
void COleServerDoc::AssertValid() const
{
	COleLinkingDoc::AssertValid();
	if (m_pInPlaceFrame != NULL)
		m_pInPlaceFrame->AssertValid();
	if (m_pOrigParent != NULL)
		m_pOrigParent->AssertValid();
}

void COleServerDoc::Dump(CDumpContext& dc) const
{
	COleLinkingDoc::Dump(dc);

	if (dc.GetDepth() != 0)
	{
		if (m_pInPlaceFrame != NULL)
			dc << "\nwith in-place frame: " << m_pInPlaceFrame;
		else
			dc << "\nwith no in-place frame\n";
		if (m_pOrigParent != NULL)
			dc << "\nwith original parent: " << m_pOrigParent;
		else
			dc << "with no original parent\n";
	}
	dc << "m_lpClientSite = " << m_lpClientSite;
	dc << "\nm_strHostObj = " << m_strHostObj;
	dc << "\nm_bCntrVisible = " << m_bCntrVisible;
	dc << "\nm_dwOrigStyle = " << m_dwOrigStyle;

	dc << "\n";
}
#endif //_DEBUG

//////////////////////////////////////////////////////////////////////////////
// Inline function declarations expanded out-of-line

#ifndef _AFX_ENABLE_INLINES

// expand inlines for OLE server APIs
#define _AFXOLESVR_INLINE
#include "afxole.inl"

#endif //!_AFX_ENABLE_INLINES


IMPLEMENT_DYNAMIC(COleServerDoc, COleLinkingDoc)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\olestrm.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// COleStreamFile implementation

COleStreamFile::COleStreamFile(LPSTREAM lpStream)
{
	m_lpStream = lpStream;

	m_strStorageName.Empty();
	if (m_lpStream != NULL)
	{		
		STATSTG statstg;
		if (m_lpStream->Stat(&statstg, 0) == S_OK)
		{
			if (statstg.pwcsName != NULL)
			{
				TCHAR szTemp[_MAX_PATH];
				const CString strPath(statstg.pwcsName);

				if (strPath.GetLength() >= _MAX_PATH)
				{
					ASSERT(FALSE);

					// Before throwing the exception out, need free the
					// memory of statstg.pwcsName.
					CoTaskMemFree(statstg.pwcsName);

					// MFC requires paths with length < _MAX_PATH
					// No other way to handle the error from a constructor
					AfxThrowFileException(CFileException::badPath);
				}

				// We call AfxFullPath because in earlier versions of MFC,
				// we have called it to transform all paths to absolute paths.
				// AfxFullPath reverts to "plain" copy behavior for non-path
				// inputs, and returns FALSE.

				// By design, we ignore the return value of AfxFullPath because
				// OLE Stream names don't have to be valid paths.
				AfxFullPath(szTemp, strPath);
				CoTaskMemFree(statstg.pwcsName);
				m_strStorageName = szTemp;
			}
		}
	}
}

COleStreamFile::~COleStreamFile()
{
	AFX_BEGIN_DESTRUCTOR

	if (m_lpStream != NULL && m_bCloseOnDelete)
	{
		Close();
		ASSERT(m_lpStream == NULL);
	}

	AFX_END_DESTRUCTOR
}

LPSTREAM COleStreamFile::Detach()
{
	LPSTREAM lpStream = m_lpStream;
	m_lpStream = NULL;  // detach and transfer ownership of m_lpStream
	return lpStream;
}

void COleStreamFile::Attach(LPSTREAM lpStream)
{
	ASSERT(m_lpStream == NULL); // already attached to an LPSTREAM?
	ASSERT(lpStream != NULL);
	
	if (lpStream == NULL)
	{
		AfxThrowInvalidArgException();
	}

	m_lpStream = lpStream;
	m_bCloseOnDelete = FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// OLE streams helper

HRESULT AFXAPI _AfxReadFromStream(LPSTREAM pStream, void* lpBuf, UINT nCount, DWORD& nRead)
{
	if (nCount == 0)
	{
		nRead = 0;
		return S_OK;
	}

	ASSERT(AfxIsValidAddress(lpBuf, nCount));
	ASSERT(pStream != NULL);

	if (pStream == NULL || lpBuf == NULL)
	{
		return E_INVALIDARG;
	}

	// read from the stream
	SCODE sc = pStream->Read(lpBuf, nCount, &nRead);
	return ResultFromScode(sc);
}

/////////////////////////////////////////////////////////////////////////////
// OLE CFileException helpers

void AFXAPI _AfxFillOleFileException(CFileException* pError, SCODE sc)
{
	ASSERT(pError != NULL);
	ASSERT(FAILED(sc));

	int cause;  // portable CFileException.m_cause

	// error codes 255 or less are DOS/Win32 error codes
	if (SCODE_SEVERITY(sc) == SEVERITY_ERROR &&
		SCODE_FACILITY(sc) == FACILITY_STORAGE &&
		SCODE_CODE(sc) < 0x100)
	{
		ASSERT(SCODE_CODE(sc) != 0);

		// throw an exception matching to the DOS error
		//  (NOTE: only the DOS error part of the SCODE becomes m_lOsError)
		cause = CFileException::OsErrorToException(SCODE_CODE(sc));
		sc = (SCODE)SCODE_CODE(sc);
	}
	else
	{
		// attempt some conversion of storage specific error codes to generic
		//  CFileException causes...
		switch (sc)
		{
		case STG_E_INUSE:
		case STG_E_SHAREREQUIRED:
			cause = CFileException::sharingViolation;
			break;

		case STG_E_NOTCURRENT:
		case STG_E_REVERTED:
		case STG_E_CANTSAVE:
		case STG_E_OLDFORMAT:
		case STG_E_OLDDLL:
			cause = CFileException::genericException;
			break;

		default:
			cause = CFileException::genericException;
			break;
		}
	}

	// fill in pError
	pError->m_cause = cause;
	pError->m_lOsError = (LONG)sc;
}

void AFXAPI _AfxThrowOleFileException(SCODE sc)
{
	// ignore non-failure codes
	if (!FAILED(sc))
		return;

	// otherwise, construct and exception and throw it
	CFileException e;
	_AfxFillOleFileException(&e, sc);
	AfxThrowFileException(e.m_cause, e.m_lOsError);
}

/////////////////////////////////////////////////////////////////////////////
// COleStreamFile Attributes

BOOL COleStreamFile::GetStatus(CFileStatus& rStatus) const
{
	ASSERT_VALID(this);
	ASSERT(m_lpStream != NULL);

	// get status of the stream
	STATSTG statstg;
	if (m_lpStream->Stat(&statstg, 0) != S_OK)
		return FALSE;

	if (!CTime::IsValidFILETIME(statstg.mtime) ||
		!CTime::IsValidFILETIME(statstg.ctime) ||
		!CTime::IsValidFILETIME(statstg.atime))
	{
		return FALSE;
	}

	// map to CFileStatus struct
	rStatus.m_mtime = CTime(statstg.mtime);
	rStatus.m_ctime = CTime(statstg.ctime);
	rStatus.m_atime = CTime(statstg.atime);
	ASSERT(statstg.cbSize.HighPart == 0);
	rStatus.m_size = statstg.cbSize.LowPart;
	rStatus.m_attribute = 0;
	rStatus.m_szFullName[0] = '\0';
	if (statstg.pwcsName != NULL)
	{
		const CString strPath(statstg.pwcsName);

		// name was returned -- copy and free it
		Checked::tcsncpy_s(rStatus.m_szFullName, _countof(rStatus.m_szFullName), strPath.GetString(), _TRUNCATE);
		CoTaskMemFree(statstg.pwcsName);
	}
	return TRUE;
}

const CString COleStreamFile::GetStorageName() const
{
	ASSERT_VALID(this);
	return m_strStorageName;
}


ULONGLONG COleStreamFile::GetPosition() const
{
	ASSERT_VALID(this);
	ASSERT(m_lpStream != NULL);

	ULARGE_INTEGER liPosition;
	LARGE_INTEGER liZero; liZero.QuadPart = 0;
	SCODE sc = m_lpStream->Seek(liZero, STREAM_SEEK_CUR, &liPosition);
	if (sc != S_OK)
		_AfxThrowOleFileException(sc);

	return liPosition.QuadPart;
}


/////////////////////////////////////////////////////////////////////////////
// COleStreamFile Operations

BOOL COleStreamFile::OpenStream(LPSTORAGE lpStorage, LPCTSTR lpszStreamName,
	DWORD nOpenFlags, CFileException* pError)
{
	ASSERT_VALID(this);
	ASSERT(m_lpStream == NULL);
	ASSERT(lpStorage != NULL);
	ASSERT(AfxIsValidString(lpszStreamName));
	ASSERT(pError == NULL ||
		AfxIsValidAddress(pError, sizeof(CFileException)));

	if (lpStorage == NULL || lpszStreamName == NULL)
	{
		return FALSE;
	}

	const CStringW strStreamName(lpszStreamName);	

	SCODE sc = lpStorage->OpenStream(strStreamName.GetString(), NULL, nOpenFlags, 0, &m_lpStream);
	if (FAILED(sc) && pError != NULL)
		_AfxFillOleFileException(pError, sc);

	ASSERT(FAILED(sc) || m_lpStream != NULL);
	return !FAILED(sc);
}

BOOL COleStreamFile::CreateStream(LPSTORAGE lpStorage, LPCTSTR lpszStreamName,
	DWORD nOpenFlags, CFileException* pError)
{
	ASSERT_VALID(this);
	ASSERT(m_lpStream == NULL);
	ASSERT(lpStorage != NULL);
	ASSERT(AfxIsValidString(lpszStreamName));
	ASSERT(pError == NULL ||
		AfxIsValidAddress(pError, sizeof(CFileException)));

	if (lpStorage == NULL || lpszStreamName == NULL)
	{
		return FALSE;
	}

	STATSTG statstg;
	if (lpStorage->Stat(&statstg, 0) == S_OK)
	{
		if (statstg.pwcsName != NULL)
		{
			TCHAR szTemp[_MAX_PATH];
			const CString strPath(statstg.pwcsName);			

			// We call AfxFullPath because in earlier versions of MFC,
			// we have called it to transform all paths to absolute paths.
			// AfxFullPath reverts to "plain" copy behavior for non-path
			// inputs, and returns FALSE.

			// By design, we ignore the return value of AfxFullPath because
			// OLE Stream names don't have to be valid paths.
			AfxFullPath(szTemp, strPath);
			CoTaskMemFree(statstg.pwcsName);
			m_strStorageName = szTemp;
		}
	}

	const CStringW strStreamName(lpszStreamName);	
	SCODE sc = lpStorage->CreateStream(strStreamName.GetString(), nOpenFlags,	0, 0, &m_lpStream);

	if (FAILED(sc) && pError != NULL)
		_AfxFillOleFileException(pError, sc);

	ASSERT(FAILED(sc) || m_lpStream != NULL);
	return !FAILED(sc);
}

BOOL COleStreamFile::CreateMemoryStream(CFileException* pError)
{
	ASSERT_VALID(this);
	ASSERT(pError == NULL ||
		AfxIsValidAddress(pError, sizeof(CFileException)));

	SCODE sc = CreateStreamOnHGlobal(NULL, TRUE, &m_lpStream);
	if (FAILED(sc) && pError != NULL)
		_AfxFillOleFileException(pError, sc);

	ASSERT(FAILED(sc) || m_lpStream != NULL);
	return !FAILED(sc);
}

/////////////////////////////////////////////////////////////////////////////
// COleStreamFile Overrides

CFile* COleStreamFile::Duplicate() const
{
	ASSERT_VALID(this);
	ASSERT(m_lpStream != NULL);

	LPSTREAM lpStream;
	SCODE sc = m_lpStream->Clone(&lpStream);
	if (FAILED(sc))
		_AfxThrowOleFileException(sc);

	ASSERT(lpStream != NULL);
	COleStreamFile* pFile = NULL;

	TRY
	{
		// attempt to create the stream
		pFile = new COleStreamFile(lpStream);
		pFile->m_bCloseOnDelete = m_bCloseOnDelete;
	}
	CATCH_ALL(e)
	{
		// cleanup cloned stream
		lpStream->Release();
		THROW_LAST();
	}
	END_CATCH_ALL

	ASSERT(pFile != NULL);
	return pFile;
}

ULONGLONG COleStreamFile::Seek(LONGLONG lOff, UINT nFrom)
{
	ASSERT_VALID(this);
	ASSERT(m_lpStream != NULL);

	ASSERT(STREAM_SEEK_SET == begin);
	ASSERT(STREAM_SEEK_CUR == current);
	ASSERT(STREAM_SEEK_END == end);

	ULARGE_INTEGER liNewPosition;
	LARGE_INTEGER liOff;
   liOff.QuadPart = lOff;
	SCODE sc = m_lpStream->Seek(liOff, nFrom, &liNewPosition);
	if (sc != S_OK)
		_AfxThrowOleFileException(sc);

	return liNewPosition.QuadPart;
}

void COleStreamFile::SetLength(ULONGLONG dwNewLen)
{
	ASSERT_VALID(this);
	ASSERT(m_lpStream != NULL);

	ULARGE_INTEGER liNewLen;
   liNewLen.QuadPart = dwNewLen;
	SCODE sc = m_lpStream->SetSize(liNewLen);
	if (sc != S_OK)
		_AfxThrowOleFileException(sc);
}

ULONGLONG COleStreamFile::GetLength() const
{
	ASSERT_VALID(this);
	ASSERT(m_lpStream != NULL);

	// get status of the stream
	STATSTG statstg;
	SCODE sc = m_lpStream->Stat(&statstg, STATFLAG_NONAME);
	if (sc != S_OK)
		_AfxThrowOleFileException(sc);

	// map to CFileStatus struct
	return statstg.cbSize.QuadPart;
}

UINT COleStreamFile::Read(void* lpBuf, UINT nCount)
{
	ASSERT_VALID(this);
	ASSERT(m_lpStream != NULL);

	DWORD dwBytesRead;
	HRESULT hr = _AfxReadFromStream(m_lpStream, lpBuf, nCount, dwBytesRead);

	if (hr != S_OK)
		_AfxThrowOleFileException(hr);

	// always return number of bytes read
	return (UINT)dwBytesRead;
}

void COleStreamFile::Write(const void* lpBuf, UINT nCount)
{
	ASSERT_VALID(this);
	ASSERT(m_lpStream != NULL);

	if (nCount == 0)
		return;

	ASSERT(AfxIsValidAddress(lpBuf, nCount, FALSE));

	if (lpBuf == NULL)
	{	
		AfxThrowInvalidArgException();
	}

	// write to the stream
	DWORD dwBytesWritten;
	SCODE sc = m_lpStream->Write(lpBuf, nCount, &dwBytesWritten);
	if (sc != S_OK)
		_AfxThrowOleFileException(sc);

	// if no error, all bytes should have been written
	ASSERT((UINT)dwBytesWritten == nCount);
}

void COleStreamFile::LockRange(ULONGLONG dwPos, ULONGLONG dwCount)
{
	ASSERT_VALID(this);
	ASSERT(m_lpStream != NULL);

	// convert parameters to long integers
	ULARGE_INTEGER liPos;
   liPos.QuadPart = dwPos;
	ULARGE_INTEGER liCount;
   liCount.QuadPart = dwCount;

	// then lock the region
	SCODE sc = m_lpStream->LockRegion(liPos, liCount, LOCK_EXCLUSIVE);
	if (sc != S_OK)
		_AfxThrowOleFileException(sc);
}

void COleStreamFile::UnlockRange(ULONGLONG dwPos, ULONGLONG dwCount)
{
	ASSERT_VALID(this);
	ASSERT(m_lpStream != NULL);

	// convert parameters to long integers
	ULARGE_INTEGER liPos;
   liPos.QuadPart = dwPos;
	ULARGE_INTEGER liCount;
   liCount.QuadPart = dwCount;

	// then lock the region
	SCODE sc = m_lpStream->UnlockRegion(liPos, liCount, LOCK_EXCLUSIVE);
	if (sc != S_OK)
		_AfxThrowOleFileException(sc);
}

void COleStreamFile::Abort()
{
	ASSERT_VALID(this);

	if (m_lpStream != NULL)
	{
		m_lpStream->Revert();
		RELEASE(m_lpStream);
	}

	m_strStorageName.Empty();
}

void COleStreamFile::Flush()
{
	ASSERT_VALID(this);
	ASSERT(m_lpStream != NULL);

	// commit will return an error only if the stream is transacted
	SCODE sc = m_lpStream->Commit(0);
	if (sc != S_OK)
		_AfxThrowOleFileException(sc);
}

void COleStreamFile::Close()
{
	ASSERT_VALID(this);

	if (m_lpStream != NULL)
	{
		// commit the stream via Flush (which can be overriden)
		Flush();
		RELEASE(m_lpStream);
	}

	m_strStorageName.Empty();
}

IStream* COleStreamFile::GetStream() const
{
	return m_lpStream;
}

/////////////////////////////////////////////////////////////////////////////
// COleStreamFile diagnostics

#ifdef _DEBUG
void COleStreamFile::AssertValid() const
{
	CFile::AssertValid();
}

void COleStreamFile::Dump(CDumpContext& dc) const
{
	CFile::Dump(dc);

	dc << "m_lpStream = " << m_lpStream;
	dc << "m_strStorageName = \"" << m_strStorageName;
	dc << "\"\n";
}
#endif

////////////////////////////////////////////////////////////////////////////


IMPLEMENT_DYNAMIC(COleStreamFile, CFile)

////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\oletyplb.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CCmdTarget::EnableTypeLib - locks the typelib cache for this class

void CCmdTarget::EnableTypeLib()
{
	AfxLockGlobals(CRIT_TYPELIBCACHE);

	CTypeLibCache* pTypeLibCache = GetTypeLibCache();
	ASSERT(pTypeLibCache != NULL);  // must override GetTypeLibCache

	if (pTypeLibCache != NULL)
		pTypeLibCache->Lock();      // will be unlocked in OnFinalRelease

	AfxUnlockGlobals(CRIT_TYPELIBCACHE);
}

/////////////////////////////////////////////////////////////////////////////
// CCmdTarget::GetTypeInfoOfGuid - Returns typeinfo

HRESULT CCmdTarget::GetTypeInfoOfGuid(LCID lcid, REFGUID guid,
	LPTYPEINFO* ppTypeInfo)
{
	AfxLockGlobals(CRIT_TYPELIBCACHE);

	HRESULT hr = TYPE_E_CANTLOADLIBRARY;
	CTypeLibCache* pTypeLibCache = GetTypeLibCache();
	LPTYPELIB pTypeLib = NULL;

	// If type info is already cached, just return it.
	if (pTypeLibCache->LookupTypeInfo(lcid, guid, ppTypeInfo))
	{
		hr = S_OK;
	}
	else
	{
		// If type library isn't already cached, try to locate it.
		if (!pTypeLibCache->Lookup(lcid, &pTypeLib))
		{
			// First, try getting the subclass to load the type library
			// (normally this goes through LoadRegTypeLib).

			if (FAILED(GetTypeLib(lcid, &pTypeLib)))
			{
				AFX_MANAGE_STATE(m_pModuleState);

				// If that failed, try loading the type library from our own
				// resources.

				TCHAR szPath[_MAX_PATH];
				GetModuleFileName(AfxGetInstanceHandle(), szPath, _MAX_PATH);
				const CStringW strPath(szPath);
				if (FAILED(LoadTypeLib(strPath.GetString(), &pTypeLib)))
					pTypeLib = NULL;
			}

			pTypeLibCache->Cache(lcid, pTypeLib);
		}

		// If we got a type library, extract the requested type info.
		if (pTypeLib != NULL)
		{
			hr = pTypeLib->GetTypeInfoOfGuid(guid, ppTypeInfo);
			pTypeLib->Release();
			pTypeLibCache->CacheTypeInfo(lcid, guid, *ppTypeInfo);
		}
	}

	AfxUnlockGlobals(CRIT_TYPELIBCACHE);

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// AfxGetTypeLibCache

CTypeLibCache* AFXAPI AfxGetTypeLibCache(const GUID* pTypeLibID)
{
	AFX_MODULE_STATE* pModuleState = AfxGetModuleState();
	ASSERT(pModuleState != NULL);

	if (pModuleState->m_pTypeLibCacheMap == NULL)
	{
		const GUID* pCachedTypeLibID = pModuleState->m_typeLibCache.m_pTypeLibID;

		if (pCachedTypeLibID == NULL)
		{
			// Cache not initialized yet; initialize it now
			pModuleState->m_typeLibCache.m_pTypeLibID = pTypeLibID;
			return &pModuleState->m_typeLibCache;
		}
		else if (pCachedTypeLibID == pTypeLibID)
		{
			// This is the cache we need; return it
			return &pModuleState->m_typeLibCache;
		}
		else
		{
			// Another cache is needed; initialize the map
			pModuleState->m_pTypeLibCacheMap = new CTypeLibCacheMap;
			pModuleState->m_pTypeLibCacheMap->SetAt(
				(void*)(const void*)pModuleState->m_typeLibCache.m_pTypeLibID,
				&pModuleState->m_typeLibCache);

			// FALL THRU
		}
	}

	ASSERT(pModuleState->m_pTypeLibCacheMap != NULL);

	// Try to locate cache in the map
	CTypeLibCache* pCache;
	if (!pModuleState->m_pTypeLibCacheMap->Lookup((void*)(const void*)pTypeLibID,
		(void*&)pCache))
	{
		// Create new cache and add it to the map
		pCache = new CTypeLibCache;
		pCache->m_pTypeLibID = pTypeLibID;
		pModuleState->m_pTypeLibCacheMap->SetAt((void*)(const void*)pTypeLibID, pCache);
	}

	ASSERT(pCache != NULL);
	ASSERT(pCache->m_pTypeLibID == pTypeLibID);
	return pCache;
}

/////////////////////////////////////////////////////////////////////////////
// CTypeLibCache
// (Note: CTypeLibCache::Unlock is implemented in afxstate.cpp)

void CTypeLibCache::Lock()
{
	ASSERT(m_cRef >= 0);

	if (m_cRef == 0)
		m_lcid = (LCID)-1;

	InterlockedIncrement(&m_cRef);
}

BOOL CTypeLibCache::Lookup(LCID lcid, LPTYPELIB* pptlib)
{
	if ((m_lcid != -1) && (m_lcid == lcid))
	{
		ASSERT(m_ptlib != NULL);
		*pptlib = m_ptlib;
		m_ptlib->AddRef();
		return TRUE;
	}
	else
	{
		*pptlib = NULL;
		return FALSE;
	}
}

void CTypeLibCache::Cache(LCID lcid, LPTYPELIB ptlib)
{
	if (ptlib != NULL)
	{
		m_lcid = lcid;
		m_guidInfo = GUID_NULL;
		RELEASE(m_ptinfo);
		RELEASE(m_ptlib);
		m_ptlib = ptlib;
		m_ptlib->AddRef();
	}
}

BOOL CTypeLibCache::LookupTypeInfo(LCID lcid, REFGUID guid,
	LPTYPEINFO* pptinfo)
{
	if ((m_lcid != -1) && (m_lcid == lcid) && (m_ptinfo != NULL) &&
		IsEqualGUID(m_guidInfo, guid))
	{
		ASSERT(m_ptlib != NULL);
		ASSERT(m_ptinfo != NULL);
		*pptinfo = m_ptinfo;
		m_ptinfo->AddRef();
		return TRUE;
	}
	else
	{
		*pptinfo = NULL;
		return FALSE;
	}
}

void CTypeLibCache::CacheTypeInfo(LCID lcid, REFGUID guid, LPTYPEINFO ptinfo)
{
	if ((ptinfo != NULL) && (m_lcid == lcid))
	{
		m_guidInfo = guid;
		RELEASE(m_ptinfo);
		m_ptinfo = ptinfo;
		m_ptinfo->AddRef();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\oleui1.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// User interface for COleClientItem

BOOL COleClientItem::ReportError(SCODE sc) const
	// return TRUE if error or warning reported
{
	ASSERT_VALID(this);
	UINT nIDPrompt = 0;

	switch (sc)
	{
	case OLE_E_STATIC:
		nIDPrompt = AFX_IDP_STATIC_OBJECT;
		break;

	case E_NOINTERFACE:
	case E_NOTIMPL:
	case E_FAIL:
		nIDPrompt = AFX_IDP_FAILED_TO_CONNECT;
		break;

	case E_OUTOFMEMORY:
		nIDPrompt = AFX_IDP_FAILED_MEMORY_ALLOC;
		break;

	default:
		return FALSE;       // nothing sensible to report
	}

	ASSERT(nIDPrompt != 0);
	AfxMessageBox(nIDPrompt);
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// Item activation

BOOL COleClientItem::DoVerb(LONG nVerb, CView* pView, LPMSG lpMsg)
{
	ASSERT_VALID(this);
	if (pView != NULL)
		ASSERT_VALID(pView);
	if (lpMsg != NULL)
		ASSERT(AfxIsValidAddress(lpMsg, sizeof(MSG), FALSE));

	TRY
	{
		Activate(nVerb, pView, lpMsg);
	}
	CATCH(COleException, e)
	{
		// catch OLE errors and report them as such
		if (!ReportError(e->m_sc))
			AfxMessageBox(AFX_IDP_FAILED_TO_LAUNCH);
		DELETE_EXCEPTION(e);
		return FALSE;
	}
	AND_CATCH_ALL(e)
	{
		// otherwise, show generic error
		AfxMessageBox(AFX_IDP_FAILED_TO_LAUNCH);
		DELETE_EXCEPTION(e);
		return FALSE;
	}
	END_CATCH_ALL

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// COleClientDoc - user interface implementation
//  (functions reside in COleDocument to enable them on the server as well)

BOOL COleDocument::OnCmdMsg(UINT nID, int nCode, void* pExtra,
		AFX_CMDHANDLERINFO* pHandlerInfo)
{
	ASSERT_VALID(this);

	if (nCode == CN_COMMAND && nID >= ID_OLE_VERB_FIRST && nID <= ID_OLE_VERB_LAST)
	{
		CView* pRoutingView = GetRoutingView_();
		COleClientItem* pSel = GetPrimarySelectedItem(pRoutingView);
		if (pSel != NULL)
		{
			if (pHandlerInfo != NULL)       // routing test
			{
				pHandlerInfo->pTarget = this;
				return TRUE;        // would be handled here
			}

			// activate the current selection with the appropriate verb
			CWaitCursor wait;
			pSel->DoVerb(nID - ID_OLE_VERB_FIRST, pRoutingView);
			return TRUE;    // handled
		}
	}
	return CDocument::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
}

COleClientItem* COleDocument::GetPrimarySelectedItem(CView* pView)
{
	ASSERT_VALID(this);
	ASSERT(pView != NULL);
	ASSERT_VALID(pView);

	COleClientItem* pSelectedItem = NULL;

	// walk all items in the document - return one if there
	//   is only one client item selected
	// (note: non OLE client items are ignored)
	POSITION pos = GetStartPosition();
	COleClientItem* pItem;
	while ((pItem = GetNextClientItem(pos)) != NULL)
	{
		if (pView->IsSelected(pItem))
		{
			// client item selected in
			if (pSelectedItem != NULL)
				return NULL;        // more than one - no primary selection
			pSelectedItem = pItem;
		}
	}
	return pSelectedItem;
}

/////////////////////////////////////////////////////////////////////////////
// In-place item handling

COleClientItem* COleDocument::GetInPlaceActiveItem(CWnd* pWnd)
{
	ASSERT_VALID(this);
	ASSERT(pWnd != NULL);
	ASSERT_VALID(pWnd);

	// check for any item active on the immediate frame of pWndContainer
	//  (two active objects on same frame are not supported)
	if (!pWnd->IsFrameWnd())
	{
		CFrameWnd* pFrameWnd = pWnd->GetParentFrame();
		if (pFrameWnd != NULL)
			pWnd = pFrameWnd;
	}

	POSITION pos = GetStartPosition();
	COleClientItem* pItem;
	while ((pItem = GetNextClientItem(pos)) != NULL)
	{
		if (pItem->m_pView != NULL && pItem->IsInPlaceActive() &&
			(pItem->m_pView == pWnd ||
			 pItem->m_pView->GetParentFrame() == pWnd))
		{
			// that item is active on pWndContainer
			return pItem;
		}
	}

	// no item active on that window
	return NULL;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\olevar1.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////
// new COleVariant code (uses new features of OLEAUT32.DLL)

COleVariant::COleVariant(LPCITEMIDLIST pidl)
{
	AfxVariantInit(this);

	if (pidl != NULL)
	{
		// walk through entries in the list and accumulate their size

		UINT cbTotal = 0;
		SAFEARRAY *psa = NULL;
		LPCITEMIDLIST pidlWalker = pidl;

		while (pidlWalker->mkid.cb)
		{
			cbTotal += pidlWalker->mkid.cb;
			pidlWalker = (LPCITEMIDLIST)
				(((LPBYTE)pidlWalker) + pidlWalker->mkid.cb);
		}

		// add the base structure size
		cbTotal += sizeof(ITEMIDLIST);

		// get a safe array for them
		psa = SafeArrayCreateVector(VT_UI1, 0, cbTotal);

		// copy it and set members
		if (psa != NULL)
		{
			Checked::memcpy_s(psa->pvData, cbTotal, (LPBYTE) pidl, cbTotal);
			vt = VT_ARRAY | VT_UI1;
			parray = psa;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\olevar.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include <afxtempl.h>
#include <math.h>


/////////////////////////////////////////////////////////////////////////////
// helpers
typedef CFixedStringT<CStringW, 256> CTempStringW;

void AFXAPI AfxCheckError(SCODE sc)
{
	if (FAILED(sc))
	{
		if (sc == E_OUTOFMEMORY)
			AfxThrowMemoryException();
		else
			AfxThrowOleException(sc);
	}
}

AFX_STATIC BOOL AFXAPI _AfxCompareSafeArrays(SAFEARRAY* parray1, SAFEARRAY* parray2)
{
	BOOL bCompare = FALSE;

	// If one is NULL they must both be NULL to compare
	if (parray1 == NULL || parray2 == NULL)
	{
		return parray1 == parray2;
	}

	// Dimension must match and if 0, then arrays compare
	DWORD dwDim1 = ::SafeArrayGetDim(parray1);
	DWORD dwDim2 = ::SafeArrayGetDim(parray2);
	if (dwDim1 != dwDim2)
		return FALSE;
	else if (dwDim1 == 0)
		return TRUE;

	// Element size must match
	DWORD dwSize1 = ::SafeArrayGetElemsize(parray1);
	DWORD dwSize2 = ::SafeArrayGetElemsize(parray2);
	if (dwSize1 != dwSize2)
		return FALSE;

	long* pLBound1 = NULL;
	long* pLBound2 = NULL;
	long* pUBound1 = NULL;
	long* pUBound2 = NULL;

	void* pData1 = NULL;
	void* pData2 = NULL;

	TRY
	{
		// Bounds must match
		pLBound1 = new long[dwDim1];
		pLBound2 = new long[dwDim2];
		pUBound1 = new long[dwDim1];
		pUBound2 = new long[dwDim2];

		size_t nTotalElements = 1;

		// Get and compare bounds
		for (DWORD dwIndex = 0; dwIndex < dwDim1; dwIndex++)
		{
			AfxCheckError(::SafeArrayGetLBound(
				parray1, dwIndex+1, &pLBound1[dwIndex]));
			AfxCheckError(::SafeArrayGetLBound(
				parray2, dwIndex+1, &pLBound2[dwIndex]));
			AfxCheckError(::SafeArrayGetUBound(
				parray1, dwIndex+1, &pUBound1[dwIndex]));
			AfxCheckError(::SafeArrayGetUBound(
				parray2, dwIndex+1, &pUBound2[dwIndex]));

			// Check the magnitude of each bound
			if (pUBound1[dwIndex] - pLBound1[dwIndex] !=
				pUBound2[dwIndex] - pLBound2[dwIndex])
			{
				delete[] pLBound1;
				delete[] pLBound2;
				delete[] pUBound1;
				delete[] pUBound2;

				return FALSE;
			}

			// Increment the element count
			nTotalElements *= pUBound1[dwIndex] - pLBound1[dwIndex] + 1;
		}

		// Access the data
		AfxCheckError(::SafeArrayAccessData(parray1, &pData1));
		AfxCheckError(::SafeArrayAccessData(parray2, &pData2));

		// Calculate the number of bytes of data and compare
		size_t nSize = nTotalElements * dwSize1;
		int nOffset = memcmp(pData1, pData2, nSize);
		bCompare = nOffset == 0;

		// Release the array locks
		AfxCheckError(::SafeArrayUnaccessData(parray1));
		AfxCheckError(::SafeArrayUnaccessData(parray2));
	}
	CATCH_ALL(e)
	{
		// Clean up bounds arrays
		delete[] pLBound1;
		delete[] pLBound2;
		delete[] pUBound1;
		delete[] pUBound2;

		// Release the array locks
		if (pData1 != NULL)
			AfxCheckError(::SafeArrayUnaccessData(parray1));
		if (pData2 != NULL)
			AfxCheckError(::SafeArrayUnaccessData(parray2));

		THROW_LAST();
	}
	END_CATCH_ALL

	// Clean up bounds arrays
	delete[] pLBound1;
	delete[] pLBound2;
	delete[] pUBound1;
	delete[] pUBound2;

	return bCompare;
}

AFX_STATIC void AFXAPI _AfxCreateOneDimArray(VARIANT& varSrc, DWORD dwSize)
{
	UINT nDim;

	// Clear VARIANT and re-create SafeArray if necessary
	if (varSrc.vt != (VT_UI1 | VT_ARRAY) ||
		(nDim = ::SafeArrayGetDim(varSrc.parray)) != 1)
	{
		VERIFY(::VariantClear(&varSrc) == NOERROR);
		varSrc.vt = VT_UI1 | VT_ARRAY;

		SAFEARRAYBOUND bound;
		bound.cElements = dwSize;
		bound.lLbound = 0;
		varSrc.parray = ::SafeArrayCreate(VT_UI1, 1, &bound);
		if (varSrc.parray == NULL)
			AfxThrowMemoryException();
	}
	else
	{
		// Must redimension array if necessary
		long lLower, lUpper;
		AfxCheckError(::SafeArrayGetLBound(varSrc.parray, 1, &lLower));
		AfxCheckError(::SafeArrayGetUBound(varSrc.parray, 1, &lUpper));

		// Upper bound should always be greater than lower bound
		long lSize = lUpper - lLower;
		if (lSize < 0)
		{
			ASSERT(FALSE);
			lSize = 0;

		}

		if ((DWORD)lSize != dwSize)
		{
			SAFEARRAYBOUND bound;
			bound.cElements = dwSize;
			bound.lLbound = lLower;
			AfxCheckError(::SafeArrayRedim(varSrc.parray, &bound));
		}
	}
}

AFX_STATIC void AFXAPI _AfxCopyBinaryData(SAFEARRAY* parray, const void* pvSrc, DWORD dwSize)
{
	// Access the data, copy it and unaccess it.
	void* pDest;
	AfxCheckError(::SafeArrayAccessData(parray, &pDest));
	Checked::memcpy_s(pDest, dwSize, pvSrc, dwSize);
	AfxCheckError(::SafeArrayUnaccessData(parray));
}

/////////////////////////////////////////////////////////////////////////////
// COleVariant class

COleVariant::COleVariant(const VARIANT& varSrc)
{
	AfxVariantInit(this);
	AfxCheckError(::VariantCopy(this, (LPVARIANT)&varSrc));
}

COleVariant::COleVariant(LPCVARIANT pSrc)
{
	AfxVariantInit(this);
	AfxCheckError(::VariantCopy(this, (LPVARIANT)pSrc));
}

COleVariant::COleVariant(const COleVariant& varSrc)
{
	AfxVariantInit(this);
	AfxCheckError(::VariantCopy(this, (LPVARIANT)&varSrc));
}

COleVariant::COleVariant(LPCTSTR lpszSrc, VARTYPE vtSrc)
{
#if defined (UNICODE)
	ASSERT(vtSrc == VT_BSTR);
#else
	ASSERT(vtSrc == VT_BSTR || vtSrc == VT_BSTRT);
#endif
	UNUSED(vtSrc);

	vt = VT_BSTR;
	bstrVal = NULL;

	if (lpszSrc != NULL)
	{
#ifndef _UNICODE
		if (vtSrc == VT_BSTRT)
		{
			int nLen = lstrlen(lpszSrc);
			bstrVal = ::SysAllocStringByteLen(lpszSrc, nLen);
			
			if (bstrVal == NULL)
				AfxThrowMemoryException();
		}
		else
#endif
		{
			bstrVal = CTempStringW(lpszSrc).AllocSysString();
		}
	}
}



void COleVariant::SetString(LPCTSTR lpszSrc, VARTYPE vtSrc)
{
#if defined (UNICODE)
	ASSERT(vtSrc == VT_BSTR);
#else
	ASSERT(vtSrc == VT_BSTR || vtSrc == VT_BSTRT);
#endif
	UNUSED(vtSrc);

	// Free up previous VARIANT
	Clear();

	vt = VT_BSTR;
	bstrVal = NULL;

	if (lpszSrc != NULL)
	{
#ifndef _UNICODE
		if (vtSrc == VT_BSTRT)
		{
			int nLen = lstrlen(lpszSrc);
			bstrVal = ::SysAllocStringByteLen(lpszSrc, nLen);

			if (bstrVal == NULL)
				AfxThrowMemoryException();
		}
		else
#endif
		{
			bstrVal = CTempStringW(lpszSrc).AllocSysString();
		}
	}
}

COleVariant::COleVariant(short nSrc, VARTYPE vtSrc)
{
	ASSERT(vtSrc == VT_I2 || vtSrc == VT_BOOL);

	if (vtSrc == VT_BOOL)
	{
		vt = VT_BOOL;
		if (!nSrc)
			V_BOOL(this) = AFX_OLE_FALSE;
		else
			V_BOOL(this) = AFX_OLE_TRUE;
	}
	else
	{
		vt = VT_I2;
		iVal = nSrc;
	}
}

COleVariant::COleVariant(long lSrc, VARTYPE vtSrc)
{
	ASSERT(vtSrc == VT_I4 || vtSrc == VT_ERROR || vtSrc == VT_BOOL
		|| vtSrc == VT_UINT || vtSrc == VT_INT || vtSrc == VT_UI4
		|| vtSrc == VT_HRESULT);

	if (vtSrc == VT_ERROR)
	{
		vt = VT_ERROR;
		scode = lSrc;
	}
	else if (vtSrc == VT_BOOL)
	{
		vt = VT_BOOL;
		if (!lSrc)
			V_BOOL(this) = AFX_OLE_FALSE;
		else
			V_BOOL(this) = AFX_OLE_TRUE;
	}
	else if (vtSrc == VT_INT)
	{
		vt = VT_INT;
	 	V_INT(this) = lSrc;
	}
	else if (vtSrc == VT_UINT)
	{
		vt = VT_UINT;
	 	V_UINT(this) = lSrc;
	}
	else if (vtSrc == VT_HRESULT)
	{
		vt = VT_HRESULT;
		V_ERROR(this) = lSrc;
	}
	else if (vtSrc == VT_UI4)
	{
		vt = VT_UI4;
		lVal = lSrc;
	}
	else
	{
		vt = VT_I4;
		lVal = lSrc;
	}
}

// Operations
void COleVariant::ChangeType(VARTYPE vartype, LPVARIANT pSrc)
{
	// If pSrc is NULL, convert type in place
	if (pSrc == NULL)
		pSrc = this;
	if (pSrc != this || vartype != vt)
		AfxCheckError(::VariantChangeType(this, pSrc, 0, vartype));
}

void COleVariant::Attach(VARIANT& varSrc)
{
	// Free up previous VARIANT
	Clear();

	// give control of data to COleVariant 
	Checked::memcpy_s(this, sizeof(VARIANT), &varSrc, sizeof(varSrc));
	varSrc.vt = VT_EMPTY;
}

VARIANT COleVariant::Detach()
{
	VARIANT varResult = *this;
	vt = VT_EMPTY;
	return varResult;
}

void COleVariant::GetByteArrayFromVariantArray(CByteArray& bytes)
{
	ASSERT( V_ISARRAY(this) );

	LPVOID pSrc;
	LPVOID pDest;
	HRESULT hResult;
	ULONG nDim;
	LONG iLowerBound;
	LONG iUpperBound;
	LONG nElements;
	ULONG nBytes;

	hResult = ::SafeArrayAccessData(V_ARRAY(this), &pSrc);
	AfxCheckError(hResult);
	
	nDim = ::SafeArrayGetDim(V_ARRAY(this));
	ASSERT( (nDim == 0) || (nDim == 1) );

	if (nDim == 1)
	{
		::SafeArrayGetLBound(V_ARRAY(this), 1, &iLowerBound);
		::SafeArrayGetUBound(V_ARRAY(this), 1, &iUpperBound);
		nElements = (iUpperBound-iLowerBound)+1;
		nBytes = nElements*::SafeArrayGetElemsize(V_ARRAY(this));
		bytes.SetSize( nBytes );
		pDest = bytes.GetData();
		Checked::memcpy_s(pDest, nBytes, pSrc, nBytes);
	}
	else
	{
		bytes.SetSize(0);
	}

	::SafeArrayUnaccessData(V_ARRAY(this));
}

// Literal comparison. Types and values must match.
BOOL COleVariant::operator==(const VARIANT& var) const
{
	if (&var == this)
		return TRUE;

	// Variants not equal if types don't match
	if (var.vt != vt)
		return FALSE;

	// Check type specific values
	switch (vt)
	{
	case VT_EMPTY:
	case VT_NULL:
		return TRUE;

	case VT_BOOL:
		return V_BOOL(&var) == V_BOOL(this);

	case VT_I1:
		return var.cVal == cVal;

	case VT_UI1:
		return var.bVal == bVal;

	case VT_I2:
		return var.iVal == iVal;

	case VT_UI2:
		return var.uiVal == uiVal;

	case VT_I4:
		return var.lVal == lVal;

	case VT_UI4:
		return var.ulVal == ulVal;

	case VT_I8:
		return var.llVal == llVal;

	case VT_UI8:
		return var.ullVal == ullVal;

	case VT_CY:
		return (var.cyVal.Hi == cyVal.Hi && var.cyVal.Lo == cyVal.Lo);

	case VT_R4:
		return var.fltVal == fltVal;

	case VT_R8:
		return var.dblVal == dblVal;

	case VT_DATE:
		return var.date == date;

	case VT_BSTR:
		return SysStringByteLen(var.bstrVal) == SysStringByteLen(bstrVal) &&
			memcmp(var.bstrVal, bstrVal, SysStringByteLen(bstrVal)) == 0;

	case VT_ERROR:
		return var.scode == scode;

	case VT_DISPATCH:
	case VT_UNKNOWN:
		return var.punkVal == punkVal;

	default:
		if (vt & VT_ARRAY && !(vt & VT_BYREF))
			return _AfxCompareSafeArrays(var.parray, parray);
		else
			ASSERT(FALSE);  // VT_BYREF not supported
		// fall through
	}

	return FALSE;
}

const COleVariant& COleVariant::operator=(const VARIANT& varSrc)
{
	if(static_cast<LPVARIANT>(this) != &varSrc)
	{
	AfxCheckError(::VariantCopy(this, (LPVARIANT)&varSrc));
	}

	return *this;
}

const COleVariant& COleVariant::operator=(LPCVARIANT pSrc)
{
	if(static_cast<LPCVARIANT>(this) != pSrc)
	{
	AfxCheckError(::VariantCopy(this, (LPVARIANT)pSrc));
	}

	return *this;
}

const COleVariant& COleVariant::operator=(const COleVariant& varSrc)
{
	if(this != &varSrc)
	{
	AfxCheckError(::VariantCopy(this, (LPVARIANT)&varSrc));
	}

	return *this;
}

const COleVariant& COleVariant::operator=(const LPCTSTR lpszSrc)
{
	// Free up previous VARIANT
	Clear();

	vt = VT_BSTR;
	if (lpszSrc == NULL)
		bstrVal = NULL;
	else
	{
		bstrVal = CTempStringW(lpszSrc).AllocSysString();
	}
	return *this;
}

const COleVariant& COleVariant::operator=(const CString& strSrc)
{
	// Free up previous VARIANT
	Clear();

	vt = VT_BSTR;
	bstrVal = strSrc.AllocSysString();

	return *this;
}

const COleVariant& COleVariant::operator=(BYTE nSrc)
{
	// Free up previous VARIANT if necessary
	if (vt != VT_UI1)
	{
		Clear();
		vt = VT_UI1;
	}

	bVal = nSrc;
	return *this;
}

const COleVariant& COleVariant::operator=(short nSrc)
{
	if (vt == VT_I2)
		iVal = nSrc;
	else if (vt == VT_BOOL)
	{
		if (!nSrc)
			V_BOOL(this) = AFX_OLE_FALSE;
		else
			V_BOOL(this) = AFX_OLE_TRUE;
	}
	else
	{
		// Free up previous VARIANT
		Clear();
		vt = VT_I2;
		iVal = nSrc;
	}

	return *this;
}

const COleVariant& COleVariant::operator=(long lSrc)
{
	if (vt == VT_I4)
		lVal = lSrc;
	else if (vt == VT_ERROR)
		scode = lSrc;
	else if (vt == VT_BOOL)
	{
		if (!lSrc)
			V_BOOL(this) = AFX_OLE_FALSE;
		else
			V_BOOL(this) = AFX_OLE_TRUE;
	}
	else
	{
		// Free up previous VARIANT
		Clear();
		vt = VT_I4;
		lVal = lSrc;
	}

	return *this;
}

#if (_WIN32_WINNT >= 0x0501) || defined(_ATL_SUPPORT_VT_I8)
const COleVariant& COleVariant::operator=(LONGLONG nSrc)
{
	if (vt != VT_I8)
	{
		Clear();
		vt = VT_I8;
	}

	llVal = nSrc;
	return *this;
}

const COleVariant& COleVariant::operator=(ULONGLONG nSrc)
{
	if (vt != VT_UI8)
	{
		Clear();
		vt = VT_UI8;
	}

	ullVal = nSrc;
	return *this;
}
#endif

const COleVariant& COleVariant::operator=(const COleCurrency& curSrc)
{
	// Free up previous VARIANT if necessary
	if (vt != VT_CY)
	{
		Clear();
		vt = VT_CY;
	}

	cyVal = curSrc.m_cur;
	return *this;
}

const COleVariant& COleVariant::operator=(float fltSrc)
{
	// Free up previous VARIANT if necessary
	if (vt != VT_R4)
	{
		Clear();
		vt = VT_R4;
	}

	fltVal = fltSrc;
	return *this;
}

const COleVariant& COleVariant::operator=(double dblSrc)
{
	// Free up previous VARIANT if necessary
	if (vt != VT_R8)
	{
		Clear();
		vt = VT_R8;
	}

	dblVal = dblSrc;
	return *this;
}

const COleVariant& COleVariant::operator=(const COleDateTime& dateSrc)
{
	// Free up previous VARIANT if necessary
	if (vt != VT_DATE)
	{
		Clear();
		vt = VT_DATE;
	}

	date = dateSrc;
	return *this;
}

const COleVariant& COleVariant::operator=(const CByteArray& arrSrc)
{
	INT_PTR nSize = arrSrc.GetSize();
	if( nSize > LONG_MAX )
	{
		AfxThrowMemoryException();
	}

	// Set the correct type and make sure SafeArray can hold data
	_AfxCreateOneDimArray(*this, (DWORD)nSize);

	// Copy the data into the SafeArray
	_AfxCopyBinaryData(parray, arrSrc.GetData(), (DWORD)nSize);

	return *this;
}

const COleVariant& COleVariant::operator=(const CLongBinary& lbSrc)
{
	// Set the correct type and make sure SafeArray can hold data
	if( lbSrc.m_dwDataLength > LONG_MAX )
	{
		AfxThrowMemoryException();
	}
	_AfxCreateOneDimArray(*this, (ULONG)lbSrc.m_dwDataLength);

	// Copy the data into the SafeArray
	BYTE* pData = (BYTE*)::GlobalLock(lbSrc.m_hData);
	_AfxCopyBinaryData(parray, pData, (ULONG)lbSrc.m_dwDataLength);
	::GlobalUnlock(lbSrc.m_hData);

	return *this;
}

void AFXAPI AfxVariantInit(LPVARIANT pVar)
{
	memset(pVar, 0, sizeof(*pVar));
}

/////////////////////////////////////////////////////////////////////////////
// Diagnostics

#ifdef _DEBUG
CDumpContext& AFXAPI operator <<(CDumpContext& dc, COleVariant varSrc)
{
	LPCVARIANT pSrc = (LPCVARIANT)varSrc;

	dc << "\nCOleVariant Object:";
	dc << "\n\t vt = " << pSrc->vt;

	// No support for VT_BYREF & VT_ARRAY
	if (pSrc->vt & VT_BYREF || pSrc->vt & VT_ARRAY)
		return dc;

	switch (pSrc->vt)
	{
	case VT_BOOL:
		return dc << "\n\t VT_BOOL = " << V_BOOL(pSrc);

	case VT_I1:
		return dc << "\n\t cVal = " << pSrc->cVal;

	case VT_UI1:
		return dc << "\n\t bVal = " << pSrc->bVal;

	case VT_I2:
		return dc << "\n\t iVal = " << pSrc->iVal;

	case VT_UI2:
		return dc << "\n\t uiVal = " << pSrc->uiVal;

	case VT_I4:
		return dc << "\n\t lVal = " << pSrc->lVal;

	case VT_UI4:
		return dc << "\n\t ulVal = " << pSrc->ulVal;

	case VT_I8:
		return dc << "\n\t llVal = " << pSrc->llVal;

	case VT_UI8:
		return dc << "\n\t ullVal = " << pSrc->ullVal;

	case VT_CY:
		{
			COleVariant var(varSr