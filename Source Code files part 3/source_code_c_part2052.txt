     });

            concatStream.Source = archiveStream;

            if (maxArchiveSize > 0)
            {
                concatStream.SetLength(maxArchiveSize);
            }

            Stream compressionStream = compressionStreamCreator(concatStream);

            try
            {
                byte[] buf = new byte[4096];
                long bytesRemaining = fileStream.Length;
                int counter = 0;
                while (bytesRemaining > 0)
                {
                    int count = (int) Math.Min(
                        bytesRemaining, (long) buf.Length);

                    count = fileCrcStream.Read(buf, 0, count);
                    if (count <= 0)
                    {
                        throw new ZipException(
                            "Failed to read file: " + this.currentFileName);
                    }

                    compressionStream.Write(buf, 0, count);
                    bytesRemaining -= count;

                    this.fileBytesProcessed += count;
                    this.currentFileBytesProcessed += count;
                    this.currentArchiveTotalBytes = concatStream.Source.Position;
                    this.currentArchiveBytesProcessed = this.currentArchiveTotalBytes;

                    if (++counter % 16 == 0) // Report every 64K
                    {
                        this.OnProgress(ArchiveProgressType.PartialFile);
                    }
                }

                if (compressionStream is DeflateStream)
                {
                    compressionStream.Close();
                }
                else
                {
                    compressionStream.Flush();
                }
            }
            finally
            {
                archiveStream = concatStream.Source;
            }

            bytesWritten += archiveStream.Position - writeStartPosition;

            crc = fileCrcStream.Crc;

            return bytesWritten;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup1\Compression.Zip\ZipUnpacker.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ZipUnpacker.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Zip
{
    using System;
    using System.IO;
    using System.IO.Compression;
    using System.Collections.Generic;

    public partial class ZipEngine
    {
        /// <summary>
        /// Extracts files from a zip archive or archive chain.
        /// </summary>
        /// <param name="streamContext">A context interface to handle opening
        /// and closing of archive and file streams.</param>
        /// <param name="fileFilter">An optional predicate that can determine
        /// which files to process.</param>
        /// <exception cref="ArchiveException">The archive provided
        /// by the stream context is not valid.</exception>
        /// <remarks>
        /// The <paramref name="fileFilter"/> predicate takes an internal file
        /// path and returns true to include the file or false to exclude it.
        /// </remarks>
        public override void Unpack(
            IUnpackStreamContext streamContext,
            Predicate<string> fileFilter)
        {
            if (streamContext == null)
            {
                throw new ArgumentNullException("streamContext");
            }

            lock (this)
            {
                IList<ZipFileHeader> allHeaders = this.GetCentralDirectory(streamContext);
                if (allHeaders == null)
                {
                    throw new ZipException("Zip central directory not found.");
                }

                IList<ZipFileHeader> headers = new List<ZipFileHeader>(allHeaders.Count);
                foreach (ZipFileHeader header in allHeaders)
                {
                    if (!header.IsDirectory &&
                        (fileFilter == null || fileFilter(header.fileName)))
                    {
                        headers.Add(header);
                    }
                }

                this.ResetProgressData();

                // Count the total number of files and bytes to be compressed.
                this.totalFiles = headers.Count;
                foreach (ZipFileHeader header in headers)
                {
                    long compressedSize;
                    long uncompressedSize;
                    long localHeaderOffset;
                    int archiveNumber;
                    uint crc;
                    header.GetZip64Fields(
                        out compressedSize,
                        out uncompressedSize,
                        out localHeaderOffset,
                        out archiveNumber,
                        out crc);

                    this.totalFileBytes += uncompressedSize;
                    if (archiveNumber >= this.totalArchives)
                    {
                        this.totalArchives = (short) (archiveNumber + 1);
                    }
                }

                this.currentArchiveNumber = -1;
                this.currentFileNumber = -1;
                Stream archiveStream = null;
                try
                {
                    foreach (ZipFileHeader header in headers)
                    {
                        this.currentFileNumber++;
                        this.UnpackOneFile(streamContext, header, ref archiveStream);
                    }
                }
                finally
                {
                    if (archiveStream != null)
                    {
                        streamContext.CloseArchiveReadStream(
                            0, String.Empty, archiveStream);
                        this.currentArchiveNumber--;
                        this.OnProgress(ArchiveProgressType.FinishArchive);
                    }
                }
            }
        }

        /// <summary>
        /// Unpacks a single file from an archive or archive chain.
        /// </summary>
        private void UnpackOneFile(
            IUnpackStreamContext streamContext,
            ZipFileHeader header,
            ref Stream archiveStream)
        {
            ZipFileInfo fileInfo = null;
            Stream fileStream = null;
            try
            {
                Converter<Stream, Stream> compressionStreamCreator;
                if (!ZipEngine.decompressionStreamCreators.TryGetValue(
                    header.compressionMethod, out compressionStreamCreator))
                {
                    // Silently skip files of an unsupported compression method.
                    return;
                }

                long compressedSize;
                long uncompressedSize;
                long localHeaderOffset;
                int archiveNumber;
                uint crc;
                header.GetZip64Fields(
                    out compressedSize,
                    out uncompressedSize,
                    out localHeaderOffset,
                    out archiveNumber,
                    out crc);

                if (this.currentArchiveNumber != archiveNumber + 1)
                {
                    if (archiveStream != null)
                    {
                        streamContext.CloseArchiveReadStream(
                            this.currentArchiveNumber,
                            String.Empty,
                            archiveStream);
                        archiveStream = null;

                        this.OnProgress(ArchiveProgressType.FinishArchive);
                        this.currentArchiveName = null;
                    }

                    this.currentArchiveNumber = (short) (archiveNumber + 1);
                    this.currentArchiveBytesProcessed = 0;
                    this.currentArchiveTotalBytes = 0;

                    archiveStream = this.OpenArchive(
                        streamContext, this.currentArchiveNumber);

                    FileStream archiveFileStream = archiveStream as FileStream;
                    this.currentArchiveName = (archiveFileStream != null ?
                        Path.GetFileName(archiveFileStream.Name) : null);

                    this.currentArchiveTotalBytes = archiveStream.Length;
                    this.currentArchiveNumber--;
                    this.OnProgress(ArchiveProgressType.StartArchive);
                    this.currentArchiveNumber++;
                }

                archiveStream.Seek(localHeaderOffset, SeekOrigin.Begin);

                ZipFileHeader localHeader = new ZipFileHeader();
                if (!localHeader.Read(archiveStream, false) ||
                    !localHeader.fileName.Equals(header.fileName))
                {
                    string msg = "Could not read file: " + header.fileName;
                    throw new ZipException(msg);
                }

                fileInfo = header.ToZipFileInfo();

                fileStream = streamContext.OpenFileWriteStream(
                    fileInfo.FullName,
                    fileInfo.Length,
                    fileInfo.LastWriteTime);

                if (fileStream != null)
                {
                    this.currentFileName = header.fileName;
                    this.currentFileBytesProcessed = 0;
                    this.currentFileTotalBytes = fileInfo.Length;
                    this.currentArchiveNumber--;
                    this.OnProgress(ArchiveProgressType.StartFile);
                    this.currentArchiveNumber++;

                    this.UnpackFileBytes(
                        streamContext,
                        fileInfo.FullName,
                        fileInfo.CompressedLength,
                        fileInfo.Length,
                        header.crc32,
                        fileStream,
                        compressionStreamCreator,
                        ref archiveStream);
                }
            }
            finally
            {
                if (fileStream != null)
                {
                    streamContext.CloseFileWriteStream(
                        fileInfo.FullName,
                        fileStream,
                        fileInfo.Attributes,
                        fileInfo.LastWriteTime);

                    this.currentArchiveNumber--;
                    this.OnProgress(ArchiveProgressType.FinishFile);
                    this.currentArchiveNumber++;
                }
            }
        }

        private Stream OpenArchive(IUnpackStreamContext streamContext, int archiveNumber)
        {
            Stream archiveStream = streamContext.OpenArchiveReadStream(
                archiveNumber, String.Empty, this);
            if (archiveStream == null && archiveNumber != 0)
            {
                archiveStream = streamContext.OpenArchiveReadStream(
                    0, String.Empty, this);
            }

            if (archiveStream == null)
            {
                throw new FileNotFoundException("Archive stream not provided.");
            }

            return archiveStream;
        }

        /// <summary>
        /// Decompresses bytes for one file from an archive or archive chain,
        /// checking the crc at the end.
        /// </summary>
        private void UnpackFileBytes(
            IUnpackStreamContext streamContext,
            string fileName,
            long compressedSize,
            long uncompressedSize,
            uint crc,
            Stream fileStream,
            Converter<Stream, Stream> compressionStreamCreator,
            ref Stream archiveStream)
        {
            CrcStream crcStream = new CrcStream(fileStream);

            ConcatStream concatStream = new ConcatStream(
                delegate(ConcatStream s)
                {
                    this.currentArchiveBytesProcessed = s.Source.Position;
                    streamContext.CloseArchiveReadStream(
                        this.currentArchiveNumber,
                        String.Empty,
                        s.Source);

                    this.currentArchiveNumber--;
                    this.OnProgress(ArchiveProgressType.FinishArchive);
                    this.currentArchiveNumber += 2;
                    this.currentArchiveName = null;
                    this.currentArchiveBytesProcessed = 0;
                    this.currentArchiveTotalBytes = 0;

                    s.Source = this.OpenArchive(streamContext, this.currentArchiveNumber);

                    FileStream archiveFileStream = s.Source as FileStream;
                    this.currentArchiveName = (archiveFileStream != null ?
                        Path.GetFileName(archiveFileStream.Name) : null);

                    this.currentArchiveTotalBytes = s.Source.Length;
                    this.currentArchiveNumber--;
                    this.OnProgress(ArchiveProgressType.StartArchive);
                    this.currentArchiveNumber++;
                });

            concatStream.Source = archiveStream;
            concatStream.SetLength(compressedSize);

            Stream decompressionStream = compressionStreamCreator(concatStream);

            try
            {
                byte[] buf = new byte[4096];
                long bytesRemaining = uncompressedSize;
                int counter = 0;
                while (bytesRemaining > 0)
                {
                    int count = (int) Math.Min(buf.Length, bytesRemaining);
                    count = decompressionStream.Read(buf, 0, count);
                    crcStream.Write(buf, 0, count);
                    bytesRemaining -= count;

                    this.fileBytesProcessed += count;
                    this.currentFileBytesProcessed += count;
                    this.currentArchiveBytesProcessed = concatStream.Source.Position;

                    if (++counter % 16 == 0) // Report every 64K
                    {
                        this.currentArchiveNumber--;
                        this.OnProgress(ArchiveProgressType.PartialFile);
                        this.currentArchiveNumber++;
                    }
                }
            }
            finally
            {
                archiveStream = concatStream.Source;
            }

            crcStream.Flush();

            if (crcStream.Crc != crc)
            {
                throw new ZipException("CRC check failed for file: " + fileName);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup2\Compression\ArchiveProgressType.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ArchiveProgressType.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
using System;
using System.Collections.Generic;
using System.Text;

    /// <summary>
    /// The type of progress event.
    /// </summary>
    /// <remarks>
    /// <p>PACKING EXAMPLE: The following sequence of events might be received when
    /// extracting a simple archive file with 2 files.</p>
    /// <list type="table">
    /// <listheader><term>Message Type</term><description>Description</description></listheader>
    /// <item><term>StartArchive</term> <description>Begin extracting archive</description></item>
    /// <item><term>StartFile</term>    <description>Begin extracting first file</description></item>
    /// <item><term>PartialFile</term>  <description>Extracting first file</description></item>
    /// <item><term>PartialFile</term>  <description>Extracting first file</description></item>
    /// <item><term>FinishFile</term>   <description>Finished extracting first file</description></item>
    /// <item><term>StartFile</term>    <description>Begin extracting second file</description></item>
    /// <item><term>PartialFile</term>  <description>Extracting second file</description></item>
    /// <item><term>FinishFile</term>   <description>Finished extracting second file</description></item>
    /// <item><term>FinishArchive</term><description>Finished extracting archive</description></item>
    /// </list>
    /// <p></p>
    /// <p>UNPACKING EXAMPLE:  Packing 3 files into 2 archive chunks, where the second file is
    ///	continued to the second archive chunk.</p>
    /// <list type="table">
    /// <listheader><term>Message Type</term><description>Description</description></listheader>
    /// <item><term>StartFile</term>     <description>Begin compressing first file</description></item>
    /// <item><term>FinishFile</term>    <description>Finished compressing first file</description></item>
    /// <item><term>StartFile</term>     <description>Begin compressing second file</description></item>
    /// <item><term>PartialFile</term>   <description>Compressing second file</description></item>
    /// <item><term>PartialFile</term>   <description>Compressing second file</description></item>
    /// <item><term>FinishFile</term>    <description>Finished compressing second file</description></item>
    /// <item><term>StartArchive</term>  <description>Begin writing first archive</description></item>
    /// <item><term>PartialArchive</term><description>Writing first archive</description></item>
    /// <item><term>FinishArchive</term> <description>Finished writing first archive</description></item>
    /// <item><term>StartFile</term>     <description>Begin compressing third file</description></item>
    /// <item><term>PartialFile</term>   <description>Compressing third file</description></item>
    /// <item><term>FinishFile</term>    <description>Finished compressing third file</description></item>
    /// <item><term>StartArchive</term>  <description>Begin writing second archive</description></item>
    /// <item><term>PartialArchive</term><description>Writing second archive</description></item>
    /// <item><term>FinishArchive</term> <description>Finished writing second archive</description></item>
    /// </list>
    /// </remarks>
    public enum ArchiveProgressType : int
    {
        /// <summary>Status message before beginning the packing or unpacking an individual file.</summary>
        StartFile,

        /// <summary>Status message (possibly reported multiple times) during the process of packing or unpacking a file.</summary>
        PartialFile,

        /// <summary>Status message after completion of the packing or unpacking an individual file.</summary>
        FinishFile,

        /// <summary>Status message before beginning the packing or unpacking an archive.</summary>
        StartArchive,

        /// <summary>Status message (possibly reported multiple times) during the process of packing or unpacking an archiv.</summary>
        PartialArchive,

        /// <summary>Status message after completion of the packing or unpacking of an archive.</summary>
        FinishArchive,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup2\Compression\BasicUnpackStreamContext.cs ===
//---------------------------------------------------------------------
// <copyright file="BasicUnpackStreamContext.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
    using System;
    using System.IO;
    using System.Diagnostics.CodeAnalysis;

    /// <summary>
    /// Stream context used to extract a single file from an archive into a memory stream.
    /// </summary>
    [SuppressMessage("Microsoft.Design", "CA1001:TypesThatOwnDisposableFieldsShouldBeDisposable")]
    public class BasicUnpackStreamContext : IUnpackStreamContext
    {
        private Stream archiveStream;
        private Stream fileStream;

        /// <summary>
        /// Creates a new BasicExtractStreamContext that reads from the specified archive stream.
        /// </summary>
        /// <param name="archiveStream">Archive stream to read from.</param>
        public BasicUnpackStreamContext(Stream archiveStream)
        {
            this.archiveStream = archiveStream;
        }

        /// <summary>
        /// Gets the stream for the extracted file, or null if no file was extracted.
        /// </summary>
        public Stream FileStream
        {
            get
            {
                return this.fileStream;
            }
        }

        /// <summary>
        /// Opens the archive stream for reading. Returns a DuplicateStream instance,
        /// so the stream may be virtually opened multiple times.
        /// </summary>
        /// <param name="archiveNumber">The archive number to open (ignored; 0 is assumed).</param>
        /// <param name="archiveName">The name of the archive being opened.</param>
        /// <param name="compressionEngine">Instance of the compression engine doing the operations.</param>
        /// <returns>A stream from which archive bytes are read.</returns>
        public Stream OpenArchiveReadStream(int archiveNumber, string archiveName, CompressionEngine compressionEngine)
        {
            return new DuplicateStream(this.archiveStream);
        }

        /// <summary>
        /// Does *not* close the stream. The archive stream should be managed by
        /// the code that invokes the archive extraction.
        /// </summary>
        /// <param name="archiveNumber">The archive number of the stream to close.</param>
        /// <param name="archiveName">The name of the archive being closed.</param>
        /// <param name="stream">The stream being closed.</param>
        public void CloseArchiveReadStream(int archiveNumber, string archiveName, Stream stream)
        {
            // Do nothing.
        }

        /// <summary>
        /// Opens a stream for writing extracted file bytes. The returned stream is a MemoryStream
        /// instance, so the file is extracted straight into memory.
        /// </summary>
        /// <param name="path">Path of the file within the archive.</param>
        /// <param name="fileSize">The uncompressed size of the file to be extracted.</param>
        /// <param name="lastWriteTime">The last write time of the file.</param>
        /// <returns>A stream where extracted file bytes are to be written.</returns>
        public Stream OpenFileWriteStream(string path, long fileSize, DateTime lastWriteTime)
        {
            this.fileStream = new MemoryStream(new byte[fileSize], 0, (int) fileSize, true, true);
            return this.fileStream;
        }

        /// <summary>
        /// Does *not* close the file stream. The file stream is saved in memory so it can
        /// be read later.
        /// </summary>
        /// <param name="path">Path of the file within the archive.</param>
        /// <param name="stream">The file stream to be closed.</param>
        /// <param name="attributes">The attributes of the extracted file.</param>
        /// <param name="lastWriteTime">The last write time of the file.</param>
        public void CloseFileWriteStream(string path, Stream stream, FileAttributes attributes, DateTime lastWriteTime)
        {
            // Do nothing.
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup2\Program.cs ===
﻿//--------------------------------------------------------------------------------------
// <copyright file="Log.cs" company="Microsoft Corporation">
//     Copyright (c) Microsoft Corporation. All rights reserved.
// </copyright>
//--------------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Security.Permissions;
using Microsoft.Deployment.Compression;
using Microsoft.Deployment.Compression.Zip;
using Microsoft.Deployment.Compression.Cab;

namespace Microsoft.LFIT
{
    class Program
    {
        static string strTempManifestCabPath;

        [EnvironmentPermissionAttribute(SecurityAction.LinkDemand, Unrestricted = true)]
        public static void Run(string[] args)
        {
            Settings settings = new Settings();

            // Parse command line
            try
            {
                settings.ParseCommandLine(args);
            }
            catch (System.ArgumentException ex)
            {
                Log.ExceptionCaught = true;
                if (ex.ParamName != "-?")
                {
                    Log.WriteLog("Error: " + ex.Message);
                }

                Settings.DisplayUsage();
                throw;
            }

            Log.Quiet = settings.Quiet;

            // justify the input
            switch (settings.InputCommand)
            {
                case Command.All:
                    {
                        try
                        {
                            CreateCabFiles(settings);
/*
                            IList<CODESIGN.Submitter.Job> jobList = new List<CODESIGN.Submitter.Job>();

                            if (CodeSignSubmitCabs(settings, jobList) == 0)
                            {
                                CodeSignJobCheck(settings, jobList);
                                Log.WriteLog("LFIT job finished");
                            }
                            else
                            {
                                Log.WriteLog("LFIT job failed");
                            }
 */ 
                        }
                        catch (System.Exception)
                        {
                            Log.WriteLog("LFIT job failed");
                            throw;
                        }
                        break;
                    }
                case Command.Create:
                    {
                        CreateCabFiles(settings);
                        CopyCabsFromTempFolder(settings);
                        break;
                    }

                case Command.Submit:
                    {
                        //CodeSignSubmitFile(settings);
                        break;
                    }

                case Command.Check:
                    {
                        //CodeSignOneJobCheck(settings.CodeSignJobNumber);
                        break;
                    }

                default:
                        break;
            }

        }

        private static int CreateCabFiles(Settings settings)
        {
            // Delete the existing directory and all subdirectories with Directory static method...
            if (System.IO.Directory.Exists(settings.TempDirectory))
            {
                try
                {
                    Log.WriteLog("Deleting " + settings.TempDirectory + @"...");
                    System.IO.Directory.Delete(settings.TempDirectory, true);
                    Log.WriteLog("Deleting " + settings.TempDirectory + @" finished");
                }
                catch (System.IO.IOException)
                {
                    throw;
                }
            }

            if( !Directory.Exists(settings.InputFolder))
            {
                throw new System.IO.FileNotFoundException("Input folder not found", settings.InputFolder);
            }

/*
            string strUnZipFolder = Path.Combine(settings.TempDirectory, @"UnZipFiles");
            ZipInfo zip = new ZipInfo(settings.ZipFilePath);
            Log.WriteLog("Unzipping " + settings.ZipFilePath + "...");
            zip.Unpack(strUnZipFolder);
            Log.WriteLog("Unzipping finished");
*/ 

            long totalInstallSize = 0;
            CreateContentCabs(settings, settings.InputFolder, ref totalInstallSize);
            CreateManifestCab(settings, totalInstallSize);

            return 0;
        }

        private static int CreateContentCabs(Settings settings, string strUnZipFolder, ref long totalInstallSize)
        {
            CreateContentXbx(settings, settings.InputFolder);

            // Re-pack the file to CAB files ( < 2.0 G)
            string strCabFileFolder = Path.Combine(settings.TempDirectory, @"cabs");
            Directory.CreateDirectory(strCabFileFolder);
            string strCabName = Path.Combine(strCabFileFolder, settings.ContentID);

            totalInstallSize = 0;
            IList<string> fileList = new List<string>();
            RecursiveGetFilePathsInDirectoryTree(strUnZipFolder, true, fileList);

            foreach (string file in fileList)
            {
                // Use FileInfo to get length of each file.
                FileInfo info = new FileInfo(file);
                totalInstallSize += info.Length;
            }

            IList<string> archiveFiles = new List<string>();
            long maxVolumNum = totalInstallSize / settings.MaxCabSize + 1;
            for (int i = 1; i <= maxVolumNum; i++)
            {
                archiveFiles.Add(strCabName + string.Format("_{0}.cab", i));
            }
            //Create cab files 
            CabInfo cab = new CabInfo(strCabName);

            Log.WriteLog("Compressing content cab files for " + strUnZipFolder + "...");
            cab.Pack(archiveFiles, strUnZipFolder, true, (CompressionLevel)settings.CompressionLevel, null, settings.MaxCabSize);
            Log.WriteLog("Compressing content cab files finished");
            
            return 0;
        }

        private static int CreateManifestCab(Settings settings, long totalInstallSize)
        {
            Log.WriteLog("Creating manifest.cab...");
            string strManifestFolder = Path.Combine(settings.TempDirectory, @"Manifest");
            Directory.CreateDirectory(strManifestFolder);
            string contentFolder = Path.Combine(strManifestFolder, @"Content");
            Directory.CreateDirectory(contentFolder);

            string srcXbx = Path.Combine(settings.InputFolder, @"content.xbx");
            string destXbx = Path.Combine(strManifestFolder, @"content.xbx");
            File.Copy(srcXbx, destXbx);
            Log.WriteLog("Copied content.xbx from " + srcXbx + " to " + destXbx);

            // Create manifest file
            string strManifestFileName = Path.Combine(contentFolder, @"OfferManifest.xml");
            Manifest manifest = new Manifest();
            manifest.NewFile();
            manifest.CabFolder = Path.Combine(settings.TempDirectory, @"cabs");
            manifest.InstallSize = totalInstallSize;
            manifest.TitleId = settings.TitleID;
            manifest.LinkURL = settings.ContentURL;
            string log = manifest.SaveFile(strManifestFileName);
            Log.WriteLog(log);

            // Pack content.xbx and manifest file
            strTempManifestCabPath = Path.Combine(strManifestFolder, settings.ContentID + @"_Manifest.cab");
            CabInfo cabManifest = new CabInfo(strTempManifestCabPath);
            cabManifest.Pack(strManifestFolder, true, (CompressionLevel)settings.CompressionLevel, null);
            Log.WriteLog("Creating " + strTempManifestCabPath + " finished");

            return 0;
        }

        private static string CreateContentXbx(Settings settings, string strFolder)
        {
            // Create content.xbx
            // Create an instance of StreamWriter to write text to a file.
            // The using statement also closes the StreamWriter.
            string stringContentXbxFileName = Path.Combine(strFolder, @"content.xbx");

            if (settings.Nooverwritexbx)
            {
                if (!File.Exists(stringContentXbxFileName))
                {
                    throw new System.IO.FileNotFoundException("Error: content.xbx not found", stringContentXbxFileName);
                }
                else
                {
                    Log.WriteLog("Using content.xbx at " + stringContentXbxFileName);
                }
            }
            else
            {
                using (StreamWriter sw = new StreamWriter(stringContentXbxFileName, false, Encoding.Unicode))
                {
                    // Add some text to the file.
                    sw.WriteLine(";");
                    sw.WriteLine("; GFWL Submission Metadata File -- Generated by LFIT.exe on " + DateTime.Now.ToShortDateString());
                    sw.WriteLine(";");
                    sw.WriteLine("; Copyright (c) Microsoft Corporation");
                    sw.WriteLine(";");
                    sw.WriteLine("");

                    sw.WriteLine("[All]");
                    sw.WriteLine("Premium=No");
                    sw.WriteLine("TitleID=0x" + settings.TitleID);
                    sw.WriteLine("ContentPackageType=" + settings.ContentType);
                    sw.WriteLine("LicenseBits=0x00000000");
                    sw.WriteLine("BaseVersion=0x00000000");
                    sw.WriteLine("UpdateVersion=0x00000000");
                    sw.WriteLine("ThumbnailImage=\"generic.PNG\"");
                    sw.WriteLine("OfferingID=0x" + settings.OfferID);
                    sw.WriteLine("AdminFriendlyName=\"This is LFIT.exe generic text\"");
                    sw.WriteLine("TitleName=\"This is LFIT.exe generic text\"");
                    sw.WriteLine("PurchaseOnceOnly=Yes");
                    sw.WriteLine("ContentFlags=0xC0");
                    sw.WriteLine("ContentID=" + settings.ContentID);
                    sw.WriteLine("Platform=0x10");
                    sw.WriteLine("BitFlags=0xFFFFFFFF");
                    sw.WriteLine("ActivationDate=" + DateTime.Now.ToShortDateString());
                    sw.WriteLine("DefaultDisplayName=\"This is LFIT.exe generic text\"");
                    sw.WriteLine("OfferRegions.0=103,0,0,TaxNotApplicable");
                    if (string.Compare(settings.ContentType, "0x00080000", StringComparison.OrdinalIgnoreCase) == 0)
                    {
                        sw.WriteLine("OfferingType=Content");
                    }
                    else if (string.Compare(settings.ContentType, "0x00007000", StringComparison.OrdinalIgnoreCase) == 0)
                    {
                        sw.WriteLine("OfferingType=FullGame");
                    }
                    sw.WriteLine("EndDate=12/31/2999");
                    sw.WriteLine("DisplayInDash=Yes");
                    sw.WriteLine("Version=0x00020001");
                    sw.WriteLine("DashDisplayName.0=EN,\"This is LFIT.exe generic text\"");
                    sw.WriteLine("DashDescription.0=EN,\"This is LFIT.exe generic text\"");
                }
                Log.WriteLog("Saved content.xbx at " + stringContentXbxFileName);
            }

            return stringContentXbxFileName;
        }
/*
        private static int CodeSignSubmitFile(Settings settings)
        {
            int ret = 0;
            try
            {
                // Codesign the CAB fiels
                CodesignSubmission codeSignSubmission = new CodesignSubmission();
                Log.WriteLog("Start CodeSign submitting...");

                ret = codeSignSubmission.CreateSubmission(settings.CodeSignFileName, settings.Signers, settings.LargeFileCertID, settings.NormalFileCertID, settings.StrongNameCertID, null);
                if (ret == 0)
                {
                    Log.WriteLog("CodeSign submission succeeded. please limit the submission less than 6G per hour before the next submission");
                }
                else
                {
                    Log.WriteLog("CodeSign submission failed.");
                }

                Log.WriteLog("CodeSign submitting finished");
            }
            catch (Exception)
            {
                ret = -1;
                throw;
            }

            return ret;
        }

        private static int CodeSignSubmitCabs(Settings settings, IList<CODESIGN.Submitter.Job> jobList)
        {
            int ret = 0;
            try
            {
                // Codesign the CAB fiels
                string strCabFileFolder = Path.Combine(settings.TempDirectory, @"cabs");
                CodesignSubmission codeSignSubmission = new CodesignSubmission();
                Log.WriteLog("Start CodeSign submitting...");

                foreach (string file in Directory.GetFiles(strCabFileFolder))
                {
                    ret = codeSignSubmission.CreateSubmission(file, settings.Signers, settings.LargeFileCertID, settings.NormalFileCertID, settings.StrongNameCertID, jobList);
                    if (ret == 0)
                    {
                        Log.WriteLog("Waiting 20 minutes to start submitting next job...");
                        System.Threading.Thread.Sleep(1200000);         // 20 minutes
                    }
                    else
                    {
                        break;
                    }
                }

                // Codesigne manifest.cab
                if (ret == 0)
                {
                    string strManifestFolder = Path.Combine(settings.TempDirectory, @"Manifest");
                    string strManifesCabFile = Path.Combine(strManifestFolder, @"Manifest.cab");
                    ret = codeSignSubmission.CreateSubmission(strManifesCabFile, settings.Signers, settings.LargeFileCertID, settings.NormalFileCertID, settings.StrongNameCertID, jobList);
                }

                Log.WriteLog("CodeSign submitting finished");
            }
            catch (Exception)
            {
                ret = -1;
                throw;
            }

            return ret;
        } 
        private static int CodeSignOneJobCheck(string jobNumber)
        {
            int ret = 0;
            try
            {
                    Log.WriteLog("Waiting for  CodeSign result. Job Number = {0}...", jobNumber);
                    if (Watcher.Monitor(jobNumber) == 0)
                    {
                        Log.WriteLog("{0} CodeSign succeeded.", jobNumber);
                    }
                    else
                    {
                        Log.WriteLog("Content {0} CodeSign failed", jobNumber);
                        ret = -1;
                    }
            }
            catch (Exception)
            {
                ret = -1;
                throw;
            }

            return ret;
        }

        private static int CodeSignJobCheck(Settings settings, IList<CODESIGN.Submitter.Job> jobList)
        {
            int ret = 0;
            try
            {
                Log.WriteLog("Waiting for content cab files CodeSign result...");
                foreach (CODESIGN.Submitter.Job job in jobList)
                {
                    string file = Path.GetFileName(job.FileList.Values[0].ToString());
                    Log.WriteLog("Waiting for {0} CodeSign result...", file);
                    if (Watcher.Monitor(job.JobNumber) == 0)
                    {
                        Log.WriteLog("{0} CodeSign succeeded.", file);

                        if (string.Compare(file, "manifest.cab", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                        {
                            string destManifestFileName = Path.Combine(settings.CurrentWorkingDirectory, @"Manifest.cab");
                            Log.WriteLog("Copying {0}...", file);
                            File.Copy(job.JobCompletionPath, destManifestFileName, true);
                            Log.WriteLog("Copying {0} finished", file);
                        }
                        else
                        {
                            if (!Directory.Exists(settings.ContentFilePath))
                            {
                                Directory.CreateDirectory(settings.ContentFilePath);
                            }
                            Log.WriteLog("Copying {0}...", file);
                            string destFileName = Path.Combine(settings.ContentFilePath, file);
                            File.Copy(job.JobCompletionPath, destFileName, true);
                            Log.WriteLog("Copying {0} finished", file);
                        }
                    }
                    else
                    {
                        Log.WriteLog("Content {0} CodeSign failed", file);
                        ret = -1;
                    }
                }
            }
            catch (Exception)
            {
                ret = -1;
                throw;
            }

            return ret;
        }
*/
        private static int CopyCabsFromTempFolder(Settings settings)
        {
            Log.WriteLog("Moving content cab files to the unsigned cabs folder...");
            // Copy CAB files to /contentFilePath:<ContentFilePaht>
            string strCabFileFolder = Path.Combine(settings.TempDirectory, @"cabs");
            string strUnSignedCabPath = Path.Combine(settings.UnSignedCabPath, settings.TitleID);
            if (!Directory.Exists(strUnSignedCabPath))
            {
                Directory.CreateDirectory(strUnSignedCabPath);
            }
            foreach (string file in Directory.GetFiles(strCabFileFolder))
            {
                string destFileName = Path.Combine(strUnSignedCabPath, Path.GetFileName(file));

                // Delete (if exists) & move to overwrite
                try
                {
                    File.Delete(destFileName);
                }
                catch (System.IO.IOException)
                {
                }
                File.Move(file, destFileName);
            }
            Log.WriteLog("Moving content cab files finished");

            // Copy manifest.cab to /manifestFilePath:<ManifestFilePath>
            FileInfo fiManifest = new FileInfo(strTempManifestCabPath);
            string strManifestFileName = fiManifest.FullName;
            string destManifestFileName = Path.Combine(settings.UnSignedCabPath, fiManifest.Name);
            Log.WriteLog("Copying manifest.cab to " + destManifestFileName);

            // Delete (if exists) & move to overwrite
            try
            {
                File.Delete(destManifestFileName);
            }
            catch (System.IO.IOException)
            {
            }
            File.Move(strManifestFileName, destManifestFileName);

            // Delete the existing directory and all subdirectories with Directory static method...
            if (System.IO.Directory.Exists(settings.TempDirectory))
            {
                try
                {
                    Log.WriteLog("Deleting temporary working folder...");
                    System.IO.Directory.Delete(settings.TempDirectory, true);
                    Log.WriteLog("Deleting temporary working finished");
                }
                catch (System.IO.IOException)
                {
                }
            }

            return 0;
        }

        private static void RecursiveGetFilePathsInDirectoryTree(
            string dir,
            bool includeSubdirectories,
            IList<string> fileList)
        {
            foreach (string file in System.IO.Directory.GetFiles(dir))
            {
                fileList.Add(file);
            }

            if (includeSubdirectories)
            {
                foreach (string subDir in System.IO.Directory.GetDirectories(dir))
                {
                    string subDirName = Path.GetFileName(subDir);
                    RecursiveGetFilePathsInDirectoryTree(
                        Path.Combine(dir, subDirName),
                        includeSubdirectories,
                        fileList);
                }
            }
        }

        [EnvironmentPermissionAttribute(SecurityAction.LinkDemand, Unrestricted = true)]
        public static int Main(string[] args)
        {
            Log.WriteLog(@"LFIT.EXE starts...");

            int returnResult = 1;
            try
            {
                Run(args);
                returnResult = 0;
            }
            catch (System.Exception ex)
            {
                if (!Log.ExceptionCaught)
                {
                    Log.WriteLog(ex.ToString());
                }
            }
            Log.WriteLog(@"LFIT.EXE ends...");
            return returnResult;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup2\Compression\CompressionLevel.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="CompressionLevel.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
using System;
using System.Collections.Generic;
using System.Text;

    /// <summary>
    /// Specifies the compression level ranging from minimum compresion to
    /// maximum compression, or no compression at all.
    /// </summary>
    /// <remarks>
    /// Although only four values are enumerated, any integral value between
    /// <see cref="CompressionLevel.Min"/> and <see cref="CompressionLevel.Max"/> can also be used.
    /// </remarks>
    public enum CompressionLevel
    {
        /// <summary>Do not compress files, only store.</summary>
        None = 0,

        /// <summary>Minimum compression; fastest.</summary>
        Min = 1,

        /// <summary>A compromize between speed and compression efficiency.</summary>
        Normal = 6,

        /// <summary>Maximum compression; slowest.</summary>
        Max = 10
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup2\Compression\ArchiveFileStreamContext.cs ===
//---------------------------------------------------------------------
// <copyright file="ArchiveFileStreamContext.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
    using System;
    using System.IO;
    using System.Collections.Generic;

    /// <summary>
    /// Provides a basic implementation of the archive pack and unpack stream context
    /// interfaces, based on a list of archive files, a default directory, and an
    /// optional mapping from internal to external file paths.
    /// </summary>
    /// <remarks>
    /// This class can also handle creating or extracting chained archive packages.
    /// </remarks>
    public class ArchiveFileStreamContext
        : IPackStreamContext, IUnpackStreamContext
    {
        private IList<string> archiveFiles;
        private string directory;
        private IDictionary<string, string> files;
        private bool extractOnlyNewerFiles;
        private bool enableOffsetOpen;

        #region Constructors

        /// <summary>
        /// Creates a new ArchiveFileStreamContext with a archive file and
        /// no default directory or file mapping.
        /// </summary>
        /// <param name="archiveFile">The path to a archive file that will be
        /// created or extracted.</param>
        public ArchiveFileStreamContext(string archiveFile)
            : this(archiveFile, null, null)
        {
        }

        /// <summary>
        /// Creates a new ArchiveFileStreamContext with a archive file, default
        /// directory and mapping from internal to external file paths.
        /// </summary>
        /// <param name="archiveFile">The path to a archive file that will be
        /// created or extracted.</param>
        /// <param name="directory">The default root directory where files will be
        /// located, optional.</param>
        /// <param name="files">A mapping from internal file paths to external file
        /// paths, optional.</param>
        /// <remarks>
        /// If the mapping is not null and a file is not included in the mapping,
        /// the file will be skipped.
        /// <para>If the external path in the mapping is a simple file name or
        /// relative file path, it will be concatenated onto the default directory,
        /// if one was specified.</para>
        /// <para>For more about how the default directory and files mapping are
        /// used, see <see cref="OpenFileReadStream"/> and
        /// <see cref="OpenFileWriteStream"/>.</para>
        /// </remarks>
        public ArchiveFileStreamContext(
            string archiveFile,
            string directory,
            IDictionary<string, string> files)
            : this(new string[] { archiveFile }, directory, files)
        {
            if (archiveFile == null)
            {
                throw new ArgumentNullException("archiveFile");
            }
        }

        /// <summary>
        /// Creates a new ArchiveFileStreamContext with a list of archive files,
        /// a default directory and a mapping from internal to external file paths.
        /// </summary>
        /// <param name="archiveFiles">A list of paths to archive files that will be
        /// created or extracted.</param>
        /// <param name="directory">The default root directory where files will be
        /// located, optional.</param>
        /// <param name="files">A mapping from internal file paths to external file
        /// paths, optional.</param>
        /// <remarks>
        /// When creating chained archives, the <paramref name="archiveFiles"/> list
        /// should include at least enough archives to handle the entire set of
        /// input files, based on the maximum archive size that is passed to the
        /// <see cref="CompressionEngine"/>.<see
        /// cref="CompressionEngine.Pack(IPackStreamContext,IEnumerable&lt;string&gt;,long)"/>.
        /// <para>If the mapping is not null and a file is not included in the mapping,
        /// the file will be skipped.</para>
        /// <para>If the external path in the mapping is a simple file name or
        /// relative file path, it will be concatenated onto the default directory,
        /// if one was specified.</para>
        /// <para>For more about how the default directory and files mapping are used,
        /// see <see cref="OpenFileReadStream"/> and
        /// <see cref="OpenFileWriteStream"/>.</para>
        /// </remarks>
        public ArchiveFileStreamContext(
            IList<string> archiveFiles,
            string directory,
            IDictionary<string, string> files)
        {
            if (archiveFiles == null || archiveFiles.Count == 0)
            {
                throw new ArgumentNullException("archiveFiles");
            }

            this.archiveFiles = archiveFiles;
            this.directory = directory;
            this.files = files;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Gets or sets the list of archive files that are created or extracted.
        /// </summary>
        /// <value>The list of archive files that are created or extracted.</value>
        public IList<string> ArchiveFiles
        {
            get
            {
                return this.archiveFiles;
            }
        }

        /// <summary>
        /// Gets or sets the default root directory where files are located.
        /// </summary>
        /// <value>The default root directory where files are located.</value>
        /// <remarks>
        /// For details about how the default directory is used,
        /// see <see cref="OpenFileReadStream"/> and <see cref="OpenFileWriteStream"/>.
        /// </remarks>
        public string Directory
        {
            get
            {
                return this.directory;
            }
        }

        /// <summary>
        /// Gets or sets the mapping from internal file paths to external file paths.
        /// </summary>
        /// <value>A mapping from internal file paths to external file paths.</value>
        /// <remarks>
        /// For details about how the files mapping is used,
        /// see <see cref="OpenFileReadStream"/> and <see cref="OpenFileWriteStream"/>.
        /// </remarks>
        public IDictionary<string, string> Files
        {
            get
            {
                return this.files;
            }
        }

        /// <summary>
        /// Gets or sets a flag that can prevent extracted files from overwriting
        /// newer files that already exist.
        /// </summary>
        /// <value>True to prevent overwriting newer files that already exist
        /// during extraction; false to always extract from the archive regardless
        /// of existing files.</value>
        public bool ExtractOnlyNewerFiles
        {
            get
            {
                return this.extractOnlyNewerFiles;
            }

            set
            {
                this.extractOnlyNewerFiles = value;
            }
        }

        /// <summary>
        /// Gets or sets a flag that enables creating or extracting an archive
        /// at an offset within an existing file. (This is typically used to open
        /// archive-based self-extracting packages.)
        /// </summary>
        /// <value>True to search an existing package file for an archive offset
        /// or the end of the file;/ false to always create or open a plain
        /// archive file.</value>
        public bool EnableOffsetOpen
        {
            get
            {
                return this.enableOffsetOpen;
            }

            set
            {
                this.enableOffsetOpen = value;
            }
        }

        #endregion

        #region IPackStreamContext Members

        /// <summary>
        /// Gets the name of the archive with a specified number.
        /// </summary>
        /// <param name="archiveNumber">The 0-based index of the archive within
        /// the chain.</param>
        /// <returns>The name of the requested archive. May be an empty string
        /// for non-chained archives, but may never be null.</returns>
        /// <remarks>This method returns the file name of the archive from the
        /// <see cref="archiveFiles"/> list with the specified index, or an empty
        /// string if the archive number is outside the bounds of the list. The
        /// file name should not include any directory path.</remarks>
        public virtual string GetArchiveName(int archiveNumber)
        {
            if (archiveNumber < this.archiveFiles.Count)
            {
                return Path.GetFileName(this.archiveFiles[archiveNumber]);
            }

            return String.Empty;
        }

        /// <summary>
        /// Opens a stream for writing an archive.
        /// </summary>
        /// <param name="archiveNumber">The 0-based index of the archive within
        /// the chain.</param>
        /// <param name="archiveName">The name of the archive that was returned
        /// by <see cref="GetArchiveName"/>.</param>
        /// <param name="truncate">True if the stream should be truncated when
        /// opened (if it already exists); false if an existing stream is being
        /// re-opened for writing additional data.</param>
        /// <param name="compressionEngine">Instance of the compression engine
        /// doing the operations.</param>
        /// <returns>A writable Stream where the compressed archive bytes will be
        /// written, or null to cancel the archive creation.</returns>
        /// <remarks>
        /// This method opens the file from the <see cref="ArchiveFiles"/> list
        /// with the specified index. If the archive number is outside the bounds
        /// of the list, this method returns null.
        /// <para>If the <see cref="EnableOffsetOpen"/> flag is set, this method
        /// will seek to the start of any existing archive in the file, or to the
        /// end of the file if the existing file is not an archive.</para>
        /// </remarks>
        public virtual Stream OpenArchiveWriteStream(
            int archiveNumber,
            string archiveName,
            bool truncate,
            CompressionEngine compressionEngine)
        {
            if (archiveNumber >= this.archiveFiles.Count)
            {
                return null;
            }

            if (String.IsNullOrEmpty(archiveName))
            {
                throw new ArgumentNullException("archiveName");
            }

            // All archives must be in the same directory,
            // so always use the directory from the first archive.
            string archiveFile = Path.Combine(
                Path.GetDirectoryName(this.archiveFiles[0]), archiveName);
            Stream stream = File.Open(
                archiveFile,
                (truncate ? FileMode.OpenOrCreate : FileMode.Open),
                FileAccess.ReadWrite);

            if (this.enableOffsetOpen)
            {
                long offset = compressionEngine.FindArchiveOffset(
                    new DuplicateStream(stream));

                // If this is not an archive file, append the archive to it.
                if (offset < 0)
                {
                    offset = stream.Length;
                }

                if (offset > 0)
                {
                    stream = new OffsetStream(stream, offset);
                }

                stream.Seek(0, SeekOrigin.Begin);
            }

            if (truncate)
            {
                // Truncate the stream, in case a larger old archive starts here.
                stream.SetLength(0);
            }
            
            return stream;
        }

        /// <summary>
        /// Closes a stream where an archive package was written.
        /// </summary>
        /// <param name="archiveNumber">The 0-based index of the archive within
        /// the chain.</param>
        /// <param name="archiveName">The name of the archive that was previously
        /// returned by <see cref="GetArchiveName"/>.</param>
        /// <param name="stream">A stream that was previously returned by
        /// <see cref="OpenArchiveWriteStream"/> and is now ready to be closed.</param>
        public virtual void CloseArchiveWriteStream(
            int archiveNumber,
            string archiveName,
            Stream stream)
        {
            if (stream != null)
            {
                stream.Close();

                FileStream fileStream = stream as FileStream;
                if (fileStream != null)
                {
                    string streamFile = fileStream.Name;
                    if (!String.IsNullOrEmpty(archiveName) &&
                        archiveName != Path.GetFileName(streamFile))
                    {
                        string archiveFile = Path.Combine(
                            Path.GetDirectoryName(this.archiveFiles[0]), archiveName);
                        if (File.Exists(archiveFile))
                        {
                            File.Delete(archiveFile);
                        }
                        File.Move(streamFile, archiveFile);
                    }
                }
            }
        }

        /// <summary>
        /// Opens a stream to read a file that is to be included in an archive.
        /// </summary>
        /// <param name="path">The path of the file within the archive.</param>
        /// <param name="attributes">The returned attributes of the opened file,
        /// to be stored in the archive.</param>
        /// <param name="lastWriteTime">The returned last-modified time of the
        /// opened file, to be stored in the archive.</param>
        /// <returns>A readable Stream where the file bytes will be read from
        /// before they are compressed, or null to skip inclusion of the file and
        /// continue to the next file.</returns>
        /// <remarks>
        /// This method opens a file using the following logic:
        /// <list>
        /// <item>If the <see cref="Directory"/> and the <see cref="Files"/> mapping
        /// are both null, the path is treated as relative to the current directory,
        /// and that file is opened.</item>
        /// <item>If the <see cref="Directory"/> is not null but the <see cref="Files"/>
        /// mapping is null, the path is treated as relative to that directory, and
        /// that file is opened.</item>
        /// <item>If the <see cref="Directory"/> is null but the <see cref="Files"/>
        /// mapping is not null, the path parameter is used as a key into the mapping,
        /// and the resulting value is the file path that is opened, relative to the
        /// current directory (or it may be an absolute path). If no mapping exists,
        /// the file is skipped.</item>
        /// <item>If both the <see cref="Directory"/> and the <see cref="Files"/>
        /// mapping are specified, the path parameter is used as a key into the
        /// mapping, and the resulting value is the file path that is opened, relative
        /// to the specified directory (or it may be an absolute path). If no mapping
        /// exists, the file is skipped.</item>
        /// </list>
        /// </remarks>
        public virtual Stream OpenFileReadStream(
            string path, out FileAttributes attributes, out DateTime lastWriteTime)
        {
            string filePath = this.TranslateFilePath(path);

            if (filePath == null)
            {
                attributes = FileAttributes.Normal;
                lastWriteTime = DateTime.Now;
                return null;
            }

            attributes = File.GetAttributes(filePath);
            lastWriteTime = File.GetLastWriteTime(filePath);
            return File.Open(filePath, FileMode.Open, FileAccess.Read, FileShare.Read);
        }

        /// <summary>
        /// Closes a stream that has been used to read a file.
        /// </summary>
        /// <param name="path">The path of the file within the archive; the same as
        /// the path provided when the stream was opened.</param>
        /// <param name="stream">A stream that was previously returned by
        /// <see cref="OpenFileReadStream"/> and is now ready to be closed.</param>
        public virtual void CloseFileReadStream(string path, Stream stream)
        {
            if (stream != null)
            {
                stream.Close();
            }
        }

        /// <summary>
        /// Gets extended parameter information specific to the compression format
        /// being used.
        /// </summary>
        /// <param name="optionName">Name of the option being requested.</param>
        /// <param name="parameters">Parameters for the option; for per-file options,
        /// the first parameter is typically the internal file path.</param>
        /// <returns>Option value, or null to use the default behavior.</returns>
        /// <remarks>
        /// This implementation does not handle any options. Subclasses may override
        /// this method to allow for non-default behavior.
        /// </remarks>
        public virtual object GetOption(string optionName, object[] parameters)
        {
            return null;
        }

        #endregion

        #region IUnpackStreamContext Members

        /// <summary>
        /// Opens the archive stream for reading.
        /// </summary>
        /// <param name="archiveNumber">The zero-based index of the archive to
        /// open.</param>
        /// <param name="archiveName">The name of the archive being opened.</param>
        /// <param name="compressionEngine">Instance of the compression engine
        /// doing the operations.</param>
        /// <returns>A stream from which archive bytes are read, or null to cancel
        /// extraction of the archive.</returns>
        /// <remarks>
        /// This method opens the file from the <see cref="ArchiveFiles"/> list with
        /// the specified index. If the archive number is outside the bounds of the
        /// list, this method returns null.
        /// <para>If the <see cref="EnableOffsetOpen"/> flag is set, this method will
        /// seek to the start of any existing archive in the file, or to the end of
        /// the file if the existing file is not an archive.</para>
        /// </remarks>
        public virtual Stream OpenArchiveReadStream(
            int archiveNumber, string archiveName, CompressionEngine compressionEngine)
        {
            if (archiveNumber >= this.archiveFiles.Count)
            {
                return null;
            }

            string archiveFile = this.archiveFiles[archiveNumber];
            Stream stream = File.Open(
                archiveFile, FileMode.Open, FileAccess.Read, FileShare.Read);

            if (this.enableOffsetOpen)
            {
                long offset = compressionEngine.FindArchiveOffset(
                    new DuplicateStream(stream));
                if (offset > 0)
                {
                    stream = new OffsetStream(stream, offset);
                }
                else
                {
                    stream.Seek(0, SeekOrigin.Begin);
                }
            }

            return stream;
        }

        /// <summary>
        /// Closes a stream where an archive was read.
        /// </summary>
        /// <param name="archiveNumber">The archive number of the stream
        /// to close.</param>
        /// <param name="archiveName">The name of the archive being closed.</param>
        /// <param name="stream">The stream that was previously returned by
        /// <see cref="OpenArchiveReadStream"/> and is now ready to be closed.</param>
        public virtual void CloseArchiveReadStream(
            int archiveNumber, string archiveName, Stream stream)
        {
            if (stream != null)
            {
                stream.Close();
            }
        }

        /// <summary>
        /// Opens a stream for writing extracted file bytes.
        /// </summary>
        /// <param name="path">The path of the file within the archive.</param>
        /// <param name="fileSize">The uncompressed size of the file to be
        /// extracted.</param>
        /// <param name="lastWriteTime">The last write time of the file to be
        /// extracted.</param>
        /// <returns>A stream where extracted file bytes are to be written, or null
        /// to skip extraction of the file and continue to the next file.</returns>
        /// <remarks>
        /// This method opens a file using the following logic:
        /// <list>
        /// <item>If the <see cref="Directory"/> and the <see cref="Files"/> mapping
        /// are both null, the path is treated as relative to the current directory,
        /// and that file is opened.</item>
        /// <item>If the <see cref="Directory"/> is not null but the <see cref="Files"/>
        /// mapping is null, the path is treated as relative to that directory, and
        /// that file is opened.</item>
        /// <item>If the <see cref="Directory"/> is null but the <see cref="Files"/>
        /// mapping is not null, the path parameter is used as a key into the mapping,
        /// and the resulting value is the file path that is opened, relative to the
        /// current directory (or it may be an absolute path). If no mapping exists,
        /// the file is skipped.</item>
        /// <item>If both the <see cref="Directory"/> and the <see cref="Files"/>
        /// mapping are specified, the path parameter is used as a key into the
        /// mapping, and the resulting value is the file path that is opened,
        /// relative to the specified directory (or it may be an absolute path).
        /// If no mapping exists, the file is skipped.</item>
        /// </list>
        /// <para>If the <see cref="ExtractOnlyNewerFiles"/> flag is set, the file
        /// is skipped if a file currently exists in the same path with an equal
        /// or newer write time.</para>
        /// </remarks>
        public virtual Stream OpenFileWriteStream(
            string path,
            long fileSize,
            DateTime lastWriteTime)
        {
            string filePath = this.TranslateFilePath(path);

            if (filePath == null)
            {
                return null;
            }

            FileInfo file = new FileInfo(filePath);
            if (file.Exists)
            {
                if (this.extractOnlyNewerFiles && lastWriteTime != DateTime.MinValue)
                {
                    if (file.LastWriteTime >= lastWriteTime)
                    {
                        return null;
                    }
                }

                if ((file.Attributes & FileAttributes.ReadOnly) != 0)
                {
                    file.Attributes &= ~FileAttributes.ReadOnly;
                }
            }

            if (!file.Directory.Exists)
            {
                file.Directory.Create();
            }

            return File.Open(
                filePath, FileMode.Create, FileAccess.Write, FileShare.None);
        }

        /// <summary>
        /// Closes a stream where an extracted file was written.
        /// </summary>
        /// <param name="path">The path of the file within the archive.</param>
        /// <param name="stream">The stream that was previously returned by
        /// <see cref="OpenFileWriteStream"/> and is now ready to be closed.</param>
        /// <param name="attributes">The attributes of the extracted file.</param>
        /// <param name="lastWriteTime">The last write time of the file.</param>
        /// <remarks>
        /// After closing the extracted file stream, this method applies the date
        /// and attributes to that file.
        /// </remarks>
        public virtual void CloseFileWriteStream(
            string path,
            Stream stream,
            FileAttributes attributes,
            DateTime lastWriteTime)
        {
            if (stream != null)
            {
                stream.Close();
            }

            string filePath = this.TranslateFilePath(path);
            if (filePath != null)
            {
                FileInfo file = new FileInfo(filePath);

                if (lastWriteTime != DateTime.MinValue)
                {
                    try
                    {
                        file.LastWriteTime = lastWriteTime;
                    }
                    catch (ArgumentException)
                    {
                    }
                    catch (IOException)
                    {
                    }
                }

                try
                {
                    file.Attributes = attributes;
                }
                catch (IOException)
                {
                }
            }
        }

        #endregion

        #region Private utility methods

        /// <summary>
        /// Translates an internal file path to an external file path using the
        /// <see cref="Directory"/> and the <see cref="Files"/> mapping, according to
        /// rules documented in <see cref="OpenFileReadStream"/> and
        /// <see cref="OpenFileWriteStream"/>.
        /// </summary>
        /// <param name="path">The path of the file with the archive.</param>
        /// <returns>The external path of the file, or null if there is no
        /// valid translation.</returns>
        private string TranslateFilePath(string path)
        {
            string filePath;
            if (this.files != null)
            {
                filePath = this.files[path];
            }
            else
            {
                filePath = path;
            }

            if (filePath != null)
            {
                if (this.directory != null)
                {
                    filePath = Path.Combine(this.directory, filePath);
                }
            }

            return filePath;
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup2\Compression\DuplicateStream.cs ===
//---------------------------------------------------------------------
// <copyright file="DuplicateStream.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
    using System;
    using System.IO;

    /// <summary>
    /// Duplicates a source stream by maintaining a separate position.
    /// </summary>
    /// <remarks>
    /// WARNING: duplicate streams are not thread-safe with respect to each other or the original stream.
    /// If multiple threads use duplicate copies of the same stream, they must synchronize for any operations.
    /// </remarks>
    public class DuplicateStream : Stream
    {
        private Stream source;
        private long position;

        /// <summary>
        /// Creates a new duplicate of a stream.
        /// </summary>
        /// <param name="source">source of the duplicate</param>
        public DuplicateStream(Stream source)
        {
            if (source == null)
            {
                throw new ArgumentNullException("source");
            }

            this.source = DuplicateStream.OriginalStream(source);
        }

        /// <summary>
        /// Gets the original stream that was used to create the duplicate.
        /// </summary>
        public Stream Source
        {
            get
            {
                return this.source;
            }
        }

        /// <summary>
        /// Gets a value indicating whether the source stream supports reading.
        /// </summary>
        /// <value>true if the stream supports reading; otherwise, false.</value>
        public override bool CanRead
        {
            get
            {
                return this.source.CanRead;
            }
        }

        /// <summary>
        /// Gets a value indicating whether the source stream supports writing.
        /// </summary>
        /// <value>true if the stream supports writing; otherwise, false.</value>
        public override bool CanWrite
        {
            get
            {
                return this.source.CanWrite;
            }
        }

        /// <summary>
        /// Gets a value indicating whether the source stream supports seeking.
        /// </summary>
        /// <value>true if the stream supports seeking; otherwise, false.</value>
        public override bool CanSeek
        {
            get
            {
                return this.source.CanSeek;
            }
        }

        /// <summary>
        /// Gets the length of the source stream.
        /// </summary>
        public override long Length
        {
            get
            {
                return this.source.Length;
            }
        }

        /// <summary>
        /// Gets or sets the position of the current stream,
        /// ignoring the position of the source stream.
        /// </summary>
        public override long Position
        {
            get
            {
                return this.position;
            }

            set
            {
                this.position = value;
            }
        }

        /// <summary>
        /// Retrieves the original stream from a possible duplicate stream.
        /// </summary>
        /// <param name="stream">Possible duplicate stream.</param>
        /// <returns>If the stream is a DuplicateStream, returns
        /// the duplicate's source; otherwise returns the same stream.</returns>
        public static Stream OriginalStream(Stream stream)
        {
            DuplicateStream dupStream = stream as DuplicateStream;
            return dupStream != null ? dupStream.Source : stream;
        }

        /// <summary>
        /// Flushes the source stream.
        /// </summary>
        public override void Flush()
        {
            this.source.Flush();
        }

        /// <summary>
        /// Sets the length of the source stream.
        /// </summary>
        /// <param name="value">The desired length of the stream in bytes.</param>
        public override void SetLength(long value)
        { 
            this.source.SetLength(value);
        }

        /// <summary>
        /// Closes the underlying stream, effectively closing ALL duplicates.
        /// </summary>
        public override void Close()
        {
            this.source.Close();
        }

        /// <summary>
        /// Reads from the source stream while maintaining a separate position
        /// and not impacting the source stream's position.
        /// </summary>
        /// <param name="buffer">An array of bytes. When this method returns, the buffer
        /// contains the specified byte array with the values between offset and
        /// (offset + count - 1) replaced by the bytes read from the current source.</param>
        /// <param name="offset">The zero-based byte offset in buffer at which to begin
        /// storing the data read from the current stream.</param>
        /// <param name="count">The maximum number of bytes to be read from the current stream.</param>
        /// <returns>The total number of bytes read into the buffer. This can be less
        /// than the number of bytes requested if that many bytes are not currently available,
        /// or zero (0) if the end of the stream has been reached.</returns>
        public override int Read(byte[] buffer, int offset, int count)
        {
            long saveSourcePosition = this.source.Position;
            this.source.Position = this.position;
            int read = this.source.Read(buffer, offset, count);
            this.position = this.source.Position;
            this.source.Position = saveSourcePosition;
            return read;
        }

        /// <summary>
        /// Writes to the source stream while maintaining a separate position
        /// and not impacting the source stream's position.
        /// </summary>
        /// <param name="buffer">An array of bytes. This method copies count
        /// bytes from buffer to the current stream.</param>
        /// <param name="offset">The zero-based byte offset in buffer at which
        /// to begin copying bytes to the current stream.</param>
        /// <param name="count">The number of bytes to be written to the
        /// current stream.</param>
        public override void Write(byte[] buffer, int offset, int count)
        {
            long saveSourcePosition = this.source.Position;
            this.source.Position = this.position;
            this.source.Write(buffer, offset, count);
            this.position = this.source.Position;
            this.source.Position = saveSourcePosition;
        }

        /// <summary>
        /// Changes the position of this stream without impacting the
        /// source stream's position.
        /// </summary>
        /// <param name="offset">A byte offset relative to the origin parameter.</param>
        /// <param name="origin">A value of type SeekOrigin indicating the reference
        /// point used to obtain the new position.</param>
        /// <returns>The new position within the current stream.</returns>
        public override long Seek(long offset, SeekOrigin origin)
        {
            long originPosition = 0;
            if (origin == SeekOrigin.Current)
            {
                originPosition = this.position;
            }
            else if (origin == SeekOrigin.End)
            {
                originPosition = this.Length;
            }

            this.position = originPosition + offset;
            return this.position;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup2\Compression\IPackStreamContext.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="IPackStreamContext.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
    using System;
    using System.IO;
    using System.Diagnostics.CodeAnalysis;

    /// <summary>
    /// This interface provides the methods necessary for the
    /// <see cref="CompressionEngine"/> to open and close streams for archives
    /// and files. The implementor of this interface can use any kind of logic
    /// to determine what kind of streams to open and where.
    /// </summary>
    public interface IPackStreamContext
    {
        /// <summary>
        /// Gets the name of the archive with a specified number.
        /// </summary>
        /// <param name="archiveNumber">The 0-based index of the archive
        /// within the chain.</param>
        /// <returns>The name of the requested archive. May be an empty string
        /// for non-chained archives, but may never be null.</returns>
        /// <remarks>The archive name is the name stored within the archive, used for
        /// identification of the archive especially among archive chains. That
        /// name is often, but not necessarily the same as the filename of the
        /// archive package.</remarks>
        string GetArchiveName(int archiveNumber);

        /// <summary>
        /// Opens a stream for writing an archive package.
        /// </summary>
        /// <param name="archiveNumber">The 0-based index of the archive within
        /// the chain.</param>
        /// <param name="archiveName">The name of the archive that was returned
        /// by <see cref="GetArchiveName"/>.</param>
        /// <param name="truncate">True if the stream should be truncated when
        /// opened (if it already exists); false if an existing stream is being
        /// re-opened for writing additional data.</param>
        /// <param name="compressionEngine">Instance of the compression engine
        /// doing the operations.</param>
        /// <returns>A writable Stream where the compressed archive bytes will be
        /// written, or null to cancel the archive creation.</returns>
        /// <remarks>
        /// If this method returns null, the archive engine will throw a
        /// FileNotFoundException.
        /// </remarks>
        Stream OpenArchiveWriteStream(
            int archiveNumber,
            string archiveName,
            bool truncate,
            CompressionEngine compressionEngine);

        /// <summary>
        /// Closes a stream where an archive package was written.
        /// </summary>
        /// <param name="archiveNumber">The 0-based index of the archive within
        /// the chain.</param>
        /// <param name="archiveName">The name of the archive that was previously
        /// returned by
        /// <see cref="GetArchiveName"/>.</param>
        /// <param name="stream">A stream that was previously returned by
        /// <see cref="OpenArchiveWriteStream"/> and is now ready to be closed.</param>
        /// <remarks>
        /// If there is another archive package in the chain, then after this stream
        /// is closed a new stream will be opened.
        /// </remarks>
        void CloseArchiveWriteStream(int archiveNumber, string archiveName, Stream stream);

        /// <summary>
        /// Opens a stream to read a file that is to be included in an archive.
        /// </summary>
        /// <param name="path">The path of the file within the archive. This is often,
        /// but not necessarily, the same as the relative path of the file outside
        /// the archive.</param>
        /// <param name="attributes">Returned attributes of the opened file, to be
        /// stored in the archive.</param>
        /// <param name="lastWriteTime">Returned last-modified time of the opened file,
        /// to be stored in the archive.</param>
        /// <returns>A readable Stream where the file bytes will be read from before
        /// they are compressed, or null to skip inclusion of the file and continue to
        /// the next file.</returns>
        [SuppressMessage("Microsoft.Design", "CA1021:AvoidOutParameters")]
        Stream OpenFileReadStream(
            string path,
            out FileAttributes attributes,
            out DateTime lastWriteTime);

        /// <summary>
        /// Closes a stream that has been used to read a file.
        /// </summary>
        /// <param name="path">The path of the file within the archive; the same as
        /// the path provided
        /// when the stream was opened.</param>
        /// <param name="stream">A stream that was previously returned by
        /// <see cref="OpenFileReadStream"/> and is now ready to be closed.</param>
        void CloseFileReadStream(string path, Stream stream);

        /// <summary>
        /// Gets extended parameter information specific to the compression
        /// format being used.
        /// </summary>
        /// <param name="optionName">Name of the option being requested.</param>
        /// <param name="parameters">Parameters for the option; for per-file options,
        /// the first parameter is typically the internal file path.</param>
        /// <returns>Option value, or null to use the default behavior.</returns>
        /// <remarks>
        /// This method provides a way to set uncommon options during packaging, or a
        /// way to handle aspects of compression formats not supported by the base library.
        /// <para>For example, this may be used by the zip compression library to
        /// specify different compression methods/levels on a per-file basis.</para>
        /// <para>The available option names, parameters, and expected return values
        /// should be documented by each compression library.</para>
        /// </remarks>
        object GetOption(string optionName, object[] parameters);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup2\Compression\IUnpackStreamContext.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="IUnpackStreamContext.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
    using System;
    using System.IO;

    /// <summary>
    /// This interface provides the methods necessary for the <see cref="CompressionEngine"/> to open
    /// and close streams for archives and files. The implementor of this interface can use any
    /// kind of logic to determine what kind of streams to open and where 
    /// </summary>
    public interface IUnpackStreamContext
    {
        /// <summary>
        /// Opens the archive stream for reading.
        /// </summary>
        /// <param name="archiveNumber">The zero-based index of the archive to open.</param>
        /// <param name="archiveName">The name of the archive being opened.</param>
        /// <param name="compressionEngine">Instance of the compression engine doing the operations.</param>
        /// <returns>A stream from which archive bytes are read, or null to cancel extraction
        /// of the archive.</returns>
        /// <remarks>
        /// When the first archive in a chain is opened, the name is not yet known, so the
        /// provided value will be an empty string. When opening further archives, the
        /// provided value is the next-archive name stored in the previous archive. This
        /// name is often, but not necessarily, the same as the filename of the archive
        /// package to be opened.
        /// <para>If this method returns null, the archive engine will throw a
        /// FileNotFoundException.</para>
        /// </remarks>
        Stream OpenArchiveReadStream(int archiveNumber, string archiveName, CompressionEngine compressionEngine);

        /// <summary>
        /// Closes a stream where an archive package was read.
        /// </summary>
        /// <param name="archiveNumber">The archive number of the stream to close.</param>
        /// <param name="archiveName">The name of the archive being closed.</param>
        /// <param name="stream">The stream that was previously returned by
        /// <see cref="OpenArchiveReadStream"/> and is now ready to be closed.</param>
        void CloseArchiveReadStream(int archiveNumber, string archiveName, Stream stream);

        /// <summary>
        /// Opens a stream for writing extracted file bytes.
        /// </summary>
        /// <param name="path">The path of the file within the archive. This is often, but
        /// not necessarily, the same as the relative path of the file outside the archive.</param>
        /// <param name="fileSize">The uncompressed size of the file to be extracted.</param>
        /// <param name="lastWriteTime">The last write time of the file to be extracted.</param>
        /// <returns>A stream where extracted file bytes are to be written, or null to skip
        /// extraction of the file and continue to the next file.</returns>
        /// <remarks>
        /// The implementor may use the path, size and date information to dynamically
        /// decide whether or not the file should be extracted.
        /// </remarks>
        Stream OpenFileWriteStream(string path, long fileSize, DateTime lastWriteTime);

        /// <summary>
        /// Closes a stream where an extracted file was written.
        /// </summary>
        /// <param name="path">The path of the file within the archive.</param>
        /// <param name="stream">The stream that was previously returned by <see cref="OpenFileWriteStream"/>
        /// and is now ready to be closed.</param>
        /// <param name="attributes">The attributes of the extracted file.</param>
        /// <param name="lastWriteTime">The last write time of the file.</param>
        /// <remarks>
        /// The implementor may wish to apply the attributes and date to the newly-extracted file.
        /// </remarks>
        void CloseFileWriteStream(string path, Stream stream, FileAttributes attributes, DateTime lastWriteTime);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup2\Compression\OffsetStream.cs ===
//---------------------------------------------------------------------
// <copyright file="OffsetStream.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
    using System;
    using System.IO;

    /// <summary>
    /// Wraps a source stream and offsets all read/write/seek calls by a given value.
    /// </summary>
    /// <remarks>
    /// This class is used to trick archive an packing or unpacking process
    /// into reading or writing at an offset into a file, primarily for
    /// self-extracting packages.
    /// </remarks>
    public class OffsetStream : Stream
    {
        private Stream source;
        private long sourceOffset;

        /// <summary>
        /// Creates a new OffsetStream instance from a source stream
        /// and using a specified offset.
        /// </summary>
        /// <param name="source">Underlying stream for which all calls will be offset.</param>
        /// <param name="offset">Positive or negative number of bytes to offset.</param>
        public OffsetStream(Stream source, long offset)
        {
            if (source == null)
            {
                throw new ArgumentNullException("source");
            }

            this.source = source;
            this.sourceOffset = offset;

            this.source.Seek(this.sourceOffset, SeekOrigin.Current);
        }

        /// <summary>
        /// Gets the underlying stream that this OffsetStream calls into.
        /// </summary>
        public Stream Source
        {
            get { return this.source; }
        }

        /// <summary>
        /// Gets the number of bytes to offset all calls before
        /// redirecting to the underlying stream.
        /// </summary>
        public long Offset
        {
            get { return this.sourceOffset; }
        }

        /// <summary>
        /// Gets a value indicating whether the source stream supports reading.
        /// </summary>
        /// <value>true if the stream supports reading; otherwise, false.</value>
        public override bool CanRead
        {
            get
            {
                return this.source.CanRead;
            }
        }

        /// <summary>
        /// Gets a value indicating whether the source stream supports writing.
        /// </summary>
        /// <value>true if the stream supports writing; otherwise, false.</value>
        public override bool CanWrite
        {
            get
            {
                return this.source.CanWrite;
            }
        }

        /// <summary>
        /// Gets a value indicating whether the source stream supports seeking.
        /// </summary>
        /// <value>true if the stream supports seeking; otherwise, false.</value>
        public override bool CanSeek
        {
            get
            {
                return this.source.CanSeek;
            }
        }

        /// <summary>
        /// Gets the effective length of the stream, which is equal to
        /// the length of the source stream minus the offset.
        /// </summary>
        public override long Length
        {
            get { return this.source.Length - this.sourceOffset; } 
        }

        /// <summary>
        /// Gets or sets the effective position of the stream, which
        /// is equal to the position of the source stream minus the offset.
        /// </summary>
        public override long Position
        {
            get { return this.source.Position - this.sourceOffset; }
            set { this.source.Position = value + this.sourceOffset; }
        }

        /// <summary>
        /// Reads a sequence of bytes from the source stream and advances
        /// the position within the stream by the number of bytes read.
        /// </summary>
        /// <param name="buffer">An array of bytes. When this method returns, the buffer
        /// contains the specified byte array with the values between offset and
        /// (offset + count - 1) replaced by the bytes read from the current source.</param>
        /// <param name="offset">The zero-based byte offset in buffer at which to begin
        /// storing the data read from the current stream.</param>
        /// <param name="count">The maximum number of bytes to be read from the current stream.</param>
        /// <returns>The total number of bytes read into the buffer. This can be less
        /// than the number of bytes requested if that many bytes are not currently available,
        /// or zero (0) if the end of the stream has been reached.</returns>
        public override int Read(byte[] buffer, int offset, int count)
        {
            return this.source.Read(buffer, offset, count);
        }

        /// <summary>
        /// Writes a sequence of bytes to the source stream and advances the
        /// current position within this stream by the number of bytes written.
        /// </summary>
        /// <param name="buffer">An array of bytes. This method copies count
        /// bytes from buffer to the current stream.</param>
        /// <param name="offset">The zero-based byte offset in buffer at which
        /// to begin copying bytes to the current stream.</param>
        /// <param name="count">The number of bytes to be written to the
        /// current stream.</param>
        public override void Write(byte[] buffer, int offset, int count)
        {
            this.source.Write(buffer, offset, count);
        }

        /// <summary>
        /// Reads a byte from the stream and advances the position within the
        /// source stream by one byte, or returns -1 if at the end of the stream.
        /// </summary>
        /// <returns>The unsigned byte cast to an Int32, or -1 if at the
        /// end of the stream.</returns>
        public override int ReadByte()
        {
            return this.source.ReadByte();
        }

        /// <summary>
        /// Writes a byte to the current position in the source stream and
        /// advances the position within the stream by one byte.
        /// </summary>
        /// <param name="value">The byte to write to the stream.</param>
        public override void WriteByte(byte value)
        {
            this.source.WriteByte(value);
        }

        /// <summary>
        /// Flushes the source stream.
        /// </summary>
        public override void Flush()
        {
            this.source.Flush();
        }

        /// <summary>
        /// Sets the position within the current stream, which is
        /// equal to the position within the source stream minus the offset.
        /// </summary>
        /// <param name="offset">A byte offset relative to the origin parameter.</param>
        /// <param name="origin">A value of type SeekOrigin indicating
        /// the reference point used to obtain the new position.</param>
        /// <returns>The new position within the current stream.</returns>
        public override long Seek(long offset, SeekOrigin origin)
        {
            return this.source.Seek(offset + (origin == SeekOrigin.Begin ? this.sourceOffset : 0), origin) - this.sourceOffset;
        }

        /// <summary>
        /// Sets the effective length of the stream, which is equal to
        /// the length of the source stream minus the offset.
        /// </summary>
        /// <param name="value">The desired length of the
        /// current stream in bytes.</param>
        public override void SetLength(long value)
        {
            this.source.SetLength(value + this.sourceOffset);
        }

        /// <summary>
        /// Closes the underlying stream.
        /// </summary>
        public override void Close()
        {
            this.source.Close();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup2\Compression\SafeNativeMethods.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="SafeNativeMethods.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
    using System;
    using System.Security;
    using System.Runtime.InteropServices;

    [SuppressUnmanagedCodeSecurity]
    internal static class SafeNativeMethods
    {
        [DllImport("kernel32.dll", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        internal static extern bool DosDateTimeToFileTime(
            short wFatDate, short wFatTime, out long fileTime);

        [DllImport("kernel32.dll", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        internal static extern bool FileTimeToDosDateTime(
            ref long fileTime, out short wFatDate, out short wFatTime);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup2\Settings.cs ===
﻿using System.Globalization;
//-----------------------------------------------------------------------
// <copyright file="Settings.cs" company="Microsoft Corporation">
//     Copyright (c) Microsoft Corporation. All rights reserved.
// </copyright>
//-----------------------------------------------------------------------
namespace Microsoft.LFIT
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Runtime.InteropServices;
    using System.Security;
    using System.Security.Permissions;
    using System.Text;
    using System.Text.RegularExpressions;
    
    public enum Command
    {
        All = 0,
        Create,
        Submit,
        Check
    }
    
    public class Settings
    {
        private const long twoGigs = 2146435072;
        private const int lengthTitleId = 8;
        private const int lengthContentId = 40;
        private const int lengthOfferId = 16;

        private bool quiet;

        private Command inputCommand;
        //private string codeSignFileName;
        private string srcFileName;
        private string dstFileName;
        //private string codeSignJobNumber;
        //private string codeSignCompletionPath;
        private long maxCabSize;
        private string titleID;
        private string contentID;
        private string offerID;
        private string contentType;
        private string contentURL;
        private string inputFolder;
        private string unSignedCabPath;
        private string contentFilePath;
        private string currentWorkingDirectory;
        private string tempDirectory;
        private int compressionLevel;
        private bool nooverwritexbx;
        //private IList<string> signers;
        //private string largeFileCertID;
        //private string normalFileCertID;
        //private string strongNameCertID;

        public Settings()
        {
            quiet = false;
            inputCommand = Command.All;
            //signers = new List<string>();
            //largeFileCertID = @"10038";
            //normalFileCertID = @"10006";
            //strongNameCertID = @"";
            //codeSignJobNumber = @"";
            //codeSignCompletionPath = @"";
            //codeSignFileName = @"";
            maxCabSize = Settings.twoGigs;    // default = 2G - 1MB
            contentFilePath = @"\\xsinfxferinh001\Content\";
            contentURL = @"\\xsinfxferinh001\Content\";
            this.currentWorkingDirectory = Directory.GetCurrentDirectory();
            srcFileName = @"";
            dstFileName = @"";
        }

        public bool Quiet
        {
            get { return this.quiet; }
        }

        public Command InputCommand
        {
            get { return this.inputCommand; }
        }

        public string SrcFileName
        {
            get { return this.srcFileName; }
        }

        public int CompressionLevel
        {
            get { return compressionLevel; }
        }

        public bool Nooverwritexbx
        {
            get { return nooverwritexbx; }
        }

        public string DstFileName
        {
            get { return this.dstFileName; }
        }
        /*
        public string CodeSignFileName
        {
            get { return this.codeSignFileName; }
        }

        public string CodeSignJobNumber
        {
            get { return this.codeSignJobNumber; }
        }

        public string CodeSignCompletionPath
        {
            get { return this.codeSignCompletionPath; }
        }
        public IList<string> Signers
        {
            get { return this.signers; }
        }
        public string LargeFileCertID
        {
            get { return this.largeFileCertID; }
        }

        public string NormalFileCertID
        {
            get { return this.normalFileCertID; }
        }

        public string StrongNameCertID
        {
            get { return this.strongNameCertID; }
        }
        */
        public long MaxCabSize
        {
            get { return this.maxCabSize; }
        }

        public string InputFolder
        {
            get { return this.inputFolder; }
        }
        public string TitleID
        {
            get { return this.titleID; }
        }
        public string OfferID
        {
            get { return this.offerID; }
        }
        public string ContentID
        {
            get { return this.contentID; }
        }
        public string ContentType
        {
            get { return this.contentType; }
        }
        public string ContentFilePath
        {
            get { return this.contentFilePath; }
        }
        public string ContentURL
        {
            get { return this.contentURL; }
        }
        public string CurrentWorkingDirectory
        {
            get { return this.currentWorkingDirectory; }
        }
        public string TempDirectory
        {
            get { return this.tempDirectory; }
        }
        public string UnSignedCabPath
        {
            get { return this.unSignedCabPath; }
        }

        public static void DisplayUsage()
        {
            Log.WriteLog("\nCreates and props full game content files for Windows - LIVE title");
            Log.WriteLog(string.Empty);
            Log.WriteLog("Usage: LFIT.exe [command] /inputFolder <inputFolder> /titleId <TitleID> /contentId <ContentID> /offerId <OfferID> /contentType <ContentType> /unsignedCabPath <UnsignedCabPath> [/maxCabSize <maxCabSize>] [/contentURL <ContentURL>] [/compressionLevel <CompressionLevel>]");
            Log.WriteLog(string.Empty);
            Log.WriteLog("\t[command]\tcreate - create content and manifest cabs\n");
            Log.WriteLog("\t/q\t\t\tQuiet mode. No output displayed\n");
            Log.WriteLog("\t/inputFolder\t\tThe folder containing all of the full game files\n");
            Log.WriteLog("\t/titleId\t\tThe 8-char Title ID for the game without the hex prefix (0x)\n");
            Log.WriteLog("\t/contentId\t\tThe Content ID to be assigned to the spanned cabs\n");
            Log.WriteLog("\t/offerId\t\tThe full Offer ID for the game without the hex prefix (0x)\n");
            Log.WriteLog("\t/contentType\t\tCan be 0x00007000 (for FullGame) or 0x00080000 (for GameDemo)\n");
            Log.WriteLog("\t/maxCabSize\t\tThe maximum size of one cab file (in megabyte)\n\t\t\t\tDefault: 2048\n");
            Log.WriteLog("\t/unsignedCabPath\tThe folder to where the unsigned spanned CABs will be dropped\n");
            Log.WriteLog("\t/contentURL\t\tThe CDN location from which the spanned CABs can be reached\n\t\t\t\tDefault: \\\\xsinfxferinh001\\Content\n");
            Log.WriteLog("\t/compressionLevel\tCompression level number between 0 to 10. 0 = none and fast. 10 = max and slow. Defaults to 10.\n");
            Log.WriteLog("\t/nooverwritexbx\t\tLFIT will not overwrite or create a content.xbx.  It uses the existing one in the input folder\n");
            //Log.WriteLog("\t\t\tsubmit - submit one cab for CodeSign\n");
            //Log.WriteLog("\t\t\t\t  /fileName <FileName> /signer <Alias1> /signer <Alias2>\n");
            //Log.WriteLog("\t\t\tcheck - check CodeSign result\n");
            //Log.WriteLog("\t\t\t\t  /codeSignJobNumber <CodeSignJobNumber> \n");
            //Log.WriteLog("\t/signer \t\tRepeat input once for each person who can approve the request\n");
            //Log.WriteLog("\t/largeFileCertID\tCertificate ID used to sign files bigger than 500M\n\t\t\t\tDefault: 10038\n");
            //Log.WriteLog("\t/normalFileCertID\tCertificate ID used to sign files less than 500M\n\t\t\t\tDefault: 10006\n");
            //Log.WriteLog("\t/strongNameCertID\tCertificate ID used to sign files with strong name\n\t\t\t\tDefault: not used\n");
        }

        public void ParseCommandLine(string[] args)
        {
            this.tempDirectory = Path.Combine(System.IO.Path.GetTempPath(), @"LFIT");

            for (int i = 0; i < args.Length; i++)
            {
                string arg = args[i];
                if (arg[0] == '-' || arg[0] == '/')
                {
                    arg = arg.Remove(0, 1);
                    if (string.Compare(arg, "q", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        this.quiet = true;
                    }
                    else if (string.Compare(arg, "MaxCabSize", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.maxCabSize = Convert.ToInt64(args[i]) * 1048576;
                            if( this.maxCabSize > Settings.twoGigs )
                            {
                                throw new ArgumentException("Cab size too large.  2047MB is max", "/MaxCabSize");
                            }
                        }
                        else
                        {
                            throw new ArgumentException("Missing cab size", "/MaxCabSize");
                        }
                    }
                    else if (string.Compare(arg, "nooverwritexbx", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        this.nooverwritexbx = true;
                    }
                    else if (string.Compare(arg, "compressionLevel", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            try
                            {
                                this.compressionLevel = Int32.Parse(args[i]);
                                if (this.compressionLevel < 0 || this.compressionLevel > 10)
                                {
                                    throw new ArgumentException("Invalid compressionLevel", "/compressionLevel");
                                }
                            }
                            catch (System.Exception)
                            {
                                throw new ArgumentException("Invalid compressionLevel", "/compressionLevel");
                            }
                        }
                        else
                        {
                            throw new ArgumentException("Missing compressionLevel", "/compressionLevel");
                        }
                    }
                    else if (string.Compare(arg, "inputFolder", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.inputFolder = args[i];
                            this.inputFolder = Settings.UnquoteString(this.inputFolder);
                        }
                        else
                        {
                            throw new ArgumentException("Missing input folder", "/inputFolder");
                        }
                    }
                    else if (string.Compare(arg, "titleID", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.titleID = args[i];
                            ValidateHexParameter(this.titleID, lengthTitleId, "titleID");
                        }
                        else
                        {
                            throw new ArgumentException("Missing title ID", "/titleID");
                        }
                    }
                    else if (string.Compare(arg, "contentID", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.contentID = args[i];
                            ValidateHexParameter(this.contentID, lengthContentId, "contentID");
                        }
                        else
                        {
                            throw new ArgumentException("Missing content ID", "/contentID");
                        }
                    }
                    else if (string.Compare(arg, "offerID", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.offerID = args[i];
                            ValidateHexParameter(this.offerID, lengthOfferId, "offerID");
                        }
                        else
                        {
                            throw new ArgumentException("Missing offer ID", "/offerID");
                        }
                    }
                    else if (string.Compare(arg, "contentType", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.contentType = args[i];
                            if (string.Compare( this.ContentType, "0x00080000", StringComparison.OrdinalIgnoreCase ) != 0 &&
                                string.Compare( this.ContentType, "0x00007000", StringComparison.OrdinalIgnoreCase ) != 0) 
                            {
                                throw new ArgumentException("Invalid content type", "/contentType");
                            }
                        }
                        else
                        {
                            throw new ArgumentException("Missing content type", "/contentType");
                        }
                    }
                    else if (string.Compare(arg, "contentFilePath", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.contentFilePath = args[i];
                            this.contentFilePath = Settings.UnquoteString(this.contentFilePath);
                        }
                        else
                        {
                            throw new ArgumentException("Missing content file path", "/contentFilePath");
                        }
                    }
                    else if (string.Compare(arg, "unsignedCabPath", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.unSignedCabPath = args[i];
                            this.unSignedCabPath = Settings.UnquoteString(this.unSignedCabPath);
                        }
                        else
                        {
                            throw new ArgumentException("Missing unsigned cab files save path", "/unsignedCabPath");
                        }
                    }
                    else if (string.Compare(arg, "contentURL", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.contentURL = args[i];
                            this.contentURL = Settings.UnquoteString(this.contentURL);

                            Log.WriteLog("ContentURL: " + this.contentURL);
                        }
                        else
                        {
                            throw new ArgumentException("Missing content URL", "/contentURL");
                        }
                    }
/*
                    else if (string.Compare(arg, "signer", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.signers.Add(args[i].ToUpper());
                        }
                        else
                        {
                            throw new ArgumentException("Missing CodeSign signer", "/signer");
                        }
                    }
                    else if (string.Compare(arg, "largeFileCertID", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.largeFileCertID = args[i];
                        }
                        else
                        {
                            throw new ArgumentException("Missing the larger certificate ID", "/largeFileCertID");
                        }
                    }
                    else if (string.Compare(arg, "normalFileCertID", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.normalFileCertID = args[i];
                        }
                        else
                        {
                            throw new ArgumentException("Missing the normal certificate ID", "/normalFileCertID");
                        }
                    }
                    else if (string.Compare(arg, "strongNameCertID", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.strongNameCertID = args[i];
                        }
                        else
                        {
                            throw new ArgumentException("Missing the strong name certificate ID", "/strongNameCertID");
                        }
                    }  
                    else if (string.Compare(arg, "fileName", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.codeSignFileName = args[i];
                        }
                        else
                        {
                            throw new ArgumentException("Missing the file name", "/fileName");
                        }
                    }

                    else if (string.Compare(arg, "codeSignJobNumber", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.codeSignJobNumber = args[i];
                        }
                        else
                        {
                            throw new ArgumentException("Missing code sign job number", "/codeSignJobNumber");
                        }
                    }
                    else if (string.Compare(arg, "codeSignCompletionPath", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.codeSignCompletionPath = args[i];
                        }
                        else
                        {
                            throw new ArgumentException("Missing code sign completion path", "/codeSignCompletionPath");
                        }
                    }
 */ 
                    else if (string.Compare(arg, "srcFileName", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.srcFileName = args[i];
                            this.srcFileName = Settings.UnquoteString(this.srcFileName);
                        }
                        else
                        {
                            throw new ArgumentException("Missing the source file name", "/srcFileName");
                        }
                    }
                    else if (string.Compare(arg, "dstFileName", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.dstFileName = args[i];
                            this.dstFileName = Settings.UnquoteString(this.dstFileName);
                        }
                        else
                        {
                            throw new ArgumentException("Missing the destination file name", "/dstFileName");
                        }
                    }
                    else if (string.Compare(arg, "?", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        throw new ArgumentException("Display help", "-?");
                    }
                    else
                    {
                        throw new ArgumentException("Unknown arg", arg);
                    }
                }
                else
                {
                    if (string.Compare(arg, "create", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        this.inputCommand = Command.Create;
                    }
                    else if (string.Compare(arg, "submit", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        this.inputCommand = Command.Submit;
                    }
                    else if (string.Compare(arg, "check", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        this.inputCommand = Command.Check;
                    }
                    else
                    {
                        throw new ArgumentException("Unknown arg", arg);
                    }
                }

            }

            if (string.IsNullOrEmpty(this.contentFilePath))
            {
                this.contentFilePath = @"\\xsinfxferinh001\Content";
            }
            if (string.IsNullOrEmpty(this.contentURL))
            {
                this.contentURL = @"\\xsinfxferinh001\Content";
            }

            if( this.inputCommand != Command.Create )
            {
                throw new ArgumentException("Command must be create", "command");
            }

            // justify the input
            switch (this.inputCommand)
            {
                case Command.All:
                {
                    if (string.IsNullOrEmpty(this.inputFolder))
                    {
                        throw new ArgumentException("Missing input folder path", "/inputFolder");
                    }

                    if (string.IsNullOrEmpty(this.titleID))
                    {
                        throw new ArgumentException("Missing title ID", "/titleID");
                    }

                    if (string.IsNullOrEmpty(this.contentID))
                    {
                        throw new ArgumentException("Missing content ID", "/contentID");
                    }

                    if (string.IsNullOrEmpty(this.offerID))
                    {
                        throw new ArgumentException("Missing offer ID", "/offerID");
                    }

                    if (string.IsNullOrEmpty(this.contentType))
                    {
                        throw new ArgumentException("Missing content type", "/contentType");
                    }

                    if (string.IsNullOrEmpty(this.unSignedCabPath))
                    {
                        throw new ArgumentException("Missing unsigned cab file save path", "/unSignedCabPath");
                    }

                    // The first 8 digit in offer id should be title id
                    if (!this.offerID.StartsWith(this.titleID, StringComparison.InvariantCultureIgnoreCase))
                    {
                        throw new ArgumentException("offerID and titleID does not match", "/offerID");
                    }
/*
                    if (string.IsNullOrEmpty(this.CodeSignFileName))
                    {
                        throw new ArgumentException("Missing the input file name", "/fileName");
                    }
 
                    if (this.signers.Count < 2)
                    {
                        throw new ArgumentException("Missing CodeSign approvers", "/signer");
                    }

                    if (string.IsNullOrEmpty(this.codeSignJobNumber))
                    {
                        throw new ArgumentException("Missing the input job number", "/codeSignJobNumber");
                    }
*/
                    break;
                }
                case Command.Create:
                {
                    if (string.IsNullOrEmpty(this.inputFolder))
                    {
                        throw new ArgumentException("Missing input folder path", "/inputFolder");
                    }

                    if (string.IsNullOrEmpty(this.titleID))
                    {
                        throw new ArgumentException("Missing title ID", "/titleID");
                    }

                    if (string.IsNullOrEmpty(this.contentID))
                    {
                        throw new ArgumentException("Missing content ID", "/contentID");
                    }

                    if (string.IsNullOrEmpty(this.offerID))
                    {
                        throw new ArgumentException("Missing offer ID", "/offerID");
                    }

                    if (string.IsNullOrEmpty(this.contentType))
                    {
                        throw new ArgumentException("Missing content type", "/contentType");
                    }

                    if (string.IsNullOrEmpty(this.unSignedCabPath))
                    {
                        throw new ArgumentException("Missing unsigned cab file save path", "/unSignedCabPath");
                    }

                    // The first 8 digit in offer id should be title id
                    if (!this.offerID.StartsWith(this.titleID, StringComparison.InvariantCultureIgnoreCase))
                    {
                        throw new ArgumentException("offerID and titleID does not match", "/offerID");
                    }

                    break;
                }
/*
                case Command.Submit:
                {
                    if (string.IsNullOrEmpty(this.CodeSignFileName))
                    {
                        throw new ArgumentException("Missing the input file name", "/fileName");
                    }

                    if (this.signers.Count < 2)
                    {
                        throw new ArgumentException("Missing CodeSign approvers", "/signer");
                    }
                    break;
                }

                case Command.Check:
                {
                    if (string.IsNullOrEmpty(this.codeSignJobNumber))
                    {
                        throw new ArgumentException("Missing the input job number", "/codeSignJobNumber");
                    }
                    break;
                }
*/
            }

        }

        private static string UnquoteString(string input)
        {
            bool quotedString = false;
            if (input.EndsWith("\"") || input.StartsWith("\""))
            {
                quotedString = true;
            }

            if (quotedString)
            {
                // Remove quotes
                if (input.EndsWith("\""))
                {
                    input = input.Substring(0, input.Length - 1);
                }

                if (input.StartsWith("\""))
                {
                    input = input.Substring(1, input.Length - 1);
                }
            }

            return input;
        }

        private void ValidateHexParameter(string hexString, int expectedLength, string paramName)
        {
            if (hexString.StartsWith("0x", StringComparison.InvariantCultureIgnoreCase))
            {
                throw new ArgumentException(string.Format("{0} should not start with 0x.", paramName), string.Format("/{0}", paramName));
            }
            else if (hexString.Length != expectedLength)
            {
                throw new ArgumentException(string.Format("{0} should be in the length of {1}.", paramName, expectedLength), string.Format("/{0}", paramName));
            }
            else if (!IsHexString(hexString))
            {
                throw new ArgumentException(string.Format("{0} is not a valid hexadecimal string", paramName), string.Format("/{0}", paramName));
            }
        }

        private bool IsHexString(string hexString)
        {
            Regex hexRegex = new Regex("^[0-9a-fA-F]+$", RegexOptions.CultureInvariant | RegexOptions.Compiled);
            return hexRegex.IsMatch(hexString);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup2\Compression.Cab\CabEngine.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="CabEngine.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Cab
{
    using System;
    using System.IO;
    using System.Collections.Generic;

    /// <summary>
    /// Engine capable of packing and unpacking archives in the cabinet format.
    /// </summary>
    public class CabEngine : CompressionEngine
    {
        private CabPacker packer;
        private CabUnpacker unpacker;

        /// <summary>
        /// Creates a new instance of the cabinet engine.
        /// </summary>
        public CabEngine()
            : base()
        {
        }

        /// <summary>
        /// Disposes of resources allocated by the cabinet engine.
        /// </summary>
        /// <param name="disposing">If true, the method has been called directly
        /// or indirectly by a user's code, so managed and unmanaged resources
        /// will be disposed. If false, the method has been called by the runtime
        /// from inside the finalizer, and only unmanaged resources will be
        /// disposed.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                if (packer != null)
                {
                    packer.Dispose();
                    packer = null;
                }
                if (unpacker != null)
                {
                    unpacker.Dispose();
                    unpacker = null;
                }
            }

            base.Dispose(disposing);
        }

        private CabPacker Packer
        {
            get
            {
                if (this.packer == null)
                {
                    this.packer = new CabPacker(this);
                }

                return this.packer;
            }
        }

        private CabUnpacker Unpacker
        {
            get
            {
                if (this.unpacker == null)
                {
                    this.unpacker = new CabUnpacker(this);
                }

                return this.unpacker;
            }
        }

        /// <summary>
        /// Creates a cabinet or chain of cabinets.
        /// </summary>
        /// <param name="streamContext">A context interface to handle opening
        /// and closing of cabinet and file streams.</param>
        /// <param name="files">The paths of the files in the archive (not
        /// external file paths).</param>
        /// <param name="maxArchiveSize">The maximum number of bytes for one
        /// cabinet before the contents are chained to the next cabinet, or zero
        /// for unlimited cabinet size.</param>
        /// <exception cref="ArchiveException">The cabinet could not be
        /// created.</exception>
        /// <remarks>
        /// The stream context implementation may provide a mapping from the
        /// file paths within the cabinet to the external file paths.
        /// <para>Smaller folder sizes can make it more efficient to extract
        /// individual files out of large cabinet packages.</para>
        /// </remarks>
        public override void Pack(
            IPackStreamContext streamContext,
            IEnumerable<string> files,
            long maxArchiveSize)
        {
            this.Packer.CompressionLevel = this.CompressionLevel;
            this.Packer.UseTempFiles = this.UseTempFiles;
            this.Packer.Pack(streamContext, files, maxArchiveSize);
        }

        /// <summary>
        /// Checks whether a Stream begins with a header that indicates
        /// it is a valid cabinet file.
        /// </summary>
        /// <param name="stream">Stream for reading the cabinet file.</param>
        /// <returns>True if the stream is a valid cabinet file
        /// (with no offset); false otherwise.</returns>
        public override bool IsArchive(Stream stream)
        {
            return this.Unpacker.IsArchive(stream);
        }

        /// <summary>
        /// Gets information about files in a cabinet or cabinet chain.
        /// </summary>
        /// <param name="streamContext">A context interface to handle opening
        /// and closing of cabinet and file streams.</param>
        /// <param name="fileFilter">A predicate that can determine
        /// which files to process, optional.</param>
        /// <returns>Information about files in the cabinet stream.</returns>
        /// <exception cref="ArchiveException">The cabinet provided
        /// by the stream context is not valid.</exception>
        /// <remarks>
        /// The <paramref name="fileFilter"/> predicate takes an internal file
        /// path and returns true to include the file or false to exclude it.
        /// </remarks>
        public override IList<ArchiveFileInfo> GetFileInfo(
            IUnpackStreamContext streamContext,
            Predicate<string> fileFilter)
        {
            return this.Unpacker.GetFileInfo(streamContext, fileFilter);
        }

        /// <summary>
        /// Extracts files from a cabinet or cabinet chain.
        /// </summary>
        /// <param name="streamContext">A context interface to handle opening
        /// and closing of cabinet and file streams.</param>
        /// <param name="fileFilter">An optional predicate that can determine
        /// which files to process.</param>
        /// <exception cref="ArchiveException">The cabinet provided
        /// by the stream context is not valid.</exception>
        /// <remarks>
        /// The <paramref name="fileFilter"/> predicate takes an internal file
        /// path and returns true to include the file or false to exclude it.
        /// </remarks>
        public override void Unpack(
            IUnpackStreamContext streamContext,
            Predicate<string> fileFilter)
        {
            this.Unpacker.Unpack(streamContext, fileFilter);
        }

        internal void ReportProgress(ArchiveProgressEventArgs e)
        {
            base.OnProgress(e);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup2\Compression.Cab\CabException.cs ===
//---------------------------------------------------------------------
// <copyright file="CabException.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Cab
{
    using System;
    using System.IO;
    using System.Resources;
    using System.Globalization;
    using System.Security.Permissions;
    using System.Runtime.Serialization;

    /// <summary>
    /// Exception class for cabinet operations.
    /// </summary>
    [Serializable]
    public class CabException : ArchiveException
    {
        private static ResourceManager errorResources;
        private int error;
        private int errorCode;

        /// <summary>
        /// Creates a new CabException with a specified error message and a reference to the
        /// inner exception that is the cause of this exception.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        /// <param name="innerException">The exception that is the cause of the current exception. If the
        /// innerException parameter is not a null reference (Nothing in Visual Basic), the current exception
        /// is raised in a catch block that handles the inner exception.</param>
        public CabException(string message, Exception innerException)
            : this(0, 0, message, innerException) { }

        /// <summary>
        /// Creates a new CabException with a specified error message.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        public CabException(string message)
            : this(0, 0, message, null) { }

        /// <summary>
        /// Creates a new CabException.
        /// </summary>
        public CabException()
            : this(0, 0, null, null) { }

        internal CabException(int error, int errorCode, string message, Exception innerException)
            : base(message, innerException)
        {
            this.error = error;
            this.errorCode = errorCode;
        }

        internal CabException(int error, int errorCode, string message)
            : this(error, errorCode, message, null) { }

        /// <summary>
        /// Initializes a new instance of the CabException class with serialized data.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The StreamingContext that contains contextual information about the source or destination.</param>
        protected CabException(SerializationInfo info, StreamingContext context) : base(info, context)
        {
            if (info == null)
            {
                throw new ArgumentNullException("info");
            }

            this.error = info.GetInt32("cabError");
            this.errorCode = info.GetInt32("cabErrorCode");
        }

        /// <summary>
        /// Gets the FCI or FDI cabinet engine error number.
        /// </summary>
        /// <value>A cabinet engine error number, or 0 if the exception was
        /// not related to a cabinet engine error number.</value>
        public int Error
        {
            get
            {
                return this.error;
            }
        }

        /// <summary>
        /// Gets the Win32 error code.
        /// </summary>
        /// <value>A Win32 error code, or 0 if the exception was
        /// not related to a Win32 error.</value>
        public int ErrorCode
        {
            get
            {
                return this.errorCode;
            }
        }

        internal static ResourceManager ErrorResources
        {
            get
            {
                if (errorResources == null)
                {
                    errorResources = new ResourceManager(
                        typeof(CabException).Namespace + ".Errors",
                        typeof(CabException).Assembly);
                }
                return errorResources;
            }
        }

        /// <summary>
        /// Sets the SerializationInfo with information about the exception.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The StreamingContext that contains contextual information about the source or destination.</param>
        [SecurityPermission(SecurityAction.Demand, SerializationFormatter=true)]
        public override void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            if (info == null)
            {
                throw new ArgumentNullException("info");
            }

            info.AddValue("cabError", this.error);
            info.AddValue("cabErrorCode", this.errorCode);
            base.GetObjectData(info, context);
        }

        internal static string GetErrorMessage(int error, int errorCode, bool extracting)
        {
            const int FCI_ERROR_RESOURCE_OFFSET = 1000;
            const int FDI_ERROR_RESOURCE_OFFSET = 2000;
            int resourceOffset = (extracting ? FDI_ERROR_RESOURCE_OFFSET : FCI_ERROR_RESOURCE_OFFSET);

            string msg = CabException.ErrorResources.GetString(
                (resourceOffset + error).ToString(CultureInfo.InvariantCulture.NumberFormat),
                CultureInfo.CurrentCulture);

            if (msg == null)
            {
                msg = CabException.ErrorResources.GetString(
                    resourceOffset.ToString(CultureInfo.InvariantCulture.NumberFormat),
                    CultureInfo.CurrentCulture);
            }

            if (errorCode != 0)
            {
                const string GENERIC_ERROR_RESOURCE = "1";
                string msg2 = CabException.ErrorResources.GetString(GENERIC_ERROR_RESOURCE, CultureInfo.CurrentCulture);
                msg = String.Format(CultureInfo.InvariantCulture, "{0} " + msg2, msg, errorCode);
            }
            return msg;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup2\Compression.Cab\CabFileInfo.cs ===
//---------------------------------------------------------------------
// <copyright file="CabFileInfo.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Cab
{
    using System;
    using System.IO;
    using System.Runtime.Serialization;
    using System.Security.Permissions;

    /// <summary>
    /// Object representing a compressed file within a cabinet package; provides operations for getting
    /// the file properties and extracting the file.
    /// </summary>
    [Serializable]
    public class CabFileInfo : ArchiveFileInfo
    {
        private int cabFolder;

        /// <summary>
        /// Creates a new CabinetFileInfo object representing a file within a cabinet in a specified path.
        /// </summary>
        /// <param name="cabinetInfo">An object representing the cabinet containing the file.</param>
        /// <param name="filePath">The path to the file within the cabinet. Usually, this is a simple file
        /// name, but if the cabinet contains a directory structure this may include the directory.</param>
        public CabFileInfo(CabInfo cabinetInfo, string filePath)
            : base(cabinetInfo, filePath)
        {
            if (cabinetInfo == null)
            {
                throw new ArgumentNullException("cabinetInfo");
            }

            this.cabFolder = -1;
        }

        /// <summary>
        /// Creates a new CabinetFileInfo object with all parameters specified,
        /// used internally when reading the metadata out of a cab.
        /// </summary>
        /// <param name="filePath">The internal path and name of the file in the cab.</param>
        /// <param name="cabFolder">The folder number containing the file.</param>
        /// <param name="cabNumber">The cabinet number where the file starts.</param>
        /// <param name="attributes">The stored attributes of the file.</param>
        /// <param name="lastWriteTime">The stored last write time of the file.</param>
        /// <param name="length">The uncompressed size of the file.</param>
        internal CabFileInfo(
            string filePath,
            int cabFolder,
            int cabNumber,
            FileAttributes attributes,
            DateTime lastWriteTime,
            long length)
            : base(filePath, cabNumber, attributes, lastWriteTime, length)
        {
            this.cabFolder = cabFolder;
        }

        /// <summary>
        /// Initializes a new instance of the CabinetFileInfo class with serialized data.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The StreamingContext that contains contextual information about the source or destination.</param>
        protected CabFileInfo(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
            this.cabFolder = info.GetInt32("cabFolder");
        }

        /// <summary>
        /// Sets the SerializationInfo with information about the archive.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized object data.</param>
        /// <param name="context">The StreamingContext that contains contextual information
        /// about the source or destination.</param>
        [SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
        public override void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            base.GetObjectData(info, context);
            info.AddValue("cabFolder", this.cabFolder);
        }

        /// <summary>
        /// Gets or sets the cabinet that contains this file.
        /// </summary>
        /// <value>
        /// The CabinetInfo instance that retrieved this file information -- this
        /// may be null if the CabinetFileInfo object was returned directly from a
        /// stream.
        /// </value>
        public CabInfo Cabinet
        {
            get
            {
                return (CabInfo) this.Archive;
            }
        }

        /// <summary>
        /// Gets the full path of the cabinet that contains this file.
        /// </summary>
        /// <value>The full path of the cabinet that contains this file.</value>
        public string CabinetName
        {
            get
            {
                return this.ArchiveName;
            }
        }

        /// <summary>
        /// Gets the number of the folder containing this file.
        /// </summary>
        /// <value>The number of the cabinet folder containing this file.</value>
        /// <remarks>A single folder or the first folder of a cabinet
        /// (or chain of cabinets) is numbered 0.</remarks>
        public int CabinetFolderNumber
        {
            get
            {
                if (this.cabFolder < 0)
                {
                    this.Refresh();
                }
                return this.cabFolder;
            }
        }

        /// <summary>
        /// Refreshes the information in this object with new data retrieved
        /// from an archive.
        /// </summary>
        /// <param name="newFileInfo">Fresh instance for the same file just
        /// read from the archive.</param>
        /// <remarks>
        /// This implementation refreshes the <see cref="CabinetFolderNumber"/>.
        /// </remarks>
        protected override void Refresh(ArchiveFileInfo newFileInfo)
        {
            base.Refresh(newFileInfo);
            this.cabFolder = ((CabFileInfo) newFileInfo).cabFolder;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup2\Compression\ArchiveFileInfo.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ArchiveFileInfo.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
    using System;
    using System.IO;
    using System.Security.Permissions;
    using System.Runtime.Serialization;
    using System.Diagnostics.CodeAnalysis;

    /// <summary>
    /// Abstract object representing a compressed file within an archive;
    /// provides operations for getting the file properties and unpacking
    /// the file.
    /// </summary>
    [Serializable]
    public abstract class ArchiveFileInfo : FileSystemInfo
    {
        private ArchiveInfo archiveInfo;
        private string name;
        private string path;

        private bool initialized;
        private bool exists;
        private int archiveNumber;
        private FileAttributes attributes;
        private DateTime lastWriteTime;
        private long length;

        /// <summary>
        /// Creates a new ArchiveFileInfo object representing a file within
        /// an archive in a specified path.
        /// </summary>
        /// <param name="archiveInfo">An object representing the archive
        /// containing the file.</param>
        /// <param name="filePath">The path to the file within the archive.
        /// Usually, this is a simple file name, but if the archive contains
        /// a directory structure this may include the directory.</param>
        protected ArchiveFileInfo(ArchiveInfo archiveInfo, string filePath)
            : base()
        {
            if (filePath == null)
            {
                throw new ArgumentNullException("filePath");
            }

            this.Archive = archiveInfo;

            this.name = System.IO.Path.GetFileName(filePath);
            this.path = System.IO.Path.GetDirectoryName(filePath);

            this.attributes = FileAttributes.Normal;
            this.lastWriteTime = DateTime.MinValue;
        }

        /// <summary>
        /// Creates a new ArchiveFileInfo object with all parameters specified;
        /// used by subclasses when reading the metadata out of an archive.
        /// </summary>
        /// <param name="filePath">The internal path and name of the file in
        /// the archive.</param>
        /// <param name="archiveNumber">The archive number where the file
        /// starts.</param>
        /// <param name="attributes">The stored attributes of the file.</param>
        /// <param name="lastWriteTime">The stored last write time of the
        /// file.</param>
        /// <param name="length">The uncompressed size of the file.</param>
        protected ArchiveFileInfo(
            string filePath,
            int archiveNumber,
            FileAttributes attributes,
            DateTime lastWriteTime,
            long length)
            : this(null, filePath)
        {
            this.exists = true;
            this.archiveNumber = archiveNumber;
            this.attributes = attributes;
            this.lastWriteTime = lastWriteTime;
            this.length = length;
            this.initialized = true;
        }

        /// <summary>
        /// Initializes a new instance of the ArchiveFileInfo class with
        /// serialized data.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized
        /// object data about the exception being thrown.</param>
        /// <param name="context">The StreamingContext that contains contextual
        /// information about the source or destination.</param>
        protected ArchiveFileInfo(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
            this.archiveInfo = (ArchiveInfo) info.GetValue(
                "archiveInfo", typeof(ArchiveInfo));
            this.name = info.GetString("name");
            this.path = info.GetString("path");
            this.initialized = info.GetBoolean("initialized");
            this.exists = info.GetBoolean("exists");
            this.archiveNumber = info.GetInt32("archiveNumber");
            this.attributes = (FileAttributes) info.GetValue(
                "attributes", typeof(FileAttributes));
            this.lastWriteTime = info.GetDateTime("lastWriteTime");
            this.length = info.GetInt64("length");
        }

        /// <summary>
        /// Gets the name of the file.
        /// </summary>
        /// <value>The name of the file, not including any path.</value>
        public override string Name
        {
            get
            {
                return this.name;
            }
        }

        /// <summary>
        /// Gets the internal path of the file in the archive.
        /// </summary>
        /// <value>The internal path of the file in the archive, not including
        /// the file name.</value>
        public string Path
        {
            get
            {
                return this.path;
            }
        }

        /// <summary>
        /// Gets the full path to the file.
        /// </summary>
        /// <value>The full path to the file, including the full path to the
        /// archive, the internal path in the archive, and the file name.</value>
        /// <remarks>
        /// For example, the path <c>"C:\archive.cab\file.txt"</c> refers to
        /// a file "file.txt" inside the archive "archive.cab".
        /// </remarks>
        public override string FullName
        {
            get
            {
                string fullName = System.IO.Path.Combine(this.Path, this.Name);
                
                if (this.Archive != null)
                {
                    fullName = System.IO.Path.Combine(this.ArchiveName, fullName);
                }

                return fullName;
            }
        }

        /// <summary>
        /// Gets or sets the archive that contains this file.
        /// </summary>
        /// <value>
        /// The ArchiveInfo instance that retrieved this file information -- this
        /// may be null if the ArchiveFileInfo object was returned directly from
        /// a stream.
        /// </value>
        public ArchiveInfo Archive
        {
            get
            {
                return (ArchiveInfo) this.archiveInfo;
            }

            internal set
            {
                this.archiveInfo = value;

                // protected instance members inherited from FileSystemInfo:
                this.OriginalPath = (value != null ? value.FullName : null);
                this.FullPath = this.OriginalPath;
            }
        }

        /// <summary>
        /// Gets the full path of the archive that contains this file.
        /// </summary>
        /// <value>The full path of the archive that contains this file.</value>
        public string ArchiveName
        {
            get
            {
                return this.Archive != null ? this.Archive.FullName : null;
            }
        }

        /// <summary>
        /// Gets the number of the archive where this file starts.
        /// </summary>
        /// <value>The number of the archive where this file starts.</value>
        /// <remarks>A single archive or the first archive in a chain is
        /// numbered 0.</remarks>
        public int ArchiveNumber
        {
            get
            {
                return this.archiveNumber;
            }
        }

        /// <summary>
        /// Checks if the file exists within the archive.
        /// </summary>
        /// <value>True if the file exists, false otherwise.</value>
        public override bool Exists
        {
            get
            {
                if (!this.initialized)
                {
                    this.Refresh();
                }

                return this.exists;
            }
        }

        /// <summary>
        /// Gets the uncompressed size of the file.
        /// </summary>
        /// <value>The uncompressed size of the file in bytes.</value>
        public long Length
        {
            get
            {
                if (!this.initialized)
                {
                    this.Refresh();
                }

                return this.length;
            }
        }

        /// <summary>
        /// Gets the attributes of the file.
        /// </summary>
        /// <value>The attributes of the file as stored in the archive.</value>
        public new FileAttributes Attributes
        {
            get
            {
                if (!this.initialized)
                {
                    this.Refresh();
                }

                return this.attributes;
            }
        }

        /// <summary>
        /// Gets the last modification time of the file.
        /// </summary>
        /// <value>The last modification time of the file as stored in the
        /// archive.</value>
        public new DateTime LastWriteTime
        {
            get
            {
                if (!this.initialized)
                {
                    this.Refresh();
                }

                return this.lastWriteTime;
            }
        }

        /// <summary>
        /// Sets the SerializationInfo with information about the archive.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized
        /// object data.</param>
        /// <param name="context">The StreamingContext that contains contextual
        /// information about the source or destination.</param>
        [SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
        public override void GetObjectData(
            SerializationInfo info, StreamingContext context)
        {
            base.GetObjectData(info, context);
            info.AddValue("archiveInfo", this.archiveInfo);
            info.AddValue("name", this.name);
            info.AddValue("path", this.path);
            info.AddValue("initialized", this.initialized);
            info.AddValue("exists", this.exists);
            info.AddValue("archiveNumber", this.archiveNumber);
            info.AddValue("attributes", this.attributes);
            info.AddValue("lastWriteTime", this.lastWriteTime);
            info.AddValue("length", this.length);
        }

        /// <summary>
        /// Gets the full path to the file.
        /// </summary>
        /// <returns>The same as <see cref="FullName"/></returns>
        public override string ToString()
        {
            return this.FullName;
        }

        /// <summary>
        /// Deletes the file. NOT SUPPORTED.
        /// </summary>
        /// <exception cref="NotSupportedException">Files cannot be deleted
        /// from an existing archive.</exception>
        public override void Delete()
        {
            throw new NotSupportedException();
        }

        /// <summary>
        /// Refreshes the attributes and other cached information about the file,
        /// by re-reading the information from the archive.
        /// </summary>
        public new void Refresh()
        {
            base.Refresh();

            if (this.Archive != null)
            {
                string filePath = System.IO.Path.Combine(this.Path, this.Name);
                ArchiveFileInfo updatedFile = this.Archive.GetFile(filePath);
                if (updatedFile == null)
                {
                    throw new FileNotFoundException(
                            "File not found in archive.", filePath);
                }

                this.Refresh(updatedFile);
            }
        }

        /// <summary>
        /// Extracts the file.
        /// </summary>
        /// <param name="destFileName">The destination path where the file
        /// will be extracted.</param>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "dest")]
        public void CopyTo(string destFileName)
        {
            this.CopyTo(destFileName, false);
        }

        /// <summary>
        /// Extracts the file, optionally overwriting any existing file.
        /// </summary>
        /// <param name="destFileName">The destination path where the file
        /// will be extracted.</param>
        /// <param name="overwrite">If true, <paramref name="destFileName"/>
        /// will be overwritten if it exists.</param>
        /// <exception cref="IOException"><paramref name="overwrite"/> is false
        /// and <paramref name="destFileName"/> exists.</exception>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "dest")]
        public void CopyTo(string destFileName, bool overwrite)
        {
            if (destFileName == null)
            {
                throw new ArgumentNullException("destFileName");
            }

            if (!overwrite && File.Exists(destFileName))
            {
                throw new IOException();
            }

            if (this.Archive == null)
            {
                throw new InvalidOperationException();
            }

            this.Archive.UnpackFile(
                System.IO.Path.Combine(this.Path, this.Name), destFileName);
        }

        /// <summary>
        /// Refreshes the information in this object with new data retrieved
        /// from an archive.
        /// </summary>
        /// <param name="newFileInfo">Fresh instance for the same file just
        /// read from the archive.</param>
        /// <remarks>
        /// Subclasses may override this method to refresh sublcass fields.
        /// However they should always call the base implementation first.
        /// </remarks>
        protected virtual void Refresh(ArchiveFileInfo newFileInfo)
        {
            this.exists = newFileInfo.exists;
            this.length = newFileInfo.length;
            this.attributes = newFileInfo.attributes;
            this.lastWriteTime = newFileInfo.lastWriteTime;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup2\Compression.Cab\CabInfo.cs ===
//---------------------------------------------------------------------
// <copyright file="CabInfo.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Cab
{
    using System;
    using System.Collections.Generic;
    using System.Runtime.Serialization;

    /// <summary>
    /// Object representing a cabinet file on disk; provides access to
    /// file-based operations on the cabinet file.
    /// </summary>
    /// <remarks>
    /// Generally, the methods on this class are much easier to use than the
    /// stream-based interfaces provided by the <see cref="CabEngine"/> class.
    /// </remarks>
    [Serializable]
    public class CabInfo : ArchiveInfo
    {
        /// <summary>
        /// Creates a new CabinetInfo object representing a cabinet file in a specified path.
        /// </summary>
        /// <param name="path">The path to the cabinet file. When creating a cabinet file, this file does not
        /// necessarily exist yet.</param>
        public CabInfo(string path)
            : base(path)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CabinetInfo class with serialized data.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The StreamingContext that contains contextual information about the source or destination.</param>
        protected CabInfo(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }

        /// <summary>
        /// Creates a compression engine that does the low-level work for
        /// this object.
        /// </summary>
        /// <returns>A new <see cref="CabEngine"/> instance.</returns>
        /// <remarks>
        /// Each instance will be <see cref="CompressionEngine.Dispose()"/>d
        /// immediately after use.
        /// </remarks>
        protected override CompressionEngine CreateCompressionEngine()
        {
            return new CabEngine();
        }

        /// <summary>
        /// Gets information about the files contained in the archive.
        /// </summary>
        /// <returns>A list of <see cref="CabFileInfo"/> objects, each
        /// containing information about a file in the archive.</returns>
        public new IList<CabFileInfo> GetFiles()
        {
            IList<ArchiveFileInfo> files = base.GetFiles();
            List<CabFileInfo> cabFiles = new List<CabFileInfo>(files.Count);
            foreach (CabFileInfo cabFile in files) cabFiles.Add(cabFile);
            return cabFiles.AsReadOnly();
        }

        /// <summary>
        /// Gets information about the certain files contained in the archive file.
        /// </summary>
        /// <param name="searchPattern">The search string, such as
        /// &quot;*.txt&quot;.</param>
        /// <returns>A list of <see cref="CabFileInfo"/> objects, each containing
        /// information about a file in the archive.</returns>
        public new IList<CabFileInfo> GetFiles(string searchPattern)
        {
            IList<ArchiveFileInfo> files = base.GetFiles(searchPattern);
            List<CabFileInfo> cabFiles = new List<CabFileInfo>(files.Count);
            foreach (CabFileInfo cabFile in files) cabFiles.Add(cabFile);
            return cabFiles.AsReadOnly();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup2\Compression.Cab\HandleManager.cs ===
//---------------------------------------------------------------------
// <copyright file="HandleManager.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Cab
{
    using System;
    using System.Collections.Generic;

    /// <summary>
    /// Generic class for managing allocations of integer handles
    /// for objects of a certain type.
    /// </summary>
    /// <typeparam name="T">The type of objects the handles refer to.</typeparam>
    internal sealed class HandleManager<T> where T : class
    {
        /// <summary>
        /// Auto-resizing list of objects for which handles have been allocated.
        /// Each handle is just an index into this list. When a handle is freed,
        /// the list item at that index is set to null.
        /// </summary>
        private List<T> handles;

        /// <summary>
        /// Creates a new HandleManager instance.
        /// </summary>
        public HandleManager()
        {
            this.handles = new List<T>();
        }

        /// <summary>
        /// Gets the object of a handle, or null if the handle is invalid.
        /// </summary>
        /// <param name="handle">The integer handle previously allocated
        /// for the desired object.</param>
        /// <returns>The object for which the handle was allocated.</returns>
        public T this[int handle]
        {
            get
            {
                if (handle > 0 && handle <= this.handles.Count)
                {
                    return this.handles[handle - 1];
                }
                else
                {
                    return null;
                }
            }
        }

        /// <summary>
        /// Allocates a new handle for an object.
        /// </summary>
        /// <param name="obj">Object that the handle will refer to.</param>
        /// <returns>New handle that can be later used to retrieve the object.</returns>
        public int AllocHandle(T obj)
        {
            this.handles.Add(obj);
            int handle = this.handles.Count;
            return handle;
        }

        /// <summary>
        /// Frees a handle that was previously allocated. Afterward the handle
        /// will be invalid and the object it referred to can no longer retrieved.
        /// </summary>
        /// <param name="handle">Handle to be freed.</param>
        public void FreeHandle(int handle)
        {
            if (handle > 0 && handle <= this.handles.Count)
            {
                this.handles[handle - 1] = null;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup2\Compression.Zip\ConcatStream.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ConcatStream.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Zip
{
    using System;
    using System.IO;

    /// <summary>
    /// Used to trick a DeflateStream into reading from or writing to
    /// a series of (chunked) streams instead of a single steream.
    /// </summary>
    internal class ConcatStream : Stream
    {
        private Stream source;
        private long position;
        private long length;
        private Action<ConcatStream> nextStreamHandler;

        public ConcatStream(Action<ConcatStream> nextStreamHandler)
        {
            if (nextStreamHandler == null)
            {
                throw new ArgumentNullException("nextStreamHandler");
            }

            this.nextStreamHandler = nextStreamHandler;
            this.length = Int64.MaxValue;
        }

        public Stream Source
        {
            get { return this.source; }
            set { this.source = value; }
        }

        public override bool CanRead
        {
            get { return true; }
        }

        public override bool CanWrite
        {
            get { return true; }
        }

        public override bool CanSeek
        {
            get { return false; }
        }

        public override long Length
        {
            get
            {
                return this.length;
            }
        }

        public override long Position
        {
            get { return this.position; }
            set { throw new NotSupportedException(); }
        }

        public override int Read(byte[] buffer, int offset, int count)
        {
            if (this.source == null)
            {
                this.nextStreamHandler(this);
            }

            count = (int) Math.Min(count, this.length - this.position);

            int bytesRemaining = count;
            while (bytesRemaining > 0)
            {
                if (this.source == null)
                {
                    throw new InvalidOperationException();
                }

                int partialCount = (int) Math.Min(bytesRemaining,
                    this.source.Length - this.source.Position);

                if (partialCount == 0)
                {
                    this.nextStreamHandler(this);
                    continue;
                }

                partialCount = this.source.Read(
                    buffer, offset + count - bytesRemaining, partialCount);
                bytesRemaining -= partialCount;
                this.position += partialCount;
            }

            return count;
        }

        public override void Write(byte[] buffer, int offset, int count)
        {
            if (this.source == null)
            {
                this.nextStreamHandler(this);
            }

            int bytesRemaining = count;
            while (bytesRemaining > 0)
            {
                if (this.source == null)
                {
                    throw new InvalidOperationException();
                }

                int partialCount = (int) Math.Min(bytesRemaining,
                    Math.Max(0, this.length - this.source.Position));

                if (partialCount == 0)
                {
                    this.nextStreamHandler(this);
                    continue;
                }

                this.source.Write(
                    buffer, offset + count - bytesRemaining, partialCount);
                bytesRemaining -= partialCount;
                this.position += partialCount;
            }
        }

        public override void Flush()
        {
            if (this.source != null)
            {
                this.source.Flush();
            }
        }

        public override long Seek(long offset, SeekOrigin origin)
        {
            throw new NotSupportedException();
        }

        public override void SetLength(long value)
        {
            this.length = value;
        }

        public override void Close()
        {
            if (this.source != null)
            {
                this.source.Close();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup2\Compression\ArchiveProgressEventArgs.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ArchiveProgressEventArgs.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
using System;
using System.Collections.Generic;
using System.Text;

    /// <summary>
    /// Contains the data reported in an archive progress event.
    /// </summary>
    public class ArchiveProgressEventArgs : EventArgs
    {
        private ArchiveProgressType progressType;

        private string currentFileName;
        private int currentFileNumber;
        private int totalFiles;
        private long currentFileBytesProcessed;
        private long currentFileTotalBytes;

        private string currentArchiveName;
        private short currentArchiveNumber;
        private short totalArchives;
        private long currentArchiveBytesProcessed;
        private long currentArchiveTotalBytes;

        private long fileBytesProcessed;
        private long totalFileBytes;

        /// <summary>
        /// Creates a new ArchiveProgressEventArgs object from specified event parameters.
        /// </summary>
        /// <param name="progressType">type of status message</param>
        /// <param name="currentFileName">name of the file being processed</param>
        /// <param name="currentFileNumber">number of the current file being processed</param>
        /// <param name="totalFiles">total number of files to be processed</param>
        /// <param name="currentFileBytesProcessed">number of bytes processed so far when compressing or extracting a file</param>
        /// <param name="currentFileTotalBytes">total number of bytes in the current file</param>
        /// <param name="currentArchiveName">name of the current Archive</param>
        /// <param name="currentArchiveNumber">current Archive number, when processing a chained set of Archives</param>
        /// <param name="totalArchives">total number of Archives in a chained set</param>
        /// <param name="currentArchiveBytesProcessed">number of compressed bytes processed so far during an extraction</param>
        /// <param name="currentArchiveTotalBytes">total number of compressed bytes to be processed during an extraction</param>
        /// <param name="fileBytesProcessed">number of uncompressed file bytes processed so far</param>
        /// <param name="totalFileBytes">total number of uncompressed file bytes to be processed</param>
        public ArchiveProgressEventArgs(
            ArchiveProgressType progressType,
            string currentFileName,
            int currentFileNumber,
            int totalFiles,
            long currentFileBytesProcessed,
            long currentFileTotalBytes,
            string currentArchiveName,
            int currentArchiveNumber,
            int totalArchives,
            long currentArchiveBytesProcessed,
            long currentArchiveTotalBytes,
            long fileBytesProcessed,
            long totalFileBytes)
        {
            this.progressType = progressType;
            this.currentFileName = currentFileName;
            this.currentFileNumber = currentFileNumber;
            this.totalFiles = totalFiles;
            this.currentFileBytesProcessed = currentFileBytesProcessed;
            this.currentFileTotalBytes = currentFileTotalBytes;
            this.currentArchiveName = currentArchiveName;
            this.currentArchiveNumber = (short) currentArchiveNumber;
            this.totalArchives = (short) totalArchives;
            this.currentArchiveBytesProcessed = currentArchiveBytesProcessed;
            this.currentArchiveTotalBytes = currentArchiveTotalBytes;
            this.fileBytesProcessed = fileBytesProcessed;
            this.totalFileBytes = totalFileBytes;
        }

        /// <summary>
        /// Gets the type of status message.
        /// </summary>
        /// <value>A <see cref="ArchiveProgressType"/> value indicating what type of progress event occurred.</value>
        /// <remarks>
        /// The handler may choose to ignore some types of progress events.
        /// For example, if the handler will only list each file as it is
        /// compressed/extracted, it can ignore events that
        /// are not of type <see cref="ArchiveProgressType.FinishFile"/>.
        /// </remarks>
        public ArchiveProgressType ProgressType
        {
            get
            {
                return this.progressType;
            }
        }

        /// <summary>
        /// Gets the name of the file being processed. (The name of the file within the Archive; not the external
        /// file path.) Also includes the internal path of the file, if any.  Valid for
        /// <see cref="ArchiveProgressType.StartFile"/>, <see cref="ArchiveProgressType.PartialFile"/>,
        /// and <see cref="ArchiveProgressType.FinishFile"/> messages.
        /// </summary>
        /// <value>The name of the file currently being processed, or null if processing
        /// is currently at the stream or archive level.</value>
        public string CurrentFileName
        {
            get
            {
                return this.currentFileName;
            }
        }

        /// <summary>
        /// Gets the number of the current file being processed. The first file is number 0, and the last file
        /// is <see cref="TotalFiles"/>-1. Valid for <see cref="ArchiveProgressType.StartFile"/>,
        /// <see cref="ArchiveProgressType.PartialFile"/>, and <see cref="ArchiveProgressType.FinishFile"/> messages.
        /// </summary>
        /// <value>The number of the file currently being processed, or the most recent
        /// file processed if processing is currently at the stream or archive level.</value>
        public int CurrentFileNumber
        {
            get
            {
                return this.currentFileNumber;
            }
        }

        /// <summary>
        /// Gets the total number of files to be processed.  Valid for all message types.
        /// </summary>
        /// <value>The total number of files to be processed that are known so far.</value>
        public int TotalFiles
        {
            get
            {
                return this.totalFiles;
            }
        }

        /// <summary>
        /// Gets the number of bytes processed so far when compressing or extracting a file.  Valid for
        /// <see cref="ArchiveProgressType.StartFile"/>, <see cref="ArchiveProgressType.PartialFile"/>,
        /// and <see cref="ArchiveProgressType.FinishFile"/> messages.
        /// </summary>
        /// <value>The number of uncompressed bytes processed so far for the current file,
        /// or 0 if processing is currently at the stream or archive level.</value>
        public long CurrentFileBytesProcessed
        {
            get
            {
                return this.currentFileBytesProcessed;
            }
        }

        /// <summary>
        /// Gets the total number of bytes in the current file.  Valid for <see cref="ArchiveProgressType.StartFile"/>,
        /// <see cref="ArchiveProgressType.PartialFile"/>, and <see cref="ArchiveProgressType.FinishFile"/> messages.
        /// </summary>
        /// <value>The uncompressed size of the current file being processed,
        /// or 0 if processing is currently at the stream or archive level.</value>
        public long CurrentFileTotalBytes
        {
            get
            {
                return this.currentFileTotalBytes;
            }
        }

        /// <summary>
        /// Gets the name of the current archive.  Not necessarily the name of the archive on disk.
        /// Valid for all message types.
        /// </summary>
        /// <value>The name of the current archive, or an empty string if no name was specified.</value>
        public string CurrentArchiveName
        {
            get
            {
                return this.currentArchiveName;
            }
        }

        /// <summary>
        /// Gets the current archive number, when processing a chained set of archives. Valid for all message types.
        /// </summary>
        /// <value>The number of the current archive.</value>
        /// <remarks>The first archive is number 0, and the last archive is
        /// <see cref="TotalArchives"/>-1.</remarks>
        public int CurrentArchiveNumber
        {
            get
            {
                return this.currentArchiveNumber;
            }
        }

        /// <summary>
        /// Gets the total number of known archives in a chained set. Valid for all message types.
        /// </summary>
        /// <value>The total number of known archives in a chained set.</value>
        /// <remarks>
        /// When using the compression option to auto-split into multiple archives based on data size,
        /// this value will not be accurate until the end.
        /// </remarks>
        public int TotalArchives
        {
            get
            {
                return this.totalArchives;
            }
        }

        /// <summary>
        /// Gets the number of compressed bytes processed so far during extraction
        /// of the current archive. Valid for all extraction messages.
        /// </summary>
        /// <value>The number of compressed bytes processed so far during extraction
        /// of the current archive.</value>
        public long CurrentArchiveBytesProcessed
        {
            get
            {
                return this.currentArchiveBytesProcessed;
            }
        }

        /// <summary>
        /// Gets the total number of compressed bytes to be processed during extraction
        /// of the current archive. Valid for all extraction messages.
        /// </summary>
        /// <value>The total number of compressed bytes to be processed during extraction
        /// of the current archive.</value>
        public long CurrentArchiveTotalBytes
        {
            get
            {
                return this.currentArchiveTotalBytes;
            }
        }

        /// <summary>
        /// Gets the number of uncompressed bytes processed so far among all files. Valid for all message types.  
        /// </summary>
        /// <value>The number of uncompressed file bytes processed so far among all files.</value>
        /// <remarks>
        /// When compared to <see cref="TotalFileBytes"/>, this can be used as a measure of overall progress.
        /// </remarks>
        public long FileBytesProcessed
        {
            get
            {
                return this.fileBytesProcessed;
            }
        }

        /// <summary>
        /// Gets the total number of uncompressed file bytes to be processed.  Valid for all message types.
        /// </summary>
        /// <value>The total number of uncompressed bytes to be processed among all files.</value>
        public long TotalFileBytes
        {
            get
            {
                return this.totalFileBytes;
            }
        }

#if DEBUG

    /// <summary>
    /// Creates a string representation of the progress event.
    /// </summary>
    /// <returns>a listing of all event parameters and values</returns>
    public override string ToString()
    {
        string formatString =
            "{0}\n" +
            "\t CurrentFileName              = {1}\n" +
            "\t CurrentFileNumber            = {2}\n" +
            "\t TotalFiles                   = {3}\n" +
            "\t CurrentFileBytesProcessed    = {4}\n" +
            "\t CurrentFileTotalBytes        = {5}\n" +
            "\t CurrentArchiveName           = {6}\n" +
            "\t CurrentArchiveNumber         = {7}\n" +
            "\t TotalArchives                = {8}\n" +
            "\t CurrentArchiveBytesProcessed = {9}\n" +
            "\t CurrentArchiveTotalBytes     = {10}\n" +
            "\t FileBytesProcessed           = {11}\n" +
            "\t TotalFileBytes               = {12}\n";
        return String.Format(
            System.Globalization.CultureInfo.InvariantCulture,
            formatString,
            this.ProgressType,
            this.CurrentFileName,
            this.CurrentFileNumber,
            this.TotalFiles,
            this.CurrentFileBytesProcessed,
            this.CurrentFileTotalBytes,
            this.CurrentArchiveName,
            this.CurrentArchiveNumber,
            this.TotalArchives,
            this.CurrentArchiveBytesProcessed,
            this.CurrentArchiveTotalBytes,
            this.FileBytesProcessed,
            this.TotalFileBytes);
    }

#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup2\Compression.Zip\ZipCompressionMethod.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ZipCompressionMethod.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Zip
{
    using System.Diagnostics.CodeAnalysis;

    /// <summary>
    /// Identifies the compression method or &quot;algorithm&quot;
    /// used for a single file within a zip archive.
    /// </summary>
    /// <remarks>
    /// Proprietary zip implementations may define additional compression
    /// methods outside of those included here.
    /// </remarks>
    public enum ZipCompressionMethod
    {
        /// <summary>
        /// The file is stored (no compression)
        /// </summary>
        Store = 0,
        
        /// <summary>
        /// The file is Shrunk
        /// </summary>
        Shrink = 1,
        
        /// <summary>
        /// The file is Reduced with compression factor 1
        /// </summary>
        Reduce1 = 2,

        /// <summary>
        /// The file is Reduced with compression factor 2
        /// </summary>
        Reduce2 = 3,

        /// <summary>
        /// The file is Reduced with compression factor 3
        /// </summary>
        Reduce3 = 4,

        /// <summary>
        /// The file is Reduced with compression factor 4
        /// </summary>
        Reduce4 = 5,
        
        /// <summary>
        /// The file is Imploded
        /// </summary>
        Implode = 6,
        
        /// <summary>
        /// The file is Deflated;
        /// the most common and widely-compatible form of zip compression.
        /// </summary>
        Deflate = 8,
        
        /// <summary>
        /// The file is Deflated using the enhanced Deflate64 method.
        /// </summary>
        Deflate64 = 9,

        /// <summary>
        /// The file is compressed using the BZIP2 algorithm.
        /// </summary>
        BZip2 = 12,

        /// <summary>
        /// The file is compressed using the LZMA algorithm.
        /// </summary>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Lzma")]
        Lzma = 14,

        /// <summary>
        /// The file is compressed using the PPMd algorithm.
        /// </summary>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Ppmd")]
        Ppmd = 98
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup2\Compression.Cab\CabWorker.cs ===
//---------------------------------------------------------------------
// <copyright file="CabWorker.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Cab
{
    using System;
    using System.IO;
    using System.IO.IsolatedStorage;
    using System.Text;
    using System.Security;
    using System.Collections.Generic;
    using System.Runtime.InteropServices;
    using System.Diagnostics.CodeAnalysis;

    internal abstract class CabWorker : IDisposable
    {
        internal const string CabStreamName = "%%CAB%%";

        private CabEngine cabEngine;

        private HandleManager<Stream> streamHandles;
        private Stream cabStream;
        private Stream fileStream;

        private NativeMethods.ERF erf;
        private GCHandle erfHandle;

        private IDictionary<string, short> cabNumbers;
        private string nextCabinetName;

        private bool suppressProgressEvents;

        private byte[] buf;

        // Progress data
        protected string currentFileName;
        protected int    currentFileNumber;
        protected int    totalFiles;
        protected long   currentFileBytesProcessed;
        protected long   currentFileTotalBytes;
        protected short  currentFolderNumber;
        protected long   currentFolderTotalBytes;
        protected string currentArchiveName;
        protected short  currentArchiveNumber;
        protected short  totalArchives;
        protected long   currentArchiveBytesProcessed;
        protected long   currentArchiveTotalBytes;
        protected long   fileBytesProcessed;
        protected long   totalFileBytes;

        [SuppressMessage("Microsoft.Security", "CA2122:DoNotIndirectlyExposeMethodsWithLinkDemands")]
        protected CabWorker(CabEngine cabEngine)
        {
            this.cabEngine = cabEngine;
            this.streamHandles = new HandleManager<Stream>();
            this.erf = new NativeMethods.ERF();
            this.erfHandle = GCHandle.Alloc(this.erf, GCHandleType.Pinned);
            this.cabNumbers = new Dictionary<string, short>(1);

            // 32K seems to be the size of the largest chunks processed by cabinet.dll.
            // But just in case, this buffer will auto-enlarge.
            this.buf = new byte[32768];
        }

        ~CabWorker()
        {
            this.Dispose(false);
        }

        public CabEngine CabEngine
        {
            get
            {
                return this.cabEngine;
            }
        }

        internal NativeMethods.ERF Erf
        {
            get
            {
                return this.erf;
            }
        }

        internal GCHandle ErfHandle
        {
            get
            {
                return this.erfHandle;
            }
        }

        internal HandleManager<Stream> StreamHandles
        {
            get
            {
                return this.streamHandles;
            }
        }

        internal bool SuppressProgressEvents
        {
            get
            {
                return this.suppressProgressEvents;
            }

            set
            {
                this.suppressProgressEvents = value;
            }
        }

        internal IDictionary<string, short> CabNumbers
        {
            get
            {
                return this.cabNumbers;
            }
        }

        internal string NextCabinetName
        {
            get
            {
                return this.nextCabinetName;
            }

            set
            {
                this.nextCabinetName = value;
            }
        }

        internal Stream CabStream
        {
            get
            {
                return this.cabStream;
            }

            set
            {
                this.cabStream = value;
            }
        }

        internal Stream FileStream
        {
            get
            {
                return this.fileStream;
            }

            set
            {
                this.fileStream = value;
            }
        }

        public void Dispose() 
        {
            this.Dispose(true);
            GC.SuppressFinalize(this); 
        }

        protected void ResetProgressData()
        {
            this.currentFileName = null;
            this.currentFileNumber = 0;
            this.totalFiles = 0;
            this.currentFileBytesProcessed = 0;
            this.currentFileTotalBytes = 0;
            this.currentFolderNumber = 0;
            this.currentFolderTotalBytes = 0;
            this.currentArchiveName = null;
            this.currentArchiveNumber = 0;
            this.totalArchives = 0;
            this.currentArchiveBytesProcessed = 0;
            this.currentArchiveTotalBytes = 0;
            this.fileBytesProcessed = 0;
            this.totalFileBytes = 0;
        }

        protected void OnProgress(ArchiveProgressType progressType)
        {
            if (!this.suppressProgressEvents)
            {
                ArchiveProgressEventArgs e = new ArchiveProgressEventArgs(
                    progressType,
                    this.currentFileName,
                    this.currentFileNumber >= 0 ? this.currentFileNumber : 0,
                    this.totalFiles,
                    this.currentFileBytesProcessed,
                    this.currentFileTotalBytes,
                    this.currentArchiveName,
                    this.currentArchiveNumber,
                    this.totalArchives,
                    this.currentArchiveBytesProcessed,
                    this.currentArchiveTotalBytes,
                    this.fileBytesProcessed,
                    this.totalFileBytes);
                this.CabEngine.ReportProgress(e);
            }
        }

        internal IntPtr CabAllocMem(int byteCount)
        {
            IntPtr memPointer = Marshal.AllocHGlobal((IntPtr) byteCount);
            return memPointer;
        }

        internal void CabFreeMem(IntPtr memPointer)
        {
            Marshal.FreeHGlobal(memPointer);
        }

        internal int CabOpenStream(string path, int openFlags, int shareMode)
        {
            int err; return this.CabOpenStreamEx(path, openFlags, shareMode, out err, IntPtr.Zero);
        }

        internal virtual int CabOpenStreamEx(string path, int openFlags, int shareMode, out int err, IntPtr pv)
        {
            path = path.Trim();
            Stream stream = this.cabStream;
            this.cabStream = new DuplicateStream(stream);
            int streamHandle = this.streamHandles.AllocHandle(stream);
            err = 0;
            return streamHandle;
        }

        internal int CabReadStream(int streamHandle, IntPtr memory, int cb)
        {
            int err; return this.CabReadStreamEx(streamHandle, memory, cb, out err, IntPtr.Zero);
        }

        internal virtual int CabReadStreamEx(int streamHandle, IntPtr memory, int cb, out int err, IntPtr pv)
        {
            Stream stream = this.streamHandles[streamHandle];
            int count = (int) cb;
            if (count > this.buf.Length)
            {
                this.buf = new byte[count];
            }
            count = stream.Read(this.buf, 0, count);
            Marshal.Copy(this.buf, 0, memory, count);
            err = 0;
            return count;
        }

        internal int CabWriteStream(int streamHandle, IntPtr memory, int cb)
        {
            int err; return this.CabWriteStreamEx(streamHandle, memory, cb, out err, IntPtr.Zero);
        }

        internal virtual int CabWriteStreamEx(int streamHandle, IntPtr memory, int cb, out int err, IntPtr pv)
        {
            Stream stream = this.streamHandles[streamHandle];
            int count = (int) cb;
            if (count > this.buf.Length)
            {
                this.buf = new byte[count];
            }
            Marshal.Copy(memory, this.buf, 0, count);
            stream.Write(this.buf, 0, count);
            err = 0;
            return cb;
        }

        internal int CabCloseStream(int streamHandle)
        {
            int err; return this.CabCloseStreamEx(streamHandle, out err, IntPtr.Zero);
        }

        internal virtual int CabCloseStreamEx(int streamHandle, out int err, IntPtr pv)
        {
            this.streamHandles.FreeHandle(streamHandle);
            err = 0;
            return 0;
        }

        internal int CabSeekStream(int streamHandle, int offset, int seekOrigin)
        {
            int err; return this.CabSeekStreamEx(streamHandle, offset, seekOrigin, out err, IntPtr.Zero);
        }

        internal virtual int CabSeekStreamEx(int streamHandle, int offset, int seekOrigin, out int err, IntPtr pv)
        {
            Stream stream = this.streamHandles[streamHandle];
            offset = (int) stream.Seek(offset, (SeekOrigin) seekOrigin);
            err = 0;
            return offset;
        }

        /// <summary>
        /// Disposes of resources allocated by the cabinet engine.
        /// </summary>
        /// <param name="disposing">If true, the method has been called directly or indirectly by a user's code,
        /// so managed and unmanaged resources will be disposed. If false, the method has been called by the 
        /// runtime from inside the finalizer, and only unmanaged resources will be disposed.</param>
        [SuppressMessage("Microsoft.Security", "CA2122:DoNotIndirectlyExposeMethodsWithLinkDemands")]
        protected virtual void Dispose(bool disposing) 
        {
            if (disposing) 
            {
                if (this.cabStream != null)
                {
                    this.cabStream.Close();
                    this.cabStream = null;
                }

                if (this.fileStream != null)
                {
                    this.fileStream.Close();
                    this.fileStream = null;
                }
            }

            if (this.erfHandle.IsAllocated)
            {
                this.erfHandle.Free();
            }
        }

        protected void CheckError(bool extracting)
        {
            if (this.Erf.Error)
            {
                throw new CabException(
                    this.Erf.Oper,
                    this.Erf.Type,
                    CabException.GetErrorMessage(this.Erf.Oper, this.Erf.Type, extracting));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup2\Compression.Cab\CabPacker.cs ===
//---------------------------------------------------------------------
// <copyright file="CabPacker.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Cab
{
    using System;
    using System.IO;
    using System.Text;
    using System.Security.Permissions;
    using System.Collections.Generic;
    using System.Globalization;
    using System.Runtime.InteropServices;
    using System.Diagnostics.CodeAnalysis;

    internal class CabPacker : CabWorker
    {
        private const string TempStreamName = "%%TEMP%%";

        private NativeMethods.FCI.Handle fciHandle;

        // These delegates need to be saved as member variables
        // so that they don't get GC'd.
        private NativeMethods.FCI.PFNALLOC fciAllocMemHandler;
        private NativeMethods.FCI.PFNFREE fciFreeMemHandler;
        private NativeMethods.FCI.PFNOPEN fciOpenStreamHandler;
        private NativeMethods.FCI.PFNREAD fciReadStreamHandler;
        private NativeMethods.FCI.PFNWRITE fciWriteStreamHandler;
        private NativeMethods.FCI.PFNCLOSE fciCloseStreamHandler;
        private NativeMethods.FCI.PFNSEEK fciSeekStreamHandler;
        private NativeMethods.FCI.PFNFILEPLACED fciFilePlacedHandler;
        private NativeMethods.FCI.PFNDELETE fciDeleteFileHandler;
        private NativeMethods.FCI.PFNGETTEMPFILE fciGetTempFileHandler;

        private NativeMethods.FCI.PFNGETNEXTCABINET fciGetNextCabinet;
        private NativeMethods.FCI.PFNSTATUS fciCreateStatus;
        private NativeMethods.FCI.PFNGETOPENINFO fciGetOpenInfo;

        private IPackStreamContext context;

        private FileAttributes fileAttributes;
        private DateTime fileLastWriteTime;

        private int maxCabBytes;

        private long totalFolderBytesProcessedInCurrentCab;

        private CompressionLevel compressionLevel;
        private bool dontUseTempFiles;
        private IList<Stream> tempStreams;

        public CabPacker(CabEngine cabEngine)
            : base(cabEngine)
        {
            this.fciAllocMemHandler    = this.CabAllocMem;
            this.fciFreeMemHandler     = this.CabFreeMem;
            this.fciOpenStreamHandler  = this.CabOpenStreamEx;
            this.fciReadStreamHandler  = this.CabReadStreamEx;
            this.fciWriteStreamHandler = this.CabWriteStreamEx;
            this.fciCloseStreamHandler = this.CabCloseStreamEx;
            this.fciSeekStreamHandler  = this.CabSeekStreamEx;
            this.fciFilePlacedHandler  = this.CabFilePlaced;
            this.fciDeleteFileHandler  = this.CabDeleteFile;
            this.fciGetTempFileHandler = this.CabGetTempFile;
            this.fciGetNextCabinet     = this.CabGetNextCabinet;
            this.fciCreateStatus       = this.CabCreateStatus;
            this.fciGetOpenInfo        = this.CabGetOpenInfo;
            this.tempStreams = new List<Stream>();
            this.compressionLevel = CompressionLevel.Normal;
        }

        public bool UseTempFiles
        {
            get
            {
                return !this.dontUseTempFiles;
            }

            set
            {
                this.dontUseTempFiles = !value;
            }
        }

        public CompressionLevel CompressionLevel
        {
            get
            {
                return this.compressionLevel;
            }

            set
            {
                this.compressionLevel = value;
            }
        }

        [SuppressMessage("Microsoft.Security", "CA2122:DoNotIndirectlyExposeMethodsWithLinkDemands")]
        private void CreateFci(long maxArchiveSize)
        {
            NativeMethods.FCI.CCAB ccab = new NativeMethods.FCI.CCAB();
            if (maxArchiveSize > 0 && maxArchiveSize < ccab.cb)
            {
                ccab.cb = Math.Max(
                    NativeMethods.FCI.MIN_DISK, (int) maxArchiveSize);
            }

            object maxFolderSizeOption = this.context.GetOption(
                "maxFolderSize", null);
            if (maxFolderSizeOption != null)
            {
                long maxFolderSize = Convert.ToInt64(
                    maxFolderSizeOption, CultureInfo.InvariantCulture);
                if (maxFolderSize > 0 && maxFolderSize < ccab.cbFolderThresh)
                {
                    ccab.cbFolderThresh = (int) maxFolderSize;
                }
            }

            this.maxCabBytes = ccab.cb;
            ccab.szCab = this.context.GetArchiveName(0);
            if (ccab.szCab == null)
            {
                throw new FileNotFoundException(
                    "Cabinet name not provided by stream context.");
            }
            ccab.setID = (short) new Random().Next(
                Int16.MinValue, Int16.MaxValue + 1);
            this.CabNumbers[ccab.szCab] = 0;
            this.currentArchiveName = ccab.szCab;
            this.totalArchives = 1;
            this.CabStream = null;

            this.Erf.Clear();
            this.fciHandle = NativeMethods.FCI.Create(
                this.ErfHandle.AddrOfPinnedObject(),
                this.fciFilePlacedHandler,
                this.fciAllocMemHandler,
                this.fciFreeMemHandler,
                this.fciOpenStreamHandler,
                this.fciReadStreamHandler,
                this.fciWriteStreamHandler,
                this.fciCloseStreamHandler,
                this.fciSeekStreamHandler,
                this.fciDeleteFileHandler,
                this.fciGetTempFileHandler,
                ccab,
                IntPtr.Zero);
            this.CheckError(false);
        }

        [SuppressMessage("Microsoft.Security", "CA2106:SecureAsserts")]
        [SuppressMessage("Microsoft.Security", "CA2122:DoNotIndirectlyExposeMethodsWithLinkDemands")]
        [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
        public void Pack(
            IPackStreamContext streamContext,
            IEnumerable<string> files,
            long maxArchiveSize)
        {
            if (streamContext == null)
            {
                throw new ArgumentNullException("streamContext");
            }

            if (files == null)
            {
                throw new ArgumentNullException("files");
            }

            lock (this)
            {
                try
                {
                    this.context = streamContext;

                    this.ResetProgressData();

                    this.CreateFci(maxArchiveSize);

                    foreach (string file in files)
                    {
                        FileAttributes attributes;
                        DateTime lastWriteTime;
                        Stream fileStream = this.context.OpenFileReadStream(
                            file,
                            out attributes,
                            out lastWriteTime);
                        if (fileStream != null)
                        {
                            this.totalFileBytes += fileStream.Length;
                            this.totalFiles++;
                            this.context.CloseFileReadStream(file, fileStream);
                        }
                    }

                    long uncompressedBytesInFolder = 0;
                    this.currentFileNumber = -1;

                    foreach (string file in files)
                    {
                        FileAttributes attributes;
                        DateTime lastWriteTime;
                        Stream fileStream = this.context.OpenFileReadStream(
                            file, out attributes, out lastWriteTime);
                        if (fileStream == null)
                        {
                            continue;
                        }

                        if (fileStream.Length >= (long) NativeMethods.FCI.MAX_FOLDER)
                        {
                            throw new NotSupportedException(String.Format(
                                CultureInfo.InvariantCulture,
                                "File {0} exceeds maximum file size " +
                                "for cabinet format.",
                                file));
                        }

                        if (uncompressedBytesInFolder > 0)
                        {
                            // Automatically create a new folder if this file
                            // won't fit in the current folder.
                            bool nextFolder = uncompressedBytesInFolder
                                + fileStream.Length >= (long) NativeMethods.FCI.MAX_FOLDER;

                            // Otherwise ask the client if it wants to
                            // move to the next folder.
                            if (!nextFolder)
                            {
                                object nextFolderOption = streamContext.GetOption(
                                    "nextFolder",
                                    new object[] { file, this.currentFolderNumber });
                                nextFolder = Convert.ToBoolean(
                                    nextFolderOption, CultureInfo.InvariantCulture);
                            }

                            if (nextFolder)
                            {
                                this.FlushFolder();
                                uncompressedBytesInFolder = 0;
                            }
                        }

                        if (this.currentFolderTotalBytes > 0)
                        {
                            this.currentFolderTotalBytes = 0;
                            this.currentFolderNumber++;
                            uncompressedBytesInFolder = 0;
                        }

                        this.currentFileName = file;
                        this.currentFileNumber++;

                        this.currentFileTotalBytes = fileStream.Length;
                        this.currentFileBytesProcessed = 0;
                        this.OnProgress(ArchiveProgressType.StartFile);

                        uncompressedBytesInFolder += fileStream.Length;

                        this.AddFile(
                            file,
                            fileStream,
                            attributes,
                            lastWriteTime,
                            false,
                            this.CompressionLevel);
                    }

                    this.FlushFolder();
                    this.FlushCabinet();
                }
                finally
                {
                    if (this.CabStream != null)
                    {
                        this.context.CloseArchiveWriteStream(
                            this.currentArchiveNumber,
                            this.currentArchiveName,
                            this.CabStream);
                        this.CabStream = null;
                    }

                    if (this.FileStream != null)
                    {
                        this.context.CloseFileReadStream(
                            this.currentFileName, this.FileStream);
                        this.FileStream = null;
                    }
                    this.context = null;

                    if (this.fciHandle != null)
                    {
                        this.fciHandle.Dispose();
                        this.fciHandle = null;
                    }
                }
            }
        }

        internal override int CabOpenStreamEx(string path, int openFlags, int shareMode, out int err, IntPtr pv)
        {
            if (this.CabNumbers.ContainsKey(path))
            {
                Stream stream = this.CabStream;
                if (stream == null)
                {
                    short cabNumber = this.CabNumbers[path];

                    this.currentFolderTotalBytes = 0;

                    stream = this.context.OpenArchiveWriteStream(cabNumber, path, true, this.CabEngine);
                    if (stream == null)
                    {
                        throw new FileNotFoundException(
                            String.Format(CultureInfo.InvariantCulture, "Cabinet {0} not provided.", cabNumber));
                    }
                    this.currentArchiveName = path;

                    this.currentArchiveTotalBytes = Math.Min(
                        this.totalFolderBytesProcessedInCurrentCab, this.maxCabBytes);
                    this.currentArchiveBytesProcessed = 0;

                    this.OnProgress(ArchiveProgressType.StartArchive);
                    this.CabStream = stream;
                }
                path = CabWorker.CabStreamName;
            }
            else if (path == CabPacker.TempStreamName)
            {
                // Opening memory stream for a temp file.
                Stream stream = new MemoryStream();
                this.tempStreams.Add(stream);
                int streamHandle = this.StreamHandles.AllocHandle(stream);
                err = 0;
                return streamHandle;
            }
            else if (path != CabWorker.CabStreamName)
            {
                // Opening a file on disk for a temp file.
                path = Path.Combine(Path.GetTempPath(), path);
                Stream stream = new FileStream(path, FileMode.Open, FileAccess.ReadWrite);
                this.tempStreams.Add(stream);
                stream = new DuplicateStream(stream);
                int streamHandle = this.StreamHandles.AllocHandle(stream);
                err = 0;
                return streamHandle;
            }
            return base.CabOpenStreamEx(path, openFlags, shareMode, out err, pv);
        }

        internal override int CabWriteStreamEx(int streamHandle, IntPtr memory, int cb, out int err, IntPtr pv)
        {
            int count = base.CabWriteStreamEx(streamHandle, memory, cb, out err, pv);
            if (count > 0 && err == 0)
            {
                Stream stream = this.StreamHandles[streamHandle];
                if (DuplicateStream.OriginalStream(stream) ==
                    DuplicateStream.OriginalStream(this.CabStream))
                {
                    this.currentArchiveBytesProcessed += cb;
                    if (this.currentArchiveBytesProcessed > this.currentArchiveTotalBytes)
                    {
                        this.currentArchiveBytesProcessed = this.currentArchiveTotalBytes;
                    }
                }
            }
            return count;
        }

        internal override int CabCloseStreamEx(int streamHandle, out int err, IntPtr pv)
        {
            Stream stream = DuplicateStream.OriginalStream(this.StreamHandles[streamHandle]);

            if (stream == DuplicateStream.OriginalStream(this.FileStream))
            {
                this.context.CloseFileReadStream(this.currentFileName, stream);
                this.FileStream = null;
                long remainder = this.currentFileTotalBytes - this.currentFileBytesProcessed;
                this.currentFileBytesProcessed += remainder;
                this.fileBytesProcessed += remainder;
                this.OnProgress(ArchiveProgressType.FinishFile);

                this.currentFileTotalBytes = 0;
                this.currentFileBytesProcessed = 0;
                this.currentFileName = null;
            }
            else if (stream == DuplicateStream.OriginalStream(this.CabStream))
            {
                if (stream.CanWrite)
                {
                    stream.Flush();
                }

                this.currentArchiveBytesProcessed = this.currentArchiveTotalBytes;
                this.OnProgress(ArchiveProgressType.FinishArchive);
                this.currentArchiveNumber++;
                this.totalArchives++;

                this.context.CloseArchiveWriteStream(
                    this.currentArchiveNumber,
                    this.currentArchiveName,
                    stream);

                this.currentArchiveName = this.NextCabinetName;
                this.currentArchiveBytesProcessed = this.currentArchiveTotalBytes = 0;
                this.totalFolderBytesProcessedInCurrentCab = 0;

                this.CabStream = null;
            }
            else  // Must be a temp stream
            {
                stream.Close();
                this.tempStreams.Remove(stream);
            }
            return base.CabCloseStreamEx(streamHandle, out err, pv);
        }

        /// <summary>
        /// Disposes of resources allocated by the cabinet engine.
        /// </summary>
        /// <param name="disposing">If true, the method has been called directly or indirectly by a user's code,
        /// so managed and unmanaged resources will be disposed. If false, the method has been called by the 
        /// runtime from inside the finalizer, and only unmanaged resources will be disposed.</param>
        [SuppressMessage("Microsoft.Security", "CA2122:DoNotIndirectlyExposeMethodsWithLinkDemands")]
        protected override void Dispose(bool disposing) 
        {
            try
            {
                if (disposing)
                {
                    if (this.fciHandle != null)
                    {
                        this.fciHandle.Dispose();
                        this.fciHandle = null;
                    }
                }
            }
            finally
            {
                base.Dispose(disposing);
            }
        }

        private static NativeMethods.FCI.TCOMP GetCompressionType(CompressionLevel compLevel)
        {
            if (compLevel < CompressionLevel.Min)
            {
                return NativeMethods.FCI.TCOMP.TYPE_NONE;
            }
            else
            {
                if (compLevel > CompressionLevel.Max)
                {
                    compLevel = CompressionLevel.Max;
                }

                int lzxWindowMax =
                    ((int) NativeMethods.FCI.TCOMP.LZX_WINDOW_HI >> (int) NativeMethods.FCI.TCOMP.SHIFT_LZX_WINDOW) -
                    ((int) NativeMethods.FCI.TCOMP.LZX_WINDOW_LO >> (int) NativeMethods.FCI.TCOMP.SHIFT_LZX_WINDOW);
                int lzxWindow = lzxWindowMax *
                    (compLevel - CompressionLevel.Min) / (CompressionLevel.Max - CompressionLevel.Min);

                return (NativeMethods.FCI.TCOMP) ((int) NativeMethods.FCI.TCOMP.TYPE_LZX |
                    ((int) NativeMethods.FCI.TCOMP.LZX_WINDOW_LO +
                    (lzxWindow << (int) NativeMethods.FCI.TCOMP.SHIFT_LZX_WINDOW)));
            }
        }

        [SuppressMessage("Microsoft.Security", "CA2122:DoNotIndirectlyExposeMethodsWithLinkDemands")]
        private void AddFile(
            string name,
            Stream stream,
            FileAttributes attributes,
            DateTime lastWriteTime,
            bool execute,
            CompressionLevel compLevel)
        {
            this.FileStream = stream;
            this.fileAttributes = attributes &
                (FileAttributes.Archive | FileAttributes.Hidden | FileAttributes.ReadOnly | FileAttributes.System);
            this.fileLastWriteTime = lastWriteTime;
            this.currentFileName = name;

            NativeMethods.FCI.TCOMP tcomp = CabPacker.GetCompressionType(compLevel);

            IntPtr namePtr = IntPtr.Zero;
            try
            {
                Encoding nameEncoding = Encoding.ASCII;
                if (Encoding.UTF8.GetByteCount(name) > name.Length)
                {
                    nameEncoding = Encoding.UTF8;
                    this.fileAttributes |= FileAttributes.Normal;  // _A_NAME_IS_UTF
                }

                byte[] nameBytes = nameEncoding.GetBytes(name);
                namePtr = Marshal.AllocHGlobal(nameBytes.Length + 1);
                Marshal.Copy(nameBytes, 0, namePtr, nameBytes.Length);
                Marshal.WriteByte(namePtr, nameBytes.Length, 0);

                this.Erf.Clear();
                NativeMethods.FCI.AddFile(
                    this.fciHandle,
                    String.Empty,
                    namePtr,
                    execute,
                    this.fciGetNextCabinet,
                    this.fciCreateStatus,
                    this.fciGetOpenInfo,
                    tcomp);
            }
            finally
            {
                if (namePtr != IntPtr.Zero)
                {
                    Marshal.FreeHGlobal(namePtr);
                }
            }

            this.CheckError(false);
            this.FileStream = null;
            this.currentFileName = null;
        }

        private void FlushFolder()
        {
            this.Erf.Clear();
            NativeMethods.FCI.FlushFolder(this.fciHandle, this.fciGetNextCabinet, this.fciCreateStatus);
            this.CheckError(false);
        }

        private void FlushCabinet()
        {
            this.Erf.Clear();
            NativeMethods.FCI.FlushCabinet(this.fciHandle, false, this.fciGetNextCabinet, this.fciCreateStatus);
            this.CheckError(false);
        }

        private int CabGetOpenInfo(
            string path,
            out short date,
            out short time,
            out short attribs,
            out int err,
            IntPtr pv)
        {
            CompressionEngine.DateTimeToDosDateAndTime(this.fileLastWriteTime, out date, out time);
            attribs = (short) this.fileAttributes;

            Stream stream = this.FileStream;
            this.FileStream = new DuplicateStream(stream);
            int streamHandle = this.StreamHandles.AllocHandle(stream);
            err = 0;
            return streamHandle;
        }

        private int CabFilePlaced(
            IntPtr pccab,
            string filePath,
            long fileSize,
            int continuation,
            IntPtr pv)
        {
            return 0;
        }

        private int CabGetNextCabinet(IntPtr pccab, uint prevCabSize, IntPtr pv)
        {
            NativeMethods.FCI.CCAB nextCcab = new NativeMethods.FCI.CCAB();
            Marshal.PtrToStructure(pccab, nextCcab);

            nextCcab.szDisk = String.Empty;
            nextCcab.szCab = this.context.GetArchiveName(nextCcab.iCab);
            this.CabNumbers[nextCcab.szCab] = (short) nextCcab.iCab;
            this.NextCabinetName = nextCcab.szCab;

            Marshal.StructureToPtr(nextCcab, pccab, false);
            return 1;
        }

        private int CabCreateStatus(NativeMethods.FCI.STATUS typeStatus, uint cb1, uint cb2, IntPtr pv)
        {
            switch (typeStatus)
            {
                case NativeMethods.FCI.STATUS.FILE:
                    if (cb2 > 0 && this.currentFileBytesProcessed < this.currentFileTotalBytes)
                    {
                        if (this.currentFileBytesProcessed + cb2 > this.currentFileTotalBytes)
                        {
                            cb2 = (uint) this.currentFileTotalBytes - (uint) this.currentFileBytesProcessed;
                        }
                        this.currentFileBytesProcessed += cb2;
                        this.fileBytesProcessed += cb2;

                        this.OnProgress(ArchiveProgressType.PartialFile);
                    }
                    break;

                case NativeMethods.FCI.STATUS.FOLDER:
                    if (cb1 == 0)
                    {
                        this.currentFolderTotalBytes = cb2 - this.totalFolderBytesProcessedInCurrentCab;
                        this.totalFolderBytesProcessedInCurrentCab = cb2;
                    }
                    else if (this.currentFolderTotalBytes == 0)
                    {
                        this.OnProgress(ArchiveProgressType.PartialArchive);
                    }
                    break;

                case NativeMethods.FCI.STATUS.CABINET:
                    break;
            }
            return 0;
        }

        private int CabGetTempFile(IntPtr tempNamePtr, int tempNameSize, IntPtr pv)
        {
            string tempFileName;
            if (this.UseTempFiles)
            {
                tempFileName = Path.GetFileName(Path.GetTempFileName());
            }
            else
            {
                tempFileName = CabPacker.TempStreamName;
            }

            byte[] tempNameBytes = Encoding.ASCII.GetBytes(tempFileName);
            if (tempNameBytes.Length >= tempNameSize)
            {
                return -1;
            }

            Marshal.Copy(tempNameBytes, 0, tempNamePtr, tempNameBytes.Length);
            Marshal.WriteByte(tempNamePtr, tempNameBytes.Length, 0);  // null-terminator
            return 1;
        }

        private int CabDeleteFile(string path, out int err, IntPtr pv)
        {
            try
            {
                // Deleting a temp file - don't bother if it is only a memory stream.
                if (path != CabPacker.TempStreamName)
                {
                    path = Path.Combine(Path.GetTempPath(), path);
                    File.Delete(path);
                }
            }
            catch (IOException)
            {
                // Failure to delete a temp file is not fatal.
            }
            err = 0;
            return 1;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup2\Compression\CompressionEngine.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="CompressionEngine.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
using System;
using System.IO;
using System.Collections.Generic;
using System.Globalization;

    /// <summary>
    /// Base class for an engine capable of packing and unpacking a particular
    /// compressed file format.
    /// </summary>
    public abstract class CompressionEngine : IDisposable
    {
        private CompressionLevel compressionLevel;
        private bool dontUseTempFiles;

        /// <summary>
        /// Creates a new instance of the compression engine base class.
        /// </summary>
        protected CompressionEngine()
        {
            this.compressionLevel = CompressionLevel.Normal;
        }

        /// <summary>
        /// Disposes the compression engine.
        /// </summary>
        ~CompressionEngine()
        {
            this.Dispose(false);
        }

        /// <summary>
        /// Occurs when the compression engine reports progress in packing
        /// or unpacking an archive.
        /// </summary>
        /// <seealso cref="ArchiveProgressType"/>
        public event EventHandler<ArchiveProgressEventArgs> Progress;

        /// <summary>
        /// Gets or sets a flag indicating whether temporary files are created
        /// and used during compression.
        /// </summary>
        /// <value>True if temporary files are used; false if compression is done
        /// entirely in-memory.</value>
        /// <remarks>The value of this property is true by default. Using temporary
        /// files can greatly reduce the memory requirement of compression,
        /// especially when compressing large archives. However, setting this property
        /// to false may yield slightly better performance when creating small
        /// archives. Or it may be necessary if the process does not have sufficient
        /// privileges to create temporary files.</remarks>
        public bool UseTempFiles
        {
            get
            {
                return !this.dontUseTempFiles;
            }

            set
            {
                this.dontUseTempFiles = !value;
            }
        }

        /// <summary>
        /// Compression level to use when compressing files.
        /// </summary>
        /// <value>A compression level ranging from minimum to maximum compression,
        /// or no compression.</value>
        public CompressionLevel CompressionLevel
        {
            get
            {
                return this.compressionLevel;
            }

            set
            {
                this.compressionLevel = value;
            }
        }

        /// <summary>
        /// Disposes of resources allocated by the compression engine.
        /// </summary>
        public void Dispose()
        {
            this.Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Creates an archive.
        /// </summary>
        /// <param name="streamContext">A context interface to handle opening
        /// and closing of archive and file streams.</param>
        /// <param name="files">The paths of the files in the archive
        /// (not external file paths).</param>
        /// <exception cref="ArchiveException">The archive could not be
        /// created.</exception>
        /// <remarks>
        /// The stream context implementation may provide a mapping from the
        /// file paths within the archive to the external file paths.
        /// </remarks>
        public void Pack(IPackStreamContext streamContext, IEnumerable<string> files)
        {
            if (files == null)
            {
                throw new ArgumentNullException("files");
            }

            this.Pack(streamContext, files, 0);
        }

        /// <summary>
        /// Creates an archive or chain of archives.
        /// </summary>
        /// <param name="streamContext">A context interface to handle opening
        /// and closing of archive and file streams.</param>
        /// <param name="files">The paths of the files in the archive (not
        /// external file paths).</param>
        /// <param name="maxArchiveSize">The maximum number of bytes for one
        /// archive before the contents are chained to the next archive, or zero
        /// for unlimited archive size.</param>
        /// <exception cref="ArchiveException">The archive could not be
        /// created.</exception>
        /// <remarks>
        /// The stream context implementation may provide a mapping from the file
        /// paths within the archive to the external file paths.
        /// </remarks>
        public abstract void Pack(
            IPackStreamContext streamContext,
            IEnumerable<string> files,
            long maxArchiveSize);

        /// <summary>
        /// Checks whether a Stream begins with a header that indicates
        /// it is a valid archive.
        /// </summary>
        /// <param name="stream">Stream for reading the archive file.</param>
        /// <returns>True if the stream is a valid archive
        /// (with no offset); false otherwise.</returns>
        public abstract bool IsArchive(Stream stream);

        /// <summary>
        /// Gets the offset of an archive that is positioned 0 or more bytes
        /// from the start of the Stream.
        /// </summary>
        /// <param name="stream">A stream for reading the archive.</param>
        /// <returns>The offset in bytes of the archive,
        /// or -1 if no archive is found in the Stream.</returns>
        /// <remarks>The archive must begin on a 4-byte boundary.</remarks>
        public virtual long FindArchiveOffset(Stream stream)
        {
            if (stream == null)
            {
                throw new ArgumentNullException("stream");
            }

            long sectionSize = 4;
            long length = stream.Length;
            for (long offset = 0; offset <= length - sectionSize; offset += sectionSize)
            {
                stream.Seek(offset, SeekOrigin.Begin);
                if (this.IsArchive(stream))
                {
                    return offset;
                }
            }

            return -1;
        }

        /// <summary>
        /// Gets information about all files in an archive stream.
        /// </summary>
        /// <param name="stream">A stream for reading the archive.</param>
        /// <returns>Information about all files in the archive stream.</returns>
        /// <exception cref="ArchiveException">The stream is not a valid
        /// archive.</exception>
        public IList<ArchiveFileInfo> GetFileInfo(Stream stream)
        {
            return this.GetFileInfo(new BasicUnpackStreamContext(stream), null);
        }

        /// <summary>
        /// Gets information about files in an archive or archive chain.
        /// </summary>
        /// <param name="streamContext">A context interface to handle opening
        /// and closing of archive and file streams.</param>
        /// <param name="fileFilter">A predicate that can determine
        /// which files to process, optional.</param>
        /// <returns>Information about files in the archive stream.</returns>
        /// <exception cref="ArchiveException">The archive provided
        /// by the stream context is not valid.</exception>
        /// <remarks>
        /// The <paramref name="fileFilter"/> predicate takes an internal file
        /// path and returns true to include the file or false to exclude it.
        /// </remarks>
        public abstract IList<ArchiveFileInfo> GetFileInfo(
            IUnpackStreamContext streamContext,
            Predicate<string> fileFilter);

        /// <summary>
        /// Gets the list of files in an archive Stream.
        /// </summary>
        /// <param name="stream">A stream for reading the archive.</param>
        /// <returns>A list of the paths of all files contained in the
        /// archive.</returns>
        /// <exception cref="ArchiveException">The stream is not a valid
        /// archive.</exception>
        public IList<string> GetFiles(Stream stream)
        {
            return this.GetFiles(new BasicUnpackStreamContext(stream), null);
        }

        /// <summary>
        /// Gets the list of files in an archive or archive chain.
        /// </summary>
        /// <param name="streamContext">A context interface to handle opening
        /// and closing of archive and file streams.</param>
        /// <param name="fileFilter">A predicate that can determine
        /// which files to process, optional.</param>
        /// <returns>An array containing the names of all files contained in
        /// the archive or archive chain.</returns>
        /// <exception cref="ArchiveException">The archive provided
        /// by the stream context is not valid.</exception>
        /// <remarks>
        /// The <paramref name="fileFilter"/> predicate takes an internal file
        /// path and returns true to include the file or false to exclude it.
        /// </remarks>
        public IList<string> GetFiles(
            IUnpackStreamContext streamContext,
            Predicate<string> fileFilter)
        {
            if (streamContext == null)
            {
                throw new ArgumentNullException("streamContext");
            }

            IList<ArchiveFileInfo> files =
                this.GetFileInfo(streamContext, fileFilter);
            IList<string> fileNames = new List<string>(files.Count);
            for (int i = 0; i < files.Count; i++)
            {
                fileNames.Add(files[i].Name);
            }

            return fileNames;
        }

        /// <summary>
        /// Reads a single file from an archive stream.
        /// </summary>
        /// <param name="stream">A stream for reading the archive.</param>
        /// <param name="path">The path of the file within the archive
        /// (not the external file path).</param>
        /// <returns>A stream for reading the extracted file, or null
        /// if the file does not exist in the archive.</returns>
        /// <exception cref="ArchiveException">The stream is not a valid
        /// archive.</exception>
        /// <remarks>The entire extracted file is cached in memory, so this
        /// method requires enough free memory to hold the file.</remarks>
        public Stream Unpack(Stream stream, string path)
        {
            if (stream == null)
            {
                throw new ArgumentNullException("stream");
            }

            if (path == null)
            {
                throw new ArgumentNullException("path");
            }

            BasicUnpackStreamContext streamContext =
                new BasicUnpackStreamContext(stream);
            this.Unpack(
                streamContext,
                delegate(string match)
                {
                    return String.Compare(
                        match, path, true, CultureInfo.InvariantCulture) == 0;
                });
            
            Stream extractStream = streamContext.FileStream;
            if (extractStream != null)
            {
                extractStream.Position = 0;
            }

            return extractStream;
        }

        /// <summary>
        /// Extracts files from an archive or archive chain.
        /// </summary>
        /// <param name="streamContext">A context interface to handle opening
        /// and closing of archive and file streams.</param>
        /// <param name="fileFilter">An optional predicate that can determine
        /// which files to process.</param>
        /// <exception cref="ArchiveException">The archive provided
        /// by the stream context is not valid.</exception>
        /// <remarks>
        /// The <paramref name="fileFilter"/> predicate takes an internal file
        /// path and returns true to include the file or false to exclude it.
        /// </remarks>
        public abstract void Unpack(
            IUnpackStreamContext streamContext,
            Predicate<string> fileFilter);

        /// <summary>
        /// Called by sublcasses to distribute a packing or unpacking progress
        /// event to listeners.
        /// </summary>
        /// <param name="e">Event details.</param>
        protected void OnProgress(ArchiveProgressEventArgs e)
        {
            if (this.Progress != null)
            {
                this.Progress(this, e);
            }
        }

        /// <summary>
        /// Disposes of resources allocated by the compression engine.
        /// </summary>
        /// <param name="disposing">If true, the method has been called
        /// directly or indirectly by a user's code, so managed and unmanaged
        /// resources will be disposed. If false, the method has been called by
        /// the runtime from inside the finalizer, and only unmanaged resources
        /// will be disposed.</param>
        protected virtual void Dispose(bool disposing)
        {
        }

        /// <summary>
        /// Compresion utility function for converting old-style
        /// date and time values to a DateTime structure.
        /// </summary>
        public static void DosDateAndTimeToDateTime(
            short dosDate, short dosTime, out DateTime dateTime)
        {
            if (dosDate == 0 && dosTime == 0)
            {
                dateTime = DateTime.MinValue;
            }
            else
            {
                long fileTime;
                SafeNativeMethods.DosDateTimeToFileTime(dosDate, dosTime, out fileTime);
                dateTime = DateTime.FromFileTimeUtc(fileTime);
                dateTime = new DateTime(dateTime.Ticks, DateTimeKind.Local);
            }
        }

        /// <summary>
        /// Compresion utility function for converting a DateTime structure
        /// to old-style date and time values.
        /// </summary>
        public static void DateTimeToDosDateAndTime(
            DateTime dateTime, out short dosDate, out short dosTime)
        {
            dateTime = new DateTime(dateTime.Ticks, DateTimeKind.Utc);
            long filetime = dateTime.ToFileTimeUtc();
            SafeNativeMethods.FileTimeToDosDateTime(ref filetime, out dosDate, out dosTime);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup2\Compression.Zip\ZipException.cs ===
//---------------------------------------------------------------------
// <copyright file="ZipException.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Zip
{
    using System;
    using System.IO;
    using System.Resources;
    using System.Globalization;
    using System.Security.Permissions;
    using System.Runtime.Serialization;

    /// <summary>
    /// Exception class for zip operations.
    /// </summary>
    [Serializable]
    public class ZipException : ArchiveException
    {
        /// <summary>
        /// Creates a new ZipException with a specified error message and a reference to the
        /// inner exception that is the cause of this exception.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        /// <param name="innerException">The exception that is the cause of the current exception. If the
        /// innerException parameter is not a null reference (Nothing in Visual Basic), the current exception
        /// is raised in a catch block that handles the inner exception.</param>
        public ZipException(string message, Exception innerException)
            : base(message, innerException) { }

        /// <summary>
        /// Creates a new ZipException with a specified error message.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        public ZipException(string message)
            : this(message, null) { }

        /// <summary>
        /// Creates a new ZipException.
        /// </summary>
        public ZipException()
            : this(null, null) { }

        /// <summary>
        /// Initializes a new instance of the ZipException class with serialized data.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The StreamingContext that contains contextual information about the source or destination.</param>
        protected ZipException(SerializationInfo info, StreamingContext context) : base(info, context)
        {
        }

        /// <summary>
        /// Sets the SerializationInfo with information about the exception.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The StreamingContext that contains contextual information about the source or destination.</param>
        [SecurityPermission(SecurityAction.Demand, SerializationFormatter=true)]
        public override void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            base.GetObjectData(info, context);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup2\Compression.Zip\ZipFileInfo.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ZipFileInfo.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Zip
{
    using System;
    using System.IO;
    using System.Runtime.Serialization;
    using System.Security.Permissions;

    /// <summary>
    /// Object representing a compressed file within a zip package; provides operations for getting
    /// the file properties and extracting the file.
    /// </summary>
    [Serializable]
    public class ZipFileInfo : ArchiveFileInfo
    {
        private long compressedLength;
        private ZipCompressionMethod compressionMethod;

        /// <summary>
        /// Creates a new ZipFileInfo object representing a file within a zip in a specified path.
        /// </summary>
        /// <param name="zipInfo">An object representing the zip archive containing the file.</param>
        /// <param name="filePath">The path to the file within the zip archive. Usually, this is a simple file
        /// name, but if the zip archive contains a directory structure this may include the directory.</param>
        public ZipFileInfo(ZipInfo zipInfo, string filePath)
            : base(zipInfo, filePath)
        {
            if (zipInfo == null)
            {
                throw new ArgumentNullException("zipInfo");
            }
        }

        /// <summary>
        /// Creates a new ZipFileInfo object with all parameters specified,
        /// used internally when reading the metadata out of a zip archive.
        /// </summary>
        /// <param name="filePath">The internal path and name of the file in the zip archive.</param>
        /// <param name="zipNumber">The zip archive number where the file starts.</param>
        /// <param name="attributes">The stored attributes of the file.</param>
        /// <param name="lastWriteTime">The stored last write time of the file.</param>
        /// <param name="length">The uncompressed size of the file.</param>
        /// <param name="compressedLength">The compressed size of the file.</param>
        /// <param name="compressionMethod">Compression algorithm used for this file.</param>
        internal ZipFileInfo(
            string filePath,
            int zipNumber,
            FileAttributes attributes,
            DateTime lastWriteTime,
            long length,
            long compressedLength,
            ZipCompressionMethod compressionMethod)
            : base(filePath, zipNumber, attributes, lastWriteTime, length)
        {
            this.compressedLength = compressedLength;
            this.compressionMethod = compressionMethod;
        }

        /// <summary>
        /// Initializes a new instance of the ZipFileInfo class with serialized data.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The StreamingContext that contains contextual information about the source or destination.</param>
        protected ZipFileInfo(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
            this.compressedLength = info.GetInt64("compressedLength");
        }

        /// <summary>
        /// Gets the compressed size of the file in bytes.
        /// </summary>
        public long CompressedLength
        {
            get
            {
                return this.compressedLength;
            }
        }

        /// <summary>
        /// Gets the method used to compress this file.
        /// </summary>
        public ZipCompressionMethod CompressionMethod
        {
            get
            {
                return this.compressionMethod;
            }
        }

        /// <summary>
        /// Sets the SerializationInfo with information about the archive.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized object data.</param>
        /// <param name="context">The StreamingContext that contains contextual information
        /// about the source or destination.</param>
        [SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
        public override void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            base.GetObjectData(info, context);
            info.AddValue("compressedLength", this.compressedLength);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup2\Compression.Zip\ZipInfo.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ZipInfo.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Zip
{
    using System;
    using System.Collections.Generic;
    using System.Runtime.Serialization;

    /// <summary>
    /// Object representing a zip file on disk; provides access to
    /// file-based operations on the zip file.
    /// </summary>
    /// <remarks>
    /// Generally, the methods on this class are much easier to use than the
    /// stream-based interfaces provided by the <see cref="ZipEngine"/> class.
    /// </remarks>
    [Serializable]
    public class ZipInfo : ArchiveInfo
    {
        /// <summary>
        /// Creates a new CabinetInfo object representing a zip file in a specified path.
        /// </summary>
        /// <param name="path">The path to the zip file. When creating a zip file, this file does not
        /// necessarily exist yet.</param>
        public ZipInfo(string path)
            : base(path)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CabinetInfo class with serialized data.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The StreamingContext that contains contextual information about the source or destination.</param>
        protected ZipInfo(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }

        /// <summary>
        /// Creates a compression engine that does the low-level work for
        /// this object.
        /// </summary>
        /// <returns>A new <see cref="ZipEngine"/> instance.</returns>
        /// <remarks>
        /// Each instance will be <see cref="CompressionEngine.Dispose()"/>d
        /// immediately after use.
        /// </remarks>
        protected override CompressionEngine CreateCompressionEngine()
        {
            return new ZipEngine();
        }

        /// <summary>
        /// Gets information about the files contained in the archive.
        /// </summary>
        /// <returns>A list of <see cref="ZipFileInfo"/> objects, each
        /// containing information about a file in the archive.</returns>
        public new IList<ZipFileInfo> GetFiles()
        {
            IList<ArchiveFileInfo> files = base.GetFiles();
            List<ZipFileInfo> zipFiles = new List<ZipFileInfo>(files.Count);
            foreach (ZipFileInfo zipFile in files) zipFiles.Add(zipFile);
            return zipFiles.AsReadOnly();
        }

        /// <summary>
        /// Gets information about the certain files contained in the archive file.
        /// </summary>
        /// <param name="searchPattern">The search string, such as
        /// &quot;*.txt&quot;.</param>
        /// <returns>A list of <see cref="ZipFileInfo"/> objects, each containing
        /// information about a file in the archive.</returns>
        public new IList<ZipFileInfo> GetFiles(string searchPattern)
        {
            IList<ArchiveFileInfo> files = base.GetFiles(searchPattern);
            List<ZipFileInfo> zipFiles = new List<ZipFileInfo>(files.Count);
            foreach (ZipFileInfo zipFile in files) zipFiles.Add(zipFile);
            return zipFiles.AsReadOnly();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup2\Compression.Cab\CabUnpacker.cs ===
//---------------------------------------------------------------------
// <copyright file="CabUnpacker.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Cab
{
    using System;
    using System.IO;
    using System.Text;
    using System.Security.Permissions;
    using System.Collections.Generic;
    using System.Globalization;
    using System.Runtime.InteropServices;
    using System.Diagnostics.CodeAnalysis;

    internal class CabUnpacker : CabWorker
    {
        private NativeMethods.FDI.Handle fdiHandle;

        // These delegates need to be saved as member variables
        // so that they don't get GC'd.
        private NativeMethods.FDI.PFNALLOC fdiAllocMemHandler;
        private NativeMethods.FDI.PFNFREE fdiFreeMemHandler;
        private NativeMethods.FDI.PFNOPEN fdiOpenStreamHandler;
        private NativeMethods.FDI.PFNREAD fdiReadStreamHandler;
        private NativeMethods.FDI.PFNWRITE fdiWriteStreamHandler;
        private NativeMethods.FDI.PFNCLOSE fdiCloseStreamHandler;
        private NativeMethods.FDI.PFNSEEK fdiSeekStreamHandler;

        private IUnpackStreamContext context;

        private List<ArchiveFileInfo> fileList;

        private int folderId;

        private Predicate<string> filter;

        [SuppressMessage("Microsoft.Security", "CA2106:SecureAsserts")]
        [SuppressMessage("Microsoft.Security", "CA2122:DoNotIndirectlyExposeMethodsWithLinkDemands")]
        [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
        public CabUnpacker(CabEngine cabEngine)
            : base(cabEngine)
        {
            this.fdiAllocMemHandler = this.CabAllocMem;
            this.fdiFreeMemHandler = this.CabFreeMem;
            this.fdiOpenStreamHandler = this.CabOpenStream;
            this.fdiReadStreamHandler = this.CabReadStream;
            this.fdiWriteStreamHandler = this.CabWriteStream;
            this.fdiCloseStreamHandler = this.CabCloseStream;
            this.fdiSeekStreamHandler = this.CabSeekStream;

            this.fdiHandle = NativeMethods.FDI.Create(
                this.fdiAllocMemHandler,
                this.fdiFreeMemHandler,
                this.fdiOpenStreamHandler,
                this.fdiReadStreamHandler,
                this.fdiWriteStreamHandler,
                this.fdiCloseStreamHandler,
                this.fdiSeekStreamHandler,
                NativeMethods.FDI.CPU_80386,
                this.ErfHandle.AddrOfPinnedObject());
            if (this.Erf.Error)
            {
                int error = this.Erf.Oper;
                int errorCode = this.Erf.Type;
                this.ErfHandle.Free();
                throw new CabException(
                    error,
                    errorCode,
                    CabException.GetErrorMessage(error, errorCode, true));
            }
        }

        [SuppressMessage("Microsoft.Security", "CA2106:SecureAsserts")]
        [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
        public bool IsArchive(Stream stream)
        {
            if (stream == null)
            {
                throw new ArgumentNullException("stream");
            }

            lock (this)
            {
                short id;
                int folderCount, fileCount;
                return this.IsCabinet(stream, out id, out folderCount, out fileCount);
            }
        }

        [SuppressMessage("Microsoft.Security", "CA2106:SecureAsserts")]
        [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
        public IList<ArchiveFileInfo> GetFileInfo(
            IUnpackStreamContext streamContext,
            Predicate<string> fileFilter)
        {
            if (streamContext == null)
            {
                throw new ArgumentNullException("streamContext");
            }

            lock (this)
            {
                this.context = streamContext;
                this.filter = fileFilter;
                this.NextCabinetName = String.Empty;
                this.fileList = new List<ArchiveFileInfo>();
                bool tmpSuppress = this.SuppressProgressEvents;
                this.SuppressProgressEvents = true;
                try
                {
                    for (short cabNumber = 0;
                         this.NextCabinetName != null;
                         cabNumber++)
                    {
                        this.Erf.Clear();
                        this.CabNumbers[this.NextCabinetName] = cabNumber;
                        
                        NativeMethods.FDI.Copy(
                            this.fdiHandle,
                            this.NextCabinetName,
                            String.Empty,
                            0,
                            this.CabListNotify,
                            IntPtr.Zero,
                            IntPtr.Zero);
                        this.CheckError(true);
                    }

                    List<ArchiveFileInfo> tmpFileList = this.fileList;
                    this.fileList = null;
                    return tmpFileList.AsReadOnly();
                }
                finally
                {
                    this.SuppressProgressEvents = tmpSuppress;

                    if (this.CabStream != null)
                    {
                        this.context.CloseArchiveReadStream(
                            this.currentArchiveNumber,
                            this.currentArchiveName,
                            this.CabStream);
                        this.CabStream = null;
                    }

                    this.context = null;
                }
            }
        }

        [SuppressMessage("Microsoft.Security", "CA2106:SecureAsserts")]
        [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
        public void Unpack(
            IUnpackStreamContext streamContext,
            Predicate<string> fileFilter)
        {
            lock (this)
            {
                IList<ArchiveFileInfo> files =
                    this.GetFileInfo(streamContext, fileFilter);

                this.ResetProgressData();

                if (files != null)
                {
                    this.totalFiles = files.Count;

                    for (int i = 0; i < files.Count; i++)
                    {
                        this.totalFileBytes += files[i].Length;
                        if (files[i].ArchiveNumber >= this.totalArchives)
                        {
                            int totalArchives = files[i].ArchiveNumber + 1;
                            this.totalArchives = (short) totalArchives;
                        }
                    }
                }

                this.context = streamContext;
                this.fileList = null;
                this.NextCabinetName = String.Empty;
                this.folderId = -1;
                this.currentFileNumber = -1;

                try
                {
                    for (short cabNumber = 0;
                         this.NextCabinetName != null;
                         cabNumber++)
                    {
                        this.Erf.Clear();
                        this.CabNumbers[this.NextCabinetName] = cabNumber;

                        NativeMethods.FDI.Copy(
                            this.fdiHandle,
                            this.NextCabinetName,
                            String.Empty,
                            0,
                            this.CabExtractNotify,
                            IntPtr.Zero,
                            IntPtr.Zero);
                        this.CheckError(true);
                    }
                }
                finally
                {
                    if (this.CabStream != null)
                    {
                        this.context.CloseArchiveReadStream(
                            this.currentArchiveNumber,
                            this.currentArchiveName,
                            this.CabStream);
                        this.CabStream = null;
                    }

                    if (this.FileStream != null)
                    {
                        this.context.CloseFileWriteStream(this.currentFileName, this.FileStream, FileAttributes.Normal, DateTime.Now);
                        this.FileStream = null;
                    }

                    this.context = null;
                }
            }
        }

        internal override int CabOpenStreamEx(string path, int openFlags, int shareMode, out int err, IntPtr pv)
        {
            if (this.CabNumbers.ContainsKey(path))
            {
                Stream stream = this.CabStream;
                if (stream == null)
                {
                    short cabNumber = this.CabNumbers[path];

                    stream = this.context.OpenArchiveReadStream(cabNumber, path, this.CabEngine);
                    if (stream == null)
                    {
                        throw new FileNotFoundException(String.Format(CultureInfo.InvariantCulture, "Cabinet {0} not provided.", cabNumber));
                    }
                    this.currentArchiveName = path;
                    this.currentArchiveNumber = cabNumber;
                    if (this.totalArchives <= this.currentArchiveNumber)
                    {
                        int totalArchives = this.currentArchiveNumber + 1;
                        this.totalArchives = (short) totalArchives;
                    }
                    this.currentArchiveTotalBytes = stream.Length;
                    this.currentArchiveBytesProcessed = 0;

                    if (this.folderId != -3)  // -3 is a special folderId that requires re-opening the same cab
                    {
                        this.OnProgress(ArchiveProgressType.StartArchive);
                    }
                    this.CabStream = stream;
                }
                path = CabWorker.CabStreamName;
            }
            return base.CabOpenStreamEx(path, openFlags, shareMode, out err, pv);
        }

        internal override int CabReadStreamEx(int streamHandle, IntPtr memory, int cb, out int err, IntPtr pv)
        {
            int count = base.CabReadStreamEx(streamHandle, memory, cb, out err, pv);
            if (err == 0 && this.CabStream != null)
            {
                if (this.fileList == null)
                {
                    Stream stream = this.StreamHandles[streamHandle];
                    if (DuplicateStream.OriginalStream(stream) ==
                        DuplicateStream.OriginalStream(this.CabStream))
                    {
                        this.currentArchiveBytesProcessed += cb;
                        if (this.currentArchiveBytesProcessed > this.currentArchiveTotalBytes)
                        {
                            this.currentArchiveBytesProcessed = this.currentArchiveTotalBytes;
                        }
                    }
                }
            }
            return count;
        }

        internal override int CabWriteStreamEx(int streamHandle, IntPtr memory, int cb, out int err, IntPtr pv)
        {
            int count = base.CabWriteStreamEx(streamHandle, memory, cb, out err, pv);
            if (count > 0 && err == 0)
            {
                this.currentFileBytesProcessed += cb;
                this.fileBytesProcessed += cb;
                this.OnProgress(ArchiveProgressType.PartialFile);
            }
            return count;
        }

        internal override int CabCloseStreamEx(int streamHandle, out int err, IntPtr pv)
        {
            Stream stream = DuplicateStream.OriginalStream(this.StreamHandles[streamHandle]);

            if (stream == DuplicateStream.OriginalStream(this.CabStream))
            {
                if (this.folderId != -3)  // -3 is a special folderId that requires re-opening the same cab
                {
                    this.OnProgress(ArchiveProgressType.FinishArchive);
                }

                this.context.CloseArchiveReadStream(this.currentArchiveNumber, this.currentArchiveName, stream);

                this.currentArchiveName = this.NextCabinetName;
                this.currentArchiveBytesProcessed = this.currentArchiveTotalBytes = 0;

                this.CabStream = null;
            }
            return base.CabCloseStreamEx(streamHandle, out err, pv);
        }

        /// <summary>
        /// Disposes of resources allocated by the cabinet engine.
        /// </summary>
        /// <param name="disposing">If true, the method has been called directly or indirectly by a user's code,
        /// so managed and unmanaged resources will be disposed. If false, the method has been called by the 
        /// runtime from inside the finalizer, and only unmanaged resources will be disposed.</param>
        [SuppressMessage("Microsoft.Security", "CA2122:DoNotIndirectlyExposeMethodsWithLinkDemands")]
        protected override void Dispose(bool disposing)
        {
            try
            {
                if (disposing)
                {
                    if (this.fdiHandle != null)
                    {
                        this.fdiHandle.Dispose();
                        this.fdiHandle = null;
                    }
                }
            }
            finally
            {
                base.Dispose(disposing);
            }
        }

        private static string GetFileName(NativeMethods.FDI.NOTIFICATION notification)
        {
            bool utf8Name = (notification.attribs & (ushort) FileAttributes.Normal) != 0;  // _A_NAME_IS_UTF

            // Non-utf8 names should be completely ASCII. But for compatibility with
            // legacy tools, interpret them using the current (Default) ANSI codepage.
            Encoding nameEncoding = utf8Name ? Encoding.UTF8 : Encoding.Default;

            // Find how many bytes are in the string.
            // Unfortunately there is no faster way.
            int nameBytesCount = 0;
            while (Marshal.ReadByte(notification.psz1, nameBytesCount) != 0)
            {
                nameBytesCount++;
            }

            byte[] nameBytes = new byte[nameBytesCount];
            Marshal.Copy(notification.psz1, nameBytes, 0, nameBytesCount);
            string name = nameEncoding.GetString(nameBytes);
            if (Path.IsPathRooted(name))
            {
                name = name.Replace("" + Path.VolumeSeparatorChar, "");
            }

            return name;
        }

        private bool IsCabinet(Stream cabStream, out short id, out int cabFolderCount, out int fileCount)
        {
            int streamHandle = this.StreamHandles.AllocHandle(cabStream);
            try
            {
                this.Erf.Clear();
                NativeMethods.FDI.CABINFO fdici;
                bool isCabinet = 0 != NativeMethods.FDI.IsCabinet(this.fdiHandle, streamHandle, out fdici);

                if (this.Erf.Error)
                {
                    if (((NativeMethods.FDI.ERROR) this.Erf.Oper) == NativeMethods.FDI.ERROR.UNKNOWN_CABINET_VERSION)
                    {
                        isCabinet = false;
                    }
                    else
                    {
                        throw new CabException(
                            this.Erf.Oper,
                            this.Erf.Type,
                            CabException.GetErrorMessage(this.Erf.Oper, this.Erf.Type, true));
                    }
                }

                id = fdici.setID;
                cabFolderCount = (int) fdici.cFolders;
                fileCount = (int) fdici.cFiles;
                return isCabinet;
            }
            finally
            {
                this.StreamHandles.FreeHandle(streamHandle);
            }
        }

        private int CabListNotify(NativeMethods.FDI.NOTIFICATIONTYPE notificationType, NativeMethods.FDI.NOTIFICATION notification)
        {
            switch (notificationType)
            {
                case NativeMethods.FDI.NOTIFICATIONTYPE.CABINET_INFO:
                    {
                        string nextCab = Marshal.PtrToStringAnsi(notification.psz1);
                        this.NextCabinetName = (nextCab.Length != 0 ? nextCab : null);
                        return 0;  // Continue
                    }
                case NativeMethods.FDI.NOTIFICATIONTYPE.PARTIAL_FILE:
                    {
                        // This notification can occur when examining the contents of a non-first cab file.
                        return 0;  // Continue
                    }
                case NativeMethods.FDI.NOTIFICATIONTYPE.COPY_FILE:
                    {
                        //bool execute = (notification.attribs & (ushort) FileAttributes.Device) != 0;  // _A_EXEC

                        string name = CabUnpacker.GetFileName(notification);

                        if (this.filter == null || this.filter(name))
                        {
                            if (this.fileList != null)
                            {
                                FileAttributes attributes = (FileAttributes) notification.attribs &
                                    (FileAttributes.Archive | FileAttributes.Hidden | FileAttributes.ReadOnly | FileAttributes.System);
                                if (attributes == (FileAttributes) 0)
                                {
                                    attributes = FileAttributes.Normal;
                                }
                                DateTime lastWriteTime;
                                CompressionEngine.DosDateAndTimeToDateTime(notification.date, notification.time, out lastWriteTime);
                                long length = notification.cb;

                                CabFileInfo fileInfo = new CabFileInfo(
                                    name,
                                    notification.iFolder,
                                    notification.iCabinet,
                                    attributes,
                                    lastWriteTime,
                                    length);
                                this.fileList.Add(fileInfo);
                                this.currentFileNumber = this.fileList.Count - 1;
                                this.fileBytesProcessed += notification.cb;
                            }
                        }

                        this.totalFiles++;
                        this.totalFileBytes += notification.cb;
                        return 0;  // Continue
                    }
            }
            return 0;
        }

        private int CabExtractNotify(NativeMethods.FDI.NOTIFICATIONTYPE notificationType, NativeMethods.FDI.NOTIFICATION notification)
        {
            switch (notificationType)
            {
                case NativeMethods.FDI.NOTIFICATIONTYPE.CABINET_INFO:
                    {
                        if (this.NextCabinetName != null && this.NextCabinetName.StartsWith("?", StringComparison.Ordinal))
                        {
                            // We are just continuing the copy of a file that spanned cabinets.
                            // The next cabinet name needs to be preserved.
                            this.NextCabinetName = this.NextCabinetName.Substring(1);
                        }
                        else
                        {
                            string nextCab = Marshal.PtrToStringAnsi(notification.psz1);
                            this.NextCabinetName = (nextCab.Length != 0 ? nextCab : null);
                        }
                        return 0;  // Continue
                    }
                case NativeMethods.FDI.NOTIFICATIONTYPE.NEXT_CABINET:
                    {
                        string nextCab = Marshal.PtrToStringAnsi(notification.psz1);
                        this.CabNumbers[nextCab] = (short) notification.iCabinet;
                        this.NextCabinetName = "?" + this.NextCabinetName;
                        return 0;  // Continue
                    }
                case NativeMethods.FDI.NOTIFICATIONTYPE.COPY_FILE:
                    {
                        return this.CabExtractCopyFile(notification);
                    }
                case NativeMethods.FDI.NOTIFICATIONTYPE.CLOSE_FILE_INFO:
                    {
                        return this.CabExtractCloseFile(notification);
                    }
            }
            return 0;
        }

        private int CabExtractCopyFile(NativeMethods.FDI.NOTIFICATION notification)
        {
            if (notification.iFolder != this.folderId)
            {
                if (notification.iFolder != -3)  // -3 is a special folderId used when continuing a folder from a previous cab
                {
                    if (this.folderId != -1) // -1 means we just started the extraction sequence
                    {
                        this.currentFolderNumber++;
                    }
                }
                this.folderId = notification.iFolder;
            }

            //bool execute = (notification.attribs & (ushort) FileAttributes.Device) != 0;  // _A_EXEC

            string name = CabUnpacker.GetFileName(notification);

            if (this.filter == null || this.filter(name))
            {
                this.currentFileNumber++;
                this.currentFileName = name;

                this.currentFileBytesProcessed = 0;
                this.currentFileTotalBytes = notification.cb;
                this.OnProgress(ArchiveProgressType.StartFile);

                DateTime lastWriteTime;
                CompressionEngine.DosDateAndTimeToDateTime(notification.date, notification.time, out lastWriteTime);

                Stream stream = this.context.OpenFileWriteStream(name, notification.cb, lastWriteTime);
                if (stream != null)
                {
                    this.FileStream = stream;
                    int streamHandle = this.StreamHandles.AllocHandle(stream);
                    return streamHandle;
                }
                else
                {
                    this.fileBytesProcessed += notification.cb;
                    this.OnProgress(ArchiveProgressType.FinishFile);
                    this.currentFileName = null;
                }
            }
            return 0;  // Continue
        }

        private int CabExtractCloseFile(NativeMethods.FDI.NOTIFICATION notification)
        {
            Stream stream = this.StreamHandles[notification.hf];
            this.StreamHandles.FreeHandle(notification.hf);

            //bool execute = (notification.attribs & (ushort) FileAttributes.Device) != 0;  // _A_EXEC

            string name = CabUnpacker.GetFileName(notification);

            FileAttributes attributes = (FileAttributes) notification.attribs &
                (FileAttributes.Archive | FileAttributes.Hidden | FileAttributes.ReadOnly | FileAttributes.System);
            if (attributes == (FileAttributes) 0)
            {
                attributes = FileAttributes.Normal;
            }
            DateTime lastWriteTime;
            CompressionEngine.DosDateAndTimeToDateTime(notification.date, notification.time, out lastWriteTime);

            stream.Flush();
            this.context.CloseFileWriteStream(name, stream, attributes, lastWriteTime);
            this.FileStream = null;

            long remainder = this.currentFileTotalBytes - this.currentFileBytesProcessed;
            this.currentFileBytesProcessed += remainder;
            this.fileBytesProcessed += remainder;
            this.OnProgress(ArchiveProgressType.FinishFile);
            this.currentFileName = null;

            return 1;  // Continue
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup2\Compression.Cab\NativeMethods.cs ===
//---------------------------------------------------------------------
// <copyright file="NativeMethods.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Cab
{
using System;
using System.Text;
using System.Security;
using System.Security.Permissions;
using System.Runtime.InteropServices;
using System.Diagnostics.CodeAnalysis;

/// <summary>
/// Native DllImport methods and related structures and constants used for
/// cabinet creation and extraction via cabinet.dll.
/// </summary>
internal static class NativeMethods
{
    /// <summary>
    /// A direct import of constants, enums, structures, delegates, and functions from fci.h.
    /// Refer to comments in fci.h for documentation.
    /// </summary>
    internal static class FCI
    {
        internal const int MIN_DISK = 32768;
        internal const int MAX_DISK = Int32.MaxValue;
        internal const int MAX_FOLDER = 0x7FFF8000;
        internal const int MAX_FILENAME = 256;
        internal const int MAX_CABINET_NAME = 256;
        internal const int MAX_CAB_PATH = 256;
        internal const int MAX_DISK_NAME = 256;

        internal const int CPU_80386 = 1;

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate IntPtr PFNALLOC(int cb);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate void PFNFREE(IntPtr pv);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNOPEN(string path, int oflag, int pmode, out int err, IntPtr pv);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNREAD(int fileHandle, IntPtr memory, int cb, out int err, IntPtr pv);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNWRITE(int fileHandle, IntPtr memory, int cb, out int err, IntPtr pv);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNCLOSE(int fileHandle, out int err, IntPtr pv);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNSEEK(int fileHandle, int dist, int seekType, out int err, IntPtr pv);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNDELETE(string path, out int err, IntPtr pv);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNGETNEXTCABINET(IntPtr pccab, uint cbPrevCab, IntPtr pv);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNFILEPLACED(IntPtr pccab, string path, long fileSize, int continuation, IntPtr pv);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNGETOPENINFO(string path, out short date, out short time, out short pattribs, out int err, IntPtr pv);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNSTATUS(STATUS typeStatus, uint cb1, uint cb2, IntPtr pv);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNGETTEMPFILE(IntPtr tempNamePtr, int tempNameSize, IntPtr pv);

        /// <summary>
        /// Error codes that can be returned by FCI.
        /// </summary>
        internal enum ERROR : int
        {
            NONE,
            OPEN_SRC,
            READ_SRC,
            ALLOC_FAIL,
            TEMP_FILE,
            BAD_COMPR_TYPE,
            CAB_FILE,
            USER_ABORT,
            MCI_FAIL,
        }

        /// <summary>
        /// FCI compression algorithm types and parameters.
        /// </summary>
        internal enum TCOMP : ushort
        {
            MASK_TYPE           = 0x000F,
            TYPE_NONE           = 0x0000,
            TYPE_MSZIP          = 0x0001,
            TYPE_QUANTUM        = 0x0002,
            TYPE_LZX            = 0x0003,
            BAD                 = 0x000F,

            MASK_LZX_WINDOW     = 0x1F00,
            LZX_WINDOW_LO       = 0x0F00,
            LZX_WINDOW_HI       = 0x1500,
            SHIFT_LZX_WINDOW    = 0x0008,

            MASK_QUANTUM_LEVEL  = 0x00F0,
            QUANTUM_LEVEL_LO    = 0x0010,
            QUANTUM_LEVEL_HI    = 0x0070,
            SHIFT_QUANTUM_LEVEL = 0x0004,

            MASK_QUANTUM_MEM    = 0x1F00,
            QUANTUM_MEM_LO      = 0x0A00,
            QUANTUM_MEM_HI      = 0x1500,
            SHIFT_QUANTUM_MEM   = 0x0008,

            MASK_RESERVED       = 0xE000,
        }

        /// <summary>
        /// Reason for FCI status callback.
        /// </summary>
        internal enum STATUS : uint
        {
            FILE    = 0,
            FOLDER  = 1,
            CABINET = 2,
        }

        [SuppressMessage("Microsoft.Globalization", "CA2101:SpecifyMarshalingForPInvokeStringArguments")]
        [DllImport("cabinet.dll", EntryPoint = "FCICreate", CharSet = CharSet.Ansi, BestFitMapping = false, ThrowOnUnmappableChar = true, CallingConvention = CallingConvention.Cdecl)]
        internal static extern Handle Create(IntPtr perf, PFNFILEPLACED pfnfcifp, PFNALLOC pfna, PFNFREE pfnf, PFNOPEN pfnopen, PFNREAD pfnread, PFNWRITE pfnwrite, PFNCLOSE pfnclose, PFNSEEK pfnseek, PFNDELETE pfndelete, PFNGETTEMPFILE pfnfcigtf, [MarshalAs(UnmanagedType.LPStruct)] CCAB pccab, IntPtr pv);

        [DllImport("cabinet.dll", EntryPoint = "FCIAddFile", CharSet = CharSet.Ansi, BestFitMapping = false, ThrowOnUnmappableChar = true, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int AddFile(Handle hfci, string pszSourceFile, IntPtr pszFileName, [MarshalAs(UnmanagedType.Bool)] bool fExecute, PFNGETNEXTCABINET pfnfcignc, PFNSTATUS pfnfcis, PFNGETOPENINFO pfnfcigoi, TCOMP typeCompress);

        [DllImport("cabinet.dll", EntryPoint = "FCIFlushCabinet", CharSet = CharSet.Ansi, BestFitMapping = false, ThrowOnUnmappableChar = true, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int FlushCabinet(Handle hfci, [MarshalAs(UnmanagedType.Bool)] bool fGetNextCab, PFNGETNEXTCABINET pfnfcignc, PFNSTATUS pfnfcis);

        [DllImport("cabinet.dll", EntryPoint = "FCIFlushFolder", CharSet = CharSet.Ansi, BestFitMapping = false, ThrowOnUnmappableChar = true, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int FlushFolder(Handle hfci, PFNGETNEXTCABINET pfnfcignc, PFNSTATUS pfnfcis);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("cabinet.dll", EntryPoint = "FCIDestroy", CharSet = CharSet.Ansi, BestFitMapping = false, ThrowOnUnmappableChar = true, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.Bool)]
        internal static extern bool Destroy(IntPtr hfci);

        /// <summary>
        /// Cabinet information structure used for FCI initialization and GetNextCabinet callback.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        internal class CCAB
        {
            internal int cb             = MAX_DISK;
            internal int cbFolderThresh = MAX_FOLDER;
            internal int cbReserveCFHeader;
            internal int cbReserveCFFolder;
            internal int cbReserveCFData;
            internal int iCab;
            internal int iDisk;
            internal int fFailOnIncompressible;
            internal short setID;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst=MAX_DISK_NAME   )] internal string szDisk    = String.Empty;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst=MAX_CABINET_NAME)] internal string szCab     = String.Empty;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst=MAX_CAB_PATH    )] internal string szCabPath = String.Empty;
        }

        /// <summary>
        /// Ensures that the FCI handle is safely released.
        /// </summary>
        internal class Handle : SafeHandle
        {
            /// <summary>
            /// Creates a new unintialized handle. The handle will be initialized
            /// when it is marshalled back from native code.
            /// </summary>
            internal Handle()
                : base(IntPtr.Zero, true)
            {
            }

            /// <summary>
            /// Checks if the handle is invalid. An FCI handle is invalid when it is zero.
            /// </summary>
            public override bool IsInvalid
            {
                get
                {
                    return this.handle == IntPtr.Zero;
                }
            }

            /// <summary>
            /// Releases the handle by calling FDIDestroy().
            /// </summary>
            /// <returns>True if the release succeeded.</returns>
            [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
            protected override bool ReleaseHandle()
            {
                return FCI.Destroy(this.handle);
            }
        }
    }

    /// <summary>
    /// A direct import of constants, enums, structures, delegates, and functions from fdi.h.
    /// Refer to comments in fdi.h for documentation.
    /// </summary>
    internal static class FDI
    {
        internal const int MAX_DISK         = Int32.MaxValue;
        internal const int MAX_FILENAME     = 256;
        internal const int MAX_CABINET_NAME = 256;
        internal const int MAX_CAB_PATH     = 256;
        internal const int MAX_DISK_NAME    = 256;

        internal const int CPU_80386 = 1;

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate IntPtr PFNALLOC(int cb);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate void PFNFREE(IntPtr pv);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNOPEN(string path, int oflag, int pmode);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNREAD(int hf, IntPtr pv, int cb);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNWRITE(int hf, IntPtr pv, int cb);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNCLOSE(int hf);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNSEEK(int hf, int dist, int seektype);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNNOTIFY(NOTIFICATIONTYPE fdint, NOTIFICATION fdin);

        /// <summary>
        /// Error codes that can be returned by FDI.
        /// </summary>
        internal enum ERROR : int
        {
            NONE,
            CABINET_NOT_FOUND,
            NOT_A_CABINET,
            UNKNOWN_CABINET_VERSION,
            CORRUPT_CABINET,
            ALLOC_FAIL,
            BAD_COMPR_TYPE,
            MDI_FAIL,
            TARGET_FILE,
            RESERVE_MISMATCH,
            WRONG_CABINET,
            USER_ABORT,
        }

        /// <summary>
        /// Type of notification message for the FDI Notify callback.
        /// </summary>
        internal enum NOTIFICATIONTYPE : int
        {
            CABINET_INFO,
            PARTIAL_FILE,
            COPY_FILE,
            CLOSE_FILE_INFO,
            NEXT_CABINET,
            ENUMERATE,
        }

        [DllImport("cabinet.dll", EntryPoint = "FDICreate", CharSet = CharSet.Ansi, BestFitMapping = false, ThrowOnUnmappableChar = true, CallingConvention = CallingConvention.Cdecl)]
        internal static extern Handle Create([MarshalAs(UnmanagedType.FunctionPtr)] PFNALLOC pfnalloc, [MarshalAs(UnmanagedType.FunctionPtr)] PFNFREE pfnfree, PFNOPEN pfnopen, PFNREAD pfnread, PFNWRITE pfnwrite, PFNCLOSE pfnclose, PFNSEEK pfnseek, int cpuType, IntPtr perf);

        [DllImport("cabinet.dll", EntryPoint = "FDICopy", CharSet = CharSet.Ansi, BestFitMapping = false, ThrowOnUnmappableChar = true, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int Copy(Handle hfdi, string pszCabinet, string pszCabPath, int flags, PFNNOTIFY pfnfdin, IntPtr pfnfdid, IntPtr pvUser);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("cabinet.dll", EntryPoint = "FDIDestroy", CharSet = CharSet.Ansi, BestFitMapping = false, ThrowOnUnmappableChar = true, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.Bool)]
        internal static extern bool Destroy(IntPtr hfdi);

        [DllImport("cabinet.dll", EntryPoint = "FDIIsCabinet", CharSet = CharSet.Ansi, BestFitMapping = false, ThrowOnUnmappableChar = true, CallingConvention = CallingConvention.Cdecl)]
        [SuppressMessage("Microsoft.Portability", "CA1901:PInvokeDeclarationsShouldBePortable", Justification="FDI file handles definitely remain 4 bytes on 64bit platforms.")]
        internal static extern int IsCabinet(Handle hfdi, int hf, out CABINFO pfdici);

        /// <summary>
        /// Cabinet information structure filled in by FDI IsCabinet.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        internal struct CABINFO
        {
            internal int cbCabinet;
            internal short cFolders;
            internal short cFiles;
            internal short setID;
            internal short iCabinet;
            internal int fReserve;
            internal int hasprev;
            internal int hasnext;
        }

        /// <summary>
        /// Cabinet notification details passed to the FDI Notify callback.
        /// </summary>
        [SuppressMessage("Microsoft.Performance", "CA1812:AvoidUninstantiatedInternalClasses")]
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        internal class NOTIFICATION
        {
            internal int cb;
            internal IntPtr psz1;
            internal IntPtr psz2;
            internal IntPtr psz3;
            internal IntPtr pv;

            internal IntPtr hf_ptr;

            internal short date;
            internal short time;
            internal short attribs;
            internal short setID;
            internal short iCabinet;
            internal short iFolder;
            internal int fdie;

            // Unlike all the other file handles in FCI/FDI, this one is
            // actually pointer-sized. Use a property to pretend it isn't.
            internal int hf
            {
                get { return (int) this.hf_ptr; }
            }
        }

        /// <summary>
        /// Ensures that the FDI handle is safely released.
        /// </summary>
        internal class Handle : SafeHandle
        {
            /// <summary>
            /// Creates a new unintialized handle. The handle will be initialized
            /// when it is marshalled back from native code.
            /// </summary>
            internal Handle()
                : base(IntPtr.Zero, true)
            {
            }

            /// <summary>
            /// Checks if the handle is invalid. An FDI handle is invalid when it is zero.
            /// </summary>
            public override bool IsInvalid
            {
                get
                {
                    return this.handle == IntPtr.Zero;
                }
            }

            /// <summary>
            /// Releases the handle by calling FDIDestroy().
            /// </summary>
            /// <returns>True if the release succeeded.</returns>
            protected override bool ReleaseHandle()
            {
                return FDI.Destroy(this.handle);
            }
        }
    }

    /// <summary>
    /// Error info structure for FCI and FDI.
    /// </summary>
    /// <remarks>Before being passed to FCI or FDI, this structure is
    /// pinned in memory via a GCHandle. The pinning is necessary
    /// to be able to read the results, since the ERF structure doesn't
    /// get marshalled back out after an error.</remarks>
    [StructLayout(LayoutKind.Sequential)]
    internal class ERF
    {
        private int erfOper;
        private int erfType;
        private int fError;

        /// <summary>
        /// Gets or sets the cabinet error code.
        /// </summary>
        internal int Oper
        {
            get
            {
                return this.erfOper;
            }

            set
            {
                this.erfOper = value;
            }
        }

        /// <summary>
        /// Gets or sets the Win32 error code.
        /// </summary>
        internal int Type
        {
            get
            {
                return this.erfType;
            }

            set
            {
                this.erfType = value;
            }
        }

        /// <summary>
        /// GCHandle doesn't like the bool type, so use an int underneath.
        /// </summary>
        internal bool Error
        {
            get
            {
                return this.fError != 0;
            }

            set
            {
                this.fError = value ? 1 : 0;
            }
        }

        /// <summary>
        /// Clears the error information.
        /// </summary>
        internal void Clear()
        {
            this.Oper = 0;
            this.Type = 0;
            this.Error = false;
        }
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup2\Properties\AssemblyInfo.cs ===
﻿using System;
using System.Resources;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

[assembly: CLSCompliant(true)]
[assembly: NeutralResourcesLanguage("en-US")]
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("LFIT")]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("ee0eea6d-89be-4709-b22f-30110754d5cb")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Compression\ArchiveException.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ArchiveException.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
    using System;
    using System.IO;
    using System.Runtime.Serialization;

    /// <summary>
    /// Base exception class for compression operations. Compression libraries should
    /// derive subclass exceptions with more specific error information relevent to the
    /// file format.
    /// </summary>
    [Serializable]
    public class ArchiveException : IOException
    {
        /// <summary>
        /// Creates a new ArchiveException with a specified error message and a reference to the
        /// inner exception that is the cause of this exception.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        /// <param name="innerException">The exception that is the cause of the current exception. If the
        /// innerException parameter is not a null reference (Nothing in Visual Basic), the current exception
        /// is raised in a catch block that handles the inner exception.</param>
        public ArchiveException(string message, Exception innerException)
            : base(message, innerException)
        {
        }

        /// <summary>
        /// Creates a new ArchiveException with a specified error message.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        public ArchiveException(string message)
            : this(message, null)
        {
        }

        /// <summary>
        /// Creates a new ArchiveException.
        /// </summary>
        public ArchiveException()
            : this(null, null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ArchiveException class with serialized data.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The StreamingContext that contains contextual information about the source or destination.</param>
        protected ArchiveException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup2\Compression\ArchiveInfo.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ArchiveInfo.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
    using System;
    using System.IO;
    using System.Collections.Generic;
    using System.Globalization;
    using System.Text.RegularExpressions;
    using System.Security.Permissions;
    using System.Runtime.Serialization;
    using System.Diagnostics.CodeAnalysis;

    /// <summary>
    /// Abstract object representing a compressed archive on disk;
    /// provides access to file-based operations on the archive.
    /// </summary>
    [Serializable]
    public abstract class ArchiveInfo : FileSystemInfo
    {
        /// <summary>
        /// Creates a new ArchiveInfo object representing an archive in a
        /// specified path.
        /// </summary>
        /// <param name="path">The path to the archive. When creating an archive,
        /// this file does not necessarily exist yet.</param>
        protected ArchiveInfo(string path) : base()
        {
            if (path == null)
            {
                throw new ArgumentNullException("path");
            }

            // protected instance members inherited from FileSystemInfo:
            this.OriginalPath = path;
            this.FullPath = Path.GetFullPath(path);
        }

        /// <summary>
        /// Initializes a new instance of the ArchiveInfo class with serialized data.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized object
        /// data about the exception being thrown.</param>
        /// <param name="context">The StreamingContext that contains contextual
        /// information about the source or destination.</param>
        protected ArchiveInfo(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }

        /// <summary>
        /// Gets the directory that contains the archive.
        /// </summary>
        /// <value>A DirectoryInfo object representing the parent directory of the
        /// archive.</value>
        public DirectoryInfo Directory
        {
            get
            {
                return new DirectoryInfo(Path.GetDirectoryName(this.FullName));
            }
        }

        /// <summary>
        /// Gets the full path of the directory that contains the archive.
        /// </summary>
        /// <value>The full path of the directory that contains the archive.</value>
        public string DirectoryName
        {
            get
            {
                return Path.GetDirectoryName(this.FullName);
            }
        }

        /// <summary>
        /// Gets the size of the archive.
        /// </summary>
        /// <value>The size of the archive in bytes.</value>
        public long Length
        {
            get
            {
                return new FileInfo(this.FullName).Length;
            }
        }

        /// <summary>
        /// Gets the file name of the archive.
        /// </summary>
        /// <value>The file name of the archive, not including any path.</value>
        public override string Name
        {
            get
            {
                return Path.GetFileName(this.FullName);
            }
        }

        /// <summary>
        /// Checks if the archive exists.
        /// </summary>
        /// <value>True if the archive exists; else false.</value>
        public override bool Exists
        {
            get
            {
                return File.Exists(this.FullName);
            }
        }

        /// <summary>
        /// Gets the full path of the archive.
        /// </summary>
        /// <returns>The full path of the archive.</returns>
        public override string ToString()
        {
            return this.FullName;
        }

        /// <summary>
        /// Deletes the archive.
        /// </summary>
        public override void Delete()
        {
            File.Delete(this.FullName);
        }

        /// <summary>
        /// Copies an existing archive to another location.
        /// </summary>
        /// <param name="destFileName">The destination file path.</param>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "dest")]
        public void CopyTo(string destFileName)
        {
            File.Copy(this.FullName, destFileName);
        }

        /// <summary>
        /// Copies an existing archive to another location, optionally
        /// overwriting the destination file.
        /// </summary>
        /// <param name="destFileName">The destination file path.</param>
        /// <param name="overwrite">If true, the destination file will be
        /// overwritten if it exists.</param>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "dest")]
        public void CopyTo(string destFileName, bool overwrite)
        {
            File.Copy(this.FullName, destFileName, overwrite);
        }
        
        /// <summary>
        /// Moves an existing archive to another location.
        /// </summary>
        /// <param name="destFileName">The destination file path.</param>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "dest")]
        public void MoveTo(string destFileName)
        {
            File.Move(this.FullName, destFileName);
            this.FullPath = Path.GetFullPath(destFileName);
        }

        /// <summary>
        /// Checks if the archive contains a valid archive header.
        /// </summary>
        /// <returns>True if the file is a valid archive; false otherwise.</returns>
        public bool IsValid()
        {
            using (Stream stream = File.OpenRead(this.FullName))
            {
                using (CompressionEngine compressionEngine = this.CreateCompressionEngine())
                {
                    return compressionEngine.FindArchiveOffset(stream) >= 0;
                }
            }
        }

        /// <summary>
        /// Gets information about the files contained in the archive.
        /// </summary>
        /// <returns>A list of <see cref="ArchiveFileInfo"/> objects, each
        /// containing information about a file in the archive.</returns>
        public IList<ArchiveFileInfo> GetFiles()
        {
            return this.InternalGetFiles((Predicate<string>) null);
        }

        /// <summary>
        /// Gets information about the certain files contained in the archive file.
        /// </summary>
        /// <param name="searchPattern">The search string, such as
        /// &quot;*.txt&quot;.</param>
        /// <returns>A list of <see cref="ArchiveFileInfo"/> objects, each containing
        /// information about a file in the archive.</returns>
        public IList<ArchiveFileInfo> GetFiles(string searchPattern)
        {
            if (searchPattern == null)
            {
                throw new ArgumentNullException("searchPattern");
            }

            string regexPattern = String.Format(
                CultureInfo.InvariantCulture,
                "^{0}$",
                Regex.Escape(searchPattern).Replace("\\*", ".*").Replace("\\?", "."));
            Regex regex = new Regex(
                    regexPattern,
                    RegexOptions.IgnoreCase | RegexOptions.CultureInvariant);

            return this.InternalGetFiles(
                delegate(string match)
                {
                    return regex.IsMatch(match);
                });
        }

        /// <summary>
        /// Extracts all files from an archive to a destination directory.
        /// </summary>
        /// <param name="destDirectory">Directory where the files are to be
        /// extracted.</param>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "dest")]
        public void Unpack(string destDirectory)
        {
            this.Unpack(destDirectory, null);
        }

        /// <summary>
        /// Extracts all files from an archive to a destination directory,
        /// optionally extracting only newer files.
        /// </summary>
        /// <param name="destDirectory">Directory where the files are to be
        /// extracted.</param>
        /// <param name="progressHandler">Handler for receiving progress
        /// information; this may be null if progress is not desired.</param>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "dest")]
        public void Unpack(
            string destDirectory,
            EventHandler<ArchiveProgressEventArgs> progressHandler)
        {
            using (CompressionEngine compressionEngine = this.CreateCompressionEngine())
            {
                compressionEngine.Progress += progressHandler;
                ArchiveFileStreamContext streamContext =
                    new ArchiveFileStreamContext(this.FullName, destDirectory, null);
                streamContext.EnableOffsetOpen = true;
                compressionEngine.Unpack(streamContext, null);
            }
        }

        /// <summary>
        /// Extracts a single file from the archive.
        /// </summary>
        /// <param name="fileName">The name of the file in the archive. Also
        /// includes the internal path of the file, if any. File name matching
        /// is case-insensitive.</param>
        /// <param name="destFileName">The path where the file is to be
        /// extracted on disk.</param>
        /// <remarks>If <paramref name="destFileName"/> already exists,
        /// it will be overwritten.</remarks>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "dest")]
        public void UnpackFile(string fileName, string destFileName)
        {
            if (fileName == null)
            {
                throw new ArgumentNullException("fileName");
            }

            if (destFileName == null)
            {
                throw new ArgumentNullException("destFileName");
            }

            this.UnpackFiles(
                new string[] { fileName },
                null,
                new string[] { destFileName });
        }

        /// <summary>
        /// Extracts multiple files from the archive.
        /// </summary>
        /// <param name="fileNames">The names of the files in the archive.
        /// Each name includes the internal path of the file, if any. File name
        /// matching is case-insensitive.</param>
        /// <param name="destDirectory">This parameter may be null, but if
        /// specified it is the root directory for any relative paths in
        /// <paramref name="destFileNames"/>.</param>
        /// <param name="destFileNames">The paths where the files are to be
        /// extracted on disk. If this parameter is null, the files will be
        /// extracted with the names from the archive.</param>
        /// <remarks>
        /// If any extracted files already exist on disk, they will be overwritten.
        /// <p>The <paramref name="destDirectory"/> and
        /// <paramref name="destFileNames"/> parameters cannot both be null.</p>
        /// </remarks>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "dest")]
        public void UnpackFiles(
            IList<string> fileNames,
            string destDirectory,
            IList<string> destFileNames)
        {
            this.UnpackFiles(fileNames, destDirectory, destFileNames, null);
        }

        /// <summary>
        /// Extracts multiple files from the archive, optionally extracting
        /// only newer files.
        /// </summary>
        /// <param name="fileNames">The names of the files in the archive.
        /// Each name includes the internal path of the file, if any. File name
        /// matching is case-insensitive.</param>
        /// <param name="destDirectory">This parameter may be null, but if
        /// specified it is the root directory for any relative paths in
        /// <paramref name="destFileNames"/>.</param>
        /// <param name="destFileNames">The paths where the files are to be
        /// extracted on disk. If this parameter is null, the files will be
        /// extracted with the names from the archive.</param>
        /// <param name="progressHandler">Handler for receiving progress information;
        /// this may be null if progress is not desired.</param>
        /// <remarks>
        /// If any extracted files already exist on disk, they will be overwritten.
        /// <p>The <paramref name="destDirectory"/> and
        /// <paramref name="destFileNames"/> parameters cannot both be null.</p>
        /// </remarks>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "dest")]
        public void UnpackFiles(
            IList<string> fileNames,
            string destDirectory,
            IList<string> destFileNames,
            EventHandler<ArchiveProgressEventArgs> progressHandler)
        {
            if (fileNames == null)
            {
                throw new ArgumentNullException("fileNames");
            }

            if (destFileNames == null)
            {
                if (destDirectory == null)
                {
                    throw new ArgumentNullException("destFileNames");
                }

                destFileNames = fileNames;
            }

            if (destFileNames.Count != fileNames.Count)
            {
                throw new ArgumentOutOfRangeException("destFileNames");
            }

            IDictionary<string, string> files =
                ArchiveInfo.CreateStringDictionary(fileNames, destFileNames);
            this.UnpackFileSet(files, destDirectory, progressHandler);
        }

        /// <summary>
        /// Extracts multiple files from the archive.
        /// </summary>
        /// <param name="fileNames">A mapping from internal file paths to
        /// external file paths. Case-senstivity when matching internal paths
        /// depends on the IDictionary implementation.</param>
        /// <param name="destDirectory">This parameter may be null, but if
        /// specified it is the root directory for any relative external paths
        /// in <paramref name="fileNameMap"/>.</param>
        /// <remarks>
        /// If any extracted files already exist on disk, they will be overwritten.
        /// </remarks>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "dest")]
        public void UnpackFileSet(
            IDictionary<string, string> fileNames,
            string destDirectory)
        {
            this.UnpackFileSet(fileNames, destDirectory, null);
        }

        /// <summary>
        /// Extracts multiple files from the archive.
        /// </summary>
        /// <param name="fileNames">A mapping from internal file paths to
        /// external file paths. Case-senstivity when matching internal
        /// paths depends on the IDictionary implementation.</param>
        /// <param name="destDirectory">This parameter may be null, but if
        /// specified it is the root directory for any relative external
        /// paths in <paramref name="fileNameMap"/>.</param>
        /// <param name="progressHandler">Handler for receiving progress
        /// information; this may be null if progress is not desired.</param>
        /// <remarks>
        /// If any extracted files already exist on disk, they will be overwritten.
        /// </remarks>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "dest")]
        public void UnpackFileSet(
            IDictionary<string, string> fileNames,
            string destDirectory,
            EventHandler<ArchiveProgressEventArgs> progressHandler)
        {
            if (fileNames == null)
            {
                throw new ArgumentNullException("fileNames");
            }

            using (CompressionEngine compressionEngine = this.CreateCompressionEngine())
            {
                compressionEngine.Progress += progressHandler;
                ArchiveFileStreamContext streamContext =
                    new ArchiveFileStreamContext(this.FullName, destDirectory, fileNames);
                streamContext.EnableOffsetOpen = true;
                compressionEngine.Unpack(
                    streamContext,
                    delegate(string match)
                    {
                        return fileNames.ContainsKey(match);
                    });
            }
        }

        /// <summary>
        /// Compresses all files in a directory into the archive.
        /// Does not include subdirectories.
        /// </summary>
        /// <param name="sourceDirectory">The directory containing the
        /// files to be included.</param>
        /// <remarks>
        /// Uses maximum compression level.
        /// </remarks>
        public void Pack(string sourceDirectory)
        {
            this.Pack(sourceDirectory, false, CompressionLevel.Max, null);
        }
        /// <summary>
        /// Compresses all files in a directory into the archive, optionally
        /// including subdirectories.
        /// </summary>
        /// <param name="sourceDirectory">This parameter may be null, but
        /// if specified it is the root directory
        /// for any relative paths in <paramref name="sourceFileNames"/>.</param>
        /// <param name="includeSubdirectories">If true, recursively include
        /// files in subdirectories.</param>
        /// <param name="compLevel">The compression level used when creating
        /// the archive.</param>
        /// <param name="progressHandler">Handler for receiving progress information;
        /// this may be null if progress is not desired.</param>
        /// <remarks>
        /// The files are stored in the archive using their relative file paths in
        /// the directory tree, if supported by the archive file format.
        /// </remarks>
        public void Pack(
            IList<string> archiveFiles,
            string sourceDirectory,
            bool includeSubdirectories,
            CompressionLevel compLevel,
            EventHandler<ArchiveProgressEventArgs> progressHandler,
            long maxArchiveSize)
        {
            IList<string> files = this.GetRelativeFilePathsInDirectoryTree(
                sourceDirectory, includeSubdirectories);
            this.PackFiles(archiveFiles, sourceDirectory, files, files, compLevel, progressHandler, maxArchiveSize);
        }

        /// <summary>
        /// Compresses all files in a directory into the archive, optionally
        /// including subdirectories.
        /// </summary>
        /// <param name="sourceDirectory">This parameter may be null, but
        /// if specified it is the root directory
        /// for any relative paths in <paramref name="sourceFileNames"/>.</param>
        /// <param name="includeSubdirectories">If true, recursively include
        /// files in subdirectories.</param>
        /// <param name="compLevel">The compression level used when creating
        /// the archive.</param>
        /// <param name="progressHandler">Handler for receiving progress information;
        /// this may be null if progress is not desired.</param>
        /// <remarks>
        /// The files are stored in the archive using their relative file paths in
        /// the directory tree, if supported by the archive file format.
        /// </remarks>
        public void Pack(
            string sourceDirectory,
            bool includeSubdirectories,
            CompressionLevel compLevel,
            EventHandler<ArchiveProgressEventArgs> progressHandler)
        {
            IList<string> files = this.GetRelativeFilePathsInDirectoryTree(
                sourceDirectory, includeSubdirectories);
            this.PackFiles(sourceDirectory, files, files, compLevel, progressHandler);
        }

        /// <summary>
        /// Compresses files into the archive, specifying the names used to
        /// store the files in the archive.
        /// </summary>
        /// <param name="sourceDirectory">This parameter may be null, but
        /// if specified it is the root directory
        /// for any relative paths in <paramref name="sourceFileNames"/>.</param>
        /// <param name="sourceFileNames">The list of files to be included in
        /// the archive.</param>
        /// <param name="fileNames">The names of the files as they are stored
        /// in the archive. Each name
        /// includes the internal path of the file, if any. This parameter may
        /// be null, in which case the files are stored in the archive with their
        /// source file names and no path information.</param>
        /// <remarks>
        /// Uses maximum compression level.
        /// <p>Duplicate items in the <paramref name="fileNames"/> array will cause
        /// an <see cref="ArchiveException"/>.</p>
        /// </remarks>
        public void PackFiles(
            string sourceDirectory,
            IList<string> sourceFileNames,
            IList<string> fileNames)
        {
            this.PackFiles(
                sourceDirectory,
                sourceFileNames,
                fileNames,
                CompressionLevel.Max,
                null);
        }

        /// <summary>
        /// Compresses files into the archive, specifying the names used to
        /// store the files in the archive.
        /// </summary>
        /// <param name="sourceDirectory">This parameter may be null, but if
        /// specified it is the root directory
        /// for any relative paths in <paramref name="sourceFileNames"/>.</param>
        /// <param name="sourceFileNames">The list of files to be included in
        /// the archive.</param>
        /// <param name="fileNames">The names of the files as they are stored in
        /// the archive. Each name includes the internal path of the file, if any.
        /// This parameter may be null, in which case the files are stored in the
        /// archive with their source file names and no path information.</param>
        /// <param name="compLevel">The compression level used when creating the
        /// archive.</param>
        /// <param name="progressHandler">Handler for receiving progress information;
        /// this may be null if progress is not desired.</param>
        /// <remarks>
        /// Duplicate items in the <paramref name="fileNames"/> array will cause
        /// an <see cref="ArchiveException"/>.
        /// </remarks>
        public void PackFiles(
            IList<string> archiveFiles,
            string sourceDirectory,
            IList<string> sourceFileNames,
            IList<string> fileNames,
            CompressionLevel compLevel,
            EventHandler<ArchiveProgressEventArgs> progressHandler,
            long maxArchiveSize)
        {
            if (sourceFileNames == null)
            {
                throw new ArgumentNullException("sourceFileNames");
            }

            if (fileNames == null)
            {
                string[] fileNamesArray = new string[sourceFileNames.Count];
                for (int i = 0; i < sourceFileNames.Count; i++)
                {
                    fileNamesArray[i] = Path.GetFileName(sourceFileNames[i]);
                }

                fileNames = fileNamesArray;
            }
            else if (fileNames.Count != sourceFileNames.Count)
            {
                throw new ArgumentOutOfRangeException("fileNames");
            }

            using (CompressionEngine compressionEngine = this.CreateCompressionEngine())
            {
                compressionEngine.Progress += progressHandler;
                IDictionary<string, string> contextFiles =
                    ArchiveInfo.CreateStringDictionary(fileNames, sourceFileNames);

                
                ArchiveFileStreamContext streamContext;
                if (archiveFiles == null)
                {
                    streamContext = new ArchiveFileStreamContext(
                            this.FullName, sourceDirectory, contextFiles);
                }
                else
                {
                    streamContext = new ArchiveFileStreamContext(
                            archiveFiles, sourceDirectory, contextFiles);
                }
                streamContext.EnableOffsetOpen = true;
                compressionEngine.CompressionLevel = compLevel;
                compressionEngine.Pack(streamContext, fileNames, maxArchiveSize);
            }
        }

        /// <summary>
        /// Compresses files into the archive, specifying the names used to
        /// store the files in the archive.
        /// </summary>
        /// <param name="sourceDirectory">This parameter may be null, but if
        /// specified it is the root directory
        /// for any relative paths in <paramref name="sourceFileNames"/>.</param>
        /// <param name="sourceFileNames">The list of files to be included in
        /// the archive.</param>
        /// <param name="fileNames">The names of the files as they are stored in
        /// the archive. Each name includes the internal path of the file, if any.
        /// This parameter may be null, in which case the files are stored in the
        /// archive with their source file names and no path information.</param>
        /// <param name="compLevel">The compression level used when creating the
        /// archive.</param>
        /// <param name="progressHandler">Handler for receiving progress information;
        /// this may be null if progress is not desired.</param>
        /// <remarks>
        /// Duplicate items in the <paramref name="fileNames"/> array will cause
        /// an <see cref="ArchiveException"/>.
        /// </remarks>
        public void PackFiles(
            string sourceDirectory,
            IList<string> sourceFileNames,
            IList<string> fileNames,
            CompressionLevel compLevel,
            EventHandler<ArchiveProgressEventArgs> progressHandler)
        {
            if (sourceFileNames == null)
            {
                throw new ArgumentNullException("sourceFileNames");
            }

            if (fileNames == null)
            {
                string[] fileNamesArray = new string[sourceFileNames.Count];
                for (int i = 0; i < sourceFileNames.Count; i++)
                {
                    fileNamesArray[i] = Path.GetFileName(sourceFileNames[i]);
                }

                fileNames = fileNamesArray;
            }
            else if (fileNames.Count != sourceFileNames.Count)
            {
                throw new ArgumentOutOfRangeException("fileNames");
            }

            using (CompressionEngine compressionEngine = this.CreateCompressionEngine())
            {
                compressionEngine.Progress += progressHandler;
                IDictionary<string, string> contextFiles =
                    ArchiveInfo.CreateStringDictionary(fileNames, sourceFileNames);

                ArchiveFileStreamContext streamContext = new ArchiveFileStreamContext(
                        this.FullName, sourceDirectory, contextFiles);
                streamContext.EnableOffsetOpen = true;
                compressionEngine.CompressionLevel = compLevel;
                compressionEngine.Pack(streamContext, fileNames);
            }
        }

        /// <summary>
        /// Compresses files into the archive, specifying the names used
        /// to store the files in the archive.
        /// </summary>
        /// <param name="sourceDirectory">This parameter may be null, but if
        /// specified it is the root directory
        /// for any relative paths in <paramref name="fileNames"/>.</param>
        /// <param name="fileNames">A mapping from internal file paths to
        /// external file paths.</param>
        /// <remarks>
        /// Uses maximum compression level.
        /// </remarks>
        public void PackFileSet(
            string sourceDirectory,
            IDictionary<string, string> fileNames)
        {
            this.PackFileSet(sourceDirectory, fileNames, CompressionLevel.Max, null);
        }

        /// <summary>
        /// Compresses files into the archive, specifying the names used to
        /// store the files in the archive.
        /// </summary>
        /// <param name="sourceDirectory">This parameter may be null, but if
        /// specified it is the root directory
        /// for any relative paths in <paramref name="fileNames"/>.</param>
        /// <param name="fileNames">A mapping from internal file paths to
        /// external file paths.</param>
        /// <param name="compLevel">The compression level used when creating
        /// the archive.</param>
        /// <param name="progressHandler">Handler for receiving progress information;
        /// this may be null if progress is not desired.</param>
        public void PackFileSet(
            string sourceDirectory,
            IDictionary<string, string> fileNames,
            CompressionLevel compLevel,
            EventHandler<ArchiveProgressEventArgs> progressHandler)
        {
            if (fileNames == null)
            {
                throw new ArgumentNullException("fileNames");
            }

            string[] fileNamesArray = new string[fileNames.Count];
            fileNames.Keys.CopyTo(fileNamesArray, 0);

            using (CompressionEngine compressionEngine = this.CreateCompressionEngine())
            {
                compressionEngine.Progress += progressHandler;
                ArchiveFileStreamContext streamContext = new ArchiveFileStreamContext(
                        this.FullName, sourceDirectory, fileNames);
                streamContext.EnableOffsetOpen = true;
                compressionEngine.CompressionLevel = compLevel;
                compressionEngine.Pack(streamContext, fileNamesArray);
            }
        }

        /// <summary>
        /// Given a directory, gets the relative paths of all files in the
        /// directory, optionally including all subdirectories.
        /// </summary>
        /// <param name="dir">The directory to search.</param>
        /// <param name="includeSubdirectories">True to include subdirectories
        /// in the search.</param>
        /// <returns>A list of file paths relative to the directory.</returns>
        internal IList<string> GetRelativeFilePathsInDirectoryTree(
            string dir, bool includeSubdirectories)
        {
            IList<string> fileList = new List<string>();
            this.RecursiveGetRelativeFilePathsInDirectoryTree(
                dir, String.Empty, includeSubdirectories, fileList);
            return fileList;
        }

        /// <summary>
        /// Retrieves information about one file from this archive.
        /// </summary>
        /// <param name="path">Path of the file in the archive.</param>
        /// <returns>File information, or null if the file was not found
        /// in the archive.</returns>
        internal ArchiveFileInfo GetFile(string path)
        {
            IList<ArchiveFileInfo> files = this.InternalGetFiles(
                delegate(string match)
                {
                    return String.Compare(
                        match, path, true, CultureInfo.InvariantCulture) == 0;
                });
            return (files != null && files.Count > 0 ? files[0] : null);
        }

        /// <summary>
        /// Creates a compression engine that does the low-level work for
        /// this object.
        /// </summary>
        /// <returns>A new compression engine instance that matches the specific
        /// subclass of archive.</returns>
        /// <remarks>
        /// Each instance will be <see cref="CompressionEngine.Dispose()"/>d
        /// immediately after use.
        /// </remarks>
        protected abstract CompressionEngine CreateCompressionEngine();

        /// <summary>
        /// Creates a case-insensitive dictionary mapping from one list of
        /// strings to the other.
        /// </summary>
        /// <param name="keys">List of keys.</param>
        /// <param name="values">List of values that are mapped 1-to-1 to
        /// the keys.</param>
        /// <returns>A filled dictionary of the strings.</returns>
        private static IDictionary<string, string> CreateStringDictionary(
            IList<string> keys, IList<string> values)
        {
            IDictionary<string, string> stringDict =
                new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
            for (int i = 0; i < keys.Count; i++)
            {
                stringDict.Add(keys[i], values[i]);
            }

            return stringDict;
        }

        /// <summary>
        /// Recursive-descent helper function for
        /// GetRelativeFilePathsInDirectoryTree.
        /// </summary>
        /// <param name="dir">The root directory of the search.</param>
        /// <param name="relativeDir">The relative directory to be
        /// processed now.</param>
        /// <param name="includeSubdirectories">True to descend into
        /// subdirectories.</param>
        /// <param name="fileList">List of files found so far.</param>
        private void RecursiveGetRelativeFilePathsInDirectoryTree(
            string dir,
            string relativeDir,
            bool includeSubdirectories,
            IList<string> fileList)
        {
            foreach (string file in System.IO.Directory.GetFiles(dir))
            {
                string fileName = Path.GetFileName(file);
                fileList.Add(Path.Combine(relativeDir, fileName));
            }

            if (includeSubdirectories)
            {
                foreach (string subDir in System.IO.Directory.GetDirectories(dir))
                {
                    string subDirName = Path.GetFileName(subDir);
                    this.RecursiveGetRelativeFilePathsInDirectoryTree(
                        Path.Combine(dir, subDirName),
                        Path.Combine(relativeDir, subDirName),
                        includeSubdirectories,
                        fileList);
                }
            }
        }

        /// <summary>
        /// Uses a CompressionEngine to get ArchiveFileInfo objects from this
        /// archive, and then associates them with this ArchiveInfo instance.
        /// </summary>
        /// <param name="fileFilter">Optional predicate that can determine
        /// which files to process.</param>
        /// <returns>A list of <see cref="ArchiveFileInfo"/> objects, each
        /// containing information about a file in the archive.</returns>
        private IList<ArchiveFileInfo> InternalGetFiles(Predicate<string> fileFilter)
        {
            using (CompressionEngine compressionEngine = this.CreateCompressionEngine())
            {
                ArchiveFileStreamContext streamContext =
                    new ArchiveFileStreamContext(this.FullName, null, null);
                streamContext.EnableOffsetOpen = true;
                IList<ArchiveFileInfo> files =
                    compressionEngine.GetFileInfo(streamContext, fileFilter);
                for (int i = 0; i < files.Count; i++)
                {
                    files[i].Archive = this;
                }

                return files;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup2\Compression.Zip\CrcStream.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="CrcStream.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Zip
{
    using System;
    using System.IO;
    using System.Diagnostics.CodeAnalysis;

    /// <summary>
    /// Wraps a source stream and calcaluates a CRC over all bytes that are read or written.
    /// </summary>
    /// <remarks>
    /// The CRC algorithm matches that used in the standard ZIP file format.
    /// </remarks>
    [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Crc")]
    public class CrcStream : Stream
    {
        private Stream source;
        private uint crc;

        /// <summary>
        /// Creates a new CrcStream instance from a source stream.
        /// </summary>
        /// <param name="source">Underlying stream where bytes will be read from or written to.</param>
        public CrcStream(Stream source)
        {
            this.source = source;
        }

        /// <summary>
        /// Gets the current CRC over all bytes that have been read or written
        /// since this instance was created.
        /// </summary>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Crc")]
        [CLSCompliant(false)]
        public uint Crc
        {
            get
            {
                return this.crc;
            }
        }

        /// <summary>
        /// Gets the underlying stream that this stream reads from or writes to.
        /// </summary>
        public Stream Source
        {
            get
            {
                return this.source;
            }
        }

        /// <summary>
        /// Gets a value indicating whether the source stream supports reading.
        /// </summary>
        /// <value>true if the stream supports reading; otherwise, false.</value>
        public override bool CanRead
        {
            get
            {
                return this.source.CanRead;
            }
        }

        /// <summary>
        /// Gets a value indicating whether the source stream supports writing.
        /// </summary>
        /// <value>true if the stream supports writing; otherwise, false.</value>
        public override bool CanWrite
        {
            get
            {
                return this.source.CanWrite;
            }
        }

        /// <summary>
        /// Gets a value indicating whether the source stream supports seeking.
        /// </summary>
        /// <value>true if the stream supports seeking; otherwise, false.</value>
        public override bool CanSeek
        {
            get
            {
                return this.source.CanSeek;
            }
        }

        /// <summary>
        /// Gets the length of the source stream.
        /// </summary>
        public override long Length
        {
            get
            {
                return this.source.Length;
            }
        }

        /// <summary>
        /// Gets or sets the position of the source stream.
        /// </summary>
        public override long Position
        {
            get
            {
                return this.source.Position;
            }

            set
            {
                this.source.Position = value;
            }
        }

        /// <summary>
        /// Sets the position within the source stream.
        /// </summary>
        /// <param name="offset">A byte offset relative to the origin parameter.</param>
        /// <param name="origin">A value of type SeekOrigin indicating
        /// the reference point used to obtain the new position.</param>
        /// <returns>The new position within the source stream.</returns>
        /// <remarks>
        /// Note the CRC is only calculated over bytes that are actually read or
        /// written, so any bytes skipped by seeking will not contribute to the CRC.
        /// </remarks>
        public override long Seek(long offset, SeekOrigin origin)
        {
            return this.source.Seek(offset, origin);
        }

        /// <summary>
        /// Sets the length of the source stream.
        /// </summary>
        /// <param name="value">The desired length of the
        /// stream in bytes.</param>
        public override void SetLength(long value)
        {
            this.source.SetLength(value);
        }

        /// <summary>
        /// Reads a sequence of bytes from the source stream and advances
        /// the position within the stream by the number of bytes read.
        /// </summary>
        /// <param name="buffer">An array of bytes. When this method returns, the buffer
        /// contains the specified byte array with the values between offset and
        /// (offset + count - 1) replaced by the bytes read from the current source.</param>
        /// <param name="offset">The zero-based byte offset in buffer at which to begin
        /// storing the data read from the current stream.</param>
        /// <param name="count">The maximum number of bytes to be read from the current stream.</param>
        /// <returns>The total number of bytes read into the buffer. This can be less
        /// than the number of bytes requested if that many bytes are not currently available,
        /// or zero (0) if the end of the stream has been reached.</returns>
        public override int Read(byte[] buffer, int offset, int count)
        {
            count = this.source.Read(buffer, offset, count);
            this.UpdateCrc(buffer, offset, count);
            return count;
        }

        /// <summary>
        /// Writes a sequence of bytes to the source stream and advances the
        /// current position within this stream by the number of bytes written.
        /// </summary>
        /// <param name="buffer">An array of bytes. This method copies count
        /// bytes from buffer to the current stream.</param>
        /// <param name="offset">The zero-based byte offset in buffer at which
        /// to begin copying bytes to the current stream.</param>
        /// <param name="count">The number of bytes to be written to the
        /// current stream.</param>
        public override void Write(byte[] buffer, int offset, int count)
        {
            this.source.Write(buffer, offset, count);
            this.UpdateCrc(buffer, offset, count);
        }

        /// <summary>
        /// Flushes the source stream.
        /// </summary>
        public override void Flush()
        {
            this.source.Flush();
        }

        /// <summary>
        /// Closes the underlying stream.
        /// </summary>
        public override void Close()
        {
            this.source.Close();
            base.Close();
        }

        /// <summary>
        /// Updates the CRC with a range of bytes that were read or written.
        /// </summary>
        private void UpdateCrc(byte[] buffer, int offset, int count)
        {
            this.crc = ~this.crc;
            for( ; count > 0; count--, offset++)
            {
                this.crc = (this.crc >> 8) ^
                    CrcStream.crcTable[(this.crc  & 0xFF) ^ buffer[offset]];
            }
            this.crc = ~this.crc;
        }

        private static uint[] crcTable = MakeCrcTable();

        /// <summary>
        /// Computes a table that speeds up calculation of the CRC.
        /// </summary>
        private static uint[] MakeCrcTable()
        {
            const uint poly = 0x04C11DB7u;
            uint[] crcTable = new uint[256];
            for(uint n = 0; n < 256; n++)
            {
                uint c = CrcStream.Reflect(n, 8);
                c = c << 24;
                for(uint k = 0; k < 8; k++)
                {
                    c = (c << 1) ^ ((c & 0x80000000u) != 0 ? poly : 0);
                }
                crcTable[n] = CrcStream.Reflect(c, 32);
            }
            return crcTable;
        }

        /// <summary>
        /// Reflects the ordering of certain number of bits. For exmample when reflecting
        /// one byte, bit one is swapped with bit eight, bit two with bit seven, etc.
        /// </summary>
        private static uint Reflect(uint value, int bits)
        {
            for (int i = 0; i < bits / 2; i++)
            {
                uint leftBit = 1u << (bits - 1 - i);
                uint rightBit = 1u << i;
                if (((value & leftBit) != 0) != ((value & rightBit) != 0))
                {
                    value ^= leftBit | rightBit;
                }
            }
            return value;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup2\Compression.Zip\ZipPacker.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ZipPacker.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Zip
{
    using System;
    using System.IO;
    using System.IO.Compression;
    using System.Collections.Generic;
    using System.Globalization;

    public partial class ZipEngine
    {
        /// <summary>
        /// Creates a zip archive or chain of zip archives.
        /// </summary>
        /// <param name="streamContext">A context interface to handle opening
        /// and closing of archive and file streams.</param>
        /// <param name="files">An array of file lists.  Each list is
        /// compressed into one stream in the archive.</param>
        /// <param name="maxArchiveSize">The maximum number of bytes for one archive
        /// before the contents are chained to the next archive, or zero for unlimited
        /// archive size.</param>
        /// <exception cref="ArchiveException">The archive could not be
        /// created.</exception>
        /// <remarks>
        /// The stream context implementation may provide a mapping from the file
        /// paths within the archive to the external file paths.
        /// </remarks>
        public override void Pack(
            IPackStreamContext streamContext,
            IEnumerable<string> files,
            long maxArchiveSize)
        {
            if (streamContext == null)
            {
                throw new ArgumentNullException("streamContext");
            }

            if (files == null)
            {
                throw new ArgumentNullException("files");
            }

            lock (this)
            {
                Stream archiveStream = null;
                try
                {
                    this.ResetProgressData();
                    this.totalArchives = 1;

                    object forceZip64Value = streamContext.GetOption("forceZip64", null);
                    bool forceZip64 = Convert.ToBoolean(
                        forceZip64Value, CultureInfo.InvariantCulture);

                    // Count the total number of files and bytes to be compressed.
                    foreach (string file in files)
                    {
                        FileAttributes attributes;
                        DateTime lastWriteTime;
                        Stream fileStream = streamContext.OpenFileReadStream(
                            file,
                            out attributes,
                            out lastWriteTime);
                        if (fileStream != null)
                        {
                            this.totalFileBytes += fileStream.Length;
                            this.totalFiles++;
                            streamContext.CloseFileReadStream(file, fileStream);
                        }
                    }

                    List<ZipFileHeader> fileHeaders = new List<ZipFileHeader>();
                    this.currentFileNumber = -1;

                    if (this.currentArchiveName == null)
                    {
                        this.mainArchiveName = streamContext.GetArchiveName(0);
                        this.currentArchiveName = this.mainArchiveName;

                        if (String.IsNullOrEmpty(this.currentArchiveName))
                        {
                            throw new FileNotFoundException("No name provided for archive.");
                        }
                    }

                    this.OnProgress(ArchiveProgressType.StartArchive);

                    // Compress files one by one, saving header info for each.
                    foreach (string file in files)
                    {
                        ZipFileHeader fileHeader = this.PackOneFile(
                                streamContext,
                                file,
                                maxArchiveSize,
                                forceZip64,
                                ref archiveStream);

                        if (fileHeader != null)
                        {
                            fileHeaders.Add(fileHeader);
                        }

                        this.currentArchiveTotalBytes = (archiveStream != null ?
                            archiveStream.Position : 0);
                        this.currentArchiveBytesProcessed = this.currentArchiveTotalBytes;
                    }

                    // Write the central directory composed of all the file headers.
                    bool zip64 = forceZip64;
                    uint centralDirStartArchiveNumber = 0;
                    long centralDirStartPosition = 0;
                    long centralDirSize = 0;
                    for (int i = 0; i < fileHeaders.Count; i++)
                    {
                        ZipFileHeader fileHeader = fileHeaders[i];

                        int headerSize = fileHeader.GetSize(true);
                        centralDirSize += headerSize;

                        this.CheckArchiveWriteStream(
                            streamContext,
                            maxArchiveSize,
                            headerSize,
                            ref archiveStream);

                        if (i == 0)
                        {
                            centralDirStartArchiveNumber = (uint) this.currentArchiveNumber;
                            centralDirStartPosition = archiveStream.Position;
                        }

                        fileHeader.Write(archiveStream, true);
                        if (fileHeader.zip64)
                        {
                            zip64 = true;
                        }
                    }

                    this.currentArchiveTotalBytes =
                        (archiveStream != null ? archiveStream.Position : 0);
                    this.currentArchiveBytesProcessed = this.currentArchiveTotalBytes;

                    ZipEndOfCentralDirectory eocd = new ZipEndOfCentralDirectory();
                    eocd.dirStartDiskNumber = centralDirStartArchiveNumber;
                    eocd.entriesOnDisk = fileHeaders.Count;
                    eocd.totalEntries = fileHeaders.Count;
                    eocd.dirSize = centralDirSize;
                    eocd.dirOffset = centralDirStartPosition;
                    eocd.comment = this.comment;

                    Zip64EndOfCentralDirectoryLocator eocdl =
                        new Zip64EndOfCentralDirectoryLocator();

                    int maxFooterSize = eocd.GetSize(false);
                    if (archiveStream != null && (zip64 || archiveStream.Position >
                        ((long) UInt32.MaxValue) - eocd.GetSize(false)))
                    {
                        maxFooterSize += eocd.GetSize(true) + (int)
                            Zip64EndOfCentralDirectoryLocator.EOCDL64_SIZE;
                        zip64 = true;
                    }

                    this.CheckArchiveWriteStream(
                        streamContext,
                        maxArchiveSize,
                        maxFooterSize,
                        ref archiveStream);
                    eocd.diskNumber = (uint) this.currentArchiveNumber;

                    if (zip64)
                    {
                        eocd.versionMadeBy = 45;
                        eocd.versionNeeded = 45;
                        eocd.zip64 = true;
                        eocdl.dirOffset = archiveStream.Position;
                        eocdl.dirStartDiskNumber = (uint) this.currentArchiveNumber;
                        eocdl.totalDisks = (uint) this.currentArchiveNumber + 1;
                        eocd.Write(archiveStream);
                        eocdl.Write(archiveStream);

                        if (forceZip64)
                        {
                            eocd.dirOffset = UInt32.MaxValue;
                            eocd.dirStartDiskNumber = UInt16.MaxValue;
                        }
                    }

                    eocd.zip64 = false;
                    eocd.Write(archiveStream);

                    this.currentArchiveTotalBytes = archiveStream.Position;
                    this.currentArchiveBytesProcessed = this.currentArchiveTotalBytes;
                }
                finally
                {
                    if (archiveStream != null)
                    {
                        streamContext.CloseArchiveWriteStream(
                            this.currentArchiveNumber, this.mainArchiveName, archiveStream);
                        this.OnProgress(ArchiveProgressType.FinishArchive);
                    }
                }
            }
        }

        /// <summary>
        /// Moves to the next archive in the sequence if necessary.
        /// </summary>
        private void CheckArchiveWriteStream(
            IPackStreamContext streamContext,
            long maxArchiveSize,
            long requiredSize,
            ref Stream archiveStream)
        {
            if (archiveStream != null &&
                archiveStream.Length > 0 && maxArchiveSize > 0)
            {
                long sizeRemaining = maxArchiveSize - archiveStream.Length;
                if (sizeRemaining < requiredSize)
                {
                    string nextArchiveName = streamContext.GetArchiveName(
                        this.currentArchiveNumber + 1);

                    if (String.IsNullOrEmpty(nextArchiveName))
                    {
                        throw new FileNotFoundException("No name provided for archive #" +
                            this.currentArchiveNumber + 1);
                    }

                    this.currentArchiveTotalBytes = archiveStream.Position;
                    this.currentArchiveBytesProcessed = this.currentArchiveTotalBytes;

                    streamContext.CloseArchiveWriteStream(
                        this.currentArchiveNumber,
                        nextArchiveName,
                        archiveStream);
                    archiveStream = null;

                    this.OnProgress(ArchiveProgressType.FinishArchive);

                    this.currentArchiveNumber++;
                    this.totalArchives++;
                    this.currentArchiveBytesProcessed = 0;
                    this.currentArchiveTotalBytes = 0;
                }
            }

            if (archiveStream == null)
            {
                if (this.currentArchiveNumber > 0)
                {
                    this.OnProgress(ArchiveProgressType.StartArchive);
                }

                archiveStream = streamContext.OpenArchiveWriteStream(
                    this.currentArchiveNumber, this.mainArchiveName, true, this);

                if (archiveStream == null)
                {
                    throw new FileNotFoundException("Stream not provided for archive #" +
                        this.currentArchiveNumber);
                }
            }
        }

        /// <summary>
        /// Adds one file to a zip archive in the process of being created.
        /// </summary>
        private ZipFileHeader PackOneFile(
            IPackStreamContext streamContext,
            string file,
            long maxArchiveSize,
            bool forceZip64,
            ref Stream archiveStream)
        {
            Stream fileStream = null;
            int headerArchiveNumber = 0;
            try
            {
                // TODO: call GetOption to get compression method for the specific file
                ZipCompressionMethod compressionMethod = ZipCompressionMethod.Deflate;
                if (this.CompressionLevel == CompressionLevel.None)
                {
                    compressionMethod = ZipCompressionMethod.Store;
                }

                Converter<Stream, Stream> compressionStreamCreator;
                if (!ZipEngine.compressionStreamCreators.TryGetValue(
                    compressionMethod, out compressionStreamCreator))
                {
                    return null;
                }

                FileAttributes attributes;
                DateTime lastWriteTime;
                fileStream = streamContext.OpenFileReadStream(
                    file, out attributes, out lastWriteTime);
                if (fileStream == null)
                {
                    return null;
                }

                this.currentFileName = file;
                this.currentFileNumber++;

                this.currentFileTotalBytes = fileStream.Length;
                this.currentFileBytesProcessed = 0;
                this.OnProgress(ArchiveProgressType.StartFile);

                ZipFileInfo fileInfo = new ZipFileInfo(
                    file,
                    this.currentArchiveNumber,
                    attributes,
                    lastWriteTime,
                    fileStream.Length,
                    0,
                    compressionMethod);

                bool zip64 = forceZip64 || fileStream.Length >= (long) UInt32.MaxValue;
                ZipFileHeader fileHeader = new ZipFileHeader(fileInfo, zip64);

                this.CheckArchiveWriteStream(
                    streamContext,
                    maxArchiveSize,
                    fileHeader.GetSize(false),
                    ref archiveStream);

                long headerPosition = archiveStream.Position;
                fileHeader.Write(archiveStream, false);
                headerArchiveNumber = this.currentArchiveNumber;

                uint crc;
                long bytesWritten = this.PackFileBytes(
                    streamContext,
                    fileStream,
                    maxArchiveSize,
                    compressionStreamCreator,
                    ref archiveStream,
                    out crc);

                fileHeader.Update(
                    bytesWritten,
                    fileStream.Length,
                    crc,
                    headerPosition,
                    headerArchiveNumber);

                streamContext.CloseFileReadStream(file, fileStream);
                fileStream = null;

                // Go back and rewrite the updated file header.
                if (this.currentArchiveNumber == headerArchiveNumber)
                {
                    long fileEndPosition = archiveStream.Position;
                    archiveStream.Seek(headerPosition, SeekOrigin.Begin);
                    fileHeader.Write(archiveStream, false);
                    archiveStream.Seek(fileEndPosition, SeekOrigin.Begin);
                }
                else
                {
                    // The file spanned archives, so temporarily reopen
                    // the archive where it started.
                    string headerArchiveName = streamContext.GetArchiveName(
                        headerArchiveNumber + 1);
                    Stream headerStream = null;
                    try
                    {
                        headerStream = streamContext.OpenArchiveWriteStream(
                            headerArchiveNumber, headerArchiveName, false, this);
                        headerStream.Seek(headerPosition, SeekOrigin.Begin);
                        fileHeader.Write(headerStream, false);
                    }
                    finally
                    {
                        if (headerStream != null)
                        {
                            streamContext.CloseArchiveWriteStream(
                                headerArchiveNumber, headerArchiveName, headerStream);
                        }
                    }
                }

                this.OnProgress(ArchiveProgressType.FinishFile);

                return fileHeader;
            }
            finally
            {
                if (fileStream != null)
                {
                    streamContext.CloseFileReadStream(
                        this.currentFileName, fileStream);
                }
            }
        }

        /// <summary>
        /// Writes compressed bytes of one file to the archive,
        /// keeping track of the CRC and number of bytes written.
        /// </summary>
        private long PackFileBytes(
            IPackStreamContext streamContext,
            Stream fileStream,
            long maxArchiveSize,
            Converter<Stream, Stream> compressionStreamCreator,
            ref Stream archiveStream,
            out uint crc)
        {
            long writeStartPosition = archiveStream.Position;
            long bytesWritten = 0;
            CrcStream fileCrcStream = new CrcStream(fileStream);

            ConcatStream concatStream = new ConcatStream(
                delegate(ConcatStream s)
                {
                    Stream sourceStream = s.Source;
                    bytesWritten += sourceStream.Position - writeStartPosition;

                    this.CheckArchiveWriteStream(
                        streamContext,
                        maxArchiveSize,
                        1,
                        ref sourceStream);

                    writeStartPosition = sourceStream.Position;
                    s.Source = sourceStream;
                });

            concatStream.Source = archiveStream;

            if (maxArchiveSize > 0)
            {
                concatStream.SetLength(maxArchiveSize);
            }

            Stream compressionStream = compressionStreamCreator(concatStream);

            try
            {
                byte[] buf = new byte[4096];
                long bytesRemaining = fileStream.Length;
                int counter = 0;
                while (bytesRemaining > 0)
                {
                    int count = (int) Math.Min(
                        bytesRemaining, (long) buf.Length);

                    count = fileCrcStream.Read(buf, 0, count);
                    if (count <= 0)
                    {
                        throw new ZipException(
                            "Failed to read file: " + this.currentFileName);
                    }

                    compressionStream.Write(buf, 0, count);
                    bytesRemaining -= count;

                    this.fileBytesProcessed += count;
                    this.currentFileBytesProcessed += count;
                    this.currentArchiveTotalBytes = concatStream.Source.Position;
                    this.currentArchiveBytesProcessed = this.currentArchiveTotalBytes;

                    if (++counter % 16 == 0) // Report every 64K
                    {
                        this.OnProgress(ArchiveProgressType.PartialFile);
                    }
                }

                if (compressionStream is DeflateStream)
                {
                    compressionStream.Close();
                }
                else
                {
                    compressionStream.Flush();
                }
            }
            finally
            {
                archiveStream = concatStream.Source;
            }

            bytesWritten += archiveStream.Position - writeStartPosition;

            crc = fileCrcStream.Crc;

            return bytesWritten;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup2\Compression.Zip\ZipFormat.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ZipFormat.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Zip
{
    using System;
    using System.Globalization;
    using System.IO;
    using System.Text;
    using System.Collections.Generic;
    using System.Diagnostics.CodeAnalysis;

    [Flags]
    internal enum ZipFileFlags : ushort
    {
        None            = 0x0000,
        Encrypt         = 0x0001,
        CompressOption1 = 0x0002,
        CompressOption2 = 0x0004,
        DataDescriptor  = 0x0008,
        StrongEncrypt   = 0x0040,
        UTF8            = 0x0800
    }

    internal enum ZipExtraFileFieldType : ushort
    {
        ZIP64 = 0x0001,
        NTFS_TIMES = 0x000A,
        NTFS_ACLS = 0x4453,
        EXTIME = 0x5455
    }

    internal class ZipFileHeader
    {
        public const uint LFHSIG = 0x04034B50;
        public const uint CFHSIG = 0x02014B50;

        public const uint SPANSIG  = 0x08074b50;
        public const uint SPANSIG2 = 0x30304b50;
        
        public const uint LFH_FIXEDSIZE = 30;
        public const uint CFH_FIXEDSIZE = 46;

        public ushort versionMadeBy;
        public ushort versionNeeded;
        public ZipFileFlags flags;
        public ZipCompressionMethod compressionMethod;
        public short lastModTime;
        public short lastModDate;
        public uint crc32;
        public uint compressedSize;
        public uint uncompressedSize;
        public ushort diskStart;
        public ushort internalFileAttrs;
        public uint externalFileAttrs;
        public uint localHeaderOffset;
        public string fileName;
        public ZipExtraFileField[] extraFields;
        public string fileComment;
        public bool zip64;

        public ZipFileHeader()
        {
            this.versionMadeBy = 20;
            this.versionNeeded = 20;
        }

        public ZipFileHeader(ZipFileInfo fileInfo, bool zip64)
            : this()
        {
            this.flags = ZipFileFlags.None;
            this.compressionMethod = fileInfo.CompressionMethod;
            this.fileName = Path.Combine(fileInfo.Path, fileInfo.Name);
            CompressionEngine.DateTimeToDosDateAndTime(
                fileInfo.LastWriteTime, out this.lastModDate, out this.lastModTime);
            this.zip64 = zip64;

            if (this.zip64)
            {
                this.compressedSize = UInt32.MaxValue;
                this.uncompressedSize = UInt32.MaxValue;
                this.diskStart = UInt16.MaxValue;
                this.versionMadeBy = 45;
                this.versionNeeded = 45;
                ZipExtraFileField field = new ZipExtraFileField();
                field.fieldType = ZipExtraFileFieldType.ZIP64;
                field.SetZip64Data(
                    fileInfo.CompressedLength,
                    fileInfo.Length,
                    0,
                    fileInfo.ArchiveNumber);
                this.extraFields = new ZipExtraFileField[] { field };
            }
            else
            {
                this.compressedSize = (uint) fileInfo.CompressedLength;
                this.uncompressedSize = (uint) fileInfo.Length;
                this.diskStart = (ushort) fileInfo.ArchiveNumber;
            }
        }

        [SuppressMessage("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames", MessageId = "compressedSize")]
        [SuppressMessage("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames", MessageId = "uncompressedSize")]
        [SuppressMessage("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames", MessageId = "crc32")]
        [SuppressMessage("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames", MessageId = "localHeaderOffset")]
        public void Update(
            long compressedSize,
            long uncompressedSize,
            uint crc32,
            long localHeaderOffset,
            int archiveNumber)
        {
            this.crc32 = crc32;

            if (this.zip64)
            {
                this.compressedSize = UInt32.MaxValue;
                this.uncompressedSize = UInt32.MaxValue;
                this.localHeaderOffset = UInt32.MaxValue;
                this.diskStart = UInt16.MaxValue;

                if (this.extraFields != null)
                {
                    foreach (ZipExtraFileField field in this.extraFields)
                    {
                        if (field.fieldType == ZipExtraFileFieldType.ZIP64)
                        {
                            field.SetZip64Data(
                                compressedSize,
                                uncompressedSize,
                                localHeaderOffset,
                                archiveNumber);
                        }
                    }
                }
            }
            else
            {
                this.compressedSize = (uint) compressedSize;
                this.uncompressedSize = (uint) uncompressedSize;
                this.localHeaderOffset = (uint) localHeaderOffset;
                this.diskStart = (ushort) archiveNumber;
            }
        }

        public bool Read(Stream stream, bool central)
        {
            long startPos = stream.Position;

            if (stream.Length - startPos <
                (central ? CFH_FIXEDSIZE : LFH_FIXEDSIZE))
            {
                return false;
            }

            BinaryReader reader = new BinaryReader(stream);
            uint sig = reader.ReadUInt32();

            if (sig == SPANSIG || sig == SPANSIG2)
            {
                // Spanned zip files may optionally begin with a special marker.
                // Just ignore it and move on.
                sig = reader.ReadUInt32();
            }

            if (sig != (central ? CFHSIG : LFHSIG))
            {
                return false;
            }

            this.versionMadeBy = (central ? reader.ReadUInt16() : (ushort) 0);
            this.versionNeeded = reader.ReadUInt16();
            this.flags = (ZipFileFlags) reader.ReadUInt16();
            this.compressionMethod = (ZipCompressionMethod) reader.ReadUInt16();
            this.lastModTime = reader.ReadInt16();
            this.lastModDate = reader.ReadInt16();
            this.crc32 = reader.ReadUInt32();
            this.compressedSize = reader.ReadUInt32();
            this.uncompressedSize = reader.ReadUInt32();
            
            this.zip64 = this.uncompressedSize == UInt32.MaxValue;

            int fileNameLength = reader.ReadUInt16();
            int extraFieldLength = reader.ReadUInt16();
            int fileCommentLength;

            if (central)
            {
                fileCommentLength = reader.ReadUInt16();

                this.diskStart = reader.ReadUInt16();
                this.internalFileAttrs = reader.ReadUInt16();
                this.externalFileAttrs = reader.ReadUInt32();
                this.localHeaderOffset = reader.ReadUInt32();
            }
            else
            {
                fileCommentLength = 0;
                this.diskStart = 0;
                this.internalFileAttrs = 0;
                this.externalFileAttrs = 0;
                this.localHeaderOffset = 0;
            }

            if (stream.Length - stream.Position <
                fileNameLength + extraFieldLength + fileCommentLength)
            {
                return false;
            }

            Encoding headerEncoding = ((this.flags | ZipFileFlags.UTF8) != 0 ?
                Encoding.UTF8 : Encoding.GetEncoding(CultureInfo.CurrentCulture.TextInfo.OEMCodePage));

            byte[] fileNameBytes = reader.ReadBytes(fileNameLength);
            this.fileName = headerEncoding.GetString(fileNameBytes);

            List<ZipExtraFileField> fields = new List<ZipExtraFileField>();
            while (extraFieldLength > 0)
            {
                ZipExtraFileField field = new ZipExtraFileField();
                if (!field.Read(stream, ref extraFieldLength))
                {
                    return false;
                }
                fields.Add(field);
                if (field.fieldType == ZipExtraFileFieldType.ZIP64)
                {
                    this.zip64 = true;
                }
            }
            this.extraFields = fields.ToArray();

            byte[] fileCommentBytes = reader.ReadBytes(fileCommentLength);
            this.fileComment = headerEncoding.GetString(fileCommentBytes);

            return true;
        }

        public void Write(Stream stream, bool central)
        {
            byte[] fileNameBytes = (this.fileName != null
                ? Encoding.UTF8.GetBytes(this.fileName) : new byte[0]);
            byte[] fileCommentBytes = (this.fileComment != null
                ? Encoding.UTF8.GetBytes(this.fileComment) : new byte[0]);
            bool useUtf8 =
                (this.fileName != null && fileNameBytes.Length > this.fileName.Length) ||
                (this.fileComment != null && fileCommentBytes.Length > this.fileComment.Length);
            if (useUtf8)
            {
                this.flags |= ZipFileFlags.UTF8;
            }

            BinaryWriter writer = new BinaryWriter(stream);
            writer.Write(central ? CFHSIG : LFHSIG);
            if (central)
            {
                writer.Write(this.versionMadeBy);
            }
            writer.Write(this.versionNeeded);
            writer.Write((ushort) this.flags);
            writer.Write((ushort) this.compressionMethod);
            writer.Write(this.lastModTime);
            writer.Write(this.lastModDate);
            writer.Write(this.crc32);
            writer.Write(this.compressedSize);
            writer.Write(this.uncompressedSize);
            
            ushort extraFieldLength = 0;
            if (this.extraFields != null)
            {
                foreach (ZipExtraFileField field in this.extraFields)
                {
                    if (field.data != null)
                    {
                        extraFieldLength += (ushort) (4 + field.data.Length);
                    }
                }
            }

            writer.Write((ushort) fileNameBytes.Length);
            writer.Write(extraFieldLength);

            if (central)
            {
                writer.Write((ushort) fileCommentBytes.Length);

                writer.Write(this.diskStart);
                writer.Write(this.internalFileAttrs);
                writer.Write(this.externalFileAttrs);
                writer.Write(this.localHeaderOffset);
            }

            writer.Write(fileNameBytes);

            if (this.extraFields != null)
            {
                foreach (ZipExtraFileField field in this.extraFields)
                {
                    if (field.data != null)
                    {
                        field.Write(stream);
                    }
                }
            }

            if (central)
            {
                writer.Write(fileCommentBytes);
            }
        }

        [SuppressMessage("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames", MessageId = "compressedSize")]
        [SuppressMessage("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames", MessageId = "uncompressedSize")]
        [SuppressMessage("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames", MessageId = "crc32")]
        [SuppressMessage("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames", MessageId = "localHeaderOffset")]
        public void GetZip64Fields(
            out long compressedSize,
            out long uncompressedSize,
            out long localHeaderOffset,
            out int archiveNumber,
            out uint crc)
        {
            compressedSize = this.compressedSize;
            uncompressedSize = this.uncompressedSize;
            localHeaderOffset = this.localHeaderOffset;
            archiveNumber = this.diskStart;
            crc = this.crc32;

            foreach (ZipExtraFileField field in this.extraFields)
            {
                if (field.fieldType == ZipExtraFileFieldType.ZIP64)
                {
                    field.GetZip64Data(
                        out compressedSize,
                        out uncompressedSize,
                        out localHeaderOffset,
                        out archiveNumber);
                }
            }
        }

        public ZipFileInfo ToZipFileInfo()
        {
            string name = this.fileName;
            
            long compressedSizeL;
            long uncompressedSizeL;
            long localHeaderOffsetL;
            int archiveNumberL;
            uint crc;
            this.GetZip64Fields(
                out compressedSizeL,
                out uncompressedSizeL,
                out localHeaderOffsetL,
                out archiveNumberL,
                out crc);

            DateTime dateTime;
            CompressionEngine.DosDateAndTimeToDateTime(
                this.lastModDate,
                this.lastModTime,
                out dateTime);
            FileAttributes attrs = FileAttributes.Normal;
            // TODO: look for attrs or times in extra fields

            return new ZipFileInfo(name, archiveNumberL, attrs, dateTime,
                uncompressedSizeL, compressedSizeL, this.compressionMethod);
        }

        public bool IsDirectory
        {
            get
            {
                return this.fileName != null &&
                    (this.fileName.EndsWith("/", StringComparison.Ordinal) ||
                    this.fileName.EndsWith("\\", StringComparison.Ordinal));
            }
        }

        public int GetSize(bool central)
        {
            int size = 30;

            int fileNameSize = (this.fileName != null
                ? Encoding.UTF8.GetByteCount(this.fileName) : 0);
            size += fileNameSize;

            if (this.extraFields != null)
            {
                foreach (ZipExtraFileField field in this.extraFields)
                {
                    if (field.data != null)
                    {
                        size += 4 + field.data.Length;
                    }
                }
            }

            if (central)
            {
                size += 16;

                int fileCommentSize = (this.fileComment != null
                    ? Encoding.UTF8.GetByteCount(this.fileComment) : 0);
                size += fileCommentSize;
            }

            return size;
        }
    }

    internal class ZipExtraFileField
    {
        public ZipExtraFileFieldType fieldType;
        public byte[] data;

        public bool Read(Stream stream, ref int bytesRemaining)
        {
            if (bytesRemaining < 4)
            {
                return false;
            }

            BinaryReader reader = new BinaryReader(stream);

            this.fieldType = (ZipExtraFileFieldType) reader.ReadUInt16();
            ushort dataSize = reader.ReadUInt16();
            bytesRemaining -= 4;

            if (bytesRemaining < dataSize)
            {
                return false;
            }

            this.data = reader.ReadBytes(dataSize);
            bytesRemaining -= dataSize;

            return true;
        }

        public void Write(Stream stream)
        {
            BinaryWriter writer = new BinaryWriter(stream);
            writer.Write((ushort) this.fieldType);

            byte[] dataBytes = (this.data != null ? this.data : new byte[0]);
            writer.Write((ushort) dataBytes.Length);
            writer.Write(dataBytes);
        }

        public bool GetZip64Data(
            out long compressedSize,
            out long uncompressedSize,
            out long localHeaderOffset,
            out int diskStart)
        {
            uncompressedSize = 0;
            compressedSize = 0;
            localHeaderOffset = 0;
            diskStart = 0;

            if (this.fieldType != ZipExtraFileFieldType.ZIP64 ||
                this.data == null || this.data.Length != 28)
            {
                return false;
            }

            using (MemoryStream dataStream = new MemoryStream(this.data))
            {
                BinaryReader reader = new BinaryReader(dataStream);
                uncompressedSize = reader.ReadInt64();
                compressedSize = reader.ReadInt64();
                localHeaderOffset = reader.ReadInt64();
                diskStart = reader.ReadInt32();
            }

            return true;
        }

        public bool SetZip64Data(
            long compressedSize,
            long uncompressedSize,
            long localHeaderOffset,
            int diskStart)
        {
            if (this.fieldType != ZipExtraFileFieldType.ZIP64)
            {
                return false;
            }

            using (MemoryStream dataStream = new MemoryStream())
            {
                BinaryWriter writer = new BinaryWriter(dataStream);
                writer.Write(uncompressedSize);
                writer.Write(compressedSize);
                writer.Write(localHeaderOffset);
                writer.Write(diskStart);
                this.data = dataStream.ToArray();
            }

            return true;
        }
    }

    internal class ZipEndOfCentralDirectory
    {
        public const uint EOCDSIG = 0x06054B50;
        public const uint EOCD64SIG = 0x06064B50;

        public const uint EOCD_RECORD_FIXEDSIZE = 22;
        public const uint EOCD64_RECORD_FIXEDSIZE = 56;

        public ushort versionMadeBy;
        public ushort versionNeeded;
        public uint diskNumber;
        public uint dirStartDiskNumber;
        public long entriesOnDisk;
        public long totalEntries;
        public long dirSize;
        public long dirOffset;
        public string comment;
        public bool zip64;

        public ZipEndOfCentralDirectory()
        {
            this.versionMadeBy = 20;
            this.versionNeeded = 20;
        }

        public bool Read(Stream stream)
        {
            long startPos = stream.Position;

            if (stream.Length - startPos < EOCD_RECORD_FIXEDSIZE)
            {
                return false;
            }

            BinaryReader reader = new BinaryReader(stream);
            uint sig = reader.ReadUInt32();

            this.zip64 = false;
            if (sig != EOCDSIG)
            {
                if (sig == EOCD64SIG)
                {
                    this.zip64 = true;
                }
                else
                {
                    return false;
                }
            }

            if (this.zip64)
            {
                if (stream.Length - startPos < EOCD64_RECORD_FIXEDSIZE)
                {
                    return false;
                }

                long recordSize = reader.ReadInt64();
                this.versionMadeBy = reader.ReadUInt16();
                this.versionNeeded = reader.ReadUInt16();
                this.diskNumber = reader.ReadUInt32();
                this.dirStartDiskNumber = reader.ReadUInt32();
                this.entriesOnDisk = reader.ReadInt64();
                this.totalEntries = reader.ReadInt64();
                this.dirSize = reader.ReadInt64();
                this.dirOffset = reader.ReadInt64();

                // Ignore any extended zip64 eocd data.
                long exDataSize = recordSize + 12 - EOCD64_RECORD_FIXEDSIZE;

                if (stream.Length - stream.Position < exDataSize)
                {
                    return false;
                }

                stream.Seek(exDataSize, SeekOrigin.Current);

                this.comment = null;
            }
            else
            {
                this.diskNumber = reader.ReadUInt16();
                this.dirStartDiskNumber = reader.ReadUInt16();
                this.entriesOnDisk = reader.ReadUInt16();
                this.totalEntries = reader.ReadUInt16();
                this.dirSize = reader.ReadUInt32();
                this.dirOffset = reader.ReadUInt32();

                int commentLength = reader.ReadUInt16();

                if (stream.Length - stream.Position < commentLength)
                {
                    return false;
                }

                byte[] commentBytes = reader.ReadBytes(commentLength);
                this.comment = Encoding.UTF8.GetString(commentBytes);
            }

            return true;
        }

        public void Write(Stream stream)
        {
            BinaryWriter writer = new BinaryWriter(stream);

            if (this.zip64)
            {
                writer.Write(EOCD64SIG);
                writer.Write((long) EOCD64_RECORD_FIXEDSIZE);
                writer.Write(this.versionMadeBy);
                writer.Write(this.versionNeeded);
                writer.Write(this.diskNumber);
                writer.Write(this.dirStartDiskNumber);
                writer.Write(this.entriesOnDisk);
                writer.Write(this.totalEntries);
                writer.Write(this.dirSize);
                writer.Write(this.dirOffset);
            }
            else
            {
                writer.Write(EOCDSIG);
                writer.Write((ushort) Math.Min((int) UInt16.MaxValue, this.diskNumber));
                writer.Write((ushort) Math.Min((int) UInt16.MaxValue, this.dirStartDiskNumber));
                writer.Write((ushort) Math.Min((int) UInt16.MaxValue, this.entriesOnDisk));
                writer.Write((ushort) Math.Min((int) UInt16.MaxValue, this.totalEntries));
                writer.Write((uint) Math.Min((long) UInt32.MaxValue, this.dirSize));
                writer.Write((uint) Math.Min((long) UInt32.MaxValue, this.dirOffset));

                byte[] commentBytes = (this.comment != null
                    ? Encoding.UTF8.GetBytes(this.comment) : new byte[0]);
                writer.Write((ushort) commentBytes.Length);
                writer.Write(commentBytes);
            }
        }

        public int GetSize(bool zip64Size)
        {
            if (zip64Size)
            {
                return 56;
            }
            else
            {
                int commentSize = (this.comment != null
                    ? Encoding.UTF8.GetByteCount(this.comment) : 0);
                return 22 + commentSize;
            }
        }
    }

    internal class Zip64EndOfCentralDirectoryLocator
    {
        public const uint EOCDL64SIG = 0x07064B50;

        public const uint EOCDL64_SIZE = 20;

        public uint dirStartDiskNumber;
        public long dirOffset;
        public uint totalDisks;

        public bool Read(Stream stream)
        {
            long startPos = stream.Position;
            if (stream.Length - startPos < EOCDL64_SIZE)
            {
                return false;
            }

            BinaryReader reader = new BinaryReader(stream);
            uint sig = reader.ReadUInt32();

            if (sig != EOCDL64SIG)
            {
                return false;
            }

            this.dirStartDiskNumber = reader.ReadUInt32();
            this.dirOffset = reader.ReadInt64();
            this.totalDisks = reader.ReadUInt32();

            return true;
        }

        public void Write(Stream stream)
        {
            BinaryWriter writer = new BinaryWriter(stream);
            writer.Write(EOCDL64SIG);
            writer.Write(this.dirStartDiskNumber);
            writer.Write(this.dirOffset);
            writer.Write(this.totalDisks);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Compression\ArchiveFileStreamContext.cs ===
//---------------------------------------------------------------------
// <copyright file="ArchiveFileStreamContext.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
    using System;
    using System.IO;
    using System.Collections.Generic;

    /// <summary>
    /// Provides a basic implementation of the archive pack and unpack stream context
    /// interfaces, based on a list of archive files, a default directory, and an
    /// optional mapping from internal to external file paths.
    /// </summary>
    /// <remarks>
    /// This class can also handle creating or extracting chained archive packages.
    /// </remarks>
    public class ArchiveFileStreamContext
        : IPackStreamContext, IUnpackStreamContext
    {
        private IList<string> archiveFiles;
        private string directory;
        private IDictionary<string, string> files;
        private bool extractOnlyNewerFiles;
        private bool enableOffsetOpen;

        #region Constructors

        /// <summary>
        /// Creates a new ArchiveFileStreamContext with a archive file and
        /// no default directory or file mapping.
        /// </summary>
        /// <param name="archiveFile">The path to a archive file that will be
        /// created or extracted.</param>
        public ArchiveFileStreamContext(string archiveFile)
            : this(archiveFile, null, null)
        {
        }

        /// <summary>
        /// Creates a new ArchiveFileStreamContext with a archive file, default
        /// directory and mapping from internal to external file paths.
        /// </summary>
        /// <param name="archiveFile">The path to a archive file that will be
        /// created or extracted.</param>
        /// <param name="directory">The default root directory where files will be
        /// located, optional.</param>
        /// <param name="files">A mapping from internal file paths to external file
        /// paths, optional.</param>
        /// <remarks>
        /// If the mapping is not null and a file is not included in the mapping,
        /// the file will be skipped.
        /// <para>If the external path in the mapping is a simple file name or
        /// relative file path, it will be concatenated onto the default directory,
        /// if one was specified.</para>
        /// <para>For more about how the default directory and files mapping are
        /// used, see <see cref="OpenFileReadStream"/> and
        /// <see cref="OpenFileWriteStream"/>.</para>
        /// </remarks>
        public ArchiveFileStreamContext(
            string archiveFile,
            string directory,
            IDictionary<string, string> files)
            : this(new string[] { archiveFile }, directory, files)
        {
            if (archiveFile == null)
            {
                throw new ArgumentNullException("archiveFile");
            }
        }

        /// <summary>
        /// Creates a new ArchiveFileStreamContext with a list of archive files,
        /// a default directory and a mapping from internal to external file paths.
        /// </summary>
        /// <param name="archiveFiles">A list of paths to archive files that will be
        /// created or extracted.</param>
        /// <param name="directory">The default root directory where files will be
        /// located, optional.</param>
        /// <param name="files">A mapping from internal file paths to external file
        /// paths, optional.</param>
        /// <remarks>
        /// When creating chained archives, the <paramref name="archiveFiles"/> list
        /// should include at least enough archives to handle the entire set of
        /// input files, based on the maximum archive size that is passed to the
        /// <see cref="CompressionEngine"/>.<see
        /// cref="CompressionEngine.Pack(IPackStreamContext,IEnumerable&lt;string&gt;,long)"/>.
        /// <para>If the mapping is not null and a file is not included in the mapping,
        /// the file will be skipped.</para>
        /// <para>If the external path in the mapping is a simple file name or
        /// relative file path, it will be concatenated onto the default directory,
        /// if one was specified.</para>
        /// <para>For more about how the default directory and files mapping are used,
        /// see <see cref="OpenFileReadStream"/> and
        /// <see cref="OpenFileWriteStream"/>.</para>
        /// </remarks>
        public ArchiveFileStreamContext(
            IList<string> archiveFiles,
            string directory,
            IDictionary<string, string> files)
        {
            if (archiveFiles == null || archiveFiles.Count == 0)
            {
                throw new ArgumentNullException("archiveFiles");
            }

            this.archiveFiles = archiveFiles;
            this.directory = directory;
            this.files = files;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Gets or sets the list of archive files that are created or extracted.
        /// </summary>
        /// <value>The list of archive files that are created or extracted.</value>
        public IList<string> ArchiveFiles
        {
            get
            {
                return this.archiveFiles;
            }
        }

        /// <summary>
        /// Gets or sets the default root directory where files are located.
        /// </summary>
        /// <value>The default root directory where files are located.</value>
        /// <remarks>
        /// For details about how the default directory is used,
        /// see <see cref="OpenFileReadStream"/> and <see cref="OpenFileWriteStream"/>.
        /// </remarks>
        public string Directory
        {
            get
            {
                return this.directory;
            }
        }

        /// <summary>
        /// Gets or sets the mapping from internal file paths to external file paths.
        /// </summary>
        /// <value>A mapping from internal file paths to external file paths.</value>
        /// <remarks>
        /// For details about how the files mapping is used,
        /// see <see cref="OpenFileReadStream"/> and <see cref="OpenFileWriteStream"/>.
        /// </remarks>
        public IDictionary<string, string> Files
        {
            get
            {
                return this.files;
            }
        }

        /// <summary>
        /// Gets or sets a flag that can prevent extracted files from overwriting
        /// newer files that already exist.
        /// </summary>
        /// <value>True to prevent overwriting newer files that already exist
        /// during extraction; false to always extract from the archive regardless
        /// of existing files.</value>
        public bool ExtractOnlyNewerFiles
        {
            get
            {
                return this.extractOnlyNewerFiles;
            }

            set
            {
                this.extractOnlyNewerFiles = value;
            }
        }

        /// <summary>
        /// Gets or sets a flag that enables creating or extracting an archive
        /// at an offset within an existing file. (This is typically used to open
        /// archive-based self-extracting packages.)
        /// </summary>
        /// <value>True to search an existing package file for an archive offset
        /// or the end of the file;/ false to always create or open a plain
        /// archive file.</value>
        public bool EnableOffsetOpen
        {
            get
            {
                return this.enableOffsetOpen;
            }

            set
            {
                this.enableOffsetOpen = value;
            }
        }

        #endregion

        #region IPackStreamContext Members

        /// <summary>
        /// Gets the name of the archive with a specified number.
        /// </summary>
        /// <param name="archiveNumber">The 0-based index of the archive within
        /// the chain.</param>
        /// <returns>The name of the requested archive. May be an empty string
        /// for non-chained archives, but may never be null.</returns>
        /// <remarks>This method returns the file name of the archive from the
        /// <see cref="archiveFiles"/> list with the specified index, or an empty
        /// string if the archive number is outside the bounds of the list. The
        /// file name should not include any directory path.</remarks>
        public virtual string GetArchiveName(int archiveNumber)
        {
            if (archiveNumber < this.archiveFiles.Count)
            {
                return Path.GetFileName(this.archiveFiles[archiveNumber]);
            }

            return String.Empty;
        }

        /// <summary>
        /// Opens a stream for writing an archive.
        /// </summary>
        /// <param name="archiveNumber">The 0-based index of the archive within
        /// the chain.</param>
        /// <param name="archiveName">The name of the archive that was returned
        /// by <see cref="GetArchiveName"/>.</param>
        /// <param name="truncate">True if the stream should be truncated when
        /// opened (if it already exists); false if an existing stream is being
        /// re-opened for writing additional data.</param>
        /// <param name="compressionEngine">Instance of the compression engine
        /// doing the operations.</param>
        /// <returns>A writable Stream where the compressed archive bytes will be
        /// written, or null to cancel the archive creation.</returns>
        /// <remarks>
        /// This method opens the file from the <see cref="ArchiveFiles"/> list
        /// with the specified index. If the archive number is outside the bounds
        /// of the list, this method returns null.
        /// <para>If the <see cref="EnableOffsetOpen"/> flag is set, this method
        /// will seek to the start of any existing archive in the file, or to the
        /// end of the file if the existing file is not an archive.</para>
        /// </remarks>
        public virtual Stream OpenArchiveWriteStream(
            int archiveNumber,
            string archiveName,
            bool truncate,
            CompressionEngine compressionEngine)
        {
            if (archiveNumber >= this.archiveFiles.Count)
            {
                return null;
            }

            if (String.IsNullOrEmpty(archiveName))
            {
                throw new ArgumentNullException("archiveName");
            }

            // All archives must be in the same directory,
            // so always use the directory from the first archive.
            string archiveFile = Path.Combine(
                Path.GetDirectoryName(this.archiveFiles[0]), archiveName);
            Stream stream = File.Open(
                archiveFile,
                (truncate ? FileMode.OpenOrCreate : FileMode.Open),
                FileAccess.ReadWrite);

            if (this.enableOffsetOpen)
            {
                long offset = compressionEngine.FindArchiveOffset(
                    new DuplicateStream(stream));

                // If this is not an archive file, append the archive to it.
                if (offset < 0)
                {
                    offset = stream.Length;
                }

                if (offset > 0)
                {
                    stream = new OffsetStream(stream, offset);
                }

                stream.Seek(0, SeekOrigin.Begin);
            }

            if (truncate)
            {
                // Truncate the stream, in case a larger old archive starts here.
                stream.SetLength(0);
            }
            
            return stream;
        }

        /// <summary>
        /// Closes a stream where an archive package was written.
        /// </summary>
        /// <param name="archiveNumber">The 0-based index of the archive within
        /// the chain.</param>
        /// <param name="archiveName">The name of the archive that was previously
        /// returned by <see cref="GetArchiveName"/>.</param>
        /// <param name="stream">A stream that was previously returned by
        /// <see cref="OpenArchiveWriteStream"/> and is now ready to be closed.</param>
        public virtual void CloseArchiveWriteStream(
            int archiveNumber,
            string archiveName,
            Stream stream)
        {
            if (stream != null)
            {
                stream.Close();

                FileStream fileStream = stream as FileStream;
                if (fileStream != null)
                {
                    string streamFile = fileStream.Name;
                    if (!String.IsNullOrEmpty(archiveName) &&
                        archiveName != Path.GetFileName(streamFile))
                    {
                        string archiveFile = Path.Combine(
                            Path.GetDirectoryName(this.archiveFiles[0]), archiveName);
                        if (File.Exists(archiveFile))
                        {
                            File.Delete(archiveFile);
                        }
                        File.Move(streamFile, archiveFile);
                    }
                }
            }
        }

        /// <summary>
        /// Opens a stream to read a file that is to be included in an archive.
        /// </summary>
        /// <param name="path">The path of the file within the archive.</param>
        /// <param name="attributes">The returned attributes of the opened file,
        /// to be stored in the archive.</param>
        /// <param name="lastWriteTime">The returned last-modified time of the
        /// opened file, to be stored in the archive.</param>
        /// <returns>A readable Stream where the file bytes will be read from
        /// before they are compressed, or null to skip inclusion of the file and
        /// continue to the next file.</returns>
        /// <remarks>
        /// This method opens a file using the following logic:
        /// <list>
        /// <item>If the <see cref="Directory"/> and the <see cref="Files"/> mapping
        /// are both null, the path is treated as relative to the current directory,
        /// and that file is opened.</item>
        /// <item>If the <see cref="Directory"/> is not null but the <see cref="Files"/>
        /// mapping is null, the path is treated as relative to that directory, and
        /// that file is opened.</item>
        /// <item>If the <see cref="Directory"/> is null but the <see cref="Files"/>
        /// mapping is not null, the path parameter is used as a key into the mapping,
        /// and the resulting value is the file path that is opened, relative to the
        /// current directory (or it may be an absolute path). If no mapping exists,
        /// the file is skipped.</item>
        /// <item>If both the <see cref="Directory"/> and the <see cref="Files"/>
        /// mapping are specified, the path parameter is used as a key into the
        /// mapping, and the resulting value is the file path that is opened, relative
        /// to the specified directory (or it may be an absolute path). If no mapping
        /// exists, the file is skipped.</item>
        /// </list>
        /// </remarks>
        public virtual Stream OpenFileReadStream(
            string path, out FileAttributes attributes, out DateTime lastWriteTime)
        {
            string filePath = this.TranslateFilePath(path);

            if (filePath == null)
            {
                attributes = FileAttributes.Normal;
                lastWriteTime = DateTime.Now;
                return null;
            }

            attributes = File.GetAttributes(filePath);
            lastWriteTime = File.GetLastWriteTime(filePath);
            return File.Open(filePath, FileMode.Open, FileAccess.Read, FileShare.Read);
        }

        /// <summary>
        /// Closes a stream that has been used to read a file.
        /// </summary>
        /// <param name="path">The path of the file within the archive; the same as
        /// the path provided when the stream was opened.</param>
        /// <param name="stream">A stream that was previously returned by
        /// <see cref="OpenFileReadStream"/> and is now ready to be closed.</param>
        public virtual void CloseFileReadStream(string path, Stream stream)
        {
            if (stream != null)
            {
                stream.Close();
            }
        }

        /// <summary>
        /// Gets extended parameter information specific to the compression format
        /// being used.
        /// </summary>
        /// <param name="optionName">Name of the option being requested.</param>
        /// <param name="parameters">Parameters for the option; for per-file options,
        /// the first parameter is typically the internal file path.</param>
        /// <returns>Option value, or null to use the default behavior.</returns>
        /// <remarks>
        /// This implementation does not handle any options. Subclasses may override
        /// this method to allow for non-default behavior.
        /// </remarks>
        public virtual object GetOption(string optionName, object[] parameters)
        {
            return null;
        }

        #endregion

        #region IUnpackStreamContext Members

        /// <summary>
        /// Opens the archive stream for reading.
        /// </summary>
        /// <param name="archiveNumber">The zero-based index of the archive to
        /// open.</param>
        /// <param name="archiveName">The name of the archive being opened.</param>
        /// <param name="compressionEngine">Instance of the compression engine
        /// doing the operations.</param>
        /// <returns>A stream from which archive bytes are read, or null to cancel
        /// extraction of the archive.</returns>
        /// <remarks>
        /// This method opens the file from the <see cref="ArchiveFiles"/> list with
        /// the specified index. If the archive number is outside the bounds of the
        /// list, this method returns null.
        /// <para>If the <see cref="EnableOffsetOpen"/> flag is set, this method will
        /// seek to the start of any existing archive in the file, or to the end of
        /// the file if the existing file is not an archive.</para>
        /// </remarks>
        public virtual Stream OpenArchiveReadStream(
            int archiveNumber, string archiveName, CompressionEngine compressionEngine)
        {
            if (archiveNumber >= this.archiveFiles.Count)
            {
                return null;
            }

            string archiveFile = this.archiveFiles[archiveNumber];
            Stream stream = File.Open(
                archiveFile, FileMode.Open, FileAccess.Read, FileShare.Read);

            if (this.enableOffsetOpen)
            {
                long offset = compressionEngine.FindArchiveOffset(
                    new DuplicateStream(stream));
                if (offset > 0)
                {
                    stream = new OffsetStream(stream, offset);
                }
                else
                {
                    stream.Seek(0, SeekOrigin.Begin);
                }
            }

            return stream;
        }

        /// <summary>
        /// Closes a stream where an archive was read.
        /// </summary>
        /// <param name="archiveNumber">The archive number of the stream
        /// to close.</param>
        /// <param name="archiveName">The name of the archive being closed.</param>
        /// <param name="stream">The stream that was previously returned by
        /// <see cref="OpenArchiveReadStream"/> and is now ready to be closed.</param>
        public virtual void CloseArchiveReadStream(
            int archiveNumber, string archiveName, Stream stream)
        {
            if (stream != null)
            {
                stream.Close();
            }
        }

        /// <summary>
        /// Opens a stream for writing extracted file bytes.
        /// </summary>
        /// <param name="path">The path of the file within the archive.</param>
        /// <param name="fileSize">The uncompressed size of the file to be
        /// extracted.</param>
        /// <param name="lastWriteTime">The last write time of the file to be
        /// extracted.</param>
        /// <returns>A stream where extracted file bytes are to be written, or null
        /// to skip extraction of the file and continue to the next file.</returns>
        /// <remarks>
        /// This method opens a file using the following logic:
        /// <list>
        /// <item>If the <see cref="Directory"/> and the <see cref="Files"/> mapping
        /// are both null, the path is treated as relative to the current directory,
        /// and that file is opened.</item>
        /// <item>If the <see cref="Directory"/> is not null but the <see cref="Files"/>
        /// mapping is null, the path is treated as relative to that directory, and
        /// that file is opened.</item>
        /// <item>If the <see cref="Directory"/> is null but the <see cref="Files"/>
        /// mapping is not null, the path parameter is used as a key into the mapping,
        /// and the resulting value is the file path that is opened, relative to the
        /// current directory (or it may be an absolute path). If no mapping exists,
        /// the file is skipped.</item>
        /// <item>If both the <see cref="Directory"/> and the <see cref="Files"/>
        /// mapping are specified, the path parameter is used as a key into the
        /// mapping, and the resulting value is the file path that is opened,
        /// relative to the specified directory (or it may be an absolute path).
        /// If no mapping exists, the file is skipped.</item>
        /// </list>
        /// <para>If the <see cref="ExtractOnlyNewerFiles"/> flag is set, the file
        /// is skipped if a file currently exists in the same path with an equal
        /// or newer write time.</para>
        /// </remarks>
        public virtual Stream OpenFileWriteStream(
            string path,
            long fileSize,
            DateTime lastWriteTime)
        {
            string filePath = this.TranslateFilePath(path);

            if (filePath == null)
            {
                return null;
            }

            FileInfo file = new FileInfo(filePath);
            if (file.Exists)
            {
                if (this.extractOnlyNewerFiles && lastWriteTime != DateTime.MinValue)
                {
                    if (file.LastWriteTime >= lastWriteTime)
                    {
                        return null;
                    }
                }

                if ((file.Attributes & FileAttributes.ReadOnly) != 0)
                {
                    file.Attributes &= ~FileAttributes.ReadOnly;
                }
            }

            if (!file.Directory.Exists)
            {
                file.Directory.Create();
            }

            return File.Open(
                filePath, FileMode.Create, FileAccess.Write, FileShare.None);
        }

        /// <summary>
        /// Closes a stream where an extracted file was written.
        /// </summary>
        /// <param name="path">The path of the file within the archive.</param>
        /// <param name="stream">The stream that was previously returned by
        /// <see cref="OpenFileWriteStream"/> and is now ready to be closed.</param>
        /// <param name="attributes">The attributes of the extracted file.</param>
        /// <param name="lastWriteTime">The last write time of the file.</param>
        /// <remarks>
        /// After closing the extracted file stream, this method applies the date
        /// and attributes to that file.
        /// </remarks>
        public virtual void CloseFileWriteStream(
            string path,
            Stream stream,
            FileAttributes attributes,
            DateTime lastWriteTime)
        {
            if (stream != null)
            {
                stream.Close();
            }

            string filePath = this.TranslateFilePath(path);
            if (filePath != null)
            {
                FileInfo file = new FileInfo(filePath);

                if (lastWriteTime != DateTime.MinValue)
                {
                    try
                    {
                        file.LastWriteTime = lastWriteTime;
                    }
                    catch (ArgumentException)
                    {
                    }
                    catch (IOException)
                    {
                    }
                }

                try
                {
                    file.Attributes = attributes;
                }
                catch (IOException)
                {
                }
            }
        }

        #endregion

        #region Private utility methods

        /// <summary>
        /// Translates an internal file path to an external file path using the
        /// <see cref="Directory"/> and the <see cref="Files"/> mapping, according to
        /// rules documented in <see cref="OpenFileReadStream"/> and
        /// <see cref="OpenFileWriteStream"/>.
        /// </summary>
        /// <param name="path">The path of the file with the archive.</param>
        /// <returns>The external path of the file, or null if there is no
        /// valid translation.</returns>
        private string TranslateFilePath(string path)
        {
            string filePath;
            if (this.files != null)
            {
                filePath = this.files[path];
            }
            else
            {
                filePath = path;
            }

            if (filePath != null)
            {
                if (this.directory != null)
                {
                    filePath = Path.Combine(this.directory, filePath);
                }
            }

            return filePath;
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Compression\ArchiveProgressType.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ArchiveProgressType.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
using System;
using System.Collections.Generic;
using System.Text;

    /// <summary>
    /// The type of progress event.
    /// </summary>
    /// <remarks>
    /// <p>PACKING EXAMPLE: The following sequence of events might be received when
    /// extracting a simple archive file with 2 files.</p>
    /// <list type="table">
    /// <listheader><term>Message Type</term><description>Description</description></listheader>
    /// <item><term>StartArchive</term> <description>Begin extracting archive</description></item>
    /// <item><term>StartFile</term>    <description>Begin extracting first file</description></item>
    /// <item><term>PartialFile</term>  <description>Extracting first file</description></item>
    /// <item><term>PartialFile</term>  <description>Extracting first file</description></item>
    /// <item><term>FinishFile</term>   <description>Finished extracting first file</description></item>
    /// <item><term>StartFile</term>    <description>Begin extracting second file</description></item>
    /// <item><term>PartialFile</term>  <description>Extracting second file</description></item>
    /// <item><term>FinishFile</term>   <description>Finished extracting second file</description></item>
    /// <item><term>FinishArchive</term><description>Finished extracting archive</description></item>
    /// </list>
    /// <p></p>
    /// <p>UNPACKING EXAMPLE:  Packing 3 files into 2 archive chunks, where the second file is
    ///	continued to the second archive chunk.</p>
    /// <list type="table">
    /// <listheader><term>Message Type</term><description>Description</description></listheader>
    /// <item><term>StartFile</term>     <description>Begin compressing first file</description></item>
    /// <item><term>FinishFile</term>    <description>Finished compressing first file</description></item>
    /// <item><term>StartFile</term>     <description>Begin compressing second file</description></item>
    /// <item><term>PartialFile</term>   <description>Compressing second file</description></item>
    /// <item><term>PartialFile</term>   <description>Compressing second file</description></item>
    /// <item><term>FinishFile</term>    <description>Finished compressing second file</description></item>
    /// <item><term>StartArchive</term>  <description>Begin writing first archive</description></item>
    /// <item><term>PartialArchive</term><description>Writing first archive</description></item>
    /// <item><term>FinishArchive</term> <description>Finished writing first archive</description></item>
    /// <item><term>StartFile</term>     <description>Begin compressing third file</description></item>
    /// <item><term>PartialFile</term>   <description>Compressing third file</description></item>
    /// <item><term>FinishFile</term>    <description>Finished compressing third file</description></item>
    /// <item><term>StartArchive</term>  <description>Begin writing second archive</description></item>
    /// <item><term>PartialArchive</term><description>Writing second archive</description></item>
    /// <item><term>FinishArchive</term> <description>Finished writing second archive</description></item>
    /// </list>
    /// </remarks>
    public enum ArchiveProgressType : int
    {
        /// <summary>Status message before beginning the packing or unpacking an individual file.</summary>
        StartFile,

        /// <summary>Status message (possibly reported multiple times) during the process of packing or unpacking a file.</summary>
        PartialFile,

        /// <summary>Status message after completion of the packing or unpacking an individual file.</summary>
        FinishFile,

        /// <summary>Status message before beginning the packing or unpacking an archive.</summary>
        StartArchive,

        /// <summary>Status message (possibly reported multiple times) during the process of packing or unpacking an archiv.</summary>
        PartialArchive,

        /// <summary>Status message after completion of the packing or unpacking of an archive.</summary>
        FinishArchive,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Compression\BasicUnpackStreamContext.cs ===
//---------------------------------------------------------------------
// <copyright file="BasicUnpackStreamContext.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
    using System;
    using System.IO;
    using System.Diagnostics.CodeAnalysis;

    /// <summary>
    /// Stream context used to extract a single file from an archive into a memory stream.
    /// </summary>
    [SuppressMessage("Microsoft.Design", "CA1001:TypesThatOwnDisposableFieldsShouldBeDisposable")]
    public class BasicUnpackStreamContext : IUnpackStreamContext
    {
        private Stream archiveStream;
        private Stream fileStream;

        /// <summary>
        /// Creates a new BasicExtractStreamContext that reads from the specified archive stream.
        /// </summary>
        /// <param name="archiveStream">Archive stream to read from.</param>
        public BasicUnpackStreamContext(Stream archiveStream)
        {
            this.archiveStream = archiveStream;
        }

        /// <summary>
        /// Gets the stream for the extracted file, or null if no file was extracted.
        /// </summary>
        public Stream FileStream
        {
            get
            {
                return this.fileStream;
            }
        }

        /// <summary>
        /// Opens the archive stream for reading. Returns a DuplicateStream instance,
        /// so the stream may be virtually opened multiple times.
        /// </summary>
        /// <param name="archiveNumber">The archive number to open (ignored; 0 is assumed).</param>
        /// <param name="archiveName">The name of the archive being opened.</param>
        /// <param name="compressionEngine">Instance of the compression engine doing the operations.</param>
        /// <returns>A stream from which archive bytes are read.</returns>
        public Stream OpenArchiveReadStream(int archiveNumber, string archiveName, CompressionEngine compressionEngine)
        {
            return new DuplicateStream(this.archiveStream);
        }

        /// <summary>
        /// Does *not* close the stream. The archive stream should be managed by
        /// the code that invokes the archive extraction.
        /// </summary>
        /// <param name="archiveNumber">The archive number of the stream to close.</param>
        /// <param name="archiveName">The name of the archive being closed.</param>
        /// <param name="stream">The stream being closed.</param>
        public void CloseArchiveReadStream(int archiveNumber, string archiveName, Stream stream)
        {
            // Do nothing.
        }

        /// <summary>
        /// Opens a stream for writing extracted file bytes. The returned stream is a MemoryStream
        /// instance, so the file is extracted straight into memory.
        /// </summary>
        /// <param name="path">Path of the file within the archive.</param>
        /// <param name="fileSize">The uncompressed size of the file to be extracted.</param>
        /// <param name="lastWriteTime">The last write time of the file.</param>
        /// <returns>A stream where extracted file bytes are to be written.</returns>
        public Stream OpenFileWriteStream(string path, long fileSize, DateTime lastWriteTime)
        {
            this.fileStream = new MemoryStream(new byte[fileSize], 0, (int) fileSize, true, true);
            return this.fileStream;
        }

        /// <summary>
        /// Does *not* close the file stream. The file stream is saved in memory so it can
        /// be read later.
        /// </summary>
        /// <param name="path">Path of the file within the archive.</param>
        /// <param name="stream">The file stream to be closed.</param>
        /// <param name="attributes">The attributes of the extracted file.</param>
        /// <param name="lastWriteTime">The last write time of the file.</param>
        public void CloseFileWriteStream(string path, Stream stream, FileAttributes attributes, DateTime lastWriteTime)
        {
            // Do nothing.
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Compression\CompressionLevel.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="CompressionLevel.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
using System;
using System.Collections.Generic;
using System.Text;

    /// <summary>
    /// Specifies the compression level ranging from minimum compresion to
    /// maximum compression, or no compression at all.
    /// </summary>
    /// <remarks>
    /// Although only four values are enumerated, any integral value between
    /// <see cref="CompressionLevel.Min"/> and <see cref="CompressionLevel.Max"/> can also be used.
    /// </remarks>
    public enum CompressionLevel
    {
        /// <summary>Do not compress files, only store.</summary>
        None = 0,

        /// <summary>Minimum compression; fastest.</summary>
        Min = 1,

        /// <summary>A compromize between speed and compression efficiency.</summary>
        Normal = 6,

        /// <summary>Maximum compression; slowest.</summary>
        Max = 10
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Compression\DuplicateStream.cs ===
//---------------------------------------------------------------------
// <copyright file="DuplicateStream.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
    using System;
    using System.IO;

    /// <summary>
    /// Duplicates a source stream by maintaining a separate position.
    /// </summary>
    /// <remarks>
    /// WARNING: duplicate streams are not thread-safe with respect to each other or the original stream.
    /// If multiple threads use duplicate copies of the same stream, they must synchronize for any operations.
    /// </remarks>
    public class DuplicateStream : Stream
    {
        private Stream source;
        private long position;

        /// <summary>
        /// Creates a new duplicate of a stream.
        /// </summary>
        /// <param name="source">source of the duplicate</param>
        public DuplicateStream(Stream source)
        {
            if (source == null)
            {
                throw new ArgumentNullException("source");
            }

            this.source = DuplicateStream.OriginalStream(source);
        }

        /// <summary>
        /// Gets the original stream that was used to create the duplicate.
        /// </summary>
        public Stream Source
        {
            get
            {
                return this.source;
            }
        }

        /// <summary>
        /// Gets a value indicating whether the source stream supports reading.
        /// </summary>
        /// <value>true if the stream supports reading; otherwise, false.</value>
        public override bool CanRead
        {
            get
            {
                return this.source.CanRead;
            }
        }

        /// <summary>
        /// Gets a value indicating whether the source stream supports writing.
        /// </summary>
        /// <value>true if the stream supports writing; otherwise, false.</value>
        public override bool CanWrite
        {
            get
            {
                return this.source.CanWrite;
            }
        }

        /// <summary>
        /// Gets a value indicating whether the source stream supports seeking.
        /// </summary>
        /// <value>true if the stream supports seeking; otherwise, false.</value>
        public override bool CanSeek
        {
            get
            {
                return this.source.CanSeek;
            }
        }

        /// <summary>
        /// Gets the length of the source stream.
        /// </summary>
        public override long Length
        {
            get
            {
                return this.source.Length;
            }
        }

        /// <summary>
        /// Gets or sets the position of the current stream,
        /// ignoring the position of the source stream.
        /// </summary>
        public override long Position
        {
            get
            {
                return this.position;
            }

            set
            {
                this.position = value;
            }
        }

        /// <summary>
        /// Retrieves the original stream from a possible duplicate stream.
        /// </summary>
        /// <param name="stream">Possible duplicate stream.</param>
        /// <returns>If the stream is a DuplicateStream, returns
        /// the duplicate's source; otherwise returns the same stream.</returns>
        public static Stream OriginalStream(Stream stream)
        {
            DuplicateStream dupStream = stream as DuplicateStream;
            return dupStream != null ? dupStream.Source : stream;
        }

        /// <summary>
        /// Flushes the source stream.
        /// </summary>
        public override void Flush()
        {
            this.source.Flush();
        }

        /// <summary>
        /// Sets the length of the source stream.
        /// </summary>
        /// <param name="value">The desired length of the stream in bytes.</param>
        public override void SetLength(long value)
        { 
            this.source.SetLength(value);
        }

        /// <summary>
        /// Closes the underlying stream, effectively closing ALL duplicates.
        /// </summary>
        public override void Close()
        {
            this.source.Close();
        }

        /// <summary>
        /// Reads from the source stream while maintaining a separate position
        /// and not impacting the source stream's position.
        /// </summary>
        /// <param name="buffer">An array of bytes. When this method returns, the buffer
        /// contains the specified byte array with the values between offset and
        /// (offset + count - 1) replaced by the bytes read from the current source.</param>
        /// <param name="offset">The zero-based byte offset in buffer at which to begin
        /// storing the data read from the current stream.</param>
        /// <param name="count">The maximum number of bytes to be read from the current stream.</param>
        /// <returns>The total number of bytes read into the buffer. This can be less
        /// than the number of bytes requested if that many bytes are not currently available,
        /// or zero (0) if the end of the stream has been reached.</returns>
        public override int Read(byte[] buffer, int offset, int count)
        {
            long saveSourcePosition = this.source.Position;
            this.source.Position = this.position;
            int read = this.source.Read(buffer, offset, count);
            this.position = this.source.Position;
            this.source.Position = saveSourcePosition;
            return read;
        }

        /// <summary>
        /// Writes to the source stream while maintaining a separate position
        /// and not impacting the source stream's position.
        /// </summary>
        /// <param name="buffer">An array of bytes. This method copies count
        /// bytes from buffer to the current stream.</param>
        /// <param name="offset">The zero-based byte offset in buffer at which
        /// to begin copying bytes to the current stream.</param>
        /// <param name="count">The number of bytes to be written to the
        /// current stream.</param>
        public override void Write(byte[] buffer, int offset, int count)
        {
            long saveSourcePosition = this.source.Position;
            this.source.Position = this.position;
            this.source.Write(buffer, offset, count);
            this.position = this.source.Position;
            this.source.Position = saveSourcePosition;
        }

        /// <summary>
        /// Changes the position of this stream without impacting the
        /// source stream's position.
        /// </summary>
        /// <param name="offset">A byte offset relative to the origin parameter.</param>
        /// <param name="origin">A value of type SeekOrigin indicating the reference
        /// point used to obtain the new position.</param>
        /// <returns>The new position within the current stream.</returns>
        public override long Seek(long offset, SeekOrigin origin)
        {
            long originPosition = 0;
            if (origin == SeekOrigin.Current)
            {
                originPosition = this.position;
            }
            else if (origin == SeekOrigin.End)
            {
                originPosition = this.Length;
            }

            this.position = originPosition + offset;
            return this.position;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Compression\IPackStreamContext.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="IPackStreamContext.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
    using System;
    using System.IO;
    using System.Diagnostics.CodeAnalysis;

    /// <summary>
    /// This interface provides the methods necessary for the
    /// <see cref="CompressionEngine"/> to open and close streams for archives
    /// and files. The implementor of this interface can use any kind of logic
    /// to determine what kind of streams to open and where.
    /// </summary>
    public interface IPackStreamContext
    {
        /// <summary>
        /// Gets the name of the archive with a specified number.
        /// </summary>
        /// <param name="archiveNumber">The 0-based index of the archive
        /// within the chain.</param>
        /// <returns>The name of the requested archive. May be an empty string
        /// for non-chained archives, but may never be null.</returns>
        /// <remarks>The archive name is the name stored within the archive, used for
        /// identification of the archive especially among archive chains. That
        /// name is often, but not necessarily the same as the filename of the
        /// archive package.</remarks>
        string GetArchiveName(int archiveNumber);

        /// <summary>
        /// Opens a stream for writing an archive package.
        /// </summary>
        /// <param name="archiveNumber">The 0-based index of the archive within
        /// the chain.</param>
        /// <param name="archiveName">The name of the archive that was returned
        /// by <see cref="GetArchiveName"/>.</param>
        /// <param name="truncate">True if the stream should be truncated when
        /// opened (if it already exists); false if an existing stream is being
        /// re-opened for writing additional data.</param>
        /// <param name="compressionEngine">Instance of the compression engine
        /// doing the operations.</param>
        /// <returns>A writable Stream where the compressed archive bytes will be
        /// written, or null to cancel the archive creation.</returns>
        /// <remarks>
        /// If this method returns null, the archive engine will throw a
        /// FileNotFoundException.
        /// </remarks>
        Stream OpenArchiveWriteStream(
            int archiveNumber,
            string archiveName,
            bool truncate,
            CompressionEngine compressionEngine);

        /// <summary>
        /// Closes a stream where an archive package was written.
        /// </summary>
        /// <param name="archiveNumber">The 0-based index of the archive within
        /// the chain.</param>
        /// <param name="archiveName">The name of the archive that was previously
        /// returned by
        /// <see cref="GetArchiveName"/>.</param>
        /// <param name="stream">A stream that was previously returned by
        /// <see cref="OpenArchiveWriteStream"/> and is now ready to be closed.</param>
        /// <remarks>
        /// If there is another archive package in the chain, then after this stream
        /// is closed a new stream will be opened.
        /// </remarks>
        void CloseArchiveWriteStream(int archiveNumber, string archiveName, Stream stream);

        /// <summary>
        /// Opens a stream to read a file that is to be included in an archive.
        /// </summary>
        /// <param name="path">The path of the file within the archive. This is often,
        /// but not necessarily, the same as the relative path of the file outside
        /// the archive.</param>
        /// <param name="attributes">Returned attributes of the opened file, to be
        /// stored in the archive.</param>
        /// <param name="lastWriteTime">Returned last-modified time of the opened file,
        /// to be stored in the archive.</param>
        /// <returns>A readable Stream where the file bytes will be read from before
        /// they are compressed, or null to skip inclusion of the file and continue to
        /// the next file.</returns>
        [SuppressMessage("Microsoft.Design", "CA1021:AvoidOutParameters")]
        Stream OpenFileReadStream(
            string path,
            out FileAttributes attributes,
            out DateTime lastWriteTime);

        /// <summary>
        /// Closes a stream that has been used to read a file.
        /// </summary>
        /// <param name="path">The path of the file within the archive; the same as
        /// the path provided
        /// when the stream was opened.</param>
        /// <param name="stream">A stream that was previously returned by
        /// <see cref="OpenFileReadStream"/> and is now ready to be closed.</param>
        void CloseFileReadStream(string path, Stream stream);

        /// <summary>
        /// Gets extended parameter information specific to the compression
        /// format being used.
        /// </summary>
        /// <param name="optionName">Name of the option being requested.</param>
        /// <param name="parameters">Parameters for the option; for per-file options,
        /// the first parameter is typically the internal file path.</param>
        /// <returns>Option value, or null to use the default behavior.</returns>
        /// <remarks>
        /// This method provides a way to set uncommon options during packaging, or a
        /// way to handle aspects of compression formats not supported by the base library.
        /// <para>For example, this may be used by the zip compression library to
        /// specify different compression methods/levels on a per-file basis.</para>
        /// <para>The available option names, parameters, and expected return values
        /// should be documented by each compression library.</para>
        /// </remarks>
        object GetOption(string optionName, object[] parameters);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Compression\IUnpackStreamContext.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="IUnpackStreamContext.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
    using System;
    using System.IO;

    /// <summary>
    /// This interface provides the methods necessary for the <see cref="CompressionEngine"/> to open
    /// and close streams for archives and files. The implementor of this interface can use any
    /// kind of logic to determine what kind of streams to open and where 
    /// </summary>
    public interface IUnpackStreamContext
    {
        /// <summary>
        /// Opens the archive stream for reading.
        /// </summary>
        /// <param name="archiveNumber">The zero-based index of the archive to open.</param>
        /// <param name="archiveName">The name of the archive being opened.</param>
        /// <param name="compressionEngine">Instance of the compression engine doing the operations.</param>
        /// <returns>A stream from which archive bytes are read, or null to cancel extraction
        /// of the archive.</returns>
        /// <remarks>
        /// When the first archive in a chain is opened, the name is not yet known, so the
        /// provided value will be an empty string. When opening further archives, the
        /// provided value is the next-archive name stored in the previous archive. This
        /// name is often, but not necessarily, the same as the filename of the archive
        /// package to be opened.
        /// <para>If this method returns null, the archive engine will throw a
        /// FileNotFoundException.</para>
        /// </remarks>
        Stream OpenArchiveReadStream(int archiveNumber, string archiveName, CompressionEngine compressionEngine);

        /// <summary>
        /// Closes a stream where an archive package was read.
        /// </summary>
        /// <param name="archiveNumber">The archive number of the stream to close.</param>
        /// <param name="archiveName">The name of the archive being closed.</param>
        /// <param name="stream">The stream that was previously returned by
        /// <see cref="OpenArchiveReadStream"/> and is now ready to be closed.</param>
        void CloseArchiveReadStream(int archiveNumber, string archiveName, Stream stream);

        /// <summary>
        /// Opens a stream for writing extracted file bytes.
        /// </summary>
        /// <param name="path">The path of the file within the archive. This is often, but
        /// not necessarily, the same as the relative path of the file outside the archive.</param>
        /// <param name="fileSize">The uncompressed size of the file to be extracted.</param>
        /// <param name="lastWriteTime">The last write time of the file to be extracted.</param>
        /// <returns>A stream where extracted file bytes are to be written, or null to skip
        /// extraction of the file and continue to the next file.</returns>
        /// <remarks>
        /// The implementor may use the path, size and date information to dynamically
        /// decide whether or not the file should be extracted.
        /// </remarks>
        Stream OpenFileWriteStream(string path, long fileSize, DateTime lastWriteTime);

        /// <summary>
        /// Closes a stream where an extracted file was written.
        /// </summary>
        /// <param name="path">The path of the file within the archive.</param>
        /// <param name="stream">The stream that was previously returned by <see cref="OpenFileWriteStream"/>
        /// and is now ready to be closed.</param>
        /// <param name="attributes">The attributes of the extracted file.</param>
        /// <param name="lastWriteTime">The last write time of the file.</param>
        /// <remarks>
        /// The implementor may wish to apply the attributes and date to the newly-extracted file.
        /// </remarks>
        void CloseFileWriteStream(string path, Stream stream, FileAttributes attributes, DateTime lastWriteTime);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Compression\OffsetStream.cs ===
//---------------------------------------------------------------------
// <copyright file="OffsetStream.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
    using System;
    using System.IO;

    /// <summary>
    /// Wraps a source stream and offsets all read/write/seek calls by a given value.
    /// </summary>
    /// <remarks>
    /// This class is used to trick archive an packing or unpacking process
    /// into reading or writing at an offset into a file, primarily for
    /// self-extracting packages.
    /// </remarks>
    public class OffsetStream : Stream
    {
        private Stream source;
        private long sourceOffset;

        /// <summary>
        /// Creates a new OffsetStream instance from a source stream
        /// and using a specified offset.
        /// </summary>
        /// <param name="source">Underlying stream for which all calls will be offset.</param>
        /// <param name="offset">Positive or negative number of bytes to offset.</param>
        public OffsetStream(Stream source, long offset)
        {
            if (source == null)
            {
                throw new ArgumentNullException("source");
            }

            this.source = source;
            this.sourceOffset = offset;

            this.source.Seek(this.sourceOffset, SeekOrigin.Current);
        }

        /// <summary>
        /// Gets the underlying stream that this OffsetStream calls into.
        /// </summary>
        public Stream Source
        {
            get { return this.source; }
        }

        /// <summary>
        /// Gets the number of bytes to offset all calls before
        /// redirecting to the underlying stream.
        /// </summary>
        public long Offset
        {
            get { return this.sourceOffset; }
        }

        /// <summary>
        /// Gets a value indicating whether the source stream supports reading.
        /// </summary>
        /// <value>true if the stream supports reading; otherwise, false.</value>
        public override bool CanRead
        {
            get
            {
                return this.source.CanRead;
            }
        }

        /// <summary>
        /// Gets a value indicating whether the source stream supports writing.
        /// </summary>
        /// <value>true if the stream supports writing; otherwise, false.</value>
        public override bool CanWrite
        {
            get
            {
                return this.source.CanWrite;
            }
        }

        /// <summary>
        /// Gets a value indicating whether the source stream supports seeking.
        /// </summary>
        /// <value>true if the stream supports seeking; otherwise, false.</value>
        public override bool CanSeek
        {
            get
            {
                return this.source.CanSeek;
            }
        }

        /// <summary>
        /// Gets the effective length of the stream, which is equal to
        /// the length of the source stream minus the offset.
        /// </summary>
        public override long Length
        {
            get { return this.source.Length - this.sourceOffset; } 
        }

        /// <summary>
        /// Gets or sets the effective position of the stream, which
        /// is equal to the position of the source stream minus the offset.
        /// </summary>
        public override long Position
        {
            get { return this.source.Position - this.sourceOffset; }
            set { this.source.Position = value + this.sourceOffset; }
        }

        /// <summary>
        /// Reads a sequence of bytes from the source stream and advances
        /// the position within the stream by the number of bytes read.
        /// </summary>
        /// <param name="buffer">An array of bytes. When this method returns, the buffer
        /// contains the specified byte array with the values between offset and
        /// (offset + count - 1) replaced by the bytes read from the current source.</param>
        /// <param name="offset">The zero-based byte offset in buffer at which to begin
        /// storing the data read from the current stream.</param>
        /// <param name="count">The maximum number of bytes to be read from the current stream.</param>
        /// <returns>The total number of bytes read into the buffer. This can be less
        /// than the number of bytes requested if that many bytes are not currently available,
        /// or zero (0) if the end of the stream has been reached.</returns>
        public override int Read(byte[] buffer, int offset, int count)
        {
            return this.source.Read(buffer, offset, count);
        }

        /// <summary>
        /// Writes a sequence of bytes to the source stream and advances the
        /// current position within this stream by the number of bytes written.
        /// </summary>
        /// <param name="buffer">An array of bytes. This method copies count
        /// bytes from buffer to the current stream.</param>
        /// <param name="offset">The zero-based byte offset in buffer at which
        /// to begin copying bytes to the current stream.</param>
        /// <param name="count">The number of bytes to be written to the
        /// current stream.</param>
        public override void Write(byte[] buffer, int offset, int count)
        {
            this.source.Write(buffer, offset, count);
        }

        /// <summary>
        /// Reads a byte from the stream and advances the position within the
        /// source stream by one byte, or returns -1 if at the end of the stream.
        /// </summary>
        /// <returns>The unsigned byte cast to an Int32, or -1 if at the
        /// end of the stream.</returns>
        public override int ReadByte()
        {
            return this.source.ReadByte();
        }

        /// <summary>
        /// Writes a byte to the current position in the source stream and
        /// advances the position within the stream by one byte.
        /// </summary>
        /// <param name="value">The byte to write to the stream.</param>
        public override void WriteByte(byte value)
        {
            this.source.WriteByte(value);
        }

        /// <summary>
        /// Flushes the source stream.
        /// </summary>
        public override void Flush()
        {
            this.source.Flush();
        }

        /// <summary>
        /// Sets the position within the current stream, which is
        /// equal to the position within the source stream minus the offset.
        /// </summary>
        /// <param name="offset">A byte offset relative to the origin parameter.</param>
        /// <param name="origin">A value of type SeekOrigin indicating
        /// the reference point used to obtain the new position.</param>
        /// <returns>The new position within the current stream.</returns>
        public override long Seek(long offset, SeekOrigin origin)
        {
            return this.source.Seek(offset + (origin == SeekOrigin.Begin ? this.sourceOffset : 0), origin) - this.sourceOffset;
        }

        /// <summary>
        /// Sets the effective length of the stream, which is equal to
        /// the length of the source stream minus the offset.
        /// </summary>
        /// <param name="value">The desired length of the
        /// current stream in bytes.</param>
        public override void SetLength(long value)
        {
            this.source.SetLength(value + this.sourceOffset);
        }

        /// <summary>
        /// Closes the underlying stream.
        /// </summary>
        public override void Close()
        {
            this.source.Close();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Compression\SafeNativeMethods.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="SafeNativeMethods.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
    using System;
    using System.Security;
    using System.Runtime.InteropServices;

    [SuppressUnmanagedCodeSecurity]
    internal static class SafeNativeMethods
    {
        [DllImport("kernel32.dll", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        internal static extern bool DosDateTimeToFileTime(
            short wFatDate, short wFatTime, out long fileTime);

        [DllImport("kernel32.dll", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        internal static extern bool FileTimeToDosDateTime(
            ref long fileTime, out short wFatDate, out short wFatTime);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup2\Compression.Zip\ZipEngine.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ZipEngine.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Zip
{
    using System;
    using System.IO;
    using System.IO.Compression;
    using System.Collections.Generic;
    using System.Reflection;
    using System.Diagnostics.CodeAnalysis;

    /// <summary>
    /// Engine capable of packing and unpacking archives in the zip format.
    /// </summary>
    public partial class ZipEngine : CompressionEngine
    {
        private static Dictionary<ZipCompressionMethod, Converter<Stream, Stream>>
            compressionStreamCreators;
        private static Dictionary<ZipCompressionMethod, Converter<Stream, Stream>>
            decompressionStreamCreators;

        private static void InitCompressionStreamCreators()
        {
            if (ZipEngine.compressionStreamCreators == null)
            {
                ZipEngine.compressionStreamCreators = new
                    Dictionary<ZipCompressionMethod, Converter<Stream, Stream>>();
                ZipEngine.decompressionStreamCreators = new
                    Dictionary<ZipCompressionMethod, Converter<Stream, Stream>>();

                ZipEngine.RegisterCompressionStreamCreator(
                    ZipCompressionMethod.Store,
                    CompressionMode.Compress,
                    delegate(Stream stream) {
                        return stream;
                    });
                ZipEngine.RegisterCompressionStreamCreator(
                    ZipCompressionMethod.Deflate,
                    CompressionMode.Compress,
                    delegate(Stream stream) {
                        return new DeflateStream(stream, CompressionMode.Compress, true);
                    });
                ZipEngine.RegisterCompressionStreamCreator(
                    ZipCompressionMethod.Store,
                    CompressionMode.Decompress,
                    delegate(Stream stream) {
                        return stream;
                    });
                ZipEngine.RegisterCompressionStreamCreator(
                    ZipCompressionMethod.Deflate,
                    CompressionMode.Decompress,
                    delegate(Stream stream) {
                        return new DeflateStream(stream, CompressionMode.Decompress, true);
                    });
            }
        }

        /// <summary>
        /// Registers a delegate that can create a warpper stream for
        /// compressing or uncompressing the data of a source stream.
        /// </summary>
        /// <param name="compressionMethod">Compression method being registered.</param>
        /// <param name="compressionMode">Indicates registration for ether
        /// compress or decompress mode.</param>
        /// <param name="creator">Delegate being registered.</param>
        /// <remarks>
        /// For compression, the delegate accepts a stream that writes to the archive
        /// and returns a wrapper stream that compresses bytes as they are written.
        /// For decompression, the delegate accepts a stream that reads from the archive
        /// and returns a wrapper stream that decompresses bytes as they are read.
        /// This wrapper stream model follows the design used by
        /// System.IO.Compression.DeflateStream, and indeed that class is used
        /// to implement the Deflate compression method by default.
        /// <para>To unregister a delegate, call this method again and pass
        /// null for the delegate parameter.</para>
        /// </remarks>
        /// <example>
        /// When the ZipEngine class is initialized, the Deflate compression method
        /// is automatically registered like this:
        /// <code>
        ///        ZipEngine.RegisterCompressionStreamCreator(
        ///            ZipCompressionMethod.Deflate,
        ///            CompressionMode.Compress,
        ///            delegate(Stream stream) {
        ///                return new DeflateStream(stream, CompressionMode.Compress, true);
        ///            });
        ///        ZipEngine.RegisterCompressionStreamCreator(
        ///            ZipCompressionMethod.Deflate,
        ///            CompressionMode.Decompress,
        ///            delegate(Stream stream) {
        ///                return new DeflateStream(stream, CompressionMode.Decompress, true);
        ///            });
        /// </code></example>
        public static void RegisterCompressionStreamCreator(
            ZipCompressionMethod compressionMethod,
            CompressionMode compressionMode,
            Converter<Stream, Stream> creator)
        {
            ZipEngine.InitCompressionStreamCreators();
            if (compressionMode == CompressionMode.Compress)
            {
                ZipEngine.compressionStreamCreators[compressionMethod] = creator;
            }
            else
            {
                ZipEngine.decompressionStreamCreators[compressionMethod] = creator;
            }
        }

        // Progress data
        private string currentFileName;
        private int currentFileNumber;
        private int totalFiles;
        private long currentFileBytesProcessed;
        private long currentFileTotalBytes;
        private string mainArchiveName;
        private string currentArchiveName;
        private short currentArchiveNumber;
        private short totalArchives;
        private long currentArchiveBytesProcessed;
        private long currentArchiveTotalBytes;
        private long fileBytesProcessed;
        private long totalFileBytes;
        private string comment;

        /// <summary>
        /// Creates a new instance of the zip engine.
        /// </summary>
        public ZipEngine()
            : base()
        {
            ZipEngine.InitCompressionStreamCreators();
        }

        /// <summary>
        /// Gets the comment from the last-examined archive,
        /// or sets the comment to be added to any created archives.
        /// </summary>
        public string ArchiveComment
        {
            get
            {
                return this.comment;
            }
            set
            {
                this.comment = value;
            }
        }

        /// <summary>
        /// Checks whether a Stream begins with a header that indicates
        /// it is a valid archive file.
        /// </summary>
        /// <param name="stream">Stream for reading the archive file.</param>
        /// <returns>True if the stream is a valid zip archive
        /// (with no offset); false otherwise.</returns>
        public override bool IsArchive(Stream stream)
        {
            if (stream == null)
            {
                throw new ArgumentNullException("stream");
            }

            if (stream.Length - stream.Position < 4)
            {
                return false;
            }

            BinaryReader reader = new BinaryReader(stream);
            uint sig = reader.ReadUInt32();
            switch (sig)
            {
                case ZipFileHeader.LFHSIG:
                case ZipEndOfCentralDirectory.EOCDSIG:
                case ZipEndOfCentralDirectory.EOCD64SIG:
                case ZipFileHeader.SPANSIG:
                case ZipFileHeader.SPANSIG2:
                    return true;
                default:
                    return false;
            }
        }

        /// <summary>
        /// Gets the offset of an archive that is positioned 0 or more bytes
        /// from the start of the Stream.
        /// </summary>
        /// <param name="stream">A stream for reading the archive.</param>
        /// <returns>The offset in bytes of the archive,
        /// or -1 if no archive is found in the Stream.</returns>
        /// <remarks>The archive must begin on a 4-byte boundary.</remarks>
        public override long FindArchiveOffset(Stream stream)
        {
            long offset = base.FindArchiveOffset(stream);
            if (offset > 0)
            {
                // Some self-extract packages include the exe stub in file offset calculations.
                // Check the first header directory offset to decide whether the entire
                // archive needs to be offset or not.

                ZipEndOfCentralDirectory eocd = this.GetEOCD(null, stream);
                if (eocd != null && eocd.totalEntries > 0)
                {
                    stream.Seek(eocd.dirOffset, SeekOrigin.Begin);

                    ZipFileHeader header = new ZipFileHeader();
                    if (header.Read(stream, true) && header.localHeaderOffset < stream.Length)
                    {
                        stream.Seek(header.localHeaderOffset, SeekOrigin.Begin);
                        if (header.Read(stream, false))
                        {
                            return 0;
                        }
                    }
                }
            }

            return offset;
        }

        /// <summary>
        /// Gets information about files in a zip archive or archive chain.
        /// </summary>
        /// <param name="streamContext">A context interface to handle opening
        /// and closing of archive and file streams.</param>
        /// <param name="fileFilter">A predicate that can determine
        /// which files to process, optional.</param>
        /// <returns>Information about files in the archive stream.</returns>
        /// <exception cref="ArchiveException">The archive provided
        /// by the stream context is not valid.</exception>
        /// <remarks>
        /// The <paramref name="fileFilter"/> predicate takes an internal file
        /// path and returns true to include the file or false to exclude it.
        /// </remarks>
        public override IList<ArchiveFileInfo> GetFileInfo(
            IUnpackStreamContext streamContext,
            Predicate<string> fileFilter)
        {
            if (streamContext == null)
            {
                throw new ArgumentNullException("streamContext");
            }

            lock (this)
            {
                IList<ZipFileHeader> headers = this.GetCentralDirectory(streamContext);
                if (headers == null)
                {
                    throw new ZipException("Zip central directory not found.");
                }

                List<ArchiveFileInfo> files = new List<ArchiveFileInfo>(headers.Count);
                foreach (ZipFileHeader header in headers)
                {
                    if (!header.IsDirectory &&
                        (fileFilter == null || fileFilter(header.fileName)))
                    {
                        files.Add(header.ToZipFileInfo());
                    }
                }

                return files.AsReadOnly();
            }
        }

        /// <summary>
        /// Reads all the file headers from the central directory in the main archive.
        /// </summary>
        private IList<ZipFileHeader> GetCentralDirectory(IUnpackStreamContext streamContext)
        {
            Stream archiveStream = null;
            this.currentArchiveNumber = 0;
            try
            {
                List<ZipFileHeader> headers = new List<ZipFileHeader>();
                archiveStream = this.OpenArchive(streamContext, 0);

                ZipEndOfCentralDirectory eocd = this.GetEOCD(streamContext, archiveStream);
                if (eocd == null)
                {
                    return null;
                }
                else if (eocd.totalEntries == 0)
                {
                    return headers;
                }

                headers.Capacity = (int) eocd.totalEntries;

                if (eocd.dirOffset > archiveStream.Length - ZipFileHeader.CFH_FIXEDSIZE)
                {
                    streamContext.CloseArchiveReadStream(
                        this.currentArchiveNumber, String.Empty, archiveStream);
                    archiveStream = null;
                }
                else
                {
                    archiveStream.Seek(eocd.dirOffset, SeekOrigin.Begin);
                    uint sig = new BinaryReader(archiveStream).ReadUInt32();
                    if (sig != ZipFileHeader.CFHSIG)
                    {
                        streamContext.CloseArchiveReadStream(
                            this.currentArchiveNumber, String.Empty, archiveStream);
                        archiveStream = null;
                    }
                }

                if (archiveStream == null)
                {
                    this.currentArchiveNumber = (short) (eocd.dirStartDiskNumber + 1);
                    archiveStream = streamContext.OpenArchiveReadStream(
                        this.currentArchiveNumber, String.Empty, this);

                    if (archiveStream == null)
                    {
                        return null;
                    }
                }

                archiveStream.Seek(eocd.dirOffset, SeekOrigin.Begin);

                while (headers.Count < eocd.totalEntries)
                {
                    ZipFileHeader header = new ZipFileHeader();
                    if (!header.Read(archiveStream, true))
                    {
                        throw new ZipException(
                            "Missing or invalid central directory file header");
                    }

                    headers.Add(header);

                    if (headers.Count < eocd.totalEntries &&
                        archiveStream.Position == archiveStream.Length)
                    {
                        streamContext.CloseArchiveReadStream(
                            this.currentArchiveNumber, String.Empty, archiveStream);
                        this.currentArchiveNumber++;
                        archiveStream = streamContext.OpenArchiveReadStream(
                            this.currentArchiveNumber, String.Empty, this);
                        if (archiveStream == null)
                        {
                            this.currentArchiveNumber = 0;
                            archiveStream = streamContext.OpenArchiveReadStream(
                                this.currentArchiveNumber, String.Empty, this);
                        }
                    }
                }

                return headers;
            }
            finally
            {
                if (archiveStream != null)
                {
                    streamContext.CloseArchiveReadStream(
                        this.currentArchiveNumber, String.Empty, archiveStream);
                }
            }
        }

        /// <summary>
        /// Locates and reads the end of central directory record near the
        /// end of the archive.
        /// </summary>
        [SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic")]
        [SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId = "streamContext")]
        private ZipEndOfCentralDirectory GetEOCD(
            IUnpackStreamContext streamContext, Stream archiveStream)
        {
            BinaryReader reader = new BinaryReader(archiveStream);
            long offset = archiveStream.Length
                - ZipEndOfCentralDirectory.EOCD_RECORD_FIXEDSIZE;
            while (offset >= 0)
            {
                archiveStream.Seek(offset, SeekOrigin.Begin);

                uint sig = reader.ReadUInt32();
                if (sig == ZipEndOfCentralDirectory.EOCDSIG)
                {
                    break;
                }

                offset--;
            }

            if (offset < 0)
            {
                return null;
            }

            ZipEndOfCentralDirectory eocd = new ZipEndOfCentralDirectory();
            archiveStream.Seek(offset, SeekOrigin.Begin);
            if (!eocd.Read(archiveStream))
            {
                throw new ZipException("Invalid end of central directory record");
            }

            if (eocd.dirOffset == (long) UInt32.MaxValue)
            {
                string saveComment = eocd.comment;

                archiveStream.Seek(
                    offset - Zip64EndOfCentralDirectoryLocator.EOCDL64_SIZE,
                    SeekOrigin.Begin);

                Zip64EndOfCentralDirectoryLocator eocdl =
                    new Zip64EndOfCentralDirectoryLocator();
                if (!eocdl.Read(archiveStream))
                {
                    throw new ZipException("Missing or invalid end of " +
                        "central directory record locator");
                }

                if (eocdl.dirStartDiskNumber == eocdl.totalDisks - 1)
                {
                    // ZIP64 eocd is entirely in current stream.
                    archiveStream.Seek(eocdl.dirOffset, SeekOrigin.Begin);
                    if (!eocd.Read(archiveStream))
                    {
                        throw new ZipException("Missing or invalid ZIP64 end of " +
                            "central directory record");
                    }
                }
                else if (streamContext == null)
                {
                    return null;
                }
                else
                {
                    // TODO: handle EOCD64 spanning archives!
                    throw new NotImplementedException("Zip implementation does not " +
                        "handle end of central directory record that spans archives.");
                }

                eocd.comment = saveComment;
            }

            return eocd;
        }

        private void ResetProgressData()
        {
            this.currentFileName = null;
            this.currentFileNumber = 0;
            this.totalFiles = 0;
            this.currentFileBytesProcessed = 0;
            this.currentFileTotalBytes = 0;
            this.currentArchiveName = null;
            this.currentArchiveNumber = 0;
            this.totalArchives = 0;
            this.currentArchiveBytesProcessed = 0;
            this.currentArchiveTotalBytes = 0;
            this.fileBytesProcessed = 0;
            this.totalFileBytes = 0;
        }

        private void OnProgress(ArchiveProgressType progressType)
        {
            ArchiveProgressEventArgs e = new ArchiveProgressEventArgs(
                progressType,
                this.currentFileName,
                this.currentFileNumber >= 0 ? this.currentFileNumber : 0,
                this.totalFiles,
                this.currentFileBytesProcessed,
                this.currentFileTotalBytes,
                this.currentArchiveName,
                this.currentArchiveNumber,
                this.totalArchives,
                this.currentArchiveBytesProcessed,
                this.currentArchiveTotalBytes,
                this.fileBytesProcessed,
                this.totalFileBytes);
            this.OnProgress(e);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Compression\ArchiveProgressEventArgs.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ArchiveProgressEventArgs.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
using System;
using System.Collections.Generic;
using System.Text;

    /// <summary>
    /// Contains the data reported in an archive progress event.
    /// </summary>
    public class ArchiveProgressEventArgs : EventArgs
    {
        private ArchiveProgressType progressType;

        private string currentFileName;
        private int currentFileNumber;
        private int totalFiles;
        private long currentFileBytesProcessed;
        private long currentFileTotalBytes;

        private string currentArchiveName;
        private short currentArchiveNumber;
        private short totalArchives;
        private long currentArchiveBytesProcessed;
        private long currentArchiveTotalBytes;

        private long fileBytesProcessed;
        private long totalFileBytes;

        /// <summary>
        /// Creates a new ArchiveProgressEventArgs object from specified event parameters.
        /// </summary>
        /// <param name="progressType">type of status message</param>
        /// <param name="currentFileName">name of the file being processed</param>
        /// <param name="currentFileNumber">number of the current file being processed</param>
        /// <param name="totalFiles">total number of files to be processed</param>
        /// <param name="currentFileBytesProcessed">number of bytes processed so far when compressing or extracting a file</param>
        /// <param name="currentFileTotalBytes">total number of bytes in the current file</param>
        /// <param name="currentArchiveName">name of the current Archive</param>
        /// <param name="currentArchiveNumber">current Archive number, when processing a chained set of Archives</param>
        /// <param name="totalArchives">total number of Archives in a chained set</param>
        /// <param name="currentArchiveBytesProcessed">number of compressed bytes processed so far during an extraction</param>
        /// <param name="currentArchiveTotalBytes">total number of compressed bytes to be processed during an extraction</param>
        /// <param name="fileBytesProcessed">number of uncompressed file bytes processed so far</param>
        /// <param name="totalFileBytes">total number of uncompressed file bytes to be processed</param>
        public ArchiveProgressEventArgs(
            ArchiveProgressType progressType,
            string currentFileName,
            int currentFileNumber,
            int totalFiles,
            long currentFileBytesProcessed,
            long currentFileTotalBytes,
            string currentArchiveName,
            int currentArchiveNumber,
            int totalArchives,
            long currentArchiveBytesProcessed,
            long currentArchiveTotalBytes,
            long fileBytesProcessed,
            long totalFileBytes)
        {
            this.progressType = progressType;
            this.currentFileName = currentFileName;
            this.currentFileNumber = currentFileNumber;
            this.totalFiles = totalFiles;
            this.currentFileBytesProcessed = currentFileBytesProcessed;
            this.currentFileTotalBytes = currentFileTotalBytes;
            this.currentArchiveName = currentArchiveName;
            this.currentArchiveNumber = (short) currentArchiveNumber;
            this.totalArchives = (short) totalArchives;
            this.currentArchiveBytesProcessed = currentArchiveBytesProcessed;
            this.currentArchiveTotalBytes = currentArchiveTotalBytes;
            this.fileBytesProcessed = fileBytesProcessed;
            this.totalFileBytes = totalFileBytes;
        }

        /// <summary>
        /// Gets the type of status message.
        /// </summary>
        /// <value>A <see cref="ArchiveProgressType"/> value indicating what type of progress event occurred.</value>
        /// <remarks>
        /// The handler may choose to ignore some types of progress events.
        /// For example, if the handler will only list each file as it is
        /// compressed/extracted, it can ignore events that
        /// are not of type <see cref="ArchiveProgressType.FinishFile"/>.
        /// </remarks>
        public ArchiveProgressType ProgressType
        {
            get
            {
                return this.progressType;
            }
        }

        /// <summary>
        /// Gets the name of the file being processed. (The name of the file within the Archive; not the external
        /// file path.) Also includes the internal path of the file, if any.  Valid for
        /// <see cref="ArchiveProgressType.StartFile"/>, <see cref="ArchiveProgressType.PartialFile"/>,
        /// and <see cref="ArchiveProgressType.FinishFile"/> messages.
        /// </summary>
        /// <value>The name of the file currently being processed, or null if processing
        /// is currently at the stream or archive level.</value>
        public string CurrentFileName
        {
            get
            {
                return this.currentFileName;
            }
        }

        /// <summary>
        /// Gets the number of the current file being processed. The first file is number 0, and the last file
        /// is <see cref="TotalFiles"/>-1. Valid for <see cref="ArchiveProgressType.StartFile"/>,
        /// <see cref="ArchiveProgressType.PartialFile"/>, and <see cref="ArchiveProgressType.FinishFile"/> messages.
        /// </summary>
        /// <value>The number of the file currently being processed, or the most recent
        /// file processed if processing is currently at the stream or archive level.</value>
        public int CurrentFileNumber
        {
            get
            {
                return this.currentFileNumber;
            }
        }

        /// <summary>
        /// Gets the total number of files to be processed.  Valid for all message types.
        /// </summary>
        /// <value>The total number of files to be processed that are known so far.</value>
        public int TotalFiles
        {
            get
            {
                return this.totalFiles;
            }
        }

        /// <summary>
        /// Gets the number of bytes processed so far when compressing or extracting a file.  Valid for
        /// <see cref="ArchiveProgressType.StartFile"/>, <see cref="ArchiveProgressType.PartialFile"/>,
        /// and <see cref="ArchiveProgressType.FinishFile"/> messages.
        /// </summary>
        /// <value>The number of uncompressed bytes processed so far for the current file,
        /// or 0 if processing is currently at the stream or archive level.</value>
        public long CurrentFileBytesProcessed
        {
            get
            {
                return this.currentFileBytesProcessed;
            }
        }

        /// <summary>
        /// Gets the total number of bytes in the current file.  Valid for <see cref="ArchiveProgressType.StartFile"/>,
        /// <see cref="ArchiveProgressType.PartialFile"/>, and <see cref="ArchiveProgressType.FinishFile"/> messages.
        /// </summary>
        /// <value>The uncompressed size of the current file being processed,
        /// or 0 if processing is currently at the stream or archive level.</value>
        public long CurrentFileTotalBytes
        {
            get
            {
                return this.currentFileTotalBytes;
            }
        }

        /// <summary>
        /// Gets the name of the current archive.  Not necessarily the name of the archive on disk.
        /// Valid for all message types.
        /// </summary>
        /// <value>The name of the current archive, or an empty string if no name was specified.</value>
        public string CurrentArchiveName
        {
            get
            {
                return this.currentArchiveName;
            }
        }

        /// <summary>
        /// Gets the current archive number, when processing a chained set of archives. Valid for all message types.
        /// </summary>
        /// <value>The number of the current archive.</value>
        /// <remarks>The first archive is number 0, and the last archive is
        /// <see cref="TotalArchives"/>-1.</remarks>
        public int CurrentArchiveNumber
        {
            get
            {
                return this.currentArchiveNumber;
            }
        }

        /// <summary>
        /// Gets the total number of known archives in a chained set. Valid for all message types.
        /// </summary>
        /// <value>The total number of known archives in a chained set.</value>
        /// <remarks>
        /// When using the compression option to auto-split into multiple archives based on data size,
        /// this value will not be accurate until the end.
        /// </remarks>
        public int TotalArchives
        {
            get
            {
                return this.totalArchives;
            }
        }

        /// <summary>
        /// Gets the number of compressed bytes processed so far during extraction
        /// of the current archive. Valid for all extraction messages.
        /// </summary>
        /// <value>The number of compressed bytes processed so far during extraction
        /// of the current archive.</value>
        public long CurrentArchiveBytesProcessed
        {
            get
            {
                return this.currentArchiveBytesProcessed;
            }
        }

        /// <summary>
        /// Gets the total number of compressed bytes to be processed during extraction
        /// of the current archive. Valid for all extraction messages.
        /// </summary>
        /// <value>The total number of compressed bytes to be processed during extraction
        /// of the current archive.</value>
        public long CurrentArchiveTotalBytes
        {
            get
            {
                return this.currentArchiveTotalBytes;
            }
        }

        /// <summary>
        /// Gets the number of uncompressed bytes processed so far among all files. Valid for all message types.  
        /// </summary>
        /// <value>The number of uncompressed file bytes processed so far among all files.</value>
        /// <remarks>
        /// When compared to <see cref="TotalFileBytes"/>, this can be used as a measure of overall progress.
        /// </remarks>
        public long FileBytesProcessed
        {
            get
            {
                return this.fileBytesProcessed;
            }
        }

        /// <summary>
        /// Gets the total number of uncompressed file bytes to be processed.  Valid for all message types.
        /// </summary>
        /// <value>The total number of uncompressed bytes to be processed among all files.</value>
        public long TotalFileBytes
        {
            get
            {
                return this.totalFileBytes;
            }
        }

#if DEBUG

    /// <summary>
    /// Creates a string representation of the progress event.
    /// </summary>
    /// <returns>a listing of all event parameters and values</returns>
    public override string ToString()
    {
        string formatString =
            "{0}\n" +
            "\t CurrentFileName              = {1}\n" +
            "\t CurrentFileNumber            = {2}\n" +
            "\t TotalFiles                   = {3}\n" +
            "\t CurrentFileBytesProcessed    = {4}\n" +
            "\t CurrentFileTotalBytes        = {5}\n" +
            "\t CurrentArchiveName           = {6}\n" +
            "\t CurrentArchiveNumber         = {7}\n" +
            "\t TotalArchives                = {8}\n" +
            "\t CurrentArchiveBytesProcessed = {9}\n" +
            "\t CurrentArchiveTotalBytes     = {10}\n" +
            "\t FileBytesProcessed           = {11}\n" +
            "\t TotalFileBytes               = {12}\n";
        return String.Format(
            System.Globalization.CultureInfo.InvariantCulture,
            formatString,
            this.ProgressType,
            this.CurrentFileName,
            this.CurrentFileNumber,
            this.TotalFiles,
            this.CurrentFileBytesProcessed,
            this.CurrentFileTotalBytes,
            this.CurrentArchiveName,
            this.CurrentArchiveNumber,
            this.TotalArchives,
            this.CurrentArchiveBytesProcessed,
            this.CurrentArchiveTotalBytes,
            this.FileBytesProcessed,
            this.TotalFileBytes);
    }

#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup2\Compression.Zip\ZipUnpacker.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ZipUnpacker.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Zip
{
    using System;
    using System.IO;
    using System.IO.Compression;
    using System.Collections.Generic;

    public partial class ZipEngine
    {
        /// <summary>
        /// Extracts files from a zip archive or archive chain.
        /// </summary>
        /// <param name="streamContext">A context interface to handle opening
        /// and closing of archive and file streams.</param>
        /// <param name="fileFilter">An optional predicate that can determine
        /// which files to process.</param>
        /// <exception cref="ArchiveException">The archive provided
        /// by the stream context is not valid.</exception>
        /// <remarks>
        /// The <paramref name="fileFilter"/> predicate takes an internal file
        /// path and returns true to include the file or false to exclude it.
        /// </remarks>
        public override void Unpack(
            IUnpackStreamContext streamContext,
            Predicate<string> fileFilter)
        {
            if (streamContext == null)
            {
                throw new ArgumentNullException("streamContext");
            }

            lock (this)
            {
                IList<ZipFileHeader> allHeaders = this.GetCentralDirectory(streamContext);
                if (allHeaders == null)
                {
                    throw new ZipException("Zip central directory not found.");
                }

                IList<ZipFileHeader> headers = new List<ZipFileHeader>(allHeaders.Count);
                foreach (ZipFileHeader header in allHeaders)
                {
                    if (!header.IsDirectory &&
                        (fileFilter == null || fileFilter(header.fileName)))
                    {
                        headers.Add(header);
                    }
                }

                this.ResetProgressData();

                // Count the total number of files and bytes to be compressed.
                this.totalFiles = headers.Count;
                foreach (ZipFileHeader header in headers)
                {
                    long compressedSize;
                    long uncompressedSize;
                    long localHeaderOffset;
                    int archiveNumber;
                    uint crc;
                    header.GetZip64Fields(
                        out compressedSize,
                        out uncompressedSize,
                        out localHeaderOffset,
                        out archiveNumber,
                        out crc);

                    this.totalFileBytes += uncompressedSize;
                    if (archiveNumber >= this.totalArchives)
                    {
                        this.totalArchives = (short) (archiveNumber + 1);
                    }
                }

                this.currentArchiveNumber = -1;
                this.currentFileNumber = -1;
                Stream archiveStream = null;
                try
                {
                    foreach (ZipFileHeader header in headers)
                    {
                        this.currentFileNumber++;
                        this.UnpackOneFile(streamContext, header, ref archiveStream);
                    }
                }
                finally
                {
                    if (archiveStream != null)
                    {
                        streamContext.CloseArchiveReadStream(
                            0, String.Empty, archiveStream);
                        this.currentArchiveNumber--;
                        this.OnProgress(ArchiveProgressType.FinishArchive);
                    }
                }
            }
        }

        /// <summary>
        /// Unpacks a single file from an archive or archive chain.
        /// </summary>
        private void UnpackOneFile(
            IUnpackStreamContext streamContext,
            ZipFileHeader header,
            ref Stream archiveStream)
        {
            ZipFileInfo fileInfo = null;
            Stream fileStream = null;
            try
            {
                Converter<Stream, Stream> compressionStreamCreator;
                if (!ZipEngine.decompressionStreamCreators.TryGetValue(
                    header.compressionMethod, out compressionStreamCreator))
                {
                    // Silently skip files of an unsupported compression method.
                    return;
                }

                long compressedSize;
                long uncompressedSize;
                long localHeaderOffset;
                int archiveNumber;
                uint crc;
                header.GetZip64Fields(
                    out compressedSize,
                    out uncompressedSize,
                    out localHeaderOffset,
                    out archiveNumber,
                    out crc);

                if (this.currentArchiveNumber != archiveNumber + 1)
                {
                    if (archiveStream != null)
                    {
                        streamContext.CloseArchiveReadStream(
                            this.currentArchiveNumber,
                            String.Empty,
                            archiveStream);
                        archiveStream = null;

                        this.OnProgress(ArchiveProgressType.FinishArchive);
                        this.currentArchiveName = null;
                    }

                    this.currentArchiveNumber = (short) (archiveNumber + 1);
                    this.currentArchiveBytesProcessed = 0;
                    this.currentArchiveTotalBytes = 0;

                    archiveStream = this.OpenArchive(
                        streamContext, this.currentArchiveNumber);

                    FileStream archiveFileStream = archiveStream as FileStream;
                    this.currentArchiveName = (archiveFileStream != null ?
                        Path.GetFileName(archiveFileStream.Name) : null);

                    this.currentArchiveTotalBytes = archiveStream.Length;
                    this.currentArchiveNumber--;
                    this.OnProgress(ArchiveProgressType.StartArchive);
                    this.currentArchiveNumber++;
                }

                archiveStream.Seek(localHeaderOffset, SeekOrigin.Begin);

                ZipFileHeader localHeader = new ZipFileHeader();
                if (!localHeader.Read(archiveStream, false) ||
                    !localHeader.fileName.Equals(header.fileName))
                {
                    string msg = "Could not read file: " + header.fileName;
                    throw new ZipException(msg);
                }

                fileInfo = header.ToZipFileInfo();

                fileStream = streamContext.OpenFileWriteStream(
                    fileInfo.FullName,
                    fileInfo.Length,
                    fileInfo.LastWriteTime);

                if (fileStream != null)
                {
                    this.currentFileName = header.fileName;
                    this.currentFileBytesProcessed = 0;
                    this.currentFileTotalBytes = fileInfo.Length;
                    this.currentArchiveNumber--;
                    this.OnProgress(ArchiveProgressType.StartFile);
                    this.currentArchiveNumber++;

                    this.UnpackFileBytes(
                        streamContext,
                        fileInfo.FullName,
                        fileInfo.CompressedLength,
                        fileInfo.Length,
                        header.crc32,
                        fileStream,
                        compressionStreamCreator,
                        ref archiveStream);
                }
            }
            finally
            {
                if (fileStream != null)
                {
                    streamContext.CloseFileWriteStream(
                        fileInfo.FullName,
                        fileStream,
                        fileInfo.Attributes,
                        fileInfo.LastWriteTime);

                    this.currentArchiveNumber--;
                    this.OnProgress(ArchiveProgressType.FinishFile);
                    this.currentArchiveNumber++;
                }
            }
        }

        private Stream OpenArchive(IUnpackStreamContext streamContext, int archiveNumber)
        {
            Stream archiveStream = streamContext.OpenArchiveReadStream(
                archiveNumber, String.Empty, this);
            if (archiveStream == null && archiveNumber != 0)
            {
                archiveStream = streamContext.OpenArchiveReadStream(
                    0, String.Empty, this);
            }

            if (archiveStream == null)
            {
                throw new FileNotFoundException("Archive stream not provided.");
            }

            return archiveStream;
        }

        /// <summary>
        /// Decompresses bytes for one file from an archive or archive chain,
        /// checking the crc at the end.
        /// </summary>
        private void UnpackFileBytes(
            IUnpackStreamContext streamContext,
            string fileName,
            long compressedSize,
            long uncompressedSize,
            uint crc,
            Stream fileStream,
            Converter<Stream, Stream> compressionStreamCreator,
            ref Stream archiveStream)
        {
            CrcStream crcStream = new CrcStream(fileStream);

            ConcatStream concatStream = new ConcatStream(
                delegate(ConcatStream s)
                {
                    this.currentArchiveBytesProcessed = s.Source.Position;
                    streamContext.CloseArchiveReadStream(
                        this.currentArchiveNumber,
                        String.Empty,
                        s.Source);

                    this.currentArchiveNumber--;
                    this.OnProgress(ArchiveProgressType.FinishArchive);
                    this.currentArchiveNumber += 2;
                    this.currentArchiveName = null;
                    this.currentArchiveBytesProcessed = 0;
                    this.currentArchiveTotalBytes = 0;

                    s.Source = this.OpenArchive(streamContext, this.currentArchiveNumber);

                    FileStream archiveFileStream = s.Source as FileStream;
                    this.currentArchiveName = (archiveFileStream != null ?
                        Path.GetFileName(archiveFileStream.Name) : null);

                    this.currentArchiveTotalBytes = s.Source.Length;
                    this.currentArchiveNumber--;
                    this.OnProgress(ArchiveProgressType.StartArchive);
                    this.currentArchiveNumber++;
                });

            concatStream.Source = archiveStream;
            concatStream.SetLength(compressedSize);

            Stream decompressionStream = compressionStreamCreator(concatStream);

            try
            {
                byte[] buf = new byte[4096];
                long bytesRemaining = uncompressedSize;
                int counter = 0;
                while (bytesRemaining > 0)
                {
                    int count = (int) Math.Min(buf.Length, bytesRemaining);
                    count = decompressionStream.Read(buf, 0, count);
                    crcStream.Write(buf, 0, count);
                    bytesRemaining -= count;

                    this.fileBytesProcessed += count;
                    this.currentFileBytesProcessed += count;
                    this.currentArchiveBytesProcessed = concatStream.Source.Position;

                    if (++counter % 16 == 0) // Report every 64K
                    {
                        this.currentArchiveNumber--;
                        this.OnProgress(ArchiveProgressType.PartialFile);
                        this.currentArchiveNumber++;
                    }
                }
            }
            finally
            {
                archiveStream = concatStream.Source;
            }

            crcStream.Flush();

            if (crcStream.Crc != crc)
            {
                throw new ZipException("CRC check failed for file: " + fileName);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Compression.Cab\CabEngine.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="CabEngine.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Cab
{
    using System;
    using System.IO;
    using System.Collections.Generic;

    /// <summary>
    /// Engine capable of packing and unpacking archives in the cabinet format.
    /// </summary>
    public class CabEngine : CompressionEngine
    {
        private CabPacker packer;
        private CabUnpacker unpacker;

        /// <summary>
        /// Creates a new instance of the cabinet engine.
        /// </summary>
        public CabEngine()
            : base()
        {
        }

        /// <summary>
        /// Disposes of resources allocated by the cabinet engine.
        /// </summary>
        /// <param name="disposing">If true, the method has been called directly
        /// or indirectly by a user's code, so managed and unmanaged resources
        /// will be disposed. If false, the method has been called by the runtime
        /// from inside the finalizer, and only unmanaged resources will be
        /// disposed.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                if (packer != null)
                {
                    packer.Dispose();
                    packer = null;
                }
                if (unpacker != null)
                {
                    unpacker.Dispose();
                    unpacker = null;
                }
            }

            base.Dispose(disposing);
        }

        private CabPacker Packer
        {
            get
            {
                if (this.packer == null)
                {
                    this.packer = new CabPacker(this);
                }

                return this.packer;
            }
        }

        private CabUnpacker Unpacker
        {
            get
            {
                if (this.unpacker == null)
                {
                    this.unpacker = new CabUnpacker(this);
                }

                return this.unpacker;
            }
        }

        /// <summary>
        /// Creates a cabinet or chain of cabinets.
        /// </summary>
        /// <param name="streamContext">A context interface to handle opening
        /// and closing of cabinet and file streams.</param>
        /// <param name="files">The paths of the files in the archive (not
        /// external file paths).</param>
        /// <param name="maxArchiveSize">The maximum number of bytes for one
        /// cabinet before the contents are chained to the next cabinet, or zero
        /// for unlimited cabinet size.</param>
        /// <exception cref="ArchiveException">The cabinet could not be
        /// created.</exception>
        /// <remarks>
        /// The stream context implementation may provide a mapping from the
        /// file paths within the cabinet to the external file paths.
        /// <para>Smaller folder sizes can make it more efficient to extract
        /// individual files out of large cabinet packages.</para>
        /// </remarks>
        public override void Pack(
            IPackStreamContext streamContext,
            IEnumerable<string> files,
            long maxArchiveSize)
        {
            this.Packer.CompressionLevel = this.CompressionLevel;
            this.Packer.UseTempFiles = this.UseTempFiles;
            this.Packer.Pack(streamContext, files, maxArchiveSize);
        }

        /// <summary>
        /// Checks whether a Stream begins with a header that indicates
        /// it is a valid cabinet file.
        /// </summary>
        /// <param name="stream">Stream for reading the cabinet file.</param>
        /// <returns>True if the stream is a valid cabinet file
        /// (with no offset); false otherwise.</returns>
        public override bool IsArchive(Stream stream)
        {
            return this.Unpacker.IsArchive(stream);
        }

        /// <summary>
        /// Gets information about files in a cabinet or cabinet chain.
        /// </summary>
        /// <param name="streamContext">A context interface to handle opening
        /// and closing of cabinet and file streams.</param>
        /// <param name="fileFilter">A predicate that can determine
        /// which files to process, optional.</param>
        /// <returns>Information about files in the cabinet stream.</returns>
        /// <exception cref="ArchiveException">The cabinet provided
        /// by the stream context is not valid.</exception>
        /// <remarks>
        /// The <paramref name="fileFilter"/> predicate takes an internal file
        /// path and returns true to include the file or false to exclude it.
        /// </remarks>
        public override IList<ArchiveFileInfo> GetFileInfo(
            IUnpackStreamContext streamContext,
            Predicate<string> fileFilter)
        {
            return this.Unpacker.GetFileInfo(streamContext, fileFilter);
        }

        /// <summary>
        /// Extracts files from a cabinet or cabinet chain.
        /// </summary>
        /// <param name="streamContext">A context interface to handle opening
        /// and closing of cabinet and file streams.</param>
        /// <param name="fileFilter">An optional predicate that can determine
        /// which files to process.</param>
        /// <exception cref="ArchiveException">The cabinet provided
        /// by the stream context is not valid.</exception>
        /// <remarks>
        /// The <paramref name="fileFilter"/> predicate takes an internal file
        /// path and returns true to include the file or false to exclude it.
        /// </remarks>
        public override void Unpack(
            IUnpackStreamContext streamContext,
            Predicate<string> fileFilter)
        {
            this.Unpacker.Unpack(streamContext, fileFilter);
        }

        internal void ReportProgress(ArchiveProgressEventArgs e)
        {
            base.OnProgress(e);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Compression.Cab\CabException.cs ===
//---------------------------------------------------------------------
// <copyright file="CabException.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Cab
{
    using System;
    using System.IO;
    using System.Resources;
    using System.Globalization;
    using System.Security.Permissions;
    using System.Runtime.Serialization;

    /// <summary>
    /// Exception class for cabinet operations.
    /// </summary>
    [Serializable]
    public class CabException : ArchiveException
    {
        private static ResourceManager errorResources;
        private int error;
        private int errorCode;

        /// <summary>
        /// Creates a new CabException with a specified error message and a reference to the
        /// inner exception that is the cause of this exception.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        /// <param name="innerException">The exception that is the cause of the current exception. If the
        /// innerException parameter is not a null reference (Nothing in Visual Basic), the current exception
        /// is raised in a catch block that handles the inner exception.</param>
        public CabException(string message, Exception innerException)
            : this(0, 0, message, innerException) { }

        /// <summary>
        /// Creates a new CabException with a specified error message.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        public CabException(string message)
            : this(0, 0, message, null) { }

        /// <summary>
        /// Creates a new CabException.
        /// </summary>
        public CabException()
            : this(0, 0, null, null) { }

        internal CabException(int error, int errorCode, string message, Exception innerException)
            : base(message, innerException)
        {
            this.error = error;
            this.errorCode = errorCode;
        }

        internal CabException(int error, int errorCode, string message)
            : this(error, errorCode, message, null) { }

        /// <summary>
        /// Initializes a new instance of the CabException class with serialized data.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The StreamingContext that contains contextual information about the source or destination.</param>
        protected CabException(SerializationInfo info, StreamingContext context) : base(info, context)
        {
            if (info == null)
            {
                throw new ArgumentNullException("info");
            }

            this.error = info.GetInt32("cabError");
            this.errorCode = info.GetInt32("cabErrorCode");
        }

        /// <summary>
        /// Gets the FCI or FDI cabinet engine error number.
        /// </summary>
        /// <value>A cabinet engine error number, or 0 if the exception was
        /// not related to a cabinet engine error number.</value>
        public int Error
        {
            get
            {
                return this.error;
            }
        }

        /// <summary>
        /// Gets the Win32 error code.
        /// </summary>
        /// <value>A Win32 error code, or 0 if the exception was
        /// not related to a Win32 error.</value>
        public int ErrorCode
        {
            get
            {
                return this.errorCode;
            }
        }

        internal static ResourceManager ErrorResources
        {
            get
            {
                if (errorResources == null)
                {
                    errorResources = new ResourceManager(
                        typeof(CabException).Namespace + ".Errors",
                        typeof(CabException).Assembly);
                }
                return errorResources;
            }
        }

        /// <summary>
        /// Sets the SerializationInfo with information about the exception.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The StreamingContext that contains contextual information about the source or destination.</param>
        [SecurityPermission(SecurityAction.Demand, SerializationFormatter=true)]
        public override void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            if (info == null)
            {
                throw new ArgumentNullException("info");
            }

            info.AddValue("cabError", this.error);
            info.AddValue("cabErrorCode", this.errorCode);
            base.GetObjectData(info, context);
        }

        internal static string GetErrorMessage(int error, int errorCode, bool extracting)
        {
            const int FCI_ERROR_RESOURCE_OFFSET = 1000;
            const int FDI_ERROR_RESOURCE_OFFSET = 2000;
            int resourceOffset = (extracting ? FDI_ERROR_RESOURCE_OFFSET : FCI_ERROR_RESOURCE_OFFSET);

            string msg = CabException.ErrorResources.GetString(
                (resourceOffset + error).ToString(CultureInfo.InvariantCulture.NumberFormat),
                CultureInfo.CurrentCulture);

            if (msg == null)
            {
                msg = CabException.ErrorResources.GetString(
                    resourceOffset.ToString(CultureInfo.InvariantCulture.NumberFormat),
                    CultureInfo.CurrentCulture);
            }

            if (errorCode != 0)
            {
                const string GENERIC_ERROR_RESOURCE = "1";
                string msg2 = CabException.ErrorResources.GetString(GENERIC_ERROR_RESOURCE, CultureInfo.CurrentCulture);
                msg = String.Format(CultureInfo.InvariantCulture, "{0} " + msg2, msg, errorCode);
            }
            return msg;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Compression.Cab\CabFileInfo.cs ===
//---------------------------------------------------------------------
// <copyright file="CabFileInfo.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Cab
{
    using System;
    using System.IO;
    using System.Runtime.Serialization;
    using System.Security.Permissions;

    /// <summary>
    /// Object representing a compressed file within a cabinet package; provides operations for getting
    /// the file properties and extracting the file.
    /// </summary>
    [Serializable]
    public class CabFileInfo : ArchiveFileInfo
    {
        private int cabFolder;

        /// <summary>
        /// Creates a new CabinetFileInfo object representing a file within a cabinet in a specified path.
        /// </summary>
        /// <param name="cabinetInfo">An object representing the cabinet containing the file.</param>
        /// <param name="filePath">The path to the file within the cabinet. Usually, this is a simple file
        /// name, but if the cabinet contains a directory structure this may include the directory.</param>
        public CabFileInfo(CabInfo cabinetInfo, string filePath)
            : base(cabinetInfo, filePath)
        {
            if (cabinetInfo == null)
            {
                throw new ArgumentNullException("cabinetInfo");
            }

            this.cabFolder = -1;
        }

        /// <summary>
        /// Creates a new CabinetFileInfo object with all parameters specified,
        /// used internally when reading the metadata out of a cab.
        /// </summary>
        /// <param name="filePath">The internal path and name of the file in the cab.</param>
        /// <param name="cabFolder">The folder number containing the file.</param>
        /// <param name="cabNumber">The cabinet number where the file starts.</param>
        /// <param name="attributes">The stored attributes of the file.</param>
        /// <param name="lastWriteTime">The stored last write time of the file.</param>
        /// <param name="length">The uncompressed size of the file.</param>
        internal CabFileInfo(
            string filePath,
            int cabFolder,
            int cabNumber,
            FileAttributes attributes,
            DateTime lastWriteTime,
            long length)
            : base(filePath, cabNumber, attributes, lastWriteTime, length)
        {
            this.cabFolder = cabFolder;
        }

        /// <summary>
        /// Initializes a new instance of the CabinetFileInfo class with serialized data.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The StreamingContext that contains contextual information about the source or destination.</param>
        protected CabFileInfo(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
            this.cabFolder = info.GetInt32("cabFolder");
        }

        /// <summary>
        /// Sets the SerializationInfo with information about the archive.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized object data.</param>
        /// <param name="context">The StreamingContext that contains contextual information
        /// about the source or destination.</param>
        [SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
        public override void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            base.GetObjectData(info, context);
            info.AddValue("cabFolder", this.cabFolder);
        }

        /// <summary>
        /// Gets or sets the cabinet that contains this file.
        /// </summary>
        /// <value>
        /// The CabinetInfo instance that retrieved this file information -- this
        /// may be null if the CabinetFileInfo object was returned directly from a
        /// stream.
        /// </value>
        public CabInfo Cabinet
        {
            get
            {
                return (CabInfo) this.Archive;
            }
        }

        /// <summary>
        /// Gets the full path of the cabinet that contains this file.
        /// </summary>
        /// <value>The full path of the cabinet that contains this file.</value>
        public string CabinetName
        {
            get
            {
                return this.ArchiveName;
            }
        }

        /// <summary>
        /// Gets the number of the folder containing this file.
        /// </summary>
        /// <value>The number of the cabinet folder containing this file.</value>
        /// <remarks>A single folder or the first folder of a cabinet
        /// (or chain of cabinets) is numbered 0.</remarks>
        public int CabinetFolderNumber
        {
            get
            {
                if (this.cabFolder < 0)
                {
                    this.Refresh();
                }
                return this.cabFolder;
            }
        }

        /// <summary>
        /// Refreshes the information in this object with new data retrieved
        /// from an archive.
        /// </summary>
        /// <param name="newFileInfo">Fresh instance for the same file just
        /// read from the archive.</param>
        /// <remarks>
        /// This implementation refreshes the <see cref="CabinetFolderNumber"/>.
        /// </remarks>
        protected override void Refresh(ArchiveFileInfo newFileInfo)
        {
            base.Refresh(newFileInfo);
            this.cabFolder = ((CabFileInfo) newFileInfo).cabFolder;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Compression.Cab\CabInfo.cs ===
//---------------------------------------------------------------------
// <copyright file="CabInfo.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Cab
{
    using System;
    using System.Collections.Generic;
    using System.Runtime.Serialization;

    /// <summary>
    /// Object representing a cabinet file on disk; provides access to
    /// file-based operations on the cabinet file.
    /// </summary>
    /// <remarks>
    /// Generally, the methods on this class are much easier to use than the
    /// stream-based interfaces provided by the <see cref="CabEngine"/> class.
    /// </remarks>
    [Serializable]
    public class CabInfo : ArchiveInfo
    {
        /// <summary>
        /// Creates a new CabinetInfo object representing a cabinet file in a specified path.
        /// </summary>
        /// <param name="path">The path to the cabinet file. When creating a cabinet file, this file does not
        /// necessarily exist yet.</param>
        public CabInfo(string path)
            : base(path)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CabinetInfo class with serialized data.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The StreamingContext that contains contextual information about the source or destination.</param>
        protected CabInfo(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }

        /// <summary>
        /// Creates a compression engine that does the low-level work for
        /// this object.
        /// </summary>
        /// <returns>A new <see cref="CabEngine"/> instance.</returns>
        /// <remarks>
        /// Each instance will be <see cref="CompressionEngine.Dispose()"/>d
        /// immediately after use.
        /// </remarks>
        protected override CompressionEngine CreateCompressionEngine()
        {
            return new CabEngine();
        }

        /// <summary>
        /// Gets information about the files contained in the archive.
        /// </summary>
        /// <returns>A list of <see cref="CabFileInfo"/> objects, each
        /// containing information about a file in the archive.</returns>
        public new IList<CabFileInfo> GetFiles()
        {
            IList<ArchiveFileInfo> files = base.GetFiles();
            List<CabFileInfo> cabFiles = new List<CabFileInfo>(files.Count);
            foreach (CabFileInfo cabFile in files) cabFiles.Add(cabFile);
            return cabFiles.AsReadOnly();
        }

        /// <summary>
        /// Gets information about the certain files contained in the archive file.
        /// </summary>
        /// <param name="searchPattern">The search string, such as
        /// &quot;*.txt&quot;.</param>
        /// <returns>A list of <see cref="CabFileInfo"/> objects, each containing
        /// information about a file in the archive.</returns>
        public new IList<CabFileInfo> GetFiles(string searchPattern)
        {
            IList<ArchiveFileInfo> files = base.GetFiles(searchPattern);
            List<CabFileInfo> cabFiles = new List<CabFileInfo>(files.Count);
            foreach (CabFileInfo cabFile in files) cabFiles.Add(cabFile);
            return cabFiles.AsReadOnly();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Compression\ArchiveFileInfo.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ArchiveFileInfo.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
    using System;
    using System.IO;
    using System.Security.Permissions;
    using System.Runtime.Serialization;
    using System.Diagnostics.CodeAnalysis;

    /// <summary>
    /// Abstract object representing a compressed file within an archive;
    /// provides operations for getting the file properties and unpacking
    /// the file.
    /// </summary>
    [Serializable]
    public abstract class ArchiveFileInfo : FileSystemInfo
    {
        private ArchiveInfo archiveInfo;
        private string name;
        private string path;

        private bool initialized;
        private bool exists;
        private int archiveNumber;
        private FileAttributes attributes;
        private DateTime lastWriteTime;
        private long length;

        /// <summary>
        /// Creates a new ArchiveFileInfo object representing a file within
        /// an archive in a specified path.
        /// </summary>
        /// <param name="archiveInfo">An object representing the archive
        /// containing the file.</param>
        /// <param name="filePath">The path to the file within the archive.
        /// Usually, this is a simple file name, but if the archive contains
        /// a directory structure this may include the directory.</param>
        protected ArchiveFileInfo(ArchiveInfo archiveInfo, string filePath)
            : base()
        {
            if (filePath == null)
            {
                throw new ArgumentNullException("filePath");
            }

            this.Archive = archiveInfo;

            this.name = System.IO.Path.GetFileName(filePath);
            this.path = System.IO.Path.GetDirectoryName(filePath);

            this.attributes = FileAttributes.Normal;
            this.lastWriteTime = DateTime.MinValue;
        }

        /// <summary>
        /// Creates a new ArchiveFileInfo object with all parameters specified;
        /// used by subclasses when reading the metadata out of an archive.
        /// </summary>
        /// <param name="filePath">The internal path and name of the file in
        /// the archive.</param>
        /// <param name="archiveNumber">The archive number where the file
        /// starts.</param>
        /// <param name="attributes">The stored attributes of the file.</param>
        /// <param name="lastWriteTime">The stored last write time of the
        /// file.</param>
        /// <param name="length">The uncompressed size of the file.</param>
        protected ArchiveFileInfo(
            string filePath,
            int archiveNumber,
            FileAttributes attributes,
            DateTime lastWriteTime,
            long length)
            : this(null, filePath)
        {
            this.exists = true;
            this.archiveNumber = archiveNumber;
            this.attributes = attributes;
            this.lastWriteTime = lastWriteTime;
            this.length = length;
            this.initialized = true;
        }

        /// <summary>
        /// Initializes a new instance of the ArchiveFileInfo class with
        /// serialized data.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized
        /// object data about the exception being thrown.</param>
        /// <param name="context">The StreamingContext that contains contextual
        /// information about the source or destination.</param>
        protected ArchiveFileInfo(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
            this.archiveInfo = (ArchiveInfo) info.GetValue(
                "archiveInfo", typeof(ArchiveInfo));
            this.name = info.GetString("name");
            this.path = info.GetString("path");
            this.initialized = info.GetBoolean("initialized");
            this.exists = info.GetBoolean("exists");
            this.archiveNumber = info.GetInt32("archiveNumber");
            this.attributes = (FileAttributes) info.GetValue(
                "attributes", typeof(FileAttributes));
            this.lastWriteTime = info.GetDateTime("lastWriteTime");
            this.length = info.GetInt64("length");
        }

        /// <summary>
        /// Gets the name of the file.
        /// </summary>
        /// <value>The name of the file, not including any path.</value>
        public override string Name
        {
            get
            {
                return this.name;
            }
        }

        /// <summary>
        /// Gets the internal path of the file in the archive.
        /// </summary>
        /// <value>The internal path of the file in the archive, not including
        /// the file name.</value>
        public string Path
        {
            get
            {
                return this.path;
            }
        }

        /// <summary>
        /// Gets the full path to the file.
        /// </summary>
        /// <value>The full path to the file, including the full path to the
        /// archive, the internal path in the archive, and the file name.</value>
        /// <remarks>
        /// For example, the path <c>"C:\archive.cab\file.txt"</c> refers to
        /// a file "file.txt" inside the archive "archive.cab".
        /// </remarks>
        public override string FullName
        {
            get
            {
                string fullName = System.IO.Path.Combine(this.Path, this.Name);
                
                if (this.Archive != null)
                {
                    fullName = System.IO.Path.Combine(this.ArchiveName, fullName);
                }

                return fullName;
            }
        }

        /// <summary>
        /// Gets or sets the archive that contains this file.
        /// </summary>
        /// <value>
        /// The ArchiveInfo instance that retrieved this file information -- this
        /// may be null if the ArchiveFileInfo object was returned directly from
        /// a stream.
        /// </value>
        public ArchiveInfo Archive
        {
            get
            {
                return (ArchiveInfo) this.archiveInfo;
            }

            internal set
            {
                this.archiveInfo = value;

                // protected instance members inherited from FileSystemInfo:
                this.OriginalPath = (value != null ? value.FullName : null);
                this.FullPath = this.OriginalPath;
            }
        }

        /// <summary>
        /// Gets the full path of the archive that contains this file.
        /// </summary>
        /// <value>The full path of the archive that contains this file.</value>
        public string ArchiveName
        {
            get
            {
                return this.Archive != null ? this.Archive.FullName : null;
            }
        }

        /// <summary>
        /// Gets the number of the archive where this file starts.
        /// </summary>
        /// <value>The number of the archive where this file starts.</value>
        /// <remarks>A single archive or the first archive in a chain is
        /// numbered 0.</remarks>
        public int ArchiveNumber
        {
            get
            {
                return this.archiveNumber;
            }
        }

        /// <summary>
        /// Checks if the file exists within the archive.
        /// </summary>
        /// <value>True if the file exists, false otherwise.</value>
        public override bool Exists
        {
            get
            {
                if (!this.initialized)
                {
                    this.Refresh();
                }

                return this.exists;
            }
        }

        /// <summary>
        /// Gets the uncompressed size of the file.
        /// </summary>
        /// <value>The uncompressed size of the file in bytes.</value>
        public long Length
        {
            get
            {
                if (!this.initialized)
                {
                    this.Refresh();
                }

                return this.length;
            }
        }

        /// <summary>
        /// Gets the attributes of the file.
        /// </summary>
        /// <value>The attributes of the file as stored in the archive.</value>
        public new FileAttributes Attributes
        {
            get
            {
                if (!this.initialized)
                {
                    this.Refresh();
                }

                return this.attributes;
            }
        }

        /// <summary>
        /// Gets the last modification time of the file.
        /// </summary>
        /// <value>The last modification time of the file as stored in the
        /// archive.</value>
        public new DateTime LastWriteTime
        {
            get
            {
                if (!this.initialized)
                {
                    this.Refresh();
                }

                return this.lastWriteTime;
            }
        }

        /// <summary>
        /// Sets the SerializationInfo with information about the archive.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized
        /// object data.</param>
        /// <param name="context">The StreamingContext that contains contextual
        /// information about the source or destination.</param>
        [SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
        public override void GetObjectData(
            SerializationInfo info, StreamingContext context)
        {
            base.GetObjectData(info, context);
            info.AddValue("archiveInfo", this.archiveInfo);
            info.AddValue("name", this.name);
            info.AddValue("path", this.path);
            info.AddValue("initialized", this.initialized);
            info.AddValue("exists", this.exists);
            info.AddValue("archiveNumber", this.archiveNumber);
            info.AddValue("attributes", this.attributes);
            info.AddValue("lastWriteTime", this.lastWriteTime);
            info.AddValue("length", this.length);
        }

        /// <summary>
        /// Gets the full path to the file.
        /// </summary>
        /// <returns>The same as <see cref="FullName"/></returns>
        public override string ToString()
        {
            return this.FullName;
        }

        /// <summary>
        /// Deletes the file. NOT SUPPORTED.
        /// </summary>
        /// <exception cref="NotSupportedException">Files cannot be deleted
        /// from an existing archive.</exception>
        public override void Delete()
        {
            throw new NotSupportedException();
        }

        /// <summary>
        /// Refreshes the attributes and other cached information about the file,
        /// by re-reading the information from the archive.
        /// </summary>
        public new void Refresh()
        {
            base.Refresh();

            if (this.Archive != null)
            {
                string filePath = System.IO.Path.Combine(this.Path, this.Name);
                ArchiveFileInfo updatedFile = this.Archive.GetFile(filePath);
                if (updatedFile == null)
                {
                    throw new FileNotFoundException(
                            "File not found in archive.", filePath);
                }

                this.Refresh(updatedFile);
            }
        }

        /// <summary>
        /// Extracts the file.
        /// </summary>
        /// <param name="destFileName">The destination path where the file
        /// will be extracted.</param>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "dest")]
        public void CopyTo(string destFileName)
        {
            this.CopyTo(destFileName, false);
        }

        /// <summary>
        /// Extracts the file, optionally overwriting any existing file.
        /// </summary>
        /// <param name="destFileName">The destination path where the file
        /// will be extracted.</param>
        /// <param name="overwrite">If true, <paramref name="destFileName"/>
        /// will be overwritten if it exists.</param>
        /// <exception cref="IOException"><paramref name="overwrite"/> is false
        /// and <paramref name="destFileName"/> exists.</exception>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "dest")]
        public void CopyTo(string destFileName, bool overwrite)
        {
            if (destFileName == null)
            {
                throw new ArgumentNullException("destFileName");
            }

            if (!overwrite && File.Exists(destFileName))
            {
                throw new IOException();
            }

            if (this.Archive == null)
            {
                throw new InvalidOperationException();
            }

            this.Archive.UnpackFile(
                System.IO.Path.Combine(this.Path, this.Name), destFileName);
        }

        /// <summary>
        /// Refreshes the information in this object with new data retrieved
        /// from an archive.
        /// </summary>
        /// <param name="newFileInfo">Fresh instance for the same file just
        /// read from the archive.</param>
        /// <remarks>
        /// Subclasses may override this method to refresh sublcass fields.
        /// However they should always call the base implementation first.
        /// </remarks>
        protected virtual void Refresh(ArchiveFileInfo newFileInfo)
        {
            this.exists = newFileInfo.exists;
            this.length = newFileInfo.length;
            this.attributes = newFileInfo.attributes;
            this.lastWriteTime = newFileInfo.lastWriteTime;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Compression.Cab\HandleManager.cs ===
//---------------------------------------------------------------------
// <copyright file="HandleManager.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Cab
{
    using System;
    using System.Collections.Generic;

    /// <summary>
    /// Generic class for managing allocations of integer handles
    /// for objects of a certain type.
    /// </summary>
    /// <typeparam name="T">The type of objects the handles refer to.</typeparam>
    internal sealed class HandleManager<T> where T : class
    {
        /// <summary>
        /// Auto-resizing list of objects for which handles have been allocated.
        /// Each handle is just an index into this list. When a handle is freed,
        /// the list item at that index is set to null.
        /// </summary>
        private List<T> handles;

        /// <summary>
        /// Creates a new HandleManager instance.
        /// </summary>
        public HandleManager()
        {
            this.handles = new List<T>();
        }

        /// <summary>
        /// Gets the object of a handle, or null if the handle is invalid.
        /// </summary>
        /// <param name="handle">The integer handle previously allocated
        /// for the desired object.</param>
        /// <returns>The object for which the handle was allocated.</returns>
        public T this[int handle]
        {
            get
            {
                if (handle > 0 && handle <= this.handles.Count)
                {
                    return this.handles[handle - 1];
                }
                else
                {
                    return null;
                }
            }
        }

        /// <summary>
        /// Allocates a new handle for an object.
        /// </summary>
        /// <param name="obj">Object that the handle will refer to.</param>
        /// <returns>New handle that can be later used to retrieve the object.</returns>
        public int AllocHandle(T obj)
        {
            this.handles.Add(obj);
            int handle = this.handles.Count;
            return handle;
        }

        /// <summary>
        /// Frees a handle that was previously allocated. Afterward the handle
        /// will be invalid and the object it referred to can no longer retrieved.
        /// </summary>
        /// <param name="handle">Handle to be freed.</param>
        public void FreeHandle(int handle)
        {
            if (handle > 0 && handle <= this.handles.Count)
            {
                this.handles[handle - 1] = null;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Compression.Zip\ConcatStream.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ConcatStream.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Zip
{
    using System;
    using System.IO;

    /// <summary>
    /// Used to trick a DeflateStream into reading from or writing to
    /// a series of (chunked) streams instead of a single steream.
    /// </summary>
    internal class ConcatStream : Stream
    {
        private Stream source;
        private long position;
        private long length;
        private Action<ConcatStream> nextStreamHandler;

        public ConcatStream(Action<ConcatStream> nextStreamHandler)
        {
            if (nextStreamHandler == null)
            {
                throw new ArgumentNullException("nextStreamHandler");
            }

            this.nextStreamHandler = nextStreamHandler;
            this.length = Int64.MaxValue;
        }

        public Stream Source
        {
            get { return this.source; }
            set { this.source = value; }
        }

        public override bool CanRead
        {
            get { return true; }
        }

        public override bool CanWrite
        {
            get { return true; }
        }

        public override bool CanSeek
        {
            get { return false; }
        }

        public override long Length
        {
            get
            {
                return this.length;
            }
        }

        public override long Position
        {
            get { return this.position; }
            set { throw new NotSupportedException(); }
        }

        public override int Read(byte[] buffer, int offset, int count)
        {
            if (this.source == null)
            {
                this.nextStreamHandler(this);
            }

            count = (int) Math.Min(count, this.length - this.position);

            int bytesRemaining = count;
            while (bytesRemaining > 0)
            {
                if (this.source == null)
                {
                    throw new InvalidOperationException();
                }

                int partialCount = (int) Math.Min(bytesRemaining,
                    this.source.Length - this.source.Position);

                if (partialCount == 0)
                {
                    this.nextStreamHandler(this);
                    continue;
                }

                partialCount = this.source.Read(
                    buffer, offset + count - bytesRemaining, partialCount);
                bytesRemaining -= partialCount;
                this.position += partialCount;
            }

            return count;
        }

        public override void Write(byte[] buffer, int offset, int count)
        {
            if (this.source == null)
            {
                this.nextStreamHandler(this);
            }

            int bytesRemaining = count;
            while (bytesRemaining > 0)
            {
                if (this.source == null)
                {
                    throw new InvalidOperationException();
                }

                int partialCount = (int) Math.Min(bytesRemaining,
                    Math.Max(0, this.length - this.source.Position));

                if (partialCount == 0)
                {
                    this.nextStreamHandler(this);
                    continue;
                }

                this.source.Write(
                    buffer, offset + count - bytesRemaining, partialCount);
                bytesRemaining -= partialCount;
                this.position += partialCount;
            }
        }

        public override void Flush()
        {
            if (this.source != null)
            {
                this.source.Flush();
            }
        }

        public override long Seek(long offset, SeekOrigin origin)
        {
            throw new NotSupportedException();
        }

        public override void SetLength(long value)
        {
            this.length = value;
        }

        public override void Close()
        {
            if (this.source != null)
            {
                this.source.Close();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Compression\ArchiveInfo.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ArchiveInfo.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
    using System;
    using System.IO;
    using System.Collections.Generic;
    using System.Globalization;
    using System.Text.RegularExpressions;
    using System.Security.Permissions;
    using System.Runtime.Serialization;
    using System.Diagnostics.CodeAnalysis;

    /// <summary>
    /// Abstract object representing a compressed archive on disk;
    /// provides access to file-based operations on the archive.
    /// </summary>
    [Serializable]
    public abstract class ArchiveInfo : FileSystemInfo
    {
        /// <summary>
        /// Creates a new ArchiveInfo object representing an archive in a
        /// specified path.
        /// </summary>
        /// <param name="path">The path to the archive. When creating an archive,
        /// this file does not necessarily exist yet.</param>
        protected ArchiveInfo(string path) : base()
        {
            if (path == null)
            {
                throw new ArgumentNullException("path");
            }

            // protected instance members inherited from FileSystemInfo:
            this.OriginalPath = path;
            this.FullPath = Path.GetFullPath(path);
        }

        /// <summary>
        /// Initializes a new instance of the ArchiveInfo class with serialized data.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized object
        /// data about the exception being thrown.</param>
        /// <param name="context">The StreamingContext that contains contextual
        /// information about the source or destination.</param>
        protected ArchiveInfo(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }

        /// <summary>
        /// Gets the directory that contains the archive.
        /// </summary>
        /// <value>A DirectoryInfo object representing the parent directory of the
        /// archive.</value>
        public DirectoryInfo Directory
        {
            get
            {
                return new DirectoryInfo(Path.GetDirectoryName(this.FullName));
            }
        }

        /// <summary>
        /// Gets the full path of the directory that contains the archive.
        /// </summary>
        /// <value>The full path of the directory that contains the archive.</value>
        public string DirectoryName
        {
            get
            {
                return Path.GetDirectoryName(this.FullName);
            }
        }

        /// <summary>
        /// Gets the size of the archive.
        /// </summary>
        /// <value>The size of the archive in bytes.</value>
        public long Length
        {
            get
            {
                return new FileInfo(this.FullName).Length;
            }
        }

        /// <summary>
        /// Gets the file name of the archive.
        /// </summary>
        /// <value>The file name of the archive, not including any path.</value>
        public override string Name
        {
            get
            {
                return Path.GetFileName(this.FullName);
            }
        }

        /// <summary>
        /// Checks if the archive exists.
        /// </summary>
        /// <value>True if the archive exists; else false.</value>
        public override bool Exists
        {
            get
            {
                return File.Exists(this.FullName);
            }
        }

        /// <summary>
        /// Gets the full path of the archive.
        /// </summary>
        /// <returns>The full path of the archive.</returns>
        public override string ToString()
        {
            return this.FullName;
        }

        /// <summary>
        /// Deletes the archive.
        /// </summary>
        public override void Delete()
        {
            File.Delete(this.FullName);
        }

        /// <summary>
        /// Copies an existing archive to another location.
        /// </summary>
        /// <param name="destFileName">The destination file path.</param>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "dest")]
        public void CopyTo(string destFileName)
        {
            File.Copy(this.FullName, destFileName);
        }

        /// <summary>
        /// Copies an existing archive to another location, optionally
        /// overwriting the destination file.
        /// </summary>
        /// <param name="destFileName">The destination file path.</param>
        /// <param name="overwrite">If true, the destination file will be
        /// overwritten if it exists.</param>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "dest")]
        public void CopyTo(string destFileName, bool overwrite)
        {
            File.Copy(this.FullName, destFileName, overwrite);
        }
        
        /// <summary>
        /// Moves an existing archive to another location.
        /// </summary>
        /// <param name="destFileName">The destination file path.</param>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "dest")]
        public void MoveTo(string destFileName)
        {
            File.Move(this.FullName, destFileName);
            this.FullPath = Path.GetFullPath(destFileName);
        }

        /// <summary>
        /// Checks if the archive contains a valid archive header.
        /// </summary>
        /// <returns>True if the file is a valid archive; false otherwise.</returns>
        public bool IsValid()
        {
            using (Stream stream = File.OpenRead(this.FullName))
            {
                using (CompressionEngine compressionEngine = this.CreateCompressionEngine())
                {
                    return compressionEngine.FindArchiveOffset(stream) >= 0;
                }
            }
        }

        /// <summary>
        /// Gets information about the files contained in the archive.
        /// </summary>
        /// <returns>A list of <see cref="ArchiveFileInfo"/> objects, each
        /// containing information about a file in the archive.</returns>
        public IList<ArchiveFileInfo> GetFiles()
        {
            return this.InternalGetFiles((Predicate<string>) null);
        }

        /// <summary>
        /// Gets information about the certain files contained in the archive file.
        /// </summary>
        /// <param name="searchPattern">The search string, such as
        /// &quot;*.txt&quot;.</param>
        /// <returns>A list of <see cref="ArchiveFileInfo"/> objects, each containing
        /// information about a file in the archive.</returns>
        public IList<ArchiveFileInfo> GetFiles(string searchPattern)
        {
            if (searchPattern == null)
            {
                throw new ArgumentNullException("searchPattern");
            }

            string regexPattern = String.Format(
                CultureInfo.InvariantCulture,
                "^{0}$",
                Regex.Escape(searchPattern).Replace("\\*", ".*").Replace("\\?", "."));
            Regex regex = new Regex(
                    regexPattern,
                    RegexOptions.IgnoreCase | RegexOptions.CultureInvariant);

            return this.InternalGetFiles(
                delegate(string match)
                {
                    return regex.IsMatch(match);
                });
        }

        /// <summary>
        /// Extracts all files from an archive to a destination directory.
        /// </summary>
        /// <param name="destDirectory">Directory where the files are to be
        /// extracted.</param>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "dest")]
        public void Unpack(string destDirectory)
        {
            this.Unpack(destDirectory, null);
        }

        /// <summary>
        /// Extracts all files from an archive to a destination directory,
        /// optionally extracting only newer files.
        /// </summary>
        /// <param name="destDirectory">Directory where the files are to be
        /// extracted.</param>
        /// <param name="progressHandler">Handler for receiving progress
        /// information; this may be null if progress is not desired.</param>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "dest")]
        public void Unpack(
            string destDirectory,
            EventHandler<ArchiveProgressEventArgs> progressHandler)
        {
            using (CompressionEngine compressionEngine = this.CreateCompressionEngine())
            {
                compressionEngine.Progress += progressHandler;
                ArchiveFileStreamContext streamContext =
                    new ArchiveFileStreamContext(this.FullName, destDirectory, null);
                streamContext.EnableOffsetOpen = true;
                compressionEngine.Unpack(streamContext, null);
            }
        }

        /// <summary>
        /// Extracts a single file from the archive.
        /// </summary>
        /// <param name="fileName">The name of the file in the archive. Also
        /// includes the internal path of the file, if any. File name matching
        /// is case-insensitive.</param>
        /// <param name="destFileName">The path where the file is to be
        /// extracted on disk.</param>
        /// <remarks>If <paramref name="destFileName"/> already exists,
        /// it will be overwritten.</remarks>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "dest")]
        public void UnpackFile(string fileName, string destFileName)
        {
            if (fileName == null)
            {
                throw new ArgumentNullException("fileName");
            }

            if (destFileName == null)
            {
                throw new ArgumentNullException("destFileName");
            }

            this.UnpackFiles(
                new string[] { fileName },
                null,
                new string[] { destFileName });
        }

        /// <summary>
        /// Extracts multiple files from the archive.
        /// </summary>
        /// <param name="fileNames">The names of the files in the archive.
        /// Each name includes the internal path of the file, if any. File name
        /// matching is case-insensitive.</param>
        /// <param name="destDirectory">This parameter may be null, but if
        /// specified it is the root directory for any relative paths in
        /// <paramref name="destFileNames"/>.</param>
        /// <param name="destFileNames">The paths where the files are to be
        /// extracted on disk. If this parameter is null, the files will be
        /// extracted with the names from the archive.</param>
        /// <remarks>
        /// If any extracted files already exist on disk, they will be overwritten.
        /// <p>The <paramref name="destDirectory"/> and
        /// <paramref name="destFileNames"/> parameters cannot both be null.</p>
        /// </remarks>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "dest")]
        public void UnpackFiles(
            IList<string> fileNames,
            string destDirectory,
            IList<string> destFileNames)
        {
            this.UnpackFiles(fileNames, destDirectory, destFileNames, null);
        }

        /// <summary>
        /// Extracts multiple files from the archive, optionally extracting
        /// only newer files.
        /// </summary>
        /// <param name="fileNames">The names of the files in the archive.
        /// Each name includes the internal path of the file, if any. File name
        /// matching is case-insensitive.</param>
        /// <param name="destDirectory">This parameter may be null, but if
        /// specified it is the root directory for any relative paths in
        /// <paramref name="destFileNames"/>.</param>
        /// <param name="destFileNames">The paths where the files are to be
        /// extracted on disk. If this parameter is null, the files will be
        /// extracted with the names from the archive.</param>
        /// <param name="progressHandler">Handler for receiving progress information;
        /// this may be null if progress is not desired.</param>
        /// <remarks>
        /// If any extracted files already exist on disk, they will be overwritten.
        /// <p>The <paramref name="destDirectory"/> and
        /// <paramref name="destFileNames"/> parameters cannot both be null.</p>
        /// </remarks>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "dest")]
        public void UnpackFiles(
            IList<string> fileNames,
            string destDirectory,
            IList<string> destFileNames,
            EventHandler<ArchiveProgressEventArgs> progressHandler)
        {
            if (fileNames == null)
            {
                throw new ArgumentNullException("fileNames");
            }

            if (destFileNames == null)
            {
                if (destDirectory == null)
                {
                    throw new ArgumentNullException("destFileNames");
                }

                destFileNames = fileNames;
            }

            if (destFileNames.Count != fileNames.Count)
            {
                throw new ArgumentOutOfRangeException("destFileNames");
            }

            IDictionary<string, string> files =
                ArchiveInfo.CreateStringDictionary(fileNames, destFileNames);
            this.UnpackFileSet(files, destDirectory, progressHandler);
        }

        /// <summary>
        /// Extracts multiple files from the archive.
        /// </summary>
        /// <param name="fileNames">A mapping from internal file paths to
        /// external file paths. Case-senstivity when matching internal paths
        /// depends on the IDictionary implementation.</param>
        /// <param name="destDirectory">This parameter may be null, but if
        /// specified it is the root directory for any relative external paths
        /// in <paramref name="fileNameMap"/>.</param>
        /// <remarks>
        /// If any extracted files already exist on disk, they will be overwritten.
        /// </remarks>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "dest")]
        public void UnpackFileSet(
            IDictionary<string, string> fileNames,
            string destDirectory)
        {
            this.UnpackFileSet(fileNames, destDirectory, null);
        }

        /// <summary>
        /// Extracts multiple files from the archive.
        /// </summary>
        /// <param name="fileNames">A mapping from internal file paths to
        /// external file paths. Case-senstivity when matching internal
        /// paths depends on the IDictionary implementation.</param>
        /// <param name="destDirectory">This parameter may be null, but if
        /// specified it is the root directory for any relative external
        /// paths in <paramref name="fileNameMap"/>.</param>
        /// <param name="progressHandler">Handler for receiving progress
        /// information; this may be null if progress is not desired.</param>
        /// <remarks>
        /// If any extracted files already exist on disk, they will be overwritten.
        /// </remarks>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "dest")]
        public void UnpackFileSet(
            IDictionary<string, string> fileNames,
            string destDirectory,
            EventHandler<ArchiveProgressEventArgs> progressHandler)
        {
            if (fileNames == null)
            {
                throw new ArgumentNullException("fileNames");
            }

            using (CompressionEngine compressionEngine = this.CreateCompressionEngine())
            {
                compressionEngine.Progress += progressHandler;
                ArchiveFileStreamContext streamContext =
                    new ArchiveFileStreamContext(this.FullName, destDirectory, fileNames);
                streamContext.EnableOffsetOpen = true;
                compressionEngine.Unpack(
                    streamContext,
                    delegate(string match)
                    {
                        return fileNames.ContainsKey(match);
                    });
            }
        }

        /// <summary>
        /// Compresses all files in a directory into the archive.
        /// Does not include subdirectories.
        /// </summary>
        /// <param name="sourceDirectory">The directory containing the
        /// files to be included.</param>
        /// <remarks>
        /// Uses maximum compression level.
        /// </remarks>
        public void Pack(string sourceDirectory)
        {
            this.Pack(sourceDirectory, false, CompressionLevel.Max, null);
        }
        /// <summary>
        /// Compresses all files in a directory into the archive, optionally
        /// including subdirectories.
        /// </summary>
        /// <param name="sourceDirectory">This parameter may be null, but
        /// if specified it is the root directory
        /// for any relative paths in <paramref name="sourceFileNames"/>.</param>
        /// <param name="includeSubdirectories">If true, recursively include
        /// files in subdirectories.</param>
        /// <param name="compLevel">The compression level used when creating
        /// the archive.</param>
        /// <param name="progressHandler">Handler for receiving progress information;
        /// this may be null if progress is not desired.</param>
        /// <remarks>
        /// The files are stored in the archive using their relative file paths in
        /// the directory tree, if supported by the archive file format.
        /// </remarks>
        public void Pack(
            IList<string> archiveFiles,
            string sourceDirectory,
            bool includeSubdirectories,
            CompressionLevel compLevel,
            EventHandler<ArchiveProgressEventArgs> progressHandler,
            long maxArchiveSize)
        {
            IList<string> files = this.GetRelativeFilePathsInDirectoryTree(
                sourceDirectory, includeSubdirectories);
            this.PackFiles(archiveFiles, sourceDirectory, files, files, compLevel, progressHandler, maxArchiveSize);
        }

        /// <summary>
        /// Compresses all files in a directory into the archive, optionally
        /// including subdirectories.
        /// </summary>
        /// <param name="sourceDirectory">This parameter may be null, but
        /// if specified it is the root directory
        /// for any relative paths in <paramref name="sourceFileNames"/>.</param>
        /// <param name="includeSubdirectories">If true, recursively include
        /// files in subdirectories.</param>
        /// <param name="compLevel">The compression level used when creating
        /// the archive.</param>
        /// <param name="progressHandler">Handler for receiving progress information;
        /// this may be null if progress is not desired.</param>
        /// <remarks>
        /// The files are stored in the archive using their relative file paths in
        /// the directory tree, if supported by the archive file format.
        /// </remarks>
        public void Pack(
            string sourceDirectory,
            bool includeSubdirectories,
            CompressionLevel compLevel,
            EventHandler<ArchiveProgressEventArgs> progressHandler)
        {
            IList<string> files = this.GetRelativeFilePathsInDirectoryTree(
                sourceDirectory, includeSubdirectories);
            this.PackFiles(sourceDirectory, files, files, compLevel, progressHandler);
        }

        /// <summary>
        /// Compresses files into the archive, specifying the names used to
        /// store the files in the archive.
        /// </summary>
        /// <param name="sourceDirectory">This parameter may be null, but
        /// if specified it is the root directory
        /// for any relative paths in <paramref name="sourceFileNames"/>.</param>
        /// <param name="sourceFileNames">The list of files to be included in
        /// the archive.</param>
        /// <param name="fileNames">The names of the files as they are stored
        /// in the archive. Each name
        /// includes the internal path of the file, if any. This parameter may
        /// be null, in which case the files are stored in the archive with their
        /// source file names and no path information.</param>
        /// <remarks>
        /// Uses maximum compression level.
        /// <p>Duplicate items in the <paramref name="fileNames"/> array will cause
        /// an <see cref="ArchiveException"/>.</p>
        /// </remarks>
        public void PackFiles(
            string sourceDirectory,
            IList<string> sourceFileNames,
            IList<string> fileNames)
        {
            this.PackFiles(
                sourceDirectory,
                sourceFileNames,
                fileNames,
                CompressionLevel.Max,
                null);
        }

        /// <summary>
        /// Compresses files into the archive, specifying the names used to
        /// store the files in the archive.
        /// </summary>
        /// <param name="sourceDirectory">This parameter may be null, but if
        /// specified it is the root directory
        /// for any relative paths in <paramref name="sourceFileNames"/>.</param>
        /// <param name="sourceFileNames">The list of files to be included in
        /// the archive.</param>
        /// <param name="fileNames">The names of the files as they are stored in
        /// the archive. Each name includes the internal path of the file, if any.
        /// This parameter may be null, in which case the files are stored in the
        /// archive with their source file names and no path information.</param>
        /// <param name="compLevel">The compression level used when creating the
        /// archive.</param>
        /// <param name="progressHandler">Handler for receiving progress information;
        /// this may be null if progress is not desired.</param>
        /// <remarks>
        /// Duplicate items in the <paramref name="fileNames"/> array will cause
        /// an <see cref="ArchiveException"/>.
        /// </remarks>
        public void PackFiles(
            IList<string> archiveFiles,
            string sourceDirectory,
            IList<string> sourceFileNames,
            IList<string> fileNames,
            CompressionLevel compLevel,
            EventHandler<ArchiveProgressEventArgs> progressHandler,
            long maxArchiveSize)
        {
            if (sourceFileNames == null)
            {
                throw new ArgumentNullException("sourceFileNames");
            }

            if (fileNames == null)
            {
                string[] fileNamesArray = new string[sourceFileNames.Count];
                for (int i = 0; i < sourceFileNames.Count; i++)
                {
                    fileNamesArray[i] = Path.GetFileName(sourceFileNames[i]);
                }

                fileNames = fileNamesArray;
            }
            else if (fileNames.Count != sourceFileNames.Count)
            {
                throw new ArgumentOutOfRangeException("fileNames");
            }

            using (CompressionEngine compressionEngine = this.CreateCompressionEngine())
            {
                compressionEngine.Progress += progressHandler;
                IDictionary<string, string> contextFiles =
                    ArchiveInfo.CreateStringDictionary(fileNames, sourceFileNames);

                
                ArchiveFileStreamContext streamContext;
                if (archiveFiles == null)
                {
                    streamContext = new ArchiveFileStreamContext(
                            this.FullName, sourceDirectory, contextFiles);
                }
                else
                {
                    streamContext = new ArchiveFileStreamContext(
                            archiveFiles, sourceDirectory, contextFiles);
                }
                streamContext.EnableOffsetOpen = true;
                compressionEngine.CompressionLevel = compLevel;
                compressionEngine.Pack(streamContext, fileNames, maxArchiveSize);
            }
        }

        /// <summary>
        /// Compresses files into the archive, specifying the names used to
        /// store the files in the archive.
        /// </summary>
        /// <param name="sourceDirectory">This parameter may be null, but if
        /// specified it is the root directory
        /// for any relative paths in <paramref name="sourceFileNames"/>.</param>
        /// <param name="sourceFileNames">The list of files to be included in
        /// the archive.</param>
        /// <param name="fileNames">The names of the files as they are stored in
        /// the archive. Each name includes the internal path of the file, if any.
        /// This parameter may be null, in which case the files are stored in the
        /// archive with their source file names and no path information.</param>
        /// <param name="compLevel">The compression level used when creating the
        /// archive.</param>
        /// <param name="progressHandler">Handler for receiving progress information;
        /// this may be null if progress is not desired.</param>
        /// <remarks>
        /// Duplicate items in the <paramref name="fileNames"/> array will cause
        /// an <see cref="ArchiveException"/>.
        /// </remarks>
        public void PackFiles(
            string sourceDirectory,
            IList<string> sourceFileNames,
            IList<string> fileNames,
            CompressionLevel compLevel,
            EventHandler<ArchiveProgressEventArgs> progressHandler)
        {
            if (sourceFileNames == null)
            {
                throw new ArgumentNullException("sourceFileNames");
            }

            if (fileNames == null)
            {
                string[] fileNamesArray = new string[sourceFileNames.Count];
                for (int i = 0; i < sourceFileNames.Count; i++)
                {
                    fileNamesArray[i] = Path.GetFileName(sourceFileNames[i]);
                }

                fileNames = fileNamesArray;
            }
            else if (fileNames.Count != sourceFileNames.Count)
            {
                throw new ArgumentOutOfRangeException("fileNames");
            }

            using (CompressionEngine compressionEngine = this.CreateCompressionEngine())
            {
                compressionEngine.Progress += progressHandler;
                IDictionary<string, string> contextFiles =
                    ArchiveInfo.CreateStringDictionary(fileNames, sourceFileNames);

                ArchiveFileStreamContext streamContext = new ArchiveFileStreamContext(
                        this.FullName, sourceDirectory, contextFiles);
                streamContext.EnableOffsetOpen = true;
                compressionEngine.CompressionLevel = compLevel;
                compressionEngine.Pack(streamContext, fileNames);
            }
        }

        /// <summary>
        /// Compresses files into the archive, specifying the names used
        /// to store the files in the archive.
        /// </summary>
        /// <param name="sourceDirectory">This parameter may be null, but if
        /// specified it is the root directory
        /// for any relative paths in <paramref name="fileNames"/>.</param>
        /// <param name="fileNames">A mapping from internal file paths to
        /// external file paths.</param>
        /// <remarks>
        /// Uses maximum compression level.
        /// </remarks>
        public void PackFileSet(
            string sourceDirectory,
            IDictionary<string, string> fileNames)
        {
            this.PackFileSet(sourceDirectory, fileNames, CompressionLevel.Max, null);
        }

        /// <summary>
        /// Compresses files into the archive, specifying the names used to
        /// store the files in the archive.
        /// </summary>
        /// <param name="sourceDirectory">This parameter may be null, but if
        /// specified it is the root directory
        /// for any relative paths in <paramref name="fileNames"/>.</param>
        /// <param name="fileNames">A mapping from internal file paths to
        /// external file paths.</param>
        /// <param name="compLevel">The compression level used when creating
        /// the archive.</param>
        /// <param name="progressHandler">Handler for receiving progress information;
        /// this may be null if progress is not desired.</param>
        public void PackFileSet(
            string sourceDirectory,
            IDictionary<string, string> fileNames,
            CompressionLevel compLevel,
            EventHandler<ArchiveProgressEventArgs> progressHandler)
        {
            if (fileNames == null)
            {
                throw new ArgumentNullException("fileNames");
            }

            string[] fileNamesArray = new string[fileNames.Count];
            fileNames.Keys.CopyTo(fileNamesArray, 0);

            using (CompressionEngine compressionEngine = this.CreateCompressionEngine())
            {
                compressionEngine.Progress += progressHandler;
                ArchiveFileStreamContext streamContext = new ArchiveFileStreamContext(
                        this.FullName, sourceDirectory, fileNames);
                streamContext.EnableOffsetOpen = true;
                compressionEngine.CompressionLevel = compLevel;
                compressionEngine.Pack(streamContext, fileNamesArray);
            }
        }

        /// <summary>
        /// Given a directory, gets the relative paths of all files in the
        /// directory, optionally including all subdirectories.
        /// </summary>
        /// <param name="dir">The directory to search.</param>
        /// <param name="includeSubdirectories">True to include subdirectories
        /// in the search.</param>
        /// <returns>A list of file paths relative to the directory.</returns>
        internal IList<string> GetRelativeFilePathsInDirectoryTree(
            string dir, bool includeSubdirectories)
        {
            IList<string> fileList = new List<string>();
            this.RecursiveGetRelativeFilePathsInDirectoryTree(
                dir, String.Empty, includeSubdirectories, fileList);
            return fileList;
        }

        /// <summary>
        /// Retrieves information about one file from this archive.
        /// </summary>
        /// <param name="path">Path of the file in the archive.</param>
        /// <returns>File information, or null if the file was not found
        /// in the archive.</returns>
        internal ArchiveFileInfo GetFile(string path)
        {
            IList<ArchiveFileInfo> files = this.InternalGetFiles(
                delegate(string match)
                {
                    return String.Compare(
                        match, path, true, CultureInfo.InvariantCulture) == 0;
                });
            return (files != null && files.Count > 0 ? files[0] : null);
        }

        /// <summary>
        /// Creates a compression engine that does the low-level work for
        /// this object.
        /// </summary>
        /// <returns>A new compression engine instance that matches the specific
        /// subclass of archive.</returns>
        /// <remarks>
        /// Each instance will be <see cref="CompressionEngine.Dispose()"/>d
        /// immediately after use.
        /// </remarks>
        protected abstract CompressionEngine CreateCompressionEngine();

        /// <summary>
        /// Creates a case-insensitive dictionary mapping from one list of
        /// strings to the other.
        /// </summary>
        /// <param name="keys">List of keys.</param>
        /// <param name="values">List of values that are mapped 1-to-1 to
        /// the keys.</param>
        /// <returns>A filled dictionary of the strings.</returns>
        private static IDictionary<string, string> CreateStringDictionary(
            IList<string> keys, IList<string> values)
        {
            IDictionary<string, string> stringDict =
                new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
            for (int i = 0; i < keys.Count; i++)
            {
                stringDict.Add(keys[i], values[i]);
            }

            return stringDict;
        }

        /// <summary>
        /// Recursive-descent helper function for
        /// GetRelativeFilePathsInDirectoryTree.
        /// </summary>
        /// <param name="dir">The root directory of the search.</param>
        /// <param name="relativeDir">The relative directory to be
        /// processed now.</param>
        /// <param name="includeSubdirectories">True to descend into
        /// subdirectories.</param>
        /// <param name="fileList">List of files found so far.</param>
        private void RecursiveGetRelativeFilePathsInDirectoryTree(
            string dir,
            string relativeDir,
            bool includeSubdirectories,
            IList<string> fileList)
        {
            foreach (string file in System.IO.Directory.GetFiles(dir))
            {
                string fileName = Path.GetFileName(file);
                fileList.Add(Path.Combine(relativeDir, fileName));
            }

            if (includeSubdirectories)
            {
                foreach (string subDir in System.IO.Directory.GetDirectories(dir))
                {
                    string subDirName = Path.GetFileName(subDir);
                    this.RecursiveGetRelativeFilePathsInDirectoryTree(
                        Path.Combine(dir, subDirName),
                        Path.Combine(relativeDir, subDirName),
                        includeSubdirectories,
                        fileList);
                }
            }
        }

        /// <summary>
        /// Uses a CompressionEngine to get ArchiveFileInfo objects from this
        /// archive, and then associates them with this ArchiveInfo instance.
        /// </summary>
        /// <param name="fileFilter">Optional predicate that can determine
        /// which files to process.</param>
        /// <returns>A list of <see cref="ArchiveFileInfo"/> objects, each
        /// containing information about a file in the archive.</returns>
        private IList<ArchiveFileInfo> InternalGetFiles(Predicate<string> fileFilter)
        {
            using (CompressionEngine compressionEngine = this.CreateCompressionEngine())
            {
                ArchiveFileStreamContext streamContext =
                    new ArchiveFileStreamContext(this.FullName, null, null);
                streamContext.EnableOffsetOpen = true;
                IList<ArchiveFileInfo> files =
                    compressionEngine.GetFileInfo(streamContext, fileFilter);
                for (int i = 0; i < files.Count; i++)
                {
                    files[i].Archive = this;
                }

                return files;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Compression.Zip\ZipCompressionMethod.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ZipCompressionMethod.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Zip
{
    using System.Diagnostics.CodeAnalysis;

    /// <summary>
    /// Identifies the compression method or &quot;algorithm&quot;
    /// used for a single file within a zip archive.
    /// </summary>
    /// <remarks>
    /// Proprietary zip implementations may define additional compression
    /// methods outside of those included here.
    /// </remarks>
    public enum ZipCompressionMethod
    {
        /// <summary>
        /// The file is stored (no compression)
        /// </summary>
        Store = 0,
        
        /// <summary>
        /// The file is Shrunk
        /// </summary>
        Shrink = 1,
        
        /// <summary>
        /// The file is Reduced with compression factor 1
        /// </summary>
        Reduce1 = 2,

        /// <summary>
        /// The file is Reduced with compression factor 2
        /// </summary>
        Reduce2 = 3,

        /// <summary>
        /// The file is Reduced with compression factor 3
        /// </summary>
        Reduce3 = 4,

        /// <summary>
        /// The file is Reduced with compression factor 4
        /// </summary>
        Reduce4 = 5,
        
        /// <summary>
        /// The file is Imploded
        /// </summary>
        Implode = 6,
        
        /// <summary>
        /// The file is Deflated;
        /// the most common and widely-compatible form of zip compression.
        /// </summary>
        Deflate = 8,
        
        /// <summary>
        /// The file is Deflated using the enhanced Deflate64 method.
        /// </summary>
        Deflate64 = 9,

        /// <summary>
        /// The file is compressed using the BZIP2 algorithm.
        /// </summary>
        BZip2 = 12,

        /// <summary>
        /// The file is compressed using the LZMA algorithm.
        /// </summary>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Lzma")]
        Lzma = 14,

        /// <summary>
        /// The file is compressed using the PPMd algorithm.
        /// </summary>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Ppmd")]
        Ppmd = 98
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Compression.Zip\ZipException.cs ===
//---------------------------------------------------------------------
// <copyright file="ZipException.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Zip
{
    using System;
    using System.IO;
    using System.Resources;
    using System.Globalization;
    using System.Security.Permissions;
    using System.Runtime.Serialization;

    /// <summary>
    /// Exception class for zip operations.
    /// </summary>
    [Serializable]
    public class ZipException : ArchiveException
    {
        /// <summary>
        /// Creates a new ZipException with a specified error message and a reference to the
        /// inner exception that is the cause of this exception.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        /// <param name="innerException">The exception that is the cause of the current exception. If the
        /// innerException parameter is not a null reference (Nothing in Visual Basic), the current exception
        /// is raised in a catch block that handles the inner exception.</param>
        public ZipException(string message, Exception innerException)
            : base(message, innerException) { }

        /// <summary>
        /// Creates a new ZipException with a specified error message.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        public ZipException(string message)
            : this(message, null) { }

        /// <summary>
        /// Creates a new ZipException.
        /// </summary>
        public ZipException()
            : this(null, null) { }

        /// <summary>
        /// Initializes a new instance of the ZipException class with serialized data.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The StreamingContext that contains contextual information about the source or destination.</param>
        protected ZipException(SerializationInfo info, StreamingContext context) : base(info, context)
        {
        }

        /// <summary>
        /// Sets the SerializationInfo with information about the exception.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The StreamingContext that contains contextual information about the source or destination.</param>
        [SecurityPermission(SecurityAction.Demand, SerializationFormatter=true)]
        public override void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            base.GetObjectData(info, context);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Compression.Zip\ZipFileInfo.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ZipFileInfo.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Zip
{
    using System;
    using System.IO;
    using System.Runtime.Serialization;
    using System.Security.Permissions;

    /// <summary>
    /// Object representing a compressed file within a zip package; provides operations for getting
    /// the file properties and extracting the file.
    /// </summary>
    [Serializable]
    public class ZipFileInfo : ArchiveFileInfo
    {
        private long compressedLength;
        private ZipCompressionMethod compressionMethod;

        /// <summary>
        /// Creates a new ZipFileInfo object representing a file within a zip in a specified path.
        /// </summary>
        /// <param name="zipInfo">An object representing the zip archive containing the file.</param>
        /// <param name="filePath">The path to the file within the zip archive. Usually, this is a simple file
        /// name, but if the zip archive contains a directory structure this may include the directory.</param>
        public ZipFileInfo(ZipInfo zipInfo, string filePath)
            : base(zipInfo, filePath)
        {
            if (zipInfo == null)
            {
                throw new ArgumentNullException("zipInfo");
            }
        }

        /// <summary>
        /// Creates a new ZipFileInfo object with all parameters specified,
        /// used internally when reading the metadata out of a zip archive.
        /// </summary>
        /// <param name="filePath">The internal path and name of the file in the zip archive.</param>
        /// <param name="zipNumber">The zip archive number where the file starts.</param>
        /// <param name="attributes">The stored attributes of the file.</param>
        /// <param name="lastWriteTime">The stored last write time of the file.</param>
        /// <param name="length">The uncompressed size of the file.</param>
        /// <param name="compressedLength">The compressed size of the file.</param>
        /// <param name="compressionMethod">Compression algorithm used for this file.</param>
        internal ZipFileInfo(
            string filePath,
            int zipNumber,
            FileAttributes attributes,
            DateTime lastWriteTime,
            long length,
            long compressedLength,
            ZipCompressionMethod compressionMethod)
            : base(filePath, zipNumber, attributes, lastWriteTime, length)
        {
            this.compressedLength = compressedLength;
            this.compressionMethod = compressionMethod;
        }

        /// <summary>
        /// Initializes a new instance of the ZipFileInfo class with serialized data.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The StreamingContext that contains contextual information about the source or destination.</param>
        protected ZipFileInfo(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
            this.compressedLength = info.GetInt64("compressedLength");
        }

        /// <summary>
        /// Gets the compressed size of the file in bytes.
        /// </summary>
        public long CompressedLength
        {
            get
            {
                return this.compressedLength;
            }
        }

        /// <summary>
        /// Gets the method used to compress this file.
        /// </summary>
        public ZipCompressionMethod CompressionMethod
        {
            get
            {
                return this.compressionMethod;
            }
        }

        /// <summary>
        /// Sets the SerializationInfo with information about the archive.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized object data.</param>
        /// <param name="context">The StreamingContext that contains contextual information
        /// about the source or destination.</param>
        [SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
        public override void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            base.GetObjectData(info, context);
            info.AddValue("compressedLength", this.compressedLength);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Compression\CompressionEngine.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="CompressionEngine.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
using System;
using System.IO;
using System.Collections.Generic;
using System.Globalization;

    /// <summary>
    /// Base class for an engine capable of packing and unpacking a particular
    /// compressed file format.
    /// </summary>
    public abstract class CompressionEngine : IDisposable
    {
        private CompressionLevel compressionLevel;
        private bool dontUseTempFiles;

        /// <summary>
        /// Creates a new instance of the compression engine base class.
        /// </summary>
        protected CompressionEngine()
        {
            this.compressionLevel = CompressionLevel.Normal;
        }

        /// <summary>
        /// Disposes the compression engine.
        /// </summary>
        ~CompressionEngine()
        {
            this.Dispose(false);
        }

        /// <summary>
        /// Occurs when the compression engine reports progress in packing
        /// or unpacking an archive.
        /// </summary>
        /// <seealso cref="ArchiveProgressType"/>
        public event EventHandler<ArchiveProgressEventArgs> Progress;

        /// <summary>
        /// Gets or sets a flag indicating whether temporary files are created
        /// and used during compression.
        /// </summary>
        /// <value>True if temporary files are used; false if compression is done
        /// entirely in-memory.</value>
        /// <remarks>The value of this property is true by default. Using temporary
        /// files can greatly reduce the memory requirement of compression,
        /// especially when compressing large archives. However, setting this property
        /// to false may yield slightly better performance when creating small
        /// archives. Or it may be necessary if the process does not have sufficient
        /// privileges to create temporary files.</remarks>
        public bool UseTempFiles
        {
            get
            {
                return !this.dontUseTempFiles;
            }

            set
            {
                this.dontUseTempFiles = !value;
            }
        }

        /// <summary>
        /// Compression level to use when compressing files.
        /// </summary>
        /// <value>A compression level ranging from minimum to maximum compression,
        /// or no compression.</value>
        public CompressionLevel CompressionLevel
        {
            get
            {
                return this.compressionLevel;
            }

            set
            {
                this.compressionLevel = value;
            }
        }

        /// <summary>
        /// Disposes of resources allocated by the compression engine.
        /// </summary>
        public void Dispose()
        {
            this.Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Creates an archive.
        /// </summary>
        /// <param name="streamContext">A context interface to handle opening
        /// and closing of archive and file streams.</param>
        /// <param name="files">The paths of the files in the archive
        /// (not external file paths).</param>
        /// <exception cref="ArchiveException">The archive could not be
        /// created.</exception>
        /// <remarks>
        /// The stream context implementation may provide a mapping from the
        /// file paths within the archive to the external file paths.
        /// </remarks>
        public void Pack(IPackStreamContext streamContext, IEnumerable<string> files)
        {
            if (files == null)
            {
                throw new ArgumentNullException("files");
            }

            this.Pack(streamContext, files, 0);
        }

        /// <summary>
        /// Creates an archive or chain of archives.
        /// </summary>
        /// <param name="streamContext">A context interface to handle opening
        /// and closing of archive and file streams.</param>
        /// <param name="files">The paths of the files in the archive (not
        /// external file paths).</param>
        /// <param name="maxArchiveSize">The maximum number of bytes for one
        /// archive before the contents are chained to the next archive, or zero
        /// for unlimited archive size.</param>
        /// <exception cref="ArchiveException">The archive could not be
        /// created.</exception>
        /// <remarks>
        /// The stream context implementation may provide a mapping from the file
        /// paths within the archive to the external file paths.
        /// </remarks>
        public abstract void Pack(
            IPackStreamContext streamContext,
            IEnumerable<string> files,
            long maxArchiveSize);

        /// <summary>
        /// Checks whether a Stream begins with a header that indicates
        /// it is a valid archive.
        /// </summary>
        /// <param name="stream">Stream for reading the archive file.</param>
        /// <returns>True if the stream is a valid archive
        /// (with no offset); false otherwise.</returns>
        public abstract bool IsArchive(Stream stream);

        /// <summary>
        /// Gets the offset of an archive that is positioned 0 or more bytes
        /// from the start of the Stream.
        /// </summary>
        /// <param name="stream">A stream for reading the archive.</param>
        /// <returns>The offset in bytes of the archive,
        /// or -1 if no archive is found in the Stream.</returns>
        /// <remarks>The archive must begin on a 4-byte boundary.</remarks>
        public virtual long FindArchiveOffset(Stream stream)
        {
            if (stream == null)
            {
                throw new ArgumentNullException("stream");
            }

            long sectionSize = 4;
            long length = stream.Length;
            for (long offset = 0; offset <= length - sectionSize; offset += sectionSize)
            {
                stream.Seek(offset, SeekOrigin.Begin);
                if (this.IsArchive(stream))
                {
                    return offset;
                }
            }

            return -1;
        }

        /// <summary>
        /// Gets information about all files in an archive stream.
        /// </summary>
        /// <param name="stream">A stream for reading the archive.</param>
        /// <returns>Information about all files in the archive stream.</returns>
        /// <exception cref="ArchiveException">The stream is not a valid
        /// archive.</exception>
        public IList<ArchiveFileInfo> GetFileInfo(Stream stream)
        {
            return this.GetFileInfo(new BasicUnpackStreamContext(stream), null);
        }

        /// <summary>
        /// Gets information about files in an archive or archive chain.
        /// </summary>
        /// <param name="streamContext">A context interface to handle opening
        /// and closing of archive and file streams.</param>
        /// <param name="fileFilter">A predicate that can determine
        /// which files to process, optional.</param>
        /// <returns>Information about files in the archive stream.</returns>
        /// <exception cref="ArchiveException">The archive provided
        /// by the stream context is not valid.</exception>
        /// <remarks>
        /// The <paramref name="fileFilter"/> predicate takes an internal file
        /// path and returns true to include the file or false to exclude it.
        /// </remarks>
        public abstract IList<ArchiveFileInfo> GetFileInfo(
            IUnpackStreamContext streamContext,
            Predicate<string> fileFilter);

        /// <summary>
        /// Gets the list of files in an archive Stream.
        /// </summary>
        /// <param name="stream">A stream for reading the archive.</param>
        /// <returns>A list of the paths of all files contained in the
        /// archive.</returns>
        /// <exception cref="ArchiveException">The stream is not a valid
        /// archive.</exception>
        public IList<string> GetFiles(Stream stream)
        {
            return this.GetFiles(new BasicUnpackStreamContext(stream), null);
        }

        /// <summary>
        /// Gets the list of files in an archive or archive chain.
        /// </summary>
        /// <param name="streamContext">A context interface to handle opening
        /// and closing of archive and file streams.</param>
        /// <param name="fileFilter">A predicate that can determine
        /// which files to process, optional.</param>
        /// <returns>An array containing the names of all files contained in
        /// the archive or archive chain.</returns>
        /// <exception cref="ArchiveException">The archive provided
        /// by the stream context is not valid.</exception>
        /// <remarks>
        /// The <paramref name="fileFilter"/> predicate takes an internal file
        /// path and returns true to include the file or false to exclude it.
        /// </remarks>
        public IList<string> GetFiles(
            IUnpackStreamContext streamContext,
            Predicate<string> fileFilter)
        {
            if (streamContext == null)
            {
                throw new ArgumentNullException("streamContext");
            }

            IList<ArchiveFileInfo> files =
                this.GetFileInfo(streamContext, fileFilter);
            IList<string> fileNames = new List<string>(files.Count);
            for (int i = 0; i < files.Count; i++)
            {
                fileNames.Add(files[i].Name);
            }

            return fileNames;
        }

        /// <summary>
        /// Reads a single file from an archive stream.
        /// </summary>
        /// <param name="stream">A stream for reading the archive.</param>
        /// <param name="path">The path of the file within the archive
        /// (not the external file path).</param>
        /// <returns>A stream for reading the extracted file, or null
        /// if the file does not exist in the archive.</returns>
        /// <exception cref="ArchiveException">The stream is not a valid
        /// archive.</exception>
        /// <remarks>The entire extracted file is cached in memory, so this
        /// method requires enough free memory to hold the file.</remarks>
        public Stream Unpack(Stream stream, string path)
        {
            if (stream == null)
            {
                throw new ArgumentNullException("stream");
            }

            if (path == null)
            {
                throw new ArgumentNullException("path");
            }

            BasicUnpackStreamContext streamContext =
                new BasicUnpackStreamContext(stream);
            this.Unpack(
                streamContext,
                delegate(string match)
                {
                    return String.Compare(
                        match, path, true, CultureInfo.InvariantCulture) == 0;
                });
            
            Stream extractStream = streamContext.FileStream;
            if (extractStream != null)
            {
                extractStream.Position = 0;
            }

            return extractStream;
        }

        /// <summary>
        /// Extracts files from an archive or archive chain.
        /// </summary>
        /// <param name="streamContext">A context interface to handle opening
        /// and closing of archive and file streams.</param>
        /// <param name="fileFilter">An optional predicate that can determine
        /// which files to process.</param>
        /// <exception cref="ArchiveException">The archive provided
        /// by the stream context is not valid.</exception>
        /// <remarks>
        /// The <paramref name="fileFilter"/> predicate takes an internal file
        /// path and returns true to include the file or false to exclude it.
        /// </remarks>
        public abstract void Unpack(
            IUnpackStreamContext streamContext,
            Predicate<string> fileFilter);

        /// <summary>
        /// Called by sublcasses to distribute a packing or unpacking progress
        /// event to listeners.
        /// </summary>
        /// <param name="e">Event details.</param>
        protected void OnProgress(ArchiveProgressEventArgs e)
        {
            if (this.Progress != null)
            {
                this.Progress(this, e);
            }
        }

        /// <summary>
        /// Disposes of resources allocated by the compression engine.
        /// </summary>
        /// <param name="disposing">If true, the method has been called
        /// directly or indirectly by a user's code, so managed and unmanaged
        /// resources will be disposed. If false, the method has been called by
        /// the runtime from inside the finalizer, and only unmanaged resources
        /// will be disposed.</param>
        protected virtual void Dispose(bool disposing)
        {
        }

        /// <summary>
        /// Compresion utility function for converting old-style
        /// date and time values to a DateTime structure.
        /// </summary>
        public static void DosDateAndTimeToDateTime(
            short dosDate, short dosTime, out DateTime dateTime)
        {
            if (dosDate == 0 && dosTime == 0)
            {
                dateTime = DateTime.MinValue;
            }
            else
            {
                long fileTime;
                SafeNativeMethods.DosDateTimeToFileTime(dosDate, dosTime, out fileTime);
                dateTime = DateTime.FromFileTimeUtc(fileTime);
                dateTime = new DateTime(dateTime.Ticks, DateTimeKind.Local);
            }
        }

        /// <summary>
        /// Compresion utility function for converting a DateTime structure
        /// to old-style date and time values.
        /// </summary>
        public static void DateTimeToDosDateAndTime(
            DateTime dateTime, out short dosDate, out short dosTime)
        {
            dateTime = new DateTime(dateTime.Ticks, DateTimeKind.Utc);
            long filetime = dateTime.ToFileTimeUtc();
            SafeNativeMethods.FileTimeToDosDateTime(ref filetime, out dosDate, out dosTime);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Compression.Cab\CabWorker.cs ===
//---------------------------------------------------------------------
// <copyright file="CabWorker.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Cab
{
    using System;
    using System.IO;
    using System.IO.IsolatedStorage;
    using System.Text;
    using System.Security;
    using System.Collections.Generic;
    using System.Runtime.InteropServices;
    using System.Diagnostics.CodeAnalysis;

    internal abstract class CabWorker : IDisposable
    {
        internal const string CabStreamName = "%%CAB%%";

        private CabEngine cabEngine;

        private HandleManager<Stream> streamHandles;
        private Stream cabStream;
        private Stream fileStream;

        private NativeMethods.ERF erf;
        private GCHandle erfHandle;

        private IDictionary<string, short> cabNumbers;
        private string nextCabinetName;

        private bool suppressProgressEvents;

        private byte[] buf;

        // Progress data
        protected string currentFileName;
        protected int    currentFileNumber;
        protected int    totalFiles;
        protected long   currentFileBytesProcessed;
        protected long   currentFileTotalBytes;
        protected short  currentFolderNumber;
        protected long   currentFolderTotalBytes;
        protected string currentArchiveName;
        protected short  currentArchiveNumber;
        protected short  totalArchives;
        protected long   currentArchiveBytesProcessed;
        protected long   currentArchiveTotalBytes;
        protected long   fileBytesProcessed;
        protected long   totalFileBytes;

        [SuppressMessage("Microsoft.Security", "CA2122:DoNotIndirectlyExposeMethodsWithLinkDemands")]
        protected CabWorker(CabEngine cabEngine)
        {
            this.cabEngine = cabEngine;
            this.streamHandles = new HandleManager<Stream>();
            this.erf = new NativeMethods.ERF();
            this.erfHandle = GCHandle.Alloc(this.erf, GCHandleType.Pinned);
            this.cabNumbers = new Dictionary<string, short>(1);

            // 32K seems to be the size of the largest chunks processed by cabinet.dll.
            // But just in case, this buffer will auto-enlarge.
            this.buf = new byte[32768];
        }

        ~CabWorker()
        {
            this.Dispose(false);
        }

        public CabEngine CabEngine
        {
            get
            {
                return this.cabEngine;
            }
        }

        internal NativeMethods.ERF Erf
        {
            get
            {
                return this.erf;
            }
        }

        internal GCHandle ErfHandle
        {
            get
            {
                return this.erfHandle;
            }
        }

        internal HandleManager<Stream> StreamHandles
        {
            get
            {
                return this.streamHandles;
            }
        }

        internal bool SuppressProgressEvents
        {
            get
            {
                return this.suppressProgressEvents;
            }

            set
            {
                this.suppressProgressEvents = value;
            }
        }

        internal IDictionary<string, short> CabNumbers
        {
            get
            {
                return this.cabNumbers;
            }
        }

        internal string NextCabinetName
        {
            get
            {
                return this.nextCabinetName;
            }

            set
            {
                this.nextCabinetName = value;
            }
        }

        internal Stream CabStream
        {
            get
            {
                return this.cabStream;
            }

            set
            {
                this.cabStream = value;
            }
        }

        internal Stream FileStream
        {
            get
            {
                return this.fileStream;
            }

            set
            {
                this.fileStream = value;
            }
        }

        public void Dispose() 
        {
            this.Dispose(true);
            GC.SuppressFinalize(this); 
        }

        protected void ResetProgressData()
        {
            this.currentFileName = null;
            this.currentFileNumber = 0;
            this.totalFiles = 0;
            this.currentFileBytesProcessed = 0;
            this.currentFileTotalBytes = 0;
            this.currentFolderNumber = 0;
            this.currentFolderTotalBytes = 0;
            this.currentArchiveName = null;
            this.currentArchiveNumber = 0;
            this.totalArchives = 0;
            this.currentArchiveBytesProcessed = 0;
            this.currentArchiveTotalBytes = 0;
            this.fileBytesProcessed = 0;
            this.totalFileBytes = 0;
        }

        protected void OnProgress(ArchiveProgressType progressType)
        {
            if (!this.suppressProgressEvents)
            {
                ArchiveProgressEventArgs e = new ArchiveProgressEventArgs(
                    progressType,
                    this.currentFileName,
                    this.currentFileNumber >= 0 ? this.currentFileNumber : 0,
                    this.totalFiles,
                    this.currentFileBytesProcessed,
                    this.currentFileTotalBytes,
                    this.currentArchiveName,
                    this.currentArchiveNumber,
                    this.totalArchives,
                    this.currentArchiveBytesProcessed,
                    this.currentArchiveTotalBytes,
                    this.fileBytesProcessed,
                    this.totalFileBytes);
                this.CabEngine.ReportProgress(e);
            }
        }

        internal IntPtr CabAllocMem(int byteCount)
        {
            IntPtr memPointer = Marshal.AllocHGlobal((IntPtr) byteCount);
            return memPointer;
        }

        internal void CabFreeMem(IntPtr memPointer)
        {
            Marshal.FreeHGlobal(memPointer);
        }

        internal int CabOpenStream(string path, int openFlags, int shareMode)
        {
            int err; return this.CabOpenStreamEx(path, openFlags, shareMode, out err, IntPtr.Zero);
        }

        internal virtual int CabOpenStreamEx(string path, int openFlags, int shareMode, out int err, IntPtr pv)
        {
            path = path.Trim();
            Stream stream = this.cabStream;
            this.cabStream = new DuplicateStream(stream);
            int streamHandle = this.streamHandles.AllocHandle(stream);
            err = 0;
            return streamHandle;
        }

        internal int CabReadStream(int streamHandle, IntPtr memory, int cb)
        {
            int err; return this.CabReadStreamEx(streamHandle, memory, cb, out err, IntPtr.Zero);
        }

        internal virtual int CabReadStreamEx(int streamHandle, IntPtr memory, int cb, out int err, IntPtr pv)
        {
            Stream stream = this.streamHandles[streamHandle];
            int count = (int) cb;
            if (count > this.buf.Length)
            {
                this.buf = new byte[count];
            }
            count = stream.Read(this.buf, 0, count);
            Marshal.Copy(this.buf, 0, memory, count);
            err = 0;
            return count;
        }

        internal int CabWriteStream(int streamHandle, IntPtr memory, int cb)
        {
            int err; return this.CabWriteStreamEx(streamHandle, memory, cb, out err, IntPtr.Zero);
        }

        internal virtual int CabWriteStreamEx(int streamHandle, IntPtr memory, int cb, out int err, IntPtr pv)
        {
            Stream stream = this.streamHandles[streamHandle];
            int count = (int) cb;
            if (count > this.buf.Length)
            {
                this.buf = new byte[count];
            }
            Marshal.Copy(memory, this.buf, 0, count);
            stream.Write(this.buf, 0, count);
            err = 0;
            return cb;
        }

        internal int CabCloseStream(int streamHandle)
        {
            int err; return this.CabCloseStreamEx(streamHandle, out err, IntPtr.Zero);
        }

        internal virtual int CabCloseStreamEx(int streamHandle, out int err, IntPtr pv)
        {
            this.streamHandles.FreeHandle(streamHandle);
            err = 0;
            return 0;
        }

        internal int CabSeekStream(int streamHandle, int offset, int seekOrigin)
        {
            int err; return this.CabSeekStreamEx(streamHandle, offset, seekOrigin, out err, IntPtr.Zero);
        }

        internal virtual int CabSeekStreamEx(int streamHandle, int offset, int seekOrigin, out int err, IntPtr pv)
        {
            Stream stream = this.streamHandles[streamHandle];
            offset = (int) stream.Seek(offset, (SeekOrigin) seekOrigin);
            err = 0;
            return offset;
        }

        /// <summary>
        /// Disposes of resources allocated by the cabinet engine.
        /// </summary>
        /// <param name="disposing">If true, the method has been called directly or indirectly by a user's code,
        /// so managed and unmanaged resources will be disposed. If false, the method has been called by the 
        /// runtime from inside the finalizer, and only unmanaged resources will be disposed.</param>
        [SuppressMessage("Microsoft.Security", "CA2122:DoNotIndirectlyExposeMethodsWithLinkDemands")]
        protected virtual void Dispose(bool disposing) 
        {
            if (disposing) 
            {
                if (this.cabStream != null)
                {
                    this.cabStream.Close();
                    this.cabStream = null;
                }

                if (this.fileStream != null)
                {
                    this.fileStream.Close();
                    this.fileStream = null;
                }
            }

            if (this.erfHandle.IsAllocated)
            {
                this.erfHandle.Free();
            }
        }

        protected void CheckError(bool extracting)
        {
            if (this.Erf.Error)
            {
                throw new CabException(
                    this.Erf.Oper,
                    this.Erf.Type,
                    CabException.GetErrorMessage(this.Erf.Oper, this.Erf.Type, extracting));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Compression.Cab\CabPacker.cs ===
//---------------------------------------------------------------------
// <copyright file="CabPacker.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Cab
{
    using System;
    using System.IO;
    using System.Text;
    using System.Security.Permissions;
    using System.Collections.Generic;
    using System.Globalization;
    using System.Runtime.InteropServices;
    using System.Diagnostics.CodeAnalysis;

    internal class CabPacker : CabWorker
    {
        private const string TempStreamName = "%%TEMP%%";

        private NativeMethods.FCI.Handle fciHandle;

        // These delegates need to be saved as member variables
        // so that they don't get GC'd.
        private NativeMethods.FCI.PFNALLOC fciAllocMemHandler;
        private NativeMethods.FCI.PFNFREE fciFreeMemHandler;
        private NativeMethods.FCI.PFNOPEN fciOpenStreamHandler;
        private NativeMethods.FCI.PFNREAD fciReadStreamHandler;
        private NativeMethods.FCI.PFNWRITE fciWriteStreamHandler;
        private NativeMethods.FCI.PFNCLOSE fciCloseStreamHandler;
        private NativeMethods.FCI.PFNSEEK fciSeekStreamHandler;
        private NativeMethods.FCI.PFNFILEPLACED fciFilePlacedHandler;
        private NativeMethods.FCI.PFNDELETE fciDeleteFileHandler;
        private NativeMethods.FCI.PFNGETTEMPFILE fciGetTempFileHandler;

        private NativeMethods.FCI.PFNGETNEXTCABINET fciGetNextCabinet;
        private NativeMethods.FCI.PFNSTATUS fciCreateStatus;
        private NativeMethods.FCI.PFNGETOPENINFO fciGetOpenInfo;

        private IPackStreamContext context;

        private FileAttributes fileAttributes;
        private DateTime fileLastWriteTime;

        private int maxCabBytes;

        private long totalFolderBytesProcessedInCurrentCab;

        private CompressionLevel compressionLevel;
        private bool dontUseTempFiles;
        private IList<Stream> tempStreams;

        public CabPacker(CabEngine cabEngine)
            : base(cabEngine)
        {
            this.fciAllocMemHandler    = this.CabAllocMem;
            this.fciFreeMemHandler     = this.CabFreeMem;
            this.fciOpenStreamHandler  = this.CabOpenStreamEx;
            this.fciReadStreamHandler  = this.CabReadStreamEx;
            this.fciWriteStreamHandler = this.CabWriteStreamEx;
            this.fciCloseStreamHandler = this.CabCloseStreamEx;
            this.fciSeekStreamHandler  = this.CabSeekStreamEx;
            this.fciFilePlacedHandler  = this.CabFilePlaced;
            this.fciDeleteFileHandler  = this.CabDeleteFile;
            this.fciGetTempFileHandler = this.CabGetTempFile;
            this.fciGetNextCabinet     = this.CabGetNextCabinet;
            this.fciCreateStatus       = this.CabCreateStatus;
            this.fciGetOpenInfo        = this.CabGetOpenInfo;
            this.tempStreams = new List<Stream>();
            this.compressionLevel = CompressionLevel.Normal;
        }

        public bool UseTempFiles
        {
            get
            {
                return !this.dontUseTempFiles;
            }

            set
            {
                this.dontUseTempFiles = !value;
            }
        }

        public CompressionLevel CompressionLevel
        {
            get
            {
                return this.compressionLevel;
            }

            set
            {
                this.compressionLevel = value;
            }
        }

        [SuppressMessage("Microsoft.Security", "CA2122:DoNotIndirectlyExposeMethodsWithLinkDemands")]
        private void CreateFci(long maxArchiveSize)
        {
            NativeMethods.FCI.CCAB ccab = new NativeMethods.FCI.CCAB();
            if (maxArchiveSize > 0 && maxArchiveSize < ccab.cb)
            {
                ccab.cb = Math.Max(
                    NativeMethods.FCI.MIN_DISK, (int) maxArchiveSize);
            }

            object maxFolderSizeOption = this.context.GetOption(
                "maxFolderSize", null);
            if (maxFolderSizeOption != null)
            {
                long maxFolderSize = Convert.ToInt64(
                    maxFolderSizeOption, CultureInfo.InvariantCulture);
                if (maxFolderSize > 0 && maxFolderSize < ccab.cbFolderThresh)
                {
                    ccab.cbFolderThresh = (int) maxFolderSize;
                }
            }

            this.maxCabBytes = ccab.cb;
            ccab.szCab = this.context.GetArchiveName(0);
            if (ccab.szCab == null)
            {
                throw new FileNotFoundException(
                    "Cabinet name not provided by stream context.");
            }
            ccab.setID = (short) new Random().Next(
                Int16.MinValue, Int16.MaxValue + 1);
            this.CabNumbers[ccab.szCab] = 0;
            this.currentArchiveName = ccab.szCab;
            this.totalArchives = 1;
            this.CabStream = null;

            this.Erf.Clear();
            this.fciHandle = NativeMethods.FCI.Create(
                this.ErfHandle.AddrOfPinnedObject(),
                this.fciFilePlacedHandler,
                this.fciAllocMemHandler,
                this.fciFreeMemHandler,
                this.fciOpenStreamHandler,
                this.fciReadStreamHandler,
                this.fciWriteStreamHandler,
                this.fciCloseStreamHandler,
                this.fciSeekStreamHandler,
                this.fciDeleteFileHandler,
                this.fciGetTempFileHandler,
                ccab,
                IntPtr.Zero);
            this.CheckError(false);
        }

        [SuppressMessage("Microsoft.Security", "CA2106:SecureAsserts")]
        [SuppressMessage("Microsoft.Security", "CA2122:DoNotIndirectlyExposeMethodsWithLinkDemands")]
        [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
        public void Pack(
            IPackStreamContext streamContext,
            IEnumerable<string> files,
            long maxArchiveSize)
        {
            if (streamContext == null)
            {
                throw new ArgumentNullException("streamContext");
            }

            if (files == null)
            {
                throw new ArgumentNullException("files");
            }

            lock (this)
            {
                try
                {
                    this.context = streamContext;

                    this.ResetProgressData();

                    this.CreateFci(maxArchiveSize);

                    foreach (string file in files)
                    {
                        FileAttributes attributes;
                        DateTime lastWriteTime;
                        Stream fileStream = this.context.OpenFileReadStream(
                            file,
                            out attributes,
                            out lastWriteTime);
                        if (fileStream != null)
                        {
                            this.totalFileBytes += fileStream.Length;
                            this.totalFiles++;
                            this.context.CloseFileReadStream(file, fileStream);
                        }
                    }

                    long uncompressedBytesInFolder = 0;
                    this.currentFileNumber = -1;

                    foreach (string file in files)
                    {
                        FileAttributes attributes;
                        DateTime lastWriteTime;
                        Stream fileStream = this.context.OpenFileReadStream(
                            file, out attributes, out lastWriteTime);
                        if (fileStream == null)
                        {
                            continue;
                        }

                        if (fileStream.Length >= (long) NativeMethods.FCI.MAX_FOLDER)
                        {
                            throw new NotSupportedException(String.Format(
                                CultureInfo.InvariantCulture,
                                "File {0} exceeds maximum file size " +
                                "for cabinet format.",
                                file));
                        }

                        if (uncompressedBytesInFolder > 0)
                        {
                            // Automatically create a new folder if this file
                            // won't fit in the current folder.
                            bool nextFolder = uncompressedBytesInFolder
                                + fileStream.Length >= (long) NativeMethods.FCI.MAX_FOLDER;

                            // Otherwise ask the client if it wants to
                            // move to the next folder.
                            if (!nextFolder)
                            {
                                object nextFolderOption = streamContext.GetOption(
                                    "nextFolder",
                                    new object[] { file, this.currentFolderNumber });
                                nextFolder = Convert.ToBoolean(
                                    nextFolderOption, CultureInfo.InvariantCulture);
                            }

                            if (nextFolder)
                            {
                                this.FlushFolder();
                                uncompressedBytesInFolder = 0;
                            }
                        }

                        if (this.currentFolderTotalBytes > 0)
                        {
                            this.currentFolderTotalBytes = 0;
                            this.currentFolderNumber++;
                            uncompressedBytesInFolder = 0;
                        }

                        this.currentFileName = file;
                        this.currentFileNumber++;

                        this.currentFileTotalBytes = fileStream.Length;
                        this.currentFileBytesProcessed = 0;
                        this.OnProgress(ArchiveProgressType.StartFile);

                        uncompressedBytesInFolder += fileStream.Length;

                        this.AddFile(
                            file,
                            fileStream,
                            attributes,
                            lastWriteTime,
                            false,
                            this.CompressionLevel);
                    }

                    this.FlushFolder();
                    this.FlushCabinet();
                }
                finally
                {
                    if (this.CabStream != null)
                    {
                        this.context.CloseArchiveWriteStream(
                            this.currentArchiveNumber,
                            this.currentArchiveName,
                            this.CabStream);
                        this.CabStream = null;
                    }

                    if (this.FileStream != null)
                    {
                        this.context.CloseFileReadStream(
                            this.currentFileName, this.FileStream);
                        this.FileStream = null;
                    }
                    this.context = null;

                    if (this.fciHandle != null)
                    {
                        this.fciHandle.Dispose();
                        this.fciHandle = null;
                    }
                }
            }
        }

        internal override int CabOpenStreamEx(string path, int openFlags, int shareMode, out int err, IntPtr pv)
        {
            if (this.CabNumbers.ContainsKey(path))
            {
                Stream stream = this.CabStream;
                if (stream == null)
                {
                    short cabNumber = this.CabNumbers[path];

                    this.currentFolderTotalBytes = 0;

                    stream = this.context.OpenArchiveWriteStream(cabNumber, path, true, this.CabEngine);
                    if (stream == null)
                    {
                        throw new FileNotFoundException(
                            String.Format(CultureInfo.InvariantCulture, "Cabinet {0} not provided.", cabNumber));
                    }
                    this.currentArchiveName = path;

                    this.currentArchiveTotalBytes = Math.Min(
                        this.totalFolderBytesProcessedInCurrentCab, this.maxCabBytes);
                    this.currentArchiveBytesProcessed = 0;

                    this.OnProgress(ArchiveProgressType.StartArchive);
                    this.CabStream = stream;
                }
                path = CabWorker.CabStreamName;
            }
            else if (path == CabPacker.TempStreamName)
            {
                // Opening memory stream for a temp file.
                Stream stream = new MemoryStream();
                this.tempStreams.Add(stream);
                int streamHandle = this.StreamHandles.AllocHandle(stream);
                err = 0;
                return streamHandle;
            }
            else if (path != CabWorker.CabStreamName)
            {
                // Opening a file on disk for a temp file.
                path = Path.Combine(Path.GetTempPath(), path);
                Stream stream = new FileStream(path, FileMode.Open, FileAccess.ReadWrite);
                this.tempStreams.Add(stream);
                stream = new DuplicateStream(stream);
                int streamHandle = this.StreamHandles.AllocHandle(stream);
                err = 0;
                return streamHandle;
            }
            return base.CabOpenStreamEx(path, openFlags, shareMode, out err, pv);
        }

        internal override int CabWriteStreamEx(int streamHandle, IntPtr memory, int cb, out int err, IntPtr pv)
        {
            int count = base.CabWriteStreamEx(streamHandle, memory, cb, out err, pv);
            if (count > 0 && err == 0)
            {
                Stream stream = this.StreamHandles[streamHandle];
                if (DuplicateStream.OriginalStream(stream) ==
                    DuplicateStream.OriginalStream(this.CabStream))
                {
                    this.currentArchiveBytesProcessed += cb;
                    if (this.currentArchiveBytesProcessed > this.currentArchiveTotalBytes)
                    {
                        this.currentArchiveBytesProcessed = this.currentArchiveTotalBytes;
                    }
                }
            }
            return count;
        }

        internal override int CabCloseStreamEx(int streamHandle, out int err, IntPtr pv)
        {
            Stream stream = DuplicateStream.OriginalStream(this.StreamHandles[streamHandle]);

            if (stream == DuplicateStream.OriginalStream(this.FileStream))
            {
                this.context.CloseFileReadStream(this.currentFileName, stream);
                this.FileStream = null;
                long remainder = this.currentFileTotalBytes - this.currentFileBytesProcessed;
                this.currentFileBytesProcessed += remainder;
                this.fileBytesProcessed += remainder;
                this.OnProgress(ArchiveProgressType.FinishFile);

                this.currentFileTotalBytes = 0;
                this.currentFileBytesProcessed = 0;
                this.currentFileName = null;
            }
            else if (stream == DuplicateStream.OriginalStream(this.CabStream))
            {
                if (stream.CanWrite)
                {
                    stream.Flush();
                }

                this.currentArchiveBytesProcessed = this.currentArchiveTotalBytes;
                this.OnProgress(ArchiveProgressType.FinishArchive);
                this.currentArchiveNumber++;
                this.totalArchives++;

                this.context.CloseArchiveWriteStream(
                    this.currentArchiveNumber,
                    this.currentArchiveName,
                    stream);

                this.currentArchiveName = this.NextCabinetName;
                this.currentArchiveBytesProcessed = this.currentArchiveTotalBytes = 0;
                this.totalFolderBytesProcessedInCurrentCab = 0;

                this.CabStream = null;
            }
            else  // Must be a temp stream
            {
                stream.Close();
                this.tempStreams.Remove(stream);
            }
            return base.CabCloseStreamEx(streamHandle, out err, pv);
        }

        /// <summary>
        /// Disposes of resources allocated by the cabinet engine.
        /// </summary>
        /// <param name="disposing">If true, the method has been called directly or indirectly by a user's code,
        /// so managed and unmanaged resources will be disposed. If false, the method has been called by the 
        /// runtime from inside the finalizer, and only unmanaged resources will be disposed.</param>
        [SuppressMessage("Microsoft.Security", "CA2122:DoNotIndirectlyExposeMethodsWithLinkDemands")]
        protected override void Dispose(bool disposing) 
        {
            try
            {
                if (disposing)
                {
                    if (this.fciHandle != null)
                    {
                        this.fciHandle.Dispose();
                        this.fciHandle = null;
                    }
                }
            }
            finally
            {
                base.Dispose(disposing);
            }
        }

        private static NativeMethods.FCI.TCOMP GetCompressionType(CompressionLevel compLevel)
        {
            if (compLevel < CompressionLevel.Min)
            {
                return NativeMethods.FCI.TCOMP.TYPE_NONE;
            }
            else
            {
                if (compLevel > CompressionLevel.Max)
                {
                    compLevel = CompressionLevel.Max;
                }

                int lzxWindowMax =
                    ((int) NativeMethods.FCI.TCOMP.LZX_WINDOW_HI >> (int) NativeMethods.FCI.TCOMP.SHIFT_LZX_WINDOW) -
                    ((int) NativeMethods.FCI.TCOMP.LZX_WINDOW_LO >> (int) NativeMethods.FCI.TCOMP.SHIFT_LZX_WINDOW);
                int lzxWindow = lzxWindowMax *
                    (compLevel - CompressionLevel.Min) / (CompressionLevel.Max - CompressionLevel.Min);

                return (NativeMethods.FCI.TCOMP) ((int) NativeMethods.FCI.TCOMP.TYPE_LZX |
                    ((int) NativeMethods.FCI.TCOMP.LZX_WINDOW_LO +
                    (lzxWindow << (int) NativeMethods.FCI.TCOMP.SHIFT_LZX_WINDOW)));
            }
        }

        [SuppressMessage("Microsoft.Security", "CA2122:DoNotIndirectlyExposeMethodsWithLinkDemands")]
        private void AddFile(
            string name,
            Stream stream,
            FileAttributes attributes,
            DateTime lastWriteTime,
            bool execute,
            CompressionLevel compLevel)
        {
            this.FileStream = stream;
            this.fileAttributes = attributes &
                (FileAttributes.Archive | FileAttributes.Hidden | FileAttributes.ReadOnly | FileAttributes.System);
            this.fileLastWriteTime = lastWriteTime;
            this.currentFileName = name;

            NativeMethods.FCI.TCOMP tcomp = CabPacker.GetCompressionType(compLevel);

            IntPtr namePtr = IntPtr.Zero;
            try
            {
                Encoding nameEncoding = Encoding.ASCII;
                if (Encoding.UTF8.GetByteCount(name) > name.Length)
                {
                    nameEncoding = Encoding.UTF8;
                    this.fileAttributes |= FileAttributes.Normal;  // _A_NAME_IS_UTF
                }

                byte[] nameBytes = nameEncoding.GetBytes(name);
                namePtr = Marshal.AllocHGlobal(nameBytes.Length + 1);
                Marshal.Copy(nameBytes, 0, namePtr, nameBytes.Length);
                Marshal.WriteByte(namePtr, nameBytes.Length, 0);

                this.Erf.Clear();
                NativeMethods.FCI.AddFile(
                    this.fciHandle,
                    String.Empty,
                    namePtr,
                    execute,
                    this.fciGetNextCabinet,
                    this.fciCreateStatus,
                    this.fciGetOpenInfo,
                    tcomp);
            }
            finally
            {
                if (namePtr != IntPtr.Zero)
                {
                    Marshal.FreeHGlobal(namePtr);
                }
            }

            this.CheckError(false);
            this.FileStream = null;
            this.currentFileName = null;
        }

        private void FlushFolder()
        {
            this.Erf.Clear();
            NativeMethods.FCI.FlushFolder(this.fciHandle, this.fciGetNextCabinet, this.fciCreateStatus);
            this.CheckError(false);
        }

        private void FlushCabinet()
        {
            this.Erf.Clear();
            NativeMethods.FCI.FlushCabinet(this.fciHandle, false, this.fciGetNextCabinet, this.fciCreateStatus);
            this.CheckError(false);
        }

        private int CabGetOpenInfo(
            string path,
            out short date,
            out short time,
            out short attribs,
            out int err,
            IntPtr pv)
        {
            CompressionEngine.DateTimeToDosDateAndTime(this.fileLastWriteTime, out date, out time);
            attribs = (short) this.fileAttributes;

            Stream stream = this.FileStream;
            this.FileStream = new DuplicateStream(stream);
            int streamHandle = this.StreamHandles.AllocHandle(stream);
            err = 0;
            return streamHandle;
        }

        private int CabFilePlaced(
            IntPtr pccab,
            string filePath,
            long fileSize,
            int continuation,
            IntPtr pv)
        {
            return 0;
        }

        private int CabGetNextCabinet(IntPtr pccab, uint prevCabSize, IntPtr pv)
        {
            NativeMethods.FCI.CCAB nextCcab = new NativeMethods.FCI.CCAB();
            Marshal.PtrToStructure(pccab, nextCcab);

            nextCcab.szDisk = String.Empty;
            nextCcab.szCab = this.context.GetArchiveName(nextCcab.iCab);
            this.CabNumbers[nextCcab.szCab] = (short) nextCcab.iCab;
            this.NextCabinetName = nextCcab.szCab;

            Marshal.StructureToPtr(nextCcab, pccab, false);
            return 1;
        }

        private int CabCreateStatus(NativeMethods.FCI.STATUS typeStatus, uint cb1, uint cb2, IntPtr pv)
        {
            switch (typeStatus)
            {
                case NativeMethods.FCI.STATUS.FILE:
                    if (cb2 > 0 && this.currentFileBytesProcessed < this.currentFileTotalBytes)
                    {
                        if (this.currentFileBytesProcessed + cb2 > this.currentFileTotalBytes)
                        {
                            cb2 = (uint) this.currentFileTotalBytes - (uint) this.currentFileBytesProcessed;
                        }
                        this.currentFileBytesProcessed += cb2;
                        this.fileBytesProcessed += cb2;

                        this.OnProgress(ArchiveProgressType.PartialFile);
                    }
                    break;

                case NativeMethods.FCI.STATUS.FOLDER:
                    if (cb1 == 0)
                    {
                        this.currentFolderTotalBytes = cb2 - this.totalFolderBytesProcessedInCurrentCab;
                        this.totalFolderBytesProcessedInCurrentCab = cb2;
                    }
                    else if (this.currentFolderTotalBytes == 0)
                    {
                        this.OnProgress(ArchiveProgressType.PartialArchive);
                    }
                    break;

                case NativeMethods.FCI.STATUS.CABINET:
                    break;
            }
            return 0;
        }

        private int CabGetTempFile(IntPtr tempNamePtr, int tempNameSize, IntPtr pv)
        {
            string tempFileName;
            if (this.UseTempFiles)
            {
                tempFileName = Path.GetFileName(Path.GetTempFileName());
            }
            else
            {
                tempFileName = CabPacker.TempStreamName;
            }

            byte[] tempNameBytes = Encoding.ASCII.GetBytes(tempFileName);
            if (tempNameBytes.Length >= tempNameSize)
            {
                return -1;
            }

            Marshal.Copy(tempNameBytes, 0, tempNamePtr, tempNameBytes.Length);
            Marshal.WriteByte(tempNamePtr, tempNameBytes.Length, 0);  // null-terminator
            return 1;
        }

        private int CabDeleteFile(string path, out int err, IntPtr pv)
        {
            try
            {
                // Deleting a temp file - don't bother if it is only a memory stream.
                if (path != CabPacker.TempStreamName)
                {
                    path = Path.Combine(Path.GetTempPath(), path);
                    File.Delete(path);
                }
            }
            catch (IOException)
            {
                // Failure to delete a temp file is not fatal.
            }
            err = 0;
            return 1;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Compression.Zip\ZipInfo.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ZipInfo.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Zip
{
    using System;
    using System.Collections.Generic;
    using System.Runtime.Serialization;

    /// <summary>
    /// Object representing a zip file on disk; provides access to
    /// file-based operations on the zip file.
    /// </summary>
    /// <remarks>
    /// Generally, the methods on this class are much easier to use than the
    /// stream-based interfaces provided by the <see cref="ZipEngine"/> class.
    /// </remarks>
    [Serializable]
    public class ZipInfo : ArchiveInfo
    {
        /// <summary>
        /// Creates a new CabinetInfo object representing a zip file in a specified path.
        /// </summary>
        /// <param name="path">The path to the zip file. When creating a zip file, this file does not
        /// necessarily exist yet.</param>
        public ZipInfo(string path)
            : base(path)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CabinetInfo class with serialized data.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The StreamingContext that contains contextual information about the source or destination.</param>
        protected ZipInfo(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }

        /// <summary>
        /// Creates a compression engine that does the low-level work for
        /// this object.
        /// </summary>
        /// <returns>A new <see cref="ZipEngine"/> instance.</returns>
        /// <remarks>
        /// Each instance will be <see cref="CompressionEngine.Dispose()"/>d
        /// immediately after use.
        /// </remarks>
        protected override CompressionEngine CreateCompressionEngine()
        {
            return new ZipEngine();
        }

        /// <summary>
        /// Gets information about the files contained in the archive.
        /// </summary>
        /// <returns>A list of <see cref="ZipFileInfo"/> objects, each
        /// containing information about a file in the archive.</returns>
        public new IList<ZipFileInfo> GetFiles()
        {
            IList<ArchiveFileInfo> files = base.GetFiles();
            List<ZipFileInfo> zipFiles = new List<ZipFileInfo>(files.Count);
            foreach (ZipFileInfo zipFile in files) zipFiles.Add(zipFile);
            return zipFiles.AsReadOnly();
        }

        /// <summary>
        /// Gets information about the certain files contained in the archive file.
        /// </summary>
        /// <param name="searchPattern">The search string, such as
        /// &quot;*.txt&quot;.</param>
        /// <returns>A list of <see cref="ZipFileInfo"/> objects, each containing
        /// information about a file in the archive.</returns>
        public new IList<ZipFileInfo> GetFiles(string searchPattern)
        {
            IList<ArchiveFileInfo> files = base.GetFiles(searchPattern);
            List<ZipFileInfo> zipFiles = new List<ZipFileInfo>(files.Count);
            foreach (ZipFileInfo zipFile in files) zipFiles.Add(zipFile);
            return zipFiles.AsReadOnly();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Compression.Cab\CabUnpacker.cs ===
//---------------------------------------------------------------------
// <copyright file="CabUnpacker.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Cab
{
    using System;
    using System.IO;
    using System.Text;
    using System.Security.Permissions;
    using System.Collections.Generic;
    using System.Globalization;
    using System.Runtime.InteropServices;
    using System.Diagnostics.CodeAnalysis;

    internal class CabUnpacker : CabWorker
    {
        private NativeMethods.FDI.Handle fdiHandle;

        // These delegates need to be saved as member variables
        // so that they don't get GC'd.
        private NativeMethods.FDI.PFNALLOC fdiAllocMemHandler;
        private NativeMethods.FDI.PFNFREE fdiFreeMemHandler;
        private NativeMethods.FDI.PFNOPEN fdiOpenStreamHandler;
        private NativeMethods.FDI.PFNREAD fdiReadStreamHandler;
        private NativeMethods.FDI.PFNWRITE fdiWriteStreamHandler;
        private NativeMethods.FDI.PFNCLOSE fdiCloseStreamHandler;
        private NativeMethods.FDI.PFNSEEK fdiSeekStreamHandler;

        private IUnpackStreamContext context;

        private List<ArchiveFileInfo> fileList;

        private int folderId;

        private Predicate<string> filter;

        [SuppressMessage("Microsoft.Security", "CA2106:SecureAsserts")]
        [SuppressMessage("Microsoft.Security", "CA2122:DoNotIndirectlyExposeMethodsWithLinkDemands")]
        [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
        public CabUnpacker(CabEngine cabEngine)
            : base(cabEngine)
        {
            this.fdiAllocMemHandler = this.CabAllocMem;
            this.fdiFreeMemHandler = this.CabFreeMem;
            this.fdiOpenStreamHandler = this.CabOpenStream;
            this.fdiReadStreamHandler = this.CabReadStream;
            this.fdiWriteStreamHandler = this.CabWriteStream;
            this.fdiCloseStreamHandler = this.CabCloseStream;
            this.fdiSeekStreamHandler = this.CabSeekStream;

            this.fdiHandle = NativeMethods.FDI.Create(
                this.fdiAllocMemHandler,
                this.fdiFreeMemHandler,
                this.fdiOpenStreamHandler,
                this.fdiReadStreamHandler,
                this.fdiWriteStreamHandler,
                this.fdiCloseStreamHandler,
                this.fdiSeekStreamHandler,
                NativeMethods.FDI.CPU_80386,
                this.ErfHandle.AddrOfPinnedObject());
            if (this.Erf.Error)
            {
                int error = this.Erf.Oper;
                int errorCode = this.Erf.Type;
                this.ErfHandle.Free();
                throw new CabException(
                    error,
                    errorCode,
                    CabException.GetErrorMessage(error, errorCode, true));
            }
        }

        [SuppressMessage("Microsoft.Security", "CA2106:SecureAsserts")]
        [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
        public bool IsArchive(Stream stream)
        {
            if (stream == null)
            {
                throw new ArgumentNullException("stream");
            }

            lock (this)
            {
                short id;
                int folderCount, fileCount;
                return this.IsCabinet(stream, out id, out folderCount, out fileCount);
            }
        }

        [SuppressMessage("Microsoft.Security", "CA2106:SecureAsserts")]
        [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
        public IList<ArchiveFileInfo> GetFileInfo(
            IUnpackStreamContext streamContext,
            Predicate<string> fileFilter)
        {
            if (streamContext == null)
            {
                throw new ArgumentNullException("streamContext");
            }

            lock (this)
            {
                this.context = streamContext;
                this.filter = fileFilter;
                this.NextCabinetName = String.Empty;
                this.fileList = new List<ArchiveFileInfo>();
                bool tmpSuppress = this.SuppressProgressEvents;
                this.SuppressProgressEvents = true;
                try
                {
                    for (short cabNumber = 0;
                         this.NextCabinetName != null;
                         cabNumber++)
                    {
                        this.Erf.Clear();
                        this.CabNumbers[this.NextCabinetName] = cabNumber;
                        
                        NativeMethods.FDI.Copy(
                            this.fdiHandle,
                            this.NextCabinetName,
                            String.Empty,
                            0,
                            this.CabListNotify,
                            IntPtr.Zero,
                            IntPtr.Zero);
                        this.CheckError(true);
                    }

                    List<ArchiveFileInfo> tmpFileList = this.fileList;
                    this.fileList = null;
                    return tmpFileList.AsReadOnly();
                }
                finally
                {
                    this.SuppressProgressEvents = tmpSuppress;

                    if (this.CabStream != null)
                    {
                        this.context.CloseArchiveReadStream(
                            this.currentArchiveNumber,
                            this.currentArchiveName,
                            this.CabStream);
                        this.CabStream = null;
                    }

                    this.context = null;
                }
            }
        }

        [SuppressMessage("Microsoft.Security", "CA2106:SecureAsserts")]
        [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
        public void Unpack(
            IUnpackStreamContext streamContext,
            Predicate<string> fileFilter)
        {
            lock (this)
            {
                IList<ArchiveFileInfo> files =
                    this.GetFileInfo(streamContext, fileFilter);

                this.ResetProgressData();

                if (files != null)
                {
                    this.totalFiles = files.Count;

                    for (int i = 0; i < files.Count; i++)
                    {
                        this.totalFileBytes += files[i].Length;
                        if (files[i].ArchiveNumber >= this.totalArchives)
                        {
                            int totalArchives = files[i].ArchiveNumber + 1;
                            this.totalArchives = (short) totalArchives;
                        }
                    }
                }

                this.context = streamContext;
                this.fileList = null;
                this.NextCabinetName = String.Empty;
                this.folderId = -1;
                this.currentFileNumber = -1;

                try
                {
                    for (short cabNumber = 0;
                         this.NextCabinetName != null;
                         cabNumber++)
                    {
                        this.Erf.Clear();
                        this.CabNumbers[this.NextCabinetName] = cabNumber;

                        NativeMethods.FDI.Copy(
                            this.fdiHandle,
                            this.NextCabinetName,
                            String.Empty,
                            0,
                            this.CabExtractNotify,
                            IntPtr.Zero,
                            IntPtr.Zero);
                        this.CheckError(true);
                    }
                }
                finally
                {
                    if (this.CabStream != null)
                    {
                        this.context.CloseArchiveReadStream(
                            this.currentArchiveNumber,
                            this.currentArchiveName,
                            this.CabStream);
                        this.CabStream = null;
                    }

                    if (this.FileStream != null)
                    {
                        this.context.CloseFileWriteStream(this.currentFileName, this.FileStream, FileAttributes.Normal, DateTime.Now);
                        this.FileStream = null;
                    }

                    this.context = null;
                }
            }
        }

        internal override int CabOpenStreamEx(string path, int openFlags, int shareMode, out int err, IntPtr pv)
        {
            if (this.CabNumbers.ContainsKey(path))
            {
                Stream stream = this.CabStream;
                if (stream == null)
                {
                    short cabNumber = this.CabNumbers[path];

                    stream = this.context.OpenArchiveReadStream(cabNumber, path, this.CabEngine);
                    if (stream == null)
                    {
                        throw new FileNotFoundException(String.Format(CultureInfo.InvariantCulture, "Cabinet {0} not provided.", cabNumber));
                    }
                    this.currentArchiveName = path;
                    this.currentArchiveNumber = cabNumber;
                    if (this.totalArchives <= this.currentArchiveNumber)
                    {
                        int totalArchives = this.currentArchiveNumber + 1;
                        this.totalArchives = (short) totalArchives;
                    }
                    this.currentArchiveTotalBytes = stream.Length;
                    this.currentArchiveBytesProcessed = 0;

                    if (this.folderId != -3)  // -3 is a special folderId that requires re-opening the same cab
                    {
                        this.OnProgress(ArchiveProgressType.StartArchive);
                    }
                    this.CabStream = stream;
                }
                path = CabWorker.CabStreamName;
            }
            return base.CabOpenStreamEx(path, openFlags, shareMode, out err, pv);
        }

        internal override int CabReadStreamEx(int streamHandle, IntPtr memory, int cb, out int err, IntPtr pv)
        {
            int count = base.CabReadStreamEx(streamHandle, memory, cb, out err, pv);
            if (err == 0 && this.CabStream != null)
            {
                if (this.fileList == null)
                {
                    Stream stream = this.StreamHandles[streamHandle];
                    if (DuplicateStream.OriginalStream(stream) ==
                        DuplicateStream.OriginalStream(this.CabStream))
                    {
                        this.currentArchiveBytesProcessed += cb;
                        if (this.currentArchiveBytesProcessed > this.currentArchiveTotalBytes)
                        {
                            this.currentArchiveBytesProcessed = this.currentArchiveTotalBytes;
                        }
                    }
                }
            }
            return count;
        }

        internal override int CabWriteStreamEx(int streamHandle, IntPtr memory, int cb, out int err, IntPtr pv)
        {
            int count = base.CabWriteStreamEx(streamHandle, memory, cb, out err, pv);
            if (count > 0 && err == 0)
            {
                this.currentFileBytesProcessed += cb;
                this.fileBytesProcessed += cb;
                this.OnProgress(ArchiveProgressType.PartialFile);
            }
            return count;
        }

        internal override int CabCloseStreamEx(int streamHandle, out int err, IntPtr pv)
        {
            Stream stream = DuplicateStream.OriginalStream(this.StreamHandles[streamHandle]);

            if (stream == DuplicateStream.OriginalStream(this.CabStream))
            {
                if (this.folderId != -3)  // -3 is a special folderId that requires re-opening the same cab
                {
                    this.OnProgress(ArchiveProgressType.FinishArchive);
                }

                this.context.CloseArchiveReadStream(this.currentArchiveNumber, this.currentArchiveName, stream);

                this.currentArchiveName = this.NextCabinetName;
                this.currentArchiveBytesProcessed = this.currentArchiveTotalBytes = 0;

                this.CabStream = null;
            }
            return base.CabCloseStreamEx(streamHandle, out err, pv);
        }

        /// <summary>
        /// Disposes of resources allocated by the cabinet engine.
        /// </summary>
        /// <param name="disposing">If true, the method has been called directly or indirectly by a user's code,
        /// so managed and unmanaged resources will be disposed. If false, the method has been called by the 
        /// runtime from inside the finalizer, and only unmanaged resources will be disposed.</param>
        [SuppressMessage("Microsoft.Security", "CA2122:DoNotIndirectlyExposeMethodsWithLinkDemands")]
        protected override void Dispose(bool disposing)
        {
            try
            {
                if (disposing)
                {
                    if (this.fdiHandle != null)
                    {
                        this.fdiHandle.Dispose();
                        this.fdiHandle = null;
                    }
                }
            }
            finally
            {
                base.Dispose(disposing);
            }
        }

        private static string GetFileName(NativeMethods.FDI.NOTIFICATION notification)
        {
            bool utf8Name = (notification.attribs & (ushort) FileAttributes.Normal) != 0;  // _A_NAME_IS_UTF

            // Non-utf8 names should be completely ASCII. But for compatibility with
            // legacy tools, interpret them using the current (Default) ANSI codepage.
            Encoding nameEncoding = utf8Name ? Encoding.UTF8 : Encoding.Default;

            // Find how many bytes are in the string.
            // Unfortunately there is no faster way.
            int nameBytesCount = 0;
            while (Marshal.ReadByte(notification.psz1, nameBytesCount) != 0)
            {
                nameBytesCount++;
            }

            byte[] nameBytes = new byte[nameBytesCount];
            Marshal.Copy(notification.psz1, nameBytes, 0, nameBytesCount);
            string name = nameEncoding.GetString(nameBytes);
            if (Path.IsPathRooted(name))
            {
                name = name.Replace("" + Path.VolumeSeparatorChar, "");
            }

            return name;
        }

        private bool IsCabinet(Stream cabStream, out short id, out int cabFolderCount, out int fileCount)
        {
            int streamHandle = this.StreamHandles.AllocHandle(cabStream);
            try
            {
                this.Erf.Clear();
                NativeMethods.FDI.CABINFO fdici;
                bool isCabinet = 0 != NativeMethods.FDI.IsCabinet(this.fdiHandle, streamHandle, out fdici);

                if (this.Erf.Error)
                {
                    if (((NativeMethods.FDI.ERROR) this.Erf.Oper) == NativeMethods.FDI.ERROR.UNKNOWN_CABINET_VERSION)
                    {
                        isCabinet = false;
                    }
                    else
                    {
                        throw new CabException(
                            this.Erf.Oper,
                            this.Erf.Type,
                            CabException.GetErrorMessage(this.Erf.Oper, this.Erf.Type, true));
                    }
                }

                id = fdici.setID;
                cabFolderCount = (int) fdici.cFolders;
                fileCount = (int) fdici.cFiles;
                return isCabinet;
            }
            finally
            {
                this.StreamHandles.FreeHandle(streamHandle);
            }
        }

        private int CabListNotify(NativeMethods.FDI.NOTIFICATIONTYPE notificationType, NativeMethods.FDI.NOTIFICATION notification)
        {
            switch (notificationType)
            {
                case NativeMethods.FDI.NOTIFICATIONTYPE.CABINET_INFO:
                    {
                        string nextCab = Marshal.PtrToStringAnsi(notification.psz1);
                        this.NextCabinetName = (nextCab.Length != 0 ? nextCab : null);
                        return 0;  // Continue
                    }
                case NativeMethods.FDI.NOTIFICATIONTYPE.PARTIAL_FILE:
                    {
                        // This notification can occur when examining the contents of a non-first cab file.
                        return 0;  // Continue
                    }
                case NativeMethods.FDI.NOTIFICATIONTYPE.COPY_FILE:
                    {
                        //bool execute = (notification.attribs & (ushort) FileAttributes.Device) != 0;  // _A_EXEC

                        string name = CabUnpacker.GetFileName(notification);

                        if (this.filter == null || this.filter(name))
                        {
                            if (this.fileList != null)
                            {
                                FileAttributes attributes = (FileAttributes) notification.attribs &
                                    (FileAttributes.Archive | FileAttributes.Hidden | FileAttributes.ReadOnly | FileAttributes.System);
                                if (attributes == (FileAttributes) 0)
                                {
                                    attributes = FileAttributes.Normal;
                                }
                                DateTime lastWriteTime;
                                CompressionEngine.DosDateAndTimeToDateTime(notification.date, notification.time, out lastWriteTime);
                                long length = notification.cb;

                                CabFileInfo fileInfo = new CabFileInfo(
                                    name,
                                    notification.iFolder,
                                    notification.iCabinet,
                                    attributes,
                                    lastWriteTime,
                                    length);
                                this.fileList.Add(fileInfo);
                                this.currentFileNumber = this.fileList.Count - 1;
                                this.fileBytesProcessed += notification.cb;
                            }
                        }

                        this.totalFiles++;
                        this.totalFileBytes += notification.cb;
                        return 0;  // Continue
                    }
            }
            return 0;
        }

        private int CabExtractNotify(NativeMethods.FDI.NOTIFICATIONTYPE notificationType, NativeMethods.FDI.NOTIFICATION notification)
        {
            switch (notificationType)
            {
                case NativeMethods.FDI.NOTIFICATIONTYPE.CABINET_INFO:
                    {
                        if (this.NextCabinetName != null && this.NextCabinetName.StartsWith("?", StringComparison.Ordinal))
                        {
                            // We are just continuing the copy of a file that spanned cabinets.
                            // The next cabinet name needs to be preserved.
                            this.NextCabinetName = this.NextCabinetName.Substring(1);
                        }
                        else
                        {
                            string nextCab = Marshal.PtrToStringAnsi(notification.psz1);
                            this.NextCabinetName = (nextCab.Length != 0 ? nextCab : null);
                        }
                        return 0;  // Continue
                    }
                case NativeMethods.FDI.NOTIFICATIONTYPE.NEXT_CABINET:
                    {
                        string nextCab = Marshal.PtrToStringAnsi(notification.psz1);
                        this.CabNumbers[nextCab] = (short) notification.iCabinet;
                        this.NextCabinetName = "?" + this.NextCabinetName;
                        return 0;  // Continue
                    }
                case NativeMethods.FDI.NOTIFICATIONTYPE.COPY_FILE:
                    {
                        return this.CabExtractCopyFile(notification);
                    }
                case NativeMethods.FDI.NOTIFICATIONTYPE.CLOSE_FILE_INFO:
                    {
                        return this.CabExtractCloseFile(notification);
                    }
            }
            return 0;
        }

        private int CabExtractCopyFile(NativeMethods.FDI.NOTIFICATION notification)
        {
            if (notification.iFolder != this.folderId)
            {
                if (notification.iFolder != -3)  // -3 is a special folderId used when continuing a folder from a previous cab
                {
                    if (this.folderId != -1) // -1 means we just started the extraction sequence
                    {
                        this.currentFolderNumber++;
                    }
                }
                this.folderId = notification.iFolder;
            }

            //bool execute = (notification.attribs & (ushort) FileAttributes.Device) != 0;  // _A_EXEC

            string name = CabUnpacker.GetFileName(notification);

            if (this.filter == null || this.filter(name))
            {
                this.currentFileNumber++;
                this.currentFileName = name;

                this.currentFileBytesProcessed = 0;
                this.currentFileTotalBytes = notification.cb;
                this.OnProgress(ArchiveProgressType.StartFile);

                DateTime lastWriteTime;
                CompressionEngine.DosDateAndTimeToDateTime(notification.date, notification.time, out lastWriteTime);

                Stream stream = this.context.OpenFileWriteStream(name, notification.cb, lastWriteTime);
                if (stream != null)
                {
                    this.FileStream = stream;
                    int streamHandle = this.StreamHandles.AllocHandle(stream);
                    return streamHandle;
                }
                else
                {
                    this.fileBytesProcessed += notification.cb;
                    this.OnProgress(ArchiveProgressType.FinishFile);
                    this.currentFileName = null;
                }
            }
            return 0;  // Continue
        }

        private int CabExtractCloseFile(NativeMethods.FDI.NOTIFICATION notification)
        {
            Stream stream = this.StreamHandles[notification.hf];
            this.StreamHandles.FreeHandle(notification.hf);

            //bool execute = (notification.attribs & (ushort) FileAttributes.Device) != 0;  // _A_EXEC

            string name = CabUnpacker.GetFileName(notification);

            FileAttributes attributes = (FileAttributes) notification.attribs &
                (FileAttributes.Archive | FileAttributes.Hidden | FileAttributes.ReadOnly | FileAttributes.System);
            if (attributes == (FileAttributes) 0)
            {
                attributes = FileAttributes.Normal;
            }
            DateTime lastWriteTime;
            CompressionEngine.DosDateAndTimeToDateTime(notification.date, notification.time, out lastWriteTime);

            stream.Flush();
            this.context.CloseFileWriteStream(name, stream, attributes, lastWriteTime);
            this.FileStream = null;

            long remainder = this.currentFileTotalBytes - this.currentFileBytesProcessed;
            this.currentFileBytesProcessed += remainder;
            this.fileBytesProcessed += remainder;
            this.OnProgress(ArchiveProgressType.FinishFile);
            this.currentFileName = null;

            return 1;  // Continue
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Properties\AssemblyInfo.cs ===
﻿using System;
using System.Resources;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

[assembly: CLSCompliant(true)]
[assembly: NeutralResourcesLanguage("en-US")]
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("LFIT")]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("ee0eea6d-89be-4709-b22f-30110754d5cb")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LIVEnAuthClient\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Compression.Zip\CrcStream.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="CrcStream.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Zip
{
    using System;
    using System.IO;
    using System.Diagnostics.CodeAnalysis;

    /// <summary>
    /// Wraps a source stream and calcaluates a CRC over all bytes that are read or written.
    /// </summary>
    /// <remarks>
    /// The CRC algorithm matches that used in the standard ZIP file format.
    /// </remarks>
    [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Crc")]
    public class CrcStream : Stream
    {
        private Stream source;
        private uint crc;

        /// <summary>
        /// Creates a new CrcStream instance from a source stream.
        /// </summary>
        /// <param name="source">Underlying stream where bytes will be read from or written to.</param>
        public CrcStream(Stream source)
        {
            this.source = source;
        }

        /// <summary>
        /// Gets the current CRC over all bytes that have been read or written
        /// since this instance was created.
        /// </summary>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Crc")]
        [CLSCompliant(false)]
        public uint Crc
        {
            get
            {
                return this.crc;
            }
        }

        /// <summary>
        /// Gets the underlying stream that this stream reads from or writes to.
        /// </summary>
        public Stream Source
        {
            get
            {
                return this.source;
            }
        }

        /// <summary>
        /// Gets a value indicating whether the source stream supports reading.
        /// </summary>
        /// <value>true if the stream supports reading; otherwise, false.</value>
        public override bool CanRead
        {
            get
            {
                return this.source.CanRead;
            }
        }

        /// <summary>
        /// Gets a value indicating whether the source stream supports writing.
        /// </summary>
        /// <value>true if the stream supports writing; otherwise, false.</value>
        public override bool CanWrite
        {
            get
            {
                return this.source.CanWrite;
            }
        }

        /// <summary>
        /// Gets a value indicating whether the source stream supports seeking.
        /// </summary>
        /// <value>true if the stream supports seeking; otherwise, false.</value>
        public override bool CanSeek
        {
            get
            {
                return this.source.CanSeek;
            }
        }

        /// <summary>
        /// Gets the length of the source stream.
        /// </summary>
        public override long Length
        {
            get
            {
                return this.source.Length;
            }
        }

        /// <summary>
        /// Gets or sets the position of the source stream.
        /// </summary>
        public override long Position
        {
            get
            {
                return this.source.Position;
            }

            set
            {
                this.source.Position = value;
            }
        }

        /// <summary>
        /// Sets the position within the source stream.
        /// </summary>
        /// <param name="offset">A byte offset relative to the origin parameter.</param>
        /// <param name="origin">A value of type SeekOrigin indicating
        /// the reference point used to obtain the new position.</param>
        /// <returns>The new position within the source stream.</returns>
        /// <remarks>
        /// Note the CRC is only calculated over bytes that are actually read or
        /// written, so any bytes skipped by seeking will not contribute to the CRC.
        /// </remarks>
        public override long Seek(long offset, SeekOrigin origin)
        {
            return this.source.Seek(offset, origin);
        }

        /// <summary>
        /// Sets the length of the source stream.
        /// </summary>
        /// <param name="value">The desired length of the
        /// stream in bytes.</param>
        public override void SetLength(long value)
        {
            this.source.SetLength(value);
        }

        /// <summary>
        /// Reads a sequence of bytes from the source stream and advances
        /// the position within the stream by the number of bytes read.
        /// </summary>
        /// <param name="buffer">An array of bytes. When this method returns, the buffer
        /// contains the specified byte array with the values between offset and
        /// (offset + count - 1) replaced by the bytes read from the current source.</param>
        /// <param name="offset">The zero-based byte offset in buffer at which to begin
        /// storing the data read from the current stream.</param>
        /// <param name="count">The maximum number of bytes to be read from the current stream.</param>
        /// <returns>The total number of bytes read into the buffer. This can be less
        /// than the number of bytes requested if that many bytes are not currently available,
        /// or zero (0) if the end of the stream has been reached.</returns>
        public override int Read(byte[] buffer, int offset, int count)
        {
            count = this.source.Read(buffer, offset, count);
            this.UpdateCrc(buffer, offset, count);
            return count;
        }

        /// <summary>
        /// Writes a sequence of bytes to the source stream and advances the
        /// current position within this stream by the number of bytes written.
        /// </summary>
        /// <param name="buffer">An array of bytes. This method copies count
        /// bytes from buffer to the current stream.</param>
        /// <param name="offset">The zero-based byte offset in buffer at which
        /// to begin copying bytes to the current stream.</param>
        /// <param name="count">The number of bytes to be written to the
        /// current stream.</param>
        public override void Write(byte[] buffer, int offset, int count)
        {
            this.source.Write(buffer, offset, count);
            this.UpdateCrc(buffer, offset, count);
        }

        /// <summary>
        /// Flushes the source stream.
        /// </summary>
        public override void Flush()
        {
            this.source.Flush();
        }

        /// <summary>
        /// Closes the underlying stream.
        /// </summary>
        public override void Close()
        {
            this.source.Close();
            base.Close();
        }

        /// <summary>
        /// Updates the CRC with a range of bytes that were read or written.
        /// </summary>
        private void UpdateCrc(byte[] buffer, int offset, int count)
        {
            this.crc = ~this.crc;
            for( ; count > 0; count--, offset++)
            {
                this.crc = (this.crc >> 8) ^
                    CrcStream.crcTable[(this.crc  & 0xFF) ^ buffer[offset]];
            }
            this.crc = ~this.crc;
        }

        private static uint[] crcTable = MakeCrcTable();

        /// <summary>
        /// Computes a table that speeds up calculation of the CRC.
        /// </summary>
        private static uint[] MakeCrcTable()
        {
            const uint poly = 0x04C11DB7u;
            uint[] crcTable = new uint[256];
            for(uint n = 0; n < 256; n++)
            {
                uint c = CrcStream.Reflect(n, 8);
                c = c << 24;
                for(uint k = 0; k < 8; k++)
                {
                    c = (c << 1) ^ ((c & 0x80000000u) != 0 ? poly : 0);
                }
                crcTable[n] = CrcStream.Reflect(c, 32);
            }
            return crcTable;
        }

        /// <summary>
        /// Reflects the ordering of certain number of bits. For exmample when reflecting
        /// one byte, bit one is swapped with bit eight, bit two with bit seven, etc.
        /// </summary>
        private static uint Reflect(uint value, int bits)
        {
            for (int i = 0; i < bits / 2; i++)
            {
                uint leftBit = 1u << (bits - 1 - i);
                uint rightBit = 1u << i;
                if (((value & leftBit) != 0) != ((value & rightBit) != 0))
                {
                    value ^= leftBit | rightBit;
                }
            }
            return value;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Compression.Zip\ZipEngine.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ZipEngine.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Zip
{
    using System;
    using System.IO;
    using System.IO.Compression;
    using System.Collections.Generic;
    using System.Reflection;
    using System.Diagnostics.CodeAnalysis;

    /// <summary>
    /// Engine capable of packing and unpacking archives in the zip format.
    /// </summary>
    public partial class ZipEngine : CompressionEngine
    {
        private static Dictionary<ZipCompressionMethod, Converter<Stream, Stream>>
            compressionStreamCreators;
        private static Dictionary<ZipCompressionMethod, Converter<Stream, Stream>>
            decompressionStreamCreators;

        private static void InitCompressionStreamCreators()
        {
            if (ZipEngine.compressionStreamCreators == null)
            {
                ZipEngine.compressionStreamCreators = new
                    Dictionary<ZipCompressionMethod, Converter<Stream, Stream>>();
                ZipEngine.decompressionStreamCreators = new
                    Dictionary<ZipCompressionMethod, Converter<Stream, Stream>>();

                ZipEngine.RegisterCompressionStreamCreator(
                    ZipCompressionMethod.Store,
                    CompressionMode.Compress,
                    delegate(Stream stream) {
                        return stream;
                    });
                ZipEngine.RegisterCompressionStreamCreator(
                    ZipCompressionMethod.Deflate,
                    CompressionMode.Compress,
                    delegate(Stream stream) {
                        return new DeflateStream(stream, CompressionMode.Compress, true);
                    });
                ZipEngine.RegisterCompressionStreamCreator(
                    ZipCompressionMethod.Store,
                    CompressionMode.Decompress,
                    delegate(Stream stream) {
                        return stream;
                    });
                ZipEngine.RegisterCompressionStreamCreator(
                    ZipCompressionMethod.Deflate,
                    CompressionMode.Decompress,
                    delegate(Stream stream) {
                        return new DeflateStream(stream, CompressionMode.Decompress, true);
                    });
            }
        }

        /// <summary>
        /// Registers a delegate that can create a warpper stream for
        /// compressing or uncompressing the data of a source stream.
        /// </summary>
        /// <param name="compressionMethod">Compression method being registered.</param>
        /// <param name="compressionMode">Indicates registration for ether
        /// compress or decompress mode.</param>
        /// <param name="creator">Delegate being registered.</param>
        /// <remarks>
        /// For compression, the delegate accepts a stream that writes to the archive
        /// and returns a wrapper stream that compresses bytes as they are written.
        /// For decompression, the delegate accepts a stream that reads from the archive
        /// and returns a wrapper stream that decompresses bytes as they are read.
        /// This wrapper stream model follows the design used by
        /// System.IO.Compression.DeflateStream, and indeed that class is used
        /// to implement the Deflate compression method by default.
        /// <para>To unregister a delegate, call this method again and pass
        /// null for the delegate parameter.</para>
        /// </remarks>
        /// <example>
        /// When the ZipEngine class is initialized, the Deflate compression method
        /// is automatically registered like this:
        /// <code>
        ///        ZipEngine.RegisterCompressionStreamCreator(
        ///            ZipCompressionMethod.Deflate,
        ///            CompressionMode.Compress,
        ///            delegate(Stream stream) {
        ///                return new DeflateStream(stream, CompressionMode.Compress, true);
        ///            });
        ///        ZipEngine.RegisterCompressionStreamCreator(
        ///            ZipCompressionMethod.Deflate,
        ///            CompressionMode.Decompress,
        ///            delegate(Stream stream) {
        ///                return new DeflateStream(stream, CompressionMode.Decompress, true);
        ///            });
        /// </code></example>
        public static void RegisterCompressionStreamCreator(
            ZipCompressionMethod compressionMethod,
            CompressionMode compressionMode,
            Converter<Stream, Stream> creator)
        {
            ZipEngine.InitCompressionStreamCreators();
            if (compressionMode == CompressionMode.Compress)
            {
                ZipEngine.compressionStreamCreators[compressionMethod] = creator;
            }
            else
            {
                ZipEngine.decompressionStreamCreators[compressionMethod] = creator;
            }
        }

        // Progress data
        private string currentFileName;
        private int currentFileNumber;
        private int totalFiles;
        private long currentFileBytesProcessed;
        private long currentFileTotalBytes;
        private string mainArchiveName;
        private string currentArchiveName;
        private short currentArchiveNumber;
        private short totalArchives;
        private long currentArchiveBytesProcessed;
        private long currentArchiveTotalBytes;
        private long fileBytesProcessed;
        private long totalFileBytes;
        private string comment;

        /// <summary>
        /// Creates a new instance of the zip engine.
        /// </summary>
        public ZipEngine()
            : base()
        {
            ZipEngine.InitCompressionStreamCreators();
        }

        /// <summary>
        /// Gets the comment from the last-examined archive,
        /// or sets the comment to be added to any created archives.
        /// </summary>
        public string ArchiveComment
        {
            get
            {
                return this.comment;
            }
            set
            {
                this.comment = value;
            }
        }

        /// <summary>
        /// Checks whether a Stream begins with a header that indicates
        /// it is a valid archive file.
        /// </summary>
        /// <param name="stream">Stream for reading the archive file.</param>
        /// <returns>True if the stream is a valid zip archive
        /// (with no offset); false otherwise.</returns>
        public override bool IsArchive(Stream stream)
        {
            if (stream == null)
            {
                throw new ArgumentNullException("stream");
            }

            if (stream.Length - stream.Position < 4)
            {
                return false;
            }

            BinaryReader reader = new BinaryReader(stream);
            uint sig = reader.ReadUInt32();
            switch (sig)
            {
                case ZipFileHeader.LFHSIG:
                case ZipEndOfCentralDirectory.EOCDSIG:
                case ZipEndOfCentralDirectory.EOCD64SIG:
                case ZipFileHeader.SPANSIG:
                case ZipFileHeader.SPANSIG2:
                    return true;
                default:
                    return false;
            }
        }

        /// <summary>
        /// Gets the offset of an archive that is positioned 0 or more bytes
        /// from the start of the Stream.
        /// </summary>
        /// <param name="stream">A stream for reading the archive.</param>
        /// <returns>The offset in bytes of the archive,
        /// or -1 if no archive is found in the Stream.</returns>
        /// <remarks>The archive must begin on a 4-byte boundary.</remarks>
        public override long FindArchiveOffset(Stream stream)
        {
            long offset = base.FindArchiveOffset(stream);
            if (offset > 0)
            {
                // Some self-extract packages include the exe stub in file offset calculations.
                // Check the first header directory offset to decide whether the entire
                // archive needs to be offset or not.

                ZipEndOfCentralDirectory eocd = this.GetEOCD(null, stream);
                if (eocd != null && eocd.totalEntries > 0)
                {
                    stream.Seek(eocd.dirOffset, SeekOrigin.Begin);

                    ZipFileHeader header = new ZipFileHeader();
                    if (header.Read(stream, true) && header.localHeaderOffset < stream.Length)
                    {
                        stream.Seek(header.localHeaderOffset, SeekOrigin.Begin);
                        if (header.Read(stream, false))
                        {
                            return 0;
                        }
                    }
                }
            }

            return offset;
        }

        /// <summary>
        /// Gets information about files in a zip archive or archive chain.
        /// </summary>
        /// <param name="streamContext">A context interface to handle opening
        /// and closing of archive and file streams.</param>
        /// <param name="fileFilter">A predicate that can determine
        /// which files to process, optional.</param>
        /// <returns>Information about files in the archive stream.</returns>
        /// <exception cref="ArchiveException">The archive provided
        /// by the stream context is not valid.</exception>
        /// <remarks>
        /// The <paramref name="fileFilter"/> predicate takes an internal file
        /// path and returns true to include the file or false to exclude it.
        /// </remarks>
        public override IList<ArchiveFileInfo> GetFileInfo(
            IUnpackStreamContext streamContext,
            Predicate<string> fileFilter)
        {
            if (streamContext == null)
            {
                throw new ArgumentNullException("streamContext");
            }

            lock (this)
            {
                IList<ZipFileHeader> headers = this.GetCentralDirectory(streamContext);
                if (headers == null)
                {
                    throw new ZipException("Zip central directory not found.");
                }

                List<ArchiveFileInfo> files = new List<ArchiveFileInfo>(headers.Count);
                foreach (ZipFileHeader header in headers)
                {
                    if (!header.IsDirectory &&
                        (fileFilter == null || fileFilter(header.fileName)))
                    {
                        files.Add(header.ToZipFileInfo());
                    }
                }

                return files.AsReadOnly();
            }
        }

        /// <summary>
        /// Reads all the file headers from the central directory in the main archive.
        /// </summary>
        private IList<ZipFileHeader> GetCentralDirectory(IUnpackStreamContext streamContext)
        {
            Stream archiveStream = null;
            this.currentArchiveNumber = 0;
            try
            {
                List<ZipFileHeader> headers = new List<ZipFileHeader>();
                archiveStream = this.OpenArchive(streamContext, 0);

                ZipEndOfCentralDirectory eocd = this.GetEOCD(streamContext, archiveStream);
                if (eocd == null)
                {
                    return null;
                }
                else if (eocd.totalEntries == 0)
                {
                    return headers;
                }

                headers.Capacity = (int) eocd.totalEntries;

                if (eocd.dirOffset > archiveStream.Length - ZipFileHeader.CFH_FIXEDSIZE)
                {
                    streamContext.CloseArchiveReadStream(
                        this.currentArchiveNumber, String.Empty, archiveStream);
                    archiveStream = null;
                }
                else
                {
                    archiveStream.Seek(eocd.dirOffset, SeekOrigin.Begin);
                    uint sig = new BinaryReader(archiveStream).ReadUInt32();
                    if (sig != ZipFileHeader.CFHSIG)
                    {
                        streamContext.CloseArchiveReadStream(
                            this.currentArchiveNumber, String.Empty, archiveStream);
                        archiveStream = null;
                    }
                }

                if (archiveStream == null)
                {
                    this.currentArchiveNumber = (short) (eocd.dirStartDiskNumber + 1);
                    archiveStream = streamContext.OpenArchiveReadStream(
                        this.currentArchiveNumber, String.Empty, this);

                    if (archiveStream == null)
                    {
                        return null;
                    }
                }

                archiveStream.Seek(eocd.dirOffset, SeekOrigin.Begin);

                while (headers.Count < eocd.totalEntries)
                {
                    ZipFileHeader header = new ZipFileHeader();
                    if (!header.Read(archiveStream, true))
                    {
                        throw new ZipException(
                            "Missing or invalid central directory file header");
                    }

                    headers.Add(header);

                    if (headers.Count < eocd.totalEntries &&
                        archiveStream.Position == archiveStream.Length)
                    {
                        streamContext.CloseArchiveReadStream(
                            this.currentArchiveNumber, String.Empty, archiveStream);
                        this.currentArchiveNumber++;
                        archiveStream = streamContext.OpenArchiveReadStream(
                            this.currentArchiveNumber, String.Empty, this);
                        if (archiveStream == null)
                        {
                            this.currentArchiveNumber = 0;
                            archiveStream = streamContext.OpenArchiveReadStream(
                                this.currentArchiveNumber, String.Empty, this);
                        }
                    }
                }

                return headers;
            }
            finally
            {
                if (archiveStream != null)
                {
                    streamContext.CloseArchiveReadStream(
                        this.currentArchiveNumber, String.Empty, archiveStream);
                }
            }
        }

        /// <summary>
        /// Locates and reads the end of central directory record near the
        /// end of the archive.
        /// </summary>
        [SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic")]
        [SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId = "streamContext")]
        private ZipEndOfCentralDirectory GetEOCD(
            IUnpackStreamContext streamContext, Stream archiveStream)
        {
            BinaryReader reader = new BinaryReader(archiveStream);
            long offset = archiveStream.Length
                - ZipEndOfCentralDirectory.EOCD_RECORD_FIXEDSIZE;
            while (offset >= 0)
            {
                archiveStream.Seek(offset, SeekOrigin.Begin);

                uint sig = reader.ReadUInt32();
                if (sig == ZipEndOfCentralDirectory.EOCDSIG)
                {
                    break;
                }

                offset--;
            }

            if (offset < 0)
            {
                return null;
            }

            ZipEndOfCentralDirectory eocd = new ZipEndOfCentralDirectory();
            archiveStream.Seek(offset, SeekOrigin.Begin);
            if (!eocd.Read(archiveStream))
            {
                throw new ZipException("Invalid end of central directory record");
            }

            if (eocd.dirOffset == (long) UInt32.MaxValue)
            {
                string saveComment = eocd.comment;

                archiveStream.Seek(
                    offset - Zip64EndOfCentralDirectoryLocator.EOCDL64_SIZE,
                    SeekOrigin.Begin);

                Zip64EndOfCentralDirectoryLocator eocdl =
                    new Zip64EndOfCentralDirectoryLocator();
                if (!eocdl.Read(archiveStream))
                {
                    throw new ZipException("Missing or invalid end of " +
                        "central directory record locator");
                }

                if (eocdl.dirStartDiskNumber == eocdl.totalDisks - 1)
                {
                    // ZIP64 eocd is entirely in current stream.
                    archiveStream.Seek(eocdl.dirOffset, SeekOrigin.Begin);
                    if (!eocd.Read(archiveStream))
                    {
                        throw new ZipException("Missing or invalid ZIP64 end of " +
                            "central directory record");
                    }
                }
                else if (streamContext == null)
                {
                    return null;
                }
                else
                {
                    // TODO: handle EOCD64 spanning archives!
                    throw new NotImplementedException("Zip implementation does not " +
                        "handle end of central directory record that spans archives.");
                }

                eocd.comment = saveComment;
            }

            return eocd;
        }

        private void ResetProgressData()
        {
            this.currentFileName = null;
            this.currentFileNumber = 0;
            this.totalFiles = 0;
            this.currentFileBytesProcessed = 0;
            this.currentFileTotalBytes = 0;
            this.currentArchiveName = null;
            this.currentArchiveNumber = 0;
            this.totalArchives = 0;
            this.currentArchiveBytesProcessed = 0;
            this.currentArchiveTotalBytes = 0;
            this.fileBytesProcessed = 0;
            this.totalFileBytes = 0;
        }

        private void OnProgress(ArchiveProgressType progressType)
        {
            ArchiveProgressEventArgs e = new ArchiveProgressEventArgs(
                progressType,
                this.currentFileName,
                this.currentFileNumber >= 0 ? this.currentFileNumber : 0,
                this.totalFiles,
                this.currentFileBytesProcessed,
                this.currentFileTotalBytes,
                this.currentArchiveName,
                this.currentArchiveNumber,
                this.totalArchives,
                this.currentArchiveBytesProcessed,
                this.currentArchiveTotalBytes,
                this.fileBytesProcessed,
                this.totalFileBytes);
            this.OnProgress(e);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Compression.Zip\ZipPacker.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ZipPacker.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Zip
{
    using System;
    using System.IO;
    using System.IO.Compression;
    using System.Collections.Generic;
    using System.Globalization;

    public partial class ZipEngine
    {
        /// <summary>
        /// Creates a zip archive or chain of zip archives.
        /// </summary>
        /// <param name="streamContext">A context interface to handle opening
        /// and closing of archive and file streams.</param>
        /// <param name="files">An array of file lists.  Each list is
        /// compressed into one stream in the archive.</param>
        /// <param name="maxArchiveSize">The maximum number of bytes for one archive
        /// before the contents are chained to the next archive, or zero for unlimited
        /// archive size.</param>
        /// <exception cref="ArchiveException">The archive could not be
        /// created.</exception>
        /// <remarks>
        /// The stream context implementation may provide a mapping from the file
        /// paths within the archive to the external file paths.
        /// </remarks>
        public override void Pack(
            IPackStreamContext streamContext,
            IEnumerable<string> files,
            long maxArchiveSize)
        {
            if (streamContext == null)
            {
                throw new ArgumentNullException("streamContext");
            }

            if (files == null)
            {
                throw new ArgumentNullException("files");
            }

            lock (this)
            {
                Stream archiveStream = null;
                try
                {
                    this.ResetProgressData();
                    this.totalArchives = 1;

                    object forceZip64Value = streamContext.GetOption("forceZip64", null);
                    bool forceZip64 = Convert.ToBoolean(
                        forceZip64Value, CultureInfo.InvariantCulture);

                    // Count the total number of files and bytes to be compressed.
                    foreach (string file in files)
                    {
                        FileAttributes attributes;
                        DateTime lastWriteTime;
                        Stream fileStream = streamContext.OpenFileReadStream(
                            file,
                            out attributes,
                            out lastWriteTime);
                        if (fileStream != null)
                        {
                            this.totalFileBytes += fileStream.Length;
                            this.totalFiles++;
                            streamContext.CloseFileReadStream(file, fileStream);
                        }
                    }

                    List<ZipFileHeader> fileHeaders = new List<ZipFileHeader>();
                    this.currentFileNumber = -1;

                    if (this.currentArchiveName == null)
                    {
                        this.mainArchiveName = streamContext.GetArchiveName(0);
                        this.currentArchiveName = this.mainArchiveName;

                        if (String.IsNullOrEmpty(this.currentArchiveName))
                        {
                            throw new FileNotFoundException("No name provided for archive.");
                        }
                    }

                    this.OnProgress(ArchiveProgressType.StartArchive);

                    // Compress files one by one, saving header info for each.
                    foreach (string file in files)
                    {
                        ZipFileHeader fileHeader = this.PackOneFile(
                                streamContext,
                                file,
                                maxArchiveSize,
                                forceZip64,
                                ref archiveStream);

                        if (fileHeader != null)
                        {
                            fileHeaders.Add(fileHeader);
                        }

                        this.currentArchiveTotalBytes = (archiveStream != null ?
                            archiveStream.Position : 0);
                        this.currentArchiveBytesProcessed = this.currentArchiveTotalBytes;
                    }

                    // Write the central directory composed of all the file headers.
                    bool zip64 = forceZip64;
                    uint centralDirStartArchiveNumber = 0;
                    long centralDirStartPosition = 0;
                    long centralDirSize = 0;
                    for (int i = 0; i < fileHeaders.Count; i++)
                    {
                        ZipFileHeader fileHeader = fileHeaders[i];

                        int headerSize = fileHeader.GetSize(true);
                        centralDirSize += headerSize;

                        this.CheckArchiveWriteStream(
                            streamContext,
                            maxArchiveSize,
                            headerSize,
                            ref archiveStream);

                        if (i == 0)
                        {
                            centralDirStartArchiveNumber = (uint) this.currentArchiveNumber;
                            centralDirStartPosition = archiveStream.Position;
                        }

                        fileHeader.Write(archiveStream, true);
                        if (fileHeader.zip64)
                        {
                            zip64 = true;
                        }
                    }

                    this.currentArchiveTotalBytes =
                        (archiveStream != null ? archiveStream.Position : 0);
                    this.currentArchiveBytesProcessed = this.currentArchiveTotalBytes;

                    ZipEndOfCentralDirectory eocd = new ZipEndOfCentralDirectory();
                    eocd.dirStartDiskNumber = centralDirStartArchiveNumber;
                    eocd.entriesOnDisk = fileHeaders.Count;
                    eocd.totalEntries = fileHeaders.Count;
                    eocd.dirSize = centralDirSize;
                    eocd.dirOffset = centralDirStartPosition;
                    eocd.comment = this.comment;

                    Zip64EndOfCentralDirectoryLocator eocdl =
                        new Zip64EndOfCentralDirectoryLocator();

                    int maxFooterSize = eocd.GetSize(false);
                    if (archiveStream != null && (zip64 || archiveStream.Position >
                        ((long) UInt32.MaxValue) - eocd.GetSize(false)))
                    {
                        maxFooterSize += eocd.GetSize(true) + (int)
                            Zip64EndOfCentralDirectoryLocator.EOCDL64_SIZE;
                        zip64 = true;
                    }

                    this.CheckArchiveWriteStream(
                        streamContext,
                        maxArchiveSize,
                        maxFooterSize,
                        ref archiveStream);
                    eocd.diskNumber = (uint) this.currentArchiveNumber;

                    if (zip64)
                    {
                        eocd.versionMadeBy = 45;
                        eocd.versionNeeded = 45;
                        eocd.zip64 = true;
                        eocdl.dirOffset = archiveStream.Position;
                        eocdl.dirStartDiskNumber = (uint) this.currentArchiveNumber;
                        eocdl.totalDisks = (uint) this.currentArchiveNumber + 1;
                        eocd.Write(archiveStream);
                        eocdl.Write(archiveStream);

                        if (forceZip64)
                        {
                            eocd.dirOffset = UInt32.MaxValue;
                            eocd.dirStartDiskNumber = UInt16.MaxValue;
                        }
                    }

                    eocd.zip64 = false;
                    eocd.Write(archiveStream);

                    this.currentArchiveTotalBytes = archiveStream.Position;
                    this.currentArchiveBytesProcessed = this.currentArchiveTotalBytes;
                }
                finally
                {
                    if (archiveStream != null)
                    {
                        streamContext.CloseArchiveWriteStream(
                            this.currentArchiveNumber, this.mainArchiveName, archiveStream);
                        this.OnProgress(ArchiveProgressType.FinishArchive);
                    }
                }
            }
        }

        /// <summary>
        /// Moves to the next archive in the sequence if necessary.
        /// </summary>
        private void CheckArchiveWriteStream(
            IPackStreamContext streamContext,
            long maxArchiveSize,
            long requiredSize,
            ref Stream archiveStream)
        {
            if (archiveStream != null &&
                archiveStream.Length > 0 && maxArchiveSize > 0)
            {
                long sizeRemaining = maxArchiveSize - archiveStream.Length;
                if (sizeRemaining < requiredSize)
                {
                    string nextArchiveName = streamContext.GetArchiveName(
                        this.currentArchiveNumber + 1);

                    if (String.IsNullOrEmpty(nextArchiveName))
                    {
                        throw new FileNotFoundException("No name provided for archive #" +
                            this.currentArchiveNumber + 1);
                    }

                    this.currentArchiveTotalBytes = archiveStream.Position;
                    this.currentArchiveBytesProcessed = this.currentArchiveTotalBytes;

                    streamContext.CloseArchiveWriteStream(
                        this.currentArchiveNumber,
                        nextArchiveName,
                        archiveStream);
                    archiveStream = null;

                    this.OnProgress(ArchiveProgressType.FinishArchive);

                    this.currentArchiveNumber++;
                    this.totalArchives++;
                    this.currentArchiveBytesProcessed = 0;
                    this.currentArchiveTotalBytes = 0;
                }
            }

            if (archiveStream == null)
            {
                if (this.currentArchiveNumber > 0)
                {
                    this.OnProgress(ArchiveProgressType.StartArchive);
                }

                archiveStream = streamContext.OpenArchiveWriteStream(
                    this.currentArchiveNumber, this.mainArchiveName, true, this);

                if (archiveStream == null)
                {
                    throw new FileNotFoundException("Stream not provided for archive #" +
                        this.currentArchiveNumber);
                }
            }
        }

        /// <summary>
        /// Adds one file to a zip archive in the process of being created.
        /// </summary>
        private ZipFileHeader PackOneFile(
            IPackStreamContext streamContext,
            string file,
            long maxArchiveSize,
            bool forceZip64,
            ref Stream archiveStream)
        {
            Stream fileStream = null;
            int headerArchiveNumber = 0;
            try
            {
                // TODO: call GetOption to get compression method for the specific file
                ZipCompressionMethod compressionMethod = ZipCompressionMethod.Deflate;
                if (this.CompressionLevel == CompressionLevel.None)
                {
                    compressionMethod = ZipCompressionMethod.Store;
                }

                Converter<Stream, Stream> compressionStreamCreator;
                if (!ZipEngine.compressionStreamCreators.TryGetValue(
                    compressionMethod, out compressionStreamCreator))
                {
                    return null;
                }

                FileAttributes attributes;
                DateTime lastWriteTime;
                fileStream = streamContext.OpenFileReadStream(
                    file, out attributes, out lastWriteTime);
                if (fileStream == null)
                {
                    return null;
                }

                this.currentFileName = file;
                this.currentFileNumber++;

                this.currentFileTotalBytes = fileStream.Length;
                this.currentFileBytesProcessed = 0;
                this.OnProgress(ArchiveProgressType.StartFile);

                ZipFileInfo fileInfo = new ZipFileInfo(
                    file,
                    this.currentArchiveNumber,
                    attributes,
                    lastWriteTime,
                    fileStream.Length,
                    0,
                    compressionMethod);

                bool zip64 = forceZip64 || fileStream.Length >= (long) UInt32.MaxValue;
                ZipFileHeader fileHeader = new ZipFileHeader(fileInfo, zip64);

                this.CheckArchiveWriteStream(
                    streamContext,
                    maxArchiveSize,
                    fileHeader.GetSize(false),
                    ref archiveStream);

                long headerPosition = archiveStream.Position;
                fileHeader.Write(archiveStream, false);
                headerArchiveNumber = this.currentArchiveNumber;

                uint crc;
                long bytesWritten = this.PackFileBytes(
                    streamContext,
                    fileStream,
                    maxArchiveSize,
                    compressionStreamCreator,
                    ref archiveStream,
                    out crc);

                fileHeader.Update(
                    bytesWritten,
                    fileStream.Length,
                    crc,
                    headerPosition,
                    headerArchiveNumber);

                streamContext.CloseFileReadStream(file, fileStream);
                fileStream = null;

                // Go back and rewrite the updated file header.
                if (this.currentArchiveNumber == headerArchiveNumber)
                {
                    long fileEndPosition = archiveStream.Position;
                    archiveStream.Seek(headerPosition, SeekOrigin.Begin);
                    fileHeader.Write(archiveStream, false);
                    archiveStream.Seek(fileEndPosition, SeekOrigin.Begin);
                }
                else
                {
                    // The file spanned archives, so temporarily reopen
                    // the archive where it started.
                    string headerArchiveName = streamContext.GetArchiveName(
                        headerArchiveNumber + 1);
                    Stream headerStream = null;
                    try
                    {
                        headerStream = streamContext.OpenArchiveWriteStream(
                            headerArchiveNumber, headerArchiveName, false, this);
                        headerStream.Seek(headerPosition, SeekOrigin.Begin);
                        fileHeader.Write(headerStream, false);
                    }
                    finally
                    {
                        if (headerStream != null)
                        {
                            streamContext.CloseArchiveWriteStream(
                                headerArchiveNumber, headerArchiveName, headerStream);
                        }
                    }
                }

                this.OnProgress(ArchiveProgressType.FinishFile);

                return fileHeader;
            }
            finally
            {
                if (fileStream != null)
                {
                    streamContext.CloseFileReadStream(
                        this.currentFileName, fileStream);
                }
            }
        }

        /// <summary>
        /// Writes compressed bytes of one file to the archive,
        /// keeping track of the CRC and number of bytes written.
        /// </summary>
        private long PackFileBytes(
            IPackStreamContext streamContext,
            Stream fileStream,
            long maxArchiveSize,
            Converter<Stream, Stream> compressionStreamCreator,
            ref Stream archiveStream,
            out uint crc)
        {
            long writeStartPosition = archiveStream.Position;
            long bytesWritten = 0;
            CrcStream fileCrcStream = new CrcStream(fileStream);

            ConcatStream concatStream = new ConcatStream(
                delegate(ConcatStream s)
                {
                    Stream sourceStream = s.Source;
                    bytesWritten += sourceStream.Position - writeStartPosition;

                    this.CheckArchiveWriteStream(
                        streamContext,
                        maxArchiveSize,
                        1,
                        ref sourceStream);

                    writeStartPosition = sourceStream.Position;
                    s.Source = sourceStream;
                });

            concatStream.Source = archiveStream;

            if (maxArchiveSize > 0)
            {
                concatStream.SetLength(maxArchiveSize);
            }

            Stream compressionStream = compressionStreamCreator(concatStream);

            try
            {
                byte[] buf = new byte[4096];
                long bytesRemaining = fileStream.Length;
                int counter = 0;
                while (bytesRemaining > 0)
                {
                    int count = (int) Math.Min(
                        bytesRemaining, (long) buf.Length);

                    count = fileCrcStream.Read(buf, 0, count);
                    if (count <= 0)
                    {
                        throw new ZipException(
                            "Failed to read file: " + this.currentFileName);
                    }

                    compressionStream.Write(buf, 0, count);
                    bytesRemaining -= count;

                    this.fileBytesProcessed += count;
                    this.currentFileBytesProcessed += count;
                    this.currentArchiveTotalBytes = concatStream.Source.Position;
                    this.currentArchiveBytesProcessed = this.currentArchiveTotalBytes;

                    if (++counter % 16 == 0) // Report every 64K
                    {
                        this.OnProgress(ArchiveProgressType.PartialFile);
                    }
                }

                if (compressionStream is DeflateStream)
                {
                    compressionStream.Close();
                }
                else
                {
                    compressionStream.Flush();
                }
            }
            finally
            {
                archiveStream = concatStream.Source;
            }

            bytesWritten += archiveStream.Position - writeStartPosition;

            crc = fileCrcStream.Crc;

            return bytesWritten;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Compression.Cab\NativeMethods.cs ===
//---------------------------------------------------------------------
// <copyright file="NativeMethods.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Cab
{
using System;
using System.Text;
using System.Security;
using System.Security.Permissions;
using System.Runtime.InteropServices;
using System.Diagnostics.CodeAnalysis;

/// <summary>
/// Native DllImport methods and related structures and constants used for
/// cabinet creation and extraction via cabinet.dll.
/// </summary>
internal static class NativeMethods
{
    /// <summary>
    /// A direct import of constants, enums, structures, delegates, and functions from fci.h.
    /// Refer to comments in fci.h for documentation.
    /// </summary>
    internal static class FCI
    {
        internal const int MIN_DISK = 32768;
        internal const int MAX_DISK = Int32.MaxValue;
        internal const int MAX_FOLDER = 0x7FFF8000;
        internal const int MAX_FILENAME = 256;
        internal const int MAX_CABINET_NAME = 256;
        internal const int MAX_CAB_PATH = 256;
        internal const int MAX_DISK_NAME = 256;

        internal const int CPU_80386 = 1;

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate IntPtr PFNALLOC(int cb);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate void PFNFREE(IntPtr pv);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNOPEN(string path, int oflag, int pmode, out int err, IntPtr pv);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNREAD(int fileHandle, IntPtr memory, int cb, out int err, IntPtr pv);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNWRITE(int fileHandle, IntPtr memory, int cb, out int err, IntPtr pv);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNCLOSE(int fileHandle, out int err, IntPtr pv);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNSEEK(int fileHandle, int dist, int seekType, out int err, IntPtr pv);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNDELETE(string path, out int err, IntPtr pv);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNGETNEXTCABINET(IntPtr pccab, uint cbPrevCab, IntPtr pv);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNFILEPLACED(IntPtr pccab, string path, long fileSize, int continuation, IntPtr pv);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNGETOPENINFO(string path, out short date, out short time, out short pattribs, out int err, IntPtr pv);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNSTATUS(STATUS typeStatus, uint cb1, uint cb2, IntPtr pv);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNGETTEMPFILE(IntPtr tempNamePtr, int tempNameSize, IntPtr pv);

        /// <summary>
        /// Error codes that can be returned by FCI.
        /// </summary>
        internal enum ERROR : int
        {
            NONE,
            OPEN_SRC,
            READ_SRC,
            ALLOC_FAIL,
            TEMP_FILE,
            BAD_COMPR_TYPE,
            CAB_FILE,
            USER_ABORT,
            MCI_FAIL,
        }

        /// <summary>
        /// FCI compression algorithm types and parameters.
        /// </summary>
        internal enum TCOMP : ushort
        {
            MASK_TYPE           = 0x000F,
            TYPE_NONE           = 0x0000,
            TYPE_MSZIP          = 0x0001,
            TYPE_QUANTUM        = 0x0002,
            TYPE_LZX            = 0x0003,
            BAD                 = 0x000F,

            MASK_LZX_WINDOW     = 0x1F00,
            LZX_WINDOW_LO       = 0x0F00,
            LZX_WINDOW_HI       = 0x1500,
            SHIFT_LZX_WINDOW    = 0x0008,

            MASK_QUANTUM_LEVEL  = 0x00F0,
            QUANTUM_LEVEL_LO    = 0x0010,
            QUANTUM_LEVEL_HI    = 0x0070,
            SHIFT_QUANTUM_LEVEL = 0x0004,

            MASK_QUANTUM_MEM    = 0x1F00,
            QUANTUM_MEM_LO      = 0x0A00,
            QUANTUM_MEM_HI      = 0x1500,
            SHIFT_QUANTUM_MEM   = 0x0008,

            MASK_RESERVED       = 0xE000,
        }

        /// <summary>
        /// Reason for FCI status callback.
        /// </summary>
        internal enum STATUS : uint
        {
            FILE    = 0,
            FOLDER  = 1,
            CABINET = 2,
        }

        [SuppressMessage("Microsoft.Globalization", "CA2101:SpecifyMarshalingForPInvokeStringArguments")]
        [DllImport("cabinet.dll", EntryPoint = "FCICreate", CharSet = CharSet.Ansi, BestFitMapping = false, ThrowOnUnmappableChar = true, CallingConvention = CallingConvention.Cdecl)]
        internal static extern Handle Create(IntPtr perf, PFNFILEPLACED pfnfcifp, PFNALLOC pfna, PFNFREE pfnf, PFNOPEN pfnopen, PFNREAD pfnread, PFNWRITE pfnwrite, PFNCLOSE pfnclose, PFNSEEK pfnseek, PFNDELETE pfndelete, PFNGETTEMPFILE pfnfcigtf, [MarshalAs(UnmanagedType.LPStruct)] CCAB pccab, IntPtr pv);

        [DllImport("cabinet.dll", EntryPoint = "FCIAddFile", CharSet = CharSet.Ansi, BestFitMapping = false, ThrowOnUnmappableChar = true, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int AddFile(Handle hfci, string pszSourceFile, IntPtr pszFileName, [MarshalAs(UnmanagedType.Bool)] bool fExecute, PFNGETNEXTCABINET pfnfcignc, PFNSTATUS pfnfcis, PFNGETOPENINFO pfnfcigoi, TCOMP typeCompress);

        [DllImport("cabinet.dll", EntryPoint = "FCIFlushCabinet", CharSet = CharSet.Ansi, BestFitMapping = false, ThrowOnUnmappableChar = true, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int FlushCabinet(Handle hfci, [MarshalAs(UnmanagedType.Bool)] bool fGetNextCab, PFNGETNEXTCABINET pfnfcignc, PFNSTATUS pfnfcis);

        [DllImport("cabinet.dll", EntryPoint = "FCIFlushFolder", CharSet = CharSet.Ansi, BestFitMapping = false, ThrowOnUnmappableChar = true, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int FlushFolder(Handle hfci, PFNGETNEXTCABINET pfnfcignc, PFNSTATUS pfnfcis);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("cabinet.dll", EntryPoint = "FCIDestroy", CharSet = CharSet.Ansi, BestFitMapping = false, ThrowOnUnmappableChar = true, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.Bool)]
        internal static extern bool Destroy(IntPtr hfci);

        /// <summary>
        /// Cabinet information structure used for FCI initialization and GetNextCabinet callback.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        internal class CCAB
        {
            internal int cb             = MAX_DISK;
            internal int cbFolderThresh = MAX_FOLDER;
            internal int cbReserveCFHeader;
            internal int cbReserveCFFolder;
            internal int cbReserveCFData;
            internal int iCab;
            internal int iDisk;
            internal int fFailOnIncompressible;
            internal short setID;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst=MAX_DISK_NAME   )] internal string szDisk    = String.Empty;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst=MAX_CABINET_NAME)] internal string szCab     = String.Empty;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst=MAX_CAB_PATH    )] internal string szCabPath = String.Empty;
        }

        /// <summary>
        /// Ensures that the FCI handle is safely released.
        /// </summary>
        internal class Handle : SafeHandle
        {
            /// <summary>
            /// Creates a new unintialized handle. The handle will be initialized
            /// when it is marshalled back from native code.
            /// </summary>
            internal Handle()
                : base(IntPtr.Zero, true)
            {
            }

            /// <summary>
            /// Checks if the handle is invalid. An FCI handle is invalid when it is zero.
            /// </summary>
            public override bool IsInvalid
            {
                get
                {
                    return this.handle == IntPtr.Zero;
                }
            }

            /// <summary>
            /// Releases the handle by calling FDIDestroy().
            /// </summary>
            /// <returns>True if the release succeeded.</returns>
            [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
            protected override bool ReleaseHandle()
            {
                return FCI.Destroy(this.handle);
            }
        }
    }

    /// <summary>
    /// A direct import of constants, enums, structures, delegates, and functions from fdi.h.
    /// Refer to comments in fdi.h for documentation.
    /// </summary>
    internal static class FDI
    {
        internal const int MAX_DISK         = Int32.MaxValue;
        internal const int MAX_FILENAME     = 256;
        internal const int MAX_CABINET_NAME = 256;
        internal const int MAX_CAB_PATH     = 256;
        internal const int MAX_DISK_NAME    = 256;

        internal const int CPU_80386 = 1;

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate IntPtr PFNALLOC(int cb);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate void PFNFREE(IntPtr pv);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNOPEN(string path, int oflag, int pmode);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNREAD(int hf, IntPtr pv, int cb);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNWRITE(int hf, IntPtr pv, int cb);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNCLOSE(int hf);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNSEEK(int hf, int dist, int seektype);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNNOTIFY(NOTIFICATIONTYPE fdint, NOTIFICATION fdin);

        /// <summary>
        /// Error codes that can be returned by FDI.
        /// </summary>
        internal enum ERROR : int
        {
            NONE,
            CABINET_NOT_FOUND,
            NOT_A_CABINET,
            UNKNOWN_CABINET_VERSION,
            CORRUPT_CABINET,
            ALLOC_FAIL,
            BAD_COMPR_TYPE,
            MDI_FAIL,
            TARGET_FILE,
            RESERVE_MISMATCH,
            WRONG_CABINET,
            USER_ABORT,
        }

        /// <summary>
        /// Type of notification message for the FDI Notify callback.
        /// </summary>
        internal enum NOTIFICATIONTYPE : int
        {
            CABINET_INFO,
            PARTIAL_FILE,
            COPY_FILE,
            CLOSE_FILE_INFO,
            NEXT_CABINET,
            ENUMERATE,
        }

        [DllImport("cabinet.dll", EntryPoint = "FDICreate", CharSet = CharSet.Ansi, BestFitMapping = false, ThrowOnUnmappableChar = true, CallingConvention = CallingConvention.Cdecl)]
        internal static extern Handle Create([MarshalAs(UnmanagedType.FunctionPtr)] PFNALLOC pfnalloc, [MarshalAs(UnmanagedType.FunctionPtr)] PFNFREE pfnfree, PFNOPEN pfnopen, PFNREAD pfnread, PFNWRITE pfnwrite, PFNCLOSE pfnclose, PFNSEEK pfnseek, int cpuType, IntPtr perf);

        [DllImport("cabinet.dll", EntryPoint = "FDICopy", CharSet = CharSet.Ansi, BestFitMapping = false, ThrowOnUnmappableChar = true, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int Copy(Handle hfdi, string pszCabinet, string pszCabPath, int flags, PFNNOTIFY pfnfdin, IntPtr pfnfdid, IntPtr pvUser);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("cabinet.dll", EntryPoint = "FDIDestroy", CharSet = CharSet.Ansi, BestFitMapping = false, ThrowOnUnmappableChar = true, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.Bool)]
        internal static extern bool Destroy(IntPtr hfdi);

        [DllImport("cabinet.dll", EntryPoint = "FDIIsCabinet", CharSet = CharSet.Ansi, BestFitMapping = false, ThrowOnUnmappableChar = true, CallingConvention = CallingConvention.Cdecl)]
        [SuppressMessage("Microsoft.Portability", "CA1901:PInvokeDeclarationsShouldBePortable", Justification="FDI file handles definitely remain 4 bytes on 64bit platforms.")]
        internal static extern int IsCabinet(Handle hfdi, int hf, out CABINFO pfdici);

        /// <summary>
        /// Cabinet information structure filled in by FDI IsCabinet.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        internal struct CABINFO
        {
            internal int cbCabinet;
            internal short cFolders;
            internal short cFiles;
            internal short setID;
            internal short iCabinet;
            internal int fReserve;
            internal int hasprev;
            internal int hasnext;
        }

        /// <summary>
        /// Cabinet notification details passed to the FDI Notify callback.
        /// </summary>
        [SuppressMessage("Microsoft.Performance", "CA1812:AvoidUninstantiatedInternalClasses")]
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        internal class NOTIFICATION
        {
            internal int cb;
            internal IntPtr psz1;
            internal IntPtr psz2;
            internal IntPtr psz3;
            internal IntPtr pv;

            internal IntPtr hf_ptr;

            internal short date;
            internal short time;
            internal short attribs;
            internal short setID;
            internal short iCabinet;
            internal short iFolder;
            internal int fdie;

            // Unlike all the other file handles in FCI/FDI, this one is
            // actually pointer-sized. Use a property to pretend it isn't.
            internal int hf
            {
                get { return (int) this.hf_ptr; }
            }
        }

        /// <summary>
        /// Ensures that the FDI handle is safely released.
        /// </summary>
        internal class Handle : SafeHandle
        {
            /// <summary>
            /// Creates a new unintialized handle. The handle will be initialized
            /// when it is marshalled back from native code.
            /// </summary>
            internal Handle()
                : base(IntPtr.Zero, true)
            {
            }

            /// <summary>
            /// Checks if the handle is invalid. An FDI handle is invalid when it is zero.
            /// </summary>
            public override bool IsInvalid
            {
                get
                {
                    return this.handle == IntPtr.Zero;
                }
            }

            /// <summary>
            /// Releases the handle by calling FDIDestroy().
            /// </summary>
            /// <returns>True if the release succeeded.</returns>
            protected override bool ReleaseHandle()
            {
                return FDI.Destroy(this.handle);
            }
        }
    }

    /// <summary>
    /// Error info structure for FCI and FDI.
    /// </summary>
    /// <remarks>Before being passed to FCI or FDI, this structure is
    /// pinned in memory via a GCHandle. The pinning is necessary
    /// to be able to read the results, since the ERF structure doesn't
    /// get marshalled back out after an error.</remarks>
    [StructLayout(LayoutKind.Sequential)]
    internal class ERF
    {
        private int erfOper;
        private int erfType;
        private int fError;

        /// <summary>
        /// Gets or sets the cabinet error code.
        /// </summary>
        internal int Oper
        {
            get
            {
                return this.erfOper;
            }

            set
            {
                this.erfOper = value;
            }
        }

        /// <summary>
        /// Gets or sets the Win32 error code.
        /// </summary>
        internal int Type
        {
            get
            {
                return this.erfType;
            }

            set
            {
                this.erfType = value;
            }
        }

        /// <summary>
        /// GCHandle doesn't like the bool type, so use an int underneath.
        /// </summary>
        internal bool Error
        {
            get
            {
                return this.fError != 0;
            }

            set
            {
                this.fError = value ? 1 : 0;
            }
        }

        /// <summary>
        /// Clears the error information.
        /// </summary>
        internal void Clear()
        {
            this.Oper = 0;
            this.Type = 0;
            this.Error = false;
        }
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LIVEnAuthClient\LIVEnAuthClient\Authentication_Proxy.cs ===
// <copyright file="Authentication_Proxy.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation. All rights reserved.
// </copyright>
// <author email="zhangxu@microsoft.com">
//     Zhangwei Xu
// </author>
// <summary>
//  Live ID Authenticaiton Add on to web service proxy
// </summary>

namespace LIVEnAuthClient
{
    using System;
    using System.Net;

    /// <summary>
    /// This partial class adds LiveID authentication module to the web service
    /// proxy.
    /// </summary>
    public partial class UserAccount : System.Web.Services.Protocols.SoapHttpClientProtocol
    {
        /// <summary>
        /// Auth header
        /// </summary>
        public const string AuthHeader = "X-Authorization";

        /// <summary>
        /// Auth header for partner tickets
        /// </summary>
        public const string PartnerAuthHeader = "X-PartnerAuthorization";

        /// <summary>
        /// X-Locale Header for locale info
        /// </summary>
        public const String XLocale = "X-Locale";

        /// <summary>
        /// Auth header
        /// </summary>
        public const string AuthHeaderWindowsLive = "Authorization";

        /// <summary>
        /// Live ID header
        /// </summary>
        public const string LiveIDHeader = "WLID1.0 t=";

        /// <summary>
        /// XBL header
        /// </summary>
        public const string XblHeader = "XBL1.0 x=";

        /// <summary>
        /// Cache the LiveID Token.
        /// </summary>
        private string liveIDToken;

        /// <summary>
        /// Cache the STS Token.
        /// </summary>
        private string stsToken;

        /// <summary>
        /// Sets LiveID Token.
        /// </summary>
        public string LiveIDToken
        {
            set
            {
                this.liveIDToken = value;
            }
        }

        /// <summary>
        /// Sets STS Token.
        /// </summary>
        public string StsToken
        {
            set
            {
                this.stsToken = value;
            }
        }

        /// <summary>
        /// This method overrides the default GetWebRequest and adds the LiveID
        /// token to the HTTP request.
        /// </summary>
        /// <param name="uri">Uri of the request.</param>
        /// <returns>A Web request.</returns>
        protected override WebRequest GetWebRequest(Uri uri)
        {
            HttpWebRequest request;

            // Get the web request
            request = (HttpWebRequest)base.GetWebRequest(uri);

            // Set the right request based on HTTP or HTTPS
            request = LIVEnAuthClient.GetWebRequest(uri.ToString(), request, true);

            if (!String.IsNullOrEmpty(this.liveIDToken))
            {
                // Add authorization header as Authorization: WLID1.0 t=<RPS Token>
                request.Headers[AuthHeaderWindowsLive] = LiveIDHeader + this.liveIDToken;
            }
            else if (!String.IsNullOrEmpty(this.stsToken))
            {
                // Add authorization header as Authorization: XBL1.0 t=<STS Token>
                request.Headers[AuthHeader] = XblHeader + this.stsToken;
            }

            return request;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Compression.Zip\ZipUnpacker.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ZipUnpacker.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Zip
{
    using System;
    using System.IO;
    using System.IO.Compression;
    using System.Collections.Generic;

    public partial class ZipEngine
    {
        /// <summary>
        /// Extracts files from a zip archive or archive chain.
        /// </summary>
        /// <param name="streamContext">A context interface to handle opening
        /// and closing of archive and file streams.</param>
        /// <param name="fileFilter">An optional predicate that can determine
        /// which files to process.</param>
        /// <exception cref="ArchiveException">The archive provided
        /// by the stream context is not valid.</exception>
        /// <remarks>
        /// The <paramref name="fileFilter"/> predicate takes an internal file
        /// path and returns true to include the file or false to exclude it.
        /// </remarks>
        public override void Unpack(
            IUnpackStreamContext streamContext,
            Predicate<string> fileFilter)
        {
            if (streamContext == null)
            {
                throw new ArgumentNullException("streamContext");
            }

            lock (this)
            {
                IList<ZipFileHeader> allHeaders = this.GetCentralDirectory(streamContext);
                if (allHeaders == null)
                {
                    throw new ZipException("Zip central directory not found.");
                }

                IList<ZipFileHeader> headers = new List<ZipFileHeader>(allHeaders.Count);
                foreach (ZipFileHeader header in allHeaders)
                {
                    if (!header.IsDirectory &&
                        (fileFilter == null || fileFilter(header.fileName)))
                    {
                        headers.Add(header);
                    }
                }

                this.ResetProgressData();

                // Count the total number of files and bytes to be compressed.
                this.totalFiles = headers.Count;
                foreach (ZipFileHeader header in headers)
                {
                    long compressedSize;
                    long uncompressedSize;
                    long localHeaderOffset;
                    int archiveNumber;
                    uint crc;
                    header.GetZip64Fields(
                        out compressedSize,
                        out uncompressedSize,
                        out localHeaderOffset,
                        out archiveNumber,
                        out crc);

                    this.totalFileBytes += uncompressedSize;
                    if (archiveNumber >= this.totalArchives)
                    {
                        this.totalArchives = (short) (archiveNumber + 1);
                    }
                }

                this.currentArchiveNumber = -1;
                this.currentFileNumber = -1;
                Stream archiveStream = null;
                try
                {
                    foreach (ZipFileHeader header in headers)
                    {
                        this.currentFileNumber++;
                        this.UnpackOneFile(streamContext, header, ref archiveStream);
                    }
                }
                finally
                {
                    if (archiveStream != null)
                    {
                        streamContext.CloseArchiveReadStream(
                            0, String.Empty, archiveStream);
                        this.currentArchiveNumber--;
                        this.OnProgress(ArchiveProgressType.FinishArchive);
                    }
                }
            }
        }

        /// <summary>
        /// Unpacks a single file from an archive or archive chain.
        /// </summary>
        private void UnpackOneFile(
            IUnpackStreamContext streamContext,
            ZipFileHeader header,
            ref Stream archiveStream)
        {
            ZipFileInfo fileInfo = null;
            Stream fileStream = null;
            try
            {
                Converter<Stream, Stream> compressionStreamCreator;
                if (!ZipEngine.decompressionStreamCreators.TryGetValue(
                    header.compressionMethod, out compressionStreamCreator))
                {
                    // Silently skip files of an unsupported compression method.
                    return;
                }

                long compressedSize;
                long uncompressedSize;
                long localHeaderOffset;
                int archiveNumber;
                uint crc;
                header.GetZip64Fields(
                    out compressedSize,
                    out uncompressedSize,
                    out localHeaderOffset,
                    out archiveNumber,
                    out crc);

                if (this.currentArchiveNumber != archiveNumber + 1)
                {
                    if (archiveStream != null)
                    {
                        streamContext.CloseArchiveReadStream(
                            this.currentArchiveNumber,
                            String.Empty,
                            archiveStream);
                        archiveStream = null;

                        this.OnProgress(ArchiveProgressType.FinishArchive);
                        this.currentArchiveName = null;
                    }

                    this.currentArchiveNumber = (short) (archiveNumber + 1);
                    this.currentArchiveBytesProcessed = 0;
                    this.currentArchiveTotalBytes = 0;

                    archiveStream = this.OpenArchive(
                        streamContext, this.currentArchiveNumber);

                    FileStream archiveFileStream = archiveStream as FileStream;
                    this.currentArchiveName = (archiveFileStream != null ?
                        Path.GetFileName(archiveFileStream.Name) : null);

                    this.currentArchiveTotalBytes = archiveStream.Length;
                    this.currentArchiveNumber--;
                    this.OnProgress(ArchiveProgressType.StartArchive);
                    this.currentArchiveNumber++;
                }

                archiveStream.Seek(localHeaderOffset, SeekOrigin.Begin);

                ZipFileHeader localHeader = new ZipFileHeader();
                if (!localHeader.Read(archiveStream, false) ||
                    !localHeader.fileName.Equals(header.fileName))
                {
                    string msg = "Could not read file: " + header.fileName;
                    throw new ZipException(msg);
                }

                fileInfo = header.ToZipFileInfo();

                fileStream = streamContext.OpenFileWriteStream(
                    fileInfo.FullName,
                    fileInfo.Length,
                    fileInfo.LastWriteTime);

                if (fileStream != null)
                {
                    this.currentFileName = header.fileName;
                    this.currentFileBytesProcessed = 0;
                    this.currentFileTotalBytes = fileInfo.Length;
                    this.currentArchiveNumber--;
                    this.OnProgress(ArchiveProgressType.StartFile);
                    this.currentArchiveNumber++;

                    this.UnpackFileBytes(
                        streamContext,
                        fileInfo.FullName,
                        fileInfo.CompressedLength,
                        fileInfo.Length,
                        header.crc32,
                        fileStream,
                        compressionStreamCreator,
                        ref archiveStream);
                }
            }
            finally
            {
                if (fileStream != null)
                {
                    streamContext.CloseFileWriteStream(
                        fileInfo.FullName,
                        fileStream,
                        fileInfo.Attributes,
                        fileInfo.LastWriteTime);

                    this.currentArchiveNumber--;
                    this.OnProgress(ArchiveProgressType.FinishFile);
                    this.currentArchiveNumber++;
                }
            }
        }

        private Stream OpenArchive(IUnpackStreamContext streamContext, int archiveNumber)
        {
            Stream archiveStream = streamContext.OpenArchiveReadStream(
                archiveNumber, String.Empty, this);
            if (archiveStream == null && archiveNumber != 0)
            {
                archiveStream = streamContext.OpenArchiveReadStream(
                    0, String.Empty, this);
            }

            if (archiveStream == null)
            {
                throw new FileNotFoundException("Archive stream not provided.");
            }

            return archiveStream;
        }

        /// <summary>
        /// Decompresses bytes for one file from an archive or archive chain,
        /// checking the crc at the end.
        /// </summary>
        private void UnpackFileBytes(
            IUnpackStreamContext streamContext,
            string fileName,
            long compressedSize,
            long uncompressedSize,
            uint crc,
            Stream fileStream,
            Converter<Stream, Stream> compressionStreamCreator,
            ref Stream archiveStream)
        {
            CrcStream crcStream = new CrcStream(fileStream);

            ConcatStream concatStream = new ConcatStream(
                delegate(ConcatStream s)
                {
                    this.currentArchiveBytesProcessed = s.Source.Position;
                    streamContext.CloseArchiveReadStream(
                        this.currentArchiveNumber,
                        String.Empty,
                        s.Source);

                    this.currentArchiveNumber--;
                    this.OnProgress(ArchiveProgressType.FinishArchive);
                    this.currentArchiveNumber += 2;
                    this.currentArchiveName = null;
                    this.currentArchiveBytesProcessed = 0;
                    this.currentArchiveTotalBytes = 0;

                    s.Source = this.OpenArchive(streamContext, this.currentArchiveNumber);

                    FileStream archiveFileStream = s.Source as FileStream;
                    this.currentArchiveName = (archiveFileStream != null ?
                        Path.GetFileName(archiveFileStream.Name) : null);

                    this.currentArchiveTotalBytes = s.Source.Length;
                    this.currentArchiveNumber--;
                    this.OnProgress(ArchiveProgressType.StartArchive);
                    this.currentArchiveNumber++;
                });

            concatStream.Source = archiveStream;
            concatStream.SetLength(compressedSize);

            Stream decompressionStream = compressionStreamCreator(concatStream);

            try
            {
                byte[] buf = new byte[4096];
                long bytesRemaining = uncompressedSize;
                int counter = 0;
                while (bytesRemaining > 0)
                {
                    int count = (int) Math.Min(buf.Length, bytesRemaining);
                    count = decompressionStream.Read(buf, 0, count);
                    crcStream.Write(buf, 0, count);
                    bytesRemaining -= count;

                    this.fileBytesProcessed += count;
                    this.currentFileBytesProcessed += count;
                    this.currentArchiveBytesProcessed = concatStream.Source.Position;

                    if (++counter % 16 == 0) // Report every 64K
                    {
                        this.currentArchiveNumber--;
                        this.OnProgress(ArchiveProgressType.PartialFile);
                        this.currentArchiveNumber++;
                    }
                }
            }
            finally
            {
                archiveStream = concatStream.Source;
            }

            crcStream.Flush();

            if (crcStream.Crc != crc)
            {
                throw new ZipException("CRC check failed for file: " + fileName);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Compression.Zip\ZipFormat.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ZipFormat.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Zip
{
    using System;
    using System.Globalization;
    using System.IO;
    using System.Text;
    using System.Collections.Generic;
    using System.Diagnostics.CodeAnalysis;

    [Flags]
    internal enum ZipFileFlags : ushort
    {
        None            = 0x0000,
        Encrypt         = 0x0001,
        CompressOption1 = 0x0002,
        CompressOption2 = 0x0004,
        DataDescriptor  = 0x0008,
        StrongEncrypt   = 0x0040,
        UTF8            = 0x0800
    }

    internal enum ZipExtraFileFieldType : ushort
    {
        ZIP64 = 0x0001,
        NTFS_TIMES = 0x000A,
        NTFS_ACLS = 0x4453,
        EXTIME = 0x5455
    }

    internal class ZipFileHeader
    {
        public const uint LFHSIG = 0x04034B50;
        public const uint CFHSIG = 0x02014B50;

        public const uint SPANSIG  = 0x08074b50;
        public const uint SPANSIG2 = 0x30304b50;
        
        public const uint LFH_FIXEDSIZE = 30;
        public const uint CFH_FIXEDSIZE = 46;

        public ushort versionMadeBy;
        public ushort versionNeeded;
        public ZipFileFlags flags;
        public ZipCompressionMethod compressionMethod;
        public short lastModTime;
        public short lastModDate;
        public uint crc32;
        public uint compressedSize;
        public uint uncompressedSize;
        public ushort diskStart;
        public ushort internalFileAttrs;
        public uint externalFileAttrs;
        public uint localHeaderOffset;
        public string fileName;
        public ZipExtraFileField[] extraFields;
        public string fileComment;
        public bool zip64;

        public ZipFileHeader()
        {
            this.versionMadeBy = 20;
            this.versionNeeded = 20;
        }

        public ZipFileHeader(ZipFileInfo fileInfo, bool zip64)
            : this()
        {
            this.flags = ZipFileFlags.None;
            this.compressionMethod = fileInfo.CompressionMethod;
            this.fileName = Path.Combine(fileInfo.Path, fileInfo.Name);
            CompressionEngine.DateTimeToDosDateAndTime(
                fileInfo.LastWriteTime, out this.lastModDate, out this.lastModTime);
            this.zip64 = zip64;

            if (this.zip64)
            {
                this.compressedSize = UInt32.MaxValue;
                this.uncompressedSize = UInt32.MaxValue;
                this.diskStart = UInt16.MaxValue;
                this.versionMadeBy = 45;
                this.versionNeeded = 45;
                ZipExtraFileField field = new ZipExtraFileField();
                field.fieldType = ZipExtraFileFieldType.ZIP64;
                field.SetZip64Data(
                    fileInfo.CompressedLength,
                    fileInfo.Length,
                    0,
                    fileInfo.ArchiveNumber);
                this.extraFields = new ZipExtraFileField[] { field };
            }
            else
            {
                this.compressedSize = (uint) fileInfo.CompressedLength;
                this.uncompressedSize = (uint) fileInfo.Length;
                this.diskStart = (ushort) fileInfo.ArchiveNumber;
            }
        }

        [SuppressMessage("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames", MessageId = "compressedSize")]
        [SuppressMessage("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames", MessageId = "uncompressedSize")]
        [SuppressMessage("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames", MessageId = "crc32")]
        [SuppressMessage("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames", MessageId = "localHeaderOffset")]
        public void Update(
            long compressedSize,
            long uncompressedSize,
            uint crc32,
            long localHeaderOffset,
            int archiveNumber)
        {
            this.crc32 = crc32;

            if (this.zip64)
            {
                this.compressedSize = UInt32.MaxValue;
                this.uncompressedSize = UInt32.MaxValue;
                this.localHeaderOffset = UInt32.MaxValue;
                this.diskStart = UInt16.MaxValue;

                if (this.extraFields != null)
                {
                    foreach (ZipExtraFileField field in this.extraFields)
                    {
                        if (field.fieldType == ZipExtraFileFieldType.ZIP64)
                        {
                            field.SetZip64Data(
                                compressedSize,
                                uncompressedSize,
                                localHeaderOffset,
                                archiveNumber);
                        }
                    }
                }
            }
            else
            {
                this.compressedSize = (uint) compressedSize;
                this.uncompressedSize = (uint) uncompressedSize;
                this.localHeaderOffset = (uint) localHeaderOffset;
                this.diskStart = (ushort) archiveNumber;
            }
        }

        public bool Read(Stream stream, bool central)
        {
            long startPos = stream.Position;

            if (stream.Length - startPos <
                (central ? CFH_FIXEDSIZE : LFH_FIXEDSIZE))
            {
                return false;
            }

            BinaryReader reader = new BinaryReader(stream);
            uint sig = reader.ReadUInt32();

            if (sig == SPANSIG || sig == SPANSIG2)
            {
                // Spanned zip files may optionally begin with a special marker.
                // Just ignore it and move on.
                sig = reader.ReadUInt32();
            }

            if (sig != (central ? CFHSIG : LFHSIG))
            {
                return false;
            }

            this.versionMadeBy = (central ? reader.ReadUInt16() : (ushort) 0);
            this.versionNeeded = reader.ReadUInt16();
            this.flags = (ZipFileFlags) reader.ReadUInt16();
            this.compressionMethod = (ZipCompressionMethod) reader.ReadUInt16();
            this.lastModTime = reader.ReadInt16();
            this.lastModDate = reader.ReadInt16();
            this.crc32 = reader.ReadUInt32();
            this.compressedSize = reader.ReadUInt32();
            this.uncompressedSize = reader.ReadUInt32();
            
            this.zip64 = this.uncompressedSize == UInt32.MaxValue;

            int fileNameLength = reader.ReadUInt16();
            int extraFieldLength = reader.ReadUInt16();
            int fileCommentLength;

            if (central)
            {
                fileCommentLength = reader.ReadUInt16();

                this.diskStart = reader.ReadUInt16();
                this.internalFileAttrs = reader.ReadUInt16();
                this.externalFileAttrs = reader.ReadUInt32();
                this.localHeaderOffset = reader.ReadUInt32();
            }
            else
            {
                fileCommentLength = 0;
                this.diskStart = 0;
                this.internalFileAttrs = 0;
                this.externalFileAttrs = 0;
                this.localHeaderOffset = 0;
            }

            if (stream.Length - stream.Position <
                fileNameLength + extraFieldLength + fileCommentLength)
            {
                return false;
            }

            Encoding headerEncoding = ((this.flags | ZipFileFlags.UTF8) != 0 ?
                Encoding.UTF8 : Encoding.GetEncoding(CultureInfo.CurrentCulture.TextInfo.OEMCodePage));

            byte[] fileNameBytes = reader.ReadBytes(fileNameLength);
            this.fileName = headerEncoding.GetString(fileNameBytes);

            List<ZipExtraFileField> fields = new List<ZipExtraFileField>();
            while (extraFieldLength > 0)
            {
                ZipExtraFileField field = new ZipExtraFileField();
                if (!field.Read(stream, ref extraFieldLength))
                {
                    return false;
                }
                fields.Add(field);
                if (field.fieldType == ZipExtraFileFieldType.ZIP64)
                {
                    this.zip64 = true;
                }
            }
            this.extraFields = fields.ToArray();

            byte[] fileCommentBytes = reader.ReadBytes(fileCommentLength);
            this.fileComment = headerEncoding.GetString(fileCommentBytes);

            return true;
        }

        public void Write(Stream stream, bool central)
        {
            byte[] fileNameBytes = (this.fileName != null
                ? Encoding.UTF8.GetBytes(this.fileName) : new byte[0]);
            byte[] fileCommentBytes = (this.fileComment != null
                ? Encoding.UTF8.GetBytes(this.fileComment) : new byte[0]);
            bool useUtf8 =
                (this.fileName != null && fileNameBytes.Length > this.fileName.Length) ||
                (this.fileComment != null && fileCommentBytes.Length > this.fileComment.Length);
            if (useUtf8)
            {
                this.flags |= ZipFileFlags.UTF8;
            }

            BinaryWriter writer = new BinaryWriter(stream);
            writer.Write(central ? CFHSIG : LFHSIG);
            if (central)
            {
                writer.Write(this.versionMadeBy);
            }
            writer.Write(this.versionNeeded);
            writer.Write((ushort) this.flags);
            writer.Write((ushort) this.compressionMethod);
            writer.Write(this.lastModTime);
            writer.Write(this.lastModDate);
            writer.Write(this.crc32);
            writer.Write(this.compressedSize);
            writer.Write(this.uncompressedSize);
            
            ushort extraFieldLength = 0;
            if (this.extraFields != null)
            {
                foreach (ZipExtraFileField field in this.extraFields)
                {
                    if (field.data != null)
                    {
                        extraFieldLength += (ushort) (4 + field.data.Length);
                    }
                }
            }

            writer.Write((ushort) fileNameBytes.Length);
            writer.Write(extraFieldLength);

            if (central)
            {
                writer.Write((ushort) fileCommentBytes.Length);

                writer.Write(this.diskStart);
                writer.Write(this.internalFileAttrs);
                writer.Write(this.externalFileAttrs);
                writer.Write(this.localHeaderOffset);
            }

            writer.Write(fileNameBytes);

            if (this.extraFields != null)
            {
                foreach (ZipExtraFileField field in this.extraFields)
                {
                    if (field.data != null)
                    {
                        field.Write(stream);
                    }
                }
            }

            if (central)
            {
                writer.Write(fileCommentBytes);
            }
        }

        [SuppressMessage("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames", MessageId = "compressedSize")]
        [SuppressMessage("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames", MessageId = "uncompressedSize")]
        [SuppressMessage("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames", MessageId = "crc32")]
        [SuppressMessage("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames", MessageId = "localHeaderOffset")]
        public void GetZip64Fields(
            out long compressedSize,
            out long uncompressedSize,
            out long localHeaderOffset,
            out int archiveNumber,
            out uint crc)
        {
            compressedSize = this.compressedSize;
            uncompressedSize = this.uncompressedSize;
            localHeaderOffset = this.localHeaderOffset;
            archiveNumber = this.diskStart;
            crc = this.crc32;

            foreach (ZipExtraFileField field in this.extraFields)
            {
                if (field.fieldType == ZipExtraFileFieldType.ZIP64)
                {
                    field.GetZip64Data(
                        out compressedSize,
                        out uncompressedSize,
                        out localHeaderOffset,
                        out archiveNumber);
                }
            }
        }

        public ZipFileInfo ToZipFileInfo()
        {
            string name = this.fileName;
            
            long compressedSizeL;
            long uncompressedSizeL;
            long localHeaderOffsetL;
            int archiveNumberL;
            uint crc;
            this.GetZip64Fields(
                out compressedSizeL,
                out uncompressedSizeL,
                out localHeaderOffsetL,
                out archiveNumberL,
                out crc);

            DateTime dateTime;
            CompressionEngine.DosDateAndTimeToDateTime(
                this.lastModDate,
                this.lastModTime,
                out dateTime);
            FileAttributes attrs = FileAttributes.Normal;
            // TODO: look for attrs or times in extra fields

            return new ZipFileInfo(name, archiveNumberL, attrs, dateTime,
                uncompressedSizeL, compressedSizeL, this.compressionMethod);
        }

        public bool IsDirectory
        {
            get
            {
                return this.fileName != null &&
                    (this.fileName.EndsWith("/", StringComparison.Ordinal) ||
                    this.fileName.EndsWith("\\", StringComparison.Ordinal));
            }
        }

        public int GetSize(bool central)
        {
            int size = 30;

            int fileNameSize = (this.fileName != null
                ? Encoding.UTF8.GetByteCount(this.fileName) : 0);
            size += fileNameSize;

            if (this.extraFields != null)
            {
                foreach (ZipExtraFileField field in this.extraFields)
                {
                    if (field.data != null)
                    {
                        size += 4 + field.data.Length;
                    }
                }
            }

            if (central)
            {
                size += 16;

                int fileCommentSize = (this.fileComment != null
                    ? Encoding.UTF8.GetByteCount(this.fileComment) : 0);
                size += fileCommentSize;
            }

            return size;
        }
    }

    internal class ZipExtraFileField
    {
        public ZipExtraFileFieldType fieldType;
        public byte[] data;

        public bool Read(Stream stream, ref int bytesRemaining)
        {
            if (bytesRemaining < 4)
            {
                return false;
            }

            BinaryReader reader = new BinaryReader(stream);

            this.fieldType = (ZipExtraFileFieldType) reader.ReadUInt16();
            ushort dataSize = reader.ReadUInt16();
            bytesRemaining -= 4;

            if (bytesRemaining < dataSize)
            {
                return false;
            }

            this.data = reader.ReadBytes(dataSize);
            bytesRemaining -= dataSize;

            return true;
        }

        public void Write(Stream stream)
        {
            BinaryWriter writer = new BinaryWriter(stream);
            writer.Write((ushort) this.fieldType);

            byte[] dataBytes = (this.data != null ? this.data : new byte[0]);
            writer.Write((ushort) dataBytes.Length);
            writer.Write(dataBytes);
        }

        public bool GetZip64Data(
            out long compressedSize,
            out long uncompressedSize,
            out long localHeaderOffset,
            out int diskStart)
        {
            uncompressedSize = 0;
            compressedSize = 0;
            localHeaderOffset = 0;
            diskStart = 0;

            if (this.fieldType != ZipExtraFileFieldType.ZIP64 ||
                this.data == null || this.data.Length != 28)
            {
                return false;
            }

            using (MemoryStream dataStream = new MemoryStream(this.data))
            {
                BinaryReader reader = new BinaryReader(dataStream);
                uncompressedSize = reader.ReadInt64();
                compressedSize = reader.ReadInt64();
                localHeaderOffset = reader.ReadInt64();
                diskStart = reader.ReadInt32();
            }

            return true;
        }

        public bool SetZip64Data(
            long compressedSize,
            long uncompressedSize,
            long localHeaderOffset,
            int diskStart)
        {
            if (this.fieldType != ZipExtraFileFieldType.ZIP64)
            {
                return false;
            }

            using (MemoryStream dataStream = new MemoryStream())
            {
                BinaryWriter writer = new BinaryWriter(dataStream);
                writer.Write(uncompressedSize);
                writer.Write(compressedSize);
                writer.Write(localHeaderOffset);
                writer.Write(diskStart);
                this.data = dataStream.ToArray();
            }

            return true;
        }
    }

    internal class ZipEndOfCentralDirectory
    {
        public const uint EOCDSIG = 0x06054B50;
        public const uint EOCD64SIG = 0x06064B50;

        public const uint EOCD_RECORD_FIXEDSIZE = 22;
        public const uint EOCD64_RECORD_FIXEDSIZE = 56;

        public ushort versionMadeBy;
        public ushort versionNeeded;
        public uint diskNumber;
        public uint dirStartDiskNumber;
        public long entriesOnDisk;
        public long totalEntries;
        public long dirSize;
        public long dirOffset;
        public string comment;
        public bool zip64;

        public ZipEndOfCentralDirectory()
        {
            this.versionMadeBy = 20;
            this.versionNeeded = 20;
        }

        public bool Read(Stream stream)
        {
            long startPos = stream.Position;

            if (stream.Length - startPos < EOCD_RECORD_FIXEDSIZE)
            {
                return false;
            }

            BinaryReader reader = new BinaryReader(stream);
            uint sig = reader.ReadUInt32();

            this.zip64 = false;
            if (sig != EOCDSIG)
            {
                if (sig == EOCD64SIG)
                {
                    this.zip64 = true;
                }
                else
                {
                    return false;
                }
            }

            if (this.zip64)
            {
                if (stream.Length - startPos < EOCD64_RECORD_FIXEDSIZE)
                {
                    return false;
                }

                long recordSize = reader.ReadInt64();
                this.versionMadeBy = reader.ReadUInt16();
                this.versionNeeded = reader.ReadUInt16();
                this.diskNumber = reader.ReadUInt32();
                this.dirStartDiskNumber = reader.ReadUInt32();
                this.entriesOnDisk = reader.ReadInt64();
                this.totalEntries = reader.ReadInt64();
                this.dirSize = reader.ReadInt64();
                this.dirOffset = reader.ReadInt64();

                // Ignore any extended zip64 eocd data.
                long exDataSize = recordSize + 12 - EOCD64_RECORD_FIXEDSIZE;

                if (stream.Length - stream.Position < exDataSize)
                {
                    return false;
                }

                stream.Seek(exDataSize, SeekOrigin.Current);

                this.comment = null;
            }
            else
            {
                this.diskNumber = reader.ReadUInt16();
                this.dirStartDiskNumber = reader.ReadUInt16();
                this.entriesOnDisk = reader.ReadUInt16();
                this.totalEntries = reader.ReadUInt16();
                this.dirSize = reader.ReadUInt32();
                this.dirOffset = reader.ReadUInt32();

                int commentLength = reader.ReadUInt16();

                if (stream.Length - stream.Position < commentLength)
                {
                    return false;
                }

                byte[] commentBytes = reader.ReadBytes(commentLength);
                this.comment = Encoding.UTF8.GetString(commentBytes);
            }

            return true;
        }

        public void Write(Stream stream)
        {
            BinaryWriter writer = new BinaryWriter(stream);

            if (this.zip64)
            {
                writer.Write(EOCD64SIG);
                writer.Write((long) EOCD64_RECORD_FIXEDSIZE);
                writer.Write(this.versionMadeBy);
                writer.Write(this.versionNeeded);
                writer.Write(this.diskNumber);
                writer.Write(this.dirStartDiskNumber);
                writer.Write(this.entriesOnDisk);
                writer.Write(this.totalEntries);
                writer.Write(this.dirSize);
                writer.Write(this.dirOffset);
            }
            else
            {
                writer.Write(EOCDSIG);
                writer.Write((ushort) Math.Min((int) UInt16.MaxValue, this.diskNumber));
                writer.Write((ushort) Math.Min((int) UInt16.MaxValue, this.dirStartDiskNumber));
                writer.Write((ushort) Math.Min((int) UInt16.MaxValue, this.entriesOnDisk));
                writer.Write((ushort) Math.Min((int) UInt16.MaxValue, this.totalEntries));
                writer.Write((uint) Math.Min((long) UInt32.MaxValue, this.dirSize));
                writer.Write((uint) Math.Min((long) UInt32.MaxValue, this.dirOffset));

                byte[] commentBytes = (this.comment != null
                    ? Encoding.UTF8.GetBytes(this.comment) : new byte[0]);
                writer.Write((ushort) commentBytes.Length);
                writer.Write(commentBytes);
            }
        }

        public int GetSize(bool zip64Size)
        {
            if (zip64Size)
            {
                return 56;
            }
            else
            {
                int commentSize = (this.comment != null
                    ? Encoding.UTF8.GetByteCount(this.comment) : 0);
                return 22 + commentSize;
            }
        }
    }

    internal class Zip64EndOfCentralDirectoryLocator
    {
        public const uint EOCDL64SIG = 0x07064B50;

        public const uint EOCDL64_SIZE = 20;

        public uint dirStartDiskNumber;
        public long dirOffset;
        public uint totalDisks;

        public bool Read(Stream stream)
        {
            long startPos = stream.Position;
            if (stream.Length - startPos < EOCDL64_SIZE)
            {
                return false;
            }

            BinaryReader reader = new BinaryReader(stream);
            uint sig = reader.ReadUInt32();

            if (sig != EOCDL64SIG)
            {
                return false;
            }

            this.dirStartDiskNumber = reader.ReadUInt32();
            this.dirOffset = reader.ReadInt64();
            this.totalDisks = reader.ReadUInt32();

            return true;
        }

        public void Write(Stream stream)
        {
            BinaryWriter writer = new BinaryWriter(stream);
            writer.Write(EOCDL64SIG);
            writer.Write(this.dirStartDiskNumber);
            writer.Write(this.dirOffset);
            writer.Write(this.totalDisks);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LIVEnAuthClient\LIVEnAuthClient\ByteEncoding.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace LIVEnAuthClient
{
           /// <summary>
        /// Encoding to just get the gosh dern bytes out of the string, and visa versa
        /// </summary>
        public class ByteEncoding : System.Text.Encoding
        {
            private static ByteEncoding _instance = null;

            public static ByteEncoding Instance
            {
                get
                {
                    if (_instance != null)
                    {
                        return _instance;
                    }

                    lock (typeof(ByteEncoding))
                    {
                        if (_instance == null)
                        {
                            _instance = new ByteEncoding();
                        }
                    }

                    return _instance;
                }
            }

            public override string EncodingName { get { return "ByteEncoding"; } }

            #region GetBytes

            public override byte[] GetBytes(string s)
            {
                byte[] b = new byte[s.Length];
                GetBytes(s, 0, s.Length, b, 0);
                return b;
            }

            public override int GetBytes(string s, int charIndex, int charCount, byte[] bytes, int byteIndex)
            {
                for (int i = 0; i < charCount; ++i)
                    bytes[byteIndex + i] = (byte)s[charIndex + i];
                return charCount;
            }

            public override byte[] GetBytes(char[] chars)
            {
                byte[] b = new byte[chars.Length];
                GetBytes(chars, 0, chars.Length, b, 0);
                return b;
            }

            public override int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex)
            {
                for (int i = 0; i < charCount; ++i)
                    bytes[byteIndex + i] = (byte)chars[charIndex + i];
                return charCount;
            }

            #endregion

            #region GetString

            public override string GetString(byte[] bytes)
            {
                return GetString(bytes, 0, bytes.Length);
            }

            public override string GetString(byte[] bytes, int start, int length)
            {
                System.Text.StringBuilder sb = new System.Text.StringBuilder(length);
                for (int i = 0; i < length; ++i)
                    sb.Append((char)bytes[start + i]);
                return sb.ToString();
            }

            public string GetNullTerminatedString(byte[] bytes, int start, int length)
            {
                System.Text.StringBuilder sb = new System.Text.StringBuilder(length);
                for (int i = 0; i < length; ++i)
                {
                    byte b = bytes[start + i];
                    if (b == 0)
                        break;
                    sb.Append((char)b);
                }
                return sb.ToString();
            }

            #endregion

            #region GetByteCount

            public override int GetByteCount(char[] chars, int index, int count)
            {
                return count;
            }

            public override int GetByteCount(string s)
            {
                return s.Length;
            }

            #endregion

            public override int GetCharCount(byte[] bytes, int index, int count)
            {
                throw new System.Exception("The method or operation is not implemented.");
            }

            public override int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex)
            {
                throw new System.Exception("The method or operation is not implemented.");
            }

            public override int GetMaxByteCount(int charCount)
            {
                throw new System.Exception("The method or operation is not implemented.");
            }

            public override int GetMaxCharCount(int byteCount)
            {
                throw new System.Exception("The method or operation is not implemented.");
            }
        };
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LIVEnAuthClient\LIVEnAuthClient\HttpRequest.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace LIVEnAuthClient
{
    public class HttpRequest
    {
        //Required first header
        public string Method = "GET";
        public string URI = "/";                                    //Path or Resourse to access (for example "/foo/bar.html")
        public string Version = "HTTP/1.1";

        //Common headers
        public string Host;                                       //Name of the server (for example "livetest")
        public string ContentLength;

        //Any other headers you'd like to include.
        //Each header is just added as-is (For valid requests you need to format it like "Name: Value"), and is seperated by \r\n.
        public LinkedList<string> OtherHeaders = new LinkedList<string>(); //A list of extra fields to include

        //The data-body to include
        public byte[] Content;

        // --

        //ctors
        public HttpRequest()
        {
        }
        public HttpRequest(string host, string path)
        {
            Host = host;
            URI = path;
        }

       //Sets the Content-Length and the body for the message
        public void SetContentLengthAndBody(byte[] data)
        {
            Content = (byte[])data.Clone();
            ContentLength = data.Length.ToString();
        }
        public void SetContentLengthAndBody(string str)
        {
            SetContentLengthAndBody(ByteEncoding.Instance.GetBytes(str));
        }

        //Retrieves the body content as a string
        public string GetContentString()
        {
            return ByteEncoding.Instance.GetString(Content);
        }

        /// <summary>
        /// Constructs the header string.
        /// </summary>
        /// <returns>The header string.</returns>
        protected string GetHeaderString()
        {
            HttpRequest useRequest = this;
            //if (BuildHeaderEvent != null) BuildHeaderEvent(this, out useRequest);

            string s = "";

            //headers
            if (useRequest.Method != null) s += useRequest.Method + " ";
            if (useRequest.URI != null) s += useRequest.URI + " ";
            if (useRequest.Version != null) s += useRequest.Version;
            if (useRequest.Method != null || useRequest.URI != null || useRequest.Version != null) s += "\r\n";

            if (useRequest.Host != null) s += "Host: " + useRequest.Host + "\r\n";

            if (useRequest.ContentLength != null) s += "Content-Length: " + useRequest.ContentLength + "\r\n";

            foreach (string ext in useRequest.OtherHeaders)
            {
                s += ext + "\r\n";
            }

            s += "\r\n";

            return s;
        }

        //puts all the fields together into a single string for the request
        public override string ToString()
        {
            string s = GetHeaderString();

            if (Content != null) s += ByteEncoding.Instance.GetString(Content);

            return s;
        }

        //puts the string representation into bytes
        public byte[] ToBytes()
        {
            string headers = GetHeaderString();
            int byte_count = ByteEncoding.Instance.GetByteCount(headers);
            byte[] ans = new byte[byte_count + (Content == null ? 0 : Content.Length)];

            ByteEncoding.Instance.GetBytes(headers, 0, headers.Length, ans, 0);
            if (Content != null)
            {
                Buffer.BlockCopy(Content, 0, ans, byte_count, Content.Length);
            }

            return ans;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LIVEnAuthClient\LIVEnAuthClient\LIVEnAuthClient.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="LIVEnAuthClient.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="zhangxu">
//     Zhangwei Xu
// </author>
//
// <summary>
//  LIVEn Auth Client library to get Windows Live RPS ticket and STS token
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="01/02/2010">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace LIVEnAuthClient
{
    using System;
    using System.Collections.Generic;
    using System.Configuration;
    using System.IO;
    using System.Linq;
    using System.Net;
    using System.Net.Cache;
    using System.Net.Security;
    using System.Net.Sockets;
    using System.Reflection;
    using System.Runtime.Serialization;
    using System.Security.Cryptography.X509Certificates;
    using System.Text;
    using System.Xml.Linq;
    using RPSTicketCreation;

    /// <summary>
    /// This class creates LiveID RPS ticket, STS token and provide information
    /// in the STS token
    /// </summary>
    public class LIVEnAuthClient
    {
        /// <summary>
        /// The dev cert thumbprint. 
        /// </summary>
        private const string DefaultDevCertThumbprint = "7d1dffceaa9c39374813dbdd473d49df6da1ff00"; 

        /// <summary>
        /// This is the STS service URL  template
        /// </summary>
        private const string SecurityTicketQuery = "/GetSecurityTicket?platformType={platformId}&titleId={titleId}&titleVersion={titleVersion}&clientVersion={clientVersion}&deviceId={deviceId}";

        /// <summary>
        /// This is the STS service URL template for partner tickets
        /// </summary>
        private const string PartnerSecurityTicketQuery = "/GetPartnerSecurityTicket?xuid={xuid}&titleId={titleId}&titleVersion={titleVersion}&audience={audience}";

        /// <summary>
        /// Https prefix string
        /// </summary>
        private const string HttpsPrefix = "https";

        /// <summary>
        /// Client certificate used for http request
        /// </summary>
        private static X509Certificate certificate;

        /// <summary>
        /// The thumbprint of the certificate to use. 
        /// </summary>
        private static string certThumbprint; 

        /// <summary>
        /// This is callback to ignore server validation
        /// </summary>
        private static RemoteCertificateValidationCallback allGood = delegate(object sender, System.Security.Cryptography.X509Certificates.X509Certificate certificate,
                                           System.Security.Cryptography.X509Certificates.X509Chain chain,
                                           System.Net.Security.SslPolicyErrors sslPolicyErrors)
        {
            return true; // **** Always accept
        };

        /// <summary>
        /// Gets or sets the thumbprint to use. 
        /// </summary>
        public static string CertThumbprint
        {
            get
            {
                if (string.IsNullOrEmpty(certThumbprint))
                {
                    // return the default dev cert thumbprint when it is requested.
                    // the code only request this value when client cert is required in the request. 
                    return DefaultDevCertThumbprint; 
                }
                else
                {
                    return certThumbprint;
                }
            }

            set 
            { 
                certThumbprint = value; 
            }
        }

        /// <summary>
        /// Helper method - to get TokenForLiveID using LiveIDClient.
        /// </summary>
        /// <param name="memberName">Windows Live ID</param>
        /// <param name="password">Password of the Live ID</param>
        /// <param name="liveIDServiceTarget">Service Target</param>
        /// <returns>RPS compact ticket string</returns>
        public static string GetRPSTicket(
            string memberName,
            string password,
            string liveIDServiceTarget)
        {
            return GetRPSTicket(memberName, password, liveIDServiceTarget, false); 
        }

        /// <summary>
        /// Helper method - to get TokenForLiveID using LiveIDClient.
        /// </summary>
        /// <param name="memberName">Windows Live ID</param>
        /// <param name="password">Password of the Live ID</param>
        /// <param name="liveIDServiceTarget">Service Target</param>
        /// <param name="accountIsProd">Whether this account is for production. </param>
        /// <returns>RPS compact ticket string</returns>
        public static string GetRPSTicket(
            string memberName,
            string password,
            string liveIDServiceTarget, 
            bool accountIsProd)
        {
            // Initialize RPS Ticket generator
            RPSTicketGeneratorConfig rpsconfig = new RPSTicketGeneratorConfig();
            rpsconfig.SiteURL = liveIDServiceTarget;
            if (accountIsProd)
            {
                rpsconfig.PPEnv = PassportEnvironment.Production;
            }
            else
            {
                rpsconfig.PPEnv = PassportEnvironment.INT;
            }

            rpsconfig.CacheData = false;

            RPSTicketGenerator ticketgen = new RPSTicketGenerator(rpsconfig);
            string rpsTicket = string.Empty;
            
            try
            {
                rpsTicket = ticketgen.GetRPSCompactTicket(memberName, password);
            }
            catch (Exception ex)
            {
                throw new Exception(String.Format("Asynchronous login failed for user {0} with password {1} against site {2}", memberName, password, rpsconfig.SiteURL) + ex.Message);
            }

            return rpsTicket;
        }

        /// <summary>
        /// This method creates a http web request based on http 
        /// or https. If it is https, it will attach client certificate
        /// </summary>
        /// <param name="serviceUrl">Service URL string</param>
        /// <param name="optionalRequest">Optional HTTP Web Request object</param>
        /// <param name="useClientCert">Whether to use client cert or not</param>
        /// <returns>A HTTP Web Request</returns>
        public static HttpWebRequest GetWebRequest(
            string serviceUrl,
            HttpWebRequest optionalRequest,
            bool useClientCert)
        {
            if (serviceUrl.StartsWith(LIVEnAuthClient.HttpsPrefix) && useClientCert)
            {
                // Load the certificate from store
                X509Store certStore = new X509Store("My", StoreLocation.LocalMachine);
                certStore.Open(OpenFlags.ReadOnly | OpenFlags.OpenExistingOnly);
                certificate = certStore.Certificates.Find(X509FindType.FindByThumbprint, CertThumbprint, false)[0];
                certStore.Close();

                Uri url = new Uri(serviceUrl);

                // Use this bit of .Net specific trickery to enable our use of whatever client certificate we want in
                // HttpWebRequest.  See this documentation on SslStream http://msdn.microsoft.com/en-us/library/ms145057.aspx
                // The Note down below mentions this "technique" of caching an SSL state
                TcpClient tcp = new TcpClient(url.Host, url.Port);
                SslStream ssl = new SslStream(tcp.GetStream(), false, allGood, PickMyCert);
                ssl.AuthenticateAsClient(
                    url.Host, 
                    new X509CertificateCollection(new X509Certificate[] { certificate }),
                    System.Security.Authentication.SslProtocols.Default, 
                    false);

                // create a request that we don't care about
                HttpRequest req = new HttpRequest(url.Host + ":" + url.Port, url.PathAndQuery);

                ssl.Write(req.ToBytes());
                ssl.Flush();

                // this read is necessary to force the client certificate
                ssl.Read(new byte[1], 0, 1);
                ssl.Close();
            }

            // Create Http request
            HttpWebRequest request = optionalRequest;

            if (optionalRequest == null)
            {
                request = (HttpWebRequest)WebRequest.Create(serviceUrl);
            }

            if (serviceUrl.StartsWith(LIVEnAuthClient.HttpsPrefix) && useClientCert)
            {
                request.ClientCertificates.Add(certificate);
                System.Net.ServicePointManager.ServerCertificateValidationCallback += allGood;
            }

            return request;
        }

        /// <summary>
        /// This method closes web request with necessary clean up
        /// </summary>
        /// <param name="url">URL String</param>
        /// <param name="request">Http web request to clean up</param>
        public static void CloseWebRequest(
            string url,
            HttpWebRequest request)
        {
            if (url.StartsWith(LIVEnAuthClient.HttpsPrefix))
            {
                // Reset the policy back
                System.Net.ServicePointManager.ServerCertificateValidationCallback -= allGood;
            }
        }

        /// <summary>
        /// This method generates a STS token based on RPS ticket
        /// </summary>
        /// <param name="rpsTicket">RPS ticket string</param>
        /// <param name="stsUrl">STS URL for specific environment</param>
        /// <param name="platformId">Platform ID string</param>
        /// <param name="titleId">Title ID string</param> 
        /// <param name="titleVersion">Title version string</param>
        /// <param name="clientVersion">Client version string</param>
        /// <param name="deviceId">Device ID String</param>
        /// <returns>SAML Token</returns>
        public static string GenerateSTSTicket(
            string rpsTicket,
            string stsUrl,           
            string platformId,
            string titleId,
            string titleVersion,
            string clientVersion,
            string deviceId)
        {
            string fullUri = SecurityTicketQuery;
            HttpWebRequest request;
            
            fullUri = fullUri.Replace("{platformId}", platformId);
            fullUri = fullUri.Replace("{titleId}", titleId);
            fullUri = fullUri.Replace("{titleVersion}", titleVersion);
            fullUri = fullUri.Replace("{clientVersion}", clientVersion);
            fullUri = fullUri.Replace("{deviceId}", deviceId);

            // Get a http web request
            request = LIVEnAuthClient.GetWebRequest(stsUrl + fullUri, null, true);            
           
            // Add auth header
            string ticket = rpsTicket;
            ticket = ticket.Remove(0, 1);
            ticket = ticket.Remove(ticket.Length - 1);
            ticket = "WLID1.0 t=" + ticket;
            request.Headers.Add("Authorization", ticket);
            string stsTicket;
            try
            {
                // Issue the request and get the response
                HttpWebResponse response = (HttpWebResponse)request.GetResponse();

                // Get the ticket
                Stream dataStream = response.GetResponseStream();
                StreamReader reader = new StreamReader(dataStream);
                stsTicket = reader.ReadToEnd();
                stsTicket = GetSAMLData(stsTicket);
            }
            finally
            {
                LIVEnAuthClient.CloseWebRequest(stsUrl, request);
            }

            return stsTicket;
        }

        /// <summary>
        /// Generates partner sts token. 
        /// </summary>
        /// <param name="stsUrl">The url of the sts service. </param>
        /// <param name="stsUserTicket">The sts user token. </param>
        /// <param name="titleId">The title id. </param>
        /// <param name="titleVersion">The version of the title. </param>
        /// <returns>Partnertoken string. </returns>
        public static string GeneratePartnerSTSTicket(string stsUrl, string stsUserTicket, string titleId, string titleVersion, string audienceUri)
        {
            XblSamlToken samlToken = new XblSamlToken(stsUserTicket);
            string xuid = samlToken.GetAttributeValue(XblSamlToken.name_attribute_xuid0);

            string fullUri = PartnerSecurityTicketQuery;
            HttpWebRequest request;

            fullUri = fullUri.Replace("{xuid}", xuid);
            fullUri = fullUri.Replace("{titleId}", titleId);
            fullUri = fullUri.Replace("{titleVersion}", titleVersion);
            fullUri = fullUri.Replace("{audience}", audienceUri);

            // Get a http web request
            request = LIVEnAuthClient.GetWebRequest(stsUrl + fullUri, null, true);

            // Add auth header
            request.Headers.Add(UserAccount.AuthHeader, UserAccount.XblHeader + stsUserTicket);
            string stsTicket;
            try
            {
                // Issue the request and get the response
                HttpWebResponse response = (HttpWebResponse)request.GetResponse();

                // Get the ticket
                Stream dataStream = response.GetResponseStream();
                StreamReader reader = new StreamReader(dataStream);
                stsTicket = reader.ReadToEnd();
                stsTicket = GetSAMLData(stsTicket);
            }
            finally
            {
                LIVEnAuthClient.CloseWebRequest(stsUrl, request);
            }

            return stsTicket;
        }

        /// <summary>
        /// This method takes a RPS ticket and creates a mobile
        /// account.
        /// </summary>
        /// <param name="passportMemberName">Passport member name string</param>
        /// <param name="rpsTicket">RPS ticket string</param>
        /// <param name="machineToken">Machine token string</param>
        /// <param name="xuacsUrl">XUACS URL string</param>
        /// <param name="countryId">Country Id string</param>
        /// <param name="languageId">Language Id string</param>
        /// <param name="birthDate">BirthDate of the user</param>
        /// <returns>Status code</returns>
        public static uint CreateMobileAccount(
            string passportMemberName,
            string rpsTicket,
            string machineToken,
            string xuacsUrl,
            byte countryId,
            ushort languageId,
            DateTime birthDate)
        {
            ulong userPuid = 0;
            ulong machinePuid = 0;
            XblSamlToken samlToken;
            string xuidString = String.Empty;
            System.Text.ASCIIEncoding encoding = new System.Text.ASCIIEncoding();
            UserAccount userAccountService = new UserAccount();

            // Retrieve user puid and machine puid from machineToken
            samlToken = new XblSamlToken(machineToken);
            userPuid = Convert.ToUInt64(samlToken.GetAttributeValue(XblSamlToken.name_attribute_puid0));
            machinePuid = Convert.ToUInt64(samlToken.GetAttributeValue(XblSamlToken.name_attribute_machineid));

            try
            {
                xuidString = samlToken.GetAttributeValue(XblSamlToken.name_attribute_xuid0);
            }
            catch (Exception)
            {
                xuidString = String.Empty;
            }

            // If XUID already exists for this user, no need to
            // create the account
            if (!String.IsNullOrEmpty(xuidString))
            {
                return 0;
            }

            // Set URL and auth token for AcceptTOU
            userAccountService.Url = xuacsUrl;
            userAccountService.LiveIDToken = rpsTicket;

            // Accept latest TOU
            userAccountService.AcceptTermsOfService(
                userPuid, 
                encoding.GetBytes(rpsTicket), 
                ServiceTypeEnum.XboxLive);

            // Set auth token for other calls
            userAccountService.LiveIDToken = String.Empty;
            userAccountService.StsToken = machineToken;

            // Generate a random gamer tag
            string gamerTag = userAccountService.GenerateGamertag(
                passportMemberName.Remove(passportMemberName.IndexOf('@')),
                machinePuid,
                GamertagSuggestionType.SeedSuggestion);

            // Create mobile account
            return userAccountService.CreateMobileAccount(
                userPuid, 
                encoding.GetBytes(rpsTicket), 
                machinePuid, 
                gamerTag, 
                countryId, 
                languageId, 
                birthDate);
        }

        /// <summary>
        /// This method parses the STS HTTP response and returns the SAML token
        /// </summary>
        /// <param name="stsServiceResponse">HTTP response from STS service</param>
        /// <returns>SAML Token</returns>
        private static string GetSAMLData(string stsServiceResponse)
        {
            try
            {
                XDocument stsResponse = XDocument.Parse(stsServiceResponse);
                return stsResponse.Descendants().Where(n => n.Name.LocalName == "string").ElementAt(0).Value;
            }
            catch
            {
                throw new Exception("The STS token was invalid.");
            }
        }

        /// <summary>
        /// Method to pick the right client cert
        /// </summary>
        /// <param name="sender">Sender object</param>
        /// <param name="targetHost">Target host</param>
        /// <param name="localCertificates">Local certificate</param>
        /// <param name="remoteCertificate">Remote certificate</param>
        /// <param name="acceptableIssuers">Acceptable issuers</param>
        /// <returns>Client certificate to use</returns>
        private static X509Certificate PickMyCert(
            object sender, 
            string targetHost, 
            X509CertificateCollection localCertificates,
            X509Certificate remoteCertificate, 
            string[] acceptableIssuers)
        {
            return certificate;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LIVEnAuthClient\LIVEnAuthClient\XblSamlToken.cs ===
﻿// 
// XblSamlToken.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Xbox Online Service
//
// Wrapper class for Xbl1.0 Saml Token
//

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.IO;
using System.IdentityModel.Selectors;
using System.IdentityModel.Tokens;
using System.ServiceModel.Security;
using System.Xml;


namespace LIVEnAuthClient
{
    using System.Net;

    public class XblSamlToken
    {
        public const int xbl10_samlmajorversion = 1;
        public const int xbl10_samlminorversion = 1;
        public const string xbl10_samlissuer = "http://sts.xboxlive.com";
        public const string ns_attribute_claims = "http://xboxlive.com/claims";

        public const string name_attribute_platformtype = "PlatformType";
        public const string name_attribute_machineid = "MachineID";
        public const string name_attribute_deviceid = "DeviceID";
        public const string name_attribute_clientversion = "ClientVersion";
        public const string name_attribute_titleid = "TitleID";
        public const string name_attribute_titleversion = "TitleVersion";
        public const string name_attribute_puid0 = "Puid0";
        public const string name_attribute_cid0 = "CID0";
        public const string name_attribute_xuid0 = "Xuid0";
        public const string name_attribute_gamertag0 = "Gamertag0";
        public const string name_attribute_tier0 = "Tier0";
        public const string name_attribute_country0 = "Country0";
        public const string name_attribute_privileges0 = "Privileges0";
        public const string name_attribute_partnerid0 = "PartnerID0";

        // Attributes
        protected SamlSecurityToken _samlSecurityToken;
        protected Dictionary<string, string> _claims = new Dictionary<string, string>();

        // Constructor
        public XblSamlToken(string samlToken)
        {
            _samlSecurityToken = XblSamlToken.GetTokenFromString(samlToken);

            // Populate the dictionary from token Attributes
            IList<SamlAttribute> samlAttributes = ((SamlAttributeStatement)_samlSecurityToken.Assertion.Statements[0]).Attributes;

            foreach (SamlAttribute samlAttribute in samlAttributes)
            {
                _claims.Add(samlAttribute.Name, samlAttribute.AttributeValues[0]);
            }

        }

        // Properties
        public IList<SamlAttribute> Attributes
        {
            get
            {
                return ((SamlAttributeStatement)_samlSecurityToken.Assertion.Statements[0]).Attributes;
            }
        }

        public string Issuer
        {
            get
            {
                return _samlSecurityToken.Assertion.Issuer;
            }
        }

        public int MajorVersion
        {
            get
            {
                return _samlSecurityToken.Assertion.MajorVersion;
            }
        }

        public int MinorVersion
        {
            get
            {
                return _samlSecurityToken.Assertion.MinorVersion;
            }
        }

        public DateTime NotBefore
        {
            get
            {
                return _samlSecurityToken.Assertion.Conditions.NotBefore;
            }
        }

        public SamlSecurityToken SecurityToken
        {
            get
            {
                return _samlSecurityToken;
            }
        }

        public SamlSubject Subject
        {
            get
            {
                return ((SamlSubjectStatement)_samlSecurityToken.Assertion.Statements[0]).SamlSubject;
            }
        }

        public string SubjectName
        {
            get
            {
                return ((SamlSubjectStatement)_samlSecurityToken.Assertion.Statements[0]).SamlSubject.Name;
            }
        }

        public DateTime ValidTo
        {
            get
            {
                return _samlSecurityToken.ValidTo;
            }
        }

        // Implementation public

        public string GetAttributeValue(string name)
        {
            return _claims[name];
        }

        // -------------------------------------------------------------------------------
        // GetTokenFromString 
        //
        // Validates a string is in fact a SAML Token and returns the Token as read from 
        // the string.
        // -------------------------------------------------------------------------------
        public static SamlSecurityToken GetTokenFromString(
            string samlToken)
        {
            //SamlUtilInit();
            SecurityTokenResolver outOfBandTokenResolver = SecurityTokenResolver.CreateDefaultSecurityTokenResolver(new ReadOnlyCollection<SecurityToken>(new List<SecurityToken>()), false);
            SamlSerializer serializer = new SamlSerializer();

            using (XmlReader reader = XmlReader.Create(new StringReader(samlToken)))
            {
                //this validates the signature and time windows, as well as format of conditions and attributes
                return serializer.ReadToken(reader, WSSecurityTokenSerializer.DefaultInstance, outOfBandTokenResolver);
            }
        }

        // -------------------------------------------------------------------------------
        // TryGetAttributeValue 
        //
        // Gets the value associated with the specified key.
        // -------------------------------------------------------------------------------
        public bool TryGetAttributeValue(string name, out string value)
        {
            return _claims.TryGetValue(name, out value);
        }

        public void Validate()
        {
            //general saml validation
            if (xbl10_samlmajorversion != MajorVersion)
            {
                //throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_XBOXLIVETOKEN_INVALID_VERSION, "; SAML MajorVersion attribute is {0}, but {1} is expected.", MajorVersion, xbl10_samlmajorversion );
                throw new Exception("SAML MajorVersion attribute is wrong");
            }

            if (xbl10_samlminorversion != MinorVersion)
            {
                //throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_XBOXLIVETOKEN_INVALID_VERSION, "; SAML MinorVersion attribute is {0}, but {1} is expected.", MinorVersion, xbl10_samlminorversion );
                throw new Exception("SAML MinorVersion attribute is wrong");
            }

            if (xbl10_samlissuer != Issuer)
            {
                //throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_XBOXLIVETOKEN_INVALID_ISSUER, "; SAML Issuer attribute is {0}, but {1} is expected.", Issuer, xbl10_samlissuer );
                throw new Exception("SAML Issuer attribute is wrong");
            }

            // There should be only one SamlStatement
            if (1 != _samlSecurityToken.Assertion.Statements.Count)
            {
                //throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_XBOXLIVETOKEN_INVALID_STATEMENT_COUNT, "; SAML Statement count is {0}, but 1 is expected.", _samlSecurityToken.Assertion.Statements.Count );
                throw new Exception("Too many SAML statements");
            }

            // It should be of type SamlAttributeStatement
            if (!(_samlSecurityToken.Assertion.Statements[0] is System.IdentityModel.Tokens.SamlAttributeStatement))
            {
                //throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_XBOXLIVETOKEN_INVALID_STATEMENT_TYPE, "; SAML Statement type is {0}, but Type:System.IdentityModel.Tokens.SamlAttributeStatement is expected.", _samlSecurityToken.Assertion.Statements[0].GetType());
                throw new Exception("Statement type is not assertion");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LIVEnAuthClient\LIVEnAuthClient\Properties\AssemblyInfo.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="AssemblyInfo.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="zhangxu">
//     Zhangwei Xu
// </author>
//
// <summary>
//  Assembly information
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="01/02/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("LIVEnAuthClient")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
//[assembly: AssemblyCompany("Microsoft")]
//[assembly: AssemblyProduct("LIVEnAuthClient")]
//[assembly: AssemblyCopyright("Copyright © Microsoft 2010")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("4eab08e8-8036-4b34-b0ee-923fc82f7f66")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
//[assembly: AssemblyVersion("1.0.*")]
//[assembly: AssemblyVersion("1.0.0.0")]
//[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LIVEnAuthClient\LiveNTool\GameState.cs ===
﻿//------------------------------------------------------------------------------------------------- 
// <copyright file="SessionManagementService.cs" company="Microsoft" author="a-thkuo">
//      Copyright © .  All rights reserved.
// </copyright>
// <summary>Code to test Session Management Service API</summary>
//-------------------------------------------------------------------------------------------------
namespace LIVEnTool
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Net;
    using System.Runtime.Serialization;
    using System.Text;
    using AsyncMultiplayer.SessionCommon;
    using LIVEnAuthClient;
    
    /// <summary>
    /// SessionManagementService class definition
    /// </summary>
    public class GameStateService
    {
        public static string GetGameState(string membername, string password, string sessionId, string gameId)
        {
            string userToken = TokenService.GetNewUserToken(membername, password, HelperLibrary.TitleId, HelperLibrary.TitleVersion);
            string partnerToken = TokenService.GetPartnerToken(userToken, HelperLibrary.MultiplayerAudienceUri, HelperLibrary.TitleId, HelperLibrary.TitleVersion);
            return GameStateService.GetGameState(partnerToken, sessionId, gameId);
        }

        /// <summary>
        /// Create a new session
        /// </summary>
        /// <param name="partnerToken">Partner's STS token</param>
        /// <returns>Response from the session creation request</returns>
        public static string GetGameState(string partnerToken, string sessionId, string gameId)
        {
            string ret = string.Empty;

            string uri = String.Format(
                "{0}GameState/{1}/{2}",
                HelperLibrary.GameStateServiceUrl,
                sessionId,
                gameId);

            WebResponse response = HelperLibrary.SendRequest(uri, "GET", partnerToken, true, string.Empty, "application/xml", out ret);

            return ret;            
        }

        public static string PutGameState(string membername, string password, string sessionId, string gameId, string activeSeatIndex, string gameData)
        {
            string userToken = TokenService.GetNewUserToken(membername, password, HelperLibrary.TitleId, HelperLibrary.TitleVersion);
            string partnerToken = TokenService.GetPartnerToken(userToken, HelperLibrary.MultiplayerAudienceUri, HelperLibrary.TitleId, HelperLibrary.TitleVersion);
            return GameStateService.PutGameState(partnerToken, sessionId, gameId, activeSeatIndex, gameData);
        }

        /// <summary>
        /// Create a new session
        /// </summary>
        /// <param name="partnerToken">Partner's STS token</param>
        /// <returns>Response from the session creation request</returns>
        public static string PutGameState(string partnerToken, string sessionId, string gameId, string activeSeatIndex, string gameData)
        {
            string ret = string.Empty;

            ModifiableGameState mgs = new ModifiableGameState();
            mgs.ActiveSeatIndex = int.Parse(activeSeatIndex);

            mgs.GameData = HelperLibrary.StringToByteArray(gameData);

            string uri = String.Format("{0}GameState/{1}/{2}", HelperLibrary.GameStateServiceUrl, sessionId, gameId);

            string requestBody = HelperLibrary.Deserialize(mgs);

            WebResponse response = HelperLibrary.SendRequest(uri, "PUT", partnerToken, true, requestBody, "application/xml", out ret);

            return ret;
        }

        public static string PostGameEnd(
            string membername, 
            string password, 
            string sessionId,
            string gameId,
            string gameOverSeatIndexes, 
            string losingSeatIndexes, 
            string tierSeatIndexes,
            string winningSeatIndexes,
            string gameResultKey, 
            string variant,
            string gameResultId,
            string timeStamp,
            string score,
            string time,
            string outcome,
            string blob)
        {
            string userToken = TokenService.GetNewUserToken(membername, password, HelperLibrary.TitleId, HelperLibrary.TitleVersion);
            string partnerToken = TokenService.GetPartnerToken(userToken, HelperLibrary.MultiplayerAudienceUri, HelperLibrary.TitleId, HelperLibrary.TitleVersion);
            return GameStateService.PostGameEnd(
                partnerToken, 
                sessionId, 
                gameId, 
                gameOverSeatIndexes, 
                losingSeatIndexes,
                tierSeatIndexes,
                winningSeatIndexes,
                gameResultKey,
                variant,
                gameResultId,
                timeStamp,
                score,
                time,
                outcome,
                blob);
        }


        /// <summary>
        /// Create a new session
        /// </summary>
        /// <param name="partnerToken">Partner's STS token</param>
        /// <returns>Response from the session creation request</returns>
        public static string PostGameEnd(
            string partnerToken, 
            string sessionId, 
            string gameId, 
            string gameOverSeatIndexes,
            string losingSeatIndexes,
            string tierSeatIndexes,
            string winningSeatIndexes,
            string gameResultKey,
            string variant,
            string gameResultId,
            string timeStamp,
            string score,
            string time,
            string outcome,
            string blob)
        {
            string ret = string.Empty;

            GameResults gr = new GameResults();
            gr.GameOverSeatIndexes = HelperLibrary.StringSplitter<int>(gameOverSeatIndexes, ',');

            gr.LosingSeatIndexes = HelperLibrary.StringSplitter<int>(losingSeatIndexes, ',');
            gr.TierSeatIndexes = HelperLibrary.StringSplitter<int>(tierSeatIndexes, ',');
            gr.WinningSeatIndexes = HelperLibrary.StringSplitter<int>(winningSeatIndexes, ',');
            gr.Results = new Dictionary<int, Gds.Contracts.GameResult>();

            Gds.Contracts.GameResult result = new Gds.Contracts.GameResult();

            result.Blob = HelperLibrary.StringToByteArray(blob);

            result.GameId = uint.Parse(gameId);
            result.GameResultId = new Guid(gameResultId);
            result.Outcome = outcome;
            result.Score = long.Parse(score);
            result.Time = long.Parse(time);
            result.TimeStamp = DateTime.Parse(timeStamp);
            result.Variant = uint.Parse(variant);

            gr.Results.Add(int.Parse(gameResultKey), result);

            string uri = String.Format("{0}GameState/{1}/{2}", HelperLibrary.GameStateServiceUrl, sessionId, gameId);

            string requestBody = HelperLibrary.Deserialize(gr);

            WebResponse response = HelperLibrary.SendRequest(uri, "POST", partnerToken, true, requestBody, "application/xml", out ret);

            return ret;
        }

        public static string PostGameAction(
            string membername, 
            string password, 
            string sessionId, 
            string gameId,
            string actionData,
            string actionTime,
            string actionType,
            string sequenceNumber)
        {
            string userToken = TokenService.GetNewUserToken(membername, password, HelperLibrary.TitleId, HelperLibrary.TitleVersion);
            string partnerToken = TokenService.GetPartnerToken(userToken, HelperLibrary.MultiplayerAudienceUri, HelperLibrary.TitleId, HelperLibrary.TitleVersion);
            return GameStateService.PostGameAction(
                partnerToken, 
                sessionId, 
                gameId, 
                actionData, 
                actionTime,
                actionType,
                sequenceNumber);
        }

        /// <summary>
        /// Create a new session
        /// </summary>
        /// <param name="partnerToken">Partner's STS token</param>
        /// <returns>Response from the session creation request</returns>
        public static string PostGameAction(
            string partnerToken, 
            string sessionId, 
            string gameId, 
            string actionData, 
            string actionTime,
            string actionType,
            string sequenceNumber)
        {
            string ret = string.Empty;

            GameAction ga = new GameAction();
            ga.ActionData = HelperLibrary.StringToByteArray(actionData);
            ga.ActionTime = DateTime.Parse(actionTime);
            ga.ActionType = (GameActionType)Enum.Parse(typeof(GameActionType), actionType);
            ga.SequenceNumber = int.Parse(sequenceNumber);


            string uri = String.Format("{0}GameAction/{1}/{2}", HelperLibrary.GameStateServiceUrl, sessionId, gameId);

            string requestBody = HelperLibrary.Deserialize(ga);

            WebResponse response = HelperLibrary.SendRequest(uri, "POST", partnerToken, true, requestBody, "application/xml", out ret);

            return ret;
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LIVEnAuthClient\LiveNTool\AccountService.cs ===
﻿//------------------------------------------------------------------------------------------------- 
// <copyright file="AccountService.cs" company="Microsoft" author="a-thkuo">
//      Copyright © .  All rights reserved.
// </copyright>
// <summary>Code to get RPS ticket and create mobile account</summary>
//-------------------------------------------------------------------------------------------------
namespace LIVEnTool
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using LIVEnAuthClient;

    /// <summary>
    /// AccountService class definition
    /// </summary>
    public class AccountService
    {
        /// <summary>
        /// Method to get RPS ticket
        /// </summary>
        /// <param name="memberName">The LIVEN user id</param>
        /// <param name="password">The user's password</param>
        /// <returns>The RPS ticket string</returns>
        public static string GetRPSTicket(string memberName, string password)
        {
            Console.WriteLine("Getting RPS Ticket...");

            string rpsTicket = string.Empty;

            if (HelperLibrary.AccountIsProduction)
            {
                // if the environment is PROD
                rpsTicket = LIVEnAuthClient.GetRPSTicket(memberName, password, HelperLibrary.LiveIDServiceTarget, true);
            }
            else
            {
                rpsTicket = LIVEnAuthClient.GetRPSTicket(memberName, password, HelperLibrary.LiveIDServiceTarget);
            }

            return rpsTicket;
        }

        ///// <summary>
        ///// Method to create a mobile account
        ///// </summary>
        ///// <param name="rpsTicket">The RPS ticket</param>
        ///// <param name="userToken">The user token</param>
        ///// <param name="memberName">The LIVEN user id</param>
        ///// <param name="birthDate">The birthdate of the user</param>
        ///// <returns>0 indicates a successful account creation</returns>

        /// <summary>
        /// Method to create a mobile account
        /// </summary>
        /// <param name="memberName">Member name (i.e. the LIVEN user id)</param>
        /// <param name="password">Member's password</param>
        /// <param name="birthDate">Member's birthdate</param>
        /// <returns>Status returned by LIVEnAuthClient. 0 means successful creation of the account.</returns>
        public static uint CreateMobileAccount(string memberName, string password, string birthDate)
        {
            Console.WriteLine("Creating mobile acount...");

            string rpsTicket = string.Empty;

            string userToken = TokenService.GetNewUserToken(memberName, password, HelperLibrary.TitleId, HelperLibrary.TitleVersion, out rpsTicket);

            uint result = LIVEnAuthClient.CreateMobileAccount(
                memberName,
                rpsTicket,
                userToken,
                HelperLibrary.XuacsUrl,
                HelperLibrary.CountryId,
                HelperLibrary.LanguageId,
                DateTime.Parse(birthDate));

            // TODO: poll for account readiness with something more performant

            // It takes some time for account to propagate
            Console.WriteLine("Account creation succeeded...");
            Console.WriteLine("Wait for 15 seconds...");
            System.Threading.Thread.Sleep(15 * 1000);
            Console.WriteLine("NOTES: It may take some time to have XUID available in STS token after account creation.");

            return result;          
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LIVEnAuthClient\LiveNTool\AvatarActions.cs ===
﻿//------------------------------------------------------------------------------------------------- 
// <copyright file="AvatarActions.cs" company="Microsoft">
//      Copyright © .  All rights reserved.
// </copyright>
// <summary>Code to test Avatar Service</summary>
//-------------------------------------------------------------------------------------------------
namespace LIVEnTool
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Net;
    using System.Runtime.Serialization;
    using System.Text;
    using Avatar.Services.ManifestRead.Library;
    using Avatar.Services.Closet.Library;
    using Avatar.Services.ManifestWrite.Library;
    using LIVEnAuthClient;
    
    /// <summary>
    /// AvatarActions class definition
    /// </summary>
    public class AvatarActions
    {
        /// <summary>
        /// Initializes a new instance of the AvatarActions class.
        /// </summary>
        public AvatarActions()
        {
        }

        #region PartnerEndpoint

        /// <summary>
        /// Calls the partner version of update manifest
        /// </summary>
        /// <param name="membername">The user's membername</param>
        /// <param name="password">The user's password</param>
        /// <returns>The webresponse responsestream</returns>
        public static string PartnerUpdateManifest(string membername, string password)
        {
            string manifest = HelperLibrary.TestAvatarManifest;

            string partnerToken = TokenService.GetPartnerToken(membername, password, HelperLibrary.AvatarAudienceUri, HelperLibrary.TitleId, HelperLibrary.TitleVersion);

            // Create a new UpdateManifest Object
            UpdateManifestRequest manifestUpdate = new UpdateManifestRequest();
            manifestUpdate.Manifest = manifest;

            string requestBody = HelperLibrary.Deserialize(manifestUpdate);
            string ret = string.Empty;

            WebResponse response = HelperLibrary.SendRequest(HelperLibrary.ManifestUpdatePartUrl, "POST", partnerToken, true, requestBody, "application/xml", out ret);
            
            return ret;
        }

        /// <summary>
        /// Calls the partner version of UpdateGamerPic
        /// </summary>
        /// <param name="membername">The user's membername</param>
        /// <param name="password">The user's password</param>
        /// <returns>The webresponse</returns>
        public static string PartnerUpdateGamerPic(string membername, string password)
        {
            string partnerToken = TokenService.GetPartnerToken(membername, password, HelperLibrary.AvatarAudienceUri, HelperLibrary.TitleId, HelperLibrary.TitleVersion);
            return AvatarActions.PartnerUpdateGamerPic(partnerToken);
        }

        /// <summary>
        /// Calls the partner version of UpdateGamerPic
        /// </summary>
        /// <param name="partnerToken">The partner's STS token</param>
        /// <returns>The webresponse</returns>
        public static string PartnerUpdateGamerPic(string partnerToken)
        {
            string ret = string.Empty;

            // Create a new UpdateGamerPicRequest Object
            UpdateGamerPicRequest gamerPicUpdate = new UpdateGamerPicRequest();
            gamerPicUpdate.AnimationId = new Guid("00400000-001d-0003-c1c8-f109a19cb2e0"); // animation for a male avatar
            gamerPicUpdate.UseProp = false;
            gamerPicUpdate.FocalJoint = 19;  // Head joint
            gamerPicUpdate.OffsetX = 0;
            gamerPicUpdate.OffsetY = -0.03f;
            gamerPicUpdate.OffsetZ = 2.4f;
            gamerPicUpdate.RotationY = 0.03f;
            gamerPicUpdate.FieldOfView = 0.155f;
            gamerPicUpdate.Background = 0;
            gamerPicUpdate.Frame = 0.05212739f;

            string requestBody = HelperLibrary.Deserialize(gamerPicUpdate);

            WebResponse response = HelperLibrary.SendRequest(HelperLibrary.GamerPicUpdatePartUrl, "POST", partnerToken, true, requestBody, "application/xml", out ret);
            return ret;
        }

        /// <summary>
        /// Calles the partner version of GetClosetAssets
        /// </summary>
        /// <param name="membername">The membername</param>
        /// <param name="password">The password</param>
        /// <returns>The web response stream</returns>
        public static string PartnerGetClosetAssets(string membername, string password)
        {
            string partnerToken = TokenService.GetPartnerToken(membername, password, HelperLibrary.AvatarAudienceUri, HelperLibrary.TitleId, HelperLibrary.TitleVersion);
            return AvatarActions.PartnerGetClosetAssets(partnerToken);
        }

        /// <summary>
        /// Calls the partner version of GetClosetAssets
        /// </summary>
        /// <param name="partnerToken">The partner STS token</param>
        /// <returns>The web response stream</returns>
        public static string PartnerGetClosetAssets(string partnerToken)
        {
            string ret = string.Empty;

            WebRequest request = HelperLibrary.CreateRequest(HelperLibrary.GetClosetAssetPartUrl, "GET", partnerToken, true, string.Empty, "application/xml");
            request.Headers.Add("X-Platform-Type", "15");
            WebResponse response = HelperLibrary.SendRequest(request, out ret);

            return ret;
        }

        /// <summary>
        /// Calls the partner version of Manifest read
        /// </summary>
        /// <param name="membername">The user's membername</param>
        /// <param name="password">The user's password</param>
        /// <returns>The web response stream</returns>
        public static string PartnerReadManifest(string membername, string password)
        {
            string partnerToken = TokenService.GetPartnerToken(membername, password, HelperLibrary.AvatarAudienceUri, HelperLibrary.TitleId, HelperLibrary.TitleVersion);
            return AvatarActions.PartnerReadManifest(partnerToken);
        }

        /// <summary>
        /// Calls the partner version of manifest read
        /// </summary>
        /// <param name="partnerToken">The partner STS token</param>
        /// <returns>The web response stream</returns>
        public static string PartnerReadManifest(string partnerToken)
        {
            string ret = string.Empty;

            WebRequest request = HelperLibrary.CreateRequest(HelperLibrary.ManifestReadPartnerUrl, "GET", partnerToken, true, string.Empty, "application/xml");
            request.Headers.Add("X-Platform-Type", "15");
            WebResponse response = HelperLibrary.SendRequest(request, out ret);

            return ret;
        }

        /// <summary>
        /// Calls the public version of ManifestRead
        /// </summary>
        /// <param name="membername">The user's STS token</param>
        /// <param name="password">The user's password</param>
        /// <returns>The web responsestream</returns>
        public static string PartnerReadCannedManifest(string membername, string password)
        {
            string userToken = TokenService.GetNewUserToken(membername, password, HelperLibrary.TitleId, HelperLibrary.TitleVersion);
            string partnerToken = TokenService.GetPartnerToken(userToken, HelperLibrary.AvatarAudienceUri, HelperLibrary.TitleId, HelperLibrary.TitleVersion);
            return AvatarActions.PartnerReadCannedManifest(partnerToken);
        }

        /// <summary>
        /// Calls the public version of ManifestRead
        /// </summary>
        /// <param name="userToken">The user's STS token</param>
        /// <returns>The web responsestream</returns>
        public static string PartnerReadCannedManifest(string partnerToken)
        {
            string ret = string.Empty;

            WebRequest request = HelperLibrary.CreateRequest(HelperLibrary.ManifestReadPartnerUrl, "GET", partnerToken, true, string.Empty, "application/xml");

            request.Headers.Add("X-Canned", "true");

            WebResponse response = HelperLibrary.SendRequest(request, out ret);

            return ret;
        }

        #endregion PartnerEndpoint
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LIVEnAuthClient\LiveNTool\HelperLibrary.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="HelperLibrary.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="zhangxu">
//     Zhangwei Xu
// </author>
//
// <summary>
//  Get User Id tool
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="01/02/2010">
//     Class created
// </history>
//-------------------------------------------------------------------
// #define __DEBUG__

namespace LIVEnTool
{
    using System;
    using System.Collections.Generic;
    using System.Collections.Specialized;
    using System.Configuration;
    using System.Diagnostics;
    using System.IO;
    using System.Linq;
    using System.Net;
    using System.Reflection;
    using System.Runtime.Serialization;
    using System.Security.Cryptography.X509Certificates;    
    using System.Text;
    using AsyncMultiplayer.NotificationService;
    using Avatar.Services.Closet.Library;
    using LIVEnAuthClient;

    /// <summary>
    /// Main program for the tool
    /// </summary>
    public class HelperLibrary
    {
        #region fields

        /// <summary>
        /// Default Live ID service target string
        /// </summary>
        public const string DefaultLiveIDServiceTarget = "http://kdc.xblob.xboxlive.com";

        /// <summary>
        /// The client cert thumbprint
        /// </summary>
        private static string clientCertThumbprint;

        public const int InstallCertsTimeoutInSeconds = 60;

        #endregion

        #region properties
        
        /// <summary>
        /// Gets or sets Live ID Service target
        /// </summary>
        public static string LiveIDServiceTarget { get; set; }

        /// <summary>
        /// Gets or sets STS URL string
        /// </summary>
        public static string StsUrl { get; set; }

        /// <summary>
        /// Gets or sets XUACS URL string
        /// </summary>
        public static string XuacsUrl { get; set; }

        /// <summary>
        /// Gets or sets Platform ID
        /// </summary>
        public static string PlatformId { get; set; }

        /// <summary>
        /// Gets or sets Title ID string
        /// </summary>
        public static string TitleId { get; set; }

        /// <summary>
        /// Gets or sets Title version string
        /// </summary>
        public static string TitleVersion { get; set; }

        /// <summary>
        /// Gets or sets Client version string
        /// </summary>
        public static string ClientVersion { get; set; }

        /// <summary>
        /// Gets or sets Device ID string
        /// </summary>
        public static string DeviceId { get; set; }

        /// <summary>
        /// Gets or sets Country Id string
        /// </summary>
        public static byte CountryId { get; set; }

        /// <summary>
        /// Gets or sets Language Id string
        /// </summary>
        public static ushort LanguageId { get; set; }

        /// <summary>
        /// Gets or sets  Profile URL
        /// </summary>
        public static string GetProfileUrl { get; set; }

        /// <summary>
        /// Gets or sets Notification Service URL
        /// </summary>
        public static string NotificationServiceUrl { get; set; }

        /// <summary>
        /// Gets or sets Notification Service URL
        /// </summary>
        public static string NotificationPrivateServiceUrl { get; set; }

        /// <summary>
        /// Gets or sets Notification Service URL
        /// </summary>
        public static string PartnerServiceUrl { get; set; }

        /// <summary>
        /// Gets or sets Session Service URL. 
        /// </summary>
        public static string SessionServiceUrl { get; set; }

        /// <summary>
        /// Gets or sets Leaderboard URL
        /// </summary>
        public static string GetLeaderboardUrl { get; set; }

        /// <summary>
        /// Gets or sets the datablob URL
        /// </summary>
        public static string GetDatablobUrl { get; set; }
        

        /// <summary>
        /// Gets or sets the Achievements URL
        /// </summary>
        public static string GetAchievementsUrl { get; set; }

        /// <summary>
        /// Gets or sets Reward Service URL
        /// </summary>
        public static string RewardServiceUrl { get; set; }

        /// <summary>
        /// Gets or sets the Manifest Read Private Url
        /// </summary>
        public static string ManifestReadPartnerUrl { get; set; }

        /// <summary>
        /// Gets or sets Manifest Update Partner URL
        /// </summary>
        public static string ManifestUpdatePartUrl { get; set; }

        /// <summary>
        /// Gets or sets Gamer Picture Update partner URL
        /// </summary>
        public static string GamerPicUpdatePartUrl { get; set; }

        /// <summary>
        /// Gets or sets  Closet Asset Partner URL
        /// </summary>
        public static string GetClosetAssetPartUrl { get; set; }

        /// <summary>
        /// Gets or sets Game State Service URL
        /// </summary>
        public static string GameStateServiceUrl { get; set; }

        /// <summary>
        /// Gets or sets Game Metadata Service URL
        /// </summary>
        public static string GameMetadataServiceUrl { get; set; }

        /// <summary>
        /// Gets or sets the Game Data Partner Service Url
        /// </summary>
        public static string GameDataPartnerServiceUrl { get; set; }

        /// <summary>
        /// Gets or sets the Friend Partner Service Url
        /// </summary>
        public static string FriendPartnerServiceUrl { get; set; }

        /// <summary>
        /// Gets or sets the Message Partner Service Url
        /// </summary>
        public static string MessagePartnerServiceUrl { get; set; }

        /// <summary>
        /// Gets or sets the PRofile Partner Service Url
        /// </summary>
        public static string ProfilePartnerServiceUrl { get; set; }

        /// <summary>
        /// Gets or sets the Presence Partner Service Url
        /// </summary>
        public static string PresencePartnerServiceUrl { get; set; }

        /// <summary>
        /// Gets or sets TestAvatarManifest
        /// </summary>
        public static string TestAvatarManifest { get; set; }

        /// <summary>
        /// 
        /// </summary>
        public static string AvatarAudienceUri { get; set; }

        /// <summary>
        /// 
        /// </summary>
        public static string MultiplayerAudienceUri { get; set; }

        /// <summary>
        /// 
        /// </summary>
        public static string UserDataAudienceUri { get; set; }

        /// <summary>
        /// Gets or sets CertPath
        /// </summary>
        public static string CertPath { get; set; }

        /// <summary>
        /// Gets or sets CertPath
        /// </summary>
        public static string CertInstaller { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether the account is a production account
        /// </summary>
        public static bool AccountIsProduction { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether to cache the STS token
        /// </summary>
        public static bool CacheStsToken { get; set; }

        /// <summary>
        /// Gets or sets filepath to where the STS token is saved
        /// </summary>
        public static string StsTokenFilepath { get; set; }

        /// <summary>
        /// Gets or sets the lifetime of the saved STS token (in number of minutes)
        /// </summary>
        public static string StsTokenLifetime { get; set; }

        /// <summary>
        /// Gets or sets the flag to use or not use EventLog for tracing
        /// </summary>
        public static bool UseEventLog { get; set; }

        /// <summary>
        /// Gets or sets ClientCertThumbprint
        /// </summary>
        public static string ClientCertThumbprint
        {
            get 
            { 
                return HelperLibrary.clientCertThumbprint; 
            }

            set 
            { 
                HelperLibrary.clientCertThumbprint = value;
                if (!String.IsNullOrEmpty(HelperLibrary.ClientCertThumbprint))
                {
                    LIVEnAuthClient.CertThumbprint = HelperLibrary.ClientCertThumbprint;
                }
            }
        }
        #endregion

        #region public methods

        /// <summary>
        /// Helper method to deserialize an object into xml
        /// </summary>
        /// <param name="serializedObject">The serialized object</param>
        /// <returns>The deserialized version, as an xml string.</returns>
        public static string Deserialize(object serializedObject)
        {
            // Create HTTP Request stream
            MemoryStream stream = new MemoryStream();
            DataContractSerializer dcs = new DataContractSerializer(serializedObject.GetType());
            dcs.WriteObject(stream, serializedObject);
            stream.Position = 0;
            StreamReader reader = new StreamReader(stream);
            string ret = reader.ReadToEnd();
            return ret;
        }

        public static int InstallClientCerts()
        {
            string filePath = Path.GetFullPath(Environment.ExpandEnvironmentVariables(HelperLibrary.CertInstaller));
            if (File.Exists(filePath))
            {
                ProcessStartInfo startInfo = new ProcessStartInfo();
                startInfo.UseShellExecute = true;
                startInfo.Verb = "runas";
                startInfo.FileName = HelperLibrary.CertInstaller;
                Process p = Process.Start(startInfo);
                p.WaitForExit(HelperLibrary.InstallCertsTimeoutInSeconds * 1000);
                return p.ExitCode;
            }

            return -1;   // likely caused by bad path supplied in the app.config
        }

        /// <summary>
        /// Uses reflection to find the right method to call, then calls it
        /// </summary>
        /// <param name="methodName">Method name</param>
        /// <param name="parameters">The parameters</param>
        /// <returns>The response from the call</returns>
        public static object InvokeServiceMethod(string methodName, object[] parameters)
        {
            Type[] paramsTypeArray = new Type[parameters.Length];
            for (int i = 0; i < parameters.Length; i++)
            {
                paramsTypeArray[i] = parameters[i].GetType();
            }

            // todo: move this out?
            Dictionary<string, Type> classMap = new Dictionary<string, Type>();
            classMap.Add("Account", typeof(AccountService));
            classMap.Add("AvatarAction", typeof(AvatarActions));
            classMap.Add("Partner", typeof(PartnerService));
            classMap.Add("Notification", typeof(NotificationService));
            classMap.Add("NotificationInternal", typeof(NotificationPrivateService));
            classMap.Add("SessionManagement", typeof(SessionManagementService));
            classMap.Add("GameState", typeof(GameStateService));
            classMap.Add("Reward", typeof(RewardService));
            classMap.Add("Token", typeof(TokenService));
            classMap.Add("UserData", typeof(UserDataService));
            classMap.Add("UserDataPartner", typeof(UserDataPartnerService));

            // todo: find the parent class by iterating over all the above. so can be independent of the config xml.
            // string serviceType = TestCollection.GetServiceContainer(methodName);
            // Type parentClass = classMap[serviceType];

            Type parentClass = null;
            MethodInfo method = null;

            foreach (Type mappedClass in classMap.Values)
            {
                MethodInfo foundMethod = mappedClass.GetMethod(methodName, paramsTypeArray);
                if (foundMethod != null)
                {
                    parentClass = mappedClass;
                    method = foundMethod;
                    break;
                }
            }

            if (method == null)
            {
                string paramsInfo = "( ";
                foreach (object param in parameters)
                {
                    paramsInfo += param.GetType().ToString() + ", ";
                }

                if (parameters.Length > 0)
                {
                    paramsInfo = paramsInfo.Substring(0, paramsInfo.Length - 2);
                }

                paramsInfo += " )";

                throw new Exception(string.Format("Specified method {0}{1} not found", methodName, paramsInfo));
            }

            object targetObj = Activator.CreateInstance(parentClass, new object[] { });
            object responseObj = method.Invoke(targetObj, parameters);

            return responseObj;
        }

        public static WebRequest CreatePrivateRequest(string uri, string method, string xuid, string body, string contentType)
        {
            WebRequest request = WebRequest.Create(uri);
            request.Headers.Add("X-Xuid", xuid);
            request.ContentType = contentType;
            request.Method = method;

            request.Headers.Add("X-Locale", "en-US");
            request.Headers.Add("X-Platform-Type: 5");

            ((HttpWebRequest)request).ClientCertificates.Add(GetX509Certificate());
            
            if (!string.IsNullOrEmpty(body))
            {
                byte[] buffer = Encoding.ASCII.GetBytes(body);
                request.ContentLength = buffer.Length;
                Stream st = request.GetRequestStream();
                st.Write(buffer, 0, buffer.Length);
                st.Close();
            }

            return request;
        }
        /// <summary>
        /// Constructs a webrequest 
        /// </summary>
        /// <param name="uri">The URL of the site to call</param>
        /// <param name="method">The service method</param>
        /// <param name="authToken">The authorization token</param>
        /// <param name="isPartnerToken">Is the auth token that of a partner or a normal user?</param>
        /// <param name="body">The body of the request</param>
        /// <param name="contentType">The content type</param>
        /// <returns>The webrequest</returns>
        public static WebRequest CreateRequest(string uri, string method, string authToken, bool isPartnerToken, string body, string contentType)
        {
            WebRequest request = WebRequest.Create(uri);
            request.ContentType = contentType;
            request.Method = method;

            if (!string.IsNullOrEmpty(authToken))
            {
                if (isPartnerToken)
                {
                    request.Headers.Add(UserAccount.PartnerAuthHeader, UserAccount.XblHeader + authToken);
                }
                else
                {
                    request.Headers.Add(UserAccount.AuthHeader, UserAccount.XblHeader + authToken);
                }
            }

            request.Headers.Add("X-Locale", "en-US");
            request.Headers.Add("X-Platform-Type: 5");
            
            if (!string.IsNullOrEmpty(body))
            {
                byte[] buffer = Encoding.ASCII.GetBytes(body);
                request.ContentLength = buffer.Length;
                Stream st = request.GetRequestStream();
                st.Write(buffer, 0, buffer.Length);
                st.Close();
            }

            return request;
        }
        /// <summary>
        /// Constructs a webrequest and sends it
        /// </summary>
        /// <param name="uri">The URL of the site to call</param>
        /// <param name="method">The service method</param>
        /// <param name="authToken">The authorization token</param>
        /// <param name="isPartnerToken">Is the auth token that of a partner or a normal user?</param>
        /// <param name="body">The body of the request</param>
        /// <param name="contentType">The content type</param>
        /// <param name="responseString">The responsestream from the webresponse</param>
        /// <returns>The actual response from the method invocation</returns>
        public static WebResponse SendInternalRequest(string uri, string method, string userXuid, bool isPartnerToken, string body, string contentType, out string responseString)
        {
            responseString = string.Empty;

            WebRequest request = HelperLibrary.CreatePrivateRequest(uri, method, userXuid, body, contentType);            
            WebResponse response = HelperLibrary.SendRequest(request, out responseString);

            return response;
        }
        /// <summary>
        /// Get a local x509 certificate
        /// </summary>
        /// <returns>a X509Certificate2 </returns>
        private static X509Certificate2 GetX509Certificate()
        {
            // Retrieve the subject name of the X.509 client certificate
            string certSubject = "int-ids.xbox.com";
            // Use the Local Store
            X509Store store = new X509Store(StoreLocation.LocalMachine);
            // Get certificate by thumbprint
            store.Open(OpenFlags.ReadOnly);
            X509Certificate2Collection collection = store.Certificates.Find(X509FindType.FindBySubjectName, certSubject, false);
            store.Close();
            if (collection.Count == 1)
            {
                // If found, return the certificate
                return collection[0];
            }
            else
            {
                if (collection.Count > 1)
                {
                    // multiple certs found
                    throw new ApplicationException(String.Format("Multiple certs found with subject \"{0}\"", certSubject));
                }
                else
                {
                    // cert not found
                    throw new ApplicationException(String.Format("Certificate with subject \"{0}\" not found found", certSubject));
                }
            }
        }

        /// <summary>
        /// Constructs a webrequest and sends it
        /// </summary>
        /// <param name="uri">The URL of the site to call</param>
        /// <param name="method">The service method</param>
        /// <param name="authToken">The authorization token</param>
        /// <param name="isPartnerToken">Is the auth token that of a partner or a normal user?</param>
        /// <param name="body">The body of the request</param>
        /// <param name="contentType">The content type</param>
        /// <param name="responseString">The responsestream from the webresponse</param>
        /// <returns>The actual response from the method invocation</returns>
        public static WebResponse SendRequest(string uri, string method, string authToken, bool isPartnerToken, string body, string contentType, out string responseString)
        {
            responseString = string.Empty;

            WebRequest request = HelperLibrary.CreateRequest(uri, method, authToken, isPartnerToken, body, contentType);

            WebResponse response = HelperLibrary.SendRequest(request, out responseString);

            return response;
        }

        /// <summary>
        /// Send a web request
        /// </summary>
        /// <param name="request">The request to send</param>
        /// <param name="responseString">The response from the server</param>
        /// <returns>The web response</returns>
        public static WebResponse SendRequest(WebRequest request, out string responseString)
        {
            responseString = string.Empty;
            WebResponse response = null;

            if (request.ContentLength < 0)
            {
                request.ContentLength = 0;
            }
   
            try
            {
                response = request.GetResponse();

                using (StreamReader sr = new StreamReader(response.GetResponseStream()))
                {
                    responseString = sr.ReadToEnd().Trim();
                }
            }
            catch (System.Net.WebException we)
            {
                if (we.Response != null)
                {
                    Stream dataStream = we.Response.GetResponseStream();
                    using (StreamReader reader = new StreamReader(dataStream))
                    {
                        string webExceptionResponse = reader.ReadToEnd();
                        throw new Exception(webExceptionResponse, we);
                    }
                }
                else
                {
                    throw;
                }
            }
            finally
            {
                if (response != null)
                {
                    response.Close();
                }
            }

            return response;
        }

        /// <summary>
        /// This method is to display user's information        
        /// </summary>
        /// <param name="userToken">The user's STS token</param>
        /// <returns>A formatted string describing the user info</returns>
        public static string GetUserInfoString(
            string userToken)
        {
            XblSamlToken samlToken;
            string puidString;
            string xuidString;
            string cidString;
            ulong puid;
            ulong xuid;
            ulong cid;
            string gamerTag;
            string privilege;

            // Get PUID/XUID/GamerTag information from STS token
            samlToken = new XblSamlToken(userToken);
            puidString = samlToken.GetAttributeValue(XblSamlToken.name_attribute_puid0);
            cidString = samlToken.GetAttributeValue(XblSamlToken.name_attribute_cid0);
            puid = Convert.ToUInt64(puidString);
            cid = Convert.ToUInt64(cidString);

            // Get XUID information
            try
            {
                xuidString = samlToken.GetAttributeValue(XblSamlToken.name_attribute_xuid0);
                xuid = Convert.ToUInt64(xuidString);
                gamerTag = samlToken.GetAttributeValue(XblSamlToken.name_attribute_gamertag0);
                privilege = samlToken.GetAttributeValue(XblSamlToken.name_attribute_privileges0);
            }
            catch (Exception)
            {
                xuidString = "0";
                xuid = 0;
                gamerTag = String.Empty;
                privilege = String.Empty;
            }

            // Display user infomration
            string ret = string.Empty;
            ret += "PUID: " + puidString + " " + puid.ToString("X");
            ret += "\n" + "XUID: " + xuidString + " " + xuid.ToString("X");
            ret += "\n" + "CID: " + cidString + " " + cid.ToString("X");
            ret += "\n" + "Gamertag: " + gamerTag;
            ret += "\n" + "Privileges: " + privilege;

            return ret;
        }

        /// <summary>
        /// Method to get the service hostnames from the HelperLibrary's properties
        /// </summary>
        /// <returns>List of service host names</returns>
        public static List<string> GetServiceHostNames()
        {
            List<string> hostNames = new List<string>();

            Type hl = Type.GetType("LIVEnTool.HelperLibrary");
            PropertyInfo[] pis = hl.GetProperties();
            foreach (PropertyInfo pi in pis)
            {
                if (pi.ToString().EndsWith("Url") && pi.GetValue(hl, null).ToString().Contains(".svc"))
                {
                    string uri = (string)pi.GetValue(hl, null);
                    int startIndex = uri.IndexOf("//") + 2;
                    int endIndex = uri.IndexOf("xboxlive.com") + "xboxlive.com".Length;
                    string hostName = uri.Substring(startIndex, endIndex - startIndex);
                    bool match = hostNames.Exists(s => s == hostName);
                    if (!match)
                    {
                        hostNames.Add(hostName);
                    }
                }
            }

            return hostNames;
        }

        /// <summary>
        /// Writing to event logger
        /// </summary>
        /// <param name="message">Message to write to the event log</param>
        /// <param name="type">Type of event log to write to</param>
        public static void WriteToEventLog(string AppName, string message, EventLogEntryType type)
        {
            if (UseEventLog)
            {
                if (!EventLog.SourceExists(AppName))
                {
                    EventLog.CreateEventSource(AppName, "Application");
                }

                EventLog.WriteEntry(AppName, message, type);
            }
        }

        /// <summary>
        /// Method overload to log an exception to event log
        /// </summary>
        /// <param name="e">Exception to log</param>
        /// <returns>Formatted text of the exception message</returns>
        public static string LogException(Exception e)
        {
            return LogException(e, null);
        }

        /// <summary>
        /// Method overload to format and log an exception to event log that includes web response
        /// </summary>
        /// <param name="e">Exception to log</param>
        /// <param name="response">Response from web request</param>
        /// <returns>Formatted text of the exception message</returns>
        public static string LogException(Exception e, string message)
        {
            StringBuilder sb = new StringBuilder();
            sb.AppendLine("----------------------------------------------");
            sb.AppendLine("Exception type: " + e.GetType().ToString());
            sb.AppendLine("Exception message: " + e.Message);
            if (message != null)
            {
                sb.AppendLine(message);
            }

            sb.AppendLine("----------------------------------------------");
            sb.AppendLine("Stack trace: " + e.StackTrace);
            sb.AppendLine("----------------------------------------------");
            if (e.InnerException != null)
            {
                sb.AppendLine("Inner exception: " + e.InnerException.ToString());
            }
            else
            {
                sb.AppendLine("Inner exception: None");
            }

            sb.AppendLine("----------------------------------------------");
            sb.AppendLine("Source: " + e.Source);
            return sb.ToString();
        }

       
        /// <summary>
        /// String splitter utility
        /// </summary>
        /// <typeparam name="T">Generic type</typeparam>
        /// <param name="delimitedString">String to delimit</param>
        /// <param name="delimiter">Delimiter</param>
        /// <returns>Resulting string</returns>
        public static T[] StringSplitter<T>(string delimitedString, char delimiter)
        {
            string[] splitString = delimitedString.Split(new char[] { delimiter });

            T[] ret = new T[splitString.Length];
            for (int i = 0; i < splitString.Length; i++)
            {
                ret[i] = (T)Convert.ChangeType(splitString[i], typeof(T));             
            }
            return ret;
        }

        public static byte[] StringToByteArray(string data)
        {
            System.Text.ASCIIEncoding encoding = new System.Text.ASCIIEncoding();
            return encoding.GetBytes(data);
        }

        /// <summary>
        /// Loading configuration parameters from App.config
        /// </summary>
        /// <param name="environment">The target environment</param>
        public static void LoadConfiguration(string environment)
        {
            LoadConfiguration(environment, null, 0);
        }

        /// <summary>
        /// Loading configuration parameters from App.config method overload
        /// </summary>
        /// <param name="environment">The target environment</param>
        /// <param name="endpoint">The service's endpoint to access by the currently running test</param>
        /// <param name="port">The port number assigned to the endpoint of the currently running test</param>
        public static void LoadConfiguration(string environment, string endpoint, int port)
        {
            // Retrieve environment independent configurations
            PlatformId = ConfigurationManager.AppSettings["PlatformId"];
            ClientVersion = ConfigurationManager.AppSettings["ClientVersion"];
            CertPath = ConfigurationManager.AppSettings["CertPath"];
            CertInstaller = ConfigurationManager.AppSettings["CertInstaller"];
            CountryId = Convert.ToByte(ConfigurationManager.AppSettings["CountryId"]);
            LanguageId = Convert.ToUInt16(ConfigurationManager.AppSettings["LanguageId"]);
            TestAvatarManifest = ConfigurationManager.AppSettings["TestAvatarManifest"];
            MultiplayerAudienceUri = ConfigurationManager.AppSettings["MultiplayerAudienceUri"];
            AvatarAudienceUri = ConfigurationManager.AppSettings["AvatarAudienceUri"];
            UserDataAudienceUri = ConfigurationManager.AppSettings["UserDataAudienceUri"];

            // Retrieve environment dependent configurations
            TitleId = ConfigurationManager.AppSettings[environment.ToUpper() + "-TitleId"];
            TitleVersion = ConfigurationManager.AppSettings[environment.ToUpper() + "-TitleVersion"];
            DeviceId = ConfigurationManager.AppSettings[environment.ToUpper() + "-DeviceId"];

            // Retrieve service URLs
            LiveIDServiceTarget = ConfigurationManager.AppSettings[environment.ToUpper() + "-LiveIDServiceTarget"];
            StsUrl = ConfigurationManager.AppSettings[environment.ToUpper() + "-StsUrl"];
            XuacsUrl = ConfigurationManager.AppSettings[environment.ToUpper() + "-XuacsUrl"];

            GetProfileUrl = ReplaceDnsNameWithLocalhostAndPortForMatchingEndpoint(environment, endpoint, port, "GetProfileUrl");
            GetLeaderboardUrl = ReplaceDnsNameWithLocalhostAndPortForMatchingEndpoint(environment, endpoint, port, "GetLeaderboardUrl");
            GetAchievementsUrl = ReplaceDnsNameWithLocalhostAndPortForMatchingEndpoint(environment, endpoint, port, "GetAchievementsUrl");
            GetDatablobUrl = ReplaceDnsNameWithLocalhostAndPortForMatchingEndpoint(environment, endpoint, port, "GetDatablobUrl");
            NotificationServiceUrl = ReplaceDnsNameWithLocalhostAndPortForMatchingEndpoint(environment, endpoint, port, "NotificationsServiceUrl");
            NotificationPrivateServiceUrl = ReplaceDnsNameWithLocalhostAndPortForMatchingEndpoint(environment, endpoint, port, "NotificationsPrivateServiceUrl");
            SessionServiceUrl = ReplaceDnsNameWithLocalhostAndPortForMatchingEndpoint(environment, endpoint, port, "SessionServiceUrl");
            PartnerServiceUrl = ReplaceDnsNameWithLocalhostAndPortForMatchingEndpoint(environment, endpoint, port, "PartnerServiceUrl");
            RewardServiceUrl = ReplaceDnsNameWithLocalhostAndPortForMatchingEndpoint(environment, endpoint, port, "RewardServiceUrl");
            ManifestReadPartnerUrl = ReplaceDnsNameWithLocalhostAndPortForMatchingEndpoint(environment, endpoint, port, "ManifestReadPartnerUrl");
            ManifestUpdatePartUrl = ReplaceDnsNameWithLocalhostAndPortForMatchingEndpoint(environment, endpoint, port, "ManifestUpdatePartUrl");
            GamerPicUpdatePartUrl = ReplaceDnsNameWithLocalhostAndPortForMatchingEndpoint(environment, endpoint, port, "GamerPicUpdatePartUrl");
            GameStateServiceUrl = ReplaceDnsNameWithLocalhostAndPortForMatchingEndpoint(environment, endpoint, port, "GameStateServiceUrl");
            GameMetadataServiceUrl = ReplaceDnsNameWithLocalhostAndPortForMatchingEndpoint(environment, endpoint, port, "GameMetadataServiceUrl");
            GameDataPartnerServiceUrl = ReplaceDnsNameWithLocalhostAndPortForMatchingEndpoint(environment, endpoint, port, "GameDataPartnerServiceUrl");
            FriendPartnerServiceUrl = ReplaceDnsNameWithLocalhostAndPortForMatchingEndpoint(environment, endpoint, port, "FriendPartnerServiceUrl");
            MessagePartnerServiceUrl = ReplaceDnsNameWithLocalhostAndPortForMatchingEndpoint(environment, endpoint, port, "MessagePartnerServiceUrl");
            ProfilePartnerServiceUrl = ReplaceDnsNameWithLocalhostAndPortForMatchingEndpoint(environment, endpoint, port, "ProfilePartnerServiceUrl");
            PresencePartnerServiceUrl = ReplaceDnsNameWithLocalhostAndPortForMatchingEndpoint(environment, endpoint, port, "PresencePartnerServiceUrl");
            GetClosetAssetPartUrl = ReplaceDnsNameWithLocalhostAndPortForMatchingEndpoint(environment, endpoint, port, "GetClosetAssetPartUrl");

            bool accountIsProduction = false;
            bool.TryParse(ConfigurationManager.AppSettings[environment.ToUpper() + "-IsProduction"], out accountIsProduction);
            AccountIsProduction = accountIsProduction;
            ClientCertThumbprint = ConfigurationManager.AppSettings[environment.ToUpper() + "-ClientCertThumbPrint"];

            if (string.IsNullOrEmpty(LiveIDServiceTarget))
            {
                LiveIDServiceTarget = DefaultLiveIDServiceTarget;
            }
        }

        /// <summary>
        /// Get cache token parameters
        /// </summary>
        public static void GetCacheTokenParams()
        {
            // STS token filepath and lifetime
            CacheStsToken = ConfigurationManager.AppSettings["TokenCacheOption"] == "Yes" ? true : false;
            StsTokenFilepath = ConfigurationManager.AppSettings["TokenFilepath"];
            StsTokenLifetime = ConfigurationManager.AppSettings["TokenLifetime"];
        }

        /// <summary>
        /// Get option to log trace to EventLog
        /// </summary>
        public static void GetEventLogOption()
        {
            UseEventLog = ConfigurationManager.AppSettings["UseEventLog"] == "Yes" ? true : false;
        }

        /// <summary>
        /// Read the URL value from App.config and replace the DNS name of the service endpoint with "localhost:port#" 
        /// when the testEndpoint matches the appConfigEndpoint. This is done for application that runs in the data
        /// center when no DNS server is available to resolve the DNS name.  Application tool is deployed in the same
        /// box as the server that hosts the services.  When a test is run, the application passes the testEndpoint
        /// that corresponds to the service endpoint being tested.
        /// 
        /// If the testEndpoint is empty and the port is 0, the code simply reads and returns the URL value from the
        /// App.config.
        /// </summary>
        /// <param name="environment">The target environment</param>
        /// <param name="testEndpoint">The service endpoint to be accessed by the currently running test</param>
        /// <param name="port">The port number in the server that corresponds to the service endpoint</param>
        /// <param name="appConfigEndpoint">The service endpoint read from the App.config</param>
        /// <returns>The resulting URL</returns>
        private static string ReplaceDnsNameWithLocalhostAndPortForMatchingEndpoint(string environment, string testEndpoint, int port, string appConfigEndpoint)
        {
            string url = ConfigurationManager.AppSettings[environment.ToUpper() + "-" + appConfigEndpoint];

            if (!string.IsNullOrEmpty(testEndpoint) && port != 0)
            {
                if (testEndpoint.ToLowerInvariant() == appConfigEndpoint.ToLowerInvariant())
                {
                    string tmp = url;
                    int startIndex = tmp.IndexOf("//") + 2;
                    int endIndex = tmp.IndexOf("xboxlive.com") + "xboxlive.com".Length;
                    string hostName = tmp.Substring(startIndex, endIndex - startIndex);
                    url = tmp.Replace(hostName, "localhost:" + port.ToString());
                }
            }

            return url;
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LIVEnAuthClient\LIVEnAuthClient\useraccountproxy.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.3038.
// 
namespace LIVEnAuthClient {
    using System.Xml.Serialization;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Diagnostics;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="UserAccountSoap", Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class UserAccount : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback AcceptTermsOfServiceOperationCompleted;
        
        private System.Threading.SendOrPostCallback AddCreditCardOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetPointsBalanceOperationCompleted;
        
        private System.Threading.SendOrPostCallback SignInOperationCompleted;
        
        private System.Threading.SendOrPostCallback CreateMobileAccountOperationCompleted;
        
        private System.Threading.SendOrPostCallback GenerateGamertagOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetPaymentInstrumentsOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetSupportedCountriesOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetUserAuthorizationOperationCompleted;
        
        private System.Threading.SendOrPostCallback TestConnectionOperationCompleted;
        
        /// <remarks/>
        public UserAccount() {
            this.Url = "http://localhost:10050/xuacs/useraccount.asmx";
        }
        
        /// <remarks/>
        public event AcceptTermsOfServiceCompletedEventHandler AcceptTermsOfServiceCompleted;
        
        /// <remarks/>
        public event AddCreditCardCompletedEventHandler AddCreditCardCompleted;
        
        /// <remarks/>
        public event GetPointsBalanceCompletedEventHandler GetPointsBalanceCompleted;
        
        /// <remarks/>
        public event SignInCompletedEventHandler SignInCompleted;
        
        /// <remarks/>
        public event CreateMobileAccountCompletedEventHandler CreateMobileAccountCompleted;
        
        /// <remarks/>
        public event GenerateGamertagCompletedEventHandler GenerateGamertagCompleted;
        
        /// <remarks/>
        public event GetPaymentInstrumentsCompletedEventHandler GetPaymentInstrumentsCompleted;
        
        /// <remarks/>
        public event GetSupportedCountriesCompletedEventHandler GetSupportedCountriesCompleted;
        
        /// <remarks/>
        public event GetUserAuthorizationCompletedEventHandler GetUserAuthorizationCompleted;
        
        /// <remarks/>
        public event TestConnectionCompletedEventHandler TestConnectionCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/AcceptTermsOfService", RequestNamespace="urn:schemas-xbox-com:user-account-data", ResponseNamespace="urn:schemas-xbox-com:user-account-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public uint AcceptTermsOfService(ulong userPuid, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] signedOwnerPassportPuid, ServiceTypeEnum serviceType) {
            object[] results = this.Invoke("AcceptTermsOfService", new object[] {
                        userPuid,
                        signedOwnerPassportPuid,
                        serviceType});
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAcceptTermsOfService(ulong userPuid, byte[] signedOwnerPassportPuid, ServiceTypeEnum serviceType, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AcceptTermsOfService", new object[] {
                        userPuid,
                        signedOwnerPassportPuid,
                        serviceType}, callback, asyncState);
        }
        
        /// <remarks/>
        public uint EndAcceptTermsOfService(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public void AcceptTermsOfServiceAsync(ulong userPuid, byte[] signedOwnerPassportPuid, ServiceTypeEnum serviceType) {
            this.AcceptTermsOfServiceAsync(userPuid, signedOwnerPassportPuid, serviceType, null);
        }
        
        /// <remarks/>
        public void AcceptTermsOfServiceAsync(ulong userPuid, byte[] signedOwnerPassportPuid, ServiceTypeEnum serviceType, object userState) {
            if ((this.AcceptTermsOfServiceOperationCompleted == null)) {
                this.AcceptTermsOfServiceOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAcceptTermsOfServiceOperationCompleted);
            }
            this.InvokeAsync("AcceptTermsOfService", new object[] {
                        userPuid,
                        signedOwnerPassportPuid,
                        serviceType}, this.AcceptTermsOfServiceOperationCompleted, userState);
        }
        
        private void OnAcceptTermsOfServiceOperationCompleted(object arg) {
            if ((this.AcceptTermsOfServiceCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AcceptTermsOfServiceCompleted(this, new AcceptTermsOfServiceCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/AddCreditCard", RequestNamespace="urn:schemas-xbox-com:user-account-data", ResponseNamespace="urn:schemas-xbox-com:user-account-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public AddCreditCardResults AddCreditCard(
                    ulong userPuid, 
                    ulong machinePuid, 
                    string addressStreet1, 
                    string addressStreet2, 
                    string addressCity, 
                    string addressDistrict, 
                    string addressState, 
                    string addressPostalCode, 
                    string phonePrefix, 
                    string phoneNumber, 
                    string phoneExtension, 
                    byte cardType, 
                    string accountHolderName, 
                    string accountNumber, 
                    string cardVerificationNumber, 
                    string expirationDate) {
            object[] results = this.Invoke("AddCreditCard", new object[] {
                        userPuid,
                        machinePuid,
                        addressStreet1,
                        addressStreet2,
                        addressCity,
                        addressDistrict,
                        addressState,
                        addressPostalCode,
                        phonePrefix,
                        phoneNumber,
                        phoneExtension,
                        cardType,
                        accountHolderName,
                        accountNumber,
                        cardVerificationNumber,
                        expirationDate});
            return ((AddCreditCardResults)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAddCreditCard(
                    ulong userPuid, 
                    ulong machinePuid, 
                    string addressStreet1, 
                    string addressStreet2, 
                    string addressCity, 
                    string addressDistrict, 
                    string addressState, 
                    string addressPostalCode, 
                    string phonePrefix, 
                    string phoneNumber, 
                    string phoneExtension, 
                    byte cardType, 
                    string accountHolderName, 
                    string accountNumber, 
                    string cardVerificationNumber, 
                    string expirationDate, 
                    System.AsyncCallback callback, 
                    object asyncState) {
            return this.BeginInvoke("AddCreditCard", new object[] {
                        userPuid,
                        machinePuid,
                        addressStreet1,
                        addressStreet2,
                        addressCity,
                        addressDistrict,
                        addressState,
                        addressPostalCode,
                        phonePrefix,
                        phoneNumber,
                        phoneExtension,
                        cardType,
                        accountHolderName,
                        accountNumber,
                        cardVerificationNumber,
                        expirationDate}, callback, asyncState);
        }
        
        /// <remarks/>
        public AddCreditCardResults EndAddCreditCard(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((AddCreditCardResults)(results[0]));
        }
        
        /// <remarks/>
        public void AddCreditCardAsync(
                    ulong userPuid, 
                    ulong machinePuid, 
                    string addressStreet1, 
                    string addressStreet2, 
                    string addressCity, 
                    string addressDistrict, 
                    string addressState, 
                    string addressPostalCode, 
                    string phonePrefix, 
                    string phoneNumber, 
                    string phoneExtension, 
                    byte cardType, 
                    string accountHolderName, 
                    string accountNumber, 
                    string cardVerificationNumber, 
                    string expirationDate) {
            this.AddCreditCardAsync(userPuid, machinePuid, addressStreet1, addressStreet2, addressCity, addressDistrict, addressState, addressPostalCode, phonePrefix, phoneNumber, phoneExtension, cardType, accountHolderName, accountNumber, cardVerificationNumber, expirationDate, null);
        }
        
        /// <remarks/>
        public void AddCreditCardAsync(
                    ulong userPuid, 
                    ulong machinePuid, 
                    string addressStreet1, 
                    string addressStreet2, 
                    string addressCity, 
                    string addressDistrict, 
                    string addressState, 
                    string addressPostalCode, 
                    string phonePrefix, 
                    string phoneNumber, 
                    string phoneExtension, 
                    byte cardType, 
                    string accountHolderName, 
                    string accountNumber, 
                    string cardVerificationNumber, 
                    string expirationDate, 
                    object userState) {
            if ((this.AddCreditCardOperationCompleted == null)) {
                this.AddCreditCardOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAddCreditCardOperationCompleted);
            }
            this.InvokeAsync("AddCreditCard", new object[] {
                        userPuid,
                        machinePuid,
                        addressStreet1,
                        addressStreet2,
                        addressCity,
                        addressDistrict,
                        addressState,
                        addressPostalCode,
                        phonePrefix,
                        phoneNumber,
                        phoneExtension,
                        cardType,
                        accountHolderName,
                        accountNumber,
                        cardVerificationNumber,
                        expirationDate}, this.AddCreditCardOperationCompleted, userState);
        }
        
        private void OnAddCreditCardOperationCompleted(object arg) {
            if ((this.AddCreditCardCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AddCreditCardCompleted(this, new AddCreditCardCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/GetPointsBalance", RequestNamespace="urn:schemas-xbox-com:user-account-data", ResponseNamespace="urn:schemas-xbox-com:user-account-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public GetPointsBalanceResults GetPointsBalance(ulong userPuid) {
            object[] results = this.Invoke("GetPointsBalance", new object[] {
                        userPuid});
            return ((GetPointsBalanceResults)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetPointsBalance(ulong userPuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetPointsBalance", new object[] {
                        userPuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public GetPointsBalanceResults EndGetPointsBalance(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((GetPointsBalanceResults)(results[0]));
        }
        
        /// <remarks/>
        public void GetPointsBalanceAsync(ulong userPuid) {
            this.GetPointsBalanceAsync(userPuid, null);
        }
        
        /// <remarks/>
        public void GetPointsBalanceAsync(ulong userPuid, object userState) {
            if ((this.GetPointsBalanceOperationCompleted == null)) {
                this.GetPointsBalanceOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetPointsBalanceOperationCompleted);
            }
            this.InvokeAsync("GetPointsBalance", new object[] {
                        userPuid}, this.GetPointsBalanceOperationCompleted, userState);
        }
        
        private void OnGetPointsBalanceOperationCompleted(object arg) {
            if ((this.GetPointsBalanceCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetPointsBalanceCompleted(this, new GetPointsBalanceCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/SignIn", RequestNamespace="urn:schemas-xbox-com:user-account-data", ResponseNamespace="urn:schemas-xbox-com:user-account-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public SignInResults SignIn() {
            object[] results = this.Invoke("SignIn", new object[0]);
            return ((SignInResults)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSignIn(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SignIn", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public SignInResults EndSignIn(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((SignInResults)(results[0]));
        }
        
        /// <remarks/>
        public void SignInAsync() {
            this.SignInAsync(null);
        }
        
        /// <remarks/>
        public void SignInAsync(object userState) {
            if ((this.SignInOperationCompleted == null)) {
                this.SignInOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSignInOperationCompleted);
            }
            this.InvokeAsync("SignIn", new object[0], this.SignInOperationCompleted, userState);
        }
        
        private void OnSignInOperationCompleted(object arg) {
            if ((this.SignInCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SignInCompleted(this, new SignInCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/CreateMobileAccount", RequestNamespace="urn:schemas-xbox-com:user-account-data", ResponseNamespace="urn:schemas-xbox-com:user-account-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public uint CreateMobileAccount(ulong userPuid, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] ownerPassportTicket, ulong machinePuid, string gamertag, byte countryId, ushort languageId, System.DateTime birthDate) {
            object[] results = this.Invoke("CreateMobileAccount", new object[] {
                        userPuid,
                        ownerPassportTicket,
                        machinePuid,
                        gamertag,
                        countryId,
                        languageId,
                        birthDate});
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCreateMobileAccount(ulong userPuid, byte[] ownerPassportTicket, ulong machinePuid, string gamertag, byte countryId, ushort languageId, System.DateTime birthDate, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CreateMobileAccount", new object[] {
                        userPuid,
                        ownerPassportTicket,
                        machinePuid,
                        gamertag,
                        countryId,
                        languageId,
                        birthDate}, callback, asyncState);
        }
        
        /// <remarks/>
        public uint EndCreateMobileAccount(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public void CreateMobileAccountAsync(ulong userPuid, byte[] ownerPassportTicket, ulong machinePuid, string gamertag, byte countryId, ushort languageId, System.DateTime birthDate) {
            this.CreateMobileAccountAsync(userPuid, ownerPassportTicket, machinePuid, gamertag, countryId, languageId, birthDate, null);
        }
        
        /// <remarks/>
        public void CreateMobileAccountAsync(ulong userPuid, byte[] ownerPassportTicket, ulong machinePuid, string gamertag, byte countryId, ushort languageId, System.DateTime birthDate, object userState) {
            if ((this.CreateMobileAccountOperationCompleted == null)) {
                this.CreateMobileAccountOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCreateMobileAccountOperationCompleted);
            }
            this.InvokeAsync("CreateMobileAccount", new object[] {
                        userPuid,
                        ownerPassportTicket,
                        machinePuid,
                        gamertag,
                        countryId,
                        languageId,
                        birthDate}, this.CreateMobileAccountOperationCompleted, userState);
        }
        
        private void OnCreateMobileAccountOperationCompleted(object arg) {
            if ((this.CreateMobileAccountCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CreateMobileAccountCompleted(this, new CreateMobileAccountCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/GenerateGamertag", RequestNamespace="urn:schemas-xbox-com:user-account-data", ResponseNamespace="urn:schemas-xbox-com:user-account-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string GenerateGamertag(string seed, ulong machinePuid, GamertagSuggestionType gamertagSuggestionType) {
            object[] results = this.Invoke("GenerateGamertag", new object[] {
                        seed,
                        machinePuid,
                        gamertagSuggestionType});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGenerateGamertag(string seed, ulong machinePuid, GamertagSuggestionType gamertagSuggestionType, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GenerateGamertag", new object[] {
                        seed,
                        machinePuid,
                        gamertagSuggestionType}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndGenerateGamertag(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void GenerateGamertagAsync(string seed, ulong machinePuid, GamertagSuggestionType gamertagSuggestionType) {
            this.GenerateGamertagAsync(seed, machinePuid, gamertagSuggestionType, null);
        }
        
        /// <remarks/>
        public void GenerateGamertagAsync(string seed, ulong machinePuid, GamertagSuggestionType gamertagSuggestionType, object userState) {
            if ((this.GenerateGamertagOperationCompleted == null)) {
                this.GenerateGamertagOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGenerateGamertagOperationCompleted);
            }
            this.InvokeAsync("GenerateGamertag", new object[] {
                        seed,
                        machinePuid,
                        gamertagSuggestionType}, this.GenerateGamertagOperationCompleted, userState);
        }
        
        private void OnGenerateGamertagOperationCompleted(object arg) {
            if ((this.GenerateGamertagCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GenerateGamertagCompleted(this, new GenerateGamertagCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/GetPaymentInstruments", RequestNamespace="urn:schemas-xbox-com:user-account-data", ResponseNamespace="urn:schemas-xbox-com:user-account-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public GetPaymentInstrumentResults GetPaymentInstruments(ulong userPuid, ulong machinePuid) {
            object[] results = this.Invoke("GetPaymentInstruments", new object[] {
                        userPuid,
                        machinePuid});
            return ((GetPaymentInstrumentResults)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetPaymentInstruments(ulong userPuid, ulong machinePuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetPaymentInstruments", new object[] {
                        userPuid,
                        machinePuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public GetPaymentInstrumentResults EndGetPaymentInstruments(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((GetPaymentInstrumentResults)(results[0]));
        }
        
        /// <remarks/>
        public void GetPaymentInstrumentsAsync(ulong userPuid, ulong machinePuid) {
            this.GetPaymentInstrumentsAsync(userPuid, machinePuid, null);
        }
        
        /// <remarks/>
        public void GetPaymentInstrumentsAsync(ulong userPuid, ulong machinePuid, object userState) {
            if ((this.GetPaymentInstrumentsOperationCompleted == null)) {
                this.GetPaymentInstrumentsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetPaymentInstrumentsOperationCompleted);
            }
            this.InvokeAsync("GetPaymentInstruments", new object[] {
                        userPuid,
                        machinePuid}, this.GetPaymentInstrumentsOperationCompleted, userState);
        }
        
        private void OnGetPaymentInstrumentsOperationCompleted(object arg) {
            if ((this.GetPaymentInstrumentsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetPaymentInstrumentsCompleted(this, new GetPaymentInstrumentsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/GetSupportedCountries", RequestNamespace="urn:schemas-xbox-com:user-account-data", ResponseNamespace="urn:schemas-xbox-com:user-account-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public CountryInfo[] GetSupportedCountries(byte serviceType, byte clientType) {
            object[] results = this.Invoke("GetSupportedCountries", new object[] {
                        serviceType,
                        clientType});
            return ((CountryInfo[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetSupportedCountries(byte serviceType, byte clientType, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetSupportedCountries", new object[] {
                        serviceType,
                        clientType}, callback, asyncState);
        }
        
        /// <remarks/>
        public CountryInfo[] EndGetSupportedCountries(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((CountryInfo[])(results[0]));
        }
        
        /// <remarks/>
        public void GetSupportedCountriesAsync(byte serviceType, byte clientType) {
            this.GetSupportedCountriesAsync(serviceType, clientType, null);
        }
        
        /// <remarks/>
        public void GetSupportedCountriesAsync(byte serviceType, byte clientType, object userState) {
            if ((this.GetSupportedCountriesOperationCompleted == null)) {
                this.GetSupportedCountriesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetSupportedCountriesOperationCompleted);
            }
            this.InvokeAsync("GetSupportedCountries", new object[] {
                        serviceType,
                        clientType}, this.GetSupportedCountriesOperationCompleted, userState);
        }
        
        private void OnGetSupportedCountriesOperationCompleted(object arg) {
            if ((this.GetSupportedCountriesCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetSupportedCountriesCompleted(this, new GetSupportedCountriesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/GetUserAuthorization", RequestNamespace="urn:schemas-xbox-com:user-account-data", ResponseNamespace="urn:schemas-xbox-com:user-account-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("GetUserAuthorizationInfo", IsNullable=true)]
        public GetUserAuthorizationInfo GetUserAuthorization(int serviceType, uint titleId) {
            object[] results = this.Invoke("GetUserAuthorization", new object[] {
                        serviceType,
                        titleId});
            return ((GetUserAuthorizationInfo)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetUserAuthorization(int serviceType, uint titleId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetUserAuthorization", new object[] {
                        serviceType,
                        titleId}, callback, asyncState);
        }
        
        /// <remarks/>
        public GetUserAuthorizationInfo EndGetUserAuthorization(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((GetUserAuthorizationInfo)(results[0]));
        }
        
        /// <remarks/>
        public void GetUserAuthorizationAsync(int serviceType, uint titleId) {
            this.GetUserAuthorizationAsync(serviceType, titleId, null);
        }
        
        /// <remarks/>
        public void GetUserAuthorizationAsync(int serviceType, uint titleId, object userState) {
            if ((this.GetUserAuthorizationOperationCompleted == null)) {
                this.GetUserAuthorizationOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetUserAuthorizationOperationCompleted);
            }
            this.InvokeAsync("GetUserAuthorization", new object[] {
                        serviceType,
                        titleId}, this.GetUserAuthorizationOperationCompleted, userState);
        }
        
        private void OnGetUserAuthorizationOperationCompleted(object arg) {
            if ((this.GetUserAuthorizationCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetUserAuthorizationCompleted(this, new GetUserAuthorizationCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/TestConnection", RequestNamespace="urn:schemas-xbox-com:user-account-data", ResponseNamespace="urn:schemas-xbox-com:user-account-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string TestConnection(string inputMessage) {
            object[] results = this.Invoke("TestConnection", new object[] {
                        inputMessage});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginTestConnection(string inputMessage, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("TestConnection", new object[] {
                        inputMessage}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndTestConnection(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void TestConnectionAsync(string inputMessage) {
            this.TestConnectionAsync(inputMessage, null);
        }
        
        /// <remarks/>
        public void TestConnectionAsync(string inputMessage, object userState) {
            if ((this.TestConnectionOperationCompleted == null)) {
                this.TestConnectionOperationCompleted = new System.Threading.SendOrPostCallback(this.OnTestConnectionOperationCompleted);
            }
            this.InvokeAsync("TestConnection", new object[] {
                        inputMessage}, this.TestConnectionOperationCompleted, userState);
        }
        
        private void OnTestConnectionOperationCompleted(object arg) {
            if ((this.TestConnectionCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.TestConnectionCompleted(this, new TestConnectionCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public enum ServiceTypeEnum {
        
        /// <remarks/>
        Unknown,
        
        /// <remarks/>
        XboxLive,
        
        /// <remarks/>
        Zune,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class AddCreditCardResults {
        
        private string paymentInstrumentIdField;
        
        /// <remarks/>
        public string PaymentInstrumentId {
            get {
                return this.paymentInstrumentIdField;
            }
            set {
                this.paymentInstrumentIdField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class SessionInfo {
        
        private string musicNetAuthTokenField;
        
        private string geoCountryCodeField;
        
        /// <remarks/>
        public string MusicNetAuthToken {
            get {
                return this.musicNetAuthTokenField;
            }
            set {
                this.musicNetAuthTokenField = value;
            }
        }
        
        /// <remarks/>
        public string GeoCountryCode {
            get {
                return this.geoCountryCodeField;
            }
            set {
                this.geoCountryCodeField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class SubscriptionInfo {
        
        private ulong offerIdField;
        
        private string billingInstanceIdField;
        
        private string statusField;
        
        private bool hasBillingViolationField;
        
        private bool hasPendingCancelField;
        
        private bool hasLapsedField;
        
        private System.DateTime startDateField;
        
        private System.DateTime endDateField;
        
        private string renewalOfferIdField;
        
        /// <remarks/>
        public ulong OfferId {
            get {
                return this.offerIdField;
            }
            set {
                this.offerIdField = value;
            }
        }
        
        /// <remarks/>
        public string BillingInstanceId {
            get {
                return this.billingInstanceIdField;
            }
            set {
                this.billingInstanceIdField = value;
            }
        }
        
        /// <remarks/>
        public string Status {
            get {
                return this.statusField;
            }
            set {
                this.statusField = value;
            }
        }
        
        /// <remarks/>
        public bool HasBillingViolation {
            get {
                return this.hasBillingViolationField;
            }
            set {
                this.hasBillingViolationField = value;
            }
        }
        
        /// <remarks/>
        public bool HasPendingCancel {
            get {
                return this.hasPendingCancelField;
            }
            set {
                this.hasPendingCancelField = value;
            }
        }
        
        /// <remarks/>
        public bool HasLapsed {
            get {
                return this.hasLapsedField;
            }
            set {
                this.hasLapsedField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime StartDate {
            get {
                return this.startDateField;
            }
            set {
                this.startDateField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime EndDate {
            get {
                return this.endDateField;
            }
            set {
                this.endDateField = value;
            }
        }
        
        /// <remarks/>
        public string RenewalOfferId {
            get {
                return this.renewalOfferIdField;
            }
            set {
                this.renewalOfferIdField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class AccountInfo {
        
        private ulong xboxPuidField;
        
        private ulong livePuidField;
        
        private string tagField;
        
        private string countryCodeField;
        
        private string postalCodeField;
        
        private bool parentallyControlledField;
        
        private byte[] privilegesField;
        
        private uint[] servicesField;
        
        private uint pointsBalanceField;
        
        private bool isLightweightField;
        
        private uint cultureIdField;
        
        private uint parentalControlGroupIdField;
        
        /// <remarks/>
        public ulong XboxPuid {
            get {
                return this.xboxPuidField;
            }
            set {
                this.xboxPuidField = value;
            }
        }
        
        /// <remarks/>
        public ulong LivePuid {
            get {
                return this.livePuidField;
            }
            set {
                this.livePuidField = value;
            }
        }
        
        /// <remarks/>
        public string Tag {
            get {
                return this.tagField;
            }
            set {
                this.tagField = value;
            }
        }
        
        /// <remarks/>
        public string CountryCode {
            get {
                return this.countryCodeField;
            }
            set {
                this.countryCodeField = value;
            }
        }
        
        /// <remarks/>
        public string PostalCode {
            get {
                return this.postalCodeField;
            }
            set {
                this.postalCodeField = value;
            }
        }
        
        /// <remarks/>
        public bool ParentallyControlled {
            get {
                return this.parentallyControlledField;
            }
            set {
                this.parentallyControlledField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayAttribute()]
        [System.Xml.Serialization.XmlArrayItemAttribute("Privilege", IsNullable=false)]
        public byte[] Privileges {
            get {
                return this.privilegesField;
            }
            set {
                this.privilegesField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute("Service", IsNullable=false)]
        public uint[] Services {
            get {
                return this.servicesField;
            }
            set {
                this.servicesField = value;
            }
        }
        
        /// <remarks/>
        public uint PointsBalance {
            get {
                return this.pointsBalanceField;
            }
            set {
                this.pointsBalanceField = value;
            }
        }
        
        /// <remarks/>
        public bool IsLightweight {
            get {
                return this.isLightweightField;
            }
            set {
                this.isLightweightField = value;
            }
        }
        
        /// <remarks/>
        public uint CultureId {
            get {
                return this.cultureIdField;
            }
            set {
                this.cultureIdField = value;
            }
        }
        
        /// <remarks/>
        public uint ParentalControlGroupId {
            get {
                return this.parentalControlGroupIdField;
            }
            set {
                this.parentalControlGroupIdField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class ErrorInfo {
        
        private uint hResultField;
        
        private string messageField;
        
        private bool tagChangeRequiredField;
        
        private bool acceptedTermsOfServiceField;
        
        private bool accountSuspendedField;
        
        private bool billingUnavailableField;
        
        /// <remarks/>
        public uint HResult {
            get {
                return this.hResultField;
            }
            set {
                this.hResultField = value;
            }
        }
        
        /// <remarks/>
        public string Message {
            get {
                return this.messageField;
            }
            set {
                this.messageField = value;
            }
        }
        
        /// <remarks/>
        public bool TagChangeRequired {
            get {
                return this.tagChangeRequiredField;
            }
            set {
                this.tagChangeRequiredField = value;
            }
        }
        
        /// <remarks/>
        public bool AcceptedTermsOfService {
            get {
                return this.acceptedTermsOfServiceField;
            }
            set {
                this.acceptedTermsOfServiceField = value;
            }
        }
        
        /// <remarks/>
        public bool AccountSuspended {
            get {
                return this.accountSuspendedField;
            }
            set {
                this.accountSuspendedField = value;
            }
        }
        
        /// <remarks/>
        public bool BillingUnavailable {
            get {
                return this.billingUnavailableField;
            }
            set {
                this.billingUnavailableField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class GetUserAuthorizationInfo {
        
        private ErrorInfo errorInfoField;
        
        private AccountInfo accountInfoField;
        
        private SubscriptionInfo[] subscriptionInfoField;
        
        private SessionInfo sessionInfoField;
        
        /// <remarks/>
        public ErrorInfo ErrorInfo {
            get {
                return this.errorInfoField;
            }
            set {
                this.errorInfoField = value;
            }
        }
        
        /// <remarks/>
        public AccountInfo AccountInfo {
            get {
                return this.accountInfoField;
            }
            set {
                this.accountInfoField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute("Subscription")]
        public SubscriptionInfo[] SubscriptionInfo {
            get {
                return this.subscriptionInfoField;
            }
            set {
                this.subscriptionInfoField = value;
            }
        }
        
        /// <remarks/>
        public SessionInfo SessionInfo {
            get {
                return this.sessionInfoField;
            }
            set {
                this.sessionInfoField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class CountryInfo {
        
        private byte countryIdField;
        
        private string countryCodeField;
        
        private byte userField;
        
        private byte billingField;
        
        private bool allowDirectDebitField;
        
        private bool allowPayPalField;
        
        private bool requireCCAgeVerificationField;
        
        /// <remarks/>
        public byte CountryId {
            get {
                return this.countryIdField;
            }
            set {
                this.countryIdField = value;
            }
        }
        
        /// <remarks/>
        public string CountryCode {
            get {
                return this.countryCodeField;
            }
            set {
                this.countryCodeField = value;
            }
        }
        
        /// <remarks/>
        public byte User {
            get {
                return this.userField;
            }
            set {
                this.userField = value;
            }
        }
        
        /// <remarks/>
        public byte Billing {
            get {
                return this.billingField;
            }
            set {
                this.billingField = value;
            }
        }
        
        /// <remarks/>
        public bool AllowDirectDebit {
            get {
                return this.allowDirectDebitField;
            }
            set {
                this.allowDirectDebitField = value;
            }
        }
        
        /// <remarks/>
        public bool AllowPayPal {
            get {
                return this.allowPayPalField;
            }
            set {
                this.allowPayPalField = value;
            }
        }
        
        /// <remarks/>
        public bool RequireCCAgeVerification {
            get {
                return this.requireCCAgeVerificationField;
            }
            set {
                this.requireCCAgeVerificationField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class BillingAgreementDetails {
        
        private string payerEmailField;
        
        private string billingAgreementIdField;
        
        private string firstNameField;
        
        private string lastNameField;
        
        private string middleNameField;
        
        private string payerBusinessField;
        
        private string payerCountryField;
        
        private string billingAgreementDescriptionField;
        
        /// <remarks/>
        public string PayerEmail {
            get {
                return this.payerEmailField;
            }
            set {
                this.payerEmailField = value;
            }
        }
        
        /// <remarks/>
        public string BillingAgreementId {
            get {
                return this.billingAgreementIdField;
            }
            set {
                this.billingAgreementIdField = value;
            }
        }
        
        /// <remarks/>
        public string FirstName {
            get {
                return this.firstNameField;
            }
            set {
                this.firstNameField = value;
            }
        }
        
        /// <remarks/>
        public string LastName {
            get {
                return this.lastNameField;
            }
            set {
                this.lastNameField = value;
            }
        }
        
        /// <remarks/>
        public string MiddleName {
            get {
                return this.middleNameField;
            }
            set {
                this.middleNameField = value;
            }
        }
        
        /// <remarks/>
        public string PayerBusiness {
            get {
                return this.payerBusinessField;
            }
            set {
                this.payerBusinessField = value;
            }
        }
        
        /// <remarks/>
        public string PayerCountry {
            get {
                return this.payerCountryField;
            }
            set {
                this.payerCountryField = value;
            }
        }
        
        /// <remarks/>
        public string BillingAgreementDescription {
            get {
                return this.billingAgreementDescriptionField;
            }
            set {
                this.billingAgreementDescriptionField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class PayPalPayinInfo {
        
        private BillingAgreementDetails billingAgreementDetailsField;
        
        /// <remarks/>
        public BillingAgreementDetails BillingAgreementDetails {
            get {
                return this.billingAgreementDetailsField;
            }
            set {
                this.billingAgreementDetailsField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class WholesaleInfo {
        
        private string accountHolderNameField;
        
        private string externalReferenceIdField;
        
        private string wholesalePartnerField;
        
        private string encryptedPasswordField;
        
        /// <remarks/>
        public string AccountHolderName {
            get {
                return this.accountHolderNameField;
            }
            set {
                this.accountHolderNameField = value;
            }
        }
        
        /// <remarks/>
        public string ExternalReferenceId {
            get {
                return this.externalReferenceIdField;
            }
            set {
                this.externalReferenceIdField = value;
            }
        }
        
        /// <remarks/>
        public string WholesalePartner {
            get {
                return this.wholesalePartnerField;
            }
            set {
                this.wholesalePartnerField = value;
            }
        }
        
        /// <remarks/>
        public string EncryptedPassword {
            get {
                return this.encryptedPasswordField;
            }
            set {
                this.encryptedPasswordField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class DirectDebitInfo {
        
        private string accountHolderNameField;
        
        private string accountNumberField;
        
        private string bankCodeField;
        
        private string branchCodeField;
        
        private string checkDigitsField;
        
        /// <remarks/>
        public string AccountHolderName {
            get {
                return this.accountHolderNameField;
            }
            set {
                this.accountHolderNameField = value;
            }
        }
        
        /// <remarks/>
        public string AccountNumber {
            get {
                return this.accountNumberField;
            }
            set {
                this.accountNumberField = value;
            }
        }
        
        /// <remarks/>
        public string BankCode {
            get {
                return this.bankCodeField;
            }
            set {
                this.bankCodeField = value;
            }
        }
        
        /// <remarks/>
        public string BranchCode {
            get {
                return this.branchCodeField;
            }
            set {
                this.branchCodeField = value;
            }
        }
        
        /// <remarks/>
        public string CheckDigits {
            get {
                return this.checkDigitsField;
            }
            set {
                this.checkDigitsField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class CreditCardInfo {
        
        private byte cardTypeField;
        
        private string accountHolderNameField;
        
        private string accountNumberField;
        
        private string ccvNumberField;
        
        private System.DateTime expirationDateField;
        
        /// <remarks/>
        public byte CardType {
            get {
                return this.cardTypeField;
            }
            set {
                this.cardTypeField = value;
            }
        }
        
        /// <remarks/>
        public string AccountHolderName {
            get {
                return this.accountHolderNameField;
            }
            set {
                this.accountHolderNameField = value;
            }
        }
        
        /// <remarks/>
        public string AccountNumber {
            get {
                return this.accountNumberField;
            }
            set {
                this.accountNumberField = value;
            }
        }
        
        /// <remarks/>
        public string CcvNumber {
            get {
                return this.ccvNumberField;
            }
            set {
                this.ccvNumberField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime ExpirationDate {
            get {
                return this.expirationDateField;
            }
            set {
                this.expirationDateField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class PhoneInfo {
        
        private string phonePrefixField;
        
        private string phoneNumberField;
        
        private string phoneExtensionField;
        
        /// <remarks/>
        public string PhonePrefix {
            get {
                return this.phonePrefixField;
            }
            set {
                this.phonePrefixField = value;
            }
        }
        
        /// <remarks/>
        public string PhoneNumber {
            get {
                return this.phoneNumberField;
            }
            set {
                this.phoneNumberField = value;
            }
        }
        
        /// <remarks/>
        public string PhoneExtension {
            get {
                return this.phoneExtensionField;
            }
            set {
                this.phoneExtensionField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class AddressInfo {
        
        private string street1Field;
        
        private string street2Field;
        
        private string cityField;
        
        private string districtField;
        
        private string stateField;
        
        private string postalCodeField;
        
        /// <remarks/>
        public string Street1 {
            get {
                return this.street1Field;
            }
            set {
                this.street1Field = value;
            }
        }
        
        /// <remarks/>
        public string Street2 {
            get {
                return this.street2Field;
            }
            set {
                this.street2Field = value;
            }
        }
        
        /// <remarks/>
        public string City {
            get {
                return this.cityField;
            }
            set {
                this.cityField = value;
            }
        }
        
        /// <remarks/>
        public string District {
            get {
                return this.districtField;
            }
            set {
                this.districtField = value;
            }
        }
        
        /// <remarks/>
        public string State {
            get {
                return this.stateField;
            }
            set {
                this.stateField = value;
            }
        }
        
        /// <remarks/>
        public string PostalCode {
            get {
                return this.postalCodeField;
            }
            set {
                this.postalCodeField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class PaymentInstrumentInfo {
        
        private string paymentInstrumentIdField;
        
        private byte paymentInstrumentTypeField;
        
        private AddressInfo addressInfoField;
        
        private PhoneInfo phoneInfoField;
        
        private CreditCardInfo creditCardInfoField;
        
        private DirectDebitInfo directDebitInfoField;
        
        private WholesaleInfo wholesaleInfoField;
        
        private PayPalPayinInfo payPalPayinInfoField;
        
        /// <remarks/>
        public string PaymentInstrumentId {
            get {
                return this.paymentInstrumentIdField;
            }
            set {
                this.paymentInstrumentIdField = value;
            }
        }
        
        /// <remarks/>
        public byte PaymentInstrumentType {
            get {
                return this.paymentInstrumentTypeField;
            }
            set {
                this.paymentInstrumentTypeField = value;
            }
        }
        
        /// <remarks/>
        public AddressInfo AddressInfo {
            get {
                return this.addressInfoField;
            }
            set {
                this.addressInfoField = value;
            }
        }
        
        /// <remarks/>
        public PhoneInfo PhoneInfo {
            get {
                return this.phoneInfoField;
            }
            set {
                this.phoneInfoField = value;
            }
        }
        
        /// <remarks/>
        public CreditCardInfo CreditCardInfo {
            get {
                return this.creditCardInfoField;
            }
            set {
                this.creditCardInfoField = value;
            }
        }
        
        /// <remarks/>
        public DirectDebitInfo DirectDebitInfo {
            get {
                return this.directDebitInfoField;
            }
            set {
                this.directDebitInfoField = value;
            }
        }
        
        /// <remarks/>
        public WholesaleInfo WholesaleInfo {
            get {
                return this.wholesaleInfoField;
            }
            set {
                this.wholesaleInfoField = value;
            }
        }
        
        /// <remarks/>
        public PayPalPayinInfo PayPalPayinInfo {
            get {
                return this.payPalPayinInfoField;
            }
            set {
                this.payPalPayinInfoField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class GetPaymentInstrumentResults {
        
        private PaymentInstrumentInfo[] paymentInstrumentInfosField;
        
        /// <remarks/>
        public PaymentInstrumentInfo[] PaymentInstrumentInfos {
            get {
                return this.paymentInstrumentInfosField;
            }
            set {
                this.paymentInstrumentInfosField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class SessionDetails {
        
        private byte[] sessionKeyField;
        
        private string musicNetAuthTokenField;
        
        private string geoCountryCodeField;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
        public byte[] SessionKey {
            get {
                return this.sessionKeyField;
            }
            set {
                this.sessionKeyField = value;
            }
        }
        
        /// <remarks/>
        public string MusicNetAuthToken {
            get {
                return this.musicNetAuthTokenField;
            }
            set {
                this.musicNetAuthTokenField = value;
            }
        }
        
        /// <remarks/>
        public string GeoCountryCode {
            get {
                return this.geoCountryCodeField;
            }
            set {
                this.geoCountryCodeField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class SubscriptionDetails {
        
        private ulong xboxOfferIdField;
        
        private string billingInstanceIdField;
        
        private string statusField;
        
        private bool hasBillingViolationField;
        
        private bool hasPendingCancelField;
        
        private string musicNetSkuField;
        
        private System.DateTime startDateField;
        
        private System.DateTime endDateField;
        
        private string renewalXboxOfferIdField;
        
        /// <remarks/>
        public ulong XboxOfferId {
            get {
                return this.xboxOfferIdField;
            }
            set {
                this.xboxOfferIdField = value;
            }
        }
        
        /// <remarks/>
        public string BillingInstanceId {
            get {
                return this.billingInstanceIdField;
            }
            set {
                this.billingInstanceIdField = value;
            }
        }
        
        /// <remarks/>
        public string Status {
            get {
                return this.statusField;
            }
            set {
                this.statusField = value;
            }
        }
        
        /// <remarks/>
        public bool HasBillingViolation {
            get {
                return this.hasBillingViolationField;
            }
            set {
                this.hasBillingViolationField = value;
            }
        }
        
        /// <remarks/>
        public bool HasPendingCancel {
            get {
                return this.hasPendingCancelField;
            }
            set {
                this.hasPendingCancelField = value;
            }
        }
        
        /// <remarks/>
        public string MusicNetSku {
            get {
                return this.musicNetSkuField;
            }
            set {
                this.musicNetSkuField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime StartDate {
            get {
                return this.startDateField;
            }
            set {
                this.startDateField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime EndDate {
            get {
                return this.endDateField;
            }
            set {
                this.endDateField = value;
            }
        }
        
        /// <remarks/>
        public string RenewalXboxOfferId {
            get {
                return this.renewalXboxOfferIdField;
            }
            set {
                this.renewalXboxOfferIdField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class AccountDetails {
        
        private ulong xboxPuidField;
        
        private ulong livePuidField;
        
        private string tagField;
        
        private string postalCodeField;
        
        private string countryCodeField;
        
        private bool parentallyControlledField;
        
        private byte[] privilegesField;
        
        private uint pointsBalanceField;
        
        private bool isLightweightField;
        
        /// <remarks/>
        public ulong XboxPuid {
            get {
                return this.xboxPuidField;
            }
            set {
                this.xboxPuidField = value;
            }
        }
        
        /// <remarks/>
        public ulong LivePuid {
            get {
                return this.livePuidField;
            }
            set {
                this.livePuidField = value;
            }
        }
        
        /// <remarks/>
        public string Tag {
            get {
                return this.tagField;
            }
            set {
                this.tagField = value;
            }
        }
        
        /// <remarks/>
        public string PostalCode {
            get {
                return this.postalCodeField;
            }
            set {
                this.postalCodeField = value;
            }
        }
        
        /// <remarks/>
        public string CountryCode {
            get {
                return this.countryCodeField;
            }
            set {
                this.countryCodeField = value;
            }
        }
        
        /// <remarks/>
        public bool ParentallyControlled {
            get {
                return this.parentallyControlledField;
            }
            set {
                this.parentallyControlledField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
        public byte[] Privileges {
            get {
                return this.privilegesField;
            }
            set {
                this.privilegesField = value;
            }
        }
        
        /// <remarks/>
        public uint PointsBalance {
            get {
                return this.pointsBalanceField;
            }
            set {
                this.pointsBalanceField = value;
            }
        }
        
        /// <remarks/>
        public bool IsLightweight {
            get {
                return this.isLightweightField;
            }
            set {
                this.isLightweightField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class ErrorDetails {
        
        private uint hResultField;
        
        private string messageField;
        
        private bool tagChangeRequiredField;
        
        private bool acceptedTermsOfServiceField;
        
        private bool accountSuspendedField;
        
        private bool subscriptionLapsedField;
        
        private bool billingUnavailableField;
        
        /// <remarks/>
        public uint HResult {
            get {
                return this.hResultField;
            }
            set {
                this.hResultField = value;
            }
        }
        
        /// <remarks/>
        public string Message {
            get {
                return this.messageField;
            }
            set {
                this.messageField = value;
            }
        }
        
        /// <remarks/>
        public bool TagChangeRequired {
            get {
                return this.tagChangeRequiredField;
            }
            set {
                this.tagChangeRequiredField = value;
            }
        }
        
        /// <remarks/>
        public bool AcceptedTermsOfService {
            get {
                return this.acceptedTermsOfServiceField;
            }
            set {
                this.acceptedTermsOfServiceField = value;
            }
        }
        
        /// <remarks/>
        public bool AccountSuspended {
            get {
                return this.accountSuspendedField;
            }
            set {
                this.accountSuspendedField = value;
            }
        }
        
        /// <remarks/>
        public bool SubscriptionLapsed {
            get {
                return this.subscriptionLapsedField;
            }
            set {
                this.subscriptionLapsedField = value;
            }
        }
        
        /// <remarks/>
        public bool BillingUnavailable {
            get {
                return this.billingUnavailableField;
            }
            set {
                this.billingUnavailableField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class SignInResults {
        
        private ErrorDetails errorInfoField;
        
        private AccountDetails accountInfoField;
        
        private SubscriptionDetails subscriptionInfoField;
        
        private SessionDetails sessionInfoField;
        
        /// <remarks/>
        public ErrorDetails ErrorInfo {
            get {
                return this.errorInfoField;
            }
            set {
                this.errorInfoField = value;
            }
        }
        
        /// <remarks/>
        public AccountDetails AccountInfo {
            get {
                return this.accountInfoField;
            }
            set {
                this.accountInfoField = value;
            }
        }
        
        /// <remarks/>
        public SubscriptionDetails SubscriptionInfo {
            get {
                return this.subscriptionInfoField;
            }
            set {
                this.subscriptionInfoField = value;
            }
        }
        
        /// <remarks/>
        public SessionDetails SessionInfo {
            get {
                return this.sessionInfoField;
            }
            set {
                this.sessionInfoField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class GetPointsBalanceResults {
        
        private int pointsBalanceField;
        
        private bool aboveLowBalanceField;
        
        private byte dmpAccountStatusField;
        
        /// <remarks/>
        public int PointsBalance {
            get {
                return this.pointsBalanceField;
            }
            set {
                this.pointsBalanceField = value;
            }
        }
        
        /// <remarks/>
        public bool AboveLowBalance {
            get {
                return this.aboveLowBalanceField;
            }
            set {
                this.aboveLowBalanceField = value;
            }
        }
        
        /// <remarks/>
        public byte DmpAccountStatus {
            get {
                return this.dmpAccountStatusField;
            }
            set {
                this.dmpAccountStatusField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public enum GamertagSuggestionType {
        
        /// <remarks/>
        NounAdjectiveSuggestion,
        
        /// <remarks/>
        SeedSuggestion,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void AcceptTermsOfServiceCompletedEventHandler(object sender, AcceptTermsOfServiceCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class AcceptTermsOfServiceCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal AcceptTermsOfServiceCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void AddCreditCardCompletedEventHandler(object sender, AddCreditCardCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class AddCreditCardCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal AddCreditCardCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public AddCreditCardResults Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((AddCreditCardResults)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void GetPointsBalanceCompletedEventHandler(object sender, GetPointsBalanceCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetPointsBalanceCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetPointsBalanceCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public GetPointsBalanceResults Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((GetPointsBalanceResults)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void SignInCompletedEventHandler(object sender, SignInCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SignInCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SignInCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public SignInResults Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((SignInResults)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void CreateMobileAccountCompletedEventHandler(object sender, CreateMobileAccountCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class CreateMobileAccountCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal CreateMobileAccountCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void GenerateGamertagCompletedEventHandler(object sender, GenerateGamertagCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GenerateGamertagCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GenerateGamertagCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void GetPaymentInstrumentsCompletedEventHandler(object sender, GetPaymentInstrumentsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetPaymentInstrumentsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetPaymentInstrumentsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public GetPaymentInstrumentResults Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((GetPaymentInstrumentResults)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void GetSupportedCountriesCompletedEventHandler(object sender, GetSupportedCountriesCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetSupportedCountriesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetSupportedCountriesCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public CountryInfo[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((CountryInfo[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void GetUserAuthorizationCompletedEventHandler(object sender, GetUserAuthorizationCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetUserAuthorizationCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetUserAuthorizationCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public GetUserAuthorizationInfo Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((GetUserAuthorizationInfo)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void TestConnectionCompletedEventHandler(object sender, TestConnectionCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class TestConnectionCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal TestConnectionCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LIVEnAuthClient\LiveNTool\NotificationPrivateService.cs ===
﻿//------------------------------------------------------------------------------------------------- 
// <copyright file="NotificationPrivateService.cs" company="Microsoft" author="a-thkuo">
//      Copyright © .  All rights reserved.
// </copyright>
// <summary>Code to test Notification Service</summary>
//-------------------------------------------------------------------------------------------------
namespace LIVEnTool
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Net;
    using System.Runtime.Serialization;
    using System.Text;
    using AsyncMultiplayer.NotificationService;
    using LIVEnAuthClient;

    /// <summary>
    /// NotificationPrivateService class definition
    /// </summary>
    public class NotificationPrivateService
    {
        /// <summary>
        /// Calls GetNotifications with count=1
        /// </summary>
        /// <param name="userXuid">The user's STS token</param>
        /// <returns>The webresponse responsestream</returns>
        public static string GetNotificationPrivate(string userXuid)
        {
            return NotificationPrivateService.GetNotificationsPrivate(userXuid, "1");
        }


        /// <summary>
        /// Get the latest notification of the user.
        /// </summary>
        /// <param name="userXuid">The user's token</param>
        /// <param name="count">The count of notifications to return</param>
        /// <returns>The notification text</returns>
        public static string GetNotificationsPrivate(string userXuid, string count)
        {
            string ret = string.Empty;
            string uri = String.Format("{0}?count={1}", HelperLibrary.NotificationPrivateServiceUrl, count);

            WebResponse response = HelperLibrary.SendInternalRequest(uri, "GET", userXuid, false, string.Empty, "application/xml", out ret);

            return ret;
        }

        /// <summary>
        /// Get the spotlight for the user.
        /// </summary>
        /// <param name="userXuid">The user's token</param>
        /// <returns>Spotlight text</returns>
        public static string GetSpotlightPrivate(string userXuid)
        {
            string ret = string.Empty;
            string uri = String.Format("{0}Spotlight/", HelperLibrary.NotificationPrivateServiceUrl);

            WebResponse response = HelperLibrary.SendInternalRequest(uri, "GET", userXuid, false, string.Empty, "application/xml", out ret);

            return ret;
        }

        /// <summary>
        /// Send an invite notification
        /// </summary>
        /// <param name="userXuid">The user's token</param>
        /// <param name="sessionId">Session ID string</param>
        /// <param name="recipients">Recipients seperated by semicolon</param>
        /// <param name="titleId">Title ID which will used as the Game ID</param>
        /// <returns>The webresponse responsestream</returns>
        public static string SendInvitePrivate(
            string userXuid, 
            string sessionId, 
            string recipients, 
            string titleId,
            string isFriendRequest,
            string invitationData)
        {
            string ret = string.Empty;

            // Create a new InviteRequest Object
            InviteRequest invite = new InviteRequest();
            invite.GameId = Convert.ToUInt32(titleId);
            invite.SessionId = sessionId;
            invite.Recipients = recipients;
            invite.FriendRequest = bool.Parse(isFriendRequest);
            invite.Data = invitationData;

            string uri = String.Format("{0}invite/", HelperLibrary.NotificationPrivateServiceUrl);

            string requestBody = HelperLibrary.Deserialize(invite);

            WebResponse response = HelperLibrary.SendInternalRequest(uri, "POST", userXuid, false, requestBody, "application/xml", out ret);
            return ret;
        }

        /// <summary>
        /// Update a notification
        /// </summary>
        /// <param name="userXuid">The user's token</param>
        /// <param name="notificationId">Notification ID string</param>
        /// <param name="status">Status string</param>
        /// <returns>The webresponse responsestream</returns>
        public static string UpdateNotificationPrivate(
            string userXuid,
            string notificationId,
            string status)
        {
            string ret = string.Empty;
            string uri = String.Format(
                "{0}update/?notification={1}&status={2}",
                HelperLibrary.NotificationPrivateServiceUrl,
                notificationId,
                status);

            WebResponse response = HelperLibrary.SendInternalRequest(uri, "PUT", userXuid, false, string.Empty, "application/xml", out ret);
            return ret;
        }

        /// <summary>
        /// Calls DeleteNotificationQuery
        /// </summary>
        /// <param name="userXuid">The user's STS token</param>
        /// <param name="notificationId">The notification ID</param>
        /// <returns>The webresponse responsestream</returns>
        public static string DeleteNotificationQueryPrivate(
            string userXuid,
            string notificationId)
        {
            string ret = string.Empty;
            string uri = String.Format(
                "{0}delete/?notification={1}",
                HelperLibrary.NotificationPrivateServiceUrl,
                notificationId);

            WebResponse response = HelperLibrary.SendInternalRequest(uri, "DELETE", userXuid, false, string.Empty, "application/xml", out ret);
            return ret;
        }

        /// <summary>
        /// Calls DeleteNotificaitonBySession
        /// </summary>
        /// <param name="userXuid">The user's STS token</param>
        /// <param name="gameId">The game ID</param>
        /// <param name="sessionId">The session ID (GUID)</param>
        /// <returns>The webresponse responsestream</returns>
        public static string DeleteNotificationBySessionPrivate(
            string userXuid,
            string gameId,
            string sessionId)
        {
            string ret = string.Empty;
            string uri = String.Format(
                "{0}deletesession/?game={1}&session={2}",
                HelperLibrary.NotificationPrivateServiceUrl,
                gameId,
                sessionId);

            WebResponse response = HelperLibrary.SendInternalRequest(uri, "DELETE", userXuid, false, string.Empty, "application/xml", out ret);
            return ret;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LIVEnAuthClient\LiveNTool\RewardService.cs ===
﻿//------------------------------------------------------------------------------------------------- 
// <copyright file="RewardService.cs" company="Microsoft" author="a-thkuo">
//      Copyright © .  All rights reserved.
// </copyright>
// <summary>Code to test Reward Service API</summary>
//-------------------------------------------------------------------------------------------------
namespace LIVEnTool
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Net;
    using System.Runtime.Serialization;
    using System.Text;
    using Gds.Contracts;
    using LIVEnAuthClient;

    /// <summary>
    /// RewardService class definition
    /// </summary>
    public class RewardService
    {
        /// <summary>
        /// Calls PostGameResult
        /// </summary>
        /// <param name="membername">The user's membername</param>
        /// <param name="password">The user's password</param>
        /// <param name="gameId">The game ID</param>
        /// <param name="variant">The variant param</param>
        /// <param name="gameResultId">The game result ID (should be a fresh guid)</param>
        /// <param name="outcome">The outcome of the game</param>
        /// <param name="score">The user's score</param>
        /// <param name="time">The amount of time played</param>
        /// <param name="timeStamp">The timestamp</param>
        /// <returns>The responsestream from the service method</returns>
        public static string PostGameResult(
            string membername,
            string password,
            string gameId,
            string variant,
            string gameResultId,
            string outcome,
            string score,
            string time,
            string timeStamp)
        {
            string userToken = TokenService.GetNewUserToken(membername, password, HelperLibrary.TitleId, HelperLibrary.TitleVersion);
            return RewardService.PostGameResult(userToken, gameId, variant, gameResultId, outcome, score, time, timeStamp);
        }

        /// <summary>
        /// Post game's result to the Rewards Service
        /// </summary>
        /// <param name="userToken">Member's STS token</param>
        /// <param name="gameId">The game id</param>
        /// <param name="variant">A variant (?)</param>
        /// <param name="gameResultId">A fresh guid</param>
        /// <param name="outcome">The outcome of the game (e.g. "Win")</param>
        /// <param name="score">The player's final score</param>
        /// <param name="time">The amount of time played (seconds?)</param>
        /// <param name="timeStamp">A timestamp, supposed to be current</param>
        /// <returns>Response from the POST request</returns>
        public static string PostGameResult(
            string userToken,
            string gameId,
            string variant,
            string gameResultId,
            string outcome,
            string score,
            string time,
            string timeStamp)
        {
            GameResult gr = new GameResult()
            {
                GameId = uint.Parse(gameId), // Convert.ToUInt32(HelperLibrary.TitleId),
                Variant = uint.Parse(variant),
                GameResultId = new Guid(gameResultId),
                Outcome = outcome,
                Score = long.Parse(score),
                Time = long.Parse(time),
                TimeStamp = DateTime.Now
            };

            string ret = string.Empty;

            string uri = String.Format("{0}GameResult?format={1}", HelperLibrary.RewardServiceUrl, "xml");

            string requestBody = HelperLibrary.Deserialize(gr);

            WebResponse response = HelperLibrary.SendRequest(uri, "POST", userToken, false, requestBody, "application/xml", out ret);

            return ret;
        }

        /// <summary>
        /// Calls GrantAchievements
        /// </summary>
        /// <param name="membername">The user's membername</param>
        /// <param name="password">The user's password</param>
        /// <param name="timeStamp">The time of the achievement being earned</param>
        /// <param name="earnedOnline">Whether it was earned online</param>
        /// <param name="key">The key param (?)</param>
        /// <returns>The responsestream from the service method</returns>
        public static string GrantAchievements(
            string membername,
            string password,
            string gameId,
            string appId,
            string timeStamp,
            string earnedOnline,
            string key)
        {
            string userToken = TokenService.GetNewUserToken(membername, password, HelperLibrary.TitleId, HelperLibrary.TitleVersion);
            return RewardService.GrantAchievements(userToken, gameId, appId, timeStamp, earnedOnline, key );
        }

        /// <summary>
        /// Calls GrantAchievements
        /// </summary>
        /// <param name="userToken">The user's STS token</param>
        /// <param name="timeStamp">The time of the achievement being earned</param>
        /// <param name="earnedOnline">Whether it was earned online</param>
        /// <param name="key">The key param (?)</param>
        /// <returns>The responsestream from the service method</returns>
        public static string GrantAchievements(
            string userToken,            
            string gameId,
            string appId,
            string timeStamp,
            string earnedOnline,
            string key
             )
        {
            GrantAchievements ga = new GrantAchievements();
            ga.Achievements = new List<AchievementEarned>();
            ga.AppId = appId;
            ga.GameId = uint.Parse(gameId);

            AchievementEarned achievementEarned = new AchievementEarned()
            {                
                EarnedDateTime = DateTime.Parse(timeStamp),
                EarnedOnline = bool.Parse(earnedOnline),
                Key = key
            };

            ga.Achievements.Add(achievementEarned);

            string ret = string.Empty;

            string uri = String.Format("{0}GrantAchievements?format={1}", HelperLibrary.RewardServiceUrl, "xml");

            string requestBody = HelperLibrary.Deserialize(ga);

            WebResponse response = HelperLibrary.SendRequest(uri, "POST", userToken, false, requestBody, "application/xml", out ret);

            return ret;
        }

        /// <summary>
        /// Gets the help info from the rewards service
        /// </summary>
        /// <returns>The help info</returns>
        public static string GetDocumentation()
        {
            string ret = string.Empty;
            string uri = String.Format("{0}help", HelperLibrary.RewardServiceUrl);

            WebResponse response = HelperLibrary.SendRequest(uri, "GET", string.Empty, false, string.Empty, "application/xml", out ret);

            return ret;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LIVEnAuthClient\LiveNTool\ServerSelfCheck.cs ===
﻿//------------------------------------------------------------------------------------------------- 
// <copyright file="ServerSelfCheck.cs" company="Microsoft" author="a-thkuo">
//      Copyright © .  All rights reserved.
// </copyright>
// <summary>
//      Code containing class and methods required to run the tests to verify that the
//      services are working when testing locally from the server box.
// </summary>
//-------------------------------------------------------------------------------------------------
namespace LIVEnTool
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Net;
    using System.Reflection;
    using System.Text;

    using Leet.Core.Configuration;
    using Leet.Core.IO;
    using Leet.Core.IoCCo;
    using LIVEnAuthClient;

    /// <summary>
    /// ServerSelfCheck class definition
    /// </summary>
    public class ServerSelfCheck
    {
        /// <summary>
        /// Filepath to the hosts file
        /// </summary>
        private static string hostsFilePath = @"%SystemRoot%\System32\drivers\etc\hosts";

        /// <summary>
        /// Filepath to the temporary file to keep the original hosts file
        /// </summary>
        private static string tmpHostsFilePath = @"%SystemRoot%\System32\drivers\etc\hosts.ori";

        /// <summary>
        /// Method to get the test environment of the server from Configuration Provider
        /// </summary>
        /// <param name="environment">The placeholder for the environment</param>
        public static void GetServerEnvironment(out string environment)
        {
            Container.Instance.AddService<IRegistryProvider, RegistryProvider>();
            Container.Instance.AddService<IFileSystem, FileSystem>();
            ConfigurationSelector.RegisterProvider("LIVEnTool", "LEET");

            IConfigurationProvider configProvider = Container.Instance.GetComponent<IConfigurationProvider>();

            environment = string.Empty;

            switch (configProvider.Environment)
            {
                case "livenoob":
                case "dev":
                    environment = "dev";
                    break;

                case "testnet":
                    environment = "test";
                    break;

                case "stressnet":
                    environment = "stress";
                    break;

                case "int2":
                    environment = "int2";
                    break;

                case "partnernet":
                    environment = "part";
                    break;

                default:
                    break;
            }
        }

        /// <summary>
        /// Method to replace the hosts file with a new hosts file needed to do the selfcheck.
        /// </summary>
        public static void ReplaceHostFile()
        {
            // Get the IP address to hostname mapping
            string hosts = GetAddressToHostMap();

            try
            {
                // First, make a copy of the original hosts file, as we want to restore it after the test is done
                FileInfo fi = new FileInfo(Environment.ExpandEnvironmentVariables(hostsFilePath));
                fi.CopyTo(Environment.ExpandEnvironmentVariables(tmpHostsFilePath), true);

                // Truncate/overwrite the hosts file with the mapping obtained 
                using (FileStream fs = fi.Open(FileMode.Truncate, FileAccess.ReadWrite))
                {
                    byte[] hostsArray = new UTF8Encoding().GetBytes(hosts);
                    fs.Write(hostsArray, 0, hostsArray.Length);
                }
            }
            catch (IOException)
            {
                if (File.Exists(tmpHostsFilePath))
                {
                    File.Delete(tmpHostsFilePath);
                }
            }
        }

        /// <summary>
        /// Method to restore the original hosts file
        /// </summary>
        public static void RestoreHostFile()
        {
            FileInfo fi = new FileInfo(Environment.ExpandEnvironmentVariables(tmpHostsFilePath));
            fi.CopyTo(Environment.ExpandEnvironmentVariables(hostsFilePath), true);
            fi.Delete();
        }

        /// <summary>
        /// Method to get the mapping table of the server's IP address to the service host names
        /// </summary>
        /// <returns>The new mapping table for the hosts file</returns>
        private static string GetAddressToHostMap()
        {
            string[] hostsFileHeader = 
            { 
              "# Copyright (c) 1993-2009 Microsoft Corp.",
              "#",
              "# This is a temporary hosts file for use when checking the services locally on the server.",
              "#========================================================================================="
            };

            string ipAddress = GetServerIpAddress();
            List<string> hostNames = HelperLibrary.GetServiceHostNames();
            StringBuilder sb = new StringBuilder();

            foreach (string s in hostsFileHeader)
            {
                sb.AppendLine(s);
            }

            foreach (string hostname in hostNames)
            {
                sb.AppendLine(ipAddress + "\t\t" + hostname);
            }

            return sb.ToString();
        }

        /// <summary>
        /// Method to the server's ip address
        /// </summary>
        /// <returns>server's ip address</returns>
        private static string GetServerIpAddress()
        {
            string hostName = Dns.GetHostName();
            IPHostEntry ipEntry = Dns.GetHostEntry(hostName);
            string ipv4 = string.Empty;

            foreach (IPAddress ip in ipEntry.AddressList)
            {
                if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)
                {
                    ipv4 = ip.ToString();
                }
            }

            return ipv4;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LIVEnAuthClient\LiveNTool\ServiceTest.cs ===
﻿namespace LIVEnTool
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;

    public class ServiceTest
    {
        public class ArgInfo
        {
            public string Name { get; set; }
            public string DefaultValue { get; set; }
            public string Type { get; set; }
            public override string ToString()
            {
                return this.Name;
            }
            public ArgInfo(string name, string type, string defaultValue)
            {
                this.Name = name;
                this.Type = type;
                this.DefaultValue = defaultValue;
            }
        }

        public enum TokenOption
        {
            None,
            User,
            Partner
        };

        public string TestName { get; private set; }

        public string ServiceEndpointKey { get; private set; }

        public string VirtualInterfaceName { get; private set; }

        public string ServiceType { get; private set; }

        public bool ShowInGui { get; private set; }

        public bool ShowInConsoleApp { get; private set; }

        public TokenOption TokenRequired { get; private set; }

        public List<ArgInfo> Arguments { get; private set; }


        internal ServiceTest()
        {
        }
       
        internal ServiceTest(string testName, string endpoint, TokenOption tokenOption, List<ArgInfo> args, bool showInGui, bool showInConsoleApp, string virtualInterfaceName)
        {
            this.TestName = testName;
            this.ServiceEndpointKey = endpoint;
            this.TokenRequired = tokenOption;
            this.Arguments = args;
            this.ShowInGui = showInGui;
            this.ShowInConsoleApp = showInConsoleApp;
            this.VirtualInterfaceName = virtualInterfaceName;
        }

        internal ServiceTest(string testName, string endpoint, string tokenOption, List<ArgInfo> args, bool showInGui, bool showInConsoleApp, string virtualInterfaceName)
        {
            this.TestName = testName;
            this.ServiceEndpointKey = endpoint;
            this.Arguments = args;
            this.ShowInGui = showInGui;
            this.ShowInConsoleApp = showInConsoleApp;
            this.VirtualInterfaceName = virtualInterfaceName;

            switch (tokenOption)
            {
                case "None":
                    this.TokenRequired = TokenOption.None;
                    break;
                case "User":
                    this.TokenRequired = TokenOption.User;
                    break;
                case "Partner":
                    this.TokenRequired = TokenOption.Partner;
                    break;
                default:
                    throw new ArgumentException("Invalid token option given: " + tokenOption);
            }

        }

        public override string ToString() 
        {
            string s = string.Format("{0}", this.TestName);
            return s;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LIVEnAuthClient\LiveNTool\NotificationService.cs ===
﻿//------------------------------------------------------------------------------------------------- 
// <copyright file="NotificationService.cs" company="Microsoft" author="a-thkuo">
//      Copyright © .  All rights reserved.
// </copyright>
// <summary>Code to test Notification Service</summary>
//-------------------------------------------------------------------------------------------------
namespace LIVEnTool
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Net;
    using System.Runtime.Serialization;
    using System.Text;
    using AsyncMultiplayer.NotificationService;
    using LIVEnAuthClient;

    /// <summary>
    /// NotificationService class definition
    /// </summary>
    public class NotificationService
    {
        /// <summary>
        /// Calls GetNotifications with count=1
        /// </summary>
        /// <param name="membername">The user's membername</param>
        /// <param name="password">The user's password</param>
        /// <returns>The webresponse responsestream</returns>
        public static string GetNotification(string membername, string password)
        {
            string userToken = TokenService.GetNewUserToken(membername, password, HelperLibrary.TitleId, HelperLibrary.TitleVersion);
            return NotificationService.GetNotifications(userToken, "1");
        }

        /// <summary>
        /// Calls GetNotifications with count=1
        /// </summary>
        /// <param name="userToken">The user's STS token</param>
        /// <returns>The webresponse responsestream</returns>
        public static string GetNotification(string userToken)
        {
            return NotificationService.GetNotifications(userToken, "1");
        }

        /// <summary>
        /// Calls GetNotifications
        /// </summary>
        /// <param name="membername">The user's membername</param>
        /// <param name="password">The user's password</param>
        /// <param name="count">The count of notifications to return</param>
        /// <returns>The webresponse responsestream</returns>
        public static string GetNotifications(string membername, string password, string count)
        {
            string userToken = TokenService.GetNewUserToken(membername, password, HelperLibrary.TitleId, HelperLibrary.TitleVersion);
            return NotificationService.GetNotifications(userToken, count);
        }

        /// <summary>
        /// Get the latest notification of the user.
        /// </summary>
        /// <param name="userToken">The user's token</param>
        /// <param name="count">The count of notifications to return</param>
        /// <returns>The notification text</returns>
        public static string GetNotifications(string userToken, string count)
        {
            string ret = string.Empty;
            string uri = String.Format("{0}?count={1}", HelperLibrary.NotificationServiceUrl, count);

            WebResponse response = HelperLibrary.SendRequest(uri, "GET", userToken, false, string.Empty, "application/xml", out ret);

            return ret;
        }

        /// <summary>
        /// Calls GetSpotlight
        /// </summary>
        /// <param name="membername">The user's membername</param>
        /// <param name="password">The user's password</param>
        /// <returns>The webresponse responsestream</returns>
        public static string GetSpotlight(string membername, string password)
        {
            string userToken = TokenService.GetNewUserToken(membername, password, HelperLibrary.TitleId, HelperLibrary.TitleVersion);
            return NotificationService.GetSpotlight(userToken);
        }

        /// <summary>
        /// Get the spotlight for the user.
        /// </summary>
        /// <param name="userToken">The user's token</param>
        /// <returns>Spotlight text</returns>
        public static string GetSpotlight(string userToken)
        {
            string ret = string.Empty;
            string uri = String.Format("{0}Spotlight/", HelperLibrary.NotificationServiceUrl);

            WebResponse response = HelperLibrary.SendRequest(uri, "GET", userToken, false, string.Empty, "application/xml", out ret);

            return ret;
        }

        /// <summary>
        /// Calls SendInvite
        /// </summary>
        /// <param name="membername">The user's membername</param>
        /// <param name="password">The user's password</param>
        /// <param name="sessionId">The session ID</param>
        /// <param name="recipients">The recipients</param>
        /// <param name="titleId">The title ID</param>
        /// <returns>The webresponse responsestream</returns>
        public static string SendInvite(
            string membername,
            string password,
            string sessionId,
            string recipients,
            string titleId,
            string isFriendRequest,
            string invitationData)
        {
            string userToken = TokenService.GetNewUserToken(membername, password, HelperLibrary.TitleId, HelperLibrary.TitleVersion);
            return NotificationService.SendInvite(userToken, sessionId, recipients, titleId, isFriendRequest, invitationData);
        }

        /// <summary>
        /// Send an invite notification
        /// </summary>
        /// <param name="userToken">The user's token</param>
        /// <param name="sessionId">Session ID string</param>
        /// <param name="recipients">Recipients seperated by semicolon</param>
        /// <param name="titleId">Title ID which will used as the Game ID</param>
        /// <returns>The webresponse responsestream</returns>
        public static string SendInvite(
            string userToken, 
            string sessionId, 
            string recipients, 
            string titleId,
            string isFriendRequest,
            string invitationData)
        {
            string ret = string.Empty;

            // Create a new InviteRequest Object
            InviteRequest invite = new InviteRequest();
            invite.GameId = Convert.ToUInt32(titleId);
            invite.SessionId = sessionId;
            invite.Recipients = recipients;
            invite.FriendRequest = bool.Parse(isFriendRequest);
            invite.Data = invitationData;

            string uri = String.Format("{0}invite/", HelperLibrary.NotificationServiceUrl);

            string requestBody = HelperLibrary.Deserialize(invite);

            WebResponse response = HelperLibrary.SendRequest(uri, "POST", userToken, false, requestBody, "application/xml", out ret);
            return ret;
        }

        /// <summary>
        /// Calls UpdateNotification
        /// </summary>
        /// <param name="membername">The user's membername</param>
        /// <param name="password">The user's password</param>
        /// <param name="notificationId">The notification ID</param>
        /// <param name="status">The status to update to</param>
        /// <returns>The webresponse responsestream</returns>
        public static string UpdateNotification(
            string membername,
            string password,
            string notificationId,
            string status)
        {
            string userToken = TokenService.GetNewUserToken(membername, password, HelperLibrary.TitleId, HelperLibrary.TitleVersion);
            return NotificationService.UpdateNotification(userToken, notificationId, status);
        }

        /// <summary>
        /// Update a notification
        /// </summary>
        /// <param name="userToken">The user's token</param>
        /// <param name="notificationId">Notification ID string</param>
        /// <param name="status">Status string</param>
        /// <returns>The webresponse responsestream</returns>
        public static string UpdateNotification(
            string userToken,
            string notificationId,
            string status)
        {
            string ret = string.Empty;
            string uri = String.Format(
                "{0}update/?notification={1}&status={2}",
                HelperLibrary.NotificationServiceUrl,
                notificationId,
                status);

            WebResponse response = HelperLibrary.SendRequest(uri, "PUT", userToken, false, string.Empty, "application/xml", out ret);
            return ret;
        }

        /// <summary>
        /// Calls DeleteNotificationQuery
        /// </summary>
        /// <param name="membername">The user's membername</param>
        /// <param name="password">The user's password</param>
        /// <param name="notificationId">The notification ID</param>
        /// <returns>The webresponse responsestream</returns>
        public static string DeleteNotificationQuery(
            string membername,
            string password,
            string notificationId)
        {
            string userToken = TokenService.GetNewUserToken(membername, password, HelperLibrary.TitleId, HelperLibrary.TitleVersion);
            return NotificationService.DeleteNotificationQuery(userToken, notificationId);
        }

        /// <summary>
        /// Calls DeleteNotificationQuery
        /// </summary>
        /// <param name="userToken">The user's STS token</param>
        /// <param name="notificationId">The notification ID</param>
        /// <returns>The webresponse responsestream</returns>
        public static string DeleteNotificationQuery(
            string userToken,
            string notificationId)
        {
            string ret = string.Empty;
            string uri = String.Format(
                "{0}delete/?notification={1}",
                HelperLibrary.NotificationServiceUrl,
                notificationId);

            WebResponse response = HelperLibrary.SendRequest(uri, "DELETE", userToken, false, string.Empty, "application/xml", out ret);
            return ret;
        }

        /// <summary>
        /// Calls DeleteNotificationBySession
        /// </summary>
        /// <param name="membername">The user's membername</param>
        /// <param name="password">The user's password</param>
        /// <param name="gameId">The gameid</param>
        /// <param name="sessionId">The sessionid (a guid)</param>
        /// <returns>The webresponse responsestream</returns>
        public static string DeleteNotificationBySession(
            string membername,
            string password,
            string gameId,
            string sessionId)
        {
            string userToken = TokenService.GetNewUserToken(membername, password, HelperLibrary.TitleId, HelperLibrary.TitleVersion);
            return NotificationService.DeleteNotificationBySession(userToken, gameId, sessionId);
        }

        /// <summary>
        /// Calls DeleteNotificaitonBySession
        /// </summary>
        /// <param name="userToken">The user's STS token</param>
        /// <param name="gameId">The game ID</param>
        /// <param name="sessionId">The session ID (GUID)</param>
        /// <returns>The webresponse responsestream</returns>
        public static string DeleteNotificationBySession(
            string userToken,
            string gameId,
            string sessionId)
        {
            string ret = string.Empty;
            string uri = String.Format(
                "{0}deletesession/?game={1}&session={2}",
                HelperLibrary.NotificationServiceUrl,
                gameId,
                sessionId);

            WebResponse response = HelperLibrary.SendRequest(uri, "DELETE", userToken, false, string.Empty, "application/xml", out ret);
            return ret;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LIVEnAuthClient\LiveNTool\PartnerService.cs ===
﻿//------------------------------------------------------------------------------------------------- 
// <copyright file="PartnerService.cs" company="Microsoft" author="amathes">
//      Copyright © .  All rights reserved.
// </copyright>
// <summary>Code to test Notification Service</summary>
//-------------------------------------------------------------------------------------------------
namespace LIVEnTool
{
    using System;
    using System.Collections.Generic;
    using System.Collections.Specialized;
    using System.IO;
    using System.Linq;
    using System.Net;
    using System.Runtime.Serialization;
    using System.Text;
    using AsyncMultiplayer.NotificationService;
    using AsyncMultiplayer.PartnerService.DataContracts;
    using LIVEnAuthClient;

    /// <summary>
    /// PartnerService class definition
    /// </summary>
    public class PartnerService
    {
        /// <summary>
        /// Calls the partner version of SendNotification
        /// </summary>
        /// <param name="gameId">The game ID</param>
        /// <param name="sessionId">The session ID</param>
        /// <param name="from">The gamertag sending the notification</param>
        /// <param name="recipients">The recipients of the notification</param>
        /// <param name="notificationType">The type of notification</param>
        /// <param name="notificationPropertiesStr">The notification properties. Name/value pairs of format {Name1}::{Value1}||{Name1}::{Value1}</param>
        /// <returns>The webresponse responsestream</returns>
        public static string PartnerSendNotification(
            string gameId,
            string sessionId,
            string from,
            string recipients,
            string notificationType,
            string notificationPropertiesStr)
        {
            uint uintGameId = Convert.ToUInt32(gameId);
            Dictionary<string, string> notificationProperties = new Dictionary<string, string>();

            List<string> notificationPropertyPairs = new List<string>(notificationPropertiesStr.Split(new string[] { "||" }, StringSplitOptions.None));

            foreach (string notificationPropertyPair in notificationPropertyPairs)
            {
                string notificationPropertyName = notificationPropertyPair.Split(new string[] { "::" }, StringSplitOptions.None)[0];
                string notificationPropertyValue = notificationPropertyPair.Split(new string[] { "::" }, StringSplitOptions.None)[1];
                notificationProperties.Add(notificationPropertyName, notificationPropertyValue);
            }

            string responseString = string.Empty;

            // Create a new InviteRequest Object
            PartnerNotificationRequest partnerNotificationRequest = new PartnerNotificationRequest();
            partnerNotificationRequest.GameId = uint.Parse(gameId);
            partnerNotificationRequest.SessionId = sessionId;
            partnerNotificationRequest.From = from;
            partnerNotificationRequest.Recipients = recipients;
            partnerNotificationRequest.NotificationType = notificationType;
            partnerNotificationRequest.NotificationProperties = new PartnerNotificationRequest.PropertyDictionary();

            foreach (string notificationPropertyName in notificationProperties.Keys)
            {
                NotificationProperty notificationProperty = (NotificationProperty)Enum.Parse(typeof(NotificationProperty), notificationPropertyName);
                string notificationPropertyValue = notificationProperties[notificationPropertyName];
                partnerNotificationRequest.NotificationProperties.Add(notificationProperty, notificationPropertyValue);
            }

            string uri = String.Format("{0}notification", HelperLibrary.PartnerServiceUrl);

            string requestBody = HelperLibrary.Deserialize(partnerNotificationRequest);

            WebResponse response = HelperLibrary.SendRequest(uri, "POST", string.Empty, false, requestBody, "text/xml", out responseString);

            return responseString;
        }

        /// <summary>
        /// Calls the partner version of DeleteNotificationBySession
        /// </summary>
        /// <param name="gameId">The gameID</param>
        /// <param name="sessionId">The session ID whose notifications are to be deleted</param>
        /// <param name="gamertags">The gamertags on the session</param>
        /// <returns>The webresponse responsestream</returns>
        public static string PartnerDeleteNotificationBySession(string gameId, string sessionId, string gamertags)
        {
            string ret = string.Empty;

            // gameIdString = "7777";
            // sessionId = "00000000-ed57-4617-962d-bb743edd0cb5";
            // gamertags = "mpdev1;;;;mpdev2;mpdev3";
            string uri = String.Format("{0}deletenotifications", HelperLibrary.PartnerServiceUrl);

            PartnerDeleteRequest partnerDeleteRequest = new PartnerDeleteRequest();
            partnerDeleteRequest.GameId = uint.Parse(gameId);
            partnerDeleteRequest.SessionId = sessionId;
            partnerDeleteRequest.Players = gamertags;

            string requestBody = HelperLibrary.Deserialize(partnerDeleteRequest);

            WebResponse response = HelperLibrary.SendRequest(uri, "POST", string.Empty, false, requestBody, "text/xml", out ret);

            return ret;
        }

        /// <summary>
        /// Calls the partner version of PostGameResult
        /// </summary>
        /// <param name="platformType">The platform type</param>
        /// <param name="locale">The locale</param>
        /// <param name="gamertag">The gamertag of the user who finished a game</param>
        /// <param name="gameId">The game ID that was finished</param>
        /// <param name="gameResultId">The game result ID (should be a fresh guid)</param>
        /// <param name="gameOutcome">The outcome of the game</param>
        /// <returns>The webresponse responsestream</returns>
        public static string PartnerPostGameResult(string platformType, string locale, string gamertag, string gameId, string gameResultId, string gameOutcome)
        {
            string ret = string.Empty;

            string uri = String.Format("{0}gameresults", HelperLibrary.PartnerServiceUrl);

            List<PartnerCompositeGameResult> resultList = new List<PartnerCompositeGameResult>();
            PartnerCompositeGameResult result = new PartnerCompositeGameResult();
            result.GameResult = new Gds.Contracts.GameResult();

            result.PlatformType = platformType;
            result.Locale = locale;
            result.Gamertag = gamertag;
            result.GameResult.GameId = uint.Parse(gameId);
            result.GameResult.GameResultId = new Guid(gameResultId);
            result.GameResult.Outcome = gameOutcome;

            resultList.Add(result);

            string requestBody = HelperLibrary.Deserialize(resultList);

            WebResponse response = HelperLibrary.SendRequest(uri, "POST", string.Empty, false, requestBody, "text/xml", out ret);

            return ret;            
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LIVEnAuthClient\LiveNTool\SessionManagementService.cs ===
﻿//------------------------------------------------------------------------------------------------- 
// <copyright file="SessionManagementService.cs" company="Microsoft" author="a-thkuo">
//      Copyright © .  All rights reserved.
// </copyright>
// <summary>Code to test Session Management Service API</summary>
//-------------------------------------------------------------------------------------------------
namespace LIVEnTool
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Net;
    using System.Runtime.Serialization;
    using System.Text;
    using AsyncMultiplayer.SessionCommon;
    using LIVEnAuthClient;
    
    /// <summary>
    /// SessionManagementService class definition
    /// </summary>
    public class SessionManagementService
    {
        public static string CreateSession(string membername, string password)
        {
            string userToken = TokenService.GetNewUserToken(membername, password, HelperLibrary.TitleId, HelperLibrary.TitleVersion);
            string partnerToken = TokenService.GetPartnerToken(userToken, HelperLibrary.MultiplayerAudienceUri, HelperLibrary.TitleId, HelperLibrary.TitleVersion);
            return SessionManagementService.CreateSession(partnerToken);
        }

        /// <summary>
        /// Create a new session
        /// </summary>
        /// <param name="partnerToken">Partner's STS token</param>
        /// <returns>Response from the session creation request</returns>
        public static string CreateSession(string partnerToken)
        {
            string initialSessionState = string.Empty;

            CreationData cd = new CreationData();
            cd.GameID = 7777;
            cd.Variant = 1;
            cd.CanRemoveEmptySeats = true;
            cd.DisplayName = "CoolSession";
            cd.ReservedSeatsAvailable = 3;
            cd.TotalSeatsAvailable = 3;
            cd.SessionParameters = new byte[] { 1, 2, 3 };
            cd.InactivityWarning = new InactivityWarningBehavior();

            string uri = String.Format("{0}game/{1}", HelperLibrary.SessionServiceUrl, "7777");

            string ret = string.Empty;

            string requestBody = HelperLibrary.Deserialize(cd);

            WebResponse response = HelperLibrary.SendRequest(uri, "POST", partnerToken, true, requestBody, "application/xml", out ret);

            return ret;                
        }

        public static string CreateSession(
            string membername,
            string password,
            string gameId,
            string variant,
            string canRemoveEmptySeats,
            string displayName,
            string reservedSeatsAvailable,
            string totalSeatsAvailable,
            string sessionParameters,
            string inactivityWarningAction,
            string inactivityWarningInterval,
            string inactivityWarningMaxNudges)
        {
            string partnerToken = TokenService.GetPartnerToken(membername, password, HelperLibrary.MultiplayerAudienceUri, HelperLibrary.TitleId, HelperLibrary.TitleVersion);
            return SessionManagementService.CreateSession(
                partnerToken,
                gameId,
                variant,
                canRemoveEmptySeats,
                displayName,
                reservedSeatsAvailable,
                totalSeatsAvailable,
                sessionParameters,
                inactivityWarningAction,
                inactivityWarningInterval,
                inactivityWarningMaxNudges);
        }

        /// <summary>
        /// Create a new session
        /// </summary>
        /// <param name="partnerToken">Partner's STS token</param>
        /// <returns>Response from the session creation request</returns>
        public static string CreateSession(
            string partnerToken,
            string gameId,
            string variant,
            string canRemoveEmptySeats,
            string displayName,
            string reservedSeatsAvailable,
            string totalSeatsAvailable,
            string sessionParameters,
            string inactivityWarningAction,
            string inactivityWarningInterval,
            string inactivityWarningMaxNudges)        
        {
            string ret = string.Empty;

            CreationData cd = new CreationData();
            cd.GameID = uint.Parse(gameId);
            cd.Variant = int.Parse(variant);
            cd.CanRemoveEmptySeats = bool.Parse(canRemoveEmptySeats);
            cd.DisplayName = displayName;
            cd.ReservedSeatsAvailable = int.Parse(reservedSeatsAvailable);
            cd.TotalSeatsAvailable = int.Parse(totalSeatsAvailable);

            cd.SessionParameters = HelperLibrary.StringToByteArray(sessionParameters);
            
            cd.InactivityWarning = new InactivityWarningBehavior();
            cd.InactivityWarning.Action = (InactivityWarningAction)Enum.Parse(typeof(InactivityWarningAction), inactivityWarningAction);
            cd.InactivityWarning.Interval = int.Parse(inactivityWarningInterval);
            cd.InactivityWarning.MaxNumberOfNudges = int.Parse(inactivityWarningMaxNudges);

            string uri = String.Format("{0}game/{1}", HelperLibrary.SessionServiceUrl, gameId);
            
            string requestBody = HelperLibrary.Deserialize(cd);

            WebResponse response = HelperLibrary.SendRequest(uri, "POST", partnerToken, true, requestBody, "application/xml", out ret);

            return ret;
        }

        public static string JoinSession(
            string membername,
            string password,
            string sessionIdForUrl,
            string sessionIdForBody,
            string gameId,
            string seatIndex,
            string seatParameters)
        {
            string partnerToken = TokenService.GetPartnerToken(membername, password, HelperLibrary.MultiplayerAudienceUri, HelperLibrary.TitleId, HelperLibrary.TitleVersion);
            return SessionManagementService.JoinSession(partnerToken, sessionIdForUrl, sessionIdForBody, gameId, seatIndex, seatParameters);
        }

        public static string JoinSession(
            string partnerToken,
            string sessionIdForUrl,
            string sessionIdForBody,
            string gameId,
            string seatIndex,
            string seatParameters)
        {
            string ret = string.Empty;

            JoinData joinData = new JoinData();
            joinData.GameID = uint.Parse(gameId);
            joinData.SeatIndex = int.Parse(seatIndex);
            joinData.SessionID = sessionIdForBody;

            joinData.SeatParameters = HelperLibrary.StringToByteArray(seatParameters);
            
            string uri = String.Format("{0}session/{1}", HelperLibrary.SessionServiceUrl, sessionIdForUrl);

            string requestBody = HelperLibrary.Deserialize(joinData);

            WebResponse response = HelperLibrary.SendRequest(uri, "POST", partnerToken, true, requestBody, "application/xml", out ret);

            return ret;
        }

        public static string RejectInvitation(string membername, string password, string sessionId, string gameId)
        {
            string partnerToken = TokenService.GetPartnerToken(membername, password, HelperLibrary.MultiplayerAudienceUri, HelperLibrary.TitleId, HelperLibrary.TitleVersion);
            return SessionManagementService.RejectInvitation(partnerToken, sessionId, gameId);
        }

        public static string RejectInvitation(string partnerToken, string sessionId, string gameId)
        {
            string ret = string.Empty;

            string uri = String.Format("{0}invite/{1}/{2}", HelperLibrary.SessionServiceUrl, sessionId, gameId);

            WebResponse response = HelperLibrary.SendRequest(uri, "DELETE", partnerToken, true, string.Empty, "application/xml", out ret);

            return ret;
        }

        public static string LeaveSession(string membername, string password, string sessionId, string gameId)
        {
            string partnerToken = TokenService.GetPartnerToken(membername, password, HelperLibrary.MultiplayerAudienceUri, HelperLibrary.TitleId, HelperLibrary.TitleVersion);
            return SessionManagementService.LeaveSession(partnerToken, sessionId, gameId);
        }

        public static string LeaveSession(string partnerToken, string sessionId, string gameId)
        {
            string ret = string.Empty;

            string uri = String.Format("{0}session/{1}/{2}", HelperLibrary.SessionServiceUrl, sessionId, gameId);

            WebResponse response = HelperLibrary.SendRequest(uri, "DELETE", partnerToken, true, string.Empty, "application/xml", out ret);

            return ret;
        }

        public static string ModifySession(
           string membername,
           string password,
           string sessionId,
           string gameId,
           string canRemoveEmptySeats,
           string displayName,
           string reservedSeatsAvailable,
           string totalSeatsAvailable,
           string isFriendsOnly,
           string sessionParameters,
           string inactivityWarningAction,
           string inactivityWarningInterval,
           string inactivityWarningMaxNudges)
        {
            string partnerToken = TokenService.GetPartnerToken(membername, password, HelperLibrary.MultiplayerAudienceUri, HelperLibrary.TitleId, HelperLibrary.TitleVersion);
            return SessionManagementService.ModifySession(
                partnerToken,
                sessionId,
                gameId,
                canRemoveEmptySeats,
                displayName,
                reservedSeatsAvailable,
                totalSeatsAvailable,
                isFriendsOnly,
                sessionParameters,
                inactivityWarningAction,
                inactivityWarningInterval,
                inactivityWarningMaxNudges);
        }

        public static string ModifySession(
            string partnerToken,
            string sessionId,
            string gameId,
            string canRemoveEmptySeats,
            string displayName,
            string reservedSeatsAvailable,
            string totalSeatsAvailable,
            string isFriendsOnly,
            string sessionParameters,
            string inactivityWarningAction,
            string inactivityWarningInterval,
            string inactivityWarningMaxNudges)
        {
            string ret = string.Empty;

            ModificationData modificationData = new ModificationData();
            modificationData.CanRemoveEmptySeats = bool.Parse(canRemoveEmptySeats);
            modificationData.DisplayName = displayName;
            modificationData.ReservedSeatsAvailable = int.Parse(reservedSeatsAvailable);
            modificationData.TotalSeatsAvailable = int.Parse(totalSeatsAvailable);
            modificationData.IsFriendsOnly = bool.Parse(isFriendsOnly);

            modificationData.SessionParameters = HelperLibrary.StringToByteArray(sessionParameters);

            modificationData.InactivityWarning = new InactivityWarningBehavior();
            modificationData.InactivityWarning.Action = (InactivityWarningAction)Enum.Parse(typeof(InactivityWarningAction), inactivityWarningAction);
            modificationData.InactivityWarning.Interval = int.Parse(inactivityWarningInterval);
            modificationData.InactivityWarning.MaxNumberOfNudges = int.Parse(inactivityWarningMaxNudges);

            string uri = String.Format("{0}session/{1}/{2}", HelperLibrary.SessionServiceUrl, sessionId, gameId);

            string requestBody = HelperLibrary.Deserialize(modificationData);

            WebResponse response = HelperLibrary.SendRequest(uri, "PUT", partnerToken, true, requestBody, "application/xml", out ret);

            return ret;
        }

        public static string ViewSession(string membername, string password, string sessionId, string gameId)
        {
            string partnerToken = TokenService.GetPartnerToken(membername, password, HelperLibrary.MultiplayerAudienceUri, HelperLibrary.TitleId, HelperLibrary.TitleVersion);
            return SessionManagementService.ViewSession(partnerToken, sessionId, gameId);
        }

        public static string ViewSession(string partnerToken, string sessionId, string gameId)
        {
            string ret = string.Empty;

            string uri = String.Format("{0}session/{1}/{2}", HelperLibrary.SessionServiceUrl, sessionId, gameId);

            WebResponse response = HelperLibrary.SendRequest(uri, "GET", partnerToken, true, string.Empty, "application/xml", out ret);

            return ret;
        }

        public static string ViewSessionSummaries(
           string membername,
           string password
           )
        {
            string partnerToken = TokenService.GetPartnerToken(membername, password, HelperLibrary.MultiplayerAudienceUri, HelperLibrary.TitleId, HelperLibrary.TitleVersion);
            string ret = string.Empty;

            string uri = String.Format(
                "{0}game",
                HelperLibrary.SessionServiceUrl
                );

            WebResponse response = HelperLibrary.SendRequest(uri, "GET", partnerToken, true, string.Empty, "application/xml", out ret);

            return ret;
        }

        public static string ViewSessionSummaries(
           string membername,
           string password,
           string gameId,
           string variant,
           string lastSession,
           string lastGame,
           string maxSessions,
           string showSessionType
           )
        {
            string partnerToken = TokenService.GetPartnerToken(membername, password, HelperLibrary.MultiplayerAudienceUri, HelperLibrary.TitleId, HelperLibrary.TitleVersion);
            return SessionManagementService.ViewSessionSummaries(partnerToken, gameId, variant, lastSession, lastGame, maxSessions, showSessionType);
        }

        public static string ViewSessionSummaries(
            string partnerToken, 
            string gameId,
            string variant,
            string lastSession,
            string lastGame,
            string maxSessions,
            string showSessionType
            )
        {
            string ret = string.Empty;

            string uri = String.Format(
                "{0}game?game={1}&variant={2}&lastSession={3}&lastGame={4}&max={5}&showSessionType={6}", 
                HelperLibrary.SessionServiceUrl, 
                gameId,
                variant,
                lastSession,
                lastGame,
                maxSessions,
                showSessionType);

            WebResponse response = HelperLibrary.SendRequest(uri, "GET", partnerToken, true, string.Empty, "application/xml", out ret);

            return ret;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LIVEnAuthClient\LiveNTool\UserDataPartnerService.cs ===
﻿//------------------------------------------------------------------------------------------------- 
// <copyright file="UserDataService.cs" company="Microsoft" author="adamdep">
//      Copyright © .  All rights reserved.
// </copyright>
// <summary>Code to test User Data Partner Service API</summary>
//-------------------------------------------------------------------------------------------------
namespace LIVEnTool
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Net;
    using System.Text;
    using Leet.UserGameData.DataContracts;
    using LIVEnAuthClient;
    using Gds.Contracts;

    /// <summary>
    /// UserDataPartnerService class definition
    /// </summary>
    public class UserDataPartnerService
    {
        public static string GetGames(string membername, string password, string gamertag, string pageStart, string pageCount)
        {
            string partnerToken = TokenService.GetPartnerToken(membername, password, HelperLibrary.UserDataAudienceUri, HelperLibrary.TitleId, HelperLibrary.TitleVersion);
            return GetGames(partnerToken, gamertag, pageStart, pageCount);
        }

        public static string GetGames(string partnerToken, string gamertag, string pageStart, string pageCount)
        {
            string games = string.Empty;

            string uri = String.Format("{0}games?gamertag={1}&pageStart={2}&pageCount={3}", HelperLibrary.GameDataPartnerServiceUrl, gamertag,pageStart,pageCount);
            
            Console.WriteLine("Sending GET request for user profile to: " + HelperLibrary.GameDataPartnerServiceUrl);

            string ret = string.Empty;

            WebResponse response = HelperLibrary.SendRequest(uri, "GET", partnerToken, true, null, "application/xml", out ret);
            
            return ret;
        }

        public static string GetAchievementsPartner(string membername, string password, string gameId, string gamertagList)
        {
            string partnerToken = TokenService.GetPartnerToken(membername, password, HelperLibrary.UserDataAudienceUri, HelperLibrary.TitleId, HelperLibrary.TitleVersion);
            return GetAchievementsPartner(partnerToken, gameId, gamertagList);
        }

        public static string GetAchievementsPartner(string partnerToken, string gameId, string gamertagList)
        {
            string games = string.Empty;

            //Create AchievementsRequest from gamertagList CSV string
            AchievementsRequest achievementsReq = new AchievementsRequest();
            achievementsReq.GamerTags = new List<Gamertag>();
            achievementsReq.GameId = gameId;

            string[] gtList = gamertagList.Split(new char[1] { ',' });

            foreach( string s in gtList)
            {
                Gamertag tempGamertag = new Gamertag();
                tempGamertag.Name = s;
                achievementsReq.GamerTags.Add(tempGamertag);
            }

            string uri = String.Format("{0}achievements/get", HelperLibrary.GameDataPartnerServiceUrl);
            
            string ret = string.Empty;
            string requestBody = HelperLibrary.Deserialize(achievementsReq);

            WebResponse response = HelperLibrary.SendRequest(uri, "POST", partnerToken, true, requestBody, "application/xml", out ret);

            return ret;
        }

        public static string GetMessages(string membername, string password, string pageStart, string pageCount)
        {
            // TODO: update the method name to GetMessageSummaries. Remove the pagination parameters and add hashcode. 
            string partnerToken = TokenService.GetPartnerToken(membername, password, HelperLibrary.UserDataAudienceUri, HelperLibrary.TitleId, HelperLibrary.TitleVersion);
            return GetMessages(partnerToken, pageStart, pageCount);
        }

        public static string GetMessages(string partnerToken, string pageStart, string pageCount)
        {
            string uri = String.Format("{0}summarylist?", HelperLibrary.MessagePartnerServiceUrl);

            Console.WriteLine("Sending GET request for messages to: " + HelperLibrary.MessagePartnerServiceUrl);

            string ret = string.Empty;

            WebResponse response = HelperLibrary.SendRequest(uri, "GET", partnerToken, true, null, "application/xml", out ret);

            return ret;
        }

        public static string GetMessageDetails(string membername, string password, string messageId)
        {
            string partnerToken = TokenService.GetPartnerToken(membername, password, HelperLibrary.UserDataAudienceUri, HelperLibrary.TitleId, HelperLibrary.TitleVersion);
            return GetMessageDetails(partnerToken, messageId);
        }

        public static string GetMessageDetails(string partnerToken, string messageId)
        {
            string uri = String.Format("{0}messagedetails?messageId={1}", HelperLibrary.MessagePartnerServiceUrl, messageId);

            Console.WriteLine("Sending GET request for message details to: " + HelperLibrary.MessagePartnerServiceUrl);

            string ret = string.Empty;

            WebResponse response = HelperLibrary.SendRequest(uri, "GET", partnerToken, true, null, "application/xml", out ret);

            return ret;
        }

        public static string SendMessage(string membername, string password, string recipients, string messageText)
        {
            string partnerToken = TokenService.GetPartnerToken(membername, password, HelperLibrary.UserDataAudienceUri, HelperLibrary.TitleId, HelperLibrary.TitleVersion);
            return SendMessage(partnerToken, recipients, messageText);
        }

        public static string SendMessage(string partnerToken, string recipients, string messageText)
        {
            //Create SendMessageRequest from gamertagList CSV string
            SendMessageRequest sendMsgRequest = new SendMessageRequest();
            sendMsgRequest.Recipients = new List<string>();
            sendMsgRequest.MessageText = messageText;

            string[] recipientsList = recipients.Split(new char[1] { ',' });

            foreach (string s in recipientsList)
            {
                sendMsgRequest.Recipients.Add(s);
            }

            string uri = String.Format("{0}send", HelperLibrary.MessagePartnerServiceUrl);

            string ret = string.Empty;
            string requestBody = HelperLibrary.Deserialize(sendMsgRequest);

            WebResponse response = HelperLibrary.SendRequest(uri, "POST", partnerToken, true, requestBody, "application/xml", out ret);

            return ret;
        }

        public static string DeleteMessage(string membername, string password, string messageId)
        {
            string partnerToken = TokenService.GetPartnerToken(membername, password, HelperLibrary.UserDataAudienceUri, HelperLibrary.TitleId, HelperLibrary.TitleVersion);
            return DeleteMessage(partnerToken, messageId);
        }

        public static string DeleteMessage(string partnerToken, string messageId)
        {
            string uri = String.Format("{0}delete?messageId={1}", HelperLibrary.MessagePartnerServiceUrl, messageId);

            string ret = string.Empty;

            WebResponse response = HelperLibrary.SendRequest(uri, "DELETE", partnerToken, true, null, "application/xml", out ret);

            return ret;
        }

        public static string DeleteMessageAndBlockGamertag(string membername, string password, string gamertag, string messageId)
        {
            string partnerToken = TokenService.GetPartnerToken(membername, password, HelperLibrary.UserDataAudienceUri, HelperLibrary.TitleId, HelperLibrary.TitleVersion);
            return DeleteMessageAndBlockGamertag(partnerToken,messageId);
        }

        public static string DeleteMessageAndBlockGamertag(string partnerToken,string messageId)
        {  
            string uri = String.Format("{0}block?messageId={2}", HelperLibrary.MessagePartnerServiceUrl,messageId);

            string ret = string.Empty;

            WebResponse response = HelperLibrary.SendRequest(uri, "DELETE", partnerToken, true, null, "application/xml", out ret);

            return ret;
        }

        public static string AddFriend(string membername, string password, string gamertag)
        {
            string partnerToken = TokenService.GetPartnerToken(membername, password, HelperLibrary.UserDataAudienceUri, HelperLibrary.TitleId, HelperLibrary.TitleVersion);
            return AddFriend(partnerToken, gamertag);
        }

        public static string AddFriend(string partnerToken, string gamertag)
        {
            string uri = String.Format("{0}add?gamertag={1}", HelperLibrary.FriendPartnerServiceUrl, gamertag);

            string ret = string.Empty;

            WebResponse response = HelperLibrary.SendRequest(uri, "POST", partnerToken, true, null, "application/xml", out ret);

            return ret;
        }

        public static string AcceptFriend(string membername, string password, string gamertag)
        {
            string partnerToken = TokenService.GetPartnerToken(membername, password, HelperLibrary.UserDataAudienceUri, HelperLibrary.TitleId, HelperLibrary.TitleVersion);
            return AcceptFriend(partnerToken, gamertag);
        }

        public static string AcceptFriend(string partnerToken, string gamertag)
        {
            string uri = String.Format("{0}accept?gamertag={1}", HelperLibrary.FriendPartnerServiceUrl, gamertag);

            string ret = string.Empty;

            WebResponse response = HelperLibrary.SendRequest(uri, "POST", partnerToken, true, null, "application/xml", out ret);

            return ret;
        }

        public static string RejectFriendRequest(string membername, string password, string gamertag)
        {
            string partnerToken = TokenService.GetPartnerToken(membername, password, HelperLibrary.UserDataAudienceUri, HelperLibrary.TitleId, HelperLibrary.TitleVersion);
            return RejectFriendRequest(partnerToken, gamertag);
        }

        public static string RejectFriendRequest(string partnerToken, string gamertag)
        {
            string uri = String.Format("{0}reject?gamertag={1}", HelperLibrary.FriendPartnerServiceUrl, gamertag);

            string ret = string.Empty;

            WebResponse response = HelperLibrary.SendRequest(uri, "POST", partnerToken, true, null, "application/xml", out ret);

            return ret;
        }

        public static string DeleteFriend(string membername, string password, string gamertag)
        {
            string partnerToken = TokenService.GetPartnerToken(membername, password, HelperLibrary.UserDataAudienceUri, HelperLibrary.TitleId, HelperLibrary.TitleVersion);
            return DeleteFriend(partnerToken, gamertag);
        }

        public static string DeleteFriend(string partnerToken, string gamertag)
        {
            string uri = String.Format("{0}gamertag={1}", HelperLibrary.FriendPartnerServiceUrl, gamertag);

            string ret = string.Empty;

            WebResponse response = HelperLibrary.SendRequest(uri, "DELETE", partnerToken, true, null, "application/xml", out ret);

            return ret;
        }

        public static string GetProfile(string membername, string password, string sectionFlags, string friendsSectionFlags, string gamertag)
        {
            string partnerToken = TokenService.GetPartnerToken(membername, password, HelperLibrary.UserDataAudienceUri, HelperLibrary.TitleId, HelperLibrary.TitleVersion);
            return GetProfile(partnerToken, sectionFlags, friendsSectionFlags, gamertag);
        }

        public static string GetProfile(string partnerToken, string sectionFlags, string friendsSectionFlags, string gamertag)
        {
            string uri = String.Format("{0}profile?sectionFlags={1}&friendsSectionFlags={2}&gamertag={3}", HelperLibrary.ProfilePartnerServiceUrl, sectionFlags, friendsSectionFlags, gamertag);

            string ret = string.Empty;

            WebResponse response = HelperLibrary.SendRequest(uri, "GET", partnerToken, true, null, "application/xml", out ret);

            return ret;
        }

        public static string PostProfile(string membername, 
            string password,
            string bio,
            string gamerzone,
            string location,
            string motto,
            string name,
            string sectionFlags,
            string voiceAndText,
            string video,
            string gamerProfile,
            string onlineStatus,
            string memberContent,
            string playedGames,
            string friendsList)
        {
            string partnerToken = TokenService.GetPartnerToken(membername, password, HelperLibrary.UserDataAudienceUri, HelperLibrary.TitleId, HelperLibrary.TitleVersion);
            return PostProfile(partnerToken,
                bio,
                gamerzone,
                location,
                motto,
                name,
                sectionFlags,
                voiceAndText,
                video,
                gamerProfile,
                onlineStatus,
                memberContent,
                playedGames,
                friendsList);
        }

        public static string PostProfile(string partnerToken,
            string bio,
            string gamerzone,
            string location,
            string motto,
            string name,
            string sectionFlags,
            string voiceAndTextPrivacySetting,
            string videoPrivacySetting,
            string gamerProfilePrivacySetting,
            string onlineStatusPrivacySetting,
            string memberContentPrivacySetting,
            string playedGamesPrivacySetting,
            string friendsListPrivacySetting)
        {
            ProfileEx postProfileRequest = new ProfileEx();

            postProfileRequest.SectionFlags = long.Parse(sectionFlags) ;

            postProfileRequest.ProfileProperties = new XmlSerializableDictionary<ProfileProperty, object>();
            postProfileRequest.ProfileProperties[ProfileProperty.Bio] = bio;
            postProfileRequest.ProfileProperties[ProfileProperty.GamerZone] = gamerzone;
            postProfileRequest.ProfileProperties[ProfileProperty.Location] = location;
            postProfileRequest.ProfileProperties[ProfileProperty.Motto] = motto;
            postProfileRequest.ProfileProperties[ProfileProperty.Name] = name;

            postProfileRequest.PrivacySettings = new XmlSerializableDictionary<PrivacySetting, uint>();
            postProfileRequest.PrivacySettings[PrivacySetting.VoiceAndText] = uint.Parse(voiceAndTextPrivacySetting);
            postProfileRequest.PrivacySettings[PrivacySetting.Video] = uint.Parse(videoPrivacySetting);
            postProfileRequest.PrivacySettings[PrivacySetting.GamerProfile] = uint.Parse(gamerProfilePrivacySetting);
            postProfileRequest.PrivacySettings[PrivacySetting.OnlineStatus] = uint.Parse(onlineStatusPrivacySetting);
            postProfileRequest.PrivacySettings[PrivacySetting.MemberContent] = uint.Parse(memberContentPrivacySetting);
            postProfileRequest.PrivacySettings[PrivacySetting.PlayedGames] = uint.Parse(playedGamesPrivacySetting);
            postProfileRequest.PrivacySettings[PrivacySetting.FriendsList] = uint.Parse(friendsListPrivacySetting);

            string uri = String.Format("{0}", HelperLibrary.ProfilePartnerServiceUrl);

            string ret = string.Empty;
            string requestBody = HelperLibrary.Deserialize(postProfileRequest);

            WebResponse response = HelperLibrary.SendRequest(uri, "POST", partnerToken, true, requestBody, "application/xml", out ret);

            return ret;
        }

        public static string UpdatePresence(string membername, string password)
        {
            string partnerToken = TokenService.GetPartnerToken(membername, password, HelperLibrary.UserDataAudienceUri, HelperLibrary.TitleId, HelperLibrary.TitleVersion);
            return UpdatePresence(partnerToken);
        }

        public static string UpdatePresence(string partnerToken)
        {
            string uri = String.Format("{0}update", HelperLibrary.PresencePartnerServiceUrl);

            string ret = string.Empty;

            WebResponse response = HelperLibrary.SendRequest(uri, "POST", partnerToken, true, null, "application/xml", out ret);

            return ret;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LIVEnAuthClient\LiveNTool\TestCollection.cs ===
﻿namespace LIVEnTool
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Text;
    using System.Xml.Linq;

    public static class TestCollection
    {
        internal static Dictionary<string, List<ServiceTest>> testsByServiceContainer = new Dictionary<string, List<ServiceTest>>();

        private const string configFile = @".\LIVEnToolTests.xml";

        public static List<string> GetServices()
        {
            List<string> ret = new List<string>();
            foreach(string service in TestCollection.testsByServiceContainer.Keys)
            {
                ret.Add(service);
            }

            return ret;
        }

        public static string GetServiceContainer(string testName)
        {
            string ret = string.Empty;
            bool found = false;

            foreach (List<ServiceTest> testList in TestCollection.testsByServiceContainer.Values)
            {
                foreach (ServiceTest test in testList)
                {
                    if (test.TestName == testName)
                    {
                        ret = test.ServiceType;
                        found = true;
                        break;
                    }
                }
                if (found)
                {
                    break;
                }
            }

            return ret;
        }

        public static List<ServiceTest> GetTests()
        {
            List<ServiceTest> ret = new List<ServiceTest>();
            foreach (string service in TestCollection.GetServices())
            {
                foreach (ServiceTest test in TestCollection.GetTests(service))
                {
                    ret.Add(test);
                }
            }
            return ret;
        }

        public static List<ServiceTest> GetTests(string serviceContainer)
        {
            List<ServiceTest> ret = new List<ServiceTest>();
            try
            {
                ret = TestCollection.testsByServiceContainer[serviceContainer];
            }
            catch
            { 
            }
            
            return ret;
        }

        public static string GetVirtualInterfaceName(string testName)
        {
            string ret = string.Empty;
            bool found = false;

            foreach (List<ServiceTest> testList in TestCollection.testsByServiceContainer.Values)
            {
                foreach (ServiceTest test in testList)
                {
                    if (test.TestName == testName && test.VirtualInterfaceName != string.Empty)
                    {
                        ret = test.VirtualInterfaceName;
                        found = true;
                        break;
                    }
                }
                if (found)
                {
                    break;
                }
            }

            return ret;
        }

        public static string GetServiceEndpoint(string testName)
        {
            string ret = string.Empty;
            bool found = false;

            foreach (List<ServiceTest> testList in TestCollection.testsByServiceContainer.Values)
            {
                foreach (ServiceTest test in testList)
                {
                    if (test.TestName == testName)
                    {
                        ret = test.ServiceEndpointKey;
                        found = true;
                        break;
                    }
                }
                if (found)
                {
                    break;
                }
            }

            return ret;
        }

        static TestCollection()
        {
            CollectTestArgsFromXml(TestCollection.configFile);
        }

        internal static void CollectTestArgsFromXml(string xmlFile)
        {
            if (!File.Exists(xmlFile))
            {
                throw new IOException("Expected file " + xmlFile + " does not exist or inaccessible");
            }

            XElement testCollection = XElement.Load(xmlFile);

            foreach (XElement service in testCollection.Elements("Service"))
            {
                string serviceType = service.Attribute("Type").Value;
                List<ServiceTest> testInfos = new List<ServiceTest>();
                foreach (XElement test in service.Elements("Test"))
                {
                    string testName = test.Attribute("Name").Value;
                    string serviceEndpointKey = test.Attribute("ServiceEndpointAppConfigKey").Value;
                    string virtualInterfaceName = string.Empty;
                    
                    bool showInGui = false;
                    try
                    {
                        showInGui = bool.Parse(test.Attribute("ShowInGui").Value);
                    }
                    catch
                    {
                    }
                    bool showInConsoleApp = false;
                    try
                    {
                        showInConsoleApp = bool.Parse(test.Attribute("ShowInConsoleApp").Value);
                        if (showInConsoleApp)
                        {
                            virtualInterfaceName = test.Attribute("VirtualInterfaceName").Value;
                        }
                    }
                    catch
                    {
                    }

                    ServiceTest.TokenOption tokenRequired = (ServiceTest.TokenOption)Enum.Parse(typeof(ServiceTest.TokenOption), test.Attribute("TokenRequired").Value);

                    List<ServiceTest.ArgInfo> args = new List<ServiceTest.ArgInfo>();
                    foreach (XElement te in test.Element("TestArgs").Elements())
                    {
                        string argName = te.Name.LocalName;
                        string argDefaultValue = te.Value;
                        string argType = string.Empty;
                        if (te.Attribute("Type") != null)
                        {
                            argType = te.Attribute("Type").Value;
                        }

                        args.Add(new ServiceTest.ArgInfo(argName, argType, argDefaultValue));
                    }
                    testInfos.Add(new ServiceTest(
                        testName, 
                        serviceEndpointKey, 
                        tokenRequired,
                        args,
                        showInGui,
                        showInConsoleApp,
                        virtualInterfaceName));
                }
                testsByServiceContainer.Add(serviceType, testInfos);
            }
        }

        public static void TestProgram()
        {

            Console.WriteLine("Service to Test Container:");
            Console.WriteLine("==========================");
            foreach (var serviceTest in testsByServiceContainer)
            {
                Console.WriteLine("Service Type = {0}", serviceTest.Key);
                foreach (ServiceTest test in serviceTest.Value)
                {
                    Console.WriteLine("Test Name = {0}, Endpoint={1}, TokenOption={2}",
                        test.TestName,
                        test.ServiceEndpointKey,
                        test.TokenRequired.ToString());
                }
                Console.WriteLine("===========================================================");
            }

            Console.WriteLine();
            Console.WriteLine("Test to Argument:");
            Console.WriteLine("***************************");
            foreach (ServiceTest test in TestCollection.GetTests())
            {
                foreach (ServiceTest.ArgInfo arg in test.Arguments)
                {
                    Console.WriteLine("Test Name = {0}", test.TestName);
                    Console.WriteLine("Arg = {0}, Default Value = {1}", arg.Name, arg.DefaultValue);
                    Console.WriteLine("***********************************************************");
                }
            }
        }       
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LIVEnAuthClient\LiveNTool\TokenService.cs ===
﻿    //------------------------------------------------------------------------------------------------- 
// <copyright file="TokenService.cs" company="Microsoft" author="a-thkuo">
//      Copyright © .  All rights reserved.
// </copyright>
// <summary>Code to test getting a user token and partner token</summary>
//-------------------------------------------------------------------------------------------------
namespace LIVEnTool
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Net;
    using System.Text;
    using LIVEnAuthClient;

    /// <summary>
    /// TokenService class definition
    /// </summary>
    public class TokenService
    {
        /// <summary>
        /// Method to get the RPS ticket
        /// </summary>
        /// <param name="member">Member's user Id</param>
        /// <param name="password">Member's password</param>
        /// <returns>The RPS Ticket</returns>
        public static string GetRpsTicket(string member, string password)
        {
            Console.WriteLine("Sending GET request for user token to: {0}", HelperLibrary.StsUrl);

            string userToken = string.Empty;

            string rpsTicket = AccountService.GetRPSTicket(member, password);
            return rpsTicket;
        }

        /// <summary>
        /// Method to get user token (aka SPS token)
        /// </summary>
        /// <param name="member">Member's user Id</param>
        /// <param name="password">Member's password</param>
        /// <returns>The acquired STS token</returns>
        public static string GetNewUserToken(string rpsTicket, string titleId, string titleVersion)
        {            

            string userToken = LIVEnAuthClient.GenerateSTSTicket(
                            rpsTicket,
                            HelperLibrary.StsUrl,
                            HelperLibrary.PlatformId,
                            titleId,
                            titleVersion,
                            HelperLibrary.ClientVersion,
                            HelperLibrary.DeviceId);

            return userToken;
        }
        /// <summary>
        /// Method to get user token (aka SPS token)
        /// </summary>
        /// <param name="member">Member's user Id</param>
        /// <param name="password">Member's password</param>
        /// <returns>The acquired STS token</returns>
        public static string GetNewUserToken(string member, string password, string titleId, string titleVersion)
        {
            Console.WriteLine("Sending GET request for user token to: {0}", HelperLibrary.StsUrl);

            string userToken = string.Empty;

            string rpsTicket = AccountService.GetRPSTicket(member, password);
            if (rpsTicket == string.Empty)
            {
                throw new WebException("Failed to get RPS ticket");
            }

            userToken = LIVEnAuthClient.GenerateSTSTicket(
                            rpsTicket,
                            HelperLibrary.StsUrl,
                            HelperLibrary.PlatformId,
                            titleId,
                            titleVersion,
                            HelperLibrary.ClientVersion,
                            HelperLibrary.DeviceId);

            return userToken;
        }

        /// <summary>
        /// Method overload to get user token (aka SPS token)
        /// </summary>
        /// <param name="member">Member's user Id</param>
        /// <param name="password">Member's password</param>
        /// <param name="rpsTicket">RPS ticket</param>
        /// <returns>The acquired STS token</returns>
        public static string GetNewUserToken(string member, string password, string rpsTicket, string titleId, string titleVersion)
        {
            Console.WriteLine("Sending GET request for user token to: {0}", HelperLibrary.StsUrl);

            string userToken = string.Empty;

            if (rpsTicket == string.Empty)
            {
                throw new WebException("Given RPS ticket is empty");
            }

            userToken = LIVEnAuthClient.GenerateSTSTicket(
                            rpsTicket,
                            HelperLibrary.StsUrl,
                            HelperLibrary.PlatformId,
                            titleId,
                            titleVersion,
                            HelperLibrary.ClientVersion,
                            HelperLibrary.DeviceId);

            return userToken;
        }

        /// <summary>
        /// Method overload to get user token (aka SPS token)
        /// </summary>
        /// <param name="member">Member's user Id</param>
        /// <param name="password">Member's password</param>
        /// <param name="rpsTicket">The RPS ticket obtained before the request for the STS token</param>
        /// <returns>The acquired STS token</returns>
        public static string GetNewUserToken(string member, string password, string titleId, string titleVersion, out string rpsTicket)
        {
            Console.WriteLine("Sending GET request for user token to: {0}", HelperLibrary.StsUrl);

            string userToken = string.Empty;

            rpsTicket = AccountService.GetRPSTicket(member, password);
            if (rpsTicket == string.Empty)
            {
                throw new WebException("Failed to get RPS ticket");
            }

            userToken = LIVEnAuthClient.GenerateSTSTicket(
                            rpsTicket,
                            HelperLibrary.StsUrl,
                            HelperLibrary.PlatformId,
                            titleId,
                            titleVersion,
                            HelperLibrary.ClientVersion,
                            HelperLibrary.DeviceId);

            return userToken;
        }

        /// <summary>
        /// Method to get partner token
        /// </summary>
        /// <param name="userToken">The user token</param>
        /// <returns>The partner token acquired from the request, else it returns string.Empty</returns>
        public static string GetPartnerToken(string membername, string password, string audienceUri, string titleId, string titleVersion)
        {
            string userToken = TokenService.GetNewUserToken(membername, password, titleId, titleVersion);

            Console.WriteLine("Sending GET request for partner token to: " + HelperLibrary.StsUrl);

            string partnerToken = string.Empty;

            partnerToken = LIVEnAuthClient.GeneratePartnerSTSTicket(
                            HelperLibrary.StsUrl,
                            userToken,
                            titleId,
                            titleVersion, 
                            audienceUri);

            return partnerToken;
        }
        /// <summary>
        /// Method to get partner token
        /// </summary>
        /// <param name="userToken">The user token</param>
        /// <returns>The partner token acquired from the request, else it returns string.Empty</returns>
        public static string GetPartnerToken(string userToken, string audienceUri, string titleId, string titleVersion)
        {
            Console.WriteLine("Sending GET request for partner token to: " + HelperLibrary.StsUrl);

            string partnerToken = string.Empty;

            partnerToken = LIVEnAuthClient.GeneratePartnerSTSTicket(
                            HelperLibrary.StsUrl,
                            userToken,
                            titleId,
                            titleVersion,
                            audienceUri);

            return partnerToken;
        }

        /// <summary>
        /// Get current user's STS token.
        /// Checks the cached STS token in the file to see if it has already expired (i.e. exceeded its
        /// configured lifetime. If so, request and return a new token; otherwise, return the cached token.
        /// </summary>
        /// <param name="memberName">Member's user Id</param>
        /// <param name="password">Member's password</param>
        /// <returns>The user's STS token</returns>
        public static string GetCurrentUserToken(string memberName, string password, string titleId, string titleVersion)
        {
            string currentUserToken = string.Empty;
            FileStream fs = null;
            bool firstFileCreation = false;


            FileInfo fi = new FileInfo(Environment.ExpandEnvironmentVariables(HelperLibrary.StsTokenFilepath + "StsToken.sts"));

            if (!Directory.Exists(fi.DirectoryName))
            {
                Directory.CreateDirectory(fi.DirectoryName);
            }

            if (!fi.Exists || fi.Length < 100)
            {
                fs = fi.Open(FileMode.OpenOrCreate, FileAccess.ReadWrite);
                fi.Refresh();
                firstFileCreation = true;
            }

            TimeSpan timeDiff = DateTime.Now.Subtract(fi.LastWriteTime);

            // If the STS token file's lifetime is >= configured lifetime or the file was just
            // created the first time, get a new STS token and write/save to the file.  Else, read 
            // the STS token from the file and return the token.
            if (timeDiff.Minutes >= Int32.Parse(HelperLibrary.StsTokenLifetime) || firstFileCreation)
            {
                // Get a new SPS token
                currentUserToken = GetNewUserToken(memberName, password, titleId, titleVersion);
                if (currentUserToken == null || currentUserToken == string.Empty)
                {
                    Console.WriteLine("Failed to get a new user STS token");
                    return currentUserToken;
                }

                // delete current token cache and create a new one (so we get the new file creation timestamp)
                // and write the new user token to the token cache.
                if (firstFileCreation)
                {
                    using (fs)
                    {
                        byte[] token = new UTF8Encoding().GetBytes(currentUserToken);
                        fs.Write(token, 0, token.Length);
                    }
                }
                else
                {
                    fi.Delete();
                    using (fs = fi.Open(FileMode.CreateNew, FileAccess.ReadWrite))
                    {
                        byte[] token = new UTF8Encoding().GetBytes(currentUserToken);
                        fs.Write(token, 0, token.Length);
                    }
                }
            }
            else
            {
                using (fs = fi.Open(FileMode.Open, FileAccess.Read))
                {
                    byte[] token = new byte[fs.Length];
                    fs.Read(token, 0, token.Length);
                    currentUserToken = new UTF8Encoding(true).GetString(token);
                }
            }

            return currentUserToken;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LIVEnAuthClient\LiveNTool\UserDataService.cs ===
﻿//------------------------------------------------------------------------------------------------- 
// <copyright file="UserDataService.cs" company="Microsoft" author="a-thkuo">
//      Copyright © .  All rights reserved.
// </copyright>
// <summary>Code to test User Data Service API</summary>
//-------------------------------------------------------------------------------------------------
namespace LIVEnTool
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Net;
    using System.Text;
    using LIVEnAuthClient;

    /// <summary>
    /// UserDataService class definition
    /// </summary>
    public class UserDataService
    {
        static string LeaderboardQuery = HelperLibrary.GetLeaderboardUrl + "?format=xml&gameId={0}&variant={1}&property={2}&datagroup={3}&numRows={4}&rankStart={5}&socialGraph={6}";
        static string AchievementQuery = HelperLibrary.GetAchievementsUrl + "?format=xml&gameId={0}";
        static string ProfileQuery = HelperLibrary.GetProfileUrl + "?format=xml&sectionflags={0}";
        static string DatablobQuery = HelperLibrary.GetDatablobUrl + "?format=xml&datablobId={0}";

        public static string GetUserProfile(string membername, string password, string sectionFlags)
        {
            string userToken = TokenService.GetNewUserToken(membername, password, HelperLibrary.TitleId, HelperLibrary.TitleVersion);
            return UserDataService.GetUserProfile(userToken, sectionFlags);
        }

        /// <summary>
        /// Query user's profile
        /// </summary>
        /// <param name="userToken">User's SPS token</param>
        /// <returns>The profile of the user </returns>
        public static string GetUserProfile(string userToken, string sectionFlags )
        {
            string profile = string.Empty;
            string uri = String.Format(ProfileQuery, sectionFlags);

            WebRequest request = HelperLibrary.CreateRequest(uri, "GET", userToken, false, null, "application/xml");
            WebResponse response = HelperLibrary.SendRequest(request, out profile);
            
            return profile;
        }


        public static string GetLeaderboard(string membername, 
            string password, 
            string gameId, 
            string variant,
            string property,
            string datagroup,
            string rowNum,
            string rankStart,
            string socialGraph)
        {
            string userToken = TokenService.GetNewUserToken(membername, password, HelperLibrary.TitleId, HelperLibrary.TitleVersion);
            return UserDataService.GetLeaderboard(userToken, 
                                                  gameId, 
                                                  variant,
                                                  property,
                                                  datagroup,
                                                  rowNum,
                                                  rankStart,
                                                  socialGraph);
        }

        /// <summary>
        /// Method to get leaderboard
        /// </summary>
        /// <param name="userToken">Member's STS token</param>
        /// <param name="gameId">The game ID</param>
        /// <param name="variant">The game's variant</param>
        /// <returns>The leaderboard received from the request</returns>
        public static string GetLeaderboard(string userToken, 
            string gameId, 
            string variant, 
            string property, 
            string datagroup, 
            string rowNum, 
            string rankStart, 
            string socialGraph)
        {
            string leaderboard = string.Empty;

            string uri = String.Format(LeaderboardQuery,
                                                 gameId,
                                                variant,
                                                property,
                                                datagroup,
                                                rowNum,
                                                rankStart,
                                                socialGraph);

            WebRequest request = HelperLibrary.CreateRequest(uri, "GET", userToken, false, null, "application/xml");
            WebResponse response = HelperLibrary.SendRequest(request, out leaderboard);

            return leaderboard;
        }

        /// <summary>
        /// Returns a list of achievements for the current user and game
        /// </summary>
        /// <param name="membername"></param>
        /// <param name="password"></param>
        /// <param name="gameId"></param>
        /// <returns></returns>
        public static string GetAchievements(string membername,string password, string gameId)
        {
            string userToken = TokenService.GetNewUserToken(membername, password, HelperLibrary.TitleId, HelperLibrary.TitleVersion);

            return UserDataService.GetAchievements(userToken, gameId);
        }

        public static string GetAchievements(string userToken, string gameId)
        {
            string achievements = String.Empty;
            string uri = String.Format(AchievementQuery, gameId);

            WebRequest request = HelperLibrary.CreateRequest(uri, "GET", userToken, false, null, "application/xml");
            WebResponse response = HelperLibrary.SendRequest(request, out achievements);

            return achievements;
        }


        /// <summary>
        /// Returns the datablob for a given blob Id
        /// </summary>
        /// <param name="membername"></param>
        /// <param name="password"></param>
        /// <param name="blobId"></param>
        /// <returns></returns>
        public static string GetDatablob(string membername, string password, string blobId)
        {
            string userToken = TokenService.GetNewUserToken(membername, password, HelperLibrary.TitleId, HelperLibrary.TitleVersion);
            return UserDataService.GetDatablob(userToken, blobId);
        }

        public static string GetDatablob(string userToken, string blobId)
        {
            string blob = string.Empty;
            string uri = String.Format(DatablobQuery, blobId);

            WebRequest request = HelperLibrary.CreateRequest(uri, "GET", userToken, false, null, "application/xml");
            WebResponse response = HelperLibrary.SendRequest(request, out blob);

            return blob;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LIVEnAuthClient\LiveNTool\Properties\AssemblyInfo.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="AssemblyInfo.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="zhangxu">
//     Zhangwei Xu
// </author>
//
// <summary>
//  Assembly information
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="08/16/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("GetUserId")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("GetUserId")]
[assembly: AssemblyCopyright("Copyright © Microsoft 2010")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("319873e2-8af7-4072-b19f-bc3558e61c0f")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LIVEnAuthClient\LIVEnToolExe\Program.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="Program.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="amathes">
//     Andrew Mathes
// </author>
//
// <summary>
//  LIVEnTool console application
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="2010.05.06">
//     Class created
// </history>
//-------------------------------------------------------------------
// #define __DEBUG__
namespace LIVEnTool
{
    using System;
    using System.Collections.Generic;
    using System.Collections.Specialized;
    using System.Configuration;
    using System.Diagnostics;
    using System.IO;
    using System.Linq;
    using System.Net;
    using System.Runtime.Serialization;
    using System.Text;
    using LIVEnTool;

    /// <summary>
    /// Main program for the tool
    /// </summary>
    public class ConsoleApplication
    {
        #region Fields
        /// <summary>
        /// The name of this application as it will appear in the EventLog
        /// </summary>
        private const string ApplicationName = "LIVEnToolConsoleApp";
        #endregion

        #region Types

        /// <summary>
        /// Enum values for exit code. 
        /// </summary>
        private enum ExitCode
        {
            /// <summary>
            /// The operation was successful and get response 
            /// </summary>
            Success = 0,

            /// <summary>
            /// There is no response. 
            /// </summary>
            NoResponse = 1,

            /// <summary>
            /// There is something wrong with the command. 
            /// </summary>
            InvalidArgument = 2,

            /// <summary>
            /// There is error in the operation. 
            /// </summary>
            Error = 3
        }

        #endregion
        
        #region properties

        /// <summary>
        /// Gets or sets the ErrorCode
        /// </summary>
        private static ExitCode ErrorCode { get; set; }

        #endregion

        #region public main method

        /// <summary>
        /// The public main method
        /// </summary>
        /// <param name="args">Command-line args</param>
        /// <returns>returned status</returns>
        public static int Main(string[] args)
        {
            string environment = string.Empty;
            string testname = string.Empty;
            string userToken = string.Empty;
            bool cachedToken = false;
            
            if (args.Count() == 0)
            {
                PrintUsage();
                return (int)ExitCode.InvalidArgument;
            }

            if (args[0] == "/installcerts")
            {
                LoadConfigForCertInstallation();
                if (HelperLibrary.InstallClientCerts() != 0)
                {
                    return (int)ExitCode.InvalidArgument;
                }

                if (args.Count() == 1)
                {
                    return (int)ExitCode.Success;
                }
                else
                {
                    Console.WriteLine("Error: Arguments supplied after /installcerts will be ignored");
                    PrintUsage();
                    return (int)ExitCode.InvalidArgument;
                }
            }

            int argindex = 0;
            List<string> paramsList = new List<string>();
            
            while (argindex < args.Length)
            {
                switch (args[argindex])
                {
                    case "/env":
                        environment = args[argindex + 1];
                        argindex = argindex + 2;
                        break;

                    case "/test":
                        testname = args[argindex + 1];
                        argindex = argindex + 2;
                        break;

                    case "/cachetoken":
                        cachedToken = true;
                        argindex++;
                        break;                   

                    case "/help":
                        if (args.Length > argindex + 1)
                        {
                            ConsoleApplication.PrintDetailedUsage(args[argindex + 1]);
                            return (int)ExitCode.Success;
                        }
                        else
                        {
                            ConsoleApplication.PrintUsage();
                            return (int)ExitCode.Success;
                        }

                    default:
                        paramsList.Add(args[argindex++]);
                        break;
                }
            }

            if (testname == string.Empty || environment == string.Empty)
            {
                Console.WriteLine("Error: either /test or /env were not provided");
                PrintUsage();
                return (int)ExitCode.InvalidArgument;
            }
          
            HelperLibrary.LoadConfiguration(environment);
            HelperLibrary.GetCacheTokenParams();
            HelperLibrary.GetEventLogOption();

            HelperLibrary.WriteToEventLog(ApplicationName, "Test " + testname + " STARTED", EventLogEntryType.Information);

            // if cachetoken switch is not provided, use the default option from App.config
            if (cachedToken == false)
            {
                cachedToken = HelperLibrary.CacheStsToken;
            }

            ConsoleApplication.ErrorCode = ExitCode.Success;

            try
            {               
                // if requested to used a cached token, take the first 2 params as membername and password, then replace them with the cached token
                if (cachedToken)
                {
                    if (paramsList.Count >= 2)
                    {
                        string membername = paramsList[0];
                        string password = paramsList[1];

                        userToken = TokenService.GetCurrentUserToken(membername, password, HelperLibrary.TitleId, HelperLibrary.TitleVersion);

                        // replace the first two params with just the user token
                        paramsList.RemoveAt(0);
                        paramsList[0] = userToken;
                    }
                }

                string[] paramsArray = new string[paramsList.Count];
                for (int i = 0; i < paramsArray.Length; i++)
                {
                    paramsArray[i] = paramsList[i];
                }

                object responseObj = HelperLibrary.InvokeServiceMethod(testname, paramsArray);

                Console.WriteLine(responseObj.ToString());
            }
            catch (WebException we)
            {
                if (we.Response != null)
                {
                    Stream dataStream = we.Response.GetResponseStream();
                    string webResponse = string.Empty;
                    using (StreamReader reader = new StreamReader(dataStream))
                    {
                        webResponse = "Web response: " + reader.ReadToEnd();
                        Console.WriteLine(HelperLibrary.LogException(we, webResponse));
                    }

                    ConsoleApplication.ErrorCode = ExitCode.Error;
                    HelperLibrary.WriteToEventLog(ApplicationName, HelperLibrary.LogException(we, webResponse), EventLogEntryType.Error);
                }
                else
                {
                    Console.WriteLine(HelperLibrary.LogException(we));
                    HelperLibrary.WriteToEventLog(ApplicationName, HelperLibrary.LogException(we), EventLogEntryType.Error);
                    ConsoleApplication.ErrorCode = ExitCode.NoResponse;
                }
            }
            catch (ArgumentException ae)
            {
                Console.WriteLine(HelperLibrary.LogException(ae));
                HelperLibrary.WriteToEventLog(ApplicationName, HelperLibrary.LogException(ae), EventLogEntryType.Error);
                ConsoleApplication.ErrorCode = ExitCode.InvalidArgument;
            }
            catch (IOException ie)
            {
                Console.WriteLine(HelperLibrary.LogException(ie));
                HelperLibrary.WriteToEventLog(ApplicationName, HelperLibrary.LogException(ie), EventLogEntryType.Error);
                ConsoleApplication.ErrorCode = ExitCode.Error;
            }
            catch (Exception e)
            {
                string msg = String.Format("Exception on test {0}: ", testname);
                Console.WriteLine(HelperLibrary.LogException(e, msg));
                HelperLibrary.WriteToEventLog(ApplicationName, HelperLibrary.LogException(e, msg), EventLogEntryType.Error);
                ConsoleApplication.ErrorCode = ExitCode.Error;
            }

#if __DEPRECATED__
            if (environment.ToLower() == "self")
            {
                ServerSelfCheck.RestoreHostFile();
            }
#endif
            Console.WriteLine(string.Format("Exit status: {0}", Enum.GetName(typeof(ExitCode), ConsoleApplication.ErrorCode)));

#if __DEBUG__
            Console.WriteLine("Enter any key to exit");
            Console.ReadKey();
#endif

            if (ConsoleApplication.ErrorCode == ExitCode.Success)
            {
                HelperLibrary.WriteToEventLog(ApplicationName, "Test " + testname + " PASSED", EventLogEntryType.Information);
            }
            else
            {
                HelperLibrary.WriteToEventLog(ApplicationName, "Test " + testname + " FAILED", EventLogEntryType.Error);
            }

            return (int)ConsoleApplication.ErrorCode;
        }
        
        /// <summary>
        /// Load configuration for certificate installation
        /// </summary>
        private static void LoadConfigForCertInstallation()
        {
            HelperLibrary.CertPath = ConfigurationManager.AppSettings["CertPath"];
            HelperLibrary.CertInstaller = ConfigurationManager.AppSettings["CertInstaller"];
        }

        /// <summary>
        /// Display the test result
        /// </summary>
        /// <param name="msg">Message to display</param>
        /// <param name="testName">Current test name</param>
        /// <param name="topic">The topic of the message</param>
        private static void DisplayTestResult(string msg, string testName, string topic)
        {
            if (msg != string.Empty)
            {
                Console.WriteLine(string.Format("{0} is:", topic));
                Console.WriteLine(msg);
            }
            else
            {
                Console.WriteLine(string.Format("{0} is empty", topic));
            }

            Console.WriteLine(string.Format("{0} done", testName));
        }
        
        /// <summary>
        /// Print usage of the program
        /// </summary>
        private static void PrintUsage()
        {
            Console.WriteLine("To view the available <Test Name>s and valid parameters for each service, enter:");
            Console.WriteLine("    LIVEntoolExe.exe /help [Service Name]");
            Console.WriteLine();
            Console.WriteLine("    LIVEntoolExe.exe /installcerts");
            Console.WriteLine(); 
            Console.WriteLine("The expected input of the executable is:");
            Console.WriteLine("    LIVEntoolExe.exe[ /cachetoken <membername> <password>] /env <Environment> /test <Test Name> [Parameter1] [Parameter2] ... [ParameterN]");
            Console.WriteLine();
            Console.WriteLine("[Service Name] can be one of the following:");
            
            // get list of services to show
            List<string> services = TestCollection.GetServices();
            foreach (string service in services)
            {
                Console.WriteLine("        {0}", service);
            }

            Console.WriteLine();
            Console.WriteLine("<Environment> can be one of the following:");
            Console.WriteLine("    DEV      for Development");
            Console.WriteLine("    TEST     for TestNet");
            Console.WriteLine("    PART     for Partner");
            Console.WriteLine("    PROD     for Production");
            Console.WriteLine("    INT2     for Integration");
            Console.WriteLine("    STORAX   for Storax");
            Console.WriteLine("    STRESS   for Stress");
        }

        /// <summary>
        /// Detailed information on the tests available for the given service and the valid arguments for each test.
        /// </summary>
        /// <param name="service">The service</param>
        private static void PrintDetailedUsage(string service)
        {
            Console.WriteLine("Supported tests for service '" + service + "':");
            List<ServiceTest> tests = TestCollection.GetTests(service);
            foreach (ServiceTest test in tests)
            {
                if (test.ShowInConsoleApp)
                {
                    string serializedArgs = string.Empty;
                    foreach (ServiceTest.ArgInfo arg in test.Arguments)
                    {
                        serializedArgs += string.Format(" <{0}>", arg.Name);
                    }

                    Console.WriteLine("{0}{1}", test, serializedArgs);
                }
            }
        }

        /// <summary>
        /// Display configuration parameters
        /// </summary>
        /// <param name="environment">The target environment</param>
        private static void DisplayConfigParams(string environment)
        {
            Console.WriteLine("Configuration parameters for " + environment.ToUpper() + " environment:");
            Console.WriteLine("Title ID = " + HelperLibrary.TitleId);
            Console.WriteLine("Title Version = " + HelperLibrary.TitleVersion);
            Console.WriteLine("Device ID = " + HelperLibrary.DeviceId);
            Console.WriteLine("Client Cert Thumbprint = " + HelperLibrary.ClientCertThumbprint);
            Console.WriteLine("Platform ID = " + HelperLibrary.PlatformId);
            Console.WriteLine("Language ID = " + HelperLibrary.LanguageId);
            Console.WriteLine("Country ID = " + HelperLibrary.CountryId);
            Console.WriteLine("Live ID Service Target = " + HelperLibrary.LiveIDServiceTarget);
            Console.WriteLine("STS = " + HelperLibrary.StsUrl);
            Console.WriteLine("XUACS = " + HelperLibrary.XuacsUrl);
            Console.WriteLine("Session Service = " + HelperLibrary.SessionServiceUrl);
            Console.WriteLine("Leaderboard URI = " + HelperLibrary.GetLeaderboardUrl);
            Console.WriteLine("Achivements URI = " + HelperLibrary.GetAchievementsUrl);
            Console.WriteLine("Datablob URI = " + HelperLibrary.GetDatablobUrl);
            Console.WriteLine("UserProfile Service URI = " + HelperLibrary.GetProfileUrl);
            Console.WriteLine("Notification Service URI = " + HelperLibrary.NotificationServiceUrl);
            Console.WriteLine("Reward Service URI = " + HelperLibrary.RewardServiceUrl);
            Console.WriteLine("Partner Manifest Update Service URI = " + HelperLibrary.ManifestUpdatePartUrl);
            Console.WriteLine("Public Gamer Picture Update Partner URI = " + HelperLibrary.GamerPicUpdatePartUrl);
            Console.WriteLine("Partner Closet Asset Service URI = " + HelperLibrary.GetClosetAssetPartUrl);
        }
        #endregion       
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LIVEnAuthClient\LIVEnToolGUI\OutputViewer.cs ===
﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Windows.Forms;

namespace LIVEnToolGUI
{
    public partial class OutputViewer : Form
    {
        public OutputViewer(string message)
        {
            InitializeComponent();
            txtResponse.Text = message;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LIVEnAuthClient\LIVEnToolGUI\Program.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Windows.Forms;

namespace LIVEnTool
{
    static class GuiApplication
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new Form1());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LIVEnAuthClient\LIVEnToolGUI\OutputViewer.Designer.cs ===
﻿namespace LIVEnToolGUI
{
    partial class OutputViewer
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.txtResponse = new System.Windows.Forms.RichTextBox();
            this.SuspendLayout();
            // 
            // txtResponse
            // 
            this.txtResponse.Dock = System.Windows.Forms.DockStyle.Fill;
            this.txtResponse.Location = new System.Drawing.Point(0, 0);
            this.txtResponse.Name = "txtResponse";
            this.txtResponse.ReadOnly = true;
            this.txtResponse.Size = new System.Drawing.Size(482, 644);
            this.txtResponse.TabIndex = 0;
            this.txtResponse.Text = "";
            // 
            // OutputViewer
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.AutoSize = true;
            this.ClientSize = new System.Drawing.Size(482, 644);
            this.Controls.Add(this.txtResponse);
            this.Name = "OutputViewer";
            this.Text = "Response";
            this.ResumeLayout(false);

        }

        #endregion

        private System.Windows.Forms.RichTextBox txtResponse;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LIVEnAuthClient\LIVEnToolGUI\Form1.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="Form1.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="amathes">
//     Andrew Mathes
// </author>
//
// <summary>
//  LIVEnTool GUI application
// </summary>
//
// <remarks/>
// 
// <todo>
// 1. separate UI and worker threads
// 2. progress indicator
// 3. add support for other service methods
// 4. get method names, params, default values from config or schema or a combo
// 5. make the request tweakable before submission
// </todo>
//
// <disclaimer/>
//
// <history date="2010.05.07">
//     Class created
// </history>
//-------------------------------------------------------------------
namespace LIVEnTool
{
    using System;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.Configuration;
    using System.Data;
    using System.Diagnostics;
    using System.Drawing;
    using System.IO;
    using System.Linq;
    using System.Text;
    using System.Windows.Forms;
    using System.Xml.Linq;
    using LIVEnTool;

    /// <summary>
    /// The Form1 class
    /// </summary>
    public partial class Form1 : Form
    {
        /// <summary>
        /// Initializes a new instance of the Form1 class
        /// </summary>
        public Form1()
        {
            InitializeComponent();
            
            // todo: get these from config file
            txtMemberName.Text = "mpdev1@xbltest.com";
            txtPassword.Text = "supersecret";

            string[] environments = ConfigurationManager.AppSettings["Environments"].Split(',');

            cboEnvironment.Items.Clear();
            foreach (string env in environments)
            {
                cboEnvironment.Items.Add(env);
            } 
            cboEnvironment.SelectedIndex = 0;

            this.Services = new List<string>();
            this.PopulateServices();
            this.PopulateAudienceUris();

            this.PopulateAuthTitleId();
        }

        /// <summary>
        /// Gets or sets the rps ticket
        /// </summary>
        private string RpsTicket { get; set; }

        /// <summary>
        /// Gets or sets the user sts token
        /// </summary>
        private string UserToken { get; set; }

        private string PartnerToken { get; set; }

        private string SessionId { get; set; }

        private List<string> Services { get; set; }

        private void PopulateServices()
        {
            if (this.Services.Count == 0)
            {
                this.Services = TestCollection.GetServices();

                cboEndpoint.Items.Clear();

                foreach (string service in this.Services)
                {
                    cboEndpoint.Items.Add(service);
                }
            }
            cboEndpoint.Sorted = true;
            cboEndpoint.SelectedIndex = 0;
        }

        private void PopulateAudienceUris()
        {
            this.cboAudienceUri.Items.Clear();
            this.cboAudienceUri.Items.Add(HelperLibrary.MultiplayerAudienceUri);
            this.cboAudienceUri.Items.Add(HelperLibrary.AvatarAudienceUri);
            this.cboAudienceUri.SelectedIndex = 0;
        }

        private void PopulateAuthTitleId()
        {
            this.txtTitleId.Text = HelperLibrary.TitleId;
            this.txtTitleVersion.Text = HelperLibrary.TitleVersion;
        }
     
        /// <summary>
        /// Populates the methods names in the combobox
        /// </summary>
        private void PopulateMethods()
        {
            List<ServiceTest> methods = TestCollection.GetTests(cboEndpoint.SelectedItem.ToString());

            cboMethod.Items.Clear();
            foreach (ServiceTest method in methods)
            {
                if (method.ShowInGui)
                {
                    cboMethod.Items.Add(method);
                }
            }
            cboMethod.Sorted = true;
            cboMethod.SelectedIndex = 0;
        }

        /// <summary>
        /// Determines which set of params should be displayed in the params grid, then calls another function to do the population work.
        /// </summary>
        private void PopulateParamsGrid()
        {
            ServiceTest test = (ServiceTest)cboMethod.SelectedItem;

            dataGridView1.Rows.Clear();

            foreach (ServiceTest.ArgInfo arg in test.Arguments)
            {
                string defaultValue = arg.DefaultValue;
                switch (arg.Name)
                {
                    case "UserToken":
                        defaultValue = this.UserToken;
                        break;
                    case "PartnerToken":
                        defaultValue = this.PartnerToken;
                        break;
                    case "RpsTicket":
                        defaultValue = this.RpsTicket;
                        break;
                    case "SessionId":
                        defaultValue = this.SessionId;
                        break;
                    default:
                        break;
                }

                if (string.IsNullOrEmpty(defaultValue))
                {
                    switch (arg.Type)
                    {
                        case "Guid":
                            defaultValue = Guid.NewGuid().ToString();
                            break;
                        case "DateTime":
                            defaultValue = DateTime.Now.ToString();
                            break;
                        default:
                            break;
                    }
                }
                
                dataGridView1.Rows.Add(new string[] { arg.Name, defaultValue });
            }
        }

        /// <summary>
        /// The event handler for when the method is changed
        /// </summary>
        /// <param name="sender">the sender object</param>
        /// <param name="e">event args</param>
        private void CboMethod_SelectedIndexChanged(object sender, EventArgs e)
        {
            this.PopulateParamsGrid();
        }

        /// <summary>
        /// Opens the default viewer for xml to show the response from the service.
        /// </summary>
        /// <param name="response">The response text</param>
        private void DisplayServiceResponse(string response)
        {
            if (string.IsNullOrEmpty(response))
            {
                MessageBox.Show("(empty response)");
            }
            else
            {
                LIVEnToolGUI.OutputViewer responseViewer;
                
                try
                {
                    XDocument xdoc = XDocument.Parse(response);
                    responseViewer = new LIVEnToolGUI.OutputViewer(xdoc.ToString());
                }
                catch (Exception ex)
                {
                    MessageBox.Show(ex.Message);
                    responseViewer = new LIVEnToolGUI.OutputViewer(response);
                }                
                responseViewer.Show();
            }
        }
        
        /// <summary>
        /// Submits the call to the service
        /// </summary>
        /// <param name="sender">the sender object</param>
        /// <param name="e">event args</param>
        private void BtnSubmit_Click(object sender, EventArgs e)
        {
            try
            {
                string methodName = ((ServiceTest)cboMethod.SelectedItem).TestName;                
                string[] parameters = new string[dataGridView1.Rows.Count];

                // warning: params are order dependent. must match between method and order shown in the xml config
                for (int i = 0; i < dataGridView1.Rows.Count; i++)
                {
                    object val = dataGridView1.Rows[i].Cells[1].Value;
                    if (val == null)
                    {
                        parameters[i] = string.Empty;
                    }
                    else
                    {
                        parameters[i] = val.ToString();
                    }
                    switch (parameters[i])
                    {
                        case "UserToken":
                            this.UserToken = parameters[i];
                            break;
                        case "PartnerToken":
                            this.PartnerToken = parameters[i];
                            break;
                        default:
                            break;
                    }

                }

                object responseObj = HelperLibrary.InvokeServiceMethod(methodName, parameters);

                this.DisplayServiceResponse(responseObj.ToString());
            }            
            catch (Exception ex)
            {
                MessageBox.Show(ex.ToString(), "Exception");
            }
            finally
            {
            }
        }

        /// <summary>
        /// The event handler for when the environment drop-down's value is changed
        /// </summary>
        /// <param name="sender">the sender object</param>
        /// <param name="e">event args</param>
        private void CboEnvironment_SelectedIndexChanged(object sender, EventArgs e)
        {
            HelperLibrary.LoadConfiguration(cboEnvironment.SelectedItem.ToString());
            this.PopulateAuthTitleId();
        }

        /// <summary>
        /// Resets the parameters to their default values
        /// </summary>
        /// <param name="sender">the sender object</param>
        /// <param name="e">event args</param>
        private void BtnResetDefaultParams_Click(object sender, EventArgs e)
        {
            this.PopulateParamsGrid();
        }

        /// <summary>
        /// The event handler for when the selected item in the Endpoint combobox is changed
        /// </summary>
        /// <param name="sender">The sender object</param>
        /// <param name="e">The event args</param>
        private void CboEndpoint_SelectedIndexChanged(object sender, EventArgs e)
        {
            this.PopulateMethods();
        }
       
        /// <summary>
        /// The event handler for the "authenticate" button click
        /// </summary>
        /// <param name="sender">The sender object</param>
        /// <param name="e">The event args</param>
        private void BtnAuth_Click(object sender, EventArgs e)
        {
            string rpsTicket = string.Empty;
            try
            {
                string userToken = TokenService.GetNewUserToken(this.txtMemberName.Text, this.txtPassword.Text, this.txtTitleId.Text, this.txtTitleVersion.Text, out rpsTicket);
                this.UserToken = userToken;
                this.PartnerToken = TokenService.GetPartnerToken(this.UserToken, this.cboAudienceUri.Text, this.txtTitleId.Text, this.txtTitleVersion.Text);
                this.RpsTicket = rpsTicket;

                this.Text = string.Format("LIVEnTool (running as {0})", this.txtMemberName.Text);
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.Message);
            }
            finally
            {
            }

            this.PopulateParamsGrid();
        }

        private void installClientCertificatesToolStripMenuItem_Click(object sender, EventArgs e)
        {
            HelperLibrary.InstallClientCerts();
        }

        private void aboutLIVEnToolToolStripMenuItem_Click(object sender, EventArgs e)
        {
            string message = "Contacts:\nAndrew Mathes (amathes)\nTed Kuo (a-thkuo)";
            MessageBox.Show(message, "About LIVEnTool");            
        }

        private void dataGridView1_CellContentClick(object sender, DataGridViewCellEventArgs e)
        {

        }

        private void dataGridView1_EditingControlShowing(object sender,
    DataGridViewEditingControlShowingEventArgs e)
        {
            if (e.Control is TextBox) //If it is a DataGridViewTextBoxCell
            {

                (e.Control as TextBox).MaxLength = 1000000;

            }

        }

        private void Form1_Load(object sender, EventArgs e)
        {

        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LIVEnAuthClient\LIVEnToolGUI\Form1.Designer.cs ===
﻿namespace LIVEnTool
{
    partial class Form1
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle2 = new System.Windows.Forms.DataGridViewCellStyle();
            System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle1 = new System.Windows.Forms.DataGridViewCellStyle();
            this.cboEnvironment = new System.Windows.Forms.ComboBox();
            this.label1 = new System.Windows.Forms.Label();
            this.dataGridView1 = new System.Windows.Forms.DataGridView();
            this.Parameter = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.Value = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.label2 = new System.Windows.Forms.Label();
            this.cboMethod = new System.Windows.Forms.ComboBox();
            this.label3 = new System.Windows.Forms.Label();
            this.txtMemberName = new System.Windows.Forms.TextBox();
            this.txtPassword = new System.Windows.Forms.TextBox();
            this.btnSubmit = new System.Windows.Forms.Button();
            this.label4 = new System.Windows.Forms.Label();
            this.cboEndpoint = new System.Windows.Forms.ComboBox();
            this.btnResetDefaultParams = new System.Windows.Forms.Button();
            this.btnAuth = new System.Windows.Forms.Button();
            this.panel1 = new System.Windows.Forms.Panel();
            this.panel2 = new System.Windows.Forms.Panel();
            this.label7 = new System.Windows.Forms.Label();
            this.txtTitleVersion = new System.Windows.Forms.TextBox();
            this.label6 = new System.Windows.Forms.Label();
            this.txtTitleId = new System.Windows.Forms.TextBox();
            this.label5 = new System.Windows.Forms.Label();
            this.cboAudienceUri = new System.Windows.Forms.ComboBox();
            this.menuStrip1 = new System.Windows.Forms.MenuStrip();
            this.toolsToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.installClientCertificatesToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.helpToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.aboutLIVEnToolToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.panel3 = new System.Windows.Forms.Panel();
            ((System.ComponentModel.ISupportInitialize)(this.dataGridView1)).BeginInit();
            this.panel1.SuspendLayout();
            this.panel2.SuspendLayout();
            this.menuStrip1.SuspendLayout();
            this.panel3.SuspendLayout();
            this.SuspendLayout();
            // 
            // cboEnvironment
            // 
            this.cboEnvironment.AutoCompleteMode = System.Windows.Forms.AutoCompleteMode.SuggestAppend;
            this.cboEnvironment.AutoCompleteSource = System.Windows.Forms.AutoCompleteSource.ListItems;
            this.cboEnvironment.FormattingEnabled = true;
            this.cboEnvironment.Location = new System.Drawing.Point(84, 13);
            this.cboEnvironment.Name = "cboEnvironment";
            this.cboEnvironment.Size = new System.Drawing.Size(371, 21);
            this.cboEnvironment.TabIndex = 0;
            this.cboEnvironment.SelectedIndexChanged += new System.EventHandler(this.CboEnvironment_SelectedIndexChanged);
            // 
            // label1
            // 
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(5, 21);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(66, 13);
            this.label1.TabIndex = 1;
            this.label1.Text = "Environment";
            // 
            // dataGridView1
            // 
            this.dataGridView1.AllowUserToAddRows = false;
            this.dataGridView1.AllowUserToDeleteRows = false;
            this.dataGridView1.AutoSizeColumnsMode = System.Windows.Forms.DataGridViewAutoSizeColumnsMode.AllCells;
            this.dataGridView1.AutoSizeRowsMode = System.Windows.Forms.DataGridViewAutoSizeRowsMode.DisplayedCells;
            this.dataGridView1.ColumnHeadersHeightSizeMode = System.Windows.Forms.DataGridViewColumnHeadersHeightSizeMode.DisableResizing;
            this.dataGridView1.Columns.AddRange(new System.Windows.Forms.DataGridViewColumn[] {
            this.Parameter,
            this.Value});
            this.dataGridView1.Dock = System.Windows.Forms.DockStyle.Top;
            this.dataGridView1.Location = new System.Drawing.Point(0, 0);
            this.dataGridView1.Name = "dataGridView1";
            dataGridViewCellStyle2.WrapMode = System.Windows.Forms.DataGridViewTriState.True;
            this.dataGridView1.RowsDefaultCellStyle = dataGridViewCellStyle2;
            this.dataGridView1.RowTemplate.DefaultCellStyle.WrapMode = System.Windows.Forms.DataGridViewTriState.True;
            this.dataGridView1.RowTemplate.Resizable = System.Windows.Forms.DataGridViewTriState.True;
            this.dataGridView1.SelectionMode = System.Windows.Forms.DataGridViewSelectionMode.CellSelect;
            this.dataGridView1.Size = new System.Drawing.Size(470, 244);
            this.dataGridView1.TabIndex = 30;
            this.dataGridView1.EditingControlShowing += new System.Windows.Forms.DataGridViewEditingControlShowingEventHandler(this.dataGridView1_EditingControlShowing);
            this.dataGridView1.CellContentClick += new System.Windows.Forms.DataGridViewCellEventHandler(this.dataGridView1_CellContentClick);
            // 
            // Parameter
            // 
            this.Parameter.HeaderText = "Parameter";
            this.Parameter.Name = "Parameter";
            this.Parameter.ReadOnly = true;
            this.Parameter.SortMode = System.Windows.Forms.DataGridViewColumnSortMode.NotSortable;
            this.Parameter.Width = 61;
            // 
            // Value
            // 
            this.Value.AutoSizeMode = System.Windows.Forms.DataGridViewAutoSizeColumnMode.AllCells;
            dataGridViewCellStyle1.WrapMode = System.Windows.Forms.DataGridViewTriState.True;
            this.Value.DefaultCellStyle = dataGridViewCellStyle1;
            this.Value.HeaderText = "Value";
            this.Value.Name = "Value";
            this.Value.SortMode = System.Windows.Forms.DataGridViewColumnSortMode.NotSortable;
            this.Value.Width = 40;
            // 
            // label2
            // 
            this.label2.AutoSize = true;
            this.label2.Location = new System.Drawing.Point(229, 20);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(43, 13);
            this.label2.TabIndex = 4;
            this.label2.Text = "Method";
            // 
            // cboMethod
            // 
            this.cboMethod.FormattingEnabled = true;
            this.cboMethod.ItemHeight = 13;
            this.cboMethod.Items.AddRange(new object[] {
            "SendNotification",
            "DeleteNotificationBySession",
            "PostGameResult"});
            this.cboMethod.Location = new System.Drawing.Point(279, 12);
            this.cboMethod.Name = "cboMethod";
            this.cboMethod.Size = new System.Drawing.Size(176, 21);
            this.cboMethod.TabIndex = 3;
            this.cboMethod.SelectedIndexChanged += new System.EventHandler(this.CboMethod_SelectedIndexChanged);
            // 
            // label3
            // 
            this.label3.AutoSize = true;
            this.label3.Location = new System.Drawing.Point(6, 126);
            this.label3.Name = "label3";
            this.label3.Size = new System.Drawing.Size(72, 13);
            this.label3.TabIndex = 3;
            this.label3.Text = "User Account";
            // 
            // txtMemberName
            // 
            this.txtMemberName.Location = new System.Drawing.Point(85, 119);
            this.txtMemberName.Name = "txtMemberName";
            this.txtMemberName.Size = new System.Drawing.Size(158, 20);
            this.txtMemberName.TabIndex = 1;
            // 
            // txtPassword
            // 
            this.txtPassword.Location = new System.Drawing.Point(249, 119);
            this.txtPassword.Name = "txtPassword";
            this.txtPassword.Size = new System.Drawing.Size(206, 20);
            this.txtPassword.TabIndex = 2;
            // 
            // btnSubmit
            // 
            this.btnSubmit.Location = new System.Drawing.Point(250, 250);
            this.btnSubmit.Name = "btnSubmit";
            this.btnSubmit.Size = new System.Drawing.Size(104, 20);
            this.btnSubmit.TabIndex = 50;
            this.btnSubmit.Text = "Submit";
            this.btnSubmit.UseVisualStyleBackColor = true;
            this.btnSubmit.Click += new System.EventHandler(this.BtnSubmit_Click);
            // 
            // label4
            // 
            this.label4.AutoSize = true;
            this.label4.Location = new System.Drawing.Point(12, 20);
            this.label4.Name = "label4";
            this.label4.Size = new System.Drawing.Size(49, 13);
            this.label4.TabIndex = 8;
            this.label4.Text = "Endpoint";
            // 
            // cboEndpoint
            // 
            this.cboEndpoint.AutoCompleteMode = System.Windows.Forms.AutoCompleteMode.SuggestAppend;
            this.cboEndpoint.AutoCompleteSource = System.Windows.Forms.AutoCompleteSource.ListItems;
            this.cboEndpoint.FormattingEnabled = true;
            this.cboEndpoint.ItemHeight = 13;
            this.cboEndpoint.Items.AddRange(new object[] {
            "PartnerService"});
            this.cboEndpoint.Location = new System.Drawing.Point(68, 12);
            this.cboEndpoint.Name = "cboEndpoint";
            this.cboEndpoint.Size = new System.Drawing.Size(149, 21);
            this.cboEndpoint.TabIndex = 7;
            this.cboEndpoint.SelectedIndexChanged += new System.EventHandler(this.CboEndpoint_SelectedIndexChanged);
            // 
            // btnResetDefaultParams
            // 
            this.btnResetDefaultParams.Location = new System.Drawing.Point(148, 250);
            this.btnResetDefaultParams.Name = "btnResetDefaultParams";
            this.btnResetDefaultParams.Size = new System.Drawing.Size(96, 20);
            this.btnResetDefaultParams.TabIndex = 40;
            this.btnResetDefaultParams.Text = "Reset";
            this.btnResetDefaultParams.UseVisualStyleBackColor = true;
            this.btnResetDefaultParams.Click += new System.EventHandler(this.BtnResetDefaultParams_Click);
            // 
            // btnAuth
            // 
            this.btnAuth.Location = new System.Drawing.Point(209, 145);
            this.btnAuth.Name = "btnAuth";
            this.btnAuth.Size = new System.Drawing.Size(78, 23);
            this.btnAuth.TabIndex = 5;
            this.btnAuth.Text = "Authenticate";
            this.btnAuth.UseVisualStyleBackColor = true;
            this.btnAuth.Click += new System.EventHandler(this.BtnAuth_Click);
            // 
            // panel1
            // 
            this.panel1.Controls.Add(this.btnResetDefaultParams);
            this.panel1.Controls.Add(this.btnSubmit);
            this.panel1.Controls.Add(this.dataGridView1);
            this.panel1.Dock = System.Windows.Forms.DockStyle.Bottom;
            this.panel1.Location = new System.Drawing.Point(0, 261);
            this.panel1.Name = "panel1";
            this.panel1.Size = new System.Drawing.Size(470, 282);
            this.panel1.TabIndex = 51;
            // 
            // panel2
            // 
            this.panel2.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
            this.panel2.Controls.Add(this.label7);
            this.panel2.Controls.Add(this.txtTitleVersion);
            this.panel2.Controls.Add(this.label6);
            this.panel2.Controls.Add(this.txtTitleId);
            this.panel2.Controls.Add(this.label5);
            this.panel2.Controls.Add(this.cboAudienceUri);
            this.panel2.Controls.Add(this.label1);
            this.panel2.Controls.Add(this.cboEnvironment);
            this.panel2.Controls.Add(this.btnAuth);
            this.panel2.Controls.Add(this.label3);
            this.panel2.Controls.Add(this.txtMemberName);
            this.panel2.Controls.Add(this.txtPassword);
            this.panel2.Dock = System.Windows.Forms.DockStyle.Top;
            this.panel2.Location = new System.Drawing.Point(0, 24);
            this.panel2.Name = "panel2";
            this.panel2.Size = new System.Drawing.Size(470, 179);
            this.panel2.TabIndex = 52;
            // 
            // label7
            // 
            this.label7.AutoSize = true;
            this.label7.Location = new System.Drawing.Point(6, 101);
            this.label7.Name = "label7";
            this.label7.Size = new System.Drawing.Size(65, 13);
            this.label7.TabIndex = 14;
            this.label7.Text = "Title Version";
            // 
            // txtTitleVersion
            // 
            this.txtTitleVersion.Location = new System.Drawing.Point(85, 94);
            this.txtTitleVersion.Name = "txtTitleVersion";
            this.txtTitleVersion.Size = new System.Drawing.Size(370, 20);
            this.txtTitleVersion.TabIndex = 13;
            // 
            // label6
            // 
            this.label6.AutoSize = true;
            this.label6.Location = new System.Drawing.Point(6, 76);
            this.label6.Name = "label6";
            this.label6.Size = new System.Drawing.Size(41, 13);
            this.label6.TabIndex = 12;
            this.label6.Text = "Title ID";
            // 
            // txtTitleId
            // 
            this.txtTitleId.Location = new System.Drawing.Point(85, 69);
            this.txtTitleId.Name = "txtTitleId";
            this.txtTitleId.Size = new System.Drawing.Size(370, 20);
            this.txtTitleId.TabIndex = 11;
            // 
            // label5
            // 
            this.label5.AutoSize = true;
            this.label5.Location = new System.Drawing.Point(5, 48);
            this.label5.Name = "label5";
            this.label5.Size = new System.Drawing.Size(65, 13);
            this.label5.TabIndex = 10;
            this.label5.Text = "AudienceUri";
            // 
            // cboAudienceUri
            // 
            this.cboAudienceUri.FormattingEnabled = true;
            this.cboAudienceUri.Location = new System.Drawing.Point(84, 40);
            this.cboAudienceUri.Name = "cboAudienceUri";
            this.cboAudienceUri.Size = new System.Drawing.Size(371, 21);
            this.cboAudienceUri.TabIndex = 9;
            // 
            // menuStrip1
            // 
            this.menuStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.toolsToolStripMenuItem,
            this.helpToolStripMenuItem});
            this.menuStrip1.Location = new System.Drawing.Point(0, 0);
            this.menuStrip1.Name = "menuStrip1";
            this.menuStrip1.Size = new System.Drawing.Size(470, 24);
            this.menuStrip1.TabIndex = 53;
            this.menuStrip1.Text = "menuStrip1";
            // 
            // toolsToolStripMenuItem
            // 
            this.toolsToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.installClientCertificatesToolStripMenuItem});
            this.toolsToolStripMenuItem.Name = "toolsToolStripMenuItem";
            this.toolsToolStripMenuItem.Size = new System.Drawing.Size(48, 20);
            this.toolsToolStripMenuItem.Text = "&Tools";
            // 
            // installClientCertificatesToolStripMenuItem
            // 
            this.installClientCertificatesToolStripMenuItem.Name = "installClientCertificatesToolStripMenuItem";
            this.installClientCertificatesToolStripMenuItem.Size = new System.Drawing.Size(201, 22);
            this.installClientCertificatesToolStripMenuItem.Text = "Install Client Certificates";
            this.installClientCertificatesToolStripMenuItem.Click += new System.EventHandler(this.installClientCertificatesToolStripMenuItem_Click);
            // 
            // helpToolStripMenuItem
            // 
            this.helpToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.aboutLIVEnToolToolStripMenuItem});
            this.helpToolStripMenuItem.Name = "helpToolStripMenuItem";
            this.helpToolStripMenuItem.Size = new System.Drawing.Size(44, 20);
            this.helpToolStripMenuItem.Text = "&Help";
            // 
            // aboutLIVEnToolToolStripMenuItem
            // 
            this.aboutLIVEnToolToolStripMenuItem.Name = "aboutLIVEnToolToolStripMenuItem";
            this.aboutLIVEnToolToolStripMenuItem.Size = new System.Drawing.Size(163, 22);
            this.aboutLIVEnToolToolStripMenuItem.Text = "About LIVEnTool";
            this.aboutLIVEnToolToolStripMenuItem.Click += new System.EventHandler(this.aboutLIVEnToolToolStripMenuItem_Click);
            // 
            // panel3
            // 
            this.panel3.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
            this.panel3.Controls.Add(this.label4);
            this.panel3.Controls.Add(this.label2);
            this.panel3.Controls.Add(this.cboMethod);
            this.panel3.Controls.Add(this.cboEndpoint);
            this.panel3.Location = new System.Drawing.Point(0, 209);
            this.panel3.Name = "panel3";
            this.panel3.Size = new System.Drawing.Size(470, 47);
            this.panel3.TabIndex = 11;
            // 
            // Form1
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(470, 543);
            this.Controls.Add(this.panel3);
            this.Controls.Add(this.panel2);
            this.Controls.Add(this.panel1);
            this.Controls.Add(this.menuStrip1);
            this.MainMenuStrip = this.menuStrip1;
            this.Name = "Form1";
            this.Text = "LIVEnTool";
            this.Load += new System.EventHandler(this.Form1_Load);
            ((System.ComponentModel.ISupportInitialize)(this.dataGridView1)).EndInit();
            this.panel1.ResumeLayout(false);
            this.panel2.ResumeLayout(false);
            this.panel2.PerformLayout();
            this.menuStrip1.ResumeLayout(false);
            this.menuStrip1.PerformLayout();
            this.panel3.ResumeLayout(false);
            this.panel3.PerformLayout();
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.ComboBox cboEnvironment;
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.Label label2;
        private System.Windows.Forms.ComboBox cboMethod;
        private System.Windows.Forms.Label label3;
        private System.Windows.Forms.TextBox txtMemberName;
        private System.Windows.Forms.TextBox txtPassword;
        private System.Windows.Forms.Button btnSubmit;
        private System.Windows.Forms.DataGridView dataGridView1;
        private System.Windows.Forms.Label label4;
        private System.Windows.Forms.ComboBox cboEndpoint;
        private System.Windows.Forms.Button btnResetDefaultParams;
        private System.Windows.Forms.Button btnAuth;
        private System.Windows.Forms.DataGridViewTextBoxColumn Parameter;
        private System.Windows.Forms.DataGridViewTextBoxColumn Value;
        private System.Windows.Forms.Panel panel1;
        private System.Windows.Forms.Panel panel2;
        private System.Windows.Forms.MenuStrip menuStrip1;
        private System.Windows.Forms.ToolStripMenuItem toolsToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem installClientCertificatesToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem helpToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem aboutLIVEnToolToolStripMenuItem;
        private System.Windows.Forms.Label label5;
        private System.Windows.Forms.ComboBox cboAudienceUri;
        private System.Windows.Forms.Panel panel3;
        private System.Windows.Forms.Label label6;
        private System.Windows.Forms.TextBox txtTitleId;
        private System.Windows.Forms.Label label7;
        private System.Windows.Forms.TextBox txtTitleVersion;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\ServiceBrokerQueue\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LIVEnAuthClient\LIVEnToolGUI\Properties\Settings.Designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace LIVEnToolGUI.Properties
{


    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "9.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase
    {

        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));

        public static Settings Default
        {
            get
            {
                return defaultInstance;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LIVEnAuthClient\LIVEnToolLocal\CertificatePolicy.cs ===
﻿//------------------------------------------------------------------------------------------------- 
// <copyright file="CertificatePolicy.cs" company="Microsoft" author="a-thkuo">
//      Copyright © .  All rights reserved.
// </copyright>
// <summary>Code to get around the certification validation check</summary>
//-------------------------------------------------------------------------------------------------
namespace LIVEnToolLocal
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Net;
    using System.Net.Security;
    using System.Security.Cryptography.X509Certificates;
    using System.Text;

    /// <summary>
    /// CertificatePolicy class definition
    /// </summary>
    internal static class CertificatePolicy
    {
        /// <summary>
        /// Sets the certificate policy.
        /// </summary>
        internal static void SetCertificatePolicy()
        {
            ServicePointManager.ServerCertificateValidationCallback
                       += RemoteCertificateValidate;
        }

        /// <summary>
        /// Callback method to trust any certificate (i.e. ignore certificate validation)
        /// </summary>
        /// <param name="sender">Sender of the request validation</param>
        /// <param name="cert">The certificate to validate</param>
        /// <param name="chain">Chain building engine</param>
        /// <param name="error">SSL policy error</param>
        /// <returns>true to indicate trust to the certificate</returns>
        private static bool RemoteCertificateValidate(
            object sender, 
            X509Certificate cert,
            X509Chain chain, 
            SslPolicyErrors error)
        {
            // trust any certificate!!!
            System.Console.WriteLine("Warning, trust any certificate");
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LIVEnAuthClient\LIVEnToolLocal\Program.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="Program.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="a-thkuo">
//     Ted Kuo
// </author>
//
// <summary>
//  LIVEnTool console application used for self-monitoring the services
//  in the local server machine.
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="2010.05.27">
//     Class created
// </history>
//-------------------------------------------------------------------
// #define __DEBUG__
namespace LIVEnToolLocal
{
    using System;
    using System.Collections.Generic;
    using System.Collections.Specialized;
    using System.Configuration;
    using System.Diagnostics;
    using System.IO;
    using System.Linq;
    using System.Net;
    using System.Runtime.Serialization;
    using System.Text;
    using LIVEnTool;

    /// <summary>
    /// Main program for the tool
    /// </summary>
    public class ConsoleApplication
    {
        #region Fields
        /// <summary>
        /// The name of this application
        /// </summary>
        private const string ApplicationName = "LiveEnSelfMonitor";
        #endregion

        #region Types

        /// <summary>
        /// Enum values for exit code. 
        /// </summary>
        private enum ExitCode
        {
            /// <summary>
            /// The operation was successful and get response 
            /// </summary>
            Success = 0,

            /// <summary>
            /// There is no response. 
            /// </summary>
            NoResponse = 1,

            /// <summary>
            /// There is something wrong with the command. 
            /// </summary>
            InvalidArgument = 2,

            /// <summary>
            /// There is error in the operation. 
            /// </summary>
            Error = 3
        }

        #endregion

        #region properties

        /// <summary>
        /// Gets or sets the ErrorCode
        /// </summary>
        private static ExitCode ErrorCode { get; set; }

        #endregion

        #region public main method
        /// <summary>
        /// The public main method
        /// </summary>
        /// <param name="args">Command-line args</param>
        /// <returns>returned status</returns>
        public static int Main(string[] args)
        {
            string environment = string.Empty;
            string testname = string.Empty;
            string userToken = string.Empty;
            bool cachedToken = false;
            bool installCert = false;

            if (args.Count() == 0)
            {
                PrintUsage();
                return (int)ExitCode.InvalidArgument;
            }

            if (args[0] == "/installcerts")
            {
                LoadConfigForCertInstallation();
                if (HelperLibrary.InstallClientCerts() != 0)
                {
                    return (int)ExitCode.InvalidArgument;
                }

                if (args.Count() == 1)
                {
                    return (int)ExitCode.Success;
                }
                else
                {
                    Console.WriteLine("Error: Arguments supplied after /installcerts will be ignored");
                    PrintUsage();
                    return (int)ExitCode.InvalidArgument;
                }
            }

            int argindex = 0;
            List<string> paramsList = new List<string>();

            while (argindex < args.Length && !installCert)
            {
                switch (args[argindex])
                {
                    case "/test":
                        testname = args[argindex + 1];
                        argindex = argindex + 2;
                        break;

                    case "/cachetoken":
                        cachedToken = true;
                        argindex++;
                        break;

                    case "/help":
                        if (args.Length > argindex + 1)
                        {
                            ConsoleApplication.PrintDetailedUsage(args[argindex + 1]);
                            return (int)ExitCode.Success;
                        }
                        else
                        {
                            ConsoleApplication.PrintUsage();
                            return (int)ExitCode.Success;
                        }

                    default:
                        paramsList.Add(args[argindex++]);
                        break;
                }
            }

            if (testname == string.Empty && !installCert)
            {
                Console.WriteLine("Error: either /test or /env were not provided");
                PrintUsage();
                return (int)ExitCode.InvalidArgument;
            }

            HelperLibrary.GetEventLogOption();
            HelperLibrary.WriteToEventLog(ApplicationName, "Test " + testname + " STARTED", EventLogEntryType.Information);

            try
            {
                ConfigProvider.RegisterServiceToConfigProvider(ApplicationName);
                string env = string.Empty;
                ConfigProvider.GetServerEnvironment(ApplicationName, out env);
                if (env == string.Empty)
                {
                    HelperLibrary.WriteToEventLog(ApplicationName, "Test " + testname + " aborted. Failed to read environment from NPDB", EventLogEntryType.Error);
                    Console.WriteLine("Test " + testname + " aborted. Failed to read environment from NPDB");
                    return (int)ExitCode.Error;
                }

                if (String.Compare(testname, "GetNewUserToken") == 0 ||
                    String.Compare(testname, "GetPartnerToken") == 0 ||
                    String.Compare(testname, "CreateMobileAccount") == 0 ||
                    String.Compare(testname, "GetUserProfile") == 0)
                {
                    // The above test does not require access to LIVEN services, so we don't need
                    // to get the high port for this
                    HelperLibrary.LoadConfiguration(env);
                }
                else
                {
                    int port = ConfigProvider.GetServicePortNumber(testname);
                    string endpoint = TestCollection.GetServiceEndpoint(testname);
                    HelperLibrary.LoadConfiguration(env, endpoint, port);
                    HelperLibrary.GetCacheTokenParams();
                }
            }
            catch (Exception e)
            {
                string msg = String.Format("Initialization failed. Likely cause: Test {0} is not supported by this tool", testname);
                Console.WriteLine(HelperLibrary.LogException(e, msg));
                HelperLibrary.WriteToEventLog(ApplicationName, HelperLibrary.LogException(e, msg), EventLogEntryType.Error);
                return (int)ExitCode.Error;
            }

            ConsoleApplication.ErrorCode = ExitCode.Success;

            // if cachetoken switch is not provided, use the default option from App.config
            if (cachedToken == false)
            {
                cachedToken = HelperLibrary.CacheStsToken;
            }

            try
            {
                // if requested to used a cached token, take the first 2 params as membername and password, then replace them with the cached token
                if (cachedToken)
                {
                    if (paramsList.Count >= 2)
                    {
                        string membername = paramsList[0];
                        string password = paramsList[1];

                        userToken = TokenService.GetCurrentUserToken(membername, password, HelperLibrary.TitleId, HelperLibrary.TitleVersion);

                        // replace the first two params with just the user token
                        paramsList.RemoveAt(0);
                        paramsList[0] = userToken;
                    }
                }

                string[] paramsArray = new string[paramsList.Count];
                for (int i = 0; i < paramsArray.Length; i++)
                {
                    paramsArray[i] = paramsList[i];
                }

                // trust any certificate
                CertificatePolicy.SetCertificatePolicy();

                object responseObj = HelperLibrary.InvokeServiceMethod(testname, paramsArray);

                Console.WriteLine(responseObj.ToString());
            }
            catch (WebException we)
            {
                if (we.Response != null)
                {
                    Stream dataStream = we.Response.GetResponseStream();
                    string webResponse = string.Empty;
                    using (StreamReader reader = new StreamReader(dataStream))
                    {
                        webResponse = "Web response: " + reader.ReadToEnd();
                        Console.WriteLine(HelperLibrary.LogException(we, webResponse));
                    }

                    ConsoleApplication.ErrorCode = ExitCode.Error;
                    HelperLibrary.WriteToEventLog(ApplicationName, HelperLibrary.LogException(we, webResponse), EventLogEntryType.Error);
                }
                else
                {
                    Console.WriteLine(HelperLibrary.LogException(we));
                    HelperLibrary.WriteToEventLog(ApplicationName, HelperLibrary.LogException(we), EventLogEntryType.Error);
                    ConsoleApplication.ErrorCode = ExitCode.NoResponse;
                }
            }
            catch (ArgumentException ae)
            {
                Console.WriteLine(HelperLibrary.LogException(ae));
                HelperLibrary.WriteToEventLog(ApplicationName, HelperLibrary.LogException(ae), EventLogEntryType.Error);
                ConsoleApplication.ErrorCode = ExitCode.InvalidArgument;
            }
            catch (IOException ie)
            {
                Console.WriteLine(HelperLibrary.LogException(ie));
                HelperLibrary.WriteToEventLog(ApplicationName, HelperLibrary.LogException(ie), EventLogEntryType.Error);
                ConsoleApplication.ErrorCode = ExitCode.Error;
            }
            catch (Exception e)
            {
                string msg = String.Format("Exception on test {0}: ", testname);
                Console.WriteLine(HelperLibrary.LogException(e, msg));
                HelperLibrary.WriteToEventLog(ApplicationName, HelperLibrary.LogException(e, msg), EventLogEntryType.Error);
                ConsoleApplication.ErrorCode = ExitCode.Error;
            }

            Console.WriteLine(string.Format("Exit status: {0}", Enum.GetName(typeof(ExitCode), ConsoleApplication.ErrorCode)));

#if __DEBUG__
            Console.WriteLine("Enter any key to exit");
            Console.ReadKey();
#endif

            if (ConsoleApplication.ErrorCode == ExitCode.Success)
            {
                HelperLibrary.WriteToEventLog(ApplicationName, "Test " + testname + " PASSED", EventLogEntryType.Information);
            }
            else
            {
                HelperLibrary.WriteToEventLog(ApplicationName, "Test " + testname + " FAILED", EventLogEntryType.Error);
            }

            return (int)ConsoleApplication.ErrorCode;
        }
    #endregion

        #region static methods

        /// <summary>
        /// Load configuration for certificate installation
        /// </summary>
        private static void LoadConfigForCertInstallation()
        {
            HelperLibrary.CertPath = ConfigurationManager.AppSettings["CertPath"];
            HelperLibrary.CertInstaller = ConfigurationManager.AppSettings["CertInstaller"];
        }

        /// <summary>
        /// Display the test result
        /// </summary>
        /// <param name="msg">Message to display</param>
        /// <param name="testName">Current test name</param>
        /// <param name="topic">The topic of the message</param>
        private static void DisplayTestResult(string msg, string testName, string topic)
        {
            if (msg != string.Empty)
            {
                Console.WriteLine(string.Format("{0} is:", topic));
                Console.WriteLine(msg);
            }
            else
            {
                Console.WriteLine(string.Format("{0} is empty", topic));
            }

            Console.WriteLine(string.Format("{0} done", testName));
        }

        /// <summary>
        /// Print usage of the program
        /// </summary>
        private static void PrintUsage()
        {
            Console.WriteLine("To view the available <Test Name>s and valid parameters for each service, enter:");
            Console.WriteLine("    LIVEntoolLocal.exe /help [Service Name]");
            Console.WriteLine();
            Console.WriteLine("    LIVEntoolLocal.exe /installcerts");
            Console.WriteLine();
            Console.WriteLine("The expected input of the executable is:");
            Console.WriteLine("    LIVEntoolLocal.exe[ /cachetoken <membername> <password>] /test <Test Name> [Parameter1] [Parameter2] ... [ParameterN]");
            Console.WriteLine();
            Console.WriteLine("[Service Name] can be one of the following:");

            // get list of services to show
            List<string> services = TestCollection.GetServices();
            foreach (string service in services)
            {
                Console.WriteLine("        {0}", service);
            }
        }

        /// <summary>
        /// Detailed information on the tests available for the given service and the valid arguments for each test.
        /// </summary>
        /// <param name="service">The service</param>
        private static void PrintDetailedUsage(string service)
        {
            Console.WriteLine("Supported tests for service '" + service + "':");
            List<ServiceTest> tests = TestCollection.GetTests(service);
            foreach (ServiceTest test in tests)
            {
                if (test.ShowInConsoleApp)
                {
                    string serializedArgs = string.Empty;
                    foreach (ServiceTest.ArgInfo arg in test.Arguments)
                    {
                        serializedArgs += string.Format(" <{0}>", arg.Name);
                    }

                    Console.WriteLine("{0}{1}", test, serializedArgs);
                }
            }
        }

        /// <summary>
        /// Display configuration parameters
        /// </summary>
        /// <param name="environment">The target environment</param>
        private static void DisplayConfigParams(string environment)
        {
            Console.WriteLine("Configuration parameters for " + environment.ToUpper() + " environment:");
            Console.WriteLine("Title ID = " + HelperLibrary.TitleId);
            Console.WriteLine("Title Version = " + HelperLibrary.TitleVersion);
            Console.WriteLine("Device ID = " + HelperLibrary.DeviceId);
            Console.WriteLine("Client Cert Thumbprint = " + HelperLibrary.ClientCertThumbprint);
            Console.WriteLine("Platform ID = " + HelperLibrary.PlatformId);
            Console.WriteLine("Language ID = " + HelperLibrary.LanguageId);
            Console.WriteLine("Country ID = " + HelperLibrary.CountryId);
            Console.WriteLine("Live ID Service Target = " + HelperLibrary.LiveIDServiceTarget);
            Console.WriteLine("STS = " + HelperLibrary.StsUrl);
            Console.WriteLine("XUACS = " + HelperLibrary.XuacsUrl);
            Console.WriteLine("Session Service = " + HelperLibrary.SessionServiceUrl);
            Console.WriteLine("Leaderboard URI = " + HelperLibrary.GetLeaderboardUrl);
            Console.WriteLine("Achivements URI = " + HelperLibrary.GetAchievementsUrl);
            Console.WriteLine("Datablob URI = " + HelperLibrary.GetDatablobUrl);
            Console.WriteLine("UserProfile Service URI = " + HelperLibrary.GetProfileUrl);
            Console.WriteLine("Notification Service URI = " + HelperLibrary.NotificationServiceUrl);
            Console.WriteLine("Reward Service URI = " + HelperLibrary.RewardServiceUrl);
            Console.WriteLine("Partner Manifest Update Service URI = " + HelperLibrary.ManifestUpdatePartUrl);
            Console.WriteLine("Public Gamer Picture Update Partner URI = " + HelperLibrary.GamerPicUpdatePartUrl);
            Console.WriteLine("Partner Closet Asset Service URI = " + HelperLibrary.GetClosetAssetPartUrl);
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LIVEnAuthClient\LIVEnToolGUI\Properties\Resources.Designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace LIVEnToolGUI.Properties
{


    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "2.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources
    {

        private static global::System.Resources.ResourceManager resourceMan;

        private static global::System.Globalization.CultureInfo resourceCulture;

        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources()
        {
        }

        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager
        {
            get
            {
                if ((resourceMan == null))
                {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("LIVEnToolGUI.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }

        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture
        {
            get
            {
                return resourceCulture;
            }
            set
            {
                resourceCulture = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\ServiceBrokerQueue\Program.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="Program.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="a-gamavi">
//     Andrew Mathes
// </author>
//
// <summary>
//  Service Broker Queue service tool to enable the disabled queue
//  Also can be used to find the status and message count of the queue
//  Default values Server = Current, Database = RewardsQueueDb, Queue = RewardsTargetQueue
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="2010.06.21">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace ConsoleApplication
{
    using System;
    using System.Text;
    using Wgx.Common.ServiceBroker;

    /// <summary>
    /// Main program for the tool
    /// </summary>
    public class ConsoleApplication
    {
        /// <summary>
        /// The public main method
        /// </summary>
        /// <param name="args">Command-line args</param>
        public static void Main(string[] args)
        {
            string server = String.Empty;
            string database = String.Empty;
            string queue = String.Empty;
            string action = String.Empty;

            int argindex = 0;
            while (argindex < args.Length)
            {
                switch (args[argindex])
                {                
                    case "/server":
                        server = args[argindex+1];
                        break;

                    case "/db":
                        database = args[argindex + 1];
                        break;

                    case "/queue":
                        queue = args[argindex + 1];
                        break;

                    case "/action":
                        action = args[argindex + 1];
                        break;

                    case "/help":
                    case "help":
                    case "-?":
                    case "?":
                    case "/?":
                        PrintUsage();
                        return;

                    default:
                        break;
                }

                argindex++; 
            }

            if (String.IsNullOrEmpty(action))
            {
                // default to status
                action = "status";
            }

            try
            {
                ServiceBrokerQueue serviceBrokerQueue = new ServiceBrokerQueue(server, database, queue);

                switch (action.ToLower())
                {
                    case "status":
                        serviceBrokerQueue.IsEnbled();
                        break;

                    case "enable":
                        serviceBrokerQueue.Enable();
                        break;

                    case "count":
                        serviceBrokerQueue.MessageCount();
                        break;

                    default:
                        PrintUsage();
                        break;
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine("Unexpected exception caught");
                Console.WriteLine(ex.Message);
            }
        }
        
        
        /// <summary>
        /// Print usage of the program
        /// </summary>
        private static void PrintUsage()
        {
            Console.WriteLine("To enable the disable service broker queue. You must be an admin of the SQL Server");
            Console.WriteLine("You can also view the status and the message count of the queue");
            Console.WriteLine("****************************************************************************************************");
            Console.WriteLine("ServiceBrokerQueue [/server <server>] [/db <database>] [/queue <queue>] /action <ActionType>");
            Console.WriteLine("ActionType must be one of the following:");
            Console.WriteLine("              enable - Enables the queue if it is disabled");
            Console.WriteLine("              status - Returns the status of the queue");
            Console.WriteLine("              count - Returns the message count of the queue");
            Console.WriteLine("****************************************************************************************************");
            Console.WriteLine("Examples:");
            Console.WriteLine("ServiceBrokerQueue /server server1 /database RewardsQueueDb /queue RewardsTargetQueue /action enable");
            Console.WriteLine("ServiceBrokerQueue /action enable will defaults to /server <CurrentServer> /database RewardsQueueDb /queue RewardsTargetQueue /action enable");
        }
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LIVEnAuthClient\LIVEnToolLocal\ConfigProvider.cs ===
﻿//------------------------------------------------------------------------------------------------- 
// <copyright file="ConfigProvider.cs" company="Microsoft" author="a-thkuo">
//      Copyright © .  All rights reserved.
// </copyright>
// <summary>Code to get data from NPDB</summary>
//-------------------------------------------------------------------------------------------------
namespace LIVEnToolLocal
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using Leet.Core.Configuration;
    using Leet.Core.IO;
    using Leet.Core.IoCCo;
    using LIVEnTool;

    /// <summary>
    /// ConfigProvider class definition
    /// </summary>
    internal static class ConfigProvider
    {
        /// <summary>
        /// Register the given service name to the NPDB configuration provider
        /// </summary>
        /// <param name="serviceConfigName">The name of the service configuration to register</param>
        internal static void RegisterServiceToConfigProvider(string serviceConfigName)
        {
            Container.Instance.AddService<IRegistryProvider, RegistryProvider>();
            Container.Instance.AddService<IFileSystem, FileSystem>();
            ConfigurationSelector.RegisterProvider(serviceConfigName, "LEET");
        }

#if __DEPRECATED__
        /// <summary>
        /// Get the URLs for getting the RPS ticket and STS token from the config provider
        /// NOTE:  Deprecated because we read the URLs from App.config instead of from NPDB.
        /// </summary>
        /// <param name="serviceConfigName">Service name</param>
        internal static void UpdateRPSandTokenLinks()
        {
            IConfigurationProvider configProvider = Container.Instance.GetComponent<IConfigurationProvider>();
            HelperLibrary.LiveIDServiceTarget = configProvider.GetSetting(Settings.RPSTicketSite);
            HelperLibrary.StsUrl = configProvider.GetSetting(Settings.STSTokenSite);
        }
#endif

        /// <summary>
        /// Obtain the port number for the required service from NPDB via the configuration provider
        /// </summary>
        /// <param name="test">The service test name</param>
        /// <returns>The port number that corresponds to the service</returns>
        internal static int GetServicePortNumber(string test)
        {
            string virtualInterfaceName = TestCollection.GetVirtualInterfaceName(test);
            IConfigurationProvider configProvider = Container.Instance.GetComponent<IConfigurationProvider>();
            IInterfaceInfo info = configProvider.GetSingleInterface(virtualInterfaceName + ".Health");
            return info.Port;
        }

        /// <summary>
        /// Method to get the test environment of the server from Configuration Provider
        /// </summary>
        /// <param name="serviceConfigName">Service configuration name</param>
        /// <param name="environment">The placeholder for the environment</param>
        internal static void GetServerEnvironment(string serviceConfigName, out string environment)
        {
            Container.Instance.AddService<IRegistryProvider, RegistryProvider>();
            Container.Instance.AddService<IFileSystem, FileSystem>();
            ConfigurationSelector.RegisterProvider(serviceConfigName, "LEET");

            IConfigurationProvider configProvider = Container.Instance.GetComponent<IConfigurationProvider>();

            environment = string.Empty;

            switch (configProvider.Environment.ToLowerInvariant())
            {
                case "livenoob":
                case "dev":
                    environment = "dev";
                    break;

                case "testnet":
                    environment = "test";
                    break;

                case "stressnet":
                    environment = "stress";
                    break;

                case "int2":
                    environment = "int2";
                    break;

                case "partnernet":
                    environment = "part";
                    break;

                default:
                    break;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\IisRunner\AccessStep.cs ===
using System;
using System.Xml;
using System.Management;

using Leet.Tools.Setup.Wmi.Iisv2;
using Leet.Tools.Setup.XmlSequencer;

namespace Leet.Tools.Setup.IisRunner
{
    /// <summary>
    /// Handles configuration of IIS Metabase access settings.
    /// </summary>
    /// <remarks>
    /// <para>
    /// This step handles the <c>&lt;access&gt;</c> element in an IisRunner configuration file.
    /// It allows configuring file access permissions for the parent IIS object of the element.
    /// </para><para>
    /// The following table lists the attributes supported by the <c>&lt;access&gt;</c> element
    /// and a brief description of their meaning. For more information, see the IIS metebase 
    /// documentation at http://msdn.microsoft.com/library/default.asp?url=/library/en-us/iissdk/iis/ref_mb_dirbrowseflags.asp.
    /// </para>
    /// <para>
    /// All attributes default to false if not specified.
    /// </para>
    /// <list type="table">
    /// <listheader>
    ///     <term>Attribute</term>
    ///     <description>Description</description>
    /// </listheader>
    /// <item>
    ///     <term>read</term>
    ///     <description>A value of true indicates that the file or the contents of the folder may be read through Microsoft Internet Explorer.</description>
    /// </item>
    /// <item>
    ///     <term>write</term>
    ///     <description>A value of true indicates that users are allowed to upload files and their associated properties to the enabled directory on your server or to change content in a Write-enabled file. Write can be implemented only with a browser that supports the PUT feature of the HTTP 1.1 protocol standard.</description>
    /// </item>
    /// <item>
    ///     <term>source</term>
    ///     <description>A value of true indicates that users are allowed to access source code if either Read or Write permissions are set. Source code includes scripts in Microsoft  Active Server Pages (ASP) applications.</description>
    /// </item>
    /// <item>
    ///     <term>script</term>
    ///     <description>A value of true indicates that the file or the contents of the folder may be executed if they are script files or static content. A value of false only allows static files, such as HTML files, to be served.</description>
    /// </item>
    /// <item>
    ///     <term>execute</term>
    ///     <description>A value of true indicates that the file or the contents of the folder may be executed, regardless of file type.</description>
    /// </item>
    /// <item>
    ///     <term>noRemoteRead</term>
    ///     <description>A value of true indicates that remote requests to view files are denied; only requests from the same computer as the IIS server succeed if the AccessRead property is set to true. You cannot set AccessNoRemoteRead to false to enable remote requests, and set AccessRead to false to disable local requests.</description>
    /// </item>
    /// <item>
    ///     <term>noRemoteWrite</term>
    ///     <description>A value of true indicates that remote requests to create or change files are denied; only requests from the same computer as the IIS server succeed if the AccessWrite property is set to true. You cannot set AccessNoRemoteWrite to false to enable remote requests, and set AccessWrite to false to disable local requests.</description>
    /// </item>
    /// <item>
    ///     <term>noRemoteScript</term>
    ///     <description>A value of true indicates that remote requests to view dynamic content are denied; only requests from the same computer as the IIS server succeed if the AccessScript property is set to true. You cannot set AccessNoRemoteScript to false to enable remote requests, and set AccessScript to false to disable local requests.</description>
    /// </item>
    /// <item>
    ///     <term>noRemoteExecute</term>
    ///     <description>A value of true indicates that remote requests to execute applications are denied; only requests from the same computer as the IIS server succeed if the AccessExecute property is set to true. You cannot set AccessNoRemoteExecute to false to enable remote requests, and set AccessExecute to false to disable local requests.</description>
    /// </item>
    /// <item>
    ///     <term>noPhysicalDir</term>
    ///     <description>A value of true indicates that access to the physical path is not allowed.</description>
    /// </item>
    /// </list> 
    ///</remarks>
    [StepElement("Access")]
    public class AccessStep : Step
    {
        public AccessStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
        }

        protected override void OnExecute()
        {
            base.OnExecute ();

            ManagementBaseObject directory = StepNavigation.GetAncestorDirectorySettingObject(this);

            int accessFlags = 0;

            if (String.Compare(BaseXmlElement.GetAttribute("execute"), "true", true) == 0)
            {
                accessFlags |= 0x00000004;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("read"), "true", true) == 0)
            {
                accessFlags |= 0x00000001;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("script"), "true", true) == 0)
            {
                accessFlags |= 0x00000200;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("source"), "true", true) == 0)
            {
                accessFlags |= 0x00000010;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("write"), "true", true) == 0)
            {
                accessFlags |= 0x00000002;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("noPhysicalDir"), "true", true) == 0)
            {
                accessFlags |= 0x00008000;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("noRemoteExecute"), "true", true) == 0)
            {
                accessFlags |= 0x00002000;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("noRemoteRead"), "true", true) == 0)
            {
                accessFlags |= 0x00001000;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("noRemoteScript"), "true", true) == 0)
            {
                accessFlags |= 0x00004000;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("noRemoteWrite"), "true", true) == 0)
            {
                accessFlags |= 0x00000400;
            }

            // BUG: There appears to be a problem with the WMI provider. If accessFlags == 0
            // then the AccessFlags item never gets written to the metabase. Other values work fine.
            // I've spent too much time trying to solve this, so I'm moving on.

            directory["AccessFlags"] = accessFlags;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\IisRunner\ApplicationPoolStep.cs ===
using System;
using System.IO;
using System.Xml;
using System.Management;
using System.Data.SqlClient;

using Leet.Tools.Setup.Wmi.Iisv2;
using Leet.Tools.Setup.XmlSequencer;

namespace Leet.Tools.Setup.IisRunner
{
	/// <summary>
	/// Summary description for WebSeverStep.
	/// </summary>
	[StepElement("ApplicationPool")]
	public class ApplicationPoolStep : StepContainer
	{
        private string name = null;
        private IIsApplicationPoolSetting applicationPoolSetting = null;

        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
        public ApplicationPoolStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
            name = BaseXmlElement.GetAttribute("name");
            
            if (name.Length == 0)
            {
                throw new ArgumentException("The name attribute of the " + stepElement.Name + " element must be specified.", "name");
            }
        }

        /// <summary>
        /// 
        /// </summary>
       public string Name
        {
            get {return name;}
        }

        public IIsApplicationPoolSetting ApplicationPoolSetting
        {
            get {return applicationPoolSetting;}
        }

        /// <summary>
        /// 
        /// </summary>
        public IisRunnerStep IisRunnerStep
        {
            get 
            {
                if (!(Root is IisRunnerStep))
                {
                    throw new InvalidOperationException("The root step must be IisRunnerStep for ApplicationPoolSetup to function correctly."); 
                }
                return (IisRunnerStep) Root;
            }
        }

        protected override void OnExecute()
        {
            ManagementScope mScope = IisRunnerStep.IisManagementScope;

            string keyName = "W3SVC/AppPools/" + Name;

            applicationPoolSetting = GetApplicationPoolSetting(keyName);

            if (ApplicationPoolSetting == null)
            {
                Root.LogMessage(String.Format("Creating Application Pool {0}.", Name));

                applicationPoolSetting = IIsApplicationPoolSetting.CreateInstance();
                applicationPoolSetting.LateBoundObject["Name"]   = keyName;
            }

            // let contained steps execute
            base.OnExecute ();
        }

        protected override void OnAfterExecute()
        {
            ManagementScope mScope = IisRunnerStep.IisManagementScope;

            string keyName = "W3SVC/AppPools/" + Name;

            if (ApplicationPoolSetting != null)
            {
                ApplicationPoolSetting.CommitObject();
            }

            IIsApplicationPool applicationPool = new IIsApplicationPool(mScope, keyName);

            try
            {
                applicationPool.Start();
            }
            catch (System.Runtime.InteropServices.COMException)
            {
                Root.LogMessage("Couldn't start application pool " + Name + ".");
            }

            Root.LogMessage("Create of application pool complete");

            applicationPoolSetting = null;
            base.OnAfterExecute ();
        }

        private IIsApplicationPoolSetting GetApplicationPoolSetting(string keyName)
        {
            ManagementScope mScope = IisRunnerStep.IisManagementScope;
    
            IIsApplicationPoolSetting.IIsApplicationPoolSettingCollection sites = IIsApplicationPoolSetting.GetInstances();
    
            foreach(IIsApplicationPoolSetting site in sites)
            {
                if (String.Compare(site.Name, keyName, true) == 0)
                {
                    return site;
                }
            }
    
            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\IisRunner\AppPoolIdentityStep.cs ===
using System;
using System.Xml;
using System.Management;
using System.DirectoryServices;

using Leet.Tools.Setup.Wmi.Iisv2;
using Leet.Tools.Setup.XmlSequencer;

namespace Leet.Tools.Setup.IisRunner
{
    /// <summary>
    /// Summary description for AppPoolIdentityStep.
    /// </summary>
    [StepElement("AppPoolIdentity")]
    public class AppPoolIdentityStep : Step
    {
        enum AppPoolIdentityType
        {
            LocalSystem = 0,
            LocalService = 1,
            NetworkService = 2,
            SpecificUser = 3
        }

        private AppPoolIdentityType type = AppPoolIdentityType.LocalSystem;
        private string userName = null;
        private string userPass = null;

        public AppPoolIdentityStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
            string poolType = stepElement.GetAttribute("type");

            if (String.Compare(poolType, "localsystem", true) == 0)
            {
                type = AppPoolIdentityType.LocalSystem;
            }
            else if (String.Compare(poolType, "localservice", true) == 0)
            {
                type = AppPoolIdentityType.LocalService;
            }
            else if (String.Compare(poolType, "networkservice", true) == 0)
            {
                type = AppPoolIdentityType.NetworkService;
            }
            else if (String.Compare(poolType, "user", true) == 0)
            {
                type = AppPoolIdentityType.SpecificUser;
            }
            else
            {
                throw new ArgumentException(stepElement.Name + " element requires a type attribute which must be either localsystem, localservice, networkservice, or user.", "type");
            }

            userName = stepElement.GetAttribute("userName");
            userPass = stepElement.GetAttribute("userPass");
        }

        protected override void OnExecute()
        {
            base.OnExecute ();

            ApplicationPoolStep appPoolStep = StepNavigation.GetApplicationPoolAncestorOfStep(this);
            ManagementBaseObject appPoolSetting = appPoolStep.ApplicationPoolSetting.LateBoundObject;

            appPoolSetting["AppPoolIdentityType"] = (int) this.type;

            if (userName.Length != 0)
            {
                if (type == AppPoolIdentityType.SpecificUser)
                {
                    AddUserToIisWpg(userName);
                }

                appPoolSetting["WAMUserName"] = userName;
            }

            if (userPass.Length != 0)
            {
                appPoolSetting["WAMUserPass"] = userPass;
            }
        }

        private void AddUserToIisWpg(string ImpersonateUser)
        {
            DirectoryEntry localMachine = new DirectoryEntry("WinNT://" + Environment.MachineName);
            DirectoryEntry group  = null;

            string ldapUser = ImpersonateUser.Replace('\\', '/');

            try
            {
                group = localMachine.Children.Find("IIS_WPG", "Group");
            }
            catch
            {
                try
                {
                    group = localMachine.Children.Find("IIS_IUSRS", "Group");
                }
                catch
                {
                    throw new ApplicationException("Unable to find the local IIS group (IIS_WPG or IIS_IUSRS)");
                }
            }
                
            try
            {
                group.Invoke("Add", new Object[] {"WinNT://" + ldapUser});     // E.G. WinNT://test/uodb_user
            }
            catch
            {
                // $REVIEW (michion): assume failures are from adding a user already present
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\IisRunner\AppPoolPerformanceStep.cs ===
using System;
using System.Xml;
using System.Management;
using System.DirectoryServices;

using Leet.Tools.Setup.Wmi.Iisv2;
using Leet.Tools.Setup.XmlSequencer;

namespace Leet.Tools.Setup.IisRunner
{
    /// <summary>
    /// Summary description for AppPoolPerformanceStep.
    /// </summary>
    [StepElement("AppPoolPerformance")]
    public class AppPoolPerformanceStep : Step
    {

        public AppPoolPerformanceStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
        }

        public int IdleTimeout
        {
            get
            {
                string configIdleTimeout = BaseXmlElement.GetAttribute("idleTimeout");
                if (configIdleTimeout.Length == 0)
                {
                    return 20;
                }

                return Convert.ToInt32(configIdleTimeout);
            }
        }

        public int RequestQueueLimit
        {
            get
            {
                string configValue = BaseXmlElement.GetAttribute("requestQueueLimit");
                if (configValue.Length == 0)
                {
                    return 4000;
                }

                return Convert.ToInt32(configValue);                
            }
        }

        public int MaxProcesses
        {
            get
            {
                string configValue = BaseXmlElement.GetAttribute("maxProcesses");
                if (configValue.Length == 0)
                {
                    return 1;
                }

                return Convert.ToInt32(configValue);                
            }
        }

        public int CpuLimit
        {
            get
            {
                string configValue = BaseXmlElement.GetAttribute("cpuLimit");
                if (configValue.Length == 0)
                {
                    return 0;
                }

                return Convert.ToInt32(configValue);                
            }
        }

        public int CpuResetInterval
        {
            get
            {
                string configValue = BaseXmlElement.GetAttribute("cpuResetInterval");
                if (configValue.Length == 0)
                {
                    return 5;
                }

                return Convert.ToInt32(configValue);                
            }
        }

        public int CpuAction
        {
            get
            {
                string configValue = BaseXmlElement.GetAttribute("cpuAction");
                if (configValue.Length == 0)
                {
                    return 0;
                }

                return Convert.ToInt32(configValue);                
            }
        }

        public int AppPoolQueueLength
        {
            get
            {
                string configValue = BaseXmlElement.GetAttribute("appPoolQueueLength");
                if (configValue.Length == 0)
                {
                    return 4000;
                }

                return Convert.ToInt32(configValue);                
            }
        }

        public int PeriodicRestartTime
        {
            get
            {
                string configValue = BaseXmlElement.GetAttribute("periodicRestartTime");
                if (configValue.Length == 0)
                {
                    return 1740;
                }

                return Convert.ToInt32(configValue);                
            }
        }

        public int PeriodicRestartMemory
        {
            get
            {
                string configValue = BaseXmlElement.GetAttribute("periodicRestartMemory");
                if (configValue.Length == 0)
                {
                    return 0;
                }

                return Convert.ToInt32(configValue);                
            }
        }

        public int PeriodicRestartPrivateMemory
        {
            get
            {
                string configValue = BaseXmlElement.GetAttribute("periodicRestartPrivateMemory");
                if (configValue.Length == 0)
                {
                    return 0;
                }

                return Convert.ToInt32(configValue);                
            }
        }

        public override void Validate()
        {
            int testValue;
            testValue = this.IdleTimeout;
            testValue = this.RequestQueueLimit;
            testValue = this.MaxProcesses;
            testValue = this.CpuLimit;
            testValue = this.CpuResetInterval;
            testValue = this.CpuAction;
            testValue = this.AppPoolQueueLength;
            testValue = this.PeriodicRestartTime;
            testValue = this.PeriodicRestartMemory;
            testValue = this.PeriodicRestartPrivateMemory;
        }

        protected override void OnExecute()
        {
            base.OnExecute ();

            ApplicationPoolStep appPoolStep = StepNavigation.GetApplicationPoolAncestorOfStep(this);
            ManagementBaseObject appPoolSetting = appPoolStep.ApplicationPoolSetting.LateBoundObject;

            appPoolSetting["IdleTimeout"] = this.IdleTimeout;
            appPoolSetting["AppPoolQueueLength"] = this.RequestQueueLimit;
            appPoolSetting["MaxProcesses"] = this.MaxProcesses;
            appPoolSetting["CPULimit"] = this.CpuLimit;
            appPoolSetting["CPUResetInterval"] = this.CpuResetInterval;
            appPoolSetting["CPUAction"] = this.CpuAction;
            appPoolSetting["AppPoolQueueLength"] = this.AppPoolQueueLength;
            appPoolSetting["PeriodicRestartTime"] = this.PeriodicRestartTime;
            appPoolSetting["PeriodicRestartMemory"] = this.PeriodicRestartMemory;
            appPoolSetting["PeriodicRestartPrivateMemory"] = this.PeriodicRestartPrivateMemory;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\IisRunner\AuthenticationStep.cs ===
using System;
using System.Xml;
using System.Management;

using Leet.Tools.Setup.Wmi.Iisv2;
using Leet.Tools.Setup.XmlSequencer;

namespace Leet.Tools.Setup.IisRunner
{
    /// <summary>
    /// Summary description for AuthenticationStep.
    /// </summary>
    [StepElement("Authentication")]
    public class AuthenticationStep : Step
    {
        public AuthenticationStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
        }

        protected override void OnExecute()
        {
            base.OnExecute ();

            ManagementBaseObject directory = StepNavigation.GetAncestorDirectorySettingObject(this);

            int authFlags = 0;

            if (BaseXmlElement.GetAttribute("anonymous").ToLower() == "true")
            {
                authFlags |= 0x00000001;
            }

            if (BaseXmlElement.GetAttribute("basic").ToLower() == "true")
            {
                authFlags |= 0x00000002;
            }

            if (BaseXmlElement.GetAttribute("digest").ToLower() == "true")
            {
                authFlags |= 0x00000010;
            }

            if (BaseXmlElement.GetAttribute("windows").ToLower() == "true")
            {
                authFlags |= 0x00000004;
            }

            if (BaseXmlElement.GetAttribute("passport").ToLower() == "true")
            {
                authFlags |= 0x00000040;
            }

            directory["AuthFlags"] = authFlags;

            if (BaseXmlElement.GetAttribute("realm").Length > 0)
            {
                directory["Realm"] = BaseXmlElement.GetAttribute("realm");
            }

            if (BaseXmlElement.GetAttribute("defaultLogonDomain").Length > 0)
            {
                directory["DefaultLogonDomain"] = BaseXmlElement.GetAttribute("defaultLogonDomain");
            }

            if (BaseXmlElement.GetAttribute("anonymousUserPass").Length > 0)
            {
                directory["AnonymousUserPass"] = BaseXmlElement.GetAttribute("anonymousUserPass");
            }

            if (BaseXmlElement.GetAttribute("anonymousUserName").Length > 0)
            {
                directory["AnonymousUserName"] = BaseXmlElement.GetAttribute("anonymousUserName");
            }

            if (BaseXmlElement.GetAttribute("anonymousPasswordSync").Length > 0)
            {
                if (BaseXmlElement.GetAttribute("anonymousPasswordSync").ToLower() == "false")
                {
                    directory["AnonymousPasswordSync"] = false;
                }
                else
                {
                    directory["AnonymousPasswordSync"] = true;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\IisRunner\ApplicationStep.cs ===
using System;
using System.Xml;
using System.Management;
using System.DirectoryServices;

using Leet.Tools.Setup.Wmi.Iisv2;
using Leet.Tools.Setup.XmlSequencer;

namespace Leet.Tools.Setup.IisRunner
{
    /// <summary>
    /// Summary description for ApplicationStep.
    /// </summary>
    [StepElement("Application")]
    public class ApplicationStep : StepContainer
    {
        private ApplicationMode appMode = ApplicationMode.InProcess;
        private string poolName = null;
        private bool aspAllowSessionState = true;
        private int aspSessionTimeout = 20;

        public ApplicationStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
            string modeText = stepElement.GetAttribute("mode");

            if (String.Compare(modeText, "InProcess", true) == 0)
            {
                appMode = ApplicationMode.InProcess;
            }
            else if (String.Compare(modeText, "OutOfProcess", true) == 0)
            {
                appMode = ApplicationMode.OutOfProcess;
            }
            else if (String.Compare(modeText, "Pooled", true) == 0)
            {
                appMode = ApplicationMode.Pooled;
            }
            else
            {
                throw new ArgumentException(stepElement.Name + " element requires a mode attribute which must be either InProcess, OutOfProcess, or Pooled.", "mode");
            }

            string szAspAllowSessionState = stepElement.GetAttribute("aspAllowSessionState");

            aspAllowSessionState = (szAspAllowSessionState.Length == 0 || szAspAllowSessionState.Equals("yes") || szAspAllowSessionState.Equals("true") || szAspAllowSessionState.Equals("on") || szAspAllowSessionState.Equals("1"));

            string szAspSessionTimeout = stepElement.GetAttribute("aspSessionTimeout");

            if (szAspSessionTimeout.Length == 0)
            {
                aspSessionTimeout = 20;
            }
            else
            {
                int iTimeout = Convert.ToInt32(szAspSessionTimeout);
                if (iTimeout < 0)
                {
                    iTimeout = 0;
                }

                aspSessionTimeout = iTimeout;
            }

            poolName = stepElement.GetAttribute("poolName");
        }

        protected override void OnExecute()
        {
            IApplicationHost appHost = StepNavigation.GetAncestorApplicationHost(this);
            appHost.CreateApplication(appMode, poolName);

            ManagementBaseObject appDir = StepNavigation.GetAncestorDirectorySettingObject(this);
            appDir["AspAllowSessionState"] = (aspAllowSessionState ? 1 : 0);
            appDir["AspSessionTimeout"] = aspSessionTimeout;

            // execute child steps after application is created
            base.OnExecute ();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\ServiceCallers\Notification\Program.cs ===
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Configuration;
using System.Runtime.Serialization;
using System.Text;
using AsyncMultiplayer.NotificationService;


namespace SendInvite
{
    class Program
    {
        // <summary>
        /// Default Live ID service target string
        /// </summary>
        private const string DefaultLiveIDServiceTarget = "http://kdc.xblob.xboxlive.com";

        /// <summary>
        /// Live ID Service target
        /// </summary>
        private static string liveIDServiceTarget;

        /// <summary>
        /// STS URL string
        /// </summary>
        private static string stsUrl;

        /// <summary>
        /// Platform ID
        /// </summary>
        private static string platformId;

        /// <summary>
        /// Title ID string
        /// </summary>
        private static string titleId;

        /// <summary>
        /// Title version string
        /// </summary>
        private static string titleVersion;

        /// <summary>
        /// Client version string
        /// </summary>
        private static string clientVersion;

        /// <summary>
        /// Device ID string
        /// </summary>
        private static string deviceId;

        /// <summary>
        ///Receipient list
        /// </summary>
        private static string recipients;

        /// <summary>
        ///Notitification Url
        /// </summary>
        private static string notificationservice;


        /// <summary>
        /// Action enumeration
        /// </summary>
        private enum Action
        {
            /// <summary>
            /// Invalid action
            /// </summary>
            None,

            /// <summary>
            /// Action to send invite
            /// </summary>
            SendInvite
        }
        /// <summary>
        /// Main entry Point
        /// </summary>
        /// <param name="args"></param>
        static void Main(string[] args)
        {
            Action action = Action.None;
            uint gameId =0;
            string sessionId = "";
  
              // Check parameters, if no parameter print usage
            if (args.Count() == 0)
            {
                ShowUsage();
                return;    
            }

            switch (args[0].ToLower())
            {
                case "-i":
                case "/i":
                    // Action is to call Invite functionality
                    if ((args.Count()> 4) || (args.Count()<3))
                    {
                        ShowUsage();
                        return;
                    }
                    if (args.Count() == 4)
                    {
                        Program.recipients = args[3];
                    }
                    gameId = UInt32.Parse(args[2]);
                    sessionId = args[1];
                    action = Action.SendInvite;
                    break;
                default:
                    ShowUsage();
                    return;
            }

            try
            {
                LoadConfiguration();
                // Get RPS ticket
                Console.WriteLine("Getting RPS Ticket...");
                string rpsTicket = LIVEnAuthClient.LIVEnAuthClient.GetRPSTicket(ConfigurationManager.AppSettings["SenderName"], ConfigurationManager.AppSettings["SenderPassword"], ConfigurationManager.AppSettings["LiveIDServiceTarget"]);

                // Get STS Token
                Console.WriteLine("Getting STS Token...");
                string stsToken = LIVEnAuthClient.LIVEnAuthClient.GenerateSTSTicket(
                    rpsTicket,
                    Program.stsUrl,
                    Program.platformId,
                    Program.titleId,
                    Program.titleVersion,
                    Program.clientVersion,
                    Program.deviceId,
                    "");

                switch(action)
                {
                    case Action.SendInvite:
                        int response = SendInviteRequest(stsToken,sessionId, gameId);
                        if (response != 0)
                        {
                            Console.WriteLine("SendInvite FAILED");
                        }
                        else
                        {
                            Console.WriteLine("SendInvite SUCCEEDED");
                        }
                        break;

                }
            
            }
            catch (Exception e)
            {
                Console.WriteLine("Unexpected exception: " + e.ToString());
            }
           
        }

        /// <summary>
        /// Send Invitation Request
        /// </summary>
        /// <param name="stsToken"></param>
        /// <param name="sessionId"></param>
        /// <param name="gameId"></param>
        /// <returns></returns>
        private static int SendInviteRequest(string stsToken,string sessionId, uint gameId)
        {
            try
            {
                InviteRequest invite = new InviteRequest();
                invite.GameId = gameId;
                invite.SessionId = sessionId;
                invite.Recipients = Program.recipients;

                WebClient client = new WebClient();
                string requestBody = null;
                string uri = String.Format("{0}invite/", Program.notificationservice);

                MemoryStream mStream = new MemoryStream();
                var dcs = new DataContractSerializer(typeof(InviteRequest));
                dcs.WriteObject(mStream, invite);
                mStream.Position = 0;
                StreamReader reader = new StreamReader(mStream);
                requestBody = reader.ReadToEnd();

                // Send POST request
                Console.WriteLine("Sending POST request: " + uri);
                byte[] buffer = Encoding.ASCII.GetBytes(requestBody);
                WebRequest request = WebRequest.Create(uri);
                request.ContentType = "application/xml";
                request.Method = "POST";
                request.ContentLength = buffer.Length;

                request.Headers.Add("X-Authorization", "XBL1.0 x=" + stsToken);
                request.Headers.Add("X-Locale", "1033");
                //request.Timeout = 50000;

                Stream st = request.GetRequestStream();
                st.Write(buffer, 0, buffer.Length);
                st.Close();
                var response = (HttpWebResponse)request.GetResponse();
                if (response.StatusCode == HttpStatusCode.OK)
                {
                    return 0;
                }
                else
                {
                    Console.WriteLine("Received an invalid response " + response.StatusDescription);
                    return -1;
                }
            }
            catch (WebException e)
            {
                StreamReader sr = new StreamReader(e.Response.GetResponseStream());

                Console.WriteLine(sr.ReadToEnd().Trim());
                return -1;
                
            }
           
        }


        /// <summary>
        /// Method to load all configurations
        /// </summary>
        private static void LoadConfiguration()
        {
            // Retrieve all configuration values
            Program.liveIDServiceTarget = ConfigurationManager.AppSettings["LiveIDServiceTarget"];
            Program.stsUrl = ConfigurationManager.AppSettings["StsUrl"];
            //Program.xuacsUrl = ConfigurationManager.AppSettings["XuacsUrl"];
            if (string.IsNullOrEmpty(liveIDServiceTarget))
            {
                Program.liveIDServiceTarget = Program.DefaultLiveIDServiceTarget;
            }

            Program.platformId = ConfigurationManager.AppSettings["PlatformId"];
            Program.titleId = ConfigurationManager.AppSettings["TitleId"];
            Program.titleVersion = ConfigurationManager.AppSettings["TitleVersion"];
            Program.clientVersion = ConfigurationManager.AppSettings["ClientVersion"];
            Program.deviceId = ConfigurationManager.AppSettings["DeviceId"];
            Program.recipients = ConfigurationManager.AppSettings["Recipients"];
            Program.notificationservice = ConfigurationManager.AppSettings["NotificationsServiceUrl"];



        }
       
        private static void ShowUsage()
        {
            Console.WriteLine("Send invitiation to multiple email addresses:");
            Console.WriteLine("    NSFECaller.exe -i <sessionID> <gameId> [emailaddresses");
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\IisRunner\DeleteWebServerStep.cs ===
using System;
using System.Xml;
using Microsoft.Win32;
using System.Management;
using System.Data.SqlClient;

using Leet.Tools.Setup.Wmi.Iisv2;
using Leet.Tools.Setup.XmlSequencer;

namespace Leet.Tools.Setup.IisRunner
{
	/// <summary>
	/// Summary description for DeleteDeleteWebServerStep.
	/// </summary>
	[StepElement("DeleteWebServer")]
	public class DeleteWebServerStep : Step
	{
        private int siteId = 0;

        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
		public DeleteWebServerStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
		{
            try
            {
                siteId = Convert.ToInt32(BaseXmlElement.GetAttribute("siteId"));
            }
            catch (FormatException)
            {
                throw new ArgumentOutOfRangeException("siteId", BaseXmlElement.GetAttribute("siteId"), "A numeric siteId attribute is required for a " + BaseXmlElement.Name + " element.");
            }
        }

        /// <summary>
        /// 
        /// </summary>
		public int SiteId
		{
            get { return siteId; }
		}

        /// <summary>
        /// 
        /// </summary>
        public IisRunnerStep IisRunnerStep
        {
            get 
            {
                if (!(Root is IisRunnerStep))
                {
                    throw new InvalidOperationException("The root step must be IisRunnerStep for DeleteWebServerStep to function correctly."); 
                }
                return (IisRunnerStep) Root;
            }
        }

        protected override void OnExecute()
        {
            base.OnExecute ();

            string keyName = "W3SVC/" + SiteId.ToString();
            Root.LogMessage("Deleting web server at " + keyName);

            ManagementScope mScope = IisRunnerStep.IisManagementScope;
            IIsWebServerSetting webServerSetting = new IIsWebServerSetting(mScope, keyName);

            try
            {
                webServerSetting.Delete();
            }
            catch (System.IO.DirectoryNotFoundException)
            {
                // The web server does not exist. Ignore the exception.
            }

            // If the site was registered with CMS, remove the EntryPoint information
            RegistryKey entryPoints = Registry.LocalMachine.OpenSubKey(@"SOFTWARE\NCompass\Resolution Content Server\Configuration\0\EntryPoints\", true);

            if (entryPoints != null)
            {
                entryPoints.DeleteSubKey(siteId.ToString(), false);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\IisRunner\DeleteVirtualDirStep.cs ===
using System;
using System.Xml;
using Microsoft.Win32;
using System.Management;
using System.Data.SqlClient;

using Leet.Tools.Setup.Wmi.Iisv2;
using Leet.Tools.Setup.XmlSequencer;

namespace Leet.Tools.Setup.IisRunner
{
    /// <summary>
    /// Summary description for DeleteVirtualDirStep.
    /// </summary>
    [StepElement("DeleteVirtualDir")]
    public class DeleteVirtualDirStep : Step
    {
        private string name = null;

        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
        public DeleteVirtualDirStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
            name = BaseXmlElement.GetAttribute("name");

            if (!name.StartsWith("/"))
            {
                throw new ArgumentException("The name attribute of the " + stepElement.Name + " element must be specified and begin with a /.", "name");
            }

        }

        /// <summary>
        /// 
        /// </summary>
        public int SiteId
        {
            get { return StepNavigation.GetWebServerAncestorOfStep(this).SiteId; }
        }

        public string Name
        {
            get { return name; }
        }

        public string KeyName
        {
            get 
            {
                if (Name == "/")
                {
                    return "W3SVC/" + SiteId.ToString() + "/root";
                }
                else
                {
                    return "W3SVC/" + SiteId.ToString() + "/root" + Name;
                }
            }
        }

            /// <summary>
            /// 
            /// </summary>
            public IisRunnerStep IisRunnerStep
        {
            get 
            {
                if (!(Root is IisRunnerStep))
                {
                    throw new InvalidOperationException("The root step must be IisRunnerStep for DeleteWebVirtualDirectoryStep to function correctly."); 
                }
                return (IisRunnerStep) Root;
            }
        }

        protected override void OnExecute()
        {
            base.OnExecute ();

            Root.LogMessage("Deleting virtual directory at " + KeyName);

            ManagementScope mScope = IisRunnerStep.IisManagementScope;
            IIsWebVirtualDirSetting virtualDirSetting = new IIsWebVirtualDirSetting(mScope, KeyName);

            try
            {
                virtualDirSetting.Delete();
            }
            catch (System.IO.DirectoryNotFoundException)
            {
                // The vdir does not exist. Ignore the exception.
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\IisRunner\DeleteApplicationPoolStep.cs ===
using System;
using System.Xml;
using Microsoft.Win32;
using System.Management;
using System.Data.SqlClient;

using Leet.Tools.Setup.Wmi.Iisv2;
using Leet.Tools.Setup.XmlSequencer;

namespace Leet.Tools.Setup.IisRunner
{
    /// <summary>
    /// Summary description for DeleteApplicationPoolStep.
    /// </summary>
    [StepElement("DeleteApplicationPool")]
    public class DeleteApplicationPoolStep : Step
    {
        private string name = null;

        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
        public DeleteApplicationPoolStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
            name = BaseXmlElement.GetAttribute("name");

            if (name.Length == 0)
            {
                throw new ArgumentException("The name attribute of the " + stepElement.Name + " element must be specified.", "name");
            }
        }

        public string Name
        {
            get { return name; }
        }

        public string KeyName
        {
            get {return "W3SVC/AppPools/" + Name;}
        }

        /// <summary>
        /// 
        /// </summary>
        public IisRunnerStep IisRunnerStep
        {
            get 
            {
                if (!(Root is IisRunnerStep))
                {
                    throw new InvalidOperationException("The root step must be IisRunnerStep for DeleteApplicationPoolStep to function correctly."); 
                }
                return (IisRunnerStep) Root;
            }
        }

        protected override void OnExecute()
        {
            base.OnExecute ();

            Root.LogMessage("Deleting application pool " + Name);

            ManagementScope mScope = IisRunnerStep.IisManagementScope;
            IIsApplicationPoolSetting appPoolSetting = new IIsApplicationPoolSetting(mScope, KeyName);

            try
            {
                appPoolSetting.Delete();
            }
            catch (System.IO.DirectoryNotFoundException)
            {
                // The app pool does not exist. Ignore the exception.
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\IisRunner\CustomErrorsStep.cs ===
using System;
using System.Xml;
using System.Management;

using Leet.Tools.Setup.Wmi.Iisv2;
using Leet.Tools.Setup.XmlSequencer;

namespace Leet.Tools.Setup.IisRunner
{
    /// <summary>
    /// Handles configuration of IIS Metabase access settings.
    /// </summary>
    /// <remarks>
    /// <para>
    /// This step handles the <c>&lt;CustomErrors&gt;</c> element in an IisRunner configuration file.
    /// It allows configuring custom errors for the parent IIS object of the element.
    /// </para><para>
    /// The following table lists the attributes supported by the <c>&lt;CustomErrors&gt;</c> element
    /// and a brief description of their meaning. For more information, see the IIS metabase 
    /// documentation at http://msdn.microsoft.com/library/default.asp?url=/library/en-us/iissdk/html/6a940e0e-4b75-4dc4-9606-8d98864333ce.asp.
    /// </para>
    /// <para>
    /// This step expects to have &lt;CustomError&gt; elements under it that define the specific custom errors. The expected attributes of
    /// these sub elements are:
    /// </para>
    /// <list type="table">
    /// <listheader>
    ///     <term>Attribute</term>
    ///     <description>Description</description>
    /// </listheader>
    /// <item>
    ///     <term>errorCode</term>
    ///     <description>This attribute specifies the HTTP error code, for example, "401". Error 401 is a server or DNS error.</description>
    /// </item>
    /// <item>
    ///     <term>errorSubCode</term>
    ///     <description>This attribute specifies the HTTP error subcode, for example, "5". Error 401-5 is a failure to authorize by an ISAPI or CGI application.</description>
    /// </item>
    /// <item>
    ///     <term>handlerType</term>
    ///     <description>This attribute The HandlerType property specifies whether the error page is a "FILE" or a "URL".</description>
    /// </item>
    /// <item>
    ///     <term>handlerLocation</term>
    ///     <description>
    ///     The handlerLocation attribute specifies the location of the error page. If handlerType is a file, then handlerLocation must be the 
    ///     absolute or relative path to the file. If HandlerType is a URL, then HandlerLocation must be the absolute or relative URL for the Web page.
    ///     </description>
    /// </item>
    /// </list> 
    ///</remarks>
    [StepElement("CustomErrors")]
    public class CustomErrorsStep : Step
    {
        public CustomErrorsStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
        }

        public IisRunnerStep IisRunnerStep
        {
            get 
            {
                if (!(Root is IisRunnerStep))
                {
                    throw new InvalidOperationException("The root step must be IisRunnerStep for WebServerSetup to function correctly."); 
                }
                return (IisRunnerStep) Root;
            }
        }

        protected override void OnExecute()
        {
            base.OnExecute ();

            Root.LogMessage("Adding custom errors.");

            CustomError[] errors = GetCustomErrors();

            ManagementBaseObject directory = StepNavigation.GetAncestorDirectorySettingObject(this);
            ManagementBaseObject[] httpErrors = new ManagementBaseObject[errors.Length];

            for (int errorIndex = 0; errorIndex < httpErrors.Length; errorIndex++)
            {
                ManagementPath mPath = new ManagementPath();
                mPath.ClassName = "HttpError";
                mPath.NamespacePath = "root\\MicrosoftIISv2";

                httpErrors[errorIndex] = new ManagementClass(IisRunnerStep.IisManagementScope, mPath, null).CreateInstance();
                httpErrors[errorIndex]["HttpErrorCode"] = errors[errorIndex].ErrorCode;
                httpErrors[errorIndex]["HttpErrorSubcode"] = errors[errorIndex].ErrorSubcode;
                httpErrors[errorIndex]["HandlerType"] = errors[errorIndex].HandlerType;
                httpErrors[errorIndex]["HandlerLocation"] = errors[errorIndex].HandlerLocation;
            }

            directory["HttpErrors"] = httpErrors;
        }

        public override void Validate()
        {
            GetCustomErrors();
            base.Validate ();
        }

        private CustomError[] GetCustomErrors()
        {
            XmlNodeList errorNodes = BaseXmlElement.SelectNodes("sequencens:CustomError", Root.NamespaceManager);
            CustomError[] customErrors = new CustomError[errorNodes.Count];

            for (int i = 0; i < errorNodes.Count; i++)
            {
                XmlElement errorElement = (XmlElement) errorNodes[i];

                customErrors[i].ErrorCode = errorElement.GetAttribute("errorCode");
                if (customErrors[i].ErrorCode.Length == 0)
                {
                    throw new ArgumentException("CustomError node detected without required errorCode attribute.");
                }

                customErrors[i].ErrorSubcode = errorElement.GetAttribute("errorSubCode");
                if (customErrors[i].ErrorSubcode.Length == 0)
                {
                    throw new ArgumentException("CustomError node detected without required errorCodeSubcode attribute.");
                }

                customErrors[i].HandlerType = errorElement.GetAttribute("handlerType").ToUpper();
                if (customErrors[i].HandlerType.Length == 0)
                {
                    throw new ArgumentException("CustomError node detected without required handlerType attribute.");
                }

                if ((customErrors[i].HandlerType != "URL") && (customErrors[i].HandlerType != "FILE"))
                {
                    throw new ArgumentException("CustomError node detected with a handlerType attribute that does not match allowed values \"URL\" or \"FILE\".");
                }

                customErrors[i].HandlerLocation = errorElement.GetAttribute("handlerLocation");
                if (customErrors[i].HandlerLocation.Length == 0)
                {
                    throw new ArgumentException("CustomError node detected without required handlerLocation attribute.");
                }
            }

            return customErrors;
        }
    
        private struct CustomError
        {
            public string ErrorCode;
            public string ErrorSubcode;
            public string HandlerType;
            public string HandlerLocation;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\IisRunner\DeleteApplicationStep.cs ===
using System;
using System.Xml;
using System.Management;
using System.DirectoryServices;

using Leet.Tools.Setup.Wmi.Iisv2;
using Leet.Tools.Setup.XmlSequencer;

namespace Leet.Tools.Setup.IisRunner
{
    /// <summary>
    /// Summary description for DeleteApplicationStep.
    /// </summary>
    [StepElement("DeleteApplication")]
    public class DeleteApplicationStep : Step
    {
        public DeleteApplicationStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
        }

        protected override void OnExecute()
        {
            base.OnExecute ();

            IApplicationHost appHost = StepNavigation.GetAncestorApplicationHost(this);
            appHost.DeleteApplication();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\IisRunner\FilterStep.cs ===
using System;
using System.IO;
using System.Xml;
using System.Management;
using System.Data.SqlClient;

using Leet.Tools.Setup.Wmi.Iisv2;
using Leet.Tools.Setup.XmlSequencer;

namespace Leet.Tools.Setup.IisRunner
{
    [StepElement("Filter")]
    public class FilterStep : Step
    {
        private string _name = null;
        private string _path = null;

        public FilterStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
            _name = BaseXmlElement.GetAttribute("name");
            _path = BaseXmlElement.GetAttribute("path");

            if (_name.Length == 0)
            {
                throw new ArgumentException("The name attribute of the filter element must be specified.", "name");
            }

            if (_path.Length == 0)
            {
                throw new ArgumentException("The path attribute of the filter element must be specified and must be a valid file system path.", "path");
            }
        }


        /// <summary>
        /// 
        /// </summary>
        public IisRunnerStep IisRunnerStep
        {
            get 
            {
                if (!(Root is IisRunnerStep))
                {
                    throw new InvalidOperationException("The root step must be IisRunnerStep for this step to function correctly."); 
                }
                return (IisRunnerStep) Root;
            }
        }

        protected override void OnExecute()
        {
            AddFilter(_name, _path);

            base.OnExecute ();
        }

        protected void AddFilter(string name, string path)
        {
            WebServerStep webserver = StepNavigation.GetWebServerAncestorOfStep(this);
            string folderPath = string.Format("W3SVC/{0}/Filters", webserver.SiteId);
            string filterPath = folderPath + "/" + name;

            Root.LogMessage(
                String.Format("Adding filter {0} ({1}).",
                name,
                path));

            //
            // append new filter to the end of load order
            //
            IIsFiltersSetting folder = new IIsFiltersSetting(folderPath);
            string loadOrder = folder.FilterLoadOrder;
            if (loadOrder.IndexOf(name) == -1)
            {
                if (loadOrder.Length > 0)
                {
                    loadOrder += ",";
                }

                loadOrder += name;

                folder.FilterLoadOrder = loadOrder;
            }

            //
            // create the new filter
            //
            IIsFilter filter = IIsFilter.CreateInstance();
            filter.LateBoundObject["Name"] = filterPath;
            filter.CommitObject();

            //
            // configure the new filter
            //
            IIsFilterSetting fs = new IIsFilterSetting(filterPath);
            fs.FilterPath = path;
            fs.FilterDescription = name;
            fs.FilterEnabled = true;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\IisRunner\HttpCompressionSchemeStep.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Xml;
using Leet.Tools.Setup.Wmi.Iisv2;
using Leet.Tools.Setup.XmlSequencer;
using System.Management;
using System.IO;
using System.Security.AccessControl;
using System.DirectoryServices;

namespace Leet.Tools.Setup.IisRunner
{
    /// <summary>
    /// Allows configuration of HttpCompression for all web sites on the server being configured.
    /// </summary>
    [StepElement("HttpCompressionScheme")]
    public class HttpCompressionSchemeStep : StepContainer
    {
        private IIsCompressionSchemeSetting _schemeSetting = null;
        private string _schemeName = null;

        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
        public HttpCompressionSchemeStep(XmlElement stepElement, StepContainer parent)
            : base(stepElement, parent)
        {
            _schemeName = BaseXmlElement.GetAttribute("scheme");

            if (_schemeName.Length == 0)
            {
                throw new ArgumentException("The scheme attribute of the " + stepElement.Name + " element must be specified.", "scheme");
            }
        }

        public bool? DoStaticCompression
        {
            get { return GetBoolAttribute("doStaticCompression"); }

        }

        public bool? DoDynamicCompression
        {
            get { return GetBoolAttribute("doDynamicCompression"); }
        }

        public bool? DoOnDemandCompression
        {
            get { return GetBoolAttribute("doOnDemandCompression"); }
        }

        public int? Priority
        {
            get { return GetIntAttribute("priority"); }
        }

        public int? DynamicCompressionLevel
        {
            get { return GetIntAttribute("dynamicCompressionLevel"); }
        }

        public int? OnDemandCompLevel
        {
            get { return GetIntAttribute("onDemandCompLevel"); }
        }

        /// <summary>
        /// 
        /// </summary>
        public IisRunnerStep IisRunnerStep
        {
            get
            {
                if (!(Root is IisRunnerStep))
                {
                    throw new InvalidOperationException("The root step must be IisRunnerStep for HttpCompressionSchemeStep to function correctly.");
                }
                return (IisRunnerStep)Root;
            }
        }

        protected override void OnExecute()
        {
            Root.LogMessage("Configuring HTTP Compression scheme properties for scheme '" + _schemeName + "'.");

            ManagementScope mScope = IisRunnerStep.IisManagementScope;

            _schemeSetting = WmiUtilities.FindCompressionSchemeSetting(mScope, _schemeName);

            if (_schemeSetting == null)
            {
                throw new ArgumentOutOfRangeException("A compression scheme with name '" + _schemeName + "' is not defined.");
            }

            if (DoDynamicCompression.HasValue)
            {
                _schemeSetting.HcDoDynamicCompression = DoDynamicCompression.Value;
            }

            if (DoStaticCompression.HasValue)
            {
                _schemeSetting.HcDoStaticCompression = DoStaticCompression.Value;
            }

            if (DoOnDemandCompression.HasValue)
            {
                _schemeSetting.HcDoOnDemandCompression = DoOnDemandCompression.Value;
            }

            if (Priority.HasValue)
            {
                _schemeSetting.HcPriority = Priority.Value;
            }

            if (DynamicCompressionLevel.HasValue)
            {
                _schemeSetting.HcDynamicCompressionLevel = DynamicCompressionLevel.Value;
            }

            if (OnDemandCompLevel.HasValue)
            {
                _schemeSetting.HcOnDemandCompLevel = OnDemandCompLevel.Value;
            }

            _schemeSetting.HcFileExtensions = GetFileExtensions(_schemeSetting.HcFileExtensions, "sequencens:FileExtensions");
            _schemeSetting.HcScriptFileExtensions = GetFileExtensions(_schemeSetting.HcScriptFileExtensions, "sequencens:ScriptFileExtensions");

            _schemeSetting.CommitObject();
        }

        public override void Validate()
        {
            bool? tempBool;
            int? tempInt;
            string[] tempStrings;

            tempBool = DoDynamicCompression;
            tempBool = DoStaticCompression;
            tempBool = DoOnDemandCompression;
            tempInt = Priority;
            tempInt = DynamicCompressionLevel;
            tempInt = OnDemandCompLevel;

            tempStrings = GetFileExtensions(new string[0], "sequencens:FileExtensions");
            tempStrings = GetFileExtensions(new string[0], "sequencens:ScriptFileExtensions");
        }

        private void ProcessScriptFileExtensions()
        {
            throw new NotImplementedException();
        }

        private string[] GetFileExtensions(string[] initialExtensions, string xpath)
        {
            XmlNode extensionNode = BaseXmlElement.SelectSingleNode(xpath, Root.NamespaceManager);
            if ((extensionNode != null) && (extensionNode.ChildNodes.Count > 0))
            {
                List<string> extensions = new List<string>(initialExtensions);

                foreach (XmlNode node in extensionNode.ChildNodes)
                {
                    if (node.NodeType == XmlNodeType.Element)
                    {
                        string extension;

                        switch (node.Name)
                        {
                            case "Add":
                                extension = ((XmlElement)node).GetAttribute("extension");
                                if (String.IsNullOrEmpty(extension))
                                {
                                    throw new ArgumentException("The Add element of a FileExtensions list must have an extension attribute.");
                                }

                                if (!extensions.Contains(extension))
                                {
                                    extensions.Add(extension);
                                }
                                break;

                            case "Remove":
                                extension = ((XmlElement)node).GetAttribute("extension");
                                if (String.IsNullOrEmpty(extension))
                                {
                                    throw new ArgumentException("The Remove element of a FileExtensions list must have an extension attribute.");
                                }

                                if (extensions.Contains(extension))
                                {
                                    extensions.Remove(extension);
                                }
                                break;

                            case "Clear":
                                extensions.Clear();
                                break;

                            default:
                                throw new ArgumentOutOfRangeException(node.Name, "'" + node.Name + "' is not a valid child element of FileExtensions.");
                        }
                    }
                }

                return extensions.ToArray();
            }

            return initialExtensions;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\IisRunner\IApplicationHost.cs ===
using System;
using System.Management;

namespace Leet.Tools.Setup.IisRunner
{
    public enum ApplicationMode
    {
        InProcess = 0,
        OutOfProcess = 1,
        Pooled = 2
    }

	/// <summary>
	/// Summary description for DirectorySettingStep.
	/// </summary>
    public interface IApplicationHost
	{
        void CreateApplication(ApplicationMode appMode, string appPoolName);
        void DeleteApplication();
        ManagementBaseObject DirectorySettingObject
        {
            get;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\IisRunner\IDirectorySetting.cs ===
using System;
using System.Management;

namespace Leet.Tools.Setup.IisRunner
{
	/// <summary>
	/// Summary description for DirectorySettingStep.
	/// </summary>
    interface IDirectorySetting
	{
        ManagementBaseObject DirectorySettingObject
        {
            get;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\IisRunner\IisRunnerCmd.cs ===
using System;
using System.IO;
using System.Xml;
using System.Diagnostics;
using System.Text.RegularExpressions;
using System.Collections.Generic;

using Leet.Tools.Setup.XmlSequencer;
using Leet.Core.IoCCo;
using Leet.Core.Configuration;
using Leet.Core.IO;

namespace Leet.Tools.Setup.IisRunner
{
    /// <summary>
    /// Provides a command line interface to the core IisRunner functionality.
    /// </summary>
    class IisRunnerCmd
    {
        private string _iisRunnerFilename = null;
        private StreamWriter _logFile = null;
        private bool _logToFile = false;
        private bool _logToEvent = false;
        private bool _configRecord = false;
        private bool _configPlayback = false;
        private Dictionary<string, string> _overrideVariables = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static int Main(string[] args)
        {
            Container.Instance.AddService<IRegistryProvider, RegistryProvider>();
            Container.Instance.AddService<IFileSystem, FileSystem>();

            ConfigurationSelector.RegisterProvider("iisrunner", "LEET");

            IisRunnerCmd theCmd = new IisRunnerCmd();
            theCmd.ParseCommandLine(args);
            int result = theCmd.RunIt();

            if (theCmd._logFile != null)
            {
                theCmd._logFile.Close();
            }

            return result;
        }

        /// <summary>
        /// Handles parsing of the command line arguments, setting member variables 
        /// based on the options and arguments specified.
        /// </summary>
        /// <param name="args">The arguments to process.</param>
        public void ParseCommandLine(string[] args)
        {
            int numberOfArgs = args.Length;
            Regex variableRegex = new Regex(
                @"^(?<name>[^=]+)=(?<value>.*)",
                RegexOptions.Compiled | RegexOptions.IgnoreCase);

            for (int currentArgIndex = 0; currentArgIndex < numberOfArgs; currentArgIndex++)
            {
                string currentArg = args[currentArgIndex];
                if (currentArg == "/?")
                {
                    ShowUsageInfo();
                    Environment.Exit(0);
                }
                else if (string.Compare(currentArg, "/lf", true) == 0)
                {
                    _logToFile = true;
                }
                else if (string.Compare(currentArg, "/le", true) == 0)
                {
                    _logToEvent = true;
                }
                else if (String.Equals(currentArg, "/record", StringComparison.OrdinalIgnoreCase))
                {
                    _configRecord = true;
                }
                else if (String.Equals(currentArg, "/playback", StringComparison.OrdinalIgnoreCase))
                {
                    _configPlayback = true;
                }
                else if (currentArg.StartsWith("/"))
                {
                    Console.WriteLine("ERROR: Invalid argument or option - '" + currentArg + "'.");
                    Console.WriteLine("Type \"IisRunner /?\" for usage help.");
                    Environment.Exit(1);
                }
                else if (variableRegex.IsMatch(currentArg))
                {
                    Match myMatch = variableRegex.Match(currentArg);
                    _overrideVariables[myMatch.Groups["name"].Value] = myMatch.Groups["value"].Value;
                }
                else
                {
                    if (_iisRunnerFilename == null)
                    {
                        _iisRunnerFilename = currentArg;
                    }
                    else
                    {
                        Console.WriteLine();
                        Console.WriteLine("Only one IisRunner input file can be specified on the command line. Second filename \"" + currentArg + "\" was encountered.");
                        Console.WriteLine("Type \"IisRunner /?\" for usage help.");
                        Environment.Exit(1);
                    }
                }
            }

            if (_iisRunnerFilename == null)
            {
                Console.WriteLine();
                Console.WriteLine("ERROR: Required input file name not specified.");
                Console.WriteLine("Type \"IisRunner /?\" for usage help.");
                Environment.Exit(1);
            }
        }

        private void VerifyParameter(string currentArg, int currentArgIndex, int numberOfArgs)
        {
            if (currentArgIndex + 1 >= numberOfArgs)
            {
                Console.WriteLine("ERROR: Option " + currentArg + " requires a value to be specified.");
                Console.WriteLine("Type \"IisRunner /?\" for usage help.");
                Environment.Exit(1);
            }
        }

        /// <summary>
        /// Displays information about this program and its command line agruments. 
        /// </summary>
        public void ShowUsageInfo()
        {
            Console.WriteLine();
            Console.WriteLine("IisRunner [/lf] [/le] [VARNAME=VALUE ...] inputfile");
            Console.WriteLine();
            Console.WriteLine("Description:");
            Console.WriteLine("    Executes IIS setup commands as specified by the IisRunner XML input file.");
            Console.WriteLine();
            Console.WriteLine("Parameter List:");
            Console.WriteLine("    /lf             Write messages to a log file (log file will have the");
            Console.WriteLine("                    same name as the runner file with a .log extension)");
            Console.WriteLine();
            Console.WriteLine("    /le             Write start, stop and exceptions to the application log.");
            Console.WriteLine();
            Console.WriteLine("    /record         Records any configuration information to the registry.");
            Console.WriteLine();
            Console.WriteLine("    /playback       Uses previously recorded configuration information ");
            Console.WriteLine("                    from the registry.");
            Console.WriteLine();
            Console.WriteLine("    VARNAME=VALUE   Specifies a variable name and its associated value");
            Console.WriteLine("                    to use when applying the configuration transform to");
            Console.WriteLine("                    the IisRunner XML input file. Any number of name/value");
            Console.WriteLine("                    definitions can be specified.");
            Console.WriteLine();
            Console.WriteLine("    inputfile       The filename of the XML input file to use.");
            Console.WriteLine();
            Console.WriteLine("  NOTE:  This tool returns an error level of 0 if all setup is successfully");
            Console.WriteLine("         executed, 1 if there are errors in the command line, or 2 if");
            Console.WriteLine("         there were problems processing the input XML or running the IIS setup");
            Console.WriteLine("         it defines.");
            Console.WriteLine();
            Console.WriteLine("Examples:");
            Console.WriteLine("    IisRunner www_xbox_com.xml");
            Console.WriteLine(@"    IisRunner SQLDATAPATH=h:\mssql\data");
            Console.WriteLine(@"              ""SQLLOGPATH=o:\mssql\log files\"" www_xbox_com.xml");
            Console.WriteLine();

        }

        /// <summary>
        /// Creates a IisRunnerStep object, configuring it based on the command line arguments,
        /// and executes it. 
        /// </summary>
        /// <returns>
        /// The errorlevel value that should be returned to the cmd environment.
        /// Returns 0 on success, 2 on failure. 
        ///</returns>
        public int RunIt()
        {
            string startMessage = String.Format("IisRunner started processing '{0}' at {1}", _iisRunnerFilename, DateTime.Now.ToString());
            Console.WriteLine(startMessage);

            if (_logFile != null)
            {
                _logFile.WriteLine(startMessage);
            }

            WriteEvent(startMessage, EventLogEntryType.Information);

            try
            {
                ConfigurationStore store = new ConfigurationStore("IisRunner", Path.GetFileNameWithoutExtension(_iisRunnerFilename));

                XmlDocument xmlDoc = new XmlDocument();
                xmlDoc.Load(_iisRunnerFilename);

                ConfigurationTransform transform = new ConfigurationTransform();

                if (_configPlayback)
                {
                    store.LoadConfiguration(transform.OverrideVariableCollection);
                }

                foreach (KeyValuePair<string, string> kvp in _overrideVariables)
                {
                    transform.OverrideVariableCollection[kvp.Key] = kvp.Value;
                }
                transform.TransformDocument(xmlDoc);

                if (_configRecord)
                {
                    store.SaveConfiguration(transform.OverrideVariableCollection);
                }

                IisRunnerStep runner = new IisRunnerStep(xmlDoc.DocumentElement);

                if (_logToFile)
                {
                    runner.OnMessage += new MessageEventHandler(FileMessageLogger);
                }

                runner.OnMessage += new MessageEventHandler(ConsoleMessageLogger);

                runner.Validate();
                runner.Execute();

            }
            catch (Exception ex)
            {
                string errorMessage = String.Format("\r\nException encountered executing IisRunner: \r\n{0}", ex.ToString());

                Console.WriteLine(errorMessage);

                if (_logFile != null)
                {
                    _logFile.WriteLine(errorMessage);
                }

                WriteEvent(errorMessage, EventLogEntryType.Error);

                return 2;
            }

            string doneMessage = String.Format("IisRunner processing of '{0}' completed at {1}", _iisRunnerFilename, DateTime.Now.ToString());

            Console.WriteLine(doneMessage);

            if (_logFile != null)
            {
                _logFile.WriteLine(doneMessage);
            }

            WriteEvent(doneMessage, EventLogEntryType.Information);

            return 0;
        }

        /// <summary>
        /// Event handler for IisRunnerStep's Message event which writes the message to the console.
        /// </summary>
        /// <param name="sender">The IisRunnerStep generating the event.</param>
        /// <param name="e">The MessageEventArgs sent by the event.</param>
        private void ConsoleMessageLogger(object sender, MessageEventArgs e)
        {
            Console.WriteLine(e.Message);
        }

        /// <summary>
        /// Event handler for IisRunnerStep's Message event which writes the message to a log file.
        /// </summary>
        /// <param name="sender">The IisRunnerStep generating the event.</param>
        /// <param name="e">The MessageEventArgs sent by the event.</param>
        private void FileMessageLogger(object sender, MessageEventArgs e)
        {
            if (_logToFile)
            {
                if (_logFile == null)
                {
                    string filename = Path.ChangeExtension(_iisRunnerFilename, ".log");
                    _logFile = new StreamWriter(filename, true);
                }

                _logFile.WriteLine(e.Message);
            }
        }

        private void WriteEvent(string message, EventLogEntryType type)
        {
            if (_logToEvent)
            {
                // Create the source, if it does not already exist.
                if (!EventLog.SourceExists("IisRunner"))
                {
                    EventLog.CreateEventSource("IisRunner", "Application");
                }

                // Create an EventLog instance and assign its source.
                EventLog myLog = new EventLog();
                myLog.Source = "IisRunner";

                // Write an informational entry to the event log.    
                myLog.WriteEntry(message, type);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\IisRunner\HttpExpiresStep.cs ===
using System;
using System.Xml;
using System.Management;

using Leet.Tools.Setup.Wmi.Iisv2;
using Leet.Tools.Setup.XmlSequencer;

namespace Leet.Tools.Setup.IisRunner
{
    /// <summary>
    /// Handles configuration of IIS Metabase HttpExpires settings.
    /// </summary>
    /// <remarks>
    /// <para>
    /// This step handles the <c>&lt;HttpExpires&gt;</c> element in an IisRunner configuration file.
    /// It allows configuring the Expires HTTP header sent for the parent Directory element.
    /// </para><para>
    /// The following table lists the attributes supported by the <c>&lt;HttpExpires&gt;</c> element
    /// and a brief description of their meaning. For more information, see the IIS metebase 
    /// documentation at http://msdn.microsoft.com/library/default.asp?url=/library/en-us/iissdk/html/91918b85-e053-4072-b93c-84afc4c0d56b.asp.
    /// </para>
    /// <para>
    /// Only one of the attributes can be specified, as they are mutually exclusive. Specify no attributes to set no expiration date.
    /// </para>
    /// <list type="table">
    /// <listheader>
    ///     <term>Attribute</term>
    ///     <description>Description</description>
    /// </listheader>
    /// <item>
    ///     <term>secondsUntilExpiration</term>
    ///     <description>The expires HTTP header will be dynamically set to the specified number of seconds past the requested time.</description>
    /// </item>
    /// <item>
    ///     <term>absoluteExpirationDate</term>
    ///     <description>A GMT date/time string (RFC1123 format is prefered). For example, Wed, 27 Jul 2005 07:00:00 GMT.</description>
    /// </item>
    /// </list> 
    ///</remarks>
    [StepElement("HttpExpires")]
    public class HttpExpiresStep : Step
    {
        public HttpExpiresStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
        }

        protected override void OnExecute()
        {
            base.OnExecute ();

            ManagementBaseObject directory = StepNavigation.GetAncestorDirectorySettingObject(this);
            directory["HttpExpires"] = GetHttpExpiresString();
        }

        public override void Validate()
        {
            GetHttpExpiresString();
            base.Validate ();
        }

        private string GetHttpExpiresString()
        {
            string dynamic = BaseXmlElement.GetAttribute("secondsUntilExpiration");
            string absolute = BaseXmlElement.GetAttribute("absoluteExpirationDate");
            string httpExpires = "D, 0xFFFFFFFF";

            if ((dynamic.Length > 0) && (absolute.Length > 0))
            {
                throw new InvalidOperationException("Both secondsUntilExpiration and absoluteExpirationDate cannot be specified in the same HttpExpires step. Current step XML: " + BaseXmlElement.OuterXml);
            }

            if (dynamic.Length > 0)
            {
                int seconds = int.Parse(dynamic);
                httpExpires = string.Format("D, 0x{0:X8}", seconds);
            }

            if (absolute.Length > 0)
            {
                DateTime absoluteDate = DateTime.Parse(absolute);
                httpExpires = string.Format("S, {0:R}", absoluteDate);
            }

            return httpExpires;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\IisRunner\LoggingStep.cs ===
using System;
using System.Xml;
using System.Management;

using Leet.Tools.Setup.Wmi.Iisv2;
using Leet.Tools.Setup.XmlSequencer;

namespace Leet.Tools.Setup.IisRunner
{
    /// <summary>
    /// Summary description for LoggingStep.
    /// </summary>
    [StepElement("Logging")]
    public class LoggingStep : Step
    {
        public LoggingStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
        }

        protected override void OnExecute()
        {
            base.OnExecute ();

            IIsWebServerSetting webServer = StepNavigation.GetWebServerAncestorOfStep(this).WebServerSetting;

            string directory = BaseXmlElement.GetAttribute("directory");
            if (directory.Length > 0)
            {
                webServer.LogFileDirectory = directory;

                if (!System.IO.Directory.Exists(directory))
                {
                    System.IO.Directory.CreateDirectory(directory);
                }
            }

            if (String.Compare(BaseXmlElement.GetAttribute("localtimeRollover"), "true", true) == 0)
            {
                webServer.LogFileLocaltimeRollover = true;
            }
            else
            {
                webServer.LogFileLocaltimeRollover = false;
            }

            if (BaseXmlElement.GetAttribute("period").Length > 0)
            {
                webServer.LogFilePeriod = Convert.ToInt32(BaseXmlElement.GetAttribute("period"));
            }

            if (BaseXmlElement.GetAttribute("truncateSize").Length > 0)
            {
                webServer.LogFileTruncateSize = Convert.ToInt32(BaseXmlElement.GetAttribute("truncateSize"));
            }

            if (String.Compare(BaseXmlElement.GetAttribute("enabled"), "false", true) == 0)
            {
                webServer.LogType = 0;
            }
            else
            {
                webServer.LogType = 1;
            }

            webServer.LogPluginClsid = "{FF160663-DE82-11CF-BC0A-00AA006111E0}"; //W3C Extended Log File Format

            int extFileFlags = 0x0;

            if (String.Compare(BaseXmlElement.GetAttribute("extFileBytesRecv"), "true", true) == 0)
            {
                extFileFlags |= 0x2000;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("extFileBytesSent"), "true", true) == 0)
            {
                extFileFlags |= 0x1000;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("extFileClientIp"), "false", true) != 0)
            {
                extFileFlags |= 0x0004;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("extFileComputerName"), "true", true) == 0)
            {
                extFileFlags |= 0x0020;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("extFileCookie"), "true", true) == 0)
            {
                extFileFlags |= 0x20000;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("extFileDate"), "false", true) != 0)
            {
                extFileFlags |= 0x0001;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("extFileHost"), "true", true) == 0)
            {
                extFileFlags |= 0x00100000;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("extFileHttpStatus"), "false", true) != 0)
            {
                extFileFlags |= 0x0400;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("extFileHttpSubStatus"), "false", true) != 0)
            {
                extFileFlags |= 0x00200000;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("extFileMethod"), "false", true) != 0)
            {
                extFileFlags |= 0x00000080;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("extFileProtocolVersion"), "true", true) == 0)
            {
                extFileFlags |= 0x00080000;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("extFileReferer"), "false", true) != 0)
            {
                extFileFlags |= 0x00040000;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("extFileServerIp"), "true", true) == 0)
            {
                extFileFlags |= 0x00000040;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("extFileServerPort"), "true", true) == 0)
            {
                extFileFlags |= 0x00008000;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("extFileSiteName"), "true", true) == 0)
            {
                extFileFlags |= 0x00000010;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("extFileTime"), "false", true) != 0)
            {
                extFileFlags |= 0x00000002;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("extFileTimeTaken"), "true", true) == 0)
            {
                extFileFlags |= 0x00004000;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("extFileUriQuery"), "false", true) != 0)
            {
                extFileFlags |= 0x00000200;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("extFileUriStem"), "false", true) != 0)
            {
                extFileFlags |= 0x00000100;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("extFileUserAgent"), "false", true) != 0)
            {
                extFileFlags |= 0x00010000;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("extFileUserName"), "false", true) != 0)
            {
                extFileFlags |= 0x00000008;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("extFileWin32Status"), "false", true) != 0)
            {
                extFileFlags |= 0x00000800;
            }

            webServer.LateBoundObject["LogExtFileFlags"] = extFileFlags;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\IisRunner\HttpCompressionStep.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Xml;
using Leet.Tools.Setup.Wmi.Iisv2;
using Leet.Tools.Setup.XmlSequencer;
using System.Management;
using System.IO;
using System.Security.AccessControl;
using System.DirectoryServices;

namespace Leet.Tools.Setup.IisRunner
{
    /// <summary>
    /// Allows configuration of HttpCompression for all web sites on the server being configured.
    /// </summary>
    [StepElement("HttpCompression")]
    public class HttpCompressionStep : StepContainer
    {
        private IIsCompressionSchemesSetting _allSchemesSetting = null;

        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
        public HttpCompressionStep(XmlElement stepElement, StepContainer parent)
            : base(stepElement, parent)
        {
        }

        public bool? DoStaticCompression
        {
            get { return GetBoolAttribute("doStaticCompression"); }
        }

        public bool? DoDynamicCompression
        {
            get { return GetBoolAttribute("doDynamicCompression"); }
        }

        public bool? DoOnDemandCompression
        {
            get { return GetBoolAttribute("doOnDemandCompression"); }
        }

        public string CompressionDirectory
        {
            get { return BaseXmlElement.GetAttribute("compressionDirectory"); }
        }

        public string CacheControlHeader
        {
            get { return BaseXmlElement.GetAttribute("cacheControlHeader"); }
        }

        public string ExpiresHeader
        {
            get { return BaseXmlElement.GetAttribute("expiresHeader"); }
        }

        public bool? DoDiskSpaceLimiting
        {
            get { return GetBoolAttribute("doDiskSpaceLimiting"); }
        }

        public bool? NoCompressionForHttp10
        {
            get { return GetBoolAttribute("noCompressionForHttp10"); }
        }

        public bool? NoCompressionForProxies
        {
            get { return GetBoolAttribute("noCompressionForProxies"); }
        }

        public bool? NoCompressionForRange
        {
            get { return GetBoolAttribute("noCompressionForRange"); }
        }

        public bool? SendCacheHeaders
        {
            get { return GetBoolAttribute("sendCacheHeaders"); }
        }

        public int? MaxDiskSpaceUsage
        {
            get { return GetIntAttribute("maxDiskSpaceUsage"); }
        }

        public int? IoBufferSize
        {
            get { return GetIntAttribute("ioBufferSize"); }
        }

        public int? CompressionBufferSize
        {
            get { return GetIntAttribute("compressionBufferSize"); }
        }

        public int? MaxQueueLength
        {
            get { return GetIntAttribute("maxQueueLength"); }
        }

        public int? FilesDeletedPerDiskFree
        {
            get { return GetIntAttribute("filesDeletedPerDiskFree"); }
        }

        public int? MinFileSizeForComp
        {
            get { return GetIntAttribute("minFileSizeForComp"); }
        }

        /// <summary>
        /// 
        /// </summary>
        public IisRunnerStep IisRunnerStep
        {
            get
            {
                if (!(Root is IisRunnerStep))
                {
                    throw new InvalidOperationException("The root step must be IisRunnerStep for HttpCompressionStep to function correctly.");
                }
                return (IisRunnerStep)Root;
            }
        }

        protected override void OnExecute()
        {
            Root.LogMessage("Configuring global HTTP Compression properties.");

            ManagementScope mScope = IisRunnerStep.IisManagementScope;

            _allSchemesSetting = WmiUtilities.GetCompressionSchemesSetting(mScope);

            if (DoDynamicCompression.HasValue)
            {
                _allSchemesSetting.HcDoDynamicCompression = DoDynamicCompression.Value;
            }

            if (DoStaticCompression.HasValue)
            {
                _allSchemesSetting.HcDoStaticCompression = DoStaticCompression.Value;
            }

            if (DoOnDemandCompression.HasValue)
            {
                _allSchemesSetting.HcDoOnDemandCompression = DoOnDemandCompression.Value;
            }

            if (!String.IsNullOrEmpty(CompressionDirectory))
            {
                _allSchemesSetting.HcCompressionDirectory = CompressionDirectory;

                if (!Directory.Exists(CompressionDirectory))
                {
                    Directory.CreateDirectory(CompressionDirectory);
                }

                DirectoryEntry localMachine = new DirectoryEntry("WinNT://" + Environment.MachineName);
                DirectoryEntry group = null;

                group = localMachine.Children.Find("IIS_WPG", "Group");

                DirectorySecurity dSecurity = Directory.GetAccessControl(CompressionDirectory);
                dSecurity.AddAccessRule(new FileSystemAccessRule(group.Name, FileSystemRights.FullControl, AccessControlType.Allow));
                Directory.SetAccessControl(CompressionDirectory, dSecurity);
            }

            if (!String.IsNullOrEmpty(CacheControlHeader))
            {
                _allSchemesSetting.HcCacheControlHeader = CacheControlHeader;
            }

            if (!String.IsNullOrEmpty(ExpiresHeader))
            {
                _allSchemesSetting.HcExpiresHeader = ExpiresHeader;
            }

            if (DoDiskSpaceLimiting.HasValue)
            {
                _allSchemesSetting.HcDoDiskSpaceLimiting = DoDiskSpaceLimiting.Value;
            }

            if (NoCompressionForHttp10.HasValue)
            {
                _allSchemesSetting.HcNoCompressionForHttp10 = NoCompressionForHttp10.Value;
            }

            if (NoCompressionForProxies.HasValue)
            {
                _allSchemesSetting.HcNoCompressionForProxies = NoCompressionForProxies.Value;
            }

            if (NoCompressionForRange.HasValue)
            {
                _allSchemesSetting.HcNoCompressionForRange = NoCompressionForRange.Value;
            }

            if (SendCacheHeaders.HasValue)
            {
                _allSchemesSetting.HcSendCacheHeaders = SendCacheHeaders.Value;
            }

            if (MaxDiskSpaceUsage.HasValue)
            {
                _allSchemesSetting.HcMaxDiskSpaceUsage = MaxDiskSpaceUsage.Value;
            }

            if (IoBufferSize.HasValue)
            {
                _allSchemesSetting.HcIoBufferSize = IoBufferSize.Value;
            }

            if (CompressionBufferSize.HasValue)
            {
                _allSchemesSetting.HcCompressionBufferSize = CompressionBufferSize.Value;
            }

            if (MaxQueueLength.HasValue)
            {
                _allSchemesSetting.HcMaxQueueLength = MaxQueueLength.Value;
            }

            if (FilesDeletedPerDiskFree.HasValue)
            {
                _allSchemesSetting.HcFilesDeletedPerDiskFree = FilesDeletedPerDiskFree.Value;
            }

            if (MinFileSizeForComp.HasValue)
            {
                _allSchemesSetting.HcMinFileSizeForComp = MinFileSizeForComp.Value;
            }

            // let contained steps execute
            base.OnExecute();

            _allSchemesSetting.CommitObject();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\IisRunner\IisRunnerStep.cs ===
using System;
using System.IO;
using System.Xml;
using System.Management;

using Leet.Tools.Setup.XmlSequencer;

namespace Leet.Tools.Setup.IisRunner
{
    public enum IisRunnerAction
    {
        Create,
        Modify,
        Delete
    }

	/// <summary>
	/// Provides the entry point for the IisRunner components.
	/// </summary>
	/// <remarks>
	///  This class provides the primary interface to process a IisRunner XML document. The IisRunner XML document defines 
	///  a sequential series of steps to configure IIS services, allowing the sequencing and intent of the setup actions
	///  to be seperated from the code that implements how to perform those actions.
    ///</remarks>
	public class IisRunnerStep : RootStepContainer
	{
        private ManagementScope iisManagementScope = null;

        /// <summary>
        /// Initializes a new instance of the IisRunnerStep class.
        /// </summary>
        /// <param name="stepElement">
        /// The IisRunner XmlElement that contains the attributes and steps (children elements) that define the 
        /// actions to take.
        /// </param>
        /// <exception cref="InvalidOperationException">The passed stepElement does not belong to the IisRunner namespace.</exception>
        /// <exception cref="ArgumentNullException">The passed stepElement was null.</exception>
		public IisRunnerStep(XmlElement stepElement) : base(stepElement)
		{
		}

        /// <summary>
        /// Gets the name of the XML namespace that all IisRunner elements must belong to.  
        /// </summary>
        public override string Namespace
        {
            get {return "http://www.xbox.com/iisrunner.xsd";}
        }

        public ManagementScope IisManagementScope
        {
            get
            {
                if (iisManagementScope == null)
                {
                    ConnectionOptions cnOpts = new ConnectionOptions();

                    iisManagementScope = new ManagementScope("\\\\"+ System.Environment.MachineName +"\\root\\MicrosoftIISv2", cnOpts);
                    iisManagementScope.Connect();
                }

                return iisManagementScope;
            }
        }
	
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\IisRunner\IisRunnerInstaller.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Xml;
using Leet.Core.Configuration;
using Leet.Core.IO;
using Leet.Tools.Setup.XmlSequencer;

namespace Leet.Tools.Setup.IisRunner
{
    /// <summary>
    /// Summary description for IisRunnerInstaller.
    /// </summary>
    [RunInstaller(true)]
    public class IisRunnerInstaller : System.Configuration.Install.Installer
    {
        private System.Diagnostics.EventLog eventLog;
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.Container components = null;

        public IisRunnerInstaller()
        {
            // This call is required by the Designer.
            InitializeComponent();
        }

        /// <summary> 
        /// Clean up any resources being used.
        /// </summary>
        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                if (components != null)
                {
                    components.Dispose();
                }
            }
            base.Dispose(disposing);
        }

        public override void Install(IDictionary stateSaver)
        {
            base.Install(stateSaver);

            StartIisRunner("install");
        }

        public override void Commit(IDictionary savedState)
        {
            base.Commit(savedState);
        }

        public override void Uninstall(IDictionary savedState)
        {
            base.Uninstall(savedState);

            StartIisRunner("uninstall");
        }

        public override void Rollback(IDictionary savedState)
        {
            base.Rollback(savedState);

            StartIisRunner("rollback");
        }



        private void StartIisRunner(string installPhase)
        {
            string message = null;
            string iisRunnerFilename = Context.Parameters["runnerFile"];

            try
            {
                if ((iisRunnerFilename == null) || (iisRunnerFilename.Length == 0))
                {
                    throw new ArgumentException("The runnerFile parameter must be specified. It should contain the path to the IisRunner definition file.", "runnerFile");
                }

                message = String.Format("IisRunner started {0} of '{1}' at {2}", installPhase, iisRunnerFilename, DateTime.Now.ToString());
                eventLog.WriteEntry(message, EventLogEntryType.Information);
                Context.LogMessage(message);

                Leet.Core.IoCCo.Container.Instance.AddService<IRegistryProvider, RegistryProvider>();
                Leet.Core.IoCCo.Container.Instance.AddService<IFileSystem, FileSystem>();

                ConfigurationSelector.RegisterProvider("iisrunner", "LEET");

                ConfigurationStore store = new ConfigurationStore("IisRunner", Path.GetFileNameWithoutExtension(iisRunnerFilename));

                XmlDocument xmlDoc = new XmlDocument();
                xmlDoc.Load(iisRunnerFilename);

                ConfigurationTransform transform = new ConfigurationTransform();

                if (installPhase == "uninstall")
                {
                    store.LoadConfiguration(transform.OverrideVariableCollection);
                }

                foreach (DictionaryEntry de in Context.Parameters)
                {
                    transform.OverrideVariableCollection[de.Key.ToString()] = de.Value.ToString();
                }
                transform.OverrideVariableCollection["installphase"] = installPhase;

                transform.TransformDocument(xmlDoc);

                if (installPhase == "install")
                {
                    store.SaveConfiguration(transform.OverrideVariableCollection);
                }

                IisRunnerStep runner = new IisRunnerStep(xmlDoc.DocumentElement);
                runner.OnMessage += new MessageEventHandler(myRoot_OnMessage);

                runner.Validate();
                runner.Execute();
            }
            catch (Exception ex)
            {
                Context.LogMessage("ERROR: Exception encountered executing IisRunner. - " + ex.Message);
                Context.LogMessage(ex.ToString());

                message = string.Format("Exception encountered executing IisRunner: \r\n{0}", ex.ToString());
                eventLog.WriteEntry(message, EventLogEntryType.Error, 65000);
                throw;
            }

            message = String.Format("IisRunner {0} of '{1}' completed at {2}", installPhase, iisRunnerFilename, DateTime.Now.ToString());
            eventLog.WriteEntry(message, EventLogEntryType.Information);
            Context.LogMessage(message);
        }

        /// <summary>
        /// Event handler for IisRunnerStep's Message event which writes the message to the install context's log.
        /// </summary>
        /// <param name="sender">The IisRunnerStep generating the event.</param>
        /// <param name="e">The MessageEventArgs sent by the event.</param>
        private void myRoot_OnMessage(object sender, MessageEventArgs e)
        {
            Context.LogMessage(e.Message);
        }


        #region Component Designer generated code
        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.eventLog = new System.Diagnostics.EventLog();
            ((System.ComponentModel.ISupportInitialize)(this.eventLog)).BeginInit();
            // 
            // eventLog
            // 
            this.eventLog.Log = "Application";
            this.eventLog.Source = "IisRunner";
            ((System.ComponentModel.ISupportInitialize)(this.eventLog)).EndInit();

        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\IisRunner\McmsApplicationStep.cs ===
using System;
using System.Xml;
using Microsoft.Win32;
using System.Management;
using System.DirectoryServices;

using Leet.Tools.Setup.Wmi.Iisv2;
using Leet.Tools.Setup.XmlSequencer;

namespace Leet.Tools.Setup.IisRunner
{
    /// <summary>
    /// Summary description for McmsApplicationStep.
    /// </summary>
    [StepElement("McmsApplication")]
    public class McmsApplicationStep : Step
    {
        public McmsApplicationStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
        }

        public IisRunnerStep IisRunnerStep
        {
            get 
            {
                if (!(Root is IisRunnerStep))
                {
                    throw new InvalidOperationException("The root step must be IisRunnerStep for WebServerSetup to function correctly."); 
                }
                return (IisRunnerStep) Root;
            }
        }

        public int ActiveCmsConfiguration
        {
            get
            {
                int activeCmsConfiguration = -1;

                try
                {
                    RegistryKey mcsmKey = Registry.LocalMachine.OpenSubKey(@"SOFTWARE\NCompass\Resolution Content Server\Configuration");
                    activeCmsConfiguration = (int) mcsmKey.GetValue("NextServerIndex") - 1;
                }
                catch (ArgumentException)
                {
                    activeCmsConfiguration = -1;
                }

                return activeCmsConfiguration;
            }
        }

        public string McmsRootPath
        {
            get
            {
                string mcmsRootPath = null;
                try
                {
                    RegistryKey mcmsKey = Registry.LocalMachine.OpenSubKey(@"SOFTWARE\NCompass\Resolution Content Server");
                    if (mcmsKey != null)
                    {
                        mcmsRootPath = (string) mcmsKey.GetValue("dir");
                    }
                }
                catch (ArgumentException) 
                {
                }
            
                return mcmsRootPath;
            }
        }
		
        public string McmsExeresPath
        {
            get
            {
                string mcmsExeresPath = null;

                try
                {
                    string keyName = String.Format(
                        @"SOFTWARE\NCompass\Resolution Content Server\Configuration\{0}\Local\Cache",
                        ActiveCmsConfiguration);

                    RegistryKey mcsmKey = Registry.LocalMachine.OpenSubKey(keyName);
                    mcmsExeresPath = (string) mcsmKey.GetValue("PhysicalExecPrefix");
                }
                catch (ArgumentException)
                {
                }

                return mcmsExeresPath;
            }
        }

        public string McmsRdonlyresPath
        {
            get
            {
                string mcmsRdonlyresPath = null;

                try
                {
                    string keyName = String.Format(
                        @"SOFTWARE\NCompass\Resolution Content Server\Configuration\{0}\Local\Cache",
                        ActiveCmsConfiguration);

                    RegistryKey mcsmKey = Registry.LocalMachine.OpenSubKey(keyName);
                    mcmsRdonlyresPath = (string) mcsmKey.GetValue("PhysicalReadPrefix");
                }
                catch (ArgumentException)
                {
                }

                return mcmsRdonlyresPath;
            }
        }

        protected override void OnExecute()
        {
            base.OnExecute ();

            bool readOnly = (String.Compare(BaseXmlElement.GetAttribute("readOnly"), "false") != 0);

            WebServerStep webServer = StepNavigation.GetWebServerAncestorOfStep(this);
            string rootKeyName = webServer.WebVirtualDirSetting.Name;

            if (ActiveCmsConfiguration == -1)
            {
                Root.LogMessage("MCMS is not installed. Skipping MCMS configuration for site " + rootKeyName + ".");
                return;
            }

            if (!readOnly)
            {
                CreateVirtualDir(rootKeyName + "/CMS", McmsRootPath + @"IIS_CMS", false);
                CreateVirtualDir(rootKeyName + "/webctrl_client", McmsRootPath + @"IIS_CMS\WebAuthor\Controls\webctrl_client", false);

                IIsWebVirtualDirSetting nr = CreateVirtualDir(rootKeyName + "/NR", McmsRootPath + @"IIS_NR", false);
                // Enable anonymous, basic, and NTLM authentication
                nr.LateBoundObject["AuthFlags"] = 0x00000007;
                nr.LateBoundObject["AccessFlags"] = 0x00000201;
                nr.LateBoundObject["DirBrowseFlags"] = 0x0000003e;
                nr.LateBoundObject["DontLog"] = false;
                nr.LateBoundObject["ContentIndexed"] = false;
                nr.CommitObject();

                IIsWebVirtualDirSetting mcms = CreateVirtualDir(rootKeyName + "/MCMS", McmsRootPath + @"MCMS", true);
                mcms.LateBoundObject["AuthFlags"] = 0x00000007;
                mcms.LateBoundObject["AccessFlags"] = 0x00000201;
                mcms.LateBoundObject["DirBrowseFlags"] = 0x0000003e;
                mcms.LateBoundObject["DontLog"] = false;
                mcms.LateBoundObject["ContentIndexed"] = false;
                mcms.CommitObject();

                CreateVirtualDir(rootKeyName + "/MCMS/CMS", McmsRootPath + @"IIS_CMS", false);
                CreateVirtualDir(rootKeyName + "/MCMS/SiteDeployment", McmsRootPath + @"MCMS\SiteDeployment", true);

                IIsWebVirtualDirSetting execres = CreateVirtualDir(rootKeyName + "/NR/ExeRes", McmsExeresPath, false);

                CreateWebDirectory(rootKeyName + "/NR/System", false);

                IIsWebDirectorySetting webDir = CreateWebDirectory(rootKeyName + "/NR/System/Access", false);
                webDir.LateBoundObject["AccessFlags"] = 0x00000200;
                webDir.CommitObject();
	
                webDir = CreateWebDirectory(rootKeyName + "/NR/System/ResUpload", true);
                webDir.LateBoundObject["AspMaxRequestEntityAllowed"] = 51200000;
                webDir.CommitObject();

                webDir = CreateWebDirectory(rootKeyName + "/NR/System/SDUpload", true);
                webDir.LateBoundObject["AspMaxRequestEntityAllowed"] = -198967296;
                webDir.CommitObject();

                // TODO: Figure out how to lock down the /NR/System/Staging
                // web directory to only allow access from the local machine.
                // For now, just disable it since we aren't using staging
                webDir = CreateWebDirectory(rootKeyName + "/NR/System/Staging", false);
                webDir.LateBoundObject["AccessFlags"] = 0x0;
                webDir.CommitObject();
            }
            else
            {
                CreateVirtualDir(rootKeyName + "/NR", McmsRootPath + @"IIS_NR_RO", false);
            }

            IIsWebVirtualDirSetting rdonlyres = CreateVirtualDir(rootKeyName + "/NR/RdOnlyRes", McmsRdonlyresPath, false);
            rdonlyres.DirBrowseFlags = 1073741824;
            rdonlyres.AccessFlags = 1;
            rdonlyres.ContentIndexed = false;
            // TODO: Figure out how to set the mime maps

            rdonlyres.CommitObject();

            // Register the site with CMS if installed
            RegistryKey entryPoints = Registry.LocalMachine.OpenSubKey(@"SOFTWARE\NCompass\Resolution Content Server\Configuration\0\EntryPoints", true);

            if (entryPoints != null)
            {
                RegistryKey entryPoint = entryPoints.CreateSubKey(webServer.SiteId.ToString());

                if (readOnly)
                {
                    entryPoint.SetValue("ReadOnlyServer", 1);
                }
                else
                {
                    entryPoint.SetValue("ReadOnlyServer", 0);
                }
            }
			
        }


        private IIsWebVirtualDirSetting CreateVirtualDir(string keyName, string path, bool createApplication)
        {
            ManagementScope mScope = IisRunnerStep.IisManagementScope;

            IIsWebVirtualDirSetting webVirtualDirSetting = WmiUtilities.FindWebVirtualDirSetting(mScope, keyName);

            if (webVirtualDirSetting == null)
            {
                IIsWebVirtualDir virtualDir = IIsWebVirtualDir.CreateInstance();
    
                virtualDir.LateBoundObject["Name"] = keyName;
                virtualDir.CommitObject();

                webVirtualDirSetting = WmiUtilities.FindWebVirtualDirSetting(mScope, keyName);
            }

            webVirtualDirSetting.Path0 = path;

            if (createApplication)
            {
                IIsWebVirtualDir virtualDir = new IIsWebVirtualDir(mScope, webVirtualDirSetting.Name);

                virtualDir.AppCreate2(2);

                while (keyName.EndsWith("/"))
                {
                    keyName = keyName.Substring(0, keyName.Length - 1);
                }

                string appName = keyName.Substring(keyName.LastIndexOf("/") + 1) + " Application";
                webVirtualDirSetting.AppFriendlyName = appName;
            }

            webVirtualDirSetting.CommitObject();
            return webVirtualDirSetting;
        }

        private IIsWebDirectorySetting CreateWebDirectory(string keyName, bool createApplication)
        {
            ManagementScope mScope = IisRunnerStep.IisManagementScope;

            IIsWebDirectorySetting webDirectorySetting = WmiUtilities.FindWebDirectorySetting(mScope, keyName);

            if (webDirectorySetting == null)
            {
                IIsWebDirectory webDirectory = IIsWebDirectory.CreateInstance();
    
                webDirectory.LateBoundObject["Name"] = keyName;
                webDirectory.CommitObject();

                webDirectorySetting = WmiUtilities.FindWebDirectorySetting(mScope, keyName);
            }

            if (createApplication)
            {
                IIsWebDirectory webDirectory = new IIsWebDirectory(mScope, webDirectorySetting.Name);

                webDirectory.AppCreate2(2);

                while (keyName.EndsWith("/"))
                {
                    keyName = keyName.Substring(0, keyName.Length - 1);
                }

                string appName = keyName.Substring(keyName.LastIndexOf("/") + 1) + " Application";
                webDirectorySetting.AppFriendlyName = appName;
            }

            webDirectorySetting.CommitObject();
            return webDirectorySetting;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\IisRunner\LocalHttpCompressionStep.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Xml;
using Leet.Tools.Setup.Wmi.Iisv2;
using Leet.Tools.Setup.XmlSequencer;
using System.Management;
using System.IO;
using System.Security.AccessControl;
using System.DirectoryServices;

namespace Leet.Tools.Setup.IisRunner
{
    /// <summary>
    /// Allows configuration of LocalHttpCompression for all web sites on the server being configured.
    /// </summary>
    [StepElement("LocalHttpCompression")]
    public class LocalHttpCompressionStep : StepContainer
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
        public LocalHttpCompressionStep(XmlElement stepElement, StepContainer parent)
            : base(stepElement, parent)
        {
        }

        public bool? DoStaticCompression
        {
            get { return GetBoolAttribute("doStaticCompression"); }
        }

        public bool? DoDynamicCompression
        {
            get { return GetBoolAttribute("doDynamicCompression"); }
        }

        protected override void OnExecute()
        {
            Root.LogMessage("Configuring local HTTP Compression properties.");

            ManagementBaseObject directory = StepNavigation.GetAncestorDirectorySettingObject(this);

            if (DoDynamicCompression.HasValue)
            {
                directory["DoDynamicCompression"] = DoDynamicCompression.Value;
            }

            if (DoStaticCompression.HasValue)
            {
                directory["DoStaticCompression"] = DoStaticCompression.Value;
            }

            // let contained steps execute
            base.OnExecute();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\IisRunner\PasswordChangeStep.cs ===
using System;
using System.Xml;
using System.Management;

using Leet.Tools.Setup.Wmi.Iisv2;
using Leet.Tools.Setup.XmlSequencer;

namespace Leet.Tools.Setup.IisRunner
{
    /// <summary>
    /// Summary description for PasswordChangeStep.
    /// </summary>
    [StepElement("PasswordChange")]
    public class PasswordChangeStep : Step
    {
        public PasswordChangeStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
        }

        protected override void OnExecute()
        {
            base.OnExecute ();

            WebServerStep webServer = StepNavigation.GetWebServerAncestorOfStep(this);
            ManagementBaseObject webServerBaseObject = webServer.WebServerSetting.LateBoundObject;

            int flags = 0;

            if (BaseXmlElement.GetAttribute("authAdvNotifyDisable").ToLower() == "true")
            {
                flags |= 0x00000004;
            }

            if (BaseXmlElement.GetAttribute("authChangeDisable").ToLower() == "true")
            {
                flags |= 0x00000002;
            }

            if (BaseXmlElement.GetAttribute("authChangeUnsecure").ToLower() == "true")
            {
                flags |= 0x00000001;
            }

            //webServerBaseObject["PasswordChangeFlags"] = flags;
            webServer.WebServerSetting.PasswordChangeFlags = flags;
            if (BaseXmlElement.GetAttribute("expirePrenotifyDays").Length > 0)
            {
                webServer.WebServerSetting.PasswordExpirePrenotifyDays = Convert.ToInt32(BaseXmlElement.GetAttribute("expirePrenotifyDays"));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\IisRunner\SecureBindingStep.cs ===
using System;
using System.Xml;
using System.Management;
using System.Runtime.InteropServices;

using Leet.Tools.Setup.Wmi.Iisv2;
using Leet.Tools.Setup.XmlSequencer;
using xonline.common.service;
using xonline.common.config;

namespace Leet.Tools.Setup.IisRunner
{
    /// <summary>
    /// Summary description for SSLCertStep.
    /// </summary>

    [StepElement("SecureBinding")]
    public class SecureBindingStep : Step
    {
        private Uri uri;

        public SecureBindingStep(XmlElement stepElement, StepContainer parent)
            : base(stepElement, parent)
        {
        }

        public string IpAddress
        {
            get {return BaseXmlElement.GetAttribute("ip");}
        }

        public string Port
        {
            get
            {
                return BaseXmlElement.GetAttribute("port");
            }
        }

        public string Hostname
        {
            get
            {
                ProcessUri();
                if (uri != null)
                {
                    return uri.Host;
                }
                else
                {
                    return BaseXmlElement.GetAttribute("hostname");
                }
            }
        }

        private void ProcessUri()
        {
            if ((uri == null) && (BaseXmlElement.Attributes["uri"] != null))
            {
                uri = new Uri("https://" + BaseXmlElement.GetAttribute("uri"));
            }
        }

        public IisRunnerStep IisRunnerStep
        {
            get 
            {
                if (!(Root is IisRunnerStep))
                {
                    throw new InvalidOperationException("The root step must be IisRunnerStep for SecureBinding to function correctly."); 
                }
                return (IisRunnerStep) Root;
            }
        }

        protected override void OnExecute()
        {
            base.OnExecute ();

            Root.LogMessage(String.Format(
                "Adding Secure binding - IP={0}, Port={1}, Hostname={2}.",
                (IpAddress == null) ? "*" : IpAddress,
                Port,
                (Hostname == null) ? "*" : Hostname));

            WebServerStep server = StepNavigation.GetWebServerAncestorOfStep(this);

            server.SecureBinding = IpAddress + ":" + Port + ":" + Hostname;;
        }

        public override void Validate()
        {
            base.Validate ();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\IisRunner\StepNavigation.cs ===
using System;
using System.Management;

using Leet.Tools.Setup.XmlSequencer;

namespace Leet.Tools.Setup.IisRunner
{
	/// <summary>
	/// Summary description for StepNavigation.
	/// </summary>
	public class StepNavigation
	{
        /// <summary>
        /// 
        /// </summary>
        /// <param name="startStep"></param>
        /// <returns></returns>
        static public WebServerStep GetWebServerAncestorOfStep(Step startStep)
        {
            Step currentStep = startStep.Parent;

            while (currentStep != null)
            {
                if (currentStep is WebServerStep)
                {
                    return (WebServerStep) currentStep;
                }

                currentStep = currentStep.Parent;
            }

            throw new InvalidOperationException("No WebServerStep present in the hierarchy above the passed step.");
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="startStep"></param>
        /// <returns></returns>
        static public ApplicationPoolStep GetApplicationPoolAncestorOfStep(Step startStep)
        {
            Step currentStep = startStep.Parent;

            while (currentStep != null)
            {
                if (currentStep is ApplicationPoolStep)
                {
                    return (ApplicationPoolStep) currentStep;
                }

                currentStep = currentStep.Parent;
            }

            throw new InvalidOperationException("No ApplicationPoolStep present in the hierarchy above the passed step.");
        }

        public static ManagementBaseObject GetAncestorDirectorySettingObject(Step startStep)
        {
            Step currentStep = startStep.Parent;

            while (currentStep != null)
            {
                if (currentStep is IDirectorySetting)
                {
                    return ((IDirectorySetting) currentStep).DirectorySettingObject;
                }

                currentStep = currentStep.Parent;
            }

            throw new InvalidOperationException("No step implementing IDirectorySetting present in the hierarchy above " + startStep.BaseXmlElement.OuterXml + ".");
            
        }

        public static IApplicationHost GetAncestorApplicationHost(Step startStep)
        {
            Step currentStep = startStep.Parent;

            while (currentStep != null)
            {
                if (currentStep is IApplicationHost)
                {
                    return (IApplicationHost) currentStep;
                }

                currentStep = currentStep.Parent;
            }

            throw new InvalidOperationException("No step implementing IApplicationHost present in the hierarchy above " + startStep.BaseXmlElement.OuterXml + ".");
            
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\IisRunner\SSLCertHashStep.cs ===
using System;
using System.Xml;
using System.Management;
using System.Runtime.InteropServices;

using Leet.Tools.Setup.Wmi.Iisv2;
using Leet.Tools.Setup.XmlSequencer;
using xonline.common.service;
using xonline.common.config;
using System.Security.Cryptography.X509Certificates;

namespace Leet.Tools.Setup.IisRunner
{
    /// <summary>
    /// Summary description for SSLCertStep.
    /// </summary>

    [StepElement("SSLCertHash")]
    public class SSLCertHashStep : Step
    {
        public SSLCertHashStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
        }

        public string CertPath
        {
            get 
            {
                string path = BaseXmlElement.GetAttribute("path");

                if (path == null)
                {
                    throw new ArgumentException("The SSLCert attribute of the " + BaseXmlElement.Name + " element must be specified.", "path");
                }

                //NOTE: UNC paths lose the leading backslash.  This solution
                // requires using a period as the first character to use a
                // relative path
                if ((path[0] == '\\') && (path[1] != '\\'))
                {
                    path = "\\" + path;
                }

                return path;
            }
        }

        public string CertPassword
        {
            get 
            {
                string password = string.Empty;
                if (BaseXmlElement.Attributes["password"] != null)
                {
                    password = BaseXmlElement.GetAttribute("password");
                }
                return password;
            }
        }

        public IisRunnerStep IisRunnerStep
        {
            get 
            {
                if (!(Root is IisRunnerStep))
                {
                    throw new InvalidOperationException("The root step must be IisRunnerStep for SSLCertHash to function correctly."); 
                }
                return (IisRunnerStep) Root;
            }
        }

        protected override void OnExecute()
        {
            base.OnExecute ();

            Root.LogMessage(String.Format(
                "Adding SSL server certificate, certPath={0}, certPassword={1}.", 
                CertPath, CertPassword));

            SSLCertConfig config = new SSLCertConfig(CertPath, CertPassword);

            WebServerStep server = StepNavigation.GetWebServerAncestorOfStep(this);

            server.SSLCertHash = config.SSLCertHash;
        }

        public override void Validate()
        {
            base.Validate ();
        }
    }


    public class CertImpXAPI
    {
        public static byte[] ImportCompletePFX(string certPath, string certPassword, bool importToSystemStore)
        {
            X509Certificate2 certificate = GetCertificate(certPath, certPassword);
            AddCertificateToStore(certificate, importToSystemStore);

            return certificate.GetCertHash();
        }

        private static X509Certificate2 GetCertificate(string certPath, string certPassword)
        {
            X509Certificate2 certificate;
            if (String.IsNullOrEmpty(certPassword))
            {
                certificate = new X509Certificate2(certPath);
            }
            else
            {
                certificate = new X509Certificate2(certPath, certPassword);
            }

            return certificate;
        }

        private static void AddCertificateToStore(X509Certificate2 certificate, bool addToSystemStore)
        {
            X509Store certificateStore;
            if (addToSystemStore)
            {
                certificateStore = new X509Store(StoreName.My, StoreLocation.LocalMachine);
            }
            else
            {
                certificateStore = new X509Store(StoreName.My, StoreLocation.CurrentUser);
            }
            certificateStore.Open(OpenFlags.ReadWrite);
            certificateStore.Add(certificate);
        }
    }

    public class SSLCertConfig
    {
        Byte[]      sslCertHash             = null;
        string      sslCertFilePath         = null;
        string      sslCertFilePassword     = null;

        public SSLCertConfig(string filePath, string password)
        {
            sslCertFilePath = filePath;
            sslCertFilePassword = password;
        }

        public virtual Byte[] SSLCertHash
        {
            get
            {
                if (sslCertHash == null)
                {
                    // Call our custom certimpx.dll to have the 
                    sslCertHash = CertImpXAPI.ImportCompletePFX(sslCertFilePath, sslCertFilePassword, true);

                    if (sslCertHash == null)
                    {
                        throw new ApplicationException("Unable to import SSL certificate from " + sslCertFilePath);
                    }
                }

                return sslCertHash;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\IisRunner\MimeMapsStep.cs ===
using System;
using System.Xml;
using System.Management;

using Leet.Tools.Setup.Wmi.Iisv2;
using Leet.Tools.Setup.XmlSequencer;

namespace Leet.Tools.Setup.IisRunner
{
    /// <summary>
    /// Handles configuration of IIS Metabase access settings.
    /// </summary>
    /// <remarks>
    /// <para>
    /// This step handles the <c>&lt;MimeMaps&gt;</c> element in an IisRunner configuration file.
    /// It allows configuring MIME elements for the parent IIS directory object (e.g. a directory or virtual directory) of the element.
    /// </para><para>
    /// The following table lists the attributes supported by the <c>&lt;MimeMaps&gt;</c> element
    /// and a brief description of their meaning. For more information, see the IIS metabase 
    /// documentation at http://msdn.microsoft.com/library/default.asp?url=/library/en-us/iissdk/html/b9b7a30c-5d24-4310-bb70-398c3129f6b3.asp.
    /// </para>
    /// <para>
    /// This step expects to have &lt;MimeMap&gt; elements under it that define the specific custom errors. The expected attributes of
    /// these sub elements are:
    /// </para>
    /// <list type="table">
    /// <listheader>
    ///     <term>Attribute</term>
    ///     <description>Description</description>
    /// </listheader>
    /// <item>
    ///     <term>extension</term>
    ///     <description>This attribute specifies the file extension to map to a MIME type.</description>
    /// </item>
    /// <item>
    ///     <term>type</term>
    ///     <description>This attribute specifies the MIME type to map to.</description>
    /// </item>
    /// </list> 
    ///</remarks>
    [StepElement("MimeMaps")]
    public class MimeMapsStep : Step
    {
        public MimeMapsStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
        }

        public IisRunnerStep IisRunnerStep
        {
            get 
            {
                if (!(Root is IisRunnerStep))
                {
                    throw new InvalidOperationException("The root step must be IisRunnerStep for WebServerSetup to function correctly."); 
                }
                return (IisRunnerStep) Root;
            }
        }

        protected override void OnExecute()
        {
            base.OnExecute ();

            Root.LogMessage("Adding custom MimeMaps.");

            MimeMap[] maps = GetMimeMaps();

            ManagementBaseObject directory = StepNavigation.GetAncestorDirectorySettingObject(this);
            ManagementBaseObject[] mimeMaps = new ManagementBaseObject[maps.Length];

            for (int mapIndex = 0; mapIndex < maps.Length; mapIndex++)
            {
                ManagementPath mPath = new ManagementPath();
                mPath.ClassName = "MimeMap";
                mPath.NamespacePath = "root\\MicrosoftIISv2";

                mimeMaps[mapIndex] = new ManagementClass(IisRunnerStep.IisManagementScope, mPath, null).CreateInstance();
                mimeMaps[mapIndex]["Extension"] = maps[mapIndex].Extension;
                mimeMaps[mapIndex]["MimeType"] = maps[mapIndex].Type;
            }

            directory["MimeMap"] = mimeMaps;
        }

        public override void Validate()
        {
            GetMimeMaps();
            base.Validate ();
        }

        private MimeMap[] GetMimeMaps()
        {
            XmlNodeList mimeNodes = BaseXmlElement.SelectNodes("sequencens:MimeMap", Root.NamespaceManager);
            MimeMap[] mimeMaps = new MimeMap[mimeNodes.Count];

            for (int i = 0; i < mimeNodes.Count; i++)
            {
                XmlElement mapElement = (XmlElement) mimeNodes[i];

                mimeMaps[i].Extension = mapElement.GetAttribute("extension");
                if (mimeMaps[i].Extension.Length == 0)
                {
                    throw new ArgumentException("MimeMap node detected without required extension attribute.");
                }

                mimeMaps[i].Type = mapElement.GetAttribute("type");
                if (mimeMaps[i].Type.Length == 0)
                {
                    throw new ArgumentException("MimeMap node detected without required type attribute.");
                }
            }

            return mimeMaps;
        }
    
        private struct MimeMap
        {
            public string Extension;
            public string Type;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\IisRunner\ScriptMapsStep.cs ===
using System;
using System.Xml;
using System.Management;
using System.Collections;

using Leet.Tools.Setup.Wmi.Iisv2;
using Leet.Tools.Setup.XmlSequencer;

namespace Leet.Tools.Setup.IisRunner
{
    /// <summary>
    /// Handles configuration of IIS Metabase access settings.
    /// </summary>
    /// <remarks>
    /// <para>
    /// This step handles the <c>&lt;ScriptMaps&gt;</c> element in an IisRunner configuration file.
    /// It allows configuring script maps for the parent ApplicationStep object of the element.
    /// </para><para>
    /// The following table lists the attributes supported by the <c>&lt;ScriptMaps&gt;</c> element
    /// and a brief description of their meaning. For more information, see the IIS metabase 
    /// documentation at http://msdn.microsoft.com/library/default.asp?url=/library/en-us/iissdk/html/fb2fc296-4716-4717-a4ea-6c495acc6d2c.asp?frame=true.
    /// </para>
    /// <para>
    /// Note that this step will completely replace the script map settings of the Application it applies to, so you need to include
    /// the full set of script maps, not just additional script maps you want defined.
    /// <para>
    /// This step expects to have &lt;ScriptMap&gt; elements under it that define the specific script map. The expected attributes of
    /// these sub elements are:
    /// </para>
    /// <list type="table">
    /// <listheader>
    ///     <term>Attribute</term>
    ///     <description>Description</description>
    /// </listheader>
    ///     <term>extension</term>
    ///     <description>This attribute specifies the file name extension, such as .htm.</description>
    /// </item>
    /// <item>
    ///     <term>scriptProcessor</term>
    ///     <description>the full path to the DLL that will handle requests for the specified extension type.</description>
    /// </item>
    /// <item>
    ///     <term>scriptEngine</term>
    ///     <description>If set to true, scripts are allowed to run in directories given Script permission. If this attribute is set to false, then the script can only be run in directories that are flagged for Execute permission. Default is true.</description>
    /// </item>
    /// <item>
    ///     <term>checkPathInfo</term>
    ///     <description>
    ///     If set to true, the server attempts to access the PATH_INFO portion of the URL, as a file, before starting the scripting engine. 
    ///     If the file can't be opened, or doesn't exist, an error is returned to the client. If set to false, this check is not performed.
    ///     Default value is false.
    ///     </description>
    /// </item>
    /// <item>
    ///     <term>includedVerbs</term>
    ///     <description>Comma separated list of verbs that this script map will process.</description>
    /// </item>
    /// </list> 
    ///</remarks>
    [StepElement("ScriptMaps")]
    public class ScriptMapsStep : Step
    {
        public ScriptMapsStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
        }

        public IisRunnerStep IisRunnerStep
        {
            get 
            {
                if (!(Root is IisRunnerStep))
                {
                    throw new InvalidOperationException("The root step must be IisRunnerStep for WebServerSetup to function correctly."); 
                }

                return (IisRunnerStep) Root;
            }
        }

        protected override void OnExecute()
        {
            base.OnExecute ();

            Root.LogMessage("Adding script maps.");

            ScriptMap[] maps = GetScriptMaps();

            ManagementBaseObject directory = StepNavigation.GetAncestorApplicationHost(this).DirectorySettingObject;
            ManagementBaseObject[] scriptMaps = new ManagementBaseObject[maps.Length];

            for (int mapIndex = 0; mapIndex < scriptMaps.Length; mapIndex++)
            {
                ManagementPath mPath = new ManagementPath();
                mPath.ClassName = "ScriptMap";
                mPath.NamespacePath = "root\\MicrosoftIISv2";

                scriptMaps[mapIndex] = new ManagementClass(IisRunnerStep.IisManagementScope, mPath, null).CreateInstance();
                scriptMaps[mapIndex]["Extensions"] = maps[mapIndex].Extension;
                scriptMaps[mapIndex]["Flags"] = maps[mapIndex].Flags.ToString();
                scriptMaps[mapIndex]["IncludedVerbs"] = maps[mapIndex].IncludedVerbs;
                scriptMaps[mapIndex]["ScriptProcessor"] = maps[mapIndex].ScriptProcessor;
            }

            directory["ScriptMaps"] = scriptMaps;
        }

        public override void Validate()
        {
            if (!(this.Parent is ApplicationStep))
            {
                throw new InvalidOperationException("A <ScriptMaps> step must be an immediate child of an <Application> step.");
            }

            GetScriptMaps();
            base.Validate();
        }

        private ScriptMap[] GetScriptMaps()
        {
            XmlNodeList mapNodes = BaseXmlElement.SelectNodes("sequencens:ScriptMap", Root.NamespaceManager);
            ScriptMap[] scriptMaps = new ScriptMap[mapNodes.Count];

            for (int i = 0; i < mapNodes.Count; i++)
            {
                XmlElement mapElement = (XmlElement) mapNodes[i];

                scriptMaps[i].Extension = mapElement.GetAttribute("extension");
                if (scriptMaps[i].Extension.Length == 0)
                {
                    throw new ArgumentException("ScriptMap node detected without required extension attribute.");
                }

                scriptMaps[i].IncludedVerbs = mapElement.GetAttribute("includedVerbs").ToUpper();
                if (scriptMaps[i].IncludedVerbs.Length == 0)
                {
                    throw new ArgumentException("ScriptMap node detected without required includedVerbs attribute.");
                }

                scriptMaps[i].ScriptProcessor = mapElement.GetAttribute("scriptProcessor");
                if (scriptMaps[i].ScriptProcessor.Length == 0)
                {
                    throw new ArgumentException("ScriptMap node detected without required scriptProcessor attribute.");
                }

                scriptMaps[i].Flags = 0x1;

                string scriptEngine = mapElement.GetAttribute("scriptEngine");
                if (string.Compare(scriptEngine, "false", true) == 0)
                {
                    scriptMaps[i].Flags &= ~0x1;
                }

                string checkPathInfo = mapElement.GetAttribute("checkPathInfo");
                if (string.Compare(checkPathInfo, "true", true) == 0)
                {
                    scriptMaps[i].Flags &= 0x4;
                }
            }

            return scriptMaps;
        }
    
        private struct ScriptMap
        {
            public string Extension;
            public string ScriptProcessor;
            public int Flags;
            public string IncludedVerbs;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\IisRunner\ServerBindingStep.cs ===
using System;
using System.Xml;
using System.Management;

using Leet.Tools.Setup.Wmi.Iisv2;
using Leet.Tools.Setup.XmlSequencer;

namespace Leet.Tools.Setup.IisRunner
{
    /// <summary>
    /// Adds additional server bindings to the parent Web Server.
    /// </summary>
    /// <remarks>
    /// <para>
    /// This step handles the <c>&lt;ServerBinding&gt;</c> element in an IisRunner configuration file.
    /// It allows adding additional server bindings to the parent web server.
    /// </para><para>
    /// The following table lists the attributes supported by the <c>&lt;ServerBinding&gt;</c> element
    /// and a brief description of their meaning. For more information, see the IIS metabase 
    /// documentation at http://msdn.microsoft.com/library/default.asp?url=/library/en-us/iissdk/html/3a4c46ee-a2be-413b-b56b-2717fa8ef3b7.asp.
    /// </para>
    /// <list type="table">
    /// <listheader>
    ///     <term>Attribute</term>
    ///     <description>Description</description>
    /// </listheader>
    /// <item>
    ///     <term>ip</term>
    ///     <description>The IP address to bind to. If this attribute is not specified, the binding will be for any IP address.</description>
    /// </item>
    /// <item>
    ///     <term>port</term>
    ///     <description>The port to bind to. This attribute is required.</description>
    /// </item>
    /// <item>
    ///     <term>hostname</term>
    ///     <description>Specifies a hostname that must be in the Host part of the HTTP header for this binding to be active. If this attribute is not specified, the binding will be for all hostnames.</description>
    /// </item>
    /// </list> 
    ///</remarks>
    [StepElement("ServerBinding")]
    public class ServerBindingStep : Step
    {
        private Uri uri;

        public ServerBindingStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
        }

        public string Hostname
        {
            get
            {
                ProcessUri();
                if (uri != null)
                {
                    return uri.Host;
                }
                else
                {
                    return BaseXmlElement.GetAttribute("hostname");
                }
            }
        }

        private void ProcessUri()
        {
            if ((uri == null) && (BaseXmlElement.Attributes["uri"] != null))
            {
                uri = new Uri("http://" + BaseXmlElement.GetAttribute("uri"));
            }
        }

        public string IpAddress
        {
            get {return BaseXmlElement.GetAttribute("ip");}
        }

        public string Port
        {
            get 
            {
                ProcessUri();
                if (uri != null)
                {
                    return uri.Port.ToString();
                }
                else
                {
                    string port = BaseXmlElement.GetAttribute("port");

                    if (port == null)
                    {
                        throw new ArgumentException("The port attribute of the " + BaseXmlElement.Name + " element must be specified.", "name");
                    }

                    return port;
                }
            }
        }

        public IisRunnerStep IisRunnerStep
        {
            get 
            {
                if (!(Root is IisRunnerStep))
                {
                    throw new InvalidOperationException("The root step must be IisRunnerStep for ServerBinding to function correctly."); 
                }
                return (IisRunnerStep) Root;
            }
        }

        protected override void OnExecute()
        {
            base.OnExecute ();

            Root.LogMessage(String.Format(
                "Adding additional binding - IP={0}, Port={1}, Hostname={2}.", 
                (IpAddress == null) ? "*" : IpAddress,
                Port,
                (Hostname == null) ? "*" : Hostname));

            // get the existing bindings
            WebServerStep server = StepNavigation.GetWebServerAncestorOfStep(this);
            IIsWebServerSetting serverSetting = server.WebServerSetting;

            // copy existing bindings
            ManagementBaseObject[] oldBindings = serverSetting.ServerBindings;
            ManagementBaseObject[] siteBindings = new ManagementBaseObject[oldBindings.Length + 1];

            for (int i = 0; i < oldBindings.Length; i++)
            {
                ServerBinding siteBinding = ServerBinding.CreateInstance();
                siteBinding.IP = oldBindings[i].Properties["IP"].Value.ToString();
                siteBinding.Hostname = oldBindings[i].Properties["Hostname"].Value.ToString();
                siteBinding.Port = oldBindings[i].Properties["Port"].Value.ToString();
                siteBindings[i] = siteBinding.LateBoundObject;				                
            }

            // add the new binding
            ServerBinding newBinding = ServerBinding.CreateInstance();
            newBinding.IP = IpAddress;
            newBinding.Hostname = Hostname;
            newBinding.Port = Port;
            siteBindings[siteBindings.Length - 1] = newBinding.LateBoundObject;				

            serverSetting.ServerBindings = siteBindings;
        }

        public override void Validate()
        {
            int port = Convert.ToInt32(Port);
            base.Validate ();
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\IisRunner\WmiUtilities.cs ===
using System;
using System.Management;

using Leet.Tools.Setup.Wmi.Iisv2;

namespace Leet.Tools.Setup.IisRunner
{
	/// <summary>
	/// Summary description for WmiUtilities.
	/// </summary>
    public class WmiUtilities
    {
        public static IIsWebServerSetting FindWebServerSetting(ManagementScope mScope, string keyName)
        {
            IIsWebServerSetting.IIsWebServerSettingCollection items = IIsWebServerSetting.GetInstances(mScope, String.Format("Name=\"{0}\"", keyName));
    
            if (items.Count > 1)
            {
                throw new Exception("Multiple IIsWebServerSetting objects returned when only one was expected for key " + keyName + ".");
            }
            
            foreach (IIsWebServerSetting item in items)
            {
                return item;
            }

            return null;
        }
        
        public static IIsWebVirtualDirSetting FindWebVirtualDirSetting(ManagementScope mScope, string keyName)
        {
            IIsWebVirtualDirSetting.IIsWebVirtualDirSettingCollection items = IIsWebVirtualDirSetting.GetInstances(mScope, String.Format("Name=\"{0}\"", keyName));
    
            if (items.Count > 1)
            {
                throw new Exception("Multiple IIsWebVirtualDirSetting objects returned when only one was expected for key " + keyName + ".");
            }
            
            foreach (IIsWebVirtualDirSetting item in items)
            {
                return item;
            }

            return null;
        }

        public static IIsWebVirtualDir FindWebVirtualDir(ManagementScope mScope, string keyName)
        {
            IIsWebVirtualDir.IIsWebVirtualDirCollection items = IIsWebVirtualDir.GetInstances(mScope, String.Format("Name=\"{0}\"", keyName));
        
            if (items.Count > 1)
            {
                throw new Exception("Multiple IIsWebServerSetting objects returned when only one was expected for key " + keyName + ".");
            }
            
            foreach (IIsWebVirtualDir item in items)
            {
                return item;
            }
            return null;
        }


        public static IIsWebDirectorySetting FindWebDirectorySetting(ManagementScope mScope, string keyName)
        {
            IIsWebDirectorySetting.IIsWebDirectorySettingCollection items = IIsWebDirectorySetting.GetInstances(mScope, String.Format("Name=\"{0}\"", keyName));
    
            if (items.Count > 1)
            {
                throw new Exception("Multiple IIsWebDirectorySetting objects returned when only one was expected for key " + keyName + ".");
            }
            
            foreach (IIsWebDirectorySetting item in items)
            {
                return item;
            }

            return null;
        }

        public static IIsCompressionSchemeSetting FindCompressionSchemeSetting(ManagementScope mScope, string compressionTypeName)
        {
            IIsCompressionSchemeSetting.IIsCompressionSchemeSettingCollection items = IIsCompressionSchemeSetting.GetInstances(mScope, String.Format("Name=\"W3SVC/Filters/Compression/{0}\"", compressionTypeName));

            if (items.Count > 1)
            {
                throw new Exception("Multiple IIsCompressionSchemeSetting objects returned when only one was expected for compressionTypeName " + compressionTypeName + ".");
            }

            foreach (IIsCompressionSchemeSetting item in items)
            {
                return item;
            }

            return null;
        }

        public static IIsCompressionSchemesSetting GetCompressionSchemesSetting(ManagementScope mScope)
        {
            IIsCompressionSchemesSetting.IIsCompressionSchemesSettingCollection items = IIsCompressionSchemesSetting.GetInstances(mScope, "");

            if (items.Count > 1)
            {
                throw new Exception("Multiple IIsCompressionSchemesSetting objects returned when only one was expected.");
            }

            foreach (IIsCompressionSchemesSetting item in items)
            {
                return item;
            }

            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\IisRunner\VirtualDirStep.cs ===
using System;
using System.IO;
using System.Xml;
using System.Management;
using System.Data.SqlClient;

using Leet.Tools.Setup.Wmi.Iisv2;
using Leet.Tools.Setup.XmlSequencer;

namespace Leet.Tools.Setup.IisRunner
{
	/// <summary>
	/// Summary description for WebSeverStep.
	/// </summary>
	[StepElement("VirtualDir")]
	public class VirtualDirStep : StepContainer, IDirectorySetting, IApplicationHost
	{
        private string name = null;
        private string path = null;
        private string keyName = null;
        private IIsWebVirtualDir virtualDir = null;
        private IIsWebVirtualDirSetting webVirtualDirSetting = null;

        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
		public VirtualDirStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
		{
            name = BaseXmlElement.GetAttribute("name");
            path = BaseXmlElement.GetAttribute("path");

            if (name.Length == 0)
            {
                throw new ArgumentException("The name attribute of the virtualDirectory element must be specified.", "name");
            }

            if (path.Length == 0)
            {
                throw new ArgumentException("The path attribute of the virtualDirectory element must be specified and must be a valid file system path.", "path");
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public int SiteId
        {
            get { return StepNavigation.GetWebServerAncestorOfStep(this).SiteId; }
        }

        public string Name
        {
            get {return name;}
        }

        public string Path
        {
            get {return path;}
        }

        public string KeyName
        {
            get 
            {
                if (keyName == null)
                {
                    ManagementBaseObject directory = StepNavigation.GetAncestorDirectorySettingObject(this);

                    keyName = directory["Name"] + "/" + Name;
                }

                return keyName;
            }
        }

        public IIsWebVirtualDirSetting WebVirtualDirSetting
        {
            get {return webVirtualDirSetting;}
        }

        /// <summary>
        /// 
        /// </summary>
        public IisRunnerStep IisRunnerStep
        {
            get 
            {
                if (!(Root is IisRunnerStep))
                {
                    throw new InvalidOperationException("The root step must be IisRunnerStep for this step to function correctly."); 
                }
                return (IisRunnerStep) Root;
            }
        }

        protected override void OnExecute()
        {
            ManagementScope mScope = IisRunnerStep.IisManagementScope;

            webVirtualDirSetting = WmiUtilities.FindWebVirtualDirSetting(mScope, KeyName);

            if (WebVirtualDirSetting == null)
            {
                Root.LogMessage(
                    String.Format("Creating virtual directory {0} with its web files at {1}.",
                    Name,
                    Path));

                if (!Directory.Exists(Path))
                {
                    Directory.CreateDirectory(Path);
                }

                virtualDir = IIsWebVirtualDir.CreateInstance();
    
                virtualDir.LateBoundObject["Name"] = KeyName;
                virtualDir.CommitObject();

                webVirtualDirSetting = WmiUtilities.FindWebVirtualDirSetting(mScope, KeyName);
            }

            WebVirtualDirSetting.Path0 = Path;

            // let contained steps execute
            base.OnExecute ();
        }

        protected override void OnAfterExecute()
        {
            ManagementScope mScope = IisRunnerStep.IisManagementScope;

            if (WebVirtualDirSetting != null)
            {
                WebVirtualDirSetting.CommitObject();
            }

            webVirtualDirSetting = null;
            base.OnAfterExecute ();
        }


        #region IDirectorySetting Members

        /// <summary>
        /// Gets the ManagementBaseObject for the IIsWebVirtualDirSetting WMI interface for the root VDir
        /// defined for this VirtualDirStep.
        /// </summary>
        public ManagementBaseObject DirectorySettingObject
        {
            get
            {
                if (WebVirtualDirSetting == null)
                {
                    throw new InvalidOperationException("DirectorySettingsObject is only valid during the execute phase of this object.");
                }

                return WebVirtualDirSetting.LateBoundObject;
            }
        }

        #endregion

        #region IApplicationHost Members

        public void CreateApplication(ApplicationMode appMode, string appPoolName)
        {
            ManagementScope mScope = IisRunnerStep.IisManagementScope;

            if (WebVirtualDirSetting == null)
            {
                throw new InvalidOperationException("CreateApplication is only valid during the execute phase of this object.");
            }

            IIsWebVirtualDir virtualDir = new IIsWebVirtualDir(mScope, KeyName);

            if ((appPoolName == null) || (appPoolName.Length == 0))
            {
                virtualDir.AppCreate2((int) appMode);
            }
            else
            {
                virtualDir.AppCreate3((int) appMode, appPoolName, false);

                // Need to also set the WebVirtualDirSetting AppPoolId property
                // because it will overwrite the AppPoolId set by AppCreate3
                // when it the WebVirtualDirSetting object is later commited.

                WebVirtualDirSetting.LateBoundObject["AppPoolId"] = appPoolName;
            }

             WebVirtualDirSetting.LateBoundObject["AppFriendlyName"] = Name + " Application";
            
        }

        public void DeleteApplication()
        {
            ManagementScope mScope = IisRunnerStep.IisManagementScope;

            if (WebVirtualDirSetting == null)
            {
                throw new InvalidOperationException("DeleteApplication is only valid during the execute phase of this object.");
            }

            IIsWebVirtualDir virtualDir = new IIsWebVirtualDir(mScope, KeyName);

            virtualDir.AppDelete(false);
        }

        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\IisRunner\WebDirectoryStep.cs ===
using System;
using System.IO;
using System.Xml;
using System.Management;
using System.Data.SqlClient;

using Leet.Tools.Setup.Wmi.Iisv2;
using Leet.Tools.Setup.XmlSequencer;

namespace Leet.Tools.Setup.IisRunner
{
	/// <summary>
	/// Summary description for WebDirectoryStep.
	/// </summary>
	[StepElement("WebDirectory")]
	public class WebDirectoryStep : StepContainer, IDirectorySetting, IApplicationHost
	{
        private string name = null;
        private string keyName = null;
        private IIsWebDirectorySetting webDirectorySetting = null;

        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
		public WebDirectoryStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
		{
            name = BaseXmlElement.GetAttribute("name").Trim();

            if (name.Length == 0)
            {
                throw new ArgumentException("The name attribute of the " + BaseXmlElement.Name + " element must be specified.", "name");
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public int SiteId
        {
            get { return StepNavigation.GetWebServerAncestorOfStep(this).SiteId; }
        }

        public string Name
        {
            get {return name;}
        }

        public string KeyName
        {
            get 
            {
                if (keyName == null)
                {
                    ManagementBaseObject directory = StepNavigation.GetAncestorDirectorySettingObject(this);

                    keyName = directory["Name"] + "/" + Name;
                }

                return keyName;
            }
        }

        public IIsWebDirectorySetting WebDirectorySetting
        {
            get {return webDirectorySetting;}
        }

        /// <summary>
        /// 
        /// </summary>
        public IisRunnerStep IisRunnerStep
        {
            get 
            {
                if (!(Root is IisRunnerStep))
                {
                    throw new InvalidOperationException("The root step must be IisRunnerStep for this step to function correctly."); 
                }
                return (IisRunnerStep) Root;
            }
        }

        protected override void OnExecute()
        {
            ManagementScope mScope = IisRunnerStep.IisManagementScope;

            webDirectorySetting = WmiUtilities.FindWebDirectorySetting(mScope, KeyName);

            if (WebDirectorySetting == null)
            {
                Root.LogMessage(String.Format("Creating web directory {0}.", Name));

                IIsWebDirectory directory = IIsWebDirectory.CreateInstance();
    
                directory.LateBoundObject["Name"] = KeyName;
                directory.CommitObject();

                webDirectorySetting = WmiUtilities.FindWebDirectorySetting(mScope, KeyName);
            }

            // create the directory if it doesn't exist

            string path = Name;
            Step pathStep = this.Parent;

            while (pathStep != null)
            {
                WebDirectoryStep wdStep = pathStep as WebDirectoryStep;
                VirtualDirStep vdStep = pathStep as VirtualDirStep;
                WebServerStep wsStep = pathStep as WebServerStep;

                if (wdStep != null)
                {
                    path = Path.Combine(wdStep.Name, path);
                }
                else if (vdStep != null)
                {
                    path = Path.Combine(vdStep.Path, path);
                    if (!Directory.Exists(path))
                    {
                        Directory.CreateDirectory(path);
                    }
                    break;
                }
                else if (wsStep != null)
                {
                    path = Path.Combine(wsStep.WebrootPath, path);
                    if (!Directory.Exists(path))
                    {
                        Directory.CreateDirectory(path);
                    }
                    break;
                }
                pathStep = pathStep.Parent;
            }

            // let contained steps execute
            base.OnExecute ();
        }

        protected override void OnAfterExecute()
        {
            ManagementScope mScope = IisRunnerStep.IisManagementScope;

            if (WebDirectorySetting != null)
            {
                WebDirectorySetting.CommitObject();
            }

            webDirectorySetting = null;
            base.OnAfterExecute ();
        }


        #region IDirectorySetting Members

        /// <summary>
        /// Gets the ManagementBaseObject for the IIsWebDirectorySetting WMI interface for the root VDir
        /// defined for this DirectoryStep.
        /// </summary>
        public ManagementBaseObject DirectorySettingObject
        {
            get
            {
                if (WebDirectorySetting == null)
                {
                    throw new InvalidOperationException("DirectorySettingsObject is only valid during the execute phase of this object.");
                }

                return WebDirectorySetting.LateBoundObject;
            }
        }

        #endregion

        #region IApplicationHost Members

        public void CreateApplication(ApplicationMode appMode, string appPoolName)
        {
            ManagementScope mScope = IisRunnerStep.IisManagementScope;

            if (WebDirectorySetting == null)
            {
                throw new InvalidOperationException("CreateApplication is only valid during the execute phase of this object.");
            }

            IIsWebDirectory virtualDir = new IIsWebDirectory(mScope, WebDirectorySetting.Name);

            if ((appPoolName == null) || (appPoolName.Length == 0))
            {
                virtualDir.AppCreate2((int) appMode);
            }
            else
            {
                virtualDir.AppCreate3((int) appMode, appPoolName, false);

                // Need to also set the WebVirtualDirSetting AppPoolId property
                // because it will overwrite the AppPoolId set by AppCreate3
                // when it the WebVirtualDirSetting object is later commited.

                WebDirectorySetting.LateBoundObject["AppPoolId"] = appPoolName;
            }

            WebDirectorySetting.LateBoundObject["AppFriendlyName"] = Name + " Application";
            
        }

        public void DeleteApplication()
        {
            ManagementScope mScope = IisRunnerStep.IisManagementScope;

            if (WebDirectorySetting == null)
            {
                throw new InvalidOperationException("DeleteApplication is only valid during the execute phase of this object.");
            }

            IIsWebDirectory virtualDir = new IIsWebDirectory(mScope, WebDirectorySetting.Name);

            virtualDir.AppDelete(false);
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\IisRunner\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Leet.Tools.Setup.IisRunner")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\SqlRunner\AddRoleStep.cs ===
using System;
using System.Xml;
using System.Text;
using System.Data.SqlClient;

using xonline.common.config;
using Leet.Tools.Setup.XmlSequencer;

namespace Leet.Tools.Setup.SqlRunner
{
    /// <summary>
    /// Summary description for AddRoleStep.
    /// </summary>
    [StepElement("addRole")]
    public class AddRoleStep : StepContainer
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
        public AddRoleStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
        }

        /// <summary>
        /// 
        /// </summary>
        public DatabaseStep DatabaseStep
        {
            get {return DatabaseStep.GetDatabaseAncestorOfStep(this);}
        }

        public string RoleName
        {
            get
            {
                string role = BaseXmlElement.GetAttribute("role").Trim();

                if (role.Length == 0)
                {
                    throw new ArgumentException("Required attribute 'role' not specified for element <" + BaseXmlElement.LocalName + "> in the following line.\r\n" + BaseXmlElement.OuterXml);
                }

                return role;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        protected override void OnExecute()
        {
            String sql = String.Format(@"
                if not exists (select * from sys.database_principals where name = N'{0}' and type = N'R')
                    CREATE ROLE {0}", 
                RoleName);

            Root.LogMessage("\nCreating role - " + RoleName);
            DatabaseStep.ExecuteSql(sql);

            // process any child nodes
            base.OnExecute ();
        }

        public override void Validate()
        {
            base.Validate();

            // Make sure the database name has been specified
            string roleCheck = RoleName;
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="startStep"></param>
        /// <returns></returns>
        static public AddRoleStep GetAddRoleAncestorOfStep(Step startStep)
        {
            Step currentStep = startStep;

            while (currentStep != null)
            {
                if (currentStep is AddRoleStep)
                {
                    return (AddRoleStep) currentStep;
                }

                currentStep = currentStep.Parent;
            }

            throw new InvalidOperationException("Required addRole step not present in the hierarchy above the current step.\r\n Current step = " + startStep.BaseXmlElement.OuterXml);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\SqlRunner\AddRoleMemberStep.cs ===
using System;
using System.Xml;
using System.Text;
using System.Data.SqlClient;

using xonline.common.config;
using Leet.Tools.Setup.XmlSequencer;

namespace Leet.Tools.Setup.SqlRunner
{
    /// <summary>
    /// Summary description for AddRoleMemberStep.
    /// </summary>
    [StepElement("addRoleMember")]
    public class AddRoleMemberStep : Step
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
        public AddRoleMemberStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
        }

        /// <summary>
        /// 
        /// </summary>
        public AddRoleStep AddRoleStep
        {
            get {return AddRoleStep.GetAddRoleAncestorOfStep(this);}
        }

        public DatabaseStep DatabaseStep
        {
            get {return DatabaseStep.GetDatabaseAncestorOfStep(this);}
        }

        public string UserName
        {
            get
            {
                string user = BaseXmlElement.GetAttribute("user").Trim();
                string userComponent = BaseXmlElement.GetAttribute("userComponent").Trim();
                string userInterface = BaseXmlElement.GetAttribute("userInterface").Trim();
                
                if (user.Length != 0)
                {
                    return user;
                }
                else if (userComponent.Length != 0)
                {
                    string component = userComponent;

                    IComponentInfo componentInfo = Config.GetComponent(component);

                    if ((componentInfo.Username == null) || (componentInfo.Username.Length == 0))
                    {
                        throw new ArgumentException("Username for component " + component.ToString() + " is not defined in the configuration database.", "userComponent");
                    }

                    // transform any %COMPUTERNAME% tokens in the username field to be the current machine name.
                    // this allows us to use local machine accounts, changing the username to always reference
                    // the local instance of the account.
                    return componentInfo.Username.Replace("%COMPUTERNAME%", Environment.MachineName);
                }
                else if (userInterface.Length != 0)
                {
                    IInterfaceInfo interfaceInfo = null;
                    try
                    {
                        interfaceInfo = Config.GetInterface(Environment.MachineName, userInterface);
                    }
                    catch (ApplicationException ex)
                    {
                        // An ApplicationException probably means that the interface doesn't exist on the current server, 
                        // so see if we can find the interface on any server.

                        string[] serverList = Config.GetServerListByInterface(userInterface);
                        if (serverList.Length == 0)
                        {
                            throw new ApplicationException("Couldn't find any servers exposing interface " + userInterface, ex);
                        }
 
                        interfaceInfo = Config.GetInterface(serverList[0], userInterface);
                    }

                    if ((interfaceInfo.Username == null) || (interfaceInfo.Username.Length == 0))
                    {
                        throw new ArgumentException("Username for interface " + userInterface + " is not defined in the configuration database.", "userInterface");
                    }

                    // transform any %COMPUTERNAME% tokens in the username field to be the current machine name.
                    // this allows us to use local machine accounts, changing the username to always reference
                    // the local instance of the account.

                    return interfaceInfo.Username.Replace("%COMPUTERNAME%", Environment.MachineName);
                }
                else
                {
                    throw new ArgumentException("One of the attributes 'user', 'userComponent', or 'userInterface is required for element <" + BaseXmlElement.LocalName + "> in the following line.\r\n" + BaseXmlElement.OuterXml);
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        protected override void OnExecute()
        {
            base.OnExecute ();

            Root.LogMessage("Adding user " + UserName + " to role " + AddRoleStep.RoleName);

            String sql = String.Format(@"
                EXEC sp_grantlogin N'{0}'

                if not exists (select sl.loginname from master..syslogins sl join sysusers su on sl.sid = su.sid where sl.loginname=N'{0}')
                begin
                    EXEC sp_grantdbaccess N'{0}'
                end
                
                EXEC sp_addrolemember N'{1}', N'{0}'
                ", 
                UserName,
                AddRoleStep.RoleName);

            DatabaseStep.ExecuteSql(sql);
        }

        public override void Validate()
        {
            base.Validate();

            // make sure we have a valid parent
            AddRoleStep roleStep = AddRoleStep;

            // Make sure the user name has been specified
            string userName = UserName;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\IisRunner\WebServerStep.cs ===
using System;
using System.IO;
using System.Xml;
using System.Management;
using System.DirectoryServices;
using System.ServiceProcess;
using System.Data.SqlClient;

using Leet.Tools.Setup.Wmi.Iisv2;
using Leet.Tools.Setup.XmlSequencer;

namespace Leet.Tools.Setup.IisRunner
{
    /// <summary>
    /// Summary description for WebSeverStep.
    /// </summary>
    [StepElement("WebServer")]
    public class WebServerStep : StepContainer, IDirectorySetting, IApplicationHost
    {
        private int siteId = 0;
        private IIsWebServerSetting webServerSetting = null;
        private IIsWebVirtualDirSetting webVirtualDirSetting = null;

        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
        public WebServerStep(XmlElement stepElement, StepContainer parent)
            : base(stepElement, parent)
        {
            try
            {
                siteId = Convert.ToInt32(BaseXmlElement.GetAttribute("siteId"));
            }
            catch (FormatException)
            {
                throw new ArgumentOutOfRangeException("siteId", BaseXmlElement.GetAttribute("siteId"), "A numeric siteId attribute is required for a " + BaseXmlElement.Name + " element.");
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public int SiteId
        {
            get { return siteId; }
        }

        public string SiteName
        {
            get { return BaseXmlElement.GetAttribute("name"); }
        }

        public string Hostname
        {
            get { return BaseXmlElement.GetAttribute("hostname"); }
        }

        public string IpAddress
        {
            get { return BaseXmlElement.GetAttribute("ip"); }
        }

        public string Port
        {
            get { return BaseXmlElement.GetAttribute("port"); }
        }

        public string WebrootPath
        {
            get { return BaseXmlElement.GetAttribute("webrootPath"); }
        }

        public bool? UseHostName
        {
            get { return GetBoolAttribute("useHostName"); }
        }

        public string SetHostName
        {
            get { return BaseXmlElement.GetAttribute("setHostName"); }
        }

        public IIsWebServerSetting WebServerSetting
        {
            get { return webServerSetting; }
        }

        public IIsWebVirtualDirSetting WebVirtualDirSetting
        {
            get { return webVirtualDirSetting; }
        }

        public byte[] SSLCertHash
        {
            set
            {
                DirSvcObject.Invoke("Put", new object[] { "SSLCertHash", value });
                DirSvcObject.Properties["SSLStoreName"][0] = "my";
            }
        }

        public string SecureBinding
        {
            set
            {
                // DirSvcObject.Properties["SecureBindings"].Clear();
                DirSvcObject.Properties["SecureBindings"].Add(value);
            }
            get
            {
                PropertyValueCollection bindings = DirSvcObject.Properties["SecureBindings"];
                return (bindings.Count == 0) ? string.Empty : (bindings[0] as string);
            }
        }

        protected DirectoryEntry DirSvcObject
        {
            get
            {
                if (_dirSvcObject == null)
                {
                    _dirSvcObject = new DirectoryEntry("IIS://localhost/w3svc/" + SiteId.ToString());
                }
                return _dirSvcObject;
            }
        }
        private DirectoryEntry _dirSvcObject = null;

        /// <summary>
        /// 
        /// </summary>
        public IisRunnerStep IisRunnerStep
        {
            get
            {
                if (!(Root is IisRunnerStep))
                {
                    throw new InvalidOperationException("The root step must be IisRunnerStep for WebServerSetup to function correctly.");
                }
                return (IisRunnerStep)Root;
            }
        }

        protected override void OnBeforeExecute()
        {
            base.OnBeforeExecute();

            // We are sometimes getting the following error message in certain cases:
            // Win32: The service did not respond to the start or control request in a timely fashion.
            // If W3SVC is running, we don't get these errors. Since we always start W3SVC at the end of
            // this process anyway, and many of the steps will cause W3SVC to start, we're going to just
            // start the service now to make everything happy.

            ServiceController sc = new ServiceController("W3SVC");

            if (sc.Status == ServiceControllerStatus.Stopped)
            {
                Root.LogMessage("Starting W3SVC service.");

                sc.Start();

                try
                {
                    //wait 30 seconds for the service to start
                    sc.WaitForStatus(ServiceControllerStatus.Running, new TimeSpan(0, 0, 30));
                }
                catch (System.ServiceProcess.TimeoutException)
                {
                    Root.LogMessage(
                        "W3SVC service did not respond to the start command in a timely fashion. We'll attempt to still configure the metabase, but this may cause problems later in the process.");
                }
            }
        }

        protected override void OnExecute()
        {
            ManagementScope mScope = IisRunnerStep.IisManagementScope;

            string keyName = "W3SVC/" + SiteId.ToString();

            webServerSetting = WmiUtilities.FindWebServerSetting(mScope, keyName);

            if (WebServerSetting == null)
            {
                Root.LogMessage(
                    String.Format("Creating web server {0} with ID {1} at {2}:{3} with the webroot files at {4}.",
                    SiteName,
                    SiteId,
                    IpAddress,
                    Port,
                    WebrootPath
                    ));

                if (!Directory.Exists(WebrootPath))
                {
                    Directory.CreateDirectory(WebrootPath);
                }

                ManagementBaseObject[] siteBindings = new ManagementBaseObject[1];

                ServerBinding siteBinding = ServerBinding.CreateInstance();
                siteBinding.IP = IpAddress;
                siteBinding.Hostname = Hostname;
                siteBinding.Port = Port;
                siteBindings[0] = siteBinding.LateBoundObject;

                IIsWebService webService = new IIsWebService(mScope, "W3SVC");
                webService.CreateNewSite(WebrootPath, siteBindings, SiteName, SiteId);

                webServerSetting = WmiUtilities.FindWebServerSetting(mScope, keyName);
            }

            if (UseHostName.HasValue)
            {
                webServerSetting.UseHostName = UseHostName.Value;
            }

            if (!String.IsNullOrEmpty(SetHostName))
            {
                webServerSetting.SetHostName = SetHostName;
            }
            
            webVirtualDirSetting = WmiUtilities.FindWebVirtualDirSetting(mScope, keyName + "/root");

            WebVirtualDirSetting.AppFriendlyName = SiteName + " Application";

            // let contained steps execute
            base.OnExecute();
        }

        protected override void OnAfterExecute()
        {
            ManagementScope mScope = IisRunnerStep.IisManagementScope;

            string keyName = "W3SVC/" + SiteId.ToString();

            if (WebVirtualDirSetting != null)
            {
                WebVirtualDirSetting.CommitObject();
            }

            if (WebServerSetting != null)
            {
                WebServerSetting.CommitObject();
            }

            if (_dirSvcObject != null)
            {
                _dirSvcObject.CommitChanges();
            }

            IIsWebServer webServer = new IIsWebServer(mScope, keyName);

            try
            {
                webServer.Start();
            }
            catch (System.Runtime.InteropServices.COMException ex)
            {
                Root.LogMessage("Couldn't start site " + SiteName + ". Consult IIS Manager to determine cause of error (probably due to this site's bindings conflicting with an existing site).");
                Root.LogMessage("Full exception information: " + ex.ToString());
            }

            Root.LogMessage("Create of web site complete");

            webServerSetting = null;
            base.OnAfterExecute();
        }

        #region IDirectorySetting Members

        /// <summary>
        /// Gets the ManagementBaseObject for the IIsWebServerSetting WMI interface for the root VDir
        /// defined for this WebServerStep.
        /// </summary>
        public ManagementBaseObject DirectorySettingObject
        {
            get
            {
                if (WebVirtualDirSetting == null)
                {
                    throw new InvalidOperationException("DirectorySettingsObject is only valid during the execute phase of this object.");
                }

                return WebVirtualDirSetting.LateBoundObject;
            }
        }

        #endregion

        #region IApplicationHost Members

        public void CreateApplication(ApplicationMode appMode, string appPoolName)
        {
            ManagementScope mScope = IisRunnerStep.IisManagementScope;

            if (WebVirtualDirSetting == null)
            {
                throw new InvalidOperationException("CreateApplication is only valid during the execute phase of this object.");
            }

            IIsWebVirtualDir virtualDir = new IIsWebVirtualDir(mScope, WebVirtualDirSetting.Name);

            if ((appPoolName == null) || (appPoolName.Length == 0))
            {
                virtualDir.AppCreate2((int)appMode);
            }
            else
            {
                virtualDir.AppCreate3((int)appMode, appPoolName, false);

                // Need to also set the WebVirtualDirSetting AppPoolId property
                // because it will overwrite the AppPoolId set by AppCreate3
                // when it the WebVirtualDirSetting object is later commited.

                WebVirtualDirSetting.LateBoundObject["AppPoolId"] = appPoolName;
            }

            WebVirtualDirSetting.LateBoundObject["AppFriendlyName"] = SiteName + " Application";

        }

        public void DeleteApplication()
        {
            ManagementScope mScope = IisRunnerStep.IisManagementScope;

            if (WebVirtualDirSetting == null)
            {
                throw new InvalidOperationException("DeleteApplication is only valid during the execute phase of this object.");
            }

            IIsWebVirtualDir virtualDir = new IIsWebVirtualDir(mScope, WebVirtualDirSetting.Name);

            virtualDir.AppDelete(false);
        }
        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\SqlRunner\AddLinkedServerStep.cs ===
using System;
using System.Xml;
using System.Text;
using System.Data.SqlClient;

using xonline.common.config;
using Leet.Tools.Setup.XmlSequencer;

namespace Leet.Tools.Setup.SqlRunner
{
    
    /// <summary>
    /// Summary description for AddLinkedServerStep.
    /// </summary>
    [StepElement("addLinkedServer")]
    public class AddLinkedServerStep : Step
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
        public AddLinkedServerStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
        }

        /// <summary>
        /// 
        /// </summary>
        public DatabaseStep DatabaseStep
        {
            get {return DatabaseStep.GetDatabaseAncestorOfStep(this);}
        }

        public string LinkedServer
        {
            get
            {
                string linkedServer = BaseXmlElement.GetAttribute("linkedServer").Trim();

                if (linkedServer.Length == 0)
                {
                    throw new ArgumentException("Required attribute 'linkedServer' not specified for element <" + BaseXmlElement.LocalName + "> in the following line.\r\n" + BaseXmlElement.OuterXml);
                }

                return linkedServer;
            }
        }

        public string ServerName
        {
            get
            {
                string attribValue = BaseXmlElement.GetAttribute("interface").Trim();

                if (attribValue.Length == 0)
                {
                    throw new ArgumentException("Required attribute 'interface' not specified for element <" + BaseXmlElement.LocalName + "> in the following line.\r\n" + BaseXmlElement.OuterXml);
                }

                IInterfaceInfo interfaceInfo = null;
                try
                {
                    interfaceInfo = Config.GetSingleInterface(attribValue);
                }
                catch (ApplicationException ex)
                {
                    // An ApplicationException probably means that the interface doesn't exist on the current server, 
                    throw new ApplicationException("Couldn't find the interface " + attribValue + " for this envirnoment.\r\n", ex);
                }

                return interfaceInfo.ServerName;
            }
        }

        public string DBName
        {
            get
            {
                string attribValue = BaseXmlElement.GetAttribute("interface").Trim();

                if (attribValue.Length == 0)
                {
                    throw new ArgumentException("Required attribute 'interface' not specified for element <" + BaseXmlElement.LocalName + "> in the following line.\r\n" + BaseXmlElement.OuterXml);
                }

                IInterfaceInfo interfaceInfo = null;
                try
                {
                    interfaceInfo = Config.GetSingleInterface(attribValue);
                }
                catch (ApplicationException ex)
                {
                    // An ApplicationException probably means that the interface doesn't exist on the current server, 
                    throw new ApplicationException("Couldn't find the interface " + attribValue + " for this envirnoment.\r\n", ex);
                }

                return interfaceInfo.DBName;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        protected override void OnExecute()
        {
            base.OnExecute();

            String sql = String.Format(@"
IF EXISTS (SELECT NULL FROM sys.servers WHERE [name] = N'{0}' AND is_linked = 1)
Begin		EXEC master.sys.sp_dropserver @server = N'{0}'
End
EXEC master.sys.sp_addlinkedserver @server = N'{0}',@srvproduct = N'', @provider = N'SQLOLEDB', @provstr = N'DRIVER={{SQL Server}};SERVER={1}',@catalog=N'{2}'",
                LinkedServer,
                ServerName,
                DBName);

            Root.LogMessage("\nadding linkedserver - " + LinkedServer + " - " + ServerName + " - " + DBName);
            DatabaseStep.ExecuteSql(sql);
        }

        public override void Validate()
        {
            base.Validate();
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\SqlRunner\CLRBaseStep.cs ===
using System;
using System.Xml;
using System.Data.SqlClient;

using Leet.Tools.Setup.XmlSequencer;

namespace Leet.Tools.Setup.SqlRunner
{
	/// <summary>
	/// Summary description for CLRBaseStep.
	/// </summary>
    public class CLRBaseStep : Step
	{
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
		public CLRBaseStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
		{
		}

        /// <summary>
        /// 
        /// </summary>
        public CLRStep CLRStep
        {
            get {return CLRStep.GetCLRAncestorOfStep(this);}
        }

        /// <summary>
        /// 
        /// </summary>
		public DatabaseStep DatabaseStep
		{
			get {return DatabaseStep.GetDatabaseAncestorOfStep(this);}
		}

        /// <summary>
        /// 
        /// </summary>
        public string AssemblyName
        {
            get {return CLRStep.AssemblyName;}
        }

        /// <summary>
        /// 
        /// </summary>
        public string MethodName
        {
            get
            {
                string method = BaseXmlElement.GetAttribute("method").Trim();

                if (method.Length == 0)
                {
                    return "";
                }

                return method;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        protected override void OnExecute()
        {
            base.OnExecute ();
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\SqlRunner\CLRProcStep.cs ===
using System;
using System.Xml;
using System.Data.SqlClient;

using Leet.Tools.Setup.XmlSequencer;

namespace Leet.Tools.Setup.SqlRunner
{
	/// <summary>
	/// Summary description for CLRProcStep.
	/// </summary>
    [StepElement("clrProcedure")]
    public class CLRProcStep : CLRBaseStep
	{
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
		public CLRProcStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
		{
		}

        /// <summary>
        /// 
        /// </summary>
        public string ProcedureDefinition
        {
            get
            {
                string procedure = BaseXmlElement.GetAttribute("procedure").Trim();

                if (procedure.Length == 0)
                {
                    return "";
                }

                return procedure;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public string ProcedureName
        {
            get
            {
                string procedure = ProcedureDefinition;
                int parenIndex = procedure.IndexOf('(');

                if(parenIndex > 0)
                {
                    procedure = procedure.Substring(0, parenIndex);
                }

                return procedure;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        protected override void OnExecute()
        {
            base.OnExecute ();
        
            //
            // Create the procedure from the assembly
            //
            string sql = String.Format(@"
                DECLARE @vc_sql AS NVARCHAR(MAX)
                IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[{0}]') AND type in (N'P', N'PC'))
                BEGIN
                    SET @vc_sql = 'CREATE PROCEDURE {1} AS EXTERNAL NAME {2}.{3}'
                    EXEC SP_EXECUTESQL @vc_sql
                END
                ELSE
                BEGIN
                    SET @vc_sql = 'ALTER PROCEDURE {1} AS EXTERNAL NAME {2}.{3}'
                    EXEC SP_EXECUTESQL @vc_sql
                END",
                ProcedureName, ProcedureDefinition, AssemblyName, MethodName);
        
            Root.LogMessage("\nCreating procedure - " + ProcedureName);
            DatabaseStep.ExecuteSql(sql);
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\SqlRunner\AttachDatabaseStep.cs ===
using System;
using System.Xml;
using System.Text;
using System.Data.SqlClient;

using xonline.common.config;
using Leet.Tools.Setup.XmlSequencer;

namespace Leet.Tools.Setup.SqlRunner
{

    /// <summary>
    /// Summary description for AttachDatabaseStep.
    /// </summary>
    [StepElement("attachDatabase")]
    public class AttachDatabaseStep : Step
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
        public AttachDatabaseStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
        }

        /// <summary>
        /// 
        /// </summary>
        public DatabaseStep DatabaseStep
        {
            get {return DatabaseStep.GetDatabaseAncestorOfStep(this);}
        }

        public string DatabaseName
        {
            get
            {
                string database = BaseXmlElement.GetAttribute("database").Trim();

                if (database.Length == 0)
                {
                    throw new ArgumentException("Required attribute 'database' not specified for element <" + BaseXmlElement.LocalName + "> in the following line.\r\n" + BaseXmlElement.OuterXml);
                }

                return database;
            }
        }

        public string DataFileName
        {
            get
            {
                string attribValue = BaseXmlElement.GetAttribute("dataFilename").Trim();

                if (attribValue.Length == 0)
                {
                    throw new ArgumentException("Required attribute 'dataFilename' not specified for element <" + BaseXmlElement.LocalName + "> in the following line.\r\n" + BaseXmlElement.OuterXml);
                }

                return attribValue;
            }
        }

        public string LogFileName
        {
            get
            {
                string attribValue = BaseXmlElement.GetAttribute("logFilename").Trim();

                if (attribValue.Length == 0)
                {
                    throw new ArgumentException("Required attribute 'logFilename' not specified for element <" + BaseXmlElement.LocalName + "> in the following line.\r\n" + BaseXmlElement.OuterXml);
                }

                return attribValue;
            }
        }



        /// <summary>
        /// Specifies the path to where the data file will be saved. 
        /// </summary>
        /// <remarks>
        /// Maps to the attribute &quot;dataPath&quot; in the source XML.
        /// Defaults to the value of the config setting setup_sqldbroot.
        /// </remarks>
        public string DataPath
        {
            get
            {
                string attribValue = BaseXmlElement.GetAttribute("dataPath").Trim();

                if (attribValue.Length == 0)
                {
                    return Config.GetSetting(Setting.setup_sqldbroot);
                }

                return attribValue;
            }
        }


        /// <summary>
        /// 
        /// </summary>
        protected override void OnExecute()
        {
            base.OnExecute ();

            String sql = String.Format(@"
            IF NOT EXISTS (SELECT name FROM master.dbo.sysdatabases WHERE name = N'{0}')
	        exec sp_attach_db  @dbname= N'{0}',@filename1=N'{1}\{2}',@filename2=N'{3}\{4}'", 
                DatabaseName,
                DataPath,
                DataFileName,
                DataPath,
                LogFileName);

            Root.LogMessage("\nAttaching database - " + DatabaseName);
            DatabaseStep.ExecuteSql(sql);
        }

        public override void Validate()
        {
            base.Validate();
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\SqlRunner\CLRFuncStep.cs ===
using System;
using System.Xml;
using System.Data.SqlClient;

using Leet.Tools.Setup.XmlSequencer;

namespace Leet.Tools.Setup.SqlRunner
{
	/// <summary>
	/// Summary description for CLRFuncStep.
	/// </summary>
    [StepElement("clrFunction")]
    public class CLRFuncStep : CLRBaseStep
	{
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
		public CLRFuncStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
		{
		}

        /// <summary>
        /// 
        /// </summary>
        public string FunctionDefinition
        {
            get
            {
                string function = BaseXmlElement.GetAttribute("function").Trim();

                if (function.Length == 0)
                {
                    return "";
                }

                return function;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public string FunctionName
        {
            get
            {
                string function = FunctionDefinition;
                int parenIndex = function.IndexOf('(');

                if(parenIndex > 0)
                {
                    function = function.Substring(0, parenIndex);
                }

                return function;
            }
        }
        
        /// <summary>
        /// 
        /// </summary>
        protected override void OnExecute()
        {
            base.OnExecute ();
        
            //
            // Create the function from the assembly
            //
            string sql = String.Format(@"
                DECLARE @vc_sql AS NVARCHAR(MAX)
                IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[{0}]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
                BEGIN
                    SET @vc_sql = 'CREATE FUNCTION {1} AS EXTERNAL NAME {2}.{3}'
                    EXEC SP_EXECUTESQL @vc_sql
                END
                ELSE
                BEGIN
                    SET @vc_sql = 'ALTER FUNCTION {1} AS EXTERNAL NAME {2}.{3}'
                    EXEC SP_EXECUTESQL @vc_sql
                END",
                FunctionName, FunctionDefinition, AssemblyName, MethodName);
        
            Root.LogMessage("\nCreating function - " + FunctionName);
            DatabaseStep.ExecuteSql(sql);
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\SqlRunner\CreateAssemblyStep.cs ===
using System;
using System.Xml;
using System.Text;
using System.Data.SqlClient;

using xonline.common.config;
using Leet.Tools.Setup.XmlSequencer;

namespace Leet.Tools.Setup.SqlRunner
{

    /// <summary>
    /// Summary description for AttachDatabaseStep.
    /// </summary>
    [StepElement("createAssembly")]
    public class CreateAssemblyStep : Step
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
        public CreateAssemblyStep(XmlElement stepElement, StepContainer parent)
            : base(stepElement, parent)
        {
        }

        /// <summary>
        /// 
        /// </summary>
        public DatabaseStep DatabaseStep
        {
            get {return DatabaseStep.GetDatabaseAncestorOfStep(this);}
        }

        public string AssemblyName
        {
            get
            {
                string assembly = BaseXmlElement.GetAttribute("name").Trim();

                if (assembly.Length == 0)
                {
                    throw new ArgumentException("Required attribute 'assemblyname' not specified for element <" + BaseXmlElement.LocalName + "> in the following line.\r\n" + BaseXmlElement.OuterXml);
                }

                return assembly;
            }
        }

        public string DataFileName
        {
            get
            {
                string attribValue = BaseXmlElement.GetAttribute("fileName").Trim();

                if (attribValue.Length == 0)
                {
                    throw new ArgumentException("Required attribute 'fileName' not specified for element <" + BaseXmlElement.LocalName + "> in the following line.\r\n" + BaseXmlElement.OuterXml);
                }

                return attribValue;
            }
        }

        /// <summary>
        /// Specifies the path to where the data file will be saved. 
        /// </summary>
        /// <remarks>
        /// Maps to the attribute &quot;dataPath&quot; in the source XML.
        /// Defaults to the value of the config setting setup_sqldbroot.
        /// </remarks>
        public string DataPath
        {
            get
            {
                string attribValue = BaseXmlElement.GetAttribute("dataPath").Trim();

                if (attribValue.Length == 0)
                {
                    return Config.GetSetting(Setting.setup_sqldbroot);
                }

                return attribValue;
            }
        }


        /// <summary>
        /// 
        /// </summary>
        protected override void OnExecute()
        {
            base.OnExecute ();

            String sql = String.Format(@"
            IF NOT EXISTS(SELECT * FROM sys.assemblies WHERE NAME = N'{0}')
	        CREATE ASSEMBLY {0} FROM N'{1}\{2}'",
                AssemblyName,
                DataPath,
                DataFileName);

            Root.LogMessage("\nCreating Assembly - " + AssemblyName);
            DatabaseStep.ExecuteSql(sql);
        }

        public override void Validate()
        {
            base.Validate();
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\SqlRunner\BulkInsertStep.cs ===
using System;
using System.IO;
using System.Xml;
using System.Text;
using System.Text.RegularExpressions;
using System.Data.SqlClient;

using Leet.Tools.Setup.XmlSequencer;

namespace Leet.Tools.Setup.SqlRunner
{
	/// <summary>
	/// Summary description for DatabaseStep.
	/// </summary>
    [StepElement("bulkInsert")]
    public class BulkInsertStep : Step
	{
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
		public BulkInsertStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
		{
		}

        private bool hasWithParameters = false;

        /// <summary>
        /// 
        /// </summary>
		public SqlRunnerStep SqlRunnerStep
		{
            get 
            {
                if (!(Root is SqlRunnerStep))
                {
                    throw new InvalidOperationException("The root step must be SqlRunnerStep for SqlScriptSetup to function correctly."); 
                }
                return (SqlRunnerStep) Root;
            }
		}

        /// <summary>
        /// 
        /// </summary>
		public DatabaseStep DatabaseStep
		{
			get {return DatabaseStep.GetDatabaseAncestorOfStep(this);}
		}

        /// <summary>
        /// 
        /// </summary>
        public string DataFileName
        {
            get
            {
                string src = BaseXmlElement.GetAttribute("src").Trim();

                if (src.Length == 0)
                {
                    return "";
                }

                return Path.Combine(SqlRunnerStep.WorkingPath, src);
            }
        }

        public string TableName
        {
            get
            {
                string table = BaseXmlElement.GetAttribute("table").Trim();

                if (table.Length == 0)
                {
                    throw new ArgumentException("Required attribute 'table' not specified for element <" + BaseXmlElement.LocalName + "> in the following line.\r\n" + BaseXmlElement.OuterXml);
                }

                return table;
            }
        }

        /// <summary>
        /// 
        /// </summary>
		protected override void OnExecute()
		{
			base.OnExecute ();

			string src = DataFileName;
            ThrowExceptionIfFileMissing(src);
            ExecuteBulkInsert();
		}

        private void ThrowExceptionIfFileMissing(string src)
        {
            if (!File.Exists(src))
            {
                Root.LogMessage("Specified bulkInsert data file \"" + src + "\" could not be found.");
                throw new FileNotFoundException("Specified bulkInsert data file could not be found.", src);
            }
        }

        private void ExecuteBulkInsert()
        {
            Root.LogMessage("\nBulk inserting file " + DataFileName + " into table " + TableName + ".");

            StringBuilder cmd = new StringBuilder();
            hasWithParameters = false;

            cmd.Append("BULK INSERT [");
            cmd.Append(TableName);
            cmd.Append("] FROM '");
            cmd.Append(DataFileName);
            cmd.Append("'\r\n");

            if (BaseXmlElement.GetAttribute("batchsize").Length > 0)
            {
                cmd.Append(WithAttributePrefix);
                cmd.Append("BATCHSIZE=");
                cmd.Append(BaseXmlElement.GetAttribute("batchsize"));
            }

            if (BaseXmlElement.GetAttribute("checkConstraints").Length > 0)
            {
                cmd.Append(WithAttributePrefix);
                cmd.Append("CHECK_CONSTRAINTS");
            }

            if (BaseXmlElement.GetAttribute("codepage").Length > 0)
            {
                cmd.Append(WithAttributePrefix);
                cmd.Append("CODEPAGE='");
                cmd.Append(BaseXmlElement.GetAttribute("codepage"));
                cmd.Append("'");
            }

            if (BaseXmlElement.GetAttribute("dataFileType").Length > 0)
            {
                cmd.Append(WithAttributePrefix);
                cmd.Append("DATAFILETYPE='");
                cmd.Append(BaseXmlElement.GetAttribute("dataFileType"));
                cmd.Append("'");
            }

            if (BaseXmlElement.GetAttribute("fieldTerminator").Length > 0)
            {
                cmd.Append(WithAttributePrefix);
                cmd.Append("FIELDTERMINATOR='");
                cmd.Append(BaseXmlElement.GetAttribute("fieldTerminator"));
                cmd.Append("'");
            }

            if (BaseXmlElement.GetAttribute("firstRow").Length > 0)
            {
                cmd.Append(WithAttributePrefix);
                cmd.Append("FIRSTROW=");
                cmd.Append(BaseXmlElement.GetAttribute("firstRow"));
            }

            if (BaseXmlElement.GetAttribute("fireTriggers").Length > 0)
            {
                cmd.Append(WithAttributePrefix);
                cmd.Append("FIRE_TRIGGERS");
            }

            if (BaseXmlElement.GetAttribute("formatFile").Length > 0)
            {
                cmd.Append(WithAttributePrefix);
                cmd.Append("FORMATFILE='");
                cmd.Append(BaseXmlElement.GetAttribute("formatFile"));
                cmd.Append("'");
            }

            if (BaseXmlElement.GetAttribute("keepIdentity").Length > 0)
            {
                cmd.Append(WithAttributePrefix);
                cmd.Append("KEEPIDENTITY");
            }

            if (BaseXmlElement.GetAttribute("keepNulls").Length > 0)
            {
                cmd.Append(WithAttributePrefix);
                cmd.Append("KEEPNULLS");
            }

            if (BaseXmlElement.GetAttribute("kilobytesPerBatch").Length > 0)
            {
                cmd.Append(WithAttributePrefix);
                cmd.Append("KILOBYTES_PER_BATCH=");
                cmd.Append(BaseXmlElement.GetAttribute("kilobytesPerBatch"));
            }

            if (BaseXmlElement.GetAttribute("lastRow").Length > 0)
            {
                cmd.Append(WithAttributePrefix);
                cmd.Append("LASTROW=");
                cmd.Append(BaseXmlElement.GetAttribute("lastRow"));
            }


            if (BaseXmlElement.GetAttribute("maxErrors").Length > 0)
            {
                cmd.Append(WithAttributePrefix);
                cmd.Append("MAXERRORS=");
                cmd.Append(BaseXmlElement.GetAttribute("maxErrors"));
            }
            else
            {
                cmd.Append(WithAttributePrefix);
                cmd.Append("MAXERRORS=0");
            }

            if (BaseXmlElement.GetAttribute("order").Length > 0)
            {
                cmd.Append(WithAttributePrefix);
                cmd.Append("ORDER=");
                cmd.Append(BaseXmlElement.GetAttribute("order"));
            }

            if (BaseXmlElement.GetAttribute("rowsPerBatch").Length > 0)
            {
                cmd.Append(WithAttributePrefix);
                cmd.Append("ROWS_PER_BATCH=");
                cmd.Append(BaseXmlElement.GetAttribute("rowsPerBatch"));
            }

            if (BaseXmlElement.GetAttribute("rowTerminator").Length > 0)
            {
                cmd.Append(WithAttributePrefix);
                cmd.Append("ROWTERMINATOR='");
                cmd.Append(BaseXmlElement.GetAttribute("rowTerminator"));
                cmd.Append("'");
            }

            if (BaseXmlElement.GetAttribute("tabLock").Length > 0)
            {
                cmd.Append(WithAttributePrefix);
                cmd.Append("TABLOCK");
            }


            if (hasWithParameters)
            {
                // close the with section
                cmd.Append("\r\n)");
            }

            DatabaseStep.ExecuteSql(cmd.ToString());
        }

        private string WithAttributePrefix
        {
            get
            {
                if (!hasWithParameters)
                {
                    hasWithParameters = true;
                    return "WITH (\r\n\t";
                }

                return ",\r\n\t";
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public override void Validate()
        {
            base.Validate();

            string src = DataFileName;
            ThrowExceptionIfFileMissing(src);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\SqlRunner\CLRStep.cs ===
using System;
using System.IO;
using System.Xml;
using System.Data.SqlClient;

using Leet.Tools.Setup.XmlSequencer;

namespace Leet.Tools.Setup.SqlRunner
{
	/// <summary>
	/// Summary description for CLRStep.
	/// </summary>
    [StepElement("clr")]
    public class CLRStep : StepContainer
	{
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
		public CLRStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
		{
		}

        /// <summary>
        /// 
        /// </summary>
        /// <param name="startStep"></param>
        /// <returns></returns>
        static public CLRStep GetCLRAncestorOfStep(Step startStep)
        {
            Step currentStep = startStep;

            while (currentStep != null)
            {
                if (currentStep is CLRStep)
                {
                    return (CLRStep) currentStep;
                }

                currentStep = currentStep.Parent;
            }

            throw new InvalidOperationException("No CLRStep present in the hierarchy above the current step.");
        }

        /// <summary>
        /// 
        /// </summary>
		public DatabaseStep DatabaseStep
		{
			get {return DatabaseStep.GetDatabaseAncestorOfStep(this);}
		}

        /// <summary>
        /// 
        /// </summary>
        public SqlRunnerStep SqlRunnerStep
        {
            get 
            {
                if (!(Root is SqlRunnerStep))
                {
                    throw new InvalidOperationException("The root step must be SqlRunnerStep for SqlScriptSetup to function correctly."); 
                }
                return (SqlRunnerStep) Root;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public string AssemblyFileName
        {
            get
            {
                string src = BaseXmlElement.GetAttribute("file").Trim();

                if (src.Length == 0)
                {
                    return "";
                }

                return Path.Combine(SqlRunnerStep.WorkingPath, src);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public string AssemblyName
        {
            get
            {
                string assembly = BaseXmlElement.GetAttribute("assembly").Trim();

                if (assembly.Length == 0)
                {
                    return "";
                }

                return assembly;
            }
        }

        /// <summary>
        /// 
        /// </summary>
		protected override void OnExecute()
		{
            string assembly = AssemblyFileName;
            ThrowExceptionIfFileMissing(assembly);

            //
            // Create the function from the assembly
            //
            string sql = String.Format(@"
                IF EXISTS (SELECT * FROM sys.assemblies WHERE [name] = N'{0}')
                BEGIN
                    DECLARE @vc_object AS NVARCHAR(255)
                    DECLARE @vc_type AS NVARCHAR(20)
                    DECLARE @vc_sql AS NVARCHAR(MAX)

                    DECLARE CLR_OBJ CURSOR FAST_FORWARD FOR
                        SELECT o.name, o.type FROM sys.objects o INNER JOIN sys.assembly_modules am 
                        ON o.object_id = am.object_id INNER JOIN sys.assemblies a ON a.assembly_id = am.assembly_id
                        WHERE a.[name] = N'{0}'
                    OPEN CLR_OBJ
                    FETCH NEXT FROM CLR_OBJ INTO @vc_object, @vc_type

                    WHILE(@@FETCH_STATUS = 0)
                    BEGIN
                        IF(@vc_type = N'P' OR @vc_type = N'PC')
                        BEGIN
                            SET @vc_sql = 'DROP PROCEDURE ' + @vc_object
                            EXEC SP_EXECUTESQL @vc_sql
                        END
                        ELSE IF(@vc_type = N'FN' OR @vc_type = N'IF' OR @vc_type = N'TF' OR @vc_type = N'FS' OR @vc_type = N'FT')
                        BEGIN
                            SET @vc_sql = 'DROP FUNCTION ' + @vc_object
                            EXEC SP_EXECUTESQL @vc_sql
                        END
                        FETCH NEXT FROM CLR_OBJ INTO @vc_object, @vc_type
                    END

                    DROP ASSEMBLY {0}
                END

                CREATE ASSEMBLY {0} FROM '{1}' WITH PERMISSION_SET = SAFE
                ",
                AssemblyName, AssemblyFileName);
        
            Root.LogMessage("\nCreating assembly - " + AssemblyName);
            DatabaseStep.ExecuteSql(sql);

            base.OnExecute ();
		}

        private void ThrowExceptionIfFileMissing(string assembly)
        {
            if (!File.Exists(assembly))
            {
                Root.LogMessage("Specified assembly \"" + assembly + "\" could not be found.");
                throw new FileNotFoundException("Specified assembly could not be found.", assembly);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public override void Validate()
        {
            base.Validate();

            string assembly = AssemblyFileName;
            ThrowExceptionIfFileMissing(assembly);
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\SqlRunner\CreateFTCatalog.cs ===
using System;
using System.IO;
using System.Xml;
using System.Text;
using System.Collections;
using System.Text.RegularExpressions;
using System.Data.SqlClient;

using xonline.common.config;
using Leet.Tools.Setup.XmlSequencer;

namespace Leet.Tools.Setup.SqlRunner
{
    /// <summary>
    /// Summary description for createFtcatalog.
    /// </summary>
    [StepElement("createFtcatalog")]
    public class CreateFTCatalog : Step
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>       
        public CreateFTCatalog(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
        }

        /// <summary>
        /// 
        /// </summary>
        public SqlRunnerStep SqlRunnerStep
        {
            get 
            {
                if (!(Root is SqlRunnerStep))
                {
                    throw new InvalidOperationException("The root step must be SqlRunnerStep for SqlScriptSetup to function correctly."); 
                }
                return (SqlRunnerStep) Root;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public DatabaseStep DatabaseStep
        {
            get {return DatabaseStep.GetDatabaseAncestorOfStep(this);}
        }

        /// <summary>
        /// 
        /// </summary>
        public string CatalogName
        {
            get
            {
                string name = BaseXmlElement.GetAttribute("name").Trim();

                if (name.Length == 0)
                {
                    return "";
                }

                return name;
            }
        }
        
        // The current thinking is that 1 single path for all free text catalogs is enough
        public string FTPath
        {
            get
            {
                string attribValue = BaseXmlElement.GetAttribute("ftPath").Trim();

                if (attribValue.Length == 0)
                {
                    return Config.GetSetting(Setting.setup_sqlftroot);
                }

                return attribValue;
            }
        }
        
        /// <summary>
        /// 
        /// </summary>
        protected override void OnExecute()
        {
            base.OnExecute ();

            // Make sure the FTDirectory directories have been created.
            System.IO.Directory.CreateDirectory(FTPath);

            String sql = String.Format(@"
            IF NOT EXISTS (SELECT null FROM sys.fulltext_catalogs WHERE NAME = N'{0}')
	            CREATE FULLTEXT CATALOG {0} IN PATH N'{1}' WITH ACCENT_SENSITIVITY = OFF", CatalogName, FTPath);

            Root.LogMessage("\nCreating Free Text Catalog - " + CatalogName);
            DatabaseStep.ExecuteSql(sql);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\SqlRunner\CreateDatabaseStep.cs ===
using System;
using System.Xml;
using System.Text;
using System.Data.SqlClient;

using xonline.common.config;
using Leet.Tools.Setup.XmlSequencer;

namespace Leet.Tools.Setup.SqlRunner
{
    /// <summary>
    /// Summary description for CreateDatabaseStep.
    /// </summary>
    [StepElement("createDatabase")]
    public class CreateDatabaseStep : Step
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
        public CreateDatabaseStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
        }

        /// <summary>
        /// 
        /// </summary>
        public DatabaseStep DatabaseStep
        {
            get {return DatabaseStep.GetDatabaseAncestorOfStep(this);}
        }

        public string DatabaseName
        {
            get
            {
                string database = BaseXmlElement.GetAttribute("database").Trim();

                if (database.Length == 0)
                {
                    throw new ArgumentException("Required attribute 'database' not specified for element <" + BaseXmlElement.LocalName + "> in the following line.\r\n" + BaseXmlElement.OuterXml);
                }

                return database;
            }
        }

        public string DataSize
        {
            get
            {
                string attribValue = BaseXmlElement.GetAttribute("dataSize").Trim();

                if (attribValue.Length == 0)
                {
                    throw new ArgumentException("Required attribute 'dataSize' not specified for element <" + BaseXmlElement.LocalName + "> in the following line.\r\n" + BaseXmlElement.OuterXml);
                }

                return attribValue;
            }
        }

        public string DataGrowth
        {
            get
            {
                string attribValue = BaseXmlElement.GetAttribute("dataGrowth").Trim();

                if (attribValue.Length == 0)
                {
                    throw new ArgumentException("Required attribute 'dataGrowth' not specified for element <" + BaseXmlElement.LocalName + "> in the following line.\r\n" + BaseXmlElement.OuterXml);
                }

                return attribValue;
            }
        }

        public string LogSize
        {
            get
            {
                string attribValue = BaseXmlElement.GetAttribute("logSize").Trim();

                if (attribValue.Length == 0)
                {
                    throw new ArgumentException("Required attribute 'logSize' not specified for element <" + BaseXmlElement.LocalName + "> in the following line.\r\n" + BaseXmlElement.OuterXml);
                }

                return attribValue;
            }
        }

        public string LogGrowth
        {
            get
            {
                string attribValue = BaseXmlElement.GetAttribute("logGrowth").Trim();

                if (attribValue.Length == 0)
                {
                    throw new ArgumentException("Required attribute 'logGrowth' not specified for element <" + BaseXmlElement.LocalName + "> in the following line.\r\n" + BaseXmlElement.OuterXml);
                }

                return attribValue;
            }
        }

        /// <summary>
        /// Specifies the collation for the created database. 
        /// </summary>
        /// <remarks>
        /// Maps to the attribute &quot;collate&quot; in the source XML.
        /// Defaults to SQL_Latin1_General_CP1_CI_AS.
        /// </remarks>
        public string Collation
        {
            get
            {
                string attribValue = BaseXmlElement.GetAttribute("collate").Trim();

                if (attribValue.Length == 0)
                {
                    return "SQL_Latin1_General_CP1_CI_AS";
                }

                return attribValue;
            }
        }

        /// <summary>
        /// Specifies the path to where the data file will be saved. 
        /// </summary>
        /// <remarks>
        /// Maps to the attribute &quot;dataPath&quot; in the source XML.
        /// Defaults to the value of the config setting setup_sqldbroot.
        /// </remarks>
        public string DataPath
        {
            get
            {
                string attribValue = BaseXmlElement.GetAttribute("dataPath").Trim();

                if (attribValue.Length == 0)
                {
                    return Config.GetSetting(Setting.setup_sqldbroot);
                }

                return attribValue;
            }
        }

        /// <summary>
        /// Specifies the path to where the transaction log file will be saved. 
        /// </summary>
        /// <remarks>
        /// Maps to the attribute &quot;logPath&quot; in the source XML.
        /// Defaults to the value of the config setting setup_sqllogroot.
        /// </remarks>
        public string LogPath
        {
            get
            {
                string attribValue = BaseXmlElement.GetAttribute("logPath").Trim();

                if (attribValue.Length == 0)
                {
                    return Config.GetSetting(Setting.setup_sqllogroot);
                }

                return attribValue;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        protected override void OnExecute()
        {
            base.OnExecute ();

            // Make sure the data and log directories have been created.
            System.IO.Directory.CreateDirectory(DataPath);
            System.IO.Directory.CreateDirectory(LogPath);

            String sql = String.Format(@"
            IF NOT EXISTS (SELECT name FROM master.dbo.sysdatabases WHERE name = N'{0}')
	        CREATE DATABASE {0} ON
	        (
	            NAME = N'{0}_Data',
                FILENAME = N'{1}\{0}_Data.MDF',
                SIZE = {2},
                FILEGROWTH = {3}
            )
            LOG ON
            (
                NAME = N'{0}_Log',
                FILENAME = N'{4}\{0}_Log.LDF',
                SIZE = {5},
                FILEGROWTH = {6}
            )
            COLLATE {7}", 
                DatabaseName,
                DataPath,
                DataSize,
                DataGrowth,
                LogPath,
                LogSize,
                LogGrowth,
                Collation);

            Root.LogMessage("\nCreating database - " + DatabaseName);
            DatabaseStep.ExecuteSql(sql);
        }

        public override void Validate()
        {
            base.Validate();

            // Make sure the database name has been specified
            string databaseCheck = DatabaseName;
            databaseCheck = DataSize;
            databaseCheck = DataGrowth;
            databaseCheck = LogSize;
            databaseCheck = LogGrowth;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\SqlRunner\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Leet.Tools.Setup.IisRunner")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\SqlRunner\DropDatabaseStep.cs ===
using System;
using System.Xml;
using System.Text;
using System.Data.SqlClient;

using Leet.Tools.Setup.XmlSequencer;

namespace Leet.Tools.Setup.SqlRunner
{
    /// <summary>
    /// Summary description for DatabaseStep.
    /// </summary>
    [StepElement("dropDatabase")]
    public class DropDatabaseStep : Step
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
        public DropDatabaseStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
        }

        /// <summary>
        /// 
        /// </summary>
        public DatabaseStep DatabaseStep
        {
            get {return DatabaseStep.GetDatabaseAncestorOfStep(this);}
        }

        public string DatabaseName
        {
            get
            {
                string database = BaseXmlElement.GetAttribute("database").Trim();

                if (database.Length == 0)
                {
                    throw new ArgumentException("Required attribute 'database' not specified for element <" + BaseXmlElement.LocalName + "> in the following line.\r\n" + BaseXmlElement.OuterXml);
                }

                return database;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        protected override void OnExecute()
        {
            base.OnExecute ();

            String sql = String.Format(@"
                IF EXISTS (SELECT name FROM master.dbo.sysdatabases WHERE name = N'{0}')
                BEGIN
                    -- kick anyone currently using the database
                    ALTER DATABASE {0} SET OFFLINE WITH ROLLBACK IMMEDIATE 
                
                    -- bring it back online so that the drop statement also deletes any files it uses
                    ALTER DATABASE {0} SET ONLINE, RESTRICTED_USER
                    DROP DATABASE {0}
                END ",
                DatabaseName);

            Root.LogMessage("\nDropping database - " + DatabaseName);
            DatabaseStep.ExecuteSql(sql);
        }

        public override void Validate()
        {
            base.Validate();

            // Make sure the database name has been specified
            string databaseCheck = DatabaseName;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\SqlRunner\DatabaseStep.cs ===
using System;
using System.Xml;
using System.Collections;
using System.Data.SqlClient;

using Leet.Tools.Setup.XmlSequencer;

namespace Leet.Tools.Setup.SqlRunner
{
    /// <summary>
    /// Summary description for DatabaseStep.
    /// </summary>
    [StepElement("database")]
    public class DatabaseStep : StepContainer
    {
        public delegate string StringFilter(string original);
        public static StringFilter SqlStatementFilter;

        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
        public DatabaseStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
        }

        /// <summary>
        /// 
        /// </summary>
        public string DatabaseName
        {
            get 
            {
                return BaseXmlElement.GetAttribute("name");
            }
        }

        public string ServerName
        {
            get
            {
                string serverName = BaseXmlElement.GetAttribute("server").Trim();

                if (serverName.Length == 0)
                {
                    serverName = ((SqlRunnerStep) Root).SqlServerName;
                }

                return serverName;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public string ConnectionString
        {
            get
            {
                return string.Format("Data Source={0};Initial Catalog={1};Integrated Security=SSPI;Application Name=SqlRunner;Persist Security Info=false;", ServerName, DatabaseName);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="sqlCommand"></param>
        public virtual void ExecuteSql(string sqlCommand)
        {
            ArrayList sqlArray = new ArrayList();
            sqlArray.Add(sqlCommand);
            BatchExecute(sqlArray);
        }

        public void BatchExecute(ArrayList sqlArray, int timeoout)
        {
            SqlConnection myConnection = new SqlConnection(ConnectionString);
            myConnection.InfoMessage +=new SqlInfoMessageEventHandler(myConnection_InfoMessage);
            string currentSql="";

            try
            {
                myConnection.Open();
                
                foreach (string sql in sqlArray)
                {         
                    currentSql = sql;

                    if (SqlStatementFilter!=null)
                    {
                        currentSql = SqlStatementFilter(currentSql);
                    }

                    SqlCommand myCommand = new SqlCommand(currentSql);
                    myCommand.Connection = myConnection;
                    myCommand.CommandTimeout = timeoout;

                    myCommand.ExecuteNonQuery();
                }
            }
            catch (SqlException ex)
            {
                Root.LogMessage("Encountered SQL exception: " + ex.Message);
                Root.LogMessage("Connection string: " + ConnectionString);
                Root.LogMessage("SQL command: " + currentSql);
                throw;
            }
            finally
            {
                if (myConnection != null)
                {
                    myConnection.InfoMessage -= new SqlInfoMessageEventHandler(myConnection_InfoMessage);
                    myConnection.Close();
                }
            }
        }

        public void BatchExecute(ArrayList sqlArray)
        {
            BatchExecute(sqlArray, 300); // 5 minutes
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="startStep"></param>
        /// <returns></returns>
        static public DatabaseStep GetDatabaseAncestorOfStep(Step startStep)
        {
            Step currentStep = startStep;

            while (currentStep != null)
            {
                if (currentStep is DatabaseStep)
                {
                    return (DatabaseStep) currentStep;
                }

                currentStep = currentStep.Parent;
            }

            throw new InvalidOperationException("No DatabaseStep present in the hierarchy above the current step.");
        }

        private void myConnection_InfoMessage(object sender, SqlInfoMessageEventArgs e)
        {
            Root.LogMessage(">>> " + e.Message);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\SqlRunner\SqlRunnerCmd.cs ===
using System;
using System.IO;
using System.Xml;
using System.Text.RegularExpressions;
using System.Collections.Generic;

using Leet.Tools.Setup.XmlSequencer;
using Leet.Core.IoCCo;
using Leet.Core.Configuration;
using Leet.Core.IO;

namespace Leet.Tools.Setup.SqlRunner
{
    /// <summary>
    /// Provides a command line interface to the core SqlRunner functionality.
    /// </summary>
    class SqlRunnerCmd
    {
        private string sqlServerName = null;
        private string sqlRunnerFilename = null;
        private Dictionary<string, string> overrideVariables = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static int Main(string[] args)
        {
            Container.Instance.AddService<IRegistryProvider, RegistryProvider>();
            Container.Instance.AddService<IFileSystem, FileSystem>();

            ConfigurationSelector.RegisterProvider("sqlrunner", "LEET");
            SqlRunnerCmd theCmd = new SqlRunnerCmd();
            theCmd.ParseCommandLine(args);
            return theCmd.RunIt();
        }

        /// <summary>
        /// Handles parsing of the command line arguments, setting member variables 
        /// based on the options and arguments specified.
        /// </summary>
        /// <param name="args">The arguments to process.</param>
        public void ParseCommandLine(string[] args)
        {
            int numberOfArgs = args.Length;
            Regex variableRegex = new Regex(
                @"^(?<name>[^=]+)=(?<value>.*)",
                RegexOptions.Compiled | RegexOptions.IgnoreCase);

            for (int currentArgIndex = 0; currentArgIndex < numberOfArgs; currentArgIndex++)
            {
                string currentArg = args[currentArgIndex];
                if (String.Compare(currentArg, "/s", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    sqlServerName = args[++currentArgIndex];
                }
                else if (currentArg == "/?")
                {
                    ShowUsageInfo();
                    Environment.Exit(0);
                }
                else if (currentArg.StartsWith("/"))
                {
                    Console.WriteLine("ERROR: Invalid argument or option - '" + currentArg + "'.");
                    Console.WriteLine("Type \"SqlRunner /?\" for usage help.");
                    Environment.Exit(1);
                }
                else if (variableRegex.IsMatch(currentArg))
                {
                    Match myMatch = variableRegex.Match(currentArg);
                    overrideVariables[myMatch.Groups["name"].Value] = myMatch.Groups["value"].Value;
                }
                else
                {
                    if (sqlRunnerFilename == null)
                    {
                        sqlRunnerFilename = currentArg;
                    }
                    else
                    {
                        Console.WriteLine();
                        Console.WriteLine("Only one SqlRunner input file can be specified on the command line. Second filename \"" + currentArg + "\" was encountered.");
                        Console.WriteLine("Type \"SqlRunner /?\" for usage help.");
                        Environment.Exit(1);
                    }
                }
            }

            if (sqlServerName == null)
            {
                sqlServerName = Environment.MachineName;
            }

            if (sqlRunnerFilename == null)
            {
                Console.WriteLine();
                Console.WriteLine("ERROR: Required input file name not specified.");
                Console.WriteLine("Type \"SqlRunner /?\" for usage help.");
                Environment.Exit(1);
            }
        }

        private void VerifyParameter(string currentArg, int currentArgIndex, int numberOfArgs)
        {
            if (currentArgIndex + 1 >= numberOfArgs)
            {
                Console.WriteLine("ERROR: Option " + currentArg + " requires a value to be specified.");
                Console.WriteLine("Type \"SqlRunner /?\" for usage help.");
                Environment.Exit(1);
            }
        }

        /// <summary>
        /// Displays information about this program and its command line agruments. 
        /// </summary>
        public void ShowUsageInfo()
        {
            Console.WriteLine();
            Console.WriteLine("SqlRunner [/S servername] [VARNAME=VALUE ...] inputfile");
            Console.WriteLine();
            Console.WriteLine("Description:");
            Console.WriteLine("    Executes SQL commands as specified by the SqlRunner XML input file.");
            Console.WriteLine();
            Console.WriteLine("Parameter List:");
            Console.WriteLine("    /S              Connect to the specified SQL Server name to execute");
            Console.WriteLine("                    SQL. If this parameter is not specified, the local");
            Console.WriteLine("                    server's name will be used.");
            Console.WriteLine();
            Console.WriteLine("    VARNAME=VALUE   Specifies a variable name and its associated value");
            Console.WriteLine("                    to use when applying the configuration transform to");
            Console.WriteLine("                    the SqlRunner XML input file. Any number of name/value");
            Console.WriteLine("                    definitions can be specified.");
            Console.WriteLine();
            Console.WriteLine("    inputfile       The filename of the XML input file to use.");
            Console.WriteLine();
            Console.WriteLine("  NOTE:  This tool returns an error level of 0 if all SQL is successfully");
            Console.WriteLine("         executed, or 1 if there are errors in the command line, or 2 if");
            Console.WriteLine("         there were problems processing the input XML or running the SQL it");
            Console.WriteLine("         defines.");
            Console.WriteLine();
            Console.WriteLine("Examples:");
            Console.WriteLine("    SqlRunner npdb_setup.xml");
            Console.WriteLine(@"    SqlRunner SQLDATAPATH=h:\mssql\data");
            Console.WriteLine(@"              ""SQLLOGPATH=o:\mssql\log files\"" npdb_setup.xml");
            Console.WriteLine();

        }

        /// <summary>
        /// Creates a SqlRunnerStep object, configuring it based on the command line arguments,
        /// and executes it. 
        /// </summary>
        /// <returns>
        /// The errorlevel value that should be returned to the cmd environment.
        /// Returns 0 on success, 2 on failure. 
        ///</returns>
        public int RunIt()
        {
            Console.WriteLine();
            Console.WriteLine("SqlRunner started processing '" + sqlRunnerFilename + "' at " + DateTime.Now.ToString());
            Console.WriteLine();

            try
            {
                XmlDocument xmlDoc = new XmlDocument();
                xmlDoc.Load(sqlRunnerFilename);

                ConfigurationTransform transform = new ConfigurationTransform();
                foreach (KeyValuePair<string, string> kvp in overrideVariables)
                {
                    transform.OverrideVariableCollection[kvp.Key] = kvp.Value;
                }
                transform.TransformDocument(xmlDoc);

                SqlRunnerStep runner = new SqlRunnerStep(xmlDoc.DocumentElement, sqlServerName, Path.GetFullPath(sqlRunnerFilename));
                runner.OnMessage += new MessageEventHandler(myRoot_OnMessage);

                runner.Validate();
                runner.Execute();
            }
            catch (Exception ex)
            {
                Console.WriteLine();
                Console.WriteLine();
                Console.WriteLine("ERROR: Exception encountered executing SQLRunner. - " + ex.Message);
                Console.WriteLine();
                Console.WriteLine();
                Console.WriteLine(ex.ToString());
                return 2;
            }

            Console.WriteLine();
            Console.WriteLine("SqlRunner processing of '" + sqlRunnerFilename + "' completed at " + DateTime.Now.ToString());
            Console.WriteLine();
            return 0;
        }

        /// <summary>
        /// Event handler for SqlRunnerStep's Message event which writes the message to the console.
        /// </summary>
        /// <param name="sender">The SqlRunnerStep generating the event.</param>
        /// <param name="e">The MessageEventArgs sent by the event.</param>
        private void myRoot_OnMessage(object sender, MessageEventArgs e)
        {
            Console.WriteLine(e.Message);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\SqlRunner\SqlCommandStep.cs ===
using System;
using System.Xml;
using System.Data.SqlClient;

using Leet.Tools.Setup.XmlSequencer;

namespace Leet.Tools.Setup.SqlRunner
{
	/// <summary>
	/// Summary description for DatabaseStep.
	/// </summary>
    [StepElement("sqlCommand")]
    public class SqlCommandStep : Step
	{
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
		public SqlCommandStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
		{
		}

        /// <summary>
        /// 
        /// </summary>
		public DatabaseStep DatabaseStep
		{
			get {return DatabaseStep.GetDatabaseAncestorOfStep(this);}
		}

        /// <summary>
        /// 
        /// </summary>
		protected override void OnExecute()
		{
			base.OnExecute ();

			string sql = BaseXmlElement.InnerText;

			if (sql.Length == 0)
			{
				Root.LogMessage("\n\nSkipping current SqlCommandStep. No command is specified.");
				Root.LogMessage(BaseXmlElement.OuterXml);
			}
			else
			{
				Root.LogMessage("\nExecuting SQL command - " + sql);
				DatabaseStep.ExecuteSql(sql);
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\SqlRunner\SqlRunnerInstaller.cs ===
using System;
using System.IO;
using System.Xml;
using System.Collections;
using System.Diagnostics;
using System.ComponentModel;
using System.Configuration.Install;

using Leet.Tools.Setup.XmlSequencer;
using Leet.Core.Configuration;
using Leet.Core.IO;


namespace Leet.Tools.Setup.SqlRunner
{
    /// <summary>
    /// Summary description for SqlRunnerInstaller.
    /// </summary>
    [RunInstaller(true)]
    public class SqlRunnerInstaller : System.Configuration.Install.Installer
    {
        private System.Diagnostics.EventLog eventLog;
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.Container components = null;

        public SqlRunnerInstaller()
        {
            // This call is required by the Designer.
            InitializeComponent();
        }

        /// <summary> 
        /// Clean up any resources being used.
        /// </summary>
        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                if (components != null)
                {
                    components.Dispose();
                }
            }
            base.Dispose(disposing);
        }

        public override void Install(IDictionary stateSaver)
        {
            base.Install(stateSaver);

            string message = null;
            string sqlRunnerFilename = Context.Parameters["runnerFile"];
            string sqlServerName = Context.Parameters["sqlServer"];

            if ((sqlServerName == null) || (sqlServerName.Length == 0))
            {
                sqlServerName = Environment.MachineName;
            }

            try
            {
                if ((sqlRunnerFilename == null) || (sqlRunnerFilename.Length == 0))
                {
                    throw new ArgumentException("The runnerFile parameter must be specified. It should contain the path to the SqlRunner defeinition file.", "runnerFile");
                }

                message = String.Format("SqlRunner started processing '{0}' against SQL Server {1} at {2}", sqlRunnerFilename, sqlServerName, DateTime.Now.ToString());
                eventLog.WriteEntry(message, EventLogEntryType.Information);
                Context.LogMessage(message);

                Leet.Core.IoCCo.Container.Instance.AddService<IRegistryProvider, RegistryProvider>();
                Leet.Core.IoCCo.Container.Instance.AddService<IFileSystem, FileSystem>();

                ConfigurationSelector.RegisterProvider("sqlrunner", "LEET");
                ConfigurationStore store = new ConfigurationStore("SqlRunner", Path.GetFileNameWithoutExtension(sqlRunnerFilename));

                XmlDocument xmlDoc = new XmlDocument();
                xmlDoc.Load(sqlRunnerFilename);

                ConfigurationTransform transform = new ConfigurationTransform();

                foreach (DictionaryEntry de in Context.Parameters)
                {
                    transform.OverrideVariableCollection[de.Key.ToString()] = de.Value.ToString();
                }
                transform.TransformDocument(xmlDoc);

                SqlRunnerStep runner = new SqlRunnerStep(xmlDoc.DocumentElement, sqlServerName, Path.GetFullPath(sqlRunnerFilename));
                runner.OnMessage += new MessageEventHandler(myRoot_OnMessage);

                runner.Validate();
                runner.Execute();
            }
            catch (Exception ex)
            {
                Context.LogMessage("ERROR: Exception encountered executing SQLRunner. - " + ex.Message);
                Context.LogMessage(ex.ToString());

                message = string.Format("Exception encountered executing SqlRunner: \r\n{0}", ex.ToString());
                eventLog.WriteEntry(message, EventLogEntryType.Error, 65000);
                throw;
            }

            message = String.Format("SqlRunner processing of '{0}' completed at {1}", sqlRunnerFilename, DateTime.Now.ToString());
            eventLog.WriteEntry(message, EventLogEntryType.Information);
            Context.LogMessage(message);
        }

        // even though these overriddent methods appear to do nothing,
        // omiting them will leave temp files behind after the install.
        public override void Commit(IDictionary savedState)
        {
            base.Commit(savedState);
        }

        public override void Rollback(IDictionary savedState)
        {
            base.Rollback(savedState);
        }

        public override void Uninstall(IDictionary savedState)
        {
            base.Uninstall(savedState);
        }

        /// <summary>
        /// Event handler for SqlRunnerStep's Message event which writes the message to the install context's log.
        /// </summary>
        /// <param name="sender">The SqlRunnerStep generating the event.</param>
        /// <param name="e">The MessageEventArgs sent by the event.</param>
        private void myRoot_OnMessage(object sender, MessageEventArgs e)
        {
            Context.LogMessage(e.Message);
        }


        #region Component Designer generated code
        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.eventLog = new System.Diagnostics.EventLog();
            ((System.ComponentModel.ISupportInitialize)(this.eventLog)).BeginInit();
            // 
            // eventLog
            // 
            this.eventLog.Log = "Application";
            this.eventLog.Source = "SqlRunner";
            ((System.ComponentModel.ISupportInitialize)(this.eventLog)).EndInit();

        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\SqlRunner\SqlScriptStep.cs ===
using System;
using System.IO;
using System.Xml;
using System.Text;
using System.Collections;
using System.Text.RegularExpressions;
using System.Data.SqlClient;

using Leet.Tools.Setup.XmlSequencer;

namespace Leet.Tools.Setup.SqlRunner
{
    /// <summary>
    /// Summary description for DatabaseStep.
    /// </summary>
    [StepElement("sqlScript")]
    public class SqlScriptStep : Step
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
        public SqlScriptStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
        }

        /// <summary>
        /// 
        /// </summary>
        public SqlRunnerStep SqlRunnerStep
        {
            get 
            {
                if (!(Root is SqlRunnerStep))
                {
                    throw new InvalidOperationException("The root step must be SqlRunnerStep for SqlScriptSetup to function correctly."); 
                }
                return (SqlRunnerStep) Root;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public DatabaseStep DatabaseStep
        {
            get {return DatabaseStep.GetDatabaseAncestorOfStep(this);}
        }

        /// <summary>
        /// 
        /// </summary>
        public string ScriptFileName
        {
            get
            {
                string src = BaseXmlElement.GetAttribute("src").Trim();

                if (src.Length == 0)
                {
                    return "";
                }

                return Path.Combine(SqlRunnerStep.WorkingPath, src);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public int Timeout
        {
            get
            {
                int iTimeout;
                string attribValue = BaseXmlElement.GetAttribute("timeout").Trim();

                if (!int.TryParse(attribValue, out iTimeout))
                {
                    iTimeout = 300;
                }
                return iTimeout;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public System.Text.Encoding Encoding
        {
            get
            {
                string name = BaseXmlElement.GetAttribute("encoding").Trim();

                if (name.Length == 0)
                {
                    return Encoding.UTF8;
                }

                return System.Text.Encoding.GetEncoding(name);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        protected override void OnExecute()
        {
            base.OnExecute ();

            string src = ScriptFileName;
            ThrowExceptionIfFileMissing(src);
            ProcessScript(src);
        }

        private void ThrowExceptionIfFileMissing(string src)
        {
            if (!File.Exists(src))
            {
                string msg;
                if (String.IsNullOrEmpty(src))
                {
                    msg = "Empty src attribute found while processing node: '" + BaseXmlElement.OuterXml + "'";
                }
                else
                {
                    msg = "Specified SQL script \"" + src + "\" could not be found.";
                }
                Root.LogMessage(msg);
                throw new FileNotFoundException(msg, src);
            }
        }

        private void ProcessScript(string filename)
        {
            Root.LogMessage("\nProcessing SQL script at " + filename);

            ArrayList sqlArray = new ArrayList();
            Regex goRegex = new Regex(@"^go($|(\s|--).*)", RegexOptions.Compiled | RegexOptions.IgnoreCase | RegexOptions.Singleline);   
            string currentLine = null;
            StringBuilder currentBatch = new StringBuilder(2048);

            StreamReader reader = new StreamReader(filename, this.Encoding, true);

            currentLine = reader.ReadLine();
            while (currentLine != null)
            {
                if (goRegex.IsMatch(currentLine))
                {
                    string sql = currentBatch.ToString().Trim();
                    if (sql.Length!=0) sqlArray.Add(sql);
                    
                    currentBatch.Length = 0;
                }
                else
                {
                    currentBatch.AppendFormat("{0}\r\n", currentLine);
                }

                currentLine = reader.ReadLine();
            }

            string sql2 = currentBatch.ToString().Trim();
            if (sql2.Length!=0) sqlArray.Add(sql2);

            try
            {
                DatabaseStep.BatchExecute(sqlArray, Timeout);
            }
            catch (SqlException se)
            {
                throw new Exception("Unable to process file "+filename+": " + se.Message, se);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public override void Validate()
        {
            base.Validate();

            string src = ScriptFileName;
            ThrowExceptionIfFileMissing(src);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\SqlRunner\SqlRunnerStep.cs ===
using System;
using System.IO;
using System.Xml;
using Leet.Tools.Setup.XmlSequencer;

namespace Leet.Tools.Setup.SqlRunner
{
	/// <summary>
	/// Provides the entry point for the SqlRunner components.
	/// </summary>
	/// <remarks>
	///  This class provides the primary interface to process a SqlRunner XML document. The SqlRunner XML document defines 
	///  a sequential series of steps to execute on a SQL Server, allowing the sequencing and intent of a set of SQL actions
	///  to be seperated from the code that implements how to perform those actions.
    ///</remarks>
	public class SqlRunnerStep : RootStepContainer
	{
        private string sqlServerName = "";
        private string workingPath = "";

        /// <summary>
        /// Initializes a new instance of the SqlRunnerStep class.
        /// </summary>
        /// <param name="stepElement">
        /// The SqlRunner XmlElement that contains the attributes and steps (children elements) that define the actions to take.
        /// </param>
        /// <param name="sqlServerName">
        /// The name of the SQL Server that the steps should be executed against. 
        /// Passing null or an empty string will default this value to the local machine name.
        /// </param>
        /// <param name="workingPath">
        /// The path to the directory that will be used as the base directory for any relative paths to files defined in children steps.
        /// Passing null or an empty string will default this value to the current working directory.
        /// If the path contains a file, the file name will be removed from the path and the directory containing the passed file will be used as the
        /// working path.
        /// </param>
        /// <exception cref="InvalidOperationException">The passed stepElement does not belong to the SqlRunner namespace.</exception>
        /// <exception cref="ArgumentNullException">The passed stepElement was null.</exception>
		public SqlRunnerStep(
			XmlElement stepElement, 
			string sqlServerName,
			string workingPath) : base(stepElement)
		{
			SqlServerName = sqlServerName;
			WorkingPath = workingPath;
		}

        /// <summary>
        /// Gets the name of the XML namespace that all SqlRunner elements must belong to.  
        /// </summary>
        public override string Namespace
        {
            get {return "http://www.xbox.com/sqlrunner.xsd";}
        }

        /// <summary>
        /// Gets or sets the name of the SQL Server that any SqlRunner steps will be executed against.
        /// </summary>
		public string SqlServerName
		{
			get
			{
				return sqlServerName;
			}

			set
			{
				if ((value == null) || (value.Length == 0))
				{
					sqlServerName = System.Environment.MachineName;
				}
				else
				{
					sqlServerName = value;
				}
			}
		}

        /// <summary>
        /// The path to the directory that will be used as the base directory for any relative paths to files defined in children steps.
        /// </summary>
        /// <remarks>
        /// Setting this property to null or an empty string will default this property to the current working directory.
        /// If the path contains a file, the file name will be removed from the path and the directory containing the passed file will be used as the
        /// working path.       
        /// </remarks>
        /// <exception cref="ArgumentException">The WorkingPath was set to a value containing characters that are not valid in a path specification</exception>
        /// <exception cref="FileNotFoundException">An attempt was made to set the WorkingPath to a non-existant directory.</exception>
		public string WorkingPath
		{
			get
			{
				return workingPath;
			}
			set
			{
				string dirPath = "";

				if ((value == null) || (value.Length == 0))
				{
					dirPath = Environment.CurrentDirectory;
				}
				else
				{
					dirPath = value.Trim();
				}

				if (dirPath.IndexOfAny(System.IO.Path.GetInvalidPathChars()) > -1)
				{
					throw new ArgumentException("Path contains characters that are not valid in a path specification", "WorkingPath");
				}

				if (System.IO.Path.HasExtension(dirPath))
				{
					dirPath = System.IO.Path.GetDirectoryName(dirPath);
				}

                dirPath = Path.GetFullPath(dirPath);

				if (!Directory.Exists(dirPath))
				{
					throw new FileNotFoundException("Specified working path '" + dirPath + "' does not point at a directory.", dirPath);
				}

				workingPath = dirPath;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Vibrio\AddDatabaseUser.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.Text.RegularExpressions;

namespace xonline.tools.Vibrio
{
    public class AddDatabaseUser : Command
    {
        public override string CommandName
        {
            get { return "AddDatabaseUser"; }
        }

        public override int Run(List<string> args)
        {
            int result = 0;
            if (args.Count != 3)
            {
                ShowHelp();
                result = 1024;
            }
            else
            {
                string server = args[0];
                string database = args[1];
                string[] accountName;
                if (args[2].Contains("\\"))
                {
                    accountName = args[2].Split('\\');
                }
                else
                {
                    accountName = new string[2];
                    accountName[0] = args[0];
                    accountName[1] = args[2];
                }

                Regex regex = new Regex(@"[^\[\]]+");
                if (regex.Match(accountName[0]).Value.Length != accountName[0].Length)
                {
                    Log.WriteLine("An invalid character was specified for the domain portion of the account name.");
                    return 8;
                }
                if (regex.Match(accountName[1]).Value.Length != accountName[1].Length)
                {
                    Log.WriteLine("An invalid character was specified for the user name portion of the account name.");
                    return 16;
                }

                using (SqlConnection connection = GetSqlConnection(server, database))
                {
                    using (SqlCommand command = new SqlCommand())
                    {
                        command.Connection = connection;
                        connection.Open();

                        string domainUser = accountName[0] + "\\" + accountName[1];

                        // Drop existing user without domain name if it exists
                        string statement = String.Format(@"if exists (select * from sys.sysusers where [name] = @User and islogin = 1) begin drop user [{0}] end", accountName[1]);
                        Log.WriteLine(statement + "\t@User=" + accountName[1]);
                        command.CommandText = statement;
                        command.Parameters.AddWithValue("@User", accountName[1]);
                        command.ExecuteNonQuery();

                        //Create user with domain name
                        statement = String.Format(@"if not exists (select * from sys.sysusers where [name] = @User and islogin = 1) begin create user [{0}] for login [{1}] with default_schema = dbo end", domainUser, domainUser);
                        Log.WriteLine(statement + "\t@User=" + domainUser);
                        command.Parameters.Clear();
                        command.CommandText = statement;
                        command.Parameters.AddWithValue("@User", domainUser);
                        command.ExecuteNonQuery();
                    }
                }
            }

            return result;
            //create user {2} for login [{1}\{2}] with default_schema = dbo
        }

        public override void ShowHelp()
        {
            Log.WriteLine();
            Log.WriteLine("AddDatabaseUser: Add a SQL login as a user to the");
            Log.WriteLine("                   specified datbase.  If the user name");
            Log.WriteLine("                   does not contain a domain in the ");
            Log.WriteLine("                   domain\\user format, the local machine");
            Log.WriteLine("                   is assumed.");
            Log.WriteLine();
            Log.WriteLine("Usage:");
            Log.WriteLine("   Vibrio [flags] AddDatabaseUser <server> <database> <account>");
            Log.WriteLine();
            Log.WriteLine("Return codes:");
            Log.WriteLine("   0 if operation is successful, non-zero otherwise.");
            Log.WriteLine();
            Log.WriteLine("Example:");
            Log.WriteLine("   Vibrio [flags] AddDatabaseUser XbcXblob01 xboxcom_www _xbcweb");
            Log.WriteLine();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Vibrio\AddSqlLoginToServerRole.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data.SqlClient;

namespace xonline.tools.Vibrio
{
    public class AddSqlLoginToServerRole : Command
    {
        public override string CommandName
        {
            get { return "AddSqlLoginToServerRole"; }
        }

        public override int Run(List<string> args)
        {
            int result = 0;
            if (args.Count < 3)
            {
                ShowHelp();
                result = 1024;
            }
            else
            {
                string[] accountName;
                if (args[1].Contains("\\"))
                {
                    accountName = args[1].Split('\\');
                }
                else
                {
                    accountName = new string[2];
                    accountName[0] = args[0];
                    accountName[1] = args[1];
                }

                using (SqlConnection connection = GetSqlConnection(args[0], "master"))
                {
                    using (SqlCommand command = new SqlCommand())
                    {
                        command.Connection = connection;
                        connection.Open();

                        for (int i = 2; i < args.Count; i++)
                        {
                            string domainUser = accountName[0] + "\\" + accountName[1];
                            string statement = "sp_addsrvrolemember @DomainUser, @Role";
                            Log.WriteLine(statement + "\t@DomainUser=" + domainUser + ",@Role=" + args[i]);

                            command.CommandText = statement;
                            command.Parameters.Clear();
                            command.Parameters.AddWithValue("@DomainUser", domainUser);
                            command.Parameters.AddWithValue("@Role", args[i]);
                            command.ExecuteNonQuery();
                        }
                    }
                }
            }

            return result;
        }

        public override void ShowHelp()
        {
            Log.WriteLine();
            Log.WriteLine("AddSqlLoginToServerRole: Add a SQL login to the specified");
            Log.WriteLine("                   built-in server role.  If the user name");
            Log.WriteLine("                   does not contain a domain in the ");
            Log.WriteLine("                   domain\\user format, the local machine");
            Log.WriteLine("                   is assumed.");
            Log.WriteLine();
            Log.WriteLine("Usage:");
            Log.WriteLine("   Vibrio [flags] AddSqlLoginToServerRole <server> <account> <role> [<role>...]");
            Log.WriteLine();
            Log.WriteLine("Return codes:");
            Log.WriteLine("   0 if operation is successful, non-zero otherwise.");
            Log.WriteLine();
            Log.WriteLine("Example:");
            Log.WriteLine("   Vibrio [flags] AddSqlLoginToServerRole XbcXblob01 _xbcweb sysadmin");
            Log.WriteLine();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Vibrio\AddSqlLoginToRole.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data.SqlClient;

namespace xonline.tools.Vibrio
{
    public class AddSqlLoginToRole : Command
    {
        public override string CommandName
        {
            get { return "AddSqlLoginToRole"; }
        }

        public override int Run(List<string> args)
        {
            int result = 0;
            if (args.Count < 4)
            {
                ShowHelp();
                result = 1024;
            }
            else
            {
                string server = args[0];
                string database = args[1];
                string[] accountName;
                if (args[2].Contains("\\"))
                {
                    accountName = args[2].Split('\\');
                }
                else
                {
                    accountName = new string[2];
                    accountName[0] = args[0];
                    accountName[1] = args[2];
                }

                using (SqlConnection connection = GetSqlConnection(server, database))
                {
                    using (SqlCommand command = new SqlCommand())
                    {
                        command.Connection = connection;
                        connection.Open();
                        string domainUser = accountName[0] + "\\" + accountName[1];

                        for (int i = 3; i < args.Count; i++)
                        {
                            string statement = "if exists (select * from sys.sysusers (nolock) where name = @Role and issqlrole = 1) begin exec sp_addrolemember @Role, @User end";
                            Log.WriteLine(statement + "\t@Role=" + args[i] + ", @User=" + domainUser);

                            command.CommandText = statement;
                            command.Parameters.Clear();
                            command.Parameters.AddWithValue("@Role", args[i]);
                            command.Parameters.AddWithValue("@User", domainUser);
                            command.ExecuteNonQuery();
                        }
                    }
                }
            }

            return result;
        }

        public override void ShowHelp()
        {
            Log.WriteLine();
            Log.WriteLine("AddSqlLoginToRole: Add a SQL login to the specified");
            Log.WriteLine("                   database role.  If the user name");
            Log.WriteLine("                   does not contain a domain in the ");
            Log.WriteLine("                   domain\\user format, the local machine");
            Log.WriteLine("                   is assumed.");
            Log.WriteLine();
            Log.WriteLine("Usage:");
            Log.WriteLine("   Vibrio [flags] AddSqlLoginToRole <server> <database> <account> <role> [<role>...]");
            Log.WriteLine();
            Log.WriteLine("Return codes:");
            Log.WriteLine("   0 if operation is successful, non-zero otherwise.");
            Log.WriteLine();
            Log.WriteLine("Example:");
            Log.WriteLine("   Vibrio [flags] AddSqlLoginToRole XbcXblob01 xboxcom_www _xbcweb WebUser");
            Log.WriteLine();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Vibrio\AddToGroup.cs ===
﻿using System;
using System.Collections.Generic;
using System.DirectoryServices;
using System.Collections;

namespace xonline.tools.Vibrio
{
    public class AddToGroup : Command
    {
        public override string CommandName
        {
            get { return "AddToGroup"; }
        }

        public override int Run(List<string> args)
        {
            int result = 0;

            if (args.Count != 2)
            {
                ShowHelp();
                result = 1024;
            }
            else
            {
                DirectoryEntry user = UserUtilities.GetUser(args[0]);
                if (user == null)
                {
                    Log.WriteLine("Could not find user {0}.", args[0]);
                    result = 2;
                }
                else
                {
                    DirectoryEntry group = UserUtilities.GetGroup(args[1]);
                    if (group == null)
                    {
                        Log.WriteLine("Could not find group {0}.", args[1]);
                        result = 4;
                    }
                    else
                    {
                        Log.WriteLine("Check if user {0} is a member of group {1}...", args[0], args[1]);
                        if (!GroupContainsUser(group, user))
                        {
                            Log.WriteLine("Adding user {0} to group {1}...", user.Name, group.Name);
                            group.Invoke("Add", user.Path);
                        }
                        else
                        {
                            Log.WriteLine("User {0} already exists in group {1}.", user.Name, group.Name);
                        }
                    }
                }
            }

            return result;
        }

        private bool GroupContainsUser(DirectoryEntry group, DirectoryEntry user)
        {
            foreach (object member in (IEnumerable)group.Invoke("members", null))
            {
                DirectoryEntry child = new DirectoryEntry(member);
                if (child.Name == user.Name)
                {
                    return true;
                }
            }

            return false;
        }

        public override void ShowHelp()
        {
            Log.WriteLine();
            Log.WriteLine("AddToGroup: Add a user to a group on the local machine.");
            Log.WriteLine();
            Log.WriteLine("Usage:");
            Log.WriteLine("   Vibrio [flags] AddToGroup <user> <group>");
            Log.WriteLine();
            Log.WriteLine("Return codes:");
            Log.WriteLine("   0 if operation is successful, non-zero otherwise.");
            Log.WriteLine();
            Log.WriteLine("Example:");
            Log.WriteLine("   Vibrio AddToGroup _xbcweb IIS_WPG");
            Log.WriteLine();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Vibrio\AddWebConfigSetting.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Configuration;
using System.Web.Configuration;

namespace xonline.tools.Vibrio
{
    public class AddWebConfigSetting : Command
    {
        public override string CommandName
        {
            get { return "AddWebConfigSetting"; }
        }

        public override int Run(List<string> args)
        {
            int result = 0;

            if (args.Count != 3)
            {
                ShowHelp();
                result = 1024;
            }
            else
            {
                string websiteName = args[0];
                string settingName = args[1];
                string settingValue = args[2];

                var config = WebConfigurationManager.OpenWebConfiguration("/", websiteName);
                config.AppSettings.Settings.Add(settingName, settingValue);
                config.Save(ConfigurationSaveMode.Modified);
            }

            return result;
        }

        public override void ShowHelp()
        {
            Log.WriteLine();
            Log.WriteLine("AddWebConfigSetting: Add the setting to the given web.config file.");
            Log.WriteLine();
            Log.WriteLine("Usage:");
            Log.WriteLine("   Vibrio [flags] AddWebConfigSetting <website name> <setting> <value>");
            Log.WriteLine();
            Log.WriteLine("Return codes:");
            Log.WriteLine("   0 if operation is successful, non-zero otherwise.");
            Log.WriteLine();
            Log.WriteLine("Example:");
            Log.WriteLine("   Vibrio AddWebConfigSetting \"LiveWeb Preview\" componentName livewebpreview_www");
            Log.WriteLine();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Vibrio\Command.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data.SqlClient;

namespace xonline.tools.Vibrio
{
    public abstract class Command
    {
        public abstract string CommandName { get; }
        public abstract int Run(List<string> args);
        public abstract void ShowHelp();

        public Logger Log
        {
            get;
            set;
        }

        public static SqlConnection GetSqlConnection(string server, string database)
        {
            return new SqlConnection(String.Format("SERVER={0};DATABASE={1};Integrated Security=SSPI;Connection Timeout=30;", server, database));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Vibrio\AddUpdateActiveAuthPolicy.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace xonline.tools.Vibrio
{
    public class AddUpdateActiveAuthPolicy : Command
    {
        public override string CommandName
        {
            get { return "AddUpdateActiveAuthPolicy"; }
        }

        public override int Run(List<string> args)
        {
            int result = 0;

            if (args.Count != 8)
            {
                ShowHelp();
                result = 1024;
            }
            else
            {
                string npdbServerName = args[0];
                string npdbDatabaseName = args[1];
                string environment = args[2];
                string policyKey = args[3];
                string authPolicy = args[4];
                bool requiresAuth = ((args[5]=="1")?true:false);
                bool isSsl = ((args[6] == "1") ? true : false);
                string authHeader = args[7];


                var npdbUtilities = new NpdbUtilities(npdbServerName, npdbDatabaseName, Log);
                npdbUtilities.AddUpdateActiveAuthPolicy(environment, policyKey, authPolicy, requiresAuth, isSsl, authHeader);
            }

            return result;
        }

        public override void ShowHelp()
        {
            Log.WriteLine();
            Log.WriteLine("AddUpdateActiveAuthPolicy: Add or Update ActiveAuthPolicy for an endpoint in NPDB.");
            Log.WriteLine();
            Log.WriteLine("Usage:");
            Log.WriteLine("   Vibrio [flags] AddUpdateActiveAuthPolicy <npdbServer> <npdbDatabase> <environment> <policyKey> <authPolicy> <requiresAuth> <isSsl> <authHeader>");
            Log.WriteLine();
            Log.WriteLine("Return codes:");
            Log.WriteLine("   0 if operation is successful, non-zero otherwise.");
            Log.WriteLine();
            Log.WriteLine("Example:");
            Log.WriteLine("   Vibrio [flags] AddUpdateActiveAuthPolicy MyNpdbServer01 NPDB ALL /Profiles.svc/profile LBI 1 0 XBL1.0");
            Log.WriteLine();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Vibrio\BillingSql.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Data.SqlClient;

namespace xonline.tools.Vibrio
{
    public class BillingSql : Command
    {
        private const string UodbStatement = "delete from t_service_keys where i_key_type = 4 " +
            "delete from t_service_keys where i_key_type = 8 " +
            "insert into t_service_keys (i_key_type, vc_service_data1, vc_service_data2, i_ticket_lifetime_secs, i_master_key_version, i_key_version, bin_key) " +
            "values (4, N'spsp_xbox', N'https://{XBLOB}/bdk2/bdk.wsdl', -1, 0, 0, CONVERT(varbinary(256), N'9hYYH8jTGBUrXHlLM1T4rGFKrkg')) " +
            "insert into t_service_keys (i_key_type, vc_service_data1, vc_service_data2, i_ticket_lifetime_secs, i_master_key_version, i_key_version, bin_key) " +
            "values (8, N'spsp_xbox', N'https://{XBLOB}/bdk2/bdk.wsdl', -1, 0, 0, CONVERT(varbinary(256), N'9hYYH8jTGBUrXHlLM1T4rGFKrkg')) ";
        private const string NpdbStatement = "exec p_config_add_setting_override @setting = 'billing_bdkUrl', @value = 'https://{XBLOB}/scs/scsapiwebservice.asmx?wsdl', @environment = 'xblob', @overwriteExistingValue = 1 " +
            "exec p_config_add_setting_override @setting = 'dmp_clientCertSubject', @value = 'onebox-sps.xboxlive.com', @environment = 'xblob', @overwriteExistingValue = 1 " +
            "exec p_config_add_setting_override @setting = 'dmp_tenantID', @value = 'ECC7B465-3064-4E85-8D79-B4C84A5B27FE', @environment = 'xblob', @overwriteExistingValue = 1 " +
            "exec p_config_add_setting_override @setting = 'dmp_transactionUrl', @value = 'https://{XBLOB}/DmpTransaction/Transaction.asmx', @environment = 'xblob', @overwriteExistingValue = 1 " +
            "exec p_config_add_setting_override @setting = 'billing_connectToBilling', @value = 'yes', @environment = 'xblob', @overwriteExistingValue = 1 ";


        public override string CommandName
        {
            get { return "BillingSql"; }
        }

        public override int Run(List<string> args)
        {
            int result = 0;

            if (args.Count != 1)
            {
                ShowHelp();
                result = 1024;
            }
            else
            {
                using (SqlConnection connection = GetSqlConnection(args[0], "master"))
                {
                    string statement = UodbStatement.Replace("{XBLOB}", args[0]);
                    using (SqlCommand command = new SqlCommand(statement, connection))
                    {
                        connection.Open();
                        Log.WriteLine("Executing uodb statement...");
                        Log.WriteLine(statement);
                        Log.WriteLine();
                        command.ExecuteNonQuery();
                    }
                }

                using (SqlConnection connection = GetSqlConnection(args[0], "master"))
                {
                    string statement = NpdbStatement.Replace("{XBLOB}", args[0]);
                    using (SqlCommand command = new SqlCommand(statement, connection))
                    {
                        connection.Open();
                        Log.WriteLine("Executing npdb statement...");
                        Log.WriteLine(statement);
                        Log.WriteLine();
                        command.ExecuteNonQuery();
                    }
                }
            }

            return result;
        }

        public override void ShowHelp()
        {
            Log.WriteLine();
            Log.WriteLine("BillingSql: Run the SQL statements required to set the billing box");
            Log.WriteLine("                   for the specified xblob.");
            Log.WriteLine();
            Log.WriteLine("Usage:");
            Log.WriteLine("   Vibrio [flags] BillingSql <xblob>");
            Log.WriteLine();
            Log.WriteLine("Return codes:");
            Log.WriteLine("   0 if operation is successful, non-zero otherwise.");
            Log.WriteLine();
            Log.WriteLine("Example:");
            Log.WriteLine("   Vibrio [flags] BillingSql XbcXblob01");
            Log.WriteLine();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Vibrio\ConfigureIsapiRewrite.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using Microsoft.Win32;
using System.IO;

namespace xonline.tools.Vibrio
{
    public class ConfigureIsapiRewrite : Command
    {
        public override string CommandName
        {
            get { return "ConfigureIsapiRewrite"; }
        }

        public override int Run(List<string> args)
        {
            int result = 0;

            if (args.Count != 1)
            {
                ShowHelp();
                result = 1024;
            }
            else
            {
                string configPath = GetIsapiRewritePath();
                if (!String.IsNullOrEmpty(configPath))
                {
                    Log.WriteLine("Checking for the existence of the secure share.");
                    string secureShare = args[0];
                    if (secureShare.EndsWith("\""))
                    {
                        Log.WriteLine("Removing the trailing \" character from the secure share path.");
                        secureShare = secureShare.Substring(0, secureShare.Length - 1);
                    }
                    if (Directory.Exists(secureShare))
                    {
                        if (Directory.Exists(configPath))
                        {
                            string fileName = Path.Combine(configPath, "httpd.ini");
                            FileInfo fileInfo = new FileInfo(fileName);
                            if (fileInfo.IsReadOnly)
                            {
                                Log.WriteLine("Removing read-only attribute from " + fileName + "...");
                                fileInfo.IsReadOnly = false;
                            }

                            File.Copy(Path.Combine(secureShare, "httpd.ini"), fileName, true);
                        }
                        else
                        {
                            Log.WriteLine("The path {0} does not exist.", configPath);
                            result = 4;
                        }
                    }
                    else
                    {
                        Log.WriteLine("The path {0} does not exist.", secureShare);
                        result = 4;
                    }
                }
                else
                {
                    Log.WriteLine("Could not find the installation path for ISAPIRewrite.");
                    result = 2;
                }
            }

            return result;
        }

        private string GetIsapiRewritePath()
        {
            string key = "SOFTWARE\\Helicon\\ISAPI_Rewrite\\";
            string value = "InstallDir";
            Log.WriteLine("Looking for the value in HKLM\\{0}{1}", key, value);
            string path = RegistryUtility.GetRegistryValue(Registry.LocalMachine, key, value);
            if (String.IsNullOrEmpty(path))
            {
                path = RegistryUtility.GetRegistryValue(Registry.LocalMachine, key.Replace("SOFTWARE", "SOFTWARE\\Wow6432Node"), value);
            }

            return path;
        }

        public override void ShowHelp()
        {
            Log.WriteLine();
            Log.WriteLine("ConfigureIsapiRewrite: Copy the configuration files (httpd.ini)");
            Log.WriteLine("                   to the correct locations based on the install");
            Log.WriteLine("                   location in the registry.");
            Log.WriteLine();
            Log.WriteLine("Usage:");
            Log.WriteLine("   Vibrio [flags] ConfigureIsapiRewrite <sourceFolder>");
            Log.WriteLine();
            Log.WriteLine("Return codes:");
            Log.WriteLine("   0 if operation is successful, non-zero otherwise.");
            Log.WriteLine();
            Log.WriteLine("Example:");
            Log.WriteLine("   Vibrio [flags] ConfigureIsapiRewrite \\\\XbcXblob01\\Secure");
            Log.WriteLine();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Vibrio\CopyFile.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.IO;

namespace xonline.tools.Vibrio
{
    public class CopyFile : Command
    {
        public override string CommandName
        {
            get { return "CopyFile"; }
        }

        public override int Run(List<string> args)
        {
            int result = 0;
            if (args.Count != 2)
            {
                ShowHelp();
                result = 1024;
            }
            else
            {
                string fileName = Path.GetFileName(args[0]);
                string destination = args[1];
                if (!destination.EndsWith(fileName, StringComparison.OrdinalIgnoreCase))
                {
                    destination = Path.Combine(destination, fileName);
                }

                if (File.Exists(destination))
                {
                    FileInfo fileInfo = new FileInfo(destination);
                    if (fileInfo.IsReadOnly)
                    {
                        Log.WriteLine("Removing read-only attribute from " + destination + "...");
                        fileInfo.IsReadOnly = false;
                    }
                }

                Log.WriteLine("Copying file {0} to {1}...", args[0], destination);
                File.Copy(args[0], destination, true);
            }

            return result;
        }

        public override void ShowHelp()
        {
            Log.WriteLine();
            Log.WriteLine("CopyFile: Copy the file to the specified location.");
            Log.WriteLine();
            Log.WriteLine("Usage:");
            Log.WriteLine("   Vibrio [flags] CopyFile <sourcePath> <destinationPath>");
            Log.WriteLine();
            Log.WriteLine("Return codes:");
            Log.WriteLine("   0 if operation is successful, non-zero otherwise.");
            Log.WriteLine();
            Log.WriteLine("Example:");
            Log.WriteLine("   Vibrio [flags] CopyFile C:\\temp\\httpd.ini \\\\XbcXblob01\\Secure");
            Log.WriteLine();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Vibrio\CreateShare.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Security.AccessControl;
using System.Management;
using System.Security.Principal;

namespace xonline.tools.Vibrio
{
    public class CreateShare : Command
    {
        public override string CommandName
        {
            get { return "CreateShare"; }
        }

        public override int Run(List<string> args)
        {
            int result = 0;

            if (args.Count < 3)
            {
                ShowHelp();
                result = 1024;
            }
            else
            {
                CreateDirectory(args);

                uint returnValue = CreateDirectoryShare(args);
                if ((returnValue == 0) || (returnValue == 22))  // Share already exists = 22
                {
                    if (returnValue == 22)
                    {
                        Log.WriteLine("Share already exists.");
                    }

                    List<ManagementObject> aces = BuildAces(args);
                    result = SetShareSecurity(args, result, aces);
                }
                else
                {
                    Log.WriteLine("Failed to create the share.  Return Value: {0}", returnValue);
                    result = 2;
                }
            }

            return result;
        }

        private uint CreateDirectoryShare(List<string> args)
        {
            Log.WriteLine("Creating share {0} on directory {1}...", args[0], args[1]);
            ManagementClass managementClass = new ManagementClass("Win32_Share");
            ManagementBaseObject inputParameters = managementClass.GetMethodParameters("Create");
            inputParameters["Description"] = args[0];
            inputParameters["Name"] = args[0];
            inputParameters["Path"] = args[1];
            inputParameters["Type"] = 0;
            ManagementBaseObject outputParameters = managementClass.InvokeMethod("Create", inputParameters, null);

            return (uint)(outputParameters.Properties["ReturnValue"].Value);
        }

        private int SetShareSecurity(List<string> args, int result, List<ManagementObject> aces)
        {
            ManagementObject descriptor = new ManagementClass(new ManagementPath("Win32_SecurityDescriptor"), null);
            descriptor["ControlFlags"] = 4;     // DACL present

            ManagementBaseObject[] dacl = new ManagementBaseObject[aces.Count];
            for (int i = 0; i < aces.Count; i++)
            {
                dacl[i] = aces[i];
            }

            descriptor["DACL"] = dacl;
            ManagementObject share = new ManagementObject(String.Format(@"\\{0}\root\cimv2:Win32_Share.Name='{1}'", Environment.MachineName, args[0]));
            int returnValue = Convert.ToInt32(share.InvokeMethod("SetShareInfo", new object[] { Int32.MaxValue, args[0], descriptor }));
            if (returnValue != 0)
            {
                Log.WriteLine("Unable to set security on share {0}, return value {1}.", args[0], returnValue);
                result = 4;
            }

            return result;
        }

        private List<ManagementObject> BuildAces(List<string> args)
        {
            List<ManagementObject> aces = new List<ManagementObject>();
            for (int i = 2; i < args.Count; i++)
            {
                string[] accountName;
                if (args[i].Contains("\\"))
                {
                    accountName = args[i].Split('\\');
                }
                else
                {
                    accountName = new string[2];
                    accountName[0] = Environment.MachineName;
                    accountName[1] = args[i];
                }

                NTAccount account = new NTAccount(accountName[0], accountName[1]);
                SecurityIdentifier sid = (SecurityIdentifier)account.Translate(typeof(SecurityIdentifier));
                byte[] sidArray = new byte[sid.BinaryLength];
                sid.GetBinaryForm(sidArray, 0);

                ManagementObject trustee = new ManagementClass(new ManagementPath("Win32_Trustee"), null);
                trustee["Domain"] = accountName[0];
                trustee["Name"] = accountName[1];
                trustee["SID"] = sidArray;

                ManagementObject ace = new ManagementClass(new ManagementPath("Win32_Ace"), null);
                ace["AccessMask"] = 2032127;   // Full Control
                ace["AceFlags"] = 3;           // Container and object children inherit
                ace["AceType"] = 0;            // Allow access
                ace["Trustee"] = trustee;

                aces.Add(ace);

                Log.WriteLine("Granting access to user {0}\\{1} to share...", accountName[0], accountName[1]);
            }

            return aces;
        }

        private void CreateDirectory(List<string> args)
        {
            if (!Directory.Exists(args[1]))
            {
                Log.WriteLine("Creating directory {0}...", args[1]);
                Directory.CreateDirectory(args[1]);
            }
            else
            {
                Log.WriteLine("Directory {0} already exists.", args[1]);
            }

            for (int i = 2; i < args.Count; i++)
            {
                Log.WriteLine("Granting access to user {0} for directory {1}...", args[1], args[i]);
                FileUtilities.AddFolderPermission(args[1], args[i], FileSystemRights.FullControl, InheritanceFlags.ContainerInherit | InheritanceFlags.ObjectInherit, PropagationFlags.None, AccessControlType.Allow);
            }
            Log.WriteLine();
        }

        public override void ShowHelp()
        {
            Log.WriteLine();
            Log.WriteLine("CreateShare: Given a local path, create a share and grant full");
            Log.WriteLine("                   permissions to each user/group specified.  If");
            Log.WriteLine("                   the given path does not exist, it is created.");
            Log.WriteLine("                   If a domain is not given with the user, it is");
            Log.WriteLine("                   assumed to be a local user.");
            Log.WriteLine();
            Log.WriteLine("Usage:");
            Log.WriteLine("   Vibrio [flags] CreateShare <share name> <path> <user> [<user>...]");
            Log.WriteLine();
            Log.WriteLine("Return codes:");
            Log.WriteLine("   0 if operation is successful, non-zero otherwise.");
            Log.WriteLine();
            Log.WriteLine("Example:");
            Log.WriteLine("   Vibrio [flags] CreateShare xboxcom_assets C:\\xboxcom_assets _xbcweb REDMOND\\xboxdev");
            Log.WriteLine();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Vibrio\ConfigureRps.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using Microsoft.Win32;
using System.IO;

namespace xonline.tools.Vibrio
{
    public enum ConfigurationLevel
    {
        certonly,
        nocert,
        all,
    }

    public class ConfigureRps : Command
    {
        public override string CommandName
        {
            get { return "ConfigureRps"; }
        }

        public override int Run(List<string> args)
        {
            string secureSharePath = String.Empty;
            ConfigurationLevel level = ConfigurationLevel.all;

            int result = ValidateParameters(args, ref secureSharePath, ref level);
            if (result != 0)
            {
                ShowHelp();
                return result;
            }

            string configPath = String.Empty;
            result = GetRpsConfigurationPath(ref configPath);
            if (result != 0)
            {
                return result;
            }

            if ((level == ConfigurationLevel.all) || (level == ConfigurationLevel.nocert))
            {
                string destFilePath = Path.Combine(configPath, "rpsserver.xml");
                try
                {
                    File.Copy(Path.Combine(secureSharePath, "rpsserver.xml"), destFilePath, true);
                }
                catch (UnauthorizedAccessException)
                {
                    // if the current rpsserver.xml is read only you can get this exception.  Just remove the readonly attribute and try again
                    File.SetAttributes(destFilePath, File.GetAttributes(destFilePath) & ~FileAttributes.ReadOnly);
                    File.Copy(Path.Combine(secureSharePath, "rpsserver.xml"), destFilePath, true);
                }
            }
            if ((level == ConfigurationLevel.all) || (level == ConfigurationLevel.certonly))
            {
                configPath = Path.Combine(configPath, "certs");
                if (!Directory.Exists(configPath))
                {
                    Directory.CreateDirectory(configPath);
                }
                File.Copy(Path.Combine(secureSharePath, "int-rps.xbox.com.cer"), Path.Combine(configPath, "int-rps.xbox.com.cer"), true);
            }

            return 0;
        }

        private int ValidateParameters(List<string> args, ref string secureSharePath, ref ConfigurationLevel level)
        {
            if ((args.Count < 1) || (args.Count > 2))
            {
                return 1024;
            }

            // Parse the parameters... If the secure share ends with a '\', 
            // then I need to split the string, because it is read as a \"
            if (args[0].Contains("\""))
            {
                if (args.Count > 1)
                {
                    ShowHelp();
                    return 1024;
                }

                string[] argParts = args[0].Split(new string[] { "\"" }, StringSplitOptions.RemoveEmptyEntries);
                secureSharePath = argParts[0];
                level = (ConfigurationLevel)Enum.Parse(typeof(ConfigurationLevel), argParts[1]);
            }
            else
            {
                secureSharePath = args[0];
                if (args.Count == 2)
                {
                    level = (ConfigurationLevel)Enum.Parse(typeof(ConfigurationLevel), args[1]);
                }
            }

            // Validate the secure share exists
            Log.WriteLine("Checking for the existence of the secure share.");
            if (!Directory.Exists(secureSharePath))
            {
                Log.WriteLine("The path {0} does not exist.", secureSharePath);
                return 4;
            }

            return 0;
        }

        private int GetRpsConfigurationPath(ref string path)
        {
            // Find the CLSID for Passport.RPS
            string classId = RegistryUtility.GetRegistryValue(Registry.ClassesRoot, "Passport.RPS\\CLSID\\", "");
            if (String.IsNullOrEmpty(classId))
            {
                classId = RegistryUtility.GetRegistryValue(Registry.ClassesRoot, "Wow6432Node\\Passport.RPS\\CLSID\\", "");
                if (String.IsNullOrEmpty(classId))
                {
                    return 8;
                }
            }

            // Find the installation path for the CLSID
            path = RegistryUtility.GetRegistryValue(Registry.ClassesRoot, "CLSID\\" + classId + "\\InprocServer32\\", "");
            if (String.IsNullOrEmpty(path))
            {
                path = RegistryUtility.GetRegistryValue(Registry.ClassesRoot, "Wow6432Node\\CLSID\\" + classId + "\\InprocServer32\\", "");
                if (String.IsNullOrEmpty(path))
                {
                    return 16;
                }
            }

            // Ensure the path exists
            path = path.Substring(0, path.LastIndexOf("\\"));
            if (String.IsNullOrEmpty(path))
            {
                Log.WriteLine("Could not find the installation path for RPS.");
                return 32;
            }

            // Ensure the 'config' path exists
            path = Path.Combine(path, "config");
            if (!Directory.Exists(path))
            {
                Log.WriteLine("The path {0} does not exist.", path);
                return 64;
            }

            return 0;
        }

        public override void ShowHelp()
        {
            Log.WriteLine();
            Log.WriteLine("ConfigureRps: Copy the configuration files (rpsserver.xml, ");
            Log.WriteLine("                   int-rps.xbox.com.cer) to the correct locations ");
            Log.WriteLine("                   based on the install location in the registry.");
            Log.WriteLine("                   The last parameter controls which files to copy,");
            Log.WriteLine("                   All is the default.");
            Log.WriteLine();
            Log.WriteLine("Usage:");
            Log.WriteLine("   Vibrio [flags] ConfigureRps <sourceFolder> [<CertOnly|NoCert|All>]");
            Log.WriteLine();
            Log.WriteLine("Return codes:");
            Log.WriteLine("   0 if operation is successful, non-zero otherwise.");
            Log.WriteLine();
            Log.WriteLine("Example:");
            Log.WriteLine("   Vibrio [flags] ConfigureRps \\\\XbcXblob01\\Secure All");
            Log.WriteLine();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Vibrio\DeleteRegistry.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using Microsoft.Win32;

namespace xonline.tools.Vibrio
{
    public class DeleteRegistry : Command
    {
        public override string CommandName
        {
            get { return "DeleteRegistry"; }
        }

        public override int Run(List<string> args)
        {
            int result = 0;

            if ((args.Count < 1) || (args.Count > 2))
            {
                ShowHelp();
                result = 1024;
            }
            else
            {
                int first = args[0].IndexOf("\\");
                int last = args[0].LastIndexOf("\\");
                if ((first > 0) && (last > 0))
                {
                    string sub = args[0].Substring(0, first);
                    string key = args[0].Substring(first + 1, last - first);
                    string key64 = String.Empty;
                    string valueName = args[0].Substring(last + 1);

                    RegistryKey baseKey;
                    switch (sub)
                    {
                        default:
                        case "HKLM":
                        case "HKEY_LOCAL_MACHINE":
                            baseKey = Registry.LocalMachine;
                            if (key.StartsWith("Software", StringComparison.OrdinalIgnoreCase))
                            {
                                int position = key.IndexOf("\\");
                                key64 = key.Substring(0, position) + "\\Wow6432Node" + key.Substring(position);
                            }
                            else
                            {
                                key64 = key;
                            }
                            break;

                        case "HKCR":
                        case "HKEY_CLASSES_ROOT":
                            baseKey = Registry.ClassesRoot;
                            key64 = "Wow6432Node\\" + key;
                            break;

                        case "HKCU":
                        case "HKEY_CURRENT_USER":
                            baseKey = Registry.CurrentUser;
                            if (key.StartsWith("Software", StringComparison.OrdinalIgnoreCase))
                            {
                                int position = key.IndexOf("\\");
                                key64 = key.Substring(0, position) + "\\Wow6432Node" + key.Substring(position);
                            }
                            else
                            {
                                key64 = key;
                            }
                            break;

                        case "HKCC":
                        case "HKEY_CURRENT_CONFIG":
                            baseKey = Registry.CurrentConfig;
                            key64 = key;
                            break;
                    }

                    Use64BitRegistry registryUse = Use64BitRegistry.use32;
                    if (args.Count == 2)
                    {
                        registryUse = (Use64BitRegistry)Enum.Parse(typeof(Use64BitRegistry), args[1].ToLower());
                    }

                    if ((registryUse == Use64BitRegistry.use32) || (registryUse == Use64BitRegistry.both))
                    {
                        if (!DeleteRegistryValue(baseKey, key, valueName))
                        {
                            result = 2;
                        }
                    }

                    if ((registryUse == Use64BitRegistry.use64) || (registryUse == Use64BitRegistry.both))
                    {
                        if (!DeleteRegistryValue(baseKey, key64, valueName))
                        {
                            result = 2;
                        }
                    }
                }
            }

            return result;
        }

        private bool DeleteRegistryValue(RegistryKey baseKey, string key, string valueName)
        {
            RegistryKey registryKey = RegistryUtility.GetRegistryKey(baseKey, key, false, true);
            if (registryKey != null)
            {
                if (registryKey.GetValue(valueName) != null)
                {
                    Log.WriteLine("Deleting {0}\\{1}{2}...", baseKey.Name, key, valueName);
                    registryKey.DeleteValue(valueName);
                    return true;
                }
                else
                {
                    Log.WriteLine("Value {2} in key {0}\\{1} not found.", baseKey.Name, key, valueName);
                    return false;
                }
            }
            else
            {
                Log.WriteLine("Key {0}\\{1} not found.", baseKey.Name, key);
                return false;
            }
        }

        public override void ShowHelp()
        {
            Log.WriteLine();
            Log.WriteLine("DeleteRegistry: Delete a registry value.  The 64bit registry is used");
            Log.WriteLine("                   based on a parameter passed in.  The default is");
            Log.WriteLine("                   to use the 32bit registry hive only.");
            Log.WriteLine();
            Log.WriteLine("Usage:");
            Log.WriteLine("   Vibrio [flags] DeleteRegistry <key> [<Use32|Use64|Both>]");
            Log.WriteLine();
            Log.WriteLine("Return codes:");
            Log.WriteLine("   0 if operation is successful, non-zero otherwise.");
            Log.WriteLine();
            Log.WriteLine("Example:");
            Log.WriteLine("   Vibrio DeleteRegistry HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\XboxLive\\CommonConfig\\Database both");
            Log.WriteLine();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Vibrio\CreateSqlLogin.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.Text.RegularExpressions;

namespace xonline.tools.Vibrio
{
    public class CreateSqlLogin : Command
    {
        public override string CommandName
        {
            get { return "CreateSqlLogin"; }
        }

        public override int Run(List<string> args)
        {
            int result = 0;
            if (args.Count != 2)
            {
                ShowHelp();
                result = 1024;
            }
            else
            {
                string[] accountName;
                if (args[1].Contains("\\"))
                {
                    accountName = args[1].Split('\\');
                }
                else
                {
                    accountName = new string[2];
                    accountName[0] = args[0];
                    accountName[1] = args[1];
                }

                Regex regex = new Regex(@"[^\[\]]+");
                if (regex.Match(accountName[0]).Value.Length != accountName[0].Length)
                {
                    Log.WriteLine("An invalid character was specified for the domain portion of the account name.");
                    return 8;
                }
                if (regex.Match(accountName[1]).Value.Length != accountName[1].Length)
                {
                    Log.WriteLine("An invalid character was specified for the user name portion of the account name.");
                    return 16;
                }

                using (SqlConnection connection = GetSqlConnection(args[0], "master"))
                {
                    using (SqlCommand command = new SqlCommand())
                    {
                        command.Connection = connection;
                        connection.Open();

                        string domainUser = accountName[0] + "\\" + accountName[1];
                        string statement = String.Format(@"if not exists (select * from syslogins where [name] = @DomainUser) begin CREATE LOGIN [{0}] FROM WINDOWS end", domainUser);
                        Log.WriteLine(statement + "\t@DomainUser=" + domainUser);

                        command.CommandText = statement;
                        command.Parameters.AddWithValue("@DomainUser", accountName[0] + "\\" + accountName[1]);
                        command.ExecuteNonQuery();
                    }
                }
            }

            return result;
        }

        public override void ShowHelp()
        {
            Log.WriteLine();
            Log.WriteLine("CreateSqlLogin: Create a SQL login for the specified windows");
            Log.WriteLine("                   account. If a domain is not given, the local");
            Log.WriteLine("                   machine is assumed.");
            Log.WriteLine();
            Log.WriteLine("Usage:");
            Log.WriteLine("   Vibrio [flags] CreateSqlLogin <server> <account>");
            Log.WriteLine();
            Log.WriteLine("Return codes:");
            Log.WriteLine("   0 if operation is successful, non-zero otherwise.");
            Log.WriteLine();
            Log.WriteLine("Example:");
            Log.WriteLine("   Vibrio [flags] CreateSqlLogin XbcXblob01 _xbcweb");
            Log.WriteLine();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Vibrio\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Vibrio\CreateUser.cs ===
﻿using System;
using System.Collections.Generic;
using System.DirectoryServices;

namespace xonline.tools.Vibrio
{
    [Flags]
    public enum AdsUserFlags
    {
        Script = 1,                  // 0x1
        AccountDisabled = 2,              // 0x2
        HomeDirectoryRequired = 8,           // 0x8 
        AccountLockedOut = 16,             // 0x10
        PasswordNotRequired = 32,           // 0x20
        PasswordCannotChange = 64,           // 0x40
        EncryptedTextPasswordAllowed = 128,      // 0x80
        TempDuplicateAccount = 256,          // 0x100
        NormalAccount = 512,              // 0x200
        InterDomainTrustAccount = 2048,        // 0x800
        WorkstationTrustAccount = 4096,        // 0x1000
        ServerTrustAccount = 8192,           // 0x2000
        PasswordDoesNotExpire = 65536,         // 0x10000
        MnsLogonAccount = 131072,           // 0x20000
        SmartCardRequired = 262144,          // 0x40000
        TrustedForDelegation = 524288,         // 0x80000
        AccountNotDelegated = 1048576,         // 0x100000
        UseDesKeyOnly = 2097152,            // 0x200000
        DontRequirePreauth = 4194304,          // 0x400000
        PasswordExpired = 8388608,           // 0x800000
        TrustedToAuthenticateForDelegation = 16777216, // 0x1000000
        NoAuthDataRequired = 33554432         // 0x2000000
    }

    public class CreateUser : Command
    {
        public override string CommandName
        {
            get { return "CreateUser"; }
        }

        public override int Run(List<string> args)
        {
            int result = 0;

            if (args.Count != 2)
            {
                ShowHelp();
                result = 1024;
            }
            else
            {
                DirectoryEntry computer = new DirectoryEntry("WinNT://" + Environment.MachineName);
                AdsUserFlags flags = AdsUserFlags.PasswordDoesNotExpire | AdsUserFlags.PasswordCannotChange | AdsUserFlags.NormalAccount;

                if (!UserUtilities.AccountExists(args[0]))
                {
                    Log.WriteLine("Creating user {0}...", args[0]);
                    DirectoryEntry user = (DirectoryEntry)computer.Invoke("Create", "user", args[0]);
                    user.Invoke("SetPassword", args[1]);
                    user.Properties["UserFlags"].Value = flags;
                    user.CommitChanges();
                }
                else
                {
                    Log.WriteLine("User {0} already exists.", args[0]);
                }
            }

            return result;
        }

        public override void ShowHelp()
        {
            Log.WriteLine();
            Log.WriteLine("CreateUser: Creates a new user on the local server. It sets the");
            Log.WriteLine("                   password to never expire, and cannot be changed");
            Log.WriteLine("                   by the user.");
            Log.WriteLine();
            Log.WriteLine("Usage:");
            Log.WriteLine("   Vibrio [flags] CreateUser <name> <password>");
            Log.WriteLine();
            Log.WriteLine("Return codes:");
            Log.WriteLine("   0 if operation is successful, non-zero otherwise.");
            Log.WriteLine();
            Log.WriteLine("Example:");
            Log.WriteLine("   Vibrio CreateUser _xbcweb blahblah");
            Log.WriteLine();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Vibrio\InstallCustomCulture.cs ===
﻿using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;

namespace xonline.tools.Vibrio
{
    public class InstallCustomCulture : Command
    {
        public override string CommandName
        {
            get { return "InstallCustomCulture"; }
        }

        public override int Run(List<string> args)
        {
            int result = 0;
            if (args.Count != 1)
            {
                ShowHelp();
                result = 1024;
            }
            else
            {
                string ldmlFile = args[0];

                CultureAndRegionInfoBuilder builder = CultureAndRegionInfoBuilder.CreateFromLdml(ldmlFile);
                if (IsCultureBuiltIn(builder.CultureName))
                {
                    // don't do anything to built in cultures, we want to allow future versions of .NET to provide sanctioned cultures
                    result = 0;
                }
                else
                {
                    TryUninstallCulture(builder);

                    try
                    {
                        builder.Register();       
                    }
                    catch(Exception ex)
                    {
                        Log.WriteLine("An exception occured while trying to install the culture file {0}", ldmlFile);
                        Log.WriteLine(ex.Message);
                        Log.WriteLine(ex.StackTrace);
                        result = 2;    
                    }
                }

            }

            return result;
        }

        private static void TryUninstallCulture(CultureAndRegionInfoBuilder builder)
        {
            try
            {
                CultureAndRegionInfoBuilder.Unregister(builder.CultureName);
            }
            catch (ArgumentException)
            {
                // ArgumentException == the culture didn't exist. 
            }
        }

        public override void ShowHelp()
        {
            Log.WriteLine();
            Log.WriteLine("InstallCustomCulture: Add a custome .NET culture to the");
            Log.WriteLine("                   global store, as specified in an ldml file");
            Log.WriteLine();
            Log.WriteLine("Usage:");
            Log.WriteLine("   Vibrio [flags] InstallCustomCulture <ldmlfile>");
            Log.WriteLine();
            Log.WriteLine("Return codes:");
            Log.WriteLine("   0 if operation is successful, non-zero otherwise.");
            Log.WriteLine();
            Log.WriteLine("Example:");
            Log.WriteLine("   Vibrio [flags] InstallCustomCulture en-AE.ldml");
            Log.WriteLine();
        }

        private static bool IsCultureBuiltIn(string cultureName)
        {
            CultureInfo[] builtInCultures =
                CultureInfo.GetCultures(CultureTypes.FrameworkCultures);

            foreach (CultureInfo ci in builtInCultures)
            {
                if (ci.Name == cultureName)
                    return true;
            }
            return false;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Vibrio\DeleteUser.cs ===
﻿using System;
using System.Collections.Generic;
using System.DirectoryServices;

namespace xonline.tools.Vibrio
{
    public class DeleteUser : Command
    {
        public override string CommandName
        {
            get { return "DeleteUser"; }
        }

        public override int Run(List<string> args)
        {
            int result = 0;

            if (args.Count != 1)
            {
                ShowHelp();
                result = 1024;
            }
            else
            {
                if (UserUtilities.AccountExists(args[0]))
                {
                    Log.WriteLine("Deleting user {0}...", args[0]);
                    DirectoryEntry computer = new DirectoryEntry("WinNT://" + Environment.MachineName);
                    computer.Invoke("Delete", "user", args[0]);
                }
                else
                {
                    Log.WriteLine("The user {0} does not exist.", args[0]);
                }
            }

            return result;
        }

        public override void ShowHelp()
        {
            Log.WriteLine();
            Log.WriteLine("DeleteUser: Deletes the user from the local machine.");
            Log.WriteLine();
            Log.WriteLine("Usage:");
            Log.WriteLine("   Vibrio [flags] DeleteUser <name>");
            Log.WriteLine();
            Log.WriteLine("Return codes:");
            Log.WriteLine("   0 if operation is successful, non-zero otherwise.");
            Log.WriteLine();
            Log.WriteLine("Example:");
            Log.WriteLine("   Vibrio DeleteUser _xbcweb");
            Log.WriteLine();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Vibrio\FileUtilities.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Security.AccessControl;
using System.IO;

namespace xonline.tools.Vibrio
{
    public static class FileUtilities
    {
        public static void AddFolderPermission(string folderPath, string user, FileSystemRights rights, InheritanceFlags inheritanceFlags, PropagationFlags propogationFlags, AccessControlType accessControlType)
        {
            if ((!user.Contains("\\")) && (String.Compare(user, "Administrators", true) != 0))
            {
                user = Environment.MachineName + "\\" + user;
            }

            DirectoryInfo info = new DirectoryInfo(folderPath);
            DirectorySecurity security = info.GetAccessControl();
            security.AddAccessRule(new FileSystemAccessRule(user, rights, inheritanceFlags, propogationFlags, accessControlType));
            info.SetAccessControl(security);
        }

        public static void AddFilePermission(string filename, string identity, FileSystemRights rights, InheritanceFlags inheritanceFlags, PropagationFlags propogationFlags, AccessControlType accessControlType)
        {
            FileInfo info = new FileInfo(filename);
            FileSecurity security = info.GetAccessControl();
            security.AddAccessRule(new FileSystemAccessRule(identity, rights, inheritanceFlags, propogationFlags, accessControlType));
            info.SetAccessControl(security);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Vibrio\Logger.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;

namespace xonline.tools.Vibrio
{
    public class Logger
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="message"></param>
        public void Write(string message)
        {
            MessageEventArgs e = new MessageEventArgs(message);
            OnMessageNotifier(e);
        }

        public void WriteLine()
        {
            Write("\r\n");
        }

        public void WriteLine(string value)
        {
            Write(value);
            Write("\r\n");
        }

        public void WriteLine(string format, params object[] arg)
        {
            WriteLine(String.Format(format, arg));
        }

        /// <summary>
        /// 
        /// </summary>
        public event MessageEventHandler OnMessage;

        /// <summary>
        /// 
        /// </summary>
        /// <param name="e"></param>
        protected virtual void OnMessageNotifier(MessageEventArgs e)
        {
            if (OnMessage != null)
            {
                // Invokes the delegates. 
                OnMessage(this, e);
            }
        }
    }

    /// <summary>
    /// 
    /// </summary>
    public delegate void MessageEventHandler(object sender, MessageEventArgs e);

    /// <summary>
    /// 
    /// </summary>
    public class MessageEventArgs : EventArgs
    {
        private string message = "";

        /// <summary>
        /// 
        /// </summary>
        /// <param name="message"></param>
        public MessageEventArgs(string message)
        {
            Message = message;
        }

        /// <summary>
        /// 
        /// </summary>
        public string Message
        {
            get { return message; }
            set
            {
                if (value == null)
                {
                    message = "";
                }
                else
                {
                    message = value;
                }
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Vibrio\ImportLocalMachineCert.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Security.Cryptography.X509Certificates;

namespace xonline.tools.Vibrio
{
    public class ImportLocalMachineCert : Command
    {
        public override string CommandName
        {
            get { return "ImportLocalMachineCert"; }
        }

        public override int Run(List<string> args)
        {
            int result = 0;

            if (args.Count != 2)
            {
                ShowHelp();
                result = 1024;
            }
            else
            {
                string fileName = args[0];
                string password = args[1];

                if (File.Exists(fileName))
                {
                    // Load the certificate before impersonating the user
                    Log.WriteLine("Loading certificate...");
                    X509Certificate2 certificate;
                    try
                    {
                        if (String.IsNullOrEmpty(password))
                        {
                            //need to set the password to null explicitly to get past an error on Win2k3 "The specified network password is not correct."
                            password = null;
                            certificate = new X509Certificate2(fileName, password, X509KeyStorageFlags.MachineKeySet | X509KeyStorageFlags.PersistKeySet);
                        }
                        else
                        {
                            certificate = new X509Certificate2(fileName, password, X509KeyStorageFlags.MachineKeySet | X509KeyStorageFlags.PersistKeySet);
                        }
                    }
                    catch (Exception ex)
                    {
                        Log.WriteLine("Failed to load certificate: File: {0}.", fileName);
                        Log.WriteLine(ex.Message);
                        return 4;
                    }

                    X509Store certificateStore = new X509Store(StoreName.My, StoreLocation.LocalMachine);
                    try
                    {
                        Log.WriteLine("Adding certificate to local machine personal store...");
                        certificateStore.Open(OpenFlags.ReadWrite);
                        certificateStore.Add(certificate);
                    }
                    catch (Exception ex)
                    {
                        Log.WriteLine(ex.Message);
                        return 8;
                    }
                    finally
                    {
                        certificateStore.Close();
                    }
                }
                else
                {
                    Log.WriteLine("The certificate file {0} does not exist.", args[0]);
                    result = 2;
                }
            }

            return result;
        }

        public override void ShowHelp()
        {
            Log.WriteLine();
            Log.WriteLine("ImportLocalMachineCert: Import a certificate into the local machine");
            Log.WriteLine("                        personal certificate store.");
            Log.WriteLine();
            Log.WriteLine("Usage:");
            Log.WriteLine("   Vibrio [flags] ImportLocalMachineCert <certificateFile> <certificatePassword>");
            Log.WriteLine();
            Log.WriteLine("Return codes:");
            Log.WriteLine("   0 if operation is successful, non-zero otherwise.");
            Log.WriteLine();
            Log.WriteLine("Example:");
            Log.WriteLine("   Vibrio [flags] ImportLocalMachineCert \\\\XbcXblob01\\secure\\onebox-sps.xboxlive.com.pfx pass2");
            Log.WriteLine();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Vibrio\NpdbAddSettingOverride.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace xonline.tools.Vibrio
{
    public class NpdbAddSettingOverride : Command
    {
        public override string CommandName
        {
            get { return "NpdbAddSettingOverride"; }
        }

        public override int Run(List<string> args)
        {
            int result = 0;

            // override by default
            string overrideExistingValue = "1";

            if (args.Count < 6 || args.Count > 7)
            {
                ShowHelp();
                result = 1024;
            }
            else
            {
                if (args.Count == 7)
                {
                    overrideExistingValue = args[6];
                }

                string npdbServerName = args[0];
                string npdbDatabaseName = args[1];
                string setting = args[2];
                string value = args[3];
                 string environment = args[4];
                 string server = args[5];


                var npdbUtilities = new NpdbUtilities(npdbServerName, npdbDatabaseName, Log);
                npdbUtilities.AddSettingOverride(setting, value, environment,server, overrideExistingValue);
            }

            return result;
        }

        public override void ShowHelp()
        {
            Log.WriteLine();
            Log.WriteLine("NpdbAddSettingOverride: Add a setting to NPDB.");
            Log.WriteLine();
            Log.WriteLine("Usage:");
            Log.WriteLine("   Vibrio [flags] NpdbAddSettingOverride <npdbServer> <npdbDatabase> <setting> <value> <environment> <server> [overrideExistingValue]");
            Log.WriteLine();
            Log.WriteLine("Return codes:");
            Log.WriteLine("   0 if operation is successful, non-zero otherwise.");
            Log.WriteLine();
            Log.WriteLine("Example:");
            Log.WriteLine("   Vibrio [flags] NpdbAddSettingOverride MyNpdbServer01 NPDB lest_logroot xblob %computername% c:\\logroot 1");
            Log.WriteLine();
        }
    }

    public class NpdbAddMultiSettingOverride : Command
    {
        public override string CommandName
        {
            get { return "NpdbAddMultiSettingOverride"; }
        }

        public override int Run(List<string> args)
        {
            int result = 0;

            if (args.Count !=6)
            {
                ShowHelp();
                result = 1024;
            }
            else
            {

                string npdbServerName = args[0];
                string npdbDatabaseName = args[1];
                string multisetting = args[2];
                string value = args[3];
                string environment = args[4];
                string server = args[5];


                var npdbUtilities = new NpdbUtilities(npdbServerName, npdbDatabaseName, Log);
                npdbUtilities.AddMultiSettingOverride(multisetting, value, environment, server);
            }

            return result;
        }

        public override void ShowHelp()
        {
            Log.WriteLine();
            Log.WriteLine("NpdbAddMultiSettingOverride: Add a Multi setting to NPDB.");
            Log.WriteLine();
            Log.WriteLine("Usage:");
            Log.WriteLine("   Vibrio [flags] NpdbAddMultiSettingOverride <npdbServer> <npdbDatabase> <multisetting> <value> <environment> <server>");
            Log.WriteLine();
            Log.WriteLine("Return codes:");
            Log.WriteLine("   0 if operation is successful, non-zero otherwise.");
            Log.WriteLine();
            Log.WriteLine("Example:");
            Log.WriteLine("   Vibrio [flags] NpdbAddMultiSettingOverride MyNpdbServer01 NPDB aamodule_antidosIpOverrides xblob %computername% someValue");
            Log.WriteLine();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Vibrio\NpdbAddSetting.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace xonline.tools.Vibrio
{
    public class NpdbAddSetting : Command
    {
        public override string CommandName
        {
            get { return "NpdbAddSetting"; }
        }

        public override int Run(List<string> args)
        {
            int result = 0;

            // override by default
            string overrideExistingValue = "1";

            if (args.Count < 4 || args.Count > 5)
            {
                ShowHelp();
                result = 1024;
            }
            else
            {
                if (args.Count == 5)
                {
                    overrideExistingValue = args[4];
                }

                string npdbServerName = args[0];
                string npdbDatabaseName = args[1];
                string setting = args[2];
                string value = args[3];

                var npdbUtilities = new NpdbUtilities(npdbServerName, npdbDatabaseName, Log);
                npdbUtilities.AddSetting(setting, value, overrideExistingValue);
            }

            return result;
        }

        public override void ShowHelp()
        {
            Log.WriteLine();
            Log.WriteLine("NpdbAddSetting: Add a setting to NPDB.");
            Log.WriteLine();
            Log.WriteLine("Usage:");
            Log.WriteLine("   Vibrio [flags] NpdbAddSetting <npdbServer> <npdbDatabase> <setting> <value> [overrideExistingValue]");
            Log.WriteLine();
            Log.WriteLine("Return codes:");
            Log.WriteLine("   0 if operation is successful, non-zero otherwise.");
            Log.WriteLine();
            Log.WriteLine("Example:");
            Log.WriteLine("   Vibrio [flags] NpdbAddSetting MyNpdbServer01 NPDB leet_logroot c:\\logroot 1");
            Log.WriteLine();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Vibrio\ImportUserCert.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Security.Principal;
using System.Net.Sockets;
using System.Threading;
using System.Security.Cryptography.X509Certificates;
using System.Net;
using System.Net.Security;

namespace xonline.tools.Vibrio
{
    public class ImportUserCert : Command
    {
        public override string CommandName
        {
            get { return "ImportUserCert"; }
        }

        public override int Run(List<string> args)
        {
            int result = 0;

            if (args.Count != 4)
            {
                ShowHelp();
                result = 1024;
            }
            else
            {
                if (File.Exists(args[2]))
                {
                    string[] userName;
                    if (args[0].Contains("\\"))
                    {
                        userName = args[0].Split('\\');
                    }
                    else
                    {
                        userName = new string[2];
                        userName[0] = String.Empty;
                        userName[1] = args[0];
                    }

                    // Load the certificate before impersonating the user
                    Log.WriteLine("Loading certificate...");
                    X509Certificate2 certificate;
                    try
                    {
                        if (String.IsNullOrEmpty(args[3]))
                        {
                            certificate = new X509Certificate2(args[2]);
                        }
                        else
                        {
                            certificate = new X509Certificate2(args[2], args[3]);
                        }
                    }
                    catch (Exception ex)
                    {
                        Log.WriteLine("Failed to load certificate: File: {0}.", args[2]);
                        Log.WriteLine(ex.Message);
                        return 4;
                    }

                    WindowsIdentity identity = LogonUserTCPListen(userName[1], userName[0], args[1]);
                    using (WindowsImpersonationContext impersonationContext = identity.Impersonate())
                    {
                        try
                        {
                            Log.WriteLine("Adding certificate to current user personal store...");
                            X509Store certificateStore = new X509Store(StoreName.My, StoreLocation.CurrentUser);
                            certificateStore.Open(OpenFlags.ReadWrite);
                            certificateStore.Add(certificate);
                        }
                        catch (Exception ex)
                        {
                            Log.WriteLine(ex.Message);
                            return 8;
                        }
                    }
                }
                else
                {
                    Log.WriteLine("The certificate file {0} does not exist.", args[3]);
                    result = 2;
                }
            }

            return result;
        }

        // I found the following code at: http://pinvoke.net/default.aspx/advapi32.LogonUser
        private static WindowsIdentity LogonUserTCPListen(string userName, string domain, string password)
        {
            // need a full duplex stream - loopback is easiest way to get that
            TcpListener tcpListener = new TcpListener(IPAddress.Loopback, 0);
            tcpListener.Start();
            ManualResetEvent done = new ManualResetEvent(false);

            WindowsIdentity id = null;
            tcpListener.BeginAcceptTcpClient(delegate(IAsyncResult asyncResult)
            {
                try
                {
                    using (NegotiateStream serverSide = new NegotiateStream(tcpListener.EndAcceptTcpClient(asyncResult).GetStream()))
                    {
                        serverSide.AuthenticateAsServer(CredentialCache.DefaultNetworkCredentials, ProtectionLevel.None, TokenImpersonationLevel.Impersonation);
                        id = (WindowsIdentity)serverSide.RemoteIdentity;
                    }
                }
                catch
                { 
                    id = null; 
                }
                finally
                { 
                    done.Set(); 
                }
            }, null);

            using (NegotiateStream clientSide = new NegotiateStream(new TcpClient("localhost", ((IPEndPoint)tcpListener.LocalEndpoint).Port).GetStream()))
            {
                try
                {
                    clientSide.AuthenticateAsClient(new NetworkCredential(userName, password, domain),
                     "", ProtectionLevel.None, TokenImpersonationLevel.Impersonation);
                }
                catch
                { 
                    id = null; 
                } //When the authentication fails it throws an exception
            }
            tcpListener.Stop();
            done.WaitOne(); //Wait until we really have the id populated to continue
            return id;
        }


        public override void ShowHelp()
        {
            Log.WriteLine();
            Log.WriteLine("ImportUserCert: Import a certificate into the given users");
            Log.WriteLine("                   certificate store.");
            Log.WriteLine();
            Log.WriteLine("Usage:");
            Log.WriteLine("   Vibrio [flags] ImportUserCert <user> <password> <certificateFile> <certificatePassword>");
            Log.WriteLine();
            Log.WriteLine("Return codes:");
            Log.WriteLine("   0 if operation is successful, non-zero otherwise.");
            Log.WriteLine();
            Log.WriteLine("Example:");
            Log.WriteLine("   Vibrio [flags] ImportUserCert _xbluser password \\\\XbcXblob01\\secure\\onebox-sps.xboxlive.com.pfx pass2");
            Log.WriteLine();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Vibrio\NpdbRegisterWebsite.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace xonline.tools.Vibrio
{
    public class NpdbRegisterWebsite : Command
    {
        public override string CommandName
        {
            get { return "NpdbRegisterWebsite"; }
        }

        public override int Run(List<string> args)
        {
            int result = 0;
            if (args.Count < 6)
            {
                ShowHelp();
                result = 1024;
            }
            else
            {
                string npdbServerName = args[0];
                string npdbDatabaseName = args[1];
                string interfaceName = args[2];
                string server = args[3];
                string port = args[4];
                string environment = args[5];

                string baseDomain = null;
                if (args.Count > 6)
                {
                    baseDomain = args[6];
                }

                string subDomain = null;
                if (args.Count > 7)
                {
                    subDomain = args[7];
                }

                string protocol = null;
                if(args.Count > 8)
                {
                    protocol = args[8];
                }

                string sslPort = null;
                if (args.Count > 9)
                {
                    ushort parsedSslPort;
                    if (UInt16.TryParse(args[9], out parsedSslPort))
                    {
                        // Only pass in the ssl port if a real one was specified
                        sslPort = args[9];
                    }
                }

                string installUnit = "NoInstallUnit";

                string dnsName = String.Empty;
                if (!String.IsNullOrEmpty(subDomain))
                {
                    dnsName = String.Format("{0}.{1}", subDomain, baseDomain);
                }

                var npdbUtilities = new NpdbUtilities(npdbServerName, npdbDatabaseName, Log);
                npdbUtilities.AddComponent(interfaceName, installUnit);

                ushort parsedPort;
                if (UInt16.TryParse(port, out parsedPort))
                {
                    if(string.IsNullOrEmpty(protocol))
                    {
                        protocol = "http";
                    }
                    npdbUtilities.AddWebsiteInterface(interfaceName, protocol, port, dnsName);
                    npdbUtilities.AddWebsiteVirtualInterface(interfaceName, "80", sslPort, dnsName);
                    // We have to have an entry in the t_site_virtual_interface_ips table for the virtual interface to laod
                    // Since we don't use the vip, put garbage in there for now.
                    npdbUtilities.AddWebsiteVirtualInterfaceIp(environment, interfaceName, "222.222.222.222");
                    npdbUtilities.AddServerInterface(environment, server, interfaceName);
                }
                else
                {
                    Log.WriteLine("The port '{0}' is not valid.  It must be between 1 - 65535.", port);
                    return 2;
                }
            }

            return result;
        }

        public override void ShowHelp()
        {
            Log.WriteLine();
            Log.WriteLine("NpdbRegisterWebsite: Register a new component and interface for the");
            Log.WriteLine("                     given website and port, then register the server");
            Log.WriteLine("                     for that interface.  Info1 is optionally populated");
            Log.WriteLine("                     with the FQDN for the site.");
            Log.WriteLine();
            Log.WriteLine("Usage:");
            Log.WriteLine("   Vibrio [flags] NpdbRegisterWebsite <npdbServer> <npdbDatabase> <interfaceName> <server> <port> <environment> <baseDomain> <subDomain> <protocol> <sslPort>");
            Log.WriteLine();
            Log.WriteLine("Return codes:");
            Log.WriteLine("   0 if operation is successful, non-zero otherwise.");
            Log.WriteLine();
            Log.WriteLine("Example:");
            Log.WriteLine("   Vibrio [flags] NpdbRegisterWebsite MyNpdbServer01 NPDB cosmos_authoring IisServer01 61101 livenoob xboxlive.com http 443");
            Log.WriteLine();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Vibrio\NpdbRegisterPlatformComponent.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace xonline.tools.Vibrio
{
    public class NpdbRegisterPlatformComponent : Command
    {
        public override string CommandName
        {
            get { return "NpdbRegisterPlatformComponent"; }
        }

        public override int Run(List<string> args)
        {
            int result = 0;
            if (args.Count < 3)
            {
                ShowHelp();
                result = 1024;
            }
            else
            {
                string npdbServerName = args[0];
                string npdbDatabaseName = args[1];
                string interfaceName = args[2];
                string installUnit = "NoInstallUnit";

                var npdbUtilities = new NpdbUtilities(npdbServerName, npdbDatabaseName, Log);
                npdbUtilities.AddComponent(interfaceName, installUnit);
            }

            return result;
        }

        public override void ShowHelp()
        {
            Log.WriteLine();
            Log.WriteLine("NpdbRegisterPlatformComponent: Register a new component in the platform NPDB for the");
            Log.WriteLine("                               given interface.");
            Log.WriteLine();
            Log.WriteLine("Usage:");
            Log.WriteLine("   Vibrio [flags] NpdbRegisterPlatformComponent <npdbServer> <npdbDatabase> <interfaceName>");
            Log.WriteLine();
            Log.WriteLine("Return codes:");
            Log.WriteLine("   0 if operation is successful, non-zero otherwise.");
            Log.WriteLine();
            Log.WriteLine("Example:");
            Log.WriteLine("   Vibrio [flags] NpdbRegisterPlatformComponent MyXblob01 NPDB cosmos_authoring");
            Log.WriteLine();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Vibrio\RegisterNpdbDatabase.cs ===
﻿using System.Collections.Generic;

namespace xonline.tools.Vibrio
{
    public class RegisterNpdbDatabase : Command
    {
        public override string CommandName
        {
            get { return "RegisterNpdbDatabase"; }
        }

        public override int Run(List<string> args)
        {
            int result = 0;
            if (args.Count < 6)
            {
                ShowHelp();
                result = 1024;
            }
            else
            {
                string npdbServerName = args[0];
                string npdbDatabaseName = args[1];
                string interfaceName = args[2];
                string databaseName = args[3];
                string databaseServer = args[4];
                string environment = args[5];
                string dnsName = "";
                if (args.Count >= 7)
                {
                    dnsName = args[6];
                }
                string installUnit = "NoInstallUnit";

                var npdbUtilities = new NpdbUtilities(npdbServerName, npdbDatabaseName, Log);
                npdbUtilities.AddComponent(interfaceName, installUnit);
                if (string.IsNullOrEmpty(dnsName))
                {
                    npdbUtilities.AddDatabaseInterface(interfaceName, databaseName);
                }
                else
                {
                    npdbUtilities.AddDatabaseInterface(interfaceName, databaseName, dnsName);
                }
                npdbUtilities.AddServerInterface(environment, databaseServer, interfaceName);
            }

            return result;
        }

        public override void ShowHelp()
        {
            Log.WriteLine();
            Log.WriteLine("RegisterNpdbDatabase: Register a new component and interface for the");
            Log.WriteLine("                      given database, then register the server for");
            Log.WriteLine("                      that inteface.");
            Log.WriteLine();
            Log.WriteLine("Usage:");
            Log.WriteLine("   Vibrio [flags] RegisterNpdbDatabase <npdbServer> <npdbDatabase> <interfaceName> <databaseName> <databaseServer> <environment> [<dnsName>]");
            Log.WriteLine();
            Log.WriteLine("Return codes:");
            Log.WriteLine("   0 if operation is successful, non-zero otherwise.");
            Log.WriteLine();
            Log.WriteLine("Example:");
            Log.WriteLine("   Vibrio [flags] RegisterNpdbServer MyNpdbServer01 NPDB cosmos_contentstore_db cosmos_contentstore CosmosServer01 livenoob cosmos_cs_db.test.live");
            Log.WriteLine();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Vibrio\NpdbRemoveServerInterface.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace xonline.tools.Vibrio
{
    public class NpdbRemoveServerInterface : Command
    {
        public override string CommandName
        {
            get { return "NpdbRemoveServerInterface"; }
        }

        public override int Run(List<string> args)
        {
            int result = 0;
            if (args.Count < 5)
            {
                ShowHelp();
                result = 1024;
            }
            else
            {
                string npdbServerName = args[0];
                string npdbDatabaseName = args[1];
                string interfaceName = args[2];
                string server = args[3];
                string environment = args[4];

                var npdbUtilities = new NpdbUtilities(npdbServerName, npdbDatabaseName, Log);
                npdbUtilities.RemoveServerInterface(environment, server, interfaceName);
            }

            return result;
        }

        public override void ShowHelp()
        {
            Log.WriteLine();
            Log.WriteLine("NpdbRemoveServerInterface: Remove the server interface from the given");
            Log.WriteLine("                           environment.");
            Log.WriteLine();
            Log.WriteLine("Usage:");
            Log.WriteLine("   Vibrio [flags] NpdbRemoveServerInterface <npdbServer> <npdbDatabase> <interfaceName> <server> <environment>");
            Log.WriteLine();
            Log.WriteLine("Return codes:");
            Log.WriteLine("   0 if operation is successful, non-zero otherwise.");
            Log.WriteLine();
            Log.WriteLine("Example:");
            Log.WriteLine("   Vibrio [flags] NpdbRemoveServerInterface MyNpdbServer01 NPDB cosmos_authoring IisServer01 livenoob");
            Log.WriteLine();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Vibrio\NpdbRegisterInterface.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace xonline.tools.Vibrio
{
    public class NpdbRegisterInterface : Command
    {
        public override string CommandName
        {
            get { return "NpdbRegisterInterface"; }
        }

        public override int Run(List<string> args)
        {
            int result = 0;
            if (args.Count < 6)
            {
                ShowHelp();
                result = 1024;
            }
            else
            {
                string npdbServerName = args[0];
                string npdbDatabaseName = args[1];
                string interfaceName = args[2];
                string componentName = args[3];
                bool middle_tier = true;  
                if (!string.IsNullOrEmpty(args[4]) && string.Compare(args[4], "internet_tier", true) == 0)
                {
                    middle_tier = false; 
                }

                string server = args[5];
                string port = args[6];
                string siteId = args[7]; 
                string environment = args[8];


                string baseDomain = null;
                if (args.Count > 9)
                {
                    baseDomain = args[9];
                }

                string subDomain = null;
                if (args.Count > 10)
                {
                    subDomain = args[10];
                }

                string protocol = null;
                if(args.Count > 11)
                {
                    protocol = args[11];
                }

                string sslPort = null;
                if (args.Count > 12)
                {
                    ushort parsedSslPort;
                    if (UInt16.TryParse(args[12], out parsedSslPort))
                    {
                        // Only pass in the ssl port if a real one was specified
                        sslPort = args[12];
                    }
                }

                string dnsName = String.Empty;
                if (!String.IsNullOrEmpty(subDomain))
                {
                    dnsName = String.Format("{0}.{1}", subDomain, baseDomain);
                }

                var npdbUtilities = new NpdbUtilities(npdbServerName, npdbDatabaseName, Log);
                
                ushort parsedPort;
                if (UInt16.TryParse(port, out parsedPort))
                {
                    if(string.IsNullOrEmpty(protocol))
                    {
                        protocol = "http";
                    }
                    if (middle_tier)
                    {
                        npdbUtilities.AddInternalInterfaceToSite(interfaceName, componentName, protocol, port, siteId, dnsName);
                    }
                    else
                    {
                        npdbUtilities.AddPublicInterfaceToSite(interfaceName, componentName, protocol, port, siteId, dnsName);
                    }

                    npdbUtilities.AddWebsiteVirtualInterface(interfaceName, port, sslPort, dnsName);
                    // We have to have an entry in the t_site_virtual_interface_ips table for the virtual interface to laod
                    // Since we don't use the vip, put garbage in there for now.
                    npdbUtilities.AddWebsiteVirtualInterfaceIp(environment, interfaceName, "222.222.222.222");
                    npdbUtilities.AddServerInterface(environment, server, interfaceName);
                }
                else
                {
                    Log.WriteLine("The port '{0}' is not valid.  It must be between 1 - 65535.", port);
                    return 2;
                }
            }

            return result;
        }

        public override void ShowHelp()
        {
            Log.WriteLine();
            Log.WriteLine("NpdbRegisterInterface: Register a new interface to a component for the");
            Log.WriteLine("                     given website and port, then register the server");
            Log.WriteLine("                     for that interface.  Info1 is optionally populated");
            Log.WriteLine("                     with the FQDN for the site.");
            Log.WriteLine();
            Log.WriteLine("Usage:");
            Log.WriteLine("   Vibrio [flags] NpdbRegisterInterface <npdbServer> <npdbDatabase> <interfaceName> <componentName> internet_tier|middle_tier  <server> <port> <environment> <baseDomain> <subDomain> <protocol> <sslPort>");
            Log.WriteLine();
            Log.WriteLine("Return codes:");
            Log.WriteLine("   0 if operation is successful, non-zero otherwise.");
            Log.WriteLine();
            Log.WriteLine("Example:");
            Log.WriteLine("   Vibrio [flags] NpdbRegisterInterface MyNpdbServer01 NPDB cosmos_authoring cosmos_comp internet_tier IisServer01 61101 livenoob xboxlive.com http 443");
            Log.WriteLine();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Vibrio\RegisterCertificateThumbprint.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Security.Cryptography.X509Certificates;

namespace xonline.tools.Vibrio
{
    public class RegisterCertificateThumbprint : Command
    {
        public override string CommandName
        {
            get { return "RegisterCertificateThumbprint"; }
        }

        public override int Run(List<string> args)
        {
            int result = 0;
            if ((args.Count < 4) || (args.Count > 5))
            {
                ShowHelp();
                result = 1024;
            }
            else
            {
                string npdbServerName = args[0];
                string npdbDatabaseName = args[1];
                string setting = args[2];
                string path = args[3];
                string password = null;
                if (args.Count == 5)
                {
                    password = args[4];
                }

                if (File.Exists(path))
                {
                    // Load the certificate before impersonating the user
                    Log.WriteLine("Loading certificate...");
                    X509Certificate2 certificate;
                    try
                    {
                        if (String.IsNullOrEmpty(password))
                        {
                            certificate = new X509Certificate2(path);
                        }
                        else
                        {
                            certificate = new X509Certificate2(path, password);
                        }
                    }
                    catch (Exception ex)
                    {
                        Log.WriteLine("Failed to load certificate: File: {0}.", path);
                        Log.WriteLine(ex.Message);
                        return 4;
                    }

                    var npdbUtilities = new NpdbUtilities(npdbServerName, npdbDatabaseName, Log);
                    npdbUtilities.AddSetting(setting, certificate.Thumbprint, "1");
                }
                else
                {
                    Log.WriteLine("The certificate file {0} does not exist.", path);
                    result = 2;
                }
            }

            return result;
        }


        public override void ShowHelp()
        {
            Log.WriteLine();
            Log.WriteLine("RegisterCertificateThumbprint:");
            Log.WriteLine("     Save the certificate's thumbprint to the specified NPDB setting.");
            Log.WriteLine();
            Log.WriteLine("Usage:");
            Log.WriteLine("   Vibrio [flags] RegisterCertificateThumbprint <npdbServer> <npdbDatabase> <setting> <certPath> <certPassword>");
            Log.WriteLine();
            Log.WriteLine("Return codes:");
            Log.WriteLine("   0 if operation is successful, non-zero otherwise.");
            Log.WriteLine();
            Log.WriteLine("Example:");
            Log.WriteLine("   Vibrio [flags] RegisterCertificateThumbprint MyServer LIVEN_NPDB leet_Certficiate_Thumbprint C:\\cert.pfx password");
            Log.WriteLine();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Vibrio\RegisterNpdbServer.cs ===
﻿using System;
using System.Collections.Generic;
using System.Net;

namespace xonline.tools.Vibrio
{
    public class RegisterNpdbServer : Command
    {
        public override string CommandName
        {
            get { return "RegisterNpdbServer"; }
        }

        public override int Run(List<string> args)
        {
            int result = 0;
            if (args.Count < 8)
            {
                ShowHelp();
                result = 1024;
            }
            else
            {
                string npdbServerName = args[0];
                string npdbDatabaseName = args[1];
                string environment = args[2];
                string serverName = args[3];
                string siteId = args[4];
                string serverState = args[5];
                string internetTierNicIP = args[6];
                string middleTierNicIP = args[7];

                IPAddress nicAddress;

                var npdbUtilities = new NpdbUtilities(npdbServerName, npdbDatabaseName, Log);

                var exisingInetIP = npdbUtilities.GetServerNic(environment, serverName, "internet_tier");
                var exisingMiddleIP = npdbUtilities.GetServerNic(environment, serverName, "middle_tier");

                internetTierNicIP = MergeIpWithExisting(internetTierNicIP, exisingInetIP);
                middleTierNicIP = MergeIpWithExisting(middleTierNicIP, exisingMiddleIP);

                npdbUtilities.AddServer(environment, serverName, siteId, serverState);
                // Add internet_tier NIC if necessary
                if (IPAddress.TryParse(internetTierNicIP, out nicAddress))
                {
                    npdbUtilities.AddServerNic(environment, serverName, "internet_tier", nicAddress.ToString());
                }
                if (IPAddress.TryParse(middleTierNicIP, out nicAddress))
                {
                    npdbUtilities.AddServerNic(environment, serverName, "middle_tier", nicAddress.ToString());
                }
            }

            return result;
        }

        private string MergeIpWithExisting(string newIP, string existingIP)
        {
            if (String.IsNullOrEmpty(existingIP))
            {
                return newIP;
            }
            if (String.IsNullOrEmpty(newIP))
            {
                return existingIP;
            }
            if (newIP.Trim().Equals("127.0.0.1", StringComparison.OrdinalIgnoreCase))
            {
                return existingIP;
            }
            return newIP;
        }

        public override void ShowHelp()
        {
            Log.WriteLine();
            Log.WriteLine("RegisterNpdbServer: Register a new server in NPDB and add server NIC ");
            Log.WriteLine("                    registrations associated with that server.  If NIC");
            Log.WriteLine("                    addresses are provided, they will be registered appropriately.");
            Log.WriteLine("                    Calling this operation against an existing server will update ");
            Log.WriteLine("                    the site ID, server state, and NIC information.");
            Log.WriteLine();
            Log.WriteLine("Usage:");
            Log.WriteLine("   Vibrio [flags] RegisterNpdbServer <npdbServer> <npdbDatabase> <environment> <server> <siteId> <serverState> [<intenet tier nicIp>] [<middle tier nicIp>]");
            Log.WriteLine();
            Log.WriteLine("Return codes:");
            Log.WriteLine("   0 if operation is successful, non-zero otherwise.");
            Log.WriteLine();
            Log.WriteLine("Example:");
            Log.WriteLine("   Vibrio [flags] RegisterNpdbServer MyNpdbServer01 NPDB testnet LeetServer001 1 online 127.0.0.1 127.0.0.2");
            Log.WriteLine();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Vibrio\NpdbUtilities.cs ===
﻿using System;
using System.Data.SqlClient;
using System.Data;
using xonline.common.config;

namespace xonline.tools.Vibrio
{
    public class NpdbUtilities
    {
        public string Server { get; set; }
        public string Database { get; set; }
        public Logger Log { get; set; }

        public NpdbUtilities(string server, string database, Logger log)
        {
            Server = server;
            Database = database;
            Log = log;
        }

        public void AddComponent(string interfaceName, string installUnit)
        {
            using (SqlConnection connection = Command.GetSqlConnection(Server, Database))
            {
                using (SqlCommand command = new SqlCommand())
                {
                    command.Connection = connection;
                    connection.Open();

                    string sprocName = "p_config_add_component";
                    Log.WriteLine(String.Format("exec {0} \t@component='{1}', @installUnit='{2}', @overwriteExistingValue=1",
                        sprocName, interfaceName, installUnit));

                    command.CommandType = CommandType.StoredProcedure;
                    command.CommandText = sprocName;
                    command.Parameters.AddWithValue("@component", interfaceName);
                    command.Parameters.AddWithValue("@installUnit", installUnit);
                    command.Parameters.AddWithValue("@overwriteExistingValue", "1");
                    command.ExecuteNonQuery();
                }
            }
        }

        public void AddDatabaseInterface(string interfaceName, string databaseName)
        {
            AddInterface(interfaceName, interfaceName, "middle_tier", "sql", databaseName, null, null, null);
        }

        public void AddDatabaseInterface(string interfaceName, string databaseName, string dnsName)
        {
            AddInterface(interfaceName,  interfaceName, "middle_tier", "sql", databaseName, null, null, dnsName);
        }

        public void AddWebsiteInterface(string interfaceName, string protocol, string port, string dnsName)
        {
            // the interface name and component name are the same in normal cases. 
            AddInterface(interfaceName, interfaceName, "internet_tier", protocol, null, port, port, dnsName);
        }

        public void AddPublicInterfaceToSite(string interfaceName, string componentName, string protocol, string port, string siteId, string dnsName)
        {
            // Explicitly set the componentname. 
            AddInterface(interfaceName, componentName, "internet_tier", protocol, null, port, siteId, dnsName);
        }

        public void AddInternalInterfaceToSite(string interfaceName, string componentName, string protocol, string port, string siteId, string dnsName)
        {
            // Explicitly set the componentname. 
            AddInterface(interfaceName, componentName, "middle_tier", protocol, null, port, siteId, dnsName);
        }

        private void AddInterface(string interfaceName, string componentName, string nicRole, string protocol, string databaseName, string port,string siteId,  string info1)
        {
            // Hardcoding the timeout for now to make it non-zero.
            // If we need to control it in the future, this can be made a parameter.
            var timeout = 30000;

            using (SqlConnection connection = Command.GetSqlConnection(Server, Database))
            {
                using (SqlCommand command = new SqlCommand())
                {
                    command.Connection = connection;
                    connection.Open();

                    string sprocName = "p_config_add_interface";
                    if (protocol.Equals("sql", StringComparison.OrdinalIgnoreCase))
                    {
                        Log.WriteLine(String.Format("exec {0} \t@interface='{1}', @component='{2}', @nicRole='{3}', @protocol='{4}', @dbName='{5}', @timeout={6}, @overwriteExistingValue=1",
                            sprocName, interfaceName, componentName, nicRole, protocol, databaseName, timeout));
                    }
                    else
                    {
                        if (String.IsNullOrEmpty(info1))
                        {
                            Log.WriteLine(String.Format("exec {0} \t@interface='{1}', @component='{2}', @nicRole='{3}', @protocol='{4}', @port='{5}', @vsiteid='{6}', @overwriteExistingValue=1",
                                sprocName, interfaceName, componentName, nicRole, protocol, port, siteId));
                        }
                        else
                        {
                            Log.WriteLine(String.Format("exec {0} \t@interface='{1}', @component='{2}', @nicRole='{3}', @protocol='{4}', @port='{5}', @vsiteid='{6}', @info1='{7}', @overwriteExistingValue=1",
                                sprocName, interfaceName, componentName, nicRole, protocol, port, siteId, info1));
                        }
                    }

                    command.CommandType = CommandType.StoredProcedure;
                    command.CommandText = sprocName;
                    command.Parameters.AddWithValue("@interface", interfaceName);
                    command.Parameters.AddWithValue("@component", componentName);
                    command.Parameters.AddWithValue("@nicRole", nicRole);
                    command.Parameters.AddWithValue("@protocol", protocol);
                    if (protocol.Equals("sql", StringComparison.OrdinalIgnoreCase))
                    {
                        command.Parameters.AddWithValue("@dbName", databaseName);
                    }
                    else
                    {
                        command.Parameters.AddWithValue("@port", port);
                        command.Parameters.AddWithValue("@vsiteid", siteId);
                    }
                    if (!String.IsNullOrEmpty(info1))
                    {
                        command.Parameters.AddWithValue("@info1", info1);
                    }
                    command.Parameters.AddWithValue("@timeout", timeout);
                    command.Parameters.AddWithValue("@overwriteExistingValue", "1");
                    command.ExecuteNonQuery();
                }
            }
        }

        public void AddWebsiteVirtualInterface(string interfaceName, string port, string sslPort, string dnsName)
        {
            AddVirtualInterface(interfaceName, port, dnsName, sslPort);
        }

        private void AddVirtualInterface(string interfaceName, string port, string info1, string info2)
        {
            int timeout = 30000;
            using (SqlConnection connection = Command.GetSqlConnection(Server, Database))
            {
                using (SqlCommand command = new SqlCommand())
                {
                    command.Connection = connection;
                    connection.Open();

                    Log.WriteLine(String.Format("exec p_config_add_virtual_interface \t@virtualInterface='{0}', @interface='{1}', @port='{2}', @info1='{3}', @info2='{4}', @overwriteExistingValue=1",
                        interfaceName, interfaceName, port, info1, info2));

                    command.CommandType = CommandType.StoredProcedure;
                    command.CommandText = "p_config_add_virtual_interface";
                    command.Parameters.AddWithValue("@interface", interfaceName);
                    command.Parameters.AddWithValue("@virtualInterface", interfaceName);
                    command.Parameters.AddWithValue("@port", port);
                    command.Parameters.AddWithValue("@timeout", timeout);
                    if (!String.IsNullOrEmpty(info1))
                    {
                        command.Parameters.AddWithValue("@info1", info1);
                    }
                    if (!String.IsNullOrEmpty(info2))
                    {
                        command.Parameters.AddWithValue("@info2", info2);
                    }
                    command.Parameters.AddWithValue("@overwriteExistingValue", "1");
                    command.ExecuteNonQuery();
                }
            }
        }

        public void AddWebsiteVirtualInterfaceIp(string environment, string interfaceName, string ip)
        {
            using (SqlConnection connection = Command.GetSqlConnection(Server, Database))
            {
                using (SqlCommand command = new SqlCommand())
                {
                    command.Connection = connection;
                    connection.Open();

                    Log.WriteLine(String.Format("exec p_config_add_site_virtual_interface_ip \t@environment={0}, @siteId=1, @virtualInterface='{1}', @ip='{2}', @overwriteExistingValue=1",
                        environment, interfaceName, ip));

                    command.CommandType = CommandType.StoredProcedure;
                    command.CommandText = "p_config_add_site_virtual_interface_ip";
                    command.Parameters.AddWithValue("@environment", environment);
                    command.Parameters.AddWithValue("@siteId", 1);
                    command.Parameters.AddWithValue("@virtualInterface", interfaceName);
                    command.Parameters.AddWithValue("@ip", ip);
                    command.Parameters.AddWithValue("@overwriteExistingValue", "1");
                    command.ExecuteNonQuery();
                }
            }
        }

        public void AddServerInterface(string environment, string server, string interfaceName)
        {
            ConfigInstance config = ConfigInstance.Create(Server, Database);
            config.AddServerInterfaceConfiguration(environment, server, interfaceName);
        }

        public void RemoveServerInterface(string environment, string server, string interfaceName)
        {
            ConfigInstance config = ConfigInstance.Create(Server, Database);
            config.RemoveServerInterfaceConfiguration(environment, server, interfaceName);
        }

        public void AddServer(string environment, string server, string siteId, string serverState)
        {
            using (SqlConnection connection = Command.GetSqlConnection(Server, Database))
            {
                using (SqlCommand command = new SqlCommand())
                {
                    command.Connection = connection;
                    connection.Open();

                    string sprocName = "p_config_add_server";
                    Log.WriteLine(String.Format("exec {0} \t@environment='{1}', @server='{2}', @siteId={3}, @serverState='{4}', @serverId='1', @overwriteExistingValue=1, @serverType='DEPRECATED'",
                        sprocName, environment, server, siteId, serverState));

                    command.CommandType = CommandType.StoredProcedure;
                    command.CommandText = sprocName;
                    command.Parameters.AddWithValue("@environment", environment);
                    command.Parameters.AddWithValue("@server", server);
                    command.Parameters.AddWithValue("@siteId", siteId);
                    command.Parameters.AddWithValue("@serverState", serverState);
                    command.Parameters.AddWithValue("@serverId", 1);
                    command.Parameters.AddWithValue("@overwriteExistingValue", 1);
                    command.Parameters.AddWithValue("@serverType", "DEPRECATED");
                    command.ExecuteNonQuery();
                }
            }
        }

        public void AddServerNic(string environment, string server, string nicRole, string ip)
        {
            using (SqlConnection connection = Command.GetSqlConnection(Server, Database))
            {
                using (SqlCommand command = new SqlCommand())
                {
                    command.Connection = connection;
                    connection.Open();

                    string sprocName = "p_config_add_server_nic";
                    Log.WriteLine(String.Format("exec {0} @environment='{1}', @server='{2}', @nicRole='internet_tier', @ip='{3}', @overwriteExistingValue=1",
                        sprocName, environment, server, ip));

                    command.CommandType = CommandType.StoredProcedure;
                    command.CommandText = sprocName;
                    command.Parameters.AddWithValue("@environment", environment);
                    command.Parameters.AddWithValue("@server", server);
                    command.Parameters.AddWithValue("@nicRole", nicRole);
                    command.Parameters.AddWithValue("@ip", ip);
                    command.Parameters.AddWithValue("overwriteExistingValue", 1);
                    command.ExecuteNonQuery();
                }
            }
        }

        public void AddSetting(string setting, string value, string overrideExistingValue)
        {
            using (SqlConnection connection = Command.GetSqlConnection(Server, Database))
            {
                using (SqlCommand command = new SqlCommand())
                {
                    command.Connection = connection;
                    connection.Open();

                    string sprocName = "p_config_add_setting";
                    Log.WriteLine(String.Format("exec {0} \t@setting='{1}', @value='{2}', @overwriteExistingValue={3}",
                        sprocName, setting, value, overrideExistingValue));

                    command.CommandType = CommandType.StoredProcedure;
                    command.CommandText = sprocName;
                    command.Parameters.AddWithValue("@setting", setting);
                    command.Parameters.AddWithValue("@value", value);
                    command.Parameters.AddWithValue("@overwriteExistingValue", overrideExistingValue);
                    command.ExecuteNonQuery();
                }
            }
        }

        public void AddSettingOverride(string setting, string value, string environment,string server, string overrideExistingValue)
        {
            using (SqlConnection connection = Command.GetSqlConnection(Server, Database))
            {
                using (SqlCommand command = new SqlCommand())
                {
                    command.Connection = connection;
                    connection.Open();

                    string sprocName = "p_config_add_setting_override";
                    Log.WriteLine(String.Format("exec {0} \t@setting='{1}', @value='{2}', @environment={3}, @server='{4}', @overwriteExistingValue={5}",
                        sprocName, setting, value,environment,server, overrideExistingValue));

                    command.CommandType = CommandType.StoredProcedure;
                    command.CommandText = sprocName;
                    command.Parameters.AddWithValue("@setting", setting);
                    command.Parameters.AddWithValue("@value", value);
                    command.Parameters.AddWithValue("@environment", environment);
                    command.Parameters.AddWithValue("@server", server);
                    command.Parameters.AddWithValue("@overwriteExistingValue", overrideExistingValue);
                    command.ExecuteNonQuery();
                }
            }
        }

        public void AddMultiSettingOverride(string multisetting, string value, string environment, string server)
        {
            using (SqlConnection connection = Command.GetSqlConnection(Server, Database))
            {
                using (SqlCommand command = new SqlCommand())
                {
                    command.Connection = connection;
                    connection.Open();

                    string sprocName = "p_config_add_multisetting_override";
                    Log.WriteLine(String.Format("exec {0} \t@multisetting='{1}', @value='{2}', @environment={3}, @server='{4}'",
                        sprocName, multisetting, value, environment, server));

                    command.CommandType = CommandType.StoredProcedure;
                    command.CommandText = sprocName;
                    command.Parameters.AddWithValue("@multisetting", multisetting);
                    command.Parameters.AddWithValue("@value", value);
                    command.Parameters.AddWithValue("@environment", environment);
                    command.Parameters.AddWithValue("@server", server);
                    command.ExecuteNonQuery();
                }
            }
        }


        public void AddUpdateActiveAuthPolicy(string environment, string policyKey, string authPolicy, bool requiresAuth, bool isSsl, string authHeader)
        {
            using (SqlConnection connection = Command.GetSqlConnection(Server, Database))
            {
                using (SqlCommand command = new SqlCommand())
                {
                    command.Connection = connection;
                    connection.Open();

                    string sprocName = "p_activeauth_policies_update";
                    Log.WriteLine(String.Format("exec {0} @vc_environment='{1}', @vc_policy_key={2}, @vc_auth_policy={3}, @b_requires_authentication={4},@b_ssl={5},@b_antidos=0,@vc_auth_header={6}",
                        sprocName, environment, policyKey, authPolicy, requiresAuth, isSsl, authHeader));

                    command.CommandType = CommandType.StoredProcedure;
                    command.CommandText = sprocName;
                    command.Parameters.AddWithValue("@vc_environment", environment);
                    command.Parameters.AddWithValue("@vc_policy_key", policyKey);
                    command.Parameters.AddWithValue("@vc_auth_policy", authPolicy);
                    command.Parameters.AddWithValue("@b_requires_authentication",requiresAuth);
                    command.Parameters.AddWithValue("@b_ssl",isSsl);
                    command.Parameters.AddWithValue("@b_antidos",0);
                    command.Parameters.AddWithValue("@vc_auth_header", authHeader);
                    command.ExecuteNonQuery();
                }
            }
        }

        public string GetServerNic(string environment, string serverName, string nicRole)
        {
            using (var connection = Command.GetSqlConnection(Server, Database))
            {
                using (var command = new SqlCommand())
                {
                    command.Connection = connection;
                    connection.Open();

                    const string sprocName = "p_config_get_server_nic";
                    Log.WriteLine(String.Format("exec {0} @vc_environment='{1}', @vc_server={2}, @vc_nic_role={3}",
                        sprocName, environment, serverName, nicRole));

                    command.CommandType = CommandType.StoredProcedure;
                    command.CommandText = sprocName;
                    command.Parameters.AddWithValue("@vc_environment", environment);
                    command.Parameters.AddWithValue("@vc_server", serverName);
                    command.Parameters.AddWithValue("@vc_nic_role", nicRole);
                    using (var reader = command.ExecuteReader())
                    {
                        if (reader != null && reader.Read())
                        {
                            return reader["vc_ip"].ToString();
                        }
                    }
                    return null;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Vibrio\SetCertStorePermissions.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Security.AccessControl;

namespace xonline.tools.Vibrio
{
    public class SetCertStorePermissions : Command
    {
        public override string CommandName
        {
            get { return "SetCertStorePermissions"; }
        }

        public override int Run(List<string> args)
        {
            int result = 0;

            if (args.Count < 1)
            {
                ShowHelp();
                result = 1024;
            }
            else
            {
                string path = Path.Combine(Environment.ExpandEnvironmentVariables("%ALLUSERSPROFILE%"), "Application Data\\Microsoft\\Crypto\\RSA\\MachineKeys");

                Log.WriteLine("Adding Administrators with Full Control access to {0}...", path);
                FileUtilities.AddFolderPermission(path, "Administrators", FileSystemRights.FullControl, InheritanceFlags.ContainerInherit | InheritanceFlags.ObjectInherit, PropagationFlags.None, AccessControlType.Allow);

                for (int i = 0; i < args.Count; i++)
                {
                    Log.WriteLine("Adding {0} with Read and Execute access to {1}...", args[i], path);
                    FileUtilities.AddFolderPermission(path, args[i], FileSystemRights.ReadAndExecute, InheritanceFlags.ContainerInherit | InheritanceFlags.ObjectInherit, PropagationFlags.None, AccessControlType.Allow);
                }
            }

            return result;
        }

        public override void ShowHelp()
        {
            Log.WriteLine();
            Log.WriteLine("SetCertStorePermissions: Ensure that the Administrators and passed in");
            Log.WriteLine("                   groups have the correct permissions to the RSA");
            Log.WriteLine("                   MachineKeys folder.");
            Log.WriteLine();
            Log.WriteLine("Usage:");
            Log.WriteLine("   Vibrio [flags] SetCertStorePermissions [<group>...]");
            Log.WriteLine();
            Log.WriteLine("Return codes:");
            Log.WriteLine("   0 if operation is successful, non-zero otherwise.");
            Log.WriteLine();
            Log.WriteLine("Example:");
            Log.WriteLine("   Vibrio [flags] SetCertStorePermissions");
            Log.WriteLine();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Vibrio\RegistryUtility.cs ===
﻿using Microsoft.Win32;

namespace xonline.tools.Vibrio
{
    public enum Use64BitRegistry
    {
        use32,
        use64,
        both
    }

    public static class RegistryUtility
    {
        public static RegistryKey GetRegistryKey(RegistryKey rootKey, string subKey, bool createWhenMissing, bool writable)
        {
            if (createWhenMissing)
            {
                RegistryKey key = rootKey.OpenSubKey(subKey, writable);
                RegistryKey tempKey = null;
                if (null == key)
                {
                    string[] keys = subKey.Split('\\');
                    key = rootKey;
                    for (int i = 0; i < keys.Length; i++)
                    {
                        tempKey = key.OpenSubKey(keys[i], writable);
                        if (null == tempKey)
                        {
                            tempKey = key.CreateSubKey(keys[i]);
                        }
                        key = tempKey;
                    }
                }
                return key;
            }
            else
            {
                return rootKey.OpenSubKey(subKey, writable);
            }
        }

        public static string GetRegistryValue(RegistryKey rootKey, string subKey, string valueName)
        {
            RegistryKey registryKey = GetRegistryKey(rootKey, subKey, false, false);
            if (registryKey != null)
            {
                return (string)registryKey.GetValue(valueName);
            }
            else
            {
                return null;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Vibrio\RemoveFromGroup.cs ===
﻿using System.Collections.Generic;
using System.DirectoryServices;

namespace xonline.tools.Vibrio
{
    public class RemoveFromGroup : Command
    {
        public override string CommandName
        {
            get { return "RemoveFromGroup"; }
        }

        public override int Run(List<string> args)
        {
            int result = 0;

            if (args.Count != 2)
            {
                ShowHelp();
                result = 1024;
            }
            else
            {
                DirectoryEntry user = UserUtilities.GetUser(args[0]);
                if (user == null)
                {
                    result = 2;
                }
                else
                {
                    DirectoryEntry group = UserUtilities.GetGroup(args[1]);
                    if (group == null)
                    {
                        result = 4;
                    }
                    else
                    {
                        group.Invoke("Remove", user.Path);
                    }
                }
            }

            return result;
        }

        public override void ShowHelp()
        {
            Log.WriteLine();
            Log.WriteLine("RemoveFromGroup: Remove a user from a group on the local machine.");
            Log.WriteLine();
            Log.WriteLine("Usage:");
            Log.WriteLine("   Vibrio [flags] RemoveFromGroup <user> <group>");
            Log.WriteLine();
            Log.WriteLine("Return codes:");
            Log.WriteLine("   0 if operation is successful, non-zero otherwise.");
            Log.WriteLine();
            Log.WriteLine("Example:");
            Log.WriteLine("   Vibrio RemoveFromGroup _xbcweb IIS_WPG");
            Log.WriteLine();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Vibrio\RegisterPlatformNpdbServer.cs ===
﻿using System.Collections.Generic;
using System.Net;
using xonline.common.config;

namespace xonline.tools.Vibrio
{
    public class RegisterPlatformNpdbServer : Command
    {
        public override string CommandName
        {
            get { return "RegisterPlatformNpdbServer"; }
        }

        public override int Run(List<string> args)
        {
            int result = 0;
            if (args.Count < 7)
            {
                ShowHelp();
                result = 1024;
            }
            else
            {
                string npdbServerName = args[0];
                string npdbDatabaseName = args[1];
                string serverName = args[2];
                string siteId = args[3];
                string serverState = args[4];
                string internetTierNicIP = args[5];
                string middleTierNicIP = args[6];

                IPAddress nicAddress;

                // Get the environment name from the base config instance/setting
                // This requires the \Microsoft\XboxLive\CommonConfig registry keys be present
                string environment = Config.Environment;

                var npdbUtilities = new NpdbUtilities(npdbServerName, npdbDatabaseName, Log);
                npdbUtilities.AddServer(environment, serverName, siteId, serverState);
                // Add internet_tier NIC if necessary
                if (IPAddress.TryParse(internetTierNicIP, out nicAddress))
                {
                    npdbUtilities.AddServerNic(environment, serverName, "internet_tier", nicAddress.ToString());
                }
                if (IPAddress.TryParse(middleTierNicIP, out nicAddress))
                {
                    npdbUtilities.AddServerNic(environment, serverName, "middle_tier", nicAddress.ToString());
                }
            }

            return result;
        }

        public override void ShowHelp()
        {
            Log.WriteLine();
            Log.WriteLine("RegisterPlatformNpdbServer: Register a new server in the Xbox LIVE platform NPDB and add server NIC ");
            Log.WriteLine("                            registrations associated with that server.  If NIC");
            Log.WriteLine("                            addresses are provided, they will be registered appropriately.");
            Log.WriteLine("                            Calling this operation against an existing server will update ");
            Log.WriteLine("                            the site ID, server state, and NIC information.");
            Log.WriteLine("                            The \\Microsoft\\XboxLive\\CommonConfig registry keys must be present ");
            Log.WriteLine("                            for NPDB connectivity for retrieving the environment name.");
            Log.WriteLine();
            Log.WriteLine("Usage:");
            Log.WriteLine("   Vibrio [flags] RegisterNpdbServer <npdbServer> <npdbDatabase> <server> <siteId> <serverState> [<intenet tier nicIp>] [<middle tier nicIp>]");
            Log.WriteLine();
            Log.WriteLine("Return codes:");
            Log.WriteLine("   0 if operation is successful, non-zero otherwise.");
            Log.WriteLine();
            Log.WriteLine("Example:");
            Log.WriteLine("   Vibrio [flags] RegisterNpdbServer MyNpdbServer01 NPDB LeetServer001 1 online 127.0.0.1 127.0.0.2");
            Log.WriteLine();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Vibrio\SiteXmlAddSslCert.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Xml;
using System.IO;

namespace xonline.tools.Vibrio
{
    public class SiteXmlAddSslCert : Command
    {
        public override string CommandName
        {
            get { return "SiteXmlAddSslCert"; }
        }

        public override int Run(List<string> args)
        {
            int result = 0;
            if (args.Count != 4)
            {
                ShowHelp();
                result = 1024;
            }
            else
            {
                XmlDocument siteXml = new XmlDocument();
                string fileName = Path.Combine(args[0], "site.xml");
                siteXml.Load(fileName);

                XmlNode element = siteXml.FirstChild.SelectSingleNode("//Site/Certificates/SSLCert[@Identifier='" + args[1] + "']");
                if (element == null)
                {
                    Log.WriteLine(String.Format("SSLCert element with Identifier {0} not found, creating...", args[1]));
                    element = siteXml.CreateElement("SSLCert");
                    XmlNode parentNode = siteXml.FirstChild.SelectSingleNode("//Site/Certificates");
                    parentNode.AppendChild(element);
                }

                Log.WriteLine("Setting Identifier attribute to " + args[1] + "...");
                XmlAttribute identifierAttribute = element.Attributes["Identifier"];
                if (identifierAttribute == null)
                {
                    identifierAttribute = siteXml.CreateAttribute("Identifier");
                    element.Attributes.Append(identifierAttribute);
                }
                identifierAttribute.Value = args[1];

                Log.WriteLine("Setting File attribute to " + args[2] + "...");
                XmlAttribute fileAttribute = element.Attributes["File"];
                if (fileAttribute == null)
                {
                    fileAttribute = siteXml.CreateAttribute("File");
                    element.Attributes.Append(fileAttribute);
                }
                fileAttribute.Value = args[2];

                Log.WriteLine("Setting the password...");
                element.InnerXml = "<Password><![CDATA[" + args[3] + "]]></Password>";

                siteXml.Save(fileName);
            }

            return result;
        }

        public override void ShowHelp()
        {
            Log.WriteLine();
            Log.WriteLine("SiteXmlAddSslCert: Ensure that the value in the site.xml file");
            Log.WriteLine("                   is correct for the given ssl cert entry.");
            Log.WriteLine();
            Log.WriteLine("Usage:");
            Log.WriteLine("   Vibrio [flags] ModifySiteXml <secureSharePath> <identifier> <file> <password>");
            Log.WriteLine();
            Log.WriteLine("Return codes:");
            Log.WriteLine("   0 if operation is successful, non-zero otherwise.");
            Log.WriteLine();
            Log.WriteLine("Example:");
            Log.WriteLine("   Vibrio [flags] ModifySiteXml \\\\XbcXblob01\\Secure Cert.int-ids.xbox.com int-ids.xbox.com.pfx \"password\"");
            Log.WriteLine();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Vibrio\UpdateFileContents.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Text.RegularExpressions;

namespace xonline.tools.Vibrio
{
    public class UpdateFileContents : Command
    {
        public override string CommandName
        {
            get { return "UpdateFileContents"; }
        }

        public override int Run(List<string> args)
        {
            if (args.Count != 3)
            {
                ShowHelp();
                return 1024;
            }

            string fileName = args[0];
            if (!File.Exists(fileName))
            {
                return 2;
            }

            string regularExpression = args[1];
            string replacementValue = args[2];

            try
            {
                string fileContents;
                using (StreamReader reader = new StreamReader(fileName))
                {
                    fileContents = reader.ReadToEnd();
                }

                Regex regex = new Regex(regularExpression);
                fileContents = regex.Replace(fileContents, replacementValue);

                using (StreamWriter writer = new StreamWriter(fileName))
                {
                    writer.Write(fileContents);
                }
            }
            catch (Exception)
            {
                return 4;
            }

            return 0;
        }

        public override void ShowHelp()
        {
            Log.WriteLine();
            Log.WriteLine("UpdateFileContents: Update a file by replacing every occurence");
            Log.WriteLine("                   of the given regular expression with the");
            Log.WriteLine("                   specified value.");
            Log.WriteLine();
            Log.WriteLine("Usage:");
            Log.WriteLine("   Vibrio [flags] UpdateFileContents <file> <regex> <value>");
            Log.WriteLine();
            Log.WriteLine("Return codes:");
            Log.WriteLine("   0 if operation is successful, non-zero otherwise.");
            Log.WriteLine();
            Log.WriteLine("Example:");
            Log.WriteLine("   Vibrio [flags] UpdateFileContents D:\file.txt [\\-]* _");
            Log.WriteLine();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Vibrio\SetPrivateKeyAcls.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography.X509Certificates;
using System.Runtime.InteropServices;
using System.IO;
using System.Security.AccessControl;

namespace xonline.tools.Vibrio
{
    /// <summary>
    /// Contains substantial code liberated from MSDN WCF samples: http://msdn.microsoft.com/en-us/library/aa717039.aspx
    /// </summary>
    public class SetPrivateKeyAcls : Command
    {
        public override string CommandName
        {
            get { return "SetPrivateKeyAcls"; }
        }

        public override int Run(List<string> args)
        {
            if (args.Count < 4)
            {
                ShowHelp();
                return 1024;
            }

            StoreName storeName = (StoreName)Enum.Parse(typeof(StoreName), args[0], true);
            StoreLocation storeLocation = (StoreLocation)Enum.Parse(typeof(StoreLocation), args[1], true);
            string fileName = args[2];
            string password = args[3];

            X509Certificate2 cert;
            string thumbprint;

            Log.WriteLine("Looking for certificate in file {0}...", fileName);

            try
            {
                X509Certificate2 fileCertificate = LoadCertificate(fileName, password);
                thumbprint = fileCertificate.Thumbprint;
                fileCertificate.Reset();
            }
            catch (Exception ex)
            {
                Log.WriteLine("Failed to load certificate: File: {0}.", fileName);
                Log.WriteLine(ex.Message);
                return 4;
            }

            // look up cert in specified store
            Log.WriteLine("Looking for certificate in store {0}, location {1} with thumbprint {2}...", storeName, storeLocation, thumbprint);

            cert = LoadCertificate(storeName, storeLocation, thumbprint, X509FindType.FindByThumbprint);

            string privateKeyFile = GetKeyFileName(cert);
            string privateKeyDirectory = GetKeyFileDirectory(privateKeyFile);
            string privateKeyPath = Path.Combine(privateKeyDirectory, privateKeyFile);

            Log.WriteLine("Adding Administrators with Full Control access to {0}...", privateKeyPath);
            FileUtilities.AddFolderPermission(privateKeyPath, "Administrators", FileSystemRights.FullControl, InheritanceFlags.ContainerInherit | InheritanceFlags.ObjectInherit, PropagationFlags.None, AccessControlType.Allow);

            for (int i = 4; i < args.Count; i++)
            {
                Log.WriteLine("Adding {0} with Read and Execute access to {1}...", args[i], privateKeyPath);
                FileUtilities.AddFolderPermission(privateKeyPath, args[i], FileSystemRights.ReadAndExecute, InheritanceFlags.ContainerInherit | InheritanceFlags.ObjectInherit, PropagationFlags.None, AccessControlType.Allow);
            }

            return 0;
        }

        private X509Certificate2 LoadCertificate(string fileName, string password)
        {
            X509Certificate2 certificate;
            if (File.Exists(fileName))
            {
                Log.WriteLine("Loading certificate...");

                if (String.IsNullOrEmpty(password))
                {
                    certificate = new X509Certificate2(fileName);
                }
                else
                {
                    certificate = new X509Certificate2(fileName, password);
                }
            }
            else
            {
                throw new FileNotFoundException(String.Format("File {0} can't be found.", fileName));
            }

            return certificate;
        }

        static X509Certificate2 LoadCertificate(StoreName storeName, StoreLocation storeLocation, string key, X509FindType findType)
        {
            X509Certificate2 result;

            X509Store store = new X509Store(storeName, storeLocation);
            store.Open(OpenFlags.ReadOnly);
            try
            {
                X509Certificate2Collection matches;
                matches = store.Certificates.Find(findType, key, false);
                if (matches.Count > 1)
                    throw new InvalidOperationException(String.Format("More than one certificate with key '{0}' found in the store.", key));
                if (matches.Count == 0)
                    throw new InvalidOperationException(String.Format("No certificates with key '{0}' found in the store.", key));
                result = matches[0];
            }
            finally
            {
                store.Close();
            }

            return result;
        }

        static string GetKeyFileName(X509Certificate2 cert)
        {
            IntPtr hProvider = IntPtr.Zero; // CSP handle
            bool freeProvider = false;       // Do we need to free the CSP ?
            uint acquireFlags = 0;
            int _keyNumber = 0;
            string keyFileName = null;
            byte[] keyFileBytes = null;

            //
            // Determine whether there is private key information available for this certificate in the key store
            //
            if (CryptAcquireCertificatePrivateKey(cert.Handle,
                acquireFlags,
                IntPtr.Zero,
                ref hProvider,
                ref _keyNumber,
                ref freeProvider))
            {
                IntPtr pBytes = IntPtr.Zero; // Native Memory for the CRYPT_KEY_PROV_INFO structure
                int cbBytes = 0;           // Native Memory size

                try
                {
                    if (CryptGetProvParam(hProvider, CryptGetProvParamType.PP_UNIQUE_CONTAINER, IntPtr.Zero, ref cbBytes, 0))
                    {
                        pBytes = Marshal.AllocHGlobal(cbBytes);

                        if (CryptGetProvParam(hProvider, CryptGetProvParamType.PP_UNIQUE_CONTAINER, pBytes, ref cbBytes, 0))
                        {
                            keyFileBytes = new byte[cbBytes];

                            Marshal.Copy(pBytes, keyFileBytes, 0, cbBytes);

                            // Copy eveything except tailing null byte
                            keyFileName = System.Text.Encoding.ASCII.GetString(keyFileBytes, 0, keyFileBytes.Length - 1);
                        }
                    }
                }
                finally
                {
                    if (freeProvider)
                        CryptReleaseContext(hProvider, 0);

                    //
                    // Free our native memory
                    //
                    if (pBytes != IntPtr.Zero)
                        Marshal.FreeHGlobal(pBytes);

                }
            }

            if (keyFileName == null)
                throw new InvalidOperationException("Unable to obtain private key file name");

            return keyFileName;
        }

        static string GetKeyFileDirectory(string keyFileName)
        {
            // Look up All User profile from environment variable
            string allUserProfile = System.Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData);

            // set up searching directory
            string machineKeyDir = allUserProfile + "\\Microsoft\\Crypto\\RSA\\MachineKeys";

            // Seach the key file
            string[] fs = System.IO.Directory.GetFiles(machineKeyDir, keyFileName);

            // If found
            if (fs.Length > 0)
                return machineKeyDir;

            // Next try current user profile
            string currentUserProfile = System.Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);

            // seach all sub directory
            string userKeyDir = currentUserProfile + "\\Microsoft\\Crypto\\RSA\\";

            fs = System.IO.Directory.GetDirectories(userKeyDir);
            if (fs.Length > 0)
            {
                // for each sub directory
                foreach (string keyDir in fs)
                {
                    fs = System.IO.Directory.GetFiles(keyDir, keyFileName);
                    if (fs.Length == 0)
                        continue;
                    else
                        // found
                        return keyDir;
                }
            }

            throw new InvalidOperationException("Unable to locate private key file directory");
        }

        [DllImport("crypt32", CharSet = CharSet.Unicode, SetLastError = true)]
        internal extern static bool CryptAcquireCertificatePrivateKey(IntPtr pCert, uint dwFlags, IntPtr pvReserved, ref IntPtr phCryptProv, ref int pdwKeySpec, ref bool pfCallerFreeProv);

        [DllImport("advapi32", CharSet = CharSet.Unicode, SetLastError = true)]
        internal extern static bool CryptGetProvParam(IntPtr hCryptProv, CryptGetProvParamType dwParam, IntPtr pvData, ref int pcbData, uint dwFlags);

        [DllImport("advapi32", SetLastError = true)]
        internal extern static bool CryptReleaseContext(IntPtr hProv, uint dwFlags);

        public override void ShowHelp()
        {
            Log.WriteLine();
            Log.WriteLine("SetPrivateKeyAcls: Ensure that the Administrators and passed in");
            Log.WriteLine("                   accounts have the correct permissions to the RSA");
            Log.WriteLine("                   private key file. The specified certificate file");
            Log.WriteLine("                   will be used to fetch the thumbprint of the certificate");
            Log.WriteLine("                   to locate the certificate in the specifed store.");
            Log.WriteLine();
            Log.WriteLine("Usage:");
            Log.WriteLine("   Vibrio [flags] SetPrivateKeyAcls <storeName> <storeLocation> <certificateFile> <certificatePassword> [<group>...]");
            Log.WriteLine();
            Log.WriteLine();
            Log.WriteLine("Return codes:");
            Log.WriteLine("   0 if operation is successful, non-zero otherwise.");
            Log.WriteLine();
            Log.WriteLine("Example:");
            Log.WriteLine("   Vibrio [flags] SetPrivateKeyAcls My LocalMachine \\\\XbcXblob01\\secure\\onebox-sps.xboxlive.com.pfx pass2 _leosvc");
            Log.WriteLine();
        }
    }

    enum CryptGetProvParamType
    {
        PP_ENUMALGS = 1,
        PP_ENUMCONTAINERS = 2,
        PP_IMPTYPE = 3,
        PP_NAME = 4,
        PP_VERSION = 5,
        PP_CONTAINER = 6,
        PP_CHANGE_PASSWORD = 7,
        PP_KEYSET_SEC_DESCR = 8,       // get/set security descriptor of keyset
        PP_CERTCHAIN = 9,      // for retrieving certificates from tokens
        PP_KEY_TYPE_SUBTYPE = 10,
        PP_PROVTYPE = 16,
        PP_KEYSTORAGE = 17,
        PP_APPLI_CERT = 18,
        PP_SYM_KEYSIZE = 19,
        PP_SESSION_KEYSIZE = 20,
        PP_UI_PROMPT = 21,
        PP_ENUMALGS_EX = 22,
        PP_ENUMMANDROOTS = 25,
        PP_ENUMELECTROOTS = 26,
        PP_KEYSET_TYPE = 27,
        PP_ADMIN_PIN = 31,
        PP_KEYEXCHANGE_PIN = 32,
        PP_SIGNATURE_PIN = 33,
        PP_SIG_KEYSIZE_INC = 34,
        PP_KEYX_KEYSIZE_INC = 35,
        PP_UNIQUE_CONTAINER = 36,
        PP_SGC_INFO = 37,
        PP_USE_HARDWARE_RNG = 38,
        PP_KEYSPEC = 39,
        PP_ENUMEX_SIGNING_PROT = 40,
        PP_CRYPT_COUNT_KEY_USE = 41,
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Vibrio\WriteRegistry.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using Microsoft.Win32;

namespace xonline.tools.Vibrio
{
    public class WriteRegistry : Command
    {
        public override string CommandName
        {
            get { return "WriteRegistry"; }
        }

        public override int Run(List<string> args)
        {
            int result = 0;

            if ((args.Count < 2) || (args.Count > 5))
            {
                ShowHelp();
                result = 1024;
            }
            else
            {
                RegistryValueKind valueType = RegistryValueKind.String;
                for (int i = 2; i < 3; i++)
                {
                    if (args[i] == "-t")
                    {
                        if (args.Count < i+2)
                        {
                            ShowHelp();
                            return 1024;
                        }
                        valueType = (RegistryValueKind)Enum.Parse(typeof(RegistryValueKind), args[i+1]);
                        break;
                    }
                }

                int first = args[0].IndexOf("\\");
                int last = args[0].LastIndexOf("\\");
                if ((first > 0) && (last > 0))
                {
                    string sub = args[0].Substring(0, first);
                    string key = args[0].Substring(first + 1, last - first);
                    string key64 = String.Empty;
                    string valueName = args[0].Substring(last + 1);

                    RegistryKey baseKey;
                    switch(sub)
                    {
                        default:
                        case "HKLM":
                        case "HKEY_LOCAL_MACHINE":
                            baseKey = Registry.LocalMachine;
                            if (key.StartsWith("Software", StringComparison.OrdinalIgnoreCase))
                            {
                                int position = key.IndexOf("\\");
                                key64 = key.Substring(0, position) + "\\Wow6432Node" + key.Substring(position);
                            }
                            else
                            {
                                key64 = key;
                            }
                            break;

                        case "HKCR":
                        case "HKEY_CLASSES_ROOT":
                            baseKey = Registry.ClassesRoot;
                            key64 = "Wow6432Node\\" + key;
                            break;

                        case "HKCU":
                        case "HKEY_CURRENT_USER":
                            baseKey = Registry.CurrentUser;
                            if (key.StartsWith("Software", StringComparison.OrdinalIgnoreCase))
                            {
                                int position = key.IndexOf("\\");
                                key64 = key.Substring(0, position) + "\\Wow6432Node" + key.Substring(position);
                            }
                            else
                            {
                                key64 = key;
                            }
                            break;

                        case "HKCC":
                        case "HKEY_CURRENT_CONFIG":
                            baseKey = Registry.CurrentConfig;
                            key64 = key;
                            break;
                    }

                    Use64BitRegistry registryUse = Use64BitRegistry.use32;
                    if (args.Count == 3)
                    {
                        registryUse = (Use64BitRegistry)Enum.Parse(typeof(Use64BitRegistry), args[2].ToLower());
                    }

                    if ((registryUse == Use64BitRegistry.use32) || (registryUse == Use64BitRegistry.both))
                    {
                        WriteRegistryValue(baseKey, key, valueName, args[1], valueType);
                    }

                    if ((registryUse == Use64BitRegistry.use64) || (registryUse == Use64BitRegistry.both))
                    {
                        WriteRegistryValue(baseKey, key64, valueName, args[1], valueType);
                    }
                }
            }

            return result;
        }

        private void WriteRegistryValue(RegistryKey baseKey, string key, string valueName, string value, RegistryValueKind valueType)
        {
            if (key.EndsWith("\\"))
            {
                key = key.Substring(0, key.Length - 1);
            }
            Log.WriteLine("Getting key {0}...", key);
            RegistryKey registryKey = RegistryUtility.GetRegistryKey(baseKey, key, true, true);
            Log.WriteLine("Key retrieved: " + registryKey.ToString());
            Log.WriteLine("Writing {0} = {1}...", valueName, value);
            registryKey.SetValue(valueName, value, valueType);
            Log.WriteLine("Written value: " + registryKey.GetValue(valueName));
        }

        public override void ShowHelp()
        {
            Log.WriteLine();
            Log.WriteLine("WriteRegistry: Write a registry value.  The 64bit registry is used");
            Log.WriteLine("                   based on a parameter passed in.  The default is");
            Log.WriteLine("                   to use the 32bit registry hive only.  The -t ");
            Log.WriteLine("                   parameter allows you to specify the registry type");
            Log.WriteLine("                   to use.  It is optional and defaults to String.");
            Log.WriteLine();
            Log.WriteLine("Usage:");
            Log.WriteLine("   Vibrio [flags] WriteRegistry <key> <value> [<Use32|Use64|Both>] ");
            Log.WriteLine("          [-t <String|ExpandString|Binary|DWord|MultiString|QWord>]");
            Log.WriteLine();
            Log.WriteLine("Return codes:");
            Log.WriteLine("   0 if operation is successful, non-zero otherwise.");
            Log.WriteLine();
            Log.WriteLine("Example:");
            Log.WriteLine("   Vibrio WriteRegistry HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\XboxLive\\CommonConfig\\Database NPDB both -t String");
            Log.WriteLine();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Vibrio\UpdateHosts.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Text.RegularExpressions;
using Microsoft.Win32;

namespace xonline.tools.Vibrio
{


    public class UpdateHosts : Command
    {
        public override string CommandName
        {
            get { return "UpdateHosts"; }
        }

        public override int Run(List<string> args)
        {
            int result = 0;

            if (args.Count != 1)
            {
                ShowHelp();
                result = 1024;
            }
            else
            {
                string hostsPath = Path.Combine(Environment.ExpandEnvironmentVariables("%SYSTEMROOT%"), "system32\\drivers\\etc\\hosts");
                if (File.Exists(hostsPath))
                {
                    string srcHostsPath = args[0];
                    if (File.Exists(srcHostsPath))
                    {
                        List<object> srcEntries = ReadHostsFile(srcHostsPath);
                        srcEntries.RemoveAll(o => !(o is HostEntry));

                        List<object> hostEntries = ReadHostsFile(hostsPath);

                        // Remove any entries in the current hosts file for the hosts that are defined in the src hosts file
                        foreach (HostEntry srcEntry in srcEntries)
                        {
                            hostEntries.RemoveAll(o => (o is HostEntry) && ((HostEntry)(o)).Host.Equals(srcEntry.Host, StringComparison.OrdinalIgnoreCase));
                        }

                        hostEntries.AddRange(srcEntries);
                        WriteFile(hostsPath, hostEntries);

                        // Disable the web browser proxy so that the entries in the hosts file are actually used.
                        DisableBrowserProxy();
                    }
                    else
                    {
                        Log.WriteLine("Could not find source file {0}.", srcHostsPath);
                        result = 2;
                    }

                }
                else
                {
                    Log.WriteLine("Could not find {0}.", hostsPath);
                    result = 2;
                }
            }

            return result;
        }

        private static Regex _hostEntryRegex = new Regex(@"^([\d\.]+)[ \t]+([\w\.\-\t ]+)");

        private List<object> ReadHostsFile(string path)
        {
            List<object> hostsFile = new List<object>();
            using (StreamReader reader = new StreamReader(path))
            {
                while (reader.Peek() >= 0)
                {
                    string line = reader.ReadLine();
                    Match hostEntryMatch = _hostEntryRegex.Match(line);
                    if (hostEntryMatch.Success)
                    {
                        string ip = hostEntryMatch.Groups[1].Value;
                        string[] hosts = hostEntryMatch.Groups[2].Value.Split(new char[] {' ', '\t'}, StringSplitOptions.RemoveEmptyEntries);
                        if (!string.IsNullOrEmpty(ip) || hosts.Length > 0)
                        {
                            // Add a seperate entry for each host that is mapped to this IP
                            foreach (string host in hosts)
                            {
                                hostsFile.Add(new HostEntry() { IP = ip, Host = host });
                            }
                        }
                        else
                        {
                            hostsFile.Add(line);
                        }
                    }
                    else
                    {
                        hostsFile.Add(line);
                    }
                }
            }

            return hostsFile;
        }

        private void WriteFile(string path, List<object> rows)
        {
            using (StreamWriter writer = new StreamWriter(path, false))
            {
                foreach (object row in rows)
                {
                    writer.WriteLine(row);
                }
            }
        }

        private void DisableBrowserProxy()
        {
            // With the browser proxy enabled dns entires in the hosts file won't resolve.  We should
            // just rely on the firewall client.
            RegistryKey internetSettingsKey = Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings", true);
            internetSettingsKey.SetValue("ProxyEnable", 0);
        }

        public override void ShowHelp()
        {
            Log.WriteLine();
            Log.WriteLine("UpdateHosts: Inserts or updates the host entries from the source host file in the hosts file on the current machine.");
            Log.WriteLine();
            Log.WriteLine("Usage:");
            Log.WriteLine("   Vibrio [flags] UpdateHosts <srcHostFile>");
            Log.WriteLine();
            Log.WriteLine("Return codes:");
            Log.WriteLine("   0 if operation is successful, non-zero otherwise.");
            Log.WriteLine();
            Log.WriteLine("Example:");
            Log.WriteLine("   Vibrio [flags] UpdateHosts storax.xbox.com_hosts.txt");
            Log.WriteLine();
        }
    }

    internal class HostEntry
    {
        public string IP { get; set; }
        public string Host { get; set; }

        public override string ToString()
        {
            return String.Format("{0}\t\t{1}", IP, Host);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Vibrio\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Leo.Vibrio")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("94D9B9EE-648D-4eba-8337-52B3317FD1C7")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Vibrio\VibrioApplication.cs ===
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;

namespace xonline.tools.Vibrio
{
    class VibrioApplication
    {
        private Dictionary<string, Command> _typeMap = new Dictionary<string, Command>(StringComparer.OrdinalIgnoreCase);

        private Logger _logger = new Logger();
        private TextWriter _logWriter = null;

        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static int Main(string[] args)
        {
            VibrioApplication application = new VibrioApplication();
            return application.Start(args);
        }

        public int Start(string[] args)
        {
            int result;

            _logger.OnMessage += new MessageEventHandler(ConsoleMessageLogger);
            InitializeTypeMap();

            try
            {
                result = DispatchCommand(args);
            }
            catch (Exception e)
            {
                _logger.WriteLine("An error occured processing this command:");
                _logger.WriteLine();
                _logger.WriteLine(e.ToString());
                result = 500;
            }

            if (_logWriter != null)
            {
                _logWriter.Close();
                _logWriter = null;
            }

            return result;
        }

        private int DispatchCommand(string[] args)
        {
            int result = 1024;

            if ((args.Length == 0) ||
                ((args.Length > 0) && (String.Equals(args[0], "help", StringComparison.OrdinalIgnoreCase))))
            {
                if (args.Length > 1)
                {
                    WriteHelpText(args[1]);
                }
                else
                {
                    WriteHelpText("");
                }

                result = 1024; // showing help
            }
            else
            {
                int currentArg = 0;

                while ((currentArg < args.Length) && (args[currentArg].StartsWith("/")))
                {
                    switch (args[currentArg].ToLower())
                    {
                        case "/logfile":
                            currentArg++;
                            if (currentArg < args.Length)
                            {
                                _logWriter = new StreamWriter(args[currentArg]);
                                _logger.OnMessage += new MessageEventHandler(FileMessageLogger);
                            }
                            else
                            {
                                _logger.WriteLine("No file specified for /logfile option.");
                                WriteHelpText("");
                                currentArg = args.Length;
                                result = 1024; // showing help
                            }
                            break;

                        case "/?":
                            WriteHelpText("");
                            currentArg = args.Length;
                            result = 1024; // showing help
                            break;

                        default:
                            _logger.WriteLine("Unknown option {0} specified.", args[currentArg]);
                            WriteHelpText("");
                            currentArg = args.Length;
                            result = 1024; // showing help
                            break;
                    }

                    currentArg++;
                }

                if (currentArg < args.Length)
                {
                    Command command;

                    if (_typeMap.TryGetValue(args[currentArg], out command))
                    {
                        List<string> subArgs = new List<string>();

                        for (int i = currentArg + 1; i < args.Length; i++)
                        {
                            subArgs.Add(args[i]);
                        }

                        result = command.Run(subArgs);
                    }
                    else
                    {
                        WriteHelpText("");
                        result = 1024; // showing help
                    }
                }
            }

            return result;
        }

        private void WriteHelpText(string commandName)
        {
            if (!String.IsNullOrEmpty(commandName))
            {
                Command command;

                if (_typeMap.TryGetValue(commandName, out command))
                {
                    command.ShowHelp();
                }
            }
            else
            {
                _logger.WriteLine();
                _logger.WriteLine("Vibrio: A generic utility application that provides setup support for activities such as creating users/groups, moving files, etc.");
                _logger.WriteLine("vibrio ==> http://serc.carleton.edu/microbelife/topics/marinesymbiosis/squid-vibrio/index.html");
                _logger.WriteLine();
                _logger.WriteLine("Usage:");
                _logger.WriteLine("   Vibrio [flags] command [command parameters]");
                _logger.WriteLine();
                _logger.WriteLine("Flags:");
                _logger.WriteLine("   /? - Display this help");
                _logger.WriteLine("   /logfile <filename> - Send output to the specified filename");
                _logger.WriteLine();
                _logger.WriteLine("Commands:");

                foreach (string command in _typeMap.Keys)
                {
                    _logger.WriteLine("   {0}", command);
                }

                _logger.WriteLine();
                _logger.WriteLine("Get additional information on a particular command using:");
                _logger.WriteLine("   Vibrio help <command>");
            }
        }

        private void InitializeTypeMap()
        {
            _typeMap.Clear();

            Assembly assembly = Assembly.GetExecutingAssembly();
            Type[] allTypes = assembly.GetExportedTypes();

            foreach (Type type in allTypes)
            {
                if ((type.IsClass) && (!type.IsAbstract) && (type.IsSubclassOf(typeof(Command))))
                {
                    Command currentCommand = (Command)Activator.CreateInstance(type);
                    currentCommand.Log = _logger;
                    _typeMap.Add(currentCommand.CommandName, currentCommand);
                }
            }
        }

        private void FileMessageLogger(object sender, MessageEventArgs e)
        {
            if (_logWriter != null)
            {
                _logWriter.Write(e.Message);
            }
        }

        private void ConsoleMessageLogger(object sender, MessageEventArgs e)
        {
            Console.Write(e.Message);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Vibrio\UserUtilities.cs ===
﻿using System;
using System.DirectoryServices;

namespace xonline.tools.Vibrio
{
    public static class UserUtilities
    {
        public static bool AccountExists(string accountName)
        {
            return (GetUser(accountName) != null);
        }

        public static DirectoryEntry GetUser(string name)
        {
            return GetItem(name);
        }

        public static DirectoryEntry GetGroup(string name)
        {
            return GetItem(name);
        }

        private static DirectoryEntry GetItem(string name)
        {
            string path;
            if (name.Contains("\\"))
            {
                string[] credentials = name.Split('\\');
                path = String.Format("WinNT://{0}/{1}", credentials[0], credentials[1]);
            }
            else
            {
                path = String.Format("WinNT://{0}/{1}", Environment.MachineName, name);
            }
            if (DirectoryEntry.Exists(path))
                return new DirectoryEntry(path);
            else
                return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Vibrio\UpdateSqlFileContentsInFolder.cs ===
﻿
namespace xonline.tools.Vibrio
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Text.RegularExpressions;

    /// <summary>
    /// UpdateSqlFileContentsInFolder command class
    /// </summary>
    public class UpdateSqlFileContentsInFolder : Command
    {
        /// <summary>
        /// Gets the name of the command
        /// </summary>
        public override string CommandName
        {
            get { return "UpdateSqlFileContentsInFolder"; }
        }

        /// <summary>
        /// Executes the command
        /// </summary>
        /// <param name="args">Arguments required for command</param>
        /// <returns>Command error code</returns>
        public override int Run(List<string> args)
        {
            if (args.Count != 3)
            {
                this.ShowHelp();
                return 1024;
            }

            try
            {
                string folderName = args[0];
                System.Console.WriteLine(folderName);
                var directoryInfo = new DirectoryInfo(folderName);
                if (!directoryInfo.Exists)
                {
                    System.Console.WriteLine("does not exist");
                    return 2;
                }

                string regularExpression = args[1];
                string replacementValue = args[2];

                FileInfo[] fileInfos = directoryInfo.GetFiles("*.sql");

                if (fileInfos != null)
                {
                    foreach (var info in fileInfos)
                    {
                        System.Console.WriteLine(info.FullName);

                        string fileContents;
                        using (StreamReader reader = new StreamReader(info.FullName))
                        {
                            fileContents = reader.ReadToEnd();
                        }

                        Regex regex = new Regex(regularExpression);
                        fileContents = regex.Replace(fileContents, replacementValue);

                        using (StreamWriter writer = new StreamWriter(info.FullName))
                        {
                            writer.Write(fileContents);
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                System.Console.WriteLine(ex.ToString());
                return 4;
            }

            return 0;
        }

        /// <summary>
        /// Shows contents for help
        /// </summary>
        public override void ShowHelp()
        {
            Log.WriteLine();
            Log.WriteLine("UpdateSqlFileContentsInFolder: Update all files in the folder by replacing every occurence");
            Log.WriteLine("                   of the given regular expression with the");
            Log.WriteLine("                   specified value.");
            Log.WriteLine();
            Log.WriteLine("Usage:");
            Log.WriteLine("   Vibrio [flags] UpdateSqlFileContentsInFolder <folder> <regex> <value>");
            Log.WriteLine();
            Log.WriteLine("Return codes:");
            Log.WriteLine("   0 if operation is successful, non-zero otherwise.");
            Log.WriteLine();
            Log.WriteLine("Example:");
            Log.WriteLine("   Vibrio [flags] UpdateSqlFileContentsInFolder D:\folder [\\-]* _");
            Log.WriteLine();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Wmi\iisv2\IIsApplicationPool.CS ===
﻿namespace Leet.Tools.Setup.Wmi.Iisv2 {
    using System;
    using System.ComponentModel;
    using System.Management;
    using System.Collections;
    using System.Globalization;
    using System.ComponentModel.Design.Serialization;
    using System.Reflection;
    
    
    // Functions ShouldSerialize<PropertyName> are functions used by VS property browser to check if a particular property has to be serialized. These functions are added for all ValueType properties ( properties of type Int32, BOOL etc.. which cannot be set to null). These functions use Is<PropertyName>Null function. These functions are also used in the TypeConverter implementation for the properties to check for NULL value of property so that an empty value can be shown in Property browser in case of Drag and Drop in Visual studio.
    // Functions Is<PropertyName>Null() are used to check if a property is NULL.
    // Functions Reset<PropertyName> are added for Nullable Read/Write properties. These functions are used by VS designer in property browser to set a property to NULL.
    // Every property added to the class for WMI property has attributes set to define its behavior in Visual Studio designer and also to define a TypeConverter to be used.
    // Datetime conversion functions ToDateTime and ToDmtfDateTime are added to the class to convert DMTF datetime to System.DateTime and vice-versa.
    // An Early Bound class generated for the WMI class.IIsApplicationPool
    public class IIsApplicationPool : System.ComponentModel.Component {
        
        // Private property to hold the WMI namespace in which the class resides.
        private static string CreatedWmiNamespace = "ROOT\\MicrosoftIISv2";
        
        // Private property to hold the name of WMI class which created this class.
        private static string CreatedClassName = "IIsApplicationPool";
        
        // Private member variable to hold the ManagementScope which is used by the various methods.
        private static System.Management.ManagementScope statMgmtScope = null;
        
        private ManagementSystemProperties PrivateSystemProperties;
        
        // Underlying lateBound WMI object.
        private System.Management.ManagementObject PrivateLateBoundObject;
        
        // Member variable to store the 'automatic commit' behavior for the class.
        private bool AutoCommitProp = true;
        
        // Private variable to hold the embedded property representing the instance.
        private System.Management.ManagementBaseObject embeddedObj;
        
        // The current WMI object used
        private System.Management.ManagementBaseObject curObj;
        
        // Flag to indicate if the instance is an embedded object.
        private bool isEmbedded = false;
        
        // Below are different overloads of constructors to initialize an instance of the class with a WMI object.
        public IIsApplicationPool() : 
                this(((System.Management.ManagementScope)(null)), ((System.Management.ManagementPath)(null)), ((System.Management.ObjectGetOptions)(null))) {
        }
        
        public IIsApplicationPool(string keyName) : 
                this(((System.Management.ManagementScope)(null)), ((System.Management.ManagementPath)(new System.Management.ManagementPath(IIsApplicationPool.ConstructPath(keyName)))), ((System.Management.ObjectGetOptions)(null))) {
        }
        
        public IIsApplicationPool(System.Management.ManagementScope mgmtScope, string keyName) : 
                this(((System.Management.ManagementScope)(mgmtScope)), ((System.Management.ManagementPath)(new System.Management.ManagementPath(IIsApplicationPool.ConstructPath(keyName)))), ((System.Management.ObjectGetOptions)(null))) {
        }
        
        public IIsApplicationPool(System.Management.ManagementPath path, System.Management.ObjectGetOptions getOptions) : 
                this(((System.Management.ManagementScope)(null)), ((System.Management.ManagementPath)(path)), ((System.Management.ObjectGetOptions)(getOptions))) {
        }
        
        public IIsApplicationPool(System.Management.ManagementScope mgmtScope, System.Management.ManagementPath path) : 
                this(((System.Management.ManagementScope)(mgmtScope)), ((System.Management.ManagementPath)(path)), ((System.Management.ObjectGetOptions)(null))) {
        }
        
        public IIsApplicationPool(System.Management.ManagementPath path) : 
                this(((System.Management.ManagementScope)(null)), ((System.Management.ManagementPath)(path)), ((System.Management.ObjectGetOptions)(null))) {
        }
        
        public IIsApplicationPool(System.Management.ManagementScope mgmtScope, System.Management.ManagementPath path, System.Management.ObjectGetOptions getOptions) {
            if ((path != null)) {
                if ((CheckIfProperClass(mgmtScope, path, getOptions) != true)) {
                    throw new System.ArgumentException("Class name does not match.");
                }
            }
            PrivateLateBoundObject = new System.Management.ManagementObject(mgmtScope, path, getOptions);
            PrivateSystemProperties = new ManagementSystemProperties(PrivateLateBoundObject);
            curObj = PrivateLateBoundObject;
        }
        
        public IIsApplicationPool(System.Management.ManagementObject theObject) {
            if ((CheckIfProperClass(theObject) == true)) {
                PrivateLateBoundObject = theObject;
                PrivateSystemProperties = new ManagementSystemProperties(PrivateLateBoundObject);
                curObj = PrivateLateBoundObject;
            }
            else {
                throw new System.ArgumentException("Class name does not match.");
            }
        }
        
        public IIsApplicationPool(System.Management.ManagementBaseObject theObject) {
            if ((CheckIfProperClass(theObject) == true)) {
                embeddedObj = theObject;
                PrivateSystemProperties = new ManagementSystemProperties(theObject);
                curObj = embeddedObj;
                isEmbedded = true;
            }
            else {
                throw new System.ArgumentException("Class name does not match.");
            }
        }
        
        // Property returns the namespace of the WMI class.
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string OriginatingNamespace {
            get {
                return "ROOT\\MicrosoftIISv2";
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string ManagementClassName {
            get {
                string strRet = CreatedClassName;
                if ((curObj != null)) {
                    if ((curObj.ClassPath != null)) {
                        strRet = ((string)(curObj["__CLASS"]));
                        if (((strRet == null) 
                                    || (strRet == System.String.Empty))) {
                            strRet = CreatedClassName;
                        }
                    }
                }
                return strRet;
            }
        }
        
        // Property pointing to an embedded object to get System properties of the WMI object.
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public ManagementSystemProperties SystemProperties {
            get {
                return PrivateSystemProperties;
            }
        }
        
        // Property returning the underlying lateBound object.
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Management.ManagementBaseObject LateBoundObject {
            get {
                return curObj;
            }
        }
        
        // ManagementScope of the object.
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Management.ManagementScope Scope {
            get {
                if ((isEmbedded == false)) {
                    return PrivateLateBoundObject.Scope;
                }
                else {
                    return null;
                }
            }
            set {
                if ((isEmbedded == false)) {
                    PrivateLateBoundObject.Scope = value;
                }
            }
        }
        
        // Property to show the commit behavior for the WMI object. If true, WMI object will be automatically saved after each property modification.(ie. Put() is called after modification of a property).
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool AutoCommit {
            get {
                return AutoCommitProp;
            }
            set {
                AutoCommitProp = value;
            }
        }
        
        // The ManagementPath of the underlying WMI object.
        [Browsable(true)]
        public System.Management.ManagementPath Path {
            get {
                if ((isEmbedded == false)) {
                    return PrivateLateBoundObject.Path;
                }
                else {
                    return null;
                }
            }
            set {
                if ((isEmbedded == false)) {
                    if ((CheckIfProperClass(null, value, null) != true)) {
                        throw new System.ArgumentException("Class name does not match.");
                    }
                    PrivateLateBoundObject.Path = value;
                }
            }
        }
        
        // Public static scope property which is used by the various methods.
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public static System.Management.ManagementScope StaticScope {
            get {
                return statMgmtScope;
            }
            set {
                statMgmtScope = value;
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string Caption {
            get {
                return ((string)(curObj["Caption"]));
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string Description {
            get {
                return ((string)(curObj["Description"]));
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsInstallDateNull {
            get {
                if ((curObj["InstallDate"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public System.DateTime InstallDate {
            get {
                if ((curObj["InstallDate"] != null)) {
                    return ToDateTime(((string)(curObj["InstallDate"])));
                }
                else {
                    return System.DateTime.MinValue;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string Name {
            get {
                return ((string)(curObj["Name"]));
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string Status {
            get {
                return ((string)(curObj["Status"]));
            }
        }
        
        private bool CheckIfProperClass(System.Management.ManagementScope mgmtScope, System.Management.ManagementPath path, System.Management.ObjectGetOptions OptionsParam) {
            if (((path != null) 
                        && (System.String.Compare(path.ClassName, ManagementClassName, true, CultureInfo.InvariantCulture) == 0))) {
                return true;
            }
            else {
                return CheckIfProperClass(new System.Management.ManagementObject(mgmtScope, path, OptionsParam));
            }
        }
        
        private bool CheckIfProperClass(System.Management.ManagementBaseObject theObj) {
            if (((theObj != null) 
                        && (System.String.Compare(((string)(theObj["__CLASS"])), ManagementClassName, true, CultureInfo.InvariantCulture) == 0))) {
                return true;
            }
            else {
                System.Array parentClasses = ((System.Array)(theObj["__DERIVATION"]));
                if ((parentClasses != null)) {
                    Int32 count = 0;
                    for (count = 0; (count < parentClasses.Length); count = (count + 1)) {
                        if ((System.String.Compare(((string)(parentClasses.GetValue(count))), ManagementClassName, true, CultureInfo.InvariantCulture) == 0)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        
        // Converts a given datetime in DMTF format to System.DateTime object.
        static System.DateTime ToDateTime(string dmtfDate) {
            int year = System.DateTime.MinValue.Year;
            int month = System.DateTime.MinValue.Month;
            int day = System.DateTime.MinValue.Day;
            int hour = System.DateTime.MinValue.Hour;
            int minute = System.DateTime.MinValue.Minute;
            int second = System.DateTime.MinValue.Second;
            long ticks = 0;
            string dmtf = dmtfDate;
            System.DateTime datetime = System.DateTime.MinValue;
            string tempString = System.String.Empty;
            if ((dmtf == null)) {
                throw new System.ArgumentOutOfRangeException();
            }
            if ((dmtf.Length == 0)) {
                throw new System.ArgumentOutOfRangeException();
            }
            if ((dmtf.Length != 25)) {
                throw new System.ArgumentOutOfRangeException();
            }
            try {
                tempString = dmtf.Substring(0, 4);
                if (("****" != tempString)) {
                    year = System.Int32.Parse(tempString);
                }
                tempString = dmtf.Substring(4, 2);
                if (("**" != tempString)) {
                    month = System.Int32.Parse(tempString);
                }
                tempString = dmtf.Substring(6, 2);
                if (("**" != tempString)) {
                    day = System.Int32.Parse(tempString);
                }
                tempString = dmtf.Substring(8, 2);
                if (("**" != tempString)) {
                    hour = System.Int32.Parse(tempString);
                }
                tempString = dmtf.Substring(10, 2);
                if (("**" != tempString)) {
                    minute = System.Int32.Parse(tempString);
                }
                tempString = dmtf.Substring(12, 2);
                if (("**" != tempString)) {
                    second = System.Int32.Parse(tempString);
                }
                tempString = dmtf.Substring(15, 6);
                if (("******" != tempString)) {
                    ticks = (System.Int64.Parse(tempString) 
                                * (System.TimeSpan.TicksPerMillisecond / 1000));
                }
                if (((((((((year < 0) 
                            || (month < 0)) 
                            || (day < 0)) 
                            || (hour < 0)) 
                            || (minute < 0)) 
                            || (minute < 0)) 
                            || (second < 0)) 
                            || (ticks < 0))) {
                    throw new System.ArgumentOutOfRangeException();
                }
            }
            catch (System.Exception) {
                throw new System.ArgumentOutOfRangeException();
            }
            datetime = new System.DateTime(year, month, day, hour, minute, second, 0);
            datetime = datetime.AddTicks(ticks);
            System.TimeSpan tickOffset = System.TimeZone.CurrentTimeZone.GetUtcOffset(datetime);
            int UTCOffset = 0;
            long OffsetToBeAdjusted = 0;
            long OffsetMins = (tickOffset.Ticks / System.TimeSpan.TicksPerMinute);
            tempString = dmtf.Substring(22, 3);
            if ((tempString != "***")) {
                tempString = dmtf.Substring(21, 4);
                try {
                    UTCOffset = System.Int32.Parse(tempString);
                }
                catch (System.Exception) {
                    throw new System.ArgumentOutOfRangeException();
                }
                OffsetToBeAdjusted = (OffsetMins - UTCOffset);
                datetime = datetime.AddMinutes(OffsetToBeAdjusted);
            }
            return datetime;
        }
        
        // Converts a given System.DateTime object to DMTF datetime format.
        static string ToDmtfDateTime(System.DateTime date) {
            string utcString = System.String.Empty;
            System.TimeSpan tickOffset = System.TimeZone.CurrentTimeZone.GetUtcOffset(date);
            long OffsetMins = (tickOffset.Ticks / System.TimeSpan.TicksPerMinute);
            if ((System.Math.Abs(OffsetMins) > 999)) {
                date = date.ToUniversalTime();
                utcString = "+000";
            }
            else {
                if ((tickOffset.Ticks >= 0)) {
                    utcString = ("+" + ((tickOffset.Ticks / System.TimeSpan.TicksPerMinute)).ToString().PadLeft(3, '0'));
                }
                else {
                    string strTemp = OffsetMins.ToString();
                    utcString = ("-" + strTemp.Substring(1, (strTemp.Length - 1)).PadLeft(3, '0'));
                }
            }
            string dmtfDateTime = date.Year.ToString().PadLeft(4, '0');
            dmtfDateTime = (dmtfDateTime + date.Month.ToString().PadLeft(2, '0'));
            dmtfDateTime = (dmtfDateTime + date.Day.ToString().PadLeft(2, '0'));
            dmtfDateTime = (dmtfDateTime + date.Hour.ToString().PadLeft(2, '0'));
            dmtfDateTime = (dmtfDateTime + date.Minute.ToString().PadLeft(2, '0'));
            dmtfDateTime = (dmtfDateTime + date.Second.ToString().PadLeft(2, '0'));
            dmtfDateTime = (dmtfDateTime + ".");
            System.DateTime dtTemp = new System.DateTime(date.Year, date.Month, date.Day, date.Hour, date.Minute, date.Second, 0);
            long microsec = (((date.Ticks - dtTemp.Ticks) 
                        * 1000) 
                        / System.TimeSpan.TicksPerMillisecond);
            string strMicrosec = microsec.ToString();
            if ((strMicrosec.Length > 6)) {
                strMicrosec = strMicrosec.Substring(0, 6);
            }
            dmtfDateTime = (dmtfDateTime + strMicrosec.PadLeft(6, '0'));
            dmtfDateTime = (dmtfDateTime + utcString);
            return dmtfDateTime;
        }
        
        private bool ShouldSerializeInstallDate() {
            if ((IsInstallDateNull == false)) {
                return true;
            }
            return false;
        }
        
        [Browsable(true)]
        public void CommitObject() {
            if ((isEmbedded == false)) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private static string ConstructPath(string keyName) {
            string strPath = "ROOT\\MicrosoftIISv2:IIsApplicationPool";
            strPath = (strPath 
                        + (".Name=" 
                        + ("\"" 
                        + (keyName + "\""))));
            return strPath;
        }
        
        // Different overloads of GetInstances() help in enumerating instances of the WMI class.
        public static IIsApplicationPoolCollection GetInstances() {
            return GetInstances(((System.Management.ManagementScope)(null)), ((System.Management.EnumerationOptions)(null)));
        }
        
        public static IIsApplicationPoolCollection GetInstances(string condition) {
            return GetInstances(null, condition, null);
        }
        
        public static IIsApplicationPoolCollection GetInstances(System.String [] selectedProperties) {
            return GetInstances(null, null, selectedProperties);
        }
        
        public static IIsApplicationPoolCollection GetInstances(string condition, System.String [] selectedProperties) {
            return GetInstances(null, condition, selectedProperties);
        }
        
        public static IIsApplicationPoolCollection GetInstances(System.Management.ManagementScope mgmtScope, System.Management.EnumerationOptions enumOptions) {
            if ((mgmtScope == null)) {
                if ((statMgmtScope == null)) {
                    mgmtScope = new System.Management.ManagementScope();
                    mgmtScope.Path.NamespacePath = "root\\MicrosoftIISv2";
                }
                else {
                    mgmtScope = statMgmtScope;
                }
            }
            System.Management.ManagementPath pathObj = new System.Management.ManagementPath();
            pathObj.ClassName = "IIsApplicationPool";
            pathObj.NamespacePath = "root\\MicrosoftIISv2";
            System.Management.ManagementClass clsObject = new System.Management.ManagementClass(mgmtScope, pathObj, null);
            if ((enumOptions == null)) {
                enumOptions = new System.Management.EnumerationOptions();
                enumOptions.EnsureLocatable = true;
            }
            return new IIsApplicationPoolCollection(clsObject.GetInstances(enumOptions));
        }
        
        public static IIsApplicationPoolCollection GetInstances(System.Management.ManagementScope mgmtScope, string condition) {
            return GetInstances(mgmtScope, condition, null);
        }
        
        public static IIsApplicationPoolCollection GetInstances(System.Management.ManagementScope mgmtScope, System.String [] selectedProperties) {
            return GetInstances(mgmtScope, null, selectedProperties);
        }
        
        public static IIsApplicationPoolCollection GetInstances(System.Management.ManagementScope mgmtScope, string condition, System.String [] selectedProperties) {
            if ((mgmtScope == null)) {
                if ((statMgmtScope == null)) {
                    mgmtScope = new System.Management.ManagementScope();
                    mgmtScope.Path.NamespacePath = "root\\MicrosoftIISv2";
                }
                else {
                    mgmtScope = statMgmtScope;
                }
            }
            System.Management.ManagementObjectSearcher ObjectSearcher = new System.Management.ManagementObjectSearcher(mgmtScope, new SelectQuery("IIsApplicationPool", condition, selectedProperties));
            System.Management.EnumerationOptions enumOptions = new System.Management.EnumerationOptions();
            enumOptions.EnsureLocatable = true;
            ObjectSearcher.Options = enumOptions;
            return new IIsApplicationPoolCollection(ObjectSearcher.Get());
        }
        
        [Browsable(true)]
        public static IIsApplicationPool CreateInstance() {
            System.Management.ManagementScope mgmtScope = null;
            if ((statMgmtScope == null)) {
                mgmtScope = new System.Management.ManagementScope();
                mgmtScope.Path.NamespacePath = CreatedWmiNamespace;
            }
            else {
                mgmtScope = statMgmtScope;
            }
            System.Management.ManagementPath mgmtPath = new System.Management.ManagementPath(CreatedClassName);
            return new IIsApplicationPool(new System.Management.ManagementClass(mgmtScope, mgmtPath, null).CreateInstance());
        }
        
        [Browsable(true)]
        public void Delete() {
            PrivateLateBoundObject.Delete();
        }
        
        public void EnumAppsInPool(out string[] Applications) {
            if ((isEmbedded == false)) {
                System.Management.ManagementBaseObject inParams = null;
                System.Management.ManagementBaseObject outParams = PrivateLateBoundObject.InvokeMethod("EnumAppsInPool", inParams, null);
                Applications = ((string[])(outParams.Properties["Applications"].Value));
            }
            else {
                Applications = null;
            }
        }
        
        public void Recycle() {
            if ((isEmbedded == false)) {
                System.Management.ManagementBaseObject inParams = null;
                PrivateLateBoundObject.InvokeMethod("Recycle", inParams, null);
            }
        }
        
        public void Start() {
            if ((isEmbedded == false)) {
                System.Management.ManagementBaseObject inParams = null;
                PrivateLateBoundObject.InvokeMethod("Start", inParams, null);
            }
        }
        
        public void Stop() {
            if ((isEmbedded == false)) {
                System.Management.ManagementBaseObject inParams = null;
                PrivateLateBoundObject.InvokeMethod("Stop", inParams, null);
            }
        }
        
        // Enumerator implementation for enumerating instances of the class.
        public class IIsApplicationPoolCollection : object, ICollection {
            
            private ManagementObjectCollection ObjectCollection;
            
            public IIsApplicationPoolCollection(ManagementObjectCollection objCollection) {
                ObjectCollection = objCollection;
            }
            
            public int Count {
                get {
                    return ObjectCollection.Count;
                }
            }
            
            public bool IsSynchronized {
                get {
                    return ObjectCollection.IsSynchronized;
                }
            }
            
            public object SyncRoot {
                get {
                    return this;
                }
            }
            
            public void CopyTo(System.Array array, int index) {
                ObjectCollection.CopyTo(array, index);
                int nCtr;
                for (nCtr = 0; (nCtr < array.Length); nCtr = (nCtr + 1)) {
                    array.SetValue(new IIsApplicationPool(((System.Management.ManagementObject)(array.GetValue(nCtr)))), nCtr);
                }
            }
            
            public System.Collections.IEnumerator GetEnumerator() {
                return new IIsApplicationPoolEnumerator(ObjectCollection.GetEnumerator());
            }
            
            public class IIsApplicationPoolEnumerator : object, System.Collections.IEnumerator {
                
                private ManagementObjectCollection.ManagementObjectEnumerator ObjectEnumerator;
                
                public IIsApplicationPoolEnumerator(ManagementObjectCollection.ManagementObjectEnumerator objEnum) {
                    ObjectEnumerator = objEnum;
                }
                
                public object Current {
                    get {
                        return new IIsApplicationPool(((System.Management.ManagementObject)(ObjectEnumerator.Current)));
                    }
                }
                
                public bool MoveNext() {
                    return ObjectEnumerator.MoveNext();
                }
                
                public void Reset() {
                    ObjectEnumerator.Reset();
                }
            }
        }
        
        // TypeConverter to handle null values for ValueType properties
        public class WMIValueTypeConverter : TypeConverter {
            
            private TypeConverter baseConverter;
            
            public WMIValueTypeConverter(System.Type baseType) {
                baseConverter = TypeDescriptor.GetConverter(baseType);
            }
            
            public override bool CanConvertFrom(System.ComponentModel.ITypeDescriptorContext context, System.Type srcType) {
                return baseConverter.CanConvertFrom(context, srcType);
            }
            
            public override bool CanConvertTo(System.ComponentModel.ITypeDescriptorContext context, System.Type destinationType) {
                return baseConverter.CanConvertTo(context, destinationType);
            }
            
            public override object ConvertFrom(System.ComponentModel.ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value) {
                return baseConverter.ConvertFrom(context, culture, value);
            }
            
            public override object CreateInstance(System.ComponentModel.ITypeDescriptorContext context, System.Collections.IDictionary dictionary) {
                return baseConverter.CreateInstance(context, dictionary);
            }
            
            public override bool GetCreateInstanceSupported(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetCreateInstanceSupported(context);
            }
            
            public override PropertyDescriptorCollection GetProperties(System.ComponentModel.ITypeDescriptorContext context, object value, System.Attribute[] attributeVar) {
                return baseConverter.GetProperties(context, value, attributeVar);
            }
            
            public override bool GetPropertiesSupported(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetPropertiesSupported(context);
            }
            
            public override System.ComponentModel.TypeConverter.StandardValuesCollection GetStandardValues(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetStandardValues(context);
            }
            
            public override bool GetStandardValuesExclusive(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetStandardValuesExclusive(context);
            }
            
            public override bool GetStandardValuesSupported(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetStandardValuesSupported(context);
            }
            
            public override object ConvertTo(System.ComponentModel.ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value, System.Type destinationType) {
                if ((context != null)) {
                    if ((context.PropertyDescriptor.ShouldSerializeValue(context.Instance) == false)) {
                        return "";
                    }
                }
                return baseConverter.ConvertTo(context, culture, value, destinationType);
            }
        }
        
        // Embedded class to represent WMI system Properties.
        [TypeConverter(typeof(System.ComponentModel.ExpandableObjectConverter))]
        public class ManagementSystemProperties {
            
            private System.Management.ManagementBaseObject PrivateLateBoundObject;
            
            public ManagementSystemProperties(System.Management.ManagementBaseObject ManagedObject) {
                PrivateLateBoundObject = ManagedObject;
            }
            
            [Browsable(true)]
            public int GENUS {
                get {
                    return ((int)(PrivateLateBoundObject["__GENUS"]));
                }
            }
            
            [Browsable(true)]
            public string CLASS {
                get {
                    return ((string)(PrivateLateBoundObject["__CLASS"]));
                }
            }
            
            [Browsable(true)]
            public string SUPERCLASS {
                get {
                    return ((string)(PrivateLateBoundObject["__SUPERCLASS"]));
                }
            }
            
            [Browsable(true)]
            public string DYNASTY {
                get {
                    return ((string)(PrivateLateBoundObject["__DYNASTY"]));
                }
            }
            
            [Browsable(true)]
            public string RELPATH {
                get {
                    return ((string)(PrivateLateBoundObject["__RELPATH"]));
                }
            }
            
            [Browsable(true)]
            public int PROPERTY_COUNT {
                get {
                    return ((int)(PrivateLateBoundObject["__PROPERTY_COUNT"]));
                }
            }
            
            [Browsable(true)]
            public string[] DERIVATION {
                get {
                    return ((string[])(PrivateLateBoundObject["__DERIVATION"]));
                }
            }
            
            [Browsable(true)]
            public string SERVER {
                get {
                    return ((string)(PrivateLateBoundObject["__SERVER"]));
                }
            }
            
            [Browsable(true)]
            public string NAMESPACE {
                get {
                    return ((string)(PrivateLateBoundObject["__NAMESPACE"]));
                }
            }
            
            [Browsable(true)]
            public string PATH {
                get {
                    return ((string)(PrivateLateBoundObject["__PATH"]));
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Wmi\iisv2\HttpError.CS ===
﻿namespace Leet.Tools.Setup.Wmi.Iisv2 {
    using System;
    using System.ComponentModel;
    using System.Management;
    using System.Collections;
    using System.Globalization;
    using System.ComponentModel.Design.Serialization;
    using System.Reflection;
    
    
    // Functions ShouldSerialize<PropertyName> are functions used by VS property browser to check if a particular property has to be serialized. These functions are added for all ValueType properties ( properties of type Int32, BOOL etc.. which cannot be set to null). These functions use Is<PropertyName>Null function. These functions are also used in the TypeConverter implementation for the properties to check for NULL value of property so that an empty value can be shown in Property browser in case of Drag and Drop in Visual studio.
    // Functions Is<PropertyName>Null() are used to check if a property is NULL.
    // Functions Reset<PropertyName> are added for Nullable Read/Write properties. These functions are used by VS designer in property browser to set a property to NULL.
    // Every property added to the class for WMI property has attributes set to define its behavior in Visual Studio designer and also to define a TypeConverter to be used.
    // An Early Bound class generated for the WMI class.HttpError
    public class HttpError : System.ComponentModel.Component {
        
        // Private property to hold the WMI namespace in which the class resides.
        private static string CreatedWmiNamespace = "ROOT\\MicrosoftIISv2";
        
        // Private property to hold the name of WMI class which created this class.
        private static string CreatedClassName = "HttpError";
        
        // Private member variable to hold the ManagementScope which is used by the various methods.
        private static System.Management.ManagementScope statMgmtScope = null;
        
        private ManagementSystemProperties PrivateSystemProperties;
        
        // Underlying lateBound WMI object.
        private System.Management.ManagementObject PrivateLateBoundObject;
        
        // Member variable to store the 'automatic commit' behavior for the class.
        private bool AutoCommitProp = true;
        
        // Private variable to hold the embedded property representing the instance.
        private System.Management.ManagementBaseObject embeddedObj;
        
        // The current WMI object used
        private System.Management.ManagementBaseObject curObj;
        
        // Flag to indicate if the instance is an embedded object.
        private bool isEmbedded = false;
        
        // Below are different overloads of constructors to initialize an instance of the class with a WMI object.
        public HttpError() : 
                this(((System.Management.ManagementScope)(null)), ((System.Management.ManagementPath)(null)), ((System.Management.ObjectGetOptions)(null))) {
        }
        
        public HttpError(string keyHandlerLocation, string keyHandlerType, string keyHttpErrorCode, string keyHttpErrorSubcode) : 
                this(((System.Management.ManagementScope)(null)), ((System.Management.ManagementPath)(new System.Management.ManagementPath(HttpError.ConstructPath(keyHandlerLocation, keyHandlerType, keyHttpErrorCode, keyHttpErrorSubcode)))), ((System.Management.ObjectGetOptions)(null))) {
        }
        
        public HttpError(System.Management.ManagementScope mgmtScope, string keyHandlerLocation, string keyHandlerType, string keyHttpErrorCode, string keyHttpErrorSubcode) : 
                this(((System.Management.ManagementScope)(mgmtScope)), ((System.Management.ManagementPath)(new System.Management.ManagementPath(HttpError.ConstructPath(keyHandlerLocation, keyHandlerType, keyHttpErrorCode, keyHttpErrorSubcode)))), ((System.Management.ObjectGetOptions)(null))) {
        }
        
        public HttpError(System.Management.ManagementPath path, System.Management.ObjectGetOptions getOptions) : 
                this(((System.Management.ManagementScope)(null)), ((System.Management.ManagementPath)(path)), ((System.Management.ObjectGetOptions)(getOptions))) {
        }
        
        public HttpError(System.Management.ManagementScope mgmtScope, System.Management.ManagementPath path) : 
                this(((System.Management.ManagementScope)(mgmtScope)), ((System.Management.ManagementPath)(path)), ((System.Management.ObjectGetOptions)(null))) {
        }
        
        public HttpError(System.Management.ManagementPath path) : 
                this(((System.Management.ManagementScope)(null)), ((System.Management.ManagementPath)(path)), ((System.Management.ObjectGetOptions)(null))) {
        }
        
        public HttpError(System.Management.ManagementScope mgmtScope, System.Management.ManagementPath path, System.Management.ObjectGetOptions getOptions) {
            if ((path != null)) {
                if ((CheckIfProperClass(mgmtScope, path, getOptions) != true)) {
                    throw new System.ArgumentException("Class name does not match.");
                }
            }
            PrivateLateBoundObject = new System.Management.ManagementObject(mgmtScope, path, getOptions);
            PrivateSystemProperties = new ManagementSystemProperties(PrivateLateBoundObject);
            curObj = PrivateLateBoundObject;
        }
        
        public HttpError(System.Management.ManagementObject theObject) {
            if ((CheckIfProperClass(theObject) == true)) {
                PrivateLateBoundObject = theObject;
                PrivateSystemProperties = new ManagementSystemProperties(PrivateLateBoundObject);
                curObj = PrivateLateBoundObject;
            }
            else {
                throw new System.ArgumentException("Class name does not match.");
            }
        }
        
        public HttpError(System.Management.ManagementBaseObject theObject) {
            if ((CheckIfProperClass(theObject) == true)) {
                embeddedObj = theObject;
                PrivateSystemProperties = new ManagementSystemProperties(theObject);
                curObj = embeddedObj;
                isEmbedded = true;
            }
            else {
                throw new System.ArgumentException("Class name does not match.");
            }
        }
        
        // Property returns the namespace of the WMI class.
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string OriginatingNamespace {
            get {
                return "ROOT\\MicrosoftIISv2";
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string ManagementClassName {
            get {
                string strRet = CreatedClassName;
                if ((curObj != null)) {
                    if ((curObj.ClassPath != null)) {
                        strRet = ((string)(curObj["__CLASS"]));
                        if (((strRet == null) 
                                    || (strRet == System.String.Empty))) {
                            strRet = CreatedClassName;
                        }
                    }
                }
                return strRet;
            }
        }
        
        // Property pointing to an embedded object to get System properties of the WMI object.
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public ManagementSystemProperties SystemProperties {
            get {
                return PrivateSystemProperties;
            }
        }
        
        // Property returning the underlying lateBound object.
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Management.ManagementBaseObject LateBoundObject {
            get {
                return curObj;
            }
        }
        
        // ManagementScope of the object.
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Management.ManagementScope Scope {
            get {
                if ((isEmbedded == false)) {
                    return PrivateLateBoundObject.Scope;
                }
                else {
                    return null;
                }
            }
            set {
                if ((isEmbedded == false)) {
                    PrivateLateBoundObject.Scope = value;
                }
            }
        }
        
        // Property to show the commit behavior for the WMI object. If true, WMI object will be automatically saved after each property modification.(ie. Put() is called after modification of a property).
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool AutoCommit {
            get {
                return AutoCommitProp;
            }
            set {
                AutoCommitProp = value;
            }
        }
        
        // The ManagementPath of the underlying WMI object.
        [Browsable(true)]
        public System.Management.ManagementPath Path {
            get {
                if ((isEmbedded == false)) {
                    return PrivateLateBoundObject.Path;
                }
                else {
                    return null;
                }
            }
            set {
                if ((isEmbedded == false)) {
                    if ((CheckIfProperClass(null, value, null) != true)) {
                        throw new System.ArgumentException("Class name does not match.");
                    }
                    PrivateLateBoundObject.Path = value;
                }
            }
        }
        
        // Public static scope property which is used by the various methods.
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public static System.Management.ManagementScope StaticScope {
            get {
                return statMgmtScope;
            }
            set {
                statMgmtScope = value;
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string HandlerLocation {
            get {
                return ((string)(curObj["HandlerLocation"]));
            }
            set {
                curObj["HandlerLocation"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string HandlerType {
            get {
                return ((string)(curObj["HandlerType"]));
            }
            set {
                curObj["HandlerType"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string HttpErrorCode {
            get {
                return ((string)(curObj["HttpErrorCode"]));
            }
            set {
                curObj["HttpErrorCode"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string HttpErrorSubcode {
            get {
                return ((string)(curObj["HttpErrorSubcode"]));
            }
            set {
                curObj["HttpErrorSubcode"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        private bool CheckIfProperClass(System.Management.ManagementScope mgmtScope, System.Management.ManagementPath path, System.Management.ObjectGetOptions OptionsParam) {
            if (((path != null) 
                        && (System.String.Compare(path.ClassName, ManagementClassName, true, CultureInfo.InvariantCulture) == 0))) {
                return true;
            }
            else {
                return CheckIfProperClass(new System.Management.ManagementObject(mgmtScope, path, OptionsParam));
            }
        }
        
        private bool CheckIfProperClass(System.Management.ManagementBaseObject theObj) {
            if (((theObj != null) 
                        && (System.String.Compare(((string)(theObj["__CLASS"])), ManagementClassName, true, CultureInfo.InvariantCulture) == 0))) {
                return true;
            }
            else {
                System.Array parentClasses = ((System.Array)(theObj["__DERIVATION"]));
                if ((parentClasses != null)) {
                    Int32 count = 0;
                    for (count = 0; (count < parentClasses.Length); count = (count + 1)) {
                        if ((System.String.Compare(((string)(parentClasses.GetValue(count))), ManagementClassName, true, CultureInfo.InvariantCulture) == 0)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        
        [Browsable(true)]
        public void CommitObject() {
            if ((isEmbedded == false)) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private static string ConstructPath(string keyHandlerLocation, string keyHandlerType, string keyHttpErrorCode, string keyHttpErrorSubcode) {
            string strPath = "ROOT\\MicrosoftIISv2:HttpError";
            strPath = (strPath 
                        + (".HandlerLocation=" 
                        + ("\"" 
                        + (keyHandlerLocation + "\""))));
            strPath = (strPath 
                        + (",HandlerType=" 
                        + ("\"" 
                        + (keyHandlerType + "\""))));
            strPath = (strPath 
                        + (",HttpErrorCode=" 
                        + ("\"" 
                        + (keyHttpErrorCode + "\""))));
            strPath = (strPath 
                        + (",HttpErrorSubcode=" 
                        + ("\"" 
                        + (keyHttpErrorSubcode + "\""))));
            return strPath;
        }
        
        // Different overloads of GetInstances() help in enumerating instances of the WMI class.
        public static HttpErrorCollection GetInstances() {
            return GetInstances(((System.Management.ManagementScope)(null)), ((System.Management.EnumerationOptions)(null)));
        }
        
        public static HttpErrorCollection GetInstances(string condition) {
            return GetInstances(null, condition, null);
        }
        
        public static HttpErrorCollection GetInstances(System.String [] selectedProperties) {
            return GetInstances(null, null, selectedProperties);
        }
        
        public static HttpErrorCollection GetInstances(string condition, System.String [] selectedProperties) {
            return GetInstances(null, condition, selectedProperties);
        }
        
        public static HttpErrorCollection GetInstances(System.Management.ManagementScope mgmtScope, System.Management.EnumerationOptions enumOptions) {
            if ((mgmtScope == null)) {
                if ((statMgmtScope == null)) {
                    mgmtScope = new System.Management.ManagementScope();
                    mgmtScope.Path.NamespacePath = "root\\MicrosoftIISv2";
                }
                else {
                    mgmtScope = statMgmtScope;
                }
            }
            System.Management.ManagementPath pathObj = new System.Management.ManagementPath();
            pathObj.ClassName = "HttpError";
            pathObj.NamespacePath = "root\\MicrosoftIISv2";
            System.Management.ManagementClass clsObject = new System.Management.ManagementClass(mgmtScope, pathObj, null);
            if ((enumOptions == null)) {
                enumOptions = new System.Management.EnumerationOptions();
                enumOptions.EnsureLocatable = true;
            }
            return new HttpErrorCollection(clsObject.GetInstances(enumOptions));
        }
        
        public static HttpErrorCollection GetInstances(System.Management.ManagementScope mgmtScope, string condition) {
            return GetInstances(mgmtScope, condition, null);
        }
        
        public static HttpErrorCollection GetInstances(System.Management.ManagementScope mgmtScope, System.String [] selectedProperties) {
            return GetInstances(mgmtScope, null, selectedProperties);
        }
        
        public static HttpErrorCollection GetInstances(System.Management.ManagementScope mgmtScope, string condition, System.String [] selectedProperties) {
            if ((mgmtScope == null)) {
                if ((statMgmtScope == null)) {
                    mgmtScope = new System.Management.ManagementScope();
                    mgmtScope.Path.NamespacePath = "root\\MicrosoftIISv2";
                }
                else {
                    mgmtScope = statMgmtScope;
                }
            }
            System.Management.ManagementObjectSearcher ObjectSearcher = new System.Management.ManagementObjectSearcher(mgmtScope, new SelectQuery("HttpError", condition, selectedProperties));
            System.Management.EnumerationOptions enumOptions = new System.Management.EnumerationOptions();
            enumOptions.EnsureLocatable = true;
            ObjectSearcher.Options = enumOptions;
            return new HttpErrorCollection(ObjectSearcher.Get());
        }
        
        [Browsable(true)]
        public static HttpError CreateInstance() {
            System.Management.ManagementScope mgmtScope = null;
            if ((statMgmtScope == null)) {
                mgmtScope = new System.Management.ManagementScope();
                mgmtScope.Path.NamespacePath = CreatedWmiNamespace;
            }
            else {
                mgmtScope = statMgmtScope;
            }
            System.Management.ManagementPath mgmtPath = new System.Management.ManagementPath(CreatedClassName);
            return new HttpError(new System.Management.ManagementClass(mgmtScope, mgmtPath, null).CreateInstance());
        }
        
        [Browsable(true)]
        public void Delete() {
            PrivateLateBoundObject.Delete();
        }
        
        // Enumerator implementation for enumerating instances of the class.
        public class HttpErrorCollection : object, ICollection {
            
            private ManagementObjectCollection ObjectCollection;
            
            public HttpErrorCollection(ManagementObjectCollection objCollection) {
                ObjectCollection = objCollection;
            }
            
            public int Count {
                get {
                    return ObjectCollection.Count;
                }
            }
            
            public bool IsSynchronized {
                get {
                    return ObjectCollection.IsSynchronized;
                }
            }
            
            public object SyncRoot {
                get {
                    return this;
                }
            }
            
            public void CopyTo(System.Array array, int index) {
                ObjectCollection.CopyTo(array, index);
                int nCtr;
                for (nCtr = 0; (nCtr < array.Length); nCtr = (nCtr + 1)) {
                    array.SetValue(new HttpError(((System.Management.ManagementObject)(array.GetValue(nCtr)))), nCtr);
                }
            }
            
            public System.Collections.IEnumerator GetEnumerator() {
                return new HttpErrorEnumerator(ObjectCollection.GetEnumerator());
            }
            
            public class HttpErrorEnumerator : object, System.Collections.IEnumerator {
                
                private ManagementObjectCollection.ManagementObjectEnumerator ObjectEnumerator;
                
                public HttpErrorEnumerator(ManagementObjectCollection.ManagementObjectEnumerator objEnum) {
                    ObjectEnumerator = objEnum;
                }
                
                public object Current {
                    get {
                        return new HttpError(((System.Management.ManagementObject)(ObjectEnumerator.Current)));
                    }
                }
                
                public bool MoveNext() {
                    return ObjectEnumerator.MoveNext();
                }
                
                public void Reset() {
                    ObjectEnumerator.Reset();
                }
            }
        }
        
        // TypeConverter to handle null values for ValueType properties
        public class WMIValueTypeConverter : TypeConverter {
            
            private TypeConverter baseConverter;
            
            public WMIValueTypeConverter(System.Type baseType) {
                baseConverter = TypeDescriptor.GetConverter(baseType);
            }
            
            public override bool CanConvertFrom(System.ComponentModel.ITypeDescriptorContext context, System.Type srcType) {
                return baseConverter.CanConvertFrom(context, srcType);
            }
            
            public override bool CanConvertTo(System.ComponentModel.ITypeDescriptorContext context, System.Type destinationType) {
                return baseConverter.CanConvertTo(context, destinationType);
            }
            
            public override object ConvertFrom(System.ComponentModel.ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value) {
                return baseConverter.ConvertFrom(context, culture, value);
            }
            
            public override object CreateInstance(System.ComponentModel.ITypeDescriptorContext context, System.Collections.IDictionary dictionary) {
                return baseConverter.CreateInstance(context, dictionary);
            }
            
            public override bool GetCreateInstanceSupported(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetCreateInstanceSupported(context);
            }
            
            public override PropertyDescriptorCollection GetProperties(System.ComponentModel.ITypeDescriptorContext context, object value, System.Attribute[] attributeVar) {
                return baseConverter.GetProperties(context, value, attributeVar);
            }
            
            public override bool GetPropertiesSupported(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetPropertiesSupported(context);
            }
            
            public override System.ComponentModel.TypeConverter.StandardValuesCollection GetStandardValues(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetStandardValues(context);
            }
            
            public override bool GetStandardValuesExclusive(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetStandardValuesExclusive(context);
            }
            
            public override bool GetStandardValuesSupported(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetStandardValuesSupported(context);
            }
            
            public override object ConvertTo(System.ComponentModel.ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value, System.Type destinationType) {
                if ((context != null)) {
                    if ((context.PropertyDescriptor.ShouldSerializeValue(context.Instance) == false)) {
                        return "";
                    }
                }
                return baseConverter.ConvertTo(context, culture, value, destinationType);
            }
        }
        
        // Embedded class to represent WMI system Properties.
        [TypeConverter(typeof(System.ComponentModel.ExpandableObjectConverter))]
        public class ManagementSystemProperties {
            
            private System.Management.ManagementBaseObject PrivateLateBoundObject;
            
            public ManagementSystemProperties(System.Management.ManagementBaseObject ManagedObject) {
                PrivateLateBoundObject = ManagedObject;
            }
            
            [Browsable(true)]
            public int GENUS {
                get {
                    return ((int)(PrivateLateBoundObject["__GENUS"]));
                }
            }
            
            [Browsable(true)]
            public string CLASS {
                get {
                    return ((string)(PrivateLateBoundObject["__CLASS"]));
                }
            }
            
            [Browsable(true)]
            public string SUPERCLASS {
                get {
                    return ((string)(PrivateLateBoundObject["__SUPERCLASS"]));
                }
            }
            
            [Browsable(true)]
            public string DYNASTY {
                get {
                    return ((string)(PrivateLateBoundObject["__DYNASTY"]));
                }
            }
            
            [Browsable(true)]
            public string RELPATH {
                get {
                    return ((string)(PrivateLateBoundObject["__RELPATH"]));
                }
            }
            
            [Browsable(true)]
            public int PROPERTY_COUNT {
                get {
                    return ((int)(PrivateLateBoundObject["__PROPERTY_COUNT"]));
                }
            }
            
            [Browsable(true)]
            public string[] DERIVATION {
                get {
                    return ((string[])(PrivateLateBoundObject["__DERIVATION"]));
                }
            }
            
            [Browsable(true)]
            public string SERVER {
                get {
                    return ((string)(PrivateLateBoundObject["__SERVER"]));
                }
            }
            
            [Browsable(true)]
            public string NAMESPACE {
                get {
                    return ((string)(PrivateLateBoundObject["__NAMESPACE"]));
                }
            }
            
            [Browsable(true)]
            public string PATH {
                get {
                    return ((string)(PrivateLateBoundObject["__PATH"]));
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Wmi\iisv2\IIsApplicationPools.CS ===
﻿namespace Leet.Tools.Setup.Wmi.Iisv2 {
    using System;
    using System.ComponentModel;
    using System.Management;
    using System.Collections;
    using System.Globalization;
    using System.ComponentModel.Design.Serialization;
    using System.Reflection;
    
    
    // Functions ShouldSerialize<PropertyName> are functions used by VS property browser to check if a particular property has to be serialized. These functions are added for all ValueType properties ( properties of type Int32, BOOL etc.. which cannot be set to null). These functions use Is<PropertyName>Null function. These functions are also used in the TypeConverter implementation for the properties to check for NULL value of property so that an empty value can be shown in Property browser in case of Drag and Drop in Visual studio.
    // Functions Is<PropertyName>Null() are used to check if a property is NULL.
    // Functions Reset<PropertyName> are added for Nullable Read/Write properties. These functions are used by VS designer in property browser to set a property to NULL.
    // Every property added to the class for WMI property has attributes set to define its behavior in Visual Studio designer and also to define a TypeConverter to be used.
    // Datetime conversion functions ToDateTime and ToDmtfDateTime are added to the class to convert DMTF datetime to System.DateTime and vice-versa.
    // An Early Bound class generated for the WMI class.IIsApplicationPools
    public class IIsApplicationPools : System.ComponentModel.Component {
        
        // Private property to hold the WMI namespace in which the class resides.
        private static string CreatedWmiNamespace = "ROOT\\MicrosoftIISv2";
        
        // Private property to hold the name of WMI class which created this class.
        private static string CreatedClassName = "IIsApplicationPools";
        
        // Private member variable to hold the ManagementScope which is used by the various methods.
        private static System.Management.ManagementScope statMgmtScope = null;
        
        private ManagementSystemProperties PrivateSystemProperties;
        
        // Underlying lateBound WMI object.
        private System.Management.ManagementObject PrivateLateBoundObject;
        
        // Member variable to store the 'automatic commit' behavior for the class.
        private bool AutoCommitProp = true;
        
        // Private variable to hold the embedded property representing the instance.
        private System.Management.ManagementBaseObject embeddedObj;
        
        // The current WMI object used
        private System.Management.ManagementBaseObject curObj;
        
        // Flag to indicate if the instance is an embedded object.
        private bool isEmbedded = false;
        
        // Below are different overloads of constructors to initialize an instance of the class with a WMI object.
        public IIsApplicationPools() : 
                this(((System.Management.ManagementScope)(null)), ((System.Management.ManagementPath)(null)), ((System.Management.ObjectGetOptions)(null))) {
        }
        
        public IIsApplicationPools(string keyName) : 
                this(((System.Management.ManagementScope)(null)), ((System.Management.ManagementPath)(new System.Management.ManagementPath(IIsApplicationPools.ConstructPath(keyName)))), ((System.Management.ObjectGetOptions)(null))) {
        }
        
        public IIsApplicationPools(System.Management.ManagementScope mgmtScope, string keyName) : 
                this(((System.Management.ManagementScope)(mgmtScope)), ((System.Management.ManagementPath)(new System.Management.ManagementPath(IIsApplicationPools.ConstructPath(keyName)))), ((System.Management.ObjectGetOptions)(null))) {
        }
        
        public IIsApplicationPools(System.Management.ManagementPath path, System.Management.ObjectGetOptions getOptions) : 
                this(((System.Management.ManagementScope)(null)), ((System.Management.ManagementPath)(path)), ((System.Management.ObjectGetOptions)(getOptions))) {
        }
        
        public IIsApplicationPools(System.Management.ManagementScope mgmtScope, System.Management.ManagementPath path) : 
                this(((System.Management.ManagementScope)(mgmtScope)), ((System.Management.ManagementPath)(path)), ((System.Management.ObjectGetOptions)(null))) {
        }
        
        public IIsApplicationPools(System.Management.ManagementPath path) : 
                this(((System.Management.ManagementScope)(null)), ((System.Management.ManagementPath)(path)), ((System.Management.ObjectGetOptions)(null))) {
        }
        
        public IIsApplicationPools(System.Management.ManagementScope mgmtScope, System.Management.ManagementPath path, System.Management.ObjectGetOptions getOptions) {
            if ((path != null)) {
                if ((CheckIfProperClass(mgmtScope, path, getOptions) != true)) {
                    throw new System.ArgumentException("Class name does not match.");
                }
            }
            PrivateLateBoundObject = new System.Management.ManagementObject(mgmtScope, path, getOptions);
            PrivateSystemProperties = new ManagementSystemProperties(PrivateLateBoundObject);
            curObj = PrivateLateBoundObject;
        }
        
        public IIsApplicationPools(System.Management.ManagementObject theObject) {
            if ((CheckIfProperClass(theObject) == true)) {
                PrivateLateBoundObject = theObject;
                PrivateSystemProperties = new ManagementSystemProperties(PrivateLateBoundObject);
                curObj = PrivateLateBoundObject;
            }
            else {
                throw new System.ArgumentException("Class name does not match.");
            }
        }
        
        public IIsApplicationPools(System.Management.ManagementBaseObject theObject) {
            if ((CheckIfProperClass(theObject) == true)) {
                embeddedObj = theObject;
                PrivateSystemProperties = new ManagementSystemProperties(theObject);
                curObj = embeddedObj;
                isEmbedded = true;
            }
            else {
                throw new System.ArgumentException("Class name does not match.");
            }
        }
        
        // Property returns the namespace of the WMI class.
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string OriginatingNamespace {
            get {
                return "ROOT\\MicrosoftIISv2";
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string ManagementClassName {
            get {
                string strRet = CreatedClassName;
                if ((curObj != null)) {
                    if ((curObj.ClassPath != null)) {
                        strRet = ((string)(curObj["__CLASS"]));
                        if (((strRet == null) 
                                    || (strRet == System.String.Empty))) {
                            strRet = CreatedClassName;
                        }
                    }
                }
                return strRet;
            }
        }
        
        // Property pointing to an embedded object to get System properties of the WMI object.
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public ManagementSystemProperties SystemProperties {
            get {
                return PrivateSystemProperties;
            }
        }
        
        // Property returning the underlying lateBound object.
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Management.ManagementBaseObject LateBoundObject {
            get {
                return curObj;
            }
        }
        
        // ManagementScope of the object.
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Management.ManagementScope Scope {
            get {
                if ((isEmbedded == false)) {
                    return PrivateLateBoundObject.Scope;
                }
                else {
                    return null;
                }
            }
            set {
                if ((isEmbedded == false)) {
                    PrivateLateBoundObject.Scope = value;
                }
            }
        }
        
        // Property to show the commit behavior for the WMI object. If true, WMI object will be automatically saved after each property modification.(ie. Put() is called after modification of a property).
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool AutoCommit {
            get {
                return AutoCommitProp;
            }
            set {
                AutoCommitProp = value;
            }
        }
        
        // The ManagementPath of the underlying WMI object.
        [Browsable(true)]
        public System.Management.ManagementPath Path {
            get {
                if ((isEmbedded == false)) {
                    return PrivateLateBoundObject.Path;
                }
                else {
                    return null;
                }
            }
            set {
                if ((isEmbedded == false)) {
                    if ((CheckIfProperClass(null, value, null) != true)) {
                        throw new System.ArgumentException("Class name does not match.");
                    }
                    PrivateLateBoundObject.Path = value;
                }
            }
        }
        
        // Public static scope property which is used by the various methods.
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public static System.Management.ManagementScope StaticScope {
            get {
                return statMgmtScope;
            }
            set {
                statMgmtScope = value;
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string Caption {
            get {
                return ((string)(curObj["Caption"]));
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string Description {
            get {
                return ((string)(curObj["Description"]));
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsInstallDateNull {
            get {
                if ((curObj["InstallDate"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public System.DateTime InstallDate {
            get {
                if ((curObj["InstallDate"] != null)) {
                    return ToDateTime(((string)(curObj["InstallDate"])));
                }
                else {
                    return System.DateTime.MinValue;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string Name {
            get {
                return ((string)(curObj["Name"]));
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string Status {
            get {
                return ((string)(curObj["Status"]));
            }
        }
        
        private bool CheckIfProperClass(System.Management.ManagementScope mgmtScope, System.Management.ManagementPath path, System.Management.ObjectGetOptions OptionsParam) {
            if (((path != null) 
                        && (System.String.Compare(path.ClassName, ManagementClassName, true, CultureInfo.InvariantCulture) == 0))) {
                return true;
            }
            else {
                return CheckIfProperClass(new System.Management.ManagementObject(mgmtScope, path, OptionsParam));
            }
        }
        
        private bool CheckIfProperClass(System.Management.ManagementBaseObject theObj) {
            if (((theObj != null) 
                        && (System.String.Compare(((string)(theObj["__CLASS"])), ManagementClassName, true, CultureInfo.InvariantCulture) == 0))) {
                return true;
            }
            else {
                System.Array parentClasses = ((System.Array)(theObj["__DERIVATION"]));
                if ((parentClasses != null)) {
                    Int32 count = 0;
                    for (count = 0; (count < parentClasses.Length); count = (count + 1)) {
                        if ((System.String.Compare(((string)(parentClasses.GetValue(count))), ManagementClassName, true, CultureInfo.InvariantCulture) == 0)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        
        // Converts a given datetime in DMTF format to System.DateTime object.
        static System.DateTime ToDateTime(string dmtfDate) {
            int year = System.DateTime.MinValue.Year;
            int month = System.DateTime.MinValue.Month;
            int day = System.DateTime.MinValue.Day;
            int hour = System.DateTime.MinValue.Hour;
            int minute = System.DateTime.MinValue.Minute;
            int second = System.DateTime.MinValue.Second;
            long ticks = 0;
            string dmtf = dmtfDate;
            System.DateTime datetime = System.DateTime.MinValue;
            string tempString = System.String.Empty;
            if ((dmtf == null)) {
                throw new System.ArgumentOutOfRangeException();
            }
            if ((dmtf.Length == 0)) {
                throw new System.ArgumentOutOfRangeException();
            }
            if ((dmtf.Length != 25)) {
                throw new System.ArgumentOutOfRangeException();
            }
            try {
                tempString = dmtf.Substring(0, 4);
                if (("****" != tempString)) {
                    year = System.Int32.Parse(tempString);
                }
                tempString = dmtf.Substring(4, 2);
                if (("**" != tempString)) {
                    month = System.Int32.Parse(tempString);
                }
                tempString = dmtf.Substring(6, 2);
                if (("**" != tempString)) {
                    day = System.Int32.Parse(tempString);
                }
                tempString = dmtf.Substring(8, 2);
                if (("**" != tempString)) {
                    hour = System.Int32.Parse(tempString);
                }
                tempString = dmtf.Substring(10, 2);
                if (("**" != tempString)) {
                    minute = System.Int32.Parse(tempString);
                }
                tempString = dmtf.Substring(12, 2);
                if (("**" != tempString)) {
                    second = System.Int32.Parse(tempString);
                }
                tempString = dmtf.Substring(15, 6);
                if (("******" != tempString)) {
                    ticks = (System.Int64.Parse(tempString) 
                                * (System.TimeSpan.TicksPerMillisecond / 1000));
                }
                if (((((((((year < 0) 
                            || (month < 0)) 
                            || (day < 0)) 
                            || (hour < 0)) 
                            || (minute < 0)) 
                            || (minute < 0)) 
                            || (second < 0)) 
                            || (ticks < 0))) {
                    throw new System.ArgumentOutOfRangeException();
                }
            }
            catch (System.Exception) {
                throw new System.ArgumentOutOfRangeException();
            }
            datetime = new System.DateTime(year, month, day, hour, minute, second, 0);
            datetime = datetime.AddTicks(ticks);
            System.TimeSpan tickOffset = System.TimeZone.CurrentTimeZone.GetUtcOffset(datetime);
            int UTCOffset = 0;
            long OffsetToBeAdjusted = 0;
            long OffsetMins = (tickOffset.Ticks / System.TimeSpan.TicksPerMinute);
            tempString = dmtf.Substring(22, 3);
            if ((tempString != "***")) {
                tempString = dmtf.Substring(21, 4);
                try {
                    UTCOffset = System.Int32.Parse(tempString);
                }
                catch (System.Exception) {
                    throw new System.ArgumentOutOfRangeException();
                }
                OffsetToBeAdjusted = (OffsetMins - UTCOffset);
                datetime = datetime.AddMinutes(OffsetToBeAdjusted);
            }
            return datetime;
        }
        
        // Converts a given System.DateTime object to DMTF datetime format.
        static string ToDmtfDateTime(System.DateTime date) {
            string utcString = System.String.Empty;
            System.TimeSpan tickOffset = System.TimeZone.CurrentTimeZone.GetUtcOffset(date);
            long OffsetMins = (tickOffset.Ticks / System.TimeSpan.TicksPerMinute);
            if ((System.Math.Abs(OffsetMins) > 999)) {
                date = date.ToUniversalTime();
                utcString = "+000";
            }
            else {
                if ((tickOffset.Ticks >= 0)) {
                    utcString = ("+" + ((tickOffset.Ticks / System.TimeSpan.TicksPerMinute)).ToString().PadLeft(3, '0'));
                }
                else {
                    string strTemp = OffsetMins.ToString();
                    utcString = ("-" + strTemp.Substring(1, (strTemp.Length - 1)).PadLeft(3, '0'));
                }
            }
            string dmtfDateTime = date.Year.ToString().PadLeft(4, '0');
            dmtfDateTime = (dmtfDateTime + date.Month.ToString().PadLeft(2, '0'));
            dmtfDateTime = (dmtfDateTime + date.Day.ToString().PadLeft(2, '0'));
            dmtfDateTime = (dmtfDateTime + date.Hour.ToString().PadLeft(2, '0'));
            dmtfDateTime = (dmtfDateTime + date.Minute.ToString().PadLeft(2, '0'));
            dmtfDateTime = (dmtfDateTime + date.Second.ToString().PadLeft(2, '0'));
            dmtfDateTime = (dmtfDateTime + ".");
            System.DateTime dtTemp = new System.DateTime(date.Year, date.Month, date.Day, date.Hour, date.Minute, date.Second, 0);
            long microsec = (((date.Ticks - dtTemp.Ticks) 
                        * 1000) 
                        / System.TimeSpan.TicksPerMillisecond);
            string strMicrosec = microsec.ToString();
            if ((strMicrosec.Length > 6)) {
                strMicrosec = strMicrosec.Substring(0, 6);
            }
            dmtfDateTime = (dmtfDateTime + strMicrosec.PadLeft(6, '0'));
            dmtfDateTime = (dmtfDateTime + utcString);
            return dmtfDateTime;
        }
        
        private bool ShouldSerializeInstallDate() {
            if ((IsInstallDateNull == false)) {
                return true;
            }
            return false;
        }
        
        [Browsable(true)]
        public void CommitObject() {
            if ((isEmbedded == false)) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private static string ConstructPath(string keyName) {
            string strPath = "ROOT\\MicrosoftIISv2:IIsApplicationPools";
            strPath = (strPath 
                        + (".Name=" 
                        + ("\"" 
                        + (keyName + "\""))));
            return strPath;
        }
        
        // Different overloads of GetInstances() help in enumerating instances of the WMI class.
        public static IIsApplicationPoolsCollection GetInstances() {
            return GetInstances(((System.Management.ManagementScope)(null)), ((System.Management.EnumerationOptions)(null)));
        }
        
        public static IIsApplicationPoolsCollection GetInstances(string condition) {
            return GetInstances(null, condition, null);
        }
        
        public static IIsApplicationPoolsCollection GetInstances(System.String [] selectedProperties) {
            return GetInstances(null, null, selectedProperties);
        }
        
        public static IIsApplicationPoolsCollection GetInstances(string condition, System.String [] selectedProperties) {
            return GetInstances(null, condition, selectedProperties);
        }
        
        public static IIsApplicationPoolsCollection GetInstances(System.Management.ManagementScope mgmtScope, System.Management.EnumerationOptions enumOptions) {
            if ((mgmtScope == null)) {
                if ((statMgmtScope == null)) {
                    mgmtScope = new System.Management.ManagementScope();
                    mgmtScope.Path.NamespacePath = "root\\MicrosoftIISv2";
                }
                else {
                    mgmtScope = statMgmtScope;
                }
            }
            System.Management.ManagementPath pathObj = new System.Management.ManagementPath();
            pathObj.ClassName = "IIsApplicationPools";
            pathObj.NamespacePath = "root\\MicrosoftIISv2";
            System.Management.ManagementClass clsObject = new System.Management.ManagementClass(mgmtScope, pathObj, null);
            if ((enumOptions == null)) {
                enumOptions = new System.Management.EnumerationOptions();
                enumOptions.EnsureLocatable = true;
            }
            return new IIsApplicationPoolsCollection(clsObject.GetInstances(enumOptions));
        }
        
        public static IIsApplicationPoolsCollection GetInstances(System.Management.ManagementScope mgmtScope, string condition) {
            return GetInstances(mgmtScope, condition, null);
        }
        
        public static IIsApplicationPoolsCollection GetInstances(System.Management.ManagementScope mgmtScope, System.String [] selectedProperties) {
            return GetInstances(mgmtScope, null, selectedProperties);
        }
        
        public static IIsApplicationPoolsCollection GetInstances(System.Management.ManagementScope mgmtScope, string condition, System.String [] selectedProperties) {
            if ((mgmtScope == null)) {
                if ((statMgmtScope == null)) {
                    mgmtScope = new System.Management.ManagementScope();
                    mgmtScope.Path.NamespacePath = "root\\MicrosoftIISv2";
                }
                else {
                    mgmtScope = statMgmtScope;
                }
            }
            System.Management.ManagementObjectSearcher ObjectSearcher = new System.Management.ManagementObjectSearcher(mgmtScope, new SelectQuery("IIsApplicationPools", condition, selectedProperties));
            System.Management.EnumerationOptions enumOptions = new System.Management.EnumerationOptions();
            enumOptions.EnsureLocatable = true;
            ObjectSearcher.Options = enumOptions;
            return new IIsApplicationPoolsCollection(ObjectSearcher.Get());
        }
        
        [Browsable(true)]
        public static IIsApplicationPools CreateInstance() {
            System.Management.ManagementScope mgmtScope = null;
            if ((statMgmtScope == null)) {
                mgmtScope = new System.Management.ManagementScope();
                mgmtScope.Path.NamespacePath = CreatedWmiNamespace;
            }
            else {
                mgmtScope = statMgmtScope;
            }
            System.Management.ManagementPath mgmtPath = new System.Management.ManagementPath(CreatedClassName);
            return new IIsApplicationPools(new System.Management.ManagementClass(mgmtScope, mgmtPath, null).CreateInstance());
        }
        
        [Browsable(true)]
        public void Delete() {
            PrivateLateBoundObject.Delete();
        }
        
        // Enumerator implementation for enumerating instances of the class.
        public class IIsApplicationPoolsCollection : object, ICollection {
            
            private ManagementObjectCollection ObjectCollection;
            
            public IIsApplicationPoolsCollection(ManagementObjectCollection objCollection) {
                ObjectCollection = objCollection;
            }
            
            public int Count {
                get {
                    return ObjectCollection.Count;
                }
            }
            
            public bool IsSynchronized {
                get {
                    return ObjectCollection.IsSynchronized;
                }
            }
            
            public object SyncRoot {
                get {
                    return this;
                }
            }
            
            public void CopyTo(System.Array array, int index) {
                ObjectCollection.CopyTo(array, index);
                int nCtr;
                for (nCtr = 0; (nCtr < array.Length); nCtr = (nCtr + 1)) {
                    array.SetValue(new IIsApplicationPools(((System.Management.ManagementObject)(array.GetValue(nCtr)))), nCtr);
                }
            }
            
            public System.Collections.IEnumerator GetEnumerator() {
                return new IIsApplicationPoolsEnumerator(ObjectCollection.GetEnumerator());
            }
            
            public class IIsApplicationPoolsEnumerator : object, System.Collections.IEnumerator {
                
                private ManagementObjectCollection.ManagementObjectEnumerator ObjectEnumerator;
                
                public IIsApplicationPoolsEnumerator(ManagementObjectCollection.ManagementObjectEnumerator objEnum) {
                    ObjectEnumerator = objEnum;
                }
                
                public object Current {
                    get {
                        return new IIsApplicationPools(((System.Management.ManagementObject)(ObjectEnumerator.Current)));
                    }
                }
                
                public bool MoveNext() {
                    return ObjectEnumerator.MoveNext();
                }
                
                public void Reset() {
                    ObjectEnumerator.Reset();
                }
            }
        }
        
        // TypeConverter to handle null values for ValueType properties
        public class WMIValueTypeConverter : TypeConverter {
            
            private TypeConverter baseConverter;
            
            public WMIValueTypeConverter(System.Type baseType) {
                baseConverter = TypeDescriptor.GetConverter(baseType);
            }
            
            public override bool CanConvertFrom(System.ComponentModel.ITypeDescriptorContext context, System.Type srcType) {
                return baseConverter.CanConvertFrom(context, srcType);
            }
            
            public override bool CanConvertTo(System.ComponentModel.ITypeDescriptorContext context, System.Type destinationType) {
                return baseConverter.CanConvertTo(context, destinationType);
            }
            
            public override object ConvertFrom(System.ComponentModel.ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value) {
                return baseConverter.ConvertFrom(context, culture, value);
            }
            
            public override object CreateInstance(System.ComponentModel.ITypeDescriptorContext context, System.Collections.IDictionary dictionary) {
                return baseConverter.CreateInstance(context, dictionary);
            }
            
            public override bool GetCreateInstanceSupported(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetCreateInstanceSupported(context);
            }
            
            public override PropertyDescriptorCollection GetProperties(System.ComponentModel.ITypeDescriptorContext context, object value, System.Attribute[] attributeVar) {
                return baseConverter.GetProperties(context, value, attributeVar);
            }
            
            public override bool GetPropertiesSupported(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetPropertiesSupported(context);
            }
            
            public override System.ComponentModel.TypeConverter.StandardValuesCollection GetStandardValues(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetStandardValues(context);
            }
            
            public override bool GetStandardValuesExclusive(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetStandardValuesExclusive(context);
            }
            
            public override bool GetStandardValuesSupported(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetStandardValuesSupported(context);
            }
            
            public override object ConvertTo(System.ComponentModel.ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value, System.Type destinationType) {
                if ((context != null)) {
                    if ((context.PropertyDescriptor.ShouldSerializeValue(context.Instance) == false)) {
                        return "";
                    }
                }
                return baseConverter.ConvertTo(context, culture, value, destinationType);
            }
        }
        
        // Embedded class to represent WMI system Properties.
        [TypeConverter(typeof(System.ComponentModel.ExpandableObjectConverter))]
        public class ManagementSystemProperties {
            
            private System.Management.ManagementBaseObject PrivateLateBoundObject;
            
            public ManagementSystemProperties(System.Management.ManagementBaseObject ManagedObject) {
                PrivateLateBoundObject = ManagedObject;
            }
            
            [Browsable(true)]
            public int GENUS {
                get {
                    return ((int)(PrivateLateBoundObject["__GENUS"]));
                }
            }
            
            [Browsable(true)]
            public string CLASS {
                get {
                    return ((string)(PrivateLateBoundObject["__CLASS"]));
                }
            }
            
            [Browsable(true)]
            public string SUPERCLASS {
                get {
                    return ((string)(PrivateLateBoundObject["__SUPERCLASS"]));
                }
            }
            
            [Browsable(true)]
            public string DYNASTY {
                get {
                    return ((string)(PrivateLateBoundObject["__DYNASTY"]));
                }
            }
            
            [Browsable(true)]
            public string RELPATH {
                get {
                    return ((string)(PrivateLateBoundObject["__RELPATH"]));
                }
            }
            
            [Browsable(true)]
            public int PROPERTY_COUNT {
                get {
                    return ((int)(PrivateLateBoundObject["__PROPERTY_COUNT"]));
                }
            }
            
            [Browsable(true)]
            public string[] DERIVATION {
                get {
                    return ((string[])(PrivateLateBoundObject["__DERIVATION"]));
                }
            }
            
            [Browsable(true)]
            public string SERVER {
                get {
                    return ((string)(PrivateLateBoundObject["__SERVER"]));
                }
            }
            
            [Browsable(true)]
            public string NAMESPACE {
                get {
                    return ((string)(PrivateLateBoundObject["__NAMESPACE"]));
                }
            }
            
            [Browsable(true)]
            public string PATH {
                get {
                    return ((string)(PrivateLateBoundObject["__PATH"]));
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Wmi\iisv2\IIsApplicationPoolsSetting.CS ===
﻿namespace Leet.Tools.Setup.Wmi.Iisv2 {
    using System;
    using System.ComponentModel;
    using System.Management;
    using System.Collections;
    using System.Globalization;
    using System.ComponentModel.Design.Serialization;
    using System.Reflection;
    
    
    // Functions ShouldSerialize<PropertyName> are functions used by VS property browser to check if a particular property has to be serialized. These functions are added for all ValueType properties ( properties of type Int32, BOOL etc.. which cannot be set to null). These functions use Is<PropertyName>Null function. These functions are also used in the TypeConverter implementation for the properties to check for NULL value of property so that an empty value can be shown in Property browser in case of Drag and Drop in Visual studio.
    // Functions Is<PropertyName>Null() are used to check if a property is NULL.
    // Functions Reset<PropertyName> are added for Nullable Read/Write properties. These functions are used by VS designer in property browser to set a property to NULL.
    // Every property added to the class for WMI property has attributes set to define its behavior in Visual Studio designer and also to define a TypeConverter to be used.
    // An Early Bound class generated for the WMI class.IIsApplicationPoolsSetting
    public class IIsApplicationPoolsSetting : System.ComponentModel.Component {
        
        // Private property to hold the WMI namespace in which the class resides.
        private static string CreatedWmiNamespace = "ROOT\\MicrosoftIISv2";
        
        // Private property to hold the name of WMI class which created this class.
        private static string CreatedClassName = "IIsApplicationPoolsSetting";
        
        // Private member variable to hold the ManagementScope which is used by the various methods.
        private static System.Management.ManagementScope statMgmtScope = null;
        
        private ManagementSystemProperties PrivateSystemProperties;
        
        // Underlying lateBound WMI object.
        private System.Management.ManagementObject PrivateLateBoundObject;
        
        // Member variable to store the 'automatic commit' behavior for the class.
        private bool AutoCommitProp = true;
        
        // Private variable to hold the embedded property representing the instance.
        private System.Management.ManagementBaseObject embeddedObj;
        
        // The current WMI object used
        private System.Management.ManagementBaseObject curObj;
        
        // Flag to indicate if the instance is an embedded object.
        private bool isEmbedded = false;
        
        // Below are different overloads of constructors to initialize an instance of the class with a WMI object.
        public IIsApplicationPoolsSetting() : 
                this(((System.Management.ManagementScope)(null)), ((System.Management.ManagementPath)(null)), ((System.Management.ObjectGetOptions)(null))) {
        }
        
        public IIsApplicationPoolsSetting(string keyName) : 
                this(((System.Management.ManagementScope)(null)), ((System.Management.ManagementPath)(new System.Management.ManagementPath(IIsApplicationPoolsSetting.ConstructPath(keyName)))), ((System.Management.ObjectGetOptions)(null))) {
        }
        
        public IIsApplicationPoolsSetting(System.Management.ManagementScope mgmtScope, string keyName) : 
                this(((System.Management.ManagementScope)(mgmtScope)), ((System.Management.ManagementPath)(new System.Management.ManagementPath(IIsApplicationPoolsSetting.ConstructPath(keyName)))), ((System.Management.ObjectGetOptions)(null))) {
        }
        
        public IIsApplicationPoolsSetting(System.Management.ManagementPath path, System.Management.ObjectGetOptions getOptions) : 
                this(((System.Management.ManagementScope)(null)), ((System.Management.ManagementPath)(path)), ((System.Management.ObjectGetOptions)(getOptions))) {
        }
        
        public IIsApplicationPoolsSetting(System.Management.ManagementScope mgmtScope, System.Management.ManagementPath path) : 
                this(((System.Management.ManagementScope)(mgmtScope)), ((System.Management.ManagementPath)(path)), ((System.Management.ObjectGetOptions)(null))) {
        }
        
        public IIsApplicationPoolsSetting(System.Management.ManagementPath path) : 
                this(((System.Management.ManagementScope)(null)), ((System.Management.ManagementPath)(path)), ((System.Management.ObjectGetOptions)(null))) {
        }
        
        public IIsApplicationPoolsSetting(System.Management.ManagementScope mgmtScope, System.Management.ManagementPath path, System.Management.ObjectGetOptions getOptions) {
            if ((path != null)) {
                if ((CheckIfProperClass(mgmtScope, path, getOptions) != true)) {
                    throw new System.ArgumentException("Class name does not match.");
                }
            }
            PrivateLateBoundObject = new System.Management.ManagementObject(mgmtScope, path, getOptions);
            PrivateSystemProperties = new ManagementSystemProperties(PrivateLateBoundObject);
            curObj = PrivateLateBoundObject;
        }
        
        public IIsApplicationPoolsSetting(System.Management.ManagementObject theObject) {
            if ((CheckIfProperClass(theObject) == true)) {
                PrivateLateBoundObject = theObject;
                PrivateSystemProperties = new ManagementSystemProperties(PrivateLateBoundObject);
                curObj = PrivateLateBoundObject;
            }
            else {
                throw new System.ArgumentException("Class name does not match.");
            }
        }
        
        public IIsApplicationPoolsSetting(System.Management.ManagementBaseObject theObject) {
            if ((CheckIfProperClass(theObject) == true)) {
                embeddedObj = theObject;
                PrivateSystemProperties = new ManagementSystemProperties(theObject);
                curObj = embeddedObj;
                isEmbedded = true;
            }
            else {
                throw new System.ArgumentException("Class name does not match.");
            }
        }
        
        // Property returns the namespace of the WMI class.
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string OriginatingNamespace {
            get {
                return "ROOT\\MicrosoftIISv2";
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string ManagementClassName {
            get {
                string strRet = CreatedClassName;
                if ((curObj != null)) {
                    if ((curObj.ClassPath != null)) {
                        strRet = ((string)(curObj["__CLASS"]));
                        if (((strRet == null) 
                                    || (strRet == System.String.Empty))) {
                            strRet = CreatedClassName;
                        }
                    }
                }
                return strRet;
            }
        }
        
        // Property pointing to an embedded object to get System properties of the WMI object.
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public ManagementSystemProperties SystemProperties {
            get {
                return PrivateSystemProperties;
            }
        }
        
        // Property returning the underlying lateBound object.
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Management.ManagementBaseObject LateBoundObject {
            get {
                return curObj;
            }
        }
        
        // ManagementScope of the object.
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Management.ManagementScope Scope {
            get {
                if ((isEmbedded == false)) {
                    return PrivateLateBoundObject.Scope;
                }
                else {
                    return null;
                }
            }
            set {
                if ((isEmbedded == false)) {
                    PrivateLateBoundObject.Scope = value;
                }
            }
        }
        
        // Property to show the commit behavior for the WMI object. If true, WMI object will be automatically saved after each property modification.(ie. Put() is called after modification of a property).
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool AutoCommit {
            get {
                return AutoCommitProp;
            }
            set {
                AutoCommitProp = value;
            }
        }
        
        // The ManagementPath of the underlying WMI object.
        [Browsable(true)]
        public System.Management.ManagementPath Path {
            get {
                if ((isEmbedded == false)) {
                    return PrivateLateBoundObject.Path;
                }
                else {
                    return null;
                }
            }
            set {
                if ((isEmbedded == false)) {
                    if ((CheckIfProperClass(null, value, null) != true)) {
                        throw new System.ArgumentException("Class name does not match.");
                    }
                    PrivateLateBoundObject.Path = value;
                }
            }
        }
        
        // Public static scope property which is used by the various methods.
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public static System.Management.ManagementScope StaticScope {
            get {
                return statMgmtScope;
            }
            set {
                statMgmtScope = value;
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Byte[] AdminACLBin {
            get {
                return ((System.Byte[])(curObj["AdminACLBin"]));
            }
            set {
                curObj["AdminACLBin"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAppPoolAutoStartNull {
            get {
                if ((curObj["AppPoolAutoStart"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AppPoolAutoStart {
            get {
                if ((curObj["AppPoolAutoStart"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AppPoolAutoStart"]));
            }
            set {
                curObj["AppPoolAutoStart"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAppPoolIdentityTypeNull {
            get {
                if ((curObj["AppPoolIdentityType"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AppPoolIdentityType {
            get {
                if ((curObj["AppPoolIdentityType"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AppPoolIdentityType"]));
            }
            set {
                curObj["AppPoolIdentityType"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAppPoolQueueLengthNull {
            get {
                if ((curObj["AppPoolQueueLength"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AppPoolQueueLength {
            get {
                if ((curObj["AppPoolQueueLength"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AppPoolQueueLength"]));
            }
            set {
                curObj["AppPoolQueueLength"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAppPoolRecycleConfigChangeNull {
            get {
                if ((curObj["AppPoolRecycleConfigChange"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AppPoolRecycleConfigChange {
            get {
                if ((curObj["AppPoolRecycleConfigChange"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AppPoolRecycleConfigChange"]));
            }
            set {
                curObj["AppPoolRecycleConfigChange"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAppPoolRecycleIsapiUnhealthyNull {
            get {
                if ((curObj["AppPoolRecycleIsapiUnhealthy"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AppPoolRecycleIsapiUnhealthy {
            get {
                if ((curObj["AppPoolRecycleIsapiUnhealthy"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AppPoolRecycleIsapiUnhealthy"]));
            }
            set {
                curObj["AppPoolRecycleIsapiUnhealthy"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAppPoolRecycleMemoryNull {
            get {
                if ((curObj["AppPoolRecycleMemory"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AppPoolRecycleMemory {
            get {
                if ((curObj["AppPoolRecycleMemory"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AppPoolRecycleMemory"]));
            }
            set {
                curObj["AppPoolRecycleMemory"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAppPoolRecycleOnDemandNull {
            get {
                if ((curObj["AppPoolRecycleOnDemand"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AppPoolRecycleOnDemand {
            get {
                if ((curObj["AppPoolRecycleOnDemand"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AppPoolRecycleOnDemand"]));
            }
            set {
                curObj["AppPoolRecycleOnDemand"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAppPoolRecyclePrivateMemoryNull {
            get {
                if ((curObj["AppPoolRecyclePrivateMemory"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AppPoolRecyclePrivateMemory {
            get {
                if ((curObj["AppPoolRecyclePrivateMemory"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AppPoolRecyclePrivateMemory"]));
            }
            set {
                curObj["AppPoolRecyclePrivateMemory"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAppPoolRecycleRequestsNull {
            get {
                if ((curObj["AppPoolRecycleRequests"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AppPoolRecycleRequests {
            get {
                if ((curObj["AppPoolRecycleRequests"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AppPoolRecycleRequests"]));
            }
            set {
                curObj["AppPoolRecycleRequests"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAppPoolRecycleScheduleNull {
            get {
                if ((curObj["AppPoolRecycleSchedule"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AppPoolRecycleSchedule {
            get {
                if ((curObj["AppPoolRecycleSchedule"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AppPoolRecycleSchedule"]));
            }
            set {
                curObj["AppPoolRecycleSchedule"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAppPoolRecycleTimeNull {
            get {
                if ((curObj["AppPoolRecycleTime"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AppPoolRecycleTime {
            get {
                if ((curObj["AppPoolRecycleTime"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AppPoolRecycleTime"]));
            }
            set {
                curObj["AppPoolRecycleTime"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string AutoShutdownAppPoolExe {
            get {
                return ((string)(curObj["AutoShutdownAppPoolExe"]));
            }
            set {
                curObj["AutoShutdownAppPoolExe"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string AutoShutdownAppPoolParams {
            get {
                return ((string)(curObj["AutoShutdownAppPoolParams"]));
            }
            set {
                curObj["AutoShutdownAppPoolParams"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string Caption {
            get {
                return ((string)(curObj["Caption"]));
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsCPUActionNull {
            get {
                if ((curObj["CPUAction"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int CPUAction {
            get {
                if ((curObj["CPUAction"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["CPUAction"]));
            }
            set {
                curObj["CPUAction"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsCPULimitNull {
            get {
                if ((curObj["CPULimit"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int CPULimit {
            get {
                if ((curObj["CPULimit"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["CPULimit"]));
            }
            set {
                curObj["CPULimit"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsCPUResetIntervalNull {
            get {
                if ((curObj["CPUResetInterval"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int CPUResetInterval {
            get {
                if ((curObj["CPUResetInterval"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["CPUResetInterval"]));
            }
            set {
                curObj["CPUResetInterval"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string Description {
            get {
                return ((string)(curObj["Description"]));
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDisallowOverlappingRotationNull {
            get {
                if ((curObj["DisallowOverlappingRotation"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool DisallowOverlappingRotation {
            get {
                if ((curObj["DisallowOverlappingRotation"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["DisallowOverlappingRotation"]));
            }
            set {
                curObj["DisallowOverlappingRotation"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDisallowRotationOnConfigChangeNull {
            get {
                if ((curObj["DisallowRotationOnConfigChange"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool DisallowRotationOnConfigChange {
            get {
                if ((curObj["DisallowRotationOnConfigChange"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["DisallowRotationOnConfigChange"]));
            }
            set {
                curObj["DisallowRotationOnConfigChange"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsIdleTimeoutNull {
            get {
                if ((curObj["IdleTimeout"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int IdleTimeout {
            get {
                if ((curObj["IdleTimeout"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["IdleTimeout"]));
            }
            set {
                curObj["IdleTimeout"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLoadBalancerCapabilitiesNull {
            get {
                if ((curObj["LoadBalancerCapabilities"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int LoadBalancerCapabilities {
            get {
                if ((curObj["LoadBalancerCapabilities"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["LoadBalancerCapabilities"]));
            }
            set {
                curObj["LoadBalancerCapabilities"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogEventOnRecycleNull {
            get {
                if ((curObj["LogEventOnRecycle"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int LogEventOnRecycle {
            get {
                if ((curObj["LogEventOnRecycle"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["LogEventOnRecycle"]));
            }
            set {
                curObj["LogEventOnRecycle"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogonMethodNull {
            get {
                if ((curObj["LogonMethod"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int LogonMethod {
            get {
                if ((curObj["LogonMethod"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["LogonMethod"]));
            }
            set {
                curObj["LogonMethod"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsMaxProcessesNull {
            get {
                if ((curObj["MaxProcesses"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int MaxProcesses {
            get {
                if ((curObj["MaxProcesses"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["MaxProcesses"]));
            }
            set {
                curObj["MaxProcesses"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string Name {
            get {
                return ((string)(curObj["Name"]));
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string OrphanActionExe {
            get {
                return ((string)(curObj["OrphanActionExe"]));
            }
            set {
                curObj["OrphanActionExe"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string OrphanActionParams {
            get {
                return ((string)(curObj["OrphanActionParams"]));
            }
            set {
                curObj["OrphanActionParams"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsOrphanWorkerProcessNull {
            get {
                if ((curObj["OrphanWorkerProcess"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool OrphanWorkerProcess {
            get {
                if ((curObj["OrphanWorkerProcess"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["OrphanWorkerProcess"]));
            }
            set {
                curObj["OrphanWorkerProcess"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsPeriodicRestartMemoryNull {
            get {
                if ((curObj["PeriodicRestartMemory"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int PeriodicRestartMemory {
            get {
                if ((curObj["PeriodicRestartMemory"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["PeriodicRestartMemory"]));
            }
            set {
                curObj["PeriodicRestartMemory"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsPeriodicRestartPrivateMemoryNull {
            get {
                if ((curObj["PeriodicRestartPrivateMemory"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int PeriodicRestartPrivateMemory {
            get {
                if ((curObj["PeriodicRestartPrivateMemory"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["PeriodicRestartPrivateMemory"]));
            }
            set {
                curObj["PeriodicRestartPrivateMemory"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsPeriodicRestartRequestsNull {
            get {
                if ((curObj["PeriodicRestartRequests"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int PeriodicRestartRequests {
            get {
                if ((curObj["PeriodicRestartRequests"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["PeriodicRestartRequests"]));
            }
            set {
                curObj["PeriodicRestartRequests"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string[] PeriodicRestartSchedule {
            get {
                return ((string[])(curObj["PeriodicRestartSchedule"]));
            }
            set {
                curObj["PeriodicRestartSchedule"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsPeriodicRestartTimeNull {
            get {
                if ((curObj["PeriodicRestartTime"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int PeriodicRestartTime {
            get {
                if ((curObj["PeriodicRestartTime"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["PeriodicRestartTime"]));
            }
            set {
                curObj["PeriodicRestartTime"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsPingingEnabledNull {
            get {
                if ((curObj["PingingEnabled"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool PingingEnabled {
            get {
                if ((curObj["PingingEnabled"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["PingingEnabled"]));
            }
            set {
                curObj["PingingEnabled"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsPingIntervalNull {
            get {
                if ((curObj["PingInterval"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int PingInterval {
            get {
                if ((curObj["PingInterval"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["PingInterval"]));
            }
            set {
                curObj["PingInterval"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsPingResponseTimeNull {
            get {
                if ((curObj["PingResponseTime"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int PingResponseTime {
            get {
                if ((curObj["PingResponseTime"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["PingResponseTime"]));
            }
            set {
                curObj["PingResponseTime"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsRapidFailProtectionNull {
            get {
                if ((curObj["RapidFailProtection"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool RapidFailProtection {
            get {
                if ((curObj["RapidFailProtection"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["RapidFailProtection"]));
            }
            set {
                curObj["RapidFailProtection"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsRapidFailProtectionIntervalNull {
            get {
                if ((curObj["RapidFailProtectionInterval"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int RapidFailProtectionInterval {
            get {
                if ((curObj["RapidFailProtectionInterval"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["RapidFailProtectionInterval"]));
            }
            set {
                curObj["RapidFailProtectionInterval"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsRapidFailProtectionMaxCrashesNull {
            get {
                if ((curObj["RapidFailProtectionMaxCrashes"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int RapidFailProtectionMaxCrashes {
            get {
                if ((curObj["RapidFailProtectionMaxCrashes"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["RapidFailProtectionMaxCrashes"]));
            }
            set {
                curObj["RapidFailProtectionMaxCrashes"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string SettingID {
            get {
                return ((string)(curObj["SettingID"]));
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsShutdownTimeLimitNull {
            get {
                if ((curObj["ShutdownTimeLimit"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int ShutdownTimeLimit {
            get {
                if ((curObj["ShutdownTimeLimit"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["ShutdownTimeLimit"]));
            }
            set {
                curObj["ShutdownTimeLimit"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsSMPAffinitizedNull {
            get {
                if ((curObj["SMPAffinitized"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool SMPAffinitized {
            get {
                if ((curObj["SMPAffinitized"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["SMPAffinitized"]));
            }
            set {
                curObj["SMPAffinitized"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsSMPProcessorAffinityMaskNull {
            get {
                if ((curObj["SMPProcessorAffinityMask"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int SMPProcessorAffinityMask {
            get {
                if ((curObj["SMPProcessorAffinityMask"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["SMPProcessorAffinityMask"]));
            }
            set {
                curObj["SMPProcessorAffinityMask"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsStartupTimeLimitNull {
            get {
                if ((curObj["StartupTimeLimit"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int StartupTimeLimit {
            get {
                if ((curObj["StartupTimeLimit"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["StartupTimeLimit"]));
            }
            set {
                curObj["StartupTimeLimit"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string WAMUserName {
            get {
                return ((string)(curObj["WAMUserName"]));
            }
            set {
                curObj["WAMUserName"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string WAMUserPass {
            get {
                return ((string)(curObj["WAMUserPass"]));
            }
            set {
                curObj["WAMUserPass"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsWin32ErrorNull {
            get {
                if ((curObj["Win32Error"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int Win32Error {
            get {
                if ((curObj["Win32Error"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["Win32Error"]));
            }
            set {
                curObj["Win32Error"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        private bool CheckIfProperClass(System.Management.ManagementScope mgmtScope, System.Management.ManagementPath path, System.Management.ObjectGetOptions OptionsParam) {
            if (((path != null) 
                        && (System.String.Compare(path.ClassName, ManagementClassName, true, CultureInfo.InvariantCulture) == 0))) {
                return true;
            }
            else {
                return CheckIfProperClass(new System.Management.ManagementObject(mgmtScope, path, OptionsParam));
            }
        }
        
        private bool CheckIfProperClass(System.Management.ManagementBaseObject theObj) {
            if (((theObj != null) 
                        && (System.String.Compare(((string)(theObj["__CLASS"])), ManagementClassName, true, CultureInfo.InvariantCulture) == 0))) {
                return true;
            }
            else {
                System.Array parentClasses = ((System.Array)(theObj["__DERIVATION"]));
                if ((parentClasses != null)) {
                    Int32 count = 0;
                    for (count = 0; (count < parentClasses.Length); count = (count + 1)) {
                        if ((System.String.Compare(((string)(parentClasses.GetValue(count))), ManagementClassName, true, CultureInfo.InvariantCulture) == 0)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        
        private void ResetAdminACLBin() {
            curObj["AdminACLBin"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAppPoolAutoStart() {
            if ((IsAppPoolAutoStartNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAppPoolAutoStart() {
            curObj["AppPoolAutoStart"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAppPoolIdentityType() {
            if ((IsAppPoolIdentityTypeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAppPoolIdentityType() {
            curObj["AppPoolIdentityType"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAppPoolQueueLength() {
            if ((IsAppPoolQueueLengthNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAppPoolQueueLength() {
            curObj["AppPoolQueueLength"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAppPoolRecycleConfigChange() {
            if ((IsAppPoolRecycleConfigChangeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAppPoolRecycleConfigChange() {
            curObj["AppPoolRecycleConfigChange"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAppPoolRecycleIsapiUnhealthy() {
            if ((IsAppPoolRecycleIsapiUnhealthyNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAppPoolRecycleIsapiUnhealthy() {
            curObj["AppPoolRecycleIsapiUnhealthy"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAppPoolRecycleMemory() {
            if ((IsAppPoolRecycleMemoryNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAppPoolRecycleMemory() {
            curObj["AppPoolRecycleMemory"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAppPoolRecycleOnDemand() {
            if ((IsAppPoolRecycleOnDemandNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAppPoolRecycleOnDemand() {
            curObj["AppPoolRecycleOnDemand"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAppPoolRecyclePrivateMemory() {
            if ((IsAppPoolRecyclePrivateMemoryNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAppPoolRecyclePrivateMemory() {
            curObj["AppPoolRecyclePrivateMemory"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAppPoolRecycleRequests() {
            if ((IsAppPoolRecycleRequestsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAppPoolRecycleRequests() {
            curObj["AppPoolRecycleRequests"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAppPoolRecycleSchedule() {
            if ((IsAppPoolRecycleScheduleNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAppPoolRecycleSchedule() {
            curObj["AppPoolRecycleSchedule"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAppPoolRecycleTime() {
            if ((IsAppPoolRecycleTimeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAppPoolRecycleTime() {
            curObj["AppPoolRecycleTime"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAutoShutdownAppPoolExe() {
            curObj["AutoShutdownAppPoolExe"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAutoShutdownAppPoolParams() {
            curObj["AutoShutdownAppPoolParams"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeCPUAction() {
            if ((IsCPUActionNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetCPUAction() {
            curObj["CPUAction"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeCPULimit() {
            if ((IsCPULimitNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetCPULimit() {
            curObj["CPULimit"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeCPUResetInterval() {
            if ((IsCPUResetIntervalNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetCPUResetInterval() {
            curObj["CPUResetInterval"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDisallowOverlappingRotation() {
            if ((IsDisallowOverlappingRotationNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDisallowOverlappingRotation() {
            curObj["DisallowOverlappingRotation"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDisallowRotationOnConfigChange() {
            if ((IsDisallowRotationOnConfigChangeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDisallowRotationOnConfigChange() {
            curObj["DisallowRotationOnConfigChange"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeIdleTimeout() {
            if ((IsIdleTimeoutNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetIdleTimeout() {
            curObj["IdleTimeout"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLoadBalancerCapabilities() {
            if ((IsLoadBalancerCapabilitiesNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLoadBalancerCapabilities() {
            curObj["LoadBalancerCapabilities"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogEventOnRecycle() {
            if ((IsLogEventOnRecycleNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogEventOnRecycle() {
            curObj["LogEventOnRecycle"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogonMethod() {
            if ((IsLogonMethodNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogonMethod() {
            curObj["LogonMethod"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeMaxProcesses() {
            if ((IsMaxProcessesNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetMaxProcesses() {
            curObj["MaxProcesses"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetOrphanActionExe() {
            curObj["OrphanActionExe"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetOrphanActionParams() {
            curObj["OrphanActionParams"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeOrphanWorkerProcess() {
            if ((IsOrphanWorkerProcessNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetOrphanWorkerProcess() {
            curObj["OrphanWorkerProcess"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializePeriodicRestartMemory() {
            if ((IsPeriodicRestartMemoryNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetPeriodicRestartMemory() {
            curObj["PeriodicRestartMemory"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializePeriodicRestartPrivateMemory() {
            if ((IsPeriodicRestartPrivateMemoryNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetPeriodicRestartPrivateMemory() {
            curObj["PeriodicRestartPrivateMemory"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializePeriodicRestartRequests() {
            if ((IsPeriodicRestartRequestsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetPeriodicRestartRequests() {
            curObj["PeriodicRestartRequests"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetPeriodicRestartSchedule() {
            curObj["PeriodicRestartSchedule"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializePeriodicRestartTime() {
            if ((IsPeriodicRestartTimeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetPeriodicRestartTime() {
            curObj["PeriodicRestartTime"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializePingingEnabled() {
            if ((IsPingingEnabledNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetPingingEnabled() {
            curObj["PingingEnabled"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializePingInterval() {
            if ((IsPingIntervalNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetPingInterval() {
            curObj["PingInterval"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializePingResponseTime() {
            if ((IsPingResponseTimeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetPingResponseTime() {
            curObj["PingResponseTime"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeRapidFailProtection() {
            if ((IsRapidFailProtectionNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetRapidFailProtection() {
            curObj["RapidFailProtection"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeRapidFailProtectionInterval() {
            if ((IsRapidFailProtectionIntervalNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetRapidFailProtectionInterval() {
            curObj["RapidFailProtectionInterval"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeRapidFailProtectionMaxCrashes() {
            if ((IsRapidFailProtectionMaxCrashesNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetRapidFailProtectionMaxCrashes() {
            curObj["RapidFailProtectionMaxCrashes"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeShutdownTimeLimit() {
            if ((IsShutdownTimeLimitNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetShutdownTimeLimit() {
            curObj["ShutdownTimeLimit"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeSMPAffinitized() {
            if ((IsSMPAffinitizedNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetSMPAffinitized() {
            curObj["SMPAffinitized"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeSMPProcessorAffinityMask() {
            if ((IsSMPProcessorAffinityMaskNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetSMPProcessorAffinityMask() {
            curObj["SMPProcessorAffinityMask"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeStartupTimeLimit() {
            if ((IsStartupTimeLimitNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetStartupTimeLimit() {
            curObj["StartupTimeLimit"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetWAMUserName() {
            curObj["WAMUserName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetWAMUserPass() {
            curObj["WAMUserPass"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeWin32Error() {
            if ((IsWin32ErrorNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetWin32Error() {
            curObj["Win32Error"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        [Browsable(true)]
        public void CommitObject() {
            if ((isEmbedded == false)) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private static string ConstructPath(string keyName) {
            string strPath = "ROOT\\MicrosoftIISv2:IIsApplicationPoolsSetting";
            strPath = (strPath 
                        + (".Name=" 
                        + ("\"" 
                        + (keyName + "\""))));
            return strPath;
        }
        
        // Different overloads of GetInstances() help in enumerating instances of the WMI class.
        public static IIsApplicationPoolsSettingCollection GetInstances() {
            return GetInstances(((System.Management.ManagementScope)(null)), ((System.Management.EnumerationOptions)(null)));
        }
        
        public static IIsApplicationPoolsSettingCollection GetInstances(string condition) {
            return GetInstances(null, condition, null);
        }
        
        public static IIsApplicationPoolsSettingCollection GetInstances(System.String [] selectedProperties) {
            return GetInstances(null, null, selectedProperties);
        }
        
        public static IIsApplicationPoolsSettingCollection GetInstances(string condition, System.String [] selectedProperties) {
            return GetInstances(null, condition, selectedProperties);
        }
        
        public static IIsApplicationPoolsSettingCollection GetInstances(System.Management.ManagementScope mgmtScope, System.Management.EnumerationOptions enumOptions) {
            if ((mgmtScope == null)) {
                if ((statMgmtScope == null)) {
                    mgmtScope = new System.Management.ManagementScope();
                    mgmtScope.Path.NamespacePath = "root\\MicrosoftIISv2";
                }
                else {
                    mgmtScope = statMgmtScope;
                }
            }
            System.Management.ManagementPath pathObj = new System.Management.ManagementPath();
            pathObj.ClassName = "IIsApplicationPoolsSetting";
            pathObj.NamespacePath = "root\\MicrosoftIISv2";
            System.Management.ManagementClass clsObject = new System.Management.ManagementClass(mgmtScope, pathObj, null);
            if ((enumOptions == null)) {
                enumOptions = new System.Management.EnumerationOptions();
                enumOptions.EnsureLocatable = true;
            }
            return new IIsApplicationPoolsSettingCollection(clsObject.GetInstances(enumOptions));
        }
        
        public static IIsApplicationPoolsSettingCollection GetInstances(System.Management.ManagementScope mgmtScope, string condition) {
            return GetInstances(mgmtScope, condition, null);
        }
        
        public static IIsApplicationPoolsSettingCollection GetInstances(System.Management.ManagementScope mgmtScope, System.String [] selectedProperties) {
            return GetInstances(mgmtScope, null, selectedProperties);
        }
        
        public static IIsApplicationPoolsSettingCollection GetInstances(System.Management.ManagementScope mgmtScope, string condition, System.String [] selectedProperties) {
            if ((mgmtScope == null)) {
                if ((statMgmtScope == null)) {
                    mgmtScope = new System.Management.ManagementScope();
                    mgmtScope.Path.NamespacePath = "root\\MicrosoftIISv2";
                }
                else {
                    mgmtScope = statMgmtScope;
                }
            }
            System.Management.ManagementObjectSearcher ObjectSearcher = new System.Management.ManagementObjectSearcher(mgmtScope, new SelectQuery("IIsApplicationPoolsSetting", condition, selectedProperties));
            System.Management.EnumerationOptions enumOptions = new System.Management.EnumerationOptions();
            enumOptions.EnsureLocatable = true;
            ObjectSearcher.Options = enumOptions;
            return new IIsApplicationPoolsSettingCollection(ObjectSearcher.Get());
        }
        
        [Browsable(true)]
        public static IIsApplicationPoolsSetting CreateInstance() {
            System.Management.ManagementScope mgmtScope = null;
            if ((statMgmtScope == null)) {
                mgmtScope = new System.Management.ManagementScope();
                mgmtScope.Path.NamespacePath = CreatedWmiNamespace;
            }
            else {
                mgmtScope = statMgmtScope;
            }
            System.Management.ManagementPath mgmtPath = new System.Management.ManagementPath(CreatedClassName);
            return new IIsApplicationPoolsSetting(new System.Management.ManagementClass(mgmtScope, mgmtPath, null).CreateInstance());
        }
        
        [Browsable(true)]
        public void Delete() {
            PrivateLateBoundObject.Delete();
        }
        
        // Enumerator implementation for enumerating instances of the class.
        public class IIsApplicationPoolsSettingCollection : object, ICollection {
            
            private ManagementObjectCollection ObjectCollection;
            
            public IIsApplicationPoolsSettingCollection(ManagementObjectCollection objCollection) {
                ObjectCollection = objCollection;
            }
            
            public int Count {
                get {
                    return ObjectCollection.Count;
                }
            }
            
            public bool IsSynchronized {
                get {
                    return ObjectCollection.IsSynchronized;
                }
            }
            
            public object SyncRoot {
                get {
                    return this;
                }
            }
            
            public void CopyTo(System.Array array, int index) {
                ObjectCollection.CopyTo(array, index);
                int nCtr;
                for (nCtr = 0; (nCtr < array.Length); nCtr = (nCtr + 1)) {
                    array.SetValue(new IIsApplicationPoolsSetting(((System.Management.ManagementObject)(array.GetValue(nCtr)))), nCtr);
                }
            }
            
            public System.Collections.IEnumerator GetEnumerator() {
                return new IIsApplicationPoolsSettingEnumerator(ObjectCollection.GetEnumerator());
            }
            
            public class IIsApplicationPoolsSettingEnumerator : object, System.Collections.IEnumerator {
                
                private ManagementObjectCollection.ManagementObjectEnumerator ObjectEnumerator;
                
                public IIsApplicationPoolsSettingEnumerator(ManagementObjectCollection.ManagementObjectEnumerator objEnum) {
                    ObjectEnumerator = objEnum;
                }
                
                public object Current {
                    get {
                        return new IIsApplicationPoolsSetting(((System.Management.ManagementObject)(ObjectEnumerator.Current)));
                    }
                }
                
                public bool MoveNext() {
                    return ObjectEnumerator.MoveNext();
                }
                
                public void Reset() {
                    ObjectEnumerator.Reset();
                }
            }
        }
        
        // TypeConverter to handle null values for ValueType properties
        public class WMIValueTypeConverter : TypeConverter {
            
            private TypeConverter baseConverter;
            
            public WMIValueTypeConverter(System.Type baseType) {
                baseConverter = TypeDescriptor.GetConverter(baseType);
            }
            
            public override bool CanConvertFrom(System.ComponentModel.ITypeDescriptorContext context, System.Type srcType) {
                return baseConverter.CanConvertFrom(context, srcType);
            }
            
            public override bool CanConvertTo(System.ComponentModel.ITypeDescriptorContext context, System.Type destinationType) {
                return baseConverter.CanConvertTo(context, destinationType);
            }
            
            public override object ConvertFrom(System.ComponentModel.ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value) {
                return baseConverter.ConvertFrom(context, culture, value);
            }
            
            public override object CreateInstance(System.ComponentModel.ITypeDescriptorContext context, System.Collections.IDictionary dictionary) {
                return baseConverter.CreateInstance(context, dictionary);
            }
            
            public override bool GetCreateInstanceSupported(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetCreateInstanceSupported(context);
            }
            
            public override PropertyDescriptorCollection GetProperties(System.ComponentModel.ITypeDescriptorContext context, object value, System.Attribute[] attributeVar) {
                return baseConverter.GetProperties(context, value, attributeVar);
            }
            
            public override bool GetPropertiesSupported(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetPropertiesSupported(context);
            }
            
            public override System.ComponentModel.TypeConverter.StandardValuesCollection GetStandardValues(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetStandardValues(context);
            }
            
            public override bool GetStandardValuesExclusive(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetStandardValuesExclusive(context);
            }
            
            public override bool GetStandardValuesSupported(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetStandardValuesSupported(context);
            }
            
            public override object ConvertTo(System.ComponentModel.ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value, System.Type destinationType) {
                if ((context != null)) {
                    if ((context.PropertyDescriptor.ShouldSerializeValue(context.Instance) == false)) {
                        return "";
                    }
                }
                return baseConverter.ConvertTo(context, culture, value, destinationType);
            }
        }
        
        // Embedded class to represent WMI system Properties.
        [TypeConverter(typeof(System.ComponentModel.ExpandableObjectConverter))]
        public class ManagementSystemProperties {
            
            private System.Management.ManagementBaseObject PrivateLateBoundObject;
            
            public ManagementSystemProperties(System.Management.ManagementBaseObject ManagedObject) {
                PrivateLateBoundObject = ManagedObject;
            }
            
            [Browsable(true)]
            public int GENUS {
                get {
                    return ((int)(PrivateLateBoundObject["__GENUS"]));
                }
            }
            
            [Browsable(true)]
            public string CLASS {
                get {
                    return ((string)(PrivateLateBoundObject["__CLASS"]));
                }
            }
            
            [Browsable(true)]
            public string SUPERCLASS {
                get {
                    return ((string)(PrivateLateBoundObject["__SUPERCLASS"]));
                }
            }
            
            [Browsable(true)]
            public string DYNASTY {
                get {
                    return ((string)(PrivateLateBoundObject["__DYNASTY"]));
                }
            }
            
            [Browsable(true)]
            public string RELPATH {
                get {
                    return ((string)(PrivateLateBoundObject["__RELPATH"]));
                }
            }
            
            [Browsable(true)]
            public int PROPERTY_COUNT {
                get {
                    return ((int)(PrivateLateBoundObject["__PROPERTY_COUNT"]));
                }
            }
            
            [Browsable(true)]
            public string[] DERIVATION {
                get {
                    return ((string[])(PrivateLateBoundObject["__DERIVATION"]));
                }
            }
            
            [Browsable(true)]
            public string SERVER {
                get {
                    return ((string)(PrivateLateBoundObject["__SERVER"]));
                }
            }
            
            [Browsable(true)]
            public string NAMESPACE {
                get {
                    return ((string)(PrivateLateBoundObject["__NAMESPACE"]));
                }
            }
            
            [Browsable(true)]
            public string PATH {
                get {
                    return ((string)(PrivateLateBoundObject["__PATH"]));
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Wmi\iisv2\IIsCompressionScheme.cs ===
﻿namespace Leet.Tools.Setup.Wmi.Iisv2 {
    using System;
    using System.ComponentModel;
    using System.Management;
    using System.Collections;
    using System.Globalization;
    using System.ComponentModel.Design.Serialization;
    using System.Reflection;
    
    
    // Functions ShouldSerialize<PropertyName> are functions used by VS property browser to check if a particular property has to be serialized. These functions are added for all ValueType properties ( properties of type Int32, BOOL etc.. which cannot be set to null). These functions use Is<PropertyName>Null function. These functions are also used in the TypeConverter implementation for the properties to check for NULL value of property so that an empty value can be shown in Property browser in case of Drag and Drop in Visual studio.
    // Functions Is<PropertyName>Null() are used to check if a property is NULL.
    // Functions Reset<PropertyName> are added for Nullable Read/Write properties. These functions are used by VS designer in property browser to set a property to NULL.
    // Every property added to the class for WMI property has attributes set to define its behavior in Visual Studio designer and also to define a TypeConverter to be used.
    // Datetime conversion functions ToDateTime and ToDmtfDateTime are added to the class to convert DMTF datetime to System.DateTime and vice-versa.
    // An Early Bound class generated for the WMI class.IIsCompressionScheme
    public class IIsCompressionScheme : System.ComponentModel.Component {
        
        // Private property to hold the WMI namespace in which the class resides.
        private static string CreatedWmiNamespace = "ROOT\\MicrosoftIISv2";
        
        // Private property to hold the name of WMI class which created this class.
        private static string CreatedClassName = "IIsCompressionScheme";
        
        // Private member variable to hold the ManagementScope which is used by the various methods.
        private static System.Management.ManagementScope statMgmtScope = null;
        
        private ManagementSystemProperties PrivateSystemProperties;
        
        // Underlying lateBound WMI object.
        private System.Management.ManagementObject PrivateLateBoundObject;
        
        // Member variable to store the 'automatic commit' behavior for the class.
        private bool AutoCommitProp;
        
        // Private variable to hold the embedded property representing the instance.
        private System.Management.ManagementBaseObject embeddedObj;
        
        // The current WMI object used
        private System.Management.ManagementBaseObject curObj;
        
        // Flag to indicate if the instance is an embedded object.
        private bool isEmbedded;
        
        // Below are different overloads of constructors to initialize an instance of the class with a WMI object.
        public IIsCompressionScheme() {
            this.InitializeObject(null, null, null);
        }
        
        public IIsCompressionScheme(string keyName) {
            this.InitializeObject(null, new System.Management.ManagementPath(IIsCompressionScheme.ConstructPath(keyName)), null);
        }
        
        public IIsCompressionScheme(System.Management.ManagementScope mgmtScope, string keyName) {
            this.InitializeObject(((System.Management.ManagementScope)(mgmtScope)), new System.Management.ManagementPath(IIsCompressionScheme.ConstructPath(keyName)), null);
        }
        
        public IIsCompressionScheme(System.Management.ManagementPath path, System.Management.ObjectGetOptions getOptions) {
            this.InitializeObject(null, path, getOptions);
        }
        
        public IIsCompressionScheme(System.Management.ManagementScope mgmtScope, System.Management.ManagementPath path) {
            this.InitializeObject(mgmtScope, path, null);
        }
        
        public IIsCompressionScheme(System.Management.ManagementPath path) {
            this.InitializeObject(null, path, null);
        }
        
        public IIsCompressionScheme(System.Management.ManagementScope mgmtScope, System.Management.ManagementPath path, System.Management.ObjectGetOptions getOptions) {
            this.InitializeObject(mgmtScope, path, getOptions);
        }
        
        public IIsCompressionScheme(System.Management.ManagementObject theObject) {
            Initialize();
            if ((CheckIfProperClass(theObject) == true)) {
                PrivateLateBoundObject = theObject;
                PrivateSystemProperties = new ManagementSystemProperties(PrivateLateBoundObject);
                curObj = PrivateLateBoundObject;
            }
            else {
                throw new System.ArgumentException("Class name does not match.");
            }
        }
        
        public IIsCompressionScheme(System.Management.ManagementBaseObject theObject) {
            Initialize();
            if ((CheckIfProperClass(theObject) == true)) {
                embeddedObj = theObject;
                PrivateSystemProperties = new ManagementSystemProperties(theObject);
                curObj = embeddedObj;
                isEmbedded = true;
            }
            else {
                throw new System.ArgumentException("Class name does not match.");
            }
        }
        
        // Property returns the namespace of the WMI class.
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string OriginatingNamespace {
            get {
                return "ROOT\\MicrosoftIISv2";
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string ManagementClassName {
            get {
                string strRet = CreatedClassName;
                if ((curObj != null)) {
                    if ((curObj.ClassPath != null)) {
                        strRet = ((string)(curObj["__CLASS"]));
                        if (((strRet == null) 
                                    || (strRet == string.Empty))) {
                            strRet = CreatedClassName;
                        }
                    }
                }
                return strRet;
            }
        }
        
        // Property pointing to an embedded object to get System properties of the WMI object.
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public ManagementSystemProperties SystemProperties {
            get {
                return PrivateSystemProperties;
            }
        }
        
        // Property returning the underlying lateBound object.
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Management.ManagementBaseObject LateBoundObject {
            get {
                return curObj;
            }
        }
        
        // ManagementScope of the object.
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Management.ManagementScope Scope {
            get {
                if ((isEmbedded == false)) {
                    return PrivateLateBoundObject.Scope;
                }
                else {
                    return null;
                }
            }
            set {
                if ((isEmbedded == false)) {
                    PrivateLateBoundObject.Scope = value;
                }
            }
        }
        
        // Property to show the commit behavior for the WMI object. If true, WMI object will be automatically saved after each property modification.(ie. Put() is called after modification of a property).
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool AutoCommit {
            get {
                return AutoCommitProp;
            }
            set {
                AutoCommitProp = value;
            }
        }
        
        // The ManagementPath of the underlying WMI object.
        [Browsable(true)]
        public System.Management.ManagementPath Path {
            get {
                if ((isEmbedded == false)) {
                    return PrivateLateBoundObject.Path;
                }
                else {
                    return null;
                }
            }
            set {
                if ((isEmbedded == false)) {
                    if ((CheckIfProperClass(null, value, null) != true)) {
                        throw new System.ArgumentException("Class name does not match.");
                    }
                    PrivateLateBoundObject.Path = value;
                }
            }
        }
        
        // Public static scope property which is used by the various methods.
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public static System.Management.ManagementScope StaticScope {
            get {
                return statMgmtScope;
            }
            set {
                statMgmtScope = value;
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [Description("The Caption property is a short textual description (one-line string) of the obje" +
            "ct.")]
        public string Caption {
            get {
                return ((string)(curObj["Caption"]));
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [Description("The Description property provides a textual description of the object.")]
        public string Description {
            get {
                return ((string)(curObj["Description"]));
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsInstallDateNull {
            get {
                if ((curObj["InstallDate"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [Description("The InstallDate property is datetime value indicating when the object was install" +
            "ed. A lack of a value does not indicate that the object is not installed.")]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public System.DateTime InstallDate {
            get {
                if ((curObj["InstallDate"] != null)) {
                    return ToDateTime(((string)(curObj["InstallDate"])));
                }
                else {
                    return System.DateTime.MinValue;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [Description("The Name property defines the label by which the object is known. When subclassed" +
            ", the Name property can be overridden to be a Key property.")]
        public string Name {
            get {
                return ((string)(curObj["Name"]));
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [Description(@"The Status property is a string indicating the current status of the object. Various operational and non-operational statuses can be defined. Operational statuses are ""OK"", ""Degraded"" and ""Pred Fail"". ""Pred Fail"" indicates that an element may be functioning properly but predicting a failure in the near future. An example is a SMART-enabled hard drive. Non-operational statuses can also be specified. These are ""Error"", ""Starting"", ""Stopping"" and ""Service"". The latter, ""Service"", could apply during mirror-resilvering of a disk, reload of a user permissions list, or other administrative work. Not all such work is on-line, yet the managed element is neither ""OK"" nor in one of the other states.")]
        public string Status {
            get {
                return ((string)(curObj["Status"]));
            }
        }
        
        private bool CheckIfProperClass(System.Management.ManagementScope mgmtScope, System.Management.ManagementPath path, System.Management.ObjectGetOptions OptionsParam) {
            if (((path != null) 
                        && (string.Compare(path.ClassName, this.ManagementClassName, true, System.Globalization.CultureInfo.InvariantCulture) == 0))) {
                return true;
            }
            else {
                return CheckIfProperClass(new System.Management.ManagementObject(mgmtScope, path, OptionsParam));
            }
        }
        
        private bool CheckIfProperClass(System.Management.ManagementBaseObject theObj) {
            if (((theObj != null) 
                        && (string.Compare(((string)(theObj["__CLASS"])), this.ManagementClassName, true, System.Globalization.CultureInfo.InvariantCulture) == 0))) {
                return true;
            }
            else {
                System.Array parentClasses = ((System.Array)(theObj["__DERIVATION"]));
                if ((parentClasses != null)) {
                    int count = 0;
                    for (count = 0; (count < parentClasses.Length); count = (count + 1)) {
                        if ((string.Compare(((string)(parentClasses.GetValue(count))), this.ManagementClassName, true, System.Globalization.CultureInfo.InvariantCulture) == 0)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        
        // Converts a given datetime in DMTF format to System.DateTime object.
        static System.DateTime ToDateTime(string dmtfDate) {
            System.DateTime initializer = System.DateTime.MinValue;
            int year = initializer.Year;
            int month = initializer.Month;
            int day = initializer.Day;
            int hour = initializer.Hour;
            int minute = initializer.Minute;
            int second = initializer.Second;
            long ticks = 0;
            string dmtf = dmtfDate;
            System.DateTime datetime = System.DateTime.MinValue;
            string tempString = string.Empty;
            if ((dmtf == null)) {
                throw new System.ArgumentOutOfRangeException();
            }
            if ((dmtf.Length == 0)) {
                throw new System.ArgumentOutOfRangeException();
            }
            if ((dmtf.Length != 25)) {
                throw new System.ArgumentOutOfRangeException();
            }
            try {
                tempString = dmtf.Substring(0, 4);
                if (("****" != tempString)) {
                    year = int.Parse(tempString);
                }
                tempString = dmtf.Substring(4, 2);
                if (("**" != tempString)) {
                    month = int.Parse(tempString);
                }
                tempString = dmtf.Substring(6, 2);
                if (("**" != tempString)) {
                    day = int.Parse(tempString);
                }
                tempString = dmtf.Substring(8, 2);
                if (("**" != tempString)) {
                    hour = int.Parse(tempString);
                }
                tempString = dmtf.Substring(10, 2);
                if (("**" != tempString)) {
                    minute = int.Parse(tempString);
                }
                tempString = dmtf.Substring(12, 2);
                if (("**" != tempString)) {
                    second = int.Parse(tempString);
                }
                tempString = dmtf.Substring(15, 6);
                if (("******" != tempString)) {
                    ticks = (long.Parse(tempString) * ((long)((System.TimeSpan.TicksPerMillisecond / 1000))));
                }
                if (((((((((year < 0) 
                            || (month < 0)) 
                            || (day < 0)) 
                            || (hour < 0)) 
                            || (minute < 0)) 
                            || (minute < 0)) 
                            || (second < 0)) 
                            || (ticks < 0))) {
                    throw new System.ArgumentOutOfRangeException();
                }
            }
            catch (System.Exception e) {
                throw new System.ArgumentOutOfRangeException(null, e.Message);
            }
            datetime = new System.DateTime(year, month, day, hour, minute, second, 0);
            datetime = datetime.AddTicks(ticks);
            System.TimeSpan tickOffset = System.TimeZone.CurrentTimeZone.GetUtcOffset(datetime);
            int UTCOffset = 0;
            int OffsetToBeAdjusted = 0;
            long OffsetMins = ((long)((tickOffset.Ticks / System.TimeSpan.TicksPerMinute)));
            tempString = dmtf.Substring(22, 3);
            if ((tempString != "******")) {
                tempString = dmtf.Substring(21, 4);
                try {
                    UTCOffset = int.Parse(tempString);
                }
                catch (System.Exception e) {
                    throw new System.ArgumentOutOfRangeException(null, e.Message);
                }
                OffsetToBeAdjusted = ((int)((OffsetMins - UTCOffset)));
                datetime = datetime.AddMinutes(((double)(OffsetToBeAdjusted)));
            }
            return datetime;
        }
        
        // Converts a given System.DateTime object to DMTF datetime format.
        static string ToDmtfDateTime(System.DateTime date) {
            string utcString = string.Empty;
            System.TimeSpan tickOffset = System.TimeZone.CurrentTimeZone.GetUtcOffset(date);
            long OffsetMins = ((long)((tickOffset.Ticks / System.TimeSpan.TicksPerMinute)));
            if ((System.Math.Abs(OffsetMins) > 999)) {
                date = date.ToUniversalTime();
                utcString = "+000";
            }
            else {
                if ((tickOffset.Ticks >= 0)) {
                    utcString = string.Concat("+", ((System.Int64 )((tickOffset.Ticks / System.TimeSpan.TicksPerMinute))).ToString().PadLeft(3, '0'));
                }
                else {
                    string strTemp = ((System.Int64 )(OffsetMins)).ToString();
                    utcString = string.Concat("-", strTemp.Substring(1, (strTemp.Length - 1)).PadLeft(3, '0'));
                }
            }
            string dmtfDateTime = ((System.Int32 )(date.Year)).ToString().PadLeft(4, '0');
            dmtfDateTime = string.Concat(dmtfDateTime, ((System.Int32 )(date.Month)).ToString().PadLeft(2, '0'));
            dmtfDateTime = string.Concat(dmtfDateTime, ((System.Int32 )(date.Day)).ToString().PadLeft(2, '0'));
            dmtfDateTime = string.Concat(dmtfDateTime, ((System.Int32 )(date.Hour)).ToString().PadLeft(2, '0'));
            dmtfDateTime = string.Concat(dmtfDateTime, ((System.Int32 )(date.Minute)).ToString().PadLeft(2, '0'));
            dmtfDateTime = string.Concat(dmtfDateTime, ((System.Int32 )(date.Second)).ToString().PadLeft(2, '0'));
            dmtfDateTime = string.Concat(dmtfDateTime, ".");
            System.DateTime dtTemp = new System.DateTime(date.Year, date.Month, date.Day, date.Hour, date.Minute, date.Second, 0);
            long microsec = ((long)((((date.Ticks - dtTemp.Ticks) 
                        * 1000) 
                        / System.TimeSpan.TicksPerMillisecond)));
            string strMicrosec = ((System.Int64 )(microsec)).ToString();
            if ((strMicrosec.Length > 6)) {
                strMicrosec = strMicrosec.Substring(0, 6);
            }
            dmtfDateTime = string.Concat(dmtfDateTime, strMicrosec.PadLeft(6, '0'));
            dmtfDateTime = string.Concat(dmtfDateTime, utcString);
            return dmtfDateTime;
        }
        
        private bool ShouldSerializeInstallDate() {
            if ((this.IsInstallDateNull == false)) {
                return true;
            }
            return false;
        }
        
        [Browsable(true)]
        public void CommitObject() {
            if ((isEmbedded == false)) {
                PrivateLateBoundObject.Put();
            }
        }
        
        [Browsable(true)]
        public void CommitObject(System.Management.PutOptions putOptions) {
            if ((isEmbedded == false)) {
                PrivateLateBoundObject.Put(putOptions);
            }
        }
        
        private void Initialize() {
            AutoCommitProp = true;
            isEmbedded = false;
        }
        
        private static string ConstructPath(string keyName) {
            string strPath = "ROOT\\MicrosoftIISv2:IIsCompressionScheme";
            strPath = string.Concat(strPath, string.Concat(".Name=", string.Concat("\"", string.Concat(keyName, "\""))));
            return strPath;
        }
        
        private void InitializeObject(System.Management.ManagementScope mgmtScope, System.Management.ManagementPath path, System.Management.ObjectGetOptions getOptions) {
            Initialize();
            if ((path != null)) {
                if ((CheckIfProperClass(mgmtScope, path, getOptions) != true)) {
                    throw new System.ArgumentException("Class name does not match.");
                }
            }
            PrivateLateBoundObject = new System.Management.ManagementObject(mgmtScope, path, getOptions);
            PrivateSystemProperties = new ManagementSystemProperties(PrivateLateBoundObject);
            curObj = PrivateLateBoundObject;
        }
        
        // Different overloads of GetInstances() help in enumerating instances of the WMI class.
        public static IIsCompressionSchemeCollection GetInstances() {
            return GetInstances(null, null, null);
        }
        
        public static IIsCompressionSchemeCollection GetInstances(string condition) {
            return GetInstances(null, condition, null);
        }
        
        public static IIsCompressionSchemeCollection GetInstances(System.String [] selectedProperties) {
            return GetInstances(null, null, selectedProperties);
        }
        
        public static IIsCompressionSchemeCollection GetInstances(string condition, System.String [] selectedProperties) {
            return GetInstances(null, condition, selectedProperties);
        }
        
        public static IIsCompressionSchemeCollection GetInstances(System.Management.ManagementScope mgmtScope, System.Management.EnumerationOptions enumOptions) {
            if ((mgmtScope == null)) {
                if ((statMgmtScope == null)) {
                    mgmtScope = new System.Management.ManagementScope();
                    mgmtScope.Path.NamespacePath = "root\\MicrosoftIISv2";
                }
                else {
                    mgmtScope = statMgmtScope;
                }
            }
            System.Management.ManagementPath pathObj = new System.Management.ManagementPath();
            pathObj.ClassName = "IIsCompressionScheme";
            pathObj.NamespacePath = "root\\MicrosoftIISv2";
            System.Management.ManagementClass clsObject = new System.Management.ManagementClass(mgmtScope, pathObj, null);
            if ((enumOptions == null)) {
                enumOptions = new System.Management.EnumerationOptions();
                enumOptions.EnsureLocatable = true;
            }
            return new IIsCompressionSchemeCollection(clsObject.GetInstances(enumOptions));
        }
        
        public static IIsCompressionSchemeCollection GetInstances(System.Management.ManagementScope mgmtScope, string condition) {
            return GetInstances(mgmtScope, condition, null);
        }
        
        public static IIsCompressionSchemeCollection GetInstances(System.Management.ManagementScope mgmtScope, System.String [] selectedProperties) {
            return GetInstances(mgmtScope, null, selectedProperties);
        }
        
        public static IIsCompressionSchemeCollection GetInstances(System.Management.ManagementScope mgmtScope, string condition, System.String [] selectedProperties) {
            if ((mgmtScope == null)) {
                if ((statMgmtScope == null)) {
                    mgmtScope = new System.Management.ManagementScope();
                    mgmtScope.Path.NamespacePath = "root\\MicrosoftIISv2";
                }
                else {
                    mgmtScope = statMgmtScope;
                }
            }
            System.Management.ManagementObjectSearcher ObjectSearcher = new System.Management.ManagementObjectSearcher(mgmtScope, new SelectQuery("IIsCompressionScheme", condition, selectedProperties));
            System.Management.EnumerationOptions enumOptions = new System.Management.EnumerationOptions();
            enumOptions.EnsureLocatable = true;
            ObjectSearcher.Options = enumOptions;
            return new IIsCompressionSchemeCollection(ObjectSearcher.Get());
        }
        
        [Browsable(true)]
        public static IIsCompressionScheme CreateInstance() {
            System.Management.ManagementScope mgmtScope = null;
            if ((statMgmtScope == null)) {
                mgmtScope = new System.Management.ManagementScope();
                mgmtScope.Path.NamespacePath = CreatedWmiNamespace;
            }
            else {
                mgmtScope = statMgmtScope;
            }
            System.Management.ManagementPath mgmtPath = new System.Management.ManagementPath(CreatedClassName);
            System.Management.ManagementClass tmpMgmtClass = new System.Management.ManagementClass(mgmtScope, mgmtPath, null);
            return new IIsCompressionScheme(tmpMgmtClass.CreateInstance());
        }
        
        [Browsable(true)]
        public void Delete() {
            PrivateLateBoundObject.Delete();
        }
        
        // Enumerator implementation for enumerating instances of the class.
        public class IIsCompressionSchemeCollection : object, ICollection {
            
            private ManagementObjectCollection privColObj;
            
            public IIsCompressionSchemeCollection(ManagementObjectCollection objCollection) {
                privColObj = objCollection;
            }
            
            public virtual int Count {
                get {
                    return privColObj.Count;
                }
            }
            
            public virtual bool IsSynchronized {
                get {
                    return privColObj.IsSynchronized;
                }
            }
            
            public virtual object SyncRoot {
                get {
                    return this;
                }
            }
            
            public virtual void CopyTo(System.Array array, int index) {
                privColObj.CopyTo(array, index);
                int nCtr;
                for (nCtr = 0; (nCtr < array.Length); nCtr = (nCtr + 1)) {
                    array.SetValue(new IIsCompressionScheme(((System.Management.ManagementObject)(array.GetValue(nCtr)))), nCtr);
                }
            }
            
            public virtual System.Collections.IEnumerator GetEnumerator() {
                return new IIsCompressionSchemeEnumerator(privColObj.GetEnumerator());
            }
            
            public class IIsCompressionSchemeEnumerator : object, System.Collections.IEnumerator {
                
                private ManagementObjectCollection.ManagementObjectEnumerator privObjEnum;
                
                public IIsCompressionSchemeEnumerator(ManagementObjectCollection.ManagementObjectEnumerator objEnum) {
                    privObjEnum = objEnum;
                }
                
                public virtual object Current {
                    get {
                        return new IIsCompressionScheme(((System.Management.ManagementObject)(privObjEnum.Current)));
                    }
                }
                
                public virtual bool MoveNext() {
                    return privObjEnum.MoveNext();
                }
                
                public virtual void Reset() {
                    privObjEnum.Reset();
                }
            }
        }
        
        // TypeConverter to handle null values for ValueType properties
        public class WMIValueTypeConverter : TypeConverter {
            
            private TypeConverter baseConverter;
            
            private System.Type baseType;
            
            public WMIValueTypeConverter(System.Type inBaseType) {
                baseConverter = TypeDescriptor.GetConverter(inBaseType);
                baseType = inBaseType;
            }
            
            public override bool CanConvertFrom(System.ComponentModel.ITypeDescriptorContext context, System.Type srcType) {
                return baseConverter.CanConvertFrom(context, srcType);
            }
            
            public override bool CanConvertTo(System.ComponentModel.ITypeDescriptorContext context, System.Type destinationType) {
                return baseConverter.CanConvertTo(context, destinationType);
            }
            
            public override object ConvertFrom(System.ComponentModel.ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value) {
                return baseConverter.ConvertFrom(context, culture, value);
            }
            
            public override object CreateInstance(System.ComponentModel.ITypeDescriptorContext context, System.Collections.IDictionary dictionary) {
                return baseConverter.CreateInstance(context, dictionary);
            }
            
            public override bool GetCreateInstanceSupported(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetCreateInstanceSupported(context);
            }
            
            public override PropertyDescriptorCollection GetProperties(System.ComponentModel.ITypeDescriptorContext context, object value, System.Attribute[] attributeVar) {
                return baseConverter.GetProperties(context, value, attributeVar);
            }
            
            public override bool GetPropertiesSupported(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetPropertiesSupported(context);
            }
            
            public override System.ComponentModel.TypeConverter.StandardValuesCollection GetStandardValues(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetStandardValues(context);
            }
            
            public override bool GetStandardValuesExclusive(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetStandardValuesExclusive(context);
            }
            
            public override bool GetStandardValuesSupported(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetStandardValuesSupported(context);
            }
            
            public override object ConvertTo(System.ComponentModel.ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value, System.Type destinationType) {
                if ((baseType.BaseType == typeof(System.Enum))) {
                    if ((value.GetType() == destinationType)) {
                        return value;
                    }
                    if ((((value == null) 
                                && (context != null)) 
                                && (context.PropertyDescriptor.ShouldSerializeValue(context.Instance) == false))) {
                        return  "NULL_ENUM_VALUE" ;
                    }
                    return baseConverter.ConvertTo(context, culture, value, destinationType);
                }
                if (((baseType == typeof(bool)) 
                            && (baseType.BaseType == typeof(System.ValueType)))) {
                    if ((((value == null) 
                                && (context != null)) 
                                && (context.PropertyDescriptor.ShouldSerializeValue(context.Instance) == false))) {
                        return "";
                    }
                    return baseConverter.ConvertTo(context, culture, value, destinationType);
                }
                if (((context != null) 
                            && (context.PropertyDescriptor.ShouldSerializeValue(context.Instance) == false))) {
                    return "";
                }
                return baseConverter.ConvertTo(context, culture, value, destinationType);
            }
        }
        
        // Embedded class to represent WMI system Properties.
        [TypeConverter(typeof(System.ComponentModel.ExpandableObjectConverter))]
        public class ManagementSystemProperties {
            
            private System.Management.ManagementBaseObject PrivateLateBoundObject;
            
            public ManagementSystemProperties(System.Management.ManagementBaseObject ManagedObject) {
                PrivateLateBoundObject = ManagedObject;
            }
            
            [Browsable(true)]
            public int GENUS {
                get {
                    return ((int)(PrivateLateBoundObject["__GENUS"]));
                }
            }
            
            [Browsable(true)]
            public string CLASS {
                get {
                    return ((string)(PrivateLateBoundObject["__CLASS"]));
                }
            }
            
            [Browsable(true)]
            public string SUPERCLASS {
                get {
                    return ((string)(PrivateLateBoundObject["__SUPERCLASS"]));
                }
            }
            
            [Browsable(true)]
            public string DYNASTY {
                get {
                    return ((string)(PrivateLateBoundObject["__DYNASTY"]));
                }
            }
            
            [Browsable(true)]
            public string RELPATH {
                get {
                    return ((string)(PrivateLateBoundObject["__RELPATH"]));
                }
            }
            
            [Browsable(true)]
            public int PROPERTY_COUNT {
                get {
                    return ((int)(PrivateLateBoundObject["__PROPERTY_COUNT"]));
                }
            }
            
            [Browsable(true)]
            public string[] DERIVATION {
                get {
                    return ((string[])(PrivateLateBoundObject["__DERIVATION"]));
                }
            }
            
            [Browsable(true)]
            public string SERVER {
                get {
                    return ((string)(PrivateLateBoundObject["__SERVER"]));
                }
            }
            
            [Browsable(true)]
            public string NAMESPACE {
                get {
                    return ((string)(PrivateLateBoundObject["__NAMESPACE"]));
                }
            }
            
            [Browsable(true)]
            public string PATH {
                get {
                    return ((string)(PrivateLateBoundObject["__PATH"]));
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Wmi\iisv2\IIsCompressionSchemes.cs ===
﻿namespace Leet.Tools.Setup.Wmi.Iisv2
{
    using System;
    using System.ComponentModel;
    using System.Management;
    using System.Collections;
    using System.Globalization;
    using System.ComponentModel.Design.Serialization;
    using System.Reflection;
    
    
    // Functions ShouldSerialize<PropertyName> are functions used by VS property browser to check if a particular property has to be serialized. These functions are added for all ValueType properties ( properties of type Int32, BOOL etc.. which cannot be set to null). These functions use Is<PropertyName>Null function. These functions are also used in the TypeConverter implementation for the properties to check for NULL value of property so that an empty value can be shown in Property browser in case of Drag and Drop in Visual studio.
    // Functions Is<PropertyName>Null() are used to check if a property is NULL.
    // Functions Reset<PropertyName> are added for Nullable Read/Write properties. These functions are used by VS designer in property browser to set a property to NULL.
    // Every property added to the class for WMI property has attributes set to define its behavior in Visual Studio designer and also to define a TypeConverter to be used.
    // Datetime conversion functions ToDateTime and ToDmtfDateTime are added to the class to convert DMTF datetime to System.DateTime and vice-versa.
    // An Early Bound class generated for the WMI class.IIsCompressionSchemes
    public class IIsCompressionSchemes : System.ComponentModel.Component {
        
        // Private property to hold the WMI namespace in which the class resides.
        private static string CreatedWmiNamespace = "ROOT\\MicrosoftIISv2";
        
        // Private property to hold the name of WMI class which created this class.
        private static string CreatedClassName = "IIsCompressionSchemes";
        
        // Private member variable to hold the ManagementScope which is used by the various methods.
        private static System.Management.ManagementScope statMgmtScope = null;
        
        private ManagementSystemProperties PrivateSystemProperties;
        
        // Underlying lateBound WMI object.
        private System.Management.ManagementObject PrivateLateBoundObject;
        
        // Member variable to store the 'automatic commit' behavior for the class.
        private bool AutoCommitProp;
        
        // Private variable to hold the embedded property representing the instance.
        private System.Management.ManagementBaseObject embeddedObj;
        
        // The current WMI object used
        private System.Management.ManagementBaseObject curObj;
        
        // Flag to indicate if the instance is an embedded object.
        private bool isEmbedded;
        
        // Below are different overloads of constructors to initialize an instance of the class with a WMI object.
        public IIsCompressionSchemes() {
            this.InitializeObject(null, null, null);
        }
        
        public IIsCompressionSchemes(string keyName) {
            this.InitializeObject(null, new System.Management.ManagementPath(IIsCompressionSchemes.ConstructPath(keyName)), null);
        }
        
        public IIsCompressionSchemes(System.Management.ManagementScope mgmtScope, string keyName) {
            this.InitializeObject(((System.Management.ManagementScope)(mgmtScope)), new System.Management.ManagementPath(IIsCompressionSchemes.ConstructPath(keyName)), null);
        }
        
        public IIsCompressionSchemes(System.Management.ManagementPath path, System.Management.ObjectGetOptions getOptions) {
            this.InitializeObject(null, path, getOptions);
        }
        
        public IIsCompressionSchemes(System.Management.ManagementScope mgmtScope, System.Management.ManagementPath path) {
            this.InitializeObject(mgmtScope, path, null);
        }
        
        public IIsCompressionSchemes(System.Management.ManagementPath path) {
            this.InitializeObject(null, path, null);
        }
        
        public IIsCompressionSchemes(System.Management.ManagementScope mgmtScope, System.Management.ManagementPath path, System.Management.ObjectGetOptions getOptions) {
            this.InitializeObject(mgmtScope, path, getOptions);
        }
        
        public IIsCompressionSchemes(System.Management.ManagementObject theObject) {
            Initialize();
            if ((CheckIfProperClass(theObject) == true)) {
                PrivateLateBoundObject = theObject;
                PrivateSystemProperties = new ManagementSystemProperties(PrivateLateBoundObject);
                curObj = PrivateLateBoundObject;
            }
            else {
                throw new System.ArgumentException("Class name does not match.");
            }
        }
        
        public IIsCompressionSchemes(System.Management.ManagementBaseObject theObject) {
            Initialize();
            if ((CheckIfProperClass(theObject) == true)) {
                embeddedObj = theObject;
                PrivateSystemProperties = new ManagementSystemProperties(theObject);
                curObj = embeddedObj;
                isEmbedded = true;
            }
            else {
                throw new System.ArgumentException("Class name does not match.");
            }
        }
        
        // Property returns the namespace of the WMI class.
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string OriginatingNamespace {
            get {
                return "ROOT\\MicrosoftIISv2";
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string ManagementClassName {
            get {
                string strRet = CreatedClassName;
                if ((curObj != null)) {
                    if ((curObj.ClassPath != null)) {
                        strRet = ((string)(curObj["__CLASS"]));
                        if (((strRet == null) 
                                    || (strRet == string.Empty))) {
                            strRet = CreatedClassName;
                        }
                    }
                }
                return strRet;
            }
        }
        
        // Property pointing to an embedded object to get System properties of the WMI object.
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public ManagementSystemProperties SystemProperties {
            get {
                return PrivateSystemProperties;
            }
        }
        
        // Property returning the underlying lateBound object.
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Management.ManagementBaseObject LateBoundObject {
            get {
                return curObj;
            }
        }
        
        // ManagementScope of the object.
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Management.ManagementScope Scope {
            get {
                if ((isEmbedded == false)) {
                    return PrivateLateBoundObject.Scope;
                }
                else {
                    return null;
                }
            }
            set {
                if ((isEmbedded == false)) {
                    PrivateLateBoundObject.Scope = value;
                }
            }
        }
        
        // Property to show the commit behavior for the WMI object. If true, WMI object will be automatically saved after each property modification.(ie. Put() is called after modification of a property).
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool AutoCommit {
            get {
                return AutoCommitProp;
            }
            set {
                AutoCommitProp = value;
            }
        }
        
        // The ManagementPath of the underlying WMI object.
        [Browsable(true)]
        public System.Management.ManagementPath Path {
            get {
                if ((isEmbedded == false)) {
                    return PrivateLateBoundObject.Path;
                }
                else {
                    return null;
                }
            }
            set {
                if ((isEmbedded == false)) {
                    if ((CheckIfProperClass(null, value, null) != true)) {
                        throw new System.ArgumentException("Class name does not match.");
                    }
                    PrivateLateBoundObject.Path = value;
                }
            }
        }
        
        // Public static scope property which is used by the various methods.
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public static System.Management.ManagementScope StaticScope {
            get {
                return statMgmtScope;
            }
            set {
                statMgmtScope = value;
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [Description("The Caption property is a short textual description (one-line string) of the obje" +
            "ct.")]
        public string Caption {
            get {
                return ((string)(curObj["Caption"]));
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [Description("The Description property provides a textual description of the object.")]
        public string Description {
            get {
                return ((string)(curObj["Description"]));
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsInstallDateNull {
            get {
                if ((curObj["InstallDate"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [Description("The InstallDate property is datetime value indicating when the object was install" +
            "ed. A lack of a value does not indicate that the object is not installed.")]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public System.DateTime InstallDate {
            get {
                if ((curObj["InstallDate"] != null)) {
                    return ToDateTime(((string)(curObj["InstallDate"])));
                }
                else {
                    return System.DateTime.MinValue;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [Description("The Name property defines the label by which the object is known. When subclassed" +
            ", the Name property can be overridden to be a Key property.")]
        public string Name {
            get {
                return ((string)(curObj["Name"]));
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [Description(@"The Status property is a string indicating the current status of the object. Various operational and non-operational statuses can be defined. Operational statuses are ""OK"", ""Degraded"" and ""Pred Fail"". ""Pred Fail"" indicates that an element may be functioning properly but predicting a failure in the near future. An example is a SMART-enabled hard drive. Non-operational statuses can also be specified. These are ""Error"", ""Starting"", ""Stopping"" and ""Service"". The latter, ""Service"", could apply during mirror-resilvering of a disk, reload of a user permissions list, or other administrative work. Not all such work is on-line, yet the managed element is neither ""OK"" nor in one of the other states.")]
        public string Status {
            get {
                return ((string)(curObj["Status"]));
            }
        }
        
        private bool CheckIfProperClass(System.Management.ManagementScope mgmtScope, System.Management.ManagementPath path, System.Management.ObjectGetOptions OptionsParam) {
            if (((path != null) 
                        && (string.Compare(path.ClassName, this.ManagementClassName, true, System.Globalization.CultureInfo.InvariantCulture) == 0))) {
                return true;
            }
            else {
                return CheckIfProperClass(new System.Management.ManagementObject(mgmtScope, path, OptionsParam));
            }
        }
        
        private bool CheckIfProperClass(System.Management.ManagementBaseObject theObj) {
            if (((theObj != null) 
                        && (string.Compare(((string)(theObj["__CLASS"])), this.ManagementClassName, true, System.Globalization.CultureInfo.InvariantCulture) == 0))) {
                return true;
            }
            else {
                System.Array parentClasses = ((System.Array)(theObj["__DERIVATION"]));
                if ((parentClasses != null)) {
                    int count = 0;
                    for (count = 0; (count < parentClasses.Length); count = (count + 1)) {
                        if ((string.Compare(((string)(parentClasses.GetValue(count))), this.ManagementClassName, true, System.Globalization.CultureInfo.InvariantCulture) == 0)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        
        // Converts a given datetime in DMTF format to System.DateTime object.
        static System.DateTime ToDateTime(string dmtfDate) {
            System.DateTime initializer = System.DateTime.MinValue;
            int year = initializer.Year;
            int month = initializer.Month;
            int day = initializer.Day;
            int hour = initializer.Hour;
            int minute = initializer.Minute;
            int second = initializer.Second;
            long ticks = 0;
            string dmtf = dmtfDate;
            System.DateTime datetime = System.DateTime.MinValue;
            string tempString = string.Empty;
            if ((dmtf == null)) {
                throw new System.ArgumentOutOfRangeException();
            }
            if ((dmtf.Length == 0)) {
                throw new System.ArgumentOutOfRangeException();
            }
            if ((dmtf.Length != 25)) {
                throw new System.ArgumentOutOfRangeException();
            }
            try {
                tempString = dmtf.Substring(0, 4);
                if (("****" != tempString)) {
                    year = int.Parse(tempString);
                }
                tempString = dmtf.Substring(4, 2);
                if (("**" != tempString)) {
                    month = int.Parse(tempString);
                }
                tempString = dmtf.Substring(6, 2);
                if (("**" != tempString)) {
                    day = int.Parse(tempString);
                }
                tempString = dmtf.Substring(8, 2);
                if (("**" != tempString)) {
                    hour = int.Parse(tempString);
                }
                tempString = dmtf.Substring(10, 2);
                if (("**" != tempString)) {
                    minute = int.Parse(tempString);
                }
                tempString = dmtf.Substring(12, 2);
                if (("**" != tempString)) {
                    second = int.Parse(tempString);
                }
                tempString = dmtf.Substring(15, 6);
                if (("******" != tempString)) {
                    ticks = (long.Parse(tempString) * ((long)((System.TimeSpan.TicksPerMillisecond / 1000))));
                }
                if (((((((((year < 0) 
                            || (month < 0)) 
                            || (day < 0)) 
                            || (hour < 0)) 
                            || (minute < 0)) 
                            || (minute < 0)) 
                            || (second < 0)) 
                            || (ticks < 0))) {
                    throw new System.ArgumentOutOfRangeException();
                }
            }
            catch (System.Exception e) {
                throw new System.ArgumentOutOfRangeException(null, e.Message);
            }
            datetime = new System.DateTime(year, month, day, hour, minute, second, 0);
            datetime = datetime.AddTicks(ticks);
            System.TimeSpan tickOffset = System.TimeZone.CurrentTimeZone.GetUtcOffset(datetime);
            int UTCOffset = 0;
            int OffsetToBeAdjusted = 0;
            long OffsetMins = ((long)((tickOffset.Ticks / System.TimeSpan.TicksPerMinute)));
            tempString = dmtf.Substring(22, 3);
            if ((tempString != "******")) {
                tempString = dmtf.Substring(21, 4);
                try {
                    UTCOffset = int.Parse(tempString);
                }
                catch (System.Exception e) {
                    throw new System.ArgumentOutOfRangeException(null, e.Message);
                }
                OffsetToBeAdjusted = ((int)((OffsetMins - UTCOffset)));
                datetime = datetime.AddMinutes(((double)(OffsetToBeAdjusted)));
            }
            return datetime;
        }
        
        // Converts a given System.DateTime object to DMTF datetime format.
        static string ToDmtfDateTime(System.DateTime date) {
            string utcString = string.Empty;
            System.TimeSpan tickOffset = System.TimeZone.CurrentTimeZone.GetUtcOffset(date);
            long OffsetMins = ((long)((tickOffset.Ticks / System.TimeSpan.TicksPerMinute)));
            if ((System.Math.Abs(OffsetMins) > 999)) {
                date = date.ToUniversalTime();
                utcString = "+000";
            }
            else {
                if ((tickOffset.Ticks >= 0)) {
                    utcString = string.Concat("+", ((System.Int64 )((tickOffset.Ticks / System.TimeSpan.TicksPerMinute))).ToString().PadLeft(3, '0'));
                }
                else {
                    string strTemp = ((System.Int64 )(OffsetMins)).ToString();
                    utcString = string.Concat("-", strTemp.Substring(1, (strTemp.Length - 1)).PadLeft(3, '0'));
                }
            }
            string dmtfDateTime = ((System.Int32 )(date.Year)).ToString().PadLeft(4, '0');
            dmtfDateTime = string.Concat(dmtfDateTime, ((System.Int32 )(date.Month)).ToString().PadLeft(2, '0'));
            dmtfDateTime = string.Concat(dmtfDateTime, ((System.Int32 )(date.Day)).ToString().PadLeft(2, '0'));
            dmtfDateTime = string.Concat(dmtfDateTime, ((System.Int32 )(date.Hour)).ToString().PadLeft(2, '0'));
            dmtfDateTime = string.Concat(dmtfDateTime, ((System.Int32 )(date.Minute)).ToString().PadLeft(2, '0'));
            dmtfDateTime = string.Concat(dmtfDateTime, ((System.Int32 )(date.Second)).ToString().PadLeft(2, '0'));
            dmtfDateTime = string.Concat(dmtfDateTime, ".");
            System.DateTime dtTemp = new System.DateTime(date.Year, date.Month, date.Day, date.Hour, date.Minute, date.Second, 0);
            long microsec = ((long)((((date.Ticks - dtTemp.Ticks) 
                        * 1000) 
                        / System.TimeSpan.TicksPerMillisecond)));
            string strMicrosec = ((System.Int64 )(microsec)).ToString();
            if ((strMicrosec.Length > 6)) {
                strMicrosec = strMicrosec.Substring(0, 6);
            }
            dmtfDateTime = string.Concat(dmtfDateTime, strMicrosec.PadLeft(6, '0'));
            dmtfDateTime = string.Concat(dmtfDateTime, utcString);
            return dmtfDateTime;
        }
        
        private bool ShouldSerializeInstallDate() {
            if ((this.IsInstallDateNull == false)) {
                return true;
            }
            return false;
        }
        
        [Browsable(true)]
        public void CommitObject() {
            if ((isEmbedded == false)) {
                PrivateLateBoundObject.Put();
            }
        }
        
        [Browsable(true)]
        public void CommitObject(System.Management.PutOptions putOptions) {
            if ((isEmbedded == false)) {
                PrivateLateBoundObject.Put(putOptions);
            }
        }
        
        private void Initialize() {
            AutoCommitProp = true;
            isEmbedded = false;
        }
        
        private static string ConstructPath(string keyName) {
            string strPath = "ROOT\\MicrosoftIISv2:IIsCompressionSchemes";
            strPath = string.Concat(strPath, string.Concat(".Name=", string.Concat("\"", string.Concat(keyName, "\""))));
            return strPath;
        }
        
        private void InitializeObject(System.Management.ManagementScope mgmtScope, System.Management.ManagementPath path, System.Management.ObjectGetOptions getOptions) {
            Initialize();
            if ((path != null)) {
                if ((CheckIfProperClass(mgmtScope, path, getOptions) != true)) {
                    throw new System.ArgumentException("Class name does not match.");
                }
            }
            PrivateLateBoundObject = new System.Management.ManagementObject(mgmtScope, path, getOptions);
            PrivateSystemProperties = new ManagementSystemProperties(PrivateLateBoundObject);
            curObj = PrivateLateBoundObject;
        }
        
        // Different overloads of GetInstances() help in enumerating instances of the WMI class.
        public static IIsCompressionSchemesCollection GetInstances() {
            return GetInstances(null, null, null);
        }
        
        public static IIsCompressionSchemesCollection GetInstances(string condition) {
            return GetInstances(null, condition, null);
        }
        
        public static IIsCompressionSchemesCollection GetInstances(System.String [] selectedProperties) {
            return GetInstances(null, null, selectedProperties);
        }
        
        public static IIsCompressionSchemesCollection GetInstances(string condition, System.String [] selectedProperties) {
            return GetInstances(null, condition, selectedProperties);
        }
        
        public static IIsCompressionSchemesCollection GetInstances(System.Management.ManagementScope mgmtScope, System.Management.EnumerationOptions enumOptions) {
            if ((mgmtScope == null)) {
                if ((statMgmtScope == null)) {
                    mgmtScope = new System.Management.ManagementScope();
                    mgmtScope.Path.NamespacePath = "root\\MicrosoftIISv2";
                }
                else {
                    mgmtScope = statMgmtScope;
                }
            }
            System.Management.ManagementPath pathObj = new System.Management.ManagementPath();
            pathObj.ClassName = "IIsCompressionSchemes";
            pathObj.NamespacePath = "root\\MicrosoftIISv2";
            System.Management.ManagementClass clsObject = new System.Management.ManagementClass(mgmtScope, pathObj, null);
            if ((enumOptions == null)) {
                enumOptions = new System.Management.EnumerationOptions();
                enumOptions.EnsureLocatable = true;
            }
            return new IIsCompressionSchemesCollection(clsObject.GetInstances(enumOptions));
        }
        
        public static IIsCompressionSchemesCollection GetInstances(System.Management.ManagementScope mgmtScope, string condition) {
            return GetInstances(mgmtScope, condition, null);
        }
        
        public static IIsCompressionSchemesCollection GetInstances(System.Management.ManagementScope mgmtScope, System.String [] selectedProperties) {
            return GetInstances(mgmtScope, null, selectedProperties);
        }
        
        public static IIsCompressionSchemesCollection GetInstances(System.Management.ManagementScope mgmtScope, string condition, System.String [] selectedProperties) {
            if ((mgmtScope == null)) {
                if ((statMgmtScope == null)) {
                    mgmtScope = new System.Management.ManagementScope();
                    mgmtScope.Path.NamespacePath = "root\\MicrosoftIISv2";
                }
                else {
                    mgmtScope = statMgmtScope;
                }
            }
            System.Management.ManagementObjectSearcher ObjectSearcher = new System.Management.ManagementObjectSearcher(mgmtScope, new SelectQuery("IIsCompressionSchemes", condition, selectedProperties));
            System.Management.EnumerationOptions enumOptions = new System.Management.EnumerationOptions();
            enumOptions.EnsureLocatable = true;
            ObjectSearcher.Options = enumOptions;
            return new IIsCompressionSchemesCollection(ObjectSearcher.Get());
        }
        
        [Browsable(true)]
        public static IIsCompressionSchemes CreateInstance() {
            System.Management.ManagementScope mgmtScope = null;
            if ((statMgmtScope == null)) {
                mgmtScope = new System.Management.ManagementScope();
                mgmtScope.Path.NamespacePath = CreatedWmiNamespace;
            }
            else {
                mgmtScope = statMgmtScope;
            }
            System.Management.ManagementPath mgmtPath = new System.Management.ManagementPath(CreatedClassName);
            System.Management.ManagementClass tmpMgmtClass = new System.Management.ManagementClass(mgmtScope, mgmtPath, null);
            return new IIsCompressionSchemes(tmpMgmtClass.CreateInstance());
        }
        
        [Browsable(true)]
        public void Delete() {
            PrivateLateBoundObject.Delete();
        }
        
        // Enumerator implementation for enumerating instances of the class.
        public class IIsCompressionSchemesCollection : object, ICollection {
            
            private ManagementObjectCollection privColObj;
            
            public IIsCompressionSchemesCollection(ManagementObjectCollection objCollection) {
                privColObj = objCollection;
            }
            
            public virtual int Count {
                get {
                    return privColObj.Count;
                }
            }
            
            public virtual bool IsSynchronized {
                get {
                    return privColObj.IsSynchronized;
                }
            }
            
            public virtual object SyncRoot {
                get {
                    return this;
                }
            }
            
            public virtual void CopyTo(System.Array array, int index) {
                privColObj.CopyTo(array, index);
                int nCtr;
                for (nCtr = 0; (nCtr < array.Length); nCtr = (nCtr + 1)) {
                    array.SetValue(new IIsCompressionSchemes(((System.Management.ManagementObject)(array.GetValue(nCtr)))), nCtr);
                }
            }
            
            public virtual System.Collections.IEnumerator GetEnumerator() {
                return new IIsCompressionSchemesEnumerator(privColObj.GetEnumerator());
            }
            
            public class IIsCompressionSchemesEnumerator : object, System.Collections.IEnumerator {
                
                private ManagementObjectCollection.ManagementObjectEnumerator privObjEnum;
                
                public IIsCompressionSchemesEnumerator(ManagementObjectCollection.ManagementObjectEnumerator objEnum) {
                    privObjEnum = objEnum;
                }
                
                public virtual object Current {
                    get {
                        return new IIsCompressionSchemes(((System.Management.ManagementObject)(privObjEnum.Current)));
                    }
                }
                
                public virtual bool MoveNext() {
                    return privObjEnum.MoveNext();
                }
                
                public virtual void Reset() {
                    privObjEnum.Reset();
                }
            }
        }
        
        // TypeConverter to handle null values for ValueType properties
        public class WMIValueTypeConverter : TypeConverter {
            
            private TypeConverter baseConverter;
            
            private System.Type baseType;
            
            public WMIValueTypeConverter(System.Type inBaseType) {
                baseConverter = TypeDescriptor.GetConverter(inBaseType);
                baseType = inBaseType;
            }
            
            public override bool CanConvertFrom(System.ComponentModel.ITypeDescriptorContext context, System.Type srcType) {
                return baseConverter.CanConvertFrom(context, srcType);
            }
            
            public override bool CanConvertTo(System.ComponentModel.ITypeDescriptorContext context, System.Type destinationType) {
                return baseConverter.CanConvertTo(context, destinationType);
            }
            
            public override object ConvertFrom(System.ComponentModel.ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value) {
                return baseConverter.ConvertFrom(context, culture, value);
            }
            
            public override object CreateInstance(System.ComponentModel.ITypeDescriptorContext context, System.Collections.IDictionary dictionary) {
                return baseConverter.CreateInstance(context, dictionary);
            }
            
            public override bool GetCreateInstanceSupported(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetCreateInstanceSupported(context);
            }
            
            public override PropertyDescriptorCollection GetProperties(System.ComponentModel.ITypeDescriptorContext context, object value, System.Attribute[] attributeVar) {
                return baseConverter.GetProperties(context, value, attributeVar);
            }
            
            public override bool GetPropertiesSupported(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetPropertiesSupported(context);
            }
            
            public override System.ComponentModel.TypeConverter.StandardValuesCollection GetStandardValues(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetStandardValues(context);
            }
            
            public override bool GetStandardValuesExclusive(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetStandardValuesExclusive(context);
            }
            
            public override bool GetStandardValuesSupported(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetStandardValuesSupported(context);
            }
            
            public override object ConvertTo(System.ComponentModel.ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value, System.Type destinationType) {
                if ((baseType.BaseType == typeof(System.Enum))) {
                    if ((value.GetType() == destinationType)) {
                        return value;
                    }
                    if ((((value == null) 
                                && (context != null)) 
                                && (context.PropertyDescriptor.ShouldSerializeValue(context.Instance) == false))) {
                        return  "NULL_ENUM_VALUE" ;
                    }
                    return baseConverter.ConvertTo(context, culture, value, destinationType);
                }
                if (((baseType == typeof(bool)) 
                            && (baseType.BaseType == typeof(System.ValueType)))) {
                    if ((((value == null) 
                                && (context != null)) 
                                && (context.PropertyDescriptor.ShouldSerializeValue(context.Instance) == false))) {
                        return "";
                    }
                    return baseConverter.ConvertTo(context, culture, value, destinationType);
                }
                if (((context != null) 
                            && (context.PropertyDescriptor.ShouldSerializeValue(context.Instance) == false))) {
                    return "";
                }
                return baseConverter.ConvertTo(context, culture, value, destinationType);
            }
        }
        
        // Embedded class to represent WMI system Properties.
        [TypeConverter(typeof(System.ComponentModel.ExpandableObjectConverter))]
        public class ManagementSystemProperties {
            
            private System.Management.ManagementBaseObject PrivateLateBoundObject;
            
            public ManagementSystemProperties(System.Management.ManagementBaseObject ManagedObject) {
                PrivateLateBoundObject = ManagedObject;
            }
            
            [Browsable(true)]
            public int GENUS {
                get {
                    return ((int)(PrivateLateBoundObject["__GENUS"]));
                }
            }
            
            [Browsable(true)]
            public string CLASS {
                get {
                    return ((string)(PrivateLateBoundObject["__CLASS"]));
                }
            }
            
            [Browsable(true)]
            public string SUPERCLASS {
                get {
                    return ((string)(PrivateLateBoundObject["__SUPERCLASS"]));
                }
            }
            
            [Browsable(true)]
            public string DYNASTY {
                get {
                    return ((string)(PrivateLateBoundObject["__DYNASTY"]));
                }
            }
            
            [Browsable(true)]
            public string RELPATH {
                get {
                    return ((string)(PrivateLateBoundObject["__RELPATH"]));
                }
            }
            
            [Browsable(true)]
            public int PROPERTY_COUNT {
                get {
                    return ((int)(PrivateLateBoundObject["__PROPERTY_COUNT"]));
                }
            }
            
            [Browsable(true)]
            public string[] DERIVATION {
                get {
                    return ((string[])(PrivateLateBoundObject["__DERIVATION"]));
                }
            }
            
            [Browsable(true)]
            public string SERVER {
                get {
                    return ((string)(PrivateLateBoundObject["__SERVER"]));
                }
            }
            
            [Browsable(true)]
            public string NAMESPACE {
                get {
                    return ((string)(PrivateLateBoundObject["__NAMESPACE"]));
                }
            }
            
            [Browsable(true)]
            public string PATH {
                get {
                    return ((string)(PrivateLateBoundObject["__PATH"]));
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Wmi\iisv2\IIsCompressionSchemeSetting.cs ===
﻿namespace Leet.Tools.Setup.Wmi.Iisv2
{
    using System;
    using System.ComponentModel;
    using System.Management;
    using System.Collections;
    using System.Globalization;
    using System.ComponentModel.Design.Serialization;
    using System.Reflection;
    
    
    // Functions ShouldSerialize<PropertyName> are functions used by VS property browser to check if a particular property has to be serialized. These functions are added for all ValueType properties ( properties of type Int32, BOOL etc.. which cannot be set to null). These functions use Is<PropertyName>Null function. These functions are also used in the TypeConverter implementation for the properties to check for NULL value of property so that an empty value can be shown in Property browser in case of Drag and Drop in Visual studio.
    // Functions Is<PropertyName>Null() are used to check if a property is NULL.
    // Functions Reset<PropertyName> are added for Nullable Read/Write properties. These functions are used by VS designer in property browser to set a property to NULL.
    // Every property added to the class for WMI property has attributes set to define its behavior in Visual Studio designer and also to define a TypeConverter to be used.
    // An Early Bound class generated for the WMI class.IIsCompressionSchemeSetting
    public class IIsCompressionSchemeSetting : System.ComponentModel.Component {
        
        // Private property to hold the WMI namespace in which the class resides.
        private static string CreatedWmiNamespace = "ROOT\\MicrosoftIISv2";
        
        // Private property to hold the name of WMI class which created this class.
        private static string CreatedClassName = "IIsCompressionSchemeSetting";
        
        // Private member variable to hold the ManagementScope which is used by the various methods.
        private static System.Management.ManagementScope statMgmtScope = null;
        
        private ManagementSystemProperties PrivateSystemProperties;
        
        // Underlying lateBound WMI object.
        private System.Management.ManagementObject PrivateLateBoundObject;
        
        // Member variable to store the 'automatic commit' behavior for the class.
        private bool AutoCommitProp;
        
        // Private variable to hold the embedded property representing the instance.
        private System.Management.ManagementBaseObject embeddedObj;
        
        // The current WMI object used
        private System.Management.ManagementBaseObject curObj;
        
        // Flag to indicate if the instance is an embedded object.
        private bool isEmbedded;
        
        // Below are different overloads of constructors to initialize an instance of the class with a WMI object.
        public IIsCompressionSchemeSetting() {
            this.InitializeObject(null, null, null);
        }
        
        public IIsCompressionSchemeSetting(string keyName) {
            this.InitializeObject(null, new System.Management.ManagementPath(IIsCompressionSchemeSetting.ConstructPath(keyName)), null);
        }
        
        public IIsCompressionSchemeSetting(System.Management.ManagementScope mgmtScope, string keyName) {
            this.InitializeObject(((System.Management.ManagementScope)(mgmtScope)), new System.Management.ManagementPath(IIsCompressionSchemeSetting.ConstructPath(keyName)), null);
        }
        
        public IIsCompressionSchemeSetting(System.Management.ManagementPath path, System.Management.ObjectGetOptions getOptions) {
            this.InitializeObject(null, path, getOptions);
        }
        
        public IIsCompressionSchemeSetting(System.Management.ManagementScope mgmtScope, System.Management.ManagementPath path) {
            this.InitializeObject(mgmtScope, path, null);
        }
        
        public IIsCompressionSchemeSetting(System.Management.ManagementPath path) {
            this.InitializeObject(null, path, null);
        }
        
        public IIsCompressionSchemeSetting(System.Management.ManagementScope mgmtScope, System.Management.ManagementPath path, System.Management.ObjectGetOptions getOptions) {
            this.InitializeObject(mgmtScope, path, getOptions);
        }
        
        public IIsCompressionSchemeSetting(System.Management.ManagementObject theObject) {
            Initialize();
            if ((CheckIfProperClass(theObject) == true)) {
                PrivateLateBoundObject = theObject;
                PrivateSystemProperties = new ManagementSystemProperties(PrivateLateBoundObject);
                curObj = PrivateLateBoundObject;
            }
            else {
                throw new System.ArgumentException("Class name does not match.");
            }
        }
        
        public IIsCompressionSchemeSetting(System.Management.ManagementBaseObject theObject) {
            Initialize();
            if ((CheckIfProperClass(theObject) == true)) {
                embeddedObj = theObject;
                PrivateSystemProperties = new ManagementSystemProperties(theObject);
                curObj = embeddedObj;
                isEmbedded = true;
            }
            else {
                throw new System.ArgumentException("Class name does not match.");
            }
        }
        
        // Property returns the namespace of the WMI class.
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string OriginatingNamespace {
            get {
                return "ROOT\\MicrosoftIISv2";
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string ManagementClassName {
            get {
                string strRet = CreatedClassName;
                if ((curObj != null)) {
                    if ((curObj.ClassPath != null)) {
                        strRet = ((string)(curObj["__CLASS"]));
                        if (((strRet == null) 
                                    || (strRet == string.Empty))) {
                            strRet = CreatedClassName;
                        }
                    }
                }
                return strRet;
            }
        }
        
        // Property pointing to an embedded object to get System properties of the WMI object.
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public ManagementSystemProperties SystemProperties {
            get {
                return PrivateSystemProperties;
            }
        }
        
        // Property returning the underlying lateBound object.
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Management.ManagementBaseObject LateBoundObject {
            get {
                return curObj;
            }
        }
        
        // ManagementScope of the object.
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Management.ManagementScope Scope {
            get {
                if ((isEmbedded == false)) {
                    return PrivateLateBoundObject.Scope;
                }
                else {
                    return null;
                }
            }
            set {
                if ((isEmbedded == false)) {
                    PrivateLateBoundObject.Scope = value;
                }
            }
        }
        
        // Property to show the commit behavior for the WMI object. If true, WMI object will be automatically saved after each property modification.(ie. Put() is called after modification of a property).
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool AutoCommit {
            get {
                return AutoCommitProp;
            }
            set {
                AutoCommitProp = value;
            }
        }
        
        // The ManagementPath of the underlying WMI object.
        [Browsable(true)]
        public System.Management.ManagementPath Path {
            get {
                if ((isEmbedded == false)) {
                    return PrivateLateBoundObject.Path;
                }
                else {
                    return null;
                }
            }
            set {
                if ((isEmbedded == false)) {
                    if ((CheckIfProperClass(null, value, null) != true)) {
                        throw new System.ArgumentException("Class name does not match.");
                    }
                    PrivateLateBoundObject.Path = value;
                }
            }
        }
        
        // Public static scope property which is used by the various methods.
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public static System.Management.ManagementScope StaticScope {
            get {
                return statMgmtScope;
            }
            set {
                statMgmtScope = value;
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public byte[] AdminACLBin {
            get {
                return ((byte[])(curObj["AdminACLBin"]));
            }
            set {
                curObj["AdminACLBin"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [Description("A short textual description (one-line string) of the CIM_Setting object.")]
        public string Caption {
            get {
                return ((string)(curObj["Caption"]));
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [Description("A textual description of the CIM_Setting object.")]
        public string Description {
            get {
                return ((string)(curObj["Description"]));
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string HcCompressionDll {
            get {
                return ((string)(curObj["HcCompressionDll"]));
            }
            set {
                curObj["HcCompressionDll"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsHcCreateFlagsNull {
            get {
                if ((curObj["HcCreateFlags"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int HcCreateFlags {
            get {
                if ((curObj["HcCreateFlags"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["HcCreateFlags"]));
            }
            set {
                curObj["HcCreateFlags"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsHcDoDynamicCompressionNull {
            get {
                if ((curObj["HcDoDynamicCompression"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool HcDoDynamicCompression {
            get {
                if ((curObj["HcDoDynamicCompression"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["HcDoDynamicCompression"]));
            }
            set {
                curObj["HcDoDynamicCompression"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsHcDoOnDemandCompressionNull {
            get {
                if ((curObj["HcDoOnDemandCompression"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool HcDoOnDemandCompression {
            get {
                if ((curObj["HcDoOnDemandCompression"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["HcDoOnDemandCompression"]));
            }
            set {
                curObj["HcDoOnDemandCompression"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsHcDoStaticCompressionNull {
            get {
                if ((curObj["HcDoStaticCompression"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool HcDoStaticCompression {
            get {
                if ((curObj["HcDoStaticCompression"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["HcDoStaticCompression"]));
            }
            set {
                curObj["HcDoStaticCompression"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsHcDynamicCompressionLevelNull {
            get {
                if ((curObj["HcDynamicCompressionLevel"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int HcDynamicCompressionLevel {
            get {
                if ((curObj["HcDynamicCompressionLevel"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["HcDynamicCompressionLevel"]));
            }
            set {
                curObj["HcDynamicCompressionLevel"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string[] HcFileExtensions {
            get {
                return ((string[])(curObj["HcFileExtensions"]));
            }
            set {
                curObj["HcFileExtensions"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsHcOnDemandCompLevelNull {
            get {
                if ((curObj["HcOnDemandCompLevel"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int HcOnDemandCompLevel {
            get {
                if ((curObj["HcOnDemandCompLevel"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["HcOnDemandCompLevel"]));
            }
            set {
                curObj["HcOnDemandCompLevel"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsHcPriorityNull {
            get {
                if ((curObj["HcPriority"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int HcPriority {
            get {
                if ((curObj["HcPriority"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["HcPriority"]));
            }
            set {
                curObj["HcPriority"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string[] HcScriptFileExtensions {
            get {
                return ((string[])(curObj["HcScriptFileExtensions"]));
            }
            set {
                curObj["HcScriptFileExtensions"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string Name {
            get {
                return ((string)(curObj["Name"]));
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [Description("The identifier by which the CIM_Setting object is known.")]
        public string SettingID {
            get {
                return ((string)(curObj["SettingID"]));
            }
        }
        
        private bool CheckIfProperClass(System.Management.ManagementScope mgmtScope, System.Management.ManagementPath path, System.Management.ObjectGetOptions OptionsParam) {
            if (((path != null) 
                        && (string.Compare(path.ClassName, this.ManagementClassName, true, System.Globalization.CultureInfo.InvariantCulture) == 0))) {
                return true;
            }
            else {
                return CheckIfProperClass(new System.Management.ManagementObject(mgmtScope, path, OptionsParam));
            }
        }
        
        private bool CheckIfProperClass(System.Management.ManagementBaseObject theObj) {
            if (((theObj != null) 
                        && (string.Compare(((string)(theObj["__CLASS"])), this.ManagementClassName, true, System.Globalization.CultureInfo.InvariantCulture) == 0))) {
                return true;
            }
            else {
                System.Array parentClasses = ((System.Array)(theObj["__DERIVATION"]));
                if ((parentClasses != null)) {
                    int count = 0;
                    for (count = 0; (count < parentClasses.Length); count = (count + 1)) {
                        if ((string.Compare(((string)(parentClasses.GetValue(count))), this.ManagementClassName, true, System.Globalization.CultureInfo.InvariantCulture) == 0)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        
        private void ResetAdminACLBin() {
            curObj["AdminACLBin"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetHcCompressionDll() {
            curObj["HcCompressionDll"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeHcCreateFlags() {
            if ((this.IsHcCreateFlagsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetHcCreateFlags() {
            curObj["HcCreateFlags"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeHcDoDynamicCompression() {
            if ((this.IsHcDoDynamicCompressionNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetHcDoDynamicCompression() {
            curObj["HcDoDynamicCompression"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeHcDoOnDemandCompression() {
            if ((this.IsHcDoOnDemandCompressionNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetHcDoOnDemandCompression() {
            curObj["HcDoOnDemandCompression"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeHcDoStaticCompression() {
            if ((this.IsHcDoStaticCompressionNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetHcDoStaticCompression() {
            curObj["HcDoStaticCompression"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeHcDynamicCompressionLevel() {
            if ((this.IsHcDynamicCompressionLevelNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetHcDynamicCompressionLevel() {
            curObj["HcDynamicCompressionLevel"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetHcFileExtensions() {
            curObj["HcFileExtensions"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeHcOnDemandCompLevel() {
            if ((this.IsHcOnDemandCompLevelNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetHcOnDemandCompLevel() {
            curObj["HcOnDemandCompLevel"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeHcPriority() {
            if ((this.IsHcPriorityNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetHcPriority() {
            curObj["HcPriority"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetHcScriptFileExtensions() {
            curObj["HcScriptFileExtensions"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        [Browsable(true)]
        public void CommitObject() {
            if ((isEmbedded == false)) {
                PrivateLateBoundObject.Put();
            }
        }
        
        [Browsable(true)]
        public void CommitObject(System.Management.PutOptions putOptions) {
            if ((isEmbedded == false)) {
                PrivateLateBoundObject.Put(putOptions);
            }
        }
        
        private void Initialize() {
            AutoCommitProp = true;
            isEmbedded = false;
        }
        
        private static string ConstructPath(string keyName) {
            string strPath = "ROOT\\MicrosoftIISv2:IIsCompressionSchemeSetting";
            strPath = string.Concat(strPath, string.Concat(".Name=", string.Concat("\"", string.Concat(keyName, "\""))));
            return strPath;
        }
        
        private void InitializeObject(System.Management.ManagementScope mgmtScope, System.Management.ManagementPath path, System.Management.ObjectGetOptions getOptions) {
            Initialize();
            if ((path != null)) {
                if ((CheckIfProperClass(mgmtScope, path, getOptions) != true)) {
                    throw new System.ArgumentException("Class name does not match.");
                }
            }
            PrivateLateBoundObject = new System.Management.ManagementObject(mgmtScope, path, getOptions);
            PrivateSystemProperties = new ManagementSystemProperties(PrivateLateBoundObject);
            curObj = PrivateLateBoundObject;
        }
        
        // Different overloads of GetInstances() help in enumerating instances of the WMI class.
        public static IIsCompressionSchemeSettingCollection GetInstances() {
            return GetInstances(null, null, null);
        }
        
        public static IIsCompressionSchemeSettingCollection GetInstances(string condition) {
            return GetInstances(null, condition, null);
        }
        
        public static IIsCompressionSchemeSettingCollection GetInstances(System.String [] selectedProperties) {
            return GetInstances(null, null, selectedProperties);
        }
        
        public static IIsCompressionSchemeSettingCollection GetInstances(string condition, System.String [] selectedProperties) {
            return GetInstances(null, condition, selectedProperties);
        }
        
        public static IIsCompressionSchemeSettingCollection GetInstances(System.Management.ManagementScope mgmtScope, System.Management.EnumerationOptions enumOptions) {
            if ((mgmtScope == null)) {
                if ((statMgmtScope == null)) {
                    mgmtScope = new System.Management.ManagementScope();
                    mgmtScope.Path.NamespacePath = "root\\MicrosoftIISv2";
                }
                else {
                    mgmtScope = statMgmtScope;
                }
            }
            System.Management.ManagementPath pathObj = new System.Management.ManagementPath();
            pathObj.ClassName = "IIsCompressionSchemeSetting";
            pathObj.NamespacePath = "root\\MicrosoftIISv2";
            System.Management.ManagementClass clsObject = new System.Management.ManagementClass(mgmtScope, pathObj, null);
            if ((enumOptions == null)) {
                enumOptions = new System.Management.EnumerationOptions();
                enumOptions.EnsureLocatable = true;
            }
            return new IIsCompressionSchemeSettingCollection(clsObject.GetInstances(enumOptions));
        }
        
        public static IIsCompressionSchemeSettingCollection GetInstances(System.Management.ManagementScope mgmtScope, string condition) {
            return GetInstances(mgmtScope, condition, null);
        }
        
        public static IIsCompressionSchemeSettingCollection GetInstances(System.Management.ManagementScope mgmtScope, System.String [] selectedProperties) {
            return GetInstances(mgmtScope, null, selectedProperties);
        }
        
        public static IIsCompressionSchemeSettingCollection GetInstances(System.Management.ManagementScope mgmtScope, string condition, System.String [] selectedProperties) {
            if ((mgmtScope == null)) {
                if ((statMgmtScope == null)) {
                    mgmtScope = new System.Management.ManagementScope();
                    mgmtScope.Path.NamespacePath = "root\\MicrosoftIISv2";
                }
                else {
                    mgmtScope = statMgmtScope;
                }
            }
            System.Management.ManagementObjectSearcher ObjectSearcher = new System.Management.ManagementObjectSearcher(mgmtScope, new SelectQuery("IIsCompressionSchemeSetting", condition, selectedProperties));
            System.Management.EnumerationOptions enumOptions = new System.Management.EnumerationOptions();
            enumOptions.EnsureLocatable = true;
            ObjectSearcher.Options = enumOptions;
            return new IIsCompressionSchemeSettingCollection(ObjectSearcher.Get());
        }
        
        [Browsable(true)]
        public static IIsCompressionSchemeSetting CreateInstance() {
            System.Management.ManagementScope mgmtScope = null;
            if ((statMgmtScope == null)) {
                mgmtScope = new System.Management.ManagementScope();
                mgmtScope.Path.NamespacePath = CreatedWmiNamespace;
            }
            else {
                mgmtScope = statMgmtScope;
            }
            System.Management.ManagementPath mgmtPath = new System.Management.ManagementPath(CreatedClassName);
            System.Management.ManagementClass tmpMgmtClass = new System.Management.ManagementClass(mgmtScope, mgmtPath, null);
            return new IIsCompressionSchemeSetting(tmpMgmtClass.CreateInstance());
        }
        
        [Browsable(true)]
        public void Delete() {
            PrivateLateBoundObject.Delete();
        }
        
        // Enumerator implementation for enumerating instances of the class.
        public class IIsCompressionSchemeSettingCollection : object, ICollection {
            
            private ManagementObjectCollection privColObj;
            
            public IIsCompressionSchemeSettingCollection(ManagementObjectCollection objCollection) {
                privColObj = objCollection;
            }
            
            public virtual int Count {
                get {
                    return privColObj.Count;
                }
            }
            
            public virtual bool IsSynchronized {
                get {
                    return privColObj.IsSynchronized;
                }
            }
            
            public virtual object SyncRoot {
                get {
                    return this;
                }
            }
            
            public virtual void CopyTo(System.Array array, int index) {
                privColObj.CopyTo(array, index);
                int nCtr;
                for (nCtr = 0; (nCtr < array.Length); nCtr = (nCtr + 1)) {
                    array.SetValue(new IIsCompressionSchemeSetting(((System.Management.ManagementObject)(array.GetValue(nCtr)))), nCtr);
                }
            }
            
            public virtual System.Collections.IEnumerator GetEnumerator() {
                return new IIsCompressionSchemeSettingEnumerator(privColObj.GetEnumerator());
            }
            
            public class IIsCompressionSchemeSettingEnumerator : object, System.Collections.IEnumerator {
                
                private ManagementObjectCollection.ManagementObjectEnumerator privObjEnum;
                
                public IIsCompressionSchemeSettingEnumerator(ManagementObjectCollection.ManagementObjectEnumerator objEnum) {
                    privObjEnum = objEnum;
                }
                
                public virtual object Current {
                    get {
                        return new IIsCompressionSchemeSetting(((System.Management.ManagementObject)(privObjEnum.Current)));
                    }
                }
                
                public virtual bool MoveNext() {
                    return privObjEnum.MoveNext();
                }
                
                public virtual void Reset() {
                    privObjEnum.Reset();
                }
            }
        }
        
        // TypeConverter to handle null values for ValueType properties
        public class WMIValueTypeConverter : TypeConverter {
            
            private TypeConverter baseConverter;
            
            private System.Type baseType;
            
            public WMIValueTypeConverter(System.Type inBaseType) {
                baseConverter = TypeDescriptor.GetConverter(inBaseType);
                baseType = inBaseType;
            }
            
            public override bool CanConvertFrom(System.ComponentModel.ITypeDescriptorContext context, System.Type srcType) {
                return baseConverter.CanConvertFrom(context, srcType);
            }
            
            public override bool CanConvertTo(System.ComponentModel.ITypeDescriptorContext context, System.Type destinationType) {
                return baseConverter.CanConvertTo(context, destinationType);
            }
            
            public override object ConvertFrom(System.ComponentModel.ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value) {
                return baseConverter.ConvertFrom(context, culture, value);
            }
            
            public override object CreateInstance(System.ComponentModel.ITypeDescriptorContext context, System.Collections.IDictionary dictionary) {
                return baseConverter.CreateInstance(context, dictionary);
            }
            
            public override bool GetCreateInstanceSupported(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetCreateInstanceSupported(context);
            }
            
            public override PropertyDescriptorCollection GetProperties(System.ComponentModel.ITypeDescriptorContext context, object value, System.Attribute[] attributeVar) {
                return baseConverter.GetProperties(context, value, attributeVar);
            }
            
            public override bool GetPropertiesSupported(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetPropertiesSupported(context);
            }
            
            public override System.ComponentModel.TypeConverter.StandardValuesCollection GetStandardValues(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetStandardValues(context);
            }
            
            public override bool GetStandardValuesExclusive(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetStandardValuesExclusive(context);
            }
            
            public override bool GetStandardValuesSupported(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetStandardValuesSupported(context);
            }
            
            public override object ConvertTo(System.ComponentModel.ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value, System.Type destinationType) {
                if ((baseType.BaseType == typeof(System.Enum))) {
                    if ((value.GetType() == destinationType)) {
                        return value;
                    }
                    if ((((value == null) 
                                && (context != null)) 
                                && (context.PropertyDescriptor.ShouldSerializeValue(context.Instance) == false))) {
                        return  "NULL_ENUM_VALUE" ;
                    }
                    return baseConverter.ConvertTo(context, culture, value, destinationType);
                }
                if (((baseType == typeof(bool)) 
                            && (baseType.BaseType == typeof(System.ValueType)))) {
                    if ((((value == null) 
                                && (context != null)) 
                                && (context.PropertyDescriptor.ShouldSerializeValue(context.Instance) == false))) {
                        return "";
                    }
                    return baseConverter.ConvertTo(context, culture, value, destinationType);
                }
                if (((context != null) 
                            && (context.PropertyDescriptor.ShouldSerializeValue(context.Instance) == false))) {
                    return "";
                }
                return baseConverter.ConvertTo(context, culture, value, destinationType);
            }
        }
        
        // Embedded class to represent WMI system Properties.
        [TypeConverter(typeof(System.ComponentModel.ExpandableObjectConverter))]
        public class ManagementSystemProperties {
            
            private System.Management.ManagementBaseObject PrivateLateBoundObject;
            
            public ManagementSystemProperties(System.Management.ManagementBaseObject ManagedObject) {
                PrivateLateBoundObject = ManagedObject;
            }
            
            [Browsable(true)]
            public int GENUS {
                get {
                    return ((int)(PrivateLateBoundObject["__GENUS"]));
                }
            }
            
            [Browsable(true)]
            public string CLASS {
                get {
                    return ((string)(PrivateLateBoundObject["__CLASS"]));
                }
            }
            
            [Browsable(true)]
            public string SUPERCLASS {
                get {
                    return ((string)(PrivateLateBoundObject["__SUPERCLASS"]));
                }
            }
            
            [Browsable(true)]
            public string DYNASTY {
                get {
                    return ((string)(PrivateLateBoundObject["__DYNASTY"]));
                }
            }
            
            [Browsable(true)]
            public string RELPATH {
                get {
                    return ((string)(PrivateLateBoundObject["__RELPATH"]));
                }
            }
            
            [Browsable(true)]
            public int PROPERTY_COUNT {
                get {
                    return ((int)(PrivateLateBoundObject["__PROPERTY_COUNT"]));
                }
            }
            
            [Browsable(true)]
            public string[] DERIVATION {
                get {
                    return ((string[])(PrivateLateBoundObject["__DERIVATION"]));
                }
            }
            
            [Browsable(true)]
            public string SERVER {
                get {
                    return ((string)(PrivateLateBoundObject["__SERVER"]));
                }
            }
            
            [Browsable(true)]
            public string NAMESPACE {
                get {
                    return ((string)(PrivateLateBoundObject["__NAMESPACE"]));
                }
            }
            
            [Browsable(true)]
            public string PATH {
                get {
                    return ((string)(PrivateLateBoundObject["__PATH"]));
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Wmi\iisv2\IIsApplicationPoolSetting.CS ===
﻿namespace Leet.Tools.Setup.Wmi.Iisv2 {
    using System;
    using System.ComponentModel;
    using System.Management;
    using System.Collections;
    using System.Globalization;
    using System.ComponentModel.Design.Serialization;
    using System.Reflection;
    
    
    // Functions ShouldSerialize<PropertyName> are functions used by VS property browser to check if a particular property has to be serialized. These functions are added for all ValueType properties ( properties of type Int32, BOOL etc.. which cannot be set to null). These functions use Is<PropertyName>Null function. These functions are also used in the TypeConverter implementation for the properties to check for NULL value of property so that an empty value can be shown in Property browser in case of Drag and Drop in Visual studio.
    // Functions Is<PropertyName>Null() are used to check if a property is NULL.
    // Functions Reset<PropertyName> are added for Nullable Read/Write properties. These functions are used by VS designer in property browser to set a property to NULL.
    // Every property added to the class for WMI property has attributes set to define its behavior in Visual Studio designer and also to define a TypeConverter to be used.
    // An Early Bound class generated for the WMI class.IIsApplicationPoolSetting
    public class IIsApplicationPoolSetting : System.ComponentModel.Component {
        
        // Private property to hold the WMI namespace in which the class resides.
        private static string CreatedWmiNamespace = "ROOT\\MicrosoftIISv2";
        
        // Private property to hold the name of WMI class which created this class.
        private static string CreatedClassName = "IIsApplicationPoolSetting";
        
        // Private member variable to hold the ManagementScope which is used by the various methods.
        private static System.Management.ManagementScope statMgmtScope = null;
        
        private ManagementSystemProperties PrivateSystemProperties;
        
        // Underlying lateBound WMI object.
        private System.Management.ManagementObject PrivateLateBoundObject;
        
        // Member variable to store the 'automatic commit' behavior for the class.
        private bool AutoCommitProp = true;
        
        // Private variable to hold the embedded property representing the instance.
        private System.Management.ManagementBaseObject embeddedObj;
        
        // The current WMI object used
        private System.Management.ManagementBaseObject curObj;
        
        // Flag to indicate if the instance is an embedded object.
        private bool isEmbedded = false;
        
        // Below are different overloads of constructors to initialize an instance of the class with a WMI object.
        public IIsApplicationPoolSetting() : 
                this(((System.Management.ManagementScope)(null)), ((System.Management.ManagementPath)(null)), ((System.Management.ObjectGetOptions)(null))) {
        }
        
        public IIsApplicationPoolSetting(string keyName) : 
                this(((System.Management.ManagementScope)(null)), ((System.Management.ManagementPath)(new System.Management.ManagementPath(IIsApplicationPoolSetting.ConstructPath(keyName)))), ((System.Management.ObjectGetOptions)(null))) {
        }
        
        public IIsApplicationPoolSetting(System.Management.ManagementScope mgmtScope, string keyName) : 
                this(((System.Management.ManagementScope)(mgmtScope)), ((System.Management.ManagementPath)(new System.Management.ManagementPath(IIsApplicationPoolSetting.ConstructPath(keyName)))), ((System.Management.ObjectGetOptions)(null))) {
        }
        
        public IIsApplicationPoolSetting(System.Management.ManagementPath path, System.Management.ObjectGetOptions getOptions) : 
                this(((System.Management.ManagementScope)(null)), ((System.Management.ManagementPath)(path)), ((System.Management.ObjectGetOptions)(getOptions))) {
        }
        
        public IIsApplicationPoolSetting(System.Management.ManagementScope mgmtScope, System.Management.ManagementPath path) : 
                this(((System.Management.ManagementScope)(mgmtScope)), ((System.Management.ManagementPath)(path)), ((System.Management.ObjectGetOptions)(null))) {
        }
        
        public IIsApplicationPoolSetting(System.Management.ManagementPath path) : 
                this(((System.Management.ManagementScope)(null)), ((System.Management.ManagementPath)(path)), ((System.Management.ObjectGetOptions)(null))) {
        }
        
        public IIsApplicationPoolSetting(System.Management.ManagementScope mgmtScope, System.Management.ManagementPath path, System.Management.ObjectGetOptions getOptions) {
            if ((path != null)) {
                if ((CheckIfProperClass(mgmtScope, path, getOptions) != true)) {
                    throw new System.ArgumentException("Class name does not match.");
                }
            }
            PrivateLateBoundObject = new System.Management.ManagementObject(mgmtScope, path, getOptions);
            PrivateSystemProperties = new ManagementSystemProperties(PrivateLateBoundObject);
            curObj = PrivateLateBoundObject;
        }
        
        public IIsApplicationPoolSetting(System.Management.ManagementObject theObject) {
            if ((CheckIfProperClass(theObject) == true)) {
                PrivateLateBoundObject = theObject;
                PrivateSystemProperties = new ManagementSystemProperties(PrivateLateBoundObject);
                curObj = PrivateLateBoundObject;
            }
            else {
                throw new System.ArgumentException("Class name does not match.");
            }
        }
        
        public IIsApplicationPoolSetting(System.Management.ManagementBaseObject theObject) {
            if ((CheckIfProperClass(theObject) == true)) {
                embeddedObj = theObject;
                PrivateSystemProperties = new ManagementSystemProperties(theObject);
                curObj = embeddedObj;
                isEmbedded = true;
            }
            else {
                throw new System.ArgumentException("Class name does not match.");
            }
        }
        
        // Property returns the namespace of the WMI class.
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string OriginatingNamespace {
            get {
                return "ROOT\\MicrosoftIISv2";
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string ManagementClassName {
            get {
                string strRet = CreatedClassName;
                if ((curObj != null)) {
                    if ((curObj.ClassPath != null)) {
                        strRet = ((string)(curObj["__CLASS"]));
                        if (((strRet == null) 
                                    || (strRet == System.String.Empty))) {
                            strRet = CreatedClassName;
                        }
                    }
                }
                return strRet;
            }
        }
        
        // Property pointing to an embedded object to get System properties of the WMI object.
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public ManagementSystemProperties SystemProperties {
            get {
                return PrivateSystemProperties;
            }
        }
        
        // Property returning the underlying lateBound object.
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Management.ManagementBaseObject LateBoundObject {
            get {
                return curObj;
            }
        }
        
        // ManagementScope of the object.
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Management.ManagementScope Scope {
            get {
                if ((isEmbedded == false)) {
                    return PrivateLateBoundObject.Scope;
                }
                else {
                    return null;
                }
            }
            set {
                if ((isEmbedded == false)) {
                    PrivateLateBoundObject.Scope = value;
                }
            }
        }
        
        // Property to show the commit behavior for the WMI object. If true, WMI object will be automatically saved after each property modification.(ie. Put() is called after modification of a property).
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool AutoCommit {
            get {
                return AutoCommitProp;
            }
            set {
                AutoCommitProp = value;
            }
        }
        
        // The ManagementPath of the underlying WMI object.
        [Browsable(true)]
        public System.Management.ManagementPath Path {
            get {
                if ((isEmbedded == false)) {
                    return PrivateLateBoundObject.Path;
                }
                else {
                    return null;
                }
            }
            set {
                if ((isEmbedded == false)) {
                    if ((CheckIfProperClass(null, value, null) != true)) {
                        throw new System.ArgumentException("Class name does not match.");
                    }
                    PrivateLateBoundObject.Path = value;
                }
            }
        }
        
        // Public static scope property which is used by the various methods.
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public static System.Management.ManagementScope StaticScope {
            get {
                return statMgmtScope;
            }
            set {
                statMgmtScope = value;
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Byte[] AdminACLBin {
            get {
                return ((System.Byte[])(curObj["AdminACLBin"]));
            }
            set {
                curObj["AdminACLBin"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAppPoolAutoStartNull {
            get {
                if ((curObj["AppPoolAutoStart"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AppPoolAutoStart {
            get {
                if ((curObj["AppPoolAutoStart"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AppPoolAutoStart"]));
            }
            set {
                curObj["AppPoolAutoStart"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAppPoolCommandNull {
            get {
                if ((curObj["AppPoolCommand"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AppPoolCommand {
            get {
                if ((curObj["AppPoolCommand"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AppPoolCommand"]));
            }
            set {
                curObj["AppPoolCommand"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAppPoolIdentityTypeNull {
            get {
                if ((curObj["AppPoolIdentityType"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AppPoolIdentityType {
            get {
                if ((curObj["AppPoolIdentityType"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AppPoolIdentityType"]));
            }
            set {
                curObj["AppPoolIdentityType"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAppPoolQueueLengthNull {
            get {
                if ((curObj["AppPoolQueueLength"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AppPoolQueueLength {
            get {
                if ((curObj["AppPoolQueueLength"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AppPoolQueueLength"]));
            }
            set {
                curObj["AppPoolQueueLength"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAppPoolRecycleConfigChangeNull {
            get {
                if ((curObj["AppPoolRecycleConfigChange"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AppPoolRecycleConfigChange {
            get {
                if ((curObj["AppPoolRecycleConfigChange"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AppPoolRecycleConfigChange"]));
            }
            set {
                curObj["AppPoolRecycleConfigChange"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAppPoolRecycleIsapiUnhealthyNull {
            get {
                if ((curObj["AppPoolRecycleIsapiUnhealthy"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AppPoolRecycleIsapiUnhealthy {
            get {
                if ((curObj["AppPoolRecycleIsapiUnhealthy"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AppPoolRecycleIsapiUnhealthy"]));
            }
            set {
                curObj["AppPoolRecycleIsapiUnhealthy"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAppPoolRecycleMemoryNull {
            get {
                if ((curObj["AppPoolRecycleMemory"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AppPoolRecycleMemory {
            get {
                if ((curObj["AppPoolRecycleMemory"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AppPoolRecycleMemory"]));
            }
            set {
                curObj["AppPoolRecycleMemory"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAppPoolRecycleOnDemandNull {
            get {
                if ((curObj["AppPoolRecycleOnDemand"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AppPoolRecycleOnDemand {
            get {
                if ((curObj["AppPoolRecycleOnDemand"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AppPoolRecycleOnDemand"]));
            }
            set {
                curObj["AppPoolRecycleOnDemand"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAppPoolRecyclePrivateMemoryNull {
            get {
                if ((curObj["AppPoolRecyclePrivateMemory"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AppPoolRecyclePrivateMemory {
            get {
                if ((curObj["AppPoolRecyclePrivateMemory"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AppPoolRecyclePrivateMemory"]));
            }
            set {
                curObj["AppPoolRecyclePrivateMemory"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAppPoolRecycleRequestsNull {
            get {
                if ((curObj["AppPoolRecycleRequests"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AppPoolRecycleRequests {
            get {
                if ((curObj["AppPoolRecycleRequests"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AppPoolRecycleRequests"]));
            }
            set {
                curObj["AppPoolRecycleRequests"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAppPoolRecycleScheduleNull {
            get {
                if ((curObj["AppPoolRecycleSchedule"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AppPoolRecycleSchedule {
            get {
                if ((curObj["AppPoolRecycleSchedule"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AppPoolRecycleSchedule"]));
            }
            set {
                curObj["AppPoolRecycleSchedule"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAppPoolRecycleTimeNull {
            get {
                if ((curObj["AppPoolRecycleTime"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AppPoolRecycleTime {
            get {
                if ((curObj["AppPoolRecycleTime"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AppPoolRecycleTime"]));
            }
            set {
                curObj["AppPoolRecycleTime"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAppPoolStateNull {
            get {
                if ((curObj["AppPoolState"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AppPoolState {
            get {
                if ((curObj["AppPoolState"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AppPoolState"]));
            }
            set {
                curObj["AppPoolState"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string AutoShutdownAppPoolExe {
            get {
                return ((string)(curObj["AutoShutdownAppPoolExe"]));
            }
            set {
                curObj["AutoShutdownAppPoolExe"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string AutoShutdownAppPoolParams {
            get {
                return ((string)(curObj["AutoShutdownAppPoolParams"]));
            }
            set {
                curObj["AutoShutdownAppPoolParams"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string Caption {
            get {
                return ((string)(curObj["Caption"]));
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsCPUActionNull {
            get {
                if ((curObj["CPUAction"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int CPUAction {
            get {
                if ((curObj["CPUAction"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["CPUAction"]));
            }
            set {
                curObj["CPUAction"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsCPULimitNull {
            get {
                if ((curObj["CPULimit"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int CPULimit {
            get {
                if ((curObj["CPULimit"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["CPULimit"]));
            }
            set {
                curObj["CPULimit"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsCPUResetIntervalNull {
            get {
                if ((curObj["CPUResetInterval"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int CPUResetInterval {
            get {
                if ((curObj["CPUResetInterval"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["CPUResetInterval"]));
            }
            set {
                curObj["CPUResetInterval"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string Description {
            get {
                return ((string)(curObj["Description"]));
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDisallowOverlappingRotationNull {
            get {
                if ((curObj["DisallowOverlappingRotation"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool DisallowOverlappingRotation {
            get {
                if ((curObj["DisallowOverlappingRotation"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["DisallowOverlappingRotation"]));
            }
            set {
                curObj["DisallowOverlappingRotation"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDisallowRotationOnConfigChangeNull {
            get {
                if ((curObj["DisallowRotationOnConfigChange"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool DisallowRotationOnConfigChange {
            get {
                if ((curObj["DisallowRotationOnConfigChange"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["DisallowRotationOnConfigChange"]));
            }
            set {
                curObj["DisallowRotationOnConfigChange"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsIdleTimeoutNull {
            get {
                if ((curObj["IdleTimeout"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int IdleTimeout {
            get {
                if ((curObj["IdleTimeout"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["IdleTimeout"]));
            }
            set {
                curObj["IdleTimeout"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLoadBalancerCapabilitiesNull {
            get {
                if ((curObj["LoadBalancerCapabilities"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int LoadBalancerCapabilities {
            get {
                if ((curObj["LoadBalancerCapabilities"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["LoadBalancerCapabilities"]));
            }
            set {
                curObj["LoadBalancerCapabilities"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogEventOnRecycleNull {
            get {
                if ((curObj["LogEventOnRecycle"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int LogEventOnRecycle {
            get {
                if ((curObj["LogEventOnRecycle"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["LogEventOnRecycle"]));
            }
            set {
                curObj["LogEventOnRecycle"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogonMethodNull {
            get {
                if ((curObj["LogonMethod"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int LogonMethod {
            get {
                if ((curObj["LogonMethod"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["LogonMethod"]));
            }
            set {
                curObj["LogonMethod"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsMaxProcessesNull {
            get {
                if ((curObj["MaxProcesses"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int MaxProcesses {
            get {
                if ((curObj["MaxProcesses"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["MaxProcesses"]));
            }
            set {
                curObj["MaxProcesses"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string Name {
            get {
                return ((string)(curObj["Name"]));
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string OrphanActionExe {
            get {
                return ((string)(curObj["OrphanActionExe"]));
            }
            set {
                curObj["OrphanActionExe"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string OrphanActionParams {
            get {
                return ((string)(curObj["OrphanActionParams"]));
            }
            set {
                curObj["OrphanActionParams"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsOrphanWorkerProcessNull {
            get {
                if ((curObj["OrphanWorkerProcess"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool OrphanWorkerProcess {
            get {
                if ((curObj["OrphanWorkerProcess"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["OrphanWorkerProcess"]));
            }
            set {
                curObj["OrphanWorkerProcess"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsPeriodicRestartMemoryNull {
            get {
                if ((curObj["PeriodicRestartMemory"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int PeriodicRestartMemory {
            get {
                if ((curObj["PeriodicRestartMemory"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["PeriodicRestartMemory"]));
            }
            set {
                curObj["PeriodicRestartMemory"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsPeriodicRestartPrivateMemoryNull {
            get {
                if ((curObj["PeriodicRestartPrivateMemory"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int PeriodicRestartPrivateMemory {
            get {
                if ((curObj["PeriodicRestartPrivateMemory"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["PeriodicRestartPrivateMemory"]));
            }
            set {
                curObj["PeriodicRestartPrivateMemory"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsPeriodicRestartRequestsNull {
            get {
                if ((curObj["PeriodicRestartRequests"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int PeriodicRestartRequests {
            get {
                if ((curObj["PeriodicRestartRequests"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["PeriodicRestartRequests"]));
            }
            set {
                curObj["PeriodicRestartRequests"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string[] PeriodicRestartSchedule {
            get {
                return ((string[])(curObj["PeriodicRestartSchedule"]));
            }
            set {
                curObj["PeriodicRestartSchedule"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsPeriodicRestartTimeNull {
            get {
                if ((curObj["PeriodicRestartTime"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int PeriodicRestartTime {
            get {
                if ((curObj["PeriodicRestartTime"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["PeriodicRestartTime"]));
            }
            set {
                curObj["PeriodicRestartTime"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsPingingEnabledNull {
            get {
                if ((curObj["PingingEnabled"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool PingingEnabled {
            get {
                if ((curObj["PingingEnabled"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["PingingEnabled"]));
            }
            set {
                curObj["PingingEnabled"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsPingIntervalNull {
            get {
                if ((curObj["PingInterval"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int PingInterval {
            get {
                if ((curObj["PingInterval"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["PingInterval"]));
            }
            set {
                curObj["PingInterval"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsPingResponseTimeNull {
            get {
                if ((curObj["PingResponseTime"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int PingResponseTime {
            get {
                if ((curObj["PingResponseTime"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["PingResponseTime"]));
            }
            set {
                curObj["PingResponseTime"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsRapidFailProtectionNull {
            get {
                if ((curObj["RapidFailProtection"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool RapidFailProtection {
            get {
                if ((curObj["RapidFailProtection"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["RapidFailProtection"]));
            }
            set {
                curObj["RapidFailProtection"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsRapidFailProtectionIntervalNull {
            get {
                if ((curObj["RapidFailProtectionInterval"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int RapidFailProtectionInterval {
            get {
                if ((curObj["RapidFailProtectionInterval"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["RapidFailProtectionInterval"]));
            }
            set {
                curObj["RapidFailProtectionInterval"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsRapidFailProtectionMaxCrashesNull {
            get {
                if ((curObj["RapidFailProtectionMaxCrashes"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int RapidFailProtectionMaxCrashes {
            get {
                if ((curObj["RapidFailProtectionMaxCrashes"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["RapidFailProtectionMaxCrashes"]));
            }
            set {
                curObj["RapidFailProtectionMaxCrashes"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string SettingID {
            get {
                return ((string)(curObj["SettingID"]));
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsShutdownTimeLimitNull {
            get {
                if ((curObj["ShutdownTimeLimit"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int ShutdownTimeLimit {
            get {
                if ((curObj["ShutdownTimeLimit"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["ShutdownTimeLimit"]));
            }
            set {
                curObj["ShutdownTimeLimit"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsSMPAffinitizedNull {
            get {
                if ((curObj["SMPAffinitized"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool SMPAffinitized {
            get {
                if ((curObj["SMPAffinitized"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["SMPAffinitized"]));
            }
            set {
                curObj["SMPAffinitized"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsSMPProcessorAffinityMaskNull {
            get {
                if ((curObj["SMPProcessorAffinityMask"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int SMPProcessorAffinityMask {
            get {
                if ((curObj["SMPProcessorAffinityMask"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["SMPProcessorAffinityMask"]));
            }
            set {
                curObj["SMPProcessorAffinityMask"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsStartupTimeLimitNull {
            get {
                if ((curObj["StartupTimeLimit"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int StartupTimeLimit {
            get {
                if ((curObj["StartupTimeLimit"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["StartupTimeLimit"]));
            }
            set {
                curObj["StartupTimeLimit"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string WAMUserName {
            get {
                return ((string)(curObj["WAMUserName"]));
            }
            set {
                curObj["WAMUserName"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string WAMUserPass {
            get {
                return ((string)(curObj["WAMUserPass"]));
            }
            set {
                curObj["WAMUserPass"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsWin32ErrorNull {
            get {
                if ((curObj["Win32Error"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int Win32Error {
            get {
                if ((curObj["Win32Error"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["Win32Error"]));
            }
            set {
                curObj["Win32Error"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        private bool CheckIfProperClass(System.Management.ManagementScope mgmtScope, System.Management.ManagementPath path, System.Management.ObjectGetOptions OptionsParam) {
            if (((path != null) 
                        && (System.String.Compare(path.ClassName, ManagementClassName, true, CultureInfo.InvariantCulture) == 0))) {
                return true;
            }
            else {
                return CheckIfProperClass(new System.Management.ManagementObject(mgmtScope, path, OptionsParam));
            }
        }
        
        private bool CheckIfProperClass(System.Management.ManagementBaseObject theObj) {
            if (((theObj != null) 
                        && (System.String.Compare(((string)(theObj["__CLASS"])), ManagementClassName, true, CultureInfo.InvariantCulture) == 0))) {
                return true;
            }
            else {
                System.Array parentClasses = ((System.Array)(theObj["__DERIVATION"]));
                if ((parentClasses != null)) {
                    Int32 count = 0;
                    for (count = 0; (count < parentClasses.Length); count = (count + 1)) {
                        if ((System.String.Compare(((string)(parentClasses.GetValue(count))), ManagementClassName, true, CultureInfo.InvariantCulture) == 0)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        
        private void ResetAdminACLBin() {
            curObj["AdminACLBin"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAppPoolAutoStart() {
            if ((IsAppPoolAutoStartNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAppPoolAutoStart() {
            curObj["AppPoolAutoStart"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAppPoolCommand() {
            if ((IsAppPoolCommandNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAppPoolCommand() {
            curObj["AppPoolCommand"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAppPoolIdentityType() {
            if ((IsAppPoolIdentityTypeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAppPoolIdentityType() {
            curObj["AppPoolIdentityType"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAppPoolQueueLength() {
            if ((IsAppPoolQueueLengthNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAppPoolQueueLength() {
            curObj["AppPoolQueueLength"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAppPoolRecycleConfigChange() {
            if ((IsAppPoolRecycleConfigChangeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAppPoolRecycleConfigChange() {
            curObj["AppPoolRecycleConfigChange"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAppPoolRecycleIsapiUnhealthy() {
            if ((IsAppPoolRecycleIsapiUnhealthyNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAppPoolRecycleIsapiUnhealthy() {
            curObj["AppPoolRecycleIsapiUnhealthy"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAppPoolRecycleMemory() {
            if ((IsAppPoolRecycleMemoryNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAppPoolRecycleMemory() {
            curObj["AppPoolRecycleMemory"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAppPoolRecycleOnDemand() {
            if ((IsAppPoolRecycleOnDemandNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAppPoolRecycleOnDemand() {
            curObj["AppPoolRecycleOnDemand"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAppPoolRecyclePrivateMemory() {
            if ((IsAppPoolRecyclePrivateMemoryNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAppPoolRecyclePrivateMemory() {
            curObj["AppPoolRecyclePrivateMemory"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAppPoolRecycleRequests() {
            if ((IsAppPoolRecycleRequestsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAppPoolRecycleRequests() {
            curObj["AppPoolRecycleRequests"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAppPoolRecycleSchedule() {
            if ((IsAppPoolRecycleScheduleNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAppPoolRecycleSchedule() {
            curObj["AppPoolRecycleSchedule"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAppPoolRecycleTime() {
            if ((IsAppPoolRecycleTimeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAppPoolRecycleTime() {
            curObj["AppPoolRecycleTime"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAppPoolState() {
            if ((IsAppPoolStateNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAppPoolState() {
            curObj["AppPoolState"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAutoShutdownAppPoolExe() {
            curObj["AutoShutdownAppPoolExe"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAutoShutdownAppPoolParams() {
            curObj["AutoShutdownAppPoolParams"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeCPUAction() {
            if ((IsCPUActionNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetCPUAction() {
            curObj["CPUAction"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeCPULimit() {
            if ((IsCPULimitNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetCPULimit() {
            curObj["CPULimit"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeCPUResetInterval() {
            if ((IsCPUResetIntervalNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetCPUResetInterval() {
            curObj["CPUResetInterval"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDisallowOverlappingRotation() {
            if ((IsDisallowOverlappingRotationNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDisallowOverlappingRotation() {
            curObj["DisallowOverlappingRotation"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDisallowRotationOnConfigChange() {
            if ((IsDisallowRotationOnConfigChangeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDisallowRotationOnConfigChange() {
            curObj["DisallowRotationOnConfigChange"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeIdleTimeout() {
            if ((IsIdleTimeoutNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetIdleTimeout() {
            curObj["IdleTimeout"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLoadBalancerCapabilities() {
            if ((IsLoadBalancerCapabilitiesNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLoadBalancerCapabilities() {
            curObj["LoadBalancerCapabilities"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogEventOnRecycle() {
            if ((IsLogEventOnRecycleNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogEventOnRecycle() {
            curObj["LogEventOnRecycle"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogonMethod() {
            if ((IsLogonMethodNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogonMethod() {
            curObj["LogonMethod"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeMaxProcesses() {
            if ((IsMaxProcessesNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetMaxProcesses() {
            curObj["MaxProcesses"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetOrphanActionExe() {
            curObj["OrphanActionExe"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetOrphanActionParams() {
            curObj["OrphanActionParams"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeOrphanWorkerProcess() {
            if ((IsOrphanWorkerProcessNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetOrphanWorkerProcess() {
            curObj["OrphanWorkerProcess"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializePeriodicRestartMemory() {
            if ((IsPeriodicRestartMemoryNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetPeriodicRestartMemory() {
            curObj["PeriodicRestartMemory"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializePeriodicRestartPrivateMemory() {
            if ((IsPeriodicRestartPrivateMemoryNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetPeriodicRestartPrivateMemory() {
            curObj["PeriodicRestartPrivateMemory"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializePeriodicRestartRequests() {
            if ((IsPeriodicRestartRequestsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetPeriodicRestartRequests() {
            curObj["PeriodicRestartRequests"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetPeriodicRestartSchedule() {
            curObj["PeriodicRestartSchedule"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializePeriodicRestartTime() {
            if ((IsPeriodicRestartTimeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetPeriodicRestartTime() {
            curObj["PeriodicRestartTime"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializePingingEnabled() {
            if ((IsPingingEnabledNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetPingingEnabled() {
            curObj["PingingEnabled"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializePingInterval() {
            if ((IsPingIntervalNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetPingInterval() {
            curObj["PingInterval"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializePingResponseTime() {
            if ((IsPingResponseTimeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetPingResponseTime() {
            curObj["PingResponseTime"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeRapidFailProtection() {
            if ((IsRapidFailProtectionNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetRapidFailProtection() {
            curObj["RapidFailProtection"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeRapidFailProtectionInterval() {
            if ((IsRapidFailProtectionIntervalNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetRapidFailProtectionInterval() {
            curObj["RapidFailProtectionInterval"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeRapidFailProtectionMaxCrashes() {
            if ((IsRapidFailProtectionMaxCrashesNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetRapidFailProtectionMaxCrashes() {
            curObj["RapidFailProtectionMaxCrashes"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeShutdownTimeLimit() {
            if ((IsShutdownTimeLimitNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetShutdownTimeLimit() {
            curObj["ShutdownTimeLimit"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeSMPAffinitized() {
            if ((IsSMPAffinitizedNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetSMPAffinitized() {
            curObj["SMPAffinitized"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeSMPProcessorAffinityMask() {
            if ((IsSMPProcessorAffinityMaskNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetSMPProcessorAffinityMask() {
            curObj["SMPProcessorAffinityMask"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeStartupTimeLimit() {
            if ((IsStartupTimeLimitNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetStartupTimeLimit() {
            curObj["StartupTimeLimit"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetWAMUserName() {
            curObj["WAMUserName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetWAMUserPass() {
            curObj["WAMUserPass"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeWin32Error() {
            if ((IsWin32ErrorNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetWin32Error() {
            curObj["Win32Error"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        [Browsable(true)]
        public void CommitObject() {
            if ((isEmbedded == false)) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private static string ConstructPath(string keyName) {
            string strPath = "ROOT\\MicrosoftIISv2:IIsApplicationPoolSetting";
            strPath = (strPath 
                        + (".Name=" 
                        + ("\"" 
                        + (keyName + "\""))));
            return strPath;
        }
        
        // Different overloads of GetInstances() help in enumerating instances of the WMI class.
        public static IIsApplicationPoolSettingCollection GetInstances() {
            return GetInstances(((System.Management.ManagementScope)(null)), ((System.Management.EnumerationOptions)(null)));
        }
        
        public static IIsApplicationPoolSettingCollection GetInstances(string condition) {
            return GetInstances(null, condition, null);
        }
        
        public static IIsApplicationPoolSettingCollection GetInstances(System.String [] selectedProperties) {
            return GetInstances(null, null, selectedProperties);
        }
        
        public static IIsApplicationPoolSettingCollection GetInstances(string condition, System.String [] selectedProperties) {
            return GetInstances(null, condition, selectedProperties);
        }
        
        public static IIsApplicationPoolSettingCollection GetInstances(System.Management.ManagementScope mgmtScope, System.Management.EnumerationOptions enumOptions) {
            if ((mgmtScope == null)) {
                if ((statMgmtScope == null)) {
                    mgmtScope = new System.Management.ManagementScope();
                    mgmtScope.Path.NamespacePath = "root\\MicrosoftIISv2";
                }
                else {
                    mgmtScope = statMgmtScope;
                }
            }
            System.Management.ManagementPath pathObj = new System.Management.ManagementPath();
            pathObj.ClassName = "IIsApplicationPoolSetting";
            pathObj.NamespacePath = "root\\MicrosoftIISv2";
            System.Management.ManagementClass clsObject = new System.Management.ManagementClass(mgmtScope, pathObj, null);
            if ((enumOptions == null)) {
                enumOptions = new System.Management.EnumerationOptions();
                enumOptions.EnsureLocatable = true;
            }
            return new IIsApplicationPoolSettingCollection(clsObject.GetInstances(enumOptions));
        }
        
        public static IIsApplicationPoolSettingCollection GetInstances(System.Management.ManagementScope mgmtScope, string condition) {
            return GetInstances(mgmtScope, condition, null);
        }
        
        public static IIsApplicationPoolSettingCollection GetInstances(System.Management.ManagementScope mgmtScope, System.String [] selectedProperties) {
            return GetInstances(mgmtScope, null, selectedProperties);
        }
        
        public static IIsApplicationPoolSettingCollection GetInstances(System.Management.ManagementScope mgmtScope, string condition, System.String [] selectedProperties) {
            if ((mgmtScope == null)) {
                if ((statMgmtScope == null)) {
                    mgmtScope = new System.Management.ManagementScope();
                    mgmtScope.Path.NamespacePath = "root\\MicrosoftIISv2";
                }
                else {
                    mgmtScope = statMgmtScope;
                }
            }
            System.Management.ManagementObjectSearcher ObjectSearcher = new System.Management.ManagementObjectSearcher(mgmtScope, new SelectQuery("IIsApplicationPoolSetting", condition, selectedProperties));
            System.Management.EnumerationOptions enumOptions = new System.Management.EnumerationOptions();
            enumOptions.EnsureLocatable = true;
            ObjectSearcher.Options = enumOptions;
            return new IIsApplicationPoolSettingCollection(ObjectSearcher.Get());
        }
        
        [Browsable(true)]
        public static IIsApplicationPoolSetting CreateInstance() {
            System.Management.ManagementScope mgmtScope = null;
            if ((statMgmtScope == null)) {
                mgmtScope = new System.Management.ManagementScope();
                mgmtScope.Path.NamespacePath = CreatedWmiNamespace;
            }
            else {
                mgmtScope = statMgmtScope;
            }
            System.Management.ManagementPath mgmtPath = new System.Management.ManagementPath(CreatedClassName);
            return new IIsApplicationPoolSetting(new System.Management.ManagementClass(mgmtScope, mgmtPath, null).CreateInstance());
        }
        
        [Browsable(true)]
        public void Delete() {
            PrivateLateBoundObject.Delete();
        }
        
        // Enumerator implementation for enumerating instances of the class.
        public class IIsApplicationPoolSettingCollection : object, ICollection {
            
            private ManagementObjectCollection ObjectCollection;
            
            public IIsApplicationPoolSettingCollection(ManagementObjectCollection objCollection) {
                ObjectCollection = objCollection;
            }
            
            public int Count {
                get {
                    return ObjectCollection.Count;
                }
            }
            
            public bool IsSynchronized {
                get {
                    return ObjectCollection.IsSynchronized;
                }
            }
            
            public object SyncRoot {
                get {
                    return this;
                }
            }
            
            public void CopyTo(System.Array array, int index) {
                ObjectCollection.CopyTo(array, index);
                int nCtr;
                for (nCtr = 0; (nCtr < array.Length); nCtr = (nCtr + 1)) {
                    array.SetValue(new IIsApplicationPoolSetting(((System.Management.ManagementObject)(array.GetValue(nCtr)))), nCtr);
                }
            }
            
            public System.Collections.IEnumerator GetEnumerator() {
                return new IIsApplicationPoolSettingEnumerator(ObjectCollection.GetEnumerator());
            }
            
            public class IIsApplicationPoolSettingEnumerator : object, System.Collections.IEnumerator {
                
                private ManagementObjectCollection.ManagementObjectEnumerator ObjectEnumerator;
                
                public IIsApplicationPoolSettingEnumerator(ManagementObjectCollection.ManagementObjectEnumerator objEnum) {
                    ObjectEnumerator = objEnum;
                }
                
                public object Current {
                    get {
                        return new IIsApplicationPoolSetting(((System.Management.ManagementObject)(ObjectEnumerator.Current)));
                    }
                }
                
                public bool MoveNext() {
                    return ObjectEnumerator.MoveNext();
                }
                
                public void Reset() {
                    ObjectEnumerator.Reset();
                }
            }
        }
        
        // TypeConverter to handle null values for ValueType properties
        public class WMIValueTypeConverter : TypeConverter {
            
            private TypeConverter baseConverter;
            
            public WMIValueTypeConverter(System.Type baseType) {
                baseConverter = TypeDescriptor.GetConverter(baseType);
            }
            
            public override bool CanConvertFrom(System.ComponentModel.ITypeDescriptorContext context, System.Type srcType) {
                return baseConverter.CanConvertFrom(context, srcType);
            }
            
            public override bool CanConvertTo(System.ComponentModel.ITypeDescriptorContext context, System.Type destinationType) {
                return baseConverter.CanConvertTo(context, destinationType);
            }
            
            public override object ConvertFrom(System.ComponentModel.ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value) {
                return baseConverter.ConvertFrom(context, culture, value);
            }
            
            public override object CreateInstance(System.ComponentModel.ITypeDescriptorContext context, System.Collections.IDictionary dictionary) {
                return baseConverter.CreateInstance(context, dictionary);
            }
            
            public override bool GetCreateInstanceSupported(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetCreateInstanceSupported(context);
            }
            
            public override PropertyDescriptorCollection GetProperties(System.ComponentModel.ITypeDescriptorContext context, object value, System.Attribute[] attributeVar) {
                return baseConverter.GetProperties(context, value, attributeVar);
            }
            
            public override bool GetPropertiesSupported(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetPropertiesSupported(context);
            }
            
            public override System.ComponentModel.TypeConverter.StandardValuesCollection GetStandardValues(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetStandardValues(context);
            }
            
            public override bool GetStandardValuesExclusive(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetStandardValuesExclusive(context);
            }
            
            public override bool GetStandardValuesSupported(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetStandardValuesSupported(context);
            }
            
            public override object ConvertTo(System.ComponentModel.ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value, System.Type destinationType) {
                if ((context != null)) {
                    if ((context.PropertyDescriptor.ShouldSerializeValue(context.Instance) == false)) {
                        return "";
                    }
                }
                return baseConverter.ConvertTo(context, culture, value, destinationType);
            }
        }
        
        // Embedded class to represent WMI system Properties.
        [TypeConverter(typeof(System.ComponentModel.ExpandableObjectConverter))]
        public class ManagementSystemProperties {
            
            private System.Management.ManagementBaseObject PrivateLateBoundObject;
            
            public ManagementSystemProperties(System.Management.ManagementBaseObject ManagedObject) {
                PrivateLateBoundObject = ManagedObject;
            }
            
            [Browsable(true)]
            public int GENUS {
                get {
                    return ((int)(PrivateLateBoundObject["__GENUS"]));
                }
            }
            
            [Browsable(true)]
            public string CLASS {
                get {
                    return ((string)(PrivateLateBoundObject["__CLASS"]));
                }
            }
            
            [Browsable(true)]
            public string SUPERCLASS {
                get {
                    return ((string)(PrivateLateBoundObject["__SUPERCLASS"]));
                }
            }
            
            [Browsable(true)]
            public string DYNASTY {
                get {
                    return ((string)(PrivateLateBoundObject["__DYNASTY"]));
                }
            }
            
            [Browsable(true)]
            public string RELPATH {
                get {
                    return ((string)(PrivateLateBoundObject["__RELPATH"]));
                }
            }
            
            [Browsable(true)]
            public int PROPERTY_COUNT {
                get {
                    return ((int)(PrivateLateBoundObject["__PROPERTY_COUNT"]));
                }
            }
            
            [Browsable(true)]
            public string[] DERIVATION {
                get {
                    return ((string[])(PrivateLateBoundObject["__DERIVATION"]));
                }
            }
            
            [Browsable(true)]
            public string SERVER {
                get {
                    return ((string)(PrivateLateBoundObject["__SERVER"]));
                }
            }
            
            [Browsable(true)]
            public string NAMESPACE {
                get {
                    return ((string)(PrivateLateBoundObject["__NAMESPACE"]));
                }
            }
            
            [Browsable(true)]
            public string PATH {
                get {
                    return ((string)(PrivateLateBoundObject["__PATH"]));
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\Wmi\iisv2\IIsFilter.cs ===
﻿namespace Leet.Tools.Setup.Wmi.Iisv2 {
    using System;
    using System.ComponentModel;
    using System.Management;
    using System.Collections;
    using System.Globalization;
    using System.ComponentModel.Design.Serialization;
    using System.Reflection;
    
    
    // Functions ShouldSerialize<PropertyName> are functions used by VS property browser to check if a particular property has to be serialized. These functions are added for all ValueType properties ( properties of type Int32, BOOL etc.. which cannot be set to null). These functions use Is<PropertyName>Null function. These functions are also used in the TypeConverter implementation for the properties to check for NULL value of property so that an empty value can be shown in Property browser in case of Drag and Drop in Visual studio.
    // Functions Is<PropertyName>Null() are used to check if a property is NULL.
    // Functions Reset<PropertyName> are added for Nullable Read/Write properties. These functions are used by VS designer in property browser to set a property to NULL.
    // Every property added to the class for WMI property has attributes set to define its behavior in Visual Studio designer and also to define a TypeConverter to be used.
    // Datetime conversion functions ToDateTime and ToDmtfDateTime are added to the class to convert DMTF datetime to System.DateTime and vice-versa.
    // An Early Bound class generated for the WMI class.IIsFilter
    public class IIsFilter : System.ComponentModel.Component {
        
        // Private property to hold the WMI namespace in which the class resides.
        private static string CreatedWmiNamespace = "ROOT\\MicrosoftIISv2";
        
        // Private property to hold the name of WMI class which created this class.
        private static string CreatedClassName = "IIsFilter";
        
        // Private member variable to hold the ManagementScope which is used by the various methods.
        private static System.Management.ManagementScope statMgmtScope = null;
        
        private ManagementSystemProperties PrivateSystemProperties;
        
        // Underlying lateBound WMI object.
        private System.Management.ManagementObject PrivateLateBoundObject;
        
        // Member variable to store the 'automatic commit' behavior for the class.
        private bool AutoCommitProp;
        
        // Private variable to hold the embedded property representing the instance.
        private System.Management.ManagementBaseObject embeddedObj;
        
        // The current WMI object used
        private System.Management.ManagementBaseObject curObj;
        
        // Flag to indicate if the instance is an embedded object.
        private bool isEmbedded;
        
        // Below are different overloads of constructors to initialize an instance of the class with a WMI object.
        public IIsFilter() {
            this.InitializeObject(null, null, null);
        }
        
        public IIsFilter(string keyName) {
            this.InitializeObject(null, new System.Management.ManagementPath(IIsFilter.ConstructPath(keyName)), null);
        }
        
        public IIsFilter(System.Management.ManagementScope mgmtScope, string keyName) {
            this.InitializeObject(((System.Management.ManagementScope)(mgmtScope)), new System.Management.ManagementPath(IIsFilter.ConstructPath(keyName)), null);
        }
        
        public IIsFilter(System.Management.ManagementPath path, System.Management.ObjectGetOptions getOptions) {
            this.InitializeObject(null, path, getOptions);
        }
        
        public IIsFilter(System.Management.ManagementScope mgmtScope, System.Management.ManagementPath path) {
            this.InitializeObject(mgmtScope, path, null);
        }
        
        public IIsFilter(System.Management.ManagementPath path) {
            this.InitializeObject(null, path, null);
        }
        
        public IIsFilter(System.Management.ManagementScope mgmtScope, System.Management.ManagementPath path, System.Management.ObjectGetOptions getOptions) {
            this.InitializeObject(mgmtScope, path, getOptions);
        }
        
        public IIsFilter(System.Management.ManagementObject theObject) {
            Initialize();
            if ((CheckIfProperClass(theObject) == true)) {
                PrivateLateBoundObject = theObject;
                PrivateSystemProperties = new ManagementSystemProperties(PrivateLateBoundObject);
                curObj = PrivateLateBoundObject;
            }
            else {
                throw new System.ArgumentException("Class name does not match.");
            }
        }
        
        public IIsFilter(System.Management.ManagementBaseObject theObject) {
            Initialize();
            if ((CheckIfProperClass(theObject) == true)) {
                embeddedObj = theObject;
                PrivateSystemProperties = new ManagementSystemProperties(theObject);
                curObj = embeddedObj;
                isEmbedded = true;
            }
            else {
                throw new System.ArgumentException("Class name does not match.");
            }
        }
        
        // Property returns the namespace of the WMI class.
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string OriginatingNamespace {
            get {
                return "ROOT\\MicrosoftIISv2";
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string ManagementClassName {
            get {
                string strRet = CreatedClassName;
                if ((curObj != null)) {
                    if ((curObj.ClassPath != null)) {
                        strRet = ((string)(curObj["__CLASS"]));
                        if (((strRet == null) 
                                    || (strRet == string.Empty))) {
                            strRet = CreatedClassName;
                        }
                    }
                }
                return strRet;
            }
        }
        
        // Property pointing to an embedded object to get System properties of the WMI object.
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public ManagementSystemProperties SystemProperties {
            get {
                return PrivateSystemProperties;
            }
        }
        
        // Property returning the underlying lateBound object.
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Management.ManagementBaseObject LateBoundObject {
            get {
                return curObj;
            }
        }
        
        // ManagementScope of the object.
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Management.ManagementScope Scope {
            get {
                if ((isEmbedded == false)) {
                    return PrivateLateBoundObject.Scope;
                }
                else {
                    return null;
                }
            }
            set {
                if ((isEmbedded == false)) {
                    PrivateLateBoundObject.Scope = value;
                }
            }
        }
        
        // Property to show the commit behavior for the WMI object. If true, WMI object will be automatically saved after each property modification.(ie. Put() is called after modification of a property).
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool AutoCommit {
            get {
                return AutoCommitProp;
            }
            set {
                AutoCommitProp = value;
            }
        }
        
        // The ManagementPath of the underlying WMI object.
        [Browsable(true)]
        public System.Management.ManagementPath Path {
            get {
                if ((isEmbedded == false)) {
                    return PrivateLateBoundObject.Path;
                }
                else {
                    return null;
                }
            }
            set {
                if ((isEmbedded == false)) {
                    if ((CheckIfProperClass(null, value, null) != true)) {
                        throw new System.ArgumentException("Class name does not match.");
                    }
                    PrivateLateBoundObject.Path = value;
                }
            }
        }
        
        // Public static scope property which is used by the various methods.
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public static System.Management.ManagementScope StaticScope {
            get {
                return statMgmtScope;
            }
            set {
                statMgmtScope = value;
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string Caption {
            get {
                return ((string)(curObj["Caption"]));
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string Description {
            get {
                return ((string)(curObj["Description"]));
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsInstallDateNull {
            get {
                if ((curObj["InstallDate"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public System.DateTime InstallDate {
            get {
                if ((curObj["InstallDate"] != null)) {
                    return ToDateTime(((string)(curObj["InstallDate"])));
                }
                else {
                    return System.DateTime.MinValue;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string Name {
            get {
                return ((string)(curObj["Name"]));
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string Status {
            get {
                return ((string)(curObj["Status"]));
            }
        }
        
        private bool CheckIfProperClass(System.Management.ManagementScope mgmtScope, System.Management.ManagementPath path, System.Management.ObjectGetOptions OptionsParam) {
            if (((path != null) 
                        && (string.Compare(path.ClassName, this.ManagementClassName, true, System.Globalization.CultureInfo.InvariantCulture) == 0))) {
                return true;
            }
            else {
                return CheckIfProperClass(new System.Management.ManagementObject(mgmtScope, path, OptionsParam));
            }
        }
        
        private bool CheckIfProperClass(System.Management.ManagementBaseObject theObj) {
            if (((theObj != null) 
                        && (string.Compare(((string)(theObj["__CLASS"])), this.ManagementClassName, true, System.Globalization.CultureInfo.InvariantCulture) == 0))) {
                return true;
            }
            else {
                System.Array parentClasses = ((System.Array)(theObj["__DERIVATION"]));
                if ((parentClasses != null)) {
                    int count = 0;
                    for (count = 0; (count < parentClasses.Length); count = (count + 1)) {
                        if ((string.Compare(((string)(parentClasses.GetValue(count))), this.ManagementClassName, true, System.Globalization.CultureInfo.InvariantCulture) == 0)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        
        // Converts a given datetime in DMTF format to System.DateTime object.
        static System.DateTime ToDateTime(string dmtfDate) {
            System.DateTime initializer = System.DateTime.MinValue;
            int year = initializer.Year;
            int month = initializer.Month;
            int day = initializer.Day;
            int hour = initializer.Hour;
            int minute = initializer.Minute;
            int second = initializer.Second;
            long ticks = 0;
            string dmtf = dmtfDate;
            System.DateTime datetime = System.DateTime.MinValue;
            string tempString = string.Empty;
            if ((dmtf == null)) {
                throw new System.ArgumentOutOfRangeException();
            }
            if ((dmtf.Length == 0)) {
                throw new System.ArgumentOutOfRangeException();
            }
            if ((dmtf.Length != 25)) {
                throw new System.ArgumentOutOfRangeException();
            }
            try {
                tempString = dmtf.Substring(0, 4);
                if (("****" != tempString)) {
                    year = int.Parse(tempString);
                }
                tempString = dmtf.Substring(4, 2);
                if (("**" != tempString)) {
                    month = int.Parse(tempString);
                }
                tempString = dmtf.Substring(6, 2);
                if (("**" != tempString)) {
                    day = int.Parse(tempString);
                }
                tempString = dmtf.Substring(8, 2);
                if (("**" != tempString)) {
                    hour = int.Parse(tempString);
                }
                tempString = dmtf.Substring(10, 2);
                if (("**" != tempString)) {
                    minute = int.Parse(tempString);
                }
                tempString = dmtf.Substring(12, 2);
                if (("**" != tempString)) {
                    second = int.Parse(tempString);
                }
                tempString = dmtf.Substring(15, 6);
                if (("******" != tempString)) {
                    ticks = (long.Parse(tempString) * ((long)((System.TimeSpan.TicksPerMillisecond / 1000))));
                }
                if (((((((((year < 0) 
                            || (month < 0)) 
                            || (day < 0)) 
                            || (hour < 0)) 
                            || (minute < 0)) 
                            || (minute < 0)) 
                            || (second < 0)) 
                            || (ticks < 0))) {
                    throw new System.ArgumentOutOfRangeException();
                }
            }
            catch (System.Exception e) {
                throw new System.ArgumentOutOfRangeException(null, e.Message);
            }
            datetime = new System.DateTime(year, month, day, hour, minute, second, 0);
            datetime = datetime.AddTicks(ticks);
            System.TimeSpan tickOffset = System.TimeZone.CurrentTimeZone.GetUtcOffset(datetime);
            int UTCOffset = 0;
            int OffsetToBeAdjusted = 0;
            long OffsetMins = ((long)((tickOffset.Ticks / System.TimeSpan.TicksPerMinute)));
            tempString = dmtf.Substring(22, 3);
            if ((tempString != "******")) {
                tempString = dmtf.Substring(21, 4);
                try {
                    UTCOffset = int.Parse(tempString);
                }
                catch (System.Exception e) {
                    throw new System.ArgumentOutOfRangeException(null, e.Message);
                }
                OffsetToBeAdjusted = ((int)((OffsetMins - UTCOffset)));
                datetime = datetime.AddMinutes(((double)(OffsetToBeAdjusted)));
            }
            return datetime;
        }
        
        // Converts a given System.DateTime object to DMTF datetime format.
        static string ToDmtfDateTime(System.DateTime date) {
            string utcString = string.Empty;
            System.TimeSpan tickOffset = System.TimeZone.CurrentTimeZone.GetUtcOffset(date);
            long OffsetMins = ((long)((tickOffset.Ticks / System.TimeSpan.TicksPerMinute)));
            if ((System.Math.Abs(OffsetMins) > 999)) {
                date = date.ToUniversalTime();
                utcString = "+000";
            }
            else {
                if ((tickOffset.Ticks >= 0)) {
                    utcString = string.Concat("+", ((System.Int64 )((tickOffset.Ticks / System.TimeSpan.TicksPerMinute))).ToString().PadLeft(3, '0'));
                }
                else {
                    string strTemp = ((System.Int64 )(OffsetMins)).ToString();
                    utcString = string.Concat("-", strTemp.Substring(1, (strTemp.Length - 1)).PadLeft(3, '0'));
                }
            }
            string dmtfDateTime = ((System.Int32 )(date.Year)).ToString().PadLeft(4, '0');
            dmtfDateTime = string.Concat(dmtfDateTime, ((System.Int32 )(date.Month)).ToString().PadLeft(2, '0'));
            dmtfDateTime = string.Concat(dmtfDateTime, ((System.Int32 )(date.Day)).ToString().PadLeft(2, '0'));
            dmtfDateTime = string.Concat(dmtfDateTime, ((System.Int32 )(date.Hour)).ToString().PadLeft(2, '0'));
            dmtfDateTime = string.Concat(dmtfDateTime, ((System.Int32 )(date.Minute)).ToString().PadLeft(2, '0'));
            dmtfDateTime = string.Concat(dmtfDateTime, ((System.Int32 )(date.Second)).ToString().PadLeft(2, '0'));
            dmtfDateTime = string.Concat(dmtfDateTime, ".");
            System.DateTime dtTemp = new System.DateTime(date.Year, date.Month, date.Day, date.Hour, date.Minute, date.Second, 0);
            long microsec = ((long)((((date.Ticks - dtTemp.Ticks) 
                        * 1000) 
                        / System.TimeSpan.TicksPerMillisecond)));
            string strMicrosec = ((System.Int64 )(microsec)).ToString();
            if ((strMicrosec.Length > 6)) {
                strMicrosec = strMicrosec.Substring(0, 6);
            }
            dmtfDateTime = string.Concat(dmtfDateTime, strMicrosec.PadLeft(6, '0'));
            dmtfDateTime = string.Concat(dmtfDateTime, utcString);
            return dmtfDateTime;
        }
        
        private bool ShouldSerializeInstallDate() {
            if ((this.IsInstallDateNull == false)) {
                return true;
            }
            return false;
        }
        
        [Browsable(true)]
        public void CommitObject() {
            if ((isEmbedded == false)) {
                PrivateLateBoundObject.Put();
            }
        }
        
        [Browsable(true)]
        public void CommitObject(System.Management.PutOptions putOptions) {
            if ((isEmbedded == false)) {
       